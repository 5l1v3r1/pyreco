__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# python-github2 documentation build configuration file, created by
# sphinx-quickstart on Mon Apr 11 16:16:25 2011.
#
# This file is execfile()d with the current directory set to its containing
# dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import os
import sys

from sphinx.util import inspect

import cloud_sptheme as csp

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('..'))

# -- General configuration ----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ["sphinx.ext.%s" % ext
              for ext in ["autodoc", "todo", "intersphinx", "viewcode",
                         "coverage"]] + \
    ["sphinxcontrib.%s" % ext for ext in ["cheeseshop", ]]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['.templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'github2'
copyright = u'2009-2012, Ask Solem'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
import github2
# The short X.Y version.
version = ".".join(map(str, github2.VERSION[:2]))
# The full version, including alpha/beta/rc tags.
release = github2.__version__

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['.build']

# The reST default role (used for this markup: `text`) to use for all
# documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output --------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'cloud'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
html_theme_options = {
    "externalrefs": True,
}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = [csp.get_theme_dir(), ]

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['.static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'github2doc'


# -- Options for LaTeX output -------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author,
# documentclass [howto/manual]).
latex_documents = [
  ('index', 'github2.tex', u'github2 Documentation',
   u'Ask Solem', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output -------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'github2', u'github2 Documentation',
     [u'Ask Solem'], 1)
]

autoclass_content = "class"
autodoc_default_flags = ['members', ]

intersphinx_mapping = {
    'python': ('http://docs.python.org/', os.getenv('SPHINX_PYTHON_OBJECTS'))
}


# Horrific nastiness to generate correct function signature for decorated
# objects.  Close your eyes... Now!
orig_getargspec = inspect.getargspec


def getargspec(func):
    if hasattr(func, '__orig_func__'):
        return orig_getargspec(func.__orig_func__)
    else:
        return orig_getargspec(func)
inspect.getargspec = getargspec

########NEW FILE########
__FILENAME__ = friend-or-follow
# Copyright (C) 2010-2012 Ask Solem <askh@modwheel.net>
#
# This file is part of python-github2, and is made available under the 3-clause
# BSD license.  See LICENSE for the full details.

import sys
import optparse
from subprocess import Popen, PIPE

from github2.client import Github

ITEM_FMT = "* %s (%s)"
URL_USER_FMT = "http://github.com/%s"

OPTION_LIST = (
    optparse.make_option('-t', '--api-token',
            default=None, action="store", dest="api_token", type="str",
            help="GitHub API token. Default is to find this from git config"),
    optparse.make_option('-u', '--api-user',
            default=None, action="store", dest="api_user", type="str",
            help="GitHub Username. Default is to find this from git config"),
)
BY_LOWER = lambda value: value.lower()


class FriendOrFollow(object):
    # Caching api calls
    _followers = None
    _following = None

    def __init__(self, username=None, api_user=None, api_token=None):
        self.api_user = api_user or self.git_config_get("github.user")
        self.api_token = api_token or self.git_config_get("github.token")
        self.username = username or self.api_user
        print("U:(%s) T:(%s) F:(%s)" % (self.api_user, self.api_token,
            self.username))
        self.client = Github(self.api_user, self.api_token)

    def get_friends(self):
        return sorted((user for user in self.following
                        if user in self.followers), key=BY_LOWER)

    def get_following(self):
        return sorted((user for user in self.following
                        if user not in self.followers), key=BY_LOWER)

    def get_fans(self):
        return sorted((user for user in self.followers
                        if user not in self.following), key=BY_LOWER)

    def users_with_urls(self, users):
        return ((user, URL_USER_FMT % user)
                    for user in users)

    def git_config_get(self, key):
        pipe = Popen(["git", "config", "--get", key], stdout=PIPE)
        return pipe.communicate()[0].strip()

    @property
    def followers(self):
        if self._followers is None:
            self._followers = self.client.users.followers(self.username)
        return self._followers

    @property
    def following(self):
        if self._following is None:
            self._following = self.client.users.following(self.username)
        return self._following


def parse_options(arguments):
    parser = optparse.OptionParser(option_list=OPTION_LIST)
    options, values = parser.parse_args(arguments)
    return options, values


def format_output(*data):
    headify = lambda title: "\n".join([title, "=" * len(title)])
    itemify = lambda item: ITEM_FMT % item

    def format_section(header, items):
        return "\n".join(["\n%s\n" % headify(header)] +
                         [itemify(item) for item in items])

    return "\n".join(format_section(*section)
                            for section in data)


def main():
    options, values = parse_options(sys.argv[1:])
    username = values and values[0] or None
    f = FriendOrFollow(username=username, **vars(options))
    print(format_output(
            ("Friends", f.users_with_urls(f.get_friends())),
            ("Following", f.users_with_urls(f.get_following())),
            ("Fans", f.users_with_urls(f.get_fans()))))

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = manage_collaborators
#!/usr/bin/env python
# encoding: utf-8
"""github_manage_collaborators - add/remove collaborators to all github
projects of an account.

Typically used with company accounts where all coders should have
R/W access to all private repositories of the company account.
"""

# Created by Maximillian Dornseif on 2009-12-31 for HUDORA.
# Copyright (C) 2009-2012 James Rowe <jnrowe@gmail.com>
#                         Maximillian Dornseif <m.dornseif@hudora.de>
#
# This file is part of python-github2, and is made available under the 3-clause
# BSD license.  See LICENSE for the full details.

import logging
import sys

from optparse import OptionParser

import github2.client


#: Running under Python 3
PY3K = sys.version_info[0] == 3 and True or False


def print_(text):
    """Python 2 & 3 compatible print function.

    We support <2.6, so can't use __future__.print_function

    """
    if PY3K:
        print(text)
    else:
        sys.stdout.write(text + '\n')


def parse_commandline():
    """Parse the command line and return parsed options."""

    parser = OptionParser()
    parser.description = __doc__

    parser.set_usage('usage: %prog [options] (list|add|remove) [collaborator].'
                     '\nTry %prog --help for details.')
    parser.add_option('-d', '--debug', action='store_true',
                      help='Enables debugging mode')
    parser.add_option('-c', '--cache', default=None,
                      help='Location for network cache [default: None]')
    parser.add_option('-l', '--login',
                      help='Username to login with')
    parser.add_option('-a', '--account',
                      help='User owning the repositories to be changed ' \
                           '[default: same as --login]')
    parser.add_option('-t', '--apitoken',
                      help='API Token - can be found on the lower right of ' \
                           'https://github.com/account')

    options, args = parser.parse_args()
    if len(args) not in [1, 2]:
        parser.error('wrong number of arguments')
    if (len(args) == 1 and args[0] in ['add', 'remove']):
        parser.error('%r needs a collaborator name as second parameter\n'
                     % args[0])
    elif (len(args) == 1 and args[0] != 'list'):
        parser.error('unknown command %r. Try "list", "add" or "remove"\n'
                     % args[0])
    if (len(args) == 2 and args[0] not in ['add', 'remove']):
        parser.error('unknown command %r. Try "list", "add" or "remove"\n'
                     % args[0])
    if not options.login:
        parser.error('you must provide --login information\n')

    return options, args


def main():
    """Implement the actual program functionality."""

    options, args = parse_commandline()

    if not options.account:
        options.account = options.login

    github = github2.client.Github(username=options.login,
                                   api_token=options.apitoken,
                                   cache=options.cache)

    # PEP-308 conditional expressions are much better, but we're keeping Py2.4
    # compatibility elsewhere.
    logging.basicConfig(level=options.debug and logging.DEBUG or logging.WARN,
                        format="%(asctime)s - %(message)s",
                        datefmt="%Y-%m-%dT%H:%M:%S")
    if len(args) == 1:
        for repos in github.repos.list(options.account):
            fullreposname = github.project_for_user_repo(options.account,
                                                         repos.name)
            collabs = github.repos.list_collaborators(fullreposname)
            print_("%s: %s" % (repos.name, ' '.join(collabs)))
    elif len(args) == 2:
        command, collaborator = args
        for repos in github.repos.list(options.account):
            fullreposname = github.project_for_user_repo(options.account,
                                                         repos.name)
            if collaborator in github.repos.list_collaborators(fullreposname):
                if command == 'remove':
                    github.repos.remove_collaborator(repos.name, collaborator)
                    print_("removed %r from %r" % (collaborator, repos.name))
            else:
                if command == 'add':
                    github.repos.add_collaborator(repos.name, collaborator)
                    print_("added %r to %r" % (collaborator, repos.name))

    logging.shutdown()


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = search_repos
#! /usr/bin/env python
# coding: utf-8
"""github_search_repos - search for repositories on GitHub"""
# Copyright (C) 2011-2012 James Rowe <jnrowe@gmail.com>
#
# This file is part of python-github2, and is made available under the 3-clause
# BSD license.  See LICENSE for the full details.


import logging
import sys

from optparse import OptionParser
from textwrap import wrap

import github2.client


#: Running under Python 3
PY3K = sys.version_info[0] == 3 and True or False


def print_(text):
    """Python 2 & 3 compatible print function.

    We support <2.6, so can't use __future__.print_function

    """
    if PY3K:
        print(text)
    else:
        sys.stdout.write(text + '\n')


def parse_commandline():
    """Parse the command line and return parsed options."""

    parser = OptionParser()
    parser.description = __doc__

    parser.set_usage('usage: %prog [options] <term>')
    parser.add_option('-d', '--debug', action='store_true',
                      help='Enables debugging mode')
    parser.add_option('-c', '--cache', default=None,
                      help='Location for network cache [default: None]')

    options, args = parser.parse_args()
    if len(args) != 1:
        parser.error('wrong number of arguments')

    return options, args[0]


def main():
    """Implement the actual program functionality."""
    return_value = 0

    options, term = parse_commandline()

    github = github2.client.Github(cache=options.cache)

    # PEP-308 conditional expressions are much better, but we're keeping Py2.4
    # compatibility elsewhere.
    logging.basicConfig(level=options.debug and logging.DEBUG or logging.WARN,
                        format="%(asctime)s - %(message)s",
                        datefmt="%Y-%m-%dT%H:%M:%S")

    repos = github.repos.search(term)
    if not repos:
        print_('No repos found!')
        return_value = 255
    else:
        for repo in repos:
            print(repo.project)
            if repo.description:
                print_('\n'.join(wrap(repo.description, initial_indent='    ',
                                     subsequent_indent='    ')))

    logging.shutdown()
    return return_value


if __name__ == '__main__':
    sys.exit(main())

########NEW FILE########
__FILENAME__ = client
# -*- coding: utf-8 -*-
# Copyright (C) 2009-2012 Ask Solem <askh@modwheel.net>
#                         Christopher MacGown <ignoti+github@gmail.com>
#                         Evan Broder <broder@mit.edu>
#                         James Rowe <jnrowe@gmail.com>
#                         Jeremy Dunck <jdunck@gmail.com>
#                         Michael Basnight <mbasnight@gmail.com>
#                         Patryk Zawadzki <patrys@pld-linux.org>
#                         Surajram Kumaravel <root@surajram.com>
#                         Vincent Driessen <vincent@datafox.nl>
#                         modocache <modocache@gmail.com>
#
# This file is part of python-github2, and is made available under the 3-clause
# BSD license.  See LICENSE for the full details.

from github2.request import GithubRequest
from github2.issues import Issues
from github2.repositories import Repositories
from github2.users import Users
from github2.commits import Commits
from github2.organizations import Organizations
from github2.teams import Teams
from github2.pull_requests import PullRequests


class Github(object):

    """Interface to GitHub's API v2."""

    def __init__(self, username=None, api_token=None, requests_per_second=None,
                 access_token=None, cache=None, proxy_host=None,
                 proxy_port=8080, github_url=None):
        """Setup GitHub API object.

        .. versionadded:: 0.2.0
           The ``requests_per_second`` parameter
        .. versionadded:: 0.3.0
           The ``cache`` and ``access_token`` parameters
        .. versionadded:: 0.4.0
           The ``proxy_host`` and ``proxy_port`` parameters
        .. versionadded:: 0.7.0
           The ``github_url`` parameter

        :param str username: your own GitHub username.
        :param str api_token: can be found at https://github.com/account
            (while logged in as that user):
        :param str access_token: can be used when no ``username`` and/or
            ``api_token`` is used.  The ``access_token`` is the OAuth access
            token that is received after successful OAuth authentication.
        :param float requests_per_second: indicate the API rate limit you're
            operating under (1 per second per GitHub at the moment),
            or None to disable delays.  The default is to disable delays (for
            backwards compatibility).
        :param str cache: a directory for caching GitHub responses.
        :param str proxy_host: the hostname for the HTTP proxy, if needed.
        :param str proxy_port: the hostname for the HTTP proxy, if needed (will
            default to 8080 if a proxy_host is set and no port is set).
        :param str github_url: the hostname to connect to, for GitHub
            Enterprise support

        """

        self.request = GithubRequest(username=username, api_token=api_token,
                                     requests_per_second=requests_per_second,
                                     access_token=access_token, cache=cache,
                                     proxy_host=proxy_host,
                                     proxy_port=proxy_port,
                                     github_url=github_url)
        self.issues = Issues(self.request)
        self.users = Users(self.request)
        self.repos = Repositories(self.request)
        self.commits = Commits(self.request)
        self.organizations = Organizations(self.request)
        self.teams = Teams(self.request)
        self.pull_requests = PullRequests(self.request)

    def project_for_user_repo(self, user, repo):
        """Return GitHub identifier for a user's repository.

        :param str user: repository owner
        :param str repo: repository name

        """
        return "/".join([user, repo])

    def get_all_blobs(self, project, tree_sha):
        """Get a list of all blobs for a specific tree.

        .. versionadded:: 0.3.0

        :param str project: GitHub project
        :param str tree_sha: object ID of tree

        """
        blobs = self.request.get("blob/all", project, tree_sha)
        return blobs.get("blobs")

    def get_blob_info(self, project, tree_sha, path):
        """Get the blob for a file within a specific tree.

        :param str project: GitHub project
        :param str tree_sha: object ID of tree
        :param str path: path within tree to fetch blob for

        """
        blob = self.request.get("blob/show", project, tree_sha, path)
        return blob.get("blob")

    def get_tree(self, project, tree_sha):
        """Get tree information for a specifc tree.

        :param str project: GitHub project
        :param str tree_sha: object ID of tree

        """
        tree = self.request.get("tree/show", project, tree_sha)
        return tree.get("tree", [])

    def get_network_meta(self, project):
        """Get GitHub metadata associated with a project.

        :param str project: GitHub project

        """
        return self.request.raw_request("/".join([self.request.github_url,
                                                  project,
                                                  "network_meta"]), {})

    def get_network_data(self, project, nethash, start=None, end=None):
        """Get chunk of GitHub network data.

        :param str project: GitHub project
        :param str nethash: identifier provided by :meth:`get_network_meta`
        :param int start: optional start point for data
        :param int stop: optional end point for data

        """
        data = {"nethash": nethash}
        if start:
            data["start"] = start
        if end:
            data["end"] = end

        return self.request.raw_request("/".join([self.request.github_url,
                                                  project,
                                                  "network_data_chunk"]),
                                                  data)

########NEW FILE########
__FILENAME__ = commits
# -*- coding: utf-8 -*-
# Copyright (C) 2009-2012 Ask Solem <askh@modwheel.net>
#                         James Rowe <jnrowe@gmail.com>
#                         Stéphane Angel <s.angel@twidi.com>
#                         Vincent Driessen <vincent@datafox.nl>
#
# This file is part of python-github2, and is made available under the 3-clause
# BSD license.  See LICENSE for the full details.

from github2.core import (BaseData, GithubCommand, Attribute, DateAttribute,
                          repr_string)


class Commit(BaseData):

    """Commit container."""

    message = Attribute("Commit message.")
    parents = Attribute("List of parents for this commit.")
    url = Attribute("Canonical URL for this commit.")
    author = Attribute("Author metadata (dict with name/email.)")
    id = Attribute("Commit ID.")
    committed_date = DateAttribute("Date committed.", format="commit")
    authored_date = DateAttribute("Date authored.", format="commit")
    tree = Attribute("Tree SHA for this commit.")
    committer = Attribute("Comitter metadata (dict with name/email.)")

    added = Attribute("(If present) Datastructure representing what's been "
                      "added since last commit.")
    removed = Attribute("(if present) Datastructure representing what's been "
                        "removed since last commit.")
    modified = Attribute("(If present) Datastructure representing what's "
                         "been modified since last commit.")

    def __repr__(self):
        return "<Commit: %s %s>" % (self.id[:8], repr_string(self.message))


class Commits(GithubCommand):

    """GitHub API commits functionality."""

    domain = "commits"

    def list(self, project, branch="master", file=None, page=1):
        """List commits on a project.

        .. warning::
           Not all projects use ``master`` as their default branch, you can
           check the value of the ``Repo(project).master_branch`` attribute to
           determine the default branch of a given repository.

        :param str project: project name
        :param str branch: branch name, or ``master`` if not given
        :param str file: optional file filter
        :param int page: optional page number

        """
        return self.get_values("list", project, branch, file, filter="commits",
                               datatype=Commit, page=page)

    def show(self, project, sha):
        """Get a specific commit.

        :param str project: project name
        :param str sha: commit id

        """
        return self.get_value("show", project, sha,
                              filter="commit", datatype=Commit)

########NEW FILE########
__FILENAME__ = core
# -*- coding: utf-8 -*-
# Copyright (C) 2009-2012 Ask Solem <askh@modwheel.net>
#                         Fernando Perez <Fernando.Perez@berkeley.edu>
#                         James Rowe <jnrowe@gmail.com>
#                         Mark Paschal <markpasc@markpasc.org>
#                         Patryk Zawadzki <patrys@pld-linux.org>
#                         Sameer Al-Sakran <sameer@whitelabellabs.com>
#                         Stéphane Angel <s.angel@twidi.com>
#                         Vincent Driessen <vincent@datafox.nl>
#
# This file is part of python-github2, and is made available under the 3-clause
# BSD license.  See LICENSE for the full details.

import logging
import sys

from datetime import datetime
from dateutil import (parser, tz)


#: Logger for core module
LOGGER = logging.getLogger('github2.core')

#: Running under Python 3
PY3K = sys.version_info[0] == 3

#: Running under Python 2.7, or newer
PY27 = sys.version_info[:2] >= (2, 7)

GITHUB_DATE_FORMAT = "%Y/%m/%d %H:%M:%S %z"
# We need to manually mangle the timezone for commit date formatting because it
# uses -xx:xx format
COMMIT_DATE_FORMAT = "%Y-%m-%dT%H:%M:%S"
#: GitHub timezone used in API output
GITHUB_TZ = tz.gettz("America/Los_Angeles")

#: Operate on naive :class:`datetime.datetime` objects, this is the default
#: for backwards compatibility
NAIVE = True


def string_to_datetime(string):
    """Convert a string to Python datetime.

    :param str github_date: date string to parse

    """
    parsed = parser.parse(string)
    if NAIVE:
        parsed = parsed.replace(tzinfo=None)
    return parsed


def _handle_naive_datetimes(f):
    """Decorator to make datetime arguments use GitHub timezone.

    :param func f: Function to wrap

    """
    def wrapper(datetime_):
        if not datetime_.tzinfo:
            datetime_ = datetime_.replace(tzinfo=GITHUB_TZ)
        else:
            datetime_ = datetime_.astimezone(GITHUB_TZ)
        return f(datetime_)
    wrapped = wrapper
    wrapped.__name__ = f.__name__
    wrapped.__doc__ = (
        f.__doc__
        + """\n    .. note:: Supports naive and timezone-aware datetimes"""
    )
    return wrapped


@_handle_naive_datetimes
def datetime_to_ghdate(datetime_):
    """Convert Python datetime to GitHub date string.

    :param datetime datetime_: datetime object to convert

    """
    return datetime_.strftime(GITHUB_DATE_FORMAT)


@_handle_naive_datetimes
def datetime_to_commitdate(datetime_):
    """Convert Python datetime to GitHub date string.

    :param datetime datetime_: datetime object to convert

    """
    date_without_tz = datetime_.strftime(COMMIT_DATE_FORMAT)
    utcoffset = GITHUB_TZ.utcoffset(datetime_)
    hours, minutes = divmod(utcoffset.days * 86400 + utcoffset.seconds, 3600)

    return "".join([date_without_tz, "%+03d:%02d" % (hours, minutes)])


def datetime_to_isodate(datetime_):
    """Convert Python datetime to GitHub date string.

    :param str datetime_: datetime object to convert

    .. note:: Supports naive and timezone-aware datetimes
    """
    if not datetime_.tzinfo:
        datetime_ = datetime_.replace(tzinfo=tz.tzutc())
    else:
        datetime_ = datetime_.astimezone(tz.tzutc())
    return "%sZ" % datetime_.isoformat()[:-6]


class AuthError(Exception):

    """Requires authentication."""


def requires_auth(f):
    """Decorate to check a function call for authentication.

    Sets a ``requires_auth`` attribute on functions, for use in introspection.

    :param func f: Function to wrap
    :raises AuthError: If function called without an authenticated session

    """
    # When Python 2.4 support is dropped move straight to functools.wraps,
    # don't pass go and don't collect $200.
    def wrapper(self, *args, **kwargs):
        if not self.request.access_token and not self.request.api_token:
            raise AuthError("%r requires an authenticated session"
                            % f.__name__)
        return f(self, *args, **kwargs)
    wrapped = wrapper
    wrapped.__orig_func__ = f
    wrapped.__name__ = f.__name__
    wrapped.__doc__ = f.__doc__ + """\n.. warning:: Requires authentication"""
    wrapped.__module__ = f.__module__
    wrapped.requires_auth = True
    return wrapped


def enhanced_by_auth(f):
    """Decorator to mark a function as enhanced by authentication.

    Sets a ``enhanced_by_auth`` attribute on functions, for use in
    introspection.

    :param func f: Function to wrap

    """
    f.enhanced_by_auth = True
    f.__doc__ += """\n.. note:: This call is enhanced with authentication"""
    return f


class GithubCommand(object):

    """Main API binding interface."""

    def __init__(self, request):
        """Setup command object.

        :param github2.request.GithubRequest request: HTTP request handler

        """
        self.request = request

    def make_request(self, command, *args, **kwargs):
        """Make an API request.

        Various options are supported if they exist in ``kwargs``:

        * The value of a ``method`` argument will define the HTTP method
          to perform for this request, the default is ``GET``
        * The value of a ``filter`` argument will restrict the response to that
          data
        * The value of a ``page`` argument will be used to fetch a specific
          page of results, default of 1 is assumed if not given

        """
        filter = kwargs.get("filter")
        post_data = kwargs.get("post_data") or {}
        page = kwargs.pop("page", 1)
        if page and not page == 1:
            post_data["page"] = page
        method = kwargs.get("method", "GET").upper()
        if method == "POST" or method == "GET" and post_data:
            response = self.request.post(self.domain, command, *args,
                                         **post_data)
        elif method == "PUT":
            response = self.request.put(self.domain, command, *args,
                                        **post_data)
        elif method == "DELETE":
            response = self.request.delete(self.domain, command, *args,
                                           **post_data)
        else:
            response = self.request.get(self.domain, command, *args)
        if filter:
            return response[filter]
        return response

    def get_value(self, *args, **kwargs):
        """Process a single-value response from the API.

        If a ``datatype`` parameter is given it defines the
        :class:`BaseData`-derived class we should build from the provided data

        """
        datatype = kwargs.pop("datatype", None)
        value = self.make_request(*args, **kwargs)
        if datatype:
            if not PY27:
                # unicode keys are not accepted as kwargs by python, until 2.7:
                # http://bugs.python.org/issue2646
                # So we make a local dict with the same keys but as strings:
                return datatype(**dict((str(k), v)
                                       for (k, v) in value.items()))
            else:
                return datatype(**value)
        return value

    def get_values(self, *args, **kwargs):
        """Process a multi-value response from the API.

        :see: :meth:`get_value`

        """
        datatype = kwargs.pop("datatype", None)
        values = self.make_request(*args, **kwargs)
        if datatype:
            if not PY27:
                # Same as above, unicode keys will blow up in **args, so we
                # need to create a new 'values' dict with string keys
                return [datatype(**dict((str(k), v)
                                        for (k, v) in value.items()))
                        for value in values]
            else:
                return [datatype(**value) for value in values]
        else:
            return values


def doc_generator(docstring, attributes):
    """Utility function to augment BaseDataType docstring.

    :param str docstring: docstring to augment
    :param dict attributes: attributes to add to docstring

    """
    docstring = docstring or ""

    def bullet(title, text):
        return """.. attribute:: %s\n\n   %s\n""" % (title, text)

    b = "\n".join([bullet(attr_name, attr.help)
                   for attr_name, attr in attributes.items()])
    return "\n\n".join([docstring, b])


class Attribute(object):

    """Generic object attribute for use with :class:`BaseData`."""

    def __init__(self, help):
        """Setup Attribute object.

        :param str help: Attribute description

        """
        self.help = help

    def to_python(self, value):
        return value

    from_python = to_python


class DateAttribute(Attribute):

    """Date handling attribute for use with :class:`BaseData`."""

    format = "github"
    converter_for_format = {
        "github": datetime_to_ghdate,
        "commit": datetime_to_commitdate,
        "user": datetime_to_ghdate,
        "iso": datetime_to_isodate,
    }

    def __init__(self, *args, **kwargs):
        """Setup DateAttribute object.

        :param str format: The date format to support, see
            :data:`convertor_for_format` for supported options

        """
        self.format = kwargs.pop("format", self.format)
        super(DateAttribute, self).__init__(*args, **kwargs)

    def to_python(self, value):
        if value and not isinstance(value, datetime):
            return string_to_datetime(value)
        return value

    def from_python(self, value):
        if value and isinstance(value, datetime):
            return self.converter_for_format[self.format](value)
        return value


class BaseDataType(type):

    def __new__(cls, name, bases, attrs):
        super_new = super(BaseDataType, cls).__new__

        _meta = dict([(attr_name, attr_value)
                      for attr_name, attr_value in attrs.items()
                      if isinstance(attr_value, Attribute)])
        attrs["_meta"] = _meta
        attributes = _meta.keys()
        attrs.update(dict([(attr_name, None) for attr_name in attributes]))

        def _contribute_method(name, func):
            func.__name__ = name
            attrs[name] = func

        def constructor(self, **kwargs):
            for attr_name, attr_value in kwargs.items():
                attr = self._meta.get(attr_name)
                if attr:
                    setattr(self, attr_name, attr.to_python(attr_value))
                else:
                    setattr(self, attr_name, attr_value)
        _contribute_method("__init__", constructor)

        def iterate(self):
            not_empty = lambda e: e[1] is not None
            return iter(filter(not_empty, vars(self).items()))
        _contribute_method("__iter__", iterate)

        result_cls = super_new(cls, name, bases, attrs)
        result_cls.__doc__ = doc_generator(result_cls.__doc__, _meta)
        return result_cls


# Ugly base class definition for Python 2 and 3 compatibility, where metaclass
# syntax is incompatible
class BaseData(BaseDataType('BaseData', (object, ), {})):

    """Wrapper for API responses.

    .. warning::
       Supports subscript attribute access purely for backwards compatibility,
       you shouldn't rely on that functionality in new code

    """

    def __getitem__(self, key):
        """Access objects's attribute using subscript notation.

        This is here purely to maintain compatibility when switching ``dict``
        responses to ``BaseData`` derived objects.

        """
        LOGGER.warning("Subscript access on %r is deprecated, use object "
                       "attributes" % self.__class__.__name__)
        if not key in self._meta.keys():
            raise KeyError(key)
        return getattr(self, key)

    def __setitem__(self, key, value):
        """Update object's attribute using subscript notation.

        :see: :meth:`BaseData.__getitem__`

        """
        LOGGER.warning("Subscript access on %r is deprecated, use object "
                       "attributes" % self.__class__.__name__)
        if not key in self._meta.keys():
            raise KeyError(key)
        setattr(self, key, value)


def repr_string(string):
    """Shorten string for use in repr() output.

    :param str string: string to operate on
    :return: string, with maximum length of 20 characters

    """
    if len(string) > 20:
        string = string[:17] + '...'
    if not PY3K:
        string.decode('utf-8')
    return string

########NEW FILE########
__FILENAME__ = issues
# Copyright (C) 2009-2012 Adam Vandenberg <flangy@gmail.com>
#                         Ask Solem <askh@modwheel.net>
#                         Barthelemy Dagenais <bart@cs.mcgill.ca>
#                         Fernando Perez <Fernando.Perez@berkeley.edu>
#                         James Rowe <jnrowe@gmail.com>
#                         Scott Torborg <scott@crookedmedia.com>
#
# This file is part of python-github2, and is made available under the 3-clause
# BSD license.  See LICENSE for the full details.

try:
    from urllib.parse import quote_plus  # For Python 3
except ImportError:
    from urllib import quote_plus  # NOQA

from github2.core import (GithubCommand, BaseData, Attribute, DateAttribute,
                          repr_string, requires_auth)


class Issue(BaseData):

    """Issue container."""

    position = Attribute("The position of this issue in a list.")
    number = Attribute("The issue number (unique for project).")
    votes = Attribute("Number of votes for this issue.")
    body = Attribute("The full description for this issue.")
    title = Attribute("Issue title.")
    user = Attribute("The username of the user that created this issue.")
    state = Attribute("State of this issue. Can be ``open`` or ``closed``.")
    labels = Attribute("Labels associated with this issue.")
    created_at = DateAttribute("The date this issue was created.")
    closed_at = DateAttribute("The date this issue was closed.")
    updated_at = DateAttribute("The date when this issue was last updated.")
    diff_url = Attribute("URL for diff output associated with this issue.")
    patch_url = Attribute("URL for format-patch associated with this issue.")
    pull_request_url = Attribute("URL for the issue's related pull request.")

    def __repr__(self):
        return "<Issue: %s>" % repr_string(self.title)


class Comment(BaseData):

    """Comment container."""

    created_at = DateAttribute("The date this comment was created.")
    updated_at = DateAttribute("The date when this comment was last updated.")
    body = Attribute("The full text of this comment.")
    id = Attribute("The comment id.")
    user = Attribute("The username of the user that created this comment.")

    def __repr__(self):
        return "<Comment: %s>" % repr_string(self.body)


class Issues(GithubCommand):

    """GitHub API issues functionality."""

    domain = "issues"

    def search(self, project, term, state="open"):
        """Get all issues for project that match term with given state.

        .. versionadded:: 0.3.0

        :param str project: GitHub project
        :param str term: term to search issues for
        :param str state: can be either ``open`` or ``closed``

        """
        return self.get_values("search", project, state, quote_plus(term),
                               filter="issues", datatype=Issue)

    def list(self, project, state="open"):
        """Get all issues for project with given state.

        :param str project: GitHub project
        :param str state: can be either ``open`` or ``closed``

        """
        return self.get_values("list", project, state, filter="issues",
                               datatype=Issue)

    def list_by_label(self, project, label):
        """Get all issues for project with label.

        .. versionadded:: 0.3.0

        :param str project: GitHub project
        :param str label:  a string representing a label (e.g., ``bug``)

        """
        return self.get_values("list", project, "label", label,
                               filter="issues", datatype=Issue)

    def list_labels(self, project):
        """Get all labels for project.

        .. versionadded:: 0.3.0

        :param str project: GitHub project

        """
        return self.get_values("labels", project, filter="labels")

    def show(self, project, number):
        """Get all the data for issue by issue-number.

        :param str project: GitHub project
        :param int number: issue number in the GitHub database

        """
        return self.get_value("show", project, str(number),
                              filter="issue", datatype=Issue)

    @requires_auth
    def open(self, project, title, body):
        """Open up a new issue.

        :param str project: GitHub project
        :param str title: title for issue
        :param str body: body for issue

        """
        issue_data = {"title": title, "body": body}
        return self.get_value("open", project, post_data=issue_data,
                              filter="issue", datatype=Issue)

    @requires_auth
    def close(self, project, number):
        """Close an issue.

        :param str project: GitHub project
        :param int number: issue number in the GitHub database

        """
        return self.get_value("close", project, str(number), filter="issue",
                              datatype=Issue, method="POST")

    @requires_auth
    def reopen(self, project, number):
        """Reopen a closed issue.

        .. versionadded:: 0.3.0

        :param str project: GitHub project
        :param int number: issue number in the GitHub database

        """
        return self.get_value("reopen", project, str(number), filter="issue",
                              datatype=Issue, method="POST")

    @requires_auth
    def edit(self, project, number, title, body):
        """Edit an existing issue.

        .. versionadded:: 0.3.0

        :param str project: GitHub project
        :param int number: issue number in the GitHub database
        :param str title: title for issue
        :param str body: body for issue

        """
        issue_data = {"title": title, "body": body}
        return self.get_value("edit", project, str(number),
                              post_data=issue_data, filter="issue",
                              datatype=Issue)

    @requires_auth
    def add_label(self, project, number, label):
        """Add a label to an issue.

        :param str project: GitHub project
        :param int number: issue number in the GitHub database
        :param str label: label to attach to issue

        """
        return self.get_values("label/add", project, label, str(number),
                               filter="labels", method="POST")

    @requires_auth
    def remove_label(self, project, number, label):
        """Remove an existing label from an issue.

        :param str project: GitHub project
        :param int number: issue number in the GitHub database
        :param str label: label to remove from issue

        """
        return self.get_values("label/remove", project, label, str(number),
                               filter="labels", method="POST")

    @requires_auth
    def comment(self, project, number, comment):
        """Comment on an issue.

        :param str project: GitHub project
        :param int number: issue number in the GitHub database
        :param str comment: comment to attach to issue

        """
        comment_data = {'comment': comment}
        return self.get_value("comment", project, str(number),
                              post_data=comment_data, filter='comment',
                              datatype=Comment)

    def comments(self, project, number):
        """View comments on an issue.

        :param str project: GitHub project

        """
        return self.get_values("comments", project, str(number),
                               filter="comments", datatype=Comment)

########NEW FILE########
__FILENAME__ = organizations
# Copyright (C) 2011-2012 James Rowe <jnrowe@gmail.com>
#                         Patryk Zawadzki <patrys@pld-linux.org>
#                         Rok Garbas <rok@garbas.si>
#
# This file is part of python-github2, and is made available under the 3-clause
# BSD license.  See LICENSE for the full details.

from github2.core import (BaseData, GithubCommand, Attribute, DateAttribute,
                          requires_auth)
from github2.repositories import Repository
from github2.teams import Team
from github2.users import User


class Organization(BaseData):

    """Organization container.

    .. versionadded:: 0.4.0

    """

    id = Attribute("The organization id.")
    name = Attribute("The full name of the organization.")
    blog = Attribute("The organization's blog.")
    location = Attribute("Location of the organization.")
    gravatar_id = Attribute("Gravatar ID.")
    login = Attribute("The login username.")
    email = Attribute("The organization's e-mail address.")
    company = Attribute("The organization's company name.")
    created_at = DateAttribute("The date the organization was created.",
                               format="commit")
    following_count = Attribute("Number of users the organization is "
                                "following.")
    followers_count = Attribute("Number of users following this organization.")
    public_gist_count = Attribute("Organization's number of active public "
                                  "gists.")
    public_repo_count = Attribute("Organization's number of active "
                                  "repositories.")
    permission = Attribute("Permissions within this organization.")
    plan = Attribute("GitHub plan for this organization.")

    def is_authenticated(self):
        return self.plan is not None

    def __repr__(self):
        return "<Organization: %s>" % self.login


class Organizations(GithubCommand):

    """GitHub API organizations functionality.

    .. versionadded:: 0.4.0

    """

    domain = "organizations"

    def show(self, organization):
        """Get information on organization.

        :param str organization: organization to show

        """
        return self.get_value(organization, filter="organization",
                              datatype=Organization)

    def list(self):
        """Get list of all of your organizations."""
        return self.get_values('', filter="organizations",
                               datatype=Organization)

    def repositories(self, organization=''):
        """Get list of all repositories in an organization.

        If organization is not given, or is empty, then this will list
        repositories for all organizations the authenticated user belongs to.

        :param: str organization: organization to list repositories for

        """
        return self.get_values(organization, 'repositories',
                               filter="repositories", datatype=Repository)

    def public_repositories(self, organization):
        """Get list of public repositories in an organization.

        :param str organization: organization to list public repositories for

        """
        return self.get_values(organization, 'public_repositories',
                               filter="repositories", datatype=Repository)

    def public_members(self, organization):
        """Get list of public members in an organization.

        :param str organization: organization to list members for

        """
        return self.get_values(organization, 'public_members', filter="users",
                               datatype=User)

    def teams(self, organization):
        """Get list of teams in an organization.

        :param str organization: organization to list teams for

        """
        return self.get_values(organization, 'teams', filter="teams",
                               datatype=Team)

    @requires_auth
    def add_team(self, organization, name, permission='pull', projects=None):
        """Add a team to an organization.

        :param str organization: organization to add team to
        :param str team: name of team to add
        :param str permission: permissions for team(push, pull or admin)
        :param list projects: optional GitHub projects for this team

        """
        team_data = {'team[name]': name, 'team[permission]': permission}
        if projects:
            team_data['team[repo_names][]'] = projects
        return self.get_value(organization, 'teams', post_data=team_data,
                              method='POST', filter='team', datatype=Team)

########NEW FILE########
__FILENAME__ = pull_requests
# -*- coding: utf-8 -*-
# Copyright (C) 2010-2012 Christopher MacGown <ignoti+github@gmail.com>
#                         Ionuț Arțăriși <mapleoin@lavabit.com>
#                         James Rowe <jnrowe@gmail.com>
#                         Stéphane Angel <s.angel@twidi.com>
#
# This file is part of python-github2, and is made available under the 3-clause
# BSD license.  See LICENSE for the full details.

from github2.core import (BaseData, GithubCommand, Attribute, DateAttribute,
                          repr_string)


class PullRequest(BaseData):

    """Pull request container.

    .. versionadded:: 0.5.0

    """

    state = Attribute("The pull request state")
    base = Attribute("The base repo")
    head = Attribute("The head of the pull request")
    issue_user = Attribute("The user who created the pull request.")
    user = Attribute("The owner of the repo.")
    title = Attribute("The text of the pull request title.")
    body = Attribute("The text of the body.")
    position = Attribute("Floating point position of the pull request.")
    number = Attribute("Number of this request.")
    votes = Attribute("Number of votes for this request.")
    comments = Attribute("Number of comments made on this request.")
    diff_url = Attribute("The URL to the unified diff.")
    patch_url = Attribute("The URL to the downloadable patch.")
    labels = Attribute("A list of labels attached to the pull request.")
    html_url = Attribute("The URL to the pull request.")
    issue_created_at = DateAttribute("The date the issue for this pull "
                                     "request was opened.", format='iso')
    issue_updated_at = DateAttribute("The date the issue for this pull "
                                     "request was last updated.", format='iso')
    created_at = DateAttribute("The date when this pull request was created.",
                               format='iso')
    updated_at = DateAttribute("The date when this pull request was last "
                               "updated.", format='iso')
    closed_at = DateAttribute("The date when this pull request was closed",
                              format='iso')
    discussion = Attribute("Discussion thread for the pull request.")
    mergeable = Attribute("Whether the pull request can be merge cleanly")

    def __repr__(self):
        return "<PullRequest: %s>" % repr_string(self.title)


class PullRequests(GithubCommand):

    """GitHub API pull request functionality.

    .. versionadded:: 0.5.0

    """

    domain = "pulls"

    def create(self, project, base, head, title=None, body=None, issue=None):
        """Create a new pull request.

        Pull requests can be created from scratch, or attached to an existing
        issue.  If an ``issue`` parameter is supplied the pull request is
        attached to that issue, else a new pull request is created.

        :param str project: the GitHub project to send the pull request to
        :param str base: branch changes should be pulled into
        :param str head: branch of the changes to be pulled
        :param str title: title for pull request
        :param str body: optional body for pull request
        :param str issue: existing issue to attach pull request to

        """
        post_data = {"base": base, "head": head}
        if issue:
            post_data["issue"] = issue
        elif title:
            post_data["title"] = title
            if body:
                post_data["body"] = body
        else:
            raise TypeError("You must either specify a title for the "
                            "pull request or an issue number to which the "
                            "pull request should be attached.")
        pull_request_data = [("pull[%s]" % k, v) for k, v in post_data.items()]
        return self.get_value(project, post_data=dict(pull_request_data),
                              filter="pull", datatype=PullRequest)

    def show(self, project, number):
        """Show a single pull request.

        :param str project: GitHub project
        :param int number: pull request number in the GitHub database

        """
        return self.get_value(project, str(number), filter="pull",
                              datatype=PullRequest)

    def list(self, project, state="open", page=1):
        """List all pull requests for a project.

        :param str project: GitHub project
        :param str state: can be either ``open`` or ``closed``
        :param int page: optional page number

        """
        return self.get_values(project, state, filter="pulls",
                               datatype=PullRequest, page=page)

########NEW FILE########
__FILENAME__ = repositories
# -*- coding: utf-8 -*-
# Copyright (C) 2009-2012 Ask Solem <askh@modwheel.net>
#                         Claudio B. <claudiob@gmail.com>
#                         Daniel Greenfeld <pydanny@gmail.com>
#                         James Rowe <jnrowe@gmail.com>
#                         Jens Ohlig <jens.ohlig@gmail.com>
#                         Jeremy Dunck <jdunck@gmail.com>
#                         Jonas Obrist <jonas.obrist@divio.ch>
#                         Kenneth Reitz <me@kennethreitz.com>
#                         Mark Paschal <markpasc@markpasc.org>
#                         Maximillian Dornseif <m.dornseif@hudora.de>
#                         Sameer Al-Sakran <sameer@whitelabellabs.com>
#                         Stéphane Angel <s.angel@twidi.com>
#
# This file is part of python-github2, and is made available under the 3-clause
# BSD license.  See LICENSE for the full details.

from github2.core import (BaseData, GithubCommand, Attribute, DateAttribute,
                          requires_auth)

from github2.users import User


class Repository(BaseData):

    """Repository container."""

    name = Attribute("Name of repository.")
    description = Attribute("Repository description.")
    forks = Attribute("Number of forks of this repository.")
    watchers = Attribute("Number of people watching this repository.")
    private = Attribute("If True, the repository is private.")
    url = Attribute("Canonical URL to this repository")
    fork = Attribute("If True, this is a fork of another repository.")
    owner = Attribute("Username of the user owning this repository.")
    homepage = Attribute("Homepage for this project.")
    master_branch = Attribute("Default branch, if set.")
    integration_branch = Attribute("Integration branch, if set.")
    open_issues = Attribute("List of open issues for this repository.")
    created_at = DateAttribute("Datetime the repository was created.")
    pushed_at = DateAttribute("Datetime of the last push to this repository")
    has_downloads = Attribute("If True, this repository has downloads.")
    has_wiki = Attribute("If True, this repository has a wiki.")
    has_issues = Attribute("If True, this repository has an issue tracker.")
    language = Attribute("Primary language for the repository.")
    parent = Attribute("The parent project of this fork.")
    source = Attribute("The root project of this fork")

    def _project(self):
        return self.owner + "/" + self.name
    project = property(_project)

    def __repr__(self):
        return "<Repository: %s>" % self.project


class Repositories(GithubCommand):
    """GitHub API repository functionality."""

    domain = "repos"

    def search(self, query):
        """Get all repositories that match term.

        .. warning:
           Returns at most 100 repositories

        :param str query: term to search issues for

        """
        return self.get_values("search", query, filter="repositories",
                               datatype=Repository)

    def show(self, project):
        """Get repository object for project.

        :param str project: GitHub project

        """
        return self.get_value("show", project, filter="repository",
                              datatype=Repository)

    @requires_auth
    def pushable(self):
        """Return a list of repos you can push to that are not your own.

        .. versionadded:: 0.3.0

        """
        return self.get_values("pushable", filter="repositories",
                               datatype=Repository)

    def list(self, user=None, page=1):
        """Return a list of all repositories for a user.

        .. deprecated:: 0.4.0
           Previous releases would attempt to display repositories for the
           logged-in user when ``user`` wasn't supplied.  This functionality is
           brittle and will be removed in a future release!

        :param str user: GitHub user name to list repositories for
        :param int page: optional page number

        """
        user = user or self.request.username
        return self.get_values("show", user, filter="repositories",
                               datatype=Repository, page=page)

    @requires_auth
    def watch(self, project):
        """Watch a project.

        :param str project: GitHub project

        """
        return self.get_value("watch", project, filter='repository',
                              datatype=Repository)

    @requires_auth
    def unwatch(self, project):
        """Unwatch a project.

        :param str project: GitHub project

        """
        return self.get_value("unwatch", project, filter='repository',
                              datatype=Repository)

    @requires_auth
    def fork(self, project):
        """Fork a project.

        :param str project: GitHub project

        """
        return self.get_value("fork", project, filter="repository",
                              datatype=Repository)

    @requires_auth
    def create(self, project, description=None, homepage=None, public=True):
        """Create a repository.

        :param str project: new project name
        :param str description: optional project description
        :param str homepage: optional project homepage
        :param bool public: whether to make a public project

        """
        repo_data = {"name": project, "description": description,
                     "homepage": homepage, "public": str(int(public))}
        return self.get_value("create", post_data=repo_data,
                              filter="repository", datatype=Repository)

    @requires_auth
    def delete(self, project):
        """Delete a repository.

        :param str project: project name to delete

        """
        # Two-step delete mechanism.  We must echo the delete_token value back
        # to GitHub to actually delete a repository
        result = self.make_request("delete", project, method="POST")
        self.make_request("delete", project, post_data=result)

    @requires_auth
    def set_private(self, project):
        """Mark repository as private.

        :param str project: project name to set as private

        """
        return self.make_request("set/private", project)

    @requires_auth
    def set_public(self, project):
        """Mark repository as public.

        :param str project: project name to set as public

        """
        return self.make_request("set/public", project)

    def list_collaborators(self, project):
        """List all the collaborators in a project.

        :param str project: GitHub project

        """
        return self.get_values("show", project, "collaborators",
                               filter="collaborators")

    @requires_auth
    def add_collaborator(self, project, username):
        """Add an add_collaborator to a repo.

        :param str project: GitHub project
        :param str username: GitHub user to add as collaborator

        """
        return self.make_request("collaborators", project, "add", username,
                                 method="POST")

    @requires_auth
    def remove_collaborator(self, project, username):
        """Remove a collaborator from a repo.

        :param str project: GitHub project
        :param str username: GitHub user to add as collaborator

        """
        return self.make_request("collaborators", project, "remove",
                                 username, method="POST")

    def network(self, project):
        """Get network data for project.

        :param str project: GitHub project

        """
        return self.get_values("show", project, "network", filter="network",
                               datatype=Repository)

    def languages(self, project):
        """Get programming language data for project.

        :param str project: GitHub project

        """
        return self.get_values("show", project, "languages",
                               filter="languages")

    def tags(self, project):
        """Get tags for project.

        :param str project: GitHub project

        """
        return self.get_values("show", project, "tags", filter="tags")

    def branches(self, project):
        """Get branch names for project.

        :param str project: GitHub project

        """
        return self.get_values("show", project, "branches", filter="branches")

    def watchers(self, project):
        """Get list of watchers for project.

        :param str project: GitHub project

        """
        return self.get_values("show", project, "watchers", filter="watchers")

    def watching(self, for_user=None, page=None):
        """List all the repos a user is watching.

        :param str for_user: optional GitHub user name to list repositories for
        :param int page: optional page number

        """
        for_user = for_user or self.request.username
        return self.get_values("watched", for_user, filter="repositories",
                               datatype=Repository, page=page)

    def list_contributors(self, project):
        """List all the contributors in a project.

        :param str project: GitHub project

        """
        return self.get_values("show", project, "contributors",
                               filter="contributors", datatype=User)

########NEW FILE########
__FILENAME__ = request
# Copyright (C) 2009-2012 Adam Vandenberg <flangy@gmail.com>
#                         Asheesh Laroia <asheesh@openhatch.org>
#                         Ask Solem <askh@modwheel.net>
#                         Chris Vale <crispywalrus@gmail.com>
#                         Daniel Greenfeld <pydanny@gmail.com>
#                         Evan Broder <broder@mit.edu>
#                         James Rowe <jnrowe@gmail.com>
#                         Jeremy Dunck <jdunck@gmail.com>
#                         Josh Weinberg <daemoncollector@gmail.com>
#                         Mark Paschal <markpasc@markpasc.org>
#                         Maximillian Dornseif <m.dornseif@hudora.de>
#                         Michael Basnight <mbasnight@gmail.com>
#                         Patryk Zawadzki <patrys@pld-linux.org>
#                         Rick Harris <rick.harris@rackspace.com>
#                         Sameer Al-Sakran <sameer@whitelabellabs.com>
#                         Vincent Driessen <vincent@datafox.nl>
#                         modocache <modocache@gmail.com>
#
# This file is part of python-github2, and is made available under the 3-clause
# BSD license.  See LICENSE for the full details.

import datetime
import logging
import re
import sys
import time

try:
    # For Python 3
    from http.client import responses
except ImportError:  # For Python 2.5-2.7
    try:
        from httplib import responses  # NOQA
    except ImportError:  # For Python 2.4
        from BaseHTTPServer import BaseHTTPRequestHandler as _BHRH
        responses = dict([(k, v[0]) for k, v in _BHRH.responses.items()])  # NOQA
try:
    import json as simplejson  # For Python 2.6+
except ImportError:
    import simplejson  # NOQA
from os import (getenv, path)
try:
    # For Python 3
    from urllib.parse import (parse_qs, quote, urlencode, urlsplit, urlunsplit)
except ImportError:
    from urlparse import (urlsplit, urlunsplit)  # NOQA
    try:
        from urlparse import parse_qs  # NOQA
    except ImportError:
        from cgi import parse_qs  # NOQA
    from urllib import urlencode, quote  # NOQA

import httplib2


#: Hostname for API access
DEFAULT_GITHUB_URL = "https://github.com"

#: Logger for requests module
LOGGER = logging.getLogger('github2.request')

# Fetch actual path for httplib2's default cert bundle, for distributions that
# symlink their system certs
_HTTPLIB2_BUNDLE = path.realpath(path.dirname(httplib2.CA_CERTS))
#: Whether github2 is using the system's certificates for SSL connections
SYSTEM_CERTS = not _HTTPLIB2_BUNDLE.startswith(path.dirname(httplib2.__file__))
CA_CERTS = None
#: Whether github2 is using the cert's from the file given in $CURL_CA_BUNDLE
CURL_CERTS = False
if not SYSTEM_CERTS and sys.platform.startswith('linux'):
    for cert_file in ['/etc/ssl/certs/ca-certificates.crt',
                      '/etc/pki/tls/certs/ca-bundle.crt']:
        if path.exists(cert_file):
            CA_CERTS = cert_file
            SYSTEM_CERTS = True
            break
elif not SYSTEM_CERTS and sys.platform.startswith('freebsd'):
    if path.exists('/usr/local/share/certs/ca-root-nss.crt'):
        CA_CERTS = '/usr/local/share/certs/ca-root-nss.crt'
        SYSTEM_CERTS = True
elif path.exists(getenv('CURL_CA_BUNDLE', '')):
    CA_CERTS = getenv('CURL_CA_BUNDLE')
    CURL_CERTS = True
if not SYSTEM_CERTS and not CURL_CERTS:
    CA_CERTS = path.join(path.dirname(path.abspath(__file__)),
                         "DigiCert_High_Assurance_EV_Root_CA.crt")


# Common missing entries from the HTTP status code dict, basically anything
# GitHub reports that isn't basic HTTP/1.1.
responses[422] = 'Unprocessable Entity'


def charset_from_headers(headers):
    """Parse charset from headers.

    :param httplib2.Response headers: Request headers
    :return: Defined encoding, or default to ASCII

    """
    match = re.search("charset=([^ ;]+)", headers.get('content-type', ""))
    if match:
        charset = match.groups()[0]
    else:
        charset = "ascii"
    return charset


class GithubError(Exception):

    """An error occurred when making a request to the GitHub API."""


class HttpError(RuntimeError):

    """A HTTP error occured when making a request to the GitHub API."""

    def __init__(self, message, content, code):
        """Create a HttpError exception.

        :param str message: Exception string
        :param str content: Full content of HTTP request
        :param int code: HTTP status code

        """
        self.args = (message, content, code)
        self.message = message
        self.content = content
        self.code = code
        if code in responses:
            self.code_reason = responses[code]
        else:
            self.code_reason = "<unknown status code>"
            LOGGER.warning('Unknown HTTP status %r, please file an issue',
                           code)


class GithubRequest(object):

    """Make an API request.

    :see: :class:`github2.client.Github`

    """

    url_format = "%(github_url)s/api/%(api_version)s/%(api_format)s"
    api_version = "v2"
    api_format = "json"
    GithubError = GithubError

    def __init__(self, username=None, api_token=None, url_prefix=None,
                 requests_per_second=None, access_token=None,
                 cache=None, proxy_host=None, proxy_port=None,
                 github_url=None):
        self.username = username
        self.api_token = api_token
        self.access_token = access_token
        self.url_prefix = url_prefix
        if github_url is None:
            self.github_url = DEFAULT_GITHUB_URL
        else:
            self.github_url = github_url
        if requests_per_second is None:
            self.delay = 0
        else:
            self.delay = 1.0 / requests_per_second
        self.last_request = datetime.datetime(1900, 1, 1)
        if not self.url_prefix:
            self.url_prefix = self.url_format % {
                "github_url": self.github_url,
                "api_version": self.api_version,
                "api_format": self.api_format,
            }
        if proxy_host is None:
            self._http = httplib2.Http(cache=cache)
        else:
            proxy_info = httplib2.ProxyInfo(httplib2.socks.PROXY_TYPE_HTTP,
                                            proxy_host, proxy_port)
            self._http = httplib2.Http(proxy_info=proxy_info, cache=cache)
        self._http.ca_certs = CA_CERTS
        if SYSTEM_CERTS:
            LOGGER.info('Using system certificates in %r', CA_CERTS)
        elif CURL_CERTS:
            LOGGER.info("Using cURL's certificates in %r", CA_CERTS)
        else:
            LOGGER.warning('Using bundled certificate for HTTPS connections')

    def encode_authentication_data(self, extra_post_data):
        post_data = []
        if self.access_token:
            post_data.append(("access_token", self.access_token))
        elif self.username and self.api_token:
            post_data.append(("login", self.username))
            post_data.append(("token", self.api_token))
        for key, value in extra_post_data.items():
            if isinstance(value, list):
                for elem in value:
                    post_data.append((key, elem))
            else:
                post_data.append((key, value))
        return urlencode(post_data)

    def get(self, *path_components):
        path_components = filter(None, path_components)
        return self.make_request("/".join(path_components))

    def post(self, *path_components, **extra_post_data):
        path_components = filter(None, path_components)
        return self.make_request("/".join(path_components), extra_post_data,
            method="POST")

    def put(self, *path_components, **extra_post_data):
        path_components = filter(None, path_components)
        return self.make_request("/".join(path_components), extra_post_data,
            method="PUT")

    def delete(self, *path_components, **extra_post_data):
        path_components = filter(None, path_components)
        return self.make_request("/".join(path_components), extra_post_data,
            method="DELETE")

    def make_request(self, path, extra_post_data=None, method="GET"):
        if self.delay:
            since_last = (datetime.datetime.utcnow() - self.last_request)
            if since_last.days == 0 and since_last.seconds < self.delay:
                duration = self.delay - since_last.seconds
                LOGGER.warning("delaying API call %g second(s)", duration)
                time.sleep(duration)

        extra_post_data = extra_post_data or {}
        url = "/".join([self.url_prefix, quote(path)])
        result = self.raw_request(url, extra_post_data, method=method)

        if self.delay:
            self.last_request = datetime.datetime.utcnow()
        return result

    def raw_request(self, url, extra_post_data, method="GET"):
        scheme, netloc, path, query, fragment = urlsplit(url)
        post_data = None
        headers = self.http_headers
        method = method.upper()
        if extra_post_data or method == "POST":
            post_data = self.encode_authentication_data(extra_post_data)
            headers["Content-Length"] = str(len(post_data))
        else:
            query = self.encode_authentication_data(parse_qs(query))
        url = urlunsplit((scheme, netloc, path, query, fragment))
        response, content = self._http.request(url, method, post_data, headers)
        if LOGGER.isEnabledFor(logging.DEBUG):
            logging.debug("URL: %r POST_DATA: %r RESPONSE_TEXT: %r", url,
                          post_data, content)
        if response.status >= 400:
            raise HttpError("Unexpected response from github.com %d: %r"
                            % (response.status, content), content,
                            response.status)
        json = simplejson.loads(content.decode(charset_from_headers(response)))
        if json.get("error"):
            raise self.GithubError(json["error"][0]["error"])

        return json

    @property
    def http_headers(self):
        return {
            "User-Agent": "pygithub2 v1",
            "Accept": "application/json",
        }

########NEW FILE########
__FILENAME__ = teams
# Copyright (C) 2011-2012 James Rowe <jnrowe@gmail.com>
#                         Patryk Zawadzki <patrys@pld-linux.org>
#
# This file is part of python-github2, and is made available under the 3-clause
# BSD license.  See LICENSE for the full details.

from github2.core import BaseData, GithubCommand, Attribute, requires_auth
from github2.repositories import Repository
from github2.users import User


class Team(BaseData):

    """Team container.

    .. versionadded:: 0.4.0

    """

    id = Attribute("The team id")
    name = Attribute("Name of the team")
    permission = Attribute("Permissions of the team")

    def __repr__(self):
        return "<Team: %s>" % self.name


class Teams(GithubCommand):

    """GitHub API teams functionality.

    .. versionadded:: 0.4.0

    """

    domain = "teams"

    def show(self, team_id):
        """Get information on team_id.

        :param int team_id: team to get information for

        """
        return self.get_value(str(team_id), filter="team", datatype=Team)

    def members(self, team_id):
        """Get list of all team members.

        :param int team_id: team to get information for

        """
        return self.get_values(str(team_id), "members", filter="users",
                               datatype=User)

    @requires_auth
    def add_member(self, team_id, username):
        """Add a new member to a team.

        :param int team_id: team to add new member to
        :param str username: GitHub username to add to team

        """
        return self.get_values(str(team_id), 'members', method='POST',
                               post_data={'name': username}, filter='users',
                               datatype=User)

    def repositories(self, team_id):
        """Get list of all team repositories.

        :param int team_id: team to get information for

        """
        return self.get_values(str(team_id), "repositories",
                               filter="repositories", datatype=Repository)

    @requires_auth
    def add_project(self, team_id, project):
        """Add a project to a team.

        :param int team_id: team to add repository to
        :param str project: GitHub project

        """
        if isinstance(project, Repository):
            project = project.project
        return self.get_values(str(team_id), "repositories", method="POST",
                               post_data={'name': project},
                               filter="repositories", datatype=Repository)

    @requires_auth
    def remove_project(self, team_id, project):
        """Remove a project to a team.

        :param int team_id: team to remove project from
        :param str project: GitHub project

        """
        if isinstance(project, Repository):
            project = project.project
        return self.get_values(str(team_id), "repositories", method="DELETE",
                               post_data={'name': project},
                               filter="repositories", datatype=Repository)

########NEW FILE########
__FILENAME__ = users
# -*- coding: utf-8 -*-
# Copyright (C) 2009-2012 Ask Solem <askh@modwheel.net>
#                         James Rowe <jnrowe@gmail.com>
#                         Sameer Al-Sakran <sameer@whitelabellabs.com>
#                         Stéphane Angel <s.angel@twidi.com>
#
# This file is part of python-github2, and is made available under the 3-clause
# BSD license.  See LICENSE for the full details.

try:
    from urllib.parse import quote_plus  # For Python 3
except ImportError:
    from urllib import quote_plus  # NOQA

from github2.core import (BaseData, GithubCommand, DateAttribute, Attribute,
                          enhanced_by_auth, requires_auth)


class Key(BaseData):

    """SSH key container."""

    id = Attribute('The key id')
    key = Attribute('The SSH key data')
    title = Attribute('The title for the SSH key')

    def __repr__(self):
        return "<Key: %s>" % self.id


class User(BaseData):

    """GitHub user container."""

    id = Attribute("The user id")
    login = Attribute("The login username")
    name = Attribute("The users full name")
    company = Attribute("Name of the company the user is associated with")
    location = Attribute("Location of the user")
    email = Attribute("The users e-mail address")
    blog = Attribute("The users blog")
    following_count = Attribute("Number of other users the user is following")
    followers_count = Attribute("Number of users following this user")
    public_gist_count = Attribute(
                            "Number of active public gists owned by the user")
    public_repo_count = Attribute(
                        "Number of active repositories owned by the user")
    total_private_repo_count = Attribute("Number of private repositories")
    collaborators = Attribute("Number of collaborators")
    disk_usage = Attribute("Currently used disk space")
    owned_private_repo_count = Attribute("Number of privately owned repos")
    private_gist_count = Attribute(
        "Number of private gists owned by the user")
    plan = Attribute("Current active github plan")
    created_at = DateAttribute("The date this user was registered",
                               format="user")

    def is_authenticated(self):
        """Test for user authentication.

        :return bool: ``True`` if user is authenticated

       """
        return self.plan is not None

    def __repr__(self):
        return "<User: %s>" % self.login


class Users(GithubCommand):

    """GitHub API user functionality."""

    domain = "user"

    def search(self, query):
        """Search for users.

        .. warning:
           Returns at most 100 users

        :param str query: term to search for

        """
        return self.get_values("search", quote_plus(query), filter="users",
                               datatype=User)

    def search_by_email(self, query):
        """Search for users by email address.

        :param str query: email to search for

        """
        return self.get_value("email", query, filter="user", datatype=User)

    @enhanced_by_auth
    def show(self, username):
        """Get information on GitHub user.

        if ``username`` is ``None`` or an empty string information for the
        currently authenticated user is returned.


        """
        return self.get_value("show", username, filter="user", datatype=User)

    def followers(self, username):
        """Get list of GitHub user's followers.

        :param str username: GitHub user name

        """
        return self.get_values("show", username, "followers", filter="users")

    def following(self, username):
        """Get list of users a GitHub user is following.

        :param str username: GitHub user name

        """
        return self.get_values("show", username, "following", filter="users")

    @requires_auth
    def follow(self, other_user):
        """Follow a GitHub user.

        :param str other_user: GitHub user name

        """
        return self.get_values("follow", other_user, method="POST")

    @requires_auth
    def unfollow(self, other_user):
        """Unfollow a GitHub user.

        :param str other_user: GitHub user name

        """
        return self.get_values("unfollow", other_user, method="POST")

    @requires_auth
    def list_keys(self):
        """Get list of SSH keys for the authenticated user."""
        return self.get_values('keys', filter='public_keys', datatype=Key)

    @requires_auth
    def add_key(self, key, title=''):
        """Add a SSH key for the authenticated user.

        :param str key: SSH key identifier
        :param str title: Optional title for the SSH key

        """
        return self.get_values("key/add",
                               post_data={'key': key, 'title': title},
                               method="POST", filter='public_keys',
                               datatype=Key)

    @requires_auth
    def remove_key(self, key_id):
        """Remove a SSH key for the authenticated user.

        :param int key_id: SSH key's GitHub identifier

        """
        return self.get_values('key/remove', post_data={'id': str(key_id)},
                               filter='public_keys', datatype=Key)

########NEW FILE########
__FILENAME__ = _version
# This is github2 version 0.6.2 (2012-06-11)
# pylint: disable=C0103, C0111, C0121, W0622

dotted = "0.6.2"
libtool = "6:22"
hex = 0x000602
date = "2012-06-11"
tuple = (0, 6, 2)
web = "github2/0.6.2"

########NEW FILE########
__FILENAME__ = test_charset_header
# Copyright (C) 2011-2012 James Rowe <jnrowe@gmail.com>
#
# This file is part of python-github2, and is made available under the 3-clause
# BSD license.  See LICENSE for the full details.

from nose.tools import eq_

from github2.request import charset_from_headers


def no_match_test():
    d = {}
    eq_("ascii", charset_from_headers(d))


def utf_test():
    d = {'content-type': 'application/json; charset=utf-8'}
    eq_("utf-8", charset_from_headers(d))

########NEW FILE########
__FILENAME__ = test_commits
# Copyright (C) 2011-2012 James Rowe <jnrowe@gmail.com>
#
# This file is part of python-github2, and is made available under the 3-clause
# BSD license.  See LICENSE for the full details.

from datetime import datetime

from nose.tools import eq_

import utils


class CommitProperties(utils.HttpMockTestCase):

    """Test commit property handling."""

    commit_id = '1c83cde9b5a7c396a01af1007fb7b88765b9ae45'

    def test_commit(self):
        commit = self.client.commits.show('ask/python-github2', self.commit_id)
        eq_(commit.message, 'Added cache support to manage_collaborators.')
        eq_(commit.parents,
            [{"id": '7d1c855d2f44a55e4b90b40017be697cf70cb4a0'}])
        eq_(commit.url, '/ask/python-github2/commit/%s' % self.commit_id)
        eq_(commit.author['login'], 'JNRowe')
        eq_(commit.id, self.commit_id)
        eq_(commit.committed_date, datetime(2011, 6, 6, 16, 13, 50))
        eq_(commit.authored_date, datetime(2011, 6, 6, 16, 13, 50))
        eq_(commit.tree, 'f48fcc1a0b8ea97f3147dc42cf7cdb6683493e94')
        eq_(commit.committer['login'], 'JNRowe')
        eq_(commit.added, None)
        eq_(commit.removed, None)
        eq_(commit.modified[0]['filename'],
            'github2/bin/manage_collaborators.py')

    def test_repr(self):
        commit = self.client.commits.show('ask/python-github2', self.commit_id)
        eq_(repr(commit),
            '<Commit: %s Added cache suppo...>' % self.commit_id[:8])


class CommitsQueries(utils.HttpMockTestCase):

    """Test commit querying"""

    def test_list(self):
        commits = self.client.commits.list('JNRowe/misc-overlay')
        eq_(len(commits), 35)
        eq_(commits[0].id, '4de0834d58b37ef3020c49df43c95649217a2def')

    def test_list_with_page(self):
        commits = self.client.commits.list('JNRowe/jnrowe-misc', page=2)
        eq_(len(commits), 35)
        eq_(commits[0].id, '1f5ad2c3206bafc4aca9e6ce50f5c605befdb3d6')

    def test_list_with_branch(self):
        commits = self.client.commits.list('JNRowe/misc-overlay', 'gh-pages')
        eq_(len(commits), 35)
        eq_(commits[0].id, '025148bdaa6fb6bdac9c3522d481fadf1c0a456f')

    def test_list_with_file(self):
        commits = self.client.commits.list('JNRowe/misc-overlay',
                                           file='Makefile')
        eq_(len(commits), 35)
        eq_(commits[0].id, 'fc12b924d34dc38c8ce76d27a866221faa88cb72')

    def test_list_with_branch_and_file(self):
        commits = self.client.commits.list('JNRowe/misc-overlay', 'gh-pages',
                                           'packages/dev-python.html')
        eq_(len(commits), 35)
        eq_(commits[0].id, '025148bdaa6fb6bdac9c3522d481fadf1c0a456f')

########NEW FILE########
__FILENAME__ = test_date_handling
# -*- coding: utf-8 -*-
# Copyright (C) 2011-2012 James Rowe <jnrowe@gmail.com>
#
# This file is part of python-github2, and is made available under the 3-clause
# BSD license.  See LICENSE for the full details.

from datetime import datetime as dt

from nose.tools import eq_

from github2.core import (datetime_to_ghdate, datetime_to_commitdate,
                          datetime_to_isodate, string_to_datetime)


# Commented test cases are in PST, and aren't correctly handled with the
# naïve datetime objects used in the current code base

def test_ghdate_to_datetime():
    eq_(string_to_datetime('2011/05/22 00:24:15 -0700'),
        dt(2011, 5, 22, 0, 24, 15))

    eq_(string_to_datetime('2009/04/18 13:04:09 -0700'),
        dt(2009, 4, 18, 13, 4, 9))
    #eq_(string_to_datetime('2009/11/12 21:15:17 -0800'),
    #    dt(2009, 11, 12, 21, 15, 17))
    #eq_(string_to_datetime('2009/11/12 21:16:20 -0800'),
    #    dt(2009, 11, 12, 21, 16, 20))
    eq_(string_to_datetime('2010/04/17 17:24:29 -0700'),
        dt(2010, 4, 17, 17, 24, 29))
    eq_(string_to_datetime('2010/05/18 06:10:36 -0700'),
        dt(2010, 5, 18, 6, 10, 36))
    eq_(string_to_datetime('2010/05/25 21:59:37 -0700'),
        dt(2010, 5, 25, 21, 59, 37))
    eq_(string_to_datetime('2010/05/26 17:08:41 -0700'),
        dt(2010, 5, 26, 17, 8, 41))
    eq_(string_to_datetime('2010/06/20 06:13:37 -0700'),
        dt(2010, 6, 20, 6, 13, 37))
    eq_(string_to_datetime('2010/07/28 12:56:51 -0700'),
        dt(2010, 7, 28, 12, 56, 51))
    eq_(string_to_datetime('2010/09/20 21:32:49 -0700'),
        dt(2010, 9, 20, 21, 32, 49))


def test_datetime_to_ghdate():
    eq_(datetime_to_ghdate(dt(2011, 5, 22, 0, 24, 15)),
        '2011/05/22 00:24:15 -0700')

    eq_(datetime_to_ghdate(dt(2009, 4, 18, 20, 4, 9)),
        '2009/04/18 20:04:09 -0700')
    #eq_(datetime_to_ghdate(dt(2009, 11, 13, 4, 15, 17)),
    #    '2009/11/13 04:15:17 -0800')
    #eq_(datetime_to_ghdate(dt(2009, 11, 13, 4, 16, 20)),
    #    '2009/11/13 04:16:20 -0800')
    eq_(datetime_to_ghdate(dt(2010, 4, 18, 0, 24, 29)),
        '2010/04/18 00:24:29 -0700')
    eq_(datetime_to_ghdate(dt(2010, 5, 18, 13, 10, 36)),
        '2010/05/18 13:10:36 -0700')
    eq_(datetime_to_ghdate(dt(2010, 5, 26, 5, 59, 37)),
        '2010/05/26 05:59:37 -0700')
    eq_(datetime_to_ghdate(dt(2010, 5, 27, 0, 8, 41)),
        '2010/05/27 00:08:41 -0700')
    eq_(datetime_to_ghdate(dt(2010, 6, 20, 13, 13, 37)),
        '2010/06/20 13:13:37 -0700')
    eq_(datetime_to_ghdate(dt(2010, 7, 28, 19, 56, 51)),
        '2010/07/28 19:56:51 -0700')
    eq_(datetime_to_ghdate(dt(2010, 9, 21, 4, 32, 49)),
        '2010/09/21 04:32:49 -0700')


def test_commitdate_to_datetime():
    eq_(string_to_datetime('2011-05-22T00:24:15-07:00'),
        dt(2011, 5, 22, 0, 24, 15))

    eq_(string_to_datetime('2011-04-09T10:07:30-07:00'),
        dt(2011, 4, 9, 10, 7, 30))
    #eq_(string_to_datetime('2011-02-19T07:16:11-08:00'),
    #    dt(2011, 2, 19, 7, 16, 11))
    #eq_(string_to_datetime('2010-12-21T12:34:27-08:00'),
    #    dt(2010, 12, 21, 12, 34, 27))
    eq_(string_to_datetime('2011-04-09T10:20:05-07:00'),
        dt(2011, 4, 9, 10, 20, 5))
    eq_(string_to_datetime('2011-04-09T10:05:58-07:00'),
        dt(2011, 4, 9, 10, 5, 58))
    eq_(string_to_datetime('2011-04-09T09:53:00-07:00'),
        dt(2011, 4, 9, 9, 53, 0))
    eq_(string_to_datetime('2011-04-09T10:00:21-07:00'),
        dt(2011, 4, 9, 10, 0, 21))
    #eq_(string_to_datetime('2010-12-16T15:10:59-08:00'),
    #    dt(2010, 12, 16, 15, 10, 59))
    eq_(string_to_datetime('2011-04-09T09:53:00-07:00'),
        dt(2011, 4, 9, 9, 53, 0))
    eq_(string_to_datetime('2011-04-09T09:53:00-07:00'),
        dt(2011, 4, 9, 9, 53, 0))


def test_datetime_to_commitdate():
    eq_(datetime_to_commitdate(dt(2011, 5, 22, 0, 24, 15)),
        '2011-05-22T00:24:15-07:00')

    eq_(datetime_to_commitdate(dt(2011, 4, 9, 10, 7, 30)),
        '2011-04-09T10:07:30-07:00')
    #eq_(datetime_to_commitdate(dt(2011, 2, 19, 7, 16, 11)),
    #    '2011-02-19T07:16:11-08:00')
    #eq_(datetime_to_commitdate(dt(2010, 12, 21, 12, 34, 27)),
    #    '2010-12-21T12:34:27-08:00')
    eq_(datetime_to_commitdate(dt(2011, 4, 9, 10, 20, 5)),
        '2011-04-09T10:20:05-07:00')
    eq_(datetime_to_commitdate(dt(2011, 4, 9, 10, 5, 58)),
        '2011-04-09T10:05:58-07:00')
    eq_(datetime_to_commitdate(dt(2011, 4, 9, 9, 53, 0)),
        '2011-04-09T09:53:00-07:00')
    eq_(datetime_to_commitdate(dt(2011, 4, 9, 10, 0, 21)),
        '2011-04-09T10:00:21-07:00')
    #eq_(datetime_to_commitdate(dt(2010, 12, 16, 15, 10, 59)),
    #    '2010-12-16T15:10:59-08:00')
    eq_(datetime_to_commitdate(dt(2011, 4, 9, 9, 53, 0)),
        '2011-04-09T09:53:00-07:00')
    eq_(datetime_to_commitdate(dt(2011, 4, 9, 9, 53, 0)),
        '2011-04-09T09:53:00-07:00')


def test_isodate_to_datetime():
    eq_(string_to_datetime('2011-05-22T00:24:15Z'), dt(2011, 5, 22, 0, 24, 15))
    eq_(string_to_datetime('2011-04-09T10:07:30Z'), dt(2011, 4, 9, 10, 7, 30))
    eq_(string_to_datetime('2011-02-19T07:16:11Z'), dt(2011, 2, 19, 7, 16, 11))
    eq_(string_to_datetime('2010-12-21T12:34:27Z'),
        dt(2010, 12, 21, 12, 34, 27))
    eq_(string_to_datetime('2011-04-09T10:20:05Z'), dt(2011, 4, 9, 10, 20, 5))
    eq_(string_to_datetime('2011-04-09T10:05:58Z'), dt(2011, 4, 9, 10, 5, 58))
    eq_(string_to_datetime('2011-04-09T09:53:00Z'), dt(2011, 4, 9, 9, 53, 0))
    eq_(string_to_datetime('2011-04-09T10:00:21Z'), dt(2011, 4, 9, 10, 0, 21))
    eq_(string_to_datetime('2010-12-16T15:10:59Z'),
        dt(2010, 12, 16, 15, 10, 59))
    eq_(string_to_datetime('2011-04-09T09:53:00Z'), dt(2011, 4, 9, 9, 53, 0))
    eq_(string_to_datetime('2011-04-09T09:53:00Z'), dt(2011, 4, 9, 9, 53, 0))


def test_datetime_to_isodate():
    eq_(datetime_to_isodate(dt(2011, 5, 22, 0, 24, 15)),
        '2011-05-22T00:24:15Z')
    eq_(datetime_to_isodate(dt(2011, 4, 9, 10, 7, 30)), '2011-04-09T10:07:30Z')
    eq_(datetime_to_isodate(dt(2011, 2, 19, 7, 16, 11)),
        '2011-02-19T07:16:11Z')
    eq_(datetime_to_isodate(dt(2010, 12, 21, 12, 34, 27)),
        '2010-12-21T12:34:27Z')
    eq_(datetime_to_isodate(dt(2011, 4, 9, 10, 20, 5)), '2011-04-09T10:20:05Z')
    eq_(datetime_to_isodate(dt(2011, 4, 9, 10, 5, 58)), '2011-04-09T10:05:58Z')
    eq_(datetime_to_isodate(dt(2011, 4, 9, 9, 53, 0)), '2011-04-09T09:53:00Z')
    eq_(datetime_to_isodate(dt(2011, 4, 9, 10, 0, 21)), '2011-04-09T10:00:21Z')
    eq_(datetime_to_isodate(dt(2010, 12, 16, 15, 10, 59)),
        '2010-12-16T15:10:59Z')
    eq_(datetime_to_isodate(dt(2011, 4, 9, 9, 53, 0)), '2011-04-09T09:53:00Z')
    eq_(datetime_to_isodate(dt(2011, 4, 9, 9, 53, 0)), '2011-04-09T09:53:00Z')

########NEW FILE########
__FILENAME__ = test_issues
# Copyright (C) 2011-2012 James Rowe <jnrowe@gmail.com>
#
# This file is part of python-github2, and is made available under the 3-clause
# BSD license.  See LICENSE for the full details.

from datetime import datetime

from nose.tools import eq_

import utils


class Issue(utils.HttpMockTestCase):
    def test_properties(self):
        issue = self.client.issues.show('ask/python-github2', 24)
        eq_(issue.position, 24.0)
        eq_(issue.number, 24)
        eq_(issue.votes, 0)
        eq_(len(issue.body), 164)
        eq_(issue.title, 'Pagination support for commits.')
        eq_(issue.user, 'svetlyak40wt')
        eq_(issue.state, 'open')
        eq_(issue.labels, [])
        eq_(issue.created_at, datetime(2010, 12, 8, 23, 50, 26))
        eq_(issue.closed_at, None)
        eq_(issue.updated_at, datetime(2011, 1, 4, 16, 26, 7))
        eq_(issue.diff_url,
            'https://github.com/ask/python-github2/pull/24.diff')
        eq_(issue.patch_url,
            'https://github.com/ask/python-github2/pull/24.patch')
        eq_(issue.pull_request_url,
            'https://github.com/ask/python-github2/pull/24')

    def test_issue_repr(self):
        issue = self.client.issues.show('ask/python-github2', 24)
        eq_(repr(issue), '<Issue: Pagination suppor...>')


class Comment(utils.HttpMockTestCase):
    def test_properties(self):
        comments = self.client.issues.comments('ask/python-github2', 24)
        comment = comments[0]
        eq_(comment.created_at, datetime(2010, 12, 9, 22, 37, 26))
        eq_(comment.updated_at, datetime(2010, 12, 9, 22, 37, 26))
        eq_(len(comment.body), 267)
        eq_(comment.id, 601871)
        eq_(comment.user, 'nvie')

    def test_comment_repr(self):
        comments = self.client.issues.comments('ask/python-github2', 24)
        eq_(repr(comments[1]), '<Comment: Sure, but I have ...>')


class IssueQueries(utils.HttpMockTestCase):

    """Test issue querying."""

    def test_search(self):
        issues = self.client.issues.search('ask/python-github2', 'timezone',
                                           'closed')
        eq_(len(issues), 2)
        eq_(issues[1].number, 39)

    def test_list(self):
        issues = self.client.issues.list('ask/python-github2')
        eq_(len(issues), 4)
        eq_(issues[-1].number, 58)

    def test_list_with_state(self):
        issues = self.client.issues.list('ask/python-github2', "closed")
        eq_(len(issues), 55)
        eq_(issues[0].number, 59)

    def test_issue_labels(self):
        labels = self.client.issues.list_labels('JNRowe/misc-overlay')
        eq_(len(labels), 4)
        eq_(labels[0], 'feature')

    def test_list_by_label(self):
        issues = self.client.issues.list_by_label('JNRowe/misc-overlay', 'bug')
        eq_(len(issues), 30)
        eq_(issues[-1].number, 328)

########NEW FILE########
__FILENAME__ = test_organizations
# Copyright (C) 2011-2012 James Rowe <jnrowe@gmail.com>
#
# This file is part of python-github2, and is made available under the 3-clause
# BSD license.  See LICENSE for the full details.

from datetime import datetime

from nose.tools import (eq_, ok_)

import utils


class OrganizationProperties(utils.HttpMockTestCase):
    def test_properties(self):
        organization = self.client.organizations.show('github')
        eq_(organization.id, 9919)
        eq_(organization.name, 'GitHub')
        eq_(organization.blog, 'https://github.com/about')
        eq_(organization.location, 'San Francisco, CA')
        eq_(organization.gravatar_id, '61024896f291303615bcd4f7a0dcfb74')
        eq_(organization.login, 'github')
        eq_(organization.email, 'support@github.com')
        eq_(organization.company, None)
        eq_(organization.created_at, datetime(2008, 5, 10, 21, 37, 31))
        eq_(organization.following_count, 0)
        eq_(organization.followers_count, 591)
        eq_(organization.public_gist_count, 0)
        eq_(organization.public_repo_count, 31)
        eq_(organization.permission, None)
        eq_(organization.plan, None)

    def test_is_authenticated(self):
        organization = self.client.organizations.show('github')
        ok_(organization.is_authenticated() is False)
        organization = self.client.organizations.show('fake_org_with_auth')
        ok_(organization.is_authenticated() is True)


class Organization(utils.HttpMockTestCase):
    def test_repr(self):
        organization = self.client.organizations.show('github')
        eq_(repr(organization), '<Organization: github>')


class OrganizationQueries(utils.HttpMockTestCase):
    """Test organisation querying"""
    def test_public_repositories(self):
        repos = self.client.organizations.public_repositories('github')
        eq_(len(repos), 31)
        eq_(repos[2].name, 'hubahuba')

    def test_public_members(self):
        members = self.client.organizations.public_members('github')
        eq_(len(members), 35)
        eq_(members[2].name, 'Ben Burkert')


class OrganizationsEdits(utils.HttpMockAuthenticatedTestCase):
    def test_add_team(self):
        team = self.client.organizations.add_team('JNRowe-test-org',
                                                  'test_pull', 'pull')
        eq_(team.name, 'team_pull')
        eq_(team.permission, 'pull')

    def test_add_team_with_repos(self):
        projects = ['JNRowe-test-org/test1', 'JNRowe-test-org/test2']
        team = self.client.organizations.add_team('JNRowe-test-org',
                                                  'test_push', 'push',
                                                  projects)

        team_repos = self.client.teams.repositories(team.id)
        eq_(['/'.join([x.organization, x.name]) for x in team_repos], projects)

########NEW FILE########
__FILENAME__ = test_pull_requests
# Copyright (C) 2011-2012 James Rowe <jnrowe@gmail.com>
#
# This file is part of python-github2, and is made available under the 3-clause
# BSD license.  See LICENSE for the full details.

from datetime import datetime

from nose.tools import eq_

import utils


class PullRequest(utils.HttpMockTestCase):
    def test_properties(self):
        pull_request = self.client.pull_requests.show('ask/python-github2', 39)
        eq_(pull_request.state, 'closed')
        eq_(pull_request.base['sha'],
                      '0786a96c80afad7bbd0747df590f649eaa46ca04')
        eq_(pull_request.head['sha'],
                      '5438e41d9c390f53089ed3fa0842831fafc73d8e')
        eq_(pull_request.issue_user['login'], 'JNRowe')
        eq_(pull_request.user['login'], 'JNRowe')
        eq_(pull_request.title, 'Datetime timezone handling.')
        eq_(len(pull_request.body), 1442)
        eq_(pull_request.position, 39.0)
        eq_(pull_request.number, 39.0)
        eq_(pull_request.votes, 0)
        eq_(pull_request.comments, 4)
        eq_(pull_request.diff_url,
            'https://github.com/ask/python-github2/pull/39.diff')
        eq_(pull_request.patch_url,
            'https://github.com/ask/python-github2/pull/39.patch')
        eq_(pull_request.labels, [])
        eq_(pull_request.html_url,
            'https://github.com/ask/python-github2/pull/39')
        eq_(pull_request.issue_created_at, datetime(2011, 4, 18, 15, 25, 47))
        eq_(pull_request.issue_updated_at, datetime(2011, 6, 23, 9, 33, 57))
        eq_(pull_request.created_at, datetime(2011, 6, 20, 16, 51, 24))
        eq_(pull_request.updated_at, datetime(2011, 6, 23, 9, 28, 42))
        eq_(pull_request.closed_at, datetime(2011, 6, 23, 9, 33, 57))
        eq_(len(pull_request.discussion), 13)
        eq_(pull_request.mergeable, True)

    def test_repr(self):
        pull_request = self.client.pull_requests.show('ask/python-github2', 39)
        eq_(repr(pull_request), '<PullRequest: Datetime timezone...>')


class PullRequestQueries(utils.HttpMockTestCase):
    """Test pull request querying"""
    def test_list(self):
        pull_requests = self.client.pull_requests.list('ask/python-github2')
        eq_(len(pull_requests), 1)
        eq_(pull_requests[0].title, 'Pagination support for commits.')

    def test_list_with_page(self):
        pull_requests = self.client.pull_requests.list('robbyrussell/oh-my-zsh',
                                                       page=2)
        eq_(len(pull_requests), 52)
        eq_(pull_requests[1].title, 'Added my own custom theme')

########NEW FILE########
__FILENAME__ = test_regression
# Copyright (C) 2011-2012 James Rowe <jnrowe@gmail.com>
#
# This file is part of python-github2, and is made available under the 3-clause
# BSD license.  See LICENSE for the full details.

import httplib2

from nose.tools import eq_

from github2.client import Github


def test_issue_50():
    """Erroneous init of ``Http`` with proxy setup.

    See https://github.com/ask/python-github2/pull/50
    """
    client = Github(proxy_host="my.proxy.com", proxy_port=9000)
    proxy_info = client.request._http.proxy_info
    eq_(type(proxy_info), httplib2.ProxyInfo)
    eq_(proxy_info.proxy_host, 'my.proxy.com')
    eq_(proxy_info.proxy_port, 9000)

########NEW FILE########
__FILENAME__ = test_repositories
# coding: utf-8
# Copyright (C) 2011-2012 James Rowe <jnrowe@gmail.com>
#                         Stéphane Angel <s.angel@twidi.com>
#
# This file is part of python-github2, and is made available under the 3-clause
# BSD license.  See LICENSE for the full details.

import datetime

from nose.tools import eq_

import utils


class Repo(utils.HttpMockTestCase):
    def test_repr(self):
        repo = self.client.repos.show('JNRowe/misc-overlay')
        eq_(repr(repo), '<Repository: JNRowe/misc-overlay>')


class RepoProperties(utils.HttpMockTestCase):

    """Test repository property handling."""

    def test_repo(self):
        repo = self.client.repos.show('JNRowe/misc-overlay')

        eq_(repo.name, 'misc-overlay')
        eq_(repo.description, 'Gentoo overlay -- miscellaneous packages')
        eq_(repo.url, 'https://github.com/JNRowe/misc-overlay')
        eq_(repo.owner, 'JNRowe')
        eq_(repo.homepage, 'http://jnrowe.github.com/misc-overlay/')

        eq_(repo.project, 'JNRowe/misc-overlay')

    def test_meta(self):
        repo = self.client.repos.show('JNRowe/misc-overlay')
        eq_(repo.forks, 0)
        eq_(repo.watchers, 5)
        eq_(repo.private, False)
        eq_(repo.fork, False)
        eq_(repo.master_branch, None)
        eq_(repo.integration_branch, None)
        eq_(repo.open_issues, 13)
        eq_(repo.created_at, datetime.datetime(2009, 5, 2, 7, 32, 50))
        eq_(repo.pushed_at, datetime.datetime(2011, 8, 11, 11, 46, 23))
        eq_(repo.has_downloads, True)
        eq_(repo.has_wiki, True)
        eq_(repo.has_issues, True)
        eq_(repo.language, 'Python')

    def test_fork_properties(self):
        repo = self.client.repos.show('JNRowe/python-github2')
        eq_(repo.forks, 0)
        eq_(repo.fork, True)
        eq_(repo.parent, 'ask/python-github2')
        eq_(repo.source, 'ask/python-github2')


class RepoQueries(utils.HttpMockTestCase):
    """Test repository querying"""
    def test_search(self):
        repos = self.client.repos.search('surfraw')
        eq_(len(repos), 8)
        eq_(repos[0].owner, 'JNRowe')

    def test_list(self):
        repos = self.client.repos.list('JNRowe')
        eq_(len(repos), 48)
        eq_(repos[0].name, 'bfm')

    def test_list_with_page(self):
        repos = self.client.repos.list('tekkub', page=2)
        eq_(len(repos), 37)
        eq_(repos[0].name, 'OhSnap')

    def test_watching(self):
        repos = self.client.repos.watching('JNRowe')
        eq_(len(repos), 90)
        eq_(repos[0].name, 'nerdtree')

    def test_watching_with_page(self):
        repos = self.client.repos.watching('tekkub', page=2)
        eq_(len(repos), 39)
        eq_(repos[0].name, 'Buffoon')

    def test_contributors(self):
        contributors = self.client.repos.list_contributors('ask/python-github2')
        eq_(len(contributors), 29)
        eq_(contributors[1].name, 'Ask Solem Hoel')

    def test_list_collaborators(self):
        collaborators = self.client.repos.list_collaborators('ask/python-github2')
        eq_(len(collaborators), 4)
        eq_(collaborators[2], 'JNRowe')

    def test_languages(self):
        languages = self.client.repos.languages('JNRowe/misc-overlay')
        eq_(len(languages), 2)
        eq_(languages['Python'], 11194)

    def test_tags(self):
        tags = self.client.repos.tags('ask/python-github2')
        eq_(len(tags), 7)
        eq_(tags['0.4.1'], '96b0a41dd249c521323700bc11a0a721a7c9e642')

    def test_branches(self):
        branches = self.client.repos.branches('ask/python-github2')
        eq_(len(branches), 1)
        eq_(branches['master'], '1c83cde9b5a7c396a01af1007fb7b88765b9ae45')

    def test_watchers(self):
        watchers = self.client.repos.watchers('ask/python-github2')
        eq_(len(watchers), 143)
        eq_(watchers[0], 'ask')


class AuthenticatedRepoQueries(utils.HttpMockAuthenticatedTestCase):
    def test_pushable(self):
        repos = self.client.repos.pushable()
        eq_(len(repos), 1)
        eq_(repos[0].name, 'python-github2')

########NEW FILE########
__FILENAME__ = test_request
# Copyright (C) 2011-2012 James Rowe <jnrowe@gmail.com>
#
# This file is part of python-github2, and is made available under the 3-clause
# BSD license.  See LICENSE for the full details.

import unittest

try:
    from urllib.parse import parse_qs  # For Python 3
except ImportError:
    try:
        from urlparse import parse_qs  # NOQA
    except ImportError:  # For Python <2.6
        from cgi import parse_qs  # NOQA

try:
    from nose.tools import (assert_dict_contains_subset, assert_dict_equal)
except ImportError:  # for Python <2.7
    import unittest2

    _binding = unittest2.TestCase('run')
    assert_dict_contains_subset = _binding.assertDictContainsSubset  # NOQA
    assert_dict_equal = _binding.assertDictEqual  # NOQA


from github2 import request


def assert_params(first, second):
    assert_dict_equal(first, parse_qs(second))


def assert_params_contain(first, second):
    assert_dict_contains_subset(first, parse_qs(second))


class TestAuthEncode(unittest.TestCase):

    """Test processing of authentication data."""

    def setUp(self):
        self.r = request.GithubRequest()

    def test_unauthenticated(self):
        assert_params({}, self.r.encode_authentication_data({}))

    def test_access_token(self):
        try:
            self.r.access_token = 'hex string'
            assert_params({'access_token': ['hex string', ]},
                          self.r.encode_authentication_data({}))
        finally:
            self.r.access_token = None

    def test_user_token(self):
        try:
            self.r.username = 'user'
            self.r.api_token = 'hex string'
            token_params = {'login': ['user', ], 'token': ['hex string', ]}
            assert_params(token_params, self.r.encode_authentication_data({}))
        finally:
            self.r.username = self.r.api_token = None


class TestParameterEncoding(unittest.TestCase):
    def setUp(self):
        self.r = request.GithubRequest()
        self.params = {
            'key1': 'value1',
            'key2': 'value2',
        }

    def test_no_parameters(self):
        assert_params({}, self.r.encode_authentication_data({}))

    def test_parameters(self):
        assert_params({'key1': ['value1', ], 'key2': ['value2', ]},
                      self.r.encode_authentication_data(self.params))

    def test_parameters_with_auth(self):
        try:
            self.r.username = 'user'
            self.r.api_token = 'hex string'
            assert_params({'key2': ['value2', ], 'login': ['user', ],
                           'token': ['hex string', ], 'key1': ['value1', ]},
                            self.r.encode_authentication_data(self.params))
        finally:
            self.r.username = ''
            self.r.api_token = ''

    def test_multivalue_parameters(self):
        multivals = {'key': ['value1', 'value2']}
        assert_params(multivals, self.r.encode_authentication_data(multivals))

########NEW FILE########
__FILENAME__ = test_teams
# Copyright (C) 2011-2012 James Rowe <jnrowe@gmail.com>
#
# This file is part of python-github2, and is made available under the 3-clause
# BSD license.  See LICENSE for the full details.

from nose.tools import eq_

import utils


class TeamEdits(utils.HttpMockAuthenticatedTestCase):
    def test_add_member(self):
        users = self.client.teams.add_member(121990, 'JNRowe')
        eq_(users[0].login, 'JNRowe')

########NEW FILE########
__FILENAME__ = test_tz_aware_date_handling
# -*- coding: utf-8 -*-
# Copyright (C) 2011-2012 James Rowe <jnrowe@gmail.com>
#
# This file is part of python-github2, and is made available under the 3-clause
# BSD license.  See LICENSE for the full details.

from datetime import datetime as dt

from dateutil.tz import tzutc
from nose.tools import eq_

from github2 import core
from github2.core import (datetime_to_ghdate, datetime_to_commitdate,
                          datetime_to_isodate, string_to_datetime)


def setup_module():
    """Enable timezone-aware datetime handling for this module's tests."""
    core.NAIVE = False


def teardown_module():
    """Disable timezone-aware datetime handling when tests have completed."""
    core.NAIVE = True


def dt_utz(year, month, day, hour, minute, second):
    """Produce a UTC-anchored datetime object.

    :see: :class:`datetime.datetime`

    """
    return dt(year, month, day, hour, minute, second, tzinfo=tzutc())


def test_ghdate_to_datetime():
    eq_(string_to_datetime('2011/05/22 00:24:15 -0700'),
        dt_utz(2011, 5, 22, 7, 24, 15))
    eq_(string_to_datetime('2009/04/18 13:04:09 -0700'),
        dt_utz(2009, 4, 18, 20, 4, 9))
    eq_(string_to_datetime('2009/11/12 21:15:17 -0800'),
        dt_utz(2009, 11, 13, 5, 15, 17))
    eq_(string_to_datetime('2009/11/12 21:16:20 -0800'),
        dt_utz(2009, 11, 13, 5, 16, 20))
    eq_(string_to_datetime('2010/04/17 17:24:29 -0700'),
        dt_utz(2010, 4, 18, 0, 24, 29))
    eq_(string_to_datetime('2010/05/18 06:10:36 -0700'),
        dt_utz(2010, 5, 18, 13, 10, 36))
    eq_(string_to_datetime('2010/05/25 21:59:37 -0700'),
        dt_utz(2010, 5, 26, 4, 59, 37))
    eq_(string_to_datetime('2010/05/26 17:08:41 -0700'),
        dt_utz(2010, 5, 27, 0, 8, 41))
    eq_(string_to_datetime('2010/06/20 06:13:37 -0700'),
        dt_utz(2010, 6, 20, 13, 13, 37))
    eq_(string_to_datetime('2010/07/28 12:56:51 -0700'),
        dt_utz(2010, 7, 28, 19, 56, 51))
    eq_(string_to_datetime('2010/09/20 21:32:49 -0700'),
        dt_utz(2010, 9, 21, 4, 32, 49))


def test_datetime_to_ghdate():
    eq_(datetime_to_ghdate(dt_utz(2011, 5, 22, 7, 24, 15)),
        '2011/05/22 00:24:15 -0700')
    eq_(datetime_to_ghdate(dt_utz(2009, 4, 18, 20, 4, 9)),
        '2009/04/18 13:04:09 -0700')
    eq_(datetime_to_ghdate(dt_utz(2009, 11, 13, 4, 15, 17)),
        '2009/11/12 20:15:17 -0800')
    eq_(datetime_to_ghdate(dt_utz(2009, 11, 13, 4, 16, 20)),
        '2009/11/12 20:16:20 -0800')
    eq_(datetime_to_ghdate(dt_utz(2010, 4, 18, 0, 24, 29)),
        '2010/04/17 17:24:29 -0700')
    eq_(datetime_to_ghdate(dt_utz(2010, 5, 18, 13, 10, 36)),
        '2010/05/18 06:10:36 -0700')
    eq_(datetime_to_ghdate(dt_utz(2010, 5, 26, 5, 59, 37)),
        '2010/05/25 22:59:37 -0700')
    eq_(datetime_to_ghdate(dt_utz(2010, 5, 27, 0, 8, 41)),
        '2010/05/26 17:08:41 -0700')
    eq_(datetime_to_ghdate(dt_utz(2010, 6, 20, 13, 13, 37)),
        '2010/06/20 06:13:37 -0700')
    eq_(datetime_to_ghdate(dt_utz(2010, 7, 28, 19, 56, 51)),
        '2010/07/28 12:56:51 -0700')
    eq_(datetime_to_ghdate(dt_utz(2010, 9, 21, 4, 32, 49)),
        '2010/09/20 21:32:49 -0700')


def test_commitdate_to_datetime():
    eq_(string_to_datetime('2011-05-22T00:24:15-07:00'),
        dt_utz(2011, 5, 22, 7, 24, 15))
    eq_(string_to_datetime('2011-04-09T10:07:30-07:00'),
        dt_utz(2011, 4, 9, 17, 7, 30))
    eq_(string_to_datetime('2011-02-19T07:16:11-08:00'),
        dt_utz(2011, 2, 19, 15, 16, 11))
    eq_(string_to_datetime('2010-12-21T12:34:27-08:00'),
        dt_utz(2010, 12, 21, 20, 34, 27))
    eq_(string_to_datetime('2011-04-09T10:20:05-07:00'),
        dt_utz(2011, 4, 9, 17, 20, 5))
    eq_(string_to_datetime('2011-04-09T10:05:58-07:00'),
        dt_utz(2011, 4, 9, 17, 5, 58))
    eq_(string_to_datetime('2011-04-09T09:53:00-07:00'),
        dt_utz(2011, 4, 9, 16, 53, 0))
    eq_(string_to_datetime('2011-04-09T10:00:21-07:00'),
        dt_utz(2011, 4, 9, 17, 0, 21))
    eq_(string_to_datetime('2010-12-16T15:10:59-08:00'),
        dt_utz(2010, 12, 16, 23, 10, 59))
    eq_(string_to_datetime('2011-04-09T09:53:00-07:00'),
        dt_utz(2011, 4, 9, 16, 53, 0))
    eq_(string_to_datetime('2011-04-09T09:53:00-07:00'),
        dt_utz(2011, 4, 9, 16, 53, 0))


def test_datetime_to_commitdate():
    eq_(datetime_to_commitdate(dt_utz(2011, 5, 22, 7, 24, 15)),
        '2011-05-22T00:24:15-07:00')
    eq_(datetime_to_commitdate(dt_utz(2011, 4, 9, 17, 7, 30)),
        '2011-04-09T10:07:30-07:00')
    eq_(datetime_to_commitdate(dt_utz(2011, 2, 19, 15, 16, 11)),
        '2011-02-19T07:16:11-08:00')
    eq_(datetime_to_commitdate(dt_utz(2010, 12, 21, 20, 34, 27)),
        '2010-12-21T12:34:27-08:00')
    eq_(datetime_to_commitdate(dt_utz(2011, 4, 9, 17, 20, 5)),
        '2011-04-09T10:20:05-07:00')
    eq_(datetime_to_commitdate(dt_utz(2011, 4, 9, 17, 5, 58)),
        '2011-04-09T10:05:58-07:00')
    eq_(datetime_to_commitdate(dt_utz(2011, 4, 9, 16, 53, 0)),
        '2011-04-09T09:53:00-07:00')
    eq_(datetime_to_commitdate(dt_utz(2011, 4, 9, 17, 0, 21)),
        '2011-04-09T10:00:21-07:00')
    eq_(datetime_to_commitdate(dt_utz(2010, 12, 16, 23, 10, 59)),
        '2010-12-16T15:10:59-08:00')
    eq_(datetime_to_commitdate(dt_utz(2011, 4, 9, 16, 53, 0)),
        '2011-04-09T09:53:00-07:00')
    eq_(datetime_to_commitdate(dt_utz(2011, 4, 9, 16, 53, 0)),
        '2011-04-09T09:53:00-07:00')


def test_isodate_to_datetime():
    eq_(string_to_datetime('2011-05-22T00:24:15Z'),
        dt_utz(2011, 5, 22, 0, 24, 15))
    eq_(string_to_datetime('2011-04-09T10:07:30Z'),
        dt_utz(2011, 4, 9, 10, 7, 30))
    eq_(string_to_datetime('2011-02-19T07:16:11Z'),
        dt_utz(2011, 2, 19, 7, 16, 11))
    eq_(string_to_datetime('2010-12-21T12:34:27Z'),
        dt_utz(2010, 12, 21, 12, 34, 27))
    eq_(string_to_datetime('2011-04-09T10:20:05Z'),
        dt_utz(2011, 4, 9, 10, 20, 5))
    eq_(string_to_datetime('2011-04-09T10:05:58Z'),
        dt_utz(2011, 4, 9, 10, 5, 58))
    eq_(string_to_datetime('2011-04-09T09:53:00Z'),
        dt_utz(2011, 4, 9, 9, 53, 0))
    eq_(string_to_datetime('2011-04-09T10:00:21Z'),
        dt_utz(2011, 4, 9, 10, 0, 21))
    eq_(string_to_datetime('2010-12-16T15:10:59Z'),
        dt_utz(2010, 12, 16, 15, 10, 59))
    eq_(string_to_datetime('2011-04-09T09:53:00Z'),
        dt_utz(2011, 4, 9, 9, 53, 0))
    eq_(string_to_datetime('2011-04-09T09:53:00Z'),
        dt_utz(2011, 4, 9, 9, 53, 0))


def test_datetime_to_isodate():
    eq_(datetime_to_isodate(dt_utz(2011, 5, 22, 0, 24, 15)),
        '2011-05-22T00:24:15Z')
    eq_(datetime_to_isodate(dt_utz(2011, 4, 9, 10, 7, 30)),
        '2011-04-09T10:07:30Z')
    eq_(datetime_to_isodate(dt_utz(2011, 2, 19, 7, 16, 11)),
        '2011-02-19T07:16:11Z')
    eq_(datetime_to_isodate(dt_utz(2010, 12, 21, 12, 34, 27)),
        '2010-12-21T12:34:27Z')
    eq_(datetime_to_isodate(dt_utz(2011, 4, 9, 10, 20, 5)),
        '2011-04-09T10:20:05Z')
    eq_(datetime_to_isodate(dt_utz(2011, 4, 9, 10, 5, 58)),
        '2011-04-09T10:05:58Z')
    eq_(datetime_to_isodate(dt_utz(2011, 4, 9, 9, 53, 0)),
        '2011-04-09T09:53:00Z')
    eq_(datetime_to_isodate(dt_utz(2011, 4, 9, 10, 0, 21)),
        '2011-04-09T10:00:21Z')
    eq_(datetime_to_isodate(dt_utz(2010, 12, 16, 15, 10, 59)),
        '2010-12-16T15:10:59Z')
    eq_(datetime_to_isodate(dt_utz(2011, 4, 9, 9, 53, 0)),
        '2011-04-09T09:53:00Z')
    eq_(datetime_to_isodate(dt_utz(2011, 4, 9, 9, 53, 0)),
        '2011-04-09T09:53:00Z')

########NEW FILE########
__FILENAME__ = test_unit
# -*- coding: utf-8 -*-
# Copyright (C) 2010-2012 Adam Vandenberg <flangy@gmail.com>
#                         James Rowe <jnrowe@gmail.com>
#                         Jeremy Dunck <jdunck@gmail.com>
#                         modocache <modocache@gmail.com>
#
# This file is part of python-github2, and is made available under the 3-clause
# BSD license.  See LICENSE for the full details.

import unittest

from mock import patch
from nose.tools import (eq_, ok_, raises)

from github2.core import (AuthError, repr_string, requires_auth)
from github2.issues import Issue
from github2.client import Github

import utils


class ReprTests(unittest.TestCase):

    """__repr__ must return strings, not unicode objects."""

    def test_issue(self):
        """Issues can have non-ASCII characters in the title."""
        title = 'abcdé'
        i = Issue(title=title)
        eq_(str, type(repr(i)))


class HostSetting(unittest.TestCase):
    def test_default_host(self):
        client = Github()
        eq_(client.request.github_url, 'https://github.com')

    def test_non_standard_host(self):
        client = Github(github_url="http://your-github-enterprise-url.com/")
        eq_(client.request.github_url,
            'http://your-github-enterprise-url.com/')


class RateLimits(utils.HttpMockTestCase):

    """Test API rate-limiting."""

    @patch('github2.request.time.sleep')
    def test_delays(self, sleep):
        """Test calls in quick succession are delayed."""
        client = Github(requests_per_second=.5)
        client.users.show('defunkt')
        client.users.show('mojombo')

        # 0.5 requests per second, means a two second delay
        sleep.assert_called_once_with(2.0)


class BaseDataIter(utils.HttpMockTestCase):

    """Test iter availability of objects."""

    def test_iter(self):
        commit_id = '1c83cde9b5a7c396a01af1007fb7b88765b9ae45'
        commit = self.client.commits.show('ask/python-github2', commit_id)
        ok_('__iter__' in dir(commit))


class BaseDataDict(utils.HttpMockTestCase):

    """Test dict compatibility on objects."""

    def test_getitem(self):
        user = self.client.users.show('defunkt')
        eq_(user['blog'], user.blog)
        eq_(user['company'], user.company)
        eq_(user['email'], user.email)
        eq_(user['location'], user.location)
        eq_(user['login'], user.login)
        eq_(user['name'], user.name)

    @raises(KeyError)
    def test_getitem_failure(self):
        user = self.client.users.show('defunkt')
        ok_(user['invalid_key'])

    def test_setitem(self):
        user = self.client.users.show('defunkt')
        user['blog'] = 'http://example.com'
        eq_(user['blog'], 'http://example.com')

    @raises(KeyError)
    def test_setitem_failure(self):
        user = self.client.users.show('defunkt')
        user['invalid_key'] = 'test'


def test_project_for_user_repo():
    client = Github()
    eq_(client.project_for_user_repo('JNRowe', 'misc-overlay'),
                  'JNRowe/misc-overlay')


def test_repr_string():
    eq_(repr_string('test'), 'test')
    eq_(repr_string('abcdefghijklmnopqrst'), 'abcdefghijklmnopqrst')
    eq_(repr_string('abcdefghijklmnopqrstu'), 'abcdefghijklmnopq...')


class RequiresAuth(utils.HttpMockTestCase):
    @raises(AuthError)
    def test_no_auth(self):
        f = lambda: None
        f.__doc__ = 'test func'
        wrapped = requires_auth(f)
        wrapped(self.client)

########NEW FILE########
__FILENAME__ = test_user
# Copyright (C) 2011-2012 James Rowe <jnrowe@gmail.com>
#
# This file is part of python-github2, and is made available under the 3-clause
# BSD license.  See LICENSE for the full details.

import datetime

from nose.tools import (eq_, assert_false, ok_)

import utils


class UserProperties(utils.HttpMockTestCase):

    """Test user property handling."""

    def test_user(self):
        user = self.client.users.show('defunkt')
        eq_(user.blog, 'http://chriswanstrath.com/')
        eq_(user.company, 'GitHub')
        eq_(user.email, 'chris@wanstrath.com')
        eq_(user.location, 'San Francisco')
        eq_(user.login, 'defunkt')
        eq_(user.name, 'Chris Wanstrath')

    def test_meta(self):
        user = self.client.users.show('defunkt')
        eq_(user.created_at, datetime.datetime(2007, 10, 19, 22, 24, 19))
        eq_(user.followers_count, 3402)
        eq_(user.following_count, 212)
        eq_(user.gravatar_id, 'b8dbb1987e8e5318584865f880036796')
        eq_(user.id, 2)
        eq_(user.public_gist_count, 278)
        eq_(user.public_repo_count, 93)

    def test_followers(self):
        eq_(len(self.client.users.followers('defunkt')), 3402)

    def test_following(self):
        eq_(len(self.client.users.following('defunkt')), 212)

    def test_is_not_authenticated(self):
        user = self.client.users.show('defunkt')
        ok_(user.is_authenticated() is False)


class UserQueries(utils.HttpMockTestCase):

    """Test user querying."""

    def test_search(self):
        eq_(repr(self.client.users.search('James Rowe')),
            '[<User: JNRowe>, <User: wooki>]')

    def test_search_by_email(self):
        user = self.client.users.search_by_email('jnrowe@gmail.com')
        eq_(repr(user), '<User: JNRowe>')


class AuthenticatedUserMethods(utils.HttpMockAuthenticatedTestCase):
    def test_follow(self):
        result = self.client.users.follow('defunkt')
        ok_('defunkt' in result['users'])

    def test_unfollow(self):
        result = self.client.users.unfollow('defunkt')
        assert_false('defunkt' in result['users'])

    def test_is_authenticated(self):
        user = self.client.users.show('')
        ok_(user.is_authenticated() is True)

    def test_list_keys(self):
        keys = self.client.users.list_keys()
        eq_(keys[0].id, 1337)


class AuthenticatedUserProperties(utils.HttpMockAuthenticatedTestCase):
    def test_private_data(self):
        user = self.client.users.show('')
        eq_(user.total_private_repo_count, 0)
        eq_(user.collaborators, 0)
        eq_(user.disk_usage, 66069)
        eq_(user.owned_private_repo_count, 0)
        eq_(user.private_gist_count, 7)

    def test_plan_data(self):
        user = self.client.users.show('')
        eq_(user.plan['name'], "free")
        eq_(user.plan['collaborators'], 0)
        eq_(user.plan['space'], 307200)
        eq_(user.plan['private_repos'], 0)

########NEW FILE########
__FILENAME__ = utils
# Copyright (C) 2011-2012 James Rowe <jnrowe@gmail.com>
#
# This file is part of python-github2, and is made available under the 3-clause
# BSD license.  See LICENSE for the full details.

import os
import sys
import unittest

from email import message_from_file

import httplib2

from mock import Mock

from github2.client import Github
from github2.request import charset_from_headers


if sys.version_info[0] == 2:
    bytes = lambda x, enc: x


ORIG_REQUEST_METHOD = httplib2.Http.request


def request_mock(uri, method='GET', body=None, headers=None,
              redirections=5, connection_type=None):
    """Http mock side effect that returns saved entries.

    Implementation tests should never span network boundaries.

    """

    file = os.path.join("tests/data", httplib2.safename(uri))
    if os.path.exists(file):
        response = message_from_file(open(file))
        headers = httplib2.Response(response)
        body = bytes(response.get_payload(), charset_from_headers(headers))
        return (headers, body)
    else:
        return (httplib2.Response({"status": "404"}),
                "Resource %r unavailable from test data store" % file)


class HttpMockTestCase(unittest.TestCase):
    def setUp(self):
        """Prepare test fixtures.

        `httplib2.Http` is patched to return cached entries via
        :class:`HttpMock`.

        :attr:`client` is an unauthenticated :obj:`Github` object for easy use
        in tests.

        """
        httplib2.Http.request = Mock(spec_set=httplib2.Http.request,
                                     side_effect=request_mock)
        self.client = Github()

    def tearDown(self):
        """Remove test fixtures.

        `httplib2.Http` is returned to its original state.

        """
        httplib2.Http.request = ORIG_REQUEST_METHOD


class HttpMockAuthenticatedTestCase(HttpMockTestCase):
    def setUp(self):
        """Prepare test fixtures.

        :see: :class:`HttpMockTestCase`

        :attr:`client` is an authenticated :obj:`Github` object for easy use
        in tests.

        """
        httplib2.Http.request = Mock(spec_set=httplib2.Http.request,
                                     side_effect=request_mock)
        self.client = Github(access_token='xxx')

########NEW FILE########
