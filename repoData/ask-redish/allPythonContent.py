__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
import sys
import os

# If your extensions are in another directory, add it here. If the directory
# is relative to the documentation root, use os.path.abspath to make it
# absolute, like shown here.
sys.path.insert(0, "../")
import redish

# General configuration
# ---------------------

# Add any Sphinx extension module names here, as strings.
# They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['.templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'redish'
copyright = u'2010, Ask Solem <askh@opera.com>'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = ".".join(map(str, redish.VERSION[0:2]))
# The full version, including alpha/beta/rc tags.
release = redish.__version__

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['.build']

# The reST default role (used for this markup: `text`) to use for all
# documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'trac'

#html_translator_class = "djangodocs.DjangoHTMLTranslator"


# Options for HTML output
# -----------------------

# The style sheet to use for HTML and HTML Help pages. A file of that name
# must exist either in Sphinx' static/ path, or in one of the custom paths
# given in html_static_path.
#html_style = 'agogo.css'

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['.static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
html_use_modindex = True

# If false, no index is generated.
html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, the reST sources are included in the HTML build as _sources/<name>.
#html_copy_source = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'redishdoc'


# Options for LaTeX output
# ------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, document class
# [howto/manual]).
latex_documents = [
  ('index', 'redish.tex', ur'redish Documentation',
   ur'Ask Solem', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True

html_theme = "nature"
html_theme_path = ["_theme"]

########NEW FILE########
__FILENAME__ = applyxrefs
"""Adds xref targets to the top of files."""

import sys
import os

testing = False

DONT_TOUCH = (
        './index.txt',
        )


def target_name(fn):
    if fn.endswith('.txt'):
        fn = fn[:-4]
    return '_' + fn.lstrip('./').replace('/', '-')


def process_file(fn, lines):
    lines.insert(0, '\n')
    lines.insert(0, '.. %s:\n' % target_name(fn))
    try:
        f = open(fn, 'w')
    except IOError:
        print("Can't open %s for writing. Not touching it." % fn)
        return
    try:
        f.writelines(lines)
    except IOError:
        print("Can't write to %s. Not touching it." % fn)
    finally:
        f.close()


def has_target(fn):
    try:
        f = open(fn, 'r')
    except IOError:
        print("Can't open %s. Not touching it." % fn)
        return (True, None)
    readok = True
    try:
        lines = f.readlines()
    except IOError:
        print("Can't read %s. Not touching it." % fn)
        readok = False
    finally:
        f.close()
        if not readok:
            return (True, None)

    #print fn, len(lines)
    if len(lines) < 1:
        print("Not touching empty file %s." % fn)
        return (True, None)
    if lines[0].startswith('.. _'):
        return (True, None)
    return (False, lines)


def main(argv=None):
    if argv is None:
        argv = sys.argv

    if len(argv) == 1:
        argv.extend('.')

    files = []
    for root in argv[1:]:
        for (dirpath, dirnames, filenames) in os.walk(root):
            files.extend([(dirpath, f) for f in filenames])
    files.sort()
    files = [os.path.join(p, fn) for p, fn in files if fn.endswith('.txt')]
    #print files

    for fn in files:
        if fn in DONT_TOUCH:
            print("Skipping blacklisted file %s." % fn)
            continue

        target_found, lines = has_target(fn)
        if not target_found:
            if testing:
                print '%s: %s' % (fn, lines[0]),
            else:
                print "Adding xref to %s" % fn
                process_file(fn, lines)
        else:
            print "Skipping %s: already has a xref" % fn

if __name__ == '__main__':
    sys.exit(main())

########NEW FILE########
__FILENAME__ = literals_to_xrefs
"""
Runs through a reST file looking for old-style literals, and helps replace them
with new-style references.
"""

import re
import sys
import shelve

refre = re.compile(r'``([^`\s]+?)``')

ROLES = (
    'attr',
    'class',
    "djadmin",
    'data',
    'exc',
    'file',
    'func',
    'lookup',
    'meth',
    'mod',
    "djadminopt",
    "ref",
    "setting",
    "term",
    "tfilter",
    "ttag",

    # special
    "skip",
)

ALWAYS_SKIP = [
    "NULL",
    "True",
    "False",
]


def fixliterals(fname):
    data = open(fname).read()

    last = 0
    new = []
    storage = shelve.open("/tmp/literals_to_xref.shelve")
    lastvalues = storage.get("lastvalues", {})

    for m in refre.finditer(data):

        new.append(data[last:m.start()])
        last = m.end()

        line_start = data.rfind("\n", 0, m.start())
        line_end = data.find("\n", m.end())
        prev_start = data.rfind("\n", 0, line_start)
        next_end = data.find("\n", line_end + 1)

        # Skip always-skip stuff
        if m.group(1) in ALWAYS_SKIP:
            new.append(m.group(0))
            continue

        # skip when the next line is a title
        next_line = data[m.end():next_end].strip()
        if next_line[0] in "!-/:-@[-`{-~" and \
                all(c == next_line[0] for c in next_line):
            new.append(m.group(0))
            continue

        sys.stdout.write("\n"+"-"*80+"\n")
        sys.stdout.write(data[prev_start+1:m.start()])
        sys.stdout.write(colorize(m.group(0), fg="red"))
        sys.stdout.write(data[m.end():next_end])
        sys.stdout.write("\n\n")

        replace_type = None
        while replace_type is None:
            replace_type = raw_input(
                colorize("Replace role: ", fg="yellow")).strip().lower()
            if replace_type and replace_type not in ROLES:
                replace_type = None

        if replace_type == "":
            new.append(m.group(0))
            continue

        if replace_type == "skip":
            new.append(m.group(0))
            ALWAYS_SKIP.append(m.group(1))
            continue

        default = lastvalues.get(m.group(1), m.group(1))
        if default.endswith("()") and \
                replace_type in ("class", "func", "meth"):
            default = default[:-2]
        replace_value = raw_input(
            colorize("Text <target> [", fg="yellow") + default + \
                    colorize("]: ", fg="yellow")).strip()
        if not replace_value:
            replace_value = default
        new.append(":%s:`%s`" % (replace_type, replace_value))
        lastvalues[m.group(1)] = replace_value

    new.append(data[last:])
    open(fname, "w").write("".join(new))

    storage["lastvalues"] = lastvalues
    storage.close()

#
# The following is taken from django.utils.termcolors and is copied here to
# avoid the dependancy.
#


def colorize(text='', opts=(), **kwargs):
    """
    Returns your text, enclosed in ANSI graphics codes.

    Depends on the keyword arguments 'fg' and 'bg', and the contents of
    the opts tuple/list.

    Returns the RESET code if no parameters are given.

    Valid colors:
        'black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white'

    Valid options:
        'bold'
        'underscore'
        'blink'
        'reverse'
        'conceal'
        'noreset' - string will not be auto-terminated with the RESET code

    Examples:
        colorize('hello', fg='red', bg='blue', opts=('blink',))
        colorize()
        colorize('goodbye', opts=('underscore',))
        print colorize('first line', fg='red', opts=('noreset',))
        print 'this should be red too'
        print colorize('and so should this')
        print 'this should not be red'
    """
    color_names = ('black', 'red', 'green', 'yellow',
                   'blue', 'magenta', 'cyan', 'white')
    foreground = dict([(color_names[x], '3%s' % x) for x in range(8)])
    background = dict([(color_names[x], '4%s' % x) for x in range(8)])

    RESET = '0'
    opt_dict = {'bold': '1',
                'underscore': '4',
                'blink': '5',
                'reverse': '7',
                'conceal': '8'}

    text = str(text)
    code_list = []
    if text == '' and len(opts) == 1 and opts[0] == 'reset':
        return '\x1b[%sm' % RESET
    for k, v in kwargs.iteritems():
        if k == 'fg':
            code_list.append(foreground[v])
        elif k == 'bg':
            code_list.append(background[v])
    for o in opts:
        if o in opt_dict:
            code_list.append(opt_dict[o])
    if 'noreset' not in opts:
        text = text + '\x1b[%sm' % RESET
    return ('\x1b[%sm' % ';'.join(code_list)) + text

if __name__ == '__main__':
    try:
        fixliterals(sys.argv[1])
    except (KeyboardInterrupt, SystemExit):
        print

########NEW FILE########
__FILENAME__ = feedentries
from redish.utils import maybe_datetime
from redish.models import Model, Manager


class Entry(Model):

    def post_save(self):
        self.guid_index.add(self.guid)
        self.sort_index.add(self.id, maybe_datetime(self.timestamp))

    def post_delete(self):
        self.guid_index.remove(self.guid)
        self.sort_index.remove(self.id)

    @property
    def guid_index(self):
        return self.objects.Set((self.feed_url, "guid"))

    @property
    def sort_index(self):
        return self.objects.SortedSet((self.feed_url, "sort"))


class Entries(Manager):
    db = "feeds"
    model = Entry


if __name__ == "__main__":
    from datetime import datetime
    posts = Entries(host="localhost")

    feed1 = dict(feed_url="http://rss.com/example",
                 title="Example Post",
                 guid="http://rss.com/example/1",
                 link="http://rss.com/example/1",
                 content="This is an example",
                 timestamp=datetime.now())
    entry = posts.Entry(**data)
    entry_id = entry.save()
    assert entry_id == entry.id

    stored = posts.get(entry_id)
    stored.content = "Content has been changed"
    entry_id = stored.save()
    assert stored.id == new_id)
    again = posts.get(entry_id)

    stored.delete()

    feed2 = posts.create(**data)

    for post in iter(posts):
        print("(%s) %s" % (post.id, post.title))

########NEW FILE########
__FILENAME__ = pavement
from paver.easy import *
from paver import doctools
from paver.setuputils import setup

options(
        sphinx=Bunch(builddir=".build"),
)

def sphinx_builddir(options):
    return path("docs") / options.sphinx.builddir / "html"


@task
def clean_docs(options):
    sphinx_builddir(options).rmtree()


@task
@needs("clean_docs", "paver.doctools.html")
def html(options):
    destdir = path("Documentation")
    destdir.rmtree()
    builtdocs = sphinx_builddir(options)
    builtdocs.move(destdir)


@task
@needs("clean_docs", "paver.doctools.html")
def ghdocs(options):
    builtdocs = sphinx_builddir(options)
    sh("sphinx-to-github", cwd=builtdocs)
    sh("git checkout gh-pages && \
            cp -r %s/* .    && \
            git commit . -m 'Rendered documentation for Github Pages.' && \
            git push origin gh-pages && \
            git checkout master" % builtdocs)


@task
@needs("clean_docs", "paver.doctools.html")
def upload_pypi_docs(options):
    builtdocs = path("docs") / options.builddir / "html"
    sh("python setup.py upload_sphinx --upload-dir='%s'" % (builtdocs))


@task
@needs("upload_pypi_docs", "ghdocs")
def upload_docs(options):
    pass


@task
def flakes(options):
    sh("find redish -name '*.py' | xargs pyflakes")


@task
def clean_readme(options):
    path("README").unlink()
    path("README.rst").unlink()


@task
@needs("clean_readme")
def readme(options):
    sh("python contrib/release/sphinx-to-rst.py docs/templates/readme.txt \
            > README.rst")
    sh("ln -sf README.rst README")


@task
def bump(options):
    sh("bump -c redish")


@task
@cmdopts([
    ("coverage", "c", "Enable coverage"),
    ("quick", "q", "Quick test"),
    ("verbose", "V", "Make more noise"),
])
def test(options):
    cmd = "python manage.py test"
    if getattr(options, "coverage", False):
        cmd += " --coverage"
    if getattr(options, "quick", False):
        cmd = "env QUICKTEST=1 %s" % cmd
    if getattr(options, "verbose", False):
        cmd += " --verbosity=2"
    sh(cmd, cwd="tests")


@task
@cmdopts([
    ("noerror", "E", "Ignore errors"),
])
def pep8(options):
    noerror = getattr(options, "noerror", False)
    return sh("""find . -name "*.py" | xargs pep8 | perl -nle'\
            print; $a=1 if $_}{exit($a)'""", ignore_error=noerror)


@task
def removepyc(options):
    sh("find . -name '*.pyc' | xargs rm")


@task
@needs("removepyc")
def gitclean(options):
    sh("git clean -xdn")


@task
@needs("removepyc")
def gitcleanforce(options):
    sh("git clean -xdf")


@task
@needs("pep8", "test", "gitclean")
def releaseok(options):
    pass


@task
@needs("releaseok", "removepyc", "upload_docs")
def release(options):
    pass

########NEW FILE########
__FILENAME__ = client
from redis import Redis as _RedisClient
from redis.exceptions import ResponseError

from redish import types
from redish.utils import mkey
from redish.serialization import Pickler

DEFAULT_PORT = 6379


class Client(object):
    """Redis Client

    :keyword host: Hostname of the Redis server to connect to.
        Default is ``"localhost"``.
    :keyword port: Port of the server to connect to.
        Default is ``6379``.
    :keyword db: Name of the database to use.
        Default is to use the default database.
    :keyword serializer: Object used to serialize/deserialize values.
        Must support the methods ``serialize(value)`` and
        ``deserialize(value)``. The default is to use
        :class:`redish.serialization.Pickler`.

    """

    host = "localhost"
    port = DEFAULT_PORT
    db = None
    serializer = Pickler()
    #serializer = anyjson

    def __init__(self, host=None, port=None, db=None,
            serializer=None, **kwargs):
        self.host = host or self.host
        self.port = port or self.port
        self.serializer = serializer or self.serializer
        self.db = db or self.db
        self.api = _RedisClient(self.host, self.port, self.db, **kwargs)

    def id(self, name):
        """Return the next id for a name."""
        return types.Id(name, self.api)

    def List(self, name, initial=None):
        """The list datatype.

        :param name: The name of the list.
        :keyword initial: Initial contents of the list.

        See :class:`redish.types.List`.

        """
        return types.List(name, self.api, initial=initial)

    def Set(self, name, initial=None):
        """The set datatype.

        :param name: The name of the set.
        :keyword initial: Initial members of the set.

        See :class:`redish.types.Set`.

        """
        return types.Set(name, self.api, initial)


    def SortedSet(self, name, initial=None):
        """The sorted set datatype.

        :param name: The name of the sorted set.
        :param initial: Initial members of the set as an iterable
           of ``(element, score)`` tuples.

        See :class:`redish.types.SortedSet`.

        """
        return types.SortedSet(name, self.api, initial)

    def Dict(self, name, initial=None, **extra):
        """The dictionary datatype (Hash).

        :param name: The name of the dictionary.
        :keyword initial: Initial contents.
        :keyword \*\*extra: Initial contents as keyword arguments.

        The ``initial``, and ``**extra`` keyword arguments
        will be merged (keyword arguments has priority).

        See :class:`redish.types.Dict`.

        """
        return types.Dict(name, self.api, initial=initial, **extra)

    def Queue(self, name, initial=None, maxsize=None):
        """The queue datatype.

        :param name: The name of the queue.
        :keyword initial: Initial items in the queue.

        See :class:`redish.types.Queue`.

        """
        return types.Queue(name, self.api, initial=initial, maxsize=maxsize)

    def LifoQueue(self, name, initial=None, maxsize=None):
        """The LIFO queue datatype.

        :param name: The name of the queue.
        :keyword initial: Initial items in the queue.

        See :class:`redish.types.LifoQueue`.

        """
        return types.LifoQueue(name, self.api,
                               initial=initial, maxsize=maxsize)

    def prepare_value(self, value):
        """Encode python object to be stored in the database."""
        return self.serializer.encode(value)

    def value_to_python(self, value):
        """Decode value to a Python object."""
        return self.serializer.decode(value)

    def clear(self):
        """Remove all keys from the current database."""
        return self.api.flushdb()

    def update(self, mapping):
        """Update database with the key/values from a :class:`dict`."""
        return self.api.mset(dict((key, self.prepare_value(value))
                                for key, value in mapping.items()))

    def rename(self, old_name, new_name):
        """Rename key to a new name."""
        try:
            self.api.rename(mkey(old_name), mkey(new_name))
        except ResponseError, exc:
            if "no such key" in exc.args:
                raise KeyError(old_name)
            raise

    def keys(self, pattern="*"):
        """Get a list of all the keys in the database, or
        matching ``pattern``."""
        return self.api.keys(pattern)

    def iterkeys(self, pattern="*"):
        """An iterator over all the keys in the database, or matching
        ``pattern``."""
        return iter(self.keys(pattern))

    def iteritems(self, pattern="*"):
        """An iterator over all the ``(key, value)`` items in the database,
        or where the keys matches ``pattern``."""
        for key in self.keys(pattern):
            yield (key, self[key])

    def items(self, pattern="*"):
        """Get a list of all the ``(key, value)`` pairs in the database,
        or the keys matching ``pattern``, as 2-tuples."""
        return list(self.iteritems(pattern))

    def itervalues(self, pattern="*"):
        """Iterate over all the values in the database, or those where the
        keys matches ``pattern``."""
        for key, value in self.iteritems(pattern):
            yield value

    def values(self, pattern="*"):
        """Get a list of all values in the database, or those where the
        keys matches ``pattern``."""
        return list(self.itervalues(pattern))

    def pop(self, name):
        """Get and remove key from database (atomic)."""
        name = mkey(name)
        temp = mkey((name, "__poptmp__"))
        self.rename(name, temp)
        value = self[temp]
        del(self[temp])
        return value

    def get(self, key, default=None):
        """Returns the value at ``key`` if present, otherwise returns
        ``default`` (``None`` by default.)"""
        try:
            return self[key]
        except KeyError:
            return default

    def __getitem__(self, name):
        """``x.__getitem__(name) <==> x[name]``"""
        name = mkey(name)
        value = self.api.get(name)
        if value is None:
            raise KeyError(name)
        return self.value_to_python(value)

    def __setitem__(self, name, value):
        """``x.__setitem(name, value) <==> x[name] = value``"""
        return self.api.set(mkey(name), self.prepare_value(value))

    def __delitem__(self, name):
        """``x.__delitem__(name) <==> del(x[name])``"""
        name = mkey(name)
        if not self.api.delete(name):
            raise KeyError(name)

    def __len__(self):
        """``x.__len__() <==> len(x)``"""
        return self.api.dbsize()

    def __contains__(self, name):
        """``x.__contains__(name) <==> name in x``"""
        return self.api.exists(mkey(name))

    def __repr__(self):
        """``x.__repr__() <==> repr(x)``"""
        return "<RedisClient: %s:%s/%s>" % (self.host,
                                           self.port,
                                           self.db or "")

########NEW FILE########
__FILENAME__ = models
from redish.client import Client


class ModelType(type):
    """Metaclass for :class:`Model`s."""

    def __new__(cls, name, bases, attrs):
        attrs.setdefault("name", name)
        protected_attrs = set(attrs.keys())
        for base in bases:
            protected_attrs.update(set(vars(base).keys()))
        attrs["_protected"] = protected_attrs
        return super(ModelType, cls).__new__(cls, name, bases, attrs)


def _unpickle_model(model, id, fields):
    return model(id=id, **fields)


class Model(dict):
    """A Model.

    :param manager: The :class:`Manager` for this model.
    :keyword id: Id of the entry, ``None`` if the entry has not been
        created yet.
    :keyword \*\*fields: Values of the entry.

    .. attribute:: name

        Name of the model.
        **REQUIRED**

        All models needs a name, this name is used to keep track of ids
        related to this model.

    .. attribute:: id

        The unique id for this entry.
        If the entry does not have an id, it means the entry has not yet
        been created and a new id will be automatically assigned when saved.

    .. attribute:: objects

        :class:`Manager` instance for this model.


    """
    __metaclass__ = ModelType

    id = None
    name = None
    objects = None

    def __init__(self, manager=None, id=None, **fields):
        self.objects = manager
        self.id = id
        dict.__init__(self, self.prepare_fields(fields))

    def __reduce__(self):
        return (_unpickle_model, (self.__class__, self.id, dict(self)), None)

    def save(self):
        """Save this entry.

        If the entry does not have an :attr:`id`, a new id will be assigned,
        and the :attr:`id` attribute set accordingly.

        Pre-save processing of the fields saved can be done by
        overriding the :meth:`prepare_save` method.

        Additional actions to be done after the save operation
        has been completed can be added by defining the
        :meth:`post_save` method.

        """
        id = self.id or self.objects.id(self.name)
        self.objects[id] = self.prepare_save(dict(self))
        self.id = id
        self.post_save()
        return id

    def delete(self):
        """Delete this entry."""
        del(self.objects[self.id])
        self.post_delete()

    def prepare_save(self, fields):
        """Prepare fields for saving."""
        return fields

    def prepare_fields(self, fields):
        """Prepare fields when creating an instance of this class."""
        return fields

    def post_save(self):
        """Additional actions to be done after a :meth:`save` operation has been
        completed."""
        pass

    def post_delete(self):
        """Additional actions to be done after a :meth:`delete` operation has
        been completed."""
        pass

    def __repr__(self):
        return "<%s %s>" % (self.id, super(Model, self).__repr__())

    def __getattr__(self, key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(key)

    def __setattr__(self, key, value):
        if key not in self._protected:
            self[key] = value
        else:
            object.__setattr__(self, key, value)


class ManagerType(type):
    """Metaclass for :class:`Manager`s."""

    def __new__(cls, name, bases, attrs):
        if not attrs.get("abstract", False):
            model = attrs["model"]

            def instance(self, id=None, **fields):
                return model(self, id, **fields)

            attrs[model.name] = attrs["instance"] = instance
        attrs["abstract"] = False

        return super(ManagerType, cls).__new__(cls, name, bases, attrs)


class Manager(Client):
    """A manager.

    .. attribute model::
        The :class:`Model` this is a manager for.
        **REQUIRED**

    .. attribute abstract::
        Set this to ``True`` if this is an abstract class,
        (i.e not having a :attr:`model` instance assigned to it).

    .. attribute instance::

        Method returning an instance of the model that is
        connected to this manager.

    """
    __metaclass__ = ManagerType

    model = None
    abstract = True

    def get(self, id):
        """Get entry by id."""
        return self.instance(id, **self[id])

    def get_many(self, ids):
        """Get several entries at once."""
        return [self.instance(id, **fields)
                    for id, fields in zip(ids, self.api.mget(ids))]

    def __iter__(self):
        pattern = "%s:*" % self.model.name
        return (self.instance(id, **fields)
                        for id, fields in self.iteritems(pattern))

    def all(self):
        """Get all entries."""
        return list(iter(self))

    def create(self, **fields):
        """Create new entry."""
        entry = self.instance(**fields)
        entry.save()
        return entry

########NEW FILE########
__FILENAME__ = proxy
"""
.. module:: proxy.py
   :synopsis: Transparent access to Redis as a data structure server
.. moduleauthor:: Adam T. Lindsay <http://github.com/atl>

Rather than use the native redis-py's methods for getitem/setitem as simple
key-value storage, use item access as a means to obtain proxy objects for
structures in the redis store. The proxy objects are obtained from
redish.types -- no other redish modules are used.

This provides as simple access as possible to Redis as a "data structure"
server.

(originally by Adam T. Lindsay)
"""
from codecs import encode, decode
import re
from redis import Redis
from redish import types

TYPE_MAP = {
    "list":   types.List,
    "set":    types.Set,
    "zset":   types.SortedSet,
    "hash":   types.Dict,
}

REV_TYPE_MAP = {
    list:       types.List,
    set:        types.Set,
    dict:       types.Dict,
    types.ZSet: types.SortedSet,
}

# OMG, what have I done?
FORMAT_SPEC = re.compile(r'%(\(\w+\))?[#0\- \+]?[0-9\*]*\.?[0-9\*]*[hlL]?[diouxXeXfXgGcrs]')

def int_or_str(thing, key, client):
    try:
        int(thing)
        return types.Int(key, client)
    except (TypeError, ValueError):
        return decode(thing, "UTF-8")

class Glob(str):
    pass

class Proxy(Redis):
    """Acts as the Redis object except with basic item access or assignment.
    In those cases, transparently returns an object that mimics its 
    associated Python type or passes assignments to the backing store."""
    
    def __init__(self, *args, **kwargs):
        """
        This mostly defers to the main redis-py object, with the exception of 
        keeping track of empty elements and keyspaces.
        
        If a user attempts to initialize a redis key with an empty container, 
        that container is kept in the (local thread's) proxy object so that 
        subsequent accesses keep the right type without throwing KeyErrors.
        """
        self._empties = {}
        self._keyspaces = {}
        super(Proxy, self).__init__(*args, **kwargs)
    
    def keyspaced(f):
        def preprocessed(self, key, *argv):
            if isinstance(key, tuple):
                keyspace = key[0]
                if len(key) == 2:
                    keyargs = key[1:][0]
                else:
                    keyargs = tuple(key[1:])
                key = self._keyspaces[keyspace] % keyargs
            return f(self, key, *argv)
        preprocessed.__doc__ = f.__doc__
        preprocessed.__name__ = f.__name__
        return preprocessed
    
    @keyspaced
    def __getitem__(self, key):
        """Return a proxy type according to the native redis type 
        associated with the key."""
        if isinstance(key, Glob):
            return self.multikey(key)
        typ = self.type(key)
        if typ == 'string':
            # because strings can be empty, check before "empties"
            return int_or_str(self.get(key), key, self)
        if key in self._empties:
            if typ == 'none':
                return self._empties[key]
            else:
                self._empties.pop(key)
        if typ == 'none':
            raise KeyError(key)
        else:
            return TYPE_MAP[typ](key, self)
    
    @keyspaced
    def __setitem__(self, key, value):
        """Copy the contents of the value into the redis store."""
        if key in self._empties:
            del self._empties[key]
        if isinstance(value, (int, types.Int)):
            self.set(key, int(value))
            return
        elif isinstance(value, basestring):
            self.set(key, encode(value, "UTF-8"))
            return
        if not value:
            if self.exists(key):
                self.delete(key)
            if value != None:
                self._empties[key] = REV_TYPE_MAP[type(value)](key, self)
            return
        pline = self.pipeline()
        if self.exists(key):
            pline = pline.delete(key)
        if isinstance(value, (list, types.List)):
            for item in value:
                pline = pline.rpush(key, item)
        elif isinstance(value, (set, types.Set)):
            for item in value:
                pline = pline.sadd(key, item)
        elif isinstance(value, (dict, types.Dict)):
            pline = pline.hmset(key, value)
        elif isinstance(value, (types.ZSet, types.SortedSet)):
            for k,v in value.items():
                pline = pline.zadd(key, k, v)
        pline.execute()
    
    @keyspaced
    def __contains__(self, key):
        """
        We check for existence within the *proxy object*, and so we
        must look in both the backing store and the object's "empties."
        """
        return self.exists(key) or key in self._empties
    
    @keyspaced
    def __delitem__(self, k):
        if isinstance(k, Glob):
            keys = self.keys(k)
        else:
            keys = [k]
        for key in keys:
            if key in self._empties:
                del self._empties[key]
        self.delete(*keys)
    
    def values(self, pattern):
        if pattern in self._keyspaces:
            pattern = FORMAT_SPEC.sub('*', self._keyspaces[pattern])
        return [self[p] for p in super(Proxy, self).keys(pattern)]
    
    def keys(self, pattern):
        if pattern in self._keyspaces:
            pattern = FORMAT_SPEC.sub('*', self._keyspaces[pattern])
        return super(Proxy, self).keys(pattern)
    
    def items(self, pattern):
        if pattern in self._keyspaces:
            pattern = FORMAT_SPEC.sub('*', self._keyspaces[pattern])
        return [(p, self[p]) for p in super(Proxy, self).keys(pattern)]
    
    def register_keyspace(self, shortcut, formatstring):
        """
        Define a keyspace by mapping a label to a formatstring.
        
        The function returns the name of the shortcut to facilitate
        symbolic access with this pattern::
        
            VALUE = proxyobject.register_keyspace('val', "user:%d:name")
        
        The following three statements are then all equivalent::
        
            proxyobject[VALUE, 1001] = "Fred"
            proxyobject['val', 1001] = "Fred"
            proxyobject['user:1001:name'] = "Fred"
        """
        self._keyspaces[shortcut] = formatstring
        return shortcut
    
    def keyspace(self, keyspace):
        """
        Convenient, consistent access to a sub-set of all keys.
        """
        if FORMAT_SPEC.search(keyspace):
            return KeyspacedProxy(self, keyspace)
        else:
            return KeyspacedProxy(self, self._keyspaces[keyspace])
    
    @keyspaced
    def actual_key(self, key):
        """
        For debugging.
        """
        return key
    

class KeyspacedProxy(Proxy):
    """
    The easiest way of describing this is that it simulates a partial on the 
    mapping object by interpolating the keyspace. Clear?
    """
    def __init__(self, proxy, transform):
        self.proxy = proxy
        self.transform = transform
        self.globbed = FORMAT_SPEC.sub('*', transform)
    
    def __getitem__(self, key):
        return self.proxy.__getitem__(self.transform % key)
    
    def __setitem__(self, key, value):
        return self.proxy.__setitem__(self.transform % key, value)
    
    def __contains__(self, key):
        return self.proxy.__contains__(self.transform % key)
    
    def __delitem__(self, key):
        return self.proxy.__delitem__(self.transform % key)
    
    def keys(self):
        return self.proxy.keys(self.globbed)
    
    def values(self):
        return self.proxy.values(self.globbed)
    
    def items(self):
        return self.proxy.items(self.globbed)
    

########NEW FILE########
__FILENAME__ = serialization
try:
    import cPickle as pickle
except ImportError:
    import pickle

import anyjson

from redish.utils import maybe_list


class Serializer(object):
    """Base class for serializers.

    :keyword encoding: Optional encoding applied after serialization,
        and before deserialization.

    Example using compression::

        >>> s = Pickler(encoding="zlib")
        >>> val = s.encode({"foo: "bar"})
        >>> s.decode(val)

    Serializers must implement the :meth:`serialize` and :meth:`deserialize`
    methods. Both take a single argument, which is the value to
    serialize/deserialize.

    """

    def __init__(self, encoding=None):
        self.encoding = encoding

    def encode(self, value):
        """Encode value."""
        value = self.serialize(value)
        if self.encoding:
            value = value.encode(self.encoding)
        return value

    def decode(self, value):
        """Decode value."""
        if self.encoding:
            value = value.decode(self.encoding)
        return self.deserialize(value)

    def serialize(self, value):
        raise NotImplementedError("Serializers must implement serialize()")

    def deserialize(self, value):
        raise NotImplementedError("Serializers must implement deserialize()")


class Plain(Serializer):
    """A pass-through serializer.

    Values will not be serialized.

    """

    def serialize(self, value):
        return value

    def deserialize(self, value):
        return value


class Pickler(Serializer):
    """The :mod:`pickle` serializer."""
    protocol = 2

    def serialize(self, value):
        """Encode value to pickle format."""
        return pickle.dumps(value, protocol=self.protocol)

    def deserialize(self, value):
        """Decode pickled value to Python object."""
        return pickle.loads(value)


class JSON(Serializer):

    def serialize(self, value):
        """Encode value to JSON format."""
        return anyjson.serialize(value)

    def deserialize(self, value):
        """Decode JSON to Python object."""
        return anyjson.deserialize(value)

########NEW FILE########
__FILENAME__ = config
import os

from redish.client import DEFAULT_PORT

connection = dict(
    host=os.environ.get("REDIS_TEST_HOST") or "localhost",
    port=os.environ.get("REDIS_TEST_PORT") or DEFAULT_PORT,
    db=os.environ.get("REDIS_TEST_DB") or "redish-test",
)

########NEW FILE########
__FILENAME__ = test_client
from __future__ import with_statement

import unittest2 as unittest

from redish import client
from redish.tests import config


class ClientTestCase(unittest.TestCase):

    def setUp(self):
        self.client = self.get_client()
        self.client.clear()

    def get_client(self):
        return client.Client(**config.connection)

    def tearDown(self):
        self.client.clear()



class test_Client(ClientTestCase):

    def test_id(self):
        for i in range(1, 10):
            self.assertEqual(self.client.id("Something"), "Something:%s" % i)

    def test_set_get_delete_object(self):
        object = {"foo": "bar", "baz": 1, "xuzzy": 3.14}
        self.client["test:set_object"] = object
        self.assertDictEqual(object, self.client["test:set_object"])

        del(self.client["test:set_object"])
        with self.assertRaises(KeyError):
            self.client["test:set_object"]

        with self.assertRaises(KeyError):
            # delete nonexistent key raises KeyError
            del(self.client["test:set_object"])

    def test_clear(self):
        self.client["test:clear"] = [1, 2, 3]
        self.client.clear()
        with self.assertRaises(KeyError):
            self.client["test:clear"]

    def test_update(self):
        keys = {"test:update:1": 1,
                "test:update:2": 2,
                "test:update:3": 3}
        self.client.update(keys)
        for key, value in keys.items():
            self.assertEqual(self.client[key], value)
        self.client.clear()

    def test_rename(self):
        self.client["test:rename:first"] = "some-value"
        self.client.rename("test:rename:first", "test:rename:second")
        self.assertEqual(self.client["test:rename:second"], "some-value")
        with self.assertRaises(KeyError):
            self.client["test:rename:first"]

        with self.assertRaises(KeyError):
            # rename nonexistent key raises KeyError
            self.client.rename("test:rename:first", "test:rename:second")
        self.client.clear()

    def test_rename_respects_custom_error(self):

        class MockClient(object):

            def rename(self, *args, **kwargs):
                raise client.ResponseError("connection lost")

        c = self.get_client()
        c.api = MockClient()

        with self.assertRaises(client.ResponseError):
            c.rename("test:renamex:1", "test:renamex:2")

    def test_iterkeys(self):
        # also tests c.keys()
        keys = {"test:iterkeys:1": 1,
                "test:iterkeys:2": 2,
                "test:iterkeys:3": 3,
                "test:iterkeys:4": 4}
        self.client.update(keys)
        self.assertItemsEqual(list(self.client.iterkeys("test:iterkeys:*")),
                keys.keys())
        self.client.clear()

    def test_items(self):
        # also tests c.iteritems()
        keys = {"test:items:1": 1,
                "test:items:2": 2,
                "test:items:3": 3,
                "test:items:4": 4}
        self.client.update(keys)
        items = dict(self.client.items("test:items:*"))
        self.assertDictContainsSubset(keys, items)
        self.client.clear()

    def test_values(self):
        # also tests c.itervalues()
        keys = {"test:values:1": 1,
                "test:values:2": 2,
                "test:values:3": 3,
                "test:values:4": 4}
        self.client.update(keys)
        values = self.client.values("test:values:*")
        self.assertItemsEqual(values, keys.values())
        self.client.clear()

    def test_pop(self):
        self.client["test:pop"] = "the quick brown fox..."
        item = self.client.pop("test:pop")
        self.assertEqual(item, "the quick brown fox...")
        with self.assertRaises(KeyError):
            self.client["test:pop"]

        with self.assertRaises(KeyError):
            # pop on nonexistent key raises KeyError
            self.client.pop("test:pop")

    def test_get(self):
        self.client["test:get:exists"] = "George Costanza"
        self.assertEqual(self.client.get("test:get:exists"),
                         "George Costanza")
        self.assertIsNone(self.client.get("test:get:nonexistent"))
        self.assertEqual(self.client.get("test:get:nonexistent", 12345),
                         12345)
        self.client.clear()

    def test__len__(self):
        self.client.clear()
        self.assertEqual(len(self.client), 0)
        keys = dict(("test:__len__:%s" % i, i)
                        for i in range(100))
        self.client.update(keys)
        self.assertEqual(len(self.client), 100)
        self.client.clear()
        self.assertEqual(len(self.client), 0)

    def test__contains__(self):
        self.client["test:__contains__:exists"] = "Elaine Marie Benes"
        self.assertIn("test:__contains__:exists", self.client)
        self.assertNotIn("test:__contains__:nonexistent", self.client)
        self.client.clear()

    def test__repr__(self):
        self.assertTrue(repr(self.client))





########NEW FILE########
__FILENAME__ = test_types
from __future__ import with_statement

from redish import types
from redish.client import ResponseError
from redish.tests.test_client import ClientTestCase


class test_List(ClientTestCase):

    def test_get_set_item(self):
        names = ("George Costanza", "Jerry Seinfeld",
                 "Kosmo Kramer", "Elaine Marie Benes")
        l = self.client.List("test:List:get_set_item", names)
        for i, name in enumerate(names):
            self.assertEqual(l[i], name)

        with self.assertRaises(IndexError):
            l[99]

        revnames = list(reversed(names))
        for i, name in enumerate(revnames):
            l[i] = name
        for i, name in enumerate(revnames):
            self.assertEqual(l[i], name)

        with self.assertRaises(IndexError):
            l[99] = "value"

    def test__setitem__respects_custom_error(self):

        class MockClient(object):

            def lset(self, *args, **kwargs):
                raise ResponseError("connection lost")

        l = self.client.List("test:List:__setitem__ResponseError")
        l.client = MockClient()

        with self.assertRaises(ResponseError):
            l[1] = 2

    def test__len__(self):
        initial = range(100)
        l = self.client.List("test:List:__len__", initial)
        self.assertEqual(len(l), len(initial))
        l2 = self.client.List("test:List:__len__:empty")
        self.assertEqual(len(l2), 0)

    def test__repr__(self):
        l = self.client.List("test:List:__repr__", [1, 2, 3])
        self.assertIn("'1', '2', '3'", repr(l))

    def test__iter__(self):
        data = ["foo", "bar", "baz"]
        l = self.client.List("test:List:__iter__", data)
        self.assertListEqual(list(iter(l)), data)

    def test__getslice__(self):
        data = ["foo", "bar", "baz", "xuzzy"]
        l = self.client.List("test:List:__getslice__", data)
        self.assertListEqual(l[:2], ["foo", "bar"])
        self.assertListEqual(l[:-1], ["foo", "bar", "baz"])

    def test_append(self):
        data = ["foo", "bar", "baz"]
        l = self.client.List("test:List:append", data)
        l.append("xuzzy")
        self.assertListEqual(list(l), data + ["xuzzy"])

    def test_appendleft(self):
        data = ["foo", "bar", "baz"]
        l = self.client.List("test:List:append", data)
        l.appendleft("xuzzy")
        self.assertListEqual(list(l), ["xuzzy"] + data)

    def test_trim(self):
        data = map(str, range(100))
        l = self.client.List("test:List:trim", data)
        l.trim(0, 50)
        self.assertListEqual(list(l), data[:50])

    def test_pop(self):
        data = ["foo", "bar", "baz"]
        l = self.client.List("test:List:pop", data)
        self.assertEqual(l.pop(), "baz")

    def test_popleft(self):
        data = ["foo", "bar", "baz"]
        l = self.client.List("test:List:popleft", data)
        self.assertEqual(l.popleft(), "foo")

    def test_remove(self):
        data = ["foo", "bar", "baz", "bar", "baz", "bar", "bar", "bar"]
        l = self.client.List("test:List:remove", data)
        l.remove("bar")
        self.assertEqual(len(l), len(data) - 1)
        l.remove("bar", 100)
        self.assertEqual(len(l), 3)

        with self.assertRaises(ValueError):
            l.remove("nonexistent")

    def test_extend(self):
        data1 = ["foo", "bar", "baz"]
        data2 = ["Bart", "Lisa", "Homer", "Marge", "Maggie"]
        l = self.client.List("test:List:extend", data1)
        l.extend(data2)
        self.assertListEqual(list(l), data1 + data2)

    def test_extendleft(self):
        data1 = ["foo", "bar", "baz"]
        data2 = ["Bart", "Lisa", "Homer", "Marge", "Maggie"]
        l = self.client.List("test:List:extend", data1)
        l.extendleft(data2)
        self.assertListEqual(list(l), list(reversed(data2)) + data1)


class test_Set(ClientTestCase):

    def test_no_initial_data(self):
        s = self.client.Set("test:Set:no_initial_data")
        self.assertEqual(len(s), 0)

    def test__iter__(self):
        data = ["foo", "bar", "baz", "zaz"]
        s = self.client.Set("test:Set:__iter__", data)
        self.assertItemsEqual(list(iter(s)), list(set(data)))

    def test__repr__(self):
        data = ["foo", "bar", "baz"]
        s = self.client.Set("test:Set:__repr__", data)
        self.assertIn("'foo'", repr(s))

    def test__contains__(self):
        data = ["foo", "bar", "baz"]
        s = self.client.Set("test:Set:__contains__", data)
        self.assertIn("foo", s)
        self.assertNotIn("zaz", s)

    def test__len__(self):
        data = range(100)
        s = self.client.Set("test:Set:__len__", data)
        self.assertEqual(len(s), 100)

    def test_add(self):
        data = ["foo", "bar", "baz"]
        s = self.client.Set("test:Set:add", data)
        s.add("zaz")
        self.assertIn("zaz", s)

    def test_remove(self):
        data = ["foo", "bar", "baz", "zaz"]
        s = self.client.Set("test:Set:remove", data)
        s.remove("foo")
        self.assertNotIn("foo", s)
        with self.assertRaises(KeyError):
            s.remove("xuzzy")

    def test_pop(self):
        data = set(["foo", "bar", "baz", "zaz"])
        s = self.client.Set("test:Set:remove", data)
        member = s.pop()
        self.assertIn(member, data)
        self.assertNotIn(member, s)
        self.assertEqual(len(s), len(data) - 1)

    def test_pop_empty_set_raises_KeyError(self):
        s = self.client.Set("test:Set:pop_empty_set")
        with self.assertRaises(KeyError):
            s.pop()

    def test_union(self):
        ds1 = set(["foo", "bar", "baz"])
        ds2 = set(["baz", "xuzzy", "zaz"])
        s1 = self.client.Set("test:Set:union:1", ds1)
        s2 = self.client.Set("test:Set:union:2", ds2)
        u = s1.union(s2)
        self.assertSetEqual(ds1.union(ds2), u)

    def test_update_redis_set(self):
        ds1 = set(["foo", "bar", "baz"])
        ds2 = set(["baz", "xuzzy", "zaz"])
        s1 = self.client.Set("test:Set:update_redis_set:1", ds1)
        s2 = self.client.Set("test:Set:update_redis_set:2", ds2)
        s1.update(s2)
        self.assertSetEqual(s1._as_set(), ds1.union(ds2))

    def test_update_pyset(self):
        ds1 = set(["foo", "bar", "baz"])
        ds2 = set(["baz", "xuzzy", "zaz"])
        s1 = self.client.Set("test:Set:update_pyset", ds1)
        s1.update(ds2)
        self.assertSetEqual(s1._as_set(), ds1.union(ds2))

    def test_intersection(self):
        ds1 = set(["foo", "bar", "baz"])
        ds2 = set(["baz", "xuzzy", "zaz"])
        s1 = self.client.Set("test:Set:intersection:1", ds1)
        s2 = self.client.Set("test:Set:intersection:2", ds2)
        self.assertSetEqual(s1.intersection(s2), ds1.intersection(ds2))

    def test_intersection_update(self):
        ds1 = set(["foo", "bar", "baz"])
        ds2 = set(["baz", "xuzzy", "zaz"])
        s1 = self.client.Set("test:Set:intersection_update:1", ds1)
        s2 = self.client.Set("test:Set:intersection_update:2", ds2)
        s1.intersection_update(s2)
        self.assertSetEqual(s1._as_set(), ds1.intersection(ds2))

    def test_difference(self):
        ds1 = set(["foo", "bar", "baz"])
        ds2 = set(["baz", "xuzzy", "zaz"])
        s1 = self.client.Set("test:Set:difference:1", ds1)
        s2 = self.client.Set("test:Set:difference:2", ds2)
        self.assertSetEqual(s1.difference(s2), ds1.difference(ds2))

    def test_difference_update(self):
        ds1 = set(["foo", "bar", "baz"])
        ds2 = set(["baz", "xuzzy", "zaz"])
        s1 = self.client.Set("test:Set:difference_update:1", ds1)
        s2 = self.client.Set("test:Set:difference_update:2", ds2)
        s1.difference_update(s2)
        self.assertSetEqual(s1._as_set(), ds1.difference(ds2))


class test_SortedSet(ClientTestCase):

    def test_no_initial_data(self):
        z = self.client.SortedSet("test:SortedSet:no_initial_data")
        self.assertEqual(len(z), 0)

    def test__iter__(self):
        data = (("foo", 0.9), ("bar", 0.1), ("baz", 0.3))
        z = self.client.SortedSet("test:SortedSet:__iter__", data)
        self.assertListEqual(list(iter(z)), ["bar", "baz", "foo"])

    def test__getslice__(self):
        data = (("foo", 0.9), ("bar", 0.1), ("baz", 0.3))
        z = self.client.SortedSet("test:SortedSet:__getslice__", data)
        self.assertListEqual(z[0:2], ["bar", "baz"])
        self.assertListEqual(z[0:-1], ["bar", "baz"])

    def test__len__(self):
        data = (("foo", 0.9), ("bar", 0.1), ("baz", 0.3))
        z = self.client.SortedSet("test:SortedSet:__len__", data)
        self.assertEqual(len(z), len(data))

    def test__repr__(self):
        data = (("foo", 0.9), ("bar", 0.1), ("baz", 0.3))
        z = self.client.SortedSet("test:SortedSet:__repr__", data)
        self.assertIn("'foo'", repr(z))

    def test_add(self):
        data = (("foo", 0.9), ("bar", 0.1), ("baz", 0.3))
        z = self.client.SortedSet("test:SortedSet:add", data)
        z.add("xuzzy", 0.4)
        self.assertListEqual(list(z), ["bar", "baz", "xuzzy", "foo"])

    def test_remove(self):
        data = (("foo", 0.9), ("bar", 0.1), ("baz", 0.3))
        z = self.client.SortedSet("test:SortedSet:remove", data)
        z.remove("bar")
        self.assertListEqual(list(z), ["baz", "foo"])

        with self.assertRaises(KeyError):
            z.remove("nonexistent")

    def test_revrange(self):
        data = (("foo", 0.9), ("bar", 0.1), ("baz", 0.3))
        z = self.client.SortedSet("test:SortedSet:revrange", data)
        self.assertListEqual(z.revrange(), ["foo", "baz", "bar"])

    def test_increment(self):
        data = (("foo", 0.9), ("bar", 0.1), ("baz", 0.3))
        z = self.client.SortedSet("test:SortedSet:increment", data)
        z.increment("bar", 1)
        self.assertListEqual(list(z), ["baz", "foo", "bar"])

    def test_rank(self):
        data = (("foo", 0.9), ("bar", 0.1), ("baz", 0.3))
        z = self.client.SortedSet("test:SortedSet:rank", data)
        self.assertEqual(z.rank("bar"), 0)
        self.assertEqual(z.rank("baz"), 1)
        self.assertEqual(z.rank("foo"), 2)

    def test_revrank(self):
        data = (("foo", 0.9), ("bar", 0.1), ("baz", 0.3))
        z = self.client.SortedSet("test:SortedSet:revrank", data)
        self.assertEqual(z.revrank("bar"), 2)
        self.assertEqual(z.revrank("baz"), 1)
        self.assertEqual(z.revrank("foo"), 0)

    def test_score(self):
        data = (("foo", 0.9), ("bar", 0.1), ("baz", 0.3))
        z = self.client.SortedSet("test:SortedSet:score", data)
        for member, score in data:
            self.assertEqual(z.score(member), score)

    def test_update(self):
        data1 = (("foo", 0.9), ("bar", 0.1), ("baz", 0.3))
        data2 = (("bar", 1.2), ("xuzzy", 0.2), ("zaz", 0.4))
        z = self.client.SortedSet("test:SortedSet:update", data1)
        z.update(data2)
        self.assertListEqual(list(z), ["xuzzy", "baz", "zaz", "foo", "bar"])

    def test_range_by_score(self):
        data = (("foo", 0.9), ("bar", 0.1), ("baz", 0.3),
                 ("bam", 1.2), ("xuzzy", 0.2), ("zaz", 0.4))
        z = self.client.SortedSet("test:SortedSet:range_by_score", data)
        self.assertListEqual(z.range_by_score(0.3, 1.0), [
                                "baz", "zaz", "foo"])

    def test_itemsview(self):
        data = (("foo", 0.9), ("bar", 0.1), ("baz", 0.3),
                 ("bam", 1.2), ("xuzzy", 0.2), ("zaz", 0.4))
        z = self.client.SortedSet("test:SortedSet:itemsview", data)
        view = z.itemsview()
        self.assertTupleEqual(tuple(view), (
            ("bar", 0.1),
            ("xuzzy", 0.2),
            ("baz", 0.3),
            ("zaz", 0.4),
            ("foo", 0.9),
            ("bam", 1.2)))

    def test_keysview(self):
        data = (("foo", 0.9), ("bar", 0.1), ("baz", 0.3),
                 ("bam", 1.2), ("xuzzy", 0.2), ("zaz", 0.4))
        z = self.client.SortedSet("test:SortedSet:keysview", data)
        self.assertListEqual(list(z.keysview()),
                ["bar", "xuzzy", "baz", "zaz", "foo", "bam"])
        self.assertListEqual(list(reversed(z.keysview())),
                ["bam", "foo", "zaz", "baz", "xuzzy", "bar"])
        self.assertListEqual(z.keysview()[0:3],
                ["bar", "xuzzy", "baz"])

        self.assertEqual(z.keysview()[3], "zaz")

        self.assertRaises(IndexError, z.keysview().__getitem__, 100)


class test_Dict(ClientTestCase):

    def test__init__(self):
        data = {"name": "George Costanza"}
        d = self.client.Dict("test:Dict:__init__", data,
                             company="Vandelay Industries")
        self.assertEqual(d["name"], "George Costanza")
        self.assertEqual(d["company"], "Vandelay Industries")

    def test__missing__(self):

        class MissingDict(types.Dict):

            def __missing__(self, key):
                return 42

        d = MissingDict("test:Dict:__missing__", self.client.api)
        self.assertEqual(d["nonexistent"], 42)

    def test_set_get_delete(self):
        d = self.client.Dict("test:Dict:set_get_delete")
        d["foo"] = "bar"
        self.assertEqual(d["foo"], "bar")
        del(d["foo"])
        with self.assertRaises(KeyError):
            d["foo"]
        with self.assertRaises(KeyError):
            del(d["foo"])

    def test__getitem__raises_KeyError(self):
        d = self.client.Dict("test:Dict:__getitem__raises_KeyError")
        with self.assertRaises(KeyError):
            d["nonexistent"]

    def test__contains__(self):
        d = self.client.Dict("test:Dict:__contains__", {"name": "Jerry"})
        self.assertIn("name", d)
        self.assertNotIn("address", d)

    def test__len__(self):
        d = self.client.Dict("test:Dict:__len__", dict((i, i)
                                                    for i in range(100)))
        self.assertEqual(len(d), 100)

    def test__iter__(self):
        # also tests d.iteritems() + d.items()
        items = dict((i, i) for i in map(str, range(100)))
        d = self.client.Dict("test:Dict:__iter__", items)
        self.assertListEqual(list(iter(d)), items.items())

    def test__repr__(self):
        d = self.client.Dict("test:Dict:__repr__", foo="bar")
        self.assertIn("'foo': 'bar'", repr(d))

    def test_iterkeys(self):
        # also tests d.keys()
        items = dict((i, i) for i in map(str, range(100)))
        d = self.client.Dict("test:Dict:iterkeys", items)
        self.assertItemsEqual(list(d.iterkeys()), items.keys())

    def test_itervalues(self):
        # also tests d.values()
        items = dict((i, i) for i in map(str, range(100)))
        d = self.client.Dict("test:Dict:itervalues", items)
        self.assertItemsEqual(list(d.itervalues()), items.values())

    def test_has_key(self):
        d = self.client.Dict("test:Dict:has_key", foo="bar")
        self.assertTrue(d.has_key("foo"))
        self.assertFalse(d.has_key("bar"))

    def test_get(self):
        d = self.client.Dict("test:Dict:get", foo="bar")
        self.assertEqual(d.get("foo"), "bar")
        self.assertIsNone(d.get("bar"))
        self.assertEqual(d.get("bar", 12345), 12345)

    def test_setdefault(self):
        d = self.client.Dict("test:Dict:setdefault")
        self.assertEqual(d.setdefault("somekey", "54321"), "54321")
        self.assertEqual(d["somekey"], "54321")

        d["otherkey"] = "56789"
        self.assertEqual(d.setdefault("otherkey", "12345"), "56789")
        self.assertEqual(d["otherkey"], "56789")

    def test_pop(self):
        d = self.client.Dict("test:Dict:pop", foo="bar")
        self.assertIsNone(d.pop("nonexistent", None))
        self.assertIsNone(d.pop("nonexistent", default=None))
        self.assertEqual(d.pop("nonexistent", "12345"), "12345")
        self.assertEqual(d.pop("nonexistent", default="12345"), "12345")

        with self.assertRaises(KeyError):
            d.pop("nonexistent")

        self.assertEqual(d.pop("foo"), "bar")
        with self.assertRaises(KeyError):
            d.pop("foo")

        with self.assertRaises(KeyError):
            d["foo"]

    def test_update(self):
        data1 = {"George Costanza": "architect",
                 "Jerry Seinfeld": "comedian"}
        data2 = {"Elaine Marie Benes": "assistant"}
        d = self.client.Dict("test:Dict:update", data2)
        d.update(data1)
        self.assertDictContainsSubset(data1, dict(d))



class QueueCase(ClientTestCase):

    def setUp(self):
        super(QueueCase, self).setUp()
        self.setUpQueue()

    def setUpQueue(self):
        self.qtype = None

    def test_empty(self):
        if not self.qtype:
            return
        q = self.qtype("test:Queue:empty")
        self.assertTrue(q.empty())
        q.put("foo")
        self.assertFalse(q.empty())

    def test_full(self):
        if not self.qtype:
            return
        q = self.qtype("test:Queue:full:1", maxsize=None)
        self.assertFalse(q.full())

        q2 = self.qtype("test:Queue:full:2", maxsize=10)
        [q2.put(i) for i in map(str, range(10))]
        self.assertTrue(q2.full())

    def test_put_get(self):
        if not self.qtype:
            return
        q = self.qtype("test:Queue:put_get")
        q.put("foo")
        self.assertEqual(q.get(block=False), "foo")

    def test_get_raises_Empty(self):
        if not self.qtype:
            return
        q = self.qtype("test:Queue:get_raises_Empty")
        with self.assertRaises(q.Empty):
            q.get(block=False)

    def test_put_raises_Full(self):
        if not self.qtype:
            return
        q = self.qtype("test:Queue:put_raises_Full", maxsize=3)
        q.put("foo")
        q.put("bar")
        q.put("baz")
        self.assertTrue(q.full())
        with self.assertRaises(q.Full):
            q.put("xuzzy")

    def test_qsize(self):
        if not self.qtype:
            return
        q = self.qtype("test:Queue:qsize")
        self.assertEqual(q.qsize(), 0)
        [q.put(i) for i in range(100)]
        self.assertEqual(q.qsize(), 100)


class test_Queue(QueueCase):

    def setUpQueue(self):
        self.qtype = self.client.Queue

    def test_is_FIFO(self):
        items = ("foo", "bar", "baz")
        q = self.qtype("test:Queue:is_FIFO")
        for item in items:
            q.put(item)
        for item in items:
            self.assertEqual(q.get(block=False), item)


class test_LifoQueue(QueueCase):

    def setUpQueue(self):
        self.qtype = self.client.LifoQueue

    def test_is_LIFO(self):
        items = ("foo", "bar", "baz")
        q = self.qtype("test:Queue:is_LIFO")
        for item in items:
            q.put(item)
        for item in reversed(items):
            self.assertEqual(q.get(block=False), item)

########NEW FILE########
__FILENAME__ = test_utils
import unittest2 as unittest
from datetime import datetime

from redish import utils


class test_maybe_list(unittest.TestCase):

    def test_list(self):
        self.assertListEqual(utils.maybe_list([1, 2, 3]), [1, 2, 3])

    def test_value(self):
        self.assertListEqual(utils.maybe_list(1), [1])

    def test_None(self):
        self.assertListEqual(utils.maybe_list(None), [])


class test_utils(unittest.TestCase):

    def test_mkey(self):
        self.assertEqual(utils.mkey("foo"), "foo")
        self.assertEqual(utils.mkey("foo:bar"), "foo:bar")
        self.assertEqual(utils.mkey(("foo", "bar", "baz")), "foo:bar:baz")
        self.assertEqual(utils.mkey(["foo", "bar", "baz"]), "foo:bar:baz")

    def test_dt_to_timestamp(self):
        dt = datetime(2010, 4, 29, 13, 49, 34, 112487)
        self.assertIsInstance(utils.dt_to_timestamp(dt), float)

    def test_maybe_datetime(self):
        self.assertIsInstance(utils.maybe_datetime(
                                datetime(2010, 4, 29, 13, 49, 34, 112487)),
                              float)
        self.assertIsInstance(utils.maybe_datetime(1272541774.0), float)

########NEW FILE########
__FILENAME__ = types
import bisect

from Queue import Empty, Full

from redis.exceptions import ResponseError
from redish.utils import mkey


class Type(object):
    """Base-class for Redis datatypes."""

    def __init__(self, name, client):
        self.name = mkey(name)
        self.client = client


def Id(name, client):
    """Return the next value for an unique id."""
    return "%s:%s" % (name, client.incr("ids:%s" % (name, )), )


class List(Type):
    """A list."""

    def __init__(self, name, client, initial=None):
        super(List, self).__init__(name, client)
        self.extend(initial or [])

    def __getitem__(self, index):
        """``x.__getitem__(index) <==> x[index]``"""
        item = self.client.lindex(self.name, index)
        if item:
            return item
        raise IndexError("list index out of range")

    def __setitem__(self, index, value):
        """``x.__setitem__(index, value) <==> x[index] = value``"""
        try:
            self.client.lset(self.name, index, value)
        except ResponseError, exc:
            if "index out of range" in exc.args:
                raise IndexError("list assignment index out of range")
            raise

    def __len__(self):
        """``x.__len__() <==> len(x)``"""
        return self.client.llen(self.name)

    def __repr__(self):
        """``x.__repr__() <==> repr(x)``"""
        return repr(self._as_list())

    def __iter__(self):
        """``x.__iter__() <==> iter(x)``"""
        return iter(self._as_list())

    def __getslice__(self, i, j):
        """``x.__getslice__(start, stop) <==> x[start:stop]``"""
        # Redis indices are zero-based, while Python indices are 1-based.
        return self.client.lrange(self.name, i, j - 1)

    def _as_list(self):
        return self.client.lrange(self.name, 0, -1)

    copy = _as_list

    def append(self, value):
        """Add ``value`` to the end of the list."""
        return self.client.rpush(self.name, value)

    def appendleft(self, value):
        """Add ``value`` to the head of the list."""
        return self.client.lpush(self.name, value)

    def trim(self, start, stop):
        """Trim the list to the specified range of elements."""
        return self.client.ltrim(self.name, start, stop - 1)

    def pop(self):
        """Remove and return the last element of the list."""
        return self.client.rpop(self.name)

    def popleft(self):
        """Remove and return the first element of the list."""
        return self.client.lpop(self.name)

    def remove(self, value, count=1):
        """Remove occurences of ``value`` from the list.

        :keyword count: Number of matching values to remove.
            Default is to remove a single value.

        """
        count = self.client.lrem(self.name, value, num=count)
        if not count:
            raise ValueError("%s not in list" % value)
        return count

    def extend(self, iterable):
        """Append the values in ``iterable`` to this list."""
        for value in iterable:
            self.append(value)

    def extendleft(self, iterable):
        """Add the values in ``iterable`` to the head of this list."""
        for value in iterable:
            self.appendleft(value)


class Set(Type):
    """A set."""

    def __init__(self, name, client, initial=None):
        super(Set, self).__init__(name, client)
        if initial:
            self.update(initial)

    def __iter__(self):
        """``x.__iter__() <==> iter(x)``"""
        return iter(self._as_set())

    def __repr__(self):
        """``x.__repr__() <==> repr(x)``"""
        return "<Set: %s>" % (repr(list(self._as_set())), )

    def __contains__(self, member):
        """``x.__contains__(member) <==> member in x``"""
        return self.client.sismember(self.name, member)

    def __len__(self):
        """``x.__len__() <==> len(x)``"""
        return self.client.scard(self.name)

    def _as_set(self):
        return self.client.smembers(self.name)

    copy = _as_set

    def add(self, member):
        """Add element to set.

        This has no effect if the member is already present.

        """
        return self.client.sadd(self.name, member)

    def remove(self, member):
        """Remove element from set; it must be a member.

        :raises KeyError: if the element is not a member.

        """
        if not self.client.srem(self.name, member):
            raise KeyError(member)

    def pop(self):
        """Remove and return an arbitrary set element.

        :raises KeyError: if the set is empty.

        """
        member = self.client.spop(self.name)
        if member is not None:
            return member
        raise KeyError()

    def union(self, other):
        """Return the union of sets as a new set.

        (i.e. all elements that are in either set.)

        Operates on either redish.types.Set or __builtins__.set.

        """
        if isinstance(other, self.__class__):
            return self.client.sunion([self.name, other.name])
        else:
            return self._as_set().union(other)

    def update(self, other):
        """Update this set with the union of itself and others."""
        if isinstance(other, self.__class__):
            return self.client.sunionstore(self.name, [self.name, other.name])
        else:
            return map(self.add, other)

    def intersection(self, other):
        """Return the intersection of two sets as a new set.

        (i.e. all elements that are in both sets.)

        Operates on either redish.types.Set or __builtins__.set.

        """
        if isinstance(other, self.__class__):
            return self.client.sinter([self.name, other.name])
        else:
            return self._as_set().intersection(other)

    def intersection_update(self, other):
        """Update the set with the intersection of itself and another."""
        return self.client.sinterstore(self.name, [self.name, other.name])

    def difference(self, *others):
        """Return the difference of two or more sets as a new :class:`set`.

        (i.e. all elements that are in this set but not the others.)

        Operates on either redish.types.Set or __builtins__.set.

        """
        if all([isinstance(a, self.__class__) for a in others]):
            return self.client.sdiff([self.name] + [other.name for other in others])
        else:
            othersets = filter(lambda x: isinstance(x, set), others)
            otherTypes = filter(lambda x: isinstance(x, self.__class__), others)
            return self.client.sdiff([self.name] + [other.name for other in otherTypes]).difference(*othersets)

    def difference_update(self, other):
        """Remove all elements of another set from this set."""
        return self.client.sdiffstore(self.name, [self.name, other.name])


class SortedSet(Type):
    """A sorted set.

    :keyword initial: Initial data to populate the set with,
      must be an iterable of ``(element, score)`` tuples.

    """

    class _itemsview(object):

        def __init__(self, zset, start=0, end=-1, desc=False,
                withscores=False):
            self.zset = zset
            self.start = start
            self.end = end
            self.desc = desc
            self.withscores = withscores

        def _items(self, start, end, desc, withscores):
            return self.zset.items(start, end, desc=desc,
                                   withscores=withscores)

        def __iter__(self):
            return iter(self._items(self.start, self.end, self.desc,
                                    self.withscores))

        def __reversed__(self):
            return self._items(self.start, self.end, True, self.withscores)

        def __getitem__(self, s):
            if isinstance(s, slice):
                i = s.start or 0
                j = s.stop or -1
                j = j - 1
                return self._items(i, j, False, self.withscores)
            else:
                return self._items(s, s, False, self.withscores)[0]

    def __init__(self, name, client, initial=None):
        super(SortedSet, self).__init__(name, client)
        if initial:
            self.update(initial)

    def __iter__(self):
        """``x.__iter__() <==> iter(x)``"""
        return iter(self._as_set())

    def __getitem__(self, s):
        if isinstance(s, slice):
            i = s.start or 0
            j = s.stop or -1
            j = j - 1
        else:
            i = j = s
        return self.client.zrange(self.name, i, j)

    def __len__(self):
        """``x.__len__() <==> len(x)``"""
        return self.client.zcard(self.name)

    def __repr__(self):
        """``x.__repr__() <==> repr(x)``"""
        return "<SortedSet: %s>" % (repr(list(self._as_set())), )

    def add(self, member, score):
        """Add the specified member to the sorted set, or update the score
        if it already exist."""
        return self.client.zadd(self.name, member, score)

    def remove(self, member):
        """Remove member."""
        if not self.client.zrem(self.name, member):
            raise KeyError(member)

    def revrange(self, start=0, stop=-1):
        stop = stop is None and -1 or stop
        return self.client.zrevrange(self.name, start, stop)

    def discard(self, member):
        """Discard member."""
        self.client.zrem(self.name, member)

    def increment(self, member, amount=1):
        """Increment the score of ``member`` by ``amount``."""
        return self.client.zincrby(self.name, member, amount)

    def rank(self, member):
        """Rank the set with scores being ordered from low to high."""
        return self.client.zrank(self.name, member)

    def revrank(self, member):
        """Rank the set with scores being ordered from high to low."""
        return self.client.zrevrank(self.name, member)

    def score(self, member):
        """Return the score associated with the specified member."""
        return self.client.zscore(self.name, member)

    def range_by_score(self, min, max, num=None, withscores=False):
        """Return all the elements with score >= min and score <= max
        (a range query) from the sorted set."""
        return self.client.zrangebyscore(self.name, min, max, num=num,
                                         withscores=withscores)

    def update(self, iterable):
        for member, score in iterable:
            self.add(member, score)

    def _as_set(self):
        return self.client.zrange(self.name, 0, -1)

    def items(self, start=0, end=-1, desc=False, withscores=False):
        return self.client.zrange(self.name, start, end,
                                  desc=desc, withscores=withscores)

    def itemsview(self, start=0, end=-1, desc=False):
        return self._itemsview(self, start, end, desc, withscores=True)

    def keysview(self, start=0, end=-1, desc=False):
        return self._itemsview(self, start, end, desc, withscores=False)

    copy = _as_set


class Dict(Type):
    """A dictionary."""

    def __init__(self, name, client, initial=None, **extra):
        super(Dict, self).__init__(name, client)
        initial = dict(initial or {}, **extra)
        if initial:
            self.update(initial)

    def __getitem__(self, key):
        """``x.__getitem__(key) <==> x[key]``"""
        value = self.client.hget(self.name, key)
        if value is not None:
            return value
        if hasattr(self.__class__, "__missing__"):
            return self.__class__.__missing__(self, key)
        raise KeyError(key)

    def __setitem__(self, key, value):
        """``x.__setitem__(key, value) <==> x[key] = value``"""
        return self.client.hset(self.name, key, value)

    def __delitem__(self, key):
        """``x.__delitem__(key) <==> del(x[key])``"""
        if not self.client.hdel(self.name, key):
            raise KeyError(key)

    def __contains__(self, key):
        """``x.__contains__(key) <==> key in x``"""
        return self.client.hexists(self.name, key)

    def __len__(self):
        """``x.__len__() <==> len(x)``"""
        return self.client.hlen(self.name)

    def __iter__(self):
        """``x.__iter__() <==> iter(x)``"""
        return self.iteritems()

    def __repr__(self):
        """``x.__repr__() <==> repr(x)``"""
        return repr(self._as_dict())

    def keys(self):
        """Returns the list of keys present in this dictionary."""
        return self.client.hkeys(self.name)

    def values(self):
        """Returns the list of values present in this dictionary."""
        return self.client.hvals(self.name)

    def items(self):
        """This dictionary as a list of ``(key, value)`` pairs, as
        2-tuples."""
        return self._as_dict().items()

    def iteritems(self):
        """Returns an iterator over the ``(key, value)`` items present in this
        dictionary."""
        return iter(self.items())

    def iterkeys(self):
        """Returns an iterator over the keys present in this dictionary."""
        return iter(self.keys())

    def itervalues(self):
        """Returns an iterator over the values present in this dictionary."""
        return iter(self.values())

    def has_key(self, key):
        """Returns ``True`` if ``key`` is present in this dictionary,
        ``False`` otherwise."""
        return key in self

    def get(self, key, default=None):
        """Returns the value at ``key`` if present, otherwise returns
        ``default`` (``None`` by default.)"""
        try:
            return self[key]
        except KeyError:
            return default

    def setdefault(self, key, default=None):
        """Returns the value at ``key`` if present, otherwise
        stores ``default`` value at ``key``."""
        try:
            return self[key]
        except KeyError:
            self[key] = default
            return default

    def pop(self, key, *args, **kwargs):
        """Remove specified key and return the corresponding value.

        :keyword default: If key is not found, ``default`` is returned if given,
            otherwise :exc:`KeyError` is raised.

        """
        try:
            val = self[key]
        except KeyError:
            if len(args):
                return args[0]
            if "default" in kwargs:
                return kwargs["default"]
            raise

        try:
            del(self[key])
        except KeyError:
            pass

        return val

    def update(self, other):
        """Update this dictionary with another."""
        return self.client.hmset(self.name, other)

    def _as_dict(self):
        return self.client.hgetall(self.name)

    copy = _as_dict


class Queue(Type):
    """FIFO Queue."""

    Empty = Empty
    Full = Full

    def __init__(self, name, client, initial=None, maxsize=0):
        super(Queue, self).__init__(name, client)
        self.list = List(name, client, initial)
        self.maxsize = maxsize
        self._pop = self.list.pop
        self._bpop = self.client.brpop
        self._append = self.list.appendleft

    def empty(self):
        """Return ``True`` if the queue is empty, or ``False``
        otherwise (not reliable!)."""
        return not len(self.list)

    def full(self):
        """Return ``True`` if the queue is full, ``False``
        otherwise (not reliable!).

        Only applicable if :attr:`maxsize` is set.

        """
        return self.maxsize and len(self.list) >= self.maxsize or False

    def get(self, block=True, timeout=None):
        """Remove and return an item from the queue.

        If optional args ``block`` is ``True`` and ``timeout`` is
        ``None`` (the default), block if necessary until an item is
        available.  If ``timeout`` is a positive number, it blocks at
        most ``timeout`` seconds and raises the :exc:`Queue.Empty` exception
        if no item was available within that time. Otherwise (``block`` is
        ``False``), return an item if one is immediately available, else
        raise the :exc:`Queue.Empty` exception (``timeout`` is ignored
        in that case).

        """
        if not block:
            return self.get_nowait()
        item = self._bpop([self.name], timeout=timeout)
        if item is not None:
            return item
        raise Empty

    def get_nowait(self):
        """Remove and return an item from the queue without blocking.

        :raises Queue.Empty: if an item is not immediately available.

        """
        item = self._pop()
        if item is not None:
            return item
        raise Empty()

    def put(self, item, **kwargs):
        """Put an item into the queue."""
        if self.full():
            raise Full()
        self._append(item)

    def qsize(self):
        """Returns the current size of the queue."""
        return len(self.list)


class LifoQueue(Queue):
    """Variant of :class:`Queue` that retrieves most recently added
    entries first."""

    def __init__(self, name, client, initial=None, maxsize=0):
        super(LifoQueue, self).__init__(name, client, initial, maxsize)
        self._pop = self.list.popleft
        self._bpop = self.client.blpop


class Int(Type):
    """In order to mimic an int, we reimplement all its methods with
    all values accessing the backing store.

    These flip-flopping definitions are a 'convenient' way to mix Ints
    with types that are not int (including itself).

    I am not at all convinced this was worth it.
    """
    def __add__(self, other):
        return type(other).__radd__(other, self.__int__())

    def __sub__(self, other):
        return type(other).__rsub__(other, self.__int__())

    def __mul__(self, other):
        return type(other).__rmul__(other, self.__int__())

    def __div__(self, other):
        return type(other).__rdiv__(other, self.__int__())

    def __truediv__(self, other):
        return type(other).__rtruediv__(other, self.__int__())

    def __floordiv__(self, other):
        return type(other).__rfloordiv__(other, self.__int__())

    def __mod__(self, other):
        return type(other).__rmod__(other, self.__int__())

    def __divmod__(self, other):
        return type(other).__rdivmod__(other, self.__int__())

    def __pow__(self, other):
        return type(other).__rpow__(other, self.__int__())

    def __lshift__(self, other):
        return type(other).__rlshift__(other, self.__int__())

    def __rshift__(self, other):
        return type(other).__rrshift__(other, self.__int__())

    def __and__(self, other):
        return type(other).__rand__(other, self.__int__())

    def __or__(self, other):
        return type(other).__ror__(other, self.__int__())

    def __xor__(self, other):
        return type(other).__rxor__(other, self.__int__())

    def __radd__(self, other):
        return type(other).__add__(other, self.__int__())

    def __rsub__(self, other):
        return type(other).__sub__(other, self.__int__())

    def __rmul__(self, other):
        return type(other).__mul__(other, self.__int__())

    def __rdiv__(self, other):
        return type(other).__div__(other, self.__int__())

    def __rtruediv__(self, other):
        return type(other).__truediv__(other, self.__int__())

    def __rfloordiv__(self, other):
        return type(other).__floordiv__(other, self.__int__())

    def __rmod__(self, other):
        return type(other).__mod__(other, self.__int__())

    def __rdivmod__(self, other):
        return type(other).__divmod__(other, self.__int__())

    def __rpow__(self, other):
        return type(other).__pow__(other, self.__int__())

    def __rlshift__(self, other):
        return type(other).__lshift__(other, self.__int__())

    def __rrshift__(self, other):
        return type(other).__shift__(other, self.__int__())

    def __rand__(self, other):
        return type(other).__and__(other, self.__int__())

    def __ror__(self, other):
        return type(other).__or__(other, self.__int__())

    def __rxor__(self, other):
        return type(other).__xor__(other, self.__int__())

    def __iadd__(self, other):
        self.client.incr(self.name, other)
        return self

    def __isub__(self, other):
        self.client.decr(self.name, other)
        return self

    def __imul__(self, other):
        self.client.set(self.name, int.__mul__(self.__int__(), other))
        return self

    def __idiv__(self, other):
        self.client.set(self.name, int.__div__(self.__int__(), other))
        return self

    def __itruediv__(self, other):
        self.client.set(self.name, int.__truediv__(self.__int__(), other))
        return self

    def __ifloordiv__(self, other):
        self.client.set(self.name, int.__floordiv__(self.__int__(), other))
        return self

    def __imod__(self, other):
        self.client.set(self.name, int.__mod__(self.__int__(), other))
        return self

    def __ipow__(self, other):
        self.client.set(self.name, int.__pow__(self.__int__(), other))
        return self

    def __iand__(self, other):
        self.client.set(self.name, int.__and__(self.__int__(), other))
        return self

    def __ior__(self, other):
        self.client.set(self.name, int.__or__(self.__int__(), other))
        return self

    def __ixor__(self, other):
        self.client.set(self.name, int.__xor__(self.__int__(), other))
        return self

    def __ilshift__(self, other):
        self.client.set(self.name, int.__lshift__(self.__int__(), other))
        return self

    def __irshift__(self, other):
        self.client.set(self.name, int.__rshift__(self.__int__(), other))
        return self

    def __neg__(self):
        return int.__neg__(self.__int__())

    def __pos__(self):
        return int.__pos__(self.__int__())

    def __abs__(self):
        return int.__abs__(self.__int__())

    def __invert__(self):
        return int.__invert__(self.__int__())

    def __long__(self):
        return int.__long__(self.__int__())

    def __float__(self):
        return int.__float__(self.__int__())

    def __complex__(self):
        return int.__complex__(self.__int__())

    def __int__(self):
        return int(self.client.get(self.name))

    def __repr__(self):
        return repr(int(self))

    copy = __int__

def is_zsettable(s):
    """quick check that all values in a dict are reals"""
    return all(map(lambda x: isinstance(x, (int, float, long)), s.values()))


class ZSet(object):
    """The simplest local implementation to Redis's Sorted Set imaginable.
    Little thought given to performance, simply get the basic implementation
    right."""
    def __init__(self, initial={}):
        if not is_zsettable(initial):
            raise ValueError(initial)
        self._dict = initial

    def items(self):
        return sorted(self._dict.items(), key=lambda x: (x[1], x[0]))

    def __getitem__(self, s):
        return self._as_set()[s]

    def __len__(self):
        """``x.__len__() <==> len(x)``"""
        return len(self._dict)

    def __iter__(self):
        """``x.__iter__() <==> iter(x)``"""
        return iter(self._as_set())

    def __repr__(self):
        """``x.__repr__() <==> repr(x)``"""
        return repr(self._as_set())

    def add(self, member, score):
        """Add the specified member to the sorted set, or update the score
        if it already exist."""
        self._dict[member] = score

    def remove(self, member):
        """Remove member."""
        del self._dict[member]

    def discard(self, member):
        if member in self._dict:
            del self._dict[member]

    def increment(self, member, amount=1):
        """Increment the score of ``member`` by ``amount``."""
        self._dict[member] += amount
        return self._dict[member]

    def rank(self, member):
        """Rank the set with scores being ordered from low to high."""
        return self._as_set().index(member)

    def revrank(self, member):
        """Rank the set with scores being ordered from high to low."""
        return self.__len__() - self.rank(member) - 1

    def score(self, member):
        """Return the score associated with the specified member."""
        return self._dict[member]

    def range_by_score(self, min, max):
        """Return all the elements with score >= min and score <= max
        (a range query) from the sorted set."""
        data = self.items()
        keys = [r[1] for r in data] 
        start = bisect.bisect_left(keys, min)
        end = bisect.bisect_right(keys, max, start)
        return self._as_set()[start:end]

    def _as_set(self):
        return map(lambda x: x[0], self.items())

########NEW FILE########
__FILENAME__ = utils
import time
from datetime import datetime


def maybe_list(value):
    if hasattr(value, "__iter__"):
        return value
    if value is None:
        return []
    return [value]


def mkey(names):
    return ":".join(maybe_list(names))


def dt_to_timestamp(dt):
    """Convert :class:`datetime` to UNIX timestamp."""
    return time.mktime(dt.timetuple())

def maybe_datetime(timestamp):
    """Convert datetime to timestamp, only if timestamp
    is a datetime object."""
    if isinstance(timestamp, datetime):
        return dt_to_timestamp(timestamp)
    return timestamp

########NEW FILE########
