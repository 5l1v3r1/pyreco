__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# django-markup documentation build configuration file, created by
# sphinx-quickstart on Mon Jun  1 16:33:50 2009.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.append(os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'django-markup'
copyright = u'2009, Martin Mahner'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.4'
# The full version, including alpha/beta/rc tags.
release = '0.4'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'nature'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'django-markupdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'django-markup.tex', u'django-markup Documentation',
   u'Martin Mahner', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True

########NEW FILE########
__FILENAME__ = creole
# -*- coding: iso-8859-1 -*-
"""
    Creole wiki markup parser

    See http://wikicreole.org/ for latest specs.

    Notes:
    * No markup allowed in headings.
      Creole 1.0 does not require us to support this.
    * No markup allowed in table headings.
      Creole 1.0 does not require us to support this.
    * No (non-bracketed) generic url recognition: this is "mission impossible"
      except if you want to risk lots of false positives. Only known protocols
      are recognized.
    * We do not allow ":" before "//" italic markup to avoid urls with
      unrecognized schemes (like wtf://server/path) triggering italic rendering
      for the rest of the paragraph.

    @copyright: 2007 MoinMoin:RadomirDopieralski (creole 0.5 implementation),
                2007 MoinMoin:ThomasWaldmann (updates)
    @license: GNU GPL, see COPYING for details.
    @license: BSD, see COPYING for details.
"""

import re
import six

# Whether the parser should convert \n into <br>.
bloglike_lines = False

class Rules:
    """Hold all the rules for generating regular expressions."""

    # For the inline elements:
    proto = r'http|https|ftp|nntp|news|mailto|telnet|file|irc'
    url =  r'''(?P<url>
            (^ | (?<=\s | [.,:;!?()/=]))
            (?P<escaped_url>~)?
            (?P<url_target> (?P<url_proto> %s ):\S+? )
            ($ | (?=\s | [,.:;!?()] (\s | $)))
        )''' % proto
    link = r'''(?P<link>
            \[\[
            (?P<link_target>.+?) \s*
            ([|] \s* (?P<link_text>.+?) \s*)?
            ]]
        )'''
    image = r'''(?P<image>
            {{
            (?P<image_target>.+?) \s*
            ([|] \s* (?P<image_text>.+?) \s*)?
            }}
        )'''
    macro = r'''(?P<macro>
            <<
            (?P<macro_name> \w+)
            (\( (?P<macro_args> .*?) \))? \s*
            ([|] \s* (?P<macro_text> .+?) \s* )?
            >>
        )'''
    code = r'(?P<code> {{{ (?P<code_text>.*?) }}} )'
    emph = r'(?P<emph> (?<!:)// )' # there must be no : in front of the //
                                   # avoids italic rendering in urls with
                                   # unknown protocols
    strong = r'(?P<strong> \*\* )'
    linebreak = r'(?P<break> \\\\ )'
    escape = r'(?P<escape> ~ (?P<escaped_char>\S) )'
    char =  r'(?P<char> . )'

    # For the block elements:
    separator = r'(?P<separator> ^ \s* ---- \s* $ )' # horizontal line
    line = r'(?P<line> ^ \s* $ )' # empty line that separates paragraphs
    head = r'''(?P<head>
            ^ \s*
            (?P<head_head>=+) \s*
            (?P<head_text> .*? ) \s*
            (?P<head_tail>=*) \s*
            $
        )'''
    if bloglike_lines:
        text = r'(?P<text> .+ ) (?P<break> (?<!\\)$\n(?!\s*$) )?'
    else:
        text = r'(?P<text> .+ )'
    list = r'''(?P<list>
            ^ [ \t]* ([*][^*\#]|[\#][^\#*]).* $
            ( \n[ \t]* [*\#]+.* $ )*
        )''' # Matches the whole list, separate items are parsed later. The
             # list *must* start with a single bullet.
    item = r'''(?P<item>
            ^ \s*
            (?P<item_head> [\#*]+) \s*
            (?P<item_text> .*?)
            $
        )''' # Matches single list items
    pre = r'''(?P<pre>
            ^{{{ \s* $
            (\n)?
            (?P<pre_text>
                ([\#]!(?P<pre_kind>\w*?)(\s+.*)?$)?
                (.|\n)+?
            )
            (\n)?
            ^}}} \s*$
        )'''
    pre_escape = r' ^(?P<indent>\s*) ~ (?P<rest> \}\}\} \s*) $'
    table = r'''(?P<table>
            ^ \s*
            [|].*? \s*
            [|]? \s*
            $
        )'''

    # For splitting table cells:
    cell = r'''
            \| \s*
            (
                (?P<head> [=][^|]+ ) |
                (?P<cell> (  %s | [^|])+ )
            ) \s*
        ''' % '|'.join([link, macro, image, code])

class Parser:
    """
    Parse the raw text and create a document object
    that can be converted into output using Emitter.
    """

    # For pre escaping, in creole 1.0 done with ~:
    pre_escape_re = re.compile(Rules.pre_escape, re.M | re.X)
    link_re = re.compile('|'.join([Rules.image, Rules.linebreak, Rules.char]), re.X | re.U) # for link descriptions
    item_re = re.compile(Rules.item, re.X | re.U | re.M) # for list items
    cell_re = re.compile(Rules.cell, re.X | re.U) # for table cells
    # For block elements:
    block_re = re.compile('|'.join([Rules.line, Rules.head, Rules.separator,
        Rules.pre, Rules.list, Rules.table, Rules.text]), re.X | re.U | re.M)
    # For inline elements:
    inline_re = re.compile('|'.join([Rules.link, Rules.url, Rules.macro,
        Rules.code, Rules.image, Rules.strong, Rules.emph, Rules.linebreak,
        Rules.escape, Rules.char]), re.X | re.U)

    def __init__(self, raw):
        self.raw = raw
        self.root = DocNode('document', None)
        self.cur = self.root        # The most recent document node
        self.text = None            # The node to add inline characters to

    def _upto(self, node, kinds):
        """
        Look up the tree to the first occurence
        of one of the listed kinds of nodes or root.
        Start at the node node.
        """
        while node.parent is not None and not node.kind in kinds:
            node = node.parent
        return node

    # The _*_repl methods called for matches in regexps. Sometimes the
    # same method needs several names, because of group names in regexps.

    def _url_repl(self, groups):
        """Handle raw urls in text."""

        if not groups.get('escaped_url'):
            # this url is NOT escaped
            target = groups.get('url_target', '')
            node = DocNode('link', self.cur)
            node.content = target
            DocNode('text', node, node.content)
            self.text = None
        else:
            # this url is escaped, we render it as text
            if self.text is None:
                self.text = DocNode('text', self.cur, u'')
            self.text.content += groups.get('url_target')
    _url_target_repl = _url_repl
    _url_proto_repl = _url_repl
    _escaped_url = _url_repl

    def _link_repl(self, groups):
        """Handle all kinds of links."""

        target = groups.get('link_target', '')
        text = (groups.get('link_text', '') or '').strip()
        parent = self.cur
        self.cur = DocNode('link', self.cur)
        self.cur.content = target
        self.text = None
        re.sub(self.link_re, self._replace, text)
        self.cur = parent
        self.text = None
    _link_target_repl = _link_repl
    _link_text_repl = _link_repl

    def _macro_repl(self, groups):
        """Handles macros using the placeholder syntax."""

        name = groups.get('macro_name', '')
        text = (groups.get('macro_text', '') or '').strip()
        node = DocNode('macro', self.cur, name)
        node.args = groups.get('macro_args', '') or ''
        DocNode('text', node, text or name)
        self.text = None
    _macro_name_repl = _macro_repl
    _macro_args_repl = _macro_repl
    _macro_text_repl = _macro_repl

    def _image_repl(self, groups):
        """Handles images and attachemnts included in the page."""

        target = groups.get('image_target', '').strip()
        text = (groups.get('image_text', '') or '').strip()
        node = DocNode("image", self.cur, target)
        DocNode('text', node, text or node.content)
        self.text = None
    _image_target_repl = _image_repl
    _image_text_repl = _image_repl

    def _separator_repl(self, groups):
        self.cur = self._upto(self.cur, ('document', 'section', 'blockquote'))
        DocNode('separator', self.cur)

    def _item_repl(self, groups):
        bullet = groups.get('item_head', u'')
        text = groups.get('item_text', u'')
        if bullet[-1] == '#':
            kind = 'number_list'
        else:
            kind = 'bullet_list'
        level = len(bullet)
        lst = self.cur
        # Find a list of the same kind and level up the tree
        while (lst and
                   not (lst.kind in ('number_list', 'bullet_list') and
                        lst.level == level) and
                    not lst.kind in ('document', 'section', 'blockquote')):
            lst = lst.parent
        if lst and lst.kind == kind:
            self.cur = lst
        else:
            # Create a new level of list
            self.cur = self._upto(self.cur,
                ('list_item', 'document', 'section', 'blockquote'))
            self.cur = DocNode(kind, self.cur)
            self.cur.level = level
        self.cur = DocNode('list_item', self.cur)
        self.parse_inline(text)
        self.text = None
    _item_text_repl = _item_repl
    _item_head_repl = _item_repl

    def _list_repl(self, groups):
        text = groups.get('list', u'')
        self.item_re.sub(self._replace, text)

    def _head_repl(self, groups):
        self.cur = self._upto(self.cur, ('document', 'section', 'blockquote'))
        node = DocNode('header', self.cur, groups.get('head_text', '').strip())
        node.level = len(groups.get('head_head', ' '))
    _head_head_repl = _head_repl
    _head_text_repl = _head_repl

    def _text_repl(self, groups):
        text = groups.get('text', '')
        if self.cur.kind in ('table', 'table_row', 'bullet_list',
            'number_list'):
            self.cur = self._upto(self.cur,
                ('document', 'section', 'blockquote'))
        if self.cur.kind in ('document', 'section', 'blockquote'):
            self.cur = DocNode('paragraph', self.cur)
        else:
            text = u' ' + text
        self.parse_inline(text)
        if groups.get('break') and self.cur.kind in ('paragraph',
            'emphasis', 'strong', 'code'):
            DocNode('break', self.cur, '')
        self.text = None
    _break_repl = _text_repl

    def _table_repl(self, groups):
        row = groups.get('table', '|').strip()
        self.cur = self._upto(self.cur, (
            'table', 'document', 'section', 'blockquote'))
        if self.cur.kind != 'table':
            self.cur = DocNode('table', self.cur)
        tb = self.cur
        tr = DocNode('table_row', tb)

        text = ''
        for m in self.cell_re.finditer(row):
            cell = m.group('cell')
            if cell:
                self.cur = DocNode('table_cell', tr)
                self.text = None
                self.parse_inline(cell)
            else:
                cell = m.group('head')
                self.cur = DocNode('table_head', tr)
                self.text = DocNode('text', self.cur, u'')
                self.text.content = cell.strip('=')
        self.cur = tb
        self.text = None

    def _pre_repl(self, groups):
        self.cur = self._upto(self.cur, ('document', 'section', 'blockquote'))
        kind = groups.get('pre_kind', None)
        text = groups.get('pre_text', u'')
        def remove_tilde(m):
            return m.group('indent') + m.group('rest')
        text = self.pre_escape_re.sub(remove_tilde, text)
        node = DocNode('preformatted', self.cur, text)
        node.sect = kind or ''
        self.text = None
    _pre_text_repl = _pre_repl
    _pre_head_repl = _pre_repl
    _pre_kind_repl = _pre_repl

    def _line_repl(self, groups):
        self.cur = self._upto(self.cur, ('document', 'section', 'blockquote'))

    def _code_repl(self, groups):
        DocNode('code', self.cur, groups.get('code_text', u'').strip())
        self.text = None
    _code_text_repl = _code_repl
    _code_head_repl = _code_repl

    def _emph_repl(self, groups):
        if self.cur.kind != 'emphasis':
            self.cur = DocNode('emphasis', self.cur)
        else:
            self.cur = self._upto(self.cur, ('emphasis', )).parent
        self.text = None

    def _strong_repl(self, groups):
        if self.cur.kind != 'strong':
            self.cur = DocNode('strong', self.cur)
        else:
            self.cur = self._upto(self.cur, ('strong', )).parent
        self.text = None

    def _break_repl(self, groups):
        DocNode('break', self.cur, None)
        self.text = None

    def _escape_repl(self, groups):
        if self.text is None:
            self.text = DocNode('text', self.cur, u'')
        self.text.content += groups.get('escaped_char', u'')

    def _char_repl(self, groups):
        if self.text is None:
            self.text = DocNode('text', self.cur, u'')
        self.text.content += groups.get('char', u'')

    def _replace(self, match):
        """Invoke appropriate _*_repl method. Called for every matched group."""

        groups = match.groupdict()
        for name, text in six.iteritems(groups):
            if text is not None:
                replace = getattr(self, '_%s_repl' % name)
                replace(groups)
                return

    def parse_inline(self, raw):
        """Recognize inline elements inside blocks."""

        re.sub(self.inline_re, self._replace, raw)

    def parse_block(self, raw):
        """Recognize block elements."""

        re.sub(self.block_re, self._replace, raw)

    def parse(self):
        """Parse the text given as self.raw and return DOM tree."""

        self.parse_block(self.raw)
        return self.root

#################### Helper classes

### The document model and emitter follow

class DocNode:
    """
    A node in the document.
    """

    def __init__(self, kind='', parent=None, content=None):
        self.children = []
        self.parent = parent
        self.kind = kind
        self.content = content
        if self.parent is not None:
            self.parent.children.append(self)



########NEW FILE########
__FILENAME__ = creole2html
#!/usr/bin/env python
# -*- coding: utf-8 -*-

r"""
WikiCreole to HTML converter
This program is an example of how the creole.py WikiCreole parser
can be used.

@copyright: 2007 MoinMoin:RadomirDopieralski
@license: BSD, see COPYING for details.

Test cases contributed by Jan Klopper (janklopper@underdark.nl),
modified by Radomir Dopieralski (MoinMoin:RadomirDopieralski).

>>> import lxml.html.usedoctest
>>> def parse(text):
...     print HtmlEmitter(Parser(text).parse()).emit()

>>> parse(u'test')
<p>test</p>

>>> parse(u'test\ntest')
<p>test test</p>

>>> HtmlEmitter(Parser(u'test\ntest').parse()).emit()
u'<p>test test</p>\n'

>>> parse(u'test\n\ntest')
<p>test</p><p>test</p>

>>> parse(u'test\\\\test')
<p>test<br>test</p>

>>> parse(u'ÓÔÕÖØÙÚÛÜÝßàáâãäåæçèéêëìíîïñòóôõöøùúûüýÿŒœ%0A')
<p>ÓÔÕÖØÙÚÛÜÝßàáâãäåæçèéêëìíîïñòóôõöøùúûüýÿŒœ%0A</p>

>>> parse(u'----')
<hr>

>>> parse(u'==test==')
<h2>test</h2>

>>> parse(u'== test')
<h2>test</h2>

>>> parse(u'==test====')
<h2>test</h2>

>>> parse(u'=====test')
<h5>test</h5>

>>> parse(u'==test==\ntest\n===test===')
<h2>test</h2>
<p>test</p>
<h3>test</h3>

>>> parse(u'test\n* test line one\n * test line two\ntest\n\ntest')
<p>test</p>
<ul>
    <li>test line one</li>
    <li>test line two test</li>
</ul>
<p>test</p>

>>> parse(u'* test line one\n* test line two\n** Nested item')
<ul>
    <li>test line one</li>
    <li>test line two<ul>
        <li>Nested item</li>
    </ul></li>
</ul>

>>> parse(u'* test line one\n* test line two\n# Nested item')
<ul>
    <li>test line one</li>
    <li>test line two<ol>
        <li>Nested item</li>
    </ol></li>
</ul>

>>> parse(u'test //test test// test **test test** test')
<p>test <i>test test</i> test <b>test test</b> test</p>

>>> parse(u'test //test **test// test** test')
<p>test <i>test <b>test<i> test<b> test</b></i></b></i></p>

>>> parse(u'**test')
<p><b>test</b></p>

>>> parse(u'|x|y|z|\n|a|b|c|\n|d|e|f|\ntest')
<table>
    <tr><td>x</td><td>y</td><td>z</td></tr>
    <tr><td>a</td><td>b</td><td>c</td></tr>
    <tr><td>d</td><td>e</td><td>f</td></tr>
</table>
<p>test</p>

>>> parse(u'|=x|y|=z=|\n|a|b|c|\n|d|e|f|')
<table>
    <tr><th>x</th><td>y</td><th>z</th></tr>
    <tr><td>a</td><td>b</td><td>c</td></tr>
    <tr><td>d</td><td>e</td><td>f</td></tr>
</table>

>>> parse(u'test http://example.com/test test')
<p>test <a href="http://example.com/test">http://example.com/test</a> test</p>

>>> parse(u'http://example.com/,test, test')
<p><a href="http://example.com/,test">http://example.com/,test</a>, test</p>

>>> parse(u'(http://example.com/test)')
<p>(<a href="http://example.com/test">http://example.com/test</a>)</p>

XXX This might be considered a bug, but it's impossible to detect in general.
>>> parse(u'http://example.com/(test)')
<p><a href="http://example.com/(test">http://example.com/(test</a>)</p>

>>> parse(u'http://example.com/test?test&test=1')
<p><a href="http://example.com/test?test&amp;test=1">http://example.com/test?test&amp;test=1</a></p>

>>> parse(u'~http://example.com/test')
<p>http://example.com/test</p>

>>> parse(u'http://example.com/~test')
<p><a href="http://example.com/~test">http://example.com/~test</a></p>

>>> parse(u'[[test]] [[tset|test]]')
<p><a href="test">test</a> <a href="tset">test</a></p>

>>> parse(u'[[http://example.com|test]]')
<p><a href="http://example.com">test</a></p>
"""

import re
from creole import Parser

class Rules:
    # For the link targets:
    proto = r'http|https|ftp|nntp|news|mailto|telnet|file|irc'
    extern = r'(?P<extern_addr>(?P<extern_proto>%s):.*)' % proto
    interwiki = r'''
            (?P<inter_wiki> [A-Z][a-zA-Z]+ ) :
            (?P<inter_page> .* )
        '''

class HtmlEmitter:
    """
    Generate HTML output for the document
    tree consisting of DocNodes.
    """

    addr_re = re.compile('|'.join([
            Rules.extern,
            Rules.interwiki,
        ]), re.X | re.U) # for addresses

    def __init__(self, root):
        self.root = root

    def get_text(self, node):
        """Try to emit whatever text is in the node."""

        try:
            return node.children[0].content or ''
        except:
            return node.content or ''

    def html_escape(self, text):
        return text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')

    def attr_escape(self, text):
        return self.html_escape(text).replace('"', '&quot')

    # *_emit methods for emitting nodes of the document:

    def document_emit(self, node):
        return self.emit_children(node)

    def text_emit(self, node):
        return self.html_escape(node.content)

    def separator_emit(self, node):
        return u'<hr>';

    def paragraph_emit(self, node):
        return u'<p>%s</p>\n' % self.emit_children(node)

    def bullet_list_emit(self, node):
        return u'<ul>\n%s</ul>\n' % self.emit_children(node)

    def number_list_emit(self, node):
        return u'<ol>\n%s</ol>\n' % self.emit_children(node)

    def list_item_emit(self, node):
        return u'<li>%s</li>\n' % self.emit_children(node)

    def table_emit(self, node):
        return u'<table>\n%s</table>\n' % self.emit_children(node)

    def table_row_emit(self, node):
        return u'<tr>%s</tr>\n' % self.emit_children(node)

    def table_cell_emit(self, node):
        return u'<td>%s</td>' % self.emit_children(node)

    def table_head_emit(self, node):
        return u'<th>%s</th>' % self.emit_children(node)

    def emphasis_emit(self, node):
        return u'<i>%s</i>' % self.emit_children(node)

    def strong_emit(self, node):
        return u'<b>%s</b>' % self.emit_children(node)

    def header_emit(self, node):
        return u'<h%d>%s</h%d>\n' % (
            node.level, self.html_escape(node.content), node.level)

    def code_emit(self, node):
        return u'<tt>%s</tt>' % self.html_escape(node.content)

    def link_emit(self, node):
        target = node.content
        if node.children:
            inside = self.emit_children(node)
        else:
            inside = self.html_escape(target)
        m = self.addr_re.match(target)
        if m:
            if m.group('extern_addr'):
                return u'<a href="%s">%s</a>' % (
                    self.attr_escape(target), inside)
            elif m.group('inter_wiki'):
                raise NotImplementedError
        return u'<a href="%s">%s</a>' % (
            self.attr_escape(target), inside)

    def image_emit(self, node):
        target = node.content
        text = self.get_text(node)
        m = self.addr_re.match(target)
        if m:
            if m.group('extern_addr'):
                return u'<img src="%s" alt="%s">' % (
                    self.attr_escape(target), self.attr_escape(text))
            elif m.group('inter_wiki'):
                raise NotImplementedError
        return u'<img src="%s" alt="%s">' % (
            self.attr_escape(target), self.attr_escape(text))

    def macro_emit(self, node):
        raise NotImplementedError

    def break_emit(self, node):
        return u"<br>"

    def preformatted_emit(self, node):
        return u"<pre>%s</pre>" % self.html_escape(node.content)

    def default_emit(self, node):
        """Fallback function for emitting unknown nodes."""

        raise TypeError

    def emit_children(self, node):
        """Emit all the children of a node."""

        return u''.join([self.emit_node(child) for child in node.children])

    def emit_node(self, node):
        """Emit a single node."""

        emit = getattr(self, '%s_emit' % node.kind, self.default_emit)
        return emit(node)

    def emit(self):
        """Emit the document represented by self.root DOM tree."""

        return self.emit_node(self.root)

if __name__=="__main__":
    import sys
    document = Parser(unicode(sys.stdin.read(), 'utf-8', 'ignore')).parse()
    sys.stdout.write(HtmlEmitter(document).emit().encode('utf-8', 'ignore'))



########NEW FILE########
__FILENAME__ = test
#!/usr/bin/python
# -*- coding: utf-8 -*-

import doctest
import creole2html

if __name__ == "__main__":
    doctest.testmod(creole2html)

########NEW FILE########
__FILENAME__ = defaults
# The list of automatically loaded MarkupFilters
from django_markup.filter.linebreaks_filter import LinebreaksMarkupFilter
from django_markup.filter.markdown_filter import MarkdownMarkupFilter
from django_markup.filter.textile_filter import TextileMarkupFilter
from django_markup.filter.rst_filter import RstMarkupFilter
from django_markup.filter.smartypants_filter import SmartyPantsMarkupFilter
from django_markup.filter.none_filter import NoneMarkupFilter
from django_markup.filter.creole_filter import CreoleMarkupFilter
from django_markup.filter.lightbox_filter import LightboxMarkupFilter
from django_markup.filter.widont_filter import WidontMarkupFilter

# MarkupFilter that get's loaded automatically
# You can override this list within your settings: MARKUP_FILTER

DEFAULT_MARKUP_FILTER = {
    'creole': CreoleMarkupFilter,
    'linebreaks': LinebreaksMarkupFilter,
    'lightbox': LightboxMarkupFilter,
    'markdown': MarkdownMarkupFilter,
    'none': NoneMarkupFilter,
    'restructuredtext': RstMarkupFilter,
    'smartypants': SmartyPantsMarkupFilter,
    'textile': TextileMarkupFilter,
    'widont': WidontMarkupFilter,
}

# MarkupFilter that are the default value for choices, used in the MarkupField
# You can override this list within your settings: MARKUP_CHOICES

DEFAULT_MARKUP_CHOICES = (
    'none',
    'linebreaks',
    'markdown',
    'restructuredtext',
)
########NEW FILE########
__FILENAME__ = fields
from django.db.models.fields import CharField, TextField
from django.utils.translation import ugettext_lazy
from django.core.exceptions import ImproperlyConfigured
from django_markup.markup import formatter

class MarkupField(CharField):
    '''
    A CharField that holds the markup name for the row. In the admin it's
    displayed as a ChoiceField.
    '''
    def __init__(self, default=False, formatter=formatter, *args, **kwargs):
        # Check that the default value is a valid filter
        if default:
            if default not in formatter.filter_list:
                raise ImproperlyConfigured("'%s' is not a registered markup filter. Registered filters are: %s." %
                                           (default, ', '.join(formatter.filter_list.iterkeys())))
            kwargs.setdefault('default', default)

        kwargs.setdefault('max_length', 255)
        kwargs.setdefault('choices', formatter.choices())
        kwargs.setdefault('verbose_name', ugettext_lazy('markup'))
        CharField.__init__(self, *args, **kwargs)

# Tell South how to freeze the MarkupField model.
# Because MarkupField inherits from CharField and does not add any new
# arguments, no special introspection rules are needed.
try:
    from south.modelsinspector import add_introspection_rules
    add_introspection_rules([], ['django_markup\.fields\.MarkupField'])
except ImportError:
    pass

########NEW FILE########
__FILENAME__ = creole_filter
from django_markup.filter import MarkupFilter

class CreoleMarkupFilter(MarkupFilter):
    title = 'Creole (Wiki Syntax)'

    def render(self, text, **kwargs):
        from django_markup.bundles.WikiCreole.creole import Parser
        from django_markup.bundles.WikiCreole.creole2html import HtmlEmitter
        return HtmlEmitter(Parser(text).parse()).emit()
########NEW FILE########
__FILENAME__ = lightbox_filter
from django_markup.filter import MarkupFilter

class LightboxMarkupFilter(MarkupFilter):
    '''Add's a lightbox attributes to links that have images in it's target'''
    title = 'Lightbox Attribute'

    def __init__(self):
        import re
        self.r_lightbox = re.compile('<a (?=[^>]*\.(jpg|gif|png))(?![^>]*lightbox)')
        self.s_lightbox = '<a rel="lightbox" '

    def render(self, text, attribute='rel="lightbox"', **kwargs):
        return self.r_lightbox.sub(self.s_lightbox, text)
########NEW FILE########
__FILENAME__ = linebreaks_filter
from django.template.defaultfilters import linebreaks
from django_markup.filter import MarkupFilter

class LinebreaksMarkupFilter(MarkupFilter):
    """
    Replaces line breaks in plain text with appropriate HTML; a single
    newline becomes an HTML line break (``<br />``) and a new line
    followed by a blank line becomes a paragraph break (``</p>``).
    """
    title = 'Linebreaks'

    def render(self, text, **kwargs):
        return linebreaks(text, **kwargs)
########NEW FILE########
__FILENAME__ = markdown_filter
from django_markup.filter import MarkupFilter

class MarkdownMarkupFilter(MarkupFilter):
    """
    Applies Markdown conversion to a string, and returns the HTML. If the
    pygments library is installed, it highlights code blocks with it.
    """
    title = 'Markdown'
    use_pygments = False

    def __init__(self):
        try:
            # Check if pygments is installed and highlight code blocks.
            import pygments
            self.use_pygments = True
        except ImportError:
            pass

    def render(self, text, **kwargs):
        from markdown import markdown
        text = markdown(text, **kwargs)
        if self.use_pygments:
            text = self.pygmentize(text)
        return text

    def get_lexer(self, code_string, lexer_prefix='#!'):
        """
        Resolves the lexer name out of a code block.
        """
        from pygments import lexers
        from pygments.util import ClassNotFound

        lexer_line = code_string.splitlines()[0]
        if lexer_line.startswith(lexer_prefix):
            lexer_name = lexer_line[len(lexer_prefix):].strip(' ')
            code_string = '\n'.join(code_string.splitlines()[1:])
            try:
                lexer = lexers.get_lexer_by_name(lexer_name)
            except ClassNotFound:
                try:
                    lexer = lexers.guess_lexer(code_string)
                except ClassNotFound:
                    lexer = lexers.TextLexer()
        else:
            try:
                lexer = lexers.guess_lexer(code_string)
            except ClassNotFound:
                lexer = lexers.TextLexer()
        return (code_string, lexer)

    def pygmentize(self, text, pygments_formatter=None, **kwargs):
        """
        Replaces naked code blocks with highlighted.
        """
        import pygments
        from pygments import formatters
        import re

        if not pygments_formatter:
            pygments_formatter = formatters.HtmlFormatter

        regex = re.compile(r'(<pre><code>(.*?)</code></pre>)', re.DOTALL)
        last_end = 0
        to_return = ''
        found = 0
        for match_obj in regex.finditer(text):
            code_string = match_obj.group(2)
            code_string, lexer = self.get_lexer(code_string)
            code_string = code_string.replace('&gt;', '>')
            code_string = code_string.replace('&lt;', '<')
            pygmented_string = pygments.highlight(code_string, lexer, pygments_formatter())
            pygmented_string = pygmented_string.replace('&amp;', '&')
            to_return = to_return + text[last_end:match_obj.start(1)] + pygmented_string
            last_end = match_obj.end(1)
            found += 1
        to_return = to_return + text[last_end:]
        return to_return

########NEW FILE########
__FILENAME__ = none_filter
from django_markup.filter import MarkupFilter

class NoneMarkupFilter(MarkupFilter):
    """
    Simply returns the text without any modification. This is the same as the
    base class does.
    """
    title = 'None (no processing)'
########NEW FILE########
__FILENAME__ = rst_filter
from __future__ import unicode_literals

from django_markup.filter import MarkupFilter

class RstMarkupFilter(MarkupFilter):
    """
    Converts a reStructuredText string to HTML. If the pygments library is
    installed you can use a special `sourcecode` directive to highlight
    portions of your text. Example:

    .. sourcecode: python

        def foo():
            return 'foo'
    """
    title = 'reStructuredText'

    def __init__(self):
        # Check if pygments is installed and load it's directive
        try:
            import pygments
            from docutils.parsers.rst import directives
            directives.register_directive('sourcecode', self.pygments_directive)
        except ImportError:
            pass

    def render(self, text, **kwargs):
        from docutils import core
        publish_args = {'source': text, 'writer_name': 'html4css1'}
        publish_args.update(**kwargs)
        parts = core.publish_parts(**publish_args)
        return parts['fragment']

    def pygments_directive(self, name, arguments, options, content, lineno,
                           content_offset, block_text, state, state_machine,
                           pygments_formatter=None):
        import pygments
        from pygments import formatters, lexers
        from docutils import nodes

        if not pygments_formatter:
            pygments_formatter = formatters.HtmlFormatter

        try:
            lexer = lexers.get_lexer_by_name(arguments[0])
        except ValueError:
            lexer = lexers.TextLexer()

        parsed = pygments.highlight('\n'.join(content), lexer, pygments_formatter())
        return [nodes.raw('', parsed, format='html')]
    pygments_directive.arguments = (1, 0, 1)
    pygments_directive.content = 1

########NEW FILE########
__FILENAME__ = smartypants_filter
from django_markup.filter import MarkupFilter

class SmartyPantsMarkupFilter(MarkupFilter):
    title = 'SmartyPants'

    def render(self, text, **kwargs):
        from smartypants import smartyPants
        return smartyPants(text, **kwargs)
########NEW FILE########
__FILENAME__ = textile_filter
from django_markup.filter import MarkupFilter

class TextileMarkupFilter(MarkupFilter):
    title = 'Textile'

    def render(self, text, **kwargs):
        from textile import textile
        return textile(text, **kwargs)
########NEW FILE########
__FILENAME__ = widont_filter
from django_markup.filter import MarkupFilter

class WidontMarkupFilter(MarkupFilter):
    title = 'Widont'

    def render(self, text, **kwargs):
        return '&nbsp;'.join(text.strip().rsplit(' ', 1))
########NEW FILE########
__FILENAME__ = markup
import six

from django.conf import settings
from django_markup.defaults import DEFAULT_MARKUP_FILTER, DEFAULT_MARKUP_CHOICES

class MarkupFormatter(object):

    def __init__(self, load_defaults=True):
        self.filter_list = {}

        if load_defaults:
            filter_list = getattr(settings, 'MARKUP_FILTER', DEFAULT_MARKUP_FILTER)
            for filter_name, filter_class in six.iteritems(filter_list):
                self.register(filter_name, filter_class)

    def _get_filter_title(self, filter_name):
        '''
        Returns the human readable title of a given filter_name. If no title
        attribute is set, the filter_name is used, where underscores are
        replaced with whitespaces and the first character of each word is
        uppercased. Example:

        >>> MarkupFormatter._get_title('markdown')
        'Markdown'

        >>> MarkupFormatter._get_title('a_cool_filter_name')
        'A Cool Filter Name'
        '''
        title = getattr(self.filter_list[filter_name], 'title', None)
        if not title:
            title = ' '.join([w.title() for w in filter_name.split('_')])
        return title

    def choices(self):
        '''
        Returns the filter list as a tuple. Useful for model choices.
        '''
        choice_list = getattr(settings, 'MARKUP_CHOICES', DEFAULT_MARKUP_CHOICES)
        return [(f, self._get_filter_title(f)) for f in choice_list]

    def register(self, filter_name, filter_class):
        '''
        Register a new filter for use
        '''
        self.filter_list[filter_name] = filter_class

    def update(self, filter_name, filter_class):
        '''
        Yep, this is the same as register, it just sounds better.
        '''
        self.filter_list[filter_name] = filter_class

    def unregister(self, filter_name):
        '''
        Unregister a filter from the filter list
        '''
        if filter_name in self.filter_list:
            self.filter_list.pop(filter_name)

    def flush(self):
        '''
        Flushes the filter list.
        '''
        self.filter_list = {}

    def __call__(self, text, filter_name=None, **kwargs):
        '''
        Applies text-to-HTML conversion to a string, and returns the
        HTML.

        TODO: `filter` should either be a filter_name or a filter class.
        '''

        filter_fallback = getattr(settings, 'MARKUP_FILTER_FALLBACK', False)
        if not filter_name and filter_fallback:
            filter_name = filter_fallback

        # Check that the filter_name is a registered markup filter
        if filter_name not in self.filter_list:
            raise ValueError("'%s' is not a registered markup filter. Registered filters are: %s." %
                             (filter_name, ', '.join(self.filter_list.iterkeys())))
        filter_class = self.filter_list[filter_name]

        # Read global filter settings and apply it
        filter_kwargs = {}
        filter_settings = getattr(settings, 'MARKUP_SETTINGS', {})
        if filter_name in filter_settings:
            filter_kwargs.update(filter_settings[filter_name])
        filter_kwargs.update(**kwargs)

        # Apply the filter on text
        return filter_class().render(text, **filter_kwargs)


# Unless you need to have multiple instances of MarkupFormatter lying
# around, or want to subclass it, the easiest way to use it is to
# import this instance.
#
# Note if you create a new instance of MarkupFormatter(), the built
# in filters are not assigned.

formatter = MarkupFormatter()

########NEW FILE########
__FILENAME__ = markup_tags
from django.template import Library
from django_markup.markup import formatter
from django.utils.safestring import mark_safe

register = Library()

@register.filter
def apply_markup(text, filter_name):
    return mark_safe(formatter(text, filter_name))
########NEW FILE########
