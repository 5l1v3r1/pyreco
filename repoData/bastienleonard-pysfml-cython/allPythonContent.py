__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# pySFML - Cython documentation build configuration file, created by
# sphinx-quickstart on Fri Feb 18 08:41:37 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

ON_READ_THE_DOCS = True if 'READTHEDOCS' in os.environ else False

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'pySFML - Cython'
copyright = u'2011, 2012 Bastien Léonard'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.2'
# The full version, including alpha/beta/rc tags.
release = '0.2'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.

# Pyramid is a fairly recent theme that may not be available locally,
# so we only use it online.
html_theme = 'pyramid' if ON_READ_THE_DOCS else 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'pySFML-Cythondoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'pySFML-Cython.tex', u'pySFML - Cython Documentation',
   u'Bastien Léonard', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'pysfml-cython', u'pySFML - Cython Documentation',
     [u'Bastien Léonard'], 1)
]

########NEW FILE########
__FILENAME__ = customdrawable
#! /usr/bin/env python2
# -*- coding: utf-8 -*-

import sfml as sf


class Drawable(object):
    def __init__(self):
        self.princess = sf.Sprite(sf.Texture.load_from_file('princess.png'))
        self.logo = sf.Sprite(sf.Texture.load_from_file('python-logo.png'))

    def draw(self, target, states):
        target.draw(self.logo)
        target.draw(self.princess)


class LowLevelDrawable(object):
    def draw(self, target, states):
        vertices = [sf.Vertex((200, 150), sf.Color.BLACK),
                    sf.Vertex((400, 150), sf.Color.RED),
                    sf.Vertex((400, 350), sf.Color.BLUE),
                    sf.Vertex((200, 350), sf.Color.MAGENTA)]
        target.draw(vertices, sf.TRIANGLES_FAN)


window = sf.RenderWindow(sf.VideoMode(640, 480), 'User defined drawable')
window.framerate_limit = 60
running = True
drawable = Drawable()
low_level_drawable = LowLevelDrawable()

while running:
    for event in window.iter_events():
        if event.type == sf.Event.CLOSED:
            running = False

    window.clear(sf.Color.WHITE)
    window.draw(drawable)
    window.draw(low_level_drawable)
    window.display()

########NEW FILE########
__FILENAME__ = events
#! /usr/bin/env python2
# -*- coding: utf-8 -*-

import sfml as sf


class EventQueue(object):
    def __init__(self, max_events, font):
        self.max_events = max_events
        self.font = font
        self.events = []

    def add(self, event):
        self.events.append(event)

        if len(self.events) > self.max_events:
            self.events.pop(0)

    # We could make it a custom drawable, but I personally don't like it
    def draw(self, window):
        y = 0
        text = sf.Text('Last events, with event attributes:', self.font, 14)
        text.color = sf.Color.BLACK
        window.draw(text)

        for event in reversed(self.events):
            y += text.global_bounds.height
            text.string = str(event)
            text.color = sf.Color.BLACK
            text.y = y
            window.draw(text)


def main():
    window = sf.RenderWindow(sf.VideoMode(800, 600), 'SFML Events example')
    window.framerate_limit = 60
    running = True
    font = sf.Font.load_from_file('LinBiolinum_Re.ttf')
    events = EventQueue(50, font)

    while running:
        for event in window.iter_events():
            # Stop running if the application is closed
            # or if the user presses Escape
            if (event.type == sf.Event.CLOSED or
               (event.type == sf.Event.KEY_PRESSED and
                event.code == sf.Keyboard.ESCAPE)):
                running = False

            events.add(event)

        window.clear(sf.Color.WHITE)
        events.draw(window)
        window.display()

    window.close()


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = image
#! /usr/bin/env python2
# -*- coding: utf-8 -*-

import sfml as sf


def main():
    window = sf.RenderWindow(sf.VideoMode(640, 480), 'Image example')
    window.framerate_limit = 60
    logo = sf.Image.load_from_file('python-logo.png')
    princess = sf.Image.load_from_file('princess.png')
    logo.copy(princess, 0, 0, sf.IntRect(0, 0, 0, 0), True)
    texture = sf.Texture.load_from_image(logo)
    sprite = sf.Sprite(texture)
    running = True

    while running:
        for event in window.iter_events():
            if event.type == sf.Event.CLOSED:
                running = False

        window.clear(sf.Color.WHITE)
        window.draw(sprite)
        window.display()

    window.close()


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = inputstream
#! /usr/bin/env python2
# -*- coding: utf-8 -*-

import sys

import sfml as sf


class Stream(sf.InputStream):
    def __init__(self, filename):
        sf.InputStream.__init__(self)
        self.filename = filename
        self.file = open(filename, 'rb')
        self.file.seek(0, 2)
        self.size = self.file.tell()
        self.file.seek(0)

    def get_size(self):
        print('{0}: get_size()'.format(self.filename))
        return self.size

    def read(self, size):
        print('{0}: read({1})'.format(self.filename, size))

        return self.file.read(size)

    def seek(self, position):
        print('{0}: seek({1})'.format(self.filename, position))
        self.file.seek(position)

        return self.tell()

    def tell(self):
        print('{0}: tell()'.format(self.filename))

        return self.file.tell()

    def close(self):
        self.file.close()



def main(args):
    window = sf.RenderWindow(sf.VideoMode(640, 480), 'InputStream example')
    window.framerate_limit = 60
    running = True
    error_message = None
    texture_stream = Stream('python-logo.png')
    texture = sf.Texture.load_from_stream(texture_stream)
    sprite = sf.Sprite(texture)
    music = None
    music_stream = None

    if len(args) > 1:
        music_stream = Stream(args[1])
        music = sf.Music.open_from_stream(music_stream)
        music.play()
    else:
        error_message = sf.Text(
            "Error: please provide an audio file as a command-line argument\n"
            "Example: ./soundstream.py music.ogg")
        error_message.color = sf.Color.BLACK
        error_message.character_size = 18


    while running:
        for event in window.iter_events():
            if event.type == sf.Event.CLOSED:
                running = False

        window.clear(sf.Color.WHITE)
        window.draw(sprite)

        if error_message is not None:
            window.draw(error_message)

        window.display()

    texture_stream.close()

    if music is not None:
        music.stop()

    if music_stream is not None:
        music_stream.close()

    window.close()


if __name__ == '__main__':
    main(sys.argv)

########NEW FILE########
__FILENAME__ = pixels
#! /usr/bin/env python2
# -*- coding: utf-8 -*-

import struct

import sfml as sf


# This example shows how you can manipulate the raw string given by
# sf.Image.get_pixels().


def main():
    window = sf.RenderWindow(sf.VideoMode(640, 480), 'Pixels test')
    window.framerate_limit = 60
    princess = sf.Image.load_from_file('princess.png')
    new_image = sf.Image(princess.width, princess.height)
    pixels = princess.get_pixels()
    unpacker = struct.Struct('BBBB')

    for i in xrange(princess.width):
        for j in xrange(princess.height):
            k = i * 4 + j * princess.width * 4
            s = pixels[k:k+4]

            if s:
                color = sf.Color(*unpacker.unpack(s))
                mean = (color.r + color.g + color.b) / 3
                color.r = color.g = color.b = mean
                new_image[i,j] = color
            else:
                pass

    texture = sf.Texture.load_from_image(new_image)
    sprite = sf.Sprite(texture)
    running = True

    while running:
        for event in window.iter_events():
            if event.type == sf.Event.CLOSED:
                running = False

        window.clear(sf.Color.WHITE)
        window.draw(sprite)
        window.display()

    window.close()


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = main
#! /usr/bin/env python2
# -*- coding: utf-8 -*-

# This example is ported from the SFML C++ examples.

import math
import random

import sfml as sf


def main():
    # Create the window of the application
    window = sf.RenderWindow(sf.VideoMode(800, 600, 32), 'PySFML Pong');

    # Load the sounds used in the game
    ball_sound_buffer = sf.SoundBuffer.load_from_file("resources/ball.wav")
    ball_sound = sf.Sound(ball_sound_buffer);

    # Load the textures used in the game
    background_texture = sf.Texture.load_from_file('resources/background.jpg')
    left_paddle_texture = sf.Texture.load_from_file('resources/paddle_left.png')
    right_paddle_texture = sf.Texture.load_from_file(
        'resources/paddle_right.png')
    ball_texture = sf.Texture.load_from_file('resources/ball.png')

    # Load the text font
    font = sf.Font.load_from_file('resources/sansation.ttf')

    # Initialize the end text
    end = sf.Text()
    end.font = font
    end.character_size = 60
    end.move(150, 200);
    end.color = sf.Color(50, 50, 250)

    # Create the sprites of the background, the paddles and the ball
    background = sf.Sprite(background_texture)
    left_paddle = sf.Sprite(left_paddle_texture)
    right_paddle = sf.Sprite(right_paddle_texture)
    ball = sf.Sprite(ball_texture)

    left_paddle.move(
        10, (window.view.size[1] - left_paddle.global_bounds.height) / 2)
    right_paddle.move(
        window.view.size[0] - right_paddle.global_bounds.width - 10,
        (window.view.size[1] - right_paddle.global_bounds.height) / 2)
    ball.move((window.view.size[0] - ball.global_bounds.width) / 2,
              (window.view.size[1] - ball.global_bounds.height) / 2)

    # Define the paddles properties
    ai_timer = sf.Clock()
    ai_time = sf.Time(milliseconds=100)
    left_paddle_speed  = 0.4
    right_paddle_speed = 0.4

    # Define the ball properties
    ball_speed = 0.4
    ball_angle = 0.0

    clock = sf.Clock()

    while True:
        # Make sure the ball initial angle is not too much vertical
        ball_angle = random.uniform(0.0, 2 * math.pi)

        if abs(math.cos(ball_angle)) < 0.7:
            break

    is_playing = True

    while window.open:
        # Handle events
        for event in window.iter_events():
            # Window closed or escape key pressed : exit
            if ((event.type == sf.Event.CLOSED) or
                (event.type == sf.Event.KEY_PRESSED and
                 event.code == sf.Keyboard.ESCAPE)):
                window.close()
                break

        frame_time = clock.restart().as_milliseconds()

        if is_playing:
            # Move the player's paddle
            if (sf.Keyboard.is_key_pressed(sf.Keyboard.UP) and
                left_paddle.y > 5.0):
                left_paddle.move(0.0, -left_paddle_speed * frame_time)

            if (sf.Keyboard.is_key_pressed(sf.Keyboard.DOWN) and
                (left_paddle.y <
                 window.view.size[1] - left_paddle.global_bounds.height - 5.0)):
                left_paddle.move(0.0, left_paddle_speed * frame_time)

            # Move the computer's paddle
            if (((right_paddle_speed < 0.0) and
                 (right_paddle.y > 5.0)) or
                ((right_paddle_speed > 0.0) and
                 (right_paddle.y < window.view.size[1] -
                  right_paddle.global_bounds.height - 5.0))):
                right_paddle.move(0.0, right_paddle_speed * frame_time)

            # Update the computer's paddle direction according
            # to the ball position
            if ai_timer.elapsed_time > ai_time:
                ai_timer.restart()

                if (right_paddle_speed < 0 and
                    (ball.y + ball.global_bounds.height >
                     right_paddle.y + right_paddle.global_bounds.height)):
                    right_paddle_speed = -right_paddle_speed

                if right_paddle_speed > 0 and ball.y < right_paddle.y:
                    right_paddle_speed = -right_paddle_speed;

            # Move the ball
            factor = ball_speed * frame_time
            ball.move(math.cos(ball_angle) * factor,
                      math.sin(ball_angle) * factor)

            # Check collisions between the ball and the screen
            if ball.x < 0.0:
                is_playing = False
                end.string = "You lost !\n(press escape to exit)"

            if ball.x + ball.global_bounds.width > window.view.size[0]:
                is_playing = False
                end.string = "You won !\n(press escape to exit)"

            if ball.y < 0.0:
                ball_sound.play();
                ball_angle = -ball_angle
                ball.y = 0.1

            if ball.y + ball.global_bounds.height > window.view.size[1]:
                ball_sound.play()
                ball_angle = -ball_angle
                ball.y = window.view.size[1] - ball.global_bounds.height - 0.1

            # Check the collisions between the ball and the paddles
            # Left Paddle
            if (ball.x < left_paddle.x + left_paddle.global_bounds.width and
                ball.x > left_paddle.x +
                (left_paddle.global_bounds.width / 2.0) and
                ball.y + ball.global_bounds.height >= left_paddle.y and
                ball.y <= left_paddle.y + left_paddle.global_bounds.height):
                ball_sound.play()
                ball_angle = math.pi - ball_angle
                ball.x = left_paddle.x + left_paddle.global_bounds.width + 0.1

            # Right Paddle
            if (ball.x + ball.global_bounds.width > right_paddle.x and
                ball.x + ball.global_bounds.width < right_paddle.x +
                (right_paddle.global_bounds.width / 2.0) and
                ball.y + ball.global_bounds.height >= right_paddle.y and
                ball.y <= right_paddle.y + right_paddle.global_bounds.height):
                # ball_sound.play();
                ball_angle = math.pi - ball_angle
                ball.x = right_paddle.x - ball.global_bounds.width - 0.1

        # Clear the window
        window.clear()

        # Draw the background, paddles and ball sprites
        window.draw(background)
        window.draw(left_paddle)
        window.draw(right_paddle)
        window.draw(ball)

        # If the game is over, display the end message
        if not is_playing:
            window.draw(end)

        # Display things on screen
        window.display()


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = rendertexture
#! /usr/bin/env python2
# -*- coding: utf-8 -*-

# Please note that this example may not work on all GPUs (eg. intel chipsets)
# because of a bug in the drivers. See the corresponding SFML issue:
# https://github.com/LaurentGomila/SFML/issues/101

import sfml as sf


def main():
    window = sf.RenderWindow(sf.VideoMode(640, 480),
                             'SFML RenderTexture example')
    window.framerate_limit = 60
    running = True
    
    rect0 = sf.RectangleShape((5, 5))
    rect0.position = (90, 50)
    rect0.fill_color = sf.Color.GREEN
    rect0.outline_color = sf.Color.BLUE
    rect0.outline_thickness = 2.0

    rect1 = sf.RectangleShape((20, 30))
    rect1.position = (50, 50)
    rect1.fill_color = sf.Color.CYAN

    rt = sf.RenderTexture(110, 110)
    rt.clear(sf.Color(0, 0, 0, 0))
    rt.draw(rect0)
    rt.draw(rect1)
    rt.display()
    s = sf.Sprite(rt.texture)
    s.origin = (55, 55)
    s.position = (320, 240)

    while running:
        for event in window.iter_events():
            if event.type == sf.Event.CLOSED:
                running = False

        window.clear(sf.Color.WHITE)
        s.rotate(5)
        window.draw(s)
        window.display()
    window.close()


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = main
#! /usr/bin/env python2
# -*- coding: utf-8 -*-

# This example is ported from the SFML C++ examples.


import math

import sfml as sf


NOTHING, BLUR, COLORIZE, EDGE, FISHEYE, WAVE, PIXELATE = range(7)


# Quick and dirty port of the equivalent class in the C++ example, not
# very elegant but it does the trick. It uses a list and array indexes
# instead of a dict and iterators because Python's iterators don't
# allow to go backwards. collections.OrderedDict is probably the way
# to go but requires to access the __root internal attribute to go
# backwards AFAIK.
class ShaderSelector(object):
    def __init__(self, shaders):
        self.shaders = shaders
        self.current = 0

    def go_to_previous(self):
        if self.current > 0:
            self.current -= 1
        else:
            self.current = len(self.shaders) - 1

        assert 0 <= self.current < len(self.shaders)

    def go_to_next(self):
        if self.current < len(self.shaders) - 1:
            self.current += 1
        else:
            self.current = 0

        assert 0 <= self.current < len(self.shaders)

    def update(self, x, y):
        current = self.shaders[self.current]

        if self.current == BLUR:
            current.set_parameter('offset', x * y * 0.03)
        elif self.current == COLORIZE:
            current.set_parameter('color', 0.3, x, y)
        elif self.current == EDGE:
            current.set_parameter('threshold', x * y)
        elif self.current == FISHEYE:
            current.set_parameter('mouse', x, y)
        elif self.current == WAVE:
            current.set_parameter('offset', x, y)
        elif self.current == PIXELATE:
            current.set_parameter('mouse', x, y)
    
    def get_name(self):
        names = ['nothing', 'blur', 'colorize', 'edge', 'fisheye', 'wave',
                 'pixelate']

        return names[self.current]

    def get_shader(self):
        return self.shaders[self.current]


def display_error():
    # Create the main window
    window = sf.RenderWindow(sf.VideoMode(800, 600), 'SFML Shader example')

    # Define a string for displaying the error message
    error = sf.Text("Sorry, your system doesn't support shaders")
    error.position = (100.0, 250.0)
    error.color = sf.Color(200, 100, 150)

    # Start the game loop
    while window.opened:
        # Process events
        for event in window.iter_events():
            # Close window: exit
            if event.type == sf.Event.CLOSED:
                window.close()

            # Escape key: exit
            if (event.type == sf.Event.KEY_PRESSED and
                event.code == sf.Keyboard.ESCAPE):
                window.close()

        # Clear the window
        window.clear()

        # Draw the error message
        window.draw(error)

        # Finally, display the rendered frame on screen
        window.display()



def main():
    if not sf.Shader.IS_AVAILABLE:
        display_error()

    # Create the main window
    window = sf.RenderWindow(sf.VideoMode(800, 600), 'SFML shader example')

    clock = sf.Clock()

    # Create the render texture
    texture = sf.RenderTexture(window.width, window.height)

    # Load a background texture to display
    background_texture = sf.Texture.load_from_file('resources/background.jpg')
    background = sf.Sprite(background_texture)

    # Load a sprite which we'll move into the scene
    entity_texture = sf.Texture.load_from_file('resources/sprite.png')
    entity = sf.Sprite(entity_texture)

    # Load the text font
    font = sf.Font.load_from_file('resources/sansation.ttf')

    # Load the texture needed for the wave shader
    wave_texture = sf.Texture.load_from_file('resources/wave.jpg')

    # Load all shaders
    shaders = [None] * 7
    shaders[NOTHING] = sf.Shader.load_from_file('resources/nothing.sfx',
                                                 sf.Shader.FRAGMENT)
    shaders[BLUR] = sf.Shader.load_from_file('resources/blur.sfx',
                                             sf.Shader.FRAGMENT)
    shaders[COLORIZE] = sf.Shader.load_from_file('resources/colorize.sfx',
                                                 sf.Shader.FRAGMENT)
    shaders[EDGE] = sf.Shader.load_from_file('resources/edge.sfx',
                                             sf.Shader.FRAGMENT)
    shaders[FISHEYE] = sf.Shader.load_from_file('resources/fisheye.sfx',
                                                sf.Shader.FRAGMENT)
    shaders[WAVE] = sf.Shader.load_from_file('resources/wave.sfx',
                                             sf.Shader.FRAGMENT)
    shaders[PIXELATE] = sf.Shader.load_from_file('resources/pixelate.sfx',
                                                 sf.Shader.FRAGMENT)

    background_shader = ShaderSelector(shaders)
    entity_shader = ShaderSelector(shaders)
    global_shader = ShaderSelector(shaders)

    # Do specific initializations
    shaders[NOTHING].set_parameter('texture', sf.Shader.CURRENT_TEXTURE)
    shaders[BLUR].set_parameter('texture', sf.Shader.CURRENT_TEXTURE)
    shaders[BLUR].set_parameter('offset', 0.0)
    shaders[COLORIZE].set_parameter('texture', sf.Shader.CURRENT_TEXTURE)
    shaders[COLORIZE].set_parameter('color', 1.0, 1.0, 1.0)
    shaders[EDGE].set_parameter('texture', sf.Shader.CURRENT_TEXTURE)
    shaders[FISHEYE].set_parameter('texture', sf.Shader.CURRENT_TEXTURE)
    shaders[WAVE].set_parameter('texture', sf.Shader.CURRENT_TEXTURE)
    shaders[WAVE].set_parameter('wave', wave_texture)
    shaders[PIXELATE].set_parameter('texture', sf.Shader.CURRENT_TEXTURE)

    # Define a string for displaying the description of the current shader
    shader_str = sf.Text()
    shader_str.font = font
    shader_str.character_size = 20
    shader_str.position = (5.0, 0.0)
    shader_str.color = sf.Color(250, 100, 30)
    shader_str.string = ("Background shader: \"{0}\"\n"
                         "Flower shader: \"{1}\"\n"
                         "Global shader: \"{2}\"\n"
                         .format(background_shader.get_name(),
                                 entity_shader.get_name(),
                                 global_shader.get_name()))


    # Define a string for displaying help
    info_str = sf.Text()
    info_str.font = font
    info_str.character_size = 20
    info_str.position = (5.0, 500.0)
    info_str.color = sf.Color(250, 100, 30)
    info_str.string = ("Move your mouse to change the shaders' parameters\n"
                       "Press numpad 1/4 to change the background shader\n"
                       "Press numpad 2/5 to change the flower shader\n"
                       "Press numpad 3/6 to change the global shader")

    # Create a clock to measure the total time elapsed
    clock = sf.Clock()

    # Start the game loop
    while window.open:
        # Process events
        for event in window.iter_events():
            # Close window : exit
            if event.type == sf.Event.CLOSED:
                window.close()

            if event.type == sf.Event.KEY_PRESSED:
                # Escape key : exit
                if event.code == sf.Keyboard.ESCAPE:
                    window.close()

                # Numpad : switch effect
                if event.code == sf.Keyboard.NUMPAD1:
                    background_shader.go_to_previous()
                elif event.code == sf.Keyboard.NUMPAD4:
                    background_shader.go_to_next()
                elif event.code == sf.Keyboard.NUMPAD2:
                    entity_shader.go_to_previous()
                elif event.code == sf.Keyboard.NUMPAD5:
                    entity_shader.go_to_next()
                elif event.code == sf.Keyboard.NUMPAD3:
                    global_shader.go_to_previous()
                elif event.code == sf.Keyboard.NUMPAD6:
                    global_shader.go_to_next()

                # Update the text
                shader_str.string = (
                    "Background shader: \"{0}\"\n"
                    "Entity shader: \"{1}\"\n"
                    "Global shader: \"{2}\"\n"
                    .format(background_shader.get_name(),
                            entity_shader.get_name(),
                            global_shader.get_name()))

        frame_time = clock.restart().as_milliseconds()

        # Get the mouse position in the range [0, 1]
        if window.width and window.height:
            mouse_x = sf.Mouse.get_position(window)[0] / float(window.width)
            mouse_y = sf.Mouse.get_position(window)[1] / float(window.height)

        # Update the shaders
        background_shader.update(mouse_x, mouse_y);
        entity_shader.update(mouse_x, mouse_y);
        global_shader.update(mouse_x, mouse_y);

        # Animate the entity
        entity_x = ((math.cos(clock.elapsed_time.as_milliseconds() * 0.0013) +
                     1.2) * 300)
        entity_y = ((math.cos(clock.elapsed_time.as_milliseconds() * 0.0008) +
                     1.2) * 200)
        entity.position = (entity_x, entity_y)
        entity.rotate(frame_time * 0.1)

        # Draw the background and the moving entity to the render texture
        texture.clear()
        texture.draw(background, background_shader.get_shader())
        texture.draw(entity, entity_shader.get_shader())
        texture.display()

        # Draw the contents of the render texture to the window
        screen = sf.Sprite(texture.texture)
        window.draw(screen, global_shader.get_shader())

        # Draw the interface texts
        window.draw(shader_str)
        window.draw(info_str)

        # Finally, display the rendered frame on screen
        window.display()


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = shape
#! /usr/bin/env python2
# -*- coding: utf-8 -*-

from random import randint

import sfml as sf


def random_color():
    return sf.Color(randint(0, 255), randint(0, 255), randint(0, 255))

def random_position(window):
    return (randint(0, window.view.width), randint(0, window.view.height))


class CustomShape(sf.Shape):
    def __init__(self):
        sf.Shape.__init__(self)
        self.fill_color = sf.Color.RED
        self.points = [(400, 200), (450, 150), (500, 200), (550, 200),
                       (500, 250), (420, 300)]
        self.update()

    def get_point_count(self):
        return len(self.points)

    def get_point(self, index):
        return self.points[index]


def main():
    window = sf.RenderWindow(sf.VideoMode(800, 600), 'Shape example')
    window.framerate_limit = 60
    running = True
    clock = sf.Clock()

    custom_shapes = [CustomShape()]
    rectangles = []
    circles = []

    for i in range(30):
        circle = sf.CircleShape(randint(5, 20))
        circle.fill_color = random_color()
        circle.position = random_position(window)
        circles.append(circle)

    for i in range(100):
        rectangle = sf.RectangleShape((randint(10, 30), randint(10, 30)))
        rectangle.position = random_position(window)
        rectangle.fill_color = random_color()
        rectangle.outline_color = random_color()
        rectangle.outline_thickness = randint(1, 2)
        rectangles.append(rectangle)

    while running:
        for event in window.iter_events():
            if event.type == sf.Event.CLOSED:
                running = False

        frame_time = clock.restart().as_milliseconds()

        for r in rectangles:
            r.rotate(frame_time * 0.3)

        window.clear(sf.Color.WHITE)

        for shape in custom_shapes + rectangles + circles:
            window.draw(shape)

        window.display()

    window.close()


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = soundstream
#! /usr/bin/env python2
# -*- coding: utf-8 -*-

import sys
import time

try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO

import sfml as sf


class CustomStream(sf.SoundStream):
    def __init__(self, path):
        sf.SoundStream.__init__(self)
        sound_buffer = sf.SoundBuffer.load_from_file(path)
        self.string_buffer = StringIO(sound_buffer.samples)

        # The program crashes if this line is removed. Apparently,
        # cStringIO doesn't keep a Python reference to the string.
        self.s = sound_buffer.samples
        self.initialize(sound_buffer.channel_count,
                        sound_buffer.sample_rate)
        self.buffer_size = 2 ** 12
        self.next_data = self.string_buffer.read(self.buffer_size)

    def on_get_data(self, chunk):
        if not self.next_data:
            return False

        chunk.samples = self.next_data
        self.next_data = self.string_buffer.read(self.buffer_size)

        return True

    def on_seek(self, time_offset):
        print(time_offset)



def main(args):
    window = sf.RenderWindow(sf.VideoMode(640, 480),
                             'SFML sound streaming example')
    window.framerate_limit = 60
    running = True

    stream = None
    error_message = None

    if len(args) > 1:
        stream = CustomStream(args[1])
        stream.play()
    else:
        error_message = sf.Text(
            "Error: please provide an audio file as a command-line argument\n"
            "Example: ./soundstream.py sound.wav")
        error_message.color = sf.Color.BLACK
        error_message.character_size = 17

    while running:
        for event in window.iter_events():
            if event.type == sf.Event.CLOSED:
                running = False

        window.clear(sf.Color.WHITE)

        if error_message is not None:
            window.draw(error_message)

        window.display()


if __name__ == '__main__':
    main(sys.argv)

########NEW FILE########
__FILENAME__ = sprite
#! /usr/bin/env python2
# -*- coding: utf-8 -*-

import sfml as sf


def main():
    window = sf.RenderWindow(sf.VideoMode(640, 480), 'Sprite example')
    window.framerate_limit = 60
    running = True
    texture = sf.Texture.load_from_file('python-logo.png')
    sprite = sf.Sprite(texture)

    while running:
        for event in window.iter_events():
            if event.type == sf.Event.CLOSED:
                running = False

        window.clear(sf.Color.WHITE)
        window.draw(sprite)
        window.display()

    window.close()


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = text
#! /usr/bin/env python2
# -*- coding: utf-8 -*-

import sfml as sf


def main():
    window = sf.RenderWindow(sf.VideoMode(640, 480), 'Title')
    window.framerate_limit = 60
    font = sf.Font.load_from_file('LinBiolinum_Bd.ttf')
    text = sf.Text(u'éèàtest', font, 100)
    text.color = sf.Color.BLACK
    text.style = sf.Text.UNDERLINED | sf.Text.BOLD | sf.Text.ITALIC
    text.x = window.width / 2.0 - text.global_bounds.width / 2.0
    text.y = window.height / 2.0 - text.global_bounds.height / 2.0
    running = True

    while running:
        for event in window.iter_events():
            if event.type == sf.Event.CLOSED:
                running = False

        window.clear(sf.Color.WHITE)
        window.draw(text)
        window.display()

    window.close()


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = vertices
#! /usr/bin/env python2
# -*- coding: utf-8 -*-

import sfml as sf


def main():
    window = sf.RenderWindow(sf.VideoMode(640, 480), 'SFML vertices example')
    window.framerate_limit = 60
    running = True
    vertices = [sf.Vertex((200, 150), sf.Color.RED),
                sf.Vertex((200, 350), sf.Color.BLUE),
                sf.Vertex((400, 350), sf.Color.GREEN),
                sf.Vertex((400, 150), sf.Color.YELLOW)]


    while running:
        for event in window.iter_events():
            if event.type == sf.Event.CLOSED:
                running = False

        window.clear(sf.Color.WHITE)
        window.draw(vertices, sf.TRIANGLES)
        window.display()

    window.close()


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = videomode
#! /usr/bin/env python2
# -*- coding: utf-8 -*-

import sfml as sf


def main():
    desktop_mode = sf.VideoMode.get_desktop_mode()
    print('The current desktop mode is:', desktop_mode)
    fullscreen_modes = sf.VideoMode.get_fullscreen_modes()
    print('The available fullscreen modes are:')

    for mode in fullscreen_modes:
        print(' {0}'.format(mode))

    format = raw_input('Please enter a video mode format (e.g. 1024x768x32): ')
    values = [int(item) for item in format.split('x')]
    mode = sf.VideoMode(*values)

    if mode.is_valid():
        print('The mode {0} is valid!'.format(mode))
    else:
        print('The mode {0} is not valid!'.format(mode))


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = patch
#! /usr/bin/env python2
# -*- coding: utf-8 -*-

"""This script modifies some Cython-generated files.

   Currently, it's only needed to call it when building for Python 3."""


import os.path
import re


def patch_sf_h():
    """Remove the DL_IMPORT macros in src/sfml.h."""

    filename = os.path.join('src', 'sfml.h')

    with open(filename, 'r') as f:
        source = f.read()

    source = re.sub(r'DL_IMPORT\(([\w\s:]+)\)', r'\1', source)

    with open(filename, 'w') as f:
        f.write(source)

def main():
    patch_sf_h()


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = main
#! /usr/bin/env python2
# -*- coding: utf-8 -*-

import random
import unittest

import sfml as sf


class TestColor(unittest.TestCase):
    def random_color(self):
        return sf.Color(random.randint(0, 255),
                        random.randint(0, 255),
                        random.randint(0, 255),
                        random.randint(0, 255))

    def test_eq(self):
        equal = [(sf.Color(i, i, i, i), sf.Color(i, i, i, i))
                 for i in range(256)]

        for c1, c2 in equal:
            self.assertEqual(c1, c2)

    def test_neq(self):
        not_equal = [(sf.Color(0, 0, 0, 1), sf.Color(0, 1, 0, 0)),
                     (sf.Color(255, 255, 255, 255),
                      sf.Color(254, 255, 255, 255))]

        for c1, c2 in not_equal:
            self.assertNotEqual(c1, c2)

    def test_copy(self):
        c1 = self.random_color()
        c2 = c1.copy()
        self.assertEqual(c1, c2)


class TestIntRect(unittest.TestCase):
    def random_rect(self):
        return sf.IntRect(random.randint(0, 100),
                          random.randint(0, 100),
                          random.randint(0, 100),
                          random.randint(0, 100))

    def test_eq(self):
        def r():
            return random.randint(0, 100)

        equal = [(sf.IntRect(l, t, w, h), sf.IntRect(l, t, w, h))
                 for l, t, w, h in
                 [(r(), r(), r(), r()) for i in range(100)]]

        for r1, r2 in equal:
            self.assertEqual(r1, r2)

    def test_neq(self):
        not_equal = [(sf.IntRect(0, 0, 0, 0), sf.IntRect(0, 0, 0, 10)),
                     (sf.IntRect(0, 0, 0, 0), sf.IntRect(0, 0, 10, 0)),
                     (sf.IntRect(0, 0, 0, 0), sf.IntRect(0, 10, 0, 0)),
                     (sf.IntRect(0, 0, 0, 0), sf.IntRect(10, 0, 0, 0))]

        for r1, r2 in not_equal:
            self.assertNotEqual

    def test_copy(self):
        r1 = self.random_rect()
        r2 = r1.copy()
        self.assertEqual(r1, r2)


class TestFloatRect(unittest.TestCase):
    def random_rect(self):
        return sf.FloatRect(random.triangular(0.0, 100.0),
                            random.triangular(0.0, 100.0),
                            random.triangular(0.0, 100.0),
                            random.triangular(0.0, 100.0))

    def test_eq(self):
        def r():
            return random.triangular(0.0, 100.0)

        equal = [(sf.FloatRect(l, t, w, h), sf.FloatRect(l, t, w, h))
                 for l, t, w, h in
                 [(r(), r(), r(), r()) for i in range(100)]]

        for r1, r2 in equal:
            self.assertEqual(r1, r2)

    def test_neq(self):
        not_equal = [(sf.FloatRect(0, 0, 0, 0), sf.FloatRect(0, 0, 0, 10)),
                     (sf.FloatRect(0, 0, 0, 0), sf.FloatRect(0, 0, 10, 0)),
                     (sf.FloatRect(0, 0, 0, 0), sf.FloatRect(0, 10, 0, 0)),
                     (sf.FloatRect(0, 0, 0, 0), sf.FloatRect(10, 0, 0, 0))]

        for r1, r2 in not_equal:
            self.assertNotEqual

    def test_copy(self):
        r1 = self.random_rect()
        r2 = r1.copy()
        self.assertEqual(r1, r2)


class TestTime(unittest.TestCase):
    def random_time(self):
        return sf.Time(microseconds=random.randint(0, 1000000))

    def test_eq(self):
        equal = [(sf.Time(microseconds=x), sf.Time(microseconds=x))
                  for x in
                  [random.randint(0, 1000000) for n in range(10)]]

        for t1, t2 in equal:
            self.assertEqual(t1, t2)

    def test_add(self):
        t1 = self.random_time()
        t2 = self.random_time()
        self.assertEqual(
            t1 + t2,
            sf.Time(microseconds=t1.as_microseconds() + t2.as_microseconds()))

    def test_sub(self):
        t1 = self.random_time()
        t2 = self.random_time()
        self.assertEqual(
            t1 - t2,
            sf.Time(microseconds=t1.as_microseconds() - t2.as_microseconds()))

    def test_mul(self):
        t = self.random_time()
        i = random.randint(1, 1000)
        self.assertEqual(t * i,
                         sf.Time(microseconds=t.as_microseconds() * i))
        f = random.triangular(0.0, 100.0)
        self.assertEqual(t * f,
                         sf.Time(seconds=t.as_seconds() * f))

    def test_div(self):
        t = self.random_time()
        i = random.randint(1,  1000)
        self.assertEqual(t / i,
                         sf.Time(microseconds=t.as_microseconds() / i))
        f = random.triangular(0.0, 100.0)
        self.assertEqual(t / f,
                         sf.Time(seconds=t.as_seconds() / f))

    def test_copy(self):
        t1 = self.random_time()
        t2 = t1.copy()
        self.assertEqual(t1, t2)


class TestTransform(unittest.TestCase):
    def random_transform(self):
        return sf.Transform(*[random.triangular(0.0, 5.0) for i in range(9)])

    def test_init(self):
        self.assertEqual(sf.Transform().matrix, sf.Transform.IDENTITY.matrix)
        self.assertRaises(TypeError, sf.Transform, *range(10))

    def test_copy(self):
        for i in range(10):
            t1 = self.random_transform()
            t2 = t1.copy()
            self.assertEqual(t1.matrix, t2.matrix)

    def test_imul(self):
        t1 = self.random_transform()
        t2 = self.random_transform()
        t3 = t1.copy()
        t3 *= t2
        self.assertEqual((t1 * t2).matrix, t3.matrix)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
