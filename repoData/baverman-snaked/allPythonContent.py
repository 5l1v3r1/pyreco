__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Snaked documentation build configuration file, created by
# sphinx-quickstart on Tue Oct 12 18:56:32 2010.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Snaked'
copyright = u'2010, Anton Bobrov'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.4.6'
# The full version, including alpha/beta/rc tags.
release = '0.4.6'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Snakeddoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Snaked.tex', u'Snaked Documentation',
   u'Anton Bobrov', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'snaked', u'Snaked Documentation',
     [u'Anton Bobrov'], 1)
]

########NEW FILE########
__FILENAME__ = app
import sys, os, time
import socket
from multiprocessing.connection import Client, Listener
import multiprocessing.connection

def _init_timeout(timeout=3):
    return time.time() + timeout

def get_addr(session):
    if sys.platform == 'win32':
        return '\\.\pipe\snaked.session.%s.%s' % (os.environ.get('USERNAME', 'USERNAME'), session)
    else:
        return '/tmp/snaked.session.%i.%s' % (os.geteuid(), session)

def is_master(session):
    addr = get_addr(session)
    try:
        return True, Listener(addr)
    except socket.error:
        multiprocessing.connection._init_timeout = _init_timeout
        i = 2
        while i > 0:
            try:
                conn = Client(addr)
                return False, conn
            except socket.error, e:
                print e

            time.sleep(0.1)
            i -= 1

        os.remove(addr)
        return is_master(session)

def serve(manager, listener):
    def runner():
        while True:
            conn = listener.accept()
            conn_alive = True
            while conn_alive:
                while conn.poll():
                    try:
                        data = conn.recv()
                        if data[0] == 'END':
                            conn_alive = False
                        elif data[0] == 'OPEN':
                            for f in data[1:]:
                                manager.open_or_activate(f)
                            [w for w in manager.windows if w][0].present()
                    except EOFError:
                        break
                    except Exception:
                        import traceback
                        traceback.print_exc()

                time.sleep(0.1)

    def on_quit():
        listener.close()

    manager.on_quit.append(on_quit)

    import threading
    t = threading.Thread(target=runner)
    t.daemon = True
    t.start()

########NEW FILE########
__FILENAME__ = completer
from bisect import bisect
import gtk

from uxie.complete import TextViewCompleter

completer = None

def init(injector):
    injector.bind('textview-active', 'complete', 'Edit/Complete', complete)

def complete(textview):
    if not hasattr(textview, 'completer'):
        textview.get_toplevel().message('Where is your attached completer now?',
            'warn', parent=textview)
        return

    textview.completer.complete(textview)

def add_completion_provider(buf, provider, priority=None):
    if priority is None:
        priority = 0

    value = (-priority, provider)
    if not hasattr(buf, 'completion_providers'):
        buf.completion_providers = []

    buf.completion_providers.insert(bisect(buf.completion_providers, value), value)

def create_completer():
    model = gtk.ListStore(object, str, object, bool) # provider, match, object, selection
    view = gtk.TreeView(model)
    view.set_headers_visible(False)
    view.append_column(gtk.TreeViewColumn('None', gtk.CellRendererText(),
        markup=1, sensitive=3))

    view.get_selection().set_select_function(lambda info: model[info[0]][3])

    return TextViewCompleter(view)

def get_completer():
    global completer
    if not completer:
        completer = create_completer()

    return completer

def fill_callback(view, textview, check, providers=None, it=None):
    buf = textview.get_buffer()
    model = view.get_model()
    model.clear()

    is_interactive = it is None

    it = it or buf.get_iter_at_mark(buf.get_insert())
    providers = providers or (r[1] for r in buf.completion_providers)
    provider_iters = []
    for provider in providers:
        if is_interactive:
            ctx = provider.is_match(it.copy())
        else:
            ctx = it.copy()

        if ctx is not None:
            is_any_items = False
            for name, obj in provider.complete(ctx, is_interactive):
                next(check)
                start_iter = model.append((provider, name, obj, True))
                if not is_any_items:
                    provider_iters.append((provider, start_iter))
                    is_any_items = True

    if len(provider_iters) > 1:
        for p, it in provider_iters:
            model.insert_before(it, (None, '<b>%s</b>' % p.get_name(), None, False))

def activate_callback(view, path, textview, is_final):
    if is_final:
        provider, _, obj = tuple(view.get_model()[path])[:3]
        provider.activate(textview, obj)

def attach_completer(textview):
    completer = get_completer()
    completer.attach(textview, fill_callback, activate_callback)
    textview.completer = completer


class Provider(object):
    def is_match(self, it):
        return None

    def complete(self, ctx, is_interactive):
        return []

    def get_name():
        return 'Unknown'

    def activate(self, textview, obj):
        pass

########NEW FILE########
__FILENAME__ = console
import os, fcntl
import gtk
import glib
import pango

from uxie.escape import Escapable

from snaked.util import mimic_to_sourceview_theme

console_widget = []
pty_master = [None]

def init(injector):
    injector.bind('editor', 'toggle-console', 'View/Toggle _console#10',
        toggle_console).to('<alt>grave')
    injector.bind('editor-active', 'send-to-console', 'Edit/Sen_d to console#100',
        send_to_console).to('<alt>Return')

def get_console_widget(editor):
    try:
        return console_widget[0]
    except IndexError:
        pass

    w = create_console_widget()

    if editor.conf['MIMIC_PANEL_COLORS_TO_EDITOR_THEME']:
        mimic_to_sourceview_theme(w.view, editor.view)

    if editor.conf['CONSOLE_FONT']:
        w.view.modify_font(pango.FontDescription(editor.conf['CONSOLE_FONT']))

    console_widget.append(w)
    editor.window.append_panel(w)\
        .on_activate(lambda w: w.view.grab_focus())
    return w

def create_console_widget():
    panel = gtk.ScrolledWindow()
    panel.set_border_width(5)
    panel.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)

    panel.view = gtk.TextView()
    panel.view.set_editable(False)
    panel.view.set_buffer(gtk.TextBuffer())
    panel.add(panel.view)
    panel.view.show()

    return panel

def toggle_console(editor):
    console = get_console_widget(editor)
    editor.window.popup_panel(console)

def unblock_fd(fd):
    fl = fcntl.fcntl(fd, fcntl.F_GETFL)
    fcntl.fcntl(fd, fcntl.F_SETFL, fl | os.O_NONBLOCK)

def consume_output(editor, proc, on_finish):
    console = get_console_widget(editor)
    buf = console.view.get_buffer()
    buf.delete(*buf.get_bounds())
    unblock_fd(proc.stdout)
    unblock_fd(proc.stderr)
    glib.io_add_watch(proc.stdout, glib.IO_IN|glib.IO_ERR|glib.IO_HUP,
        consume_io, editor, console, proc, on_finish)
    glib.io_add_watch(proc.stderr, glib.IO_IN|glib.IO_ERR|glib.IO_HUP,
        consume_io, editor, console, proc, on_finish)

def consume_pty(editor, proc, master, on_finish):
    console = get_console_widget(editor)
    buf = console.view.get_buffer()
    buf.delete(*buf.get_bounds())
    unblock_fd(master)
    glib.io_add_watch(master, glib.IO_IN|glib.IO_ERR|glib.IO_HUP,
        consume_io, editor, console, proc, on_finish)

    pty_master[0] = master

def consume_io(f, cond, editor, console, proc, on_finish):
    if isinstance(f, int):
        data = os.read(f, 1024)
    else:
        data = f.read()

    if data:
        if not console.props.visible:
            editor.window.popup_panel(console, editor)

        buf = console.view.get_buffer()
        iter = buf.get_bounds()[1]
        buf.insert(iter, data)
        buf.place_cursor(buf.get_bounds()[1])
        console.view.scroll_mark_onscreen(buf.get_insert())

    if proc.poll() is not None:
        if not getattr(proc, 'consume_done', False):
            proc.consume_done = True
            if pty_master[0] == f:
                pty_master[0] = None
            on_finish()
        return False

    return True

def send_to_console(editor):
    selection = editor.selection
    if selection:
        if pty_master[0]:
            os.write(pty_master[0], selection)
        else:
            editor.message('There is no interactive console', 'warn')
    else:
        editor.message('You need to select something', 'warn')

########NEW FILE########
__FILENAME__ = context
import os.path
import re

class Manager(object):
    def __init__(self, project_root, parent_processors, project_context_config):
        self.root = project_root
        self.processors = list(parent_processors)
        self.project_processor = Processor(project_context_config)
        self.processors.append(self.project_processor)

    def invalidate(self):
        try:
            del self.contexts
        except AttributeError:
            pass

        for p in self.processors:
            p.invalidate()

    def get(self):
        try:
            return self.contexts
        except AttributeError:
            pass

        rules = {}
        for p in self.processors:
            for ctx, params in p.get_rules().iteritems():
                for p, expr_list in params.iteritems():
                    pe = rules.setdefault(ctx, {}).setdefault(p, [])
                    pe += expr_list

        result = self.contexts = {}
        root = re.escape(self.root)
        for ctx, params in rules.iteritems():
            for param, expr_list in params.iteritems():
                result.setdefault(ctx, {})[param] = re.compile(
                    '|'.join(root + r for r in expr_list))

        return result

    def get_first(self, ctx, uri):
        for p, matcher in self.get().get(ctx, {}).iteritems():
            if matcher.match(uri):
                return p

        return None

    def get_all(self, ctx, uri):
        result = []
        for p, matcher in self.get().get(ctx, {}).iteritems():
            if matcher.match(uri):
                result.append(p)

        return result


class FakeManager(Manager):
    def __init__(self):
        self.contexts = {}

    def invalidate(self):
        pass

    def get(self):
        return self.contexts


class Processor(object):
    def __init__(self, filename):
        self.filename = filename

    def get_rules(self):
        try:
            return self.rules
        except AttributeError:
            pass

        self.rules = {}
        try:
            for l in open(self.filename):
                l = l.strip()
                if not l or l.startswith('#'):
                    continue

                try:
                    expr, contexts = l.split(':', 1)
                except ValueError:
                    continue

                contexts = [c.strip() for c in contexts.split(',')]
                if not contexts:
                    continue

                if not l.startswith('/'):
                    expr = '/*/' + expr

                expr = re.escape(expr).replace('\*', '.*') + '$'

                for c in contexts:
                    try:
                        ctx, param = c.split(':', 1)
                    except ValueError:
                        print 'Bad context:', c
                        continue

                    self.rules.setdefault(ctx, {}).setdefault(param, []).append(expr)
        except IOError:
            pass

        return self.rules

    def invalidate(self):
        try:
            del self.rules
        except AttributeError:
            pass

########NEW FILE########
__FILENAME__ = editor
import os.path
import weakref

import gtk
import gtksourceview2

from uxie.utils import idle

from .prefs import add_option, update_view_preferences
from ..util import save_file, get_project_root
from ..signals import SignalManager, Signal, connect_all, connect_external, weak_connect

add_option('DISABLE_LEFT_CLICK', False, 'Disable left mouse button handling in editor view')

class Editor(SignalManager):
    before_close = Signal()
    before_file_save = Signal(return_type=bool) # Handlers can return True to prevent file saving

    file_loaded = Signal()
    file_saved = Signal()

    get_file_position = Signal(return_type=int)
    get_project_larva = Signal(return_type=str)
    get_title = Signal(return_type=str)
    get_window_title = Signal(return_type=str)

    def __init__(self, conf, buf=None):
        self.last_cursor_move = None

        sw = gtk.ScrolledWindow()
        sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_ALWAYS)

        self.buffer = buf or gtksourceview2.Buffer()

        self.view = gtksourceview2.View()
        self.view.set_buffer(self.buffer)
        sw.add(self.view)
        self.view.editor_ref = weakref.ref(self)

        self.ins_mark = self.sb_mark = None
        self.view.connect('focus-in-event', self.on_focus_in)
        self.view.connect('focus-out-event', self.on_focus_out)

        self.widget = gtk.VBox(False, 0)
        self.widget.pack_start(sw)

        self.widget.show_all()

        connect_all(self, buffer=self.buffer, view=self.view)

        if conf['DISABLE_LEFT_CLICK']:
            weak_connect(self.view, 'button-press-event', self, 'on_button_press_event')

        self.conf = conf

        if buf:
            idle(self.update_view_preferences)
            idle(self.update_title)

    def update_title(self):
        if self.uri:
            title = self.get_title.emit()

            if not title:
                title = os.path.basename(self.uri)
        else:
            title = 'Unknown'

        self.window.set_editor_title(self, title)

    @property
    def uri(self):
        return self.buffer.uri

    @property
    def encoding(self):
        return self.buffer.encoding

    @property
    def session(self):
        return self.buffer.session

    def load_file(self, filename, line=None):
        self.buffer.uri = os.path.abspath(filename)
        self.buffer.encoding = 'utf-8'
        self.buffer.saveable = True

        if os.path.exists(self.uri):
            self.view.window.freeze_updates()
            self.on_modified_changed_handler.block()
            self.buffer.begin_not_undoable_action()

            text = open(filename).read()

            try:
                utext = text.decode('utf-8')
            except UnicodeDecodeError, e:
                try:
                    import chardet
                    result = chardet.detect(text)
                    if result['encoding']:
                        utext = text.decode(result['encoding'])
                        self.buffer.encoding = result['encoding']
                        idle(self.message,
                            'Automatically selected ' + self.buffer.encoding + 'encoding', 'info', 5000)
                    else:
                        self.buffer.saveable = False
                        utext = 'Is this a text file?'
                except ImportError:
                    self.buffer.saveable = False
                    utext = str(e)
                except UnicodeDecodeError, ee:
                    self.buffer.saveable = False
                    utext = str(ee)

            self.buffer.set_text(utext)
            self.buffer.set_modified(False)

            self.buffer.end_not_undoable_action()

            if self.uri in self.conf['MODIFIED_FILES']:
                tmpfilename = self.conf['MODIFIED_FILES'][self.uri]
                if os.path.exists(tmpfilename):
                    self.buffer.begin_user_action()
                    utext = open(tmpfilename).read().decode(self.buffer.encoding)
                    self.buffer.set_text(utext)
                    self.buffer.end_user_action()

            self.on_modified_changed_handler.unblock()
            self.view.window.thaw_updates()
            self.buffer.is_changed = False

            pos = line if line is not None else self.get_file_position.emit()
            if pos is not None and pos >= 0:
                self.buffer.place_cursor(self.buffer.get_iter_at_line(pos))
                self.view.scroll_to_mark(self.buffer.get_insert(), 0.001, use_align=True, xalign=1.0)
            else:
                self.buffer.place_cursor(self.buffer.get_start_iter())

        self.file_loaded.emit()

        self.update_title()

    @connect_external('buffer', 'modified-changed', idle=True)
    def on_modified_changed(self, *args):
        self.update_title()

    def save(self):
        if not self.buffer.saveable:
            self.message("This file was opened with error and can't be saved", 'warn')
            return

        if self.uri:
            if self.before_file_save.emit():
                return

            if self.buffer.config['remove-trailing-space']:
                from snaked.core.processors import remove_trailing_spaces
                remove_trailing_spaces(self.buffer)

            # TODO quick hack to ignore file changes by snaked itself
            try:
                save_file(self.uri, self.utext, self.encoding)
                self.buffer.monitor.saved_by_snaked = True
                if not self.buffer.get_modified():
                    self.message("%s saved" % self.uri, 'done')
                self.buffer.set_modified(False)
                self.file_saved.emit()
            except Exception, e:
                self.message(str(e), 'error', 5000)

    @property
    def project_root(self):
        """This is real file's project root

        There config can be saved and so on.

        """
        return self.get_project_root()

    def get_project_root(self, larva=False, force_select=False):
        if not self.uri:
            return None

        root = get_project_root(self.uri)

        if not root and force_select:
            pass

        if not root and larva:
            root = self.get_project_larva.emit()
            if not root:
                root = os.path.dirname(self.uri)

        return root

    @property
    def cursor(self):
        """Return buffer's cursor iter

        :rtype: gtk.TextIter
        """
        return self.buffer.get_iter_at_mark(self.buffer.get_insert())

    @property
    def text(self):
        """Return buffer's content as utf-8 encoded string

        :rtype: str
        """
        return self.buffer.get_text(*self.buffer.get_bounds())

    @property
    def selection(self):
        """Return buffer's selection or none as utf-8 encoded string

        :rtype: str
        """
        if self.buffer.get_has_selection():
            return self.buffer.get_text(*self.buffer.get_selection_bounds())
        else:
            None

    @property
    def uselection(self):
        """Return buffer's selection or none as unicode string

        :rtype: str
        """
        if self.buffer.get_has_selection():
            return self.selection
        else:
            None

    @property
    def utext(self):
        """Return buffer's content as unicode string

        :rtype: unicode
        """
        return unicode(self.text, 'utf-8')

    def clear_cursor(self):
        if self.ins_mark:
            self.buffer.delete_mark(self.ins_mark)
            self.ins_mark = None

        if self.sb_mark:
            self.buffer.delete_mark(self.sb_mark)
            self.sb_mark = None

    def goto_line(self, line, minimal=False):
        iterator = self.buffer.get_iter_at_line(line - 1)
        self.buffer.place_cursor(iterator)
        if minimal:
            self.view.scroll_mark_onscreen(self.buffer.get_insert())
        else:
            self.view.scroll_to_mark(self.buffer.get_insert(), 0.001, use_align=True, xalign=1.0)

        self.clear_cursor()

    def scroll_to_cursor(self):
        self.view.scroll_to_mark(self.buffer.get_insert(), 0.001, use_align=True, xalign=1.0)
        self.clear_cursor()

    def message(self, message, category=None, timeout=None, markup=False):
        return self.window.message(message, category, timeout, markup=markup, parent=self.view)

    def add_spot(self):
        self.window.manager.spot_manager.add(self)

    def on_button_press_event(self, view, event):
        if event.button == 1:
            return True

        return False

    def on_close(self):
        self.view.destroy()

    def update_view_preferences(self):
        update_view_preferences(self.view, self.buffer)

    @property
    def window(self):
        return self.view.get_toplevel()

    def close(self):
        self.window.close_editor(self)

    def focus(self):
        w = self.window
        w.focus_editor(self)
        w.present()

    @property
    def lang(self):
        return self.buffer.lang

    @property
    def contexts(self):
        return self.buffer.contexts

    def on_focus_in(self, view, event):
        if self.ins_mark:
            buf = self.buffer
            buf.select_range(buf.get_iter_at_mark(self.ins_mark),
                buf.get_iter_at_mark(self.sb_mark))

        return False

    def on_focus_out(self, view, event):
        buf = self.buffer
        ins = buf.get_iter_at_mark(buf.get_insert())
        sb = buf.get_iter_at_mark(buf.get_selection_bound())

        if self.ins_mark:
            buf.move_mark(self.ins_mark, ins)
        else:
            self.ins_mark = buf.create_mark(None, ins)

        if self.sb_mark:
            buf.move_mark(self.sb_mark, sb)
        else:
            self.sb_mark = buf.create_mark(None, sb)
########NEW FILE########
__FILENAME__ = gui
import weakref

import pango, gtk

from uxie.utils import idle, join_to_file_dir, refresh_gui
from uxie.misc import BuilderAware
from uxie.actions import Activator

mnemonics = '1234567890abcdefghigklmnopqrstuvwxyz'

def search_func(model, column, key, iter):
    if key in model.get_value(iter, 0):
        return False

    return True

class EditorListDialog(BuilderAware):
    """glade-file: gui.glade"""

    def __init__(self):
        super(EditorListDialog, self).__init__(join_to_file_dir(__file__, 'gui.glade'))

        from snaked.core.manager import keymap
        self.activator = keymap.get_activator(self.window)
        self.activator.bind('any', 'escape', None, self.hide)
        self.activator.bind('any', 'delete', None, self.close_editor)

        self.block_cursor = False

        self.path2uri = {}
        self.paths = []
        self.editors_view.set_search_equal_func(search_func)
        self.editors_view.get_selection().set_mode(gtk.SELECTION_MULTIPLE)

        self.model = gtk.ListStore(str, int, str, object, str)
        self.editors_view.set_model(self.model)

        self.mnemonic_renderer.set_property('yalign', 0.5)
        self.mnemonic_renderer.set_property('weight', pango.WEIGHT_BOLD)
        self.mnemonic_renderer.set_property('width', 5)
        self.mnemonic_hole.set_property('width', 20)

        for m in mnemonics:
            self.activator.bind('any', 'activate-mnemonic-'+m,
                None, self.mnemonic_activate, m).to('<alt>'+m)

    def show(self, window, recent_editors):
        self.pwindow = weakref.ref(window)
        self.recent_editors = recent_editors

        self.block_cursor = True
        self.fill()
        self.window.set_transient_for(window)
        self.window.present()
        self.block_cursor = False

    @property
    def editor_list(self):
        return list(self.pwindow().manager.get_editors())

    @property
    def current_editor(self):
        return self.pwindow().get_editor_context()

    def fill(self):
        self.model.clear()

        active_editor = self.current_editor
        titles = [(e.get_title.emit(), e) for e in self.editor_list]
        editor_uris = set()

        def append(uri, title, editor, weight, mnemonic_idx):
            if mnemonic_idx < len(mnemonics):
                m = '<b><small>%s</small></b>' % mnemonics[mnemonic_idx]
                ml = mnemonics[mnemonic_idx]
            else:
                m = ''
                ml = ''

            self.model.append((title, weight, m, (uri, weakref.ref(editor) if editor else None), ml))

        for i, (t, e) in enumerate(sorted(titles, key=lambda r: r[0])):
            editor_uris.add(e.uri)
            weight = pango.WEIGHT_BOLD if e is active_editor else pango.WEIGHT_NORMAL
            append(e.uri, t, e, weight, i)

        recent_titles = [(u, t) for u, t in self.recent_editors.items() if u not in editor_uris]
        if recent_titles:
            self.model.append(('----=== Recent ===----', pango.WEIGHT_NORMAL, '', (None, None), ''))
            for u, t in sorted(recent_titles, key=lambda r: r[1]):
                i += 1
                append(u, t, None, pango.WEIGHT_NORMAL, i)

    def hide(self):
        self.window.hide()

    def on_delete_event(self, *args):
        self.escape()
        return True

    def close_editor(self, *args):
        model, pathes = self.editors_view.get_selection().get_selected_rows()
        for p in pathes:
            u, e = model[p][3]
            if e and e():
                e().close()

        refresh_gui()
        if self.editor_list:
            idle(self.fill)
        else:
            self.hide()

    def activate_editor(self, path):
        uri, editor = self.model[path][3]
        if editor and editor():
            ce = self.current_editor
            if ce:
                ce.add_spot()
            idle(editor().focus)
            idle(self.hide)
        elif uri:
            ce = self.current_editor
            if ce:
                ce.add_spot()
            idle(self.pwindow().open_or_activate, uri)
            idle(self.hide)

    def on_editors_view_row_activated(self, view, path, *args):
        self.activate_editor(path)

    def on_editors_view_cursor_changed(self, *args):
        pwindow = self.pwindow()
        if pwindow and pwindow.manager.conf['EDITOR_LIST_SWITCH_ON_SELECT'] and not self.block_cursor:
            path, _ = self.editors_view.get_cursor()
            uri, editor = self.model[path][3]
            if editor and editor():
                idle(editor().focus)

    def mnemonic_activate(self, m):
        for r in self.model:
            if r[4] == m:
                self.activate_editor(r.path)
########NEW FILE########
__FILENAME__ = feedback
import gtk
from gobject import timeout_add, source_remove

class EscapeObject(object): pass

class FeedbackPopup(object):
    def __init__(self):

        self.window = gtk.Window(gtk.WINDOW_TOPLEVEL)
        self.window.set_property('allow-shrink', True)

        self.window.props.skip_pager_hint = True
        self.window.props.skip_taskbar_hint = True
        self.window.props.accept_focus = False
        self.window.set_decorated(False)

        self.bar = gtk.EventBox()
        self.bar.set_border_width(5)

        box = gtk.EventBox()

        self.label = gtk.Label()
        self.label.set_alignment(0, 0)
        self.label.set_padding(10, 0)
        box.add(self.label)

        self.bar.add(box)
        self.bar.show_all()

        self.window.add(self.bar)

        self.window.realize()
        self.window.window.set_override_redirect(True)

        self.timeout_id = None
        self.escape = None

        self.handlers_connected = False

    def focus_out_event(self, wnd, event):
        self.window.hide()

    def focus_in_event(self, wnd, event):
        if self.timeout_id:
            self.window.show()

    def remove_timeout(self):
        if self.timeout_id:
            source_remove(self.timeout_id)

        self.timeout_id = None

    def show(self, editor, text, timeout=1500, markup=False):
        if not self.handlers_connected:
            self.handlers_connected = True
            toplevel = editor.window
            toplevel.connect('focus-out-event', self.focus_out_event)
            toplevel.connect('focus-in-event', self.focus_in_event)

        self.remove_timeout()
        if self.escape:
            self.hide()

        if markup:
            self.label.set_markup(text)
        else:
            self.label.set_text(text)

        self.window.resize(*self.window.size_request())

        win = editor.view.get_window(gtk.TEXT_WINDOW_TEXT)
        x, y, w, h, _ = win.get_geometry()
        x, y = win.get_origin()
        mw, mh = self.window.get_size()

        self.window.set_transient_for(editor.window)
        self.window.move(x + w - mw, y + h - mh)
        self.window.show()

        if not self.escape:
            self.escape = EscapeObject()

        self.timeout_id = timeout_add(timeout, self.hide)

    def hide(self, *args):
        self.remove_timeout()
        self.window.hide()
        self.escape = None
        return False

########NEW FILE########
__FILENAME__ = editor_prefs
import weakref

import gtksourceview2

from uxie.utils import join_to_file_dir, idle
from uxie.misc import BuilderAware
from uxie.actions import Activator

import snaked.core.prefs as prefs

on_dialog_created_hooks = []
on_pref_refresh_hooks = []


class PreferencesDialog(BuilderAware):
    def __init__(self, prefs):
        BuilderAware.__init__(self, join_to_file_dir(__file__, 'editor_prefs.glade'))

        from snaked.core.manager import keymap
        self.activator = keymap.get_activator(self.window)
        self.activator.bind('any', 'escape', None, self.hide)

        self.prefs = prefs
        self.original_prefs = prefs.copy()

        self.langs.append(('default', ))
        lm = gtksourceview2.language_manager_get_default()
        for lang_id in sorted(lm.get_language_ids()):
            self.langs.append((lang_id, ))

        sm = gtksourceview2.style_scheme_manager_get_default()
        for style_id in sorted(sm.get_scheme_ids()):
            self.styles.append((style_id, ))

        self.checks = ['use-tabs', 'show-right-margin', 'show-line-numbers', 'wrap-text',
            'highlight-current-line', 'show-whitespace', 'remove-trailing-space']

        for name in self.checks:
            getattr(self, name.replace('-', '_')).connect(
                'toggled', self.on_checkbox_toggled, name)

        self.margin_width.connect('value-changed', self.on_spin_changed, 'right-margin')
        self.tab_width.connect('value-changed', self.on_spin_changed, 'tab-width')
        self.line_spacing.connect('value-changed', self.on_spin_changed, 'line-spacing')

        self.font.connect('font-set', self.on_font_set, 'font')

        for h in on_dialog_created_hooks:
            h(self)

    def show(self, window):
        self.pwindow = weakref.ref(window)
        self.window.set_transient_for(window)

        editor = window.get_editor_context()
        if editor:
            self.select_lang(editor.lang)
        else:
            self.select_lang(default)

        self.refresh_lang_settings()
        self.window.present()

    def select_lang(self, lang_id):
        for i, (name,) in enumerate(self.langs):
            if name == lang_id:
                self.langs_view.set_cursor((i,))
                self.langs_view.scroll_to_cell((i,), None, True, 0.5, 0)
                return

        self.langs_view.set_cursor((0,))

    def get_current_lang_id(self):
        (model, iter) = self.langs_view.get_selection().get_selected()
        return self.langs.get_value(iter, 0)

    def get_lang_prefs(self, lang_id):
        if lang_id == 'default':
            return prefs.CompositePreferences(self.prefs.get('default', {}),
                prefs.default_prefs.get(lang_id, {}), prefs.default_prefs['default'])
        else:
            return prefs.CompositePreferences(self.prefs.get(lang_id, {}),
                self.prefs.get('default', {}), prefs.default_prefs.get(lang_id, {}),
                prefs.default_prefs['default'])

    def get_default_lang_prefs(self, lang_id):
        if lang_id == 'default':
            return prefs.CompositePreferences(prefs.default_prefs.get(lang_id, {}),
                prefs.default_prefs['default'])
        else:
            return prefs.CompositePreferences(self.prefs.get('default', {}),
                prefs.default_prefs.get(lang_id, {}), prefs.default_prefs['default'])

    def set_checkbox(self, pref, name):
        getattr(self, name.replace('-', '_')).set_active(pref[name])

    def refresh_lang_settings(self, *args):
        pref = self.get_lang_prefs(self.get_current_lang_id())

        for name in self.checks:
            self.set_checkbox(pref, name)

        self.select_style(pref['style'])

        self.margin_width.set_value(pref['right-margin'])
        self.tab_width.set_value(pref['tab-width'])
        self.line_spacing.set_value(pref['line-spacing'])

        self.font.set_font_name(pref['font'])

        for h in on_pref_refresh_hooks:
            h(self, pref)

    def select_style(self, style_id, try_classic=True):
        for i, (name,) in enumerate(self.styles):
            if name == style_id:
                self.style_cb.set_active(i)
                return

        if try_classic:
            return self.select_style('classic', False)

        self.style_cb.set_active(0)

    def hide(self):
        self.save_settings()
        self.pwindow().emessage('Editor settings saved')
        self.window.destroy()

    def save_settings(self):
        prefs.save_json_settings('langs.conf', self.prefs)

    def on_delete_event(self, *args):
        idle(self.hide)
        return True

    def update_editor_settings(self):
        manager = self.pwindow().manager
        editor = self.pwindow().get_editor_context()
        buf = editor.buffer if editor else None

        if editor:
            manager.set_buffer_prefs(buf, buf.uri, buf.lang)
            editor.update_view_preferences()

        for b in manager.buffers:
            if b is not buf:
                idle(manager.set_buffer_prefs, b, b.uri, b.lang)

        for e in manager.get_editors():
            if e is not editor:
                idle(e.update_view_preferences)

    def update_pref_value(self, lang_id, name, value):
        current_value = self.get_lang_prefs(lang_id)[name]
        if value != current_value:
            default_value = self.get_default_lang_prefs(lang_id)[name]
            if value == default_value:
                try:
                    del self.prefs[lang_id][name]
                except KeyError:
                    pass
            else:
                self.prefs.setdefault(lang_id, {})[name] = value

            self.update_editor_settings()

    def on_style_cb_changed(self, *args):
        (style_id,) = self.styles[self.style_cb.get_active()]
        lang_id = self.get_current_lang_id()
        self.update_pref_value(lang_id, 'style', style_id)

    def on_checkbox_toggled(self, widget, name):
        self.update_pref_value(self.get_current_lang_id(), name, widget.get_active())

    def on_spin_changed(self, widget, name):
        self.update_pref_value(self.get_current_lang_id(), name, widget.get_value_as_int())

    def on_font_set(self, widget, name):
        self.update_pref_value(self.get_current_lang_id(), name, widget.get_font_name())

    def on_reset_to_default_clicked(self, *args):
        try:
            del self.prefs[self.get_current_lang_id()]
        except KeyError:
            pass

        self.refresh_lang_settings()
        self.update_editor_settings()

########NEW FILE########
__FILENAME__ = new_file
import os.path
import gtk

from uxie.utils import idle
from uxie.escape import Escapable
from uxie.complete import EntryCompleter, create_simple_complete_view

def show_create_file(editor):
    widget = create_widget(editor)

    editor.widget.pack_start(widget, False)
    widget.entry.grab_focus()
    widget.entry.set_position(-1)
    widget.show_all()

    editor.window.push_escape(Escapable(hide, editor, widget))

def create_widget(editor):
    widget = gtk.HBox(False, 10)

    label = gtk.Label("File name:")
    widget.pack_start(label, False)

    entry = gtk.Entry()
    entry.set_width_chars(50)
    widget.pack_start(entry, False)
    entry.connect('activate', on_entry_activate, editor, widget)

    path = os.path.dirname(editor.uri)
    entry.set_text(path + '/')

    widget.completion = EntryCompleter(create_simple_complete_view())
    widget.completion.attach(entry, fill_func, activate_func)
    widget.completion.pass_enter_key = True

    widget.entry = entry

    return widget

def hide(editor, widget):
    if widget and widget.get_parent():
        editor.widget.remove(widget)
        widget.destroy()
    editor.view.grab_focus()

def on_entry_activate(entry, editor, widget):
    filename = entry.get_text()
    hide(editor, widget)
    editor.window.open_or_activate(filename)

def get_pos(entry):
    try:
        start, end = entry.get_selection_bounds()
    except ValueError:
        start = entry.get_position()

    return start

def get_key(entry):
    return os.path.split(entry.get_text()[:get_pos(entry)])

def fill_func(view, entry, check):
    root, key = get_key(entry)
    model = view.get_model()
    model.clear()

    dirs = []
    files = []
    try:
        for p in os.listdir(root):
            next(check)

            if p.startswith(key):
                if os.path.isdir(os.path.join(root, p)):
                    dirs.append(p + '/')
                else:
                    files.append(p)
    except OSError:
        pass

    for p in sorted(dirs) + sorted(files):
        model.append((p,))

    #view.get_selection().unselect_all()

def activate_func(view, path, entry, is_final):
    if is_final:
        pos = get_pos(entry)
        root, key = get_key(entry)
        if root[-1] != '/':
            root += '/'

        entry.set_text(root + view.get_model()[path][0])
        entry.set_position(-1)
        idle(entry.emit, 'changed')
########NEW FILE########
__FILENAME__ = plugin_prefs
import os
from os.path import join, isdir, exists

from glib import markup_escape_text

from uxie.utils import join_to_file_dir, idle
from uxie.misc import BuilderAware

from snaked.core.plugins import get_plugin

def discover_plugins():
    import snaked.plugins
    result = {}
    for p in snaked.plugins.__path__:
        try:
            for n in os.listdir(p):
                if isdir(join(p, n)) and exists(join(p, n, '__init__.py')):
                    result[n] = True
        except OSError:
            pass

    return result.keys()


class PluginDialog(BuilderAware):
    def __init__(self):
        BuilderAware.__init__(self, join_to_file_dir(__file__, 'plugin_prefs.glade'))

        from snaked.core.manager import keymap
        self.activator = keymap.get_activator(self.window)
        self.activator.bind('any', 'escape', None, self.hide)


    def show(self, enabled_plugins, callback):
        self.callback = callback
        self.fill_plugin_list(enabled_plugins)
        self.window.present()

    def hide(self):
        enabled_plugins = [p[1] for p in self.plugins if p[0]]
        self.callback(enabled_plugins)
        self.window.destroy()

    def on_delete_event(self, *args):
        idle(self.hide)
        return True

    def get_aviable_plugins(self):
        for pname in discover_plugins():
            failed = False
            try:
                package = get_plugin(pname)
            except:
                failed = True

            name = getattr(package, 'name', pname)
            desc = getattr(package, 'desc', 'Load failed' if failed else 'Some weird plugin')
            markup = "<b>%s</b>\n<small>%s</small>" % tuple(
                map(markup_escape_text, (name, desc)))

            yield (pname, markup, name)

    def fill_plugin_list(self, enabled):
        self.plugins.clear()

        for p in sorted(self.get_aviable_plugins(), key=lambda r: r[-1]):
            self.plugins.append((p[0] in enabled,) + p)

        self.plugins_tree.columns_autosize()
        self.plugins_tree.set_cursor("0", self.plugins_tree.get_columns()[0])

    def on_enabled_toggled(self, renderer, path):
        iter = self.plugins.get_iter(path)
        self.plugins.set_value(iter, 0, not renderer.get_active())

########NEW FILE########
__FILENAME__ = prefs
import weakref

from uxie.utils import idle, join_to_file_dir
from uxie.misc import BuilderAware

from snaked.util import set_activate_the_one_item

import snaked.core.prefs as prefs

class PreferencesDialog(BuilderAware):
    def __init__(self):
        BuilderAware.__init__(self, join_to_file_dir(__file__, 'prefs.glade'))

        from snaked.core.shortcuts import ShortcutActivator
        self.activator = ShortcutActivator(self.window)
        self.activator.bind('Escape', self.hide)
        self.activator.bind('<alt>s', self.focus_search)

        set_activate_the_one_item(self.search_entry, self.dialogs_view)

    def hide(self):
        self.window.destroy()

    def show(self, editor):
        self.editor = weakref.ref(editor)
        self.fill_dialogs(None)
        editor.request_transient_for.emit(self.window)
        self.window.show()

    def fill_dialogs(self, search):
        self.dialogs.clear()

        for name in sorted(prefs.registered_dialogs):
            keywords, show_func = prefs.registered_dialogs[name]
            if not search or any(w.startswith(search) for w in keywords):
                markup = '<b>%s</b>\n<small>%s</small>' % (
                    name, u' \u2022 '.join(keywords))
                self.dialogs.append((name, markup))

    def on_delete_event(self, *args):
        return False

    def on_search_entry_changed(self, *args):
        search = self.search_entry.get_text().strip().lower()
        idle(self.fill_dialogs, search)

    def activate(self, *args):
        (model, iter) = self.dialogs_view.get_selection().get_selected()
        if iter:
            name = model.get_value(iter, 0)
            prefs.registered_dialogs[name][1](self.editor())
            idle(self.hide)
        else:
            self.editor().message('You need select item')

    def focus_search(self):
        self.search_entry.grab_focus()
########NEW FILE########
__FILENAME__ = session_selector
import os.path

from uxie.utils import join_to_file_dir
from uxie.misc import BuilderAware

def select_session():
    dialog = SessionSelector().dialog
    response = dialog.run()
    result = dialog.selected_session if response == 1 else None
    dialog.destroy()
    return result

class SessionSelector(BuilderAware):
    def __init__(self):
        BuilderAware.__init__(self, join_to_file_dir(__file__, 'select_session.glade'))

        from snaked.core.prefs import get_settings_path

        self.dialog.vbox.remove(self.dialog.action_area)
        self.dialog.set_default_response(1)

        cfg = get_settings_path('')
        for p in os.listdir(cfg):
            if os.path.isdir(os.path.join(cfg, p)):
                self.sessions.append((p,))

    def on_row_activated(self, view, path, *args):
        self.dialog.selected_session = self.sessions[path][0]
        self.dialog.response(1)
########NEW FILE########
__FILENAME__ = manager
import os.path

import gtk
import gtksourceview2

from uxie.utils import idle, join_to_file_dir, join_to_settings_dir
from uxie.plugins import Manager as PluginManager
from uxie.actions import KeyMap

from ..util import lazy_property, get_project_root, save_file

from . import prefs

from .editor import Editor
from .context import Processor as ContextProcessor, Manager as ContextManager, \
                     FakeManager as FakeContextManager

import snaked.core.quick_open
import snaked.core.titler
import snaked.core.editor_list
import snaked.core.window
import snaked.core.plugins
import snaked.core.console
import snaked.core.spot
import snaked.core.monitor
import snaked.core.completer

prefs.add_option('RESTORE_POSITION', True, 'Restore snaked windows position')
prefs.add_option('CONSOLE_FONT', 'Monospace 8', 'Font used in console panel')
prefs.add_option('MIMIC_PANEL_COLORS_TO_EDITOR_THEME', True,
                 'Try to apply editor color theme to various panels')
prefs.add_option('WINDOW_BORDER_WIDTH', 0, 'Adjust window border width if you have bad wm')
prefs.add_option('SHOW_TABS', None,
                 'State of tabs visibility. Set it to None to use window specific settings')
prefs.add_option('TAB_BAR_PLACEMENT', None,
                 '''Tab bar placement position. One of "top", "bottom", "left", "right"
                    Set it to None to use window specific settings''')

prefs.add_internal_option('WINDOWS', list)
prefs.add_internal_option('MODIFIED_FILES', dict)

keymap = KeyMap(join_to_settings_dir('snaked', 'keys.conf'))
keymap.map_generic('root-menu', 'F1')
keymap.map_generic('activate-search-entry', '<ctrl>s')
keymap.map_generic('escape', 'Escape')
keymap.map_generic('delete', 'Delete')

keymap.map_generic('prev', '<ctrl>Up', 1)
keymap.map_generic('next', '<ctrl>Down', 1)

keymap.map_generic('complete', '<ctrl>space', 1)
keymap.map_generic('goto-definition', 'F3')
keymap.map_generic('show-outline', '<ctrl>o')
keymap.map_generic('show-calltip', '<ctrl>Return', 1)

keymap.map_generic('run-test', '<ctrl>F10')
keymap.map_generic('run-all-tests', '<ctrl><shift>F10')
keymap.map_generic('rerun-test', '<shift><alt>x')
keymap.map_generic('toggle-test-panel', '<alt>1')


class EditorManager(object):
    def __init__(self, session):
        self.buffers = []
        self.windows = []

        self.session = session
        self.style_manager = gtksourceview2.style_scheme_manager_get_default()
        self.lang_manager = gtksourceview2.language_manager_get_default()
        self.modify_lang_search_path(self.lang_manager)

        self.activator = keymap.get_activator(config_section='editor_window')
        self.activator.add_context('manager', (), lambda: self)

        self.activator.bind_menu('_File#1')
        self.activator.bind_menu('_Edit#10')
        self.activator.bind_menu('_Prefs#15/_Global#90')
        self.activator.bind_menu('Prefs/_Session')
        self.activator.bind_menu('Prefs/_Project')
        self.activator.bind_menu('_View#20')
        self.activator.bind_menu('Too_ls#30')
        self.activator.bind_menu('_Run#40')
        self.activator.bind_menu('_Tab#90')
        self.activator.bind_menu('_Window#100')

        self.activator.bind('manager', 'quit', 'File/_Quit#100', EditorManager.quit).to('<ctrl>q')
        self.activator.bind('window', 'plugin-list', 'Prefs/Pl_ugins#10',
            snaked.core.plugins.show_plugins_prefs)

        self.activator.alias(('window', 'activator'), 'root-menu', 'Prefs/_Root menu#100')

        self.plugin_manager = PluginManager(self.activator)

        self.init_conf()

        self.default_ctx_processor = ContextProcessor(join_to_settings_dir('snaked', 'contexts.conf'))
        self.session_ctx_processor = ContextProcessor(
            join_to_settings_dir('snaked', self.session, 'contexts'))
        self.ctx_managers = {}

        self.escape_stack = []
        self.escape_map = {}
        self.on_quit = []

        # Init core plugins
        self.plugin_manager.add_plugin(prefs)
        self.plugin_manager.add_plugin(snaked.core.quick_open)
        self.plugin_manager.add_plugin(snaked.core.editor_list)
        self.plugin_manager.add_plugin(snaked.core.titler)
        self.plugin_manager.add_plugin(snaked.core.console)
        self.plugin_manager.add_plugin(snaked.core.spot)
        self.plugin_manager.add_plugin(snaked.core.monitor)
        self.plugin_manager.add_plugin(snaked.core.completer)

        self.spot_manager = snaked.core.spot.Manager()

        self.plugin_manager.ready('manager', self)

        self.plugin_manager.add_plugin(snaked.core.window)

        snaked.core.plugins.init_plugins(self.plugin_manager)

    def init_conf(self):
        self.default_config = prefs.PySettings(prefs.options)
        self.default_config.load(prefs.get_settings_path('snaked.conf'))

        self.session_config = prefs.PySettings(parent=self.default_config)
        self.session_config.load(prefs.get_settings_path(self.session, 'config'))

        self.internal_config = prefs.PySettings(prefs.internal_options)
        self.internal_config.load(prefs.get_settings_path(self.session, 'internal'))

        self.conf = prefs.CompositePreferences(self.internal_config, self.session_config)

    def save_conf(self, active_editor=None):
        self.default_config.save()
        self.internal_config.save()
        self.session_config.save()

    def get_context_manager(self, project_root):
        try:
            return self.ctx_managers[project_root]
        except KeyError:
            pass

        if project_root:
            manager = ContextManager(project_root,
                [self.default_ctx_processor, self.session_ctx_processor],
                os.path.join(project_root, '.snaked_project', 'contexts'))
        else:
            manager = FakeContextManager()

        self.ctx_managers[project_root] = manager
        return manager

    def get_buffer_for_uri(self, filename):
        for buf in self.buffers:
            if buf.uri == filename:
                return buf

        return None

    def open(self, filename, line=None, contexts=None):
        buf = self.get_buffer_for_uri(filename)
        if buf:
            editor = Editor(self.conf, buf)
        else:
            editor = Editor(self.conf)
            self.buffers.append(editor.buffer)
            editor.buffer.session = self.session
            editor.buffer.uri = filename

            idle(self.set_buffer_prefs, editor.buffer, filename, contexts)
            idle(self.plugin_manager.ready, 'buffer-created', editor.buffer)
            idle(self.plugin_manager.ready, 'editor-with-new-buffer-created', editor)

            idle(editor.update_view_preferences)

            idle(editor.load_file, filename, line)
            idle(self.plugin_manager.ready, 'buffer-loaded', editor.buffer)

            idle(self.plugin_manager.ready, 'editor-with-new-buffer', editor)

        idle(self.plugin_manager.ready, 'editor', editor)
        return editor

    def open_or_activate(self, uri, window=None, line=None):
        buf = self.get_buffer_for_uri(uri)
        if buf:
            if window:
                for e in window.editors:
                    if e.buffer is buf:
                        if line is not None:
                            e.goto_line(line)
                        e.focus()
                        return e

            for e in self.get_editors():
                if e.buffer is buf:
                    if line is not None:
                        e.goto_line(line)
                    e.focus()
                    return e
        else:
            window = window or [w for w in self.windows if w][0]
            e = self.open(uri, line)
            window.attach_editor(e)
            return e

    @lazy_property
    def lang_prefs(self):
        return prefs.load_json_settings('langs.conf', {})

    def set_buffer_prefs(self, buf, filename, lang_id=None):
        lang = None
        buf.lang = 'default'

        root = get_project_root(filename)
        ctx_manager = self.get_context_manager(root)

        if not lang_id:
            lang_id = ctx_manager.get_first('lang', filename)

        if lang_id:
            lang = self.lang_manager.get_language(lang_id)
            if lang:
                buf.lang = lang.get_id()

        if not lang:
            lang = self.lang_manager.guess_language(filename, None)
            if lang:
                buf.lang = lang.get_id()

        if lang:
            buf.set_language(lang)

        buf.contexts = [buf.lang]
        buf.contexts += ctx_manager.get_all('ctx', filename)

        if self.session:
            buf.contexts.append('session:' + self.session)

        buf.config = prefs.CompositePreferences(self.lang_prefs.get(buf.lang, {}),
            self.lang_prefs.get('default', {}), prefs.default_prefs.get(buf.lang, {}),
            prefs.default_prefs['default'])

        style_scheme = self.style_manager.get_scheme(buf.config['style'])
        buf.set_style_scheme(style_scheme)

    def window_closed(self, window):
        self.windows[self.windows.index(window)] = False
        window.destroy()
        if not any(self.windows):
            self.quit()

    def get_editors(self):
        for w in self.get_windows():
            for e in w.editors:
                yield e

    def get_windows(self):
        for w in self.windows:
            if w:
                yield w

    def editor_closed(self, editor):
        buf = editor.buffer
        is_last_buffer = not any(e.buffer is buf for e in self.get_editors() if e is not editor)

        self.plugin_manager.done('editor', editor)

        if is_last_buffer:
            self.plugin_manager.done('last-buffer-editor', editor)

        editor.on_close()
        del editor.view
        del editor.buffer

        if not is_last_buffer:
            return

        self.plugin_manager.done('buffer', buf)

        self.buffers.remove(buf)
        if buf.get_modified():
            text = unicode(buf.get_text(*buf.get_bounds()), 'utf-8')
            self.conf['MODIFIED_FILES'][buf.uri] = save_file(buf.uri, text, buf.encoding, True)
        else:
            try:
                del self.conf['MODIFIED_FILES'][buf.uri]
            except KeyError:
                pass

    def quit(self):
        for w in self.windows:
            if w: w.close(False)

        self.save_conf()

        self.plugin_manager.done('manager', self)

        for q in self.on_quit:
            try:
                q()
            except:
                import traceback
                traceback.print_exc()

        if gtk.main_level() > 0:
            gtk.main_quit()

    def modify_lang_search_path(self, manager):
        search_path = manager.get_search_path()
        user_path = os.path.expanduser('~')
        for i, p in enumerate(search_path):
            if not p.startswith(user_path):
                break

        search_path.insert(i, join_to_file_dir(__file__, 'lang-specs'))
        manager.set_search_path(search_path)

    def save_all(self, editor):
        for e in self.editors:
            e.save()

    def get_free_window(self):
        for idx, (w, wc) in enumerate(zip(self.windows, self.conf['WINDOWS'])):
            if not w:
                w = snaked.core.window.Window(self, wc)
                self.windows[idx] = w
                return w

        wc = {'name':'window%d' % len(self.windows)}
        self.conf['WINDOWS'].append(wc)
        w = snaked.core.window.Window(self, wc)
        self.windows.append(w)
        return w

    def start(self, files_to_open):
        opened_files = set()

        if not self.conf['WINDOWS']:
            self.conf['WINDOWS'].append({'name':'main'})

        main_window = None
        for window_conf in self.conf['WINDOWS']:
            files = [r['uri'] for r in window_conf.get('files', [])
                if os.path.exists(r['uri']) and os.path.isfile(r['uri'])]

            if files:
                w = snaked.core.window.Window(self, window_conf)
                self.windows.append(w)
                main_window = main_window or w

                for f in files:
                    e = self.open(f)
                    w.attach_editor(e)
                    opened_files.add(f)
            else:
                self.windows.append(False)

        window = main_window or self.get_free_window()
        for f in files_to_open:
            f = os.path.abspath(f)
            window.window_conf['active-uri'] = f
            if f not in opened_files:
                e = self.open(f)
                window.attach_editor(e)
                opened_files.add(f)

        for w in self.windows:
            if w:
                if w.window_conf.get('active-uri', None):
                    w.open_or_activate(w.window_conf['active-uri'])

        if not self.buffers:
            snaked.core.quick_open.quick_open(window)


########NEW FILE########
__FILENAME__ = monitor
import gio
import glib
import weakref

def init(injector):
    injector.on_ready('buffer-loaded', buffer_loaded)
    injector.on_done('buffer', buffer_closed)
    injector.on_ready('manager', store_manager_ref)

def buffer_loaded(buf):
    monitor = gio.File(path=buf.uri).monitor(gio.FILE_MONITOR_SEND_MOVED)
    monitor.connect('changed', on_file_changed, weakref.ref(buf))
    buf.monitor = monitor

def buffer_closed(buf):
    buf.monitor.cancel()
    del buf.monitor

def store_manager_ref(manager):
    global manager_ref
    manager_ref = weakref.ref(manager)

collected_file_changes = {}
timer_id = [None]
manager_ref = None

def changes_done():
    changed = []
    deleted = []
    for buf, event in collected_file_changes.items():
        buf = buf()
        if event == 'changed':
            try:
                text = get_new_content(buf)
            except:
                import traceback
                traceback.print_exc()
                continue

            if text is not None:
                changed.append(buf)
                update_buffer_content(buf, text)

        elif event == 'deleted':
            deleted.append(buf)

    for window in manager_ref().get_windows():
        changed_buffers = []
        for e in window.editors:
            if e.buffer in changed:
                changed_buffers.append(e.buffer)
            elif e.buffer in deleted:
                e.message('File deleted', 'warn', 0)

        if changed_buffers:
            message = 'External change detected:\n'
            message += '\n'.join(r.uri for r in changed_buffers)
            message += '\nOriginal content stored in an undo history.'
            window.message(message, 'warn', 0)

    collected_file_changes.clear()
    timer_id[0] = None

def get_new_content(buf):
    text = open(buf.uri).read().decode(buf.encoding)
    buf_text = buf.get_text(*buf.get_bounds()).decode('utf-8')
    if text != buf_text:
        return text

    return None

def update_buffer_content(buf, text):
    buf.begin_user_action()
    buf.set_text(text)
    buf.set_modified(False)
    buf.end_user_action()
    buf.is_changed = False

def on_file_changed(monitor, changed_file, other_file, event_type, buf):
    if getattr(monitor, 'saved_by_snaked', False):
        monitor.saved_by_snaked = False
        return

    if event_type == gio.FILE_MONITOR_EVENT_CHANGES_DONE_HINT:
        collected_file_changes[buf] = 'changed'
    elif event_type == gio.FILE_MONITOR_EVENT_DELETED:
        collected_file_changes[buf] = 'deleted'

    if timer_id[0]:
        glib.source_remove(timer_id[0])

    timer_id[0] = glib.timeout_add(1000, changes_done)

########NEW FILE########
__FILENAME__ = plugins
import sys

from uxie.utils import join_to_data_dir, idle

from .prefs import ListSettings

import snaked.plugins
snaked.plugins.__path__.insert(0, join_to_data_dir('snaked', 'plugins'))

default_enabled_plugins = ['save_positions', 'edit_and_select',
    'python', 'complete_words', 'hash_comment', 'python_flakes', 'goto_line',
    'search']

enabled_plugins = []

enabled_plugins_prefs = ListSettings('enabled-plugins.db')

def get_package(name):
    try:
        return sys.modules[name]
    except KeyError:
        __import__(name)
        return sys.modules[name]

def get_plugin(name):
    package_name = 'snaked.plugins.' + name
    return get_package(package_name)

def init_plugin(name, manager):
    try:
        p = get_plugin(name)
    except:
        import traceback
        traceback.print_exc()
    else:
        manager.add_plugin(p)

def get_available_plugins():
        return ListSettings('enabled-plugins.db')

def init_plugins(plugin_manager):
    enabled_plugins[:] = enabled_plugins_prefs.load(default_enabled_plugins)
    for name in enabled_plugins:
        idle(init_plugin, name, plugin_manager)

def show_plugins_prefs(window):
    from snaked.core.gui.plugin_prefs import PluginDialog
    dialog = PluginDialog()
    dialog.window.set_transient_for(window)

    def set_plugin_list(plugin_list):
        enabled_plugins_prefs.store(plugin_list)
        plugins_activated = False
        for name in [r for r in plugin_list if r not in enabled_plugins]:
            plugins_activated = True
            enabled_plugins.append(name)
            init_plugin(name, window.manager.plugin_manager)

        window.message('Enabled plugins list saved', 'done', 5000)

        if plugins_activated:
            window.message('Enabled plugins have been activated', 'done', 5000)

        if any(r not in plugin_list for r in enabled_plugins):
            window.message('You should restart snaked to deactivate disabled plugins', 'warn', 5000)

    dialog.show(enabled_plugins_prefs.load(default_enabled_plugins), set_plugin_list)

########NEW FILE########
__FILENAME__ = prefs
import anydbm, whichdb
import os.path
import json
from itertools import chain
from inspect import cleandoc

import gtk, pango

from uxie.utils import make_missing_dirs, join_to_settings_dir

def init(injector):
    injector.bind('window', 'editor-prefs', 'Prefs/_Editor settings#1', show_editor_preferences)
    injector.bind('window', 'default-config', 'Prefs/Global/_Config', show_default_config)
    injector.bind('window', 'default-contexts', 'Prefs/Global/Conte_xts',
        show_contexts_config, 'default')

    injector.bind('window', 'session-config', 'Prefs/Session/_Config', show_session_config)
    injector.bind('window', 'session-contexts', 'Prefs/Session/Conte_xts',
        show_contexts_config, 'session')

    injector.bind('window', 'project-contexts', 'Prefs/_Project/Conte_xts',
        show_contexts_config, 'project')

    injector.bind_menu('Prefs').to('<ctrl>p')

def show_editor_preferences(window):
    from snaked.core.gui.editor_prefs import PreferencesDialog
    dialog = PreferencesDialog(window.manager.lang_prefs)
    dialog.show(window)

def show_default_config(window):
    window.manager.default_config.save()
    uri = join_to_settings_dir('snaked', 'snaked.conf')
    e = window.manager.open(uri, contexts='python')
    window.attach_editor(e)
    e.connect('file-saved', on_config_saved, window.manager.default_config, uri)

def show_session_config(window):
    window.manager.session_config.save()
    uri = join_to_settings_dir('snaked', window.manager.session, 'config')
    e = window.manager.open(uri, contexts='python')
    window.attach_editor(e)
    e.connect('file-saved', on_config_saved, window.manager.session_config, uri)

def on_config_saved(editor, config, config_path):
    editor.message('Config updated', 'done')
    config.load(config_path)

def show_contexts_config(window, config_type):
    import shutil
    from os.path import join, exists, dirname
    from uxie.utils import make_missing_dirs

    manager = window.manager

    if config_type == 'default':
        processor = manager.default_ctx_processor
    elif config_type == 'session':
        processor = manager.session_ctx_processor
    elif config_type == 'project':
        editor = window.get_editor_context()
        if not editor:
            window.message('Hmm. Project?', 'warn')
            return

        root = editor.project_root
        if not root:
            editor.message('Current project root is not defined', 'warn')
            return

        processor = manager.get_context_manager(root).project_processor
    else:
        raise Exception('Unknown context config type: ' + str(config_type))

    uri = processor.filename
    if not exists(uri):
        make_missing_dirs(uri)
        shutil.copy(join(dirname(__file__), 'contexts.template'), uri)

    e = window.manager.open(uri)
    window.attach_editor(e)
    e.connect('file-saved', on_context_saved)

def on_context_saved(editor):
    editor.message('Contexts updated', 'done')
    for m in editor.window.manager.ctx_managers.values():
        m.invalidate()

default_prefs = {
    'default': {
        'font': 'Monospace 11',
        'use-tabs': True,
        'tab-width': 4,
        'show-right-margin': False,
        'right-margin': 100,
        'show-line-numbers': True,
        'wrap-text': False,
        'style': 'classic',
        'auto-indent': True,
        'indent-on-tab': True,
        'smart-home-end': True,
        'highlight-current-line': True,
        'show-whitespace': False,
        'line-spacing': 0,
        'remove-trailing-space': False,
    },
    'python': {
        'use-tabs': False,
        'show-right-margin': True,
        'remove-trailing-space': True,
    },
    'snippets': {
        'use-tabs': True,
        'remove-trailing-space': False,
    },
    'rst': {
        'use-tabs': False,
        'tab-width': 3,
        'remove-trailing-space': False,
        'right-margin': 80,
        'show-right-margin': True,
    }
}

def update_view_preferences(view, buf):
    # Try to fix screen flickering
    # No hope, should mail bug to upstream
    #text_style = style_scheme.get_style('text')
    #if text_style and editor.view.window:
    #    color = editor.view.get_colormap().alloc_color(text_style.props.background)
    #    editor.view.modify_bg(gtk.STATE_NORMAL, color)

    pref = buf.config

    font = pango.FontDescription(pref['font'])
    view.modify_font(font)

    view.set_auto_indent(pref['auto-indent'])
    view.set_indent_on_tab(pref['indent-on-tab'])
    view.set_insert_spaces_instead_of_tabs(not pref['use-tabs'])
    view.set_smart_home_end(pref['smart-home-end'])
    view.set_highlight_current_line(pref['highlight-current-line'])
    view.set_show_line_numbers(pref['show-line-numbers'])
    view.set_tab_width(pref['tab-width'])
    view.set_draw_spaces(pref['show-whitespace'])
    view.set_right_margin_position(pref['right-margin'])
    view.set_show_right_margin(pref['show-right-margin'])
    view.set_wrap_mode(gtk.WRAP_WORD if pref['wrap-text'] else gtk.WRAP_NONE)
    view.set_pixels_above_lines(pref['line-spacing'])

def load_json_settings(name, default=None):
    filename = get_settings_path(name)
    try:
        with open(filename) as f:
            try:
                return json.load(f)
            except ValueError:
                pass
    except IOError:
        pass

    return default

def save_json_settings(name, value):
    filename = get_settings_path(name)
    with open(filename, 'w') as f:
        json.dump(value, f, sort_keys=True, indent=4)

def get_settings_path(*name):
    filename = join_to_settings_dir('snaked', *name)
    make_missing_dirs(filename)
    return filename


options = {}
def add_option(name, default, desc=''):
    options[name] = (default, desc)

internal_options = {}
def add_internal_option(name, default, desc=''):
    internal_options[name] = (default, desc)

def add_editor_preferences(on_dialog_created, on_pref_refresh, default_values):
    import snaked.core.gui.editor_prefs

    for k, v in default_values.iteritems():
        default_prefs.setdefault(k, {}).update(v)

    snaked.core.gui.editor_prefs.on_dialog_created_hooks.append(on_dialog_created)
    snaked.core.gui.editor_prefs.on_pref_refresh_hooks.append(on_pref_refresh)

class CompositePreferences(object):
    def __init__(self, *prefs):
        self.prefs = list(prefs)

    def __getitem__(self, key):
        for p in self.prefs:
            try:
                return p[key]
            except KeyError:
                pass

        raise KeyError('There is no %s in preferences' % key)

    def __setitem__(self, key, value):
        for p in self.prefs:
            if key in p:
                p[key] = value
                return

        raise KeyError('There is no %s in preferences' % key)

    def __contains__(self, key):
        raise NotImplementedError()


class KVSettings(object):
    def __init__(self, *name):
        filename = get_settings_path(*name)

        # Dirty. Try to avoid locking of gdbm files
        result = whichdb.whichdb(filename)
        if result is None:
            result = anydbm._defaultmod.__name__
        elif result == "":
            raise Exception("db type of %s could not be determined" % filename)

        if result == 'gdbm':
            flags = 'cu'
        else:
            flags = 'c'

        self.db = anydbm.open(filename, flags)

    def get_key(self, key):
        if isinstance(key, unicode):
            return key.encode('utf-8')
        else:
            return key

    def __getitem__(self, key):
        return self.db[self.get_key(key)]

    def __contains__(self, key):
        return self.db.has_key(self.get_key(key))

    def __setitem__(self, key, value):
        self.db[self.get_key(key)] = value

    def save(self):
        self.db.sync()

class ListSettings(object):
    def __init__(self, name):
        self.path = get_settings_path(name)

    def exists(self):
        return os.path.exists(self.path)

    def load(self, default):
        try:
            return [l.strip() for l in open(self.path)]
        except IOError:
            return default

    def store(self, data):
        open(self.path, 'w').write('\n'.join(data))


class DefaultValue(object):
    def __init__(self, conf, name, additional=None):
        self.conf = conf
        self.name = name
        self.additional = additional

    @property
    def value(self):
        try:
            return self._value
        except AttributeError:
            pass

        default_value = self.conf[self.name]
        if isinstance(default_value, dict):
            value = DefaultDictValue(default_value, self.additional)
        elif isinstance(default_value, list):
            value = DefaultListValue(default_value, self.additional)
        else:
            raise Exception('Unsupported default type: ' + str(type(default_value)))

        self._value = value
        return value

    def __iter__(self):
        return self.value.__iter__()

    def __add__(self, x):
        return DefaultValue(self.conf, self.name, x)

    def __getitem__(self, name):
        return self.value[name]

    def __contains__(self, name):
        return name in self.value

    def __setitem__(self, name, value):
        self.value[name] = value

    def __repr__(self):
        if self.additional is None:
            return "default['%s']" % self.name
        else:
            return "default['%s'] + %s" % (self.name, repr(self.additional))

class DefaultListValue(object):
    def __init__(self, default, x):
        self.default = default + x

    def __iter__(self):
        return iter(self.default)


class DefaultDictValue(object):
    def __init__(self, default, x):
        self.default = default.copy()
        self.default.update(x)
        self.additional = x

    def __getitem__(self, name):
        return self.default[name]

    def __contains__(self, name):
        return name in self.default

    def __setitem__(self, name, value):
        self.additional[name] = value
        self.default[name] = value

    def __iter__(self):
        return iter(self.default)


class DefaultValuesProvider(object):
    def __init__(self, conf):
        self.conf = conf

    def __getitem__(self, name):
        return DefaultValue(self.conf, name)


class PySettings(object):
    def __init__(self, options=None, parent=None):
        assert options or parent
        if parent:
            self.parent = parent
            self.options = parent.options
        else:
            self.options = options
            self.parent = None

        self.data = {}

    def __getitem__(self, name):
        try:
            return self.data[name]
        except KeyError:
            pass

        if self.parent:
            v = self.parent[name]
            if isinstance(v, list):
                v = v[:]
            elif isinstance(v, dict):
                v = v.copy()
        else:
            v = self.get_default(name)

        self.data[name] = v
        return v

    def __contains__(self, name):
        return name in self.options

    def get_default(self, name):
        value = self.options[name][0]
        if callable(value):
            value = value()

        return value

    def __setitem__(self, name, value):
        self.data[name] = value

    def get_config(self):
        result = ''
        for name in sorted(set(chain(self.data, self.options))):
            doc = cleandoc(self.options.get(name, (0, 'Unknown option'))[1])
            if doc:
                for l in doc.splitlines():
                    result += '# ' + l + '\n'

            if name not in self.options:
                value = self.data[name]
                is_default = False
            elif name not in self.data:
                is_default = True
                if self.parent:
                    value = self.parent[name]
                else:
                    value = self.get_default(name)
            else:
                value = self.data[name]
                if (self.parent and value == self.parent[name]) or (
                        not self.parent and value == self.get_default(name)):
                    is_default = True
                else:
                    is_default = False

            value = '%s = %s' % (name, repr(value))
            if is_default:
                value = '# ' + value

            result += value + '\n\n'

        return result

    def load(self, filename):
        self.filename = filename
        self.data.clear()

        if self.parent:
            self.data['default'] = DefaultValuesProvider(self.parent)

        try:
            execfile(self.filename, self.data)
        except IOError:
            pass
        except SyntaxError, e:
            print 'Error on loading config: %s' % self.filename, e

        try:
            del self.data['__builtins__']
        except KeyError:
            pass

        if self.parent:
            del self.data['default']

    def save(self):
        with open(self.filename, 'w') as f:
            f.write(self.get_config())

########NEW FILE########
__FILENAME__ = problems
import weakref
import gtk
import pango

marked_problems = weakref.WeakKeyDictionary()
attached_editors = weakref.WeakKeyDictionary()

def attach_to_editor(editor):
    """Attach problem tooltips to editor

    It's safe to call function twice on same editor.
    To show problems use :ref:mark_problems

    """
    if editor not in attached_editors:
        attached_editors[editor] = True
        editor.view.connect('query-tooltip', on_query_tooltip)
        editor.view.set_property('has-tooltip', True)

def on_query_tooltip(view, x, y, keyboard_mode, tooltip):
    x, y = view.window_to_buffer_coords(gtk.TEXT_WINDOW_WIDGET, x, y)
    iterator = view.get_iter_at_location(x, y)
    tags = iterator.get_tags()
    if tags:
        tags.reverse()
        for tag in tags:
            try:
                message = marked_problems[view][tag.props.name]
            except KeyError:
                pass
            else:
                box = gtk.EventBox()
                box.set_border_width(5)
                box.add(gtk.Label(message))
                box.show_all()
                tooltip.set_custom(box)

                return True

    return False

def get_tag(editor, prefix, num, message):
    table = editor.buffer.get_tag_table()
    tag_name = '%s_%d' % (prefix, num)

    tag = table.lookup(tag_name)
    if not tag:
        tag = editor.buffer.create_tag(tag_name, underline=pango.UNDERLINE_ERROR)

    marked_problems.setdefault(editor.view, {})[tag_name] = '%s: %s' % (prefix, message)

    return tag

def clear_problems(editor, prefix):
    start, end = editor.buffer.get_bounds()

    sprefix = prefix + '_'
    def clean_tag(tag, data):
        tag_name = tag.props.name
        if tag_name and tag_name.startswith(sprefix):
            try:
                del marked_problems[editor.view][tag_name]
            except KeyError:
                pass

            editor.buffer.remove_tag_by_name(tag_name, start, end)
    editor.buffer.get_tag_table().foreach(clean_tag)

def mark_problems(editor, prefix, problems):
    """Marks problems with error underline

    Also binds messages which can be seen as tooltips to these marks

    :param prefix: problem namespace, e.g. ``python_flakes`` plugin define ``flakes``
                   namespace.
    :param problems: list of (line, name, message) tuples. Where name is suspicious
                      symbol and message is detailed description.

    """
    clear_problems(editor, prefix)

    for num, (line, name, message) in enumerate(problems):
        iter = editor.buffer.get_iter_at_line(line-1)
        nstart = nend = None
        while iter.get_line() == line - 1:
            result = iter.forward_search(name, gtk.TEXT_SEARCH_VISIBLE_ONLY)
            if result is None:
                break
            nstart, nend = result
            if nstart.starts_word() and nend.ends_word():
                break

            iter = nend

        if nstart:
            editor.buffer.apply_tag(get_tag(editor, prefix, num, message), nstart, nend)
        else:
            print "%s: can't find name [%s] on line %d in %s" % (prefix, name, line, editor.uri)

def mark_exact_problems(editor, prefix, problems):
    """Marks problems with error underline

    Also binds messages which can be seen as tooltips to these marks

    :param prefix: problem namespace, e.g. ``python_flakes`` plugin define ``flakes``
                   namespace.
    :param problems: list of ((line, offset), name, message) tuples. Where name is suspicious
                      symbol and message is detailed description.

    """
    clear_problems(editor, prefix)

    for num, ((line, offset), name, message) in enumerate(problems):
        nstart = editor.buffer.get_iter_at_line_offset(line - 1, offset)
        nend = nstart.copy()
        nend.forward_chars(len(name))
        editor.buffer.apply_tag(get_tag(editor, prefix, num, message), nstart, nend)

########NEW FILE########
__FILENAME__ = processors
import re

def remove_trailing_spaces(buffer):
    matcher = re.compile(r'(?um)([ \t]+)$')
    while True:
        match = matcher.search(buffer.get_text(*buffer.get_bounds()).decode('utf-8'))
        if match:
            buffer.delete(*map(buffer.get_iter_at_offset, match.span(1)))
        else:
            break

########NEW FILE########
__FILENAME__ = gui
import os.path
import weakref

import gtk

from uxie.utils import idle, join_to_file_dir, refresh_gui
from uxie.misc import BuilderAware
from uxie.actions import Activator

from snaked.util import set_activate_the_one_item

import settings
import searcher

class QuickOpenDialog(BuilderAware):
    """glade-file: gui.glade"""

    def __init__(self):
        super(QuickOpenDialog, self).__init__(join_to_file_dir(__file__, 'gui.glade'))

        from snaked.core.manager import keymap
        self.shortcuts = keymap.get_activator(self.window, 'quick_open')
        self.shortcuts.bind('any', 'activate-search-entry',
            'Activate search entry', self.focus_search)

        self.shortcuts.bind('any', 'open-mime', 'Run _external editor',
            self.open_mime).to('<ctrl>Return')
        self.shortcuts.bind('any', 'open-dialog', '_Open...', self.free_open).to('<ctrl>o')
        self.shortcuts.bind('any', 'toggle-hidden', 'Toggle _hidden',
            self.toggle_hidden).to('<ctrl>h')

        self.shortcuts.bind('any', 'project-list', 'Toggle project _list',
            self.toggle_projects).to('<ctrl>p', 1)
        self.shortcuts.bind('projectlist', 'delete', '_Delete project', self.delete_project)
        self.shortcuts.bind('projectlist', 'set-root', 'Use as _root',
            self.use_as_root).to('Return', 1)

        self.shortcuts.bind('any', 'goto-parent', 'Goto p_arent', self.browse_top).to('BackSpace')
        self.shortcuts.bind('any', 'escape', '_Close', self.escape)

        self.shortcuts.add_context('projectlist', (),
            lambda: self.projectlist_tree if self.projectlist_tree.is_focus() else None)

        project_selection = self.projectlist_tree.get_selection()
        project_selection.set_mode(gtk.SELECTION_MULTIPLE)
        project_selection.connect_after('changed', self.on_projectlist_selection_changed)

        set_activate_the_one_item(self.search_entry, self.filelist_tree)

        self.roots = []

    def get_stored_recent_projects(self):
        return self.pwindow().manager.conf['QUICK_OPEN_RECENT_PROJECTS']

    def store_recent_projects(self, projects):
        self.pwindow().manager.conf['QUICK_OPEN_RECENT_PROJECTS'][:] = list(projects)

    def get_editor_project_root(self):
        editor = self.pwindow().get_editor_context()
        return editor.project_root if editor else None

    def get_selected_projects(self):
        cur_projects = self.pwindow().manager.conf['QUICK_OPEN_CURRENT_PROJECTS']
        if not cur_projects:
            editor = self.pwindow().get_editor_context()
            if editor:
                cur_projects = [editor.get_project_root(larva=True)]
            else:
                cur_projects = [os.getcwd()]

        return cur_projects

    def on_projectlist_selection_changed(self, selection):
        model, paths = selection.get_selected_rows()
        self.pwindow().manager.conf['QUICK_OPEN_CURRENT_PROJECTS'][:] = [model[r][1] for r in paths]
        self.update_projects(self.get_selected_projects())

    def use_as_root(self, pl):
        cursor, _ = pl.get_cursor()
        if cursor:
            self.update_projects([pl.get_model()[cursor][1]])
        else:
            self.pwindow().emessage('Which project?', 'warn')

    def show(self, window, on_dialog_escape=None):
        self.on_dialog_escape = on_dialog_escape
        self.pwindow = weakref.ref(window)
        self.update_recent_projects()

        editor = window.get_editor_context()
        if editor:
            self.update_projects(self.get_selected_projects())
        self.window.set_transient_for(window)

        self.search_entry.grab_focus()

        self.window.present()

    def update_recent_projects(self):
        saved_projects = self.get_stored_recent_projects()

        if any(p not in saved_projects for p in settings.recent_projects):
            [saved_projects.append(p) for p in settings.recent_projects
                if p not in saved_projects]
            self.store_recent_projects(saved_projects)
            settings.recent_projects = saved_projects
            return

        if any(p not in settings.recent_projects for p in saved_projects):
            [settings.recent_projects.append(p) for p in saved_projects
                if p not in settings.recent_projects]

        sel = self.projectlist_tree.get_selection()
        sel.handler_block_by_func(self.on_projectlist_selection_changed)
        self.projectlist_tree.set_model(None)
        self.projectlist.clear()

        cur_projects = self.pwindow().manager.conf['QUICK_OPEN_CURRENT_PROJECTS']

        toselect = []
        for i, r in enumerate(settings.recent_projects):
            it = self.projectlist.append((os.path.basename(r), r))
            if r in cur_projects:
                toselect.append(it)

        for i, r in enumerate(reversed(sorted(settings.larva_projects, key=lambda r:len(r)))):
            it = self.projectlist.append((os.path.basename(r), r))
            if r in cur_projects:
                toselect.append(it)

        self.projectlist_tree.set_model(self.projectlist)

        for it in toselect:
            self.projectlist_tree.get_selection().select_iter(it)

        sel.handler_unblock_by_func(self.on_projectlist_selection_changed)

    def update_projects(self, roots):
        self.projects_lb.set_text('\n'.join(roots))

        if self.roots != roots:
            self.on_search_entry_changed()

        self.roots[:] = roots

    def hide(self):
        self.current_search = None
        self.window.hide()

    def on_delete_event(self, *args):
        self.escape()
        return True

    def fill_filelist(self, search, current_search):
        self.filelist.clear()

        already_matched = {}
        counter = [-1]

        def tick():
            counter[0] += 1
            if counter[0] % 50 == 0:
                refresh_gui()
                if self.current_search is not current_search:
                    raise StopIteration()

        bad_matchers = {}
        for r in self.roots:
            try:
                bad_re = self.pwindow().manager.get_context_manager(r).get()['quick_open']['ignore']
            except KeyError:
                bad_matchers[r] = None
            else:
                bad_matchers[r] = lambda path, bre=bad_re: bre.search(path)

        for m in (searcher.name_start_match, searcher.name_match,
                searcher.path_match, searcher.fuzzy_match):
            for root in self.roots:
                for p in searcher.search(os.path.dirname(root), os.path.basename(root),
                        m(search), already_matched, bad_matchers[root], tick):
                    if self.current_search is not current_search:
                        return

                    already_matched[p] = True
                    self.filelist.append(p)

                    if len(self.filelist) > 150:
                        self.filelist_tree.columns_autosize()
                        return

        self.filelist_tree.columns_autosize()

    def fill_with_dirs(self, root='', top='', place=False):
        self.filelist.clear()

        dirs = []
        files = []

        conf = self.pwindow().manager.conf
        hidden_masks = None
        if not conf['QUICK_OPEN_SHOW_HIDDEN']:
            hidden_masks = conf['QUICK_OPEN_HIDDEN_FILES']

        if not top and len(self.roots) > 1:
            for r in self.roots:
                dirs.append((os.path.basename(r), r, os.path.dirname(r), ''))
        else:
            if not top:
                root = self.roots[0]

            for name in os.listdir(os.path.join(root, top)):
                if hidden_masks and any(name.endswith(m) for m in hidden_masks):
                    continue

                fpath = os.path.join(root, top, name)
                if os.path.isdir(fpath):
                    dirs.append((name, fpath, root, top))
                else:
                    files.append((name, fpath, root, top))

        place_idx = 0
        for i, (name, fpath, root, top) in enumerate(sorted(dirs) + sorted(files)):
            if name == place:
                place_idx = i
            self.filelist.append((name, top, fpath, root))
        self.filelist_tree.columns_autosize()

        if place and len(self.filelist):
            self.filelist_tree.set_cursor((place_idx,))

    def on_search_entry_changed(self, *args):
        search = self.search_entry.get_text().strip()
        self.current_search = object()
        if search:
            idle(self.fill_filelist, search, self.current_search)
        else:
            idle(self.fill_with_dirs)

    def get_selected_file(self):
        (model, iter) = self.filelist_tree.get_selection().get_selected()
        if iter:
            name, top, path, root = self.filelist.get(iter, 0, 1, 2, 3)
            return path, name, root, top
        else:
            return None, None, None, None

    def open_file(self, *args):
        fname, name, root, top = self.get_selected_file()
        if fname:
            if os.path.isdir(fname):
                idle(self.fill_with_dirs, root, os.path.join(top, name), True)
            else:
                self.hide()
                refresh_gui()
                self.pwindow().open_or_activate(fname)

    def open_mime(self):
        fname, name, root, top = self.get_selected_file()
        if fname:
            import gio
            self.hide()
            refresh_gui()

            f = gio.file_parse_name(fname)
            ct = f.query_info(gio.FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE).get_content_type()
            ai = gio.app_info_get_default_for_type(ct, False)

            if ai:
                ai.launch([f])
            else:
                self.pwindow().emessage('Unknown content type for launch %s' % ct, 'error')

    def focus_search(self):
        self.search_entry.grab_focus()

    def escape(self):
        if self.on_dialog_escape:
            idle(self.on_dialog_escape, self)

        self.hide()

    def free_open(self):
        dialog = gtk.FileChooserDialog("Open file...",
            None,
            gtk.FILE_CHOOSER_ACTION_OPEN,
            (gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL,
            gtk.STOCK_OPEN, gtk.RESPONSE_OK))

        dialog.set_default_response(gtk.RESPONSE_OK)
        dialog.set_current_folder(self.roots[0])

        response = dialog.run()
        if response == gtk.RESPONSE_OK:
            idle(self.pwindow().open_or_activate, dialog.get_filename())
            idle(self.hide)

        dialog.destroy()

    def toggle_projects(self):
        if not self.scrolledwindow2.get_visible():
            self.scrolledwindow2.show()

        if self.projectlist_tree.is_focus():
            self.scrolledwindow2.hide()
            self.window.resize(self.window.size_request()[0], self.window.get_size()[1])
            getattr(self, 'last_focus', self.search_entry).grab_focus()
        else:
            self.last_focus = self.window.get_focus()
            self.projectlist_tree.grab_focus()

    def delete_project(self, pl):
        if len(self.projectlist):
            cursor, _ = pl.get_cursor()
            if cursor:
                current_root = self.projectlist[cursor][1]
                if current_root in self.roots:
                    self.pwindow().emessage('You can not remove current project', 'warn')
                    return

                settings.recent_projects.remove(current_root)
                self.store_recent_projects(settings.recent_projects)

                self.projectlist.remove(self.projectlist[cursor].iter)
                self.pwindow().emessage('Project removed', 'done')

    def browse_top(self):
        if not self.filelist_tree.is_focus():
            return False

        if self.search_entry.get_text():
            self.pwindow().emessage('You are not in browse mode', 'warn')
            return

        fname, name, root, top = self.get_selected_file()
        if fname:
            if not top:
                self.pwindow().emessage('No way!', 'warn')
            else:
                place = os.path.basename(top)
                idle(self.fill_with_dirs, root, os.path.dirname(top), place)

    def toggle_hidden(self):
        if self.search_entry.get_text():
            self.pwindow().emessage('You are not in browse mode', 'warn')
            return

        conf = self.pwindow().manager.conf
        conf['QUICK_OPEN_SHOW_HIDDEN'] = not conf['QUICK_OPEN_SHOW_HIDDEN']

        self.pwindow().emessage('Show hidden files' if conf['QUICK_OPEN_SHOW_HIDDEN']
            else 'Do not show hidden files', 'info')

        fname, name, root, top = self.get_selected_file()
        if fname:
            idle(self.fill_with_dirs, root, top, name)
        else:
            if len(self.filelist):
                name, top = self.filelist[0]
                idle(self.fill_with_dirs, root, top)
########NEW FILE########
__FILENAME__ = searcher
import re

def get_pattern(what):
    parts = what.split('/')

    if len(parts) <= 1:
        return None

    rexp = r'(/|^)' + r'[^/]+/'.join(map(re.escape, parts))
    return re.compile(rexp)

def name_start_match(what):
    def inner(name, path):
        return name.startswith(what)

    return inner

def name_match(what):
    def inner(name, path):
        return what in name

    return inner

def path_match(what):
    def inner(name, path):
        return what in path

    return inner

def fuzzy_match(what):
    pattern = get_pattern(what)
    def inner(name, path):
        if pattern:
            return pattern.search(path) is not None
        else:
            return False

    return inner

def dir_is_good(name, path):
    if name.startswith('.'):
        return False

    return True

def file_is_good(name, path):
    if any(map(name.endswith, ('.pyc', '.pyo', '.png'))):
        return False

    return True

def search(root, top, match, already_matched, bad_match, tick):
    from os import listdir
    from os.path import join, isdir

    tick()

    dirs_to_visit = []

    try:
        dir_list = listdir(join(root, top))
    except OSError:
        pass
    else:
        for name in dir_list:
            tick()
            fullpath = join(root, top, name)
            path = join(top, name)

            if bad_match and bad_match(fullpath):
                continue

            if isdir(fullpath):
                if dir_is_good(name, path):
                    dirs_to_visit.append(path)
            elif (name, top, fullpath, root) not in already_matched \
                    and match(name, path) and file_is_good(name, path):
                yield name, top, fullpath, root

    for path in dirs_to_visit:
        for p in search(root, path, match, already_matched, bad_match, tick):
            yield p

########NEW FILE########
__FILENAME__ = settings
recent_projects = []

larva_projects = []
########NEW FILE########
__FILENAME__ = run
from optparse import OptionParser
import os

from snaked import VERSION

def get_manager():
    parser = OptionParser(version='%prog ' + VERSION)
    parser.add_option('-s', '--session', dest='session',
        help="Open snaked with specified session", default='default')
    parser.add_option('', '--select-session', action="store_true", dest='select_session',
        help="Show dialog to select session at startup", default=False)
    parser.add_option('-d', '--debug', action="store_true", dest='debug',
        help="Run embedded drainhunter", default=False)
    parser.add_option('', '--g-fatal-warnings', action="store_true")

    options, args = parser.parse_args()
    if options.select_session:
        from snaked.core.gui import session_selector
        options.session = session_selector.select_session()

    from .app import is_master, serve

    master, conn = is_master(options.session)
    if master:
        import gobject
        gobject.threads_init()
        from .manager import EditorManager

        manager = EditorManager(options.session)
        manager.start(args)
        serve(manager, conn)

        if options.debug:
            import drainhunter.server
            drainhunter.server.run()

        return manager
    else:
        conn.send(['OPEN'] + list(map(os.path.abspath, args)))
        conn.send(['END'])
        conn.close()
        return None

def run():
    manager = get_manager()
    if not manager:
        return

    import gtk

    try:
        gtk.main()
    except KeyboardInterrupt:
        manager.quit()

########NEW FILE########
__FILENAME__ = spot
import weakref
import gtk

def init(injector):
    injector.add_context('spot-manager', 'window', lambda w: w.manager.spot_manager)
    #injector.add_context('edit-spot', 'editor-active', spot_context('edit'))
    #injector.add_context('master-spot', 'editor-active', spot_context('master'))
    injector.add_context('regular-spot', 'editor-active', spot_context('regular'))

    injector.bind(('spot-manager', 'editor-active', 'regular-spot'), 'goto-last-spot',
        'Edit/Goto last spot#70', Manager.goto_last).to('<Alt>q')

    #injector.bind_accel(('spot-manager', 'editor-active', 'edit-spot'), 'goto-last-spot',
    #    '_Edit/Goto last edit spot', '<Alt>q', Manager.goto_last, 5)

    injector.bind(('spot-manager', 'editor-active'), 'goto-next-spot',
        'Edit/Goto next spot', Manager.goto_next_prev, True).to('<ctrl>bracketright')

    injector.bind(('spot-manager', 'editor-active'), 'goto-prev-spot',
        'Edit/Goto prev spot', Manager.goto_next_prev, False).to('<ctrl>bracketleft')

    #injector.bind_accel(('spot-manager', 'editor-active', 'master-spot'), 'goto-last-spot',
    #    '_Edit/Goto last master spot', '<Alt>q', Manager.goto_last, 10)

    #injector.bind_accel(('spot-manager', 'editor-active'), 'add-master-spot',
    #    '_Edit/Add master spot', '<Alt>s', Manager.add_master_spot)


    injector.on_ready('buffer-created', buffer_created)
    injector.on_ready('editor', editor_opened)
    injector.on_done('editor', editor_closed)

def spot_context(spot_type):
    def inner(editor):
        new_spot = EditorSpot(editor, spot_type)
        spot = editor.window.manager.spot_manager.get_last(new_spot, None, spot_type)
        if spot:
            return spot, new_spot
        else:
            return None

    return inner

def buffer_created(buf):
    buf.connect('changed', on_buffer_changed)
    buf.is_changed = False

def on_buffer_changed(buf):
    buf.is_changed = True

def editor_opened(editor):
    editor.view.connect('move-cursor', on_textview_move_cursor)

def editor_closed(editor):
    editor.window.manager.spot_manager.remove_invalid_spots(editor=editor)

SAFE_MOVEMENTS = set((gtk.MOVEMENT_VISUAL_POSITIONS, gtk.MOVEMENT_WORDS,
    gtk.MOVEMENT_LOGICAL_POSITIONS, gtk.MOVEMENT_DISPLAY_LINE_ENDS))

def on_textview_move_cursor(view, step_size, count, extend_selection):
    if view.get_buffer().is_changed and step_size not in SAFE_MOVEMENTS:
        editor = view.editor_ref()
        editor.window.manager.spot_manager.add(editor)

class Manager(object):
    def __init__(self):
        self.history = []

    def add_master_spot(self, editor):
        self.add(editor, 'master')
        editor.message('Master spot added', 'done')

    def add(self, editor, spot_type=None):
        #if not spot_type and editor.buffer.is_changed:
        #    spot_type = 'edit'

        editor.buffer.is_changed = False
        self.add_to_history(EditorSpot(editor, spot_type))

    def remove_invalid_spots(self, spot=None, editor=None):
        result = []
        for i, s in enumerate(self.history):
            if i > 30 or (editor and s.editor() is editor) or not s.is_valid() or s.similar_to(spot):
                s.remove()
            else:
                result.append(s)

        self.history[:] = result

    def add_to_history(self, spot):
        self.remove_invalid_spots(spot=spot)
        self.history.insert(0, spot)

    def goto_last(self, editor, spots):
        if spots:
            spot, new_spot = spots
            spot.goto(editor)
            self.add_to_history(new_spot)
        else:
            editor.message('Spot history is empty', 'warn')

    def get_last(self, exclude_spot=None, exclude_editor=None, spot_type=None):
        spot_type = spot_type or 'regular'
        for s in self.history:
            if s.is_valid() and not s.similar_to(exclude_spot) \
                    and s.editor() is not exclude_editor and s.type == spot_type:
                return s

        return None

    def goto_next_prev(self, editor, is_next):
        current_spot = EditorSpot(editor)
        if is_next:
            seq = self.history
        else:
            seq = reversed(self.history)

        prev_spot = None
        for s in (s for s in seq if s.is_valid()):
            if s.similar_to(current_spot):
                if prev_spot:
                    prev_spot.goto(editor)
                else:
                    editor.message('No more spots to go', 'warn')
                return

            prev_spot = s

        spot = self.get_last(current_spot)
        if spot:
            self.goto_last(editor, (spot, current_spot))
        else:
            self.goto_last(editor, None)


class EditorSpot(object):
    def __init__(self, editor, spot_type=None):
        self.editor = weakref.ref(editor)
        self.mark = editor.buffer.create_mark(None, editor.cursor)
        self.type = spot_type or 'regular'

    @property
    def iter(self):
        return self.mark.get_buffer().get_iter_at_mark(self.mark)

    def is_valid(self):
        return self.editor() and not self.mark.get_deleted()

    def similar_to(self, spot):
        return spot and self.mark.get_buffer() is spot.mark.get_buffer() \
            and abs(self.iter.get_line() - spot.iter.get_line()) < 7

    def remove(self):
        editor = self.editor()
        if editor:
            editor.buffer.delete_mark(self.mark)
            del self.mark

    def goto(self, back_to=None):
        editor = self.editor()
        editor.buffer.place_cursor(self.iter)
        editor.clear_cursor()

        if editor is back_to:
            editor.scroll_to_cursor()
        else:
            editor.view.scroll_mark_onscreen(editor.buffer.get_insert())
            editor.focus()


########NEW FILE########
__FILENAME__ = titler
import os
import os.path

title_handlers = {}
fsm_cache = {}
title_contexts = {}
wtitle_contexts = {}

def init(injector):
    from .prefs import add_option

    add_option('TAB_TITLE_FORMAT', '%modified{%pypkg|%name2}{%writeable|[ro]}',
        'Default format string for tab titles')

    add_option('WINDOW_TITLE_FORMAT',
        '%modified{%project|NOP}:{%path|%fullpath}{%writeable|[ro]}',
        'Default format string for window title')

    add_title_handler('name', name_handler)
    add_title_handler('name2', name2_handler)
    add_title_handler('project', project_handler)
    add_title_handler('path', path_handler)
    add_title_handler('fullpath', fullpath_handler)
    add_title_handler('writeable', writable_handler)
    add_title_handler('modified', modified_handler)

    injector.on_ready('editor-with-new-buffer-created', editor_created)

def editor_created(editor):
    editor.connect('get-title', on_editor_get_title)
    editor.connect('get-window-title', on_editor_get_window_title)

def get_format_from_context(editor, context):
    return editor.window.manager.get_context_manager(
        editor.project_root).get_first(context, editor.uri)

def on_editor_get_title(editor):
    format = get_format_from_context(editor, 'title')
    if not format:
        format = editor.conf['TAB_TITLE_FORMAT']

    return get_title(editor, format)

def on_editor_get_window_title(editor):
    format = get_format_from_context(editor, 'wtitle')
    if not format:
        format = editor.conf['WINDOW_TITLE_FORMAT']

    return get_title(editor, format)

def add_title_handler(name, callback):
    title_handlers[name] = callback

def name_handler(editor):
    """Return file basename"""
    return os.path.basename(editor.uri)

def name2_handler(editor):
    """Return file basename with descending directory name"""
    dirname, basename = os.path.split(editor.uri)
    return os.path.basename(dirname) + '/' + basename

def project_handler(editor):
    """Return project name (basename of project path). None if project is not defined"""
    root = editor.project_root
    if root:
        return os.path.basename(root)

def writable_handler(editor):
    """Return empty string if file is writeable else None. Useful for ``ro`` marks"""
    path = editor.uri if os.path.exists(editor.uri) else os.path.dirname(editor.uri)
    if os.access(path, os.W_OK):
        return ''

def modified_handler(editor):
    """Return asteriks if editor's buffer is changed, empty string otherwise"""
    return '*' if editor.buffer.get_modified() else ''

def empty_handler(editor):
    """Always return None"""
    return None

def path_handler(editor):
    """Return file path within project. None if project is not defined"""
    root = editor.project_root
    if root:
        return os.path.relpath(editor.uri, root)

def fullpath_handler(editor):
    """Return absolute file path"""
    return editor.uri

def get_title(editor, format):
    try:
        fsm = fsm_cache[format]
    except KeyError:
        fsm = fsm_cache[format] = create_fsm(format)

    return fsm(editor)

def create_alternative_handler(handlers):
    def handler(editor):
        for h, fstr in handlers:
            if h is None:
                return fstr

            value = h(editor)
            if value is not None:
                return fstr % value

        return ''

    return handler

def create_fsm(format):
    import re

    alt_matcher = re.compile('\{(.+?)\}')
    handler_matcher = re.compile('%([_a-zA-Z0-9]+)')
    handlers = {}
    hid = [0]

    def replace_alt(match):
        hlist = []
        for m in match.group(1).split('|'):
            hm = handler_matcher.search(m)
            if hm:
                hlist.append((title_handlers.get(hm.group(1), empty_handler),
                    handler_matcher.sub('%s', m)))
            else:
                hlist.append((None, m))

        hid[0] += 1
        hid_name = 'alt_%d' % hid[0]
        handlers[hid_name] = create_alternative_handler(hlist)
        return '%%(%s)s' % hid_name

    def replace_handlers(match):
        hname = match.group(1)
        handlers[hname] = title_handlers.get(hname, empty_handler)
        return '%%(%s)s' % hname

    result = alt_matcher.sub(replace_alt, format)
    result = handler_matcher.sub(replace_handlers, result)

    def root(editor):
        rdict = {}
        for k, h in handlers.items():
            value = h(editor)
            if value is None:
                value = ''
            rdict[k] = value

        return result % rdict

    return root
########NEW FILE########
__FILENAME__ = window
import time
import weakref

import gtk

from uxie.floating import Manager as FloatingManager, TextFeedback, add_float, remove_float,\
    Feedback
from uxie.escape import Manager as EscapeManager
from uxie.actions import wait_mod_unpress_for_last_shortcut
from uxie.utils import idle, refresh_gui, lazy_func

tab_bar_pos_mapping = {
    'top': gtk.POS_TOP,
    'bottom': gtk.POS_BOTTOM,
    'left': gtk.POS_LEFT,
    'right': gtk.POS_RIGHT
}

def init(injector):
    injector.add_context('editor', 'window', Window.get_editor_context)
    injector.add_context('editor-active', 'editor', lambda e: e if e.view.is_focus() else None)
    injector.add_context('editor-with-selection', 'editor-active',
        lambda e: e if e.buffer.get_has_selection() else None)
    injector.add_context('textview-active', 'window',
        lambda w: w.get_focus() if isinstance(w.get_focus(), gtk.TextView) else None)
    injector.add_context('panel-visible', 'window', Window.get_panel_visible_context)


    with injector.on('window', 'editor') as ctx:
        ctx.bind('save', 'File/_Save#20', Window.save_editor).to('<ctrl>s')

        ctx.bind('close-editor', 'Tab/_Close#100', Window.close_editor).to('<ctrl>w')
        ctx.bind('next-editor', 'Tab/_Next#50', Window.switch_to, 1).to('<ctrl>Page_Down', 1)
        ctx.bind('prev-editor', 'Tab/_Prev', Window.switch_to, -1).to('<ctrl>Page_Up', 1)
        ctx.bind('move-tab-left', 'Tab/Move to _left',
            Window.move_tab, False).to('<shift><ctrl>Page_Up', 1)
        ctx.bind('move-tab-right', 'Tab/Move to _right',
            Window.move_tab, True).to('<shift><ctrl>Page_Down', 1)

        ctx.bind('detach-editor', 'Tab/_Detach', Window.retach_editor)
        ctx.bind('duplicate-editor', 'Tab/D_uplicate', Window.duplicate_editor)

    injector.bind('editor', 'new-file', 'File/_New',
        lazy_func('snaked.core.gui.new_file.show_create_file')).to('<ctrl>n')

    with injector.on('window') as ctx:
        ctx.bind('escape', None, Window.process_escape)
        ctx.bind('close-window', 'Window/_Close#100', Window.close)

        #ctx.bind_accel('save-all', '_File/Save _all', '<ctrl><shift>s', Window.save_all)
        ctx.bind_check('fullscreen', 'Window/_Fullscreen#50', Window.toggle_fullscreen).to('F11')
        ctx.bind_check('show-tabs', 'Window/Show _Tabs', Window.show_tabs).to('<Alt>F11')

    with injector.on('panel-visible') as ctx:
        ctx.bind('increase-panel-height', 'Window/_Increase panel height',
            Window.change_panel_size, 10).to('<ctrl><alt>Up')
        ctx.bind('decrease-panel-height', 'Window/_Decrease panel height',
            Window.change_panel_size, -10).to('<ctrl><alt>Down')

class PanelHandler(object):
    def __init__(self, widget):
        self.widget = widget
        self.activate_handler = None
        self.popup_handler = None

    def on_activate(self, cb):
        self.activate_handler = cb
        return self

    def on_popup(self, cb):
        self.popup_handler = cb
        return self

    def activate(self, *args):
        if self.activate_handler:
            self.activate_handler(*((self.widget,) + args))

    def popup(self, *args):
        if self.popup_handler:
            self.popup_handler(*((self.widget,) + args))


class Window(gtk.Window):
    def __init__(self, manager, window_conf):
        gtk.Window.__init__(self, gtk.WINDOW_TOPLEVEL)

        self.editors = []
        self.last_switch_time = None
        self.panels = weakref.WeakKeyDictionary()

        self.set_name('SnakedWindow')
        self.set_role('Editor')
        self.connect('delete-event', self.on_delete_event)

        # set border width handling, see self.on_state_event for more details
        self.connect('window-state-event', self.on_state_event)

        self.set_default_size(800, 500)

        manager.activator.attach(self)

        self.main_pane = gtk.VPaned()
        self.main_pane_position_set = False
        self.add(self.main_pane)

        conf = manager.conf
        self.window_conf = window_conf
        self.manager = manager

        self.floating_manager = FloatingManager()
        self.escape_manager = EscapeManager()

        self.note = gtk.Notebook()
        self.note.set_show_tabs(
            conf['SHOW_TABS'] if conf['SHOW_TABS'] is not None else window_conf.get('show-tabs', True))
        self.note.set_scrollable(True)
        self.note.set_property('tab-hborder', 10)
        self.note.set_property('homogeneous', False)
        self.note.set_show_border(False)
        self.note.connect_after('switch-page', self.on_switch_page)
        self.note.connect('page_removed', self.on_page_removed)
        self.note.connect('page_reordered', self.on_page_reordered)
        self.note.props.tab_pos = tab_bar_pos_mapping.get(conf['TAB_BAR_PLACEMENT'], gtk.POS_TOP)
        self.main_pane.add1(self.note)

        if conf['RESTORE_POSITION'] and 'last-position' in window_conf:
            try:
                pos, size = window_conf['last-position']
            except ValueError:
                if window_conf['last-position'] == 'fullscreen':
                    self.fullscreen()
                elif window_conf['last-position'] == 'maximized':
                    self.maximize()
            else:
                self.move(*pos)
                self.resize(*size)

        self.show_all()

    def get_editor_context(self):
        widget = self.note.get_nth_page(self.note.get_current_page())
        for e in self.editors:
            if e.widget is widget:
                return e

        return None

    active_editor = property(get_editor_context)

    def attach_editor(self, editor):
        self.editors.append(editor)
        label = gtk.Label('Unknown')
        self.note.append_page(editor.widget, label)
        self.note.set_tab_reorderable(editor.widget, True)
        self.focus_editor(editor)
        editor.view.grab_focus()

    def focus_editor(self, editor):
        idx = self.note.page_num(editor.widget)
        self.note.set_current_page(idx)

    def update_top_level_title(self):
        idx = self.note.get_current_page()
        if idx < 0:
            return

        editor = self.get_editor_context()
        if editor:
            title = editor.get_window_title.emit()

        if not title:
            title = self.note.get_tab_label_text(self.note.get_nth_page(idx))

        if title is not None:
            self.set_title(title)

    def set_editor_title(self, editor, title):
        self.note.set_tab_label_text(editor.widget, title)
        if self.note.get_current_page() == self.note.page_num(editor.widget):
            self.update_top_level_title()

    def on_delete_event(self, *args):
        self.close()

    def on_state_event(self, widget, event):
        """Sets the window border depending on state

        The window border eases the resizing of the window using the mouse.
        In maximized and fullscreen state the this use case is irrelevant.
        Removing the border in this cases makes it easier to hit the scrollbar.

        Unfortunately this currently only works with tabs hidden.
        """
        state = event.new_window_state
        if state & gtk.gdk.WINDOW_STATE_MAXIMIZED or state & gtk.gdk.WINDOW_STATE_FULLSCREEN:
            self.set_border_width(0)
        else:
            self.set_border_width(self.manager.conf['WINDOW_BORDER_WIDTH'])

    def detach_editor(self, editor):
        idx = self.note.page_num(editor.widget)
        self.note.remove_page(idx)
        self.editors.remove(editor)

    def close_editor(self, editor):
        self.manager.editor_closed(editor)
        self.detach_editor(editor)

        if not self.editors:
            self.close()

    def close(self, notify_manager=True):
        current_editor = self.get_editor_context()
        if current_editor:
            self.window_conf['active-uri'] = current_editor.uri

        files = self.window_conf.setdefault('files', [])
        files[:] = []
        for e in self.editors[:]:
            files.append(dict(uri=e.uri))
            self.manager.editor_closed(e)
            self.editors.remove(e)

        state = self.window.get_state()
        if state & gtk.gdk.WINDOW_STATE_FULLSCREEN:
            self.window_conf['last-position'] = 'fullscreen'
        elif state & gtk.gdk.WINDOW_STATE_MAXIMIZED:
            self.window_conf['last-position'] = 'maximized'
        else:
            self.window_conf['last-position'] = self.get_position(), self.get_size()

        if self.main_pane_position_set:
            _, _, _, wh, _ = self.window.get_geometry()
            self.window_conf['panel-height'] = wh - self.main_pane.get_position()

        if notify_manager:
            self.manager.window_closed(self)

    def save(self, editor):
        editor.save()

    def on_switch_page(self, *args):
        self.update_top_level_title()

    def on_page_removed(self, note, child, idx):
        switch_to = None
        for e in self.editors:
            if e.widget is child:
                spot = self.manager.spot_manager.get_last(None, e)
                if spot:
                    switch_to = note.page_num(spot.editor().widget)

                break

        if switch_to is None and idx > 0:
            switch_to = idx - 1

        if switch_to is not None:
            note.set_current_page(switch_to)
            refresh_gui()

        e = self.get_editor_context()
        if e:
            idle(e.view.grab_focus)

    def switch_to(self, editor, dir):
        if self.last_switch_time is None or time.time() - self.last_switch_time > 5:
            self.manager.spot_manager.add(editor)

        self.last_switch_time = time.time()

        idx = ( self.note.get_current_page() + dir ) % self.note.get_n_pages()
        self.note.set_current_page(idx)

        if not self.note.get_show_tabs() and \
                wait_mod_unpress_for_last_shortcut(self, self.hide_tab_menu):
            menu = self.get_tab_menu()

            for c in menu.get_children():
                c.deselect()

            menu.get_children()[idx].select()

    def get_tab_menu(self):
        try:
            return self.tab_menu
        except AttributeError:
            pass

        f = gtk.EventBox()

        vb = gtk.VBox()
        f.add(vb)

        for e in self.editors:
            it = gtk.MenuItem(e.get_title.emit(), False)
            vb.pack_start(it)

        add_float(self, f)
        self.tab_menu = vb
        return vb

    def hide_tab_menu(self):
        if getattr(self, 'tab_menu', None):
            remove_float(self.tab_menu.get_parent())
            del self.tab_menu

    def toggle_fullscreen(self, is_set):
        state = self.window.get_state() & gtk.gdk.WINDOW_STATE_FULLSCREEN
        if is_set:
            if state:
                self.unfullscreen()
            else:
                self.fullscreen()
        else:
            return state

    def show_tabs(self, is_set):
        if is_set:
            self.note.set_show_tabs(not self.note.get_show_tabs())
            self.window_conf['show-tabs'] = self.note.get_show_tabs()
        else:
            return self.note.get_show_tabs()

    def append_panel(self, widget):
        v = self.panels[widget] = PanelHandler(widget)
        return v

    def popup_panel(self, widget, activate=False, *args):
        if widget in self.panels:
            for w in self.panels:
                if w is not widget and w is self.main_pane.get_child2():
                    self.main_pane.remove(w)

            if not self.main_pane_position_set:
                self.main_pane_position_set = True
                _, _, _, wh, _ = self.window.get_geometry()
                self.main_pane.set_position(wh - self.window_conf.get('panel-height', 200))

            if self.main_pane.get_child2() is not widget:
                self.main_pane.add2(widget)

            if not widget.get_visible():
                widget.show()
                self.panels[widget].popup(*args)
            else:
                activate = True

            if activate:
                self.panels[widget].activate(*args)

    def on_page_reordered(self, note, child, num):
        for i, e in enumerate(self.editors):
            if e.widget is child:
                self.editors[i], self.editors[num] = self.editors[num], self.editors[i]
                break

    def move_tab(self, editor, is_right):
        pos = self.note.page_num(editor.widget)
        if is_right:
            pos += 1
        else:
            pos -= 1

        if pos < 0 or pos >= self.note.get_n_pages():
            editor.message('This is dead end')
            return

        self.note.reorder_child(editor.widget, pos)

    def activate_main_window(self):
        self.present()
        #self.present_with_time(gtk.get_current_event_time())

    def retach_editor(self, editor):
        self.detach_editor(editor)
        self.manager.get_free_window().attach_editor(editor)

    def duplicate_editor(self, editor):
        self.manager.get_free_window().attach_editor(self.manager.open(editor.uri))

    def save_editor(self, editor):
        editor.save()

    def open_or_activate(self, uri, line=None):
        return self.manager.open_or_activate(uri, self, line)

    def message(self, message, category=None, timeout=None, markup=False, parent=None):
        fb = TextFeedback(message, category, markup)
        if timeout is None:
            timeout = fb.timeout
        self.push_escape(fb)
        return self.floating_manager.add(parent or self, fb, timeout=timeout)

    def feedback(self, widget, priority=None, parent=None):
        fb = Feedback(widget)
        return self.floating_manager.add(parent or self, fb, priority)

    def emessage(self, message, category=None, timeout=None, markup=False):
        fb = TextFeedback(message, category, markup)
        if timeout is None:
            timeout = fb.timeout

        e = self.get_editor_context()
        parent = e.view if e else self
        self.push_escape(fb)
        return self.floating_manager.add(parent, fb, timeout=timeout)

    def push_escape(self, obj, priority=None):
        return self.escape_manager.push(obj, priority)

    def process_escape(self):
        if not self.escape_manager.process():
            widget = self.main_pane.get_child2()
            if widget:
                if widget.get_visible():
                    if widget.get_focus_child():
                        e = self.active_editor
                        if e:
                            e.view.grab_focus()
                    else:
                        widget.hide()

                    return True

        return False

    def get_panel_visible_context(self):
        w = self.main_pane.get_child2()
        if w and w.get_visible():
            return self
        else:
            return None

    def change_panel_size(self, delta):
        self.main_pane.set_position(self.main_pane.get_position() - delta)

########NEW FILE########
__FILENAME__ = words
from threading import Thread
import re

words = {}
current_jobs = {}
matcher = re.compile(r'[\w-]{3,}')

def process(filename, data):
    result = {}

    for w in matcher.findall(data):
        try:
            result[w] += 1
        except KeyError:
            result[w] = 1

    for w, c in result.iteritems():
        words.setdefault(w, {})[filename] = c

    for w in [w for w, files in words.iteritems() if w not in result and filename in files]:
        del words[w][filename]

def add_job(filename, data):
    if filename in current_jobs:
        current_jobs[filename].join()

    thread = Thread(target=process, args=(filename, data))
    current_jobs[filename] = thread
    thread.start()

########NEW FILE########
__FILENAME__ = bracket_matcher
import pango
import glib

brackets = {
    '(': (')', 1),
    ')': ('(', -1),
    '[': (']', 1),
    ']': ('[', -1),
    '{': ('}', 1),
    '}': ('{', -1),
}

matched_tags = [None]
cursor_movement_occurs = [False]
highlight_timer_id = [None]

def match_brackets_timeout(buf):
    if not cursor_movement_occurs[0]:
        highlight_matching_brackets(buf)
        highlight_timer_id[0] = None
        return False

    cursor_movement_occurs[0] = False
    return True

def add_highlight_task(buf):
    if not highlight_timer_id[0]:
        cursor_movement_occurs[0] = True
        highlight_timer_id[0] = glib.timeout_add(100, match_brackets_timeout, buf)
    else:
        cursor_movement_occurs[0] = True

def attach(editor):
    editor.buffer.set_highlight_matching_brackets(False)
    editor.buffer.connect_after('notify::cursor-position', on_buffer_notify)

def reset_tags(buf):
    if matched_tags[0] and buf.get_tag_table().lookup(matched_tags[0]):
        start, end = buf.get_bounds()
        buf.remove_tag_by_name(matched_tags[0], start, end)
        matched_tags[0] = None

def highlight_matching_brackets(buf):
    """:type buf: gtk.TextBuffer()"""
    iter = buf.get_iter_at_mark(buf.get_insert())
    char = iter.get_char()
    piter = iter.copy()
    if piter.backward_cursor_position():
        pchar = piter.get_char()
    else:
        pchar = ''

    lbr = rbr = None
    if char in brackets:
        rbr, rd = brackets[char]

    if pchar in brackets:
        lbr, ld = brackets[pchar]

    reset_tags(buf)

    if not lbr and not rbr:
        return

    if lbr == char:
        return

    if lbr:
        mark_brackets(buf, piter, find_bracket(piter, lbr, pchar, ld))

    if rbr:
        mark_brackets(buf, iter, find_bracket(iter, rbr, char, rd))

def on_buffer_notify(buf, prop):
    add_highlight_task(buf)

def find_bracket(from_iter, br, obr, dir):
    has_context = from_iter.get_buffer().iter_has_context_class
    iter = from_iter.copy()
    depth = 1
    while True:
        if not iter.forward_cursor_positions(dir):
            break

        if has_context(iter, 'string'):
            continue

        c = iter.get_char()
        if c == br:
            depth -= 1
        elif c == obr:
            depth += 1

        if depth == 0:
            return iter

    return None

def mark_brackets(buf, start, end):
    type = 'bracket-match' if end else 'bracket-mismatch'
    matched_tags[0] = type
    tag = get_tag(buf, type)

    mark_bracket(buf, start, tag)

    if end:
        mark_bracket(buf, end, tag)

def mark_bracket(buf, iter, tag):
    end = iter.copy()
    end.forward_char()

    buf.apply_tag(tag, iter, end)

def get_tag(buf, type, fallback='bracket-match'):
    table = buf.get_tag_table()
    tag = table.lookup(type)
    if not tag:
        style = buf.get_style_scheme().get_style(type)
        if not style:
            style = buf.get_style_scheme().get_style(fallback)

        tag = buf.create_tag(type)

        if style.props.background_set:
            tag.props.background = style.props.background

        if style.props.foreground_set:
            tag.props.foreground = style.props.foreground

        if style.props.bold_set:
            tag.props.weight = pango.WEIGHT_BOLD if style.props.bold else pango.WEIGHT_NORMAL

    return tag

########NEW FILE########
__FILENAME__ = smart_select
from util import (iter_lines, line_is_empty, get_next_not_empty_line, get_whitespace,
    line_text, next_line, prev_line, cursor_on_start_or_end_whitespace, get_line_bounds)

def extend_with_gap(from_iter, ws, delta):
    n = None
    for p, n in iter_lines(from_iter, delta):
        if line_is_empty(n):
            ne = get_next_not_empty_line(n, delta)
            if ne and len(get_whitespace(ne)) >= ws:
                n.set_line(ne.get_line())
            else:
                return p

        n_ws = len(get_whitespace(n))
        if n_ws < ws:
            return p

    return n if n else from_iter.copy()

def extend_without_gap(from_iter, ws, delta):
    n = None
    for p, n in iter_lines(from_iter, delta):
        if line_is_empty(n):
            ne = get_next_not_empty_line(n, delta)
            if ne and delta > 0 and len(get_whitespace(ne)) > ws:
                n.set_line(ne.get_line())
            else:
                return p

        n_ws = len(get_whitespace(n))
        if n_ws < ws:
            return p

    return n if n else from_iter.copy()

def extend_block_without_gap(from_iter, ws, delta):
    n = None
    for p, n in iter_lines(from_iter, delta):
        if line_is_empty(n):
            ne = get_next_not_empty_line(n, delta)
            if ne:
                n.set_line(ne.get_line())
            else:
                return p

        n_ws = len(get_whitespace(n))

        if n_ws < ws or ( n_ws == ws and len(line_text(n).strip()) > 4 ):
            return p

    return n if n else from_iter.copy()

def block_smart_extend(has_selection, start, end):
    end = end.copy()
    if not end.is_end():
        end.backward_lines(1)

    start_ws = len(get_whitespace(start))
    prev_empty = start.is_start() or line_is_empty(prev_line(start))
    prev_ws = len(get_whitespace(prev_line(start)))

    end_ws = len(get_whitespace(end))
    next_empty = end.is_end() or line_is_empty(next_line(end))
    next_ws = len(get_whitespace(next_line(end)))

    newstart, newend = start.copy(), end

    if not has_selection and start.get_line() == end.get_line() and \
            ( next_empty or next_ws < end_ws ) and (prev_empty or prev_ws < start_ws):
        pass
    elif not prev_empty and not next_empty and prev_ws == start_ws == next_ws == end_ws:
        newstart = extend_without_gap(start, start_ws, -1)
        newend = extend_without_gap(end, end_ws, 1)
    elif prev_empty and not next_empty and next_ws == end_ws:
        newend = extend_without_gap(end, end_ws, 1)
    elif not prev_empty and next_empty and prev_ws == start_ws:
        newstart = extend_without_gap(start, start_ws, -1)
    elif not next_empty and next_ws > start_ws:
        newend = extend_block_without_gap(end, start_ws, 1)
    elif ( not next_empty and next_ws == start_ws ) or ( not prev_empty and prev_ws >= start_ws ):
        if not prev_empty:
            newstart = extend_without_gap(start, start_ws, -1)
        if not next_empty:
            newend = extend_without_gap(end, start_ws, 1)
    elif next_empty and prev_empty:
        newstart = extend_with_gap(start, start_ws, -1)
        newend = extend_with_gap(end, start_ws, 1)
    elif next_empty and not prev_empty and prev_ws < start_ws:
        newend = extend_with_gap(end, start_ws, 1)

    if has_selection and start.equal(newstart) and end.equal(newend):
        if not prev_empty:
            newstart.backward_lines(1)
        else:
            ne = get_next_not_empty_line(start, -1)
            if ne:
                newstart = ne

        if not next_empty and len(line_text(next_line(end)).strip()) < 5:
            newend.forward_lines(1)

    newend.forward_lines(1)
    return newstart, newend

def get_smart_select(editor):
    if editor.buffer.get_has_selection():
        start, end = editor.buffer.get_selection_bounds()
        if start.starts_line() and ( end.starts_line() or end.is_end() ):
            return block_smart_extend(True, start, end)
        else:
            return line_smart_extend(True, start, end)
    else:
        cursor = editor.cursor

        if cursor_on_start_or_end_whitespace(cursor):
            return block_smart_extend(False, *get_line_bounds(cursor))
        else:
            return line_smart_extend(False, cursor, cursor.copy())

def get_words_bounds(cursor, include_hyphen=False):
    return backward_word_start(cursor, include_hyphen), forward_word_end(cursor, include_hyphen)

def char_is_word(char, include_hyphen=False):
    return char and char.isalnum() or char == u'_' or (include_hyphen and char == u'-')

def backward_word_start(iter, include_hyphen=False):
    iter = iter.copy()
    iter.backward_char()
    while char_is_word(iter.get_char(), include_hyphen):
        if not iter.backward_char():
            return iter

    iter.forward_char()
    return iter

def forward_word_end(iter, include_hyphen=False):
    iter = iter.copy()
    while char_is_word(iter.get_char()):
        iter.forward_char()

    return iter

def line_smart_extend(has_selection, start, end):
    from .util import cursor_in_string, source_view_pairs_parser, get_text

    def ahtung():
        start.set_line(start.get_line())
        if not end.starts_line():
            end.set_line(end.get_line() + 1)

        return start, end

    left = start.copy()
    left.backward_chars(3)
    lchars = left.get_text(start).decode('utf-8')

    right = end.copy()
    right.forward_chars(3)
    rchars = end.get_text(right).decode('utf-8')

    if not rchars:
        rchars = [None]

    if not lchars:
        lchars = [None]

    in_quotes = cursor_in_string(start)
    start_br, end_br = source_view_pairs_parser(start)
    br = get_text(start_br, 3) if start_br else None
    if br:
        if br not in ('"""', "'''"):
            br = br[0]

        start_br_inner = start_br.copy()
        start_br_inner.forward_chars(len(br))
        end_br_inner = end_br.copy()
        end_br_inner.backward_chars(len(br))

    if not in_quotes and rchars[0] in (u'(', u'[', "'", '"'):
        end.forward_cursor_positions(1)
        _, end = source_view_pairs_parser(end)
        if not end: return ahtung()
    elif char_is_word(lchars[-1]) or char_is_word(rchars[0]):
        start = backward_word_start(start, in_quotes)
        end = forward_word_end(end, in_quotes)
    elif lchars[-1] == u'.' or rchars[0] == u'.':
        if lchars[-1] == u'.':
            start.backward_char()
            start = backward_word_start(start)
        if rchars[0] == u'.':
            end.forward_char()
            end = forward_word_end(end)
    else:
        if not br: return ahtung()

        if start_br_inner.equal(start) and end_br_inner.equal(end):
            start = start_br
            end = end_br
        else:
            start = start_br_inner
            end = end_br_inner

    return start, end
########NEW FILE########
__FILENAME__ = util
import re

def get_line_bounds(cursor):
    end = cursor.copy()
    start = end.copy()
    start.set_line(end.get_line())

    very_end = end.copy()
    very_end.forward_to_end()

    if end.get_line() == very_end.get_line():
        start.backward_char()
        return start, very_end

    if not end.ends_line():
        end.forward_to_line_end()

    end.forward_char()

    return start, end

def cursor_on_start_or_end_whitespace(cursor):
    if cursor.starts_line() or cursor.ends_line():
        return True

    start, end = get_line_bounds(cursor)
    starttext = start.get_text(cursor)
    endtext = cursor.get_text(end)

    if starttext.strip() == u'' or endtext.strip() == u'':
        return True

    return False

match_ws = re.compile(u'(?u)^[ \t]*')
def get_whitespace(start):
    if start.is_end():
        return u''

    match = match_ws.search(line_text(start))
    if match:
        return match.group(0)
    else:
        return u''

def line_text(iter):
    if not iter.starts_line():
        iter = iter.copy()
        iter.set_line(iter.get_line())

    end = iter.copy()
    if not end.ends_line():
        end.forward_to_line_end()

    return iter.get_text(end)

def line_is_empty(iter):
    return iter.is_end() or line_text(iter).strip() == u''

def iter_lines(from_iter, delta):
    line_count = from_iter.get_buffer().get_line_count()
    iter = from_iter.copy()
    while True:
        newline = iter.get_line() + delta
        if newline < 0 or newline > line_count - 1:
            return

        olditer = iter.copy()
        iter.set_line(iter.get_line() + delta)

        yield olditer, iter

def get_next_not_empty_line(from_iter, delta):
    for p, n in iter_lines(from_iter, delta):
        if not line_is_empty(n):
            return n

    return None

def next_line(iter):
    result = iter.copy()
    result.set_line(result.get_line() + 1)
    return result

def prev_line(iter):
    result = iter.copy()
    result.set_line(result.get_line() - 1)
    return result

def cursor_in_string(cursor):
    buf = cursor.get_buffer()
    if buf.iter_has_context_class(cursor, 'string'):
        cursor = cursor.copy()
        if cursor.backward_char():
            if buf.iter_has_context_class(cursor, 'string'):
                return True

    return False

def find_closest_bracket(cursor, brackets, forward=True):
    buf = cursor.get_buffer()

    iters = []
    for br in brackets:
        it = cursor
        while True:
            if forward:
                result = it.forward_search(br, 0)
            else:
                result = it.backward_search(br, 0)

            if not result:
                break

            if buf.iter_has_context_class(result[0], 'string'):
                it = result[forward]
            else:
                break

        if result:
            iters.append((br, result[forward]))

    if not iters:
        return None, None

    return (max, min)[forward](iters, key=lambda r:r[1].get_offset())

brackets = {
    '(': ')',
    '{': '}',
    '[': ']',
    ')': '(',
    '}': '{',
    ']': '[',
}

def find_bracket(from_iter, br, obr, dir):
    buf = from_iter.get_buffer()
    iter = from_iter.copy()
    if dir < 0:
        iter.forward_cursor_positions(dir)
    depth = 1
    while True:
        if not iter.forward_cursor_positions(dir):
            break

        if buf.iter_has_context_class(iter, 'string'):
            continue

        c = iter.get_char()
        if c == br:
            depth -= 1
        elif c == obr:
            depth += 1

        if depth == 0:
            if dir > 0:
                iter.forward_cursor_positions(dir)
            return iter

    return None

def get_text(start, slice):
    start = start.copy()
    end = start.copy()
    end.forward_chars(slice)
    start.order(end)
    return start.get_text(end)

def source_view_pairs_parser(cursor):
    buf = cursor.get_buffer()

    if cursor_in_string(cursor):
        start = cursor.copy()
        buf.iter_backward_to_context_class_toggle(start, 'string')
        end = cursor.copy()
        buf.iter_forward_to_context_class_toggle(end, 'string')

        return start, end

    br, start = find_closest_bracket(cursor, ('(', '[', '{'), False)
    if not start: return None, None
    obr = brackets[br]

    _, end = find_closest_bracket(start, (obr,), True)
    if not end: return None, None

    if cursor.in_range(start, end):
        end = find_bracket(start, obr, br, 1)
    else:
        br, end = find_closest_bracket(cursor, (')', ']', '}'), True)
        if not end: return None, None
        obr = brackets[br]

        _, start = find_closest_bracket(end, (obr,), False)
        if not start: return None, None

        if cursor.in_range(start, end):
            start = find_bracket(end, obr, br, -1)
        else:
            return None, None

    if start and end:
        return start, end
    else:
        return None, None

########NEW FILE########
__FILENAME__ = parser
import re

allowed_inputs = ('from-buffer-or-selection', 'from-buffer', 'from-selection')
allowed_outputs = ('replace-buffer-or-selection', 'replace-buffer', 'replace-selection',
    'to-console', 'to-iconsole', 'to-feedback', 'to-clipboard', 'insert', 'insert-at-end')

remove_tags = re.compile(r'<[^<]*?/?>')




class ParseException(Exception): pass


class Context(object):
    def __init__(self):
        self.tools = []
        self.current_tool = None
        self.lineno = None
        self.script_lines = []

    def Error(self, msg):
        return ParseException('%d: %s' % (self.lineno, msg))

toolname_matcher = re.compile('tool\s+"(.*?)"')
for_matcher = re.compile('for\s+"(.*?)"')
input_matcher = re.compile('|'.join(allowed_inputs))
output_matcher = re.compile('|'.join(allowed_outputs))

def search_tool(ctx, line):
    if not line.startswith('tool'):
        return search_tool, True

    match = toolname_matcher.match(line)
    if not match:
        raise ctx.Error("Can't find tool name")

    line = toolname_matcher.sub('', line)

    tool = Tool()
    tool.name = match.group(1)

    ctx.tools.append(tool)
    ctx.current_tool = tool

    match = for_matcher.search(line)
    if match:
        tool.context = [s.strip() for s in match.group(1).split(',')]
        line = for_matcher.sub('', line)

    match = input_matcher.search(line)
    if match:
        tool.input = match.group(0)
        line = input_matcher.sub('', line)

    match = output_matcher.search(line)
    if match:
        tool.output = match.group(0)
        line = output_matcher.sub('', line)

    if line.strip():
        raise ctx.Error('Unexpected content: %s' % line.strip())

    ctx.script_lines[:] = []
    return consume_tool_script, True

def consume_tool_script(ctx, line):
    if line and not line[0].isspace():
        ctx.current_tool.script = '\n'.join(ctx.script_lines)
        return search_tool, False

    ctx.script_lines.append(line)
    return consume_tool_script, True

def parse(text):
    ctx = Context()
    func = search_tool
    for i, l in enumerate(text.splitlines()):
        ctx.lineno = i + 1
        while True:
            func, move_next = func(ctx, l)
            if move_next: break

    func(ctx, 'end')

    return ctx.tools
########NEW FILE########
__FILENAME__ = plugin
import tempfile
import os, pty
import shutil
import gtk

from os.path import join, exists, dirname
from subprocess import Popen, PIPE
from inspect import cleandoc

from uxie.utils import make_missing_dirs, join_to_settings_dir

from snaked.core.console import consume_pty
from snaked.plugins.python.utils import get_executable

tools = None
tools_module = {}

def get_stdin(editor, id):
    if id == 'none' or id is None:
        return None
    elif id == 'from-buffer':
        return editor.text
    elif id == 'from-selection':
        return editor.buffer.get_text(*editor.buffer.get_selection_bounds())
    elif id == 'from-buffer-or-selection':
        if editor.buffer.get_has_selection():
            return editor.buffer.get_text(*editor.buffer.get_selection_bounds())
        else:
            return editor.text
    else:
        print 'Unknown input action', id
        editor.message('Unknown input action ' + id, 'warn')

def replace(editor, bounds, text):
    editor.view.window.freeze_updates()
    editor.buffer.begin_user_action()
    editor.buffer.delete(*bounds)
    editor.buffer.insert_at_cursor(text)
    editor.buffer.end_user_action()
    editor.view.window.thaw_updates()

def insert(editor, iter, text):
    editor.buffer.begin_user_action()
    editor.buffer.insert(iter, text)
    editor.buffer.end_user_action()

def process_stdout(editor, stdout, stderr, id):
    if id != 'to-feedback' and stderr:
        editor.message(stderr, 'error', 0)

    if id == 'to-feedback':
        if stdout or stderr:
            msg = '\n'.join(r for r in (stdout, stderr) if r)
        else:
            msg = 'Empty command output'
        editor.message(msg, 'done')
    elif id == 'replace-selection':
        replace(editor, editor.buffer.get_selection_bounds(), stdout)
    elif id == 'replace-buffer':
        replace(editor, editor.buffer.get_bounds(), stdout)
    elif id == 'replace-buffer-or-selection':
        if editor.buffer.get_has_selection():
            replace(editor, editor.buffer.get_selection_bounds(), stdout)
        else:
            replace(editor, editor.buffer.get_bounds(), stdout)
    elif id == 'insert':
        insert(editor, editor.cursor, stdout)
    elif id == 'insert-at-end':
        last_line = editor.buffer.get_line_count()
        insert(editor, editor.buffer.get_bounds()[1], stdout)
        editor.goto_line(last_line)
    elif id == 'to-clipboard':
        clipboard = editor.view.get_clipboard(gtk.gdk.SELECTION_CLIPBOARD)
        clipboard.set_text(stdout)
        editor.message('Command output was placed on clipboard', 'done')
    elif id == 'to-console':
        if stdout:
            from snaked.core.console import get_console_widget
            console = get_console_widget(editor)
            if not console.props.visible:
                editor.window.popup_panel(console, editor)

            buf = console.view.get_buffer()
            buf.set_text(stdout)
            buf.place_cursor(buf.get_bounds()[1])
            console.view.scroll_mark_onscreen(buf.get_insert())
    else:
        editor.message('Unknown stdout action ' + id, 'warn')

def run(editor, tool):
    if tool._callable:
        run_as_python_func(editor, tool)
    else:
        run_as_command(editor, tool)

def run_as_python_func(editor, tool):
    stdin = get_stdin(editor, tool._input)
    if stdin:
        stdin = stdin.decode('utf-8')

    stderr = stdout = None

    try:
        stdout = tool._callable(editor, stdin)
    except:
        import traceback
        stderr = traceback.format_exc()

    stdout = stdout or ''
    stderr = stderr or ''
    process_stdout(editor, stdout, stderr, tool._output)

def run_as_command(editor, tool):
    editor.message('Running ' + tool._title, 'info')

    fd, filename = tempfile.mkstemp()
    os.write(fd, tool._script)
    os.close(fd)

    stdin = get_stdin(editor, tool._input)

    command_to_run = ['/usr/bin/env', 'sh', filename]

    env = {}
    env.update(os.environ)
    env['FILENAME'] = editor.uri
    env['OFFSET'] = str(editor.cursor.get_offset())
    env['PYTHON'] = get_executable(editor.conf)

    def on_finish():
        os.remove(filename)

    if tool._output == 'to-iconsole':
        return run_cmd_in_tty(command_to_run, editor, env, on_finish)

    if tool._output == 'to-background':
        proc = Popen(command_to_run, cwd=editor.project_root, env=env)
    else:
        proc = Popen(command_to_run, stdout=PIPE, stderr=PIPE, bufsize=1,
            stdin=PIPE if stdin else None, cwd=editor.project_root, env=env)

    if tool._output == 'to-console':
        from snaked.core.console import consume_output

        if stdin:
            proc.stdin.write(stdin)
            proc.stdin.close()

        consume_output(editor, proc, on_finish)
    elif tool._output == 'to-background':
        from threading import Thread
        def bg_run():
            proc.wait()
            on_finish()

        t = Thread(target=bg_run)
        t.daemon = True
        t.start()
    else:
        stdout, stderr = proc.communicate(stdin)
        on_finish()
        process_stdout(editor, stdout, stderr, tool._output)

def run_cmd_in_tty(cmd, editor, env, on_finish):
    master, slave = pty.openpty()

    proc = Popen(cmd, stdout=slave, stderr=slave,
        stdin=slave, cwd=editor.project_root, env=env)

    consume_pty(editor, proc, master, on_finish)

def edit_external_tools(editor, kind):
    if kind == 'global':
        filename = join_to_settings_dir('snaked', 'tools.conf')
    elif kind == 'session':
        filename = join_to_settings_dir('snaked', editor.session, 'tools')
    else:
        raise Exception('Unknown external tools type: ' + str(kind))

    if not exists(filename):
        make_missing_dirs(filename)
        shutil.copy(join(dirname(__file__), 'external.tools.template'), filename)

    e = editor.window.manager.open(filename, contexts='python')
    editor.window.attach_editor(e)
    e.connect('file-saved', on_external_tools_save)

def on_external_tools_save(editor):
    global tools
    tools = None
    editor.message('External tools updated', 'info')

def get_tools(editor):
    global tools, tool
    tools_module.clear()

    if tools is None:
        tools = []
        added_tools = set()

        filenames = (join_to_settings_dir('snaked', editor.session, 'tools'),
            join_to_settings_dir('snaked', 'tools.conf'))

        for f in filenames:
            tool = ToolExtractor()

            try:
                execfile(f, tools_module.setdefault(f, {}), tools_module.setdefault(f, {}))
            except IOError:
                pass
            except:
                import traceback
                editor.message('Unable to load ' + f + '\n\n' + traceback.format_exc(3), 'error', 0)
            else:
                for t in tool._tools:
                    if t._title in added_tools: continue
                    tools.append(t)
                    added_tools.add(t._title)

    return tools

def generate_menu(editor):
    has_selection = editor.buffer.get_has_selection()
    for tool in get_tools(editor):
        if tool._input == 'from-selection' and not has_selection:
            continue

        if tool._context and not all(ctx in editor.contexts for ctx in tool._context):
            continue

        yield tool._name, tool._title, (run, (editor, tool))

def resolve_menu_entry(editor, entry_id):
    for name, title, cbargs in generate_menu(editor):
        if entry_id == title:
            return cbargs + (name,)

    return None, None, None

allowed_inputs = ('from_buffer_or_selection', 'from_buffer', 'from_selection')
allowed_outputs = ('replace_buffer_or_selection', 'replace_buffer', 'replace_selection',
    'to_console', 'to_iconsole', 'to_feedback', 'to_clipboard', 'insert', 'insert_at_end',
    'to_background')

class ToolExtractor(object):
    def __init__(self):
        self._tools = []

        fake_tool = Tool()
        self.from_buffer_or_selection = fake_tool
        self.from_buffer = fake_tool
        self.from_selection = fake_tool
        self.replace_buffer_or_selection = fake_tool
        self.replace_buffer = fake_tool
        self.replace_selection = fake_tool
        self.to_console = fake_tool
        self.to_iconsole = fake_tool
        self.to_feedback = fake_tool
        self.to_clipboard = fake_tool
        self.to_background = fake_tool
        self.insert = fake_tool
        self.insert_at_end = fake_tool

    def __getattribute__(self, name):
        if name in allowed_inputs + allowed_outputs + ('__call__', 'when'):
            t = Tool()
            self._tools.append(t)
            return getattr(t, name)

        return object.__getattribute__(self, name)

    def __call__(self, *args):
        t = Tool()
        self._tools.append(t)
        return t(*args)

    def when(_self, *ctx):
        return Tool().when(*ctx)


class Tool(object):
    def __init__(self):
        self._name = None
        self._input = None
        self._output = 'to-console'
        self._context = None
        self._script = None
        self._callable = None

        self.from_buffer_or_selection = self
        self.from_buffer = self
        self.from_selection = self
        self.replace_buffer_or_selection = self
        self.replace_buffer = self
        self.replace_selection = self
        self.to_console = self
        self.to_iconsole = self
        self.to_feedback = self
        self.to_clipboard = self
        self.to_background = self
        self.insert = self
        self.insert_at_end = self

    @property
    def _title(self):
        return self._name.replace('_', '')

    def __getattribute__(self, name):
        if name in allowed_inputs:
            self._input = name.replace('_', '-')
        elif name in allowed_outputs:
            self._output = name.replace('_', '-')

        return object.__getattribute__(self, name)

    def when(self, *ctx):
        self._context = ctx
        return self

    def __call__(self, *args):
        if not args:
            return self._handle_arg

        assert len(args) == 1
        arg = args[0]
        if not self._name and not callable(arg):
            assert '\n' not in arg
            self._name = arg
            return self

        self._handle_arg(arg)

    def _handle_arg(self, callable_or_script):
        if callable(callable_or_script):
            self._callable = callable_or_script
            if not self._name:
                self._name = self._callable.__name__.replace('___', '###').replace(
                    '__', '%%%').replace('_', ' ').replace('###', ' _').replace('%%%', '_')
        else:
            self._script = cleandoc(callable_or_script)

tool = ToolExtractor()

########NEW FILE########
__FILENAME__ = complete
import textwrap

import weakref
from glib import markup_escape_text

from snaked.core.completer import Provider


def pangonify_rst(text):
    result = ''

    lines = text.strip().expandtabs().splitlines()

    if len(lines) > 1 and lines[1].strip():
        lines = [lines[0]] + [''] + lines[1:]

    indent = 1000
    for l in lines[1:]:
        stripped = l.lstrip()
        if stripped:
            indent = min(indent, len(l) - len(stripped))

    trimmed = [lines[0].strip()]
    if indent < 1000:
        for line in lines[1:]:
            trimmed.append(line[indent:].rstrip())

    wrapper = textwrap.TextWrapper(width=60)
    paragraph = ''
    break_paragraph = False

    def add_paragraph():
        r = result
        if paragraph:
            if break_paragraph:
                r += '\n'

            r += wrapper.fill(paragraph) + '\n\n'
            return r, '', False

        return r, '', break_paragraph

    for l in trimmed:
        if not l.strip():
            result, paragraph, break_paragraph = add_paragraph()
        else:
            if l.startswith('  '):
                result, paragraph, break_paragraph = add_paragraph()
                break_paragraph = True
                result += "<tt>%s</tt>" % markup_escape_text(l)
                result += '\n'
            else:
                paragraph += markup_escape_text(l) + ' '

    if paragraph:
        result, _, _ = add_paragraph()

    return result


class RopeCompletionProvider(Provider):
    def __init__(self, plugin):
        self.plugin = weakref.ref(plugin)

    def get_name(self):
        return 'python'

    def is_match(self, it):
        return it

    def complete(self, it, is_interactive):
        env = self.plugin().env
        root = self.plugin().project_path
        try:
            source, offset = self.plugin().get_source_and_offset()
            match, proposals = env.assist(root, source, offset, self.plugin().editor.uri)
        except Exception, e:
            import traceback
            traceback.print_exc()
            self.plugin().editor.message(str(e), 'error', 5000)
            return

        if proposals:
            for r in proposals:
                yield r, (r, match)
        else:
            self.plugin().editor.message("Can't assist")
            return

    def activate(self, textview, (proposal, match)):
        buf = textview.get_buffer()

        buf.begin_user_action()
        cursor = buf.get_iter_at_mark(buf.get_insert())
        start = cursor.copy()
        start.backward_chars(len(match))
        buf.delete(start, cursor)
        buf.insert_at_cursor(proposal)
        buf.end_user_action()

########NEW FILE########
__FILENAME__ = djangohints
import os.path
import sys

import rope.base.pyobjects
import rope.base.pynames
import rope.base.builtins

from rope.base import exceptions

from .ropehints import HintProvider, get_attribute_scope_path

def add_django_support(composite_provider, settings='settings'):
    return composite_provider.add_hint_provider(
        DjangoHintProvider(composite_provider.project, settings))

def get_path_and_package(module_path, project_root):
    packages = [os.path.basename(module_path).rpartition('.')[0]]
    while True:
        path = os.path.dirname(module_path)
        if path == module_path:
            break

        module_path = path

        if module_path == project_root:
            break

        if os.path.exists(os.path.join(module_path, '__init__.py')):
            packages.append(os.path.basename(module_path))
        else:
            break

    return module_path, '.'.join(reversed(packages))

loaded_django_modules = {}
def load_django_module(pymodule, project_root):
    path = os.path.realpath(pymodule.resource.real_path)
    try:
        return loaded_django_modules[path]
    except KeyError:
        pass

    syspath, module = get_path_and_package(path, project_root)
    if syspath not in sys.path:
        sys.path.append(syspath)

    __import__(module)

    loaded_django_modules[path] = sys.modules[module]
    return sys.modules[module]


class DjangoHintProvider(HintProvider):
    def __init__(self, project, settings):
        super(DjangoHintProvider, self).__init__(project)

        self.settings = settings

    def get_attributes(self, scope_path, pyclass, attrs):
        """:type pyclass: rope.base.pyobjectsdef.PyClass"""

        if not hasattr(pyclass, 'get_superclasses'):
            return {}

        if not any('django.db.models.base.Model' in get_attribute_scope_path(c)
                for c in pyclass.get_superclasses()):
            return {}

        os.environ['DJANGO_SETTINGS_MODULE'] = self.settings

        module = load_django_module(pyclass.get_module(), self.project.address)
        model = getattr(module, pyclass.get_name())()

        attrs = {}
        for name in model._meta.get_all_field_names():
            f = model._meta.get_field_by_name(name)[0]

            if f.__class__.__name__ == 'ForeignKey':
                related_model_name = f.rel.to.__module__ + '.' + f.rel.to.__name__
                attrs[name] = rope.base.pynames.DefinedName(
                    rope.base.pyobjects.PyObject(self.get_type(related_model_name).get_object()))
                attrs[f.attname] = rope.base.pynames.DefinedName(rope.base.pyobjects.PyObject(None))
            elif f.__class__.__name__ == 'RelatedObject':
                related_model_name = f.model.__module__ + '.' + f.model.__name__
                attrs[name] = DjangoObjectsName(self.get_type(related_model_name).get_object(),
                    self.get_type('django.db.models.manager.Manager'))
            else:
                attrs[name] = rope.base.pynames.DefinedName(rope.base.pyobjects.PyObject(None))

        attrs['objects'] = DjangoObjectsName(pyclass,
            self.get_type('django.db.models.manager.Manager'))

        return attrs


class DjangoObjectsName(rope.base.pynames.PyName):
    def __init__(self, pyclass, name):
        self._orig_name = name
        self.model_type = pyclass

    def get_object(self):
        return DjangoObjectsObject(self.model_type, self._orig_name.get_object())


def proxy(obj):
    cls = obj.__class__
    class Cls(cls):
        def __init__(self, obj):
            self._orig = obj

        def __getattribute__(self, name):
            obj = cls.__getattribute__(self, '_orig')
            print 'getattr', obj, name
            return cls.__getattribute__(obj, name)

    return Cls(obj)

class GetHolder:
    def __init__(self, result):
        self.result = result

    def get(self, *args):
        return self.result

class DjangoObjectsObject(object):
    def __init__(self, pyclass, obj):
        self.model_type = pyclass
        self._orig_object = obj
        self.type = obj.type

    def get_attributes(self):
        attrs = self._orig_object.get_attributes()

        attrs['get'].pyobject.returned = GetHolder(self.model_type)
        attrs['filter'].pyobject.returned = GetHolder(self)
        attrs['exclude'].pyobject.returned = GetHolder(self)
        attrs['extra'].pyobject.returned = GetHolder(self)
        attrs['order_by'].pyobject.returned = GetHolder(self)
        attrs['select_related'].pyobject.returned = GetHolder(self)
        attrs['all'].pyobject.returned = GetHolder(self)

        attrs['__getitem__'] = rope.base.pynames.DefinedName(
            SimpleFunction(self.model_type, ['index']))

        attrs['__iter__'] = rope.base.pynames.DefinedName(
            SimpleFunction(rope.base.builtins.get_iterator(self.model_type)))

        return attrs

    def __getattr__(self, name):
        return getattr(self._orig_object, name)

    def get_attribute(self, name):
        try:
            return self.get_attributes()[name]
        except KeyError:
            raise exceptions.AttributeNotFoundError('Attribute %s not found' % name)

    def __getitem__(self, key):
        return self.get_attribute(key)

    def __contains__(self, key):
        return key in self.get_attributes()


class SimpleFunction(rope.base.pyobjects.AbstractFunction):

    def __init__(self, returned=None, argnames=[]):
        rope.base.pyobjects.AbstractFunction.__init__(self)
        self.argnames = argnames
        self.returned = returned

    def get_returned_object(self, args):
        return self.returned

    def get_param_names(self, special_args=True):
        return self.argnames
########NEW FILE########
__FILENAME__ = dochints
import re

from .ropehints import HintProvider

class DocStringHintProvider(HintProvider):
    """Allows to hint functions/method parameters and return values types through doc strings

    This is build-in provider so you have no do any addition steps to enable it.

    Hints can be provided using Sphinx syntax::

        def func(text):
            '''
            :type text: str
            :rtype: str
            '''
            # now in func body 'text' parameter's type is resolved into 'str'

        # And all rest code now knows ``func`` return type is also 'str'

    """
    def __init__(self, project):
        super(DocStringHintProvider, self).__init__(project)
        self.cache = {}

    def get_function_params(self, scope_path, pyfunc):
        """:type pyfunc: rope.base.pyobjectsdef.PyFunction"""

        result = {}
        doc = pyfunc.get_doc()
        if doc:
            match = re.search(':rtype:\s*([.\w]+)', doc)
            if match:
                type_name = match.group(1)
                pyname = self.get_type(type_name, pyfunc.get_scope())
                if pyname:
                    result['return'] = pyname.get_object()

            param_names = pyfunc.get_param_names(False)
            for m in re.finditer(':type\s*(\w+):\s*([.\w]+)', doc):
                try:
                    idx = param_names.index(m.group(1))
                except ValueError:
                    continue

                type_name = m.group(2)
                pyname = self.get_type(type_name, pyfunc.get_scope())
                if pyname:
                    result[idx] = pyname.get_object()

        return result

########NEW FILE########
__FILENAME__ = pt
import sys
import os

try:
    import pytest
except ImportError:
    fname = os.__file__
    if fname.endswith('.pyc'):
        fname = fname[:-1]

    if not os.path.islink(fname):
        raise

    real_prefix = os.path.dirname(os.path.realpath(fname))
    site_packages = os.path.join(real_prefix, 'site-packages')
    old_path = sys.path
    sys.path = old_path + [site_packages]
    try:
        import pytest
    finally:
        sys.path = old_path

class Collector(object):
    def __init__(self, send):
        self.send = send

    def extract_trace(self, excinfo):
        """:type excinfo: py._code.code.ReprExceptionInfo"""

        result = []
        for entry in excinfo.reprtraceback.reprentries:
            result.append((entry.reprfileloc.path, entry.reprfileloc.lineno))

        return result

    def extract_output(self, report):
        result = str(report.longrepr)
        for s, d in report.sections:
            result += '\n\n===================== ' + s + '=======================\n' + d

        return result

    def pytest_runtest_logreport(self, report):
        """:type report: _pytest.runner.TestReport()"""

        if report.when != 'call':
            return

        if report.passed:
            self.send(('PASS', report.nodeid))
        elif report.failed:
            if report.when != "call":
                self.send(('ERROR', report.nodeid, self.extract_output(report),
                    self.extract_trace(report.longrepr)))
            else:
                self.send(('FAIL', report.nodeid, self.extract_output(report),
                    self.extract_trace(report.longrepr)))
        elif report.skipped:
            self.send(('SKIP', report.nodeid))

    def pytest_runtest_call(self, item):
        self.send(('ITEM_CALL', item.nodeid))

    def pytest_collectreport(self, report):
        """:type report: _pytest.runner.CollectReport()"""
        if report.failed:
            self.send(('FAILED_COLLECT', report.nodeid, self.extract_output(report),
                self.extract_trace(report.longrepr)))

    def pytest_internalerror(self, excrepr):
        self.send(('INTERNAL_ERROR', excrepr))

    def pytest_sessionstart(self, session):
        self.send(('START', str(session.fspath)))

    def pytest_sessionfinish(self, session, exitstatus):
        self.send(('END', ))

    def pytest_collection_finish(self, session):
        self.send(('COLLECTED_TESTS', [t.nodeid for t in session.items]))


#class Collector(object):
#    def __init__(self, *args, **kwargs):
#        self.f = open('/tmp/result.txt', 'w')
#
#    def __getattr__(self, name):
#        if not name.startswith('pytest_'):
#            raise AttributeError(name)
#
#        from _pytest import hookspec
#        import inspect
#
#        space = {'f':self.f}
#        exec 'def {0}{1}:\n    print >>f, "{0}{1}", locals()'.format(
#            name, inspect.formatargspec(*inspect.getargspec(getattr(hookspec, name)))) in space
#
#        return space[name]


if __name__ == '__main__':
    from multiprocessing.connection import Listener
    listener = Listener(sys.argv[1])
    conn = listener.accept()

    if sys.version_info[0] == 3:
        from pickle import dumps
        def sender(data):
            return conn.send_bytes(dumps(data, 2))
    else:
        sender = conn.send

    pytest.main(sys.argv[2:], plugins=[Collector(sender)])
########NEW FILE########
__FILENAME__ = outline
import weakref
import ast
import re

from uxie.utils import idle, join_to_file_dir, refresh_gui
from uxie.misc import BuilderAware

from snaked.util import set_activate_the_one_item

match_ws = re.compile('^[ \t]+')
def get_ws_len(line):
    match = match_ws.search(line)
    if match:
        return len(match.group(0))
    else:
        return 0

def parse_bad_code(code, tries=4):
    try:
        return ast.parse(code)
    except IndentationError, e:
        if not tries:
            raise

        code = code.splitlines()
        result = []
        for i, l in reversed(list(enumerate(code[:e.lineno-1]))):
            if l.strip():
                result.extend(code[:i])
                result.append(l + ' pass')
                result.extend(code[i+1:])
                break

        return parse_bad_code('\n'.join(result), tries-1)

    except SyntaxError, e:
        if not tries:
            raise

        code = code.splitlines()
        level = get_ws_len(code[e.lineno - 1])
        result = code[:e.lineno-1]
        result.append('')
        for i, l in enumerate(code[e.lineno:], e.lineno):
            if l.strip() and get_ws_len(l) <= level:
                result.extend(code[i:])
                break
            else:
                result.append('')

        return parse_bad_code('\n'.join(result), tries-1)


class OutlineVisitor(ast.NodeVisitor):
    def __init__(self):
        self.parent = ()
        self.nodes = []

    def process_childs(self,node):
        self.parent += (node.name,)
        self.generic_visit(node)
        self.parent = self.parent[:-1]

    def visit_ClassDef(self, node):
        self.nodes.append((self.parent, node))
        self.process_childs(node)

    def visit_FunctionDef(self, node):
        self.nodes.append((self.parent, node))
        self.process_childs(node)


class OutlineDialog(BuilderAware):
    def __init__(self):
        super(OutlineDialog, self).__init__(join_to_file_dir(__file__, 'outline.glade'))

        from snaked.core.manager import keymap
        self.activator = keymap.get_activator(self.window)
        self.activator.bind('any', 'escape', None, self.hide)
        self.activator.bind('any', 'activate-search-entry', None, self.focus_search)

        set_activate_the_one_item(self.search_entry, self.outline_tree)

    def show(self, editor):
        self.tree = None
        self.editor = weakref.ref(editor)
        self.search_entry.grab_focus()

        self.window.set_transient_for(editor.window)
        self.window.present()

        idle(self.fill)

    def get_tree(self):
        if not self.tree:
            visitor = OutlineVisitor()
            try:
                tree = parse_bad_code(self.editor().text)
                visitor.visit(tree)
                self.tree = visitor.nodes
            except (SyntaxError, IndentationError), e:
                print e
                self.tree = []

        return self.tree

    def hide(self):
        self.window.hide()

    def on_delete_event(self, *args):
        self.hide()
        return True

    def goto_name(self, *args):
        (model, iter) = self.outline_tree.get_selection().get_selected()
        if iter:
            self.hide()
            self.editor().add_spot()
            self.editor().goto_line(model.get_value(iter, 2))
        else:
            self.editor().message('You need select item', 'warn')

    def on_search_entry_changed(self, *args):
        what = self.search_entry.get_text().strip()
        if what:
            idle(self.filter, what)
        else:
            idle(self.fill)

    def fill(self):
        self.outline.clear()
        current_search = object()
        self.current_search = current_search

        roots = {():None}

        i = 0
        for parent, node in self.get_tree():
            if self.current_search is not current_search:
                return

            roots[parent + (node.name,)] = self.outline.append(roots[parent],
                (node.name, '', node.lineno))

            if i % 10 == 0:
                self.outline_tree.expand_all()
                self.outline_tree.columns_autosize()
                refresh_gui()

            i += 1

        self.outline_tree.expand_all()
        self.outline_tree.columns_autosize()

    def filter(self, search):
        self.outline.clear()

        current_search = object()
        self.current_search = current_search

        already_matched = {}
        i = 0

        def name_starts(name):
            return name.startswith(search)

        def name_contains(name):
            return search in name

        outline = self.get_tree()

        for m in (name_starts, name_contains):
            for top, node in outline:
                if self.current_search is not current_search:
                    return

                name, line = node.name, node.lineno

                if (top, name) in already_matched: continue

                if m(name):
                    already_matched[(top, name)] = True
                    self.outline.append(None, (name, u'/'.join(top), line))

                if i % 10 == 0:
                    refresh_gui()

                i += 1

        self.outline_tree.columns_autosize()

    def focus_search(self):
        self.search_entry.grab_focus()
########NEW FILE########
__FILENAME__ = plugin
import os.path, sys

import gtk
from uxie.utils import idle

from snaked.util import lazy_property
from snaked.signals import connect_external, connect_all
from snaked.core.completer import add_completion_provider, attach_completer

from .utils import get_env

configured_projects = {}

class Plugin(object):
    def __init__(self, editor):
        self.editor = editor
        idle(connect_all, self, view=editor.view)
        idle(self.init_completion)

    def init_completion(self):
        provider = self.completion_provider

        if not hasattr(self.editor.buffer, 'python_completion_added'):
            add_completion_provider(self.editor.buffer, provider, 100)
            self.editor.buffer.python_completion_added = True

        attach_completer(self.editor.view)

    @property
    def env(self):
        return get_env(self.editor.conf)

    @lazy_property
    def project_path(self):
        root = getattr(self.editor, 'ropeproject_root', self.editor.project_root)

        if not root:
            root = os.path.dirname(self.editor.uri)

        if root not in configured_projects:
            conf = self.editor.conf['PYTHON_SUPP_CONFIG']
            if conf:
                self.env.configure_project(root, conf)

            configured_projects[root] = True

        return root

    @lazy_property
    def completion_provider(self):
        import complete
        return complete.RopeCompletionProvider(self)

    def get_source_and_offset(self):
        offset = self.editor.cursor.get_offset()
        source = self.editor.text

        if not isinstance(source, unicode):
            source = source.decode('utf8')

        return source, offset

    def goto_definition(self):
        source, offset = self.get_source_and_offset()
        try:
            line, fname = self.env.get_location(self.project_path, source, offset, self.editor.uri)
        except Exception, e:
            import traceback
            traceback.print_exc()
            self.editor.message(str(e), 'error', 5000)
            return

        if fname == self.editor.uri:
            fname = None

        if fname:
            editor = self.editor.window.open_or_activate(fname, line - 1)
            editor.supplement_project_root = self.project_path
        else:
            if line:
                self.editor.add_spot()
                self.editor.goto_line(line)
            else:
                self.editor.message("Unknown definition", 'warn')

    @connect_external('view', 'key-press-event')
    def on_textview_key_press_event(self, sender, event):
        if event.keyval != gtk.keysyms.Return:
            return False

        cursor = self.editor.cursor
        line_start = cursor.copy()
        line_start.set_line(line_start.get_line())

        text = line_start.get_text(cursor).strip()
        if text and text[-1] == ':':
            end = line_start.copy()
            end.forward_word_end()
            end.backward_word_start()
            ws = line_start.get_text(end)

            if self.editor.view.get_insert_spaces_instead_of_tabs():
                tab = u' ' * self.editor.view.get_tab_width()
            else:
                tab = u'\t'

            self.editor.buffer.begin_user_action()
            self.editor.buffer.insert(cursor, u'\n' + ws + tab)
            self.editor.buffer.end_user_action()

            idle(self.editor.view.scroll_mark_onscreen, self.editor.buffer.get_insert())

            return True

        return False

    @connect_external('view', 'backspace')
    def on_textview_backspace(self, *args):
        cursor = self.editor.cursor

        if cursor.starts_line():
            return False

        start = cursor.copy()
        start.set_line(start.get_line())

        text = start.get_text(cursor)

        if text.strip():
            return False

        delete_from = cursor.copy()
        if text[-1] == u'\t':
            delete_from.backward_char()
        else:
            delete_from.backward_chars(self.editor.view.get_tab_width() - 1)

        if delete_from.get_line() != start.get_line():
            delete_from = start

        if delete_from.equal(start):
            delete_from.forward_char()

        self.editor.buffer.begin_user_action()
        self.editor.buffer.delete(delete_from, cursor)
        self.editor.buffer.end_user_action()

        return True

    def show_calltips(self):
        source, offset = self.get_source_and_offset()
        try:
            result = self.env.get_docstring(self.project_path, source, offset, self.editor.uri)
        except Exception, e:
            import traceback
            traceback.print_exc()
            self.editor.message(str(e), 'error', 5000)
            return

        if not result:
            self.editor.message("Can't get docstring", 'warn')
            return

        sig, docstring = result
        if sig:
            docstring = sig + '\n\n' + ( docstring if docstring is not None else '' )

        if docstring:
            self.editor.message(docstring, 'info', 20000)
        else:
            self.editor.message('Info not found', 'warn', 3000)

    def get_scope(self):
        source, _ = self.get_source_and_offset()
        return self.editor.uri, self.env.get_scope(self.project_path,
            source, self.editor.cursor.get_line() + 1, self.editor.uri, False)

########NEW FILE########
__FILENAME__ = pygtkhints
import re

import xml.sax.handler
import rope.base.pynames
import rope.base.pyobjects
from rope.base.exceptions import ModuleNotFoundError

import gobject

from .ropehints import HintProvider, get_attribute_scope_path

pydoc_glade_file_matcher = re.compile('(?m)^.*glade-file\s*:(.*)$')

def add_gtk_support(composite_provider):
    add_gtk_extension_modules(composite_provider.project)
    composite_provider.db.add_attribute('gtk$', 'TextView', 'snaked.plugins.python.pygtk_stubs.TextView')
    composite_provider.db.add_attribute('gtk$', 'TextBuffer',
        'snaked.plugins.python.pygtk_stubs.TextBuffer')

    return composite_provider.add_hint_provider(PyGtkHintProvider(composite_provider.project))

def add_gtk_extension_modules(project):
    existing_modules = project.prefs['extension_modules']
    for m in ('gtk._gtk', 'gtk.gdk', 'glib._glib', 'gobject._gobject', 'pango'):
        if m not in existing_modules:
            existing_modules.append(m)

    project.prefs['extension_modules'] = existing_modules


class ResourceAsModule(object):
    def __init__(self, resource):
        self.resource = resource

    def get_resource(self):
        return self.resource

    def get_module(self):
        return self


class GladeName(rope.base.pynames.PyName):
    def __init__(self, pyobject, module, line):
        self.pyobject = pyobject
        self.line = line
        self.module = module

    def get_object(self):
        return self.pyobject

    def get_definition_location(self):
        return self.module, self.line


class GladeFunction(rope.base.pyobjects.AbstractFunction):
    def __init__(self):
        rope.base.pyobjects.AbstractFunction.__init__(self)


class PyGtkHintProvider(HintProvider):
    def __init__(self, project):
        super(PyGtkHintProvider, self).__init__(project)
        self.gtk_aware_classes = {}
        self.cache = {}
        self.func_cache = {}
        self.handlers = {}
        self.processed_files = {}

    def get_pygtk_class_name(self, gtk_class_name):
        return gtk_class_name.replace('Gtk', 'gtk.', 1) + '()'

    def process_glade(self, scope_path, glade_resource, force=False):
        glade_file = glade_resource.real_path
        processed = self.processed_files.get(glade_file, False)
        if processed and not force:
            return

        handler = GladeHandler()
        xml.sax.parseString(open(glade_file).read(), handler)

        attrs = {}
        for id, cls, line in handler.objects:
            type = self.get_type(self.get_pygtk_class_name(cls))
            attrs[id] = GladeName(type.get_object(), ResourceAsModule(glade_resource), line)

        for name, (cls, signal, line) in handler.signals.iteritems():
            self.handlers.setdefault(scope_path, {})[name] = cls, signal
            attrs[name] = GladeName(GladeFunction(), ResourceAsModule(glade_resource), line)

        self.cache[scope_path] = attrs
        self.processed_files[glade_file] = True

    def get_glade_file_for_class(self, scope_path, pyclass):
        project = pyclass.get_module().resource.project
        try:
            path = self.gtk_aware_classes[scope_path]
            return project.get_resource(path)
        except KeyError:
            pass

        doc = pyclass.get_doc()
        if doc:
            match = pydoc_glade_file_matcher.search(doc)
            if match:
                filename = match.group(1).strip()
                if filename.startswith('/'):
                    return project.get_resource(filename[1:])
                else:
                    return pyclass.get_module().resource.parent.get_child(filename)

        return None

    def get_attributes(self, scope_path, pyclass, orig_attrs):
        attrs = {}
        glade_file = self.get_glade_file_for_class(scope_path, pyclass)
        if glade_file:
            self.process_glade(scope_path, glade_file)
            for k, v in self.cache[scope_path].iteritems():
                if k not in orig_attrs:
                    attrs[k] = v

        return attrs

    def add_class(self, scope, glade_file):
        self.gtk_aware_classes[scope] = glade_file

    def get_function_params(self, scope_path, pyfunc):
        """:type pyfunc: rope.base.pyobjectsdef.PyFunction"""

        pyclass = pyfunc.parent
        scope_path = get_attribute_scope_path(pyclass)
        glade_file = self.get_glade_file_for_class(scope_path, pyclass)

        if glade_file:
            self.process_glade(scope_path, glade_file)
            return self.get_params_for_handler(scope_path, pyfunc)
        else:
            return {}

    def get_params_for_handler(self, class_scope, pyfunc):
        """:type pyfunc: rope.base.pyobjectsdef.PyFunction"""
        try:
            cls, signal = self.handlers[class_scope][pyfunc.get_name()]
        except KeyError:
            return {}

        attrs = {}

        idx = 0
        names = pyfunc.get_param_names(False)
        if pyfunc.get_kind() in ('method', 'classmethod'):
            names = names[1:]
            idx += 1

        if names:
            attrs[idx] = self.get_type(self.get_pygtk_class_name(cls)).get_object()
            names = names[1:]
            idx += 1

        if names:
            for t in gobject.signal_query(signal, str(cls))[-1]:
                try:
                    tname = self.get_type(self.get_pygtk_class_name(t.name))
                    if tname:
                        attrs[idx] = tname.get_object()
                except ModuleNotFoundError:
                    pass

                idx += 1

        return attrs


class GladeHandler(xml.sax.handler.ContentHandler):
    def __init__(self):
        self.objects = []
        self.signals = {}
        self.current_object_class = None

    def startElement(self, name, attrs):
        if name == 'object':
            self.objects.append((attrs['id'], attrs['class'], self._locator.getLineNumber()))
            self.current_object_class = attrs['class']
        elif name == 'signal':
            if self.current_object_class:
                self.signals[attrs['handler']] = (self.current_object_class, attrs['name'],
                    self._locator.getLineNumber())

    def endElement(self, name):
        if name == 'object':
            self.current_object_class = None
########NEW FILE########
__FILENAME__ = pygtk_stubs
import gtk

class TextView(gtk.TextView):
    def get_buffer(self):
        return gtk.TextBuffer()

class TextBuffer(gtk.TextBuffer):
    def get_iter_at_mark(self, mark):
        return gtk.TextIter()
########NEW FILE########
__FILENAME__ = pytest_launcher
import sys
import os.path
import time

def run_test(project_dir, executable=None, match=None, files=[], env=None):
    from subprocess import Popen
    from multiprocessing.connection import Client, arbitrary_address

    addr = arbitrary_address('AF_UNIX')
    filename = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'launcher/pt.py')

    executable = executable or sys.executable
    args = [executable, filename, addr, '-q']
    if match:
        args.append('-k %s' % match)

    environ = None
    if env:
        environ = os.environ.copy()
        environ.update(env)

    args.extend(files)
    proc = Popen(args, cwd=project_dir, env=environ)
    start = time.time()
    while not os.path.exists(addr):
        if time.time() - start > 5:
            raise Exception('py.test launching timeout exceed')
        time.sleep(0.01)

    conn = Client(addr)

    return proc, conn
########NEW FILE########
__FILENAME__ = pytest_runner
import os.path
import weakref

import glib
import pango
import gtk

from gtk.gdk import color_parse

from uxie.utils import join_to_file_dir
from uxie.misc import BuilderAware

from . import pytest_launcher
from .utils import get_executable

class Escape(object): pass

class TestRunner(BuilderAware):
    """glade-file: pytest_runner.glade"""

    def __init__(self):
        super(TestRunner, self).__init__(join_to_file_dir(__file__, 'pytest_runner.glade'))

        self.buffer = gtk.TextBuffer()
        self.view = gtk.TextView()
        self.view.set_buffer(self.buffer)
        self.view.set_editable(False)
        self.view.set_wrap_mode(gtk.WRAP_WORD)
        self.buffer_place.add(self.view)
        self.view.show()

        self.original_progress_color = self.progress.get_style().bg[gtk.STATE_SELECTED]

        self.editor_ref = None
        self.timer_id = None
        self.test_proc = None
        self.collected_nodes = {}
        self.failed_nodes = {}
        self.nodes_traces = {}
        self.nodes_buffer_positions = {}
        self.panel.hide()

    def collect(self, conn):
        while conn.poll():
            try:
                msg = conn.recv()
            except EOFError:
                break

            handler_name = 'handle_' + msg[0].lower()
            try:
                func = getattr(self, handler_name)
            except AttributeError:
                print 'TestRunner: %s not founded' % handler_name
            else:
                func(*msg[1:])

        return self.test_proc.poll() is None

    def run(self, editor, project_root, matches='', files=[]):
        self.editor_ref = weakref.ref(editor)
        self.stop_running_test()

        self.tests.clear()
        self.collected_nodes.clear()
        self.failed_nodes.clear()
        self.nodes_traces.clear()
        self.nodes_buffer_positions.clear()
        self.tests_count = 0
        self.executed_tests = 0
        self.passed_tests_count = 0
        self.failed_tests_count = 0
        self.skipped_tests_count = 0
        self.prevent_scroll = False
        self.buffer.delete(*self.buffer.get_bounds())
        self.buffer.node = None
        self.progress.modify_bg(gtk.STATE_SELECTED, self.original_progress_color)
        self.progress.set_text('Running tests')
        self.stop_run.show()
        self.trace_buttons.hide()

        executable = get_executable(editor.conf)
        env = editor.conf['PYTHON_EXECUTABLE_ENV']

        proc, conn = pytest_launcher.run_test(project_root, executable, matches, files, env=env)
        self.test_proc = proc
        self.timer_id = glib.timeout_add(100, self.collect, conn)

    def show(self):
        self.editor_ref().window.popup_panel(self.panel)

    def find_common_parent(self, nodes):
        if not nodes:
            return ''

        parent, _, _ = nodes[0].rpartition('::')
        while parent:
            if all(n.startswith(parent) for n in nodes):
                return parent

            parent, _, _ = parent.rpartition('::')

        return ''

    def handle_failed_collect(self, node, msg, trace):
        iter = self.collected_nodes[node] = self.tests.append(
            None, (node, pango.WEIGHT_NORMAL, node))

        self.add_trace(node, msg, trace)

        testname = self.tests.get_value(iter, 0)
        self.tests.set(iter, 0, u'\u2718 '.encode('utf8') + testname, 1, pango.WEIGHT_BOLD)

        self.show()
        self.resize_tests_view()
        self.tests_view.grab_focus()
        self.prevent_scroll = True

    def handle_collected_tests(self, nodes):
        common_parent = self.find_common_parent(nodes)

        self.tests_count = len(nodes)
        self.progress_adj.set_upper(self.tests_count)

        def append(node, node_name):
            parent, sep, child = node_name.rpartition('::')
            if parent:
                if parent not in self.collected_nodes:
                    append(parent, parent)

                self.collected_nodes[node] = self.tests.append(
                    self.collected_nodes[parent], (child, pango.WEIGHT_NORMAL, node))
            else:
                self.collected_nodes[node] = self.tests.append(
                    None, (child, pango.WEIGHT_NORMAL, node))

        for node in nodes:
            node_name = node
            if common_parent:
                node_name = node[len(common_parent)+2:]
            append(node, node_name)

        if self.tests_count > 1:
            self.show()
            self.resize_tests_view()

    def resize_tests_view(self):
        self.tests_view.expand_all()
        nw = self.tests_view.size_request()[0]
        w = self.tests_view_sw.get_size_request()[0]
        tw = self.panel.window.get_size()[0]
        if nw > w:
            if nw > tw/2: nw = tw/2
            self.tests_view_sw.set_size_request(nw, -1)

    def handle_item_call(self, node):
        self.executed_tests += 1
        self.progress_adj.set_value(self.executed_tests - 1)
        self.progress.set_text('Running test %d/%d' % (self.executed_tests, self.tests_count))

        self.tests.set(self.collected_nodes[node], 1, pango.WEIGHT_BOLD)

        if not self.prevent_scroll:
            path = self.tests.get_path(self.collected_nodes[node])
            self.tests_view.scroll_to_cell(path, None, True, 0.5)

    def handle_pass(self, node):
        self.passed_tests_count += 1
        iter = self.collected_nodes[node]
        testname = self.tests.get_value(iter, 0)
        self.tests.set(iter, 0, u'\u2714 '.encode('utf8') + testname, 1, pango.WEIGHT_NORMAL)

    def handle_skip(self, node):
        self.skipped_tests_count += 1
        iter = self.collected_nodes[node]
        testname = self.tests.get_value(iter, 0)
        self.tests.set(iter, 0, u'\u2731 '.encode('utf8') + testname, 1, pango.WEIGHT_NORMAL)

    def add_trace(self, node, msg, trace):
        self.failed_nodes[node] = msg

        result = []
        msg = msg.decode('utf-8')
        for filename, line in trace:
            search = u'%s:%d:' % (filename, line)
            idx = msg.find(search)
            result.append((filename, line, idx))

        self.nodes_traces[node] = result

    def handle_fail(self, node, msg, trace):
        self.failed_tests_count += 1
        self.prevent_scroll = True
        self.add_trace(node, msg, trace)
        iter = self.collected_nodes[node]
        testname = self.tests.get_value(iter, 0)
        self.tests.set(iter, 0, u'\u2718 '.encode('utf8') + testname, 1, pango.WEIGHT_BOLD)

        self.progress.modify_bg(gtk.STATE_SELECTED, color_parse('#7d2749'))

        if self.failed_tests_count == 1:
            self.tests_view.set_cursor(self.tests.get_path(iter))
            self.show()
            self.resize_tests_view()
            self.tests_view.grab_focus()

    def handle_error(self, node, msg, err):
        self.handle_fail(node, msg, err)

    def handle_start(self, test_dir):
        self.test_dir = test_dir

    def handle_end(self):
        self.stop_run.hide()

        text = ['Done.']
        text.append('%d/%d passed.' % (self.passed_tests_count, self.tests_count))

        if self.skipped_tests_count:
            text.append('%d skipped.' % self.skipped_tests_count)

        if self.failed_tests_count:
            text.append('%d failed.' % self.failed_tests_count)
        else:
            self.progress.modify_bg(gtk.STATE_SELECTED, color_parse('#277d49'))

        self.progress.set_text(' '.join(text))
        self.progress_adj.set_value(self.tests_count)

        if not self.tests_count:
            self.editor_ref().message('There are no any tests to run')

        if self.tests_count == self.passed_tests_count == 1:
            self.editor_ref().message('Test PASSED')

    def on_tests_view_cursor_changed(self, view):
        path, column = view.get_cursor()
        iter = self.tests.get_iter(path)
        node = self.tests.get_value(iter, 2)

        buf = self.buffer

        if buf.node:
            self.nodes_buffer_positions[buf.node] = buf.get_iter_at_mark(
                buf.get_insert()).get_offset()

        self.trace_buttons.hide()

        if node in self.failed_nodes:
            buf.set_text(self.failed_nodes[node])
            buf.node = node
            if node in self.nodes_buffer_positions:
                buf.place_cursor(buf.get_iter_at_offset(self.nodes_buffer_positions[node]))
            else:
                buf.place_cursor(buf.get_bounds()[1])

            self.view.scroll_to_mark(buf.get_insert(), 0.001, use_align=True, xalign=1.0)
        else:
            self.buffer.set_text('')
            self.buffer.node = None

    def on_activate(self, widget):
        self.tests_view.grab_focus()

    def on_tests_view_row_activated(self, view, path, *args):
        iter = self.tests.get_iter(path)
        node = self.tests.get_value(iter, 2)

        if node in self.nodes_traces:
            self.goto_trace(node, self.nodes_traces[node][0])
            if len(self.nodes_traces[node]) > 1:
                self.trace_buttons.show()

    def goto_trace(self, node, trace):
        filename, line, idx = trace

        if idx >= 0:
            self.buffer.place_cursor(self.buffer.get_iter_at_offset(idx))
            self.view.scroll_to_mark(self.buffer.get_insert(), 0.001, True, 1.0, 1.0)

        if not filename.startswith('/'):
            filename = os.path.join(self.test_dir, filename)

        e = self.editor_ref().window.open_or_activate(filename, line)
        e.view.grab_focus()

    def on_stop_run_activate(self, button):
        self.stop_running_test()

    def stop_running_test(self):
        if self.test_proc:
            if self.test_proc.poll() is None:
                glib.source_remove(self.timer_id)
                self.timer_id = None
                self.test_proc.terminate()
                self.test_proc.wait()

                self.stop_run.hide()
                self.progress.set_text('Stopped')

    def move_to_next_trace(self, is_back):
        if not self.buffer.node or not self.buffer.node in self.nodes_traces:
            return

        offset = self.buffer.get_iter_at_mark(self.buffer.get_insert()).get_offset()

        traces = self.nodes_traces[self.buffer.node]
        if is_back:
            traces = reversed(traces)

        for t in traces:
            if (is_back and t[2] < offset) or (not is_back and t[2] > offset):
                self.goto_trace(self.buffer.node, t)
                return

        self.editor_ref().message('There is no any traces to follow')

    def on_trace_up_activate(self, button):
        self.move_to_next_trace(True)

    def on_trace_down_activate(self, button):
        self.move_to_next_trace(False)
########NEW FILE########
__FILENAME__ = ropehints
import re, sys

import weakref

import rope.base.oi.soi
import rope.base.pyobjects
import rope.base.pynames
from rope.base import exceptions
from rope.base.pyobjectsdef import PyModule, PyPackage, PyClass
from rope.base.builtins import BuiltinModule

class ReplacedName(rope.base.pynames.PyName):
    def __init__(self, pyobject, pyname):
        self.pyobject = pyobject
        self.pyname = pyname

    def get_object(self):
        return self.pyobject

    def get_definition_location(self):
        return self.pyname.get_definition_location()


def builtin_module(self):
    try:
        __import__(self.name)
        return sys.modules[self.name]
    except ImportError:
        return
BuiltinModule.module = property(builtin_module)


def infer_parameter_objects_with_hints(func):
    def inner(pyfunction):
        params_types = func(pyfunction)

        try:
            hintdb = pyfunction.pycore.hintdb
        except AttributeError:
            return params_types

        scope_path = get_attribute_scope_path(pyfunction)
        provided_names = hintdb.get_function_params(scope_path, pyfunction)
        for i, t in enumerate(params_types):
            if i in provided_names:
                params_types[i] = provided_names[i]

        return params_types

    return inner

rope.base.oi.soi.infer_parameter_objects = infer_parameter_objects_with_hints(
    rope.base.oi.soi.infer_parameter_objects)


def infer_returned_object_with_hints(func):
    def inner(pyfunction, args):
        try:
            hintdb = pyfunction.pycore.hintdb
        except AttributeError:
            return func(pyfunction, args)

        scope_path = get_attribute_scope_path(pyfunction)
        params = hintdb.get_function_params(scope_path, pyfunction)
        try:
            return params['return']
        except KeyError:
            return func(pyfunction, args)

    return inner

rope.base.oi.soi.infer_returned_object = infer_returned_object_with_hints(
    rope.base.oi.soi.infer_returned_object)

def get_attribute_scope_path(obj, collected=''):
        if isinstance(obj, (PyModule, PyPackage)):
            if obj.resource:
                name = obj.pycore.modname(obj.resource)
            else:
                return collected
        else:
            name = obj.get_name()

        if collected:
            collected = name + '.' + collected
        else:
            collected = name

        try:
            scope = obj.get_scope().parent
        except AttributeError:
            return collected

        if scope:
            return get_attribute_scope_path(scope.pyobject, collected)
        else:
            return collected

def get_attributes_with_hints(func):
    def inner(self):
        result = func(self)

        if isinstance(self, PyModule) and self.resource and self.resource.name == '__init__.py':
            return result

        #print 'request attributes for', get_attribute_scope_path(self), self

        try:
            hintdb = self.pycore.hintdb
        except AttributeError:
            return result

        scope_path = get_attribute_scope_path(self)
        recursion_guard = '____' + scope_path

        if recursion_guard in self.__dict__:
            return result

        self.__dict__[recursion_guard] = True
        try:
            hinted_attrs = hintdb.get_attributes(scope_path, self, result)
            result.update(hinted_attrs)
        except:
            raise
        finally:
            del self.__dict__[recursion_guard]

        return result

    return inner

PyClass._get_structural_attributes = get_attributes_with_hints(PyClass._get_structural_attributes)
PyModule._get_structural_attributes = get_attributes_with_hints(PyModule._get_structural_attributes)
PyPackage._get_structural_attributes = get_attributes_with_hints(PyPackage._get_structural_attributes)


def get_superclasses_wrapper(func):
    def inner(self):
        bases = func(self)
        for i, base in enumerate(bases):
            if self is base and hasattr(self, 'replaces_name'):
                bases[i] = self.replaces_name.get_object()

        return bases

    return inner

PyClass.get_superclasses = get_superclasses_wrapper(PyClass.get_superclasses)


class HintProvider(object):
    def __init__(self, project):
        self._project = weakref.ref(project)

    @property
    def project(self):
        """Return rope project

        :rtype: rope.base.project.Project
        """
        return self._project()

    def get_function_params(self, scope_path, pyfunc):
        """Should resolve type for function's parameters `name`

        Also should resolve return type by setting 'return' item in result dict
        If there is no any type hints {} is returned
        """
        return {}

    def get_attributes(self, scope_path, pyobj, attrs):
        """Returns additional atributes for pymodule or pyclass"""
        return {}

    def get_type(self, type_name, scope=None):
        pycore = self.project.pycore
        module, sep, name = type_name.strip('()').rpartition('.')
        if module:
            module = pycore.get_module(module)
            try:
                pyname = module[name]
            except exceptions.AttributeNotFoundError:
                pyname = None
        elif scope:
            pyname = scope.lookup(name)
        else:
            pyname = pycore.get_module(name)

        return pyname


class ScopeHintProvider(HintProvider):
    """Working horse of type hinting

    Common usage is in conjunction with :class:`ReScopeMatcher` (also see examples there)
    """
    def __init__(self, project, scope_matcher):
        """:param project: rope project
        :param scope_matcher: one of :class:`ScopeMatcher` implementations.
        """
        super(ScopeHintProvider, self).__init__(project)
        self.matcher = scope_matcher

    def get_function_params(self, scope_path, pyfunc):
        result = {}
        for i, name in enumerate(pyfunc.get_param_names(False)+['return']):
            type_name = self.matcher.find_param_type_for(scope_path, name)
            if type_name:
                pyname = self.get_type(type_name)
                if pyname:
                    if name == 'return':
                        result['return'] = pyname.get_object()
                    else:
                        result[i] = pyname.get_object()

        return result

    def get_attributes(self, scope_path, pyclass, oldattrs):
        attrs = {}
        for name, type_name in self.matcher.find_attributes(scope_path):
            type = self.get_type(type_name)
            if type:
                if type_name.endswith('()'):
                    obj = rope.base.pyobjects.PyObject(type.get_object())
                    attrs[name] = ReplacedName(obj, type)
                else:
                    attrs[name] = type

                existing_attributes = pyclass.get_attributes()
                if name in existing_attributes:
                    type.get_object().replaces_name = existing_attributes[name]

        return attrs

class ScopeMatcher(object):
    """Abstract matcher class for :class:`ScopeHintProvider`"""

    def find_param_type_for(self, scope_path, name):
        """
        Return matched function param or return value type

        :param scope_path: function or method scope path (``module.Class.method`` or ``module.func``)
        :param name: function param name or `return` in case matching function return value type
        """

    def find_attributes(self, scope_path):
        """
        Return matched class attributes types

        :param scope_path: module.ClassName
        :return: iterator of (attribute, type) tuples
        """


class ReScopeMatcher(ScopeMatcher):
    """:class:`ScopeHintProvider` matcher based on regular expressions

    Matching is done with ``re.match`` function (pay attention to differences with ``re.search``)

    See :func:`add_attribute`, :func:`add_param_hint`.

    """
    def __init__(self):
        self.param_hints = []
        self.attributes = []

    def add_param_hint(self, scope, name, object_type):
        """Add function/method parameter or return value type hint.

        Very useful in case of mass type hinting. For example part of snaked's ``ropehints.py``::

            def init(provider):
                provider.db.add_param_hint('.*', 'editor$', 'snaked.core.editor.Editor()')
                provider.db.add_param_hint('snaked\.plugins\..*?\.init$', 'manager$',
                    'snaked.core.plugins.ShortcutsHolder()')

        Snaked consist of many small functions passing around current text buffer (named ``editor``)
        as parameter and first line allows to provide such type hint. Second line resolves all plugins
        ``init`` function's ``manager`` parameter.

        Or take look at Django's view function's request resolving::

                provider.db.add_param_hint('.*\.views\..*', 'request$', 'django.http.HttpRequest()')

        If name is ``return`` type hint is provided for function's return value type. Following
        example shows it::

            provider.db.add_param_hint('re\.compile$', 'return$', 're.RegexObject()')
            provider.db.add_param_hint('re\.search$', 'return$', 're.MatchObject()')
            provider.db.add_param_hint('re\.match$', 'return$', 're.MatchObject()')
            provider.db.add_attribute('re$', 'RegexObject', 'snaked.plugins.python.stub.RegexObject')
            provider.db.add_attribute('re$', 'MatchObject', 'snaked.plugins.python.stub.MatchObject')

        Take notice, ``re.compile``, ``re.search``, ``re.match`` return absent classes which are mapped
        with :func:`add_attribute_hint` to existing stubs later.
        """
        self.param_hints.append((re.compile(scope), re.compile(name), object_type))

    def add_attribute(self, scope, name, object_type):
        """Add attribute type hint for module or class/object

        Can be used to provide module attributes types, for example in case or complex
        module loading (werkzeug) or complex runtime behavior (flask). Here is example
        ``.ropeproject/ropehints.py``::

            def init(provider):
                provider.db.add_attribute('flask$', 'request', 'flask.wrappers.Request()')
                provider.db.add_attribute('werkzeug$', 'Request', 'werkzeug.wrappers.Request')

        What happens here? ``flask.request`` is magic proxy to isolate thread contexts from each other.
        In runtime it is ``flask.wrappers.Request`` object (in default flask setup), so first line
        adds this missing information. But this is not enough. ``flask.wrappers.Request`` is a child
        of ``werkzeug.Request`` which can not be resolved because of werkzeug's module
        loading system. So there is second line adding necessary mapping: module attribute
        ``werkzeug.Request`` should be ``werkzeug.wrappers.Request`` indeed. Take note about
        parentheses, ``flask.request`` is instance so type declared with them as opposite to
        ``werkzeug.Request`` which is class.

        Also one can add class attributes hint. Here is example from my django project::

            provider.db.add_attribute('django\.http\.HttpRequest$', 'cur', 'app.Cur')
            provider.db.add_attribute('django\.http\.HttpRequest$', 'render', 'app.render')

        Here are some explanations. Every ``request`` object has ``cur`` attribute
        (I know about contexts, don't ask me why I need it) which is instance of ``app.Cur``, so
        first line injects such info. Second line resolves ``render`` function also bounded to
        request.
        """
        self.attributes.append((re.compile(scope), name, object_type))

    def find_param_type_for(self, scope_path, name):
        for scope, vname, otype in self.param_hints:
            if scope.match(scope_path) and vname.match(name):
                return otype

        return None

    def find_attributes(self, scope_path):
        for scope, vname, otype in self.attributes:
            if scope.match(scope_path):
                yield vname, otype


class CompositeHintProvider(HintProvider):
    """Default snaked's hint provider

    It is created automatically for each rope project and passed to ``.ropeproject/ropehints.py``
    ``init`` function as first parameter.

    Contains build-in :class:`ScopeHintProvider` with it's scope matcher accessed via ``self.db``
    and :class:`DocStringHintProvider`.

    Also provides hints for ``re`` module. Custom providers can be
    added via :func:`add_hint_provider`::

        def init(provider):
            provider.db.add_class_attribute('django\.http\.HttpRequest$', 'render$', 'app.render')

            from snaked.plugins.python.djangohints import DjangoHintProvider
            provider.add_hint_provider(DjangoHintProvider(provider, 'settings'))

    """
    def __init__(self, project):
        super(CompositeHintProvider, self).__init__(project)

        self.attributes_cache = {}

        self.hint_provider = []

        self.db = ReScopeMatcher()
        self.db.add_param_hint('ropehints\.init$', 'provider$',
            'snaked.plugins.python.ropehints.CompositeHintProvider()')

        self.db.add_param_hint('re\.compile$', 'return$', 're.RegexObject()')
        self.db.add_param_hint('re\.search$', 'return$', 're.MatchObject()')
        self.db.add_param_hint('re\.match$', 'return$', 're.MatchObject()')
        self.db.add_attribute('re$', 'RegexObject', 'snaked.plugins.python.stub.RegexObject')
        self.db.add_attribute('re$', 'MatchObject', 'snaked.plugins.python.stub.MatchObject')

        self.add_hint_provider(ScopeHintProvider(project, self.db))

        # prepopulate popular dynamic modules
        existing_modules = project.prefs['extension_modules'] or []
        for m in ('os._path', 'itertools'):
            if m not in existing_modules:
                existing_modules.append(m)
        project.prefs['extension_modules'] = existing_modules
        project.prefs['ignore_bad_imports'] = True

        from .dochints import DocStringHintProvider
        self.add_hint_provider(DocStringHintProvider(project))

    def add_hint_provider(self, provider):
        """Inserts provider into collection.

        Last added provider has max priority.
        """

        self.hint_provider.insert(0, provider)
        return provider

    def get_function_params(self, scope_path, pyfunc):
        for p in self.hint_provider:
            result = p.get_function_params(scope_path, pyfunc)
            if result:
                return result

        return {}

    def get_attributes(self, scope_path, pyclass, attrs):
        try:
            return self.attributes_cache[scope_path]
        except KeyError:
            pass

        new_attrs = {}
        for p in self.hint_provider:
            new_attrs.update(p.get_attributes(scope_path, pyclass, attrs))

        self.attributes_cache[scope_path] = new_attrs
        return new_attrs
########NEW FILE########
__FILENAME__ = ropehints_tpl
"""
This is ropehints module which configures Snaked's python type hinting system.

Enable Django support::

    from snaked.plugins.python.djangohints import add_django_support
    add_django_support(provider)

Enable PyGtk support::

    from snaked.plugins.python.pygtkhints import add_gtk_support
    add_gtk_support(provider)

For detailed description look at http://packages.python.org/snaked/python.html#type-hints
"""

def init(provider):
    pass
########NEW FILE########
__FILENAME__ = stub
class RegexObject:
    def __init__(self):
        self.flags = 0
        self.groups = 0
        self.groupindex = {}
        self.pattern = ""

    def match(string, pos=None, endpos=None):
        """If zero or more characters at the beginning of *string* match this regular
        expression, return a corresponding :class:`MatchObject` instance.  Return
        ``None`` if the string does not match the pattern; note that this is different
        from a zero-length match.

        .. note::

           If you want to locate a match anywhere in *string*, use
           :meth:`~RegexObject.search` instead.

        The optional second parameter *pos* gives an index in the string where the
        search is to start; it defaults to ``0``.  This is not completely equivalent to
        slicing the string; the ``'^'`` pattern character matches at the real beginning
        of the string and at positions just after a newline, but not necessarily at the
        index where the search is to start.

        The optional parameter *endpos* limits how far the string will be searched; it
        will be as if the string is *endpos* characters long, so only the characters
        from *pos* to ``endpos - 1`` will be searched for a match.  If *endpos* is less
        than *pos*, no match will be found, otherwise, if *rx* is a compiled regular
        expression object, ``rx.match(string, 0, 50)`` is equivalent to
        ``rx.match(string[:50], 0)``.

           >>> pattern = re.compile("o")
           >>> pattern.match("dog")      # No match as "o" is not at the start of "dog."
           >>> pattern.match("dog", 1)   # Match as "o" is the 2nd character of "dog".
           <_sre.SRE_Match object at ...>

        """
        return MatchObject()

    def search(string, pos=None, endpos=None):
        """Scan through *string* looking for a location where this regular expression
        produces a match, and return a corresponding :class:`MatchObject` instance.
        Return ``None`` if no position in the string matches the pattern; note that this
        is different from finding a zero-length match at some point in the string.

        The optional *pos* and *endpos* parameters have the same meaning as for the
        :meth:`~RegexObject.match` method.
        """

        return MatchObject()

    def split(string, maxsplit=0):
        """Split *string* by the occurrences of *pattern*.

        If capturing parentheses are
        used in *pattern*, then the text of all groups in the pattern are also returned
        as part of the resulting list. If *maxsplit* is nonzero, at most *maxsplit*
        splits occur, and the remainder of the string is returned as the final element
        of the list.  (Incompatibility note: in the original Python 1.5 release,
        *maxsplit* was ignored.  This has been fixed in later releases.)

            >>> re.split('\W+', 'Words, words, words.')
            ['Words', 'words', 'words', '']
            >>> re.split('(\W+)', 'Words, words, words.')
            ['Words', ', ', 'words', ', ', 'words', '.', '']
            >>> re.split('\W+', 'Words, words, words.', 1)
            ['Words', 'words, words.']
        """

    def findall(string, pos=None, endpos=None):
        """Return all non-overlapping matches of *pattern* in *string*, as a list of strings.

        The *string* is scanned left-to-right, and matches are returned in
        the order found.  If one or more groups are present in the pattern, return a
        list of groups; this will be a list of tuples if the pattern has more than
        one group.  Empty matches are included in the result unless they touch the
        beginning of another match.
        """

    def finditer(string, pos=None, endpos=None):
        """Return an :term:`iterator` yielding :class:`MatchObject` instances over all
        non-overlapping matches for the RE *pattern* in *string*.

        The *string* is
        scanned left-to-right, and matches are returned in the order found.  Empty
        matches are included in the result unless they touch the beginning of another
        match.
        """

    def sub(repl, string, count=0):
        r"""Return the string obtained by replacing the leftmost non-overlapping occurrences
        of *pattern* in *string* by the replacement *repl*.  If the pattern isn't found,
        *string* is returned unchanged.  *repl* can be a string or a function; if it is
        a string, any backslash escapes in it are processed.  That is, ``\n`` is
        converted to a single newline character, ``\r`` is converted to a linefeed, and
        so forth.  Unknown escapes such as ``\j`` are left alone.  Backreferences, such
        as ``\6``, are replaced with the substring matched by group 6 in the pattern.
        For example:

          >>> re.sub(r'def\s+([a-zA-Z_][a-zA-Z_0-9]*)\s*\(\s*\):',
          ...        r'static PyObject*\npy_\1(void)\n{',
          ...        'def myfunc():')
          'static PyObject*\npy_myfunc(void)\n{'

        If *repl* is a function, it is called for every non-overlapping occurrence of
        *pattern*.  The function takes a single match object argument, and returns the
        replacement string.  For example:

          >>> def dashrepl(matchobj):
          ...     if matchobj.group(0) == '-': return ' '
          ...     else: return '-'
          >>> re.sub('-{1,2}', dashrepl, 'pro----gram-files')
          'pro--gram files'

        The pattern may be a string or an RE object; if you need to specify regular
        expression flags, you must use a RE object, or use embedded modifiers in a
        pattern; for example, ``sub("(?i)b+", "x", "bbbb BBBB")`` returns ``'x x'``.

        The optional argument *count* is the maximum number of pattern occurrences to be
        replaced; *count* must be a non-negative integer.  If omitted or zero, all
        occurrences will be replaced. Empty matches for the pattern are replaced only
        when not adjacent to a previous match, so ``sub('x*', '-', 'abc')`` returns
        ``'-a-b-c-'``.

        In addition to character escapes and backreferences as described above,
        ``\g<name>`` will use the substring matched by the group named ``name``, as
        defined by the ``(?P<name>...)`` syntax. ``\g<number>`` uses the corresponding
        group number; ``\g<2>`` is therefore equivalent to ``\2``, but isn't ambiguous
        in a replacement such as ``\g<2>0``.  ``\20`` would be interpreted as a
        reference to group 20, not a reference to group 2 followed by the literal
        character ``'0'``.  The backreference ``\g<0>`` substitutes in the entire
        substring matched by the RE.
        """

    def subn(repl, string, count=0):
        """Perform the same operation as :func:`sub`, but return a tuple ``(new_string,
        number_of_subs_made)``.
        """

class MatchObject:
    def __init__(self):
        self.pos = 0
        self.endpos = 0
        self.lastindex = 0
        self.lastgroup = ""
        self.re = RegexObject()
        self.string = ""

    def expand(template):
        """Return the string obtained by doing backslash substitution on the template
        string *template*, as done by the :meth:`~RegexObject.sub` method.  Escapes
        such as ``\n`` are converted to the appropriate characters, and numeric
        backreferences (``\1``, ``\2``) and named backreferences (``\g<1>``,
        ``\g<name>``) are replaced by the contents of the corresponding group.
        """

    def group(*groups):
        """
        Returns one or more subgroups of the match.  If there is a single argument, the
        result is a single string; if there are multiple arguments, the result is a
        tuple with one item per argument. Without arguments, *group1* defaults to zero
        (the whole match is returned). If a *groupN* argument is zero, the corresponding
        return value is the entire matching string; if it is in the inclusive range
        [1..99], it is the string matching the corresponding parenthesized group.  If a
        group number is negative or larger than the number of groups defined in the
        pattern, an :exc:`IndexError` exception is raised. If a group is contained in a
        part of the pattern that did not match, the corresponding result is ``None``.
        If a group is contained in a part of the pattern that matched multiple times,
        the last match is returned.

          >>> m = re.match(r"(\w+) (\w+)", "Isaac Newton, physicist")
          >>> m.group(0)       # The entire match
          'Isaac Newton'
          >>> m.group(1)       # The first parenthesized subgroup.
          'Isaac'
          >>> m.group(2)       # The second parenthesized subgroup.
          'Newton'
          >>> m.group(1, 2)    # Multiple arguments give us a tuple.
          ('Isaac', 'Newton')

        If the regular expression uses the ``(?P<name>...)`` syntax, the *groupN*
        arguments may also be strings identifying groups by their group name.  If a
        string argument is not used as a group name in the pattern, an :exc:`IndexError`
        exception is raised.

        A moderately complicated example:

          >>> m = re.match(r"(?P<first_name>\w+) (?P<last_name>\w+)", "Malcom Reynolds")
          >>> m.group('first_name')
          'Malcom'
          >>> m.group('last_name')
          'Reynolds'

        Named groups can also be referred to by their index:

          >>> m.group(1)
          'Malcom'
          >>> m.group(2)
          'Reynolds'

        If a group matches multiple times, only the last match is accessible:

          >>> m = re.match(r"(..)+", "a1b2c3")  # Matches 3 times.
          >>> m.group(1)                        # Returns only the last match.
          'c3'
        """

    def groups(default=None):
        """
        Return a tuple containing all the subgroups of the match, from 1 up to however
        many groups are in the pattern.  The *default* argument is used for groups that
        did not participate in the match; it defaults to ``None``.  (Incompatibility
        note: in the original Python 1.5 release, if the tuple was one element long, a
        string would be returned instead.  In later versions (from 1.5.1 on), a
        singleton tuple is returned in such cases.)

        For example:

          >>> m = re.match(r"(\d+)\.(\d+)", "24.1632")
          >>> m.groups()
          ('24', '1632')

        If we make the decimal place and everything after it optional, not all groups
        might participate in the match.  These groups will default to ``None`` unless
        the *default* argument is given:

          >>> m = re.match(r"(\d+)\.?(\d+)?", "24")
          >>> m.groups()      # Second group defaults to None.
          ('24', None)
          >>> m.groups('0')   # Now, the second group defaults to '0'.
          ('24', '0')
        """

    def groupdict(default):
        """
        Return a dictionary containing all the *named* subgroups of the match, keyed by
        the subgroup name.  The *default* argument is used for groups that did not
        participate in the match; it defaults to ``None``.  For example:

          >>> m = re.match(r"(?P<first_name>\w+) (?P<last_name>\w+)", "Malcom Reynolds")
          >>> m.groupdict()
          {'first_name': 'Malcom', 'last_name': 'Reynolds'}
        """

        return {}

    def start(group=None):
        """Return the indices of the start and end of the substring matched by *group*;
        *group* defaults to zero (meaning the whole matched substring). Return ``-1`` if
        *group* exists but did not contribute to the match.  For a match object *m*, and
        a group *g* that did contribute to the match, the substring matched by group *g*
        (equivalent to ``m.group(g)``) is ::

          m.string[m.start(g):m.end(g)]

        Note that ``m.start(group)`` will equal ``m.end(group)`` if *group* matched a
        null string.  For example, after ``m = re.search('b(c?)', 'cba')``,
        ``m.start(0)`` is 1, ``m.end(0)`` is 2, ``m.start(1)`` and ``m.end(1)`` are both
        2, and ``m.start(2)`` raises an :exc:`IndexError` exception.

        An example that will remove *remove_this* from email addresses:

          >>> email = "tony@tiremove_thisger.net"
          >>> m = re.search("remove_this", email)
          >>> email[:m.start()] + email[m.end():]
          'tony@tiger.net'
        """

    def end(group=None):
        """see :method:`start`"""

    def span(group=None):
        """For :class:`MatchObject` *m*, return the 2-tuple ``(m.start(group),
        m.end(group))``. Note that if *group* did not contribute to the match, this is
        ``(-1, -1)``.  *group* defaults to zero, the entire match.
        """
########NEW FILE########
__FILENAME__ = utils
import sys
import os
from os.path import exists, join, expanduser, isdir, realpath

environments = {}

def which(binary_name):
    for p in os.environ.get('PATH', '').split(os.pathsep):
        path = join(p, binary_name)
        if exists(path):
            return path

    return None

def get_virtualenvwrapper_root():
    return realpath(os.getenv('WORKON_HOME', expanduser('~/.virtualenvs')))

def get_virtualenvwrapper_executables():
    root = get_virtualenvwrapper_root()
    result = {}
    if exists(root) and isdir(root):
        for p in os.listdir(root):
            epath = join(root, p, 'bin', 'python')
            if exists(epath):
                result[p] = epath

    return result

def get_virtualenvwrapper_executable(name):
    root = get_virtualenvwrapper_root()
    epath = join(root, name, 'bin', 'python')
    if exists(epath):
        return epath

def get_executable(conf):
    name = conf['PYTHON_EXECUTABLE']

    try:
        return conf['PYTHON_EXECUTABLES'][name]
    except KeyError:
        pass

    path = get_virtualenvwrapper_executable(name)
    if path:
        return path

    if name == 'default':
        return sys.executable
    elif name == 'python2':
        path = which('python2')
        if path:
            return path
    elif name == 'python3':
        path = which('python3')
        if path:
            return path

    return sys.executable

def get_env(conf):
    executable = get_executable(conf)

    try:
        env = environments[executable]
    except KeyError:
        import supplement.remote
        env = environments[executable] = supplement.remote.Environment(
            executable, conf['PYTHON_EXECUTABLE_ENV'])

    return env

def close_envs():
    for v in environments.values():
        v.close()

########NEW FILE########
__FILENAME__ = ipython_view
# -*- coding: utf-8 -*-

# this file is a modified version of source code from the Accerciser project
# http://live.gnome.org/accerciser

"""
Backend to the console plugin.

@author: Eitan Isaacson
@organization: IBM Corporation
@copyright: Copyright (c) 2007 IBM Corporation
@license: BSD

All rights reserved. This program and the accompanying materials are made
available under the terms of the BSD which accompanies this distribution, and
is available at U{http://www.opensource.org/licenses/bsd-license.php}
"""

import gtk
import re
import sys
import os
import pango
import subprocess
from StringIO import StringIO
import re

try:
    import IPython
except Exception, e:
    raise ImportError('Error importing IPython (%s)' % str(e))

ansi_colors = {
    '0;30': 'Black',
    '0;31': 'Red',
    '0;32': 'Green',
    '0;33': 'Brown',
    '0;34': 'Blue',
    '0;35': 'Purple',
    '0;36': 'Cyan',
    '0;37': 'LightGray',
    '1;30': 'DarkGray',
    '1;31': 'DarkRed',
    '1;32': 'SeaGreen',
    '1;33': 'Yellow',
    '1;34': 'LightBlue',
    '1;35': 'MediumPurple',
    '1;36': 'LightCyan',
    '1;37': 'White',
    }


init_space_re = re.compile(r'^([\s\t]*)')

def process_gap_indent(lines):
    '''
    Add proper indentation to the blank lines between blocks
    '''
    last_indent = ''
    for l in lines[:-1]:
        l = l.rstrip()
        if not l:
            l = last_indent
        else:
            last_indent = init_space_re.match(l).group(1)
        yield l
    yield lines[-1]

class IterableIPShell:

    def __init__(
        self,
        argv=None,
        user_ns=None,
        user_global_ns=None,
        cin=None,
        cout=None,
        cerr=None,
        input_func=None,
        ):

        if input_func:
            IPython.iplib.raw_input_original = input_func
        if cin:
            IPython.Shell.Term.cin = cin
        if cout:
            IPython.Shell.Term.cout = cout
        if cerr:
            IPython.Shell.Term.cerr = cerr

        if argv is None:
            argv = []

        # This is to get rid of the blockage that occurs during
        # IPython.Shell.InteractiveShell.user_setup()
        IPython.iplib.raw_input = lambda x: None

        self.interrupt_in_last_line = False

        orig_stdout = sys.stdout
        orig_stderr = sys.stderr
        sys.stdout = IPython.Shell.Term.cout
        sys.stderr = IPython.Shell.Term.cerr
        try:
            self.term = IPython.genutils.IOTerm(cin=cin, cout=cout,
                    cerr=cerr)
            os.environ['TERM'] = 'dumb'
            excepthook = sys.excepthook

            self.IP = IPython.Shell.make_IPython(argv, user_ns=user_ns,
                    user_global_ns=user_global_ns, embedded=True,
                    shell_class=IPython.Shell.InteractiveShell)
            self.IP.system = lambda cmd: \
                self.shell(self.IP.var_expand(cmd),
                           header='IPython system call: ',
                           verbose=self.IP.rc.system_verbose)
            self.IP.api.system = self.IP.system
            sys.excepthook = excepthook
            self.iter_more = 0
            self.initHistoryIndex()
            self.complete_sep = re.compile('[\s\{\}\[\]\(\)]')
            self.prompt = str(self.IP.outputcache.prompt1).strip()
        finally:
            sys.stdout = orig_stdout
            sys.stderr = orig_stderr

    def execute(self):
        orig_stdout = sys.stdout
        orig_stderr = sys.stderr
        sys.stdout = IPython.Shell.Term.cout
        sys.stderr = IPython.Shell.Term.cerr

        try:
            lines = self.IP.raw_input(None, self.iter_more).split('\n')
            for line in process_gap_indent(lines):
                try:
                    if self.IP.autoindent:
                        self.IP.readline_startup_hook(None)
                except KeyboardInterrupt:
                    self.IP.write('KeyboardInterrupt\n')
                    self.IP.resetbuffer()

                    # keep cache in sync with the prompt counter:
                    self.IP.outputcache.prompt_count -= 1

                    if self.IP.autoindent:
                        self.IP.indent_current_nsp = 0
                    self.iter_more = 0
                    self.interrupt_in_last_line = True
                except:
                    self.IP.showtraceback()
                    self.interrupt_in_last_line = True
                else:
                    self.iter_more = self.IP.push(line)
                    if self.IP.SyntaxTB.last_syntax_error \
                        and self.IP.rc.autoedit_syntax:
                        self.IP.edit_syntax_error()
                    if self.IP.SyntaxTB.last_syntax_error \
                        or self.iter_more is None:
                        self.interrupt_in_last_line = True
                    else:
                        self.interrupt_in_last_line = False

                    if self.iter_more:
                        self.prompt = \
                            str(self.IP.outputcache.prompt2).strip()
                        if self.IP.autoindent:
                            self.IP.readline_startup_hook(self.IP.pre_readline)
                    else:
                        self.prompt = \
                            str(self.IP.outputcache.prompt1).strip()
                        self.IP.indent_current_nsp = 0
                        if self._getRawHistoryList() \
                            and self._getRawHistoryList()[-1]:
                            self.commandProcessed(self._getRawHistoryList()[-1])
                if self.interrupt_in_last_line:
                    break
        finally:
            sys.stdout = orig_stdout
            sys.stderr = orig_stderr

    def commandProcessed(self, command):
        pass

    def historyBack(self):
        history = ''
        # the below while loop is used to suppress empty history lines
        while (history == '' or history == '\n') \
            and self._history_level > 0:
            if self._history_level >= 1:
                self._history_level -= 1
            history = self._getHistory()
        return history

    def historyForward(self):
        history = ''
        # the below while loop is used to suppress empty history lines
        while (history == '' or history == '\n') \
            and self._history_level <= self._getHistoryMaxIndex():
            if self._history_level < self._getHistoryMaxIndex():
                self._history_level += 1
                history = self._getHistory()
            else:
                if self._history_level == self._getHistoryMaxIndex():
                    history = self._getHistory()
                    self._history_level += 1
                else:
                    history = ''
        return history

    def initHistoryIndex(self):
        self._history_level = self._getHistoryMaxIndex() + 1

    def _getRawHistoryList(self):
        return self.IP.input_hist_raw

    def _getHistoryMaxIndex(self):
        return len(self._getRawHistoryList()) - 1

    def _getHistory(self):
        rv = self.IP.input_hist_raw[self._history_level].strip('\n')
        return rv

    def updateNamespace(self, ns_dict):
        self.IP.user_ns.update(ns_dict)

    def complete(self, line):
        split_line = self.complete_sep.split(line)
        possibilities = self.IP.complete(split_line[-1])
        if possibilities:
            common_prefix = reduce(self._commonPrefix, possibilities)
            completed = line[:-len(split_line[-1])] + common_prefix
        else:
            completed = line
        return completed, possibilities

    def _commonPrefix(self, str1, str2):
        for i in range(len(str1)):
            if not str2.startswith(str1[:i + 1]):
                return str1[:i]
        return str1

    def shell(
        self,
        cmd,
        verbose=0,
        debug=0,
        header='',
        ):

        # stat = 0
        if verbose or debug:
            print header + cmd

        # flush stdout so we don't mangle python's buffering
        if not debug:
            # input, output = os.popen4(cmd)
            p = subprocess.Popen(
                cmd,
                shell=True,
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                close_fds=True,
                )
            input, output = p.stdin, p.stdout
            print output.read()
            output.close()
            input.close()


class ConsoleView(gtk.TextView):

    def __init__(self):
        gtk.TextView.__init__(self)
        self.modify_font(pango.FontDescription('Mono'))
        self.modify_base(gtk.STATE_NORMAL,
                         gtk.gdk.color_parse(ansi_colors['0;30']))
        self.modify_text(gtk.STATE_NORMAL,
                         gtk.gdk.color_parse(ansi_colors['0;37']))
        self.set_cursor_visible(True)
        self.text_buffer = self.get_buffer()
        self.mark = self.text_buffer.create_mark('scroll_mark',
                self.text_buffer.get_end_iter(), False)
        for code in ansi_colors:
            self.text_buffer.create_tag(code,
                    foreground=ansi_colors[code], weight=700)
        self.text_buffer.create_tag('0')
        self.text_buffer.create_tag('notouch', editable=False)
        self.color_pat = re.compile('\x01?\x1b\[(.*?)m\x02?')
        self.line_start = self.text_buffer.create_mark('line_start',
                self.text_buffer.get_end_iter(), True)
        self.connect('key-press-event', self._onKeypress)
        self.last_cursor_pos = 0
        self.auto_indent = True

    def write(self, text, editable=False):
        segments = self.color_pat.split(text)
        segment = segments.pop(0)
        start_mark = self.text_buffer.create_mark(None,
                self.text_buffer.get_end_iter(), True)
        self.text_buffer.insert(self.text_buffer.get_end_iter(),
                                segment)

        if segments:
            ansi_tags = self.color_pat.findall(text)
            for tag in ansi_tags:
                i = segments.index(tag)
                if segments[i + 1]:
                    self.text_buffer.insert_with_tags_by_name(self.text_buffer.get_end_iter(),
                            segments[i + 1], tag)
                segments.pop(i)
                segments.pop(i)
        if not editable:
            self.text_buffer.apply_tag_by_name('notouch',
                    self.text_buffer.get_iter_at_mark(start_mark),
                    self.text_buffer.get_end_iter())
        self.text_buffer.delete_mark(start_mark)
        self.scroll_mark_onscreen(self.mark)

    def showPrompt(self, prompt):
        self.write(prompt)
        self.text_buffer.move_mark(self.line_start,
                                   self.text_buffer.get_end_iter())
        if self.auto_indent:
            self.write(' ' * self.IP.indent_current_nsp, editable=True)
        self.text_buffer.place_cursor(self.text_buffer.get_end_iter())

    def changeLine(self, text):
        iter = self.text_buffer.get_end_iter()
        self.text_buffer.delete(self.text_buffer.get_iter_at_mark(self.line_start),
                                iter)
        self.write(text, True)

    def getCurrentLine(self):
        rv = \
            self.text_buffer.get_slice(self.text_buffer.get_iter_at_mark(self.line_start),
                self.text_buffer.get_end_iter(), False)
        return rv

    def showReturned(self, text):
        iter = self.text_buffer.get_iter_at_mark(self.line_start)
        iter.forward_to_line_end()
        self.text_buffer.apply_tag_by_name('notouch',
                self.text_buffer.get_iter_at_mark(self.line_start),
                iter)
        self.write(text)
        if text:
            self.write('\n')
        self.showPrompt(self.prompt)

    def _onKeypress(self, obj, event):
        start_iter = self.text_buffer.get_iter_at_mark(self.line_start)
        if event.keyval == gtk.keysyms.Home:
            self.text_buffer.place_cursor(start_iter)
            return True
        if not event.string:
            return
        insert_mark = self.text_buffer.get_insert()
        insert_iter = self.text_buffer.get_iter_at_mark(insert_mark)
        selection_mark = self.text_buffer.get_selection_bound()
        selection_iter = \
            self.text_buffer.get_iter_at_mark(selection_mark)

        if start_iter.compare(insert_iter) <= 0 \
            and start_iter.compare(selection_iter) <= 0:
            return
        elif start_iter.compare(insert_iter) > 0 \
            and start_iter.compare(selection_iter) > 0:
            self.text_buffer.place_cursor(start_iter)
        elif insert_iter.compare(selection_iter) < 0:
            self.text_buffer.move_mark(insert_mark, start_iter)
        elif insert_iter.compare(selection_iter) > 0:
            self.text_buffer.move_mark(selection_mark, start_iter)

    def cursor_at_last_line(self):
        insert_iter = \
            self.text_buffer.get_iter_at_mark(self.text_buffer.get_insert())
        start_iter = self.text_buffer.get_iter_at_mark(self.line_start)
        return start_iter.compare(insert_iter) <= 0


class IPythonView(ConsoleView, IterableIPShell):

    def __init__(self):
        ConsoleView.__init__(self)
        self.cout = StringIO()
        IterableIPShell.__init__(self, cout=self.cout, cerr=self.cout,
                                 input_func=self.raw_input)
        self.interrupt = False
        self.connect('key_press_event', self.keyPress)
        #self.execute()

        self.cout.truncate(0)
        self.showPrompt(self.prompt)

    def raw_input(self, prompt=''):
        if self.interrupt:
            self.interrupt = False
            raise KeyboardInterrupt
        return self.getCurrentLine()

    def keyPress(self, widget, event):
        if event.state & gtk.gdk.CONTROL_MASK and event.keyval == 99:
            self.interrupt = True
            self._processLine()
            return True
        elif event.keyval == gtk.keysyms.Return:
            self._processLine()
            return True
        elif not event.state & gtk.gdk.CONTROL_MASK \
            and self.cursor_at_last_line() and event.keyval \
            == gtk.keysyms.Up:
            self.changeLine(self.historyBack())
            return True
        elif not event.state & gtk.gdk.CONTROL_MASK \
            and self.cursor_at_last_line() and event.keyval \
            == gtk.keysyms.Down:
            self.changeLine(self.historyForward())
            return True
        elif event.keyval == gtk.keysyms.Tab:
            if not self.getCurrentLine().strip():
                return False
            completed, possibilities = \
                self.complete(self.getCurrentLine())
            if len(possibilities) > 1:
                slice = self.getCurrentLine()
                self.write('\n')
                for symbol in possibilities:
                    self.write(symbol + '\n')
                self.showPrompt(self.prompt)
            self.changeLine(completed or slice)
            return True

    def _processLine(self):
        self.write('\n')
        self.execute()
        rv = self.cout.getvalue()
        if rv:
            rv = rv.strip('\n')
        self.showReturned(rv)
        self.cout.truncate(0)
        self.initHistoryIndex()



########NEW FILE########
__FILENAME__ = executor
import sys
import gc
import ast
import types
import code
import StringIO

from pickle import dumps


class Namespace(object):
    def __init__(self):
        self.data = {}

    def __getitem__(self, name):
        return self.data[name]

    def __setitem__(self, name, value):
        self.data[name] = value


class Interpreter(code.InteractiveInterpreter):
    def __init__(self):
        code.InteractiveInterpreter.__init__(self)
        self.buffer = StringIO.StringIO()

    def execute(self, source, lineno=None):
        oldstdout = sys.stdout
        oldstderr = sys.stderr
        sys.stdout = self.buffer
        sys.stderr = self.buffer
        try:
            tree = ast.parse(source, '<repl>', 'exec')
            if lineno:
                ast.increment_lineno(tree, lineno-1)

            for node, etype in break_ast_to_exec_parts(tree):
                result = eval(compile(node, '<repl>', etype), {}, self.locals)
                if etype == 'eval':
                    if result is not None:
                        self.write(repr(result) + '\n')
                    self.locals['___'] = self.locals.get('__', None)
                    self.locals['__'] = self.locals.get('_', None)
                    self.locals['_'] = result

        except SystemExit:
            raise
        except SyntaxError:
            self.showsyntaxerror()
        except:
            self.showtraceback()
        finally:
            sys.stdout = oldstdout
            sys.stderr = oldstderr

    def write(self, data):
        self.buffer.write(data)

    def get_buffer(self):
        data = self.buffer.getvalue()
        self.buffer = StringIO.StringIO()
        return data

def execute(code, globals=None, locals=None):
    root = ast.parse(code, '<repl>', 'exec')
    for n, type in break_ast_to_exec_parts(root):
        eval(compile(n, '<repl>', type), globals, locals)

def break_ast_to_exec_parts(root):
    result = []
    for node in root.body:
        if isinstance(node, ast.Expr):
            n = ast.Expression()
            n.body = node.value
            result.append((n, 'eval'))
        else:
            n = ast.Module()
            n.body = [node]
            result.append((n, 'exec'))

    return result

def patch(package_name, code):
    pkg = sys.modules[package_name]
    old_funcs = {}
    for name, obj in pkg.__dict__.iteritems():
        if isinstance(obj, types.FunctionType):
            old_funcs[name] = obj

    eval(compile(code, pkg.__file__, 'exec'), pkg.__dict__)

    for name, obj in pkg.__dict__.iteritems():
        if isinstance(obj, types.FunctionType):
            if name in old_funcs and obj is not old_funcs[name]:
                replace_code(name, old_funcs[name], obj)

def replace_code(name, old_func, new_func):
    old_closures = {}
    get_closures(old_func, name, old_closures)

    new_closures = {}
    get_closures(new_func, name, new_closures)

    old_consts = {}
    get_consts(old_func, name, old_consts)

    new_consts = {}
    get_consts(new_func, name, new_consts)

    for name in new_consts:
        if name in old_consts:
            for obj in gc.get_referrers(old_consts[name]):
                if isinstance(obj, types.FunctionType):
                    obj.__code__ = new_consts[name]

    old_func.__code__ = new_func.__code__

    for name in new_closures:
        if name in old_closures:
            old_closures[name].__code__ = new_closures[name].__code__

def get_closures(func, name, result):
    if func.__closure__:
        for f in func.__closure__:
            f = f.cell_contents
            if isinstance(f, types.FunctionType):
                fname = name + '.' + f.__name__
                result[fname] = f
                get_closures(f, fname, result)

def get_consts(func, name, result):
    for c in func.__code__.co_consts:
        if isinstance(c, types.CodeType):
            result[name + '.' + c.co_name] = c

def trace(obj, level):
    #print '    ' * level, obj.__code__.co_name, obj, obj.__module__
    if obj.__closure__:
        for f in obj.__closure__:
            f = f.cell_contents
            if isinstance(f, types.FunctionType):
                trace(f, level + 1)


def run_server(project_dir, executable=None, env=None):
    import os.path, time
    from subprocess import Popen
    from multiprocessing.connection import Client, arbitrary_address

    addr = arbitrary_address('AF_UNIX')

    executable = executable or sys.executable
    args = [executable, __file__, addr]

    environ = None
    if env:
        environ = os.environ.copy()
        environ.update(env)

    proc = Popen(args, cwd=project_dir, env=environ)
    start = time.time()
    while not os.path.exists(addr):
        if time.time() - start > 5:
            raise Exception('py.test launching timeout exceed')
        time.sleep(0.01)

    conn = Client(addr)

    return proc, conn


class Server(object):
    def __init__(self, conn):
        self.conn = conn
        self.interpreter = Interpreter()

    def run(self):
        conn = self.conn
        while True:
            if conn.poll(1):
                try:
                    args = conn.recv()
                except EOFError:
                    break
                except Exception:
                    import traceback
                    traceback.print_exc()
                    break

                if args[0] == 'close':
                    conn.close()
                    break
                else:
                    self.interpreter.execute(*args[1:])
                    result = self.interpreter.get_buffer()
                    try:
                        self.conn.send_bytes(dumps(result, 2))
                    except:
                        import traceback
                        traceback.print_exc()


if __name__ == '__main__':
    from multiprocessing.connection import Listener

    listener = Listener(sys.argv[1])
    conn = listener.accept()
    server = Server(conn)
    server.run()

########NEW FILE########
__FILENAME__ = parser
import re

class Snippet(object):
    def __init__(self, snippet, variant):
        self.snippet = snippet
        self.variant = variant
        self.comment = ''
        self.body = []

        if variant:
            self.label = snippet + ' ' + variant
        else:
            self.label = snippet

    def get_body_and_offsets(self, indent=u'', expand_tabs=False, tab_width=4):
        tab_offsets = {}
        insert_offsets = {}
        replaces = {}
        matcher = re.compile(ur'\$\{(\d+)(:(.*?))?\}')

        body = (u'\n' + indent).join(
            s.expandtabs(tab_width) if expand_tabs else s for s in self.body)

        for m in matcher.finditer(body):
            if m.group(3):
                replaces[int(m.group(1))] = m.group(3)

        delta = [0]
        def replace_stops(match):
            idx = int(match.group(1))
            replace = replaces.get(idx, u'')

            start = delta[0] + match.start()
            delta[0] += len(replace) - match.end() + match.start()
            end = delta[0] + match.end()

            tab_offsets[idx] = start, end

            return replace

        def replace_inserts(match):
            idx = int(match.group(1))
            replace = replaces.get(idx, u'')

            start = delta[0] + match.start()
            dt = len(replace) - match.end() + match.start()
            delta[0] += dt
            end = delta[0] + match.end()

            for k, (s, e) in tab_offsets.iteritems():
                if s >= start: s += dt
                if e >= start: e += dt
                tab_offsets[k] = s, e

            insert_offsets.setdefault(idx, []).append((start, end))

            return replace

        body = matcher.sub(replace_stops, body)
        delta[0] = 0
        body = re.sub(ur'\$(\d+)', replace_inserts, body)

        return body, tab_offsets, insert_offsets


def parse_snippets_from(filename):
    pl = ''
    csnippet = None
    snippets = {}
    for l in open(filename).read().decode('utf-8').splitlines():
        if l.startswith('snippet'):
            tag_and_variant = l.split(None, 2)[1:]
            if len(tag_and_variant) == 2:
                tag, variant = tag_and_variant
            else:
                tag, variant = tag_and_variant[0], None
            csnippet = Snippet(tag, variant)
            snippets[csnippet.label] = csnippet
            if pl.startswith('#'):
                csnippet.comment = pl[1:].strip()
        elif l.startswith('\t') and csnippet:
            csnippet.body.append(l[1:])

        pl = l

    return snippets
########NEW FILE########
__FILENAME__ = prefs
import weakref

from uxie.utils import idle, join_to_file_dir, make_missing_dirs, join_to_settings_dir
from uxie.misc import BuilderAware

from snaked.util import set_activate_the_one_item

def on_snippet_saved(editor, ctx):
    from . import existing_snippet_contexts, load_snippets_for

    existing_snippet_contexts[ctx] = editor.uri
    load_snippets_for(ctx)

    editor.message('Snippets were updated')


class PreferencesDialog(BuilderAware):
    """glade-file: prefs.glade"""

    def __init__(self, existing_snippets):
        BuilderAware.__init__(self, join_to_file_dir(__file__, 'prefs.glade'))

        from snaked.core.manager import keymap
        self.activator = keymap.get_activator(self.window)
        self.activator.bind('Escape', self.hide)
        self.activator.bind('<alt>s', self.focus_search)
        self.existing_snippets = existing_snippets

        set_activate_the_one_item(self.search_entry, self.snippets_view)

    def hide(self):
        self.window.destroy()

    def show(self, editor):
        self.editor = weakref.ref(editor)
        self.fill_snippets(None)
        editor.request_transient_for.emit(self.window)
        self.window.show()

    def fill_snippets(self, search):
        self.snippets.clear()
        for name in sorted(self.existing_snippets):
            if not search or search in name:
                self.snippets.append((name,))

    def on_delete_event(self, *args):
        return False

    def on_search_entry_changed(self, *args):
        search = self.search_entry.get_text().strip().lower()
        idle(self.fill_snippets, search)

    def activate(self, *args):
        (model, iter) = self.snippets_view.get_selection().get_selected()
        if iter:
            name = model.get_value(iter, 0)
            self.edit_context(name)
        else:
            self.editor().message('You need select item')

    def focus_search(self):
        self.search_entry.grab_focus()

    def edit_context(self, ctx):
        user_snippet_filename = join_to_settings_dir('snaked', 'snippets', ctx + '.snippets')
        if ctx in self.existing_snippets and \
                self.existing_snippets[ctx] != user_snippet_filename:

            import shutil
            make_missing_dirs(user_snippet_filename)
            shutil.copy(self.existing_snippets[ctx], user_snippet_filename)

        idle(self.hide)
        e = self.editor().open_file(user_snippet_filename)
        e.connect('file-saved', on_snippet_saved, ctx)

    def on_create_snippet_activate(self, button):
        ctx = self.search_entry.get_text()
        if ctx:
            self.edit_context(ctx)
        else:
            self.editor().message('Enter snippet name in search entry', 3000)
########NEW FILE########
__FILENAME__ = signals
import gobject
import gobject.constants
import weakref
from inspect import getmembers, ismethod

from weak import weak_connect
from util import append_attr

SSIGNAL = gobject.SIGNAL_RUN_LAST | gobject.SIGNAL_NO_RECURSE | gobject.SIGNAL_ACTION
SACTION = gobject.SIGNAL_RUN_LAST | gobject.SIGNAL_ACTION

def attach_signal_connect_info(attr, obj, func, after, idle):
    """
    Adds signal connection info to function

    Used by signal and trigger decorators
    """
    connect_params = dict(after=after, idle=idle)

    if func:
        if not getattr(func, '__call__'):
            raise Exception('Signal decorator accept callable or connect params')

        append_attr(func, attr, (obj, connect_params))
        return func
    else:
        def inner(func):
            append_attr(func, attr, (obj, connect_params))
            return func

        return inner

class Signal(object):
    """
    Unbounded signal

    Class holds signal parameters which used to construct correct GObject later.

    Instantiating signals::

        Signal() # Signal without arguments

        Signal(object, int) # Signal with two arguments

        Signal(object, return_type=int) # Signal with return type

        Signal(type=gobject.SIGNAL_RUN_FIRST) # default signal type is gobject.SIGNAL_RUN_LAST | gobject.SIGNAL_NO_RECURSE | gobject.SIGNAL_ACTION


    Unbounded signal instances can be used to mark callbacks for automatic signal connecting::

        signal = Signal()

        class Handler(object):
            @signal
            def callback(...): pass # Usual (in gobject terms) signal connection

            @signal(idle=True)
            def callback(...): pass # Connects signal with idle wrapper

            @signal(after=True)
            def callback(...): pass # sender.connect_after(callback) analog

            @signal(idle=9999)
            def callback(...): pass # idle wrapper will start callback with specified priority
    """

    def __init__(self, *signal_args, **kwargs):
        allowed_named_arguments = set(('type', 'return_type'))
        if not all(r in allowed_named_arguments for r in kwargs.keys()):
            raise Exception('Signal constructor takes only `type` and `return_type` named arguments')

        self.signal_type = kwargs.get('type', SSIGNAL)
        self.return_type = kwargs.get('return_type', None)
        self.arg_types = tuple(signal_args)
        self.name = None

    def __call__(self, func=None, after=False, idle=False):
        return attach_signal_connect_info('signals_to_connect', self, func, after, idle)

    def emit(self):
        """IDE hint"""
        raise Exception('You cannot emit unbounded signals')

    def stop_emission(self):
        """IDE hint"""
        raise Exception('You cannot stop emission of unbounded signals')


class SignalManager(object):
    """
    Wrapper for inner GObject with signals

    Example::

        class Manager(SignalManager):
            show = Signal()
            hide = Signal()

    ``Manager.show`` and ``Manager.hide`` is unbounded signals and can be used as
    decorators to callbacks. Whereas ``instance.show`` and ``instance.hide`` is bounded and
    can be used to emit signals::

        class Plugin(object):
            def __init__(self):
                self.signals = Manager()
                self.signals.connect_signals()

                self.signals.hide.emit()

            @Manager.show
            def show(self, sender):
                pass

    Inner GObject with necessary __gsignals__ is constructed during instance initialization
    """
    registered_classes = {}

    def __new__(cls, *args, **kwargs):
        try:
            newcls = SignalManager.registered_classes[cls]
            obj = newcls.__new__(newcls, *args, **kwargs)
            gobject.GObject.__init__(obj)
            newcls.__init__(obj, *args, **kwargs)

            return obj
        except KeyError:
            pass

        def make_signal_prop(signal):
            def inner(self):
                return BoundedSignal(self, signal)

            return property(inner)

        newdict = dict(cls.__dict__)
        signals = {}
        for sname, signal in cls.__dict__.iteritems():
            if isinstance(signal, Signal):
                signal.name = sname.replace('_', '-')
                signals[signal.name] = (signal.signal_type,
                    signal.return_type, signal.arg_types)

                newdict[sname] = make_signal_prop(signal)

        if not signals:
            return super(SignalManager, cls).__new__(cls, *args, **kwargs)

        newdict['__gsignals__'] = signals
        newdict['weak_connect'] = SignalManager.weak_connect
        newdict['connect_signals'] = SignalManager.connect_signals

        for k, v in newdict.iteritems():
            if hasattr(v, 'im_func'):
                newdict[k] = v.im_func

        newcls = type(cls.__name__, (gobject.GObject,), newdict)
        gobject.type_register(newcls)
        SignalManager.registered_classes[cls] = newcls

        obj = newcls.__new__(newcls, *args, **kwargs)
        gobject.GObject.__init__(obj)
        newcls.__init__(obj, *args, **kwargs)

        return obj

    def connect_signals(self, obj):
        """
        Connects marked object methods
        """
        for attr, value in getmembers(obj.__class__, ismethod):
            for signal, connect_params in getattr(value, 'signals_to_connect', ()):
                id = self.weak_connect(signal, obj, attr, **connect_params)
                append_handler_to_object(obj, attr, id, self, signal.name)

    def weak_connect(self, signal, obj, attr, after, idle):
        """
        Connects unbounded signal

        @param signal: Unbounded signal
        """
        return weak_connect(self, signal.name, obj, attr, after=after, idle=idle)


class BoundedSignal(object):
    """
    This class knows about its GObject wrapper and unbounded signal name

    This allows it to emit signals. Bounded signal weakly connected to its manager so
    you can safely use it in any context
    """
    def __init__(self, manager, signal):
        self.manager = weakref.ref(manager)
        self.signal = signal

    def connect(self, obj, attr, after=False, idle=False):
        manager = self.manager()
        if manager:
            manager.weak_connect(self.signal, obj, attr, after=after, idle=idle)

    def emit(self, *args):
        manager = self.manager()
        if manager:
            return manager.emit(self.signal.name, *args)

    def stop_emission(self):
        manager = self.manager()
        if manager:
            return manager.stop_emission(self.signal.name)

def connect_external(sender_name, signal_name, after=False, idle=False):
    def inner(func):
        return attach_signal_connect_info('external_signals_to_connect',
            (sender_name, signal_name), func, after, idle)

    return inner

def connect_external_signals(obj, **kwargs):
    for attr, value in getmembers(obj.__class__, ismethod):
        for (sender_name, signal_name), connect_params in getattr(value, 'external_signals_to_connect', ()):
            sender = kwargs[sender_name]
            id = weak_connect(sender, signal_name, obj, attr, **connect_params)
            append_handler_to_object(obj, attr, id, sender, signal_name, sender_name)

def append_handler_to_object(obj, attr, handler_id, sender, signal_name, sender_name=None):
    name = attr + '_handler'
    if not hasattr(obj, name):
        setattr(obj, name, HandlerHolder())

    getattr(obj, name).add(handler_id, sender, signal_name, sender_name)

def connect_all(obj, *signal_managers, **external_senders):
    [s.connect_signals(obj) for s in signal_managers]

    if external_senders:
        connect_external_signals(obj, **external_senders)

class Handler(object):
    def __init__(self, handler_id, sender, signal_name, sender_name):
        self.id = handler_id
        self.sender = weakref.ref(sender)
        self.signal_name = signal_name
        self.sender_name = sender_name

    def is_match(self, sender, sender_name, signal_name):
        result = True

        result = result and (sender == None or self.sender() is sender)
        result = result and (sender_name == None or self.sender_name == sender_name)
        result = result and (signal_name == None or self.signal_name == signal_name)

        return result

    def block(self):
        sender = self.sender()
        if sender:
            sender.handler_block(self.id)

    def unblock(self):
        sender = self.sender()
        if sender:
            sender.handler_unblock(self.id)


class HandlerHolder(object):

    def __init__(self):
        self.handlers = []

    def add(self, id, sender, signal_name, sender_name=None):
        self.handlers.append(Handler(id, sender, signal_name, sender_name))

    def block(self):
        try:
            (handler,) = self.handlers
            handler.block()
        except ValueError:
            raise Exception('There are several signals connected to callback')

    def unblock(self):
        try:
            (handler,) = self.handlers
            handler.unblock()
        except ValueError:
            raise Exception('There are several signals connected to callback')

    @property
    def id(self):
        try:
            (handler,) = self.handlers
            return handler.id
        except ValueError:
            raise Exception('There are several signals connected to callback')

    def __call__(self, sender=None, sender_name=None, signal_name=None):
        handler = None
        for h in self.handlers:
            if h.is_match(sender=sender, sender_name=sender_name, signal_name=signal_name):
                if handler:
                    raise Exception('Match returns several handlers')
                else:
                    handler = h

        return handler

########NEW FILE########
__FILENAME__ = util
def append_attr(obj, attr, value):
    """
    Appends value to object attribute
    
    Attribute may be undefined
    
    For example:
        append_attr(obj, 'test', 1)
        append_attr(obj, 'test', 2)
        
        assert obj.test == [1, 2]
    """
    try:
        getattr(obj, attr).append(value)
    except AttributeError:
        setattr(obj, attr, [value])

########NEW FILE########
__FILENAME__ = weak
import weakref
from gobject import idle_add

class WeakCallback(object):
    """
    Weak callback functor which disconnects on real callback deletion
    
    Magic goes here. It allows to skip accurate manual object disposion by brokening
    cyclic reference beetween sender and callback. Let python gc to work.
    
    Also it can wrap callback in idle_add with specified priority.
    
    Important note! Object and its callback attribute are passed separately.
    Because bounded methods are too weak.
    """
    def __init__(self, obj, attr, idle):
        self.wref = weakref.ref(obj)
        self.callback_attr = attr
        self.gobject_token = None
        self.dbus_token = None
        self.idle = idle

    def __call__(self, *args, **kwargs):
        obj = self.wref()
        if obj:
            # object still alive so calling method 
            attr = getattr(obj, self.callback_attr)
            
            if self.idle is False or self.idle is None:
                return attr(*args, **kwargs)
            elif self.idle is True:
                idle_add(attr, *args, **kwargs)
            else:
                idle_add(attr, priority=self.idle, *args, **kwargs)
                    
        elif self.gobject_token:
            sender = args[0]
            sender.disconnect(self.gobject_token)
            self.gobject_token = None
        elif self.dbus_token:
            self.dbus_token.remove()
            self.dbus_token = None
            
        return False


def weak_connect(sender, signal, connector, attr, idle=False, after=False):
    """
    Function to connect some GObject with weak callback
    """
    wc = WeakCallback(connector, attr, idle)
    
    if after:
        wc.gobject_token = sender.connect_after(signal, wc)
    else:
        wc.gobject_token = sender.connect(signal, wc)

    #print "Connected", sender, signal, connector, attr, idle, after

    return wc.gobject_token

########NEW FILE########
__FILENAME__ = pairs_parser
import re

match_start = re.compile(r'"""|\'\'\'|"|\'|\(|\[|\{|\)|\]|\}')
match_quote_end = {
    '"""': re.compile(r'.*?"""'),
    "'''": re.compile(r".*?'''"),
    "'": re.compile(r"'|.*?[^\\]'"),
    '"': re.compile(r'"|.*?[^\\]"'),
}

inverted = {
    ')': '(',
    '}': '{',
    ']': '[',
}

def find_closing_quote_pos(quote, text, start):
    m = match_quote_end[quote].match(text, start)
    if m:
        return m.end()

    return None

def get_brackets(text, cursor):
    start = 0
    open = []
    close = []
    level = None
    while True:
        m = match_start.search(text, start)
        if not m:
            break

        start = m.end()
        bracket = m.group()

        if start > cursor:
            if not open:
                return None, None, None
            elif level is None:
                level = len(open) - 1

        if bracket in ['"""', "'''", '"', "'"]:
            end = find_closing_quote_pos(bracket, text, start)
            if not end:
                return None, None, None
            if level is None and end > cursor:
                return bracket, start, end
            else:
                start = end
        elif bracket in ['(', '[', '{']:
            open.append((bracket, start))
        elif open and bracket in [')', ']', '}']:
            close.append((inverted[bracket], start))

        #print open, close, text, text[4]
        while open and close and open[-1][0] == close[-1][0]:
            br, opos = open.pop()
            br, cpos = close.pop()

            if len(open) == level:
                return br, opos, cpos

    return None, None, None
########NEW FILE########
__FILENAME__ = models
from django.db import models

class Blog(models.Model):
    name = models.TextField()

class Post(models.Model):
    blog = models.ForeignKey(Blog, related_name='bposts')
    body = models.TextField()
    
########NEW FILE########
__FILENAME__ = first
CONST = 2

def simple_func(x):
    return x + CONST

def decorator(func):
    def inner(x):
        return func(x + 1)

    return inner

@decorator
def decorated_func(x):
    return x

@decorator
def another_decorated_func(x):
    return x*x
########NEW FILE########
__FILENAME__ = first
import pytest
import os.path

def test_first():
    pass

def test_second():
    print 'test-second' + '-output'
    assert 2 == 1

@pytest.mark.xfail
def test_third():
    raise NotImplementedError()

def test_fourth():
    os.path.join(None, None)

########NEW FILE########
__FILENAME__ = module_with_errors
def test_test():
    raise NotImplementedError()

Unknown__Builtin
########NEW FILE########
__FILENAME__ = scopetest
import gtk

class Lolwhat(object):
    def star(self):
        pass

    def superstar(self):
        pass

class Trololo(object):
    def eduard(self):
        pass

    def hill(self):
        pass

class ModifiedTrololo(Trololo):
    def anatolievich(self):
        pass

class ModifiedTextView(gtk.TextView):
    def get_buffer(self):
        return gtk.TextBuffer()
########NEW FILE########
__FILENAME__ = test_bracket_matcher
from snaked.util.pairs_parser import get_brackets, find_closing_quote_pos

def test_parentheses_matcher():
    assert get_brackets('foo()\nboo()', 4) == ('(', 4, 5)

    assert get_brackets('foo(1,2, boo(a, b))', 13) == ('(', 13, 18)
    assert get_brackets('foo(1,2, boo(a, b))', 12) == ('(', 4, 19)

    assert get_brackets('foo(a[sas])', 6) == ('[', 6, 10)
    assert get_brackets('foo(a[sas])', 7) == ('[', 6, 10)
    assert get_brackets('foo(a[sas])', 9) == ('[', 6, 10)
    assert get_brackets('foo(a[sas])', 10) == ('(', 4, 11)

    assert get_brackets('foo() = boo()', 5) == (None, None, None)
    assert get_brackets('foo() = boo()', 6) == (None, None, None)
    assert get_brackets('foo() = boo()', 11) == (None, None, None)
    assert get_brackets('foo() = boo()', 12) == ('(', 12, 13)

def test_quotes_matcher():
    assert get_brackets(r'foo(")(\")")', 4) == ('(', 4, 12)
    assert get_brackets(r'foo(")(\")")', 11) == ('(', 4, 12)

    assert get_brackets(r'foo(")(\")")', 5) == ('"', 5, 11)
    assert get_brackets(r'foo(")(\")")', 6) == ('"', 5, 11)
    assert get_brackets(r"foo(')(\')')", 10) == ("'", 5, 11)

def test_triple_quotes_matcher():
    assert get_brackets(r'foo("""()""")', 4) == ('(', 4, 13)
    assert get_brackets(r'foo("""()""")', 7) == ('"""', 7, 12)
    assert get_brackets(r"foo('''()''')", 9) == ("'''", 7, 12)

def test_close_quote():
    assert find_closing_quote_pos("'", "sss '' ddd '", 5) == 6
    assert find_closing_quote_pos("'", "sss '\dfg' ddd '", 5) == 10

########NEW FILE########
__FILENAME__ = test_djangohints
from ropetest import testutils
from rope.contrib.codeassist import code_assist

from snaked.plugins.python.djangohints import DjangoHintProvider

def get_proposals(project, source, offset=None, **kwargs):
    head = 'from tests.djangotest.models import *\n'
    source = head + source

    if offset is None:
        offset = len(source)
    else:
        offset += len(head)

    return code_assist(project, source, offset, **kwargs)

def pset(proposals):
    return set(p.name for p in proposals)

def pytest_funcarg__project(request):
    project = testutils.sample_project()
    project.pycore.hintdb = DjangoHintProvider(project, 'tests.test_djangohints')
    request.addfinalizer(lambda: testutils.remove_project(project))
    return project

def test_common_field_names_must_be_in_proposals_for_model_instance(project):
    result = pset(get_proposals(project, 'Blog().'))
    assert 'name' in result
    assert 'id' in result
    assert 'bposts' in result

    result = pset(get_proposals(project, 'Post().'))
    assert 'body' in result
    assert 'blog' in result
    assert 'blog_id' in result

def test_proposals_for_objects_finder(project):
    assert 'objects' in pset(get_proposals(project, 'Blog.'))

    result = pset(get_proposals(project, 'Blog.objects.'))
    assert 'all' in result
    assert 'get' in result
    assert 'filter' in result

def test_manager_get_return_type_must_resolve_to_appropriate_model(project):
    result = pset(get_proposals(project, 'Blog.objects.get().'))
    assert 'name' in result
    assert 'id' in result
    assert 'bposts' in result

def test_manager_finder_methods_return_type_must_resolve_to_manager_itself(project):
    result = pset(get_proposals(project, 'Blog.objects.filter().'))
    assert 'filter' in result

    result = pset(get_proposals(project, 'Blog.objects.exclude().'))
    assert 'filter' in result

    result = pset(get_proposals(project, 'Blog.objects.select_related().'))
    assert 'filter' in result

def test_query_set_item_getting_and_iterating_must_resolve_to_model_type(project):
    result = pset(get_proposals(project, 'Blog.objects.all()[0].'))
    assert 'name' in result
    assert 'id' in result
    assert 'bposts' in result

    result = pset(get_proposals(project, 'Blog.objects.filter()[0].'))
    assert 'name' in result
    assert 'id' in result
    assert 'bposts' in result

    result = pset(get_proposals(project, 'for r in Blog.objects.filter():\n    r.'))
    assert 'name' in result
    assert 'id' in result
    assert 'bposts' in result

def test_foreign_fields_must_be_resolved_to_model_type(project):
    result = pset(get_proposals(project, 'Post().blog.'))
    assert 'name' in result
    assert 'id' in result
    assert 'bposts' in result

def test_foreign_set_must_be_resolved_to_model_manager(project):
    result = pset(get_proposals(project, 'Blog().bposts.all()[0].'))
    assert 'body' in result
    assert 'blog' in result
    assert 'blog_id' in result

    result = pset(get_proposals(project, 'for r in Blog().bposts.filter():\n    r.'))
    assert 'body' in result
    assert 'blog' in result
    assert 'blog_id' in result

    result = pset(get_proposals(project,
        'for blog in Blog.objects.filter(name="blog"):\n'
        '   for post in blog.bposts.all():\n'
        '       post.'))
    assert 'body' in result
    assert 'blog' in result
    assert 'blog_id' in result

########NEW FILE########
__FILENAME__ = test_external_tool
import pytest

from snaked.plugins.external_tools.parser import parse, ParseException

data1 = """
#Comment
tool "sphinx _make" for "project-doc" to-console
    cd doc
    make html

tool "sphinx _clean" for "project-doc" to-feedback
    cd doc

    make clean

tool "run" for "python, python-script" from-buffer to-console
    python $FILENAME
"""

def test_external_tool_parsing():
    tools = parse(data1)

    t = tools[0]
    assert t.name == 'sphinx _make'
    assert t.context == ['project-doc']
    assert t.input == None
    assert t.output == 'to-console'
    assert t.script == "    cd doc\n    make html\n"

    t = tools[1]
    assert t.name == 'sphinx _clean'
    assert t.context == ['project-doc']
    assert t.input == None
    assert t.output == 'to-feedback'
    assert t.script == "    cd doc\n\n    make clean\n"

    t = tools[2]
    assert t.name == 'run'
    assert t.context == ['python', 'python-script']
    assert t.input == 'from-buffer'
    assert t.output == 'to-console'
    assert t.script == "    python $FILENAME"

def test_invalid_tool_name_parsing():
    data = """
tool sss
    cd wow
    """

    try:
        parse(data)
        pytest.fail('Must raise ParseException')
    except ParseException, e:
        assert 'tool name' in str(e)

def test_garbage_in_tool_definition():
    data = """
tool "sss" for sss
    cd wow
    """

    try:
        parse(data)
        pytest.fail('Must raise ParseException')
    except ParseException, e:
        assert 'for sss' in str(e)

########NEW FILE########
__FILENAME__ = test_processors
# -*- coding: utf-8 -*-

import gtk

from snaked.core.processors import remove_trailing_spaces

def test_remove_trailing_spaces():
    buffer = gtk.TextBuffer()
    buffer.set_text(u"   \nword слово   \t  \n   \t \n\n   word  слово      """)

    remove_trailing_spaces(buffer)
    text = buffer.get_text(*buffer.get_bounds()).decode('utf-8')
    assert text == u"\nword слово\n\n\n   word  слово"

########NEW FILE########
__FILENAME__ = test_pydochints
from ropetest import testutils
from rope.contrib.codeassist import code_assist
from rope.base.project import NoProject

from snaked.util import join_to_file_dir

from snaked.plugins.python.dochints import DocStringHintProvider

def get_proposals(project, source, offset=None, **kwargs):
    head = 'from scopetest import *\n\n'
    source = head + source

    if offset is None:
        offset = len(source)
    else:
        offset += len(head)

    resource = NoProject().get_file(join_to_file_dir(__file__, 'module.py'))
    resource.read = lambda: ''

    return code_assist(project, source, offset, resource=resource, **kwargs)

def pset(proposals):
    return set(p.name for p in proposals)

def pytest_funcarg__project(request):
    project = testutils.sample_project()
    project.pycore.hintdb = DocStringHintProvider(project)
    request.addfinalizer(lambda: testutils.remove_project(project))
    return project


def test_func_param_hint(project):
    code = '''
def func(param):
    """:type param: Trololo"""
    param.'''

    result = pset(get_proposals(project, code))
    assert 'eduard' in result
    assert 'hill' in result

def test_func_return(project):
    code = '''
def func():
    """:rtype: Lolwhat"""

func().'''

    result = pset(get_proposals(project, code))
    assert 'superstar' in result
    assert 'star' in result

########NEW FILE########
__FILENAME__ = test_pygtkhints
from ropetest import testutils
from rope.contrib.codeassist import code_assist
from rope.base.project import NoProject

from snaked.util import join_to_file_dir
from snaked.plugins.python.pygtkhints import add_gtk_extension_modules, PyGtkHintProvider

def get_proposals(project, source, offset=None, **kwargs):
    head = (
        'class Window(object):\n'
        '   """glade-file: sample.glade"""\n'
        '\n'
        '   def func(self):\n'
        '       '
    )

    source = head + source

    if offset is None:
        offset = len(source)
    else:
        offset += len(head)

    resource = NoProject().get_file(join_to_file_dir(__file__, 'pygtktest', 'module.py'))
    resource.read = lambda: ''

    return code_assist(project, source, offset, resource=resource, **kwargs)

def pset(proposals):
    return set(p.name for p in proposals)

def pytest_funcarg__project(request):
    project = testutils.sample_project()
    add_gtk_extension_modules(project)
    project.pycore.hintdb = PyGtkHintProvider(project)
    project.db = project.pycore.hintdb

    request.addfinalizer(lambda: testutils.remove_project(project))
    return project

def test_class_must_contain_objects_defined_in_glade_file(project):
    result = pset(get_proposals(project, 'self.'))
    assert 'window1' in result
    assert 'vbox1' in result

    result = pset(get_proposals(project, 'self.window1.'))
    assert 'set_title' in result

    result = pset(get_proposals(project, 'self.vbox1.'))
    assert 'pack_start' in result

def test_class_must_contain_objects_defined_in_glade_file_with_external_mapping(project):
    project.db.add_class('module.Window', join_to_file_dir(__file__, 'pygtktest', 'sample2.glade'))

    result = pset(get_proposals(project, 'self.'))
    assert 'window2' in result
    assert 'vbox2' in result

    result = pset(get_proposals(project, 'self.window2.'))
    assert 'set_title' in result

    result = pset(get_proposals(project, 'self.vbox2.'))
    assert 'pack_start' in result

def test_provider_must_resolve_params_of_handlers_defined_in_glade_file(project):
    result = pset(get_proposals(project, 'pass\n\n'
        '   def on_window1_delete_event(self, wnd):\n'
        '       wnd.'))
    assert 'set_title' in result

def test_provider_must_resolve_params_of_handlers_defined_in_glade_file_with_external_map(project):
    project.db.add_class('module.Window', join_to_file_dir(__file__, 'pygtktest', 'sample2.glade'))

    result = pset(get_proposals(project, 'pass\n\n'
        '   def on_window2_delete_event(self, wnd):\n'
        '       wnd.'))
    assert 'set_title' in result

def test_provider_must_allow_to_implement_glade_handlers(project):
    result = pset(get_proposals(project, 'pass\n\n'
        '   def on'))
    assert 'on_window1_delete_event' in result

def test_glib_proposals(project):
    module = project.pycore.get_module('glib')
    assert 'timeout_add' in module
########NEW FILE########
__FILENAME__ = test_pysettings
from snaked.core.prefs import PySettings

def make_settings(**kwargs):
    return PySettings(dict((k, (v, '')) for k,v in kwargs.items()))

def test_prefs_must_return_default_values():
    p = make_settings(key1='key1', key2='key2')
    assert p['key1'] == 'key1'
    assert p['key2'] == 'key2'

def test_prefs_must_return_parent_values():
    p = make_settings(key1='key1', key2='key2')
    pp = PySettings(parent=p)

    p['key1'] = 20

    assert pp['key1'] == 20
    assert pp['key2'] == 'key2'

def test_prefs_must_return_assigned_values():
    p = make_settings(key1='key1', key2='key2')
    p['key1'] = 'key11'
    p['key2'] = None

    assert p['key1'] == 'key11'
    assert p['key2'] == None

def test_prefs_must_provide_its_source():
    p = make_settings(a=True, b=10, c=False)

    p['a'] = False
    p['b'] = 10

    result = p.get_config()

    assert 'a = False' in result
    assert '# b = 10' in result
    assert '# c = False' in result

def test_prefs_parent_config_override():
    p1 = make_settings(a=True, b=10, c=False)
    p2 = PySettings(parent=p1)

    p1['a'] = False

    p1['b'] = 1
    p2['b'] = 10

    p2['c'] = False

    result = p2.get_config()

    assert 'a = False' in result
    assert 'b = 10' in result
    assert '# c = False' in result
########NEW FILE########
__FILENAME__ = test_pytest
import sys
import time

from uxie.utils import join_to_file_dir
from snaked.plugins.python.pytest_launcher import run_test

def collect_results(proc, conn):
    result = []
    while True:
        while conn.poll():
            try:
                data = conn.recv()
                result.append(data)
            except EOFError:
                break

        if proc.poll() is not None:
            conn.close()
            break

        time.sleep(0.1)

    return result

def test_runner_must_return_collected_tests():
    result = collect_results(*run_test(join_to_file_dir(__file__), files=['python_test/first.py']))

    assert result[0][0] == ('START')
    assert result[1] == ('COLLECTED_TESTS', ['python_test/first.py::test_first',
        'python_test/first.py::test_second', 'python_test/first.py::test_third',
        'python_test/first.py::test_fourth'])

def test_runner_must_return_right_status_for_failed_collect():
    result = collect_results(*run_test(join_to_file_dir(__file__),
        files=['python_test/module_with_errors.py']))

    assert result[1][0] == 'FAILED_COLLECT'
    assert result[1][1] == 'python_test/module_with_errors.py'
    assert result[1][3] == [('python_test/module_with_errors.py', 4)]
    assert 'NameError' in result[1][2]

def test_runner_must_return_runned_test_results():
    result = collect_results(*run_test(join_to_file_dir(__file__), files=['python_test/first.py']))
    assert result[2] == ('ITEM_CALL', 'python_test/first.py::test_first')
    assert result[3] == ('PASS', 'python_test/first.py::test_first')

    assert result[6] == ('ITEM_CALL', 'python_test/first.py::test_third')
    assert result[7] == ('SKIP', 'python_test/first.py::test_third')

    assert result[5][:2] == ('FAIL', 'python_test/first.py::test_second')
    assert 'AssertionError' in result[5][2]

    assert result[9][:2] == ('FAIL', 'python_test/first.py::test_fourth')
    assert 'AttributeError' in result[9][2]

def test_runner_must_ignore_skipped_collected_items():
    result = collect_results(*run_test(join_to_file_dir(__file__), None,
        'test_first', files=['python_test/first.py']))

    assert result[1] == ('COLLECTED_TESTS', ['python_test/first.py::test_first'])

def test_runner_must_return_output_of_failed_tests():
    result = collect_results(*run_test(join_to_file_dir(__file__), files=['python_test/first.py'],
        match='test_second'))

    assert 'test-second-output' in result[3][2]
########NEW FILE########
__FILENAME__ = test_python_repl
import sys
from inspect import cleandoc

from snaked.plugins.python_repl.executor import execute, patch, Interpreter

def remove_test_modules():
    try:
        del sys.modules['tests.patcher.first']
    except KeyError:
        pass

def test_simple_statement_execution(capsys):
    code = "x = 5\ny=10\nx + y\n"
    ctx = {}

    execute(code, ctx)

    assert ctx['x'] == 5
    assert ctx['y'] == 10

    out = capsys.readouterr()[0]
    assert out == '15\n'

    code = "'123'\n456"
    execute(code, ctx)
    out = capsys.readouterr()[0]
    assert out == "'123'\n456\n"

def test_trivial_funcs_runtime_code_replace():
    remove_test_modules()
    from tests.patcher.first import simple_func

    result = simple_func(1)
    assert result == 3

    code = '''
def simple_func(x):
    return x + CONST + 1
    '''

    patch('tests.patcher.first', code)

    result = simple_func(1)
    assert result == 4

def test_decorated_funcs_runtime_code_replace():
    remove_test_modules()
    from tests.patcher.first import decorated_func, another_decorated_func

    result = decorated_func(1)
    assert result == 2

    result = another_decorated_func(3)
    assert result == 16

    code = '''
@decorator
def decorated_func(x):
    return x + 1
    '''

    patch('tests.patcher.first', code)

    result = decorated_func(1)
    assert result == 3

    result = another_decorated_func(3)
    assert result == 16

def test_decorator_runtime_code_replace():
    remove_test_modules()
    from tests.patcher.first import decorated_func, another_decorated_func

    result = decorated_func(1)
    assert result == 2

    result = another_decorated_func(3)
    assert result == 16

    code = '''
def decorator(func):
    def inner(x):
        return func(x+3)

    return inner
    '''

    patch('tests.patcher.first', code)

    result = decorated_func(1)
    assert result == 4

    result = another_decorated_func(3)
    assert result == 36

def test_interpreter():
    e = Interpreter()
    e.execute('a = 10; a')
    e.execute('a + 10')
    result = e.get_buffer()
    assert result == '10\n20\n'

    e.execute('a + 20')
    result = e.get_buffer()
    assert result == '30\n'

########NEW FILE########
__FILENAME__ = test_scopehints
from ropetest import testutils
from rope.contrib.codeassist import code_assist
from rope.base.project import NoProject

from snaked.util import join_to_file_dir

from snaked.plugins.python.ropehints import ScopeHintProvider, ReScopeMatcher

def get_proposals(project, source, offset=None, **kwargs):
    head = 'from tests.scopetest import *\n\n'
    source = head + source

    if offset is None:
        offset = len(source)
    else:
        offset += len(head)

    resource = NoProject().get_file(join_to_file_dir(__file__, 'module.py'))
    resource.read = lambda: ''

    return code_assist(project, source, offset, resource=resource, **kwargs)

def pset(proposals):
    return set(p.name for p in proposals)

def pytest_funcarg__project(request):
    project = testutils.sample_project()
    matcher = ReScopeMatcher()
    project.pycore.hintdb = ScopeHintProvider(project, matcher)
    project.db = matcher
    request.addfinalizer(lambda: testutils.remove_project(project))
    return project

def test_func_param_hint(project):
    project.db.add_param_hint('tests\.module\.func$', 'lolwhat$', 'tests.scopetest.Lolwhat()')

    result = pset(get_proposals(project, 'def func(lolwhat):\n    lolwhat.'))
    assert 'superstar' in result
    assert 'star' in result

def test_func_return(project):
    project.db.add_param_hint('tests\.module\.func$', 'return$', 'tests.scopetest.Lolwhat()')
    result = pset(get_proposals(project, 'def func():\n    return None\n\nfunc().'))
    assert 'superstar' in result
    assert 'star' in result

def test_module_attribute(project):
    project.db.add_attribute('re$', 'compile', 'tests.scopetest.Lolwhat()')

    result = pset(get_proposals(project, 'import re\nre.compile.'))
    assert 'superstar' in result
    assert 'star' in result

def test_class_attributes(project):
    project.db.add_attribute('tests\.scopetest\.Lolwhat$', 'trololo', 'tests.scopetest.Trololo()')

    result = pset(get_proposals(project, 'Lolwhat().trololo.'))
    assert 'eduard' in result
    assert 'hill' in result

def test_getting_recursive_attribute(project):
    project.db.add_attribute('tests\.scopetest$', 'Trololo', 'tests.scopetest.ModifiedTrololo')

    result = pset(get_proposals(project, 'Trololo().'))
    assert 'anatolievich' in result

def test_getting_recursive_attribute_from_extension(project):
    project.prefs['extension_modules'] = ['gtk._gtk']

    project.db.add_attribute('gtk$', 'TextView', 'tests.scopetest.ModifiedTextView')

    result = pset(get_proposals(project, 'gtk.TextView().'))
    assert 'set_buffer' in result

    result = pset(get_proposals(project, 'gtk.TextView().get_buffer().'))
    assert 'get_iter_at_mark' in result
########NEW FILE########
__FILENAME__ = test_signals
from snaked.signals import SignalManager, Signal

class Manager(SignalManager):
    get_value = Signal(return_type=object)

def test_multiple_connected_handler_must_be_allowed_to_return_value():
    m = Manager()

    vals = [1, False]

    def f1(m):
        if vals[0]:
            m.stop_emission('get-value')
            return vals[0]

    def f2(m):
        if vals[1]:
            m.stop_emission('get-value')
            return vals[1]

    m.connect('get-value', f1)
    m.connect('get-value', f2)

    val = m.get_value.emit()
    assert val == 1

    vals = [False, 2]
    val = m.get_value.emit()
    assert val == 2

########NEW FILE########
__FILENAME__ = test_snippets
import os.path
ROOT = os.path.dirname(os.path.dirname(__file__))

from snaked.plugins.snippets.parser import parse_snippets_from

python_snippets = os.path.join(ROOT, 'snaked', 'plugins', 'snippets',
    'snippets', 'python.snippets')

def get_slice(body, start, end):
    return body[start:end]

def test_parse_snippets_from():
    result = parse_snippets_from(python_snippets)

    assert 'imp' in result
    assert result['imp'].comment == 'Module import'
    assert result['imp'].snippet == 'imp'
    assert result['imp'].body == ['import ${1:module}']

    assert 'try Try/Except' in result
    assert result['try Try/Except'].snippet == 'try'

    assert 'try Try/Except/Else' in result
    assert result['try Try/Except/Else'].snippet == 'try'

def test_snippet_body_and_offsets():
    result = parse_snippets_from(python_snippets)
    body, stop_offsets, insert_offsets = result['cl'].get_body_and_offsets()

    assert get_slice(body, *stop_offsets[1]) == 'ClassName'
    assert get_slice(body, *stop_offsets[2]) == 'object'
    assert get_slice(body, *stop_offsets[3]) == ''
    assert get_slice(body, *stop_offsets[4]) == 'super(ClassName, self).__init__()'

    assert get_slice(body, *stop_offsets[1]) == 'ClassName'

def test_snippet_body_and_offsets2():
    result = parse_snippets_from(python_snippets)
    body, stop_offsets, insert_offsets = result['try Try/Except'].get_body_and_offsets()

    assert get_slice(body, *stop_offsets[1]) == 'pass'
    assert get_slice(body, *stop_offsets[2]) == 'Exception'
    assert get_slice(body, *stop_offsets[3]) == 'e'
    assert get_slice(body, *stop_offsets[4]) == 'raise e'

    assert get_slice(body, *stop_offsets[3]) == 'e'

def test_snippet_body_and_offsets3(tmpdir):
    snipp = tmpdir.join('snippet')
    snipp.write('''snippet set
\t@${1:propname}.setter
\tdef $1(self, value):
\t\tself._$1 = value''')

    result = parse_snippets_from(str(snipp))
    body, stop_offsets, insert_offsets = result['set'].get_body_and_offsets()

    assert get_slice(body, *stop_offsets[1]) == 'propname'
    assert insert_offsets[1] == [(21, 29), (51, 59)]
########NEW FILE########
__FILENAME__ = test_titler
from snaked.core.titler import create_fsm, add_title_handler

def hempty(name):
    return None

def hid(name):
    return name

def hq(name):
    return '"%s"' % ( name if name else None)

add_title_handler('hid', hid)
add_title_handler('hq', hq)
add_title_handler('hempty', hempty)

def test_simple_handler():
    fsm = create_fsm("%hq")
    result = fsm('aaa')
    assert result == '"aaa"'

def test_no_handler():
    fsm = create_fsm("str")
    result = fsm('aaa')
    assert result == 'str'

def test_alt_handler():
    fsm = create_fsm("{%hid|sss}")

    result = fsm(None)
    assert result == 'sss'

    result = fsm('aaa')
    assert result == 'aaa'

def test_alt_handler_with_additional_symbols():
    fsm = create_fsm("{%hid:|sss}")

    result = fsm(None)
    assert result == 'sss'

    result = fsm('aaa')
    assert result == 'aaa:'

def test_alt_handler_with_empty_section():
    fsm = create_fsm("{%hid|}")

    result = fsm(None)
    assert result == ''

def test_complex():
    fsm = create_fsm("[{%hid-|}%hq/{%hempty|%hid|nop}] RO")

    result = fsm(None)
    assert result == '["None"/nop] RO'

    result = fsm('aaa')
    assert result == '[aaa-"aaa"/aaa] RO'
########NEW FILE########
