__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Velruse documentation build configuration file, created by
# sphinx-quickstart on Fri Apr 30 14:37:53 2010.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os
import pkg_resources

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
parent = os.path.dirname(os.path.dirname(__file__))
sys.path.append(os.path.abspath(parent))

# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = [
    'sphinx.ext.autodoc',
    'sphinx.ext.intersphinx',
    'sphinx.ext.viewcode',
]

intersphinx_mapping = {
    'pyramid': (
        'http://docs.pylonsproject.org/projects/pyramid/en/latest/',
        None),
}

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Velruse'
copyright = u'2010, Ben Bangert'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = pkg_resources.get_distribution('velruse').version
# The full version, including alpha/beta/rc tags.
release = version

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
add_module_names = False

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'default'

html_style = 'default.css'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
# html_sidebars = {'index': 'indexsidebar.html'}

# Additional templates that should be rendered to pages, maps page names to
# template names.
# html_additional_pages = {'index': 'index.html'}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
html_use_opensearch = 'http://velruse.rtfd.org/'

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'Velrusedoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Velruse.tex', u'Velruse Documentation',
   u'Ben Bangert', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
latex_preamble = '''
\usepackage{palatino}
\definecolor{TitleColor}{rgb}{0.7,0,0}
\definecolor{InnerLinkColor}{rgb}{0.7,0,0}
\definecolor{OuterLinkColor}{rgb}{0.8,0,0}
\definecolor{VerbatimColor}{rgb}{0.985,0.985,0.985}
\definecolor{VerbatimBorderColor}{rgb}{0.8,0.8,0.8}
'''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
latex_use_modindex = False


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/': None}

########NEW FILE########
__FILENAME__ = myapp
import requests
from flask import (
    Flask,
    render_template,
    request
)

import velruse.app

from werkzeug.wsgi import DispatcherMiddleware

app = Flask(__name__)
app.config.from_envvar('FLASK_SETTINGS')
app.debug = True


@app.route('/login')
def login():
    return render_template('login.html')


@app.route('/logged_in', methods=['POST'])
def login_callback():
    token = request.form['token']
    payload = {'format': 'json', 'token': token}
    response = requests.get(request.host_url + 'velruse/auth_info', params=payload)
    return render_template('result.html', result=response.json)

velruse = velruse.app.make_app({}, **app.config['VELRUSE'])

application = DispatcherMiddleware(app, {
    '/velruse': velruse,
})

if __name__ == '__main__':
    import os
    from werkzeug.serving import run_simple
    # Bind to PORT if defined, otherwise default to 5000.
    port = int(os.environ.get('PORT', 5020))
    run_simple('0.0.0.0', port, application, use_reloader=True, threaded=True)

########NEW FILE########
__FILENAME__ = tests
import json
import os
import unittest

from nose.plugins.skip import SkipTest

from pyramid.paster import get_app

from selenium import webdriver
from selenium.webdriver.common.alert import Alert
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

from webtest.http import StopableWSGIServer

from velruse.compat import ConfigParser

config = {}
browser = None  # populated in setUpModule
server = None  # populated in setUpModule

def splitlines(s):
    return filter(None, [c.strip()
                         for x in s.splitlines()
                         for c in x.split(', ')])

def setUpModule():
    global browser, server

    inipath = os.path.abspath(
        os.environ.get('TEST_INI', 'test.ini'))
    if not os.path.isfile(inipath):
        raise RuntimeError(
            'Cannot find INI file to setup selenium tests. '
            'Please specify the path via the TEST_INI environment variable '
            'or by adding a test.ini file to the current directory.')

    parser = ConfigParser()
    parser.read(inipath)

    config.update(parser.items('testconfig'))
    config['test_providers'] = splitlines(config['test_providers'])

    app = get_app(inipath)
    port = int(config['app_port'])
    server = StopableWSGIServer.create(app, port=port)

    driver = config.get('selenium.driver', 'firefox')
    browser = {
        'firefox': webdriver.Firefox,
        'chrome': webdriver.Chrome,
        'ie': webdriver.Ie,
    }[driver]()

def tearDownModule():
    if browser is not None:
        browser.quit()
    if server is not None:
        server.shutdown()

class ProviderTests(object):

    @classmethod
    def require_provider(cls, name):
        if name not in config.get('test_providers', []):
            raise SkipTest('tests not enabled for "%s"' % name)

    def setUp(self):
        browser.delete_all_cookies()

def find_login_url(config, key):
    return config.get(key, config['default_login_url'])

class TestFacebook(ProviderTests, unittest.TestCase):
    """
    TODO: look into adding multiple tests using test users with varying
          levels of functionality.

          http://developers.facebook.com/docs/test_users/
    """

    @classmethod
    def setUpClass(cls):
        cls.require_provider('facebook')
        cls.login = config['facebook.login']
        cls.password = config['facebook.password']
        cls.app = config['facebook.app']
        cls.login_url = find_login_url(config, 'facebook.login_url')

    def test_it(self):
        browser.get(self.login_url)
        self.assertEqual(browser.title, 'Auth Page')
        browser.find_element_by_id('facebook').submit()
        self.assertTrue('Facebook' in browser.title)
        form = browser.find_element_by_id('login_form')
        login = form.find_element_by_name('email')
        login.send_keys(self.login)
        passwd = form.find_element_by_name('pass')
        passwd.send_keys(self.password)
        form.submit()
        find_title = EC.title_is('Facebook')
        find_result = EC.presence_of_element_located((By.ID, 'result'))
        WebDriverWait(browser, 2).until(
            lambda driver: find_title(driver) or find_result(driver))
        while browser.title == 'Facebook':
            btn = WebDriverWait(browser, 2).until(
                EC.presence_of_element_located((By.NAME, '__CONFIRM__')))
            btn.click()
            WebDriverWait(browser, 2).until(
                lambda driver: find_title(driver) or find_result(driver))
        result = browser.find_element_by_id('result')
        self.assertEqual(browser.title, 'Result Page')
        result = json.loads(result.text)
        self.assertTrue('profile' in result)
        self.assertTrue('credentials' in result)
        profile = result['profile']
        self.assertTrue('emails' in profile)
        self.assertTrue('displayName' in profile)
        self.assertTrue('accounts' in profile)
        creds = result['credentials']
        self.assertTrue('oauthAccessToken' in creds)

class TestGithub(ProviderTests, unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls.require_provider('github')
        cls.login = config['github.login']
        cls.password = config['github.password']
        cls.app = config['github.app']
        cls.login_url = find_login_url(config, 'github.login_url')

    def test_it(self):
        browser.get(self.login_url)
        self.assertEqual(browser.title, 'Auth Page')
        browser.find_element_by_id('github').submit()
        self.assertEqual(browser.title,
                         b'Sign in \xc2\xb7 GitHub'.decode('utf-8'))
        form = browser.find_element_by_id('login')
        login = form.find_element_by_name('login')
        login.send_keys(self.login)
        passwd = form.find_element_by_name('password')
        passwd.send_keys(self.password)
        form.find_element_by_name('commit').submit()
        find_title = EC.title_is('Authorize access to your account')
        find_result = EC.presence_of_element_located((By.ID, 'result'))
        WebDriverWait(browser, 2).until(
            lambda driver: find_title(driver) or find_result(driver))
        if browser.title == 'Authorize access to your account':
            btn = WebDriverWait(browser, 2).until(
                EC.presence_of_element_located((By.NAME, 'authorize')))
            btn.click()
            result = WebDriverWait(browser, 2).until(
                EC.presence_of_element_located((By.ID, 'result')))
        else:
            result = browser.find_element_by_id('result')
        self.assertEqual(browser.title, 'Result Page')
        result = browser.find_element_by_id('result').text
        result = json.loads(result)
        self.assertTrue('profile' in result)
        self.assertTrue('credentials' in result)
        profile = result['profile']
        self.assertTrue('displayName' in profile)
        self.assertTrue('accounts' in profile)
        creds = result['credentials']
        self.assertTrue('oauthAccessToken' in creds)

class TestTwitter(ProviderTests, unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls.require_provider('twitter')
        cls.login = config['twitter.login']
        cls.password = config['twitter.password']
        cls.app = config['twitter.app']
        cls.login_url = find_login_url(config, 'twitter.login_url')

    def test_it(self):
        browser.get(self.login_url)
        self.assertEqual(browser.title, 'Auth Page')
        browser.find_element_by_id('twitter').submit()
        self.assertEqual(browser.title, 'Twitter / Authorize an application')
        app_info = browser.find_elements_by_class_name('app-info')[0]
        self.assertTrue(self.app in app_info.text)
        form = browser.find_element_by_id('oauth_form')
        login = form.find_element_by_id('username_or_email')
        login.send_keys(self.login)
        passwd = form.find_element_by_id('password')
        passwd.send_keys(self.password)
        form.find_element_by_id('allow').submit()
        result = WebDriverWait(browser, 2).until(
            EC.presence_of_element_located((By.ID, 'result')))
        self.assertEqual(browser.title, 'Result Page')
        result = json.loads(result.text)
        self.assertTrue('profile' in result)
        self.assertTrue('credentials' in result)
        profile = result['profile']
        self.assertTrue('displayName' in profile)
        self.assertTrue('accounts' in profile)
        creds = result['credentials']
        self.assertTrue('oauthAccessToken' in creds)
        self.assertTrue('oauthAccessTokenSecret' in creds)

class TestBitbucket(ProviderTests, unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls.require_provider('bitbucket')
        cls.login = config['bitbucket.login']
        cls.password = config['bitbucket.password']
        cls.app = config['bitbucket.app']
        cls.login_url = find_login_url(config, 'bitbucket.login_url')

    def test_it(self):
        browser.get(self.login_url)
        self.assertEqual(browser.title, 'Auth Page')
        browser.find_element_by_id('bitbucket').submit()
        self.assertEqual(browser.title,
                         b'Log in \xe2\x80\x94 Bitbucket'.decode('utf-8'))
        login = browser.find_element_by_id('id_username')
        login.send_keys(self.login)
        passwd = browser.find_element_by_id('id_password')
        passwd.send_keys(self.password)
        passwd.submit()
        result = WebDriverWait(browser, 2).until(
            EC.presence_of_element_located((By.ID, 'result')))
        self.assertEqual(browser.title, 'Result Page')
        result = json.loads(result.text)
        self.assertTrue('profile' in result)
        self.assertTrue('credentials' in result)
        profile = result['profile']
        self.assertTrue('displayName' in profile)
        self.assertTrue('accounts' in profile)
        creds = result['credentials']
        self.assertTrue('oauthAccessToken' in creds)
        self.assertTrue('oauthAccessTokenSecret' in creds)

class TestGoogleHybrid(ProviderTests, unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls.require_provider('google_hybrid')
        cls.login = config['google_hybrid.login']
        cls.password = config['google_hybrid.password']
        cls.login_url = find_login_url(config, 'google_hybrid.login_url')

    def test_it(self):
        browser.get(self.login_url)
        self.assertEqual(browser.title, 'Auth Page')
        browser.find_element_by_id('google_hybrid').submit()
        login = WebDriverWait(browser, 2).until(
            EC.presence_of_element_located((By.ID, 'Email')))
        self.assertEqual(browser.title, 'Google Accounts')
        login.send_keys(self.login)
        passwd = browser.find_element_by_id('Passwd')
        passwd.send_keys(self.password)
        passwd.submit()
        find_title = EC.title_is('Request for Permission')
        find_result = EC.presence_of_element_located((By.ID, 'result'))
        WebDriverWait(browser, 2).until(
            lambda driver: find_title(driver) or find_result(driver))
        if browser.title == 'Request for Permission':
            btn = WebDriverWait(browser, 2).until(
                EC.element_to_be_clickable(
                    (By.ID, 'submit_approve_access')))
            btn.click()
            result = WebDriverWait(browser, 2).until(
                EC.presence_of_element_located((By.ID, 'result')))
        else:
            result = browser.find_element_by_id('result')
        self.assertEqual(browser.title, 'Result Page')
        result = json.loads(result.text)
        self.assertTrue('profile' in result)
        self.assertTrue('credentials' in result)
        profile = result['profile']
        self.assertTrue('displayName' in profile)
        self.assertTrue('accounts' in profile)
        self.assertTrue('emails' in profile)
        creds = result['credentials']
        self.assertTrue('oauthAccessToken' in creds)
        self.assertTrue('oauthAccessTokenSecret' in creds)

class TestGoogleOAuth2(ProviderTests, unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls.require_provider('google_oauth2')
        cls.login = config['google_oauth2.login']
        cls.password = config['google_oauth2.password']
        cls.login_url = find_login_url(config, 'google_oauth2.login_url')

    def test_it(self):
        browser.get(self.login_url)
        self.assertEqual(browser.title, 'Auth Page')
        browser.find_element_by_id('google_oauth2').submit()
        login = WebDriverWait(browser, 2).until(
            EC.presence_of_element_located((By.ID, 'Email')))
        self.assertEqual(browser.title, 'Google Accounts')
        login.send_keys(self.login)
        passwd = browser.find_element_by_id('Passwd')
        passwd.send_keys(self.password)
        passwd.submit()
        find_title = EC.title_is('Request for Permission')
        find_result = EC.presence_of_element_located((By.ID, 'result'))
        WebDriverWait(browser, 2).until(
            lambda driver: find_title(driver) or find_result(driver))
        if browser.title == 'Request for Permission':
            btn = WebDriverWait(browser, 2).until(
                EC.element_to_be_clickable(
                    (By.ID, 'submit_approve_access')))
            btn.click()
            result = WebDriverWait(browser, 2).until(
                EC.presence_of_element_located((By.ID, 'result')))
        else:
            result = browser.find_element_by_id('result')
        self.assertEqual(browser.title, 'Result Page')
        result = json.loads(result.text)
        self.assertTrue('profile' in result)
        self.assertTrue('credentials' in result)
        profile = result['profile']
        self.assertTrue('displayName' in profile)
        self.assertTrue('accounts' in profile)
        self.assertTrue('emails' in profile)
        creds = result['credentials']
        self.assertTrue('oauthAccessToken' in creds)
        self.assertTrue('oauthRefreshToken' in creds)

class TestYahoo(ProviderTests, unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls.require_provider('yahoo')
        cls.login = config['yahoo.login']
        cls.password = config['yahoo.password']
        cls.login_url = find_login_url(config, 'yahoo.login_url')

    def test_it(self):
        browser.get(self.login_url)
        self.assertEqual(browser.title, 'Auth Page')
        browser.find_element_by_id('yahoo').submit()
        WebDriverWait(browser, 2).until(
            EC.presence_of_element_located((By.ID, 'username')))
        self.assertEqual(browser.title, 'Sign in to Yahoo!')
        login = browser.find_element_by_id('username')
        login.send_keys(self.login)
        passwd = browser.find_element_by_id('passwd')
        passwd.send_keys(self.password)
        passwd.submit()
        # there may be a captcha here, possibly wait for user input???
        find_alert = EC.alert_is_present()
        find_auth_agree = EC.presence_of_element_located((By.ID, 'agree'))
        WebDriverWait(browser, 2).until(
            lambda driver: find_alert(driver) or find_auth_agree(driver))
        auth_agree = browser.find_element_by_id('agree')
        if auth_agree:
            auth_agree.click()
            alert = WebDriverWait(browser, 2).until(EC.alert_is_present())
        else:
            alert = browser.switch_to_alert()
        alert.accept()
        result = WebDriverWait(browser, 5).until(
            EC.presence_of_element_located((By.ID, 'result')))
        self.assertEqual(browser.title, 'Result Page')
        result = json.loads(result.text)
        self.assertTrue('profile' in result)
        self.assertTrue('credentials' in result)
        profile = result['profile']
        self.assertTrue('displayName' in profile)
        self.assertTrue('accounts' in profile)
        self.assertTrue('emails' in profile)
        creds = result['credentials']
        self.assertTrue('oauthAccessToken' in creds)
        self.assertTrue('oauthAccessTokenSecret' in creds)

class TestWindowsLive(ProviderTests, unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls.require_provider('live')
        cls.login = config['live.login']
        cls.password = config['live.password']
        cls.login_url = find_login_url(config, 'live.login_url')

    def test_it(self):
        browser.get(self.login_url)
        self.assertEqual(browser.title, 'Auth Page')
        browser.find_element_by_id('live').submit()
        WebDriverWait(browser, 2).until(
            EC.presence_of_element_located((By.NAME, 'login')))
        self.assertEqual(browser.title,
                         'Sign in to your Microsoft account')
        login = browser.find_element_by_name('login')
        login.send_keys(self.login)
        passwd = browser.find_element_by_name('passwd')
        passwd.send_keys(self.password)
        passwd.submit()
        find_title = EC.title_is('Allow access?')
        find_result = EC.presence_of_element_located((By.ID, 'result'))
        WebDriverWait(browser, 2).until(
            lambda driver: find_title(driver) or find_result(driver))
        if browser.title == 'Allow access?':
            btn = WebDriverWait(browser, 2).until(
                EC.presence_of_element_located((By.NAME, 'submitYes')))
            btn.click()
            result = WebDriverWait(browser, 2).until(
                EC.presence_of_element_located((By.ID, 'result')))
        else:
            result = browser.find_element_by_id('result')
        self.assertEqual(browser.title, 'Result Page')
        result = json.loads(result.text)
        self.assertTrue('profile' in result)
        self.assertTrue('credentials' in result)
        profile = result['profile']
        self.assertTrue('displayName' in profile)
        self.assertTrue('accounts' in profile)
        creds = result['credentials']
        self.assertTrue('oauthAccessToken' in creds)

class TestOpenID(ProviderTests, unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls.require_provider('openid')
        cls.login = config['openid.login']
        cls.password = config['openid.password']
        cls.login_url = find_login_url(config, 'openid.login_url')

    def test_it(self):
        browser.get(self.login_url)
        self.assertEqual(browser.title, 'Auth Page')
        browser.find_element_by_id('openid').submit()
        login = WebDriverWait(browser, 2).until(
            EC.presence_of_element_located((By.NAME, 'user_name')))
        self.assertEqual(browser.title, 'Sign In')
        login.send_keys(self.login)
        passwd = browser.find_element_by_name('password')
        passwd.send_keys(self.password)
        passwd.submit()
        find_alert = EC.alert_is_present()
        find_continue = EC.presence_of_element_located(
            (By.ID, 'continue-button'))
        result = WebDriverWait(browser, 2).until(
            lambda driver: find_alert(driver) or find_continue(driver))
        if isinstance(result, Alert):
            alert = browser.switch_to_alert()
        else:
            result.click()
            alert = WebDriverWait(browser, 2).until(EC.alert_is_present())
        alert.accept()
        result = WebDriverWait(browser, 2).until(
            EC.presence_of_element_located((By.ID, 'result')))
        self.assertEqual(browser.title, 'Result Page')
        result = json.loads(result.text)
        self.assertTrue('profile' in result)
        self.assertTrue('credentials' in result)
        profile = result['profile']
        self.assertTrue('name' in profile)
        self.assertTrue('accounts' in profile)

class TestLinkedin(ProviderTests, unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls.require_provider('linkedin')
        cls.login = config['linkedin.login']
        cls.password = config['linkedin.password']
        cls.login_url = find_login_url(config, 'linkedin.login_url')

    def test_it(self):
        browser.get(self.login_url)
        self.assertEqual(browser.title, 'Auth Page')
        browser.find_element_by_id('linkedin').submit()
        self.assertEqual(browser.title, 'Authorize | LinkedIn')
        form = browser.find_element_by_name('oauthAuthorizeForm')
        login = form.find_element_by_id('session_key-oauthAuthorizeForm')
        login.send_keys(self.login)
        passwd = form.find_element_by_id('session_password-oauthAuthorizeForm')
        passwd.send_keys(self.password)
        form.find_element_by_name('authorize').submit()
        result = WebDriverWait(browser, 2).until(
            EC.presence_of_element_located((By.ID, 'result')))
        self.assertEqual(browser.title, 'Result Page')
        result = json.loads(result.text)
        self.assertTrue('profile' in result)
        self.assertTrue('credentials' in result)
        profile = result['profile']
        self.assertTrue('displayName' in profile)
        self.assertTrue('accounts' in profile)
        # BBB: Linkedin app must be enabled toshare e-mail
        self.assertTrue('emails' in profile)
        creds = result['credentials']
        self.assertTrue('oauthAccessToken' in creds)
        self.assertTrue('oauthAccessTokenSecret' in creds)

########NEW FILE########
__FILENAME__ = test_baseconvert
import unittest


class TestBaseEncoding(unittest.TestCase):

    def test_encode(self):
        from velruse.app.baseconvert import base_encode
        self.assertEqual(base_encode(42), 'L')
        self.assertEqual(base_encode(425242), '4rBC')
        self.assertEqual(base_encode(0), '2')

    def test_bad_encode(self):
        from velruse.app.baseconvert import base_encode
        self.assertRaises(TypeError, base_encode, 'fred')

    def test_decode(self):
        from velruse.app.baseconvert import base_decode
        self.assertEqual(base_decode('L'), 42)
        self.assertEqual(base_decode('4rBC'), 425242)
        self.assertEqual(base_decode('2'), 0)

    def test_bad_decode(self):
        from velruse.app.baseconvert import base_decode
        self.assertRaises(ValueError, base_decode, '381')

########NEW FILE########
__FILENAME__ = test_settings
import unittest

class TestProviderSettings(unittest.TestCase):

    def _makeOne(self, settings, prefix):
        from velruse.settings import ProviderSettings
        return ProviderSettings(settings, prefix=prefix)

    def test_it(self):
        p = self._makeOne({'v.foo': 'bar'}, 'v.')
        p.update('foo')
        self.assertEqual(p.kwargs, {'foo': 'bar'})
        p.update('foo', dst='baz')
        self.assertEqual(p.kwargs, {'foo': 'bar', 'baz': 'bar'})
        self.assertRaises(KeyError, p.update, 'missing', required=True)
        p.update('missing')
        self.assertEqual(p.kwargs, {'foo': 'bar', 'baz': 'bar'})

########NEW FILE########
__FILENAME__ = api
"""Velruse Authentication API"""
from velruse import (
    AuthenticationComplete,
    AuthenticationDenied,
    login_url,
)  # bw compat


def register_provider(config, name, provider):
    """
    Add a provider to the registry. This will also provide conflict
    detection by detecting duplicate provider names.
    """

    def register():
        registry = config.registry

        if not hasattr(registry, 'velruse_providers'):
            providers = {}
            registry.velruse_providers = providers

        registry.velruse_providers[name] = provider

    config.action(('velruse-provider', name), register)

########NEW FILE########
__FILENAME__ = baseconvert
"""String functions to convert a string to another base"""

ALPHABET = "23456789abcdefghijkmnpqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"


def base_encode(num, alphabet=ALPHABET):
    """Encode a number in Base X

    `num`: The number to encode
    `alphabet`: The alphabet to use for encoding
    """
    if (num == 0):
        return alphabet[0]
    arr = []
    base = len(alphabet)
    while num:
        rem = num % base
        num = num // base
        arr.append(alphabet[rem])
    arr.reverse()
    return ''.join(arr)


def base_n_decoder(alphabet=ALPHABET):
    """Decode a Base X encoded string into the number

    Arguments:
    - `string`: The encoded string
    - `alphabet`: The alphabet to use for encoding
    """
    base = len(alphabet)
    char_value = dict(((c, v) for v, c in enumerate(alphabet)))

    def f(string):
        num = 0
        try:
            for char in string:
                num = num * base + char_value[char]
        except KeyError:
            raise ValueError('Unexpected character %r' % char)
        return num
    return f

base_decode = base_n_decoder()

########NEW FILE########
__FILENAME__ = utils
import uuid

from velruse.app.baseconvert import base_encode


def redirect_form(end_point, token):
    """Generate a redirect form for POSTing"""
    return """
<html>
<head>
  <title>OpenID transaction in progress</title>
</head>
<body onload="document.forms[0].submit();">
<form action="%s" method="post" accept-charset="UTF-8"
 enctype="application/x-www-form-urlencoded">
<input type="hidden" name="token" value="%s" />
<input type="submit" value="Continue"/></form>
<script>
var elements = document.forms[0].elements;
for (var i = 0; i < elements.length; i++) {
  elements[i].style.display = "none";
}
</script>
</body>
</html>
""" % (end_point, token)


def generate_token():
    """Generate a random token"""
    return base_encode(uuid.uuid4().int)

########NEW FILE########
__FILENAME__ = compat
try:
    STRING_TYPES = (str, unicode)
except NameError: #pragma NO COVER Python >= 3.0
    STRING_TYPES = (str,)

try:
    u = unicode
except NameError: #pragma NO COVER Python >= 3.0
    TEXT = str
    def u(x, encoding='ascii'):
        if isinstance(x, str):
            return x
        if isinstance(x, bytes):
            return x.decode(encoding)
    b = bytes
else: #pragma NO COVER Python < 3.0
    TEXT = unicode
    b = str

try:
    from ConfigParser import ConfigParser
except ImportError: #pragma NO COVER Python >= 3.0
    from configparser import ConfigParser

try:
    from urlparse import parse_qs
except ImportError:
    from urllib.parse import parse_qs

try:
    from urlparse import parse_qsl
except ImportError:
    from urllib.parse import parse_qsl

try:
    from urllib import urlencode
except ImportError:
    from urllib.parse import urlencode

########NEW FILE########
__FILENAME__ = exceptions
"""Velruse Exceptions"""


class VelruseException(Exception):
    """Base Velruse Exception"""


class MissingParameter(VelruseException):
    """Raised when the login process is missing some parameters needed to
    continue"""


class ThirdPartyFailure(VelruseException):
    """Raised when the third party authentication fails to return expected
    data"""


class CSRFError(VelruseException):
    """Raised when CSRF validation fails"""

########NEW FILE########
__FILENAME__ = bitbucket
"""Bitbucket Authentication Views

http://confluence.atlassian.com/display/BITBUCKET/OAuth+on+Bitbucket
"""
from pyramid.httpexceptions import HTTPFound
from pyramid.security import NO_PERMISSION_REQUIRED

import requests
from requests_oauthlib import OAuth1

from ..api import (
    AuthenticationComplete,
    AuthenticationDenied,
    register_provider,
)
from ..compat import parse_qsl
from ..exceptions import ThirdPartyFailure
from ..settings import ProviderSettings
from ..utils import flat_url


REQUEST_URL = 'https://bitbucket.org/api/1.0/oauth/request_token/'
AUTH_URL = 'https://bitbucket.org/api/1.0/oauth/authenticate/'
ACCESS_URL = 'https://bitbucket.org/api/1.0/oauth/access_token/'
USER_URL = 'https://bitbucket.org/api/1.0/user'
EMAIL_URL = 'https://bitbucket.org/api/1.0/users/{username}/emails'


class BitbucketAuthenticationComplete(AuthenticationComplete):
    """Bitbucket auth complete"""


def includeme(config):
    config.add_directive('add_bitbucket_login', add_bitbucket_login)
    config.add_directive('add_bitbucket_login_from_settings',
                         add_bitbucket_login_from_settings)


def add_bitbucket_login_from_settings(config, prefix='velruse.bitbucket.'):
    settings = config.registry.settings
    p = ProviderSettings(settings, prefix)
    p.update('consumer_key', required=True)
    p.update('consumer_secret', required=True)
    p.update('login_path')
    p.update('callback_path')
    config.add_bitbucket_login(**p.kwargs)


def add_bitbucket_login(config,
                        consumer_key,
                        consumer_secret,
                        login_path='/bitbucket/login',
                        callback_path='/bitbucket/login/callback',
                        name='bitbucket'):
    """
    Add a Bitbucket login provider to the application.
    """
    provider = BitbucketProvider(name, consumer_key, consumer_secret)

    config.add_route(provider.login_route, login_path)
    config.add_view(provider, attr='login', route_name=provider.login_route,
                    permission=NO_PERMISSION_REQUIRED)

    config.add_route(provider.callback_route, callback_path,
                     use_global_views=True,
                     factory=provider.callback)

    register_provider(config, name, provider)


class BitbucketProvider(object):
    def __init__(self, name, consumer_key, consumer_secret):
        self.name = name
        self.type = 'bitbucket'
        self.consumer_key = consumer_key
        self.consumer_secret = consumer_secret

        self.login_route = 'velruse.%s-login' % name
        self.callback_route = 'velruse.%s-callback' % name

    def login(self, request):
        """Initiate a bitbucket login"""
        # grab the initial request token
        oauth = OAuth1(
            self.consumer_key,
            client_secret=self.consumer_secret,
            callback_uri=request.route_url(self.callback_route))
        resp = requests.post(REQUEST_URL, auth=oauth)
        if resp.status_code != 200:
            raise ThirdPartyFailure("Status %s: %s" % (
                resp.status_code, resp.content))
        request_token = dict(parse_qsl(resp.text))

        # store the token for later
        request.session['velruse.token'] = request_token

        # redirect the user to authorize the app
        auth_url = flat_url(AUTH_URL, oauth_token=request_token['oauth_token'])
        return HTTPFound(location=auth_url)

    def callback(self, request):
        """Process the bitbucket redirect"""
        if 'denied' in request.GET:
            return AuthenticationDenied("User denied authentication",
                                        provider_name=self.name,
                                        provider_type=self.type)

        verifier = request.GET.get('oauth_verifier')
        if not verifier:
            raise ThirdPartyFailure("No oauth_verifier returned")

        request_token = request.session.pop('velruse.token')

        # turn our request token into an access token
        oauth = OAuth1(
            self.consumer_key,
            client_secret=self.consumer_secret,
            resource_owner_key=request_token['oauth_token'],
            resource_owner_secret=request_token['oauth_token_secret'],
            verifier=verifier)
        resp = requests.post(ACCESS_URL, auth=oauth)
        if resp.status_code != 200:
            raise ThirdPartyFailure("Status %s: %s" % (
                resp.status_code, resp.content))
        access_token = dict(parse_qsl(resp.text))
        creds = {
            'oauthAccessToken': access_token['oauth_token'],
            'oauthAccessTokenSecret': access_token['oauth_token_secret'],
        }

        # setup oauth for general api calls
        oauth = OAuth1(
            self.consumer_key,
            client_secret=self.consumer_secret,
            resource_owner_key=creds['oauthAccessToken'],
            resource_owner_secret=creds['oauthAccessTokenSecret'])

        # request user profile
        resp = requests.get(USER_URL, auth=oauth)
        if resp.status_code != 200:
            raise ThirdPartyFailure("Status %s: %s" % (
                resp.status_code, resp.content))
        user_data = resp.json()

        data = user_data['user']

        username = data['username']

        # Setup the normalized contact info
        profile = {}
        profile['accounts'] = [{
            'domain': 'bitbucket.com',
            'username': username,
        }]
        profile['preferredUsername'] = username
        name = {}
        first_name = data.get('first_name', '')
        last_name = data.get('last_name', '')
        if first_name or last_name:
            name['formatted'] = u'{0} {1}'.format(first_name, last_name).strip()
        if first_name:
            name['givenName'] = first_name
        if last_name:
            name['familyName'] = last_name
        if name:
            profile['name'] = name
        display_name = name.get('formatted')
        if not display_name:
            display_name = data.get('display_name')
        profile['displayName'] = display_name

        # request user emails
        resp = requests.get(EMAIL_URL.format(username=username), auth=oauth)
        if resp.status_code == 200:
            data = resp.json()
            emails = []
            for item in data:
                email = {'value': item['email']}
                if item.get('primary'):
                    email['primary'] = True
                emails.append(email)
                if item.get('active'):
                    profile['verifiedEmail'] = item['email']
            profile['emails'] = emails

        return BitbucketAuthenticationComplete(profile=profile,
                                               credentials=creds,
                                               provider_name=self.name,
                                               provider_type=self.type)

########NEW FILE########
__FILENAME__ = douban
"""Douban Authentication Views"""
from pyramid.httpexceptions import HTTPFound
from pyramid.security import NO_PERMISSION_REQUIRED

import requests

from ..api import (
    AuthenticationComplete,
    AuthenticationDenied,
    register_provider,
)
from ..exceptions import ThirdPartyFailure
from ..settings import ProviderSettings
from ..utils import flat_url


class DoubanAuthenticationComplete(AuthenticationComplete):
    """Douban auth complete"""


def includeme(config):
    config.add_directive('add_douban_login', add_douban_login)
    config.add_directive('add_douban_login_from_settings',
                         add_douban_login_from_settings)


def add_douban_login_from_settings(config, prefix='velruse.douban.'):
    settings = config.registry.settings
    p = ProviderSettings(settings, prefix)
    p.update('consumer_key', required=True)
    p.update('consumer_secret', required=True)
    p.update('scope')
    p.update('login_path')
    p.update('callback_path')
    config.add_douban_login(**p.kwargs)


def add_douban_login(config,
                     consumer_key,
                     consumer_secret,
                     scope=None,
                     login_path='/login/douban',
                     callback_path='/login/douban/callback',
                     name='douban'):
    """
    Add a Douban login provider to the application.
    """
    provider = DoubanProvider(name, consumer_key, consumer_secret, scope)

    config.add_route(provider.login_route, login_path)
    config.add_view(provider, attr='login', route_name=provider.login_route,
                    permission=NO_PERMISSION_REQUIRED)

    config.add_route(provider.callback_route, callback_path,
                     use_global_views=True,
                     factory=provider.callback)

    register_provider(config, name, provider)


class DoubanProvider(object):
    def __init__(self, name, consumer_key, consumer_secret, scope):
        self.name = name
        self.type = 'douban'
        self.consumer_key = consumer_key
        self.consumer_secret = consumer_secret
        self.scope = scope

        self.login_route = 'velruse.%s-login' % name
        self.callback_route = 'velruse.%s-callback' % name

    def login(self, request):
        """Initiate a douban login"""
        scope = request.POST.get('scope', self.scope)
        url = flat_url('https://www.douban.com/service/auth2/auth',
                       scope=scope,
                       client_id=self.consumer_key,
                       response_type='code',
                       redirect_uri=request.route_url(self.callback_route))
        return HTTPFound(url)

    def callback(self, request):
        """Process the douban redirect"""
        code = request.GET.get('code')
        if not code:
            reason = request.GET.get('error', 'No reason provided.')
            return AuthenticationDenied(reason,
                                        provider_name=self.name,
                                        provider_type=self.type)

        r = requests.post(
            'https://www.douban.com/service/auth2/token',
            dict(client_id=self.consumer_key,
            client_secret=self.consumer_secret,
            grant_type='authorization_code',
            redirect_uri=request.route_url(self.callback_route),
            code=code)
        )
        if r.status_code != 200:
            raise ThirdPartyFailure("Status %s: %s" % (
                r.status_code, r.content))
        token_data = r.json()
        access_token = token_data['access_token']
        refresh_token = token_data.get('refresh_token')
        user_id = token_data['douban_user_id']

        # Retrieve profile data if scopes allow
        profile = {
            'accounts': [{'domain': 'douban.com', 'userid': user_id}],
        }
        user_url = flat_url(
            'https://api.douban.com/v2/user/%s' % user_id,
        )
        r = requests.get(user_url)
        if r.status_code == 200:
            data = r.json()
            profile['displayName'] = data['name']
            profile['preferredUsername'] = data['name']
            profile['avatar'] = data['large_avatar']
            profile['data'] = data

        cred = {'oauthAccessToken': access_token,
                'oauthRefreshToken': refresh_token}

        return DoubanAuthenticationComplete(profile=profile,
                                            credentials=cred,
                                            provider_name=self.name,
                                            provider_type=self.type)

########NEW FILE########
__FILENAME__ = facebook
"""Facebook Authentication Views"""
import datetime
import uuid

from pyramid.httpexceptions import HTTPFound
from pyramid.security import NO_PERMISSION_REQUIRED
import requests

from ..api import (
    AuthenticationComplete,
    AuthenticationDenied,
    register_provider,
)
from ..compat import parse_qsl
from ..exceptions import CSRFError
from ..exceptions import ThirdPartyFailure
from ..settings import ProviderSettings
from ..utils import flat_url


class FacebookAuthenticationComplete(AuthenticationComplete):
    """Facebook auth complete"""


def includeme(config):
    config.add_directive('add_facebook_login', add_facebook_login)
    config.add_directive('add_facebook_login_from_settings',
                         add_facebook_login_from_settings)


def add_facebook_login_from_settings(config, prefix='velruse.facebook.'):
    settings = config.registry.settings
    p = ProviderSettings(settings, prefix)
    p.update('consumer_key', required=True)
    p.update('consumer_secret', required=True)
    p.update('scope')
    p.update('login_path')
    p.update('callback_path')
    config.add_facebook_login(**p.kwargs)


def add_facebook_login(config,
                       consumer_key,
                       consumer_secret,
                       scope=None,
                       login_path='/login/facebook',
                       callback_path='/login/facebook/callback',
                       name='facebook'):
    """
    Add a Facebook login provider to the application.
    """
    provider = FacebookProvider(name, consumer_key, consumer_secret, scope)

    config.add_route(provider.login_route, login_path)
    config.add_view(provider, attr='login', route_name=provider.login_route,
                    permission=NO_PERMISSION_REQUIRED)

    config.add_route(provider.callback_route, callback_path,
                     use_global_views=True,
                     factory=provider.callback)

    register_provider(config, name, provider)


class FacebookProvider(object):
    def __init__(self, name, consumer_key, consumer_secret, scope):
        self.name = name
        self.type = 'facebook'
        self.consumer_key = consumer_key
        self.consumer_secret = consumer_secret
        self.scope = scope
        self.display = 'page'

        self.login_route = 'velruse.%s-login' % name
        self.callback_route = 'velruse.%s-callback' % name

    def login(self, request):
        """Initiate a facebook login"""
        scope = request.POST.get('scope', self.scope)
        display = request.POST.get('display', self.display)
        request.session['velruse.state'] = state = uuid.uuid4().hex
        fb_url = flat_url(
            'https://www.facebook.com/dialog/oauth/',
            scope=scope,
            display=display,
            client_id=self.consumer_key,
            redirect_uri=request.route_url(self.callback_route),
            state=state)
        return HTTPFound(location=fb_url)

    def callback(self, request):
        """Process the facebook redirect"""
        sess_state = request.session.pop('velruse.state', None)
        req_state = request.GET.get('state')
        if not sess_state or sess_state != req_state:
            raise CSRFError(
                'CSRF Validation check failed. Request state {req_state} is '
                'not the same as session state {sess_state}'.format(
                    req_state=req_state,
                    sess_state=sess_state
                )
            )
        code = request.GET.get('code')
        if not code:
            reason = request.GET.get('error_reason', 'No reason provided.')
            return AuthenticationDenied(reason=reason,
                                        provider_name=self.name,
                                        provider_type=self.type)

        # Now retrieve the access token with the code
        access_url = flat_url(
            'https://graph.facebook.com/oauth/access_token',
            client_id=self.consumer_key,
            client_secret=self.consumer_secret,
            redirect_uri=request.route_url(self.callback_route),
            code=code)
        r = requests.get(access_url)
        if r.status_code != 200:
            raise ThirdPartyFailure("Status %s: %s" % (
                r.status_code, r.content))
        access_token = dict(parse_qsl(r.text))['access_token']

        # Retrieve profile data
        graph_url = flat_url('https://graph.facebook.com/me',
                             access_token=access_token)
        r = requests.get(graph_url)
        if r.status_code != 200:
            raise ThirdPartyFailure("Status %s: %s" % (
                r.status_code, r.content))
        fb_profile = r.json()
        profile = extract_fb_data(fb_profile)

        cred = {'oauthAccessToken': access_token}
        return FacebookAuthenticationComplete(profile=profile,
                                              credentials=cred,
                                              provider_name=self.name,
                                              provider_type=self.type)


def extract_fb_data(data):
    """Extact and normalize facebook data as parsed from the graph JSON"""
    # Setup the normalized contact info
    nick = None

    # Setup the nick and preferred username to the last portion of the
    # FB link URL if its not their ID
    link = data.get('link')
    if link:
        last = link.split('/')[-1]
        if last != data['id']:
            nick = last

    profile = {
        'accounts': [{'domain': 'facebook.com', 'userid': data['id']}],
        'displayName': data['name'],
        'preferredUsername': nick or data['name'],
    }
    gender = data.get('gender')
    if gender:
        profile['gender'] = gender
    email = data.get('email')
    if email:
        profile['emails'] = [{'value': email, 'primary': True}]
        if data.get('verified') and email:
            profile['verifiedEmail'] = email

    tz = data.get('timezone')
    if tz:
        # -5.5 -> -05:30
        offset = float(tz)
        h = int(offset)
        m = int(abs(offset - h) * 60)
        profile['utcOffset'] = '{h:+03d}:{m:02d}'.format(h=h, m=m)
    bday = data.get('birthday')
    if bday:
        try:
            mth, day, yr = bday.split('/')
            date = datetime.date(int(yr), int(mth), int(day))
            profile['birthday'] = date.strftime('%Y-%m-%d')
        except ValueError:
            pass
    name = {}
    pcard_map = {'first_name': 'givenName', 'last_name': 'familyName'}
    for key, val in pcard_map.items():
        part = data.get(key)
        if part:
            name[val] = part
    name['formatted'] = data['name']

    profile['name'] = name

    # Now strip out empty values
    for k, v in profile.items():
        if not v or (isinstance(v, list) and not v[0]):
            del profile[k]

    return profile

########NEW FILE########
__FILENAME__ = github
"""Github Authentication Views"""
import uuid

from pyramid.httpexceptions import HTTPFound
from pyramid.security import NO_PERMISSION_REQUIRED

import requests

from ..api import (
    AuthenticationComplete,
    AuthenticationDenied,
    register_provider,
)
from ..compat import parse_qsl
from ..exceptions import CSRFError
from ..exceptions import ThirdPartyFailure
from ..settings import ProviderSettings
from ..utils import flat_url


class GithubAuthenticationComplete(AuthenticationComplete):
    """Github auth complete"""


def includeme(config):
    config.add_directive('add_github_login', add_github_login)
    config.add_directive('add_github_login_from_settings',
                         add_github_login_from_settings)


def add_github_login_from_settings(config, prefix='velruse.github.'):
    settings = config.registry.settings
    p = ProviderSettings(settings, prefix)
    p.update('consumer_key', required=True)
    p.update('consumer_secret', required=True)
    p.update('scope')
    p.update('login_path')
    p.update('callback_path')
    p.update('secure')
    p.update('domain')
    config.add_github_login(**p.kwargs)


def add_github_login(config,
                     consumer_key,
                     consumer_secret,
                     scope=None,
                     login_path='/login/github',
                     callback_path='/login/github/callback',
                     secure=True,
                     domain='github.com',
                     name='github'):
    """
    Add a Github login provider to the application.
    """
    provider = GithubProvider(name,
                              consumer_key,
                              consumer_secret,
                              scope,
                              secure,
                              domain)

    config.add_route(provider.login_route, login_path)
    config.add_view(provider, attr='login', route_name=provider.login_route,
                    permission=NO_PERMISSION_REQUIRED)

    config.add_route(provider.callback_route, callback_path,
                     use_global_views=True,
                     factory=provider.callback)

    register_provider(config, name, provider)


class GithubProvider(object):
    def __init__(self,
                 name,
                 consumer_key,
                 consumer_secret,
                 scope,
                 secure,
                 domain):
        self.name = name
        self.type = 'github'
        self.consumer_key = consumer_key
        self.consumer_secret = consumer_secret
        self.scope = scope
        self.protocol = 'http' if secure is False else 'https'
        self.domain = domain

        self.login_route = 'velruse.%s-login' % name
        self.callback_route = 'velruse.%s-callback' % name

    def login(self, request):
        """Initiate a github login"""
        scope = request.POST.get('scope', self.scope)
        request.session['velruse.state'] = state = uuid.uuid4().hex
        gh_url = flat_url(
            '%s://%s/login/oauth/authorize' % (self.protocol, self.domain),
            scope=scope,
            client_id=self.consumer_key,
            redirect_uri=request.route_url(self.callback_route),
            state=state)
        return HTTPFound(location=gh_url)

    def callback(self, request):
        """Process the github redirect"""
        sess_state = request.session.pop('velruse.state', None)
        req_state = request.GET.get('state')
        if not sess_state or sess_state != req_state:
            raise CSRFError(
                'CSRF Validation check failed. Request state {req_state} is '
                'not the same as session state {sess_state}'.format(
                    req_state=req_state,
                    sess_state=sess_state
                )
            )
        code = request.GET.get('code')
        if not code:
            reason = request.GET.get('error', 'No reason provided.')
            return AuthenticationDenied(reason=reason,
                                        provider_name=self.name,
                                        provider_type=self.type)

        # Now retrieve the access token with the code
        access_url = flat_url(
            '%s://%s/login/oauth/access_token' % (self.protocol, self.domain),
            client_id=self.consumer_key,
            client_secret=self.consumer_secret,
            redirect_uri=request.route_url(self.callback_route),
            code=code)
        r = requests.get(access_url)
        if r.status_code != 200:
            raise ThirdPartyFailure("Status %s: %s" % (
                r.status_code, r.content))
        access_token = dict(parse_qsl(r.text))['access_token']

        # Retrieve profile data
        graph_url = flat_url('%s://api.%s/user' % (self.protocol, self.domain),
                             access_token=access_token)
        graph_headers = dict(Accept='application/vnd.github.v3+json')
        r = requests.get(graph_url, headers=graph_headers)
        if r.status_code != 200:
            raise ThirdPartyFailure("Status %s: %s" % (
                r.status_code, r.content))
        data = r.json()

        profile = {}
        profile['accounts'] = [{
            'domain': self.domain,
            'username': data['login'],
            'userid': data['id']
        }]

        profile['preferredUsername'] = data['login']
        profile['displayName'] = data.get('name', profile['preferredUsername'])

        # We don't add this to verifiedEmail because ppl can change email
        # addresses without verifying them
        if 'email' in data:
            profile['emails'] = [{'value': data['email']}]

        cred = {'oauthAccessToken': access_token}
        return GithubAuthenticationComplete(profile=profile,
                                            credentials=cred,
                                            provider_name=self.name,
                                            provider_type=self.type)

########NEW FILE########
__FILENAME__ = google
"""This module exists as a bw-compat shim for google_hybrid."""
from .google_hybrid import (
    add_google_login,
    GoogleAuthenticationComplete,
)

def includeme(config):
    config.add_directive('add_google_login', add_google_login)

########NEW FILE########
__FILENAME__ = google_hybrid
from __future__ import absolute_import

from openid.extensions import ax

import requests
from requests_oauthlib import OAuth1

from pyramid.security import NO_PERMISSION_REQUIRED

from ..api import register_provider
from ..compat import parse_qsl

from .oid_extensions import OAuthRequest
from .oid_extensions import UIRequest
from .openid import (
    attributes,
    OpenIDAuthenticationComplete,
    OpenIDConsumer,
)


log = __import__('logging').getLogger(__name__)


GOOGLE_OAUTH = 'https://www.google.com/accounts/OAuthGetAccessToken'


class GoogleAuthenticationComplete(OpenIDAuthenticationComplete):
    """Google auth complete"""

def includeme(config):
    """Activate the ``google_hybrid`` Pyramid plugin via
    ``config.include('velruse.providers.google_hybrid')``. After included,
    a new method will be available to configure new providers.

    ``config.add_google_hybrid_login()``
        See :func:`~velruse.providers.google_hybrid.add_google_login`
        for the supported options.

    """
    config.add_directive('add_google_hybrid_login', add_google_login)

def add_google_login(config,
                     attrs=None,
                     realm=None,
                     storage=None,
                     consumer_key=None,
                     consumer_secret=None,
                     scope=None,
                     login_path='/login/google',
                     callback_path='/login/google/callback',
                     name='google'):
    """
    Add a Google login provider to the application using the OpenID+OAuth
    hybrid protocol.  This protocol can be configured for purely
    authentication by specifying only OpenID parameters. If you also wish
    to authorize your application to access the user's information you
    may specify OAuth credentials.

    - OpenID parameters
      + ``attrs``
      + ``realm``
      + ``storage``
    - OAuth parameters
      + ``consumer_key``
      + ``consumer_secret``
      + ``scope``
    """
    provider = GoogleConsumer(
        name,
        attrs,
        realm,
        storage,
        consumer_key,
        consumer_secret,
        scope)

    config.add_route(provider.login_route, login_path)
    config.add_view(provider, attr='login', route_name=provider.login_route,
                    permission=NO_PERMISSION_REQUIRED)

    config.add_route(provider.callback_route, callback_path,
                     use_global_views=True,
                     factory=provider.callback)

    register_provider(config, name, provider)

class GoogleConsumer(OpenIDConsumer):
    openid_attributes = [
        'country', 'email', 'first_name', 'last_name', 'language',
    ]

    def __init__(self, name, attrs=None, realm=None, storage=None,
                 oauth_key=None, oauth_secret=None, oauth_scope=None):
        """Handle Google Auth

        This also handles making an OAuth request during the OpenID
        authentication.

        """
        OpenIDConsumer.__init__(self, name, 'google_hybrid', realm, storage,
                                context=GoogleAuthenticationComplete)
        self.oauth_key = oauth_key
        self.oauth_secret = oauth_secret
        self.oauth_scope = oauth_scope
        if attrs is not None:
            self.openid_attributes = attrs

    def _lookup_identifier(self, request, identifier):
        """Return the Google OpenID directed endpoint"""
        return "https://www.google.com/accounts/o8/id"

    def _update_authrequest(self, request, authrequest):
        """Update the authrequest with Attribute Exchange and optionally OAuth

        To optionally request OAuth, the request POST must include an
        ``oauth_scope`` parameter that indicates what Google Apps should have
        access requested.

        """
        ax_request = ax.FetchRequest()
        for attr in self.openid_attributes:
            ax_request.add(ax.AttrInfo(attributes[attr], required=True))
        authrequest.addExtension(ax_request)

        # Add OAuth request?
        oauth_scope = self.oauth_scope
        if 'oauth_scope' in request.POST:
            oauth_scope = request.POST['oauth_scope']
        if oauth_scope:
            oauth_request = OAuthRequest(consumer=self.oauth_key,
                                         scope=oauth_scope)
            authrequest.addExtension(oauth_request)

        if 'popup_mode' in request.POST:
            kw_args = {'mode': request.POST['popup_mode']}
            if 'popup_icon' in request.POST:
                kw_args['icon'] = request.POST['popup_icon']
            ui_request = UIRequest(**kw_args)
            authrequest.addExtension(ui_request)

    def _update_profile_data(self, request, profile, credentials):
        """Update the user data with profile information from Google Contacts

        This only works if the oauth_scope included access to Google Contacts
        i.e. the scope needs::

            http://www-opensocial.googleusercontent.com/api/people

        """
        if self.oauth_key is None:
            return

        # setup oauth for general api calls
        oauth = OAuth1(
            self.oauth_key,
            client_secret=self.oauth_secret,
            resource_owner_key=credentials['oauthAccessToken'],
            resource_owner_secret=credentials['oauthAccessTokenSecret'])

        profile_url = \
            'https://www-opensocial.googleusercontent.com/api/people/@me/@self'
        resp = requests.get(profile_url, auth=oauth)
        if resp.status_code != 200:
            return
        data = resp.json()
        if 'entry' in data:
            profile.update(data['entry'])

            # Strip out the id and add it as the user id
            profile['accounts'][0]['userid'] = profile.pop('id', None)

    def _get_access_token(self, request_token):
        """Retrieve the access token if OAuth hybrid was used"""
        oauth = OAuth1(
            self.oauth_key,
            client_secret=self.oauth_secret,
            resource_owner_key=request_token)

        resp = requests.post(GOOGLE_OAUTH, auth=oauth)
        if resp.status_code != 200:
            log.error(
                'OAuth token validation failed. Status: %d, Content: %s',
                resp.status_code, resp.content)
        else:
            access_token = dict(parse_qsl(resp.text))
            return {
                'oauthAccessToken': access_token['oauth_token'],
                'oauthAccessTokenSecret': access_token['oauth_token_secret'],
            }

########NEW FILE########
__FILENAME__ = google_oauth2
import uuid

from pyramid.httpexceptions import HTTPFound
from pyramid.security import NO_PERMISSION_REQUIRED

import requests

from ..api import (
    AuthenticationComplete,
    AuthenticationDenied,
    register_provider,
)
from ..exceptions import CSRFError
from ..exceptions import ThirdPartyFailure
from ..settings import ProviderSettings
from ..utils import flat_url


GOOGLE_OAUTH2_DOMAIN = 'accounts.google.com'


class GoogleAuthenticationComplete(AuthenticationComplete):
    """Google OAuth 2.0 auth complete"""

def includeme(config):
    """Activate the ``google_oauth2`` Pyramid plugin via
    ``config.include('velruse.providers.google_oauth2')``. After included,
    two new methods will be available to configure new providers.

    ``config.add_google_oauth2_login()``
        See :func:`~velruse.providers.google_oauth2.add_google_login`
        for the supported options.

    ``config.add_google_oauth2_login_from_settings()``

    """
    config.add_directive('add_google_oauth2_login', add_google_login)
    config.add_directive('add_google_oauth2_login_from_settings',
                         add_google_login_from_settings)

def add_google_login_from_settings(config, prefix='velruse.google.'):
    settings = config.registry.settings
    p = ProviderSettings(settings, prefix)
    p.update('consumer_key', required=True)
    p.update('consumer_secret', required=True)
    p.update('scope')
    p.update('login_path')
    p.update('callback_path')
    config.add_google_oauth2_login(**p.kwargs)

def add_google_login(config,
                     consumer_key=None,
                     consumer_secret=None,
                     scope=None,
                     login_path='/login/google',
                     callback_path='/login/google/callback',
                     name='google'):
    """
    Add a Google login provider to the application supporting the new
    OAuth2 protocol.
    """
    provider = GoogleOAuth2Provider(
        name,
        consumer_key,
        consumer_secret,
        scope)

    config.add_route(provider.login_route, login_path)
    config.add_view(provider, attr='login', route_name=provider.login_route,
                    permission=NO_PERMISSION_REQUIRED)

    config.add_route(provider.callback_route, callback_path,
                     use_global_views=True,
                     factory=provider.callback)

    register_provider(config, name, provider)

class GoogleOAuth2Provider(object):

    profile_scope = 'https://www.googleapis.com/auth/userinfo.profile'
    email_scope = 'https://www.googleapis.com/auth/userinfo.email'

    def __init__(self,
                 name,
                 consumer_key,
                 consumer_secret,
                 scope):
        self.name = name
        self.type = 'google_oauth2'
        self.consumer_key = consumer_key
        self.consumer_secret = consumer_secret
        self.protocol = 'https'
        self.domain = GOOGLE_OAUTH2_DOMAIN

        self.login_route = 'velruse.%s-login' % name
        self.callback_route = 'velruse.%s-callback' % name

        self.scope = scope
        if not self.scope:
            self.scope = ' '.join((self.profile_scope, self.email_scope))

    def login(self, request):
        """Initiate a google login"""
        scope = ' '.join(request.POST.getall('scope')) or self.scope
        request.session['velruse.state'] = state = uuid.uuid4().hex

        approval_prompt = request.POST.get('approval_prompt', 'auto')

        auth_url = flat_url(
            '%s://%s/o/oauth2/auth' % (self.protocol, self.domain),
            scope=scope,
            response_type='code',
            client_id=self.consumer_key,
            redirect_uri=request.route_url(self.callback_route),
            approval_prompt=approval_prompt,
            access_type='offline',
            state=state)
        return HTTPFound(location=auth_url)

    def callback(self, request):
        """Process the google redirect"""
        sess_state = request.session.pop('velruse.state', None)
        req_state = request.GET.get('state')
        if not sess_state or sess_state != req_state:
            raise CSRFError(
                'CSRF Validation check failed. Request state {req_state} is '
                'not the same as session state {sess_state}'.format(
                    req_state=req_state,
                    sess_state=sess_state
                )
            )
        code = request.GET.get('code')
        if not code:
            reason = request.GET.get('error', 'No reason provided.')
            return AuthenticationDenied(reason=reason,
                                        provider_name=self.name,
                                        provider_type=self.type)

        # Now retrieve the access token with the code
        r = requests.post(
            '%s://%s/o/oauth2/token' % (self.protocol, self.domain),
            dict(client_id=self.consumer_key,
                 client_secret=self.consumer_secret,
                 redirect_uri=request.route_url(self.callback_route),
                 code=code,
                 grant_type='authorization_code'),
        )
        if r.status_code != 200:
            raise ThirdPartyFailure("Status %s: %s" % (
                r.status_code, r.content))
        token_data = r.json()
        access_token = token_data['access_token']
        refresh_token = token_data.get('refresh_token')

        # Retrieve profile data if scopes allow
        profile = {}
        user_url = flat_url(
            '%s://www.googleapis.com/oauth2/v1/userinfo' % self.protocol,
            access_token=access_token)
        r = requests.get(user_url)

        if r.status_code == 200:
            data = r.json()
            profile['accounts'] = [{
                'domain': self.domain,
                'username': data['email'],
                'userid': data['id']
            }]
            if 'name' in data:
                profile['displayName'] = data['name']
            else:
                profile['displayName'] = data['email']
            profile['preferredUsername'] = data['email']
            profile['verifiedEmail'] = data['email']
            profile['emails'] = [{'value': data['email']}]

        cred = {'oauthAccessToken': access_token,
                'oauthRefreshToken': refresh_token}
        return GoogleAuthenticationComplete(profile=profile,
                                            credentials=cred,
                                            provider_name=self.name,
                                            provider_type=self.type)

########NEW FILE########
__FILENAME__ = identica_
#XXX This module needs updating to use the patterns in e.g. the 'facebook'
#    provider.
import urlparse

from routes import Mapper
import httplib2
import oauth2 as oauth
import webob.exc as exc

import velruse.utils as utils

log = __import__('logging').getLogger(__name__)

REQUEST_URL = 'https://identi.ca/api/oauth/request_token'
ACCESS_URL = 'https://identi.ca/api/oauth/access_token'
AUTHORIZE_URL = 'https://identi.ca/api/oauth/authorize'


class IdenticaResponder(utils.RouteResponder):
    """Handle Identi.ca OAuth login/authentication"""
    map = Mapper()
    map.connect('login', '/auth', action='login', requirements=dict(method='POST'))
    map.connect('process', '/process', action='process')

    def __init__(self, storage, consumer_key, consumer_secret):
        self.consumer_key = consumer_key
        self.consumer_secret = consumer_secret
        self.storage = storage
        self._consumer = oauth.Consumer(consumer_key, consumer_secret)
        self._sigmethod = oauth.SignatureMethod_HMAC_SHA1()

    @classmethod
    def parse_config(cls, config):
        """Parse config data from a config file"""
        key_map = {'Consumer Key': 'consumer_key', 'Consumer Secret': 'consumer_secret'}
        identica_vals = config['Identica']
        params = {}
        for k, v in key_map.items():
            params[v] = identica_vals[k]
        params['storage'] = config['UserStore']
        return params

    def login(self, req):
        end_point = req.POST['end_point']

        # Create the consumer and client, make the request
        client = oauth.Client(self._consumer)
        params = {'oauth_callback': req.link('process', qualified=True)}

        # We go through some shennanigans here to specify a callback url
        request = oauth.Request.from_consumer_and_token(self._consumer,
            http_url=REQUEST_URL, parameters=params)
        request.sign_request(self._sigmethod, self._consumer, None)
        resp, content = httplib2.Http.request(client, REQUEST_URL, method='GET',
            headers=request.to_header())

        if resp['status'] != '200':
            log.debug("Identi.ca oauth failed: %r %r", resp, content)
            return self._error_redirect(3, end_point)

        request_token = oauth.Token.from_string(content)
        req.session['token'] = content
        req.session['end_point'] = end_point
        req.session.save()

        # Send the user to identica to authorize us
        request = oauth.Request.from_token_and_callback(token=request_token, http_url=AUTHORIZE_URL)
        return exc.HTTPFound(location=request.to_url())

    def process(self, req):
        end_point = req.session['end_point']
        request_token = oauth.Token.from_string(req.session['token'])
        verifier = req.GET.get('oauth_verifier')
        if not verifier:
            return self._error_redirect(1, end_point)
        request_token.set_verifier(verifier)
        client = oauth.Client(self._consumer, request_token)
        resp, content = client.request(ACCESS_URL, "POST")
        if resp['status'] != '200':
            return self._error_redirect(2, end_point)

        access_token = dict(urlparse.parse_qsl(content))

        # Setup the normalized contact info
        profile = {}
        profile['providerName'] = 'Identica'
        profile['displayName'] = access_token['screen_name']
        profile['identifier'] = 'http://identi.ca/%s' % access_token['user_id']

        result_data = {'status': 'ok', 'profile': profile}

        cred = {'oauthAccessToken': access_token['oauth_token'],
                'oauthAccessTokenSecret': access_token['oauth_token_secret']}
        result_data['credentials'] = cred

        return self._success_redirect(result_data, end_point)

########NEW FILE########
__FILENAME__ = lastfm
"""Last.fm Authentication Views"""
from hashlib import md5

from pyramid.httpexceptions import HTTPFound
from pyramid.security import NO_PERMISSION_REQUIRED

import requests

from ..api import (
    AuthenticationComplete,
    AuthenticationDenied,
    register_provider,
)
from ..exceptions import ThirdPartyFailure
from ..settings import ProviderSettings
from ..utils import flat_url

API_BASE = 'https://ws.audioscrobbler.com/2.0/'


class LastFMAuthenticationComplete(AuthenticationComplete):
    """LastFM auth complete"""


def includeme(config):
    config.add_directive('add_lastfm_login', add_lastfm_login)
    config.add_directive('add_lastfm_login_from_settings',
                         add_lastfm_login_from_settings)


def add_lastfm_login_from_settings(config, prefix='velruse.lastfm.'):
    settings = config.registry.settings
    p = ProviderSettings(settings, prefix)
    p.update('consumer_key', required=True)
    p.update('consumer_secret', required=True)
    p.update('login_path')
    p.update('callback_path')
    config.add_lastfm_login(**p.kwargs)


def add_lastfm_login(config,
                     consumer_key,
                     consumer_secret,
                     login_path='/lastfm/login',
                     callback_path='/lastfm/login/callback',
                     name='lastfm'):
    """
    Add a Last.fm login provider to the application.
    """
    provider = LastfmProvider(name, consumer_key, consumer_secret)

    config.add_route(provider.login_route, login_path)
    config.add_view(provider, attr='login', route_name=provider.login_route,
                    permission=NO_PERMISSION_REQUIRED)

    config.add_route(provider.callback_route, callback_path,
                     use_global_views=True,
                     factory=provider.callback)

    register_provider(config, name, provider)


class LastfmProvider(object):
    def __init__(self, name, consumer_key, consumer_secret):
        self.name = name
        self.type = 'lastfm'
        self.consumer_key = consumer_key
        self.consumer_secret = consumer_secret

        self.login_route = 'velruse.%s-login' % name
        self.callback_route = 'velruse.%s-callback' % name

    def login(self, request):
        """Initiate a LastFM login"""
        fb_url = flat_url('https://www.last.fm/api/auth/',
                          api_key=self.consumer_key)
        return HTTPFound(location=fb_url)

    def callback(self, request):
        """Process the LastFM redirect"""
        if 'error' in request.GET:
            raise ThirdPartyFailure(request.GET.get('error_description',
                                    'No reason provided.'))
        token = request.GET.get('token')
        if not token:
            reason = request.GET.get('error_reason', 'No reason provided.')
            return AuthenticationDenied(reason,
                                        provider_name=self.name,
                                        provider_type=self.type)

        # Now establish a session with the token
        params = {
            'method': 'auth.getSession',
            'api_key': self.consumer_key,
            'token': token
        }
        signed_params = sign_call(params, self.consumer_secret)
        session_url = flat_url(API_BASE, format='json', **signed_params)
        r = requests.get(session_url)
        if r.status_code != 200:
            raise ThirdPartyFailure("Status %s: %s" % (
                r.status_code, r.content))
        data = r.json()

        session = data['session']
        cred = {
            'sessionKey': session['key']
        }

        # Fetch the user data
        user_url = flat_url(API_BASE, format='json', method='user.getInfo',
                            user=session['name'], api_key=self.consumer_key)
        r = requests.get(user_url)
        if r.status_code != 200:
            raise ThirdPartyFailure("Status %s: %s" % (
                r.status_code, r.content))
        data = r.json()['user']
        profile = {
            'displayName': data['name'],
            'gender': 'male' if data['gender'] == 'm' else 'female',
            'name': {
                'formatted': data.get('realname'),
            },
            'urls': {
                'type': 'profile',
                'value': data.get('url')
            },
            'photos': [],
            'accounts': [{
                'domain': 'last.fm',
                'username': session['name'],
                'userid': data['id']
            }]
        }
        images = {}
        for img in data.get('image', []):
            images[img['size']] = img['#text']
        if 'medium' in images:
            profile['photos'].append({'type': 'thumbnail',
                                      'value': images['medium']})
        larger = images.get('extralarge', images.get('large'))
        if larger:
            profile['photos'].append({'type': '', 'value': larger})
        return LastFMAuthenticationComplete(profile=profile,
                                            credentials=cred,
                                            provider_name=self.name,
                                            provider_type=self.type)


def sign_call(params, secret):
    pairs = ['%s%s' % (k, params[k]) for k in sorted(params)]
    api_sig = md5(''.join(pairs) + secret).hexdigest()
    signed_params = params.copy()
    signed_params['api_sig'] = api_sig
    return signed_params

########NEW FILE########
__FILENAME__ = linkedin
"""LinkedIn Authentication Views"""
import requests
from requests_oauthlib import OAuth1

from pyramid.httpexceptions import HTTPFound
from pyramid.security import NO_PERMISSION_REQUIRED

from ..api import (
    AuthenticationComplete,
    AuthenticationDenied,
    register_provider,
)
from ..compat import parse_qsl
from ..exceptions import ThirdPartyFailure
from ..settings import ProviderSettings
from ..utils import flat_url


REQUEST_URL = 'https://api.linkedin.com/uas/oauth/requestToken'
AUTH_URL = 'https://api.linkedin.com/uas/oauth/authenticate'
ACCESS_URL = 'https://api.linkedin.com/uas/oauth/accessToken'


class LinkedInAuthenticationComplete(AuthenticationComplete):
    """LinkedIn auth complete"""


def includeme(config):
    config.add_directive('add_linkedin_login', add_linkedin_login)
    config.add_directive('add_linkedin_login_from_settings',
                         add_linkedin_login_from_settings)


def add_linkedin_login_from_settings(config, prefix='velruse.linkedin.'):
    settings = config.registry.settings
    p = ProviderSettings(settings, prefix)
    p.update('consumer_key', required=True)
    p.update('consumer_secret', required=True)
    p.update('login_path')
    p.update('callback_path')
    config.add_linkedin_login(**p.kwargs)


def add_linkedin_login(config,
                       consumer_key,
                       consumer_secret,
                       login_path='/login/linkedin',
                       callback_path='/login/linkedin/callback',
                       name='linkedin'):
    """
    Add a Last.fm login provider to the application.
    """
    provider = LinkedInProvider(name, consumer_key, consumer_secret)

    config.add_route(provider.login_route, login_path)
    config.add_view(provider, attr='login', route_name=provider.login_route,
                    permission=NO_PERMISSION_REQUIRED)

    config.add_route(provider.callback_route, callback_path,
                     use_global_views=True,
                     factory=provider.callback)

    register_provider(config, name, provider)


class LinkedInProvider(object):
    def __init__(self, name, consumer_key, consumer_secret):
        self.name = name
        self.type = 'linked_in'
        self.consumer_key = consumer_key
        self.consumer_secret = consumer_secret

        self.login_route = 'velruse.%s-login' % name
        self.callback_route = 'velruse.%s-callback' % name

    def login(self, request):
        """Initiate a LinkedIn login"""
        # grab the initial request token
        oauth = OAuth1(
            self.consumer_key,
            client_secret=self.consumer_secret,
            callback_uri=request.route_url(self.callback_route))
        resp = requests.post(REQUEST_URL, auth=oauth)
        if resp.status_code != 200:
            raise ThirdPartyFailure("Status %s: %s" % (
                resp.status_code, resp.content))
        request_token = dict(parse_qsl(resp.text))

        # store the token for later
        request.session['velruse.token'] = request_token

        # redirect the user to authorize the app
        auth_url = flat_url(AUTH_URL, oauth_token=request_token['oauth_token'])
        return HTTPFound(location=auth_url)

    def callback(self, request):
        """Process the LinkedIn redirect"""
        if 'denied' in request.GET:
            return AuthenticationDenied("User denied authentication",
                                        provider_name=self.name,
                                        provider_type=self.type)

        verifier = request.GET.get('oauth_verifier')
        if not verifier:
            raise ThirdPartyFailure("No oauth_verifier returned")

        request_token = request.session.pop('velruse.token')

        # turn our request token into an access token
        oauth = OAuth1(
            self.consumer_key,
            client_secret=self.consumer_secret,
            resource_owner_key=request_token['oauth_token'],
            resource_owner_secret=request_token['oauth_token_secret'],
            verifier=verifier)
        resp = requests.post(ACCESS_URL, auth=oauth)
        if resp.status_code != 200:
            raise ThirdPartyFailure("Status %s: %s" % (
                resp.status_code, resp.content))
        access_token = dict(parse_qsl(resp.text))
        creds = {
            'oauthAccessToken': access_token['oauth_token'],
            'oauthAccessTokenSecret': access_token['oauth_token_secret'],
        }

        # setup oauth for general api calls
        oauth = OAuth1(
            self.consumer_key,
            client_secret=self.consumer_secret,
            resource_owner_key=creds['oauthAccessToken'],
            resource_owner_secret=creds['oauthAccessTokenSecret'])

        profile_url = 'http://api.linkedin.com/v1/people/~'
        profile_url += (':(first-name,last-name,id,date-of-birth,picture-url,'
                        'email-address)')
        profile_url += '?format=json'

        resp = requests.get(profile_url, auth=oauth)
        if resp.status_code != 200:
            raise ThirdPartyFailure("Status %s: %s" % (
                resp.status_code, resp.content))
        data = resp.json()

        # Setup the normalized contact info
        profile = {}
        profile['displayName'] = data['firstName'] + data['lastName']
        profile['name'] = {
            'givenName': data['firstName'],
            'familyName': data['lastName'],
            'formatted': u'%s %s' % (data['firstName'], data['lastName'])
        }
        if data.get('emailAddress'):
            profile['emails'] = [{'value': data.get('emailAddress')}]
        if data.get('pictureUrl'):
            profile['photos'] = [{'value': data.get('pictureUrl')}]

        profile['accounts'] = [{
            'domain': 'linkedin.com',
            'userid': data['id']
        }]
        return LinkedInAuthenticationComplete(profile=profile,
                                              credentials=creds,
                                              provider_name=self.name,
                                              provider_type=self.type)

########NEW FILE########
__FILENAME__ = live
"""Live Authentication Views"""
import datetime

from pyramid.httpexceptions import HTTPFound
from pyramid.security import NO_PERMISSION_REQUIRED

import requests

from ..api import (
    AuthenticationComplete,
    AuthenticationDenied,
    register_provider,
)
from ..exceptions import ThirdPartyFailure
from ..settings import ProviderSettings
from ..utils import flat_url


class LiveAuthenticationComplete(AuthenticationComplete):
    """Live Connect auth complete"""


def includeme(config):
    config.add_directive('add_live_login', add_live_login)
    config.add_directive('add_live_login_from_settings',
                         add_live_login_from_settings)


def add_live_login_from_settings(config, prefix='velruse.live.'):
    settings = config.registry.settings
    p = ProviderSettings(settings, prefix)
    p.update('consumer_key', required=True)
    p.update('consumer_secret', required=True)
    p.update('scope')
    p.update('login_path')
    p.update('callback_path')
    config.add_live_login(**p.kwargs)


def add_live_login(config,
                   consumer_key,
                   consumer_secret,
                   scope=None,
                   login_path='/login/live',
                   callback_path='/login/live/callback',
                   name='live'):
    """
    Add a Live login provider to the application.
    """
    provider = LiveProvider(name, consumer_key, consumer_secret, scope)

    config.add_route(provider.login_route, login_path)
    config.add_view(provider, attr='login', route_name=provider.login_route,
                    permission=NO_PERMISSION_REQUIRED)

    config.add_route(provider.callback_route, callback_path,
                     use_global_views=True,
                     factory=provider.callback)

    register_provider(config, name, provider)


class LiveProvider(object):
    def __init__(self, name, consumer_key, consumer_secret, scope):
        self.name = name
        self.type = 'live'
        self.consumer_key = consumer_key
        self.consumer_secret = consumer_secret
        self.scope = scope

        self.login_route = 'velruse.%s-login' % name
        self.callback_route = 'velruse.%s-callback' % name

    def login(self, request):
        """Initiate a Live login"""
        scope = request.POST.get('scope', self.scope or
                                 'wl.basic wl.emails wl.signin')
        fb_url = flat_url('https://oauth.live.com/authorize', scope=scope,
                          client_id=self.consumer_key,
                          redirect_uri=request.route_url(self.callback_route),
                          response_type="code")
        return HTTPFound(location=fb_url)

    def callback(self, request):
        """Process the Live redirect"""
        if 'error' in request.GET:
            raise ThirdPartyFailure(request.GET.get('error_description',
                                    'No reason provided.'))
        code = request.GET.get('code')
        if not code:
            reason = request.GET.get('error_reason', 'No reason provided.')
            return AuthenticationDenied(reason,
                                        provider_name=self.name,
                                        provider_type=self.type)

        # Now retrieve the access token with the code
        access_url = flat_url(
            'https://oauth.live.com/token',
            client_id=self.consumer_key,
            client_secret=self.consumer_secret,
            redirect_uri=request.route_url(self.callback_route),
            grant_type="authorization_code",
            code=code)
        r = requests.get(access_url)
        if r.status_code != 200:
            raise ThirdPartyFailure("Status %s: %s" % (
                r.status_code, r.content))
        data = r.json()
        access_token = data['access_token']

        # Retrieve profile data
        graph_url = flat_url('https://apis.live.net/v5.0/me',
                             access_token=access_token)
        r = requests.get(graph_url)
        if r.status_code != 200:
            raise ThirdPartyFailure("Status %s: %s" % (
                r.status_code, r.content))
        live_profile = r.json()
        profile = extract_live_data(live_profile)

        cred = {'oauthAccessToken': access_token}
        if 'refresh_token' in data:
            cred['oauthRefreshToken'] = data['refresh_token']
        return LiveAuthenticationComplete(profile=profile,
                                          credentials=cred,
                                          provider_name=self.name,
                                          provider_type=self.type)


def extract_live_data(data):
    """Extract and normalize Windows Live Connect data"""
    emails = data.get('emails', {})
    profile = {
        'accounts': [{'domain': 'live.com', 'userid': data['id']}],
        'gender': data.get('gender'),
        'verifiedEmail': emails.get('preferred'),
        'updated': data.get('updated_time'),
        'name': {
            'formatted': data.get('name'),
            'familyName': data.get('last_name'),
            'givenName': data.get('first_name'),
        },
        'displayName': data.get('name'),
        'emails': [],
        'urls': [],
    }

    if emails.get('personal'):
        profile['emails'].append(
            {'type': 'personal', 'value': emails['personal']})
    if emails.get('business'):
        profile['emails'].append(
            {'type': 'business', 'value': emails['business']})
    if emails.get('preferred'):
        profile['emails'].append(
            {'type': 'preferred', 'value': emails['preferred'],
             'primary': True})
    if emails.get('account'):
        profile['emails'].append(
            {'type': 'account', 'value': emails['account']})
    if 'link' in data:
        profile['urls'].append(
            {'type': 'profile', 'value': data['link']})
    if 'birth_day' in data:
        try:
            profile['birthday'] = datetime.date(
                int(data['birth_year']),
                int(data['birth_month']),
                int(data['birth_day']),
            ).strftime('%Y-%m-%d')
        except ValueError:
            pass
    return profile

########NEW FILE########
__FILENAME__ = mailru
"""Mail.ru Authentication Views

You may see developer docs on http://api.mail.ru/docs/guides/oauth/
"""
import hashlib
import re
import uuid

from pyramid.httpexceptions import HTTPFound
from pyramid.security import NO_PERMISSION_REQUIRED

import requests

from ..api import (
    AuthenticationComplete,
    AuthenticationDenied,
    register_provider,
)
from ..exceptions import CSRFError, ThirdPartyFailure
from ..settings import ProviderSettings
from ..utils import flat_url


PROVIDER_NAME = 'mailru'
PROVIDER_DOMAIN = 'mail.ru'
PROVIDER_AUTH_URL = 'https://connect.mail.ru/oauth/authorize'
PROVIDER_ACCESS_TOKEN_URL = 'https://connect.mail.ru/oauth/token'
PROVIDER_USER_PROFILE_URL = 'https://www.appsmail.ru/platform/api'
PROVIDER_USER_PROFILE_API_METHOD = 'users.getInfo'

FIELD_SEX = {
    0: 'male',
    1: 'female'
}
# Mail.ru provides a birthday information in form of 'dd.mm.yyyy' which is a
# regular representation of dates in Russia.
# Therefore, we must convert it into ISO 8601 in order to follow the
# Portable Contacts' birthday format.
FIELD_BIRTHDAY_RE = re.compile('(?P<dd>\d{2})\.(?P<mm>\d{2})\.(?P<yyyy>\d{4})')


class MailRuAuthenticationComplete(AuthenticationComplete):
    """MailRu auth complete"""


def includeme(config):
    config.add_directive('add_mailru_login', add_mailru_login)
    config.add_directive('add_mailru_login_from_settings',
                         add_mailru_login_from_settings)


def add_mailru_login_from_settings(config, prefix='velruse.mailru.'):
    settings = config.registry.settings
    p = ProviderSettings(settings, prefix)
    p.update('consumer_key', required=True)
    p.update('consumer_secret', required=True)
    p.update('scope')
    p.update('login_path')
    p.update('callback_path')
    config.add_mailru_login(**p.kwargs)


def add_mailru_login(
    config,
    consumer_key,
    consumer_secret,
    scope=None,
    login_path='/login/{name}'.format(name=PROVIDER_NAME),
    callback_path='/login/{name}/callback'.format(name=PROVIDER_NAME),
    name=PROVIDER_NAME
):
    """Add a MailRu login provider to the application."""
    provider = MailRuProvider(name, consumer_key, consumer_secret, scope)
    config.add_route(provider.login_route, login_path)
    config.add_view(
        provider,
        attr='login',
        route_name=provider.login_route,
        permission=NO_PERMISSION_REQUIRED
    )
    config.add_route(
        provider.callback_route, callback_path,
        use_global_views=True,
        factory=provider.callback
    )
    register_provider(config, name, provider)


class MailRuProvider(object):

    def __init__(self, name, consumer_key, consumer_secret, scope):
        self.name = name
        self.type = PROVIDER_NAME
        self.consumer_key = consumer_key
        self.consumer_secret = consumer_secret
        self.scope = scope

        self.login_route = 'velruse.{name}-login'.format(name=name)
        self.callback_route = 'velruse.{name}-callback'.format(name=name)

    def login(self, request):
        """Initiate a MailRu login"""
        request.session['velruse.state'] = state = uuid.uuid4().hex
        auth_url = flat_url(
            PROVIDER_AUTH_URL,
            scope=self.scope,
            client_id=self.consumer_key,
            redirect_uri=request.route_url(self.callback_route),
            response_type='code',
            state=state)
        return HTTPFound(location=auth_url)

    def callback(self, request):
        """Process the MailRu redirect"""
        sess_state = request.session.pop('velruse.state', None)
        req_state = request.GET.get('state')
        if not sess_state or sess_state != req_state:
            raise CSRFError(
                'CSRF Validation check failed. Request state {req_state} is '
                'not the same as session state {sess_state}'.format(
                    req_state=req_state,
                    sess_state=sess_state
                )
            )
        code = request.GET.get('code')
        if not code:
            reason = request.GET.get('error', 'No reason provided.')
            return AuthenticationDenied(
                reason=reason,
                provider_name=self.name,
                provider_type=self.type
            )
        # Now retrieve the access token with the code
        access_params = dict(
            grant_type='authorization_code',
            code=code,
            client_id=self.consumer_key,
            client_secret=self.consumer_secret,
            redirect_uri=request.route_url(self.callback_route),
        )
        r = requests.post(PROVIDER_ACCESS_TOKEN_URL, access_params)
        if r.status_code != 200:
            raise ThirdPartyFailure(
                'Status {status}: {content}'.format(
                    status=r.status_code, content=r.content
                )
            )
        data = r.json()
        access_token = data['access_token']

        # Retrieve profile data.

        # Mail.ru API requires a special parameter 'sig' which must be composed
        # by the following sequence
        signature = hashlib.md5(
            'app_id={client_id}'
            'method={method}'
            'secure=1'
            'session_key={access_token}'
            '{secret_key}'.format(
                client_id=self.consumer_key,
                method=PROVIDER_USER_PROFILE_API_METHOD,
                access_token=access_token,
                secret_key=self.consumer_secret
            )
        ).hexdigest()

        # Read more about the following params on
        # http://api.mail.ru/docs/guides/restapi/#params
        profile_url = flat_url(
            PROVIDER_USER_PROFILE_URL,
            method=PROVIDER_USER_PROFILE_API_METHOD,
            app_id=self.consumer_key,
            sig=signature,
            session_key=access_token,
            secure=1
        )
        r = requests.get(profile_url)
        if r.status_code != 200:
            raise ThirdPartyFailure(
                'Status {status}: {content}'.format(
                    status=r.status_code, content=r.content
                )
            )
        profile = r.json()[0]
        profile = extract_normalize_mailru_data(profile)
        cred = {'oauthAccessToken': access_token}
        return MailRuAuthenticationComplete(
            profile=profile,
            credentials=cred,
            provider_name=self.name,
            provider_type=self.type
        )


def extract_normalize_mailru_data(data):
    """Extract and normalize MailRu data returned by the provider"""
    # You may see the input data format on
    # http://api.mail.ru/docs/reference/rest/users-getinfo/#result
    profile = {
        'accounts': [
            {
                'domain': PROVIDER_DOMAIN,
                'userid': data['uid']
            }
        ],
        'name': {},
        'gender': FIELD_SEX.get(data.get('sex')),
        'photos': [],
        'addresses': []
    }

    # Names
    nickname = data.get('nick')
    if nickname:
        profile['preferredUsername'] = nickname

    first_name = data.get('first_name')
    if first_name:
        profile['name']['givenName'] = first_name

    last_name = data.get('last_name')
    if last_name:
        profile['name']['familyName'] = last_name

    if first_name and last_name:
        profile['displayName'] = u'{} {}'.format(first_name, last_name).strip()
    elif first_name:
        profile['displayName'] = first_name
    elif last_name:
        profile['displayName'] = first_name
    elif nickname:
        profile['displayName'] = nickname
    else:
        profile['displayName'] = 'Mail.ru user {uid}'.format(uid=data['uid'])

    # Birthday
    match = FIELD_BIRTHDAY_RE.match(data.get('birthday', ''))
    if match:
        profile['birthday'] = '{yyyy}-{mm}-{dd}'.format(**match.groupdict())

    # Email
    email = data.get('email')
    if email:
        profile['emails'] = [{
            'value': email,
            'primary': True
        }]

    # URLs
    link = data.get('link')
    if link:
        profile['urls'] = [{
            'value': link
        }]

    # Photos
    if data.get('has_pic'):
        road_map = [
            [
                # field suffix
                '',
                # type
                'original'
            ],
            ['_big', 'big'],
            ['_small', 'small'],
            ['_190', 'custom_190'],
            ['_180', 'custom_180'],
            ['_128', 'custom_128'],
            ['_50', 'custom_50'],
            ['_40', 'custom_40'],
            ['_32', 'custom_32'],
            ['_22', 'custom_22']
        ]
        for item in road_map:
            photo, image_type = item
            photo = data.get('pic{photo_suffix}'.format(photo_suffix=photo))
            if photo:
                profile['photos'].append({
                    'value': photo,
                    'type': image_type
                })

    # Location
    location = data.get('location', {})
    country = location.get('country', {}).get('name')
    region = location.get('region', {}).get('name')
    city = location.get('city', {}).get('name')
    if country or region or city:
        address = {}
        if country:
            address['country'] = country
        if region:
            address['region'] = region
        if city:
            address['locality'] = city
        profile['addresses'].append(address)

    # Now strip out empty values
    for k, v in profile.items():
        if not v or (isinstance(v, list) and not v[0]):
            del profile[k]

    return profile

########NEW FILE########
__FILENAME__ = oid_extensions
"""OpenID Extensions

Additional OpenID extensions for OAuth and UIRequest extensions.

"""
from __future__ import absolute_import

from openid import extension


class UIRequest(extension.Extension):
    """OpenID UI extension"""
    ns_uri = 'http://specs.openid.net/extensions/ui/1.0'
    ns_alias = 'ui'

    def __init__(self, mode=None, icon=False):
        super(UIRequest, self).__init__()
        self._args = {}
        if mode:
            self._args['mode'] = mode
        if icon:
            self._args['icon'] = str(icon).lower()

    def getExtensionArgs(self):
        return self._args


class OAuthRequest(extension.Extension):
    """OAuth extension"""
    ns_uri = 'http://specs.openid.net/extensions/oauth/1.0'
    ns_alias = 'oauth'

    def __init__(self, consumer, scope=None):
        super(OAuthRequest, self).__init__()
        self._args = {'consumer': consumer}
        if scope:
            self._args['scope'] = scope

    def getExtensionArgs(self):
        return self._args

########NEW FILE########
__FILENAME__ = openid
from __future__ import absolute_import

import datetime
import re

from openid.consumer import consumer
from openid.extensions import ax
from openid.extensions import sreg

from pyramid.request import Response
from pyramid.httpexceptions import HTTPFound
from pyramid.security import NO_PERMISSION_REQUIRED

from ..api import (
    AuthenticationComplete,
    AuthenticationDenied,
    register_provider,
)
from ..exceptions import (
    MissingParameter,
    ThirdPartyFailure,
)

log = __import__('logging').getLogger(__name__)

# Setup our attribute objects that we'll be requesting
ax_attributes = dict(
    nickname='http://axschema.org/namePerson/friendly',
    email='http://axschema.org/contact/email',
    full_name='http://axschema.org/namePerson',
    birthday='http://axschema.org/birthDate',
    gender='http://axschema.org/person/gender',
    postal_code='http://axschema.org/contact/postalCode/home',
    country='http://axschema.org/contact/country/home',
    timezone='http://axschema.org/pref/timezone',
    language='http://axschema.org/pref/language',
    name_prefix='http://axschema.org/namePerson/prefix',
    first_name='http://axschema.org/namePerson/first',
    last_name='http://axschema.org/namePerson/last',
    middle_name='http://axschema.org/namePerson/middle',
    name_suffix='http://axschema.org/namePerson/suffix',
    web='http://axschema.org/contact/web/default',
    thumbnail='http://axschema.org/media/image/default',
)

#Change names later to make things a little bit clearer
alternate_ax_attributes = dict(
    nickname='http://schema.openid.net/namePerson/friendly',
    email='http://schema.openid.net/contact/email',
    full_name='http://schema.openid.net/namePerson',
    birthday='http://schema.openid.net/birthDate',
    gender='http://schema.openid.net/person/gender',
    postal_code='http://schema.openid.net/contact/postalCode/home',
    country='http://schema.openid.net/contact/country/home',
    timezone='http://schema.openid.net/pref/timezone',
    language='http://schema.openid.net/pref/language',
    name_prefix='http://schema.openid.net/namePerson/prefix',
    first_name='http://schema.openid.net/namePerson/first',
    last_name='http://schema.openid.net/namePerson/last',
    middle_name='http://schema.openid.net/namePerson/middle',
    name_suffix='http://schema.openid.net/namePerson/suffix',
    web='http://schema.openid.net/contact/web/default',
)

# Translation dict for AX attrib names to sreg equiv
trans_dict = dict(
    full_name='fullname',
    birthday='dob',
    postal_code='postcode',
)

attributes = ax_attributes


class OpenIDAuthenticationComplete(AuthenticationComplete):
    """OpenID auth complete"""


def includeme(config):
    config.add_directive('add_openid_login', add_openid_login)


def add_openid_login(config,
                     realm=None,
                     storage=None,
                     login_path='/login/openid',
                     callback_path='/login/openid/callback',
                     name='openid'):
    """
    Add an OpenID login provider to the application.

    `storage` should be an object conforming to the
    `openid.store.interface.OpenIDStore` protocol. If left as `None` then
    the provider will run in a stateless mode.
    """
    provider = OpenIDConsumer(name, 'openid', realm=realm, storage=storage)

    config.add_route(provider.login_route, login_path)
    config.add_view(provider, attr='login', route_name=provider.login_route,
                    permission=NO_PERMISSION_REQUIRED)

    config.add_route(provider.callback_route, callback_path,
                     use_global_views=True,
                     factory=provider.callback)

    register_provider(config, name, provider)


class OpenIDConsumer(object):
    """OpenID Consumer base class

    Providors using specialized OpenID based authentication subclass this.

    """
    def __init__(self,
                 name,
                 _type,
                 realm=None,
                 storage=None,
                 context=OpenIDAuthenticationComplete):
        self.openid_store = storage
        self.name = name
        self.type = _type
        self.context = context
        self.realm_override = realm

        self.login_route = 'velruse.%s-url' % name
        self.callback_route = 'velruse.%s-callback' % name

    def _get_realm(self, request):
        if self.realm_override is not None:
            return self.realm_override
        return request.host_url

    def _lookup_identifier(self, request, identifier):
        """Extension point for inherited classes that want to change or set
        a default identifier"""
        return identifier

    def _update_authrequest(self, request, authrequest):
        """Update the authrequest with the default extensions and attributes
        we ask for

        This method doesn't need to return anything, since the extensions
        should be added to the authrequest object itself.

        """
        # Add on the Attribute Exchange for those that support that
        ax_request = ax.FetchRequest()
        for attrib in attributes.values():
            ax_request.add(ax.AttrInfo(attrib))
        authrequest.addExtension(ax_request)

        # Form the Simple Reg request
        sreg_request = sreg.SRegRequest(
            optional=['nickname', 'email', 'fullname', 'dob', 'gender',
                      'postcode', 'country', 'language', 'timezone'],
        )
        authrequest.addExtension(sreg_request)

    def _get_access_token(self, request_token):
        """Called to exchange a request token for the access token

        This method doesn't by default return anything, other OpenID+Oauth
        consumers should override it to do the appropriate lookup for the
        access token, and return the access token.

        """

    def login(self, request):
        log.debug('Handling OpenID login')

        # Load default parameters that all Auth Responders take
        openid_url = request.params.get('openid_identifier')

        # Let inherited consumers alter the openid identifier if desired
        openid_url = self._lookup_identifier(request, openid_url)

        if not openid_url:
            log.error('Velruse: no openid_url')
            raise MissingParameter('No openid_identifier was found')

        openid_session = {}
        oidconsumer = consumer.Consumer(openid_session, self.openid_store)

        try:
            log.debug('About to try OpenID begin')
            authrequest = oidconsumer.begin(openid_url)
        except consumer.DiscoveryFailure:
            log.debug('OpenID begin DiscoveryFailure')
            raise

        if authrequest is None:
            log.debug('OpenID begin returned empty')
            raise ThirdPartyFailure("OpenID begin returned nothing")

        log.debug('Updating authrequest')

        # Update the authrequest
        self._update_authrequest(request, authrequest)

        realm = self._get_realm(request)
        # TODO: add a csrf check to the return_to URL
        return_to = request.route_url(self.callback_route)
        request.session['velruse.openid_session'] = openid_session

        # OpenID 2.0 lets Providers request POST instead of redirect, this
        # checks for such a request.
        if authrequest.shouldSendRedirect():
            log.debug('About to initiate OpenID redirect')
            redirect_url = authrequest.redirectURL(
                realm=realm,
                return_to=return_to,
                immediate=False)
            return HTTPFound(location=redirect_url)
        else:
            log.debug('About to initiate OpenID POST')
            html = authrequest.htmlMarkup(
                realm=realm,
                return_to=return_to,
                immediate=False)
            return Response(body=html)

    def _update_profile_data(self, request, user_data, credentials):
        """Update the profile data using an OAuth request to fetch more data"""

    def callback(self, request):
        """Handle incoming redirect from OpenID Provider"""
        log.debug('Handling processing of response from server')

        openid_session = request.session.pop('velruse.openid_session', None)
        if not openid_session:
            raise ThirdPartyFailure("No OpenID Session has begun.")

        # Setup the consumer and parse the information coming back
        oidconsumer = consumer.Consumer(openid_session, self.openid_store)
        return_to = request.route_url(self.callback_route)
        info = oidconsumer.complete(request.params, return_to)

        if info.status in [consumer.FAILURE, consumer.CANCEL]:
            return AuthenticationDenied("OpenID failure",
                                        provider_name=self.name,
                                        provider_type=self.type)
        elif info.status == consumer.SUCCESS:
            openid_identity = info.identity_url
            if info.endpoint.canonicalID:
                # If it's an i-name, use the canonicalID as its secure even if
                # the old one is compromised
                openid_identity = info.endpoint.canonicalID

            user_data = extract_openid_data(
                identifier=openid_identity,
                sreg_resp=sreg.SRegResponse.fromSuccessResponse(info),
                ax_resp=ax.FetchResponse.fromSuccessResponse(info)
            )
            # Did we get any OAuth info?
            oauth = info.extensionResponse(
                'http://specs.openid.net/extensions/oauth/1.0', False
            )
            cred = {}
            if oauth and 'request_token' in oauth:
                access_token = self._get_access_token(oauth['request_token'])
                if access_token:
                    cred.update(access_token)

                # See if we need to update our profile data with an OAuth call
                self._update_profile_data(request, user_data, cred)

            return self.context(profile=user_data,
                                credentials=cred,
                                provider_name=self.name,
                                provider_type=self.type)
        else:
            raise ThirdPartyFailure("OpenID failed.")


class AttribAccess(object):
    """Uniform attribute accessor for Simple Reg and Attribute Exchange
    values"""
    def __init__(self, sreg_resp, ax_resp):
        self.sreg_resp = sreg_resp or {}
        self.ax_resp = ax_resp or ax.AXKeyValueMessage()

    def get(self, key, ax_only=False):
        """Get a value from either Simple Reg or AX"""
        # First attempt to fetch it from AX
        v = self.ax_resp.getSingle(attributes[key])
        if v:
            return v
        if ax_only:
            return None

        # Translate the key if needed
        if key in trans_dict:
            key = trans_dict[key]

        # Don't attempt to fetch keys that aren't valid sreg fields
        if key not in sreg.data_fields:
            return None

        return self.sreg_resp.get(key)


def extract_openid_data(identifier, sreg_resp, ax_resp):
    """Extract the OpenID Data from Simple Reg and AX data

    This normalizes the data to the appropriate format.

    """
    attribs = AttribAccess(sreg_resp, ax_resp)

    account = {}
    accounts = [account]

    ud = {'accounts': accounts}
    if 'google.com' in identifier:
        account['domain'] = 'google.com'
    elif 'yahoo.com' in identifier:
        account['domain'] = 'yahoo.com'
    elif 'aol.com' in identifier:
        account['domain'] = 'aol.com'
    else:
        account['domain'] = 'openid.net'
    account['username'] = identifier

    # Sort out the display name and preferred username
    if account['domain'] == 'google.com':
        # Extract the first bit as the username since Google doesn't return
        # any usable nickname info
        email = attribs.get('email')
        if email:
            ud['preferredUsername'] = re.match('(^.*?)@', email).groups()[0]
    else:
        ud['preferredUsername'] = attribs.get('nickname')

    # We trust that Google and Yahoo both verify their email addresses
    if account['domain'] in ['google.com', 'yahoo.com']:
        ud['verifiedEmail'] = attribs.get('email', ax_only=True)
    ud['emails'] = [attribs.get('email')]

    # Parse through the name parts, assign the properly if present
    name = {}
    name_keys = ['name_prefix', 'first_name', 'middle_name', 'last_name',
                 'name_suffix']
    pcard_map = {'first_name': 'givenName', 'middle_name': 'middleName',
                 'last_name': 'familyName',
                 'name_prefix': 'honorificPrefix',
                 'name_suffix': 'honorificSuffix'}
    full_name_vals = []
    for part in name_keys:
        val = attribs.get(part)
        if val:
            full_name_vals.append(val)
            name[pcard_map[part]] = val
    full_name = ' '.join(full_name_vals).strip()
    if not full_name:
        full_name = attribs.get('full_name')

    name['formatted'] = full_name
    ud['name'] = name

    ud['displayName'] = full_name or ud.get('preferredUsername')

    urls = attribs.get('web')
    if urls:
        ud['urls'] = [urls]

    gender = attribs.get('gender')
    if gender:
        ud['gender'] = {'M': 'male', 'F': 'female'}.get(gender)

    birthday = attribs.get('birthday')
    if birthday:
        try:
            # confirm that the date is valid
            date = datetime.datetime.strptime(birthday, '%Y-%m-%d').date()
            ud['birthday'] = date.strftime('%Y-%m-%d')
        except ValueError:
            pass

    thumbnail = attribs.get('thumbnail')
    if thumbnail:
        ud['photos'] = [{'type': 'thumbnail', 'value': thumbnail}]
        ud['thumbnailUrl'] = thumbnail

    # Now strip out empty values
    for k, v in ud.items():
        if not v or (isinstance(v, list) and not v[0]):
            del ud[k]

    return ud

########NEW FILE########
__FILENAME__ = qq
"""QQ Authentication Views"""
import json

from pyramid.httpexceptions import HTTPFound
from pyramid.security import NO_PERMISSION_REQUIRED

import requests

from ..api import (
    AuthenticationComplete,
    AuthenticationDenied,
    register_provider,
)
from ..compat import parse_qsl
from ..exceptions import ThirdPartyFailure
from ..settings import ProviderSettings
from ..utils import flat_url


class QQAuthenticationComplete(AuthenticationComplete):
    """QQ auth complete"""


def includeme(config):
    config.add_directive('add_qq_login', add_qq_login)
    config.add_directive('add_qq_login_from_settings',
                         add_qq_login_from_settings)


def add_qq_login_from_settings(config, prefix='velruse.qq.'):
    settings = config.registry.settings
    p = ProviderSettings(settings, prefix)
    p.update('consumer_key', required=True)
    p.update('consumer_secret', required=True)
    p.update('scope')
    p.update('login_path')
    p.update('callback_path')
    config.add_qq_login(**p.kwargs)


def add_qq_login(config,
                 consumer_key,
                 consumer_secret,
                 scope=None,
                 login_path='/login/qq',
                 callback_path='/login/qq/callback',
                 name='qq'):
    """
    Add a QQ login provider to the application.
    """
    provider = QQProvider(name, consumer_key, consumer_secret, scope)

    config.add_route(provider.login_route, login_path)
    config.add_view(provider, attr='login', route_name=provider.login_route,
                    permission=NO_PERMISSION_REQUIRED)

    config.add_route(provider.callback_route, callback_path,
                     use_global_views=True,
                     factory=provider.callback)

    register_provider(config, name, provider)


class QQProvider(object):
    def __init__(self, name, consumer_key, consumer_secret, scope):
        self.name = name
        self.type = 'qq'
        self.consumer_key = consumer_key
        self.consumer_secret = consumer_secret
        self.scope = scope

        self.login_route = 'velruse.%s-login' % name
        self.callback_route = 'velruse.%s-callback' % name

    def login(self, request):
        """Initiate a qq login"""
        scope = request.POST.get('scope', self.scope)
        gh_url = flat_url('https://graph.qq.com/oauth2.0/authorize',
                          scope=scope,
                          client_id=self.consumer_key,
                          response_type='code',
                          redirect_uri=request.route_url(self.callback_route))
        return HTTPFound(location=gh_url)

    def callback(self, request):
        """Process the qq redirect"""
        code = request.GET.get('code')
        if not code:
            reason = request.GET.get('error', 'No reason provided.')
            return AuthenticationDenied(reason,
                                        provider_name=self.name,
                                        provider_type=self.type)

        # Now retrieve the access token with the code
        access_url = flat_url(
            'https://graph.qq.com/oauth2.0/token',
            client_id=self.consumer_key,
            client_secret=self.consumer_secret,
            grant_type='authorization_code',
            redirect_uri=request.route_url(self.callback_route),
            code=code)
        r = requests.get(access_url)
        if r.status_code != 200:
            raise ThirdPartyFailure("Status %s: %s" % (
                r.status_code, r.content))
        access_token = dict(parse_qsl(r.text))['access_token']

        # Retrieve profile data
        graph_url = flat_url('https://graph.qq.com/oauth2.0/me',
                             access_token=access_token)
        r = requests.get(graph_url)
        if r.status_code != 200:
            raise ThirdPartyFailure("Status %s: %s" % (
                r.status_code, r.content))
        data = json.loads(r.text[10:-3])
        openid = data.get('openid', '')

        user_info_url = flat_url(
            'https://graph.qq.com/user/get_user_info',
            access_token=access_token,
            oauth_consumer_key=self.consumer_key,
            openid=openid)
        r = requests.get(user_info_url)
        if r.status_code != 200:
            raise ThirdPartyFailure("Status %s: %s" % (
                r.status_code, r.content))
        data = r.json()

        profile = {
            'accounts': [{'domain': 'qq.com', 'userid': openid}],
            'displayName': data['nickname'],
            'preferredUsername': data['nickname'],
            'data': data
        }

        cred = {'oauthAccessToken': access_token}
        return QQAuthenticationComplete(profile=profile,
                                        credentials=cred,
                                        provider_name=self.name,
                                        provider_type=self.type)

########NEW FILE########
__FILENAME__ = renren
"""Renren Authentication Views"""
from pyramid.httpexceptions import HTTPFound
from pyramid.security import NO_PERMISSION_REQUIRED

import requests

from ..api import (
    AuthenticationComplete,
    AuthenticationDenied,
    register_provider,
)
from ..exceptions import ThirdPartyFailure
from ..settings import ProviderSettings
from ..utils import flat_url


class RenrenAuthenticationComplete(AuthenticationComplete):
    """Renren auth complete"""


def includeme(config):
    config.add_directive('add_renren_login', add_renren_login)
    config.add_directive('add_renren_login_from_settings',
                         add_renren_login_from_settings)


def add_renren_login_from_settings(config, prefix='velruse.renren.'):
    settings = config.registry.settings
    p = ProviderSettings(settings, prefix)
    p.update('consumer_key', required=True)
    p.update('consumer_secret', required=True)
    p.update('scope')
    p.update('login_path')
    p.update('callback_path')
    config.add_renren_login(**p.kwargs)


def add_renren_login(config,
                     consumer_key,
                     consumer_secret,
                     scope='',
                     login_path='/login/renren',
                     callback_path='/login/renren/callback',
                     name='renren'):
    """
    Add a Renren login provider to the application.
    """
    provider = RenrenProvider(name, consumer_key, consumer_secret, scope)

    config.add_route(provider.login_route, login_path)
    config.add_view(provider, attr='login', route_name=provider.login_route,
                    permission=NO_PERMISSION_REQUIRED)

    config.add_route(provider.callback_route, callback_path,
                     use_global_views=True,
                     factory=provider.callback)

    register_provider(config, name, provider)


class RenrenProvider(object):
    def __init__(self, name, consumer_key, consumer_secret, scope):
        self.name = name
        self.type = 'renren'
        self.consumer_key = consumer_key
        self.consumer_secret = consumer_secret
        self.scope = scope

        self.login_route = 'velruse.%s-login' % name
        self.callback_route = 'velruse.%s-callback' % name

    def login(self, request):
        """Initiate a renren login"""
        scope = request.POST.get('scope', self.scope)
        url = flat_url('https://graph.renren.com/oauth/authorize',
                       scope=scope,
                       client_id=self.consumer_key,
                       response_type='code',
                       redirect_uri=request.route_url(self.callback_route))
        return HTTPFound(url)

    def callback(self, request):
        """Process the renren redirect"""
        code = request.GET.get('code')
        if not code:
            reason = request.GET.get('error', 'No reason provided.')
            return AuthenticationDenied(reason,
                                        provider_name=self.name,
                                        provider_type=self.type)

        access_url = flat_url(
            'https://graph.renren.com/oauth/token',
            client_id=self.consumer_key,
            client_secret=self.consumer_secret,
            grant_type='authorization_code',
            redirect_uri=request.route_url(self.callback_route),
            code=code)

        r = requests.get(access_url)
        if r.status_code != 200:
            raise ThirdPartyFailure("Status %s: %s" % (
                r.status_code, r.content))
        data = r.json()
        access_token = data['access_token']
        profile = {
            'accounts': [
                {'domain': 'renren.com', 'userid': data['user']['id']},
            ],
            'displayName': data['user']['name'],
            'preferredUsername': data['user']['name'],
        }

        cred = {'oauthAccessToken': access_token}

        return RenrenAuthenticationComplete(profile=profile,
                                            credentials=cred,
                                            provider_name=self.name,
                                            provider_type=self.type)

########NEW FILE########
__FILENAME__ = taobao
"""Taobao Authentication Views"""
from hashlib import md5
import time

from pyramid.httpexceptions import HTTPFound
from pyramid.security import NO_PERMISSION_REQUIRED

import requests

from ..api import (
    AuthenticationComplete,
    AuthenticationDenied,
    register_provider,
)
from ..exceptions import ThirdPartyFailure
from ..settings import ProviderSettings
from ..utils import flat_url


class TaobaoAuthenticationComplete(AuthenticationComplete):
    """Taobao auth complete"""


def includeme(config):
    config.add_directive('add_taobao_login', add_taobao_login)
    config.add_directive('add_taobao_login_from_settings',
                         add_taobao_login_from_settings)


def add_taobao_login_from_settings(config, prefix='velruse.taobao.'):
    settings = config.registry.settings
    p = ProviderSettings(settings, prefix)
    p.update('consumer_key', required=True)
    p.update('consumer_secret', required=True)
    p.update('login_path')
    p.update('callback_path')
    config.add_taobao_login(**p.kwargs)


def add_taobao_login(config,
                     consumer_key,
                     consumer_secret,
                     login_path='/login/taobao',
                     callback_path='/login/taobao/callback',
                     name='taobao'):
    """
    Add a Taobao login provider to the application.
    """
    provider = TaobaoProvider(name, consumer_key, consumer_secret)

    config.add_route(provider.login_route, login_path)
    config.add_view(provider, attr='login', route_name=provider.login_route,
                    permission=NO_PERMISSION_REQUIRED)

    config.add_route(provider.callback_route, callback_path,
                     use_global_views=True,
                     factory=provider.callback)

    register_provider(config, name, provider)


class TaobaoProvider(object):
    def __init__(self, name, consumer_key, consumer_secret):
        self.name = name
        self.type = 'taobao'
        self.consumer_key = consumer_key
        self.consumer_secret = consumer_secret

        self.login_route = 'velruse.%s-login' % name
        self.callback_route = 'velruse.%s-callback' % name

    def login(self, request):
        """Initiate a taobao login"""
        gh_url = flat_url('https://oauth.taobao.com/authorize',
                          client_id=self.consumer_key,
                          response_type='code',
                          redirect_uri=request.route_url(self.callback_route))
        return HTTPFound(location=gh_url)

    def callback(self, request):
        """Process the taobao redirect"""
        code = request.GET.get('code')
        if not code:
            reason = request.GET.get('error', 'No reason provided.')
            return AuthenticationDenied(reason,
                                        provider_name=self.name,
                                        provider_type=self.type)

        # Now retrieve the access token with the code
        r = requests.post(
            'https://oauth.taobao.com/token',
            dict(grant_type='authorization_code',
                 client_id=self.consumer_key,
                 client_secret=self.consumer_secret,
                 redirect_uri=request.route_url(self.callback_route),
                 code=code))
        if r.status_code != 200:
            raise ThirdPartyFailure("Status %s: %s" % (
                r.status_code, r.content))
        data = r.json()
        access_token = data['access_token']

        # Retrieve profile data
        params = {
            'method': 'taobao.user.get',
            'timestamp': time.strftime('%Y-%m-%d %H:%M:%S', time.localtime()),
            'format': 'json',
            'app_key': self.consumer_key,
            'v': '2.0',
            'sign_method': 'md5',
            'fields': 'user_id,nick',
            'session': access_token,
        }
        src = (
            self.consumer_secret
            + ''.join(["%s%s" % (k, v) for k, v in sorted(params.items())])
            + self.consumer_secret
        )
        params['sign'] = md5(src).hexdigest().upper()
        get_user_info_url = flat_url('http://gw.api.taobao.com/router/rest',
                                     **params)
        r = requests.get(get_user_info_url)
        if r.status_code != 200:
            raise ThirdPartyFailure("Status %s: %s" % (
                r.status_code, r.content))
        data = r.json()

        username = data['user_get_response']['user']['nick']
        userid = data['user_get_response']['user']['user_id']

        profile = {
            'accounts': [{'domain': 'taobao.com', 'userid': userid}],
            'displayName': username,
            'preferredUsername': username,
        }

        cred = {'oauthAccessToken': access_token}
        return TaobaoAuthenticationComplete(profile=profile,
                                            credentials=cred,
                                            provider_name=self.name,
                                            provider_type=self.type)

########NEW FILE########
__FILENAME__ = twitter
"""Twitter Authentication Views"""
from pyramid.httpexceptions import HTTPFound
from pyramid.security import NO_PERMISSION_REQUIRED

import requests

from requests_oauthlib import OAuth1

from ..api import (
    AuthenticationComplete,
    AuthenticationDenied,
    register_provider,
)
from ..compat import parse_qsl
from ..exceptions import ThirdPartyFailure
from ..settings import ProviderSettings
from ..utils import flat_url


REQUEST_URL = 'https://api.twitter.com/oauth/request_token'
AUTH_URL = 'https://api.twitter.com/oauth/authenticate'
ACCESS_URL = 'https://api.twitter.com/oauth/access_token'
DATA_URL = 'https://api.twitter.com/1.1/users/show.json?screen_name=%s'

class TwitterAuthenticationComplete(AuthenticationComplete):
    """Twitter auth complete"""


def includeme(config):
    config.add_directive('add_twitter_login', add_twitter_login)
    config.add_directive('add_twitter_login_from_settings',
                         add_twitter_login_from_settings)


def add_twitter_login_from_settings(config, prefix='velruse.twitter.'):
    settings = config.registry.settings
    p = ProviderSettings(settings, prefix)
    p.update('consumer_key', required=True)
    p.update('consumer_secret', required=True)
    p.update('login_path')
    p.update('callback_path')
    config.add_twitter_login(**p.kwargs)


def add_twitter_login(config,
                      consumer_key,
                      consumer_secret,
                      login_path='/login/twitter',
                      callback_path='/login/twitter/callback',
                      name='twitter'):
    """
    Add a Twitter login provider to the application.
    """
    provider = TwitterProvider(name, consumer_key, consumer_secret)

    config.add_route(provider.login_route, login_path)
    config.add_view(provider, attr='login',
                    route_name=provider.login_route,
                    permission=NO_PERMISSION_REQUIRED)

    config.add_route(provider.callback_route, callback_path,
                     use_global_views=True,
                     factory=provider.callback)

    register_provider(config, name, provider)


class TwitterProvider(object):
    def __init__(self, name, consumer_key, consumer_secret):
        self.name = name
        self.type = 'twitter'
        self.consumer_key = consumer_key
        self.consumer_secret = consumer_secret

        self.login_route = 'velruse.%s-login' % name
        self.callback_route = 'velruse.%s-callback' % name

    def login(self, request):
        """Initiate a Twitter login"""
        # grab the initial request token
        oauth = OAuth1(
            self.consumer_key,
            client_secret=self.consumer_secret,
            callback_uri=request.route_url(self.callback_route))
        resp = requests.post(REQUEST_URL, auth=oauth)
        if resp.status_code != 200:
            raise ThirdPartyFailure("Status %s: %s" % (
                resp.status_code, resp.content))
        request_token = dict(parse_qsl(resp.text))

        # store the token for later
        request.session['velruse.token'] = request_token

        # redirect the user to authorize the app
        auth_url = flat_url(AUTH_URL, oauth_token=request_token['oauth_token'])
        return HTTPFound(location=auth_url)

    def callback(self, request):
        """Process the Twitter redirect"""
        if 'denied' in request.GET:
            return AuthenticationDenied("User denied authentication",
                                        provider_name=self.name,
                                        provider_type=self.type)
        verifier = request.GET.get('oauth_verifier')
        if not verifier:
            raise ThirdPartyFailure("No oauth_verifier returned")

        request_token = request.session.pop('velruse.token')

        # turn our request token into an access token
        oauth = OAuth1(
            self.consumer_key,
            client_secret=self.consumer_secret,
            resource_owner_key=request_token['oauth_token'],
            resource_owner_secret=request_token['oauth_token_secret'],
            verifier=verifier)
        resp = requests.post(ACCESS_URL, auth=oauth)
        if resp.status_code != 200:
            raise ThirdPartyFailure("Status %s: %s" % (
                resp.status_code, resp.content))
        access_token = dict(parse_qsl(resp.text))
        creds = {
            'oauthAccessToken': access_token['oauth_token'],
            'oauthAccessTokenSecret': access_token['oauth_token_secret'],
        }

        username = access_token['screen_name']

        # Setup the normalized contact info
        profile = {}
        profile['accounts'] = [{
            'domain': 'twitter.com',
            'userid': access_token['user_id'],
            'username': username,
        }]
        profile['displayName'] = username
        profile['preferredUsername'] = username

        oauth = OAuth1(
            self.consumer_key,
            client_secret=self.consumer_secret,
            resource_owner_key=access_token['oauth_token'],
            resource_owner_secret=access_token['oauth_token_secret'])
        resp = requests.get(DATA_URL % username, auth=oauth)
        if resp.status_code == 200:
            data = resp.json()
            if 'name' in data:
                # replace display name with the full name
                profile['displayName'] = data['name']
                profile['name'] = {'formatted': profile['displayName']}
            if 'url' in data:
                profile['urls'] = [{'value': data['url']}]
            if 'location' in data:
                profile['addresses'] = [{'formatted': data['location']}]
            if 'profile_image_url' in data:
                profile['photos'] = [{'value': data['profile_image_url']}]
            if data.get('utc_offset'):
                offset = float(data['utc_offset']) / 3600
                h = int(offset)
                m = int(abs(offset - h) * 60)
                profile['utcOffset'] = '{h:+03d}:{m:02d}'.format(h=h, m=m)

        return TwitterAuthenticationComplete(profile=profile,
                                             credentials=creds,
                                             provider_name=self.name,
                                             provider_type=self.type)

########NEW FILE########
__FILENAME__ = vk
"""VK.com (ex Vkontakte.ru) Authentication Views

VK is considered to be the #1 social network
(with more than a 100 million active users) in Russia.
You may see the developer docs at http://vk.com/developers.php#devstep2
"""
import uuid

from pyramid.httpexceptions import HTTPFound
from pyramid.security import NO_PERMISSION_REQUIRED

import requests

from ..api import (
    AuthenticationComplete,
    AuthenticationDenied,
    register_provider,
)
from ..exceptions import CSRFError, ThirdPartyFailure
from ..settings import ProviderSettings
from ..utils import flat_url
from ..compat import u


PROVIDER_NAME = 'vk'
PROVIDER_AUTH_URL = 'https://oauth.vk.com/authorize'
PROVIDER_ACCESS_TOKEN_URL = 'https://api.vk.com/oauth/access_token'
PROVIDER_USER_PROFILE_URL = 'https://api.vk.com/method/getProfiles'

FIELD_SEX = {
    1: 'female',
    2: 'male'
}


class VKAuthenticationComplete(AuthenticationComplete):
    """VK auth complete"""


def includeme(config):
    config.add_directive('add_vk_login', add_vk_login)
    config.add_directive('add_vk_login_from_settings',
                         add_vk_login_from_settings)


def add_vk_login_from_settings(config, prefix='velruse.vk.'):
    settings = config.registry.settings
    p = ProviderSettings(settings, prefix)
    p.update('consumer_key', required=True)
    p.update('consumer_secret', required=True)
    p.update('scope')
    p.update('login_path')
    p.update('callback_path')
    config.add_vk_login(**p.kwargs)


def add_vk_login(
    config,
    consumer_key,
    consumer_secret,
    scope=None,
    login_path='/login/{name}'.format(name=PROVIDER_NAME),
    callback_path='/login/{name}/callback'.format(name=PROVIDER_NAME),
    name=PROVIDER_NAME
):
    """Add a VK login provider to the application."""
    provider = VKProvider(name, consumer_key, consumer_secret, scope)
    config.add_route(provider.login_route, login_path)
    config.add_view(
        provider,
        attr='login',
        route_name=provider.login_route,
        permission=NO_PERMISSION_REQUIRED
    )
    config.add_route(
        provider.callback_route, callback_path,
        use_global_views=True,
        factory=provider.callback
    )
    register_provider(config, name, provider)


class VKProvider(object):

    def __init__(self, name, consumer_key, consumer_secret, scope):
        self.name = name
        self.type = PROVIDER_NAME
        self.consumer_key = consumer_key
        self.consumer_secret = consumer_secret
        self.scope = scope

        self.login_route = 'velruse.{name}-login'.format(name=name)
        self.callback_route = 'velruse.{name}-callback'.format(name=name)

    def login(self, request):
        """Initiate a VK login"""
        request.session['velruse.state'] = state = uuid.uuid4().hex
        fb_url = flat_url(
            PROVIDER_AUTH_URL,
            scope=self.scope,
            client_id=self.consumer_key,
            redirect_uri=request.route_url(self.callback_route),
            response_type='code',
            state=state)
        return HTTPFound(location=fb_url)

    def callback(self, request):
        """Process the VK redirect"""
        sess_state = request.session.pop('velruse.state', None)
        req_state = request.GET.get('state')
        if not sess_state or sess_state != req_state:
            raise CSRFError(
                'CSRF Validation check failed. Request state {req_state} is '
                'not the same as session state {sess_state}'.format(
                    req_state=req_state,
                    sess_state=sess_state
                )
            )
        code = request.GET.get('code')
        if not code:
            reason = request.GET.get('error_description',
                                     'No reason provided.')
            return AuthenticationDenied(
                reason=reason,
                provider_name=self.name,
                provider_type=self.type
            )
        # Now retrieve the access token with the code
        access_url = flat_url(
            PROVIDER_ACCESS_TOKEN_URL,
            client_id=self.consumer_key,
            client_secret=self.consumer_secret,
            redirect_uri=request.route_url(self.callback_route),
            code=code
        )
        r = requests.get(access_url)
        if r.status_code != 200:
            raise ThirdPartyFailure(
                'Status {status}: {content}'.format(
                    status=r.status_code, content=r.content
                )
            )
        data = r.json()
        access_token = data['access_token']

        # Retrieve profile data
        graph_url = flat_url(
            PROVIDER_USER_PROFILE_URL,
            access_token=access_token,
            uids=data['user_id'],
            fields=(
                'first_name,last_name,nickname,domain,sex,bdate,city,country,'
                'timezone,photo,photo_medium,photo_big,photo_rec,has_mobile,'
                'mobile_phone,home_phone,rate,contacts,education'
            )
        )
        r = requests.get(graph_url)
        if r.status_code != 200:
            raise ThirdPartyFailure(
                'Status {status}: {content}'.format(
                    status=r.status_code, content=r.content
                )
            )
        vk_profile = r.json()['response'][0]
        vk_profile['uid'] = data['user_id']
        profile = extract_normalize_vk_data(vk_profile)
        cred = {'oauthAccessToken': access_token}
        return VKAuthenticationComplete(
            profile=profile,
            credentials=cred,
            provider_name=self.name,
            provider_type=self.type
        )


def extract_normalize_vk_data(data):
    """Extract and normalize VK data returned by the provider"""
    # Names
    profile = {
        'accounts': [
            {
                'domain': 'vk.com',
                'userid': data['uid']
            }
        ],
        'name': {},
        'preferredUsername': data.get('nickname'),
        'photos': [],
        'phoneNumbers': []
    }
    if data['first_name']:
        profile['name']['givenName'] = data['first_name']
    if data['last_name']:
        profile['name']['familyName'] = data['last_name']
    profile['displayName'] = u'{} {}'.format(
        data['first_name'], data['last_name']).strip()

    # Gender
    gender = FIELD_SEX.get(data.get('sex'))
    if gender:
        profile['gender'] = gender

    # Photos
    road_map = [
        [
            # field name
            'photo',
            # default value (i.e. no photo)
            'images/question_c.gif',
            # type
            'thumbnail'
        ],
        ['photo_medium', 'images/question_b.gif', 'medium'],
        ['photo_big', 'images/question_a.gif', 'large'],
        ['photo_rec', 'images/question_a.gif', 'square']
    ]
    for item in road_map:
        photo, default, image_type = item
        photo = data.get(photo)
        if photo and photo != default:
            profile['photos'].append({
                'value': photo,
                'type': image_type
            })

    # Phones
    road_map = [
        [
            # field name
            'mobile_phone',
            # type
            'mobile'
        ],
        ['home_phone', 'home']
    ]
    for item in road_map:
        phone, phone_type = item
        phone = data.get(phone)
        if phone:
            profile['phoneNumbers'].append({
                'value': phone,
                'type': phone_type
            })

    # Now strip out empty values
    for k, v in profile.items():
        if not v or (isinstance(v, list) and not v[0]):
            del profile[k]

    return profile

########NEW FILE########
__FILENAME__ = weibo
"""Sina Microblogging weibo.com Authentication Views"""
import uuid

import requests

from pyramid.httpexceptions import HTTPFound
from pyramid.security import NO_PERMISSION_REQUIRED


from ..api import (
    AuthenticationComplete,
    AuthenticationDenied,
    register_provider,
)
from ..exceptions import CSRFError
from ..exceptions import ThirdPartyFailure
from ..settings import ProviderSettings
from ..utils import flat_url


class WeiboAuthenticationComplete(AuthenticationComplete):
    """Weibo auth complete"""


def includeme(config):
    config.add_directive('add_weibo_login', add_weibo_login)
    config.add_directive('add_weibo_login_from_settings',
                         add_weibo_login_from_settings)


def add_weibo_login_from_settings(config, prefix='velruse.weibo.'):
    settings = config.registry.settings
    p = ProviderSettings(settings, prefix)
    p.update('consumer_key', required=True)
    p.update('consumer_secret', required=True)
    p.update('scope')
    p.update('login_path')
    p.update('callback_path')
    config.add_weibo_login(**p.kwargs)


def add_weibo_login(config,
                    consumer_key,
                    consumer_secret,
                    scope=None,
                    login_path='/login/weibo',
                    callback_path='/login/weibo/callback',
                    name='weibo'):
    """
    Add a Weibo login provider to the application.
    """
    provider = WeiboProvider(name, consumer_key, consumer_secret, scope)

    config.add_route(provider.login_route, login_path)
    config.add_view(provider, attr='login', route_name=provider.login_route,
                    permission=NO_PERMISSION_REQUIRED)

    config.add_route(provider.callback_route, callback_path,
                     use_global_views=True,
                     factory=provider.callback)

    register_provider(config, name, provider)


class WeiboProvider(object):
    def __init__(self, name, consumer_key, consumer_secret, scope):
        self.name = name
        self.type = 'weibo'
        self.consumer_key = consumer_key
        self.consumer_secret = consumer_secret
        self.scope = scope

        self.login_route = 'velruse.%s-login' % name
        self.callback_route = 'velruse.%s-callback' % name

    def login(self, request):
        """Initiate a weibo login"""
        scope = request.POST.get('scope', self.scope)
        request.session['velruse.state'] = state = uuid.uuid4().hex
        url = flat_url('https://api.weibo.com/oauth2/authorize',
                       scope=scope,
                       client_id=self.consumer_key,
                       response_type='code',
                       redirect_uri=request.route_url(self.callback_route),
                       state=state)
        return HTTPFound(url)

    def callback(self, request):
        """Process the weibo redirect"""
        sess_state = request.session.pop('velruse.state', None)
        req_state = request.GET.get('state')
        if not sess_state or sess_state != req_state:
            raise CSRFError(
                'CSRF Validation check failed. Request state {req_state} is '
                'not the same as session state {sess_state}'.format(
                    req_state=req_state,
                    sess_state=sess_state
                )
            )
        code = request.GET.get('code')
        if not code:
            reason = request.GET.get('error_reason', 'No reason provided.')
            return AuthenticationDenied(reason,
                                        provider_name=self.name,
                                        provider_type=self.type)

        # Now retrieve the access token with the code
        r = requests.post(
            'https://api.weibo.com/oauth2/access_token',
            dict(
                client_id=self.consumer_key,
                client_secret=self.consumer_secret,
                redirect_uri=request.route_url(self.callback_route),
                grant_type='authorization_code',
                code=code,
            ),
        )
        if r.status_code != 200:
            raise ThirdPartyFailure("Status %s: %s" % (
                r.status_code, r.content))
        token_data = r.json()
        access_token = token_data['access_token']
        user_id = token_data['uid']

        # Retrieve profile data
        graph_url = flat_url('https://api.weibo.com/2/users/show.json',
                             access_token=access_token,
                             uid=user_id)
        r = requests.get(graph_url)
        if r.status_code != 200:
            raise ThirdPartyFailure("Status %s: %s" % (
                r.status_code, r.content))
        data = r.json()

        profile = {
            'accounts': [{'domain': 'weibo.com', 'userid': data['id']}],
            'gender': data.get('gender'),
            'displayName': data['screen_name'],
            'preferredUsername': data['name'],
            'avatar': data['avatar_large'],
            'data': data
        }

        cred = {'oauthAccessToken': access_token}
        return WeiboAuthenticationComplete(profile=profile,
                                           credentials=cred,
                                           provider_name=self.name,
                                           provider_type=self.type)

########NEW FILE########
__FILENAME__ = yahoo
from __future__ import absolute_import

from openid.extensions import ax

import requests
from requests_oauthlib import OAuth1

from pyramid.security import NO_PERMISSION_REQUIRED

from ..api import register_provider
from ..compat import parse_qsl

from .oid_extensions import OAuthRequest
from .openid import (
    OpenIDAuthenticationComplete,
    OpenIDConsumer,
)


log = __import__('logging').getLogger(__name__)


YAHOO_OAUTH = 'https://api.login.yahoo.com/oauth/v2/get_token'


class YahooAuthenticationComplete(OpenIDAuthenticationComplete):
    """Yahoo auth complete"""


def includeme(config):
    config.add_directive('add_yahoo_login', add_yahoo_login)


def add_yahoo_login(config,
                    realm=None,
                    storage=None,
                    consumer_key=None,
                    consumer_secret=None,
                    login_path='/login/yahoo',
                    callback_path='/login/yahoo/callback',
                    name='yahoo'):
    """
    Add a Yahoo login provider to the application.

    OpenID parameters: realm, storage

    OAuth parameters: consumer_key, consumer_secret
    """
    provider = YahooConsumer(name, realm, storage,
                             consumer_key, consumer_secret)

    config.add_route(provider.login_route, login_path)
    config.add_view(provider, attr='login', route_name=provider.login_route,
                    permission=NO_PERMISSION_REQUIRED)

    config.add_route(provider.callback_route, callback_path,
                     use_global_views=True,
                     factory=provider.callback)

    register_provider(config, name, provider)


class YahooConsumer(OpenIDConsumer):
    def __init__(self, name, realm=None, storage=None,
                 oauth_key=None, oauth_secret=None):
        """Handle Yahoo Auth

        This also handles making an OAuth request during the OpenID
        authentication.

        """
        OpenIDConsumer.__init__(self, name, 'yahoo', realm, storage,
                                context=YahooAuthenticationComplete)
        self.oauth_key = oauth_key
        self.oauth_secret = oauth_secret

    def _lookup_identifier(self, request, identifier):
        """Return the Yahoo OpenID directed endpoint"""
        return 'https://me.yahoo.com/'

    def _update_authrequest(self, request, authrequest):
        # Add on the Attribute Exchange for those that support that
        ax_request = ax.FetchRequest()
        for attrib in ['http://axschema.org/namePerson/friendly',
                       'http://axschema.org/namePerson',
                       'http://axschema.org/person/gender',
                       'http://axschema.org/pref/timezone',
                       'http://axschema.org/media/image/default',
                       'http://axschema.org/contact/email']:
            ax_request.add(ax.AttrInfo(attrib))
        authrequest.addExtension(ax_request)

        # Add OAuth request?
        if 'oauth' in request.POST:
            oauth_request = OAuthRequest(consumer=self.oauth_key)
            authrequest.addExtension(oauth_request)

    def _get_access_token(self, request_token):
        oauth = OAuth1(
            self.oauth_key,
            client_secret=self.oauth_secret,
            resource_owner_key=request_token)

        resp = requests.post(YAHOO_OAUTH, auth=oauth)
        if resp.status_code != 200:
            log.error(
                'OAuth token validation failed. Status: %d, Content: %s',
                resp.status_code, resp.content)
        else:
            access_token = dict(parse_qsl(resp.text))
            return {
                'oauthAccessToken': access_token['oauth_token'],
                'oauthAccessTokenSecret': access_token['oauth_token_secret'],
            }

########NEW FILE########
__FILENAME__ = yandex
"""Yandex Authentication Views

You may see developer docs at http://api.yandex.com/oauth/
"""
import uuid

from pyramid.httpexceptions import HTTPFound
from pyramid.security import NO_PERMISSION_REQUIRED

import requests

from ..api import (
    AuthenticationComplete,
    AuthenticationDenied,
    register_provider,
)
from ..exceptions import CSRFError, ThirdPartyFailure
from ..settings import ProviderSettings
from ..utils import flat_url


PROVIDER_NAME = 'yandex'
PROVIDER_AUTH_URL = 'https://oauth.yandex.ru/authorize'
PROVIDER_ACCESS_TOKEN_URL = 'https://oauth.yandex.ru/token'
PROVIDER_USER_PROFILE_URL = 'https://login.yandex.ru/info'


class YandexAuthenticationComplete(AuthenticationComplete):
    """Yandex auth complete"""


def includeme(config):
    config.add_directive('add_yandex_login', add_yandex_login)
    config.add_directive('add_yandex_login_from_settings',
                         add_yandex_login_from_settings)


def add_yandex_login_from_settings(config, prefix='velruse.yandex.'):
    settings = config.registry.settings
    p = ProviderSettings(settings, prefix)
    p.update('consumer_key', required=True)
    p.update('consumer_secret', required=True)
    p.update('login_path')
    p.update('callback_path')
    config.add_yandex_login(**p.kwargs)


def add_yandex_login(
    config,
    consumer_key,
    consumer_secret,
    login_path='/login/{name}'.format(name=PROVIDER_NAME),
    callback_path='/login/{name}/callback'.format(name=PROVIDER_NAME),
    name=PROVIDER_NAME
):
    """Add a Yandex login provider to the application."""
    provider = YandexProvider(name, consumer_key, consumer_secret)
    config.add_route(provider.login_route, login_path)
    config.add_view(
        provider,
        attr='login',
        route_name=provider.login_route,
        permission=NO_PERMISSION_REQUIRED
    )
    config.add_route(
        provider.callback_route, callback_path,
        use_global_views=True,
        factory=provider.callback
    )
    register_provider(config, name, provider)


class YandexProvider(object):

    def __init__(self, name, consumer_key, consumer_secret):
        self.name = name
        self.type = PROVIDER_NAME
        self.consumer_key = consumer_key
        self.consumer_secret = consumer_secret
        self.login_route = 'velruse.{name}-login'.format(name=name)
        # Yandex doesn't support redirect_uri and scope parameters in
        # the query string.
        # You must define the Callback URI and the Scope fields manually in
        # application's settings page at https://oauth.yandex.ru/client/my
        # The following attribute is left intact in order to preserve API
        # consistency.
        self.callback_route = 'velruse.{name}-callback'.format(name=name)

    def login(self, request):
        """Initiate a Yandex login"""
        request.session['velruse.state'] = state = uuid.uuid4().hex
        auth_url = flat_url(
            PROVIDER_AUTH_URL,
            client_id=self.consumer_key,
            response_type='code',
            state=state
        )
        return HTTPFound(location=auth_url)

    def callback(self, request):
        """Process the Yandex redirect"""
        sess_state = request.session.pop('velruse.state', None)
        req_state = request.GET.get('state')
        if not sess_state or sess_state != req_state:
            raise CSRFError(
                'CSRF Validation check failed. Request state {req_state} is '
                'not the same as session state {sess_state}'.format(
                    req_state=req_state,
                    sess_state=sess_state
                )
            )
        code = request.GET.get('code')
        if not code:
            reason = request.GET.get('error', 'No reason provided.')
            return AuthenticationDenied(
                reason=reason,
                provider_name=self.name,
                provider_type=self.type
            )
        # Now retrieve the access token with the code
        token_params = {
            'grant_type': 'authorization_code',
            'code': code,
            'client_id': self.consumer_key,
            'client_secret': self.consumer_secret,
        }
        r = requests.post(PROVIDER_ACCESS_TOKEN_URL, token_params)
        if r.status_code != 200:
            raise ThirdPartyFailure(
                'Status {status}: {content}'.format(
                    status=r.status_code, content=r.content
                )
            )
        data = r.json()
        access_token = data['access_token']

        # Retrieve profile data
        profile_url = flat_url(
            PROVIDER_USER_PROFILE_URL,
            format='json',
            oauth_token=access_token
        )
        r = requests.get(profile_url)
        if r.status_code != 200:
            raise ThirdPartyFailure(
                'Status {status}: {content}'.format(
                    status=r.status_code, content=r.content
                )
            )
        profile = r.json()
        profile = extract_normalize_yandex_data(profile)
        cred = {'oauthAccessToken': access_token}
        return YandexAuthenticationComplete(
            profile=profile,
            credentials=cred,
            provider_name=self.name,
            provider_type=self.type
        )


def extract_normalize_yandex_data(data):
    """Extract and normalize Yandex data returned by the provider"""
    profile = {
        'accounts': [
            {
                'domain': 'yandex.ru',
                'userid': data['id']
            }
        ],
        'birthday': data.get('birthday'),
        'gender': data.get('sex'),
    }

    email = data.get('default_email')
    if email:
        profile['emails'] = [{
            'value': email,
            'primary': True
        }]

    display_name = data.get('display_name')
    if display_name:
        profile['preferredUsername'] = display_name
        profile['nickname'] = display_name
    real_name = data.get('real_name')
    profile['displayName'] = (
        real_name
        or display_name
        or u'Yandex user #{id}'.format(id=data['id'])
    )

    # Now strip out empty values
    for k, v in profile.items():
        if not v or (isinstance(v, list) and not v[0]):
            del profile[k]

    return profile

########NEW FILE########
__FILENAME__ = settings
def splitlines(s):
    return filter(None, [x.strip() for x in s.splitlines()])


class ProviderSettings(object):
    def __init__(self, settings, prefix=''):
        self.settings = settings
        self.prefix = prefix
        self.kwargs = {}

    def update(self, src, dst=None, required=False):
        if dst is None:
            dst = src
        key = self.prefix + src
        if key in self.settings:
            value = self.settings[key]

            # if value is equal to 'false' or 'true'
            # cast it as a boolean
            if value == 'true':
                value = True
            elif value == 'false':
                value = False

            self.kwargs[dst] = value
        elif required:
            raise KeyError('missing required setting "%s"' % key)

########NEW FILE########
__FILENAME__ = utils
"""Utilities for the auth functionality"""
from .compat import urlencode

def flat_url(url, **kw):
    """Creates a URL with the query param encoded"""
    return url + '?' + urlencode(kw)

########NEW FILE########
