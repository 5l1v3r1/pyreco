__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# PyRabbit documentation build configuration file, created by
# sphinx-quickstart on Tue Sep 20 22:48:33 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))
sys.path.insert(0, os.path.abspath('..'))
# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.coverage', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
#templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'PyRabbit'
copyright = u'2011, Brian K. Jones'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '1.0.0'
# The full version, including alpha/beta/rc tags.
release = '1.0.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'nature'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
#html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'PyRabbitdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'PyRabbit.tex', u'PyRabbit Documentation',
   u'Brian K. Jones', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'pyrabbit', u'PyRabbit Documentation',
     [u'Brian K. Jones'], 1)
]

########NEW FILE########
__FILENAME__ = api
"""
The api module houses the Client class, which provides the main interface
developers will use to interact with RabbitMQ. It also contains errors and
decorators used by the class.
"""

from . import http
import functools
import json
try:
    #python 2.x
    from urllib import quote
except ImportError:
    #python 3.x
    from urllib.parse import quote


class APIError(Exception):
    """Denotes a failure due to unexpected or invalid
    input/output between the client and the API

    """
    pass


class PermissionError(Exception):
    """
    Raised if the operation requires admin permissions, and the user used to
    instantiate the Client class does not have admin privileges.
    """
    pass


def needs_admin_privs(fun):
    """
    A decorator that can be added to any of the Client methods in order to
    indicate that admin privileges should be checked for before issuing an
    HTTP call (if possible - if Client.is_admin isn't set, an HTTP call is
    made to find out).

    """
    @functools.wraps(fun)
    def wrapper(self, *args, **kwargs):
        """
        This is the function that runs in place of the one being decorated.

        """
        if self.has_admin_rights:
            return fun(self, *args, **kwargs)
        else:
            raise PermissionError("Insufficient privs. User '%s'" % self.user)
    return wrapper


class Client(object):
    """
    Abstraction of the RabbitMQ Management HTTP API.

    HTTP calls are delegated to the  HTTPClient class for ease of testing,
    cleanliness, separation of duty, flexibility, etc.
    """
    urls = {'overview': 'overview',
            'all_queues': 'queues',
            'all_exchanges': 'exchanges',
            'all_channels': 'channels',
            'all_connections': 'connections',
            'all_nodes': 'nodes',
            'all_vhosts': 'vhosts',
            'all_users': 'users',
            'all_bindings': 'bindings',
            'whoami': 'whoami',
            'queues_by_vhost': 'queues/%s',
            'queues_by_name': 'queues/%s/%s',
            'exchanges_by_vhost': 'exchanges/%s',
            'exchange_by_name': 'exchanges/%s/%s',
            'live_test': 'aliveness-test/%s',
            'purge_queue': 'queues/%s/%s/contents',
            'channels_by_name': 'channels/%s',
            'connections_by_name': 'connections/%s',
            'bindings_by_source_exch': 'exchanges/%s/%s/bindings/source',
            'bindings_by_dest_exch': 'exchanges/%s/%s/bindings/destination',
            'bindings_on_queue': 'queues/%s/%s/bindings',
            'bindings_between_exch_queue': 'bindings/%s/e/%s/q/%s',
            'rt_bindings_between_exch_queue': 'bindings/%s/e/%s/q/%s/%s',
            'get_from_queue': 'queues/%s/%s/get',
            'publish_to_exchange': 'exchanges/%s/%s/publish',
            'vhosts_by_name': 'vhosts/%s',
            'vhost_permissions': 'permissions/%s/%s',
            'users_by_name': 'users/%s'
            }

    json_headers = {"content-type": "application/json"}

    def __init__(self, host, user, passwd, timeout=5):
        """
        :param string host: string of the form 'host:port'
        :param string user: username used to authenticate to the API.
        :param string passwd: password used to authenticate to the API.

        Populates server attributes using passed-in parameters and
        the HTTP API's 'overview' information. It also instantiates
        an httplib2 HTTP client and adds credentia    ls

        """
        self.host = host
        self.user = user
        self.passwd = passwd
        self.timeout = timeout
        self.http = http.HTTPClient(
            self.host,
            self.user,
            self.passwd,
            self.timeout
        )

        # initialize this now. @needs_admin_privs will check this first to
        # avoid making an HTTP call. If this is None, it'll trigger an
        # HTTP call (by calling self.has_admin_rights) and populate this for
        # next time.
        self.is_admin = None
        return

    @needs_admin_privs
    def is_alive(self, vhost='%2F'):
        """
        Uses the aliveness-test API call to determine if the
        server is alive and the vhost is active. The broker (not this code)
        creates a queue and then sends/consumes a message from it.

        :param string vhost: There should be no real reason to ever change
            this from the default value, but it's there if you need to.
        :returns bool: True if alive, False otherwise
        :raises: HTTPError if *vhost* doesn't exist on the broker.

        """
        uri = Client.urls['live_test'] % quote(vhost, '')

        try:
            resp = self.http.do_call(uri, 'GET')
        except http.HTTPError as err:
            if err.status == 404:
                raise APIError("No vhost named '%s'" % vhost)
            raise

        if resp['status'] == 'ok':
            return True
        else:
            return False

    def get_whoami(self):
        """
        A convenience function used in the event that you need to confirm that
        the broker thinks you are who you think you are.

        :returns dict whoami: Dict structure contains:
            * administrator: whether the user is has admin privileges
            * name: user name
            * auth_backend: backend used to determine admin rights
        """
        path = Client.urls['whoami']
        whoami = self.http.do_call(path, 'GET')
        return whoami

    @property
    def has_admin_rights(self):
        """
        Determine if the creds passed in for authentication have admin
        rights to RabbitMQ data. If not, then there's a decent amount of
        information you can't get at.

        :returns bool is_admin: True if self.user has admin rights.

        """
        if self.is_admin is None:
            whoami = self.get_whoami()
            self.is_admin = whoami.get('tags', '') == 'administrator'

        return self.is_admin

    def get_overview(self):
        """
        :rtype: dict

        Data in the 'overview' depends on the privileges of the creds used,
        but typically contains information about the management plugin version,
        some high-level message stats, and aggregate queue totals. Admin-level
        creds gets you information about the cluster node, listeners, etc.


        """
        overview = self.http.do_call(Client.urls['overview'], 'GET')
        return overview

    @needs_admin_privs
    def get_users(self):
        """
        Returns a list of dictionaries, each containing the attributes of a
        different RabbitMQ user.

        :returns: a list of dictionaries, each representing a user. This
              method is decorated with '@needs_admin_privs', and will raise
              an error if the credentials used to set up the broker connection
              do not have admin privileges.

        """

        users = self.http.do_call(Client.urls['all_users'], 'GET')
        return users

    ################################################
    ###         VHOSTS
    ################################################
    def get_all_vhosts(self):
        """
        Lists the names of all RabbitMQ vhosts.

        :returns: a list of dicts, each dict representing a vhost
                on the broker.

        """
        vhosts = self.http.do_call(Client.urls['all_vhosts'], 'GET')
        return vhosts

    def get_vhost_names(self):
        """
        A convenience function for getting back only the vhost names instead of
        the larger vhost dicts.

        :returns list vhost_names: A list of just the vhost names.
        """
        vhosts = self.get_all_vhosts()
        vhost_names = [i['name'] for i in vhosts]
        return vhost_names

    def get_vhost(self, vname):
        """
        Returns the attributes of a single named vhost in a dict.

        :param string vname: Name of the vhost to get.
        :returns dict vhost: Attribute dict for the named vhost

        """

        vname = quote(vname, '')
        path = Client.urls['vhosts_by_name'] % vname
        vhost = self.http.do_call(path, 'GET', headers=Client.json_headers)
        return vhost

    def create_vhost(self, vname):
        """
        Creates a vhost on the server to house exchanges.

        :param string vname: The name to give to the vhost on the server
        :returns: boolean
        """
        vname = quote(vname, '')
        path = Client.urls['vhosts_by_name'] % vname
        return self.http.do_call(path, 'PUT',
                                 headers=Client.json_headers)

    def delete_vhost(self, vname):
        """
        Deletes a vhost from the server. Note that this also deletes any
        exchanges or queues that belong to this vhost.

        :param string vname: Name of the vhost to delete from the server.
        """
        vname = quote(vname, '')
        path = Client.urls['vhosts_by_name'] % vname
        return self.http.do_call(path, 'DELETE')

    def set_vhost_permissions(self, vname, username, config, rd, wr):
        """
        Set permissions for a given username on a given vhost. Both
        must already exist.

        :param string vname: Name of the vhost to set perms on.
        :param string username: User to set permissions for.
        :param string config: Permission pattern for configuration operations
            for this user in this vhost.
        :param string rd: Permission pattern for read operations for this user
            in this vhost
        :param string wr: Permission pattern for write operations for this user
            in this vhost.

        Permission patterns are regex strings. If you're unfamiliar with this,
        you should definitely check out this section of the RabbitMQ docs:

        http://www.rabbitmq.com/admin-guide.html#access-control
        """
        vname = quote(vname, '')
        body = json.dumps({"configure": config, "read": rd, "write": wr})
        path = Client.urls['vhost_permissions'] % (vname, username)
        return self.http.do_call(path, 'PUT', body,
                                 headers=Client.json_headers)

    ###############################################
    ##           EXCHANGES
    ###############################################
    def get_exchanges(self, vhost=None):
        """
        :returns: A list of dicts
        :param string vhost: A vhost to query for exchanges, or None (default),
            which triggers a query for all exchanges in all vhosts.

        """
        if vhost:
            vhost = quote(vhost, '')
            path = Client.urls['exchanges_by_vhost'] % vhost
        else:
            path = Client.urls['all_exchanges']

        exchanges = self.http.do_call(path, 'GET')
        return exchanges

    def get_exchange(self, vhost, name):
        """
        Gets a single exchange which requires a vhost and name.

        :param string vhost: The vhost containing the target exchange
        :param string name: The name of the exchange
        :returns: dict

        """
        vhost = quote(vhost, '')
        name = quote(name, '')
        path = Client.urls['exchange_by_name'] % (vhost, name)
        exch = self.http.do_call(path, 'GET')
        return exch

    def create_exchange(self,
                        vhost,
                        name,
                        xtype,
                        auto_delete=False,
                        durable=True,
                        internal=False,
                        arguments=None):
        """
        Creates an exchange in the given vhost with the given name. As per the
        RabbitMQ API documentation, a JSON body also needs to be included that
        "looks something like this":

        {"type":"direct",
        "auto_delete":false,
        "durable":true,
        "internal":false,
        "arguments":[]}

        On success, the API returns a 204 with no content, in which case this
        function returns True. If any other response is received, it's raised.

        :param string vhost: Vhost to create the exchange in.
        :param string name: Name of the proposed exchange.
        :param string type: The AMQP exchange type.
        :param bool auto_delete: Whether or not the exchange should be
            dropped when the no. of consumers drops to zero.
        :param bool durable: Whether you want this exchange to persist a
            broker restart.
        :param bool internal: Whether or not this is a queue for use by the
            broker only.
        :param list arguments: If given, should be a list. If not given, an
            empty list is sent.

        """

        vhost = quote(vhost, '')
        name = quote(name, '')
        path = Client.urls['exchange_by_name'] % (vhost, name)
        base_body = {"type": xtype, "auto_delete": auto_delete,
                     "durable": durable, "internal": internal,
                     "arguments": arguments or list()}

        body = json.dumps(base_body)
        self.http.do_call(path, 'PUT', body,
                          headers=Client.json_headers)
        return True

    def publish(self, vhost, xname, rt_key, payload, payload_enc='string',
                properties=None):
        """
        Publish a message to an exchange.

        :param string vhost: vhost housing the target exchange
        :param string xname: name of the target exchange
        :param string rt_key: routing key for message
        :param string payload: the message body for publishing
        :param string payload_enc: encoding of the payload. The only choices
                      here are 'string' and 'base64'.
        :param dict properties: a dict of message properties
        :returns: boolean indicating success or failure.
        """
        vhost = quote(vhost, '')
        xname = quote(xname, '')
        path = Client.urls['publish_to_exchange'] % (vhost, xname)
        body = json.dumps({'routing_key': rt_key, 'payload': payload,
                           'payload_encoding': payload_enc,
                           'properties': properties or {}})
        result = self.http.do_call(path, 'POST', body)
        return result['routed']

    def delete_exchange(self, vhost, name):
        """
        Delete the named exchange from the named vhost. The API returns a 204
        on success, in which case this method returns True, otherwise the
        error is raised.

        :param string vhost: Vhost where target exchange was created
        :param string name: The name of the exchange to delete.
        :returns bool: True on success.
        """
        vhost = quote(vhost, '')
        name = quote(name, '')
        path = Client.urls['exchange_by_name'] % (vhost, name)
        self.http.do_call(path, 'DELETE')
        return True

    #############################################
    ##              QUEUES
    #############################################
    def get_queues(self, vhost=None):
        """
        Get all queues, or all queues in a vhost if vhost is not None.
        Returns a list.

        :param string vhost: The virtual host to list queues for. If This is
                    None (the default), all queues for the broker instance
                    are returned.
        :returns: A list of dicts, each representing a queue.
        :rtype: list of dicts

        """
        if vhost:
            vhost = quote(vhost, '')
            path = Client.urls['queues_by_vhost'] % vhost
        else:
            path = Client.urls['all_queues']

        queues = self.http.do_call(path, 'GET')
        return queues or list()

    def get_queue(self, vhost, name):
        """
        Get a single queue, which requires both vhost and name.

        :param string vhost: The virtual host for the queue being requested.
            If the vhost is '/', note that it will be translated to '%2F' to
            conform to URL encoding requirements.
        :param string name: The name of the queue being requested.
        :returns: A dictionary of queue properties.
        :rtype: dict

        """
        vhost = quote(vhost, '')
        name = quote(name, '')
        path = Client.urls['queues_by_name'] % (vhost, name)
        queue = self.http.do_call(path, 'GET')
        return queue

    def get_queue_depth(self, vhost, name):
        """
        Get the number of messages currently in a queue. This is a convenience
         function that just calls :meth:`Client.get_queue` and pulls
         out/returns the 'messages' field from the dictionary it returns.

        :param string vhost: The vhost of the queue being queried.
        :param string name: The name of the queue to query.
        :returns: Number of messages in the queue
        :rtype: integer

        """
        vhost = quote(vhost, '')
        name = quote(name, '')
        path = Client.urls['queues_by_name'] % (vhost, name)
        queue = self.http.do_call(path,'GET')
        depth = queue['messages']

        return depth

    def get_queue_depths(self, vhost, names=None):
        """
        Get the number of messages currently sitting in either the queue
        names listed in 'names', or all queues in 'vhost' if no 'names' are
        given.

        :param str vhost: Vhost where queues in 'names' live.
        :param list names: OPTIONAL - Specific queues to show depths for. If
                None, show depths for all queues in 'vhost'.
        """

        vhost = quote(vhost, '')
        if not names:
            # get all queues in vhost
            path = Client.urls['queues_by_vhost'] % vhost
            queues = self.http.do_call(path, 'GET')
            for queue in queues:
                depth = queue['messages']
                print("\t%s: %s" % (queue, depth))
        else:
            # get the named queues only.
            for name in names:
                depth = self.get_queue_depth(vhost, name)
                print("\t%s: %s" % (name, depth))


    def purge_queues(self, queues):
        """
        Purge all messages from one or more queues.

        :param list queues: A list of ('qname', 'vhost') tuples.
        :returns: True on success

        """
        for name, vhost in queues:
            vhost = quote(vhost, '')
            name = quote(name, '')
            path = Client.urls['purge_queue'] % (vhost, name)
            self.http.do_call(path, 'DELETE')
        return True

    def purge_queue(self, vhost, name):
        """
        Purge all messages from a single queue. This is a convenience method
        so you aren't forced to supply a list containing a single tuple to
        the purge_queues method.

        :param string vhost: The vhost of the queue being purged.
        :param string name: The name of the queue being purged.
        :rtype: None

        """
        vhost = quote(vhost, '')
        name = quote(name, '')
        path = Client.urls['purge_queue'] % (vhost, name)
        return self.http.do_call(path, 'DELETE')

    def create_queue(self, vhost, name, **kwargs):
        """
        Create a queue. The API documentation specifies that all of the body
        elements are optional, so this method only requires arguments needed
        to form the URI

        :param string vhost: The vhost to create the queue in.
        :param string name: The name of the queue

        More on these operations can be found at:
        http://www.rabbitmq.com/amqp-0-9-1-reference.html

        """

        vhost = quote(vhost, '')
        name = quote(name, '')
        path = Client.urls['queues_by_name'] % (vhost, name)

        body = json.dumps(kwargs)

        return self.http.do_call(path,
                                 'PUT',
                                 body,
                                 headers=Client.json_headers)

    def delete_queue(self, vhost, qname):
        """
        Deletes the named queue from the named vhost.

        :param string vhost: Vhost housing the queue to be deleted.
        :param string qname: Name of the queue to delete.

        Note that if you just want to delete the messages from a queue, you
        should use purge_queue instead of deleting/recreating a queue.
        """
        vhost = quote(vhost, '')
        qname = quote(qname, '')
        path = Client.urls['queues_by_name'] % (vhost, qname)
        return self.http.do_call(path, 'DELETE', headers=Client.json_headers)

    def get_messages(self, vhost, qname, count=1,
                     requeue=False, truncate=None, encoding='auto'):
        """
        Gets <count> messages from the queue.

        :param string vhost: Name of vhost containing the queue
        :param string qname: Name of the queue to consume from
        :param int count: Number of messages to get.
        :param bool requeue: Whether to requeue the message after getting it.
            This will cause the 'redelivered' flag to be set in the message on
            the queue.
        :param int truncate: The length, in bytes, beyond which the server will
            truncate the message before returning it.
        :returns: list of dicts. messages[msg-index]['payload'] will contain
                the message body.
        """

        vhost = quote(vhost, '')
        base_body = {'count': count, 'requeue': requeue, 'encoding': encoding}
        if truncate:
            base_body['truncate'] = truncate
        body = json.dumps(base_body)

        qname = quote(qname, '')
        path = Client.urls['get_from_queue'] % (vhost, qname)
        messages = self.http.do_call(path, 'POST', body,
                                     headers=Client.json_headers)
        return messages

    #########################################
    # CONNS/CHANS & BINDINGS
    #########################################
    def get_connections(self):
        """
        :returns: list of dicts, or an empty list if there are no connections.
        """
        path = Client.urls['all_connections']
        conns = self.http.do_call(path, 'GET')
        return conns

    def get_connection(self, name):
        """
        Get a connection by name. To get the names, use get_connections.

        :param string name: Name of connection to get
        :returns dict conn: A connection attribute dictionary.

        """
        name = quote(name, '')
        path = Client.urls['connections_by_name'] % name
        conn = self.http.do_call(path, 'GET')
        return conn

    def delete_connection(self, name):
        """
        Close the named connection. The API returns a 204 on success,
        in which case this method returns True, otherwise the
        error is raised.

        :param string name: The name of the connection to delete.
        :returns bool: True on success.
        """
        name = quote(name, '')
        path = Client.urls['connections_by_name'] % name
        self.http.do_call(path, 'DELETE')
        return True

    def get_channels(self):
        """
        Return a list of dicts containing details about broker connections.
        :returns: list of dicts
        """
        path = Client.urls['all_channels']
        chans = self.http.do_call(path, 'GET')
        return chans

    def get_channel(self, name):
        """
        Get a channel by name. To get the names, use get_channels.

        :param string name: Name of channel to get
        :returns dict conn: A channel attribute dictionary.

        """
        name = quote(name, '')
        path = Client.urls['channels_by_name'] % name
        chan = self.http.do_call(path, 'GET')
        return chan

    def get_bindings(self):
        """
        :returns: list of dicts

        """
        path = Client.urls['all_bindings']
        bindings = self.http.do_call(path, 'GET')
        return bindings

    def get_queue_bindings(self, vhost, qname):
        """
        Return a list of dicts, one dict per binding. The dict format coming
        from RabbitMQ for queue named 'testq' is:

        {"source":"sourceExch","vhost":"/","destination":"testq",
         "destination_type":"queue","routing_key":"*.*","arguments":{},
         "properties_key":"%2A.%2A"}
        """
        vhost = quote(vhost, '')
        qname = quote(qname, '')
        path = Client.urls['bindings_on_queue'] % (vhost, qname)
        bindings = self.http.do_call(path, 'GET')
        return bindings

    def get_bindings_from_exchange(self, vhost, exch):
        pass

    def get_bindings_to_exchange(self, vhost, exch):
        pass

    def get_bindings_between_exch_and_queue(self, vhost, exch, queue):
        pass

    def create_binding(self, vhost, exchange, queue, rt_key=None, args=None):
        """
        Creates a binding between an exchange and a queue on a given vhost.

        :param string vhost: vhost housing the exchange/queue to bind
        :param string exchange: the target exchange of the binding
        :param string queue: the queue to bind to the exchange
        :param string rt_key: the routing key to use for the binding
        :param list args: extra arguments to associate w/ the binding.
        :returns: boolean
        """

        vhost = quote(vhost, '')
        exchange = quote(exchange, '')
        queue = quote(queue, '')
        body = json.dumps({'routing_key': rt_key, 'arguments': args or []})
        path = Client.urls['bindings_between_exch_queue'] % (vhost,
                                                             exchange,
                                                             queue)
        binding = self.http.do_call(path, 'POST', body=body,
                                    headers=Client.json_headers)
        return binding

    def delete_binding(self, vhost, exchange, queue, rt_key):
        """
        Deletes a binding between an exchange and a queue on a given vhost.

        :param string vhost: vhost housing the exchange/queue to bind
        :param string exchange: the target exchange of the binding
        :param string queue: the queue to bind to the exchange
        :param string rt_key: the routing key to use for the binding
        """

        vhost = quote(vhost, '')
        exchange = quote(exchange, '')
        queue = quote(queue, '')
        body = ''
        path = Client.urls['rt_bindings_between_exch_queue'] % (vhost,
                                                                exchange,
                                                                queue,
                                                                rt_key)
        return self.http.do_call(path, 'DELETE', headers=Client.json_headers)

    def create_user(self, username, password, tags=""):
        """
        Creates a user.

        :param string username: The name to give to the new user
        :param string password: Password for the new user
        :param string tags: Comma-separated list of tags for the user
        :returns: boolean
        """
        path = Client.urls['users_by_name'] % username
        body = json.dumps({'password': password, 'tags': tags})
        return self.http.do_call(path, 'PUT', body=body,
                                 headers=Client.json_headers)

    def delete_user(self, username):
        """
        Deletes a user from the server.

        :param string username: Name of the user to delete from the server.
        """
        path = Client.urls['users_by_name'] % username
        return self.http.do_call(path, 'DELETE')

########NEW FILE########
__FILENAME__ = http

import json
import os
import socket
import httplib2


class HTTPError(Exception):
    """
    An error response from the API server. This should be an
    HTTP error of some kind (404, 500, etc).

    """
    def __init__(self, content, status=None, reason=None, path=None, body=None):
        #HTTP status code
        self.status = status
        # human readable HTTP status
        self.reason = reason
        self.path = path
        self.body = body
        self.detail = None

        # Actual, useful reason for failure returned by RabbitMQ
        self.detail=None
        if content and content.get('reason'):
            self.detail = content['reason']

        self.output = "%s - %s (%s) (%s) (%s)" % (self.status,
                                             self.reason,
                                             self.detail,
                                             self.path,
                                             repr(self.body))

    def __str__(self):
        return self.output


class NetworkError(Exception):
    """Denotes a failure to communicate with the REST API

    """
    pass


class HTTPClient(object):
    """
    A wrapper for (currently) httplib2. Abstracts away
    things like path building, return value parsing, etc.,
    so the api module code stays clean and easy to read/use.

    """

    def __init__(self, server, uname, passwd, timeout=5):
        """
        :param string server: 'host:port' string denoting the location of the
            broker and the port for interfacing with its REST API.
        :param string uname: Username credential used to authenticate.
        :param string passwd: Password used to authenticate w/ REST API
        :param int timeout: Integer number of seconds to wait for each call.

        """

        self.client = httplib2.Http(timeout=timeout)
        self.client.add_credentials(uname, passwd)
        self.base_url = 'http://%s/api' % server

    def decode_json_content(self, content):
        """
        Returns the JSON-decoded Python representation of 'content'.

        :param json content: A Python JSON object.

        """
        try:
            py_ct = json.loads(content)
        except ValueError as out:
            print("%s: %s - (%s) (%s)" % (type(out), out, content, type(content)))
            return None
        except TypeError:
            # in later Python 3.x versions, some calls return bytes objects.
            py_ct = json.loads(content.decode())
        return py_ct

    def do_call(self, path, reqtype, body=None, headers=None):
        """
        Send an HTTP request to the REST API.

        :param string path: A URL
        :param string reqtype: The HTTP method (GET, POST, etc.) to use
            in the request.
        :param string body: A string representing any data to be sent in the
            body of the HTTP request.
        :param dictionary headers:
            "{header-name: header-value}" dictionary.

        """
        url = os.path.join(self.base_url, path)
        try:
            resp, content = self.client.request(url,
                                                reqtype,
                                                body,
                                                headers)
        except socket.timeout as out:
            raise NetworkError("Timout while trying to connect to RabbitMQ")
        except Exception as out:
            # net-related exception types from httplib2 are unpredictable.
            raise NetworkError("Error: %s %s" % (type(out), out))

        # RabbitMQ will return content even on certain failures.
        if content:
            content = self.decode_json_content(content)

        # 'success' HTTP status codes are 200-206
        if resp.status < 200 or resp.status > 206:
            raise HTTPError(content, resp.status, resp.reason, path, body)
        else:
            if content:
                return content
            else:
                return None

########NEW FILE########
__FILENAME__ = test_httpclient
try:
    import unittest2 as unittest
except ImportError:
    import unittest

import sys
sys.path.append('..')
from pyrabbit import http



class TestHTTPClient(unittest.TestCase):
    """
    Except for the init test, these are largely functional tests that
    require a RabbitMQ management API to be available on localhost

    """
    testhost = 'localhost:15672'
    testuser = 'guest'
    testpass = 'guest'
    def setUp(self):
        self.c = http.HTTPClient(self.testhost, self.testuser, self.testpass)

    def test_client_init(self):
        c = http.HTTPClient(self.testhost, self.testuser, self.testpass)
        self.assertIsInstance(c, http.HTTPClient)

    def test_client_init_sets_credentials(self):
        domain = ''
        expected_credentials = [(domain, self.testuser, self.testpass)]
        self.assertEqual(
            self.c.client.credentials.credentials, expected_credentials)

    def test_client_init_sets_default_timeout(self):
        self.assertEqual(self.c.client.timeout, 5)

    def test_client_init_with_timeout(self):
        c = http.HTTPClient(self.testhost, self.testuser, self.testpass, 1)
        self.assertEqual(c.client.timeout, 1)


########NEW FILE########
__FILENAME__ = test_pyrabbit
"""Main test file for the pyrabbit Client."""

import json

try:
    #python 2.x
    import unittest2 as unittest
except ImportError:
    #python 3.x
    import unittest

import sys
sys.path.append('..')
import pyrabbit
from mock import Mock, patch

class TestClient(unittest.TestCase):
    def setUp(self):
        self.client = pyrabbit.api.Client('localhost:55672', 'guest', 'guest')

    def tearDown(self):
        del self.client

    def test_server_init_200(self):
        self.assertIsInstance(self.client, pyrabbit.api.Client)
        self.assertEqual(self.client.host, 'localhost:55672')

    def test_server_is_alive_default_vhost(self):
        response = {'status': 'ok'}
        self.client.http.do_call = Mock(return_value=response)
        with patch.object(pyrabbit.api.Client, 'has_admin_rights') as mock_rights:
            mock_rights.__get__ = Mock(return_value=True)
            self.assertTrue(self.client.is_alive())

    def test_get_vhosts_200(self):
        self.client.http.do_call = Mock(return_value=[])
        vhosts = self.client.get_all_vhosts()
        self.assertIsInstance(vhosts, list)

    def test_get_all_queues(self):
        self.client.http.do_call = Mock(return_value=[])
        queues = self.client.get_queues()
        self.assertIsInstance(queues, list)

    def test_purge_queues(self):
        self.client.http.do_call = Mock(return_value=True)
        self.assertTrue(self.client.purge_queues(['q1', 'q2']))

    def test_get_all_exchanges(self):
        xchs = [{'name': 'foo', 'vhost': '/', 'type': 'direct',
                 'durable': False, 'auto_delete': False, 'internal': False,
                 'arguments': {}},

                {'name': 'bar', 'vhost': '/', 'type': 'direct',
                 'durable': False, 'auto_delete': False, 'internal': False,
                 'arguments': {}},]
        self.client.http.do_call = Mock(return_value=xchs)
        xlist = self.client.get_exchanges()
        self.assertIsInstance(xlist, list)
        self.assertEqual(len(xlist), 2)

    def test_get_named_exchange(self):
        xch = {'name': 'foo', 'vhost': '/', 'type': 'direct',
                 'durable': False, 'auto_delete': False, 'internal': False,
                 'arguments': {}}
        self.client.http.do_call = Mock(return_value=xch)
        myexch = self.client.get_exchange('%2F', 'foo')
        self.assertEqual(myexch['name'], 'foo')

    @patch.object(pyrabbit.api.Client, 'has_admin_rights')
    def test_get_users_noprivs(self, has_rights):
        has_rights.__get__ = Mock(return_value=False)
        self.assertRaises(pyrabbit.api.PermissionError, self.client.get_users)

    @patch.object(pyrabbit.api.Client, 'has_admin_rights')
    def test_get_users_withprivs(self, has_rights):
        has_rights.return_value = True
        with patch('pyrabbit.http.HTTPClient.do_call') as do_call:
            self.assertTrue(self.client.get_users())

    def test_get_queue_depth(self):
        q = {'messages': 4}
        self.client.http.do_call = Mock(return_value=q)
        depth = self.client.get_queue_depth('/', 'test')
        self.assertEqual(depth, q['messages'])

    def test_get_queue_depth_2(self):
        """
        An integration test that includes the HTTP client's do_call
        method and json decoding operations.

        """
        q = {'messages': 8}
        json_q = json.dumps(q)

        with patch('httplib2.Response') as resp:
            resp.reason = 'response reason here'
            resp.status = 200
            self.client.http.client.request = Mock(return_value=(resp, json_q))
            depth = self.client.get_queue_depth('/', 'test')
            self.assertEqual(depth, q['messages'])

    def test_purge_queue(self):
        self.client.http.do_call = Mock(return_value=True)
        self.assertTrue(self.client.purge_queue('vname', 'qname'))

    def test_create_queue(self):
        self.client.http.do_call = Mock(return_value=True)
        self.assertTrue(self.client.create_queue('qname', 'vname'))

    def test_get_connections(self):
        self.client.http.do_call = Mock(return_value=True)
        self.assertTrue(self.client.get_connections())

    def test_get_connection(self):
        self.client.http.do_call = Mock(return_value=True)
        self.assertTrue(self.client.get_connection('cname'))

    def test_delete_connection(self):
        self.client.http.do_call = Mock(return_value=True)
        self.assertTrue(self.client.delete_connection('127.0.0.1:1234 -> 127.0.0.1:5678 (1)'))

    def test_get_channels(self):
        self.client.http.do_call = Mock(return_value=True)
        self.assertTrue(self.client.get_channels())

    def test_get_channel(self):
        self.client.http.do_call = Mock(return_value=True)
        self.assertTrue(self.client.get_channel('127.0.0.1:1234 -> 127.0.0.1:5678 (1)'))

    def test_get_bindings(self):
        self.client.http.do_call = Mock(return_value=True)
        self.assertTrue(self.client.get_bindings())

    def test_create_binding(self):
        self.client.http.do_call = Mock(return_value=True)
        self.assertTrue(self.client.create_binding('vhost',
                                                   'exch',
                                                   'queue',
                                                   'rt_key'))

    def test_delete_binding(self):
        self.client.http.do_call = Mock(return_value=True)
        self.assertTrue(self.client.delete_binding('vhost',
                                                   'exch',
                                                   'queue',
                                                   'rt_key'))

    def test_publish(self):
        self.client.http.do_call = Mock(return_value={'routed': 'true'})
        self.assertTrue(self.client.publish('vhost', 'xname', 'rt_key',
                                            'payload'))

    def test_create_vhost(self):
        self.client.http.do_call = Mock(return_value=True)
        self.assertTrue(self.client.create_vhost('vname'))

    def test_delete_vhost(self):
        self.client.http.do_call = Mock(return_value=True)
        self.assertTrue(self.client.delete_vhost('vname'))

    def test_create_user(self):
        self.client.http.do_call = Mock(return_value=True)
        self.assertTrue(self.client.create_user('user', 'password'))

    def test_delete_user(self):
        self.client.http.do_call = Mock(return_value=True)
        self.assertTrue(self.client.delete_user('user'))

    @patch.object(pyrabbit.api.Client, 'has_admin_rights')
    def test_is_alive_withprivs(self, mock_rights):
        mock_rights.__get__ = Mock(return_value=True)
        with patch('pyrabbit.http.HTTPClient.do_call') as do_call:
            do_call.return_value = {'status': 'ok'}
            self.assertTrue(self.client.is_alive())

    def test_is_alive_noprivs(self):
        with patch.object(pyrabbit.api.Client, 'has_admin_rights') as mock_rights:
            mock_rights.__get__ = Mock(return_value=False)
            self.assertRaises(pyrabbit.api.PermissionError, self.client.is_alive)

    def test_has_admin_rights(self):
        response = {
            'auth_backend': 'rabbit_auth_backend_internal',
            'name': 'guest',
            'tags': 'administrator',
        }
        self.client.get_whoami = Mock(return_value=response)
        with patch.object(pyrabbit.api.Client, 'get_whoami') as mock_whoami:
            mock_whoami.__get__ = Mock(return_value=True)
            self.assertTrue(self.client.has_admin_rights)


@unittest.skip
class TestLiveServer(unittest.TestCase):
    def setUp(self):
        self.rabbit = pyrabbit.api.Client('localhost:15672', 'guest', 'guest')
        self.vhost_name = 'pyrabbit_test_vhost'
        self.exchange_name = 'pyrabbit_test_exchange'
        self.queue_name = 'pyrabbit_test_queue'
        self.rt_key = 'pyrabbit-roundtrip'
        self.payload = 'pyrabbit test message payload'
        self.user = 'guest'

    def test_round_trip(self):
        """
        This does a 'round trip' test, which consists of the following steps:

        * Create a vhost, and verify creation
        * Give 'guest' all perms on vhost
        * Create an exchange in that vhost, verify creation
        * Create a queue
        * Create a binding between the queue and exchange
        * Publish a message to the exchange that makes it to the queue
        * Grab that message from the queue (verify it's the same message)
        * Delete binding and verify we don't receive messages
        * Delete the exchange
        * Delete the vhost
        """

        # create a vhost, verify creation, and grant all perms to 'guest'.
        self.rabbit.create_vhost(self.vhost_name)
        vhosts = [i['name'] for i in self.rabbit.get_all_vhosts()]
        self.assertIn(self.vhost_name, vhosts)
        self.rabbit.set_vhost_permissions(self.vhost_name, self.user,
                                          '.*', '.*', '.*')

        # create an exchange, and verify creation.
        self.rabbit.create_exchange(self.vhost_name,
                                    self.exchange_name,
                                    'direct')
        self.assertEqual(self.exchange_name,
                         self.rabbit.get_exchange(self.vhost_name,
                                                  self.exchange_name)['name'])

        # create a queue and verify it was created
        self.rabbit.create_queue(self.vhost_name,self.queue_name)
        self.assertEqual(self.queue_name,
                        self.rabbit.get_queue(self.vhost_name,
                                              self.queue_name)['name'])

        # bind the queue and exchange
        self.rabbit.create_binding(self.vhost_name, self.exchange_name,
                                   self.queue_name, self.rt_key)

        # publish a message, and verify by getting it back.
        self.rabbit.publish(self.vhost_name, self.exchange_name, self.rt_key,
                            self.payload)
        messages = self.rabbit.get_messages(self.vhost_name, self.queue_name)
        self.assertEqual(messages[0]['payload'], self.payload)

        # delete binding and verify we don't get the message
        self.rabbit.delete_binding(self.vhost_name, self.exchange_name,
                                   self.queue_name, self.rt_key)
        self.rabbit.publish(self.vhost_name, self.exchange_name, self.rt_key,
                            self.payload)
        messages = self.rabbit.get_messages(self.vhost_name, self.queue_name)
        self.assertIsNone(messages)

        # Clean up.
        self.rabbit.delete_exchange(self.vhost_name, self.exchange_name)
        self.rabbit.delete_vhost(self.vhost_name)


if __name__ == "__main__":
    log = open('test_out.log', 'w')
    unittest.main(testRunner=unittest.TextTestRunner(log))

########NEW FILE########
