
Juno
====

Table of Contents:
    
* [Setup][setup]
* [Configuration][config]
* [Requests and Responses][request_response]
* [Routes][routes]
* [Models][models]
* [Templates][templates]
* [Forms][forms]

[setup]:            1-setup.html
[config]:           2-configuration.html
[request_response]: 3-requests_and_responses.html
[routes]:           4-routes.html
[models]:           5-models.html
[templates]:        6-templates.html
[forms]:            7-forms.html


Setup
=====

Installation
------------

Juno consists of just one Python module, and is installed with the usual
`python setup.py install`, run as root.

Dependencies
------------

Juno's only required dependency is [SQLAlchemy][sqlalchemy].

There are a number of optional dependencies:
    
* [Jinja2][jinja2] or [Mako][mako]: Juno has builtin support for these
  templating libraries.  You can use a different one but that will require
  extra configuration.
* [Flup][flup]: Flup is required if you want to use FastCGI or SCGI.
* [Beaker][beaker]: Beaker is required if you want to use sessions.
* [Werkzeug][werkzeug]: Werkzeug is required if you want to use the
  builtin debugger.


Server Configuration
----------------------

Juno is set by default to run the builtin development server.  In addition,
it offers interfaces through SCGI, FastCGI, and WSGI.


SCGI Notes
----------

For Nginx, SCGI requires the [mod_scgi][mod_scgi] addon, which is not included 
in the default install.  After installing it, the configuration for Nginx should
look something like this:
    
    http {
        server {
            location / {
                scgi_pass   127.0.0.1:8000;
                include     scgi_vars;
            }
        }
    }

This would be in addition to whatever other options you were setting.

After starting Nginx with those settings, run Juno in 'scgi' mode.


WSGI Notes
----------

Since [mod_wsgi][mod_wsgi] requires a function named 'application', you would
need to put Juno in 'wsgi' mode and call run() like so:
    
    config('mode', 'wsgi')
    application = run()

Those functions will make more sense later.


[sqlalchemy]: http://www.sqlalchemy.org
[jinja2]:     http://jinja.pocoo.org/2/
[mako]:       http://www.makotemplates.org
[flup]:       http://trac.saddi.org/flup/
[beaker]:     http://wiki.pylonshq.com/display/beaker/Home
[werkzeug]:   http://dev.pocoo.org/projects/werkzeug
[mod_scgi]:   http://wiki.codemongers.com/NginxNgxSCGIModule
[mod_wsgi]:   http://code.google.com/p/modwsgi/


Configuration
=============

Start out by importing Juno:
    
    import juno

Juno has a number of configuration options that you can set by calling
init() with a dictionary of settings at the beginning of your application:
    
    juno.init({'config_opt': 'val', 'other_option': 'val2'})

Juno uses a global object to store all of your settings, but you can also
create it directly (it will automatically store it as the global object):
    
    my_juno_object = juno.Juno({'arg': 'val'})

You can access settings later in a number of ways.  If you created a Juno
object yourself, you can access them like so:
    
    my_juno = juno.Juno({'mode': 'wsgi', 'use_sessions': True})
    my_juno.config['mode']  # => 'wsgi'
    my_juno.mode            # => 'wsgi'
    my_juno.use_sessions    # => True

You can also use the config() function to access settings:
    
    juno.init({'template_lib': 'mako'})
    juno.config('template_lib')  # => 'mako'

And set settings:

    juno.config('log')          # => True
    juno.config('log', False)
    juno.config('log')          # => False

A full listing of options:

General Options
---------------

    * 'log': True
      => If True, writes information to stdout during requests.

Types and Encodings
-------------------

    * 'charset': 'utf-8'
      => The default charset encoding used to load and render templates.

    * 'content_type': 'text/html'
      => The default Content-Type header sent in responses.
  
Server Options
--------------

    * 'mode': 'dev'
      => Controls which interface Juno runs - 'dev' runs the development server,
         'scgi' runs the SCGI server, 'fcgi' runs the FastCGI server, 'wsgi'
         allows you to retrieve an application() object for mod_wsgi, and
         'appengine' will run using Google App Engine's run_wsgi_app.

    * 'scgi_port': 8000
      => The port where the SCGI server runs.

    * 'fcgi_port': 8000
      => The port where the FastCGI server runs.

    * 'dev_port': 8000
      => The port where the development server runs.

Static File Options
-------------------

    * 'use_static': True
      => If True, Juno sets up a static file handler for you.

    * 'static_url': '/static/*:file/'
      => The URL that is mapped to the static handler.  For example, matches
         '/static/stylesheet.css'.

    * 'static_root': './static/'
      => The filesystem path where static files are loaded from.  '/static/file.css'
         by default will map to './static/file.css' on your system.

    * 'static_handler': static_serve
      => The function that serves static files.

Template Options
----------------

    * 'use_templates': True
      => If True, set up templates.

    * 'template_lib': 'jinja2'
      => Juno has built-in template configurations for Jinja2 and Mako ('mako').

    * 'get_template_handler': _get_template_handler
      => The function Juno calls when you load a template with template().

    * 'render_template_handler': _render_template_handler
      => The function Juno calls when template() renders a template.

    * 'auto_reload_templates': True
      => If True, templates are automatically reloaded when they change.

    * 'translations': []
      => A list of translation objects to be passed to Jinja2's i18n extension.
         A translation object is one returned by gettext.translation or the
         equivalent.  If the list is empty, the i18n extension is not enabled.
         This option only acts on Jinja2 currently.

    * 'template_kwargs': {}
      => Allows you to pass custom keyword arguments to the template lookup
         object (Environment for Jinja2, TemplateLookup for Mako).

    * 'template_root': './templates/'
      => The filesystem path where templates are loaded from.

    * '404_template': '404.html'
      => The template to load when no matching URL is found for a request.

    * '500_template': '500.html'
      => The template to load when an error occurs during a request.

Database Options
----------------

    * 'use_db': True
      => If True, a connection to a database is setup.  Even if this value is False,
         SQLAlchemy is currently still imported and thus required.

    * 'db_type': 'sqlite'
      => The type of database driver to use.  Can be 'sqlite', 'postgres',
         'mysql', 'oracle', or 'mssql'.

    * 'db_location': ':memory:'
      => The location/address of your database. Read the SQLAlchemy docs
         (http://www.sqlalchemy.org/docs/05/dbengine.html#create-engine-url-arguments)
         for details.

Custom Middleware
-----------------

    * 'middleware': []
      => The list of custom WSGI middleware you want your application to be
         wrapped in. Each entry in the list should be a tuple in the following
         format:

         ('package.name.Middleware', {'arg': 'value'})

Session Options
---------------

    * 'use_sessions': False
      => If True, Juno will set up and use sessions.

    * 'session_lib': 'beaker'
      => The library to use for sessions.  Currently 'beaker' is the only option.

Debugger Options
----------------

    * 'use_debugger': False
      => If True, Juno will set up the default debugging middleware.

    * 'raise_view_exceptions': False
      => If True, uncaught exceptions during a request will be propagated.
         You'll need to set this to True if you want to use a custom debugging
         middleware.


[dbdocs]: 


Juno Requests and Responses
==============================

Request Basics
----------------

Every view in Juno must take a JunoRequest as the first argument.  This
object gives you access to all of the information that the server 
received - headers, GET and POST data, etc.

If 'web' is a JunoRequest object created from an actual request:
            
    web.location        # '/'
    web.full_location   # '/?a=4'
    web.user_agent      # ...user-agent string...
    web.raw             # A dictionary mapping header names to their values
    web.session         # A session object, if 'use_sessions': True
    web['REQUEST_URI']  # The Request can be used like a dictionary, to
                        # retrieve values from the raw dictionary.

Data received from GET/POST requests is stored in web.input().  This
would be query strings (`?a=4&b=5`) and form data.  Currently Juno
does not handle file uploads from forms, but thats at the top of the 
todo list.

To access this data:

    web.input()         # Returns a dictionary of GET/POST data

To access a specific name ('a' in '?a=4'):
    
    web.input('a')      # Gets the value of the GET/POST key 'a'

If multiple values have the same name (i.e. more than one input field
sharing a name), they values are put in a list:
            
    web.input('b')      # => ['1', '2'] for '?b=1&b=2'


To use sessions, be sure to install [Beaker][beaker], and set 'use_sessions'
to True.  Sessions are used like a dictionary:
    
    web.session['foo'] = 'bar'
    web.session.save()  # save() must be called

You then can access 'foo' later on:
    
    web.session['foo']  # => 'bar'


Response Basics
---------------

Juno gives each view a global JunoResponse object when that view is 
called.  You can define your own response object, but is often easier
to use the functions that modify the global object.

A response object is made up of 3 parts:
            
body    &rarr;  Text to send back
status  &rarr;  The HTTP status code
headers &rarr;  Dictionary of HTTP headers

The easiest way to use a response object is through the global
functions, which by default modify a JunoResponse object set to a 
status of 200:

    append(text)       => Add text to the response.  Automatically 
                          updates the Content-Length header.
    header(key, value) => Set a member of the headers dictionary.
    content_type(type) => Specify a Content-Type other than 'text/html'.
    status(code)       => Specify a response code other than 200.

To return a 404 response:
            
    notfound(error, file) => Renders template with a 404 status.
                              error defaults to 'Unspecified error'.
                              file defaults to the value of Juno's
                              '404_template' setting (which you can set
                              when you call init).

To return a 302 (redirect) response:
            
    redirect(url) => Sets the global response to a status of 302 with a 
                             'Location' header set to url.

To return a 500 (server error) response:
            
    servererror(error, file) => Renders the 500_template. error defaults
                                to 'Unspecified error'.

To automatically assign urls, without creating a view to do it:
          
    assign(from, to) => Called from outside of a view, automatically
                        redirects the 'from' url to the 'to' url. 'from'
                        can be a list of urls.

    
Templates
---------

This is probably the most common case of responses, and is covered in
'doc/6-templates.txt'.

    
Static Files
------------

Serving static files with Juno involves 3 configuration options:
            
    'static_url'     => The route that triggers static file serving.  If
                        you change this, you must include a '*:file' 
                        portion (unless you also change the static handler,
                        discussed below).  By default, it is set to
                        '/static/*:file/'.
    'static_root'    => The local directory that Juno looks for static
                        files.  By default, set to './static/'.
    'static_handler' => The view assigned to serve static files.  As noted
                        above, takes a 'file' parameter.  Maps this
                        filename to the 'static_root' directory.

The built in static handler will automatically determine mimetypes for
you, and will return a 404 if the file cannot be found.

[beaker]: http://wiki.pylonshq.com/display/beaker/Home

Juno Routes
===========

Basics
--------

Juno lets you assign functions to a given url by using python decorators:
    
    from juno import *

    @route('/hello/')
    def hello(web): return "Hello there"

The url argument given to the decorator is where this function will be located;
so going to http://127.0.0.1:8000/hello/ will let you see your work.


Multiple URLs for the Same View
---------------------------------

You can replace that one url in the route() function with a list of strings,
like so:
    
    @route(['/', '/index/'])

This lets you send multiple addresses to one view.


Getting the Reqeust Method Involved
-------------------------------------

But what if you want a view to only respond to POST requests? You could do this:
    
    @route('/probably_a_form/', 'post')
    def form_read(web): ...

Since thats pretty verbose, theres a shortcut:
    
    @post('/probably_a_form/')
    ... function ...

There are shortucts for get, post, head, put, and delete.


Handling Wildcard URLs
------------------------

Juno has a very simple URL matching scheme.  Right now there is just one special
character: `*`.  It is used like this:

    @get('/hello/*:person/')
    def hello(web, person): ...

This will match '/hello/brian/' and '/hello/112358/'.  The ':person' part lets us
send the match as a named parameter to your function, which in the preceding 
examples would be 'brian' and '112358'.

Because `*` is the only matching character available now, you don't have to
put it in: `/*:greet/` is the same as '/:greet/'.


Shortcuts
-----------

Juno provides a couple shortcut functions to use with routes.  The first is a 
redirection shortcut.  Instead of writing a function like this:
    
    @route('/')
    def temp(web): redirect('/home/')

The redirect function takes an optional second argument called code, which
defaults to 302:
    
    redirect('/', 303)

You can use the assign function instead:

    assign('/home/', '/')
    assign(['/index/', '/profile/'], '/')

The next allows you to automatically render a template in response to a certain
url:
    
    autotemplate('/about/', 'about.html')

Like assign(), it also accepts a list of urls.



Juno Model API
=================

Juno's model API is a little different than most other frameworks as 
you don't use Python's class keyword, but instead simply call Juno's
model function.  A simple example:
    
    Person = juno.model('Person', name='string')

Person is now a class that you can use to construct objects, just as if
you had used `class Person:`.  The `name='string'` portion creates an
instance variable called `name` and maps it to a SQLAlchemy column of 
type String.

To instantiate a Person object, you must use keyword arguments:
    
    brian = Person(name='brian')

`brian` now has a `name` variable and an `id` variable (its database 
primary key).  It also has the following methods:

    brian.add()         # Adds the object to the current session, but
                        # doesn't commit it.
    brian.save()        # Adds (if necessary) and commits the object.
    brian.__repr__()    # Defaults to '<Person: id = X>'


Adding Other Database Columns
-------------------------------

You can add database columns by using string versions of their SQLAlchemy
column names ('string' for String).  You can also pass in literal Column
objects (see the SQLAlchemy docs for information on those):
    
    Person = juno.model('Person', name=Column(String))


Adding Custom Functions
-------------------------

You can add custom functions to your model in the model(...) call.  For
example, to add your own `__repr__`, use something like the following:
    
    Person = juno.model('Person', name='string',
        __repr__=lambda self: '<Person: %s>' %self.name)

You could also define the function beforehand if you needed more than one
statement, or don't like lambdas:
    
    def my_repr(self): return '<Person: %s>' %self.name

    Person = juno.model('Person', name='string', __repr__=my_repr)


Querying for Objects
----------------------

Juno doesn't have its own query language, and instead just gives you access
to SQLAlchemy's query system.  To use it, use the find function and then 
attach whatever SQLAlchemy methods you need:

    people = juno.find(Person).all()

Models also include a find() function:
    
    people = Person.find().all()


Other Notes
-------------

If you need to use the current session directly, use the session() function,
which returns the SQLAlchemy session object:
    
    session().add_all([Person(...), Person(...), ...])


Creating a Database Connection
--------------------------------

Juno's default database engine is an in-memory SQLite database.  To specify
something different, use the 'db_type' and 'db_location' settings by calling
init() after importing Juno:
    
    juno.init({'db_type': 'mysql', 'db_location': 'localhost/foo'})

The database type can be any of the drivers that SQLAlchemy supports, and
the location is the part of the engine URL after the 'driver://' part.
See http://www.sqlalchemy.org/docs/05/dbengine.html#create-engine-url-arguments
for details.


For the Curious: How the Model Function Works
-----------------------------------------------

Juno's model() function is a little strange in that it is a normal function
that returns a class, exactly the same as if you had used the `class` keyword
to define it.  This is possible because of Python's metaclasses - classes
whose instances are classes.  In juno.py, JunoClassConstructor subclasses
'type', a builtin Python metaclass.  This allows model() to return a class
instead of a normal instance.

So how does your class get the variables and methods you want?  model()
takes the parameters you passed in (name='string') and builds a dictionary
that maps variable names ('name') to the database column you specified
(Column('name', String)).  Then it adds any callables you gave it (like the
`__repr__` example above), and then adds the included methods (default `__repr__`,
generic `__init__`, etc.).

This dictionary is passed along with your class name to the class constructor
mentioned above, and your class comes back out, and returned to you.


Reference
-----------

juno.model(class_name, variable_name=column_type, ..., callables)

    > Returns a class with the given variable names and methods.
    > By default includes:
        id       => Integer database column (primary key)
        __init__ => Functions like a normal __init__, and just like a 
                    normal class you don't call it directly.
        __repr__ => Returns '<class_name: id = id>'
        add      => Adds instance to current session.
        save     => Adds and commits instance.
        find     => Class method to return a Query object.
    > Column types are all lowercase versions of the standard SQLAlchemy
      types ('string', 'integer', 'unicode', 'text', 'unicodetext', 'date',
      'numeric', 'time', 'float', 'datetime', 'interval', 'binary', 'boolean',
      'pickletype'), or actual Column objects.  See SQLAlchemy reference for 
      details.
    > Callables are any lambdas or normal functions you want your class
      to have.  Like normal methods, they must take self as their first
      parameter (see __repr__ example).

juno.find(class or class_name)

    > Returns a SQLAlchemy query object for that model.
    > Takes a single parameter, which can either be a class or a string
      name of one (Person or 'Person').
    > This is the same as Person.find()


Juno Template API
====================

Basics
--------

Juno is enabled by default to use Jinja2 templates.  Juno can also use
Mako template by changing 'template_lib':
    
    init({'template_lib': 'mako'})

If you are using either Jinja2 or Mako, you can skip the next section.


Changing Template Engines
---------------------------

Juno can use any templating system that has some sort of template
object that can be specified by name and some way to return a string 
version of that object - i.e. Jinja2 has Template objects loaded from 
the filesystem, and has a render() method to return a string of that
file.

To start, change the 'template_lib' option to something other than
'jinja2' or 'mako':
    
    config('template_lib', 'my_template_lib')

Then you have to give Juno two functions - 'get_template_handler' and
'render_template_handler'.  The first takes a string (most often a
filename) and must return an object that can be rendered (i.e. the
Template objects in Jinja2 and Mako).  The second function takes a 
template object and a dictionary of keyword arguments (**kwargs).
It must return a string.

As an example, here is how Juno sets this up for Jinja2 (Jinja2's
environment object is stored in config('my_jinja_environ'):
    
    def get_template_handler(path):
        return config('my_jinja_environ').get_template(path)

    def render_template_handler(template_obj, **kwargs):
        return template_obj.render(**kwargs)

    config('get_template_handler', get_template_handler)
    config('render_template_handler', render_template_handler)


Rendering
-----------

To render a template (adds the rendering to the current response object):

    template('index.html')

To render a template with variables, you can use a dictionary or named
parameters:
    
    template('index.html', {'foo': 1, 'bar': 2})
    template('index.html', foo=1, bar=2)

You can also set a template to automatically render for a given url:
    
    autotemplate('/', 'index.html')
    autotemplate(['/index/', '/home/'], 'home.html')

Currently, this does not accept any arguments in the url.


Template Objects
------------------

If you want to retrieve a template object without rendering it, you
can use the function get_template:
    
    template_obj = get_template('index.html')

Before returning this you would need to render and add it to the 
response.


Using Forms in Juno
======================

Suppose you have a form:
    
    <form action='/submit/' method='post'>
        <input type='text' name='email' />
        <input type='submit' />
    </form>

In the view assigned to '/submit/', you can access the form elements using:
    
    web.input()         # => {'email': 'brian@brianreily.com'}
    web.input('email')  # => 'brian@brianreily.com'

This works the same for all form elements, as well as query strings.

In case of an uploaded file web.input returns a cgi.FieldStorage instance
instead of a string. Examples of processing a file element:

    f = web.input('file_field') # => the cgi.FieldStorage instance for the file
    f.file # => a file(-like) object that you can use to read data from the uploaded file

You can also use the value attribute of the cgi.FieldStorage instance but be aware
that it reads the file every time you request the value.

    f = web.input('file_field')
    f.value # => string holding the contents of the file


Juno
====

* Juno is a web framework that was designed to make development as fast
  as possible.
* Homepage: [http://brianreily.com/project/juno][homepage]
* Repository: [http://github.com/breily/juno][repo]


Using Juno
----------

To start off:

    from juno import *

    @route('/')
    def index(web):
        return 'Juno says hi'

    run()

Add some url handling:

    @route('/hello/:name/')
    def hello(web, name):
        return 'Hello, %s' %name

Use a template:

    @get('/hi_template/:name/')
    def template_hi(web, name):
        template('hello.html', name=name)

Build a model:

    Person = model('Person', name='string')
    p = Person(name='brian')


Features
--------

* All normal web framework stuff (models, routes, views, templates)
* WSGI compliant, with included development server as well as SCGI/FastCGI servers
* Database access through SQLAlchemy
* Templating included through Jinja2 and Mako, but Juno can use anything.


Install
-------

* You can use easy_install:
    
        easy_install Juno

* Or pull from [Github][repo], and then do:

        $ python setup.py install   # As root
        $ python
        >>> import juno             # Make sure everything worked

* Requires: [SQLAlchemy][sqlalchemy]
* Optional: 
    * [Jinja2][jinja2]/[Mako][mako] (for templating)
    * [Flup][flup]        (for SCGI/FastCGI only)
    * [Beaker][beaker]      (for sessions)
    * [Werkzeug][werkzeug] (for debugging)


Help / Contribute
-----------------

* See the [doc/][docs] directory for the current documentation.
* More questions? Find bugs? [Check out the new Google group][list].
* Contributions are welcome through Github or by [emailing me a patch][email].


Note
----

* Juno violates some usual principles of good design (don't use global
  variables, don't do things implicitly, etc.) for the sake of fast
  development and less boilerplate code.  You've been warned.


[homepage]:   http://brianreily.com/project/juno
[repo]:       http://github.com/breily/juno/tree/master
[docs]:       http://github.com/breily/juno/tree/master/doc/
[sqlalchemy]: http://www.sqlalchemy.org
[jinja2]:     http://jinja.pocoo.org/2/
[mako]:       http://www.makotemplates.org
[flup]:       http://trac.saddi.org/flup/
[beaker]:     http://wiki.pylonshq.com/display/beaker/Home
[list]:       http://groups.google.com/group/juno-framework
[email]:      mailto:brian@brianreily.com
[wiki]:       http://wiki.github.com/breily/juno/
[q&a]:        http://wiki.github.com/breily/juno/questions-and-answers
[werkzeug]:   http://dev.pocoo.org/projects/werkzeug

