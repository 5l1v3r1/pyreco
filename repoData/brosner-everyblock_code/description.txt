{{ obj.body|safe }}

======
ebblog
======

The blog application used by http://blog.everyblock.com

Requirements
============

A recent Django release. It has been tested with Django revision 11079 from
Subversion. When Django 1.1 is released, that should work as well.

Quickstart
==========

0. Install Django.

1. Install the ebblog package by putting it on your Python path.

2. Start a Django project (using Django 1.1, not 1.0). See the Django Book and
   Django docs for more:

       http://djangobook.com/en/2.0/
       http://docs.djangoproject.com/en/dev/

3. Update your settings file. It's probably easiest to just start with the
   file ebblog/settings.py and tweak that (or import from it in your own
   settings file). The application won't work until you set the following:

       DATABASE_USER
       DATABASE_NAME
       DATABASE_HOST
       DATABASE_PORT

   If you decide not to start with ebblog.settings, you'll also need to add
   ebblob.urls to your URLconf and add the absolute path to ebblog/templates
   to your TEMPLATE_DIRS setting.

4. Run "django-admin.py syncdb" to create all of the database tables.

5. Run "django-admin.py runserver" and go to http://127.0.0.1:8000/ in your
   Web browser to see the site in action. Go to http://127.0.0.1:8000/admin/
   to add and edit blog entries.

Customization
=============

The title, description, and link of the RSS feed should be set in
ebblog/blog/feeds.py. Also, most of the visual customization can be
accomplished by editing ebblog/templates/base.html. All of the other templates
inherit from base.html, so any styles added there will apply to the other
pages.

======
ebdata
======

Code to help write scripts that import/crawl/parse data into ebpub.

ebdata.blobs
============

The blobs package is a Django app responsible for crawling, scraping,
extracting, and geocoding news articles from the web.

The blobs app contains two models, Seed and Page. Seed is a news source, like
the Chicago Tribune, and a Page is a particular html page that was crawled from
a Seed.


ebdata.nlp
==========

The nlp package contains utilities for detecting locations in text. This
package is used by blobs, but if you want to use it directly, check out the
docstrings for the functions in ebdata.parsing.addresses.


ebdata.parsing
==============

The parsing package contains helpers for reading different file types.

The dbf, excel, mdb, and unicodecsv modules are for reading stuctured data,
and generally follow the python csv reader api. See the code for more details
on how to use the.

The pdf module is for converting pdf to text, and requires Xpdf.
http://www.foolabs.com/xpdf/download.html


ebdata.retrieval
================

The retrieval package contains a framework for writing scrapers for structured
data. There are many examples of how to use this framework in different
situation in the everyblock package.

The most commonly used scraper is the NewsItemListDetailScraper. It handles
scraping list/detail types of sites, and creating or updating NewsItem
objects.

Generally, to run a scraper, you need to instantiate it, and then call its
update method. Sometimes the scraper will take arguments, but it varies on a
case-by-case basis. You can read the scrapers in the everyblock package for
examples. You can also run a scraper by calling its display_data method. This
will run the scraper, but won't actually save any of the scraped data. It's
very useful for debugging, or when writing a scraper for the first time.

All of the methods and parameters you'll need to use are documented in
docstrings of ebdata.retrieval.scrapers.list_detail.ListDetailScraper and in
ebdata.retrieval.scrapers.newsitem_list_detail.NewsItemListDetailScraper.
ListDetailScraper is a base class of NewsItemListDetailScraper that handles
scraping, but doesn't actually have any methods for saving data.

The retrieval package also contains updaterdaemon, which is a cron-like
facility for running scrapers. It comes with a unix-style init script, and its
configuration and examples are in ebdata/retrieval/updaterdaemon/config.py.


ebdata.templatemaker
====================

The templatemaker package contains utilities for detecting the actual content
given a set of html pages that were generated from a template. For instance,
templatemaker helps detect and extract the actual article from a page that
could also contain navigation links, ads, etc.


ebdata.textmining
=================

The textmining package contains utilities for preprocessing html to strip out
things that templatemaker doesn't care about like comments, scripts, styles,
meta information, etc.

=====
ebgeo
=====

The eb map system. The ebgeo package provides for two main bits of
functionality:

 1. A `maps' subpackage for rendering map tiles with Mapnik, and

 2. A `utils' subpackage which is a collection of useful modules when
    working with geospatial data, including clustering.

Requirements
============

Mapnik version 0.6.0 or greater -- http://mapnik.org/
TileCache 2.10 -- http://tilecache.org/
processing 0.50 or greater (optional) -- http://pypi.python.org/pypi/processing

Background
==========

You should be familiar with the mapping toolkit Mapnik before getting
started with this package. Installation of Mapnik is non-trivial,
although it has gotten easier over time. You'll also need to provide
your own styles for the map tiles, which means creating Mapnik style
XML. Cascadenik_ provides a CSS-like syntax that compiles to Mapnik
XML; you may find this an friendy way to get started creating styles:

.. _Cascadenik: http://code.google.com/p/mapnik-utils/wiki/Cascadenik

You'll also be responsible for your own source geospatial data. This
is a database of features (i.e., individual roads, parks, bodies of
water, etc.) with attributes (i.e., road types, areas of parks, names
and labels, etc.) that Mapnik queries and, combined with styles
defined in the Mapnik XML format, represents in the graphical output
of the rendering engine. There are two main freely available sources
of streets data, TIGER/Line_ (produced by the Census for U.S. streets)
and OpenStreetMap_ (a user-contributed database of streets
world-wide).

.. _TIGER/Line: http://www.census.gov/geo/www/tiger/
.. _OpenStreetMap: http://www.openstreetmap.org/

Geospatial data
---------------

Mapnik provides a number of different ways to access geospatial data,
from shapefiles to PostGIS databases. The ebgeo code assumes that your
data is stored in a PostGIS database. It also makes some assumptions
about which layers and attribute field names are defined. The
ebgeo.maps.mapserver module source code should be your reference for
this information; refer to the draw_map() method.

Installation
============

After downloading the ebgeo tarball and unpacking, put the ebgeo package
on your Python path. Then create a directory called "mapnik" within your
`sys.prefix` directory (which you can get by running
"python -c 'import sys; print sys.prefix'"). This is the directory where
you should place your Mapnik style XML files.

Rendering map tiles
===================

The `render_tiles' executable iterates over a number of zoom levels
and renders the map tiles contained within.

    Usage: render_tiles [<options>] /path/to/config <layername>
    
    Options:
      -h, --help            show this help message and exit
      -s START, --start=START
                            starting zoom level
      -t STOP, --stop=STOP  ending zoom level
      -c CITY, --city=CITY  only render this city's tiles (use city slug)
      -v, --verbose         
      -D, --debug           
      -n NUM_PROCS, --num-procs=NUM_PROCS
                            number of render processes (defaults to 1)

The /path/to/config argument is a path to a TileCache config. Please
see the TileCache docs for the syntax, which is a .ini-type file.

The <layername> argument is a string that should match a defined layer
section in the TileCache config file and the Mapnik style XML
filename.

The -s and -t options indicate the starting and stopping zoom level
for rendering. The starting, -s, option is inclusive: in other words,
if the value of -s is 1, the rendering will start at level 1. However,
the stopping, -t, option is exclusive: in other words, if the value of
-t is 10, the rendering will stop upon completing level 9. The number
of zoom levels is defined in the TileCache config.

The -c option allows you to constrain tile rendering to the bounding
box of a city defined in your application. The value of -c is the slug
that represents that city. (See ebpub.metros)

The -n options allows you to spread rendering over multiple CPUs,
utilizing the great Python package `processing.'

Dynamic map tiles
=================

There's an alternate way to view map tiles other than rendering them
first and serving them statically. ebgeo.maps.views has a get_tile()
view that will render individual tiles and serve them directly to the
requesting browser. See ebgeo.maps.urls for the URLconf that wires up
a URL request to the get_tile() view.
==========
ebinternal
==========

Internal applications for the EveryBlock team.

ebinternal consists of two apps, citypoll and feedback.

citypoll powers EveryBlock's city voting system, both on EveryBlock.com and on
the iPhone app.

feeback manages the feedback received from the feedback forms at the bottom
of almost every page on EveryBlock.com.

Quickstart
==========

0. Install Django.

1. Install the ebinternal package by putting it on your Python path.

2. Start a Django project (using Django 1.1, not 1.0). See the Django Book and
   Django docs for more:

       http://djangobook.com/en/2.0/
       http://docs.djangoproject.com/en/dev/

3. Update your settings file. It's probably easiest to just start with the
   file ebinternal/settings.py and tweak that (or import from it in your own
   settings file). The application won't work until you set the following:

       DATABASE_USER
       DATABASE_NAME
       DATABASE_HOST
       DATABASE_PORT
       EMAIL_HOST (for sending responses from the feedback application)
       EB_FROM_EMAIL
       EB_STAFF

   If you decide not to start with ebinternal.settings you'll also need to add
   ebinternal.urls to your urlconf and add the absolute path to
   ebinternal/templates to your TEMPLATE_DIRS setting.

4. Run "django-admin.py syncdb" to create all of the database tables.

5. Run "django-admin.py runserver" and go to http://127.0.0.1:8000/ in your
   Web browser to see the site in action.

{% load eb full_links %}

{% ifequal obj.0 'newsitem' %}
	<ul>
		{% full_links site.domain %}{% with obj.1 as place %}{% with obj.4 as is_block %}{% with obj.5 as block_radius %}{% newsitem_list_by_schema obj.3 %}{% endwith %}{% endwith %}{% endwith %}{% end_full_links %}
	</ul>
{% else %}
	<p>{{ obj.1.summary }} <a href="{{ obj.1.url }}">Read more...</a></p>
{% endifequal %}
=====
ebpub
=====

Publishing system for block-specific news, as used by EveryBlock.com.

Requirements
============

Python version 2.4 to 2.6 -- http://www.python.org/
Django version 1.1 -- http://www.djangoproject.com/
PostgreSQL version 8 -- http://www.postgresql.org/
PostGIS -- http://postgis.refractions.net/
psycopg2 -- http://initd.org/pub/software/psycopg/

This is a Django application, so it's highly recommended that you have
familiarity with the Django Web framework. The best places to learn are
the official documentation (http://docs.djangoproject.com/) and the free
Django Book (http://www.djangobook.com/). Note that ebpub requires Django
1.1, which hasn't been released yet (as of the date ebpub was released),
so you'll need to get it from Subversion.

Background
==========

Before you dive in, it's *highly* recommend you spend a little bit of time
browsing around EveryBlock.com to get a feel for what this software does.

Also, for a light conceptual background on some of this, particularly the
data storage aspect, watch the video "Behind the scenes of EveryBlock.com"
here: http://blip.tv/file/1957362

Quickstart
==========

0. Install PostgreSQL, PostGIS, Django, psycopg2.

1. Install the ebpub package by putting it on your Python path. Also install
   the ebgeo package.

2. Start a Django project.

3. Put the smorgasbord of eb-specific settings in your settings file. It's
   probably easiest to just start with the file ebpub/settings.py and tweak
   that (or import from it in your own settings file). The application won't
   work until you set the following:

       DATABASE_USER
       DATABASE_NAME
       DATABASE_HOST
       DATABASE_PORT
       SHORT_NAME
       PASSWORD_CREATE_SALT
       PASSWORD_RESET_SALT
       METRO_LIST
       EB_MEDIA_ROOT
       EB_MEDIA_URL

   See the documentation/comments in ebpub/settings.py for info on what the
   various settings mean.

4. Run "django-admin.py syncdb" to create all of the database tables.

5. Run "django-admin.py runserver" and go to http://127.0.0.1:8000/ in your
   Web browser to see the site in action.

Adding data
===========

The next step is to add data. Broadly speaking, the system requires two
different types of data: geographic boundaries (Locations, Streets, Blocks
and Intersections) and news (Schemas and NewsItems).

LocationTypes / Locations
-------------------------

A Location is a polygon that represents a geographic area, such as a specific
neighborhood, ZIP code boundary or political boundary. Each Location has an
associated LocationType (e.g., "neighborhood"). To add a Location to the
system, follow these steps:

    1. Create a row in the "db_locationtype" table that describes this
       LocationType. See the LocationType model code in ebpub/db/models.py for
       information on the fields and what they mean.

    2. Get the Location's geographic representation (a set of
       longitude/latitude points that determine the border of the polygon).
       You might want to draw this on your own using desktop GIS tools or
       online tools, or you can try to get the data from a company or
       government agency.

    3. With the geographic representation, create a row in the "db_location"
       table that describes the Location. See the Location model code in
       ebpub/db/models.py for information on the fields and what they mean.
       You can use the script ebpub/db/bin/add_location.py, use the Django
       database API or do a manual SQL INSERT statement.

You'll need to create at least one LocationType with the slug "neighborhoods",
because that's hard-coded in various places throughout the application.

Blocks
------

A Block is a segment of a single street between one side street and another
side street. Blocks are a fundamental piece of the ebpub system; they're used
both in creating a page for each block and in geocoding.

Blocks are stored in a database table called "blocks". To populate this table,
follow these steps:

    1. Obtain a database of the streets in your city, along with each street's
       address ranges and individual street segments. If you live in the
       U.S.A. and your city hasn't had much new development since the year
       2000, you might want to use the U.S. Census' TIGER/Line file
       (http://www.census.gov/geo/www/tiger/).

    2. Import the streets data into the "blocks" table. ebpub provides two
       pre-made import scripts:

           * If you're using TIGER/Line data, you can use the script
             ebpub/streets/blockimport/tiger/import_blocks.py.

           * If you're using data from ESRI, you can use the script
             ebpub/streets/blockimport/esri/importers/blocks.py.

           * If you're using data from another source, take a look at the
             Block model in ebpub/streets/models.py for all of the required
             fields.

Streets and Intersections
-------------------------

The ebpub system maintains a separate table of each street in the city. Once
you've populated the blocks, you can automatically populate the streets table
by running the importer ebpub/streets/populate_streets.py.

The ebpub system also maintains a table of each intersection in the city, where
an intersection is defined as the meeting point of two streets. Just like
streets, you can automatically populate the intersections table by running the
code in ebpub/streets/populate_streets.py.

Streets and intersections are both necessary for various bits of the site to
work, such as the "browse by street" navigation and the geocoder (which
supports the geocoding of intersections).

Once you've got all of the above geographic boundary data imported, you can
verify it on the site by going to /streets/ and /locations/.

Schemas
-------

Next, it's time to start adding news. The ebpub system is capable of handling
many disparate types of news -- e.g., crime, photos and restaurant inspections.
Each type of news is referred to as a Schema.

To add a new Schema, add a row to the "db_schema" database table or use the
Django database API. See the Schema model in ebpub/db/models.py for information
on all of the fields.

NewsItems
---------

A NewsItem is broadly defined as "something with a date and a location." For
example, it could be a building permit, a crime report or a photo. NewsItems
are stored in the "db_newsitem" database table, and they have the following
fields:

    schema -- the associated Schema object
    title -- the "headline"
    description -- an optional blurb describing what happened
    url -- an optional URL to another Web site
    pub_date -- the date this NewsItem was added to the site
    item_date -- the date of the object
    location -- the location of the object (a GeoDjango GeometryField)
    location_name -- a textual representation of the location
    location_object -- an optional associated Location object
    block -- an optional associated Block object

The difference between pub_date and item_date might be confusing. The
distinction is intended for data sets where there's a lag in publishing or
where the data is updated infrequently or irregularly. For example, on
EveryBlock.com, Chicago crime data is published a week after it is reported,
so a crime's item_date is the day of the crime report where as the pub_date
is the day the data was published to EveryBlock.com (generally seven days after
the item_date).

SchemaFields and Attributes
---------------------------

The NewsItem model in itself is generic -- a lowest-common denominator of each
NewsItem on the site. If you'd like to extend your NewsItems to include
Schema-specific attributes, you can use SchemaFields and Attributes.

The "db_attribute" table stores arbitrary attributes for each NewsItem, and
the "db_schemafield" table is the key for those attributes. A SchemaField says,
for example, that the "int01" column in the db_attribute table for the "real
estate sales" Schema corresponds to the "sale price".

This can be confusing, so here's an example. Say you have a "real estate sales"
Schema, with an id of 5. Say, for each sale, you have the following
information:

    address
    sale date
    sale price
    property type (single-family home, condo, etc.)

The first two fields should go in NewsItem.location_name and NewsItem.item_date,
respectively -- there's no reason to put them in the Attribute table, because
the NewsItem table has a slot for them.

Sale price is a number (we'll assume it's an integer), so create a SchemaField
defining it:

    schema_id = 5
        The id of our "real estate sales" schema.

    name = 'sale_price'
        The alphanumeric-and-underscores-only name for this field. (Used in URLs.)

    real_name = 'int01'
        The column to use in the db_attribute model. Choices are:
        int01-07, text01, bool01-05, datetime01-04, date01-05, time01-02,
        varchar01-05. This value must be unique with respect to the schema_id.

    pretty_name = 'sale price'
        The human-readable name for this attribute.

    pretty_name_plural = 'sale prices'
        The plural human-readable name for this attribute.

    display = True
        Whether to display the value on the site.

    is_lookup = False
        Whether it's a lookup. (Don't worry about this for now; see the Lookups
        section below.)

    is_filter = False
        Whether it's a filter. (Again, don't worry about this for now.)

    is_charted = False
        Whether it's charted. (Again, don't worry.)

    display_order = 1
        An integer representing what order it should be displayed in on
        newsitem_detail pages.

    is_searchable = False
        Whether it's searchable. This only applies to textual fields (varchars
        and texts).

Once you've created this SchemaField, the value of "int01" for any db_attribute
row with schema_id=5 will be the sale price.

Lookups
-------

Now let's consider the "property type" data we have for each real estate sale
NewsItem. We could store it as a varchar field (in which case we'd set
real_name='varchar01') -- but that would cause a lot of duplication and
redundancy, because there are only a couple of property types -- the set
['single-family', 'condo', 'land', 'multi-family']. To represent this set,
we can use a Lookup -- a way to normalize the data.

To do this, set SchemaField.is_lookup=True and make sure to use an 'int' column
for SchemaField.real_name. Then, for each record, get or create a Lookup
object (see the model in ebpub/db/models.py) that represents the data, and use
the Lookup's id in the appropriate db_attribute column. The helper function
Lookup.get_or_create_lookup() is a convenient shortcut here (see the
code/docstring of that function).

Many-to-many Lookups
--------------------

Sometimes a NewsItem has multiple values for a single attribute. For example, a
restaurant inspection can have multiple violations. In this case, you can use a
many-to-many Lookup. To do this, just set SchemaField.is_lookup=True as before,
but use a varchar field for the SchemaField.real_name. Then, in the
db_attribute column, set the value to a string of comma-separated integers of
the Lookup IDs.

Charting and filtering lookups
------------------------------

Set SchemaField.is_filter=True on a lookup SchemaField, and the detail page for
the NewsItem (newsitem_detail) will automatically link that field to a page
that lists all of the other NewsItems in that Schema with that particular
Lookup value.

Set SchemaField.is_charted=True on a lookup SchemaField, and the detail page
for the Schema (schema_detail) will include a chart of the top 10 lookup values
in the last 30 days' worth of data. (This assumes aggregates are populated; see
the Aggregates section below.)

Aggregates
----------

Several parts of ebpub display aggregate totals of NewsItems for a particular
Schema. Because these calculations can be expensive, there's an infrastructure
for caching the aggregate numbers regularly in separate tables (db_aggregate*).

To do this, just run ebpub/db/bin/update_aggregates.py.

You'll want to do this on a regular basis, depending on how often you update
your data. Some parts of the site (such as charts) will not be visible until
you populate the aggregates.

Site views/templates
====================

Once you've gotten some data into your site, you can use the site to browse it
in various ways. The system offers two primary axes by which to browse the
data:

    * By schema -- starting with the schema_detail view/template
    * By place -- starting with the place_detail view/template (where a "place"
      is defined as either a Block or Location)

Note that default templates are included in ebpub/templates. At the very least,
you'll want to override base.html to design your ebpub-powered site. (The
design of EveryBlock.com is copyrighted; you'll have to come up with your own
unique look-and-feel.)

Custom NewsItem lists
---------------------

When NewsItems are displayed as lists, generally templates should use the
newsitem_list_by_schema custom tag. This tag takes a list of NewsItems (in
which it is assumed that the NewsItems are ordered by schema) and renders them
through separate templates, depending on the schema. These templates should be
defined in the ebpub/templates/db/snippets/newsitem_list directory and named
[schema_slug].html. If a template doesn't exist for a given schema, the tag
will use the template ebpub/templates/db/snippets/newsitem_list.html.

We've included two sample schema-specific newsitem_list templates,
news-articles.html and photos.html.

Custom NewsItem detail pages
----------------------------

Similarly to the newsitem_list snippets, you can customize the newsitem_detail
page on a per-schema basis. Just create a template named [schema_slug].html in
ebpub/templates/db/newsitem_detail. See the template
ebpub/templates/db/newsitem_detail.html for the default implementation.

Custom Schema detail pages
--------------------------

To customize the schema_detail page for a given schema, create a template called
[schema_slug].html in ebpub/templates/db/schema_detail. See the template
ebpub/templates/db/schema_detail.html for the default implementation.

E-mail alerts
=============

Users can sign up for e-mail alerts via place_detail pages. To send the e-mail
alerts, just run the send_all() function in ebpub/alerts/sending.py.

Accounts
========

This system does *not* use Django's User objects or authentication
infrastructure. ebpub comes with its own User object and Django middleware that
sets request.user to the User if somebody's logged in.

Note that a side effect is that the Django admin site will not work with ebpub.
But fear not -- the EveryBlock team hasn't needed it.

<dl>
    <dt>Summary</dt>
    <dd>
        {% if obj.change_message %}
        {{ obj.change_message|escape }}
        {% else %}
        <i>No summary given.</i>
        {% endif %}
    </dd>

    <dt>Version</dt>
    <dd>
        <a href="{{ obj.version_url }}">{{ obj.version }}</a>
        (<a href="{{ obj.diff_url }}">Changes</a>)
    </dd>
</dl>

======
ebwiki
======

A basic wiki.

Requirements
============

A recent Django release. It has been tested with Django revision 11079 from
Subversion. When Django 1.1 is released, that should work as well.

Quickstart
==========

0. Install Django, PostgreSQL, and psycopg2.

1. Install the ebwiki package by putting it on your Python path.

2. Start a Django project (using Django 1.1, not 1.0). See the Django Book and
   Django docs for more:

       http://djangobook.com/en/2.0/
       http://docs.djangoproject.com/en/dev/

3. Update your settings file. It's probably easiest to just start with the
   file ebblog/settings.py and tweak that (or import from it in your own
   settings file). The application won't work until you set the following:

       DATABASE_USER
       DATABASE_NAME
       DATABASE_HOST
       DATABASE_PORT

   If you decide not to start with ebwiki.settings you'll also need to add
   ebwiki.wiki.urls to your urlconf and add the absolute path to
   ebwiki/templates to your TEMPLATE_DIRS setting.

4. Run "django-admin.py syncdb" to create all of the database tables.

5. Run "django-admin.py runserver" and go to http://127.0.0.1:8000/ in your
   Web browser to see the site in action.

==========
everyblock
==========

This package contains code/templates that are specific to EveryBlock.com. They
are released to fulfill the terms of the grant that funded EveryBlock's
development and are likely not of general use.

Overview
========

The package is split into these directories:

    admin -- EveryBlock's internal admin application for managing its data
    cities -- City-specific data-acquisition scripts (for 15 U.S. cities)
    media -- CSS file for the admin
    states -- State-specific data-acquisition scripts
    staticmedia -- A Django template tag specific to EveryBlock.com media files
    templates -- Templates for the admin
    utils -- Various utilities used on EveryBlock.com

Quickstart
==========

0. Install PostgreSQL, PostGIS, Django, psycopg2.

1. Install the everyblock package by putting it on your Python path. Also
   install the ebdata, ebpub and ebgeo packages.

2. Start a Django project.

3. Put the smorgasbord of eb-specific settings in your settings file. It's
   probably easiest to just start with the file ebpub/settings.py and tweak
   that (or import from it in your own settings file). The application won't
   work until you set the following:

       DATABASE_USER
       DATABASE_NAME
       DATABASE_HOST
       DATABASE_PORT
       SHORT_NAME
       PASSWORD_CREATE_SALT
       PASSWORD_RESET_SALT
       METRO_LIST
       EB_MEDIA_ROOT
       EB_MEDIA_URL

   See the documentation/comments in ebpub/settings.py for info on what the
   various settings mean.

4. Run "django-admin.py syncdb" to create all of the database tables.

5. Run "django-admin.py runserver" and go to http://127.0.0.1:8000/ in your
   Web browser to see the site in action.

