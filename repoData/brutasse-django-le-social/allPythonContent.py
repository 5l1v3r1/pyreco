__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Django-le-social documentation build configuration file, created by
# sphinx-quickstart on Wed Apr 27 19:29:40 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Django-le-social'
copyright = u'2011, Bruno Renié'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.8'
# The full version, including alpha/beta/rc tags.
release = '0.8'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
#html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Django-le-socialdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Django-le-social.tex', u'Django-le-social Documentation',
   u'Bruno Renié', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'django-le-social', u'Django-le-social Documentation',
     [u'Bruno Renié'], 1)
]

DIRECTORIES = (
    ('', 'make html'),
)
IGNORE_DIRECTORIES = ['_build']

########NEW FILE########
__FILENAME__ = forms
from django import forms
from django.utils.translation import ugettext_lazy as _


class OpenIDForm(forms.Form):
    openid_url = forms.URLField(label=_('OpenID URL'))

########NEW FILE########
__FILENAME__ = middleware
class OpenIDMiddleware(object):
    """
    Populates request.openid and request.openids
    """

    def process_request(self, request):
        request.openids = request.session.get('openids', [])

########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.utils.translation import ugettext_lazy as _


class Nonce(models.Model):
    server_url = models.CharField(_('Server URL'), max_length=255)
    timestamp = models.IntegerField(_('Timestamp'))
    salt = models.CharField(_('Salt'), max_length=40)

    def __unicode__(self):
        return u'Nonce: %s' % self.pk


class Association(models.Model):
    server_url = models.CharField(_('Server URL'), max_length=2047)
    handle = models.CharField(_('OpenID handle'), max_length=255)
    secret = models.CharField(_('OpenID secret'), max_length=255)
    issued = models.IntegerField(_('Issued'))
    lifetime = models.IntegerField(_('Lifetime'))
    assoc_type = models.CharField(_('Association type'), max_length=64)

    def __unicode__(self):
        return u'Association: %s, %s' % (self.server_url, self.handle)

########NEW FILE########
__FILENAME__ = store
import base64
import operator
import time

from hashlib import md5

try:
    from openid.association import Association as OIDAssociation
    from openid.store import nonce
    from openid.store.interface import OpenIDStore
except ImportError:
    from django.core.exceptions import ImproperlyConfigured
    raise ImproperlyConfigured(
        "python-openid is required to use le_social.openid"
    )

from django.conf import settings
from django.db.models import Q

from .models import Association, Nonce


class DjangoOpenIDStore(OpenIDStore):
    def __init__(self):
        self.max_nonce_age = 6 * 60 * 60  # Six hours

    def storeAssociation(self, server_url, association):
        Association.objects.create(
            server_url=server_url,
            handle=association.handle,
            secret=base64.encodestring(association.secret),
            issued=association.issued,
            lifetime=association.lifetime,
            assoc_type=association.assoc_type,
        )

    def getAssociation(self, server_url, handle=None):
        assocs = []
        if handle is not None:
            assocs = Association.objects.filter(
                server_url=server_url, handle=handle,
            )
        else:
            assocs = Association.objects.filter(server_url=server_url)
        if not assocs:
            return None
        associations = []
        expired = []
        for assoc in assocs:
            association = OIDAssociation(
                assoc.handle, base64.decodestring(assoc.secret), assoc.issued,
                assoc.lifetime, assoc.assoc_type,
            )
            if association.getExpiresIn() == 0:
                expired.append(assoc)
            else:
                associations.append((association.issued, association))

        for assoc in expired:
            assoc.delete()
        if not associations:
            return None
        associations.sort()
        return associations[-1][1]

    def removeAssociation(self, server_url, handle):
        assocs = list(Association.objects.filter(
            server_url=server_url, handle=handle,
        ))
        assocs_exist = len(assocs) > 0
        for assoc in assocs:
            assoc.delete()
        return assocs_exist

    def useNonce(self, server_url, timestamp, salt):
        if abs(timestamp - time.time()) > nonce.SKEW:
            return False

        query = [
            Q(server_url__exact=server_url),
            Q(timestamp__exact=timestamp),
            Q(salt__exact=salt),
        ]
        try:
            Nonce.objects.get(reduce(operator.and_, query))
        except Nonce.DoesNotExist:
            Nonce.objects.create(
                server_url=server_url,
                timestamp=timestamp,
                salt=salt,
            )
            return True
        return False

    def cleanupNonces(self, _now=None):
        if _now is None:
            _now = int(time.time())
        limit = _now - nonce.SKEW
        expired = Nonce.objects.filter(timestamp__lt=limit)
        count = expired.count()
        if count:
            expired.delete()
        return count

    def cleanupAssociations(self):
        now = int(time.time())
        expired = Association.objects.extra(
            where=['issued + lifetime < %d' % now])
        count = expired.count()
        if count:
            expired.delete()
        return count

    def getAuthKey(self):
        return md5(settings.SECRET_KEY).hexdigest()[:self.AUTH_KEY_LEN]

    def isDumb(self):
        return False

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url

from . import views


urlpatterns = patterns(
    '',
    url(r'^openid/$', views.begin, name='openid_begin'),
    url(r'^openid/complete/$', views.callback, name='openid_callback'),
)

########NEW FILE########
__FILENAME__ = views
from django.core.urlresolvers import reverse
from django.http import HttpResponse

from .. import views


class Common(object):
    """
    Stuff shared by the two views.
    """
    def get_return_url(self):
        return reverse('openid_callback')

    def failure(self, message):
        return HttpResponse(message)


class Begin(Common, views.Begin):
    template_name = 'le_social/openid/openid.html'
begin = Begin.as_view()


class Callback(Common, views.Callback):
    def success(self):
        openid_url = self.openid_response.identity_url
        return HttpResponse('OpenID association: %s' % openid_url)
callback = Callback.as_view()

########NEW FILE########
__FILENAME__ = utils
import time

try:
    from openid.consumer.discover import discover
    from openid.extensions import sreg, ax
    from openid.yadis import xri
except ImportError:
    from django.core.exceptions import ImproperlyConfigured
    raise ImproperlyConfigured(
        "python-openid is required to use le_social.openid"
    )

from django.http import get_host
from django.utils.html import escape


class OpenID(object):
    def __init__(self, openid, issued, attrs=None, sreg_=None, ax_=None):
        self.openid = openid
        self.issued = issued
        self.attrs = attrs or {}
        self.sreg = sreg_ or {}
        self.ax = ax_ or {}
        self.is_iname = (xri.identifierScheme(openid) == 'XRI')

    def __repr__(self):
        return '<OpenID: %s>' % self.openid

    def __str__(self):
        return self.openid


def get_url_host(request):
    scheme = 'https' if request.is_secure() else 'http'
    host = escape(get_host(request))
    return '%s://%s' % (scheme, host)


def discover_extensions(openid_url):
    service = discover(openid_url)
    use_ax = False
    use_sreg = False
    for endpoint in service[1]:
        if not use_sreg:
            use_sreg = sreg.supportsSReg(endpoint)
        if not use_ax:
            use_ax = endpoint.usesExtension("http://openid.net/srv/ax/1.0")
        if use_ax and use_sreg:
            break
    if not use_sreg and not use_ax:
        use_sreg = True
    return use_ax, use_sreg


def from_openid_response(openid_response):
    issued = int(time.time())
    sreg_resp = (sreg.SRegResponse.fromSuccessResponse(openid_response) or
                 [])
    ax_resp = ax.FetchResponse.fromSuccessResponse(openid_response)
    ax_args = {}
    if ax_resp is not None:
        ax_args = ax_resp.getExtensionArgs()
        ax_resp.parseExtensionArgs(ax_args)
        ax_args = ax_resp.data

    return OpenID(
        openid_response.identity_url, issued, openid_response.signed_fields,
        dict(sreg_resp), ax_args,
    )

########NEW FILE########
__FILENAME__ = views
try:
    from openid.consumer.consumer import (Consumer, SUCCESS, CANCEL, FAILURE,
                                          SETUP_NEEDED)
    from openid.consumer.discover import DiscoveryFailure
    from openid.extensions import sreg, ax
except ImportError:
    from django.core.exceptions import ImproperlyConfigured
    raise ImproperlyConfigured(
        "python-openid is required to use le_social.openid"
    )

from django.shortcuts import redirect
from django.utils.encoding import smart_unicode
from django.utils.translation import ugettext_lazy as _
from django.views import generic

from .forms import OpenIDForm
from .middleware import OpenIDMiddleware
from .store import DjangoOpenIDStore
from .utils import get_url_host, discover_extensions, from_openid_response


class ReturnUrlMixin(object):
    return_url = None

    def get_return_url(self):
        if self.return_url is None:
            raise NotImplementedError("Either set the return_url or "
                                      "implement get_return_url()")
        return get_url_host(self.request) + self.return_url


class Begin(generic.FormView, ReturnUrlMixin):
    form_class = OpenIDForm
    sreg_attrs = {}
    ax_attrs = []
    store_class = DjangoOpenIDStore
    trust_root = '/'

    def form_valid(self, form):
        openid_url = form.cleaned_data['openid_url']
        return_url = self.get_return_url()
        return self.ask_openid(openid_url, return_url)

    def get_trust_root(self):
        return get_url_host(self.request) + self.trust_root

    def get_sreg_attrs(self):
        return self.sreg_attrs

    def get_ax_attrs(self):
        return self.ax_attrs

    def ask_openid(self, openid_url, return_url):
        trust_root = self.get_trust_root()
        consumer = Consumer(self.request.session, self.store_class())

        try:
            auth_request = consumer.begin(openid_url)
        except DiscoveryFailure:
            message = _('The OpenID %(url)s was invalid')
            return self.failure(message % {'url': openid_url})

        use_ax, use_sreg = discover_extensions(openid_url)
        sreg_request = None
        ax_request = None
        if use_sreg:
            sreg_attrs = self.get_sreg_attrs()
            if 'optional' not in sreg_attrs:
                sreg_attrs.update({'optional': ['nickname', 'email']})
            sreg_request = sreg.SRegRequest(**sreg_attrs)
        if use_ax:
            ax_request = ax.FetchRequest()
            ax_request.add(
                ax.AttrInfo('http://schema.openid.net/contact/email',
                            alias='email', required=True),
            )
            ax_request.add(
                ax.AttrInfo('http://schema.openid.net/namePerson/friendly',
                            alias='nickname', required=True),
            )
            ax_attrs = self.get_ax_attrs()
            for attr in ax_attrs:
                if len(attr) == 2:
                    ax_request.add(ax.AttrInfo(attr[0], required=attr[1]))
                else:
                    ax_request.add(ax.AttrInfo(attr[0]))

        if sreg_request is not None:
            auth_request.addExtension(sreg_request)
        if ax_request is not None:
            auth_request.addExtension(ax_request)
        redirect_url = auth_request.redirectURL(trust_root, return_url)
        return redirect(redirect_url)

    def failure(self, message):
        raise NotImplementedError("You need to provide an implementation "
                                  "of failure()")


class BadOpenIDStatus(Exception):
    pass


class Callback(generic.View, ReturnUrlMixin):
    def success(self):
        """
        Gets called when the OpenID authentication is successful.
        """
        raise NotImplementedError("You need to provide an implementation "
                                  "of success()")

    def failure(self, message):
        """
        Gets called when the OpenID authentication fails.
        """
        raise NotImplementedError("You need to provide an implementation "
                                  "of failure()")

    def get(self, request, *args, **kwargs):
        consumer = Consumer(request.session, DjangoOpenIDStore())
        query = dict((k, smart_unicode(v)) for k, v in request.GET.items())
        openid_response = consumer.complete(query, self.get_return_url())
        self.openid_response = openid_response

        if openid_response.status == SUCCESS:
            if 'openids' not in request.session.keys():
                request.session['openids'] = []
            request.session['openids'] = filter(
                lambda o: o.openid != openid_response.identity_url,
                request.session['openids'],
            )
            request.session['openids'].append(
                from_openid_response(openid_response),
            )
            OpenIDMiddleware().process_request(request)
            return self.success()
        elif openid_response.status == CANCEL:
            return self.failure(_('The request was cancelled'))
        elif openid_response.status == FAILURE:
            return self.failure(openid_response.message)
        elif openid_response.status == SETUP_NEEDED:
            return self.failure(_('Setup needed'))
        else:
            raise BadOpenIDStatus(openid_response.status)

########NEW FILE########
__FILENAME__ = forms
from django import forms
from django.utils.translation import ugettext_lazy as _

from ..utils import get_user_model


class RegistrationForm(forms.Form):
    username = forms.RegexField(
        regex=r'^[\w.@+-]+$', max_length=30, label=_('Username'),
        error_messages={'invalid': _('The username must contain only letters, '
                                     'numbers and underscores.')},
    )
    email = forms.EmailField(label=_('Email'))
    password1 = forms.CharField(label=_('Password'),
                                widget=forms.PasswordInput)
    password2 = forms.CharField(label=_('Password (again)'),
                                widget=forms.PasswordInput)

    def clean(self):
        data = self.cleaned_data
        if ('password1' in data and 'password2' in data):
            if data['password1'] != data['password2']:
                raise forms.ValidationError(
                    _("The two passwords didn't match."),
                )
        return self.cleaned_data

    def save(self):
        user = get_user_model().objects.create_user(
            self.cleaned_data['username'],
            self.cleaned_data['email'],
            self.cleaned_data['password1'],
        )
        user.is_active = False
        user.save()
        return user

########NEW FILE########
__FILENAME__ = models

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url

from . import views

urlpatterns = patterns(
    '',
    url(r'^activate/complete/$', views.activation_complete,
        name='registration_activation_complete'),

    url(r'^activate/(?P<activation_key>.+)/$', views.activate,
        name='registration_activate'),

    url(r'^activate-expired/(?P<activation_key>.+)/$', views.activate_expired,
        name='registration_activate_expired'),

    url(r'^register/$', views.register,
        name='registration_register'),

    url(r'^register-no-notify/$', views.register_with_no_notification,
        name='registration_register_with_notification'),

    url(r'^register-closed/$', views.register_but_closed,
        name='registration_register_but_closed'),

    url(r'^register-expired/$', views.register_expired,
        name='registration_register_expired'),

    url(r'^register/complete/$', views.registration_complete,
        name='registration_complete'),

    url(r'^register/closed/$', views.registration_closed,
        name='registration_closed'),
)

########NEW FILE########
__FILENAME__ = views
from .. import views

activation_complete = views.ActivationComplete.as_view()
registration_complete = views.RegistrationComplete.as_view()
registration_closed = views.RegistrationClosed.as_view()
register = views.Register.as_view()


class NoNotificationRegistration(views.Register):
    def send_notification(self):
        return
register_with_no_notification = NoNotificationRegistration.as_view()

register_but_closed = views.Register.as_view(registration_closed=True)
activate = views.Activate.as_view()


register_expired = views.Register.as_view(
    notification_template_name=('le_social/registration/'
                                'expired_activation_email.txt'),
)


class ExpiringActivate(views.Activate):
    expires_in = -1  # In the past
activate_expired = ExpiringActivate.as_view()

########NEW FILE########
__FILENAME__ = views
from django.conf import settings
from django.contrib.sites.models import RequestSite
from django.core import signing
from django.core.mail import send_mail
from django.core.urlresolvers import reverse_lazy
from django.shortcuts import redirect
from django.template.loader import render_to_string
from django.utils.encoding import force_text
from django.views import generic

from ..utils import get_user_model
from .forms import RegistrationForm


class ActivationComplete(generic.TemplateView):
    template_name = 'le_social/registration/activation_complete.html'


class Activate(generic.TemplateView):
    template_name = 'le_social/registration/activate.html'
    success_url = reverse_lazy('registration_activation_complete')
    expires_in = 60 * 60 * 24 * 30  # 30 days

    def dispatch(self, request, *args, **kwargs):
        try:
            self.activation_key = signing.loads(kwargs['activation_key'],
                                                max_age=self.get_expires_in(),
                                                salt='le_social.registration')
        except signing.BadSignature:
            return super(Activate, self).dispatch(request, *args, **kwargs)
        self.request = request
        self.args = args
        self.kwargs = kwargs
        self.activate()
        return redirect(self.get_success_url())

    def get_expires_in(self):
        return self.expires_in

    def get_success_url(self):
        return force_text(self.success_url)

    def activate(self):
        get_user_model().objects.filter(
            pk=self.activation_key).update(is_active=True)


class Register(generic.FormView):
    closed_url = reverse_lazy('registration_closed')
    form_class = RegistrationForm
    registration_closed = False
    success_url = reverse_lazy('registration_complete')
    template_name = 'le_social/registration/register.html'
    notification_template_name = 'le_social/registration/activation_email.txt'
    notification_subject_template_name = ('le_social/registration/'
                                          'activation_email_subject.txt')

    def dispatch(self, request, *args, **kwargs):
        if self.get_registration_closed():
            return redirect(self.get_closed_url())
        return super(Register, self).dispatch(request, *args, **kwargs)

    def get_registration_closed(self):
        return self.registration_closed

    def get_closed_url(self):
        return force_text(self.closed_url)

    def form_valid(self, form):
        self.user = form.save()
        self.activation_key = signing.dumps(self.user.pk,
                                            salt='le_social.registration')
        self.send_notification()
        return super(Register, self).form_valid(form)

    def get_notification_context(self):
        return {
            'user': self.user,
            'activation_key': self.activation_key,
            'site': RequestSite(self.request),
        }

    def send_notification(self):
        context = self.get_notification_context()
        send_mail(
            render_to_string(self.notification_subject_template_name,
                             context).strip(),
            render_to_string(self.notification_template_name, context),
            settings.DEFAULT_FROM_EMAIL,
            [self.user.email],
        )


class RegistrationComplete(generic.TemplateView):
    template_name = 'le_social/registration/registration_complete.html'


class RegistrationClosed(generic.TemplateView):
    template_name = 'le_social/registration/registration_closed.html'

########NEW FILE########
__FILENAME__ = models

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url

from . import views


urlpatterns = patterns(
    '',
    url(r'^oauth/authorize/$', views.authorize, name='authorize'),
    url(r'^oauth/callback/$', views.callback, name='callback'),
)

########NEW FILE########
__FILENAME__ = views
from __future__ import absolute_import

import twitter

from django.http import HttpResponse

from .. import views

kwargs = {'consumer_key': 'key',
          'consumer_secret': 'secret'}

authorize = views.Authorize.as_view(**kwargs)


class Callback(views.Callback):
    def error(self, message, exception=None):
        return HttpResponse(message)

    def success(self, auth):
        api = twitter.Twitter(auth=auth)
        user = api.account.verify_credentials()
        return HttpResponse(user['screen_name'])
callback = Callback.as_view(**kwargs)

########NEW FILE########
__FILENAME__ = views
from __future__ import absolute_import

from django.conf import settings
from django.core.exceptions import ImproperlyConfigured
from django.shortcuts import redirect
from django.views import generic

try:
    from twitter import Twitter, OAuth, TwitterError
    from twitter.oauth_dance import parse_oauth_tokens
except ImportError:
    raise ImproperlyConfigured(
        "twitter<1.8 is required to use le_social.twitter."
    )


class OAuthMixin(object):
    consumer_key = None
    consumer_secret = None

    def get_consumer_key(self):
        if self.consumer_key is not None:
            return self.consumer_key
        if hasattr(settings, 'CONSUMER_KEY'):
            return settings.CONSUMER_KEY
        else:
            raise ImproperlyConfigured("Set settings.CONSUMER_KEY or the "
                                       "consumer_key attribute or "
                                       "implement get_consumer_key")

    def get_consumer_secret(self):
        if self.consumer_secret is not None:
            return self.consumer_secret
        if hasattr(settings, 'CONSUMER_SECRET'):
            return settings.CONSUMER_SECRET
        else:
            raise ImproperlyConfigured("Set settings.CONSUMER_SECRET or the "
                                       "consumer_secret attribute or "
                                       "implement get_consumer_secret")


class Authorize(generic.View, OAuthMixin):
    """
    A base class for the authorize view. Just sets the request token
    in the session and redirects to twitter.
    """
    def get(self, request, force_login=False, *args, **kwargs):
        callback = self.build_callback()
        oauth = OAuth('', '',
                      self.get_consumer_key(),
                      self.get_consumer_secret())
        api = Twitter(auth=oauth, secure=True, format='', api_version=None)
        (oauth.token, oauth.token_secret) = parse_oauth_tokens(
            api.oauth.request_token(oauth_callback=callback))
        request.session['request_token'] = (oauth.token, oauth.token_secret)
        url = ('https://api.twitter.com/oauth/authenticate?oauth_token='
               '%s' % oauth.token)
        if force_login:
            url += '&force_login=true'
        return redirect(url)

    def build_callback(self):
        """ Override this if you'd like to specify a callback URL"""
        return None


class Callback(generic.View, OAuthMixin):
    """
    A base class for the return callback. Subclasses must define:

        - error(error_msg, exception=None): what to do when
          something goes wrong? Must return an HttpResponse

        - success(auth): what to do on successful auth? Do
          some stuff with the twitter.OAuth object and return
          an HttpResponse
    """
    def get(self, request, *args, **kwargs):
        verifier = request.GET.get('oauth_verifier', None)
        if verifier is None:
            return self.error('No verifier code')

        if not 'request_token' in request.session:
            return self.error('No request token found in the session')

        request_token = request.session.pop('request_token')
        request.session.modified = True

        oauth = OAuth(request_token[0], request_token[1],
                      self.get_consumer_key(),
                      self.get_consumer_secret())
        api = Twitter(auth=oauth, secure=True, format='', api_version=None)
        try:
            (oauth.token, oauth.token_secret) = parse_oauth_tokens(
                api.oauth.access_token(oauth_verifier=verifier))
        except TwitterError:
            return self.error('Failed to get an access token')

        return self.success(oauth)

    def success(self, auth):
        """
        Twitter authentication successful, do some stuff with his key.
        """
        raise NotImplementedError("You need to provide an implementation of "
                                  "success(auth)")

    def error(self, message, exception=None):
        """
        Meh. Something broke.
        """
        raise NotImplementedError("You need to provide an implementation of "
                                  "error(message, exception=None)")

########NEW FILE########
__FILENAME__ = utils
try:
    from django.contrib.auth import get_user_model
except ImportError:
    from django.contrib.auth.models import User
    get_user_model = lambda: User  # noqa

########NEW FILE########
__FILENAME__ = runtests
#!/usr/bin/env python
import os
import sys

import django

from django.conf import settings
try:
    from django.utils.functional import empty
except ImportError:
    empty = None

from le_social import openid, registration

try:
    import twitter
except ImportError:
    twitter = None

try:
    import openid as openid_
except ImportError:
    openid_ = None




def test_templates(module):
    return os.path.join(os.path.dirname(module.__file__), 'test_templates')


def setup_test_environment():
    # reset settings
    settings._wrapped = empty

    apps = [
        'django.contrib.sessions',
        'django.contrib.auth',
        'django.contrib.contenttypes',
        'django.contrib.sites',
        'django.contrib.messages',

        'le_social.registration',
    ]

    if twitter is not None:
        apps += [
            'le_social.twitter',
        ]

    if openid_ is not None:
        apps += [
            'le_social.openid',
        ]

    middleware_classes = [
        'django.middleware.common.CommonMiddleware',
        'django.contrib.sessions.middleware.SessionMiddleware',
        'django.contrib.messages.middleware.MessageMiddleware',
        'django.contrib.auth.middleware.AuthenticationMiddleware',
        'django.middleware.csrf.CsrfViewMiddleware',
    ]

    context_processors = [
        'django.contrib.auth.context_processors.auth',
        'django.contrib.messages.context_processors.messages',
    ]

    if django.VERSION[:2] <= (1, 2):
        middleware_classes.append('cbv.middleware.DeferredRenderingMiddleware')
        apps.append('django.contrib.admin')

    settings_dict = {
        "DATABASES": {
            'default': {
                'ENGINE': "django.db.backends.sqlite3",
                'NAME': 'le_social.sqlite',
            },
        },
        "ROOT_URLCONF": "",
        "MIDDLEWARE_CLASSES": middleware_classes,
        "INSTALLED_APPS": apps,
        "TEMPLATE_DIRS": [
            test_templates(openid),
            test_templates(registration),
        ],
        "TEMPLATE_CONTEXT_PROCESSORS": context_processors,
        "SITE_ID": 1,
    }

    # set up settings for running tests for all apps
    settings.configure(**settings_dict)


def runtests(*test_args):
    if not test_args:
        test_args = ('registration',)
        if twitter is not None:
            test_args += (
                'twitter',
            )
        if openid_ is not None:
            test_args += (
                'openid',
            )
    setup_test_environment()

    parent = os.path.dirname(os.path.abspath(__file__))
    sys.path.insert(0, parent)
    try:
        from django.test.simple import DjangoTestSuiteRunner

        def run_tests(test_args, verbosity, interactive):
            runner = DjangoTestSuiteRunner(
                verbosity=verbosity, interactive=interactive, failfast=False)
            return runner.run_tests(test_args)
    except ImportError:
        # for Django versions that don't have DjangoTestSuiteRunner
        from django.test.simple import run_tests
    failures = run_tests(test_args, verbosity=1, interactive=True)
    sys.exit(failures)


if __name__ == '__main__':
    runtests()

########NEW FILE########
