__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# yolk documentation build configuration file, created by
# sphinx-quickstart on Sun Feb  5 23:10:07 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'yolk'
copyright = u'2012, Rob Cakebread'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.4.2'
# The full version, including alpha/beta/rc tags.
release = '0.4.2'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'yolkdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'yolk.tex', u'yolk Documentation',
   u'Rob Cakebread', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'yolk', u'yolk Documentation',
     [u'Rob Cakebread'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'yolk', u'yolk Documentation',
   u'Rob Cakebread', 'yolk', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = yolk_acme
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""

yolk_acme

This is a plugin for acme, the package manager for Acme Linux.
It provides information for packages installed by Acme.

--acme used with -l, -a or -n will show you if the packages
were installed by Acme.


"""

__docformat__ = 'restructuredtext'

import os
from distutils.sysconfig import get_python_lib
from commands import getstatusoutput


class PackageManagerPlugin:

    """Class for finding pkgs installed by external package manager"""

    #This is the name of the external package manager
    #This will become a new yolk option: --acme
    name = "acme"

    enabled = False
    enable_opt = None

    def __init__(self):
        if self.name is None:
            self.name = self.__class__.__name__.lower()
        if self.enable_opt is None:
            self.enable_opt = "enable_plugin_%s" % self.name
            
    def add_options(self, parser):
        """Add plugin's options to yolk"""
        parser.add_option('--%s' % self.name, action='store_true', 
                dest=self.enable_opt,
                help="Show which packages are installed via the " +
                     " %s package manager. Use with -l" % self.name)

    def configure(self, options, conf):
        """Configure the plugin and system, based on selected options.

        The base plugin class sets the plugin to enabled if the enable option
        for the plugin (self.enableOpt) is true.
        """
        self.conf = conf
        if hasattr(options, self.enable_opt):
            self.enabled = getattr(options, self.enable_opt)

    def add_column(self, dist):
        """
        Add column of text to output of -l, -n or -a
        Text will be appended to normal output.
        e.g.
        normal output:
        java-config     - 2.0.31       - active
        
        Using plugin with add_column:
        java-config     - 2.0.31       - active YOUR EXTRA TEXT
        """
        return self.package_manager_owns(dist)

    def package_manager_owns(self, dist):
        """
        Returns True if package manager 'owns' file
        Returns False if package manager does not 'own' file

        There is currently no way to determine if distutils or
        setuptools installed a package. A future feature of setuptools
        will make a package manifest which can be checked.
           
        'filename' must be the full path to file

        """
        #Installed by distutils/setuptools or external package manager?
        #If location is in site-packages dir, check for .egg-info file
        if dist.location.lower() == get_python_lib().lower():
            filename = os.path.join(dist.location, dist.egg_name() + ".egg-info")
        else:
            filename = dist.location

        status, output = getstatusoutput("/usr/bin/acmefile -q %s" % filename)
        #status == 0 (file was installed by Acme)
        #status == 256 (file was not installed by Acme)
        if status == 0:
            return self.name
        else:
            return ""



########NEW FILE########
__FILENAME__ = yolk_portage
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""

yolk-portage
============

This is a plugin for yolk. It provides information for Gentoo
systems using Portage.

--portage used with -l, -a or -n will show you if the packages
were installed by Portage or directly by easy_install/setuptools/distutils.


"""

__docformat__ = 'restructuredtext'

import os
from distutils.sysconfig import get_python_lib
from commands import getstatusoutput


class PackageManagerPlugin:

    """Class for using Gentoo Portage as external package manager"""

    #This is the name of the external package manager
    #This will become a new yolk option: --portage
    name = "portage"

    enabled = False
    enable_opt = None

    def __init__(self):
        if self.name is None:
            self.name = self.__class__.__name__.lower()
        if self.enable_opt is None:
            self.enable_opt = "enable_plugin_%s" % self.name
            
    def add_options(self, parser):
        """Add plugin's options to yolk"""
        parser.add_option('--%s' % self.name, action='store_true', 
                dest=self.enable_opt,
                help="Show which packages are installed via the " +
                     "%s package manager. Use with -l, -a or -n" % self.name)

    def configure(self, options, conf):
        """Configure the plugin and system, based on selected options.

        The base plugin class sets the plugin to enabled if the enable option
        for the plugin (self.enableOpt) is true.
        """
        self.conf = conf
        if hasattr(options, self.enable_opt):
            self.enabled = getattr(options, self.enable_opt)

    def add_column(self, dist):
        """
        Add column of text to output of -l, -n or -a
        Text will be appended to normal output.
        e.g.
        normal output:
        java-config     - 2.0.31       - active
        
        Using plugin with add_column:
        java-config     - 2.0.31       - active YOUR EXTRA TEXT
        """
        return self.package_manager_owns(dist)

    def package_manager_owns(self, dist):
        """
        Returns True if package manager 'owns' file
        Returns False if package manager does not 'own' file

        There is currently no way to determine if distutils or
        setuptools installed a package. A future feature of setuptools
        will make a package manifest which can be checked.
           
        'filename' must be the full path to file

        """
        #Installed by distutils/setuptools or external package manager?
        #If location is in site-packages dir, check for .egg-info file
        if dist.location.lower() == get_python_lib().lower():
            filename = os.path.join(dist.location, dist.egg_name() + ".egg-info")
        else:
            filename = dist.location

        status, output = getstatusoutput("/usr/bin/qfile -q %s" % filename)
        #status == 0 (file was installed by Gentoo Portage)
        #status == 256 (file was not installed by Gentoo Portage)
        if status == 0:
            return output.split()[0]
        else:
            return ""

    def get_highest_version_available(self, category, package):
        """
        Find highest available version through package manager

        This can be used with -U to see if a higher version
        is available through the package manager but is not 
        yet installed.
        
        """
        
        #XXX Use gentoolkit?
        pass


########NEW FILE########
__FILENAME__ = rss_feed
#!/usr/bin/env python

"""
Some basic tests of the command-line and API using the PyPI RSS feed of recent
updates.

Known issues: Package names with spaces will show as a fail.

"""

__docformat__ = 'restructuredtext'

import urllib
import os
import sys


if sys.version_info[0] == 2 and sys.version_info[1] == 5:
    #Python >=2.5 has elementtree 
    from xml.etree.cElementTree import iterparse
else:
    try:
        #Python <2.5 has elementtree as 3rd party module
        from cElementTree import iterparse
    except ImportError:
        print "You need to install cElementTree"
        sys.exit(2)




from yolk.pypi import CheeseShop

PYPI_URL = 'http://www.python.org/pypi?:action=rss'


def get_pkg_ver(pv, add_quotes=True):
    """Return package name and version"""
    #XXX Fix package names with spaces bug.
    n = len(pv.split())
    if n == 2:
        #Normal package_name 1.0
        pkg_name, ver = pv.split()
    else:
        parts = pv.split()
        ver = parts[-1:]
        if add_quotes:
            pkg_name = "'%s'" % " ".join(parts[:-1])
        else:
            pkg_name = "%s" % " ".join(parts[:-1])
    return pkg_name, ver

def test_api(pypi_xml):
    """Basic API tests"""
    print "Testing API"""
    skipped = 0
    skipped_msgs = []
    failed = 0
    failed_msgs = []
    for event, elem in iterparse(pypi_xml):
        if elem.tag == "title":
            if not elem.text.startswith('Cheese Shop recent updates'):
                pkg_name, ver = get_pkg_ver(elem.text, False)
                (pypi_pkg_name, versions) = PyPI.query_versions_pypi(pkg_name)
                if " " in pypi_pkg_name:
                    skipped +=1
                    failed_msgs.append("%s %s" \
                            % (pkg_name, "- space in project name"))
                try:
                    assert versions[0] == ver
                    print "Testing %s... passed" % elem.text
                except:
                    failed += 1
                    failed_msgs.append("%s %s" % (pkg_name, versions))
                    print "Testing %s... failed" % elem.text

    print "%s tests failed." % failed
    for msg in failed_msgs:
        print "\t%s" % msg
    print "%s tests skipped." % skipped
    for msg in skipped_msgs:
        print "\t%s" % msg

def test_cli(pypi_xml):
    """Test the command-line tool"""
    print "Testing CLI"
    for event, elem in iterparse(pypi_xml):
        if elem.tag == "title":
            if not elem.text.startswith('Cheese Shop recent updates'):
                print "Testing %s..." % elem.text
                pkg_name, ver = get_pkg_ver(elem.text)
                if " " in pkg_name:
                    print "Space in package name, skipping: %s" % pkg_name
                else:
                    os.system("yolk -V '%s'" % pkg_name)
                    os.system("yolk -D %s==%s" % (pkg_name, ver))
            elem.clear()

test_cli(urllib.urlopen(PYPI_URL))
PyPI = CheeseShop()
test_api(urllib.urlopen(PYPI_URL))

########NEW FILE########
__FILENAME__ = test_yolk_cli
import unittest

import yolk.yolklib



class TestStdOut:
    def test_object_initialization(self):
        pass # TODO: implement your test here

    def test_write(self):
        pass # TODO: implement your test here

    def test_writelines(self):
        pass # TODO: implement your test here

class TestYolk:
    def test_object_initialization(self):
        pass # TODO: implement your test here

    def test_get_plugin(self):
        pass # TODO: implement your test here

    def test_set_log_level(self):
        pass # TODO: implement your test here

    def test_run(self):
        pass # TODO: implement your test here

    def test_show_active(self):
        pass # TODO: implement your test here

    def test_show_non_active(self):
        pass # TODO: implement your test here

    def test_show_all(self):
        pass # TODO: implement your test here

    def test_show_updates(self):
        pass # TODO: implement your test here

    def test_show_distributions(self):
        pass # TODO: implement your test here

    def test_print_metadata(self):
        pass # TODO: implement your test here

    def test_show_deps(self):
        pass # TODO: implement your test here

    def test_show_pypi_changelog(self):
        pass # TODO: implement your test here

    def test_show_pypi_releases(self):
        pass # TODO: implement your test here

    def test_show_download_links(self):
        pass # TODO: implement your test here

    def test_print_download_uri(self):
        pass # TODO: implement your test here

    def test_fetch(self):
        pass # TODO: implement your test here

    def test_fetch_uri(self):
        pass # TODO: implement your test here

    def test_fetch_svn(self):
        pass # TODO: implement your test here

    def test_browse_website(self):
        pass # TODO: implement your test here

    def test_query_metadata_pypi(self):
        pass # TODO: implement your test here

    def test_versions_available(self):
        pass # TODO: implement your test here

    def test_parse_search_spec(self):
        pass # TODO: implement your test here

    def test_pypi_search(self):
        pass # TODO: implement your test here

    def test_show_entry_map(self):
        pass # TODO: implement your test here

    def test_show_entry_points(self):
        pass # TODO: implement your test here

    def test_yolk_version(self):
        pass # TODO: implement your test here

    def test_parse_pkg_ver(self):
        pass # TODO: implement your test here

class TestSetupOptParser:
    def test_setup_opt_parser(self):
        pass # TODO: implement your test here

class TestPrintPkgVersions:
    def test_print_pkg_versions(self):
        pass # TODO: implement your test here

class TestValidatePypiOpts:
    def test_validate_pypi_opts(self):
        pass # TODO: implement your test here

class TestMain:
    def test_main(self):
        pass # TODO: implement your test here
 
 
class TestYolkLib (unittest.TestCase):
    def test_get_highest_version(self):
        versions = ['2.2', '3.0.5', '1.3', '3.1.2', '1.3.4', '0.3', '3.1.1', '1.2.4']
        self.assertEqual('3.1.2', yolk.yolklib.get_highest_version(versions))

########NEW FILE########
__FILENAME__ = cli
# pylint: disable-msg=W0613,W0612,W0212,W0511,R0912,C0322,W0704
# W0511 = XXX (my own todo's)

"""

cli.py
======

Desc: Command-line tool for listing Python packages installed by setuptools,
      package metadata, package dependencies, and querying The Cheese Shop
      (PyPI) for Python package release information such as which installed
      packages have updates available.

Author: Rob Cakebread <gentoodev a t gmail.com>

License : BSD (See COPYING)

"""

__docformat__ = 'restructuredtext'


import inspect
import re
import pprint
import os
import sys
import optparse
import pkg_resources
import webbrowser
import logging
import platform
if platform.python_version().startswith('2'):
    from xmlrpclib import Fault as XMLRPCFault
    from urllib import urlretrieve
    from urlparse import urlparse
else:
    from xmlrpc.client import Fault as XMLRPCFault
    from urllib.request import urlretrieve
    from urllib.parse import urlparse
from distutils.sysconfig import get_python_lib
from yolk.metadata import get_metadata
from yolk.yolklib import get_highest_version, Distributions
from yolk.pypi import CheeseShop
from yolk.setuptools_support import get_download_uri, get_pkglist
from yolk.plugins import load_plugins
from yolk.utils import run_command, command_successful
from yolk.__init__ import __version__ as VERSION



class StdOut:

    """
    Filter stdout or stderr from specific modules
    So far this is just used for pkg_resources
    """

    def __init__(self, stream, modulenames):
        self.stdout = stream
        #Modules to squelch
        self.modulenames = modulenames

    def __getattr__(self, attribute):
        if not self.__dict__.has_key(attribute) or attribute == '__doc__':
            return getattr(self.stdout, attribute)
        return self.__dict__[attribute]

    def flush(self):
        """Bug workaround for Python 3.2+:
         Exception AttributeError: 'flush' in <yolk.cli.StdOut object...
         """
        pass

    def write(self, inline):
        """
        Write a line to stdout if it isn't in a blacklist

        Try to get the name of the calling module to see if we want
        to filter it. If there is no calling module, use current
        frame in case there's a traceback before there is any calling module
        """
        frame = inspect.currentframe().f_back
        if frame:
            mod = frame.f_globals.get('__name__')
        else:
            mod = sys._getframe(0).f_globals.get('__name__')
        if not mod in self.modulenames:
            self.stdout.write(inline)

    def writelines(self, inline):
        """Write multiple lines"""
        for line in inline:
            self.write(line)


class Yolk(object):

    """
    Main class for yolk
    """

    def __init__(self):
        #PyPI project name with proper case
        self.project_name = ""
        #PyPI project version
        self.version = ""
        #List of all versions not hidden on PyPI
        self.all_versions = []
        self.pkg_spec = []
        self.options = None
        self.logger = logging.getLogger("yolk")

        #Squelch output from setuptools
        #Add future offenders to this list.
        shut_up = ['distutils.log']
        sys.stdout = StdOut(sys.stdout, shut_up)
        sys.stderr = StdOut(sys.stderr, shut_up)
        self.pypi = None

    def get_plugin(self, method):
        """
        Return plugin object if CLI option is activated and method exists

        @param method: name of plugin's method we're calling
        @type method: string

        @returns: list of plugins with `method`

        """
        all_plugins = []
        for entry_point in pkg_resources.iter_entry_points('yolk.plugins'):
            plugin_obj = entry_point.load()
            plugin = plugin_obj()
            plugin.configure(self.options, None)
            if plugin.enabled:
                if not hasattr(plugin, method):
                    self.logger.warn("Error: plugin has no method: %s" % method)
                    plugin = None
                else:
                    all_plugins.append(plugin)
        return all_plugins

    def set_log_level(self):
        """
        Set log level according to command-line options

        @returns: logger object
        """

        if self.options.debug:
            self.logger.setLevel(logging.DEBUG)
        elif self.options.quiet:
            self.logger.setLevel(logging.ERROR)
        else:
            self.logger.setLevel(logging.INFO)
        self.logger.addHandler(logging.StreamHandler())
        return self.logger

    def run(self):
        """
        Perform actions based on CLI options

        @returns: status code
        """
        opt_parser = setup_opt_parser()
        (self.options, remaining_args) = opt_parser.parse_args()
        logger = self.set_log_level()

        pkg_spec = validate_pypi_opts(opt_parser)
        if not pkg_spec:
            pkg_spec = remaining_args
        self.pkg_spec = pkg_spec

        if not self.options.pypi_search and (len(sys.argv) == 1 or\
                len(remaining_args) > 2):
            opt_parser.print_help()
            return 2

        #Options that depend on querying installed packages, not PyPI.
        #We find the proper case for package names if they are installed,
        #otherwise PyPI returns the correct case.
        if self.options.show_deps or self.options.show_all or \
                self.options.show_active or self.options.show_non_active  or \
                (self.options.show_updates and pkg_spec):
            want_installed = True
        else:
            want_installed = False
        #show_updates may or may not have a pkg_spec
        if not want_installed or self.options.show_updates:
            self.pypi = CheeseShop(self.options.debug)
            #XXX: We should return 2 here if we couldn't create xmlrpc server

        if pkg_spec:
            (self.project_name, self.version, self.all_versions) = \
                    self.parse_pkg_ver(want_installed)
            if want_installed and not self.project_name:
                logger.error("%s is not installed." % pkg_spec[0])
                return 1

        #I could prefix all these with 'cmd_' and the methods also
        #and then iterate over the `options` dictionary keys...
        commands = ['show_deps', 'query_metadata_pypi', 'fetch',
                'versions_available', 'show_updates', 'browse_website',
                'show_download_links', 'pypi_search', 'show_pypi_changelog',
                'show_pypi_releases', 'yolk_version', 'show_all',
                'show_active', 'show_non_active', 'show_entry_map',
                'show_entry_points']

        #Run first command it finds, and only the first command, then return
        #XXX: Check if more than one command was set in options and give error?
        for action in commands:
            if getattr(self.options, action):
                return getattr(self, action)()
        opt_parser.print_help()


    def show_active(self):
        """
        Show installed active packages
        """
        return self.show_distributions("active")

    def show_non_active(self):
        """
        Show installed non-active packages
        """
        return self.show_distributions("nonactive")

    def show_all(self):
        """
        Show all installed packages
        """
        return self.show_distributions("all")

    def show_updates(self):
        """
        Check installed packages for available updates on PyPI

        @param project_name: optional package name to check; checks every
                             installed pacakge if none specified
        @type project_name: string

        @returns: None
        """
        dists = Distributions()
        if self.project_name:
            #Check for a single package
            pkg_list = [self.project_name]
        else:
            #Check for every installed package
            pkg_list = get_pkglist()
        found = None
        for pkg in pkg_list:
            for (dist, active) in dists.get_distributions("all", pkg,
                    dists.get_highest_installed(pkg)):
                (project_name, versions) = \
                        self.pypi.query_versions_pypi(dist.project_name)
                if versions:

                    #PyPI returns them in chronological order,
                    #but who knows if its guaranteed in the API?
                    #Make sure we grab the highest version:

                    newest = get_highest_version(versions)
                    if newest != dist.version:

                        #We may have newer than what PyPI knows about

                        if pkg_resources.parse_version(dist.version) < \
                            pkg_resources.parse_version(newest):
                            found = True
                            print(" %s %s (%s)" % (project_name, dist.version,
                                    newest))
        if not found and self.project_name:
            self.logger.info("You have the latest version installed.")
        elif not found:
            self.logger.info("No newer packages found at The Cheese Shop")
        return 0


    def show_distributions(self, show):
        """
        Show list of installed activated OR non-activated packages

        @param show: type of pkgs to show (all, active or nonactive)
        @type show: string

        @returns: None or 2 if error
        """
        show_metadata = self.options.metadata

        #Search for any plugins with active CLI options with add_column() method
        plugins = self.get_plugin("add_column")

        #Some locations show false positive for 'development' packages:
        ignores = ["/UNIONFS", "/KNOPPIX.IMG"]

        #Check if we're in a workingenv
        #See http://cheeseshop.python.org/pypi/workingenv.py
        workingenv = os.environ.get('WORKING_ENV')
        if workingenv:
            ignores.append(workingenv)

        dists = Distributions()
        results = None
        for (dist, active) in dists.get_distributions(show, self.project_name,
                self.version):
            metadata = get_metadata(dist)
            for prefix in ignores:
                if dist.location.startswith(prefix):
                    dist.location = dist.location.replace(prefix, "")
            #Case-insensitve search because of Windows
            if dist.location.lower().startswith(get_python_lib().lower()):
                develop = ""
            else:
                develop = dist.location
            if metadata:
                add_column_text = ""
                for my_plugin in plugins:
                    #See if package is 'owned' by a package manager such as
                    #portage, apt, rpm etc.
                    #add_column_text += my_plugin.add_column(filename) + " "
                    add_column_text += my_plugin.add_column(dist) + " "
                self.print_metadata(metadata, develop, active, add_column_text)
            else:
                print(str(dist) + " has no metadata")
            results = True
        if not results and self.project_name:
            if self.version:
                pkg_spec = "%s==%s" % (self.project_name, self.version)
            else:
                pkg_spec = "%s" % self.project_name
            if show == "all":
                self.logger.error("There are no versions of %s installed." \
                        % pkg_spec)
            else:
                self.logger.error("There are no %s versions of %s installed." \
                        % \
                        (show, pkg_spec))
            return 2
        elif show == "all" and results and self.options.fields:
            print("Versions with '*' are non-active.")
            print("Versions with '!' are deployed in development mode.")


    def print_metadata(self, metadata, develop, active, installed_by):
        """
        Print out formatted metadata
        @param metadata: package's metadata
        @type metadata:  pkg_resources Distribution obj

        @param develop: path to pkg if its deployed in development mode
        @type develop: string

        @param active: show if package is activated or not
        @type active: boolean

        @param installed_by: Shows if pkg was installed by a package manager other
                             than setuptools
        @type installed_by: string

        @returns: None

        """
        show_metadata = self.options.metadata
        if self.options.fields:
            fields = self.options.fields.split(',')
            fields = map(str.strip, fields)
        else:
            fields = []
        version = metadata['Version']

        #When showing all packages, note which are not active:
        if active:
            if fields:
                active_status = ""
            else:
                active_status = "active"
        else:
            if fields:
                active_status = "*"
            else:
                active_status = "non-active"
        if develop:
            if fields:
                development_status = "! (%s)" % develop
            else:
                development_status = "development (%s)" % develop
        else:
            development_status = installed_by
        status = "%s %s" % (active_status, development_status)
        if fields:
            print('%s (%s)%s %s' % (metadata['Name'], version, active_status,
                                    development_status))
        else:
            # Need intelligent justification
            print(metadata['Name'].ljust(15) + " - " + version.ljust(12) + \
                " - " + status)
        if fields:
            #Only show specific fields, using case-insensitive search
            fields = map(str.lower, fields)
            for field in metadata.keys():
                if field.lower() in fields:
                    print('    %s: %s' % (field, metadata[field]))
            print()
        elif show_metadata:
            #Print all available metadata fields
            for field in metadata.keys():
                if field != 'Name' and field != 'Summary':
                    print('    %s: %s' % (field, metadata[field]))

    def show_deps(self):
        """
        Show dependencies for package(s)

        @returns: 0 - sucess  1 - No dependency info supplied
        """

        pkgs = pkg_resources.Environment()

        for pkg in pkgs[self.project_name]:
            if not self.version:
                print(pkg.project_name, pkg.version)

            i = len(pkg._dep_map.values()[0])
            if i:
                while i:
                    if not self.version or self.version and \
                            pkg.version == self.version:
                        if self.version and i == len(pkg._dep_map.values()[0]):
                            print(pkg.project_name, pkg.version)
                        print("  " + str(pkg._dep_map.values()[0][i - 1]))
                    i -= 1
            else:
                self.logger.info(\
                    "No dependency information was supplied with the package.")
                return 1
        return 0

    def show_pypi_changelog(self):
        """
        Show detailed PyPI ChangeLog for the last `hours`

        @returns: 0 = sucess or 1 if failed to retrieve from XML-RPC server

        """
        hours = self.options.show_pypi_changelog
        if not hours.isdigit():
            self.logger.error("Error: You must supply an integer.")
            return 1

        try:
            changelog = self.pypi.changelog(int(hours))
        except XMLRPCFault as err_msg:
            self.logger.error(err_msg)
            self.logger.error("ERROR: Couldn't retrieve changelog.")
            return 1

        last_pkg = ''
        for entry in changelog:
            pkg = entry[0]
            if pkg != last_pkg:
                print("%s %s\n\t%s" % (entry[0], entry[1], entry[3]))
                last_pkg = pkg
            else:
                print("\t%s" % entry[3])

        return 0

    def show_pypi_releases(self):
        """
        Show PyPI releases for the last number of `hours`

        @returns: 0 = success or 1 if failed to retrieve from XML-RPC server

        """
        try:
            hours = int(self.options.show_pypi_releases)
        except ValueError:
            self.logger.error("ERROR: You must supply an integer.")
            return 1
        try:
            latest_releases = self.pypi.updated_releases(hours)
        except XMLRPCFault as err_msg:
            self.logger.error(err_msg)
            self.logger.error("ERROR: Couldn't retrieve latest releases.")
            return 1

        for release in latest_releases:
            print("%s %s" % (release[0], release[1]))
        return 0

    def show_download_links(self):
        """
        Query PyPI for pkg download URI for a packge

        @returns: 0

        """
        #In case they specify version as 'dev' instead of using -T svn,
        #don't show three svn URI's
        if self.options.file_type == "all" and self.version == "dev":
            self.options.file_type = "svn"

        if self.options.file_type == "svn":
            version = "dev"
        else:
            if self.version:
                version = self.version
            else:
                version = self.all_versions[0]
        if self.options.file_type == "all":
            #Search for source, egg, and svn
            self.print_download_uri(version, True)
            self.print_download_uri(version, False)
            self.print_download_uri("dev", True)
        else:
            if self.options.file_type == "source":
                source = True
            else:
                source = False
            self.print_download_uri(version, source)
        return 0

    def print_download_uri(self, version, source):
        """
        @param version: version number or 'dev' for svn
        @type version: string

        @param source: download source or egg
        @type source: boolean

        @returns: None

        """

        if version == "dev":
            pkg_type = "subversion"
            source = True
        elif source:
            pkg_type = "source"
        else:
            pkg_type = "egg"

        #Use setuptools monkey-patch to grab url
        url = get_download_uri(self.project_name, version, source,
                self.options.pypi_index)
        if url:
            print("%s" % url)
        else:
            self.logger.info("No download URL found for %s" % pkg_type)

    def fetch(self):
        """
        Download a package

        @returns: 0 = success or 1 if failed download

        """
        #Default type to download
        source = True
        directory = "."

        if self.options.file_type == "svn":
            version = "dev"
            svn_uri = get_download_uri(self.project_name, \
                    "dev", True)
            if svn_uri:
                directory = self.project_name + "_svn"
                return self.fetch_svn(svn_uri, directory)
            else:
                self.logger.error(\
                    "ERROR: No subversion repository found for %s" % \
                    self.project_name)
                return 1
        elif self.options.file_type == "source":
            source = True
        elif self.options.file_type == "egg":
            source = False

        uri = get_download_uri(self.project_name, self.version, source)
        if uri:
            return self.fetch_uri(directory, uri)
        else:
            self.logger.error("No %s URI found for package: %s " % \
                    (self.options.file_type, self.project_name))
            return 1

    def fetch_uri(self, directory, uri):
        """
        Use ``urllib.urlretrieve`` to download package to file in sandbox dir.

        @param directory: directory to download to
        @type directory: string

        @param uri: uri to download
        @type uri: string

        @returns: 0 = success or 1 for failed download
        """
        filename = os.path.basename(urlparse(uri)[2])
        if os.path.exists(filename):
            self.logger.error("ERROR: File exists: " + filename)
            return 1

        try:
            downloaded_filename, headers = urlretrieve(uri, filename)
            self.logger.info("Downloaded ./" + filename)
        except IOError as err_msg:
            self.logger.error("Error downloading package %s from URL %s"  \
                    % (filename, uri))
            self.logger.error(str(err_msg))
            return 1

        if headers.gettype() in ["text/html"]:
            dfile = open(downloaded_filename)
            if re.search("404 Not Found", "".join(dfile.readlines())):
                dfile.close()
                self.logger.error("'404 Not Found' error")
                return 1
            dfile.close()
        return 0


    def fetch_svn(self, svn_uri, directory):
        """
        Fetch subversion repository

        @param svn_uri: subversion repository uri to check out
        @type svn_uri: string

        @param directory: directory to download to
        @type directory: string

        @returns: 0 = success or 1 for failed download


        """
        if not command_successful("svn --version"):
            self.logger.error("ERROR: Do you have subversion installed?")
            return 1
        if os.path.exists(directory):
            self.logger.error("ERROR: Checkout directory exists - %s" \
                    % directory)
            return 1
        try:
            os.mkdir(directory)
        except OSError as err_msg:
            self.logger.error("ERROR: " + str(err_msg))
            return 1
        cwd = os.path.realpath(os.curdir)
        os.chdir(directory)
        self.logger.info("Doing subversion checkout for %s" % svn_uri)
        status, output = run_command("/usr/bin/svn co %s" % svn_uri)
        self.logger.info(output)
        os.chdir(cwd)
        self.logger.info("subversion checkout is in directory './%s'" \
                % directory)
        return 0

    def browse_website(self, browser=None):
        """
        Launch web browser at project's homepage

        @param browser: name of web browser to use
        @type browser: string

        @returns: 0 if homepage found, 1 if no homepage found
        """
        if len(self.all_versions):
            metadata = self.pypi.release_data(self.project_name, \
                    self.all_versions[0])
            self.logger.debug("DEBUG: browser: %s" % browser)
            if metadata.has_key("home_page"):
                self.logger.info("Launching browser: %s" \
                        % metadata["home_page"])
                if browser == 'konqueror':
                    browser = webbrowser.Konqueror()
                else:
                    browser = webbrowser.get()
                    browser.open(metadata["home_page"], 2)
                return 0

        self.logger.error("No homepage URL found.")
        return 1


    def query_metadata_pypi(self):
        """
        Show pkg metadata queried from PyPI

        @returns: 0

        """
        if self.version and self.version in self.all_versions:
            metadata = self.pypi.release_data(self.project_name, self.version)
        else:
            #Give highest version
            metadata = self.pypi.release_data(self.project_name, \
                    self.all_versions[0])

        if metadata:
            for key in metadata.keys():
                if not self.options.fields or (self.options.fields and \
                        self.options.fields==key):
                    print("%s: %s" % (key, metadata[key]))
        return 0

    def versions_available(self):
        """
        Query PyPI for a particular version or all versions of a package

        @returns: 0 if version(s) found or 1 if none found
        """

        if self.version:
            spec = "%s==%s" % (self.project_name, self.version)
        else:
            spec = self.project_name

        if self.all_versions and self.version in self.all_versions:
            print_pkg_versions(self.project_name, [self.version])
        elif not self.version and self.all_versions:
            print_pkg_versions(self.project_name, self.all_versions)
        else:
            if self.version:
                self.logger.error("No pacakge found for version %s" \
                        % self.version)
            else:
                self.logger.error("No pacakge found for %s" % self.project_name)
            return 1
        return 0

    def parse_search_spec(self, spec):
        """
        Parse search args and return spec dict for PyPI
        * Owwww, my eyes!. Re-write this.

        @param spec: Cheese Shop package search spec
                     e.g.
                     name=Cheetah
                     license=ZPL
                     license=ZPL AND name=Cheetah
        @type spec: string

        @returns:  tuple with spec and operator
        """

        usage = \
            """You can search PyPI by the following:
     name
     version
     author
     author_email
     maintainer
     maintainer_email
     home_page
     license
     summary
     description
     keywords
     platform
     download_url

     e.g. yolk -S name=Cheetah
          yolk -S name=yolk AND license=PSF
          """

        if not spec:
            self.logger.error(usage)
            return (None, None)

        try:
            spec = (" ").join(spec)
            operator = 'AND'
            first = second = ""
            if " AND " in spec:
                (first, second) = spec.split('AND')
            elif " OR " in spec:
                (first, second) = spec.split('OR')
                operator = 'OR'
            else:
                first = spec
            (key1, term1) = first.split('=')
            key1 = key1.strip()
            if second:
                (key2, term2) = second.split('=')
                key2 = key2.strip()

            spec = {}
            spec[key1] = term1
            if second:
                spec[key2] = term2
        except:
            self.logger.error(usage)
            spec = operator = None
        return (spec, operator)


    def pypi_search(self):
        """
        Search PyPI by metadata keyword
        e.g. yolk -S name=yolk AND license=GPL

        @param spec: Cheese Shop search spec
        @type spec: list of strings

        spec examples:
          ["name=yolk"]
          ["license=GPL"]
          ["name=yolk", "AND", "license=GPL"]

        @returns: 0 on success or 1 if mal-formed search spec

        """
        spec = self.pkg_spec
        #Add remainging cli arguments to options.pypi_search
        search_arg = self.options.pypi_search
        spec.insert(0, search_arg.strip())

        (spec, operator) = self.parse_search_spec(spec)
        if not spec:
            return 1
        for pkg in self.pypi.search(spec, operator):
            if pkg['summary']:
                summary = pkg['summary'].encode('utf-8')
            else:
                summary = ""
            print("""%s (%s):
        %s
    """ % (pkg['name'].encode('utf-8'), pkg["version"],
                    summary))
        return 0

    def show_entry_map(self):
        """
        Show entry map for a package

        @param dist: package
        @param type: srting

        @returns: 0 for success or 1 if error
        """
        pprinter = pprint.PrettyPrinter()
        try:
            entry_map = pkg_resources.get_entry_map(self.options.show_entry_map)
            if entry_map:
                pprinter.pprint(entry_map)
        except pkg_resources.DistributionNotFound:
            self.logger.error("Distribution not found: %s" \
                    % self.options.show_entry_map)
            return 1
        return 0

    def show_entry_points(self):
        """
        Show entry points for a module

        @returns: 0 for success or 1 if error

        """
        found = False
        for entry_point in \
                pkg_resources.iter_entry_points(self.options.show_entry_points):
            found = True
            try:
                plugin = entry_point.load()
                print(plugin.__module__)
                print("   %s" % entry_point)
                if plugin.__doc__:
                    print(plugin.__doc__)
                print
            except ImportError:
                pass
        if not found:
            self.logger.error("No entry points found for %s" \
                    % self.options.show_entry_points)
            return 1
        return 0

    def yolk_version(self):
        """
        Show yolk's version

        @returns: 0
        """
        self.logger.info("yolk version %s" % VERSION)
        return 0

    def parse_pkg_ver(self, want_installed):
        """
        Return tuple with project_name and version from CLI args
        If the user gave the wrong case for the project name, this corrects it

        @param want_installed: whether package we want is installed or not
        @type want_installed: boolean

        @returns: tuple(project_name, version, all_versions)

        """
        all_versions = []

        arg_str = ("").join(self.pkg_spec)
        if "==" not in arg_str:
            #No version specified
            project_name = arg_str
            version = None
        else:
            (project_name, version) = arg_str.split("==")
            project_name = project_name.strip()
            version = version.strip()
        #Find proper case for package name
        if want_installed:
            dists = Distributions()
            project_name = dists.case_sensitive_name(project_name)
        else:
            (project_name, all_versions) = \
                    self.pypi.query_versions_pypi(project_name)

            if not len(all_versions):
                msg = "I'm afraid we have no '%s' at " % project_name
                msg += "The Cheese Shop. A little Red Leicester, perhaps?"
                self.logger.error(msg)
                sys.exit(2)
        return (project_name, version, all_versions)

def setup_opt_parser():
    """
    Setup the optparser

    @returns: opt_parser.OptionParser

    """
    #pylint: disable-msg=C0301
    #line too long

    usage = "usage: %prog [options]"
    opt_parser = optparse.OptionParser(usage=usage)

    opt_parser.add_option("--version", action='store_true', dest=
                          "yolk_version", default=False, help=
                          "Show yolk version and exit.")

    opt_parser.add_option("--debug", action='store_true', dest=
                          "debug", default=False, help=
                          "Show debugging information.")

    opt_parser.add_option("-q", "--quiet", action='store_true', dest=
                          "quiet", default=False, help=
                          "Show less output.")
    group_local = optparse.OptionGroup(opt_parser,
            "Query installed Python packages",
            "The following options show information about installed Python packages. Activated packages are normal packages on sys.path that can be imported. Non-activated packages need 'pkg_resources.require()' before they can be imported, such as packages installed with 'easy_install --multi-version'. PKG_SPEC can be either a package name or package name and version e.g. Paste==0.9")

    group_local.add_option("-l", "--list", action='store_true', dest=
                           "show_all", default=False, help=
                           "List all Python packages installed by distutils or setuptools. Use PKG_SPEC to narrow results.")

    group_local.add_option("-a", "--activated", action='store_true',
                           dest="show_active", default=False, help=
                           'List activated packages installed by distutils or ' +
                           'setuptools. Use PKG_SPEC to narrow results.')

    group_local.add_option("-n", "--non-activated", action='store_true',
                           dest="show_non_active", default=False, help=
                           'List non-activated packages installed by distutils or ' +
                           'setuptools. Use PKG_SPEC to narrow results.')

    group_local.add_option("-m", "--metadata", action='store_true', dest=
                           "metadata", default=False, help=
                           'Show all metadata for packages installed by ' +
                           'setuptools (use with -l -a or -n)')

    group_local.add_option("-f", "--fields", action="store", dest=
                           "fields", default=False, help=
                           'Show specific metadata fields. ' +
                           '(use with -m or -M)')

    group_local.add_option("-d", "--depends", action='store', dest=
                           "show_deps", metavar='PKG_SPEC',
                           help= "Show dependencies for a package installed by " +
                           "setuptools if they are available.")

    group_local.add_option("--entry-points", action='store',
                           dest="show_entry_points", default=False, help=
                           'List entry points for a module. e.g. --entry-points nose.plugins',
                            metavar="MODULE")

    group_local.add_option("--entry-map", action='store',
                           dest="show_entry_map", default=False, help=
                           'List entry map for a package. e.g. --entry-map yolk',
                           metavar="PACKAGE_NAME")
    group_pypi = optparse.OptionGroup(opt_parser,
            "PyPI (Cheese Shop) options",
            "The following options query the Python Package Index:")

    group_pypi.add_option("-C", "--changelog", action='store',
                          dest="show_pypi_changelog", metavar='HOURS',
                          default=False, help=
                          "Show detailed ChangeLog for PyPI for last n hours. ")

    group_pypi.add_option("-D", "--download-links", action='store',
                          metavar="PKG_SPEC", dest="show_download_links",
                          default=False, help=
                          "Show download URL's for package listed on PyPI. Use with -T to specify egg, source etc.")

    group_pypi.add_option("-F", "--fetch-package", action='store',
                          metavar="PKG_SPEC", dest="fetch",
                          default=False, help=
                          "Download package source or egg. You can specify a file type with -T")

    group_pypi.add_option("-H", "--browse-homepage", action='store',
                          metavar="PKG_SPEC", dest="browse_website",
                          default=False, help=
                          "Launch web browser at home page for package.")

    group_pypi.add_option("-I", "--pypi-index", action='store',
                          dest="pypi_index",
                          default=False, help=
                          "Specify PyPI mirror for package index.")

    group_pypi.add_option("-L", "--latest-releases", action='store',
                          dest="show_pypi_releases", metavar="HOURS",
                          default=False, help=
                          "Show PyPI releases for last n hours. ")

    group_pypi.add_option("-M", "--query-metadata", action='store',
                          dest="query_metadata_pypi", default=False,
                          metavar="PKG_SPEC", help=
                          "Show metadata for a package listed on PyPI. Use -f to show particular fields.")

    group_pypi.add_option("-S", "", action="store", dest="pypi_search",
                          default=False, help=
                          "Search PyPI by spec and optional AND/OR operator.",
                          metavar='SEARCH_SPEC <AND/OR SEARCH_SPEC>')

    group_pypi.add_option("-T", "--file-type", action="store", dest=
                          "file_type", default="all", help=
                          "You may specify 'source', 'egg', 'svn' or 'all' when using -D.")

    group_pypi.add_option("-U", "--show-updates", action='store_true',
                          dest="show_updates", metavar='<PKG_NAME>',
                          default=False, help=
                          "Check PyPI for updates on package(s).")

    group_pypi.add_option("-V", "--versions-available", action=
                          'store', dest="versions_available",
                          default=False, metavar='PKG_SPEC',
                          help="Show available versions for given package " +
                          "listed on PyPI.")
    opt_parser.add_option_group(group_local)
    opt_parser.add_option_group(group_pypi)
    # add opts from plugins
    all_plugins = []
    for plugcls in load_plugins(others=True):
        plug = plugcls()
        try:
            plug.add_options(opt_parser)
        except AttributeError:
            pass

    return opt_parser

def print_pkg_versions(project_name, versions):
    """
    Print list of versions available for a package

    @returns: None

    """
    for ver in versions:
        print("%s %s" % (project_name, ver))

def validate_pypi_opts(opt_parser):
    """
    Check parse options that require pkg_spec

    @returns: pkg_spec

    """

    (options, remaining_args) = opt_parser.parse_args()
    options_pkg_specs = [ options.versions_available,
            options.query_metadata_pypi,
            options.show_download_links,
            options.browse_website,
            options.fetch,
            options.show_deps,
            ]
    for pkg_spec in options_pkg_specs:
        if pkg_spec:
            return pkg_spec


def main():
    """
    Let's do it.
    """
    my_yolk = Yolk()
    my_yolk.run()

if __name__ == "__main__":
    sys.exit(main())

########NEW FILE########
__FILENAME__ = metadata
# pylint: disable-msg=W0212
# W0212 Access to a protected member _headers of a client class

"""

metadata.py
===========

Author   : Rob Cakebread <cakebread @ gmail>

License  : BSD (See COPYING)

Desc     : Return metadata for Python distribution installed by setuptools
           in a dict

           Note: The metadata uses RFC 2822-based message documents.

"""

__docformat__ = 'restructuredtext'

import email


def get_metadata(dist):
    """
    Return dictionary of metadata for given dist

    @param dist: distribution
    @type dist: pkg_resources Distribution object

    @returns: dict of metadata or None

    """
    if not dist.has_metadata('PKG-INFO'):
        return

    msg = email.message_from_string(dist.get_metadata('PKG-INFO'))
    metadata = {}
    for header in [l for l in msg._headers]:
        metadata[header[0]] = header[1]

    return metadata

########NEW FILE########
__FILENAME__ = base

# pylint: disable-msg=W0201,W0511
#XXX Attribute 'conf' defined outside __init__

"""

Base plugin class
This is not needed yet, see working plugins in examples directory.

"""


import textwrap

class Plugin(object):
    """Base class for yolk plugins. It's not necessary to subclass this
    class to create a plugin; however, all plugins must implement
    `add_options(self, parser)` and `configure(self, options,
    conf)`, and must have the attributes `enabled` and `name`.

    Plugins should not be enabled by default.

    Subclassing Plugin will give your plugin some friendly default
    behavior:

      * A --with-$name option will be added to the command line
        interface to enable the plugin. The plugin class's docstring
        will be used as the help for this option.
      * The plugin will not be enabled unless this option is selected by
        the user.    
    """
    enabled = False
    enable_opt = None
    name = None

    def __init__(self):
        if self.name is None:
            self.name = self.__class__.__name__.lower()
        if self.enable_opt is None:
            self.enable_opt = "enable_plugin_%s" % self.name
            
    def add_options(self, parser):
        """Add command-line options for this plugin.

        The base plugin class adds --with-$name by default, used to enable the
        plugin. 
        """
        parser.add_option("--with-%s" % self.name,
                          action="store_true",
                          dest=self.enable_opt,
                          help="Enable plugin %s: %s" %
                          (self.__class__.__name__, self.help())
                          )

    def configure(self, options, conf):
        """Configure the plugin and system, based on selected options.

        The base plugin class sets the plugin to enabled if the enable option
        for the plugin (self.enable_opt) is true.
        """
        self.conf = conf
        if hasattr(options, self.enable_opt):
            self.enabled = getattr(options, self.enable_opt)

    def help(self):
        """Return help for this plugin. This will be output as the help
        section of the --with-$name option that enables the plugin.
        """
        if self.__class__.__doc__:
            # doc sections are often indented; compress the spaces
            return textwrap.dedent(self.__class__.__doc__)
        return "(no help available)"



########NEW FILE########
__FILENAME__ = pypi

"""

pypi.py
=======

Desc: Library for getting information about Python packages by querying
      The CheeseShop (PYPI a.k.a. Python Package Index).


Author: Rob Cakebread <cakebread at gmail>

License  : BSD (See COPYING)

"""

__docformat__ = 'restructuredtext'

import re
import platform
if platform.python_version().startswith('2'):
    import xmlrpclib
    import cPickle
    import urllib2
else:
    import xmlrpc.client as xmlrpclib
    import pickle
    import urllib.request as urllib2
import os
import time
import logging
import urllib

from yolk.utils import get_yolk_dir


XML_RPC_SERVER = 'http://pypi.python.org/pypi'

class addinfourl(urllib2.addinfourl):
    """
    Replacement addinfourl class compatible with python-2.7's xmlrpclib

    In python-2.7, xmlrpclib expects that the response object that it receives
    has a getheader method. httplib.HTTPResponse provides this but
    urllib2.addinfourl does not. Add the necessary functions here, ported to
    use the internal data structures of addinfourl.
    """

    def getheader(self, name, default=None):
        if self.headers is None:
            raise httplib.ResponseNotReady()
        return self.headers.getheader(name, default)

    def getheaders(self):
        if self.headers is None:
            raise httplib.ResponseNotReady()
        return self.headers.items()

urllib2.addinfourl = addinfourl


class ProxyTransport(xmlrpclib.Transport):
    """
    Provides an XMl-RPC transport routing via a http proxy.

    This is done by using urllib2, which in turn uses the environment
    varable http_proxy and whatever else it is built to use (e.g. the
    windows    registry).

    NOTE: the environment variable http_proxy should be set correctly.
    See check_proxy_setting() below.

    Written from scratch but inspired by xmlrpc_urllib_transport.py
    file from http://starship.python.net/crew/jjkunce/ by jjk.

    A. Ellerton 2006-07-06
    """

    def request(self, host, handler, request_body, verbose):
        '''Send xml-rpc request using proxy'''
        #We get a traceback if we don't have this attribute:
        self.verbose = verbose
        url = 'http://' + host + handler
        request = urllib2.Request(url)
        request.add_data(request_body)
        # Note: 'Host' and 'Content-Length' are added automatically
        request.add_header('User-Agent', self.user_agent)
        request.add_header('Content-Type', 'text/xml')
        proxy_handler = urllib2.ProxyHandler()
        opener = urllib2.build_opener(proxy_handler)
        fhandle = opener.open(request)
        return(self.parse_response(fhandle))


def check_proxy_setting():
    """
    If the environmental variable 'HTTP_PROXY' is set, it will most likely be
    in one of these forms:

          proxyhost:8080
          http://proxyhost:8080

    urlllib2 requires the proxy URL to start with 'http://'
    This routine does that, and returns the transport for xmlrpc.
    """
    try:
        http_proxy = os.environ['HTTP_PROXY']
    except KeyError:
        return

    if not http_proxy.startswith('http://'):
        match = re.match('(http://)?([-_\.A-Za-z]+):(\d+)', http_proxy)
        #if not match:
        #    raise Exception('Proxy format not recognised: [%s]' % http_proxy)
        os.environ['HTTP_PROXY'] = 'http://%s:%s' % (match.group(2),
                match.group(3))
    return


class CheeseShop(object):

    """Interface to Python Package Index"""

    def __init__(self, debug=False, no_cache=False, yolk_dir=None):
        self.debug = debug
        self.no_cache = no_cache
        if yolk_dir:
            self.yolk_dir = yolk_dir
        else:
            self.yolk_dir = get_yolk_dir()
        self.xmlrpc = self.get_xmlrpc_server()
        self.pkg_cache_file = self.get_pkg_cache_file()
        self.last_sync_file = self.get_last_sync_file()
        self.pkg_list = None
        self.logger = logging.getLogger("yolk")
        self.get_cache()

    def get_cache(self):
        """
        Get a package name list from disk cache or PyPI
        """
        #This is used by external programs that import `CheeseShop` and don't
        #want a cache file written to ~/.pypi and query PyPI every time.
        if self.no_cache:
            self.pkg_list = self.list_packages()
            return

        if not os.path.exists(self.yolk_dir):
            os.mkdir(self.yolk_dir)
        if os.path.exists(self.pkg_cache_file):
            self.pkg_list = self.query_cached_package_list()
        else:
            self.logger.debug("DEBUG: Fetching package list cache from PyPi...")
            self.fetch_pkg_list()

    def get_last_sync_file(self):
        """
        Get the last time in seconds since The Epoc since the last pkg list sync
        """
        return os.path.abspath(self.yolk_dir + "/last_sync")

    def get_xmlrpc_server(self):
        """
        Returns PyPI's XML-RPC server instance
        """
        check_proxy_setting()
        if os.environ.has_key('XMLRPC_DEBUG'):
            debug = 1
        else:
            debug = 0
        try:
            return xmlrpclib.Server(XML_RPC_SERVER, transport=ProxyTransport(), verbose=debug)
        except IOError:
            self.logger("ERROR: Can't connect to XML-RPC server: %s" \
                    % XML_RPC_SERVER)

    def get_pkg_cache_file(self):
        """
        Returns filename of pkg cache
        """
        return os.path.abspath('%s/pkg_list.pkl' % self.yolk_dir)

    def query_versions_pypi(self, package_name):
        """Fetch list of available versions for a package from The CheeseShop"""
        if not package_name in self.pkg_list:
            self.logger.debug("Package %s not in cache, querying PyPI..." \
                    % package_name)
            self.fetch_pkg_list()
        #I have to set version=[] for edge cases like "Magic file extensions"
        #but I'm not sure why this happens. It's included with Python or
        #because it has a space in it's name?
        versions = []
        for pypi_pkg in self.pkg_list:
            if pypi_pkg.lower() == package_name.lower():
                if self.debug:
                    self.logger.debug("DEBUG: %s" % package_name)
                versions = self.package_releases(pypi_pkg)
                package_name = pypi_pkg
                break
        return (package_name, versions)

    def query_cached_package_list(self):
        """Return list of pickled package names from PYPI"""
        if self.debug:
            self.logger.debug("DEBUG: reading pickled cache file")
        return cPickle.load(open(self.pkg_cache_file, "r"))

    def fetch_pkg_list(self):
        """Fetch and cache master list of package names from PYPI"""
        self.logger.debug("DEBUG: Fetching package name list from PyPI")
        package_list = self.list_packages()
        cPickle.dump(package_list, open(self.pkg_cache_file, "w"))
        self.pkg_list = package_list

    def search(self, spec, operator):
        '''Query PYPI via XMLRPC interface using search spec'''
        return self.xmlrpc.search(spec, operator.lower())

    def changelog(self, hours):
        '''Query PYPI via XMLRPC interface using search spec'''
        return self.xmlrpc.changelog(get_seconds(hours))

    def updated_releases(self, hours):
        '''Query PYPI via XMLRPC interface using search spec'''
        return self.xmlrpc.updated_releases(get_seconds(hours))

    def list_packages(self):
        """Query PYPI via XMLRPC interface for a a list of all package names"""
        return self.xmlrpc.list_packages()

    def release_urls(self, package_name, version):
        """Query PYPI via XMLRPC interface for a pkg's available versions"""

        return self.xmlrpc.release_urls(package_name, version)

    def release_data(self, package_name, version):
        """Query PYPI via XMLRPC interface for a pkg's metadata"""
        try:
            return self.xmlrpc.release_data(package_name, version)
        except xmlrpclib.Fault:
            #XXX Raises xmlrpclib.Fault if you give non-existant version
            #Could this be server bug?
            return

    def package_releases(self, package_name):
        """Query PYPI via XMLRPC interface for a pkg's available versions"""
        if self.debug:
            self.logger.debug("DEBUG: querying PyPI for versions of " \
                    + package_name)
        return self.xmlrpc.package_releases(package_name)

    def get_download_urls(self, package_name, version="", pkg_type="all"):
        """Query PyPI for pkg download URI for a packge"""

        if version:
            versions = [version]
        else:

            #If they don't specify version, show em all.

            (package_name, versions) = self.query_versions_pypi(package_name)

        all_urls = []
        for ver in versions:
            metadata = self.release_data(package_name, ver)
            for urls in self.release_urls(package_name, ver):
                if pkg_type == "source" and urls['packagetype'] == "sdist":
                    all_urls.append(urls['url'])
                elif pkg_type == "egg" and \
                        urls['packagetype'].startswith("bdist"):
                    all_urls.append(urls['url'])
                elif pkg_type == "all":
                    #All
                    all_urls.append(urls['url'])

            #Try the package's metadata directly in case there's nothing
            #returned by XML-RPC's release_urls()
            if metadata and metadata.has_key('download_url') and \
                        metadata['download_url'] != "UNKNOWN" and \
                        metadata['download_url'] != None:
                if metadata['download_url'] not in all_urls:
                    if pkg_type != "all":
                        url = filter_url(pkg_type, metadata['download_url'])
                        if url:
                            all_urls.append(url)
        return all_urls

def filter_url(pkg_type, url):
    """
    Returns URL of specified file type
    'source', 'egg', or 'all'
    """
    bad_stuff = ["?modtime", "#md5="]
    for junk in bad_stuff:
        if junk in url:
            url = url.split(junk)[0]
            break

    #pkg_spec==dev (svn)
    if url.endswith("-dev"):
        url = url.split("#egg=")[0]

    if pkg_type == "all":
        return url

    elif pkg_type == "source":
        valid_source_types = [".tgz", ".tar.gz", ".zip", ".tbz2", ".tar.bz2"]
        for extension in valid_source_types:
            if url.lower().endswith(extension):
                return url

    elif pkg_type == "egg":
        if url.lower().endswith(".egg"):
            return url

def get_seconds(hours):
    """
    Get number of seconds since epoch from now minus `hours`

    @param hours: Number of `hours` back in time we are checking
    @type hours: int

    Return integer for number of seconds for now minus hours

    """
    return int(time.time() - (60 * 60) * hours)

########NEW FILE########
__FILENAME__ = utils


"""

utils.py
===========

Misc funcitions
---------------

run_command borrowed from Cheesecake - See CREDITS.
"""

__docformat__ = 'restructuredtext'

import os
import signal
import time
from subprocess import Popen, STDOUT



def get_yolk_dir():
    """
    Return location we store config files and data
    """
    return os.path.abspath("%s/.yolk" % os.path.expanduser("~"))


def run_command(cmd, env=None, max_timeout=None):
    """
    Run command and return its return status code and its output

    """
    arglist = cmd.split()

    output = os.tmpfile()
    try:
        pipe = Popen(arglist, stdout=output, stderr=STDOUT, env=env)
    except Exception as errmsg:
        return 1, errmsg

    # Wait only max_timeout seconds.
    if max_timeout:
        start = time.time()
        while pipe.poll() is None:
            time.sleep(0.1)
            if time.time() - start > max_timeout:
                os.kill(pipe.pid, signal.SIGINT)
                pipe.wait()
                return 1, "Time exceeded"

    pipe.wait()
    output.seek(0)
    return pipe.returncode, output.read()

def command_successful(cmd):
    """
    Returns True if command exited normally, False otherwise.

    """
    return_code, _output = run_command(cmd)
    return return_code == 0

########NEW FILE########
__FILENAME__ = yolklib

'''

yolklib.py
==========

Desc: Library for getting information about Python packages installed by
      setuptools, package metadata, package dependencies, and querying
      The CheeseShop (PYPI) for Python package release information.


Author: Rob Cakebread <cakebread @ gmail>

License  : BSD (See COPYING)

'''

__docformat__ = 'restructuredtext'

import pkg_resources



class Distributions(object):

    """Helper class for pkg_resources"""

    def __init__(self):
        """init"""

        self.environment = pkg_resources.Environment()
        self.working_set = pkg_resources.WorkingSet()

    def query_activated(self, dist):
        """
        Return True if distribution is active
        Return Falsee if distribution is non-active

        @param dist: pkg_resources Distribution object

        @returns: True or False

        """
        if dist in self.working_set:
            return True
        else:
            return False

    def get_distributions(self, show, pkg_name="", version=""):
        """
        Yield installed packages

        @param show: Type of package(s) to show; active, non-active or all
        @type show: string: "active", "non-active", "all"

        @param pkg_name: PyPI project name
        @type pkg_name: string

        @param version: project's PyPI version
        @type version: string

        @returns: yields tuples of distribution and True or False depending
                  on active state. e.g. (dist, True)

        """
        #pylint: disable-msg=W0612
        #'name' is a placeholder for the sorted list
        for name, dist in self.get_alpha(show, pkg_name, version):
            ver = dist.version
            for package in self.environment[dist.project_name]:
                if ver == package.version:
                    if show == "nonactive" and dist not in self.working_set:
                        yield (dist, self.query_activated(dist))
                    elif show == "active" and dist in self.working_set:
                        yield (dist, self.query_activated(dist))
                    elif show == "all":
                        yield (dist, self.query_activated(dist))

    def get_alpha(self, show, pkg_name="", version=""):
        """
        Return list of alphabetized packages

        @param pkg_name: PyPI project name
        @type pkg_name: string

        @param version: project's PyPI version
        @type version: string

        @returns: Alphabetized list of tuples. Each tuple contains
                  a string and a pkg_resources Distribution object.
                  The string is the project name + version.

        """
        alpha_list = []
        for dist in self.get_packages(show):
            if pkg_name and dist.project_name != pkg_name:
                #Only checking for a single package name
                pass
            elif version and dist.version != version:
                #Only checking for a single version of a package
                pass
            else:
                alpha_list.append((dist.project_name + dist.version, dist))
        alpha_list.sort()
        return alpha_list

    def get_packages(self, show):
        """
        Return list of Distributions filtered by active status or all

        @param show: Type of package(s) to show; active, non-active or all
        @type show: string: "active", "non-active", "all"

        @returns: list of pkg_resources Distribution objects
        """


        if show == 'nonactive' or show == "all":
            all_packages = []
            for package in self.environment:
                #There may be multiple versions of same packages
                for i in range(len(self.environment[package])):
                    if self.environment[package][i]:
                        all_packages.append(self.environment[package][i])
            return all_packages
        else:
            # Only activated packages
            return self.working_set

    def case_sensitive_name(self, package_name):
        """
        Return case-sensitive package name given any-case package name

        @param project_name: PyPI project name
        @type project_name: string

        """
        if len(self.environment[package_name]):
            return self.environment[package_name][0].project_name

    def get_highest_installed(self, project_name):
        """
        Return highest version of installed package

        @param project_name: PyPI project name
        @type project_name: string

        @return: string of highest installed version

        """
        return self.environment[project_name][0].version


def get_highest_version(versions):
    """
    Returns highest available version for a package in a list of versions
    Uses pkg_resources to parse the versions

    @param versions: List of PyPI package versions
    @type versions: List of strings

    @returns: string of a PyPI package version


    """
    sorted_versions = []
    for ver in versions:
        sorted_versions.append((pkg_resources.parse_version(ver), ver))

    sorted_versions = sorted(sorted_versions)
    sorted_versions.reverse()
    return sorted_versions[0][1]


########NEW FILE########
