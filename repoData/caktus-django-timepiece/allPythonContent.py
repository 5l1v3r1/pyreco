__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# django-timepiece documentation build configuration file, created by
# sphinx-quickstart on Mon Jun 11 11:19:04 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'django-timepiece'
copyright = u'2013,  '

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = __import__('timepiece').__version__
# The full version, including alpha/beta/rc tags.
release = __import__('timepiece').__version__

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'django-timepiecedoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'django-timepiece.tex', u'django-timepiece Documentation',
   u' ', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'django-timepiece', u'django-timepiece Documentation',
     [u' '], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'django-timepiece', u'django-timepiece Documentation',
   u' ', 'django-timepiece', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
import os
import sys

if __name__ == "__main__":
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "example_project.settings.local")

    from django.core.management import execute_from_command_line

    execute_from_command_line(sys.argv)

########NEW FILE########
__FILENAME__ = base
# Django settings for example_project project.

from os import path


PROJECT_PATH = path.abspath(path.join(path.dirname(__file__), path.pardir))

ADMINS = (
    # ('Your Name', 'your_email@example.com'),
)

MANAGERS = ADMINS

# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# On Unix systems, a value of None will cause Django to use the same
# timezone as the operating system.
# If running in a Windows environment this must be set to the same as your
# system time zone.
TIME_ZONE = 'America/New_York'

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'en-us'

SITE_ID = 1

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

# If you set this to False, Django will not format dates, numbers and
# calendars according to the current locale
USE_L10N = True

# If you set this to False, Django will not use timezone-aware datetimes.
# django-timepiece does not currently support timezones.
USE_TZ = False

# Absolute filesystem path to the directory that will hold user-uploaded files.
# Example: '/home/media/media.lawrence.com/media/'
MEDIA_ROOT = ''

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash.
# Examples: 'http://media.lawrence.com/media/', 'http://example.com/media/'
MEDIA_URL = ''

# Absolute path to the directory static files should be collected to.
# Don't put anything in this directory yourself; store your static files
# in apps' "static/" subdirectories and in STATICFILES_DIRS.
# Example: "/home/media/media.lawrence.com/static/"
STATIC_ROOT = ''

# URL prefix for static files.
# Example: "http://media.lawrence.com/static/"
STATIC_URL = '/static/'

# Additional locations of static files
STATICFILES_DIRS = ()

# List of finder classes that know how to find static files in
# various locations.
STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
#    'django.contrib.staticfiles.finders.DefaultStorageFinder',
    'compressor.finders.CompressorFinder',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'pagination.middleware.PaginationMiddleware',
    # Uncomment the next line for simple clickjacking protection:
    # 'django.middleware.clickjacking.XFrameOptionsMiddleware',
)

# Make this unique, and don't share it with anybody.
SECRET_KEY = 'oap0ahyb%_iitq1un(4j!#v81_%6jl$wefeh@$^=metg6w8pr^'

ROOT_URLCONF = 'example_project.urls'

TEMPLATE_CONTEXT_PROCESSORS = (
    'django.contrib.auth.context_processors.auth',
    'django.core.context_processors.debug',
    'django.core.context_processors.i18n',
    'django.core.context_processors.media',
    'django.core.context_processors.static',
    'django.contrib.messages.context_processors.messages',
    'django.core.context_processors.request',
    'timepiece.context_processors.quick_search',
    'timepiece.context_processors.quick_clock_in',
    'timepiece.context_processors.extra_settings',
)

TEMPLATE_DIRS = (
    '%s/templates' % PROJECT_PATH,
)

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
#     'django.template.loaders.eggs.Loader',
)

# Python dotted path to the WSGI application used by Django's runserver.
WSGI_APPLICATION = 'example_project.wsgi.application'


INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'django.contrib.admin',

    # Timepiece apps must be listed before third-party apps in order
    # for template overrides to work.
    'timepiece',
    'timepiece.contracts',
    'timepiece.crm',
    'timepiece.entries',
    'timepiece.reports',

    'pagination',
    'compressor',
    'bootstrap_toolkit',
    'selectable',
)

# A sample logging configuration. The only tangible logging
# performed by this configuration is to send an email to
# the site admins on every HTTP 500 error when DEBUG=False.
# See http://docs.djangoproject.com/en/dev/topics/logging for
# more details on how to customize your logging configuration.
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'filters': {
        'require_debug_false': {
            '()': 'django.utils.log.RequireDebugFalse'
        }
    },
    'handlers': {
        'mail_admins': {
            'level': 'ERROR',
            'filters': ['require_debug_false'],
            'class': 'django.utils.log.AdminEmailHandler'
        }
    },
    'loggers': {
        'django.request': {
            'handlers': ['mail_admins'],
            'level': 'ERROR',
            'propagate': True,
        },
    }
}

# compressor settings
COMPRESS_PRECOMPILERS = (
    ('text/less', 'lessc {infile} {outfile}'),
)
COMPRESS_ROOT = '%s/static/' % PROJECT_PATH

# django-timepiece settings
TIMEPIECE_DEFAULT_LOCATION_SLUG = None
TIMEPIECE_PAID_LEAVE_PROJECTS = {}

########NEW FILE########
__FILENAME__ = urls
try:
    from django.conf.urls import patterns, include, url
except ImportError:
    from django.conf.urls.defaults import patterns, include, url

from django.contrib import admin


admin.autodiscover()

urlpatterns = patterns('',
    url(r'^admin/', include(admin.site.urls)),
    url(r'^selectable/', include('selectable.urls')),
    url(r'', include('timepiece.urls')),

    # authentication views
    url(r'^accounts/login/$', 'django.contrib.auth.views.login',
        name='auth_login'),
    url(r'^accounts/logout/$', 'django.contrib.auth.views.logout_then_login',
        name='auth_logout'),
    url(r'^accounts/password-change/$',
        'django.contrib.auth.views.password_change',
        name='change_password'),
    url(r'^accounts/password-change/done/$',
        'django.contrib.auth.views.password_change_done'),
    url(r'^accounts/password-reset/$',
        'django.contrib.auth.views.password_reset',
        name='reset_password'),
    url(r'^accounts/password-reset/done/$',
        'django.contrib.auth.views.password_reset_done'),
    url(r'^accounts/reset/(?P<uidb36>[0-9A-Za-z]+)-(?P<token>.+)/$',
        'django.contrib.auth.views.password_reset_confirm'),
    url(r'^accounts/reset/done/$',
        'django.contrib.auth.views.password_reset_complete'),
)

########NEW FILE########
__FILENAME__ = wsgi
"""
WSGI config for example_project project.

This module contains the WSGI application used by Django's development server
and any production WSGI deployments. It should expose a module-level variable
named ``application``. Django's ``runserver`` and ``runfcgi`` commands discover
this application via the ``WSGI_APPLICATION`` setting.

Usually you will have the standard Django WSGI application here, but it also
might make sense to replace the whole Django WSGI application with a custom one
that later delegates to the Django one. For example, you could introduce WSGI
middleware here, or combine a Django application with an application of another
framework.

"""
import os

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "example_project.settings.local")

# This application object is used by any WSGI server configured to use this
# file. This includes Django's development server, if the WSGI_APPLICATION
# setting points here.
from django.core.wsgi import get_wsgi_application
application = get_wsgi_application()

# Apply WSGI middleware here.
# from helloworld.wsgi import HelloWorldApplication
# application = HelloWorldApplication(application)

########NEW FILE########
__FILENAME__ = run_tests
#!/usr/bin/env python
import os
import sys
import optparse

from django.conf import settings


parser = optparse.OptionParser()
opts, args = parser.parse_args()

if not settings.configured:
    directory = os.path.abspath('%s' % os.path.dirname(__file__))
    jenkins = ()
    db_name = 'test_django_timepiece'
    if 'jenkins' in args:
        jenkins = ('django_jenkins',)
        db_name = 'timepiece_%s' % os.environ.get('TESTENV', db_name)

    settings.configure(
        DATABASES={
            'default': {
                'ENGINE': 'django.db.backends.postgresql_psycopg2',
                'NAME': 'django_timepiece',
                'TEST_NAME': db_name,
            }
        },
        INSTALLED_APPS=(
            'django.contrib.auth',
            'django.contrib.contenttypes',
            'django.contrib.sessions',
            'django.contrib.messages',
            'django.contrib.markup',
            'django.contrib.sites',
            'bootstrap_toolkit',
            'compressor',
            'pagination',
            'selectable',
            'timepiece',
            'timepiece.contracts',
            'timepiece.crm',
            'timepiece.entries',
            'timepiece.reports',
        ) + jenkins,
        MIDDLEWARE_CLASSES=(
            'django.middleware.common.CommonMiddleware',
            'django.contrib.sessions.middleware.SessionMiddleware',
            'django.middleware.csrf.CsrfViewMiddleware',
            'django.contrib.auth.middleware.AuthenticationMiddleware',
            'django.contrib.messages.middleware.MessageMiddleware',
            'pagination.middleware.PaginationMiddleware',
        ),
        ROOT_URLCONF='example_project.urls',
        SITE_ID=1,
        STATIC_URL='%s/timepiece/static/' % directory,
        TEMPLATE_CONTEXT_PROCESSORS=(
            'django.contrib.auth.context_processors.auth',
            'django.core.context_processors.debug',
            'django.core.context_processors.i18n',
            'django.core.context_processors.media',
            'django.core.context_processors.static',
            'django.contrib.messages.context_processors.messages',
            'django.core.context_processors.request',
            'timepiece.context_processors.quick_search',
            'timepiece.context_processors.quick_clock_in',
            'timepiece.context_processors.extra_settings',
        ),
        TEMPLATE_DIRS=(
            '%s/example_project/templates' % directory,
        ),

        # In tests, compressor has a habit of choking on failing tests & masking the real error.
        COMPRESS_ENABLED=False,

        # jenkins settings.
        PROJECT_APPS=('timepiece',),
        JENKINS_TASKS=(
            'django_jenkins.tasks.with_coverage',
            'django_jenkins.tasks.django_tests',
            'django_jenkins.tasks.run_pep8',
        ),

        # Increase speed in 1.4.
        PASSWORD_HASHERS=('django.contrib.auth.hashers.MD5PasswordHasher',),
    )


def run_django_tests():
    from django.test.utils import get_runner
    TestRunner = get_runner(settings)
    test_runner = TestRunner(verbosity=1, interactive=True, failfast=False)
    apps = ['timepiece', 'contracts', 'crm', 'entries', 'reports']
    failures = test_runner.run_tests(args or apps)
    sys.exit(failures)


if __name__ == '__main__':
    run_django_tests()

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from django.contrib.auth.models import Permission
from django.contrib.contenttypes.models import ContentType


class PermissionAdmin(admin.ModelAdmin):
    list_display = ['__unicode__', 'codename']
    list_filter = ['content_type__app_label']


class ContentTypeAdmin(admin.ModelAdmin):
    list_display = ['id', 'app_label', 'model']
    list_filter = ['app_label']


admin.site.register(Permission, PermissionAdmin)
admin.site.register(ContentType, ContentTypeAdmin)

########NEW FILE########
__FILENAME__ = context_processors
from django.db.models import Q
from django.conf import settings

from timepiece import utils
from timepiece.crm.forms import QuickSearchForm

from timepiece.crm.models import Project
from timepiece.entries.models import Entry


def quick_search(request):
    return {
        'quick_search_form': QuickSearchForm(),
    }


def quick_clock_in(request):
    user = request.user
    work_projects = []
    leave_projects = []

    if user.is_authenticated() and user.is_active:
        # Display all active paid leave projects that the user is assigned to.
        leave_ids = utils.get_setting('TIMEPIECE_PAID_LEAVE_PROJECTS').values()
        lq = Q(users=user) & Q(id__in=leave_ids)
        leave_projects = Project.trackable.filter(lq).order_by('name')

        # Get all projects this user has clocked in to.
        entries = Entry.objects.filter(user=user)
        project_ids = list(entries.values_list('project', flat=True))

        # Narrow to projects which can still be clocked in to.
        pq = Q(id__in=project_ids)
        valid_projects = Project.trackable.filter(pq).exclude(id__in=leave_ids)
        valid_ids = list(valid_projects.values_list('id', flat=True))

        # Display the 10 projects this user most recently clocked into.
        work_ids = []
        for i in project_ids:
            if len(work_ids) > 10:
                break
            if i in valid_ids and i not in work_ids:
                work_ids.append(i)
        work_projects = [valid_projects.get(pk=i) for i in work_ids]

    return {
        'leave_projects': leave_projects,
        'work_projects': work_projects,
    }


def extra_settings(request):
    return {
        'COMPRESS_ENABLED': settings.COMPRESS_ENABLED,
    }

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

from timepiece.contracts.models import ProjectContract, ContractHour,\
        ContractAssignment, HourGroup


class ContractAssignmentInline(admin.TabularInline):
    model = ContractAssignment
    raw_id_fields = ('user',)

    def queryset(self, request):
        qs = super(ContractAssignmentInline, self).queryset(request)
        return qs.select_related()


class ContractHourInline(admin.TabularInline):
    model = ContractHour


class ProjectContractAdmin(admin.ModelAdmin):
    model = ProjectContract
    list_display = ('name', 'start_date', 'end_date', 'status',
                    'contracted_hours', 'pending_hours',
                    'hours_assigned', 'hours_unassigned',
                    'hours_worked',
                    'type')
    inlines = (ContractAssignmentInline, ContractHourInline)
    list_filter = ('status', 'type')
    filter_horizontal = ('projects',)
    list_per_page = 20
    search_fields = ('name', 'projects__name', 'projects__business__name')

    def hours_unassigned(self, obj):
        return obj.contracted_hours() - obj.hours_assigned


class HourGroupAdmin(admin.ModelAdmin):
    model = HourGroup
    list_display = ('name',)
    list_filter = ('activities',)
    ordering = ('order', 'name')
    filter_horizontal = ('activities',)


admin.site.register(ProjectContract, ProjectContractAdmin)
admin.site.register(HourGroup, HourGroupAdmin)
admin.site.register(ContractHour)

########NEW FILE########
__FILENAME__ = forms
from dateutil.relativedelta import relativedelta

from django import forms

from timepiece import utils
from timepiece.contracts.models import EntryGroup
from timepiece.crm.models import Attribute
from timepiece.forms import DateForm


class InvoiceForm(forms.ModelForm):

    class Meta:
        model = EntryGroup
        fields = ('status', 'number', 'comments')

    def save(self, commit=True):
        instance = super(InvoiceForm, self).save(commit=False)
        instance.project = self.initial['project']
        instance.user = self.initial['user']
        from_date = self.initial['from_date']
        to_date = self.initial['to_date']
        instance.start = from_date
        instance.end = to_date
        instance.save()
        return instance


class OutstandingHoursFilterForm(DateForm):
    statuses = forms.ModelMultipleChoiceField(queryset=Attribute.objects.none(),
            required=False, widget=forms.CheckboxSelectMultiple())

    def __init__(self, *args, **kwargs):
        super(OutstandingHoursFilterForm, self).__init__(*args, **kwargs)

        # Check all statuses by default.
        statuses = Attribute.statuses.all()
        self.fields['statuses'].queryset = statuses
        self.fields['statuses'].initial = statuses

        month_start = utils.get_month_start().date()
        self.fields['to_date'].required = True
        self.fields['to_date'].initial = month_start - relativedelta(days=1)
        self.fields['from_date'].initial = None

    def get_from_date(self):
        if self.is_valid():
            return self.cleaned_data['from_date']
        return self.fields['from_date'].initial

    def get_to_date(self):
        if self.is_valid():
            return self.cleaned_data['to_date']
        return self.fields['to_date'].initial

    def get_statuses(self):
        if self.is_valid():
            return self.cleaned_data['statuses']
        return self.fields['statuses'].initial

    def get_form_data(self):
        return {
            'to_date': self.get_to_date(),
            'from_date': self.get_from_date(),
            'statuses': self.get_statuses()
        }

########NEW FILE########
__FILENAME__ = 0001_initial
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding model 'ProjectContract'
        db.create_table('timepiece_projectcontract', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('start_date', self.gf('django.db.models.fields.DateField')()),
            ('end_date', self.gf('django.db.models.fields.DateField')()),
            ('status', self.gf('django.db.models.fields.CharField')(default='upcoming', max_length=32)),
            ('type', self.gf('django.db.models.fields.IntegerField')()),
        ))
        db.send_create_signal('contracts', ['ProjectContract'])

        # Adding M2M table for field projects on 'ProjectContract'
        db.create_table('timepiece_projectcontract_projects', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('projectcontract', models.ForeignKey(orm['contracts.projectcontract'], null=False)),
            ('project', models.ForeignKey(orm['crm.project'], null=False))
        ))
        db.create_unique('timepiece_projectcontract_projects', ['projectcontract_id', 'project_id'])

        # Adding model 'ContractHour'
        db.create_table('timepiece_contracthour', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('hours', self.gf('django.db.models.fields.DecimalField')(default=0, max_digits=8, decimal_places=2)),
            ('contract', self.gf('django.db.models.fields.related.ForeignKey')(related_name='contract_hours', to=orm['contracts.ProjectContract'])),
            ('date_requested', self.gf('django.db.models.fields.DateField')()),
            ('date_approved', self.gf('django.db.models.fields.DateField')(null=True, blank=True)),
            ('status', self.gf('django.db.models.fields.IntegerField')(default=1)),
            ('notes', self.gf('django.db.models.fields.TextField')(blank=True)),
        ))
        db.send_create_signal('contracts', ['ContractHour'])

        # Adding model 'ContractAssignment'
        db.create_table('timepiece_contractassignment', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('contract', self.gf('django.db.models.fields.related.ForeignKey')(related_name='assignments', to=orm['contracts.ProjectContract'])),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(related_name='assignments', to=orm['auth.User'])),
            ('start_date', self.gf('django.db.models.fields.DateField')()),
            ('end_date', self.gf('django.db.models.fields.DateField')()),
            ('num_hours', self.gf('django.db.models.fields.DecimalField')(default=0, max_digits=8, decimal_places=2)),
            ('min_hours_per_week', self.gf('django.db.models.fields.IntegerField')(default=0)),
        ))
        db.send_create_signal('contracts', ['ContractAssignment'])

        # Adding unique constraint on 'ContractAssignment', fields ['contract', 'user']
        db.create_unique('timepiece_contractassignment', ['contract_id', 'user_id'])

        # Adding model 'HourGroup'
        db.create_table('contracts_hourgroup', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.CharField')(unique=True, max_length=255)),
            ('order', self.gf('django.db.models.fields.PositiveIntegerField')(unique=True, null=True, blank=True)),
        ))
        db.send_create_signal('contracts', ['HourGroup'])

        # Adding M2M table for field activities on 'HourGroup'
        db.create_table('contracts_hourgroup_activities', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('hourgroup', models.ForeignKey(orm['contracts.hourgroup'], null=False)),
            ('activity', models.ForeignKey(orm['entries.activity'], null=False))
        ))
        db.create_unique('contracts_hourgroup_activities', ['hourgroup_id', 'activity_id'])

        # Adding model 'EntryGroup'
        db.create_table('contracts_entrygroup', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(related_name='entry_group', to=orm['auth.User'])),
            ('project', self.gf('django.db.models.fields.related.ForeignKey')(related_name='entry_group', to=orm['crm.Project'])),
            ('status', self.gf('django.db.models.fields.CharField')(default='invoiced', max_length=24)),
            ('number', self.gf('django.db.models.fields.CharField')(max_length=50, null=True, blank=True)),
            ('comments', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
            ('created', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('modified', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
            ('start', self.gf('django.db.models.fields.DateField')(null=True, blank=True)),
            ('end', self.gf('django.db.models.fields.DateField')()),
        ))
        db.send_create_signal('contracts', ['EntryGroup'])


    def backwards(self, orm):
        # Removing unique constraint on 'ContractAssignment', fields ['contract', 'user']
        db.delete_unique('timepiece_contractassignment', ['contract_id', 'user_id'])

        # Deleting model 'ProjectContract'
        db.delete_table('timepiece_projectcontract')

        # Removing M2M table for field projects on 'ProjectContract'
        db.delete_table('timepiece_projectcontract_projects')

        # Deleting model 'ContractHour'
        db.delete_table('timepiece_contracthour')

        # Deleting model 'ContractAssignment'
        db.delete_table('timepiece_contractassignment')

        # Deleting model 'HourGroup'
        db.delete_table('contracts_hourgroup')

        # Removing M2M table for field activities on 'HourGroup'
        db.delete_table('contracts_hourgroup_activities')

        # Deleting model 'EntryGroup'
        db.delete_table('contracts_entrygroup')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'contracts.contractassignment': {
            'Meta': {'unique_together': "(('contract', 'user'),)", 'object_name': 'ContractAssignment', 'db_table': "'timepiece_contractassignment'"},
            'contract': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'assignments'", 'to': "orm['contracts.ProjectContract']"}),
            'end_date': ('django.db.models.fields.DateField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'min_hours_per_week': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'num_hours': ('django.db.models.fields.DecimalField', [], {'default': '0', 'max_digits': '8', 'decimal_places': '2'}),
            'start_date': ('django.db.models.fields.DateField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'assignments'", 'to': "orm['auth.User']"})
        },
        'contracts.contracthour': {
            'Meta': {'object_name': 'ContractHour', 'db_table': "'timepiece_contracthour'"},
            'contract': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contract_hours'", 'to': "orm['contracts.ProjectContract']"}),
            'date_approved': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date_requested': ('django.db.models.fields.DateField', [], {}),
            'hours': ('django.db.models.fields.DecimalField', [], {'default': '0', 'max_digits': '8', 'decimal_places': '2'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'notes': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'status': ('django.db.models.fields.IntegerField', [], {'default': '1'})
        },
        'contracts.entrygroup': {
            'Meta': {'object_name': 'EntryGroup'},
            'comments': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'end': ('django.db.models.fields.DateField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'modified': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'number': ('django.db.models.fields.CharField', [], {'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'project': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'entry_group'", 'to': "orm['crm.Project']"}),
            'start': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'invoiced'", 'max_length': '24'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'entry_group'", 'to': "orm['auth.User']"})
        },
        'contracts.hourgroup': {
            'Meta': {'object_name': 'HourGroup'},
            'activities': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'activity_bundle'", 'symmetrical': 'False', 'to': "orm['entries.Activity']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'order': ('django.db.models.fields.PositiveIntegerField', [], {'unique': 'True', 'null': 'True', 'blank': 'True'})
        },
        'contracts.projectcontract': {
            'Meta': {'ordering': "('-end_date',)", 'object_name': 'ProjectContract', 'db_table': "'timepiece_projectcontract'"},
            'end_date': ('django.db.models.fields.DateField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'projects': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'contracts'", 'symmetrical': 'False', 'to': "orm['crm.Project']"}),
            'start_date': ('django.db.models.fields.DateField', [], {}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'upcoming'", 'max_length': '32'}),
            'type': ('django.db.models.fields.IntegerField', [], {})
        },
        'crm.attribute': {
            'Meta': {'ordering': "('sort_order',)", 'unique_together': "(('type', 'label'),)", 'object_name': 'Attribute', 'db_table': "'timepiece_attribute'"},
            'billable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'enable_timetracking': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'label': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'sort_order': ('django.db.models.fields.SmallIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'type': ('django.db.models.fields.CharField', [], {'max_length': '32'})
        },
        'crm.business': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Business', 'db_table': "'timepiece_business'"},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'external_id': ('django.db.models.fields.CharField', [], {'max_length': '32', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'notes': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'short_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'})
        },
        'crm.project': {
            'Meta': {'ordering': "('name', 'status', 'type')", 'object_name': 'Project', 'db_table': "'timepiece_project'"},
            'activity_group': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'activity_group'", 'null': 'True', 'to': "orm['entries.ActivityGroup']"}),
            'business': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'new_business_projects'", 'to': "orm['crm.Business']"}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'point_person': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'status': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'projects_with_status'", 'to': "orm['crm.Attribute']"}),
            'tracker_url': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '255', 'blank': 'True'}),
            'type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'projects_with_type'", 'to': "orm['crm.Attribute']"}),
            'users': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'user_projects'", 'symmetrical': 'False', 'through': "orm['crm.ProjectRelationship']", 'to': "orm['auth.User']"})
        },
        'crm.projectrelationship': {
            'Meta': {'unique_together': "(('user', 'project'),)", 'object_name': 'ProjectRelationship', 'db_table': "'timepiece_projectrelationship'"},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'project': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'project_relationships'", 'to': "orm['crm.Project']"}),
            'types': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'project_relationships'", 'blank': 'True', 'to': "orm['crm.RelationshipType']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'project_relationships'", 'to': "orm['auth.User']"})
        },
        'crm.relationshiptype': {
            'Meta': {'object_name': 'RelationshipType', 'db_table': "'timepiece_relationshiptype'"},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255'})
        },
        'entries.activity': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Activity', 'db_table': "'timepiece_activity'"},
            'billable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'code': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '5'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'entries.activitygroup': {
            'Meta': {'object_name': 'ActivityGroup', 'db_table': "'timepiece_activitygroup'"},
            'activities': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'activity_group'", 'symmetrical': 'False', 'to': "orm['entries.Activity']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        }
    }

    complete_apps = ['contracts']
########NEW FILE########
__FILENAME__ = models
import datetime
from dateutil.relativedelta import relativedelta

from django.contrib.auth.models import User
from django.contrib.sites.models import Site
from django.core.exceptions import ValidationError
from django.core.mail import send_mail
from django.core.urlresolvers import reverse
from django.db import models
from django.db.models import Sum
from django.template import Context
from django.template.loader import get_template

from timepiece import utils
from timepiece.entries.models import Entry


class ProjectContract(models.Model):
    STATUS_UPCOMING = 'upcoming'
    STATUS_CURRENT = 'current'
    STATUS_COMPLETE = 'complete'
    CONTRACT_STATUS = {
        STATUS_UPCOMING: 'Upcoming',
        STATUS_CURRENT: 'Current',
        STATUS_COMPLETE: 'Complete',
    }

    PROJECT_UNSET = 0  # Have to set existing contracts to something...
    PROJECT_FIXED = 1
    PROJECT_PRE_PAID_HOURLY = 2
    PROJECT_POST_PAID_HOURLY = 3
    PROJECT_TYPE = {   # UNSET is not an option
        PROJECT_FIXED: 'Fixed',
        PROJECT_PRE_PAID_HOURLY: 'Pre-paid Hourly',
        PROJECT_POST_PAID_HOURLY: 'Post-paid Hourly',
    }

    name = models.CharField(max_length=255)
    projects = models.ManyToManyField('crm.Project', related_name='contracts')
    start_date = models.DateField()
    end_date = models.DateField()
    status = models.CharField(choices=CONTRACT_STATUS.items(),
            default=STATUS_UPCOMING, max_length=32)
    type = models.IntegerField(choices=PROJECT_TYPE.items())

    class Meta:
        ordering = ('-end_date',)
        verbose_name = 'contract'
        db_table = 'timepiece_projectcontract'  # Using legacy table name.

    def __unicode__(self):
        return unicode(self.name)

    def get_admin_url(self):
        return reverse('admin:contracts_projectcontract_change', args=[self.pk])

    def get_absolute_url(self):
        return reverse('view_contract', args=[self.pk])

    @property
    def entries(self):
        """
        All Entries worked on projects in this contract during the contract
        period.
        """
        return Entry.objects.filter(project__in=self.projects.all(),
                start_time__gte=self.start_date,
                end_time__lt=self.end_date + relativedelta(days=1))

    def contracted_hours(self, approved_only=True):
        """Compute the hours contracted for this contract.
        (This replaces the old `num_hours` field.)

        :param boolean approved_only: If true, only include approved
            contract hours; if false, include pending ones too.
        :returns: The sum of the contracted hours, subject to the
            `approved_only` parameter.
        :rtype: Decimal
        """

        qset = self.contract_hours
        if approved_only:
            qset = qset.filter(status=ContractHour.APPROVED_STATUS)
        result = qset.aggregate(sum=Sum('hours'))['sum']
        return result or 0

    def pending_hours(self):
        """Compute the contract hours still in pending status"""
        qset = self.contract_hours.filter(status=ContractHour.PENDING_STATUS)
        result = qset.aggregate(sum=Sum('hours'))['sum']
        return result or 0

    @property
    def hours_assigned(self):
        """Total assigned hours for this contract."""
        if not hasattr(self, '_assigned'):
            # TODO put this in a .extra w/a subselect
            assignments = self.assignments.aggregate(s=Sum('num_hours'))
            self._assigned = assignments['s'] or 0
        return self._assigned or 0

    @property
    def hours_remaining(self):
        return self.contracted_hours() - self.hours_worked

    @property
    def hours_worked(self):
        """Number of billable hours worked on the contract."""
        if not hasattr(self, '_worked'):
            # TODO put this in a .extra w/a subselect
            entries = self.entries.filter(activity__billable=True)
            self._worked = entries.aggregate(s=Sum('hours'))['s'] or 0
        return self._worked or 0

    @property
    def nonbillable_hours_worked(self):
        """Number of non-billable hours worked on the contract."""
        if not hasattr(self, '_nb_worked'):
            # TODO put this in a .extra w/a subselect
            entries = self.entries.filter(activity__billable=False)
            self._nb_worked = entries.aggregate(s=Sum('hours'))['s'] or 0
        return self._nb_worked or 0

    @property
    def fraction_hours(self):
        """Fraction of contracted hours that have been worked.  E.g.
        if 50 hours have been worked of 100 contracted, value is 0.5.
        """
        if self.contracted_hours():
            return float(self.hours_worked) / float(self.contracted_hours())
        return 0.0

    @property
    def fraction_schedule(self):
        """If contract status is current, return the current date as a
        fraction of the scheduled period - e.g. if the contract period is
        June 1 to July 31, and today is July 1, then the value is
        about 0.5.

        If the contract status is not current, or either the start or end
        date is not set, returns 0.0
        """
        if self.status != ProjectContract.STATUS_CURRENT or \
            not self.start_date or \
            not self.end_date:
                return 0.0
        contract_period = (self.end_date - self.start_date).days
        if contract_period <= 0.0:
            return 0.0
        days_elapsed = (datetime.date.today() - self.start_date).days
        if days_elapsed <= 0.0:
            return 0.0
        return float(days_elapsed) / contract_period


class ContractHour(models.Model):
    PENDING_STATUS = 1
    APPROVED_STATUS = 2
    CONTRACT_HOUR_STATUS = (
        (PENDING_STATUS, 'Pending'), # default
        (APPROVED_STATUS, 'Approved')
        )

    hours = models.DecimalField(max_digits=8, decimal_places=2,
            default=0)
    contract = models.ForeignKey(ProjectContract,
            related_name='contract_hours')
    date_requested = models.DateField()
    date_approved = models.DateField(blank=True, null=True)
    status = models.IntegerField(choices=CONTRACT_HOUR_STATUS,
            default=PENDING_STATUS)
    notes = models.TextField(blank=True)

    class Meta(object):
        verbose_name = 'contracted hours'
        verbose_name_plural = verbose_name
        db_table = 'timepiece_contracthour'  # Using legacy table name.

    def __init__(self, *args, **kwargs):
        super(ContractHour, self).__init__(*args, **kwargs)
        # Save the current values so we can report changes later
        self._original = {
            'hours': self.hours,
            'notes': self.notes,
            'status': self.status,
            'get_status_display': self.get_status_display(),
            'date_requested': self.date_requested,
            'date_approved': self.date_approved,
            'contract': self.contract if self.contract_id else None,
            }

    def get_absolute_url(self):
        return reverse('admin:contracts_contracthour_change', args=[self.pk])

    def clean(self):
        # Note: this is called when editing in the admin, but not otherwise
        if self.status == self.PENDING_STATUS and self.date_approved:
            raise ValidationError(
                "Pending contracthours should not have an approved date, did "
                "you mean to change status to approved?"
            )

    def _send_mail(self, subject, ctx):
        # Don't go to the work unless we have a place to send it
        emails = utils.get_setting('TIMEPIECE_ACCOUNTING_EMAILS')
        if not emails:
            return
        from_email = utils.get_setting('DEFAULT_FROM_EMAIL')
        template = get_template('timepiece/contract/hours_email.txt')
        context = Context(ctx)
        msg = template.render(context)
        send_mail(
            subject=subject,
            message=msg,
            from_email=from_email,
            recipient_list=emails
        )

    def save(self, *args, **kwargs):
        # Let the date_approved default to today if it's been set approved
        # and doesn't have one
        if self.status == self.APPROVED_STATUS and not self.date_approved:
            self.date_approved = datetime.date.today()

        # If we have an email address to send to, and this record was
        # or is in pending status, we'll send an email about the change.
        if ContractHour.PENDING_STATUS in (self.status, self._original['status']):
            is_new = self.pk is None
        super(ContractHour, self).save(*args, **kwargs)
        if ContractHour.PENDING_STATUS in (self.status, self._original['status']):
            domain = Site.objects.get_current().domain
            method = 'https' if utils.get_setting('TIMEPIECE_EMAILS_USE_HTTPS')\
                else 'http'
            url = self.contract.get_absolute_url()
            ctx = {
                'new': is_new,
                'changed': not is_new,
                'deleted': False,
                'current': self,
                'previous': self._original,
                'link': '%s://%s%s' % (method, domain, url)
            }
            prefix = "New" if is_new else "Changed"
            name = self._meta.verbose_name
            subject = "%s pending %s for %s" % (prefix, name, self.contract)
            self._send_mail(subject, ctx)

    def delete(self, *args, **kwargs):
        # Note: this gets called when you delete a single item using the red
        # Delete button at the bottom while editing it in the admin - but not
        # when you delete one or more from the change list using the admin
        # action.
        super(ContractHour, self).delete(*args, **kwargs)
        # If we have an email address to send to, and this record was in
        # pending status, we'll send an email about the change.
        if ContractHour.PENDING_STATUS in (self.status, self._original['status']):
            domain = Site.objects.get_current().domain
            method = 'https' if utils.get_setting('TIMEPIECE_EMAILS_USE_HTTPS')\
                else 'http'
            url = self.contract.get_absolute_url()
            ctx = {
                'deleted': True,
                'new': False,
                'changed': False,
                'previous': self._original,
                'link': '%s://%s%s' % (method, domain, url)
            }
            contract = self._original['contract']
            name = self._meta.verbose_name
            subject = "Deleted pending %s for %s" % (name, contract)
            self._send_mail(subject, ctx)


class ContractAssignment(models.Model):
    contract = models.ForeignKey(ProjectContract, related_name='assignments')
    user = models.ForeignKey(User, related_name='assignments')
    start_date = models.DateField()
    end_date = models.DateField()
    num_hours = models.DecimalField(max_digits=8, decimal_places=2, default=0)
    min_hours_per_week = models.IntegerField(default=0)

    class Meta:
        unique_together = (('contract', 'user'),)
        db_table = 'timepiece_contractassignment'  # Using legacy table name.

    def __unicode__(self):
        return u'{0} / {1}'.format(self.user, self.contract)

    @property
    def entries(self):
        return Entry.objects.filter(project__in=self.contract.projects.all(),
                user=self.user, start_time__gte=self.start_date,
                end_time__lt=self.end_date + relativedelta(days=1))

    @property
    def hours_remaining(self):
        return self.num_hours - self.hours_worked

    @property
    def hours_worked(self):
        if not hasattr(self, '_worked'):
            self._worked = self.entries.aggregate(s=Sum('hours'))['s'] or 0
        return self._worked or 0


class HourGroupManager(models.Manager):

    def summaries(self, entries):
        #Get the list of bundle names and hour sums
        bundled_entries = entries.values('activity__activity_bundle',
                                         'activity__activity_bundle__name')
        bundled_entries = bundled_entries.annotate(Sum('hours'))
        bundled_entries = bundled_entries.order_by(
                                            'activity__activity_bundle__order',
                                            'activity__activity_bundle__name'
        )
        bundled_totals = list(bundled_entries.values_list(
                                             'activity__activity_bundle__name',
                                             'activity__activity_bundle',
                                             'hours__sum')
        )
        #Get the list of activity names and hour sums
        activity_entries = entries.values('activity', 'activity__name',
                                          'activity__activity_bundle')
        activity_entries = activity_entries.annotate(Sum('hours'))
        activity_entries = activity_entries.order_by('activity')
        activity_totals = list(activity_entries.values_list(
                                                   'activity__name',
                                                   'activity__activity_bundle',
                                                   'hours__sum')
        )
        totals = {}
        other_values = ()
        for bundle in bundled_totals:
            bundle_key, bundle_value = bundle[0], bundle[2]
            act_values = [(act[0], act[2]) for act in activity_totals
                          if act[1] == bundle[1]]
            if bundle_key is not None:
                totals[bundle_key] = (bundle_value, act_values)
            else:
                other_values = (bundle_value, act_values)
        totals = sorted(totals.items())
        if other_values:
            totals.append(('Other', other_values))
        all_totals = sum([bt[2] for bt in bundled_totals])
        totals.append(('Total', (all_totals, [])))
        return totals


class HourGroup(models.Model):
    """Activities that are bundled together for billing"""
    name = models.CharField(max_length=255, unique=True)
    activities = models.ManyToManyField('entries.Activity',
            related_name='activity_bundle')
    order = models.PositiveIntegerField(unique=True, blank=True, null=True)

    objects = HourGroupManager()

    class Meta:
        db_table = 'timepiece_hourgroup'  # Using legacy table name.

    def __unicode__(self):
        return self.name


class EntryGroup(models.Model):
    INVOICED = Entry.INVOICED
    NOT_INVOICED = Entry.NOT_INVOICED
    STATUSES = {
        INVOICED: 'Invoiced',
        NOT_INVOICED: 'Not Invoiced',
    }

    user = models.ForeignKey(User, related_name='entry_group')
    project = models.ForeignKey('crm.Project', related_name='entry_group')
    status = models.CharField(max_length=24, choices=STATUSES.items(),
                              default=INVOICED)
    number = models.CharField("Reference #", max_length=50, blank=True,
                              null=True)
    comments = models.TextField(blank=True, null=True)
    created = models.DateTimeField(auto_now_add=True)
    modified = models.DateTimeField(auto_now=True)
    start = models.DateField(blank=True, null=True)
    end = models.DateField()

    class Meta:
        db_table = 'timepiece_entrygroup'  # Using legacy table name.

    def delete(self):
        self.entries.update(status=Entry.APPROVED)
        super(EntryGroup, self).delete()

    def __unicode__(self):
        invoice_data = {
            'number': self.number,
            'status': self.status,
            'project': self.project,
            'end': self.end.strftime('%b %Y'),
        }
        return u'Entry Group ' + \
               u'%(number)s: %(status)s - %(project)s - %(end)s' % invoice_data

########NEW FILE########
__FILENAME__ = test_contracts
import datetime
import mock

from django.contrib.auth.models import Permission
from django.core.exceptions import ValidationError
from django.test import TestCase

from timepiece.contracts.models import ProjectContract, ContractHour
from timepiece.tests.base import ViewTestMixin
from timepiece.tests import factories


class ContractListTestCase(ViewTestMixin, TestCase):
    url_name = 'list_contracts'
    perm_names = [('contracts', 'add_projectcontract')]

    def setUp(self):
        get_perm = lambda ct, n: Permission.objects.get(
                content_type__app_label=ct, codename=n)
        self.permissions = [get_perm(*perm) for perm in self.perm_names]

        self.user = factories.User()
        self.user.user_permissions.add(*self.permissions)
        self.login_user(self.user)

        self.project1 = factories.Project()
        self.project2 = factories.Project()
        self.projects = [self.project1, self.project2]

    def test_permission(self):
        """Permission is required to see this view."""
        response = self._get()
        self.assertEqual(response.status_code, 200)

    def test_no_permission(self):
        """Permission is required to see this view."""
        self.user.user_permissions.remove(*self.permissions)
        response = self._get()
        self.assertEqual(response.status_code, 302)

    def test_no_contracts(self):
        """List should return all current contracts."""
        ProjectContract.objects.all().delete()
        response = self._get()
        self.assertEqual(response.status_code, 200)
        contracts = response.context['contracts']
        self.assertEqual(len(contracts), 0)

    def test_one_contract(self):
        """List should return all current contracts."""
        correct_contract = factories.ProjectContract(projects=self.projects,
                status=ProjectContract.STATUS_CURRENT)
        response = self._get()
        self.assertEqual(response.status_code, 200)
        contracts = response.context['contracts']
        self.assertEqual(len(contracts), 1)
        self.assertTrue(correct_contract in contracts)

    def test_contracts(self):
        """List should return all current contracts."""
        correct_contracts = [factories.ProjectContract(projects=self.projects,
                status=ProjectContract.STATUS_CURRENT) for i in range(3)]
        response = self._get()
        self.assertEqual(response.status_code, 200)
        contracts = response.context['contracts']
        self.assertEqual(len(contracts), 3)
        for i in range(3):
            self.assertTrue(correct_contracts[i] in contracts)

    def test_non_current_contracts(self):
        """List should return all current contracts."""
        complete_contract = factories.ProjectContract(projects=self.projects,
                status=ProjectContract.STATUS_COMPLETE)
        upcoming_contract = factories.ProjectContract(projects=self.projects,
                status=ProjectContract.STATUS_UPCOMING)
        response = self._get()
        self.assertEqual(response.status_code, 200)
        contracts = response.context['contracts']
        self.assertEqual(len(contracts), 0)


class ContractViewTestCase(ViewTestMixin, TestCase):
    url_name = 'view_contract'
    perm_names = [('contracts', 'add_projectcontract')]

    @property
    def url_args(self):
        return (self.contract.pk,)

    def setUp(self):
        get_perm = lambda ct, n: Permission.objects.get(
                content_type__app_label=ct, codename=n)
        self.permissions = [get_perm(*perm) for perm in self.perm_names]

        self.user = factories.User()
        self.user.user_permissions.add(*self.permissions)
        self.login_user(self.user)

        self.project1 = factories.Project()
        self.project2 = factories.Project()
        self.projects = [self.project1, self.project2]

        self.contract = factories.ProjectContract(projects=self.projects)

    def test_permission(self):
        """Permission is required to view a contract."""
        response = self._get()
        self.assertEqual(response.status_code, 200)

    def test_no_permission(self):
        """Permission is required to view a contract."""
        self.user.user_permissions.remove(*self.permissions)
        response = self._get()
        self.assertEqual(response.status_code, 302)

    def test_bad_id(self):
        response = self._get(url_args=('12345',))
        self.assertEqual(response.status_code, 404)

    def test_current_contract(self):
        contract = factories.ProjectContract(projects=self.projects,
                status=ProjectContract.STATUS_CURRENT)
        response = self._get(url_args=(contract.pk,))
        self.assertEqual(response.status_code, 200)
        self.assertEqual(contract, response.context['contract'])

    def test_upcoming_contract(self):
        contract = factories.ProjectContract(projects=self.projects,
                status=ProjectContract.STATUS_UPCOMING)
        response = self._get(url_args=(contract.pk,))
        self.assertEqual(response.status_code, 200)
        self.assertEqual(contract, response.context['contract'])

    def test_complete_contract(self):
        contract = factories.ProjectContract(projects=self.projects,
                status=ProjectContract.STATUS_COMPLETE)
        response = self._get(url_args=(contract.pk,))
        self.assertEqual(response.status_code, 200)
        self.assertEqual(contract, response.context['contract'])


class ContractHourTestCase(TestCase):

    def test_defaults(self):
        contract_hour = ContractHour()
        self.assertEqual(0, contract_hour.hours)
        self.assertEqual(ContractHour.PENDING_STATUS, contract_hour.status)

    def test_contracted_hours(self):
        # If we create some Contract Hour objects and then go to the
        # project contract and get contracted_hours(), it gives the sum
        # of the hours
        pc = factories.ProjectContract(contract_hours=4)
        self.assertEqual(4, pc.contracted_hours())
        self.assertEqual(0, pc.pending_hours())

    def test_pending_hours(self):
        # If we create some pending Contract Hour objects and then go to the
        # project contract and get pending_hours(), it gives the sum
        # of the hours
        pc = factories.ProjectContract(contract_hours=4)
        ch = factories.ContractHour(contract=pc, hours=27,
                status=ContractHour.PENDING_STATUS)
        self.assertEqual(4, pc.contracted_hours())
        self.assertEqual(27, pc.pending_hours())
        ch.delete()
        self.assertEqual(4, pc.contracted_hours())
        self.assertEqual(0, pc.pending_hours())

    def test_validation(self):
        with self.assertRaises(ValidationError):
            ch = factories.ContractHour(
                    status=ContractHour.PENDING_STATUS,
                    date_approved=datetime.date.today())
            ch.clean()

    def test_default_date_approved(self):
        # If saved with status approved and no date approved,
        # it sets it to today
        ch = factories.ContractHour(
                status=ContractHour.APPROVED_STATUS,
                date_approved=None)
        ch = ContractHour.objects.get(pk=ch.pk)
        self.assertEqual(datetime.date.today(), ch.date_approved)

    def test_fraction_hours(self):
        # fraction_hours returns what fraction of the contracted hours
        # have been worked
        contracted_hours = 0
        pc = factories.ProjectContract(contract_hours=contracted_hours)
        # If contracted hours 0, return 0 (don't div/0)
        self.assertEqual(0.0, pc.fraction_hours)
        contracted_hours = 10.0
        pc = factories.ProjectContract(contract_hours=contracted_hours)
        # If contracted hours non-zero, worked hours 0, return 0
        self.assertEqual(0.0, pc.fraction_hours)
        # Now do some work
        pc._worked = 5.0
        self.assertEqual(0.5, pc.fraction_hours)


    def test_fraction_schedule(self):
        # fraction_schedule returns what fraction of the contract period
        # has elapsed - if the contract is current
        one_month = datetime.timedelta(days=30)
        today = datetime.date.today()
        last_month = today - one_month
        next_month = today + one_month
        pc = factories.ProjectContract(
            status=ProjectContract.STATUS_UPCOMING, start_date=last_month,
            end_date=next_month
        )
        self.assertEqual(0.0, pc.fraction_schedule)
        pc.status = ProjectContract.STATUS_COMPLETE
        self.assertEqual(0.0, pc.fraction_schedule)
        pc.status = ProjectContract.STATUS_CURRENT
        self.assertEqual(0.5, pc.fraction_schedule)
        # Just to be perverse, a contract in current state whose start
        # date hasn't arrived yet
        pc.start_date = today + datetime.timedelta(days=2)
        self.assertEqual(0.0, pc.fraction_schedule)

    def test_get_absolute_url(self):
        ch = factories.ContractHour.create()
        url = '/admin/contracts/contracthour/%d/' % ch.pk
        self.assertEqual(url, ch.get_absolute_url())


class ContractHourEmailTestCase(TestCase):

    def test_save_pending_calls_send_email(self):
        with mock.patch('timepiece.contracts.models.ContractHour._send_mail') as send_mail:
            factories.ContractHour(status=ContractHour.PENDING_STATUS)
        self.assertTrue(send_mail.called)
        (subject, ctx) = send_mail.call_args[0]
        self.assertTrue(subject.startswith("New"))

    def test_save_approved_does_not_call_send_email(self):
        with mock.patch('timepiece.contracts.models.ContractHour._send_mail') as send_mail:
            factories.ContractHour(status=ContractHour.APPROVED_STATUS)
        self.assertFalse(send_mail.called)

    def test_delete_pending_calls_send_email(self):
        ch = factories.ContractHour(status=ContractHour.PENDING_STATUS)
        with mock.patch('timepiece.contracts.models.ContractHour._send_mail') as send_mail:
            ch.delete()
        self.assertTrue(send_mail.called)
        (subject, ctx) = send_mail.call_args[0]
        self.assertTrue(subject.startswith("Deleted"))

    def test_change_pending_calls_send_email(self):
        ch = factories.ContractHour(status=ContractHour.PENDING_STATUS)
        with mock.patch('timepiece.contracts.models.ContractHour._send_mail') as send_mail:
            ch.save()
        self.assertTrue(send_mail.called)
        (subject, ctx) = send_mail.call_args[0]
        self.assertTrue(subject.startswith("Changed"))

########NEW FILE########
__FILENAME__ = test_invoices
import datetime
from dateutil.relativedelta import relativedelta
import random
import urllib

from django.contrib.auth.models import Permission
from django.core.urlresolvers import reverse
from django.test import TestCase

from timepiece import utils
from timepiece.forms import DATE_FORM_FORMAT
from timepiece.tests import factories
from timepiece.tests.base import ViewTestMixin, LogTimeMixin

from timepiece.contracts.models import EntryGroup, HourGroup
from timepiece.crm.models import Attribute
from timepiece.entries.models import Activity, Entry


class TestListInvoicesView(ViewTestMixin, TestCase):
    url_name = 'list_invoices'
    template_name = 'timepiece/invoice/list.html'
    factory = factories.EntryGroup
    model = EntryGroup

    def setUp(self):
        super(TestListInvoicesView, self).setUp()
        self.permissions = [Permission.objects.get(codename='add_entrygroup')]
        self.user = factories.User(permissions=self.permissions)
        self.login_user(self.user)

    def test_get_no_permission(self):
        """Permission is required for this view."""
        self.user.user_permissions.clear()
        response = self._get()
        self.assertRedirectsToLogin(response)

    def test_list_all(self):
        """If no filters are provided, all objects should be listed."""
        object_list = [self.factory.create() for i in range(3)]
        response = self._get()
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertEquals(response.context['object_list'].count(), 3)
        for obj in object_list:
            self.assertTrue(obj in response.context['object_list'])

    def test_list_one(self):
        """Page should render if there is one object & no search query."""
        obj = self.factory.create()
        response = self._get()
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertEquals(response.context['object_list'].count(), 1)
        self.assertEquals(response.context['object_list'].get(), obj)

    def test_no_results(self):
        """Page should render if there are no search results."""
        obj = self.factory.create()
        response = self._get(get_kwargs={'search': 'hello'})
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertEquals(response.context['object_list'].count(), 0)

    def test_one_result(self):
        """Page should render if there is only one search result."""
        obj = self.factory.create(comments='hello')
        response = self._get(get_kwargs={'search': 'hello'})
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertEquals(response.context['object_list'].count(), 1)
        self.assertEquals(response.context['object_list'].get(), obj)

    def test_multiple_results(self):
        """Page should render if there are multiple search results."""
        obj_list = [self.factory.create(comments='hello') for i in range(2)]
        response = self._get(get_kwargs={'search': 'hello'})
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertEquals(response.context['object_list'].count(), 2)
        for obj in obj_list:
            self.assertTrue(obj in response.context['object_list'])

    def test_filter_number(self):
        """User should be able to filter by search query."""
        obj = self.factory.create(number='hello')
        other_obj = self.factory.create()
        response = self._get(get_kwargs={'search': 'hello'})
        self.assertEquals(response.status_code, 200)
        self.assertEquals(response.context['object_list'].get(), obj)

    def test_filter_comments(self):
        """User should be able to filter by search query."""
        obj = self.factory.create(comments='hello')
        other_obj = self.factory.create()
        response = self._get(get_kwargs={'search': 'hello'})
        self.assertEquals(response.status_code, 200)
        self.assertEquals(response.context['object_list'].get(), obj)

    def test_filter_project_name(self):
        """User should be able to filter by search query."""
        obj = self.factory.create(project__name='hello')
        other_obj = self.factory.create()
        response = self._get(get_kwargs={'search': 'hello'})
        self.assertEquals(response.status_code, 200)
        self.assertEquals(response.context['object_list'].get(), obj)

    def test_filter_user_username(self):
        """User should be able to filter by search query."""
        obj = self.factory.create(user__username='hello')
        other_obj = self.factory.create()
        response = self._get(get_kwargs={'search': 'hello'})
        self.assertEquals(response.status_code, 200)
        self.assertEquals(response.context['object_list'].get(), obj)


class InvoiceViewPreviousTestCase(ViewTestMixin, LogTimeMixin, TestCase):

    def setUp(self):
        super(InvoiceViewPreviousTestCase, self).setUp()
        self.user = factories.Superuser()
        self.login_user(self.user)
        self.devl_activity = factories.Activity(code='devl',
                name='development', billable=True)
        self.activity = factories.Activity(code='WRK',
                name='Work')
        # Make some projects and entries for invoice creation
        self.project = factories.BillableProject()
        self.project2 = factories.BillableProject()
        last_start = self.log_many([self.project, self.project2])
        # Add some non-billable entries
        self.log_many([self.project, self.project2], start=last_start,
                      billable=False)
        self.create_invoice(self.project, {'static': EntryGroup.INVOICED})
        self.create_invoice(self.project2, {'status': EntryGroup.NOT_INVOICED})

    def get_create_url(self, **kwargs):
        base_url = reverse('create_invoice')
        params = urllib.urlencode(kwargs)
        return '{0}?{1}'.format(base_url, params)

    def log_many(self, projects, num_entries=20, start=None, billable=True):
        start = utils.add_timezone(datetime.datetime(2011, 1, 1, 0, 0, 0))
        for index in xrange(0, num_entries):
            start += relativedelta(hours=(5 * index))
            project = projects[index % len(projects)]  # Alternate projects
            self.log_time(start=start, status=Entry.APPROVED, project=project,
                          billable=billable)
        return start

    def create_invoice(self, project=None, data=None):
        data = data or {}
        if not project:
            project = self.project
        to_date = utils.add_timezone(datetime.datetime(2011, 1, 31))
        url = self.get_create_url(project=project.id, to_date=to_date.strftime('%Y-%m-%d'))
        params = {
            'number': str(random.randint(999, 9999)),
            'status': EntryGroup.INVOICED,
        }
        params.update(data)
        response = self.client.post(url, params)

    def get_invoice(self):
        invoices = EntryGroup.objects.all()
        return random.choice(invoices)

    def get_entry(self, invoice):
        entries = invoice.entries.all()
        return random.choice(entries)

    def test_previous_invoice_list_no_search(self):
        url = reverse('list_invoices')
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        invoices = response.context['object_list']
        self.assertEqual(len(invoices), 2)

    def test_previous_invoice_list_search(self):

        def search(query):
            response = self.client.get(list_url, data={'search': query})
            return response.context['object_list']

        list_url = reverse('list_invoices')
        project3 = factories.BillableProject(name=':-D')
        self.log_many([project3], 10)
        self.create_invoice(project=project3, data={
            'status': EntryGroup.INVOICED,
            'comments': 'comment!',
            'number': '###',
        })

        # Search comments, project name, and number.
        for query in ['comment!', ':-D', '###']:
            results = search(query)
            self.assertEqual(len(results), 1)
            self.assertEqual(results[0].project, project3)

        # Search in username
        results = search(self.user.username)
        self.assertEqual(len(results), 3)  # all were created by this user

        # No results
        results = search("You won't find me here")
        self.assertEquals(len(results), 0)

    def test_invoice_detail(self):
        invoices = EntryGroup.objects.all()
        for invoice in invoices:
            url = reverse('view_invoice', args=[invoice.id])
            response = self.client.get(url)
            self.assertEqual(response.status_code, 200)
            self.assertTrue(response.context['invoice'])

    def test_invoice_csv(self):
        invoice = self.get_invoice()
        url = reverse('view_invoice_csv', args=[invoice.id])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        data = dict(response.items())
        self.assertEqual(data['Content-Type'], 'text/csv')
        disposition = data['Content-Disposition']
        self.assertTrue(disposition.startswith('attachment; filename=Invoice'))
        contents = response.content.splitlines()
        # TODO: Possibly find a meaningful way to test contents
        # Pull off header line and totals line
        header = contents.pop(0)
        total = contents.pop()
        num_entries = invoice.entries.all().count()
        self.assertEqual(num_entries, len(contents))

    def test_invoice_csv_bad_id(self):
        url = reverse('view_invoice_csv', args=[9999999999])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 404)

    def test_invoice_edit_get(self):
        invoice = self.get_invoice()
        url = reverse('edit_invoice', args=[invoice.id])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.context['invoice'].id, invoice.id)
        self.assertTrue(response.context['entries'])

    def test_invoice_edit_bad_id(self):
        url = reverse('edit_invoice', args=[99999999999])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 404)

    def test_invoice_edit_post(self):
        invoice = self.get_invoice()
        url = reverse('edit_invoice', args=(invoice.id,))
        status = EntryGroup.INVOICED if invoice.status != EntryGroup.INVOICED \
                else EntryGroup.NOT_INVOICED
        params = {
            'number': int(invoice.number) + 1,
            'status': status,
            'comments': 'Comments',
        }
        response = self.client.post(url, params)
        self.assertEqual(response.status_code, 302)
        new_invoice = EntryGroup.objects.get(pk=invoice.id)
        self.assertEqual(int(invoice.number) + 1, int(new_invoice.number))
        self.assertTrue(invoice.status != new_invoice.status)
        self.assertEqual(new_invoice.comments, 'Comments')

    def test_invoice_edit_bad_post(self):
        invoice = self.get_invoice()
        url = reverse('edit_invoice', args=[invoice.id])
        params = {
            'number': '2',
            'status': 'not_in_choices',
        }
        response = self.client.post(url, params)
        err_msg = 'Select a valid choice. not_in_choices is not one of ' + \
                  'the available choices.'
        self.assertFormError(response, 'invoice_form', 'status', err_msg)

    def test_invoice_delete_get(self):
        invoice = self.get_invoice()
        url = reverse('delete_invoice', args=[invoice.id])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)

    def test_invoice_delete(self):
        invoice = self.get_invoice()
        entry_ids = [entry.pk for entry in invoice.entries.all()]
        url = reverse('delete_invoice', args=[invoice.id])
        response = self.client.post(url, {'delete': 'delete'})
        self.assertEqual(response.status_code, 302)
        self.assertFalse(EntryGroup.objects.filter(pk=invoice.id))
        entries = Entry.objects.filter(pk__in=entry_ids)
        for entry in entries:
            self.assertEqual(entry.status, Entry.APPROVED)

    def test_invoice_delete_cancel(self):
        invoice = self.get_invoice()
        url = reverse('delete_invoice', args=[invoice.id])
        response = self.client.post(url, {'cancel': 'cancel'})
        self.assertEqual(response.status_code, 302)
        # Canceled out so the invoice was not deleted
        self.assertTrue(EntryGroup.objects.get(pk=invoice.id))

    def test_invoice_delete_bad_args(self):
        invoice = self.get_invoice()
        entry_ids = [entry.pk for entry in invoice.entries.all()]
        url = reverse('delete_invoice', args=[1232345345])
        response = self.client.post(url, {'delete': 'delete'})
        self.assertEqual(response.status_code, 404)

    def test_rm_invoice_entry_get(self):
        invoice = self.get_invoice()
        entry = self.get_entry(invoice)
        url = reverse('delete_invoice_entry', args=[invoice.id, entry.id])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.context['invoice'], invoice)
        self.assertEqual(response.context['entry'], entry)

    def test_rm_invoice_entry_get_bad_id(self):
        invoice = self.get_invoice()
        entry = self.get_entry(invoice)
        url = reverse('delete_invoice_entry', args=[invoice.id, 999999])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 404)
        url = reverse('delete_invoice_entry', args=[9999, entry.id])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 404)

    def test_rm_invoice_entry_post(self):
        invoice = self.get_invoice()
        entry = self.get_entry(invoice)
        url = reverse('delete_invoice_entry', args=[invoice.id, entry.id])
        response = self.client.post(url, {'submit': ''})
        self.assertEqual(response.status_code, 302)
        new_invoice = EntryGroup.objects.get(pk=invoice.pk)
        rm_entry = new_invoice.entries.filter(pk=entry.id)
        self.assertFalse(rm_entry)
        new_entry = Entry.objects.get(pk=entry.pk)
        self.assertEqual(new_entry.status, Entry.APPROVED)
        self.assertEqual(new_entry.entry_group, None)


class InvoiceCreateTestCase(ViewTestMixin, TestCase):

    def setUp(self):
        super(InvoiceCreateTestCase, self).setUp()
        self.user = factories.Superuser()
        self.login_user(self.user)
        start = utils.add_timezone(datetime.datetime(2011, 1, 1, 8))
        end = utils.add_timezone(datetime.datetime(2011, 1, 1, 12))
        self.project_billable = factories.BillableProject()
        self.project_billable2 = factories.BillableProject()
        self.project_non_billable = factories.NonbillableProject()
        self.entry1 = factories.Entry(user=self.user,
                project=self.project_billable,
                activity=factories.Activity(billable=True),
                start_time=start, end_time=end, status=Entry.APPROVED)
        self.entry2 = factories.Entry(user=self.user,
                project=self.project_billable,
                activity=factories.Activity(billable=True),
                start_time=start - relativedelta(days=5),
                end_time=end - relativedelta(days=5), status=Entry.APPROVED)
        self.entry3 = factories.Entry(user=self.user,
                project=self.project_billable2,
                activity=factories.Activity(billable=False),
                start_time=start - relativedelta(days=10),
                end_time=end - relativedelta(days=10), status=Entry.APPROVED)
        self.entry4 = factories.Entry(user=self.user,
                project=self.project_non_billable,
                start_time=start + relativedelta(hours=11),
                end_time=end + relativedelta(hours=15), status=Entry.APPROVED)

    def get_create_url(self, **kwargs):
        base_url = reverse('create_invoice')
        params = urllib.urlencode(kwargs)
        return '{0}?{1}'.format(base_url, params)

    def make_hourgroups(self):
        """
        Make several hour groups, one for each activity, and one that contains
        all activities to check for hour groups with multiple activities.
        """
        all_activities = Activity.objects.all()
        for activity in all_activities:
            hg = HourGroup.objects.create(name=activity.name)
            hg.activities.add(activity)

    def login_with_permission(self):
        """Helper to login as user with correct permissions"""
        generate_invoice = Permission.objects.get(
            codename='generate_project_invoice')
        user = factories.User()
        user.user_permissions.add(generate_invoice)

    def test_invoice_confirm_view_user(self):
        """A regular user should not be able to access this page"""
        self.login_user(factories.User())
        to_date = utils.add_timezone(datetime.datetime(2011, 1, 31))
        url = self.get_create_url(project=self.project_billable.pk,
                to_date=to_date.strftime(DATE_FORM_FORMAT))

        response = self.client.get(url)
        self.assertEquals(response.status_code, 403)

    def test_invoice_confirm_view_permission(self):
        """
        If you have the correct permission, you should be
        able to create an invoice
        """
        self.login_with_permission()
        to_date = utils.add_timezone(datetime.datetime(2011, 1, 31))
        url = self.get_create_url(project=self.project_billable.pk,
                to_date=to_date.strftime(DATE_FORM_FORMAT))

        response = self.client.get(url)
        self.assertEquals(response.status_code, 200)

    def test_invoice_confirm_view(self):
        to_date = utils.add_timezone(datetime.datetime(2011, 1, 31))
        url = self.get_create_url(project=self.project_billable.pk,
                to_date=to_date.strftime(DATE_FORM_FORMAT))
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        to_date_str = response.context['to_date'].strftime('%Y %m %d')
        self.assertEqual(to_date_str, '2011 01 31')
        # View can also take from date
        from_date = utils.add_timezone(datetime.datetime(2011, 1, 1))
        kwargs = {
            'project': self.project_billable.id,
            'to_date': to_date.strftime(DATE_FORM_FORMAT),
            'from_date': from_date.strftime(DATE_FORM_FORMAT),
        }
        url = self.get_create_url(**kwargs)
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        from_date_str = response.context['from_date'].strftime('%Y %m %d')
        to_date_str = response.context['to_date'].strftime('%Y %m %d')
        self.assertEqual(from_date_str, '2011 01 01')
        self.assertEqual(to_date_str, '2011 01 31')

    def test_invoice_confirm_totals(self):
        """Verify that the per activity totals are valid."""
        # Make a few extra entries to test per activity totals
        start = utils.add_timezone(datetime.datetime(2011, 1, 1, 8))
        end = utils.add_timezone(datetime.datetime(2011, 1, 1, 12))
        # start = utils.add_timezone(datetime.datetime.now())
        # end = start + relativedelta(hours=4)
        activity = factories.Activity(billable=True, name='activity1')
        for num in xrange(0, 4):
            new_entry = factories.Entry(user=self.user,
                    project=self.project_billable,
                    start_time=start - relativedelta(days=num),
                    end_time=end - relativedelta(days=num),
                    status=Entry.APPROVED, activity=activity)
        self.make_hourgroups()
        to_date = datetime.datetime(2011, 1, 31)
        kwargs = {
            'project': self.project_billable.id,
            'to_date': to_date.strftime(DATE_FORM_FORMAT),
        }
        url = self.get_create_url(**kwargs)
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        for name, hours_activities in response.context['billable_totals']:
            total, activities = hours_activities
            if name == 'activity1':
                self.assertEqual(total, 16)
                self.assertEqual(total, activities[0][1])
                self.assertEqual(name, activities[0][0])
            elif name == 'Total':
                self.assertEqual(total, 24)
                self.assertEqual(activities, [])
            else:
                # Each other activity is 4 hrs each
                self.assertEqual(total, 4)
                self.assertEqual(total, activities[0][1])
                self.assertEqual(name, activities[0][0])

    def test_invoice_confirm_bad_args(self):
        # A year/month/project with no entries should raise a 404
        kwargs = {
            'project': self.project_billable.id,
            'to_date': '2008-01-13',
        }
        url = self.get_create_url(**kwargs)
        response = self.client.get(url)
        self.assertEqual(response.status_code, 404)
        # A year/month with bad/overflow values should raise a 404
        kwargs = {
            'project': self.project_billable.id,
            'to_date': '9999-13-01',
        }
        url = self.get_create_url(**kwargs)
        response = self.client.get(url)
        self.assertEqual(response.status_code, 404)

    def test_make_invoice(self):
        to_date = utils.add_timezone(datetime.datetime(2011, 1, 31))
        kwargs = {
            'project': self.project_billable.id,
            'to_date': to_date.strftime(DATE_FORM_FORMAT),
        }
        url = self.get_create_url(**kwargs)
        response = self.client.post(url, {'number': '3',
                'status': EntryGroup.INVOICED})
        self.assertEqual(response.status_code, 302)
        # Verify an invoice was created with the correct attributes
        invoice = EntryGroup.objects.get(number=3)
        self.assertEqual(invoice.project.id, self.project_billable.id)
        self.assertEqual(invoice.start, None)
        self.assertEqual(invoice.end.strftime('%Y %m %d'), '2011 01 31')
        self.assertEqual(len(invoice.entries.all()), 2)
        # Verify that the entries were invoiced appropriately
        # and the unrelated entries were untouched
        entries = Entry.objects.all()
        invoiced = entries.filter(status=EntryGroup.INVOICED)
        for entry in invoiced:
            self.assertEqual(entry.entry_group_id, invoice.id)
        approved = entries.filter(status=Entry.APPROVED)
        self.assertEqual(len(approved), 2)
        self.assertEqual(approved[0].entry_group_id, None)

    def test_make_invoice_with_from_uninvoiced(self):
        from_date = utils.add_timezone(datetime.datetime(2011, 1, 1))
        to_date = utils.add_timezone(datetime.datetime(2011, 1, 31))
        kwargs = {
            'project': self.project_billable.id,
            'to_date': to_date.strftime(DATE_FORM_FORMAT),
            'from_date': from_date.strftime(DATE_FORM_FORMAT),
        }
        url = self.get_create_url(**kwargs)
        response = self.client.post(url, {'number': '5',
                                          'status': EntryGroup.NOT_INVOICED})
        self.assertEqual(response.status_code, 302)
        # Verify an invoice was created with the correct attributes
        invoice = EntryGroup.objects.get(number=5)
        self.assertEqual(invoice.project.id, self.project_billable.id)
        self.assertEqual(invoice.start.strftime('%Y %m %d'), '2011 01 01')
        self.assertEqual(invoice.end.strftime('%Y %m %d'), '2011 01 31')
        self.assertEqual(len(invoice.entries.all()), 1)
        # Verify that the entries were invoiced appropriately
        # and the unrelated entries were untouched
        entries = Entry.objects.all()
        uninvoiced = entries.filter(status=Entry.NOT_INVOICED)
        for entry in uninvoiced:
            self.assertEqual(entry.entry_group_id, invoice.id)


class ListOutstandingInvoicesViewTestCase(ViewTestMixin, TestCase):
    url_name = 'list_outstanding_invoices'

    def setUp(self):
        super(ListOutstandingInvoicesViewTestCase, self).setUp()
        self.user = factories.Superuser()
        self.login_user(self.user)

        start = utils.add_timezone(datetime.datetime(2011, 1, 1, 8))
        end = utils.add_timezone(datetime.datetime(2011, 1, 1, 12))

        self.project_billable = factories.BillableProject()
        self.project_billable2 = factories.BillableProject()
        self.project_non_billable = factories.NonbillableProject()

        self.entry1 = factories.Entry(user=self.user,
                project=self.project_billable,
                activity=factories.Activity(billable=True),
                start_time=start, end_time=end, status=Entry.APPROVED)
        self.entry2 = factories.Entry(user=self.user,
                project=self.project_billable,
                activity=factories.Activity(billable=True),
                start_time=start - relativedelta(days=5),
                end_time=end - relativedelta(days=5), status=Entry.APPROVED)
        self.entry3 = factories.Entry(user=self.user,
                project=self.project_billable2,
                activity=factories.Activity(billable=False),
                start_time=start - relativedelta(days=10),
                end_time=end - relativedelta(days=10), status=Entry.APPROVED)
        self.entry4 = factories.Entry(user=self.user,
                project=self.project_non_billable,
                start_time=start + relativedelta(hours=11),
                end_time=end + relativedelta(hours=15), status=Entry.APPROVED)

        # Default get kwargs.
        self.to_date = utils.add_timezone(datetime.datetime(2011, 1, 31, 0, 0, 0))
        self.get_kwargs = {
            'to_date': self.to_date.strftime(DATE_FORM_FORMAT),
            'statuses': list(Attribute.statuses.values_list('pk', flat=True)),
        }

    def test_unauthenticated(self):
        self.client.logout()
        response = self._get()
        self.assertEquals(response.status_code, 302)

    def test_list_no_kwargs(self):
        response = self._get(get_kwargs={})
        self.assertEquals(response.status_code, 200)
        form = response.context['form']
        self.assertFalse(form.is_bound)
        self.assertFalse(form.is_valid())
        self.assertEquals(response.context['project_totals'].count(), 3)

    def test_list_outstanding(self):
        """Only billable projects should be listed."""
        response = self._get()
        self.assertEquals(response.status_code, 200)
        form = response.context['form']
        self.assertTrue(form.is_valid(), form.errors)
        # The number of projects should be 3 because entry4 has billable=False
        self.assertEquals(response.context['project_totals'].count(), 3)
        # Verify that the date on the mark as invoiced links will be correct
        self.assertEquals(response.context['to_date'], self.to_date.date())
        self.assertEquals(list(response.context['unverified']), [])
        self.assertEquals(list(response.context['unapproved']), [])

    def test_unverified(self):
        start = utils.add_timezone(datetime.datetime(2011, 1, 1, 8))
        end = utils.add_timezone(datetime.datetime(2011, 1, 1, 12))
        unverified_entry = factories.Entry(user=self.user,
            project=self.project_non_billable,
            start_time=start + relativedelta(hours=11),
            end_time=end + relativedelta(hours=15), status=Entry.UNVERIFIED
        )
        response = self._get()
        self.assertEquals(response.status_code, 200)
        form = response.context['form']
        self.assertTrue(form.is_valid(), form.errors)
        unverified = list(response.context['unverified'])
        unapproved = list(response.context['unapproved'])
        expected_unverified = [
            (self.user.pk, self.user.first_name, self.user.last_name)
        ]
        self.assertEquals(unverified, expected_unverified)
        self.assertEquals(unapproved, [])

    def test_approved(self):
        start = utils.add_timezone(datetime.datetime(2011, 1, 1, 8))
        end = utils.add_timezone(datetime.datetime(2011, 1, 1, 12))
        unapproved_entry_a = factories.Entry(user=self.user,
            project=self.project_non_billable,
            start_time=start + relativedelta(hours=11),
            end_time=end + relativedelta(hours=15), status=Entry.VERIFIED
        )
        unapproved_entry_b = factories.Entry(user=self.user,
            project=self.project_non_billable,
            start_time=start + relativedelta(hours=11),
            end_time=end + relativedelta(hours=15), status=Entry.VERIFIED
        )
        response = self._get()
        self.assertEquals(response.status_code, 200)
        form = response.context['form']
        self.assertTrue(form.is_valid(), form.errors)
        unverified = set(response.context['unverified'])
        unapproved = set(response.context['unapproved'])
        user_a, user_b = unapproved_entry_a.user, unapproved_entry_b.user
        expected_unapproved = set([
            (user_a.pk, user_a.first_name, user_a.last_name),
            (user_b.pk, user_b.first_name, user_b.last_name),
        ])
        self.assertEquals(unverified, set())
        self.assertEquals(unapproved, expected_unapproved)

    def test_no_statuses(self):
        self.get_kwargs.pop('statuses')
        response = self._get()
        self.assertEquals(response.status_code, 200)
        form = response.context['form']
        self.assertTrue(form.is_valid(), form.errors)
        self.assertEquals(response.context['project_totals'].count(), 0)

    def test_to_date_required(self):
        """to_date is required."""
        self.get_kwargs['to_date'] = ''
        response = self._get()
        self.assertEquals(response.status_code, 200)
        form = response.context['form']
        self.assertFalse(form.is_valid(), form.errors)
        # The number of projects should be 1 because entry3 has billable=False
        self.assertEquals(response.context['project_totals'].count(), 0)

    def test_from_date(self):
        from_date = utils.add_timezone(datetime.datetime(2011, 1, 1, 0, 0, 0))
        self.get_kwargs['from_date'] = from_date.strftime(DATE_FORM_FORMAT)
        response = self._get()
        self.assertEquals(response.status_code, 200)
        form = response.context['form']
        self.assertTrue(form.is_valid(), form.errors)
        # From date filters out one entry
        self.assertEquals(response.context['project_totals'].count(), 1)
        # Verify that the date on the mark as invoiced links will be correct
        self.assertEquals(response.context['to_date'], self.to_date.date())
        self.assertEquals(response.context['from_date'], from_date.date())

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url

from timepiece.contracts import views


urlpatterns = patterns('',
    # Contracts
    url(r'^contract/$',
        views.ContractList.as_view(),
        name='list_contracts'),
    url(r'^contract/(?P<contract_id>\d+)/$',
        views.ContractDetail.as_view(),
        name='view_contract'),

    # Invoices
    url(r'invoice/$',
        views.ListInvoices.as_view(),
        name='list_invoices'),
    url(r'invoice/outstanding/$',
        views.list_outstanding_invoices,
        name='list_outstanding_invoices'),
    url(r'invoice/create/$',
        views.create_invoice,
        name='create_invoice'),
    url(r'invoice/(?P<invoice_id>\d+)/$',
        views.InvoiceDetail.as_view(),
        name='view_invoice'),
    url(r'invoice/(?P<invoice_id>\d+)/csv/$',
        views.InvoiceDetailCSV.as_view(),
        name='view_invoice_csv'),
    url(r'invoice/(?P<invoice_id>\d+)/entries/$',
        views.InvoiceEntriesDetail.as_view(),
        name='view_invoice_entries'),
    url(r'invoice/(?P<invoice_id>\d+)/entries/(?P<entry_id>\d+)/remove/$',
        views.delete_invoice_entry,
        name='delete_invoice_entry'),
    url(r'invoice/(?P<invoice_id>\d+)/edit/$',
        views.InvoiceEdit.as_view(),
        name='edit_invoice'),
    url(r'invoice/(?P<invoice_id>\d+)/delete/$',
        views.InvoiceDelete.as_view(),
        name='delete_invoice'),
)

########NEW FILE########
__FILENAME__ = views
import datetime
from dateutil.relativedelta import relativedelta

from django.contrib.auth.decorators import login_required, permission_required
from django.contrib import messages
from django.core.urlresolvers import reverse
from django.db import transaction, DatabaseError
from django.db.models import Sum, Q
from django.http import HttpResponseRedirect, Http404, HttpResponseForbidden
from django.shortcuts import get_object_or_404, redirect, render
from django.views.generic import ListView, DetailView

from timepiece import utils
from timepiece.templatetags.timepiece_tags import seconds_to_hours
from timepiece.utils.csv import CSVViewMixin
from timepiece.utils.search import SearchListView
from timepiece.utils.views import cbv_decorator

from timepiece.contracts.forms import InvoiceForm, OutstandingHoursFilterForm
from timepiece.contracts.models import ProjectContract, HourGroup, EntryGroup
from timepiece.entries.models import Project, Entry


@cbv_decorator(permission_required('contracts.add_projectcontract'))
class ContractDetail(DetailView):
    template_name = 'timepiece/contract/view.html'
    model = ProjectContract
    context_object_name = 'contract'
    pk_url_kwarg = 'contract_id'

    def get_context_data(self, *args, **kwargs):
        if 'today' not in kwargs:
            kwargs['today'] = datetime.date.today()
        if 'warning_date' not in kwargs:
            kwargs['warning_date'] = datetime.date.today() + relativedelta(weeks=2)
        return super(ContractDetail, self).get_context_data(*args, **kwargs)


@cbv_decorator(permission_required('contracts.add_projectcontract'))
class ContractList(ListView):
    template_name = 'timepiece/contract/list.html'
    model = ProjectContract
    context_object_name = 'contracts'
    queryset = ProjectContract.objects.filter(
            status=ProjectContract.STATUS_CURRENT).order_by('name')

    def get_context_data(self, *args, **kwargs):
        if 'today' not in kwargs:
            kwargs['today'] = datetime.date.today()
        if 'warning_date' not in kwargs:
            kwargs['warning_date'] = datetime.date.today() + relativedelta(weeks=2)
        kwargs['max_work_fraction'] = max(
            [0.0] + [c.fraction_hours for c in self.queryset.all()])
        kwargs['max_schedule_fraction'] = max(
            [0.0] + [c.fraction_schedule for c in self.queryset.all()])
        return super(ContractList, self).get_context_data(*args, **kwargs)


@login_required
@transaction.commit_on_success
def create_invoice(request):
    pk = request.GET.get('project', None)
    to_date = request.GET.get('to_date', None)
    if not (pk and to_date):
        raise Http404
    from_date = request.GET.get('from_date', None)
    if not request.user.has_perm('crm.generate_project_invoice'):
        return HttpResponseForbidden('Forbidden')
    try:
        to_date = utils.add_timezone(
            datetime.datetime.strptime(to_date, '%Y-%m-%d'))
        if from_date:
            from_date = utils.add_timezone(
                datetime.datetime.strptime(from_date, '%Y-%m-%d'))
    except (ValueError, OverflowError):
        raise Http404
    project = get_object_or_404(Project, pk=pk)
    initial = {
        'project': project,
        'user': request.user,
        'from_date': from_date,
        'to_date': to_date,
    }
    entries_query = {
        'status': Entry.APPROVED,
        'end_time__lt': to_date + relativedelta(days=1),
        'project__id': project.id
    }
    if from_date:
        entries_query.update({'end_time__gte': from_date})
    invoice_form = InvoiceForm(request.POST or None, initial=initial)
    if request.POST and invoice_form.is_valid():
        entries = Entry.no_join.filter(**entries_query)
        if entries.exists():
            # LOCK the entries until our transaction completes - nobody
            # else will be able to lock or change them - see
            # https://docs.djangoproject.com/en/1.4/ref/models/querysets/#select-for-update
            # (This feature requires Django 1.4.)
            # If more than one request is trying to create an invoice from
            # these same entries, then the second one to get to this line will
            # throw a DatabaseError.  That can happen if someone double-clicks
            # the Create Invoice button.
            try:
                entries.select_for_update(nowait=True)
            except DatabaseError:
                # Whoops, we lost the race
                messages.add_message(request, messages.ERROR,
                                     "Lock error trying to get entries")
            else:
                # We got the lock, we can carry on
                invoice = invoice_form.save()
                entries.update(status=invoice.status,
                               entry_group=invoice)
                messages.add_message(request, messages.INFO,
                                     "Invoice created")
                return HttpResponseRedirect(reverse('view_invoice',
                                                    args=[invoice.pk]))
        else:
            messages.add_message(request, messages.ERROR,
                                 "No entries for invoice")
    else:
        entries = Entry.objects.filter(**entries_query)
        entries = entries.order_by('start_time')
        if not entries:
            raise Http404

    billable_entries = entries.filter(activity__billable=True) \
        .select_related()
    nonbillable_entries = entries.filter(activity__billable=False) \
        .select_related()
    return render(request, 'timepiece/invoice/create.html', {
        'invoice_form': invoice_form,
        'billable_entries': billable_entries,
        'nonbillable_entries': nonbillable_entries,
        'project': project,
        'billable_totals': HourGroup.objects
            .summaries(billable_entries),
        'nonbillable_totals': HourGroup.objects
            .summaries(nonbillable_entries),
        'from_date': from_date,
        'to_date': to_date,
    })


@permission_required('contracts.change_entrygroup')
def list_outstanding_invoices(request):
    form = OutstandingHoursFilterForm(request.GET or None)
    # Determine the query to make based on the form
    if form.is_valid() or not form.is_bound:
        form_data = form.get_form_data()
        # Adjust to_date so the query includes all of the last day
        to_date = form_data['to_date'] + relativedelta(days=1)
        from_date = form_data['from_date']
        statuses = form_data['statuses']
        dates = Q()
        dates &= Q(end_time__gte=from_date) if from_date else Q()
        dates &= Q(end_time__lt=to_date) if to_date else Q()
        billable = Q(project__type__billable=True, project__status__billable=True)
        entry_status = Q(status=Entry.APPROVED)
        project_status = Q(project__status__in=statuses)\
                if statuses is not None else Q()
        # Calculate hours for each project
        ordering = ('project__type__label', 'project__status__label',
                'project__business__name', 'project__name', 'status')
        project_totals = Entry.objects.filter(
            dates, billable, entry_status, project_status).order_by(*ordering)
        # Find users with unverified/unapproved entries to warn invoice creator
        date_range_entries = Entry.objects.filter(dates)
        user_values = ['user__pk', 'user__first_name', 'user__last_name']
        unverified = date_range_entries.filter(
            status=Entry.UNVERIFIED).values_list(*user_values).order_by('user__first_name').distinct()
        unapproved = date_range_entries.filter(
            status=Entry.VERIFIED).values_list(*user_values).order_by('user__first_name').distinct()
    else:
        project_totals = unverified = unapproved = Entry.objects.none()
    return render(request, 'timepiece/invoice/outstanding.html', {
        'date_form': form,
        'project_totals': project_totals,
        'unverified': unverified,
        'unapproved': unapproved,
        'to_date': form.get_to_date(),
        'from_date': form.get_from_date(),
    })


@cbv_decorator(permission_required('contracts.add_entrygroup'))
class ListInvoices(SearchListView):
    model = EntryGroup
    search_fields = ['user__username__icontains', 'project__name__icontains',
            'comments__icontains', 'number__icontains']
    template_name = 'timepiece/invoice/list.html'


@cbv_decorator(permission_required('contracts.change_entrygroup'))
class InvoiceDetail(DetailView):
    template_name = 'timepiece/invoice/view.html'
    model = EntryGroup
    context_object_name = 'invoice'
    pk_url_kwarg = 'invoice_id'

    def get_context_data(self, **kwargs):
        context = super(InvoiceDetail, self).get_context_data(**kwargs)
        invoice = context['invoice']
        billable_entries = invoice.entries.filter(activity__billable=True)\
                                          .order_by('start_time')\
                                          .select_related()
        nonbillable_entries = invoice.entries.filter(activity__billable=False)\
                                             .order_by('start_time')\
                                             .select_related()
        return {
            'invoice': invoice,
            'billable_entries': billable_entries,
            'billable_totals': HourGroup.objects
                                        .summaries(billable_entries),
            'nonbillable_entries': nonbillable_entries,
            'nonbillable_totals': HourGroup.objects
                                           .summaries(nonbillable_entries),
            'from_date': invoice.start,
            'to_date': invoice.end,
            'project': invoice.project,
        }


class InvoiceEntriesDetail(InvoiceDetail):
    template_name = 'timepiece/invoice/view_entries.html'

    def get_context_data(self, **kwargs):
        context = super(InvoiceEntriesDetail, self).get_context_data(**kwargs)
        billable_entries = context['billable_entries']
        nonbillable_entries = context['nonbillable_entries']
        context.update({
            'billable_total': billable_entries \
                              .aggregate(hours=Sum('hours'))['hours'],
            'nonbillable_total': nonbillable_entries\
                                 .aggregate(hours=Sum('hours'))['hours'],
        })
        return context


class InvoiceDetailCSV(CSVViewMixin, InvoiceDetail):

    def get_filename(self, context):
        invoice = context['invoice']
        project = str(invoice.project).replace(' ', '_')
        end_day = invoice.end.strftime('%m-%d-%Y')
        return 'Invoice-{0}-{1}'.format(project, end_day)

    def convert_context_to_csv(self, context):
        rows = []
        rows.append([
            'Date',
            'Weekday',
            'Name',
            'Location',
            'Time In',
            'Time Out',
            'Breaks',
            'Hours',
        ])
        for entry in context['billable_entries']:
            data = [
                entry.start_time.strftime('%x'),
                entry.start_time.strftime('%A'),
                entry.user.get_name_or_username(),
                entry.location,
                entry.start_time.strftime('%X'),
                entry.end_time.strftime('%X'),
                seconds_to_hours(entry.seconds_paused),
                entry.hours,
            ]
            rows.append(data)
        total = context['billable_entries'].aggregate(hours=Sum('hours'))['hours']
        rows.append(('', '', '', '', '', '', 'Total:', total))
        return rows


class InvoiceEdit(InvoiceDetail):
    template_name = 'timepiece/invoice/edit.html'

    def get_context_data(self, **kwargs):
        context = super(InvoiceEdit, self).get_context_data(**kwargs)
        invoice_form = InvoiceForm(instance=self.object)
        context.update({
            'invoice_form': invoice_form,
        })
        return context

    def post(self, request, **kwargs):
        pk = kwargs.get(self.pk_url_kwarg)
        invoice = get_object_or_404(EntryGroup, pk=pk)
        self.object = invoice
        initial = {
            'project': invoice.project,
            'user': request.user,
            'from_date': invoice.start,
            'to_date': invoice.end,
        }
        invoice_form = InvoiceForm(request.POST,
                                   initial=initial,
                                   instance=invoice)
        if invoice_form.is_valid():
            invoice_form.save()
            return HttpResponseRedirect(reverse('view_invoice', kwargs=kwargs))
        else:
            context = super(InvoiceEdit, self).get_context_data(**kwargs)
            context.update({
                'invoice_form': invoice_form,
            })
            return self.render_to_response(context)


class InvoiceDelete(InvoiceDetail):
    template_name = 'timepiece/invoice/delete.html'

    def post(self, request, **kwargs):
        pk = kwargs.get(self.pk_url_kwarg)
        invoice = get_object_or_404(EntryGroup, pk=pk)
        if 'delete' in request.POST:
            invoice.delete()
            return HttpResponseRedirect(reverse('list_invoices'))
        else:
            return redirect(reverse('edit_invoice', kwargs=kwargs))


@permission_required('contracts.change_entrygroup')
def delete_invoice_entry(request, invoice_id, entry_id):
    invoice = get_object_or_404(EntryGroup, pk=invoice_id)
    entry = get_object_or_404(Entry, pk=entry_id)
    if request.POST:
        entry.status = Entry.APPROVED
        entry.entry_group = None
        entry.save()
        url = reverse('edit_invoice', args=(invoice_id,))
        return HttpResponseRedirect(url)
    return render(request, 'timepiece/invoice/delete_entry.html', {
        'invoice': invoice,
        'entry': entry,
    })

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

from timepiece.crm.models import (Attribute, Business, Project,
        RelationshipType, UserProfile)


class AttributeAdmin(admin.ModelAdmin):
    search_fields = ('label', 'type')
    list_display = ('label', 'type', 'enable_timetracking', 'billable')
    list_filter = ('type', 'enable_timetracking', 'billable')
    ordering = ('type', 'sort_order')  # Django honors only first field.


class BusinessAdmin(admin.ModelAdmin):
    list_display = ['name', 'short_name']
    search_fields = ['name', 'short_name']


class ProjectAdmin(admin.ModelAdmin):
    raw_id_fields = ('business',)
    list_display = ('name', 'business', 'point_person', 'status', 'type')
    list_filter = ('type', 'status')
    search_fields = ('name', 'business__name', 'point_person__username',
            'point_person__first_name', 'point_person__last_name',
            'description')


class RelationshipTypeAdmin(admin.ModelAdmin):
    pass


class UserProfileAdmin(admin.ModelAdmin):
    list_display = ('user', 'hours_per_week')


admin.site.register(Attribute, AttributeAdmin)
admin.site.register(Business, BusinessAdmin)
admin.site.register(Project, ProjectAdmin)
admin.site.register(RelationshipType, RelationshipTypeAdmin)
admin.site.register(UserProfile, UserProfileAdmin)

########NEW FILE########
__FILENAME__ = forms
from django import forms
from django.contrib.auth.forms import UserCreationForm, UserChangeForm
from django.contrib.auth.models import User

from selectable import forms as selectable

from timepiece.utils.search import SearchForm

from timepiece.crm.lookups import (BusinessLookup, ProjectLookup, UserLookup,
        QuickLookup)
from timepiece.crm.models import (Attribute, Business, Project,
        ProjectRelationship)


class CreateEditBusinessForm(forms.ModelForm):

    class Meta:
        model = Business
        fields = ('name', 'short_name', 'email', 'description', 'notes')


class CreateEditProjectForm(forms.ModelForm):
    business = selectable.AutoCompleteSelectField(BusinessLookup)
    business.widget.attrs['placeholder'] = 'Search'

    class Meta:
        model = Project
        fields = ('name', 'business', 'tracker_url', 'point_person', 'type',
                'status', 'activity_group', 'description')


class CreateUserForm(UserCreationForm):

    class Meta:
        model = User
        fields = ('username', 'first_name', 'last_name', 'email', 'is_active',
                'is_staff', 'groups')

    def __init__(self, *args, **kwargs):
        super(CreateUserForm, self).__init__(*args, **kwargs)
        self.fields['groups'].widget = forms.CheckboxSelectMultiple()
        self.fields['groups'].help_text = None

    def save(self, commit=True):
        user = super(CreateUserForm, self).save(commit)
        if commit:
            self.save_m2m()
        return user


class EditProjectRelationshipForm(forms.ModelForm):

    class Meta:
        model = ProjectRelationship
        fields = ('types',)

    def __init__(self, *args, **kwargs):
        super(EditProjectRelationshipForm, self).__init__(*args, **kwargs)
        self.fields['types'].widget = forms.CheckboxSelectMultiple(
                choices=self.fields['types'].choices)


class EditUserForm(UserChangeForm):
    password1 = forms.CharField(required=False, max_length=36,
            label='Password', widget=forms.PasswordInput(render_value=False))
    password2 = forms.CharField(required=False, max_length=36,
            label='Repeat Password',
            widget=forms.PasswordInput(render_value=False))

    class Meta:
        model = User
        fields = ('username', 'first_name', 'last_name', 'email', 'is_active',
                'is_staff', 'groups')

    def __init__(self, *args, **kwargs):
        super(EditUserForm, self).__init__(*args, **kwargs)
        self.fields['groups'].widget = forms.CheckboxSelectMultiple()
        self.fields['groups'].help_text = None

        # In 1.4 this field is created even if it is excluded in Meta.
        if 'password' in self.fields:
            del(self.fields['password'])

    def clean(self):
        super(EditUserForm, self).clean()
        password1 = self.cleaned_data.get('password1', None)
        password2 = self.cleaned_data.get('password2', None)
        if password1 and password1 != password2:
            raise forms.ValidationError('Passwords must match.')
        return self.cleaned_data

    def save(self, commit=True):
        instance = super(EditUserForm, self).save(commit=False)
        password1 = self.cleaned_data.get('password1', None)
        if password1:
            instance.set_password(password1)
        if commit:
            instance.save()
            self.save_m2m()
        return instance


class EditUserSettingsForm(forms.ModelForm):

    class Meta:
        model = User
        fields = ('first_name', 'last_name', 'email')

    def __init__(self, *args, **kwargs):
        super(EditUserSettingsForm, self).__init__(*args, **kwargs)
        for name in self.fields:
            self.fields[name].required = True


class ProjectSearchForm(SearchForm):
    status = forms.ChoiceField(required=False, choices=[], label='')

    def __init__(self, *args, **kwargs):
        super(ProjectSearchForm, self).__init__(*args, **kwargs)
        statuses = Attribute.statuses.all()
        choices = [('', 'Any Status')] + [(a.pk, a.label) for a in statuses]
        self.fields['status'].choices = choices


class QuickSearchForm(forms.Form):
    quick_search = selectable.AutoCompleteSelectField(QuickLookup, required=False)
    quick_search.widget.attrs['placeholder'] = 'Search'

    def clean_quick_search(self):
        item = self.cleaned_data['quick_search']
        if not item:
            msg = 'No user, business, or project matches your query.'
            raise forms.ValidationError(msg)
        return item

    def get_result(self):
        return self.cleaned_data['quick_search'].get_absolute_url()


class SelectProjectForm(forms.Form):
    project = selectable.AutoCompleteSelectField(ProjectLookup, label='')
    project.widget.attrs['placeholder'] = 'Add Project'

    def get_project(self):
        return self.cleaned_data['project'] if self.is_valid() else None


class SelectUserForm(forms.Form):
    user = selectable.AutoCompleteSelectField(UserLookup, label='')
    user.widget.attrs['placeholder'] = 'Add User'

    def get_user(self):
        return self.cleaned_data['user'] if self.is_valid() else None

########NEW FILE########
__FILENAME__ = lookups
from collections import namedtuple

from django.contrib.auth.models import User
from django.utils.safestring import mark_safe

from selectable.base import LookupBase
from selectable.base import ModelLookup
from selectable.registry import registry

from timepiece.crm.models import Project, Business


class ProjectLookup(ModelLookup):
    model = Project
    search_fields = ('name__icontains', 'business__name__icontains',
            'business__short_name__icontains')

    def get_item_label(self, project):
        return mark_safe(u'<span class="project">%s</span>' %
                self.get_item_value(project))

    def get_item_value(self, project):
        return project.name if project else ''


class BusinessLookup(ModelLookup):
    model = Business
    search_fields = ('name__icontains', 'short_name__icontains')

    def get_item_label(self, business):
        return mark_safe(u'<span class="business">%s</span>' %
                self.get_item_value(business))

    def get_item_value(self, business):
        return business.name if business else ''


class UserLookup(ModelLookup):
    model = User
    search_fields = ('username__icontains', 'first_name__icontains',
            'last_name__icontains', 'email__icontains')

    def get_query(self, request, q):
        return super(UserLookup, self).get_query(request, q).order_by('last_name')

    def get_item_label(self, user):
        return mark_safe(u'<span class="user">%s</span>' %
                self.get_item_value(user))

    def get_item_value(self, user):
        return user.get_name_or_username() if user else ''


class QuickLookup(LookupBase):

    def __init__(self, *args, **kwargs):
        self.lookups = {
            'user': UserLookup(),
            'project': ProjectLookup(),
            'business': BusinessLookup(),
        }
        super(QuickLookup, self).__init__(*args, **kwargs)

    def get_query(self, request, q):
        results = []
        SearchResult = namedtuple('SearchResult', ['result_type', 'item', 'label', 'value'])

        for result_type, lookup in self.lookups.items():
            for item in lookup.get_query(request, q)[:10]:
                label = lookup.get_item_label(item)
                value = lookup.get_item_value(item)
                results.append(SearchResult(result_type, item, label, value))

        results.sort(lambda a, b: cmp(a.value, b.value))
        return results

    def get_item_label(self, item):
        return item.label

    def get_item_id(self, item):
        return '{0}-{1}'.format(item.result_type, item.item.pk)

    def get_item(self, value):
        try:
            result_type, pk = value.split('-', 1)
            return self.lookups[result_type].get_item(pk)
        except (ValueError, KeyError):
            return None

    def get_item_value(self, item):
        return item.value if item else ''


registry.register(BusinessLookup)
registry.register(ProjectLookup)
registry.register(UserLookup)
registry.register(QuickLookup)

########NEW FILE########
__FILENAME__ = 0001_initial
# -*- coding: utf-8 -*-
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding model 'UserProfile'
        db.create_table('timepiece_userprofile', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('user', self.gf('django.db.models.fields.related.OneToOneField')(related_name='profile', unique=True, to=orm['auth.User'])),
            ('hours_per_week', self.gf('django.db.models.fields.DecimalField')(default=40, max_digits=8, decimal_places=2)),
        ))
        db.send_create_signal('crm', ['UserProfile'])

        # Adding model 'Attribute'
        db.create_table('timepiece_attribute', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('type', self.gf('django.db.models.fields.CharField')(max_length=32)),
            ('label', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('sort_order', self.gf('django.db.models.fields.SmallIntegerField')(null=True, blank=True)),
            ('enable_timetracking', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('billable', self.gf('django.db.models.fields.BooleanField')(default=False)),
        ))
        db.send_create_signal('crm', ['Attribute'])

        # Adding unique constraint on 'Attribute', fields ['type', 'label']
        db.create_unique('timepiece_attribute', ['type', 'label'])

        # Adding model 'Business'
        db.create_table('timepiece_business', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('short_name', self.gf('django.db.models.fields.CharField')(max_length=255, blank=True)),
            ('email', self.gf('django.db.models.fields.EmailField')(max_length=75, blank=True)),
            ('description', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('notes', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('external_id', self.gf('django.db.models.fields.CharField')(max_length=32, blank=True)),
        ))
        db.send_create_signal('crm', ['Business'])

        # Adding model 'Project'
        db.create_table('timepiece_project', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('tracker_url', self.gf('django.db.models.fields.CharField')(default='', max_length=255, blank=True)),
            ('business', self.gf('django.db.models.fields.related.ForeignKey')(related_name='new_business_projects', to=orm['crm.Business'])),
            ('point_person', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['auth.User'])),
            ('activity_group', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='activity_group', null=True, to=orm['entries.ActivityGroup'])),
            ('type', self.gf('django.db.models.fields.related.ForeignKey')(related_name='projects_with_type', to=orm['crm.Attribute'])),
            ('status', self.gf('django.db.models.fields.related.ForeignKey')(related_name='projects_with_status', to=orm['crm.Attribute'])),
            ('description', self.gf('django.db.models.fields.TextField')()),
        ))
        db.send_create_signal('crm', ['Project'])

        # Adding model 'RelationshipType'
        db.create_table('timepiece_relationshiptype', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.CharField')(unique=True, max_length=255)),
            ('slug', self.gf('django.db.models.fields.SlugField')(max_length=255)),
        ))
        db.send_create_signal('crm', ['RelationshipType'])

        # Adding model 'ProjectRelationship'
        db.create_table('timepiece_projectrelationship', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(related_name='project_relationships', to=orm['auth.User'])),
            ('project', self.gf('django.db.models.fields.related.ForeignKey')(related_name='project_relationships', to=orm['crm.Project'])),
        ))
        db.send_create_signal('crm', ['ProjectRelationship'])

        # Adding unique constraint on 'ProjectRelationship', fields ['user', 'project']
        db.create_unique('timepiece_projectrelationship', ['user_id', 'project_id'])

        # Adding M2M table for field types on 'ProjectRelationship'
        db.create_table('timepiece_projectrelationship_types', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('projectrelationship', models.ForeignKey(orm['crm.projectrelationship'], null=False)),
            ('relationshiptype', models.ForeignKey(orm['crm.relationshiptype'], null=False))
        ))
        db.create_unique('timepiece_projectrelationship_types', ['projectrelationship_id', 'relationshiptype_id'])


    def backwards(self, orm):
        # Removing unique constraint on 'ProjectRelationship', fields ['user', 'project']
        db.delete_unique('timepiece_projectrelationship', ['user_id', 'project_id'])

        # Removing unique constraint on 'Attribute', fields ['type', 'label']
        db.delete_unique('timepiece_attribute', ['type', 'label'])

        # Deleting model 'UserProfile'
        db.delete_table('timepiece_userprofile')

        # Deleting model 'Attribute'
        db.delete_table('timepiece_attribute')

        # Deleting model 'Business'
        db.delete_table('timepiece_business')

        # Deleting model 'Project'
        db.delete_table('timepiece_project')

        # Deleting model 'RelationshipType'
        db.delete_table('timepiece_relationshiptype')

        # Deleting model 'ProjectRelationship'
        db.delete_table('timepiece_projectrelationship')

        # Removing M2M table for field types on 'ProjectRelationship'
        db.delete_table('timepiece_projectrelationship_types')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'crm.attribute': {
            'Meta': {'ordering': "('sort_order',)", 'unique_together': "(('type', 'label'),)", 'object_name': 'Attribute', 'db_table': "'timepiece_attribute'"},
            'billable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'enable_timetracking': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'label': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'sort_order': ('django.db.models.fields.SmallIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'type': ('django.db.models.fields.CharField', [], {'max_length': '32'})
        },
        'crm.business': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Business', 'db_table': "'timepiece_business'"},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'external_id': ('django.db.models.fields.CharField', [], {'max_length': '32', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'notes': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'short_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'})
        },
        'crm.project': {
            'Meta': {'ordering': "('name', 'status', 'type')", 'object_name': 'Project', 'db_table': "'timepiece_project'"},
            'activity_group': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'activity_group'", 'null': 'True', 'to': "orm['entries.ActivityGroup']"}),
            'business': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'new_business_projects'", 'to': "orm['crm.Business']"}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'point_person': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'status': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'projects_with_status'", 'to': "orm['crm.Attribute']"}),
            'tracker_url': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '255', 'blank': 'True'}),
            'type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'projects_with_type'", 'to': "orm['crm.Attribute']"}),
            'users': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'user_projects'", 'symmetrical': 'False', 'through': "orm['crm.ProjectRelationship']", 'to': "orm['auth.User']"})
        },
        'crm.projectrelationship': {
            'Meta': {'unique_together': "(('user', 'project'),)", 'object_name': 'ProjectRelationship', 'db_table': "'timepiece_projectrelationship'"},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'project': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'project_relationships'", 'to': "orm['crm.Project']"}),
            'types': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'project_relationships'", 'blank': 'True', 'to': "orm['crm.RelationshipType']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'project_relationships'", 'to': "orm['auth.User']"})
        },
        'crm.relationshiptype': {
            'Meta': {'object_name': 'RelationshipType', 'db_table': "'timepiece_relationshiptype'"},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255'})
        },
        'crm.userprofile': {
            'Meta': {'object_name': 'UserProfile', 'db_table': "'timepiece_userprofile'"},
            'hours_per_week': ('django.db.models.fields.DecimalField', [], {'default': '40', 'max_digits': '8', 'decimal_places': '2'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.OneToOneField', [], {'related_name': "'profile'", 'unique': 'True', 'to': "orm['auth.User']"})
        },
        'entries.activity': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Activity', 'db_table': "'timepiece_activity'"},
            'billable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'code': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '5'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'entries.activitygroup': {
            'Meta': {'object_name': 'ActivityGroup', 'db_table': "'timepiece_activitygroup'"},
            'activities': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'activity_group'", 'symmetrical': 'False', 'to': "orm['entries.Activity']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        }
    }

    complete_apps = ['crm']

########NEW FILE########
__FILENAME__ = models
from django.contrib.auth.models import User
from django.core.urlresolvers import reverse
from django.db import models
from django.db.models import get_model

from timepiece.utils import get_active_entry


# Add a utility method to the User class that will tell whether or not a
# particular user has any unclosed entries
_clocked_in = lambda user: bool(get_active_entry(user))
User.add_to_class('clocked_in', property(_clocked_in))


# Utility method to get user's name, falling back to username.
_get_name_or_username = lambda user: user.get_full_name() or user.username
User.add_to_class('get_name_or_username', _get_name_or_username)


_get_absolute_url = lambda user: reverse('view_user', args=(user.pk,))
User.add_to_class('get_absolute_url', _get_absolute_url)


class UserProfile(models.Model):
    user = models.OneToOneField(User, unique=True, related_name='profile')
    hours_per_week = models.DecimalField(max_digits=8, decimal_places=2,
            default=40)

    class Meta:
        db_table = 'timepiece_userprofile'  # Using legacy table name.

    def __unicode__(self):
        return unicode(self.user)


class TypeAttributeManager(models.Manager):
    """Object manager for type attributes."""

    def get_query_set(self):
        qs = super(TypeAttributeManager, self).get_query_set()
        return qs.filter(type=Attribute.PROJECT_TYPE)


class StatusAttributeManager(models.Manager):
    """Object manager for status attributes."""

    def get_query_set(self):
        qs = super(StatusAttributeManager, self).get_query_set()
        return qs.filter(type=Attribute.PROJECT_STATUS)


class Attribute(models.Model):
    PROJECT_TYPE = 'project-type'
    PROJECT_STATUS = 'project-status'
    ATTRIBUTE_TYPES = {
        PROJECT_TYPE: 'Project Type',
        PROJECT_STATUS: 'Project Status',
    }
    SORT_ORDER_CHOICES = [(x, x) for x in xrange(-20, 21)]

    type = models.CharField(max_length=32, choices=ATTRIBUTE_TYPES.items())
    label = models.CharField(max_length=255)
    sort_order = models.SmallIntegerField(null=True, blank=True,
            choices=SORT_ORDER_CHOICES)
    enable_timetracking = models.BooleanField(default=False,
            help_text='Enable time tracking functionality for projects '
            'with this type or status.')
    billable = models.BooleanField(default=False)

    objects = models.Manager()
    types = TypeAttributeManager()
    statuses = StatusAttributeManager()

    class Meta:
        db_table = 'timepiece_attribute'  # Using legacy table name.
        unique_together = ('type', 'label')
        ordering = ('sort_order',)

    def __unicode__(self):
        return self.label


class Business(models.Model):
    name = models.CharField(max_length=255)
    short_name = models.CharField(max_length=255, blank=True)
    email = models.EmailField(blank=True)
    description = models.TextField(blank=True)
    notes = models.TextField(blank=True)
    external_id = models.CharField(max_length=32, blank=True)

    class Meta:
        db_table = 'timepiece_business'  # Using legacy table name.
        ordering = ('name',)
        verbose_name_plural = 'Businesses'
        permissions = (
            ('view_business', 'Can view businesses'),
        )

    def __unicode__(self):
        return self.get_display_name()

    def get_absolute_url(self):
        return reverse('view_business', args=(self.pk,))

    def get_display_name(self):
        return self.short_name or self.name


class TrackableProjectManager(models.Manager):

    def get_query_set(self):
        return super(TrackableProjectManager, self).get_query_set().filter(
            status__enable_timetracking=True,
            type__enable_timetracking=True,
        )


class Project(models.Model):
    name = models.CharField(max_length=255)
    tracker_url = models.CharField(max_length=255, blank=True, null=False,
            default="")
    business = models.ForeignKey(Business,
            related_name='new_business_projects')
    point_person = models.ForeignKey(User, limit_choices_to={'is_staff': True})
    users = models.ManyToManyField(User, related_name='user_projects',
            through='ProjectRelationship')
    activity_group = models.ForeignKey('entries.ActivityGroup',
            related_name='activity_group', null=True, blank=True,
            verbose_name='restrict activities to')
    type = models.ForeignKey(Attribute,
            limit_choices_to={'type': 'project-type'},
            related_name='projects_with_type')
    status = models.ForeignKey(Attribute,
            limit_choices_to={'type': 'project-status'},
            related_name='projects_with_status')
    description = models.TextField()

    objects = models.Manager()
    trackable = TrackableProjectManager()

    class Meta:
        db_table = 'timepiece_project'  # Using legacy table name.
        ordering = ('name', 'status', 'type',)
        permissions = (
            ('view_project', 'Can view project'),
            ('email_project_report', 'Can email project report'),
            ('view_project_time_sheet', 'Can view project time sheet'),
            ('export_project_time_sheet', 'Can export project time sheet'),
            ('generate_project_invoice', 'Can generate project invoice'),
        )

    def __unicode__(self):
        return '{0} ({1})'.format(self.name, self.business.get_display_name())

    @property
    def billable(self):
        return self.type.billable

    def get_absolute_url(self):
        return reverse('view_project', args=(self.pk,))

    def get_active_contracts(self):
        """Returns all associated contracts which are not marked complete."""
        ProjectContract = get_model('contracts', 'ProjectContract')
        return self.contracts.exclude(status=ProjectContract.STATUS_COMPLETE)


class RelationshipType(models.Model):
    name = models.CharField(max_length=255, unique=True)
    slug = models.SlugField(max_length=255)

    class Meta:
        db_table = 'timepiece_relationshiptype'  # Using legacy table name.

    def __unicode__(self):
        return self.name


class ProjectRelationship(models.Model):
    types = models.ManyToManyField(RelationshipType, blank=True,
        related_name='project_relationships')
    user = models.ForeignKey(User, related_name='project_relationships')
    project = models.ForeignKey(Project, related_name='project_relationships')

    class Meta:
        db_table = 'timepiece_projectrelationship'  # Using legacy table name.
        unique_together = ('user', 'project')

    def __unicode__(self):
        return "{project}'s relationship to {user}".format(
            project=self.project.name,
            user=self.user.get_name_or_username(),
        )

########NEW FILE########
__FILENAME__ = test_businesses
from django.core.urlresolvers import reverse_lazy
from django.test import TestCase

from timepiece.tests import factories
from timepiece.tests.base import ViewTestMixin

from ..models import Business


class TestCreateBusiness(ViewTestMixin, TestCase):
    url_name = 'create_business'
    template_name = 'timepiece/business/create_edit.html'
    factory = factories.Business
    model = Business
    permissions = ('crm.add_business',)

    def setUp(self):
        super(TestCreateBusiness, self).setUp()
        self.user = factories.User(permissions=self.permissions)
        self.login_user(self.user)
        self.post_data = {
            'name': 'Business',
            'email': 'email@email.com',
            'description': 'Described',
            'notes': 'Notes',
        }

    def test_get_no_permission(self):
        """Permission is required for this view."""
        self.user.user_permissions.clear()
        response = self._get()
        self.assertRedirectsToLogin(response)
        self.assertEquals(self.model.objects.count(), 0)

    def test_post_no_permission(self):
        """Permission is required for this view."""
        self.user.user_permissions.clear()
        response = self._post()
        self.assertRedirectsToLogin(response)
        self.assertEquals(self.model.objects.count(), 0)

    def test_get(self):
        """GET should return the page with an unbound form."""
        response = self._get()
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertTrue('form' in response.context)
        self.assertFalse(response.context['form'].is_bound)
        self.assertEquals(self.model.objects.count(), 0)

    def test_post_valid(self):
        """POST should create a new object and redirect."""
        response = self._post()
        self.assertEquals(self.model.objects.count(), 1)
        obj = self.model.objects.get()
        self.assertRedirectsNoFollow(response, obj.get_absolute_url())
        self.assertEquals(obj.name, self.post_data['name'])
        self.assertEquals(obj.email, self.post_data['email'])
        self.assertEquals(obj.description, self.post_data['description'])
        self.assertEquals(obj.notes, self.post_data['notes'])

    def test_post_invalid(self):
        """Invalid POST should not create a new object."""
        self.post_data['name'] = ''
        response = self._post()
        self.assertEquals(self.model.objects.count(), 0)
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertTrue('form' in response.context)
        self.assertTrue(response.context['form'].is_bound)
        self.assertFalse(response.context['form'].is_valid())


class TestDeleteBusiness(ViewTestMixin, TestCase):
    url_name = 'delete_business'
    template_name = 'timepiece/delete_object.html'
    model = Business
    factory = factories.Business
    success_url = reverse_lazy('list_businesses')
    permissions = ('crm.delete_business',)
    pk_url_kwarg = 'business_id'

    def setUp(self):
        super(TestDeleteBusiness, self).setUp()
        self.user = factories.User(permissions=self.permissions)
        self.login_user(self.user)
        self.obj = self.factory.create()
        self.url_kwargs = {self.pk_url_kwarg: self.obj.pk}

    def test_get_no_permission(self):
        """Permission is required for this view."""
        self.user.user_permissions.clear()
        response = self._get()
        self.assertRedirectsToLogin(response)
        self.assertEquals(self.model.objects.count(), 1)

    def test_post_no_permission(self):
        """Permission is required for this view."""
        self.user.user_permissions.clear()
        response = self._post()
        self.assertRedirectsToLogin(response)
        self.assertEquals(self.model.objects.count(), 1)

    def test_bad_pk(self):
        """View should return 404 response if no object is found."""
        self.url_kwargs[self.pk_url_kwarg] = 1234
        response = self._get()
        self.assertEquals(response.status_code, 404)

    def test_get(self):
        """GET should return a confirmation page."""
        response = self._get()
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertTrue('object' in response.context)
        self.assertEquals(response.context['object'], self.obj)
        self.assertEquals(self.model.objects.count(), 1)

    def test_post(self):
        """POST should delete the object."""
        response = self._post()
        self.assertRedirectsNoFollow(response, self.success_url)
        self.assertEquals(self.model.objects.count(), 0)


class TestEditBusiness(ViewTestMixin, TestCase):
    url_name = 'edit_business'
    template_name = 'timepiece/business/create_edit.html'
    model = Business
    factory = factories.Business
    permissions = ('crm.change_business',)
    pk_url_kwarg = 'business_id'

    def setUp(self):
        super(TestEditBusiness, self).setUp()
        self.user = factories.User(permissions=self.permissions)
        self.login_user(self.user)
        self.obj = self.factory.create()
        self.url_kwargs = {self.pk_url_kwarg: self.obj.pk}
        self.post_data = {
            'name': 'Business',
            'email': 'email@email.com',
            'description': 'Described',
            'notes': 'Notes',
        }

    def _assert_no_change(self):
        self.assertEquals(self.model.objects.count(), 1)
        obj = self.model.objects.get()
        self.assertEquals(obj.name, self.obj.name)
        self.assertEquals(obj.email, self.obj.email)
        self.assertEquals(obj.description, self.obj.description)
        self.assertEquals(obj.notes, self.obj.notes)

    def test_get_no_permission(self):
        """Permission is required for this view."""
        self.user.user_permissions.clear()
        response = self._get()
        self.assertRedirectsToLogin(response)
        self._assert_no_change()

    def test_post_no_permission(self):
        """Permission is required for this view."""
        self.user.user_permissions.clear()
        response = self._post()
        self.assertRedirectsToLogin(response)
        self._assert_no_change()

    def test_bad_pk(self):
        """View should return 404 response if no object is found."""
        self.url_kwargs[self.pk_url_kwarg] = 1234
        response = self._get()
        self.assertEquals(response.status_code, 404)

    def test_get(self):
        """GET should return the page with an unbound form."""
        response = self._get()
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertTrue('object' in response.context)
        self.assertEquals(response.context['object'], self.obj)
        self.assertTrue('form' in response.context)
        self.assertFalse(response.context['form'].is_bound)
        self.assertEquals(response.context['form'].instance, self.obj)
        self._assert_no_change()

    def test_post_valid(self):
        """POST should edit the object."""
        response = self._post()
        self.assertEquals(self.model.objects.count(), 1)
        obj = self.model.objects.get()
        self.assertEquals(obj.pk, self.obj.pk)
        self.assertRedirectsNoFollow(response, obj.get_absolute_url())
        self.assertEquals(obj.name, self.post_data['name'])
        self.assertEquals(obj.email, self.post_data['email'])
        self.assertEquals(obj.description, self.post_data['description'])
        self.assertEquals(obj.notes, self.post_data['notes'])

    def test_post_invalid(self):
        """Invalid POST should not edit the object."""
        self.post_data['name'] = ''
        response = self._post()
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertTrue('object' in response.context)
        self.assertEquals(response.context['object'], self.obj)
        self.assertTrue('form' in response.context)
        self.assertTrue(response.context['form'].is_bound)
        self.assertFalse(response.context['form'].is_valid())
        self.assertEquals(response.context['form'].instance, self.obj)
        self._assert_no_change()


class TestListBusinesses(ViewTestMixin, TestCase):
    url_name = 'list_businesses'
    template_name = 'timepiece/business/list.html'
    factory = factories.Business
    model = Business
    permissions = ('crm.view_business',)

    def setUp(self):
        super(TestListBusinesses, self).setUp()
        self.user = factories.User(permissions=self.permissions)
        self.login_user(self.user)

    def test_get_no_permission(self):
        """Permission is required for this view."""
        self.user.user_permissions.clear()
        response = self._get()
        self.assertRedirectsToLogin(response)

    def test_list_all(self):
        """If no filters are provided, all objects should be listed."""
        object_list = [self.factory.create() for i in range(3)]
        response = self._get()
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertEquals(response.context['object_list'].count(), 3)
        for obj in object_list:
            self.assertTrue(obj in response.context['object_list'])

    def test_list_none(self):
        """Page should render even if there are no objects."""
        self.model.objects.all().delete()
        response = self._get()
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertEquals(response.context['object_list'].count(), 0)

    def test_list_one(self):
        """Page should render if there is one object & no search query."""
        obj = self.factory.create()
        response = self._get()
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertEquals(response.context['object_list'].count(), 1)
        self.assertEquals(response.context['object_list'].get(), obj)

    def test_no_results(self):
        """Page should render if there are no search results."""
        self.factory.create()
        response = self._get(get_kwargs={'search': 'hello'})
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertEquals(response.context['object_list'].count(), 0)

    def test_one_result(self):
        """If there is only one search result, user should be redirected."""
        obj = self.factory.create(name='hello')
        response = self._get(get_kwargs={'search': 'hello'})
        self.assertRedirectsNoFollow(response, obj.get_absolute_url())

    def test_multiple_results(self):
        """Page should render if there are multiple search results."""
        obj_list = [self.factory.create(name='hello') for i in range(2)]
        response = self._get(get_kwargs={'search': 'hello'})
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertEquals(response.context['object_list'].count(), 2)
        for obj in obj_list:
            self.assertTrue(obj in response.context['object_list'])

    def test_filter_name(self):
        """User should be able to filter by search query."""
        self.factory.create()
        obj = self.factory.create(name='hello')
        response = self._get(get_kwargs={'search': 'hello'})
        self.assertRedirectsNoFollow(response, obj.get_absolute_url())

    def test_filter_description(self):
        """User should be able to filter by search query."""
        self.factory.create()
        obj = self.factory.create(description='hello')
        response = self._get(get_kwargs={'search': 'hello'})
        self.assertRedirectsNoFollow(response, obj.get_absolute_url())


class TestViewBusiness(ViewTestMixin, TestCase):
    url_name = 'view_business'
    template_name = 'timepiece/business/view.html'
    model = Business
    factory = factories.Business
    permissions = ('crm.view_business',)
    pk_url_kwarg = 'business_id'

    def setUp(self):
        super(TestViewBusiness, self).setUp()
        self.user = factories.User(permissions=self.permissions)
        self.login_user(self.user)
        self.obj = self.factory.create()
        self.url_kwargs = {self.pk_url_kwarg: self.obj.pk}

    def test_get_no_permission(self):
        """Permission is required for this view."""
        self.user.user_permissions.clear()
        response = self._get()
        self.assertRedirectsToLogin(response)

    def test_post(self):
        """This is a GET-only view."""
        response = self._post()
        self.assertEquals(response.status_code, 405)

    def test_bad_pk(self):
        """View should return 404 response if no object is found."""
        self.url_kwargs[self.pk_url_kwarg] = 1234
        response = self._get()
        self.assertEquals(response.status_code, 404)

    def test_get(self):
        """User should be able to view the object detail."""
        response = self._get()
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertTrue('object' in response.context)
        self.assertEquals(response.context['object'], self.obj)

########NEW FILE########
__FILENAME__ = test_projects
from django.core.urlresolvers import reverse_lazy
from django.test import TestCase

from timepiece.tests import factories
from timepiece.tests.base import ViewTestMixin

from ..models import Project


class TestCreateProject(ViewTestMixin, TestCase):
    url_name = 'create_project'
    template_name = 'timepiece/project/create_edit.html'
    factory = factories.Project
    model = Project
    permissions = ('crm.add_project',)

    def setUp(self):
        super(TestCreateProject, self).setUp()
        self.user = factories.User(permissions=self.permissions)
        self.login_user(self.user)
        self.post_data = {
            'name': 'Project',
            'business_1': factories.Business().pk,
            'point_person': factories.Superuser().pk,
            'activity_group': factories.ActivityGroup().pk,
            'type': factories.TypeAttribute().pk,
            'status': factories.StatusAttribute().pk,
            'description': 'a project...',
        }

    def test_get_no_permission(self):
        """Permission is required for this view."""
        self.user.user_permissions.clear()
        response = self._get()
        self.assertRedirectsToLogin(response)
        self.assertEquals(self.model.objects.count(), 0)

    def test_post_no_permission(self):
        """Permission is required for this view."""
        self.user.user_permissions.clear()
        response = self._post()
        self.assertRedirectsToLogin(response)
        self.assertEquals(self.model.objects.count(), 0)

    def test_get(self):
        """GET should return the page with an unbound form."""
        response = self._get()
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertTrue('form' in response.context)
        self.assertFalse(response.context['form'].is_bound)
        self.assertEquals(self.model.objects.count(), 0)

    def test_post_valid(self):
        """POST should create a new object and redirect."""
        response = self._post()
        self.assertEquals(self.model.objects.count(), 1)
        obj = self.model.objects.get()
        self.assertRedirectsNoFollow(response, obj.get_absolute_url())
        self.assertEquals(obj.name, self.post_data['name'])
        self.assertEquals(obj.business.pk, self.post_data['business_1'])
        self.assertEquals(obj.point_person.pk, self.post_data['point_person'])
        self.assertEquals(obj.activity_group.pk, self.post_data['activity_group'])
        self.assertEquals(obj.type.pk, self.post_data['type'])
        self.assertEquals(obj.status.pk, self.post_data['status'])
        self.assertEquals(obj.description, self.post_data['description'])

    def test_post_invalid(self):
        """Invalid POST should not create a new object."""
        self.post_data['name'] = ''
        response = self._post()
        self.assertEquals(self.model.objects.count(), 0)
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertTrue('form' in response.context)
        self.assertTrue(response.context['form'].is_bound)
        self.assertFalse(response.context['form'].is_valid())


class TestDeleteProject(ViewTestMixin, TestCase):
    url_name = 'delete_project'
    template_name = 'timepiece/delete_object.html'
    model = Project
    factory = factories.Project
    success_url = reverse_lazy('list_projects')
    permissions = ('crm.delete_project',)
    pk_url_kwarg = 'project_id'

    def setUp(self):
        super(TestDeleteProject, self).setUp()
        self.user = factories.User(permissions=self.permissions)
        self.login_user(self.user)
        self.obj = self.factory.create()
        self.url_kwargs = {self.pk_url_kwarg: self.obj.pk}

    def test_get_no_permission(self):
        """Permission is required for this view."""
        self.user.user_permissions.clear()
        response = self._get()
        self.assertRedirectsToLogin(response)
        self.assertEquals(self.model.objects.count(), 1)

    def test_post_no_permission(self):
        """Permission is required for this view."""
        self.user.user_permissions.clear()
        response = self._post()
        self.assertRedirectsToLogin(response)
        self.assertEquals(self.model.objects.count(), 1)

    def test_bad_pk(self):
        """View should return 404 response if no object is found."""
        self.url_kwargs[self.pk_url_kwarg] = 1234
        response = self._get()
        self.assertEquals(response.status_code, 404)

    def test_get(self):
        """GET should return a confirmation page."""
        response = self._get()
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertTrue('object' in response.context)
        self.assertEquals(response.context['object'], self.obj)
        self.assertEquals(self.model.objects.count(), 1)

    def test_post(self):
        """POST should delete the object."""
        response = self._post()
        self.assertRedirectsNoFollow(response, self.success_url)
        self.assertEquals(self.model.objects.count(), 0)


class TestEditProject(ViewTestMixin, TestCase):
    url_name = 'edit_project'
    template_name = 'timepiece/project/create_edit.html'
    model = Project
    factory = factories.Project
    permissions = ('crm.change_project',)
    pk_url_kwarg = 'project_id'

    def setUp(self):
        super(TestEditProject, self).setUp()
        self.user = factories.User(permissions=self.permissions)
        self.login_user(self.user)
        self.obj = self.factory.create()
        self.url_kwargs = {self.pk_url_kwarg: self.obj.pk}
        self.post_data = {
            'name': 'Project',
            'business_1': factories.Business().pk,
            'point_person': factories.Superuser().pk,
            'activity_group': factories.ActivityGroup().pk,
            'type': factories.TypeAttribute().pk,
            'status': factories.StatusAttribute().pk,
            'description': 'a project...',
        }

    def _assert_no_change(self):
        self.assertEquals(self.model.objects.count(), 1)
        obj = self.model.objects.get()
        self.assertEquals(obj.name, self.obj.name)
        self.assertEquals(obj.business, self.obj.business)
        self.assertEquals(obj.point_person, self.obj.point_person)
        self.assertEquals(obj.activity_group, self.obj.activity_group)
        self.assertEquals(obj.type, self.obj.type)
        self.assertEquals(obj.status, self.obj.status)
        self.assertEquals(obj.description, self.obj.description)

    def test_get_no_permission(self):
        """Permission is required for this view."""
        self.user.user_permissions.clear()
        response = self._get()
        self.assertRedirectsToLogin(response)
        self._assert_no_change()

    def test_post_no_permission(self):
        """Permission is required for this view."""
        self.user.user_permissions.clear()
        response = self._post()
        self.assertRedirectsToLogin(response)
        self._assert_no_change()

    def test_bad_pk(self):
        """View should return 404 response if no object is found."""
        self.url_kwargs[self.pk_url_kwarg] = 1234
        response = self._get()
        self.assertEquals(response.status_code, 404)

    def test_get(self):
        """GET should return the page with an unbound form."""
        response = self._get()
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertTrue('object' in response.context)
        self.assertEquals(response.context['object'], self.obj)
        self.assertTrue('form' in response.context)
        self.assertFalse(response.context['form'].is_bound)
        self.assertEquals(response.context['form'].instance, self.obj)
        self._assert_no_change()

    def test_post_valid(self):
        """POST should edit the object."""
        response = self._post()
        self.assertEquals(self.model.objects.count(), 1)
        obj = self.model.objects.get()
        self.assertEquals(obj.pk, self.obj.pk)
        self.assertRedirectsNoFollow(response, obj.get_absolute_url())
        self.assertEquals(obj.name, self.post_data['name'])
        self.assertEquals(obj.business.pk, self.post_data['business_1'])
        self.assertEquals(obj.point_person.pk, self.post_data['point_person'])
        self.assertEquals(obj.activity_group.pk, self.post_data['activity_group'])
        self.assertEquals(obj.type.pk, self.post_data['type'])
        self.assertEquals(obj.status.pk, self.post_data['status'])
        self.assertEquals(obj.description, self.post_data['description'])

    def test_post_invalid(self):
        """Invalid POST should not edit the object."""
        self.post_data['name'] = ''
        response = self._post()
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertTrue('object' in response.context)
        self.assertEquals(response.context['object'], self.obj)
        self.assertTrue('form' in response.context)
        self.assertTrue(response.context['form'].is_bound)
        self.assertFalse(response.context['form'].is_valid())
        self.assertEquals(response.context['form'].instance, self.obj)
        self._assert_no_change()


class TestListProjects(ViewTestMixin, TestCase):
    url_name = 'list_projects'
    template_name = 'timepiece/project/list.html'
    factory = factories.Project
    model = Project
    permissions = ('crm.view_project',)

    def setUp(self):
        super(TestListProjects, self).setUp()
        self.user = factories.User(permissions=self.permissions)
        self.login_user(self.user)

    def test_get_no_permission(self):
        """Permission is required for this view."""
        self.user.user_permissions.clear()
        response = self._get()
        self.assertRedirectsToLogin(response)

    def test_list_all(self):
        """If no filters are provided, all objects should be listed."""
        object_list = [self.factory.create() for i in range(3)]
        response = self._get()
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertEquals(response.context['object_list'].count(), 3)
        for obj in object_list:
            self.assertTrue(obj in response.context['object_list'])

    def test_list_none(self):
        """Page should render even if there are no objects."""
        self.model.objects.all().delete()
        response = self._get()
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertEquals(response.context['object_list'].count(), 0)

    def test_list_one(self):
        """Page should render if there is one object & no search query."""
        obj = self.factory.create()
        response = self._get()
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertEquals(response.context['object_list'].count(), 1)
        self.assertEquals(response.context['object_list'].get(), obj)

    def test_no_results(self):
        """Page should render if there are no search results."""
        self.factory.create()
        response = self._get(get_kwargs={'search': 'hello'})
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertEquals(response.context['object_list'].count(), 0)

    def test_one_result(self):
        """If there is only one search result, user should be redirected."""
        obj = self.factory.create()
        response = self._get(get_kwargs={'status': obj.status.pk})
        self.assertRedirectsNoFollow(response, obj.get_absolute_url())

    def test_multiple_results(self):
        """Page should render if there are multiple search results."""
        obj_list = [self.factory.create(name='hello') for i in range(2)]
        response = self._get(get_kwargs={'search': 'ello'})
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertEquals(response.context['object_list'].count(), 2)
        for obj in obj_list:
            self.assertTrue(obj in response.context['object_list'])

    def test_filter_name(self):
        """User should be able to filter by search query and status."""
        self.factory.create()
        obj = self.factory.create(name='hello')
        response = self._get(get_kwargs={'search': 'ello'})
        self.assertRedirectsNoFollow(response, obj.get_absolute_url())

    def test_filter_description(self):
        """User should be able to filter by search query and status."""
        self.factory.create()
        obj = self.factory.create(description='hello')
        response = self._get(get_kwargs={'search': 'ello'})
        self.assertRedirectsNoFollow(response, obj.get_absolute_url())

    def test_filter_status(self):
        """User should be able to filter by search query and status."""
        self.factory.create()
        obj = self.factory.create()
        response = self._get(get_kwargs={'status': obj.status.pk})
        self.assertRedirectsNoFollow(response, obj.get_absolute_url())

    def test_filter_query_and_status(self):
        """User should be able to filter by search query and status."""
        obj = self.factory.create(name='hello')
        self.factory.create(status=obj.status)
        self.factory.create(description='hello')
        get_kwargs = {'status': obj.status.pk, 'search': 'ello'}
        response = self._get(get_kwargs=get_kwargs)
        self.assertRedirectsNoFollow(response, obj.get_absolute_url())


class TestViewProject(ViewTestMixin, TestCase):
    url_name = 'view_project'
    template_name = 'timepiece/project/view.html'
    model = Project
    factory = factories.Project
    permissions = ('crm.view_project',)
    pk_url_kwarg = 'project_id'

    def setUp(self):
        super(TestViewProject, self).setUp()
        self.user = factories.User(permissions=self.permissions)
        self.login_user(self.user)
        self.obj = self.factory.create()
        self.url_kwargs = {self.pk_url_kwarg: self.obj.pk}

    def test_get_no_permission(self):
        """Permission is required for this view."""
        self.user.user_permissions.clear()
        response = self._get()
        self.assertRedirectsToLogin(response)

    def test_post(self):
        """This is a GET-only view."""
        response = self._post()
        self.assertEquals(response.status_code, 405)

    def test_bad_pk(self):
        """View should return 404 response if no object is found."""
        self.url_kwargs[self.pk_url_kwarg] = 1234
        response = self._get()
        self.assertEquals(response.status_code, 404)

    def test_get(self):
        """User should be able to view the object detail."""
        response = self._get()
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertTrue('object' in response.context)
        self.assertEquals(response.context['object'], self.obj)
        self.assertTrue('add_user_form' in response.context)
        self.assertFalse(response.context['add_user_form'].is_bound)

########NEW FILE########
__FILENAME__ = test_project_timesheet
import datetime
from decimal import Decimal

from django.utils import timezone
from django.test import TestCase

from timepiece import utils
from timepiece.tests import factories
from timepiece.tests.base import ViewTestMixin, LogTimeMixin


class TestProjectTimesheet(ViewTestMixin, LogTimeMixin, TestCase):
    url_name = 'view_project_timesheet'

    def setUp(self):
        super(TestProjectTimesheet, self).setUp()
        self.user = factories.User()
        self.user2 = factories.User()
        self.superuser = factories.Superuser()
        self.p1 = factories.BillableProject(name='1')
        self.p2 = factories.NonbillableProject(name='2')
        self.p4 = factories.BillableProject(name='4')
        self.p3 = factories.NonbillableProject(name='1')
        self.url_args = (self.p1.pk,)
        self.devl_activity = factories.Activity(billable=True)
        self.activity = factories.Activity()

    def make_entries(self):
        days = [
            utils.add_timezone(datetime.datetime(2011, 1, 1)),
            utils.add_timezone(datetime.datetime(2011, 1, 28)),
            utils.add_timezone(datetime.datetime(2011, 1, 31)),
            utils.add_timezone(datetime.datetime(2011, 2, 1)),
            timezone.now(),
        ]
        self.log_time(project=self.p1, start=days[0], delta=(1, 0))
        self.log_time(project=self.p2, start=days[0], delta=(1, 0))
        self.log_time(project=self.p1, start=days[1], delta=(1, 0))
        self.log_time(project=self.p3, start=days[1], delta=(1, 0))
        self.log_time(project=self.p1, user=self.user2, start=days[2],
                      delta=(1, 0))
        self.log_time(project=self.p2, start=days[2], delta=(1, 0))
        self.log_time(project=self.p1, start=days[3], delta=(1, 0))
        self.log_time(project=self.p3, start=days[3], delta=(1, 0))
        self.log_time(project=self.p1, start=days[4], delta=(1, 0))
        self.log_time(project=self.p2, start=days[4], delta=(1, 0))

    def testNoPermission(self):
        self.login_user(self.user)
        self.make_entries()
        response = self._get()
        self.assertEqual(response.status_code, 302)

    def testNoProject(self):
        self.login_user(self.superuser)
        response = self._get(url_args=(999,))
        self.assertEqual(response.status_code, 404)

    def testEmptyProjectTimesheet(self):
        """
        The project timesheet should be empty if there are no entries, or a
        month has been selected for which there are no entries
        """
        self.login_user(self.superuser)

        def verify_empty(response):
            self.assertEqual(response.status_code, 200)
            self.assertEqual(response.context['project'], self.p1)
            self.assertEqual(list(response.context['entries']), [])
        response = self._get()
        verify_empty(response)
        self.make_entries()
        data = {
            'year': 2011,
            'month': 4,
        }
        response = self._get(data=data)
        verify_empty(response)

    def testCurrentProjectTimesheet(self):
        self.login_user(self.superuser)
        self.make_entries()
        response = self._get()
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.context['project'], self.p1)
        self.assertEqual(len(response.context['entries']), 1)
        self.assertEqual(response.context['total'], Decimal(1))
        user_entry = response.context['user_entries'][0]
        self.assertEqual(user_entry['user__last_name'], self.user.last_name)
        self.assertEqual(user_entry['user__first_name'], self.user.first_name)
        self.assertEqual(user_entry['sum'], Decimal(1))

    def testOldProjectTimesheet(self):
        self.login_user(self.superuser)
        self.make_entries()
        data = {
            'year': 2011,
            'month': 1,
        }
        response = self._get(data=data)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.context['project'], self.p1)
        self.assertEqual(len(response.context['entries']), 3)
        self.assertEqual(response.context['total'], Decimal(3))
        user_entry0 = response.context['user_entries'][0]
        user_entry1 = response.context['user_entries'][1]
        self.assertEqual(user_entry0['user__last_name'], self.user.last_name)
        self.assertEqual(user_entry0['user__first_name'], self.user.first_name)
        self.assertEqual(user_entry0['sum'], Decimal(2))
        self.assertEqual(user_entry1['user__last_name'], self.user2.last_name)
        self.assertEqual(user_entry1['user__first_name'],
                         self.user2.first_name
        )
        self.assertEqual(user_entry1['sum'], Decimal(1))

    def testOtherProjectTimesheet(self):
        self.login_user(self.superuser)
        self.make_entries()
        response = self._get(url_args=(self.p2.pk,))
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.context['project'], self.p2)
        self.assertEqual(len(response.context['entries']), 1)
        self.assertEqual(response.context['total'], Decimal(1))
        user_entry = response.context['user_entries'][0]
        self.assertEqual(user_entry['user__last_name'], self.user.last_name)
        self.assertEqual(user_entry['user__first_name'], self.user.first_name)
        self.assertEqual(user_entry['sum'], Decimal(1))

    def test_project_csv(self):
        self.login_user(self.superuser)
        self.make_entries()
        response = self._get(url_name='view_project_timesheet_csv',
                url_args=(self.p1.pk,))
        self.assertEqual(response.status_code, 200)
        data = dict(response.items())
        self.assertEqual(data['Content-Type'], 'text/csv')
        disposition = data['Content-Disposition']
        self.assertTrue(disposition.startswith('attachment; filename='))
        contents = response.content.splitlines()
        headers = contents[0].split(',')
        # Assure user's comments are not included.
        self.assertTrue('comments' not in headers)

########NEW FILE########
__FILENAME__ = test_quick_search
from django.test import TestCase

from timepiece.tests import factories
from timepiece.tests.base import ViewTestMixin


class TestQuickSearchView(ViewTestMixin, TestCase):
    url_name = 'quick_search'
    template_name = 'timepiece/quick_search.html'

    def setUp(self):
        super(TestQuickSearchView, self).setUp()
        self.user = factories.User()
        self.login_user(self.user)

    def test_search_user(self):
        user = factories.User()
        response = self._post(data={
            'quick_search_1': 'user-{0}'.format(user.pk),
        })
        self.assertRedirectsNoFollow(response, user.get_absolute_url())

    def test_search_no_such_user(self):
        response = self._post(data={
            'quick_search_1': 'user-12345',
        })
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(self.template_name)
        self.assertFalse(response.context['form'].is_valid())

    def test_search_business(self):
        business = factories.Business()
        response = self._post(data={
            'quick_search_1': 'business-{0}'.format(business.pk),
        })
        self.assertRedirectsNoFollow(response, business.get_absolute_url())

    def test_search_no_such_business(self):
        response = self._post(data={
            'quick_search_1': 'business-12345',
        })
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(self.template_name)
        self.assertFalse(response.context['form'].is_valid())

    def test_search_project(self):
        project = factories.Project()
        response = self._post(data={
            'quick_search_1': 'project-{0}'.format(project.pk),
        })
        self.assertRedirectsNoFollow(response, project.get_absolute_url())

    def test_search_no_such_project(self):
        response = self._post(data={
            'quick_search_1': 'project-12345',
        })
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertFalse(response.context['form'].is_valid())

    def test_malformed_search(self):
        response = self._post(data={
            'quick_search_1': 'project no dash 12345',
        })
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertFalse(response.context['form'].is_valid())

    def test_bad_result_type(self):
        response = self._post(data={
            'quick_search_1': 'hello-12345',
        })
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertFalse(response.context['form'].is_valid())

    def test_no_search(self):
        response = self._post(data={
            'quick_search_1': '',
        })
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertFalse(response.context['form'].is_valid())

########NEW FILE########
__FILENAME__ = test_relationships
from django.contrib.auth.models import Permission
from django.core.urlresolvers import reverse
from django.test import TestCase

from timepiece.tests import factories
from timepiece.tests.base import ViewTestMixin
from timepiece.crm.models import ProjectRelationship


class RelationshipTestBase(TestCase):

    def setUp(self):
        super(RelationshipTestBase, self).setUp()
        self.user = factories.User()
        self.permissions = [Permission.objects.get(codename=n) for n in
                self.perm_names]
        self.user.user_permissions.add(*self.permissions)
        self.login_user(self.user)

        self.project = factories.Project()


class TestAddProjectToUser(ViewTestMixin, RelationshipTestBase):
    url_name = 'create_relationship'
    perm_names = ['add_projectrelationship']

    @property
    def get_kwargs(self):
        return {'user_id': self.user.pk}

    def _data(self):
        return {'project_1': self.project.pk}

    def test_other_methods(self):
        """Add Project Relationship requires POST."""
        for method in (self.client.get, self.client.head, self.client.put,
                self.client.delete):
            response = method(self._url())
            self.assertEquals(response.status_code, 405, '{method} request '
                    'did not have expected code: {actual} instead of '
                    '{expected}'.format(method=method,
                    actual=response.status_code, expected=405))
            self.assertEquals(ProjectRelationship.objects.count(), 0)

    def test_permission(self):
        """Permission is required to add a project relationship."""
        self.user.user_permissions.remove(*self.permissions)

        response = self._post()
        self.assertEquals(response.status_code, 302)
        self.assertEquals(ProjectRelationship.objects.count(), 0)

    def test_bad_user_id(self):
        """Bad user id should return a 404 response."""
        response = self._post(get_kwargs={'user_id': '12345'})
        self.assertEquals(response.status_code, 404)
        self.assertEquals(ProjectRelationship.objects.count(), 0)

    def test_bad_project_id(self):
        """Bad project id should cause no change."""
        response = self._post(data={'project_1': '12345'})
        self.assertEquals(response.status_code, 302)
        self.assertEquals(ProjectRelationship.objects.count(), 0)

    def test_add_again(self):
        """Adding project again should have no effect."""
        rel = factories.ProjectRelationship(project=self.project,
                user=self.user)

        response = self._post(data=self._data())
        self.assertEquals(response.status_code, 302)
        rel = ProjectRelationship.objects.get()
        self.assertEquals(rel.project, self.project)
        self.assertEquals(rel.user, self.user)

    def test_redirect_to_dashboard(self):
        """Adding a relationship should redirect to the dashboard by default."""
        response = self._post(data=self._data())
        self.assertRedirectsNoFollow(response, reverse('dashboard'))
        rel = ProjectRelationship.objects.get()
        self.assertEquals(rel.project, self.project)
        self.assertEquals(rel.user, self.user)

    def test_redirect_to_next(self):
        """Adding a relationship should redirect to next url if available."""
        get_kwargs = self.get_kwargs
        get_kwargs.update({'next': '/hello'})
        response = self._post(data=self._data(), get_kwargs=get_kwargs)
        self.assertRedirectsNoFollow(response, '/hello')
        rel = ProjectRelationship.objects.get()
        self.assertEquals(rel.project, self.project)
        self.assertEquals(rel.user, self.user)


class TestAddUserToProject(ViewTestMixin, RelationshipTestBase):
    url_name = 'create_relationship'
    perm_names = ['change_projectrelationship', 'add_projectrelationship']

    @property
    def get_kwargs(self):
        return {'project_id': self.project.pk}

    def _data(self):
        return {'user_1': self.user.pk}

    def test_other_methods(self):
        """Add Project Relationship requires POST."""
        for method in (self.client.get, self.client.head, self.client.put,
                self.client.delete):
            response = method(self._url())
            self.assertEquals(response.status_code, 405, '{method} request '
                    'did not have expected code: {actual} instead of '
                    '{expected}'.format(method=method,
                    actual=response.status_code, expected=405))
            self.assertEquals(ProjectRelationship.objects.count(), 0)

    def test_permission(self):
        """Permission is required to add a project relationship."""
        self.user.user_permissions.remove(*self.permissions)

        response = self._post()
        self.assertEquals(response.status_code, 302)
        self.assertEquals(ProjectRelationship.objects.count(), 0)

    def test_bad_project_id(self):
        """Bad project id should return a 404 response."""
        response = self._post(get_kwargs={'project_id': '12345'})
        self.assertEquals(response.status_code, 404)
        self.assertEquals(ProjectRelationship.objects.count(), 0)

    def test_bad_user_id(self):
        """Bad user id should cause no change."""
        response = self._post(data={'user_1': '12345'})
        self.assertEquals(response.status_code, 302)
        self.assertEquals(ProjectRelationship.objects.count(), 0)

    def test_add_again(self):
        """Adding user again should have no effect."""
        rel = factories.ProjectRelationship(project=self.project,
                user=self.user)

        response = self._post(data=self._data())
        self.assertEquals(response.status_code, 302)
        rel = ProjectRelationship.objects.get()
        self.assertEquals(rel.project, self.project)
        self.assertEquals(rel.user, self.user)

    def test_redirect_to_dashboard(self):
        """Adding a relationship hould redirect to the dashboard by default."""
        response = self._post(data=self._data())
        self.assertRedirectsNoFollow(response, reverse('dashboard'))
        rel = ProjectRelationship.objects.get()
        self.assertEquals(rel.project, self.project)
        self.assertEquals(rel.user, self.user)

    def test_redirect_to_next(self):
        """Adding a relationship should redirect to next url if available."""
        get_kwargs = self.get_kwargs
        get_kwargs.update({'next': '/hello'})
        response = self._post(data=self._data(), get_kwargs=get_kwargs)
        self.assertRedirectsNoFollow(response, '/hello')
        rel = ProjectRelationship.objects.get()
        self.assertEquals(rel.project, self.project)
        self.assertEquals(rel.user, self.user)


class TestEditRelationship(ViewTestMixin, RelationshipTestBase):
    url_name = 'edit_relationship'
    perm_names = ['change_projectrelationship']

    @property
    def get_kwargs(self):
        return {'project_id': self.project.pk, 'user_id': self.user.pk}

    def _data(self):
        return {'types': [self.rel_type1.pk, self.rel_type2.pk]}

    def setUp(self):
        super(TestEditRelationship, self).setUp()
        self.relationship = factories.ProjectRelationship(
                project=self.project, user=self.user)
        self.rel_type1 = factories.RelationshipType()
        self.rel_type2 = factories.RelationshipType()

    def test_permission(self):
        """Permission is required to edit a project relationship."""
        self.user.user_permissions.remove(*self.permissions)

        for method in (self._get, self._post):
            response = method()
            self.assertEquals(response.status_code, 302)

    def test_bad_user_id(self):
        """Bad user id should return a 404 response."""
        get_kwargs = {'user_id': '12345', 'project_id': self.project.pk}

        for method in (self._get, self._post):
            response = method(get_kwargs=get_kwargs)
            self.assertEquals(response.status_code, 404)
            rel = ProjectRelationship.objects.get()
            self.assertEquals(rel, self.relationship)

    def test_bad_project_id(self):
        """Bad project id should return a 404 response."""
        get_kwargs = {'user_id': self.user.pk, 'project_id': '12345'}

        for method in (self._get, self._post):
            response = method(get_kwargs=get_kwargs)
            self.assertEquals(response.status_code, 404)
            rel = ProjectRelationship.objects.get()
            self.assertEquals(rel, self.relationship)

    def test_non_existant_relationship(self):
        """Should return 404 response."""
        self.relationship.delete()

        for method in (self._get, self._post):
            response = method()
            self.assertEquals(response.status_code, 404)
            self.assertEquals(ProjectRelationship.objects.count(), 0)

    def test_get(self):
        """GET request should return form with bound data."""
        response = self._get()
        self.assertEquals(response.status_code, 200)
        context = response.context
        form = context['form']
        self.assertEquals(ProjectRelationship.objects.get(), self.relationship)
        self.assertEqual(context['object'], self.relationship)
        self.assertFalse(form.is_bound)
        self.assertEquals(form.instance, self.relationship)

    def test_redirect_to_project_page(self):
        """Editing a relationship should redirect to project by default."""
        project_url = reverse('view_project', args=(self.project.pk,))

        response = self._post(data=self._data())
        self.assertRedirectsNoFollow(response, project_url)
        rel = ProjectRelationship.objects.get()
        self.assertEquals(rel.project, self.project)
        self.assertEquals(rel.user, self.user)
        self.assertEquals(rel.types.count(), 2)
        self.assertTrue(self.rel_type1 in rel.types.all())
        self.assertTrue(self.rel_type2 in rel.types.all())

    def test_redirect_to_next(self):
        """Editing a relationship should redirect to next url if available."""
        get_kwargs = self.get_kwargs
        get_kwargs.update({'next': '/hello'})
        response = self._post(data=self._data(), get_kwargs=get_kwargs)
        self.assertRedirectsNoFollow(response, '/hello')
        rel = ProjectRelationship.objects.get()
        self.assertEquals(rel.project, self.project)
        self.assertEquals(rel.user, self.user)
        self.assertEquals(rel.types.count(), 2)
        self.assertTrue(self.rel_type1 in rel.types.all())
        self.assertTrue(self.rel_type2 in rel.types.all())


class TestDeleteRelationship(ViewTestMixin, RelationshipTestBase):
    url_name = 'delete_relationship'
    perm_names = ['delete_projectrelationship']

    def setUp(self):
        super(TestDeleteRelationship, self).setUp()
        self.relationship = factories.ProjectRelationship(
                project=self.project, user=self.user)

    @property
    def get_kwargs(self):
        return {'project_id': self.project.pk, 'user_id': self.user.pk}

    def test_get_no_delete(self):
        """Remove Project Relationship renders but doesn't delete on GET"""
        response = self._get()
        self.assertEqual(response.status_code, 200)
        self.assertEqual(ProjectRelationship.objects.count(), 1)

    def test_permission(self):
        """Permission is required to delete a project relationship."""
        self.user.user_permissions.remove(*self.permissions)
        response = self._post()
        self.assertEquals(response.status_code, 302)
        self.assertEquals(ProjectRelationship.objects.count(), 1)

    def test_bad_user_id(self):
        """Bad user id should return a 404 response."""
        get_kwargs = {'user_id': '12345', 'project_id': self.project.pk}
        response = self._post(get_kwargs=get_kwargs)
        self.assertEquals(response.status_code, 404)
        self.assertEquals(ProjectRelationship.objects.count(), 1)

    def test_bad_project_id(self):
        """Bad project id should return a 404 response."""
        get_kwargs = {'user_id': self.user.pk, 'project_id': '12345'}
        response = self._post(get_kwargs=get_kwargs)
        self.assertEquals(response.status_code, 404)
        self.assertEquals(ProjectRelationship.objects.count(), 1)

    def test_non_existant_relationship(self):
        """Assure 404 is raised if the project relationship doesn't exist"""
        self.relationship.delete()
        response = self._post()
        self.assertEquals(response.status_code, 404)
        self.assertEquals(ProjectRelationship.objects.count(), 0)

########NEW FILE########
__FILENAME__ = test_users
import mock

from django.contrib.auth.models import User, Permission
from django.contrib.contenttypes.models import ContentType
from django.core.urlresolvers import reverse, reverse_lazy
from django.test import TestCase

from timepiece.tests import factories
from timepiece.tests.base import ViewTestMixin


class TestAddToUserClass(TestCase):
    """Tests for methods added to the user model via User.add_to_class."""

    def setUp(self):
        super(TestAddToUserClass, self).setUp()
        self.user = factories.User()

    @mock.patch('timepiece.crm.models.get_active_entry')
    def test_clocked_in(self, get_active_entry):
        get_active_entry.return_value = True
        self.assertTrue(self.user.clocked_in)

    @mock.patch('timepiece.crm.models.get_active_entry')
    def test_not_clocked_in(self, get_active_entry):
        get_active_entry.return_value = None
        self.assertFalse(self.user.clocked_in)

    def test_get_name(self):
        self.assertEquals(self.user.get_name_or_username(), self.user.get_full_name())

    def test_get_username(self):
        self.user.first_name = ""
        self.user.last_name = ""
        self.assertEquals(self.user.get_name_or_username(), self.user.username)

    def test_get_absolute_url(self):
        correct = reverse('view_user', args=(self.user.pk,))
        self.assertEquals(self.user.get_absolute_url(), correct)


class TestCreateUser(ViewTestMixin, TestCase):
    url_name = 'create_user'
    template_name = 'timepiece/user/create_edit.html'
    factory = factories.User
    model = User
    permissions = ('auth.add_user',)

    def setUp(self):
        super(TestCreateUser, self).setUp()
        self.user = factories.User(permissions=self.permissions)
        self.login_user(self.user)
        self.post_data = {
            'username': 'hello',
            'first_name': 'Sam',
            'last_name': 'Blue',
            'email': 'sam@blue.com',
            'is_active': False,
            'is_staff': True,
            'groups': [factories.Group().pk, factories.Group().pk],
            'password1': 'aaa',
            'password2': 'aaa',
        }

    def test_get_no_permission(self):
        """Permission is required for this view."""
        self.user.user_permissions.clear()
        response = self._get()
        self.assertRedirectsToLogin(response)
        self.assertEquals(self.model.objects.count(), 1)

    def test_post_no_permission(self):
        """Permission is required for this view."""
        self.user.user_permissions.clear()
        response = self._post()
        self.assertRedirectsToLogin(response)
        self.assertEquals(self.model.objects.count(), 1)

    def test_get(self):
        """GET should return the page with an unbound form."""
        response = self._get()
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertTrue('form' in response.context)
        self.assertFalse(response.context['form'].is_bound)
        self.assertEquals(self.model.objects.count(), 1)

    def test_post_valid(self):
        """POST should create a new object and redirect."""
        response = self._post()
        self.assertEquals(self.model.objects.count(), 2)
        obj = self.model.objects.exclude(pk=self.user.pk).get()
        self.assertRedirectsNoFollow(response, obj.get_absolute_url())
        self.assertEquals(obj.username, self.post_data['username'])
        self.assertEquals(obj.first_name, self.post_data['first_name'])
        self.assertEquals(obj.last_name, self.post_data['last_name'])
        self.assertEquals(obj.email, self.post_data['email'])
        self.assertEquals(obj.is_active, self.post_data['is_active']),
        self.assertEquals(obj.is_staff, self.post_data['is_staff']),
        self.assertItemsEqual(obj.groups.values_list('pk', flat=True),
                self.post_data['groups'])
        self.assertTrue(obj.check_password(self.post_data['password1']))

    def test_nonmatching_passwords(self):
        """Passwords must match."""
        self.post_data['password2'] = 'bbb'
        response = self._post()
        self.assertEquals(self.model.objects.count(), 1)
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertTrue('form' in response.context)
        self.assertTrue(response.context['form'].is_bound)
        self.assertFalse(response.context['form'].is_valid())

    def test_post_invalid(self):
        """Invalid POST should not create a new object."""
        self.post_data['username'] = ''
        response = self._post()
        self.assertEquals(self.model.objects.count(), 1)
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertTrue('form' in response.context)
        self.assertTrue(response.context['form'].is_bound)
        self.assertFalse(response.context['form'].is_valid())


class TestDeleteUser(ViewTestMixin, TestCase):
    url_name = 'delete_user'
    template_name = 'timepiece/delete_object.html'
    model = User
    factory = factories.User
    success_url = reverse_lazy('list_users')
    permissions = ('auth.delete_user',)
    pk_url_kwarg = 'user_id'

    def setUp(self):
        super(TestDeleteUser, self).setUp()
        self.user = factories.User(permissions=self.permissions)
        self.login_user(self.user)
        self.obj = self.factory.create()
        self.url_kwargs = {self.pk_url_kwarg: self.obj.pk}

    def test_get_no_permission(self):
        """Permission is required for this view."""
        self.user.user_permissions.clear()
        response = self._get()
        self.assertRedirectsToLogin(response)
        self.assertEquals(self.model.objects.count(), 2)

    def test_post_no_permission(self):
        """Permission is required for this view."""
        self.user.user_permissions.clear()
        response = self._post()
        self.assertRedirectsToLogin(response)
        self.assertEquals(User.objects.count(), 2)

    def test_bad_pk(self):
        """View should return 404 response if no object is found."""
        self.url_kwargs[self.pk_url_kwarg] = 1234
        response = self._get()
        self.assertEquals(response.status_code, 404)

    def test_get(self):
        """GET should returd return a confirmation page."""
        response = self._get()
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertTrue('object' in response.context)
        self.assertEquals(response.context['object'], self.obj)
        self.assertEquals(self.model.objects.count(), 2)

    def test_post(self):
        """POST should delete the object."""
        response = self._post()
        self.assertRedirectsNoFollow(response, self.success_url)
        self.assertEquals(User.objects.count(), 1)


class TestEditUser(ViewTestMixin, TestCase):
    url_name = 'edit_user'
    template_name = 'timepiece/user/create_edit.html'
    permissions = ('auth.change_user',)
    model = User
    factory = factories.User
    pk_url_kwarg = 'user_id'

    def setUp(self):
        super(TestEditUser, self).setUp()
        self.user = factories.User(permissions=self.permissions)
        self.login_user(self.user)
        self.obj = self.factory.create()
        self.url_kwargs = {self.pk_url_kwarg: self.obj.pk}
        self.post_data = {
            'username': 'hello',
            'first_name': 'Sam',
            'last_name': 'Blue',
            'email': 'sam@blue.com',
            'is_active': False,
            'is_staff': True,
            'groups': [factories.Group().pk, factories.Group().pk],
        }

    def _assert_no_change(self):
        self.assertEquals(self.model.objects.count(), 2)
        obj = self.model.objects.get(pk=self.obj.pk)
        self.assertEquals(obj.username, self.obj.username)
        self.assertEquals(obj.first_name, self.obj.first_name)
        self.assertEquals(obj.last_name, self.obj.last_name)
        self.assertEquals(obj.email, self.obj.email)
        self.assertEquals(obj.is_active, self.obj.is_active)
        self.assertEquals(obj.is_staff, self.obj.is_staff)
        self.assertItemsEqual(obj.groups.values_list('pk', flat=True),
                self.obj.groups.values_list('pk', flat=True))

    def test_get_no_permission(self):
        """Permission is required for this view."""
        self.user.user_permissions.clear()
        response = self._get()
        self.assertRedirectsToLogin(response)
        self._assert_no_change()

    def test_post_no_permission(self):
        """Permission is required for this view."""
        self.user.user_permissions.clear()
        response = self._post()
        self.assertRedirectsToLogin(response)
        self._assert_no_change()

    def test_bad_pk(self):
        """View should return 404 response if no object is found."""
        self.url_kwargs[self.pk_url_kwarg] = 1234
        response = self._get()
        self.assertEquals(response.status_code, 404)

    def test_get(self):
        """GET should return the page with an unbound form."""
        response = self._get()
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertTrue('object' in response.context)
        self.assertEquals(response.context['object'], self.obj)
        self.assertTrue('form' in response.context)
        self.assertFalse(response.context['form'].is_bound)
        self.assertEquals(response.context['form'].instance, self.obj)
        self._assert_no_change()

    def test_post_valid(self):
        """POST should edit the object."""
        response = self._post()
        self.assertEquals(self.model.objects.count(), 2)
        obj = self.model.objects.get(pk=self.obj.pk)
        self.assertEquals(obj.pk, self.obj.pk)
        self.assertRedirectsNoFollow(response, obj.get_absolute_url())
        self.assertEquals(obj.first_name, self.post_data['first_name'])
        self.assertEquals(obj.last_name, self.post_data['last_name'])
        self.assertEquals(obj.email, self.post_data['email'])
        self.assertEquals(obj.is_active, self.post_data['is_active'])
        self.assertEquals(obj.is_staff, self.post_data['is_staff'])
        self.assertItemsEqual(obj.groups.values_list('pk', flat=True),
                self.post_data['groups'])

    def test_post_invalid(self):
        """Invalid POST should not edit the object."""
        self.post_data['username'] = ''
        response = self._post()
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertTrue('object' in response.context)
        self.assertEquals(response.context['object'], self.obj)
        self.assertTrue('form' in response.context)
        self.assertTrue(response.context['form'].is_bound)
        self.assertFalse(response.context['form'].is_valid())
        self._assert_no_change()

    def test_matching_passwords(self):
        """Matching passwords are required to change the password."""
        self.post_data['password1'] = 'aaa'
        self.post_data['password2'] = 'aaa'
        response = self._post()
        self.assertRedirectsNoFollow(response, self.obj.get_absolute_url())
        obj = self.model.objects.get(pk=self.obj.pk)
        self.assertTrue(obj.check_password('aaa'))

    def test_nonmatching_passwords(self):
        """Object shouldn't be edited if passwords are given but unmatching."""
        self.post_data['password1'] = 'aaa'
        self.post_data['password2'] = 'bbb'
        response = self._post()
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        form = response.context['form']
        self.assertTrue(form.is_bound)
        self.assertFalse(form.is_valid())

    def test_edit_groups(self):
        """Should be able to update user's auth groups."""
        groups = [factories.Group() for i in range(2)]
        self.post_data['groups'] = [g.pk for g in groups]
        response = self._post()
        self.assertRedirectsNoFollow(response, self.obj.get_absolute_url())
        updated_user = User.objects.get(pk=self.obj.pk)
        self.assertEquals(updated_user.groups.count(), 2)
        self.assertTrue(groups[0] in updated_user.groups.all())
        self.assertTrue(groups[1] in updated_user.groups.all())


class TestListUsers(ViewTestMixin, TestCase):
    url_name = 'list_users'
    template_name = 'timepiece/user/list.html'
    factory = factories.User
    model = User

    def setUp(self):
        super(TestListUsers, self).setUp()
        # This permission is not created by Django by default.
        ct = ContentType.objects.get(model='user')
        p = Permission.objects.create(content_type=ct, codename='view_user')
        self.user = factories.User(permissions=[p])
        self.login_user(self.user)

    def test_get_no_permission(self):
        """Permission is required for this view."""
        self.user.user_permissions.clear()
        response = self._get()
        self.assertRedirectsToLogin(response)

    def test_list_all(self):
        """If no filters are provided, all objects should be listed."""
        object_list = [self.factory.create() for i in range(2)] + [self.user]
        response = self._get()
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertEquals(response.context['object_list'].count(), 3)
        for obj in object_list:
            self.assertTrue(obj in response.context['object_list'])

    def test_list_one(self):
        """Page should render if there is one object & no search query."""
        response = self._get()
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertEquals(response.context['object_list'].count(), 1)
        self.assertEquals(response.context['object_list'].get(), self.user)

    def test_no_results(self):
        """Page should render if there are no search results."""
        self.factory.create()
        response = self._get(get_kwargs={'search': 'hello'})
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertEquals(response.context['object_list'].count(), 0)

    def test_one_result(self):
        """If there is only one search result, user should be redirected."""
        obj = self.factory.create(first_name='hello')
        response = self._get(get_kwargs={'search': 'hello'})
        self.assertRedirectsNoFollow(response, obj.get_absolute_url())

    def test_multiple_results(self):
        """Page should render if there are multiple search results."""
        obj_list = [self.factory.create(first_name='hello') for i in range(2)]
        response = self._get(get_kwargs={'search': 'hello'})
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertEquals(response.context['object_list'].count(), 2)
        for obj in obj_list:
            self.assertTrue(obj in response.context['object_list'])

    def test_filter_first_name(self):
        """User should be able to filter by search query."""
        self.factory.create()
        obj = self.factory.create(first_name='hello')
        response = self._get(get_kwargs={'search': 'hello'})
        self.assertRedirectsNoFollow(response, obj.get_absolute_url())

    def test_filter_last_name(self):
        """User should be able to filter by search query."""
        self.factory.create()
        obj = self.factory.create(last_name='hello')
        response = self._get(get_kwargs={'search': 'hello'})
        self.assertRedirectsNoFollow(response, obj.get_absolute_url())

    def test_filter_email(self):
        """User should be able to filter by search query."""
        self.factory.create()
        obj = self.factory.create(email='hello@example.com')
        response = self._get(get_kwargs={'search': 'hello'})
        self.assertRedirectsNoFollow(response, obj.get_absolute_url())

    def test_filter_username(self):
        """User should be able to filter by search query."""
        self.factory.create()
        obj = self.factory.create(username='hello')
        response = self._get(get_kwargs={'search': 'hello'})
        self.assertRedirectsNoFollow(response, obj.get_absolute_url())


class TestViewUser(ViewTestMixin, TestCase):
    url_name = 'view_user'
    template_name = 'timepiece/user/view.html'
    model = User
    factory = factories.User
    permissions = ('auth.view_user')
    pk_url_kwarg = 'user_id'

    def setUp(self):
        super(TestViewUser, self).setUp()
        ct = ContentType.objects.get(model='user')
        p = Permission.objects.create(content_type=ct, codename='view_user')
        self.user = factories.User(permissions=[p])
        self.login_user(self.user)
        self.obj = self.factory.create()
        self.url_kwargs = {self.pk_url_kwarg: self.obj.pk}

    def test_get_no_permission(self):
        """Permission is required for this view."""
        self.user.user_permissions.clear()
        response = self._get()
        self.assertRedirectsToLogin(response)

    def test_post(self):
        """This is a GET-only view."""
        response = self._post()
        self.assertEquals(response.status_code, 405)

    def test_bad_pk(self):
        """View should return 404 response if no object is found."""
        self.url_kwargs[self.pk_url_kwarg] = 1234
        response = self._get()
        self.assertEquals(response.status_code, 404)

    def test_get(self):
        """User should be able to view the object detail."""
        response = self._get()
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertTrue('object' in response.context)
        self.assertEquals(response.context['object'], self.obj)


class TestEditSettings(ViewTestMixin, TestCase):
    url_name = 'edit_settings'
    template_name = 'timepiece/user/settings.html'

    def setUp(self):
        self.user = factories.User()
        self.login_user(self.user)
        self.post_data = {
            'first_name': 'First',
            'last_name': 'Last',
            'email': 'hello@example.com',
        }

    def test_unauthenticated(self):
        """User must be logged in for this view."""
        self.client.logout()
        response = self._get()
        self.assertRedirectsToLogin(response)

    def test_get(self):
        """GET should return the page with an unbound form."""
        response = self._get()
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertFalse(response.context['form'].is_bound)

    def test_post_valid(self):
        """POST should edit the authenticated user's data."""
        response = self._post()
        self.assertRedirectsNoFollow(response, reverse('dashboard'))
        updated_user = User.objects.get(pk=self.user.pk)
        for k, v in self.post_data.iteritems():
            self.assertEquals(getattr(updated_user, k), v)

    def test_post_invalid(self):
        """Invalid POST should not edit data."""
        self.post_data['email'] = ''
        response = self._post()
        self.assertEquals(response.status_code, 200)
        self.assertTemplateUsed(response, self.template_name)
        self.assertTrue('form' in response.context)
        self.assertTrue(response.context['form'].is_bound)
        self.assertFalse(response.context['form'].is_valid())
        obj = User.objects.get(pk=self.user.pk)
        self.assertEquals(obj.first_name, self.user.first_name)
        self.assertEquals(obj.last_name, self.user.last_name)
        self.assertEquals(obj.email, self.user.email)

    def test_redirect_to_next(self):
        """Passing next parameter should customize the redirect location."""
        response = self._post(get_kwargs={'next': '/hello/'})
        self.assertRedirectsNoFollow(response, '/hello/')
        updated_user = User.objects.get(pk=self.user.pk)
        for k, v in self.post_data.iteritems():
            self.assertEquals(getattr(updated_user, k), v)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url

from timepiece.crm import views


urlpatterns = patterns('',
    # Search
    url(r'^quick_search/$',
        views.QuickSearch.as_view(),
        name='quick_search'),

    # Users
    url(r'^user/settings/$',
        views.EditSettings.as_view(),
        name='edit_settings'),
    url(r'^user/$',
        views.ListUsers.as_view(),
        name='list_users'),
    url(r'^user/create/$',
        views.CreateUser.as_view(),
        name='create_user'),
    url(r'^user/(?P<user_id>\d+)/$',
        views.ViewUser.as_view(),
        name='view_user'),
    url(r'^user/(?P<user_id>\d+)/edit/$',
        views.EditUser.as_view(),
        name='edit_user'),
    url(r'^user/(?P<user_id>\d+)/delete/$',
        views.DeleteUser.as_view(),
        name='delete_user'),

    # User timesheets
    url(r'^user/(?P<user_id>\d+)/timesheet/' +
                '(?:(?P<active_tab>overview|all-entries|daily-summary)/)?$',
        views.view_user_timesheet,
        name='view_user_timesheet'),
    url(r'^user/(?P<user_id>\d+)/timesheet/reject/$',
        views.reject_user_timesheet,
        name='reject_user_timesheet'),
    url(r'^user/(?P<user_id>\d+)/timesheet/(?P<action>verify|approve)/$',
        views.change_user_timesheet,
        name='change_user_timesheet'),

    # Projects
    url(r'^project/$',
        views.ListProjects.as_view(),
        name='list_projects'),
    url(r'^project/create/$',
        views.CreateProject.as_view(),
        name='create_project'),
    url(r'^project/(?P<project_id>\d+)/$',
        views.ViewProject.as_view(),
        name='view_project'),
    url(r'^project/(?P<project_id>\d+)/edit/$',
        views.EditProject.as_view(),
        name='edit_project'),
    url(r'^project/(?P<project_id>\d+)/delete/$',
        views.DeleteProject.as_view(),
        name='delete_project'),

    # Project timesheets
    url(r'^project/(?P<project_id>\d+)/timesheet/$',
        views.ProjectTimesheet.as_view(),
        name='view_project_timesheet'),
    url(r'^project/(?P<project_id>\d+)/timesheet/csv/$',
        views.ProjectTimesheetCSV.as_view(),
        name='view_project_timesheet_csv'),

    # Businesses
    url(r'^business/$',
        views.ListBusinesses.as_view(),
        name='list_businesses'),
    url(r'^business/create/$',
        views.CreateBusiness.as_view(),
        name='create_business'),
    url(r'^business/(?P<business_id>\d+)/$',
        views.ViewBusiness.as_view(),
        name='view_business'),
    url(r'^business/(?P<business_id>\d+)/edit/$',
        views.EditBusiness.as_view(),
        name='edit_business'),
    url(r'^business/(?P<business_id>\d+)/delete/$',
        views.DeleteBusiness.as_view(),
        name='delete_business'),

    # User-project relationships
    url(r'^relationship/create/$',
        views.CreateRelationship.as_view(),
        name='create_relationship'),
    url(r'^relationship/edit/$',
        views.EditRelationship.as_view(),
        name='edit_relationship'),
    url(r'^relationship/delete/$',
        views.DeleteRelationship.as_view(),
        name='delete_relationship'),
)

########NEW FILE########
__FILENAME__ = utils
from itertools import groupby

from django.db.models import Sum

from timepiece.utils import add_timezone, get_hours_summary, get_week_start


def daily_summary(day_entries):
    projects = {}
    all_day = {}
    for name, entries in groupby(day_entries, lambda x: x['project__name']):
        hours = get_hours_summary(entries)
        projects[name] = hours
        for key in hours.keys():
            if key in all_day:
                all_day[key] += hours[key]
            else:
                all_day[key] = hours[key]
    return (all_day, projects)


def grouped_totals(entries):
    select = {
        "day": {"date": """DATE_TRUNC('day', end_time)"""},
        "week": {"date": """DATE_TRUNC('week', end_time)"""},
    }
    weekly = entries.extra(select=select["week"]).values('date', 'billable')
    weekly = weekly.annotate(hours=Sum('hours')).order_by('date')
    daily = entries.extra(select=select["day"]).values('date', 'project__name',
                                                       'billable')
    daily = daily.annotate(hours=Sum('hours')).order_by('date',
                                                        'project__name')
    weeks = {}
    for week, week_entries in groupby(weekly, lambda x: x['date']):
        if week is not None:
            week = add_timezone(week)
        weeks[week] = get_hours_summary(week_entries)
    days = []
    last_week = None
    for day, day_entries in groupby(daily, lambda x: x['date']):
        week = get_week_start(day)
        if last_week and week > last_week:
            yield last_week, weeks.get(last_week, {}), days
            days = []
        days.append((day, daily_summary(day_entries)))
        last_week = week
    yield week, weeks.get(week, {}), days

########NEW FILE########
__FILENAME__ = views
import datetime
from dateutil.relativedelta import relativedelta
import urllib

from django.contrib import messages
from django.contrib.auth.decorators import login_required, permission_required
from django.contrib.auth.models import User
from django.core.urlresolvers import reverse, reverse_lazy
from django.db import transaction
from django.db.models import Sum
from django.http import HttpResponseRedirect, HttpResponseForbidden, Http404
from django.shortcuts import get_object_or_404, render, redirect
from django.views.decorators.csrf import csrf_exempt
from django.views.generic import (CreateView, DeleteView, DetailView,
        UpdateView, FormView, View)

from timepiece import utils
from timepiece.forms import YearMonthForm, UserYearMonthForm
from timepiece.templatetags.timepiece_tags import seconds_to_hours
from timepiece.utils.csv import CSVViewMixin
from timepiece.utils.search import SearchListView
from timepiece.utils.views import cbv_decorator

from timepiece.crm.forms import (CreateEditBusinessForm, CreateEditProjectForm,
        EditUserSettingsForm, EditProjectRelationshipForm, SelectProjectForm,
        EditUserForm, CreateUserForm, SelectUserForm, ProjectSearchForm,
        QuickSearchForm)
from timepiece.crm.models import Business, Project, ProjectRelationship
from timepiece.crm.utils import grouped_totals
from timepiece.entries.models import Entry


@cbv_decorator(login_required)
class QuickSearch(FormView):
    form_class = QuickSearchForm
    template_name = 'timepiece/quick_search.html'

    def form_valid(self, form):
        return HttpResponseRedirect(form.get_result())


# User timesheets


@permission_required('entries.view_payroll_summary')
def reject_user_timesheet(request, user_id):
    """
    This allows admins to reject all entries, instead of just one
    """
    form = YearMonthForm(request.GET or request.POST)
    user = User.objects.get(pk=user_id)
    if form.is_valid():
        from_date, to_date = form.save()
        entries = Entry.no_join.filter(status=Entry.VERIFIED, user=user,
            start_time__gte=from_date, end_time__lte=to_date)
        if request.POST.get('yes'):
            if entries.exists():
                count = entries.count()
                entries.update(status=Entry.UNVERIFIED)
                msg = 'You have rejected %d previously verified entries.' \
                    % count
            else:
                msg = 'There are no verified entries to reject.'
            messages.info(request, msg)
        else:
            return render(request, 'timepiece/user/timesheet/reject.html', {
                'date': from_date,
                'timesheet_user': user
            })
    else:
        msg = 'You must provide a month and year for entries to be rejected.'
        messages.error(request, msg)

    url = reverse('view_user_timesheet', args=(user_id,))
    return HttpResponseRedirect(url)


@login_required
def view_user_timesheet(request, user_id, active_tab):
    # User can only view their own time sheet unless they have a permission.
    user = get_object_or_404(User, pk=user_id)
    has_perm = request.user.has_perm('entries.view_entry_summary')
    if not (has_perm or user.pk == request.user.pk):
        return HttpResponseForbidden('Forbidden')

    FormClass = UserYearMonthForm if has_perm else YearMonthForm
    form = FormClass(request.GET or None)
    if form.is_valid():
        if has_perm:
            from_date, to_date, form_user = form.save()
            if form_user and request.GET.get('yearmonth', None):
                # Redirect to form_user's time sheet.
                # Do not use request.GET in urlencode to prevent redirect
                # loop caused by yearmonth parameter.
                url = reverse('view_user_timesheet', args=(form_user.pk,))
                request_data = {
                    'month': from_date.month,
                    'year': from_date.year,
                    'user': form_user.pk,  # Keep so that user appears in form.
                }
                url += '?{0}'.format(urllib.urlencode(request_data))
                return HttpResponseRedirect(url)
        else:  # User must be viewing their own time sheet; no redirect needed.
            from_date, to_date = form.save()
        from_date = utils.add_timezone(from_date)
        to_date = utils.add_timezone(to_date)
    else:
        # Default to showing this month.
        from_date = utils.get_month_start()
        to_date = from_date + relativedelta(months=1)

    entries_qs = Entry.objects.filter(user=user)
    month_qs = entries_qs.timespan(from_date, span='month')
    extra_values = ('start_time', 'end_time', 'comments', 'seconds_paused',
            'id', 'location__name', 'project__name', 'activity__name',
            'status')
    month_entries = month_qs.date_trunc('month', extra_values)
    # For grouped entries, back date up to the start of the week.
    first_week = utils.get_week_start(from_date)
    month_week = first_week + relativedelta(weeks=1)
    grouped_qs = entries_qs.timespan(first_week, to_date=to_date)
    intersection = grouped_qs.filter(start_time__lt=month_week,
        start_time__gte=from_date)
    # If the month of the first week starts in the previous
    # month and we dont have entries in that previous ISO
    # week, then update the first week to start at the first
    # of the actual month
    if not intersection and first_week.month < from_date.month:
        grouped_qs = entries_qs.timespan(from_date, to_date=to_date)
    totals = grouped_totals(grouped_qs) if month_entries else ''
    project_entries = month_qs.order_by().values(
        'project__name').annotate(sum=Sum('hours')).order_by('-sum')
    summary = Entry.summary(user, from_date, to_date)

    show_approve = show_verify = False
    can_change = request.user.has_perm('entries.change_entry')
    can_approve = request.user.has_perm('entries.approve_timesheet')
    if can_change or can_approve or user == request.user:
        statuses = list(month_qs.values_list('status', flat=True))
        total_statuses = len(statuses)
        unverified_count = statuses.count(Entry.UNVERIFIED)
        verified_count = statuses.count(Entry.VERIFIED)
        approved_count = statuses.count(Entry.APPROVED)
    if can_change or user == request.user:
        show_verify = unverified_count != 0
    if can_approve:
        show_approve = verified_count + approved_count == total_statuses \
                and verified_count > 0 and total_statuses != 0

    return render(request, 'timepiece/user/timesheet/view.html', {
        'active_tab': active_tab or 'overview',
        'year_month_form': form,
        'from_date': from_date,
        'to_date': to_date - relativedelta(days=1),
        'show_verify': show_verify,
        'show_approve': show_approve,
        'timesheet_user': user,
        'entries': month_entries,
        'grouped_totals': totals,
        'project_entries': project_entries,
        'summary': summary,
    })


@login_required
def change_user_timesheet(request, user_id, action):
    user = get_object_or_404(User, pk=user_id)
    admin_verify = request.user.has_perm('entries.view_entry_summary')
    perm = True

    if not admin_verify and action == 'verify' and user != request.user:
        perm = False
    if not admin_verify and action == 'approve':
        perm = False

    if not perm:
        return HttpResponseForbidden('Forbidden: You cannot {0} this '
                'timesheet.'.format(action))

    try:
        from_date = request.GET.get('from_date')
        from_date = utils.add_timezone(
            datetime.datetime.strptime(from_date, '%Y-%m-%d'))
    except (ValueError, OverflowError, KeyError):
        raise Http404
    to_date = from_date + relativedelta(months=1)
    entries = Entry.no_join.filter(user=user_id,
                                   end_time__gte=from_date,
                                   end_time__lt=to_date)
    active_entries = Entry.no_join.filter(
        user=user_id,
        start_time__lt=to_date,
        end_time=None,
        status=Entry.UNVERIFIED,
    )
    filter_status = {
        'verify': Entry.UNVERIFIED,
        'approve': Entry.VERIFIED,
    }
    entries = entries.filter(status=filter_status[action])

    return_url = reverse('view_user_timesheet', args=(user_id,))
    return_url += '?%s' % urllib.urlencode({
        'year': from_date.year,
        'month': from_date.month,
    })
    if active_entries:
        msg = 'You cannot verify/approve this timesheet while the user {0} ' \
            'has an active entry. Please have them close any active ' \
            'entries.'.format(user.get_name_or_username())
        messages.error(request, msg)
        return redirect(return_url)
    if request.POST.get('do_action') == 'Yes':
        update_status = {
            'verify': 'verified',
            'approve': 'approved',
        }
        entries.update(status=update_status[action])
        messages.info(request,
            'Your entries have been %s' % update_status[action])
        return redirect(return_url)
    hours = entries.all().aggregate(s=Sum('hours'))['s']
    if not hours:
        msg = 'You cannot verify/approve a timesheet with no hours'
        messages.error(request, msg)
        return redirect(return_url)
    return render(request, 'timepiece/user/timesheet/change.html', {
        'action': action,
        'timesheet_user': user,
        'from_date': from_date,
        'to_date': to_date - relativedelta(days=1),
        'return_url': return_url,
        'hours': hours,
    })


# Project timesheets


@cbv_decorator(permission_required('entries.view_project_timesheet'))
class ProjectTimesheet(DetailView):
    template_name = 'timepiece/project/timesheet.html'
    model = Project
    context_object_name = 'project'
    pk_url_kwarg = 'project_id'

    def get(self, *args, **kwargs):
        if 'csv' in self.request.GET:
            request_get = self.request.GET.copy()
            request_get.pop('csv')
            return_url = reverse('view_project_timesheet_csv',
                                 args=(self.get_object().pk,))
            return_url += '?%s' % urllib.urlencode(request_get)
            return redirect(return_url)
        return super(ProjectTimesheet, self).get(*args, **kwargs)

    def get_context_data(self, **kwargs):
        context = super(ProjectTimesheet, self).get_context_data(**kwargs)
        project = self.object
        year_month_form = YearMonthForm(self.request.GET or None)
        if self.request.GET and year_month_form.is_valid():
            from_date, to_date = year_month_form.save()
        else:
            date = utils.add_timezone(datetime.datetime.today())
            from_date = utils.get_month_start(date).date()
            to_date = from_date + relativedelta(months=1)
        entries_qs = Entry.objects
        entries_qs = entries_qs.timespan(from_date, span='month').filter(
            project=project
        )
        extra_values = ('start_time', 'end_time', 'comments', 'seconds_paused',
                'id', 'location__name', 'project__name', 'activity__name',
                'status')
        month_entries = entries_qs.date_trunc('month', extra_values)
        total = entries_qs.aggregate(hours=Sum('hours'))['hours']
        user_entries = entries_qs.order_by().values(
            'user__first_name', 'user__last_name').annotate(
            sum=Sum('hours')).order_by('-sum'
        )
        activity_entries = entries_qs.order_by().values(
            'activity__name').annotate(
            sum=Sum('hours')).order_by('-sum'
        )
        context.update({
            'project': project,
            'year_month_form': year_month_form,
            'from_date': from_date,
            'to_date': to_date - relativedelta(days=1),
            'entries': month_entries,
            'total': total,
            'user_entries': user_entries,
            'activity_entries': activity_entries,
        })
        return context


class ProjectTimesheetCSV(CSVViewMixin, ProjectTimesheet):

    def get_filename(self, context):
        project = self.object.name
        to_date_str = context['to_date'].strftime('%m-%d-%Y')
        return 'Project_timesheet {0} {1}'.format(project, to_date_str)

    def convert_context_to_csv(self, context):
        rows = []
        rows.append([
            'Date',
            'User',
            'Activity',
            'Location',
            'Time In',
            'Time Out',
            'Breaks',
            'Hours',
        ])
        for entry in context['entries']:
            data = [
                entry['start_time'].strftime('%x'),
                entry['user__first_name'] + ' ' + entry['user__last_name'],
                entry['activity__name'],
                entry['location__name'],
                entry['start_time'].strftime('%X'),
                entry['end_time'].strftime('%X'),
                seconds_to_hours(entry['seconds_paused']),
                entry['hours'],
            ]
            rows.append(data)
        total = context['total']
        rows.append(('', '', '', '', '', '', 'Total:', total))
        return rows


# Businesses


@cbv_decorator(permission_required('crm.view_business'))
class ListBusinesses(SearchListView):
    model = Business
    redirect_if_one_result = True
    search_fields = ['name__icontains', 'description__icontains']
    template_name = 'timepiece/business/list.html'


@cbv_decorator(permission_required('crm.view_business'))
class ViewBusiness(DetailView):
    model = Business
    pk_url_kwarg = 'business_id'
    template_name = 'timepiece/business/view.html'


@cbv_decorator(permission_required('crm.add_business'))
class CreateBusiness(CreateView):
    model = Business
    form_class = CreateEditBusinessForm
    template_name = 'timepiece/business/create_edit.html'


@cbv_decorator(permission_required('crm.delete_business'))
class DeleteBusiness(DeleteView):
    model = Business
    success_url = reverse_lazy('list_businesses')
    pk_url_kwarg = 'business_id'
    template_name = 'timepiece/delete_object.html'


@cbv_decorator(permission_required('crm.change_business'))
class EditBusiness(UpdateView):
    model = Business
    form_class = CreateEditBusinessForm
    template_name = 'timepiece/business/create_edit.html'
    pk_url_kwarg = 'business_id'


# Users


@cbv_decorator(login_required)
class EditSettings(UpdateView):
    form_class = EditUserSettingsForm
    template_name = 'timepiece/user/settings.html'

    def get_object(self, queryset=None):
        return self.request.user

    def get_success_url(self):
        messages.info(self.request, 'Your settings have been updated.')
        return self.request.REQUEST.get('next', None) or reverse('dashboard')


@cbv_decorator(permission_required('auth.view_user'))
class ListUsers(SearchListView):
    model = User
    redirect_if_one_result = True
    search_fields = ['first_name__icontains', 'last_name__icontains',
            'email__icontains', 'username__icontains']
    template_name = 'timepiece/user/list.html'

    def get_queryset(self):
        return super(ListUsers, self).get_queryset().select_related()


@cbv_decorator(permission_required('auth.view_user'))
class ViewUser(DetailView):
    model = User
    pk_url_kwarg = 'user_id'
    template_name = 'timepiece/user/view.html'

    def get_context_data(self, **kwargs):
        kwargs.update({'add_project_form': SelectProjectForm()})
        return super(ViewUser, self).get_context_data(**kwargs)


@cbv_decorator(permission_required('auth.add_user'))
class CreateUser(CreateView):
    model = User
    form_class = CreateUserForm
    template_name = 'timepiece/user/create_edit.html'


@cbv_decorator(permission_required('auth.delete_user'))
class DeleteUser(DeleteView):
    model = User
    success_url = reverse_lazy('list_users')
    pk_url_kwarg = 'user_id'
    template_name = 'timepiece/delete_object.html'


@cbv_decorator(permission_required('auth.change_user'))
class EditUser(UpdateView):
    model = User
    form_class = EditUserForm
    template_name = 'timepiece/user/create_edit.html'
    pk_url_kwarg = 'user_id'


# Projects


@cbv_decorator(permission_required('crm.view_project'))
class ListProjects(SearchListView):
    model = Project
    form_class = ProjectSearchForm
    redirect_if_one_result = True
    search_fields = ['name__icontains', 'description__icontains']
    template_name = 'timepiece/project/list.html'

    def filter_form_valid(self, form, queryset):
        queryset = super(ListProjects, self).filter_form_valid(form, queryset)
        status = form.cleaned_data['status']
        if status:
            queryset = queryset.filter(status=status)
        return queryset


@cbv_decorator(permission_required('crm.view_project'))
class ViewProject(DetailView):
    model = Project
    pk_url_kwarg = 'project_id'
    template_name = 'timepiece/project/view.html'

    def get_context_data(self, **kwargs):
        kwargs.update({'add_user_form': SelectUserForm()})
        return super(ViewProject, self).get_context_data(**kwargs)


@cbv_decorator(permission_required('crm.add_project'))
class CreateProject(CreateView):
    model = Project
    form_class = CreateEditProjectForm
    template_name = 'timepiece/project/create_edit.html'


@cbv_decorator(permission_required('crm.delete_project'))
class DeleteProject(DeleteView):
    model = Project
    success_url = reverse_lazy('list_projects')
    pk_url_kwarg = 'project_id'
    template_name = 'timepiece/delete_object.html'


@cbv_decorator(permission_required('crm.change_project'))
class EditProject(UpdateView):
    model = Project
    form_class = CreateEditProjectForm
    template_name = 'timepiece/project/create_edit.html'
    pk_url_kwarg = 'project_id'


# User-project relationships


@cbv_decorator(permission_required('crm.add_projectrelationship'))
@cbv_decorator(csrf_exempt)
@cbv_decorator(transaction.commit_on_success)
class CreateRelationship(View):

    def post(self, request, *args, **kwargs):
        user = self.get_user()
        project = self.get_project()
        if user and project:
            ProjectRelationship.objects.get_or_create(user=user, project=project)
        redirect_to = request.REQUEST.get('next', None) or reverse('dashboard')
        return HttpResponseRedirect(redirect_to)

    def get_user(self):
        user_id = self.request.REQUEST.get('user_id', None)
        if user_id:
            return get_object_or_404(User, pk=user_id)
        return SelectUserForm(self.request.POST).get_user()

    def get_project(self):
        project_id = self.request.REQUEST.get('project_id', None)
        if project_id:
            return get_object_or_404(Project, pk=project_id)
        return SelectProjectForm(self.request.POST).get_project()


class RelationshipObjectMixin(object):
    """Handles retrieving and redirecting for ProjectRelationship objects."""

    def get_object(self, queryset=None):
        queryset = self.get_queryset() if queryset is None else queryset
        user_id = self.request.REQUEST.get('user_id', None)
        project_id = self.request.REQUEST.get('project_id', None)
        return get_object_or_404(self.model, user__id=user_id,
                project__id=project_id)

    def get_success_url(self):
        return self.request.REQUEST.get('next',
                self.object.project.get_absolute_url())


@cbv_decorator(permission_required('crm.change_projectrelationship'))
@cbv_decorator(transaction.commit_on_success)
class EditRelationship(RelationshipObjectMixin, UpdateView):
    model = ProjectRelationship
    template_name = 'timepiece/relationship/edit.html'
    form_class = EditProjectRelationshipForm


@cbv_decorator(permission_required('crm.delete_projectrelationship'))
@cbv_decorator(csrf_exempt)
@cbv_decorator(transaction.commit_on_success)
class DeleteRelationship(RelationshipObjectMixin, DeleteView):
    model = ProjectRelationship
    template_name = 'timepiece/relationship/delete.html'

########NEW FILE########
__FILENAME__ = defaults

class TimepieceDefaults(object):

    TIMEPIECE_DEFAULT_LOCATION_SLUG = None

    TIMEPIECE_PAID_LEAVE_PROJECTS = {}

    TIMEPIECE_ACCOUNTING_EMAILS = []

    TIMEPIECE_EMAILS_USE_HTTPS = True

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

from timepiece.entries.models import Activity, ActivityGroup, Entry, Location,\
        ProjectHours


class ActivityAdmin(admin.ModelAdmin):
    model = Activity
    list_display = ('code', 'name', 'billable')
    list_filter = ('billable',)


class ActivityGroupAdmin(admin.ModelAdmin):
    model = ActivityGroup
    list_display = ('name',)
    list_filter = ('activities',)
    filter_horizontal = ('activities',)


class EntryAdmin(admin.ModelAdmin):
    model = Entry
    list_display = ('user', '_project', 'location', 'project_type', 'activity',
            'start_time', 'end_time', 'hours', 'is_closed', 'is_paused')
    list_filter = ['activity', 'project__type', 'user', 'project']
    search_fields = ['user__first_name', 'user__last_name', 'project__name',
            'activity__name', 'comments']
    date_hierarchy = 'start_time'
    ordering = ('-start_time',)

    def project_type(self, entry):
        return entry.project.type

    def _project(self, obj):
        """Use a proxy to avoid an infinite loop from ordering."""
        return unicode(obj.project)
    _project.admin_order_field = 'project__name'
    _project.short_description = 'Project'


class LocationAdmin(admin.ModelAdmin):
    list_display = ('id', 'name')


class ProjectHoursAdmin(admin.ModelAdmin):
    list_display = ('_user', '_project', 'week_start', 'hours', 'published')

    def _user(self, obj):
        return obj.user.get_name_or_username()
    _user.short_description = 'User'
    _user.admin_order_field = 'user__last_name'

    def _project(self, obj):
        """Use a proxy to avoid an infinite loop from ordering."""
        return unicode(obj.project)
    _project.admin_order_field = 'project__name'
    _project.short_description = 'Project'


admin.site.register(Activity, ActivityAdmin)
admin.site.register(ActivityGroup, ActivityGroupAdmin)
admin.site.register(Entry, EntryAdmin)
admin.site.register(Location, LocationAdmin)
admin.site.register(ProjectHours, ProjectHoursAdmin)

########NEW FILE########
__FILENAME__ = forms
import datetime
from dateutil.relativedelta import relativedelta

from django import forms

from timepiece import utils
from timepiece.crm.models import Project
from timepiece.entries.models import Entry, Location, ProjectHours
from timepiece.forms import INPUT_FORMATS, TimepieceSplitDateTimeWidget,\
        TimepieceDateInput


class ClockInForm(forms.ModelForm):
    active_comment = forms.CharField(label='Notes for the active entry',
            widget=forms.Textarea, required=False)

    class Meta:
        model = Entry
        fields = ('active_comment', 'location', 'project', 'activity',
                'start_time', 'comments')

    def __init__(self, *args, **kwargs):
        self.user = kwargs.pop('user')
        self.active = kwargs.pop('active', None)

        initial = kwargs.get('initial', {})
        default_loc = utils.get_setting('TIMEPIECE_DEFAULT_LOCATION_SLUG')
        if default_loc:
            try:
                loc = Location.objects.get(slug=default_loc)
            except Location.DoesNotExist:
                loc = None
            if loc:
                initial['location'] = loc.pk
        project = initial.get('project', None)
        try:
            last_project_entry = Entry.objects.filter(
                user=self.user, project=project).order_by('-end_time')[0]
        except IndexError:
            initial['activity'] = None
        else:
            initial['activity'] = last_project_entry.activity.pk

        super(ClockInForm, self).__init__(*args, **kwargs)

        self.fields['start_time'].required = False
        self.fields['start_time'].initial = datetime.datetime.now()
        self.fields['start_time'].widget = TimepieceSplitDateTimeWidget()
        self.fields['project'].queryset = Project.trackable.filter(
                users=self.user)
        if not self.active:
            self.fields.pop('active_comment')
        else:
            self.fields['active_comment'].initial = self.active.comments
        self.instance.user = self.user

    def clean_start_time(self):
        """
        Make sure that the start time doesn't come before the active entry
        """
        start = self.cleaned_data.get('start_time')
        if not start:
            return start
        active_entries = self.user.timepiece_entries.filter(
            start_time__gte=start, end_time__isnull=True)
        for entry in active_entries:
            output = 'The start time is on or before the current entry: ' + \
            '%s - %s starting at %s' % (entry.project, entry.activity,
                entry.start_time.strftime('%H:%M:%S'))
            raise forms.ValidationError(output)
        return start

    def clean(self):
        start_time = self.clean_start_time()
        data = self.cleaned_data
        if not start_time:
            return data
        if self.active:
            self.active.unpause()
            self.active.comments = data['active_comment']
            self.active.end_time = start_time - relativedelta(seconds=1)
            if not self.active.clean():
                raise forms.ValidationError(data)
        return data

    def save(self, commit=True):
        self.instance.hours = 0
        entry = super(ClockInForm, self).save(commit=commit)
        if self.active and commit:
            self.active.save()
        return entry


class ClockOutForm(forms.ModelForm):
    start_time = forms.DateTimeField(widget=TimepieceSplitDateTimeWidget)
    end_time = forms.DateTimeField(widget=TimepieceSplitDateTimeWidget)

    class Meta:
        model = Entry
        fields = ('location', 'start_time', 'end_time', 'comments')

    def __init__(self, *args, **kwargs):
        kwargs['initial'] = kwargs.get('initial', None) or {}
        kwargs['initial']['end_time'] = datetime.datetime.now()
        super(ClockOutForm, self).__init__(*args, **kwargs)

    def save(self, commit=True):
        entry = super(ClockOutForm, self).save(commit=False)
        entry.unpause(entry.end_time)
        if commit:
            entry.save()
        return entry


class AddUpdateEntryForm(forms.ModelForm):
    start_time = forms.DateTimeField(widget=TimepieceSplitDateTimeWidget(),
            required=True)
    end_time = forms.DateTimeField(widget=TimepieceSplitDateTimeWidget())

    class Meta:
        model = Entry
        exclude = ('user', 'pause_time', 'site', 'hours', 'status',
                   'entry_group')

    def __init__(self, *args, **kwargs):
        self.user = kwargs.pop('user')
        super(AddUpdateEntryForm, self).__init__(*args, **kwargs)
        self.instance.user = self.user

        self.fields['project'].queryset = Project.trackable.filter(
                users=self.user)
        # If editing the active entry, remove the end_time field.
        if self.instance.start_time and not self.instance.end_time:
            self.fields.pop('end_time')

    def clean(self):
        """
        If we're not editing the active entry, ensure that this entry doesn't
        conflict with or come after the active entry.
        """
        active = utils.get_active_entry(self.user)
        if active and active.pk != self.instance.pk:
            start_time = self.cleaned_data.get('start_time', None)
            end_time = self.cleaned_data.get('end_time', None)
            if (start_time and start_time > active.start_time) or \
                    (end_time and end_time > active.start_time):
                raise forms.ValidationError('The start time or end time '
                        'conflict with the active entry: {activity} on '
                        '{project} starting at {start_time}.'.format(**{
                            'project': active.project,
                            'activity': active.activity,
                            'start_time': active.start_time.strftime('%H:%M:%S'),
                        }))
        return self.cleaned_data


class ProjectHoursForm(forms.ModelForm):

    class Meta:
        model = ProjectHours


class ProjectHoursSearchForm(forms.Form):
    week_start = forms.DateField(label='Week of', required=False,
            input_formats=INPUT_FORMATS, widget=TimepieceDateInput())

    def clean_week_start(self):
        week_start = self.cleaned_data.get('week_start', None)
        return utils.get_week_start(week_start, False) if week_start else None

########NEW FILE########
__FILENAME__ = 0001_initial
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding model 'Activity'
        db.create_table('timepiece_activity', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('code', self.gf('django.db.models.fields.CharField')(unique=True, max_length=5)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=50)),
            ('billable', self.gf('django.db.models.fields.BooleanField')(default=True)),
        ))
        db.send_create_signal('entries', ['Activity'])

        # Adding model 'ActivityGroup'
        db.create_table('timepiece_activitygroup', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.CharField')(unique=True, max_length=255)),
        ))
        db.send_create_signal('entries', ['ActivityGroup'])

        # Adding M2M table for field activities on 'ActivityGroup'
        db.create_table('timepiece_activitygroup_activities', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('activitygroup', models.ForeignKey(orm['entries.activitygroup'], null=False)),
            ('activity', models.ForeignKey(orm['entries.activity'], null=False))
        ))
        db.create_unique('timepiece_activitygroup_activities', ['activitygroup_id', 'activity_id'])

        # Adding model 'Location'
        db.create_table('timepiece_location', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.CharField')(unique=True, max_length=255)),
            ('slug', self.gf('django.db.models.fields.CharField')(unique=True, max_length=255)),
        ))
        db.send_create_signal('entries', ['Location'])

        # Adding model 'Entry'
        db.create_table('timepiece_entry', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(related_name='timepiece_entries', to=orm['auth.User'])),
            ('project', self.gf('django.db.models.fields.related.ForeignKey')(related_name='entries', to=orm['crm.Project'])),
            ('activity', self.gf('django.db.models.fields.related.ForeignKey')(related_name='entries', to=orm['entries.Activity'])),
            ('location', self.gf('django.db.models.fields.related.ForeignKey')(related_name='entries', to=orm['entries.Location'])),
            ('entry_group', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='entries', null=True, on_delete=models.SET_NULL, to=orm['contracts.EntryGroup'])),
            ('status', self.gf('django.db.models.fields.CharField')(default='unverified', max_length=24)),
            ('start_time', self.gf('django.db.models.fields.DateTimeField')()),
            ('end_time', self.gf('django.db.models.fields.DateTimeField')(db_index=True, null=True, blank=True)),
            ('seconds_paused', self.gf('django.db.models.fields.PositiveIntegerField')(default=0)),
            ('pause_time', self.gf('django.db.models.fields.DateTimeField')(null=True, blank=True)),
            ('comments', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('date_updated', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
            ('hours', self.gf('django.db.models.fields.DecimalField')(default=0, max_digits=8, decimal_places=2)),
        ))
        db.send_create_signal('entries', ['Entry'])

        # Adding model 'ProjectHours'
        db.create_table('timepiece_projecthours', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('week_start', self.gf('django.db.models.fields.DateField')()),
            ('project', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['crm.Project'])),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['auth.User'])),
            ('hours', self.gf('django.db.models.fields.DecimalField')(default=0, max_digits=8, decimal_places=2)),
            ('published', self.gf('django.db.models.fields.BooleanField')(default=False)),
        ))
        db.send_create_signal('entries', ['ProjectHours'])

        # Adding unique constraint on 'ProjectHours', fields ['week_start', 'project', 'user']
        db.create_unique('timepiece_projecthours', ['week_start', 'project_id', 'user_id'])


    def backwards(self, orm):
        # Removing unique constraint on 'ProjectHours', fields ['week_start', 'project', 'user']
        db.delete_unique('timepiece_projecthours', ['week_start', 'project_id', 'user_id'])

        # Deleting model 'Activity'
        db.delete_table('timepiece_activity')

        # Deleting model 'ActivityGroup'
        db.delete_table('timepiece_activitygroup')

        # Removing M2M table for field activities on 'ActivityGroup'
        db.delete_table('timepiece_activitygroup_activities')

        # Deleting model 'Location'
        db.delete_table('timepiece_location')

        # Deleting model 'Entry'
        db.delete_table('timepiece_entry')

        # Deleting model 'ProjectHours'
        db.delete_table('timepiece_projecthours')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'contracts.entrygroup': {
            'Meta': {'object_name': 'EntryGroup'},
            'comments': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'end': ('django.db.models.fields.DateField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'modified': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'number': ('django.db.models.fields.CharField', [], {'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'project': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'entry_group'", 'to': "orm['crm.Project']"}),
            'start': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'invoiced'", 'max_length': '24'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'entry_group'", 'to': "orm['auth.User']"})
        },
        'crm.attribute': {
            'Meta': {'ordering': "('sort_order',)", 'unique_together': "(('type', 'label'),)", 'object_name': 'Attribute', 'db_table': "'timepiece_attribute'"},
            'billable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'enable_timetracking': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'label': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'sort_order': ('django.db.models.fields.SmallIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'type': ('django.db.models.fields.CharField', [], {'max_length': '32'})
        },
        'crm.business': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Business', 'db_table': "'timepiece_business'"},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'external_id': ('django.db.models.fields.CharField', [], {'max_length': '32', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'notes': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'short_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'})
        },
        'crm.project': {
            'Meta': {'ordering': "('name', 'status', 'type')", 'object_name': 'Project', 'db_table': "'timepiece_project'"},
            'activity_group': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'activity_group'", 'null': 'True', 'to': "orm['entries.ActivityGroup']"}),
            'business': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'new_business_projects'", 'to': "orm['crm.Business']"}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'point_person': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'status': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'projects_with_status'", 'to': "orm['crm.Attribute']"}),
            'tracker_url': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '255', 'blank': 'True'}),
            'type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'projects_with_type'", 'to': "orm['crm.Attribute']"}),
            'users': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'user_projects'", 'symmetrical': 'False', 'through': "orm['crm.ProjectRelationship']", 'to': "orm['auth.User']"})
        },
        'crm.projectrelationship': {
            'Meta': {'unique_together': "(('user', 'project'),)", 'object_name': 'ProjectRelationship', 'db_table': "'timepiece_projectrelationship'"},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'project': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'project_relationships'", 'to': "orm['crm.Project']"}),
            'types': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'project_relationships'", 'blank': 'True', 'to': "orm['crm.RelationshipType']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'project_relationships'", 'to': "orm['auth.User']"})
        },
        'crm.relationshiptype': {
            'Meta': {'object_name': 'RelationshipType', 'db_table': "'timepiece_relationshiptype'"},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255'})
        },
        'entries.activity': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Activity', 'db_table': "'timepiece_activity'"},
            'billable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'code': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '5'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'entries.activitygroup': {
            'Meta': {'object_name': 'ActivityGroup', 'db_table': "'timepiece_activitygroup'"},
            'activities': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'activity_group'", 'symmetrical': 'False', 'to': "orm['entries.Activity']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        },
        'entries.entry': {
            'Meta': {'ordering': "('-start_time',)", 'object_name': 'Entry', 'db_table': "'timepiece_entry'"},
            'activity': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'entries'", 'to': "orm['entries.Activity']"}),
            'comments': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'date_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'end_time': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'entry_group': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'entries'", 'null': 'True', 'on_delete': 'models.SET_NULL', 'to': "orm['contracts.EntryGroup']"}),
            'hours': ('django.db.models.fields.DecimalField', [], {'default': '0', 'max_digits': '8', 'decimal_places': '2'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'entries'", 'to': "orm['entries.Location']"}),
            'pause_time': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'project': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'entries'", 'to': "orm['crm.Project']"}),
            'seconds_paused': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0'}),
            'start_time': ('django.db.models.fields.DateTimeField', [], {}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'unverified'", 'max_length': '24'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'timepiece_entries'", 'to': "orm['auth.User']"})
        },
        'entries.location': {
            'Meta': {'object_name': 'Location', 'db_table': "'timepiece_location'"},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        },
        'entries.projecthours': {
            'Meta': {'unique_together': "(('week_start', 'project', 'user'),)", 'object_name': 'ProjectHours', 'db_table': "'timepiece_projecthours'"},
            'hours': ('django.db.models.fields.DecimalField', [], {'default': '0', 'max_digits': '8', 'decimal_places': '2'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'project': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['crm.Project']"}),
            'published': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'week_start': ('django.db.models.fields.DateField', [], {})
        }
    }

    complete_apps = ['entries']
########NEW FILE########
__FILENAME__ = models
from dateutil.relativedelta import relativedelta
from decimal import Decimal

from django.contrib.auth.models import User
from django.core import validators
from django.core.exceptions import ValidationError
from django.db import models
from django.db.models import Q, Sum, Max, Min
from django.utils import timezone

from timepiece import utils
from timepiece.crm.models import Project


class Activity(models.Model):
    """
    Represents different types of activity: debugging, developing,
    brainstorming, QA, etc...
    """
    code = models.CharField(max_length=5, unique=True, help_text='Enter a '
            'short code to describe the type of activity that took place.')
    name = models.CharField(max_length=50, help_text='Now enter a more '
            'meaningful name for the activity.')
    billable = models.BooleanField(default=True)

    def __unicode__(self):
        return self.name

    class Meta:
        db_table = 'timepiece_activity'  # Using legacy table name
        ordering = ('name',)
        verbose_name_plural = 'activities'


class ActivityGroup(models.Model):
    """Activities that are allowed for a project"""
    name = models.CharField(max_length=255, unique=True)
    activities = models.ManyToManyField(Activity, related_name='activity_group')

    class Meta:
        db_table = 'timepiece_activitygroup'  # Using legacy table

    def __unicode__(self):
        return self.name


class Location(models.Model):
    name = models.CharField(max_length=255, unique=True)
    slug = models.CharField(max_length=255, unique=True)

    class Meta:
        db_table = 'timepiece_location'  # Using legacy table name

    def __unicode__(self):
        return self.name


class EntryQuerySet(models.query.QuerySet):
    """QuerySet extension to provide filtering by billable status"""

    def date_trunc(self, key='month', extra_values=None):
        select = {"day": {"date": """DATE_TRUNC('day', end_time)"""},
                  "week": {"date": """DATE_TRUNC('week', end_time)"""},
                  "month": {"date": """DATE_TRUNC('month', end_time)"""},
                  "year": {"date": """DATE_TRUNC('year', end_time)"""},
        }
        basic_values = (
            'user', 'date', 'user__first_name', 'user__last_name', 'billable',
        )
        extra_values = extra_values or ()
        qs = self.extra(select=select[key])
        qs = qs.values(*basic_values + extra_values)
        qs = qs.annotate(hours=Sum('hours')).order_by('user__last_name',
                                                      'date')
        return qs

    def timespan(self, from_date, to_date=None, span=None, current=False):
        """
        Takes a beginning date a filters entries. An optional to_date can be
        specified, or a span, which is one of ('month', 'week', 'day').
        N.B. - If given a to_date, it does not include that date, only before.
        """
        if span and not to_date:
            diff = None
            if span == 'month':
                diff = relativedelta(months=1)
            elif span == 'week':
                diff = relativedelta(days=7)
            elif span == 'day':
                diff = relativedelta(days=1)
            if diff is not None:
                to_date = from_date + diff
        datesQ = Q(end_time__gte=from_date)
        datesQ &= Q(end_time__lt=to_date) if to_date else Q()
        datesQ |= Q(end_time__isnull=True) if current else Q()
        return self.filter(datesQ)


class EntryManager(models.Manager):

    def get_query_set(self):
        qs = EntryQuerySet(self.model)
        qs = qs.select_related('activity', 'project__type')

        # ensure our select_related are added.  Without this line later calls
        # to select_related will void ours (not sure why - probably a bug
        # in Django)
        # in other words: do not remove!
        str(qs.query)

        qs = qs.extra({'billable': 'timepiece_activity.billable AND '
                                   'timepiece_attribute.billable'})
        return qs

    def date_trunc(self, key='month', extra_values=()):
        return self.get_query_set().date_trunc(key, extra_values)

    def timespan(self, from_date, to_date=None, span='month'):
        return self.get_query_set().timespan(from_date, to_date, span)


class EntryWorkedManager(models.Manager):

    def get_query_set(self):
        qs = EntryQuerySet(self.model)
        projects = utils.get_setting('TIMEPIECE_PAID_LEAVE_PROJECTS')
        return qs.exclude(project__in=projects.values())


class Entry(models.Model):
    """
    This class is where all of the time logs are taken care of
    """
    UNVERIFIED = 'unverified'
    VERIFIED = 'verified'
    APPROVED = 'approved'
    INVOICED = 'invoiced'
    NOT_INVOICED = 'not-invoiced'
    STATUSES = {
        UNVERIFIED: 'Unverified',
        VERIFIED: 'Verified',
        APPROVED: 'Approved',
        INVOICED: 'Invoiced',
        NOT_INVOICED: 'Not Invoiced',
    }

    user = models.ForeignKey(User, related_name='timepiece_entries')
    project = models.ForeignKey('crm.Project', related_name='entries')
    activity = models.ForeignKey(Activity, related_name='entries')
    location = models.ForeignKey(Location, related_name='entries')
    entry_group = models.ForeignKey('contracts.EntryGroup', blank=True,
            null=True, related_name='entries', on_delete=models.SET_NULL)
    status = models.CharField(max_length=24, choices=STATUSES.items(),
            default=UNVERIFIED)

    start_time = models.DateTimeField()
    end_time = models.DateTimeField(blank=True, null=True, db_index=True)
    seconds_paused = models.PositiveIntegerField(default=0)
    pause_time = models.DateTimeField(blank=True, null=True)
    comments = models.TextField(blank=True)
    date_updated = models.DateTimeField(auto_now=True)

    hours = models.DecimalField(max_digits=8, decimal_places=2, default=0)

    objects = EntryManager()
    worked = EntryWorkedManager()
    no_join = models.Manager()

    class Meta:
        db_table = 'timepiece_entry'  # Using legacy table name
        ordering = ('-start_time',)
        verbose_name_plural = 'entries'
        permissions = (
            ('can_clock_in', 'Can use Pendulum to clock in'),
            ('can_pause', 'Can pause and unpause log entries'),
            ('can_clock_out', 'Can use Pendulum to clock out'),
            ('view_entry_summary', 'Can view entry summary page'),
            ('view_payroll_summary', 'Can view payroll summary page'),
            ('approve_timesheet', 'Can approve a verified timesheet'),
        )

    def __unicode__(self):
        return '%s on %s' % (self.user, self.project)

    def check_overlap(self, entry_b, **kwargs):
        """Return True if the two entries overlap."""
        consider_pause = kwargs.get('pause', True)
        entry_a = self
        #if entries are open, consider them to be closed right now
        if not entry_a.end_time or not entry_b.end_time:
            return False
        #Check the two entries against each other
        start_inside = entry_a.start_time > entry_b.start_time \
            and entry_a.start_time < entry_b.end_time
        end_inside = entry_a.end_time > entry_b.start_time \
            and entry_a.end_time < entry_b.end_time
        a_is_inside = entry_a.start_time > entry_b.start_time \
            and entry_a.end_time < entry_b.end_time
        b_is_inside = entry_a.start_time < entry_b.start_time \
            and entry_a.end_time > entry_b.end_time
        overlap = start_inside or end_inside or a_is_inside or b_is_inside
        if not consider_pause:
            return overlap
        else:
            if overlap:
                max_end = max(entry_a.end_time, entry_b.end_time)
                min_start = min(entry_a.start_time, entry_b.start_time)
                diff = max_end - min_start
                diff = diff.seconds + diff.days * 86400
                total = entry_a.get_total_seconds() + \
                        entry_b.get_total_seconds() - 1
                if total >= diff:
                    return True
            return False

    def is_overlapping(self):
        if self.start_time and self.end_time:
            entries = self.user.timepiece_entries.filter(
            Q(end_time__range=(self.start_time, self.end_time)) |
            Q(start_time__range=(self.start_time, self.end_time)) |
            Q(start_time__lte=self.start_time, end_time__gte=self.end_time))

            totals = entries.aggregate(
            max=Max('end_time'), min=Min('start_time'))

            totals['total'] = 0
            for entry in entries:
                totals['total'] = totals['total'] + entry.get_total_seconds()

            totals['diff'] = totals['max'] - totals['min']
            totals['diff'] = totals['diff'].seconds + \
                totals['diff'].days * 86400

            if totals['total'] > totals['diff']:
                return True
            else:
                return False
        else:
            return None

    def clean(self):
        if not self.user_id:
            raise ValidationError('An unexpected error has occured')
        if not self.start_time:
            raise ValidationError('Please enter a valid start time')
        start = self.start_time
        if self.end_time:
            end = self.end_time
        #Current entries have no end_time
        else:
            end = start + relativedelta(seconds=1)
        entries = self.user.timepiece_entries.filter(
            Q(end_time__range=(start, end)) |
            Q(start_time__range=(start, end)) |
            Q(start_time__lte=start, end_time__gte=end))
        #An entry can not conflict with itself so remove it from the list
        if self.id:
            entries = entries.exclude(pk=self.id)
        for entry in entries:
            entry_data = {
                'project': entry.project,
                'activity': entry.activity,
                'start_time': entry.start_time,
                'end_time': entry.end_time
            }
            #Conflicting saved entries
            if entry.end_time:
                if entry.start_time.date() == start.date() \
                and entry.end_time.date() == end.date():
                    entry_data['start_time'] = entry.start_time.strftime(
                        '%H:%M:%S')
                    entry_data['end_time'] = entry.end_time.strftime(
                        '%H:%M:%S')
                    raise ValidationError('Start time overlaps with '
                            '{activity} on {project} from {start_time} to '
                            '{end_time}.'.format(**entry_data))
                else:
                    entry_data['start_time'] = entry.start_time.strftime(
                        '%H:%M:%S on %m\%d\%Y')
                    entry_data['end_time'] = entry.end_time.strftime(
                        '%H:%M:%S on %m\%d\%Y')
                    raise ValidationError('Start time overlaps with '
                            '{activity} on {project} from {start_time} to '
                            '{end_time}.'.format(**entry_data))
        try:
            act_group = self.project.activity_group
            if act_group:
                activity = self.activity
                if not act_group.activities.filter(pk=activity.pk).exists():
                    name = activity.name
                    err_msg = '%s is not allowed for this project. ' % name
                    allowed = act_group.activities.filter()
                    allowed = allowed.values_list('name', flat=True)
                    allowed_names = ['among ']
                    if len(allowed) > 1:
                        for index, activity in enumerate(allowed):
                            allowed_names += activity
                            if index < len(allowed) - 2:
                                allowed_names += ', '
                            elif index < len(allowed) - 1:
                                allowed_names += ', and '
                        allowed_activities = ''.join(allowed_names)
                    else:
                        allowed_activities = allowed[0]
                    err_msg += 'Please choose %s' % allowed_activities
                    raise ValidationError(err_msg)
        except (Project.DoesNotExist, Activity.DoesNotExist):
            # Will be caught by field requirements
            pass
        if end <= start:
            raise ValidationError('Ending time must exceed the starting time')
        delta = (end - start)
        delta_secs = (delta.seconds + delta.days * 24 * 60 * 60)
        limit_secs = 60 * 60 * 12
        if delta_secs > limit_secs or self.seconds_paused > limit_secs:
            err_msg = 'Ending time exceeds starting time by 12 hours or more '\
                'for {0} on {1} at {2} to {3} at {4}.'.format(
                    self.project,
                    start.strftime('%m/%d/%Y'),
                    start.strftime('%H:%M:%S'),
                    end.strftime('%m/%d/%Y'),
                    end.strftime('%H:%M:%S')
                )
            raise ValidationError(err_msg)
        month_start = utils.get_month_start(start)
        next_month = month_start + relativedelta(months=1)
        entries = self.user.timepiece_entries.filter(
            Q(status=Entry.APPROVED) | Q(status=Entry.INVOICED),
            start_time__gte=month_start,
            end_time__lt=next_month
        )
        if (entries.exists() and not self.id
                or self.id and self.status == Entry.INVOICED):
            msg = 'You cannot add/edit entries after a timesheet has been ' \
                'approved or invoiced. Please correct the start and end times.'
            raise ValidationError(msg)
        return True

    def save(self, *args, **kwargs):
        self.hours = Decimal('%.2f' % round(self.total_hours, 2))
        super(Entry, self).save(*args, **kwargs)

    def get_total_seconds(self):
        """
        Determines the total number of seconds between the starting and
        ending times of this entry. If the entry is paused, the end_time is
        assumed to be the pause time. If the entry is active but not paused,
        the end_time is assumed to be now.
        """
        start = self.start_time
        end = self.end_time
        if not end:
            end = self.pause_time if self.is_paused else timezone.now()
        delta = end - start
        seconds = delta.seconds - self.get_paused_seconds()
        return seconds + (delta.days * 86400)

    def get_paused_seconds(self):
        """
        Returns the total seconds that this entry has been paused. If the
        entry is currently paused, then the additional seconds between
        pause_time and now are added to seconds_paused. If pause_time is in
        the future, no extra pause time is added.
        """
        if self.is_paused:
            date = timezone.now()
            delta = date - self.pause_time
            extra_pause = max(0, delta.seconds + (delta.days * 24 * 60 * 60))
            return self.seconds_paused + extra_pause
        return self.seconds_paused

    @property
    def total_hours(self):
        """
        Determined the total number of hours worked in this entry
        """
        total = self.get_total_seconds() / 3600.0
        #in case seconds paused are greater than the elapsed time
        if total < 0:
            total = 0
        return total

    @property
    def is_paused(self):
        """
        Determine whether or not this entry is paused
        """
        return bool(self.pause_time)

    def pause(self):
        """
        If this entry is not paused, pause it.
        """
        if not self.is_paused:
            self.pause_time = timezone.now()

    def pause_all(self):
        """
        Pause all open entries
        """
        entries = self.user.timepiece_entries.filter(
        end_time__isnull=True).all()
        for entry in entries:
            entry.pause()
            entry.save()

    def unpause(self, date=None):
        if self.is_paused:
            if not date:
                date = timezone.now()
            delta = date - self.pause_time
            self.seconds_paused += delta.seconds
            self.pause_time = None

    def toggle_paused(self):
        """
        Toggle the paused state of this entry.  If the entry is already paused,
        it will be unpaused; if it is not paused, it will be paused.
        """
        if self.is_paused:
            self.unpause()
        else:
            self.pause()

    @property
    def is_closed(self):
        """
        Determine whether this entry has been closed or not
        """
        return bool(self.end_time)

    @property
    def is_editable(self):
        return self.status == Entry.UNVERIFIED

    @property
    def delete_key(self):
        """
        Make it a little more interesting for deleting logs
        """
        salt = '%i-%i-apple-%s-sauce' \
            % (self.id, self.is_paused, self.is_closed)
        try:
            import hashlib
        except ImportError:
            import sha
            key = sha.new(salt).hexdigest()
        else:
            key = hashlib.sha1(salt).hexdigest()
        return key

    @staticmethod
    def summary(user, date, end_date):
        """
        Returns a summary of hours worked in the given time frame, for this
        user.  The setting TIMEPIECE_PAID_LEAVE_PROJECTS can be used to
        separate out hours for paid leave that should not be included in the
        total worked (e.g., sick time, vacation time, etc.).  Those hours will
        be added to the summary separately using the dictionary key set in
        TIMEPIECE_PAID_LEAVE_PROJECTS.
        """
        projects = utils.get_setting('TIMEPIECE_PAID_LEAVE_PROJECTS')
        entries = user.timepiece_entries.filter(
            end_time__gt=date, end_time__lt=end_date)
        data = {
            'billable': Decimal('0'), 'non_billable': Decimal('0'),
            'invoiced': Decimal('0'), 'uninvoiced': Decimal('0'),
            'total': Decimal('0')
            }
        invoiced = entries.filter(
            status=Entry.INVOICED).aggregate(i=Sum('hours'))['i']
        uninvoiced = entries.exclude(
            status=Entry.INVOICED).aggregate(uninv=Sum('hours'))['uninv']
        total = entries.aggregate(s=Sum('hours'))['s']
        if invoiced:
            data['invoiced'] = invoiced
        if uninvoiced:
            data['uninvoiced'] = uninvoiced
        if total:
            data['total'] = total
        billable = entries.exclude(project__in=projects.values())
        billable = billable.values(
            'billable',
        ).annotate(s=Sum('hours'))
        for row in billable:
            if row['billable']:
                data['billable'] += row['s']
            else:
                data['non_billable'] += row['s']
        data['total_worked'] = data['billable'] + data['non_billable']
        data['paid_leave'] = {}
        for name, pk in projects.iteritems():
            qs = entries.filter(project=projects[name])
            data['paid_leave'][name] = qs.aggregate(s=Sum('hours'))['s']
        return data


class ProjectHours(models.Model):
    week_start = models.DateField(verbose_name='start of week')
    project = models.ForeignKey('crm.Project')
    user = models.ForeignKey(User)
    hours = models.DecimalField(
        max_digits=8, decimal_places=2, default=0,
        validators=[validators.MinValueValidator(Decimal("0.01"))]
    )
    published = models.BooleanField(default=False)

    def __unicode__(self):
        return "{0} on {1} for Week of {2}".format(
                self.user.get_name_or_username(),
                self.project, self.week_start.strftime('%B %d, %Y'))

    def save(self, *args, **kwargs):
        # Ensure that week_start is the Monday of a given week.
        self.week_start = utils.get_week_start(self.week_start)
        return super(ProjectHours, self).save(*args, **kwargs)

    class Meta:
        db_table = 'timepiece_projecthours'  # Using legacy table name
        verbose_name = 'project hours entry'
        verbose_name_plural = 'project hours entries'
        unique_together = ('week_start', 'project', 'user')

########NEW FILE########
__FILENAME__ = test_dashboard
import datetime
from dateutil.relativedelta import relativedelta
from urllib import urlencode

from django.contrib.auth.models import Permission
from django.core.urlresolvers import reverse
from django.test import TestCase

from timepiece import utils
from timepiece.tests.base import ViewTestMixin
from timepiece.tests import factories

from timepiece.entries.models import Entry, ProjectHours
from timepiece.entries.views import Dashboard


class DashboardViewTestCase(ViewTestMixin, TestCase):
    """Tests the data that is passed to the dashboard template."""

    def setUp(self):
        self.today = datetime.date(2012, 11, 7)
        self.this_week = utils.get_week_start(self.today)
        self.next_week = self.this_week + relativedelta(days=7)

        get_params = {'week_start': self.this_week.strftime('%Y-%m-%d')}
        self.url = reverse('dashboard') + '?' + urlencode(get_params)

        self.user = factories.User()
        self.permission = Permission.objects.get(codename='can_clock_in')
        self.user.user_permissions.add(self.permission)
        self.login_user(self.user)

        self.project = factories.Project()
        self.activity = factories.Activity()
        self.location = factories.Location()
        self.status = Entry.UNVERIFIED

    def _create_entry(self, start_time, end_time=None, user=None):
        """
        Creates an entry using default values. If end time is not given, the
        entry is considered active.
        """
        data = {
            'user': user or self.user,
            'project': self.project,
            'activity': self.activity,
            'location': self.location,
            'status': self.status,
            'start_time': start_time,
        }
        if end_time:
            data['end_time'] = end_time
        return factories.Entry(**data)

    def _create_active_entry(self):
        start_time = datetime.datetime(2012, 11, 9, 0)
        return self._create_entry(start_time)

    def _create_entries(self):
        count = 5
        start_time = datetime.datetime(2012, 11, 5, 8)
        end_time = datetime.datetime(2012, 11, 5, 12)
        for i in range(count):
            start_time = end_time + relativedelta(seconds=1)
            end_time += relativedelta(hours=4)
            self._create_entry(start_time, end_time)
        return count

    def _create_others_entries(self):
        count = 5
        start_time = datetime.datetime(2012, 11, 6, 12)
        for i in range(count):
            user = factories.User()
            self._create_entry(start_time, user=user)
        return count

    def test_unauthenticated_user(self):
        """Unauthenticated users should be redirected to login view."""
        self.client.logout()
        response = self.client.get(self.url)
        self.assertEqual(response.status_code, 302)

    def test_unprivileged_user(self):
        """Unprivileged users should not see any content."""
        self.user.user_permissions.remove(self.permission)
        response = self.client.get(self.url)
        self.assertEqual(response.status_code, 200)
        # TODO: better test for whether this is working.

    def test_get(self):
        """Get without param gets entries for this week."""
        response = self.client.get(reverse('dashboard'))
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.context['week_start'],
                utils.get_week_start().date())
        self.assertEqual(response.context['week_end'],
                utils.get_week_start().date() + relativedelta(days=6))

    def test_active_entry(self):
        """Active entry should be given if it exists."""
        active_entry = self._create_active_entry()
        response = self.client.get(self.url)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.context['active_entry'], active_entry)

    def test_no_active_entry(self):
        """Active entry should be None if it doesn't exist."""
        response = self.client.get(self.url)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.context['active_entry'], None)

    def test_weeks_entries(self):
        """Week's entries list should include active entry."""
        entry_count = self._create_entries()
        active_entry = self._create_active_entry()
        entry_count += 1
        response = self.client.get(self.url)
        self.assertEqual(response.status_code, 200)
        self.assertTrue(active_entry in response.context['week_entries'])
        self.assertEqual(len(response.context['week_entries']), entry_count)

    def test_no_weeks_entries(self):
        """Week's entries list should be empty if no entries this week."""
        response = self.client.get(self.url)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.context['week_entries']), 0)

    def test_other_active_entries(self):
        """Others' entries list should exclude this user's active entry."""
        entry_count = self._create_others_entries()
        active_entry = self._create_active_entry()
        response = self.client.get(self.url)
        self.assertEqual(response.status_code, 200)
        others_active_entries = response.context['others_active_entries']
        self.assertFalse(active_entry in others_active_entries)
        self.assertEqual(len(others_active_entries), entry_count)

    def test_no_other_active_entries(self):
        """Others' entries list should be empty if no other active entries."""
        response = self.client.get(self.url)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.context['others_active_entries']), 0)


class ProcessProgressTestCase(TestCase):
    """Tests for process_progress."""

    def setUp(self):
        self.today = datetime.date(2012, 11, 7)
        self.this_week = utils.get_week_start(self.today)
        self.next_week = self.this_week + relativedelta(days=7)

        self.user = factories.User()

        self.project = factories.Project()
        self.activity = factories.Activity()
        self.location = factories.Location()
        self.status = Entry.UNVERIFIED

    def _create_entry(self, start_time, end_time=None, project=None):
        data = {
            'user': self.user,
            'project': project or self.project,
            'activity': self.activity,
            'location': self.location,
            'status': self.status,
            'start_time': start_time,
        }
        if end_time:
            data['end_time'] = end_time
        return factories.Entry(**data)

    def _create_hours(self, hours, project=None):
        data = {
            'user': self.user,
            'project': project or self.project,
            'week_start': self.this_week,
            'hours': hours,
        }
        return factories.ProjectHours(**data)

    def _get_progress(self):
        entries = Entry.objects.all()
        assignments = ProjectHours.objects.all()
        view = Dashboard()
        return view.process_progress(entries, assignments)

    def _check_progress(self, progress, project, assigned, worked):
        self.assertEqual(progress['project'], project)
        self.assertEqual(progress['assigned'], assigned)
        self.assertEqual(progress['worked'], worked)

    def test_progress(self):
        """Progress when work has been done for an assigned project."""
        start_time = datetime.datetime(2012, 11, 7, 8, 0)
        end_time = datetime.datetime(2012, 11, 7, 12, 0)
        entry = self._create_entry(start_time, end_time)
        worked_hours = 4
        assigned_hours = 5
        assignment = self._create_hours(assigned_hours)

        progress = self._get_progress()
        self.assertEqual(len(progress), 1)
        self._check_progress(progress[0], self.project,
                assigned_hours, worked_hours)

    def test_work_with_no_assignment(self):
        """Progress when work has been done on an unassigned project."""
        start_time = datetime.datetime(2012, 11, 7, 8, 0)
        end_time = datetime.datetime(2012, 11, 7, 12, 0)
        entry = self._create_entry(start_time, end_time)
        worked_hours = 4

        progress = self._get_progress()
        self.assertEqual(len(progress), 1)
        self._check_progress(progress[0], self.project, 0, worked_hours)

    def test_assignment_with_no_work(self):
        """Progress when no work has been done on an assigned project."""
        assigned_hours = 5
        assignment = self._create_hours(assigned_hours)

        progress = self._get_progress()
        self.assertEqual(len(progress), 1)
        self._check_progress(progress[0], self.project, assigned_hours, 0)

    def test_ordering(self):
        """Progress list should be ordered by project name."""
        projects = [
            factories.Project(name='a'),
            factories.Project(name='b'),
            factories.Project(name='c'),
        ]
        for i in range(3):
            start_time = datetime.datetime(2012, 11, 5 + i, 8, 0)
            end_time = datetime.datetime(2012, 11, 5 + i, 12, 0)
            entry = self._create_entry(start_time, end_time, projects[i])
            assignment = self._create_hours(5 + 5 * i, projects[i])

        progress = self._get_progress()
        self.assertEqual(len(progress), 3)
        self.assertEqual(progress[0]['project'], projects[0])
        self.assertEqual(progress[1]['project'], projects[1])
        self.assertEqual(progress[2]['project'], projects[2])

########NEW FILE########
__FILENAME__ = test_schedule
import json
import datetime
from dateutil.relativedelta import relativedelta
from decimal import Decimal

from django.contrib.auth.models import Permission
from django.contrib.contenttypes.models import ContentType
from django.core.urlresolvers import reverse
from django.test import TestCase

from timepiece import utils
from timepiece.tests import factories
from timepiece.tests.base import ViewTestMixin

from timepiece.entries.models import Entry, ProjectHours
from timepiece.entries.views import ScheduleView


class ProjectHoursTestCase(ViewTestMixin, TestCase):

    def setUp(self):
        self.user = factories.User()
        permissions = Permission.objects.filter(
            content_type=ContentType.objects.get_for_model(Entry),
            codename__in=('can_clock_in', 'can_clock_out', 'can_pause',
                    'change_entry')
        )
        self.user.user_permissions = permissions
        self.user.save()
        self.superuser = factories.Superuser()

        self.tracked_status = factories.StatusAttribute(
                label='Current', billable=True, enable_timetracking=True)
        self.untracked_status = factories.StatusAttribute(
                label='Closed', billable=False, enable_timetracking=False)
        self.tracked_type = factories.TypeAttribute(
                label='Tracked', billable=True, enable_timetracking=True)
        self.untracked_type = factories.TypeAttribute(
                label='Untracked', billable=False, enable_timetracking=False)

        self.work_activities = factories.ActivityGroup(name='Work')
        self.leave_activities = factories.ActivityGroup(name='Leave')
        self.all_activities = factories.ActivityGroup(name='All')

        self.leave_activity = factories.Activity(code='leave',
                name='Leave', billable=False)
        self.leave_activity.activity_group.add(self.leave_activities,
                self.all_activities)
        self.work_activity = factories.Activity(code='work',
                name='Work', billable=True)
        self.work_activity.activity_group.add(self.work_activities,
                self.all_activities)

        data = {
            'type': self.tracked_type,
            'status': self.tracked_status,
            'activity_group': self.work_activities,
        }
        self.tracked_project = factories.BillableProject(
                name='Tracked', **data)
        data = {
            'type': self.untracked_type,
            'status': self.untracked_status,
            'activity_group': self.all_activities,
        }
        self.untracked_project = factories.BillableProject(
                name='Untracked', **data)


class ProjectHoursModelTestCase(ProjectHoursTestCase):

    def test_week_start(self):
        """week_start should always save to Monday of the given week."""
        monday = datetime.date(2012, 07, 16)
        for i in range(7):
            date = monday + relativedelta(days=i)
            entry = ProjectHours.objects.create(
                    week_start=date, project=self.tracked_project,
                    user=self.user)
            self.assertEquals(entry.week_start.date(), monday)
            ProjectHours.objects.all().delete()


class ProjectHoursListViewTestCase(ProjectHoursTestCase):

    def setUp(self):
        super(ProjectHoursListViewTestCase, self).setUp()
        self.past_week = utils.get_week_start(datetime.date(2012, 4, 1)).date()
        self.current_week = utils.get_week_start().date()
        for i in range(5):
            factories.ProjectHours(week_start=self.past_week,
                    published=True)
            factories.ProjectHours(week_start=self.current_week,
                    published=True)
        self.url = reverse('view_schedule')
        self.login_user(self.user)
        self.date_format = '%Y-%m-%d'

    def test_no_permission(self):
        """User must have permission entries.can_clock_in to view page."""
        self.basic_user = factories.User()
        self.login_user(self.basic_user)
        response = self.client.get(self.url)
        self.assertEquals(response.status_code, 302)

    def test_permission(self):
        """User must have permission entries.can_clock_in to view page."""
        self.assertTrue(self.user.has_perm('entries.can_clock_in'))
        response = self.client.get(self.url)
        self.assertEquals(response.status_code, 200)

    def test_default_filter(self):
        """Page shows project hours entries from the current week."""
        data = {}
        response = self.client.get(self.url, data)
        self.assertEquals(response.context['week'], self.current_week)

    def test_week_filter(self):
        """Filter shows all entries from Monday to Sunday of specified week."""
        data = {
            'week_start': self.past_week.strftime(self.date_format),
            'submit': '',
        }
        response = self.client.get(self.url, data)
        self.assertEquals(response.context['week'].date(), self.past_week)

        view = ScheduleView()
        all_entries = view.get_hours_for_week(self.past_week)
        users = response.context['users']
        projects = response.context['projects']
        count = 0

        for proj_id, name, entries in projects:
            for i in range(len(entries)):
                entry = entries[i]
                if entry:
                    count += 1
                    self.assertTrue(all_entries.filter(project__id=proj_id,
                            user__id=users[i][0],
                            hours=entry['hours']).exists())
        self.assertEquals(count, all_entries.count())

    def test_week_filter_midweek(self):
        """Filter corrects mid-week date to Monday of specified week."""
        wednesday = datetime.date(2012, 7, 4)
        monday = utils.get_week_start(wednesday).date()
        data = {
            'week_start': wednesday.strftime(self.date_format),
            'submit': '',
        }
        response = self.client.get(self.url, data)
        self.assertEquals(response.context['week'].date(), monday)

    def test_no_entries(self):
        date = utils.get_week_start(datetime.date(2012, 3, 15))
        data = {
            'week_start': date.strftime('%Y-%m-%d'),
            'submit': '',
        }
        response = self.client.get(self.url, data)
        self.assertEquals(len(response.context['projects']), 0)
        self.assertEquals(len(response.context['users']), 0)

    def test_all_users_for_project(self):
        """Each project should list hours for every user."""
        response = self.client.get(self.url)
        projects = response.context['projects']
        users = response.context['users']

        for proj_id, name, entries in projects:
            self.assertEquals(len(entries), len(users))


class ProjectHoursEditTestCase(ProjectHoursTestCase):
    def setUp(self):
        super(ProjectHoursEditTestCase, self).setUp()
        self.permission = Permission.objects.filter(
            codename='add_projecthours')
        self.manager = factories.User()
        self.manager.user_permissions = self.permission
        self.view_url = reverse('edit_schedule')
        self.ajax_url = reverse('ajax_schedule')
        self.week_start = utils.get_week_start(datetime.date.today())
        self.next_week = self.week_start + relativedelta(days=7)
        self.future = self.week_start + relativedelta(days=14)

    def create_project_hours(self):
        """Create project hours data"""
        ProjectHours.objects.create(
            week_start=self.week_start, project=self.tracked_project,
            user=self.user, hours="25.0")
        ProjectHours.objects.create(
            week_start=self.week_start, project=self.tracked_project,
            user=self.manager, hours="5.0")

        ProjectHours.objects.create(
            week_start=self.next_week, project=self.tracked_project,
            user=self.user, hours="15.0")
        ProjectHours.objects.create(
            week_start=self.next_week, project=self.tracked_project,
            user=self.manager, hours="2.0")

    def ajax_posts(self):
        date_msg = 'Parameter week_start must be a date in the format ' \
            'yyyy-mm-dd'
        msg = 'The request must contain values for user, project, and hours'

        response = self.client.post(self.ajax_url, data={
            'hours': 5,
            'week_start': '2012-07-23'
        })
        self.assertEquals(response.status_code, 500)
        self.assertEquals(response.content, msg)

        response = self.client.post(self.ajax_url, data={
            'hours': 5,
            'project': self.tracked_project.pk,
            'week_start': '2012-07-23'
        })
        self.assertEquals(response.status_code, 500)
        self.assertEquals(response.content, msg)

        response = self.client.post(self.ajax_url, data={
            'project': self.tracked_project.pk,
            'week_start': '2012-07-23'
        })
        self.assertEquals(response.status_code, 500)
        self.assertEquals(response.content, msg)

        response = self.client.post(self.ajax_url, data={
            'project': self.tracked_project.pk,
            'user': self.manager.pk,
            'week_start': '2012-07-23'
        })
        self.assertEquals(response.status_code, 500)
        self.assertEquals(response.content, msg)

        response = self.client.post(self.ajax_url, data={
            'user': self.manager.pk,
            'week_start': '2012-07-23'
        })
        self.assertEquals(response.status_code, 500)
        self.assertEquals(response.content, msg)

        response = self.client.post(self.ajax_url, data={
            'hours': 5,
            'user': self.manager.pk,
            'week_start': '2012-07-23'
        })
        self.assertEquals(response.status_code, 500)
        self.assertEquals(response.content, msg)

        response = self.client.post(self.ajax_url, data={
            'week_start': '2012-07-23'
        })
        self.assertEquals(response.status_code, 500)
        self.assertEquals(response.content, msg)

        response = self.client.post(self.ajax_url, data={
            'hours': 5,
            'user': self.manager.pk,
            'project': self.tracked_project.pk
        })
        self.assertEquals(response.status_code, 500)
        self.assertEquals(response.content, date_msg)

    def process_default_call(self, response):
        self.assertEquals(response.status_code, 200)

        data = json.loads(response.content)

        self.assertEquals(len(data['project_hours']), 2)
        self.assertEquals(len(data['projects']), 1)

        correct_hours = {self.manager.id: 5.0, self.user.id: 25.0}
        for entry in data['project_hours']:
            self.assertEquals(entry['hours'], correct_hours[entry['user']])

    def test_permission_access(self):
        """
        You must have the permission to view the edit page or
        the ajax page
        """
        self.login_user(self.manager)

        response = self.client.get(self.view_url)
        self.assertEquals(response.status_code, 200)

        response = self.client.get(self.ajax_url)
        self.assertEquals(response.status_code, 200)

    def test_no_permission_access(self):
        """
        If you are a regular user, edit view should redirect to regular view
        and you should not be able to request any ajax data.
        """
        self.login_user(self.user)

        response = self.client.get(self.view_url)
        self.assertEquals(response.status_code, 302)

        response = self.client.get(self.ajax_url)
        self.assertEquals(response.status_code, 302)

    def test_empty_ajax_call(self):
        """
        An ajax call should return empty data sets when project hours
        do not exist
        """
        self.login_user(self.manager)

        response = self.client.get(self.ajax_url)
        self.assertEquals(response.status_code, 200)

        data = json.loads(response.content)

        self.assertEquals(data['project_hours'], [])
        self.assertEquals(data['projects'], [])

    def test_users(self):
        """Should retrieve all users who can_clock_in."""
        perm = Permission.objects.get(codename='can_clock_in')
        group = factories.Group()
        group.permissions.add(perm)

        group_user = factories.User()
        group_user.groups.add(group)
        perm_user = self.user
        super_user = self.superuser

        self.login_user(self.manager)
        response = self.client.get(self.ajax_url)
        self.assertEquals(response.status_code, 200)
        users = [u['id'] for u in json.loads(response.content)['all_users']]
        self.assertEquals(len(users), 3)
        self.assertTrue(group_user.id in users)
        self.assertTrue(perm_user.id in users)
        self.assertTrue(super_user.id in users)

    def test_default_ajax_call(self):
        """
        An ajax call without any parameters should return the current
        weeks data
        """
        self.login_user(self.manager)
        self.create_project_hours()

        response = self.client.get(self.ajax_url)

        self.process_default_call(response)

    def test_default_empty_ajax_call(self):
        """
        An ajax call with the parameter present, but empty value, should
        return the same as a call with no parameter
        """
        self.login_user(self.manager)
        self.create_project_hours()

        response = self.client.get(self.ajax_url, data={
            'week_start': ''
        })

        self.process_default_call(response)

    def test_ajax_call_date(self):
        """
        An ajax call with the 'week_of' parameter should return
        the data for that week
        """
        self.login_user(self.manager)
        self.create_project_hours()

        date = datetime.datetime.now() + relativedelta(days=7)
        response = self.client.get(self.ajax_url, data={
            'week_start': date.strftime('%Y-%m-%d')
        })
        self.assertEquals(response.status_code, 200)

        data = json.loads(response.content)

        self.assertEquals(len(data['project_hours']), 2)
        self.assertEquals(len(data['projects']), 1)
        correct_hours = {
            self.manager.id: 2.0,
            self.user.id: 15.0
        }
        for entry in data['project_hours']:
            self.assertEqual(entry['hours'], correct_hours[entry['user']])

    def test_ajax_create_successful(self):
        """
        A post request on the ajax url should create a new project
        hour entry and return the entry's pk
        """
        self.login_user(self.manager)

        self.assertEquals(ProjectHours.objects.count(), 0)

        data = {
            'hours': 5,
            'user': self.manager.pk,
            'project': self.tracked_project.pk,
            'week_start': self.week_start.strftime('%Y-%m-%d')
        }
        response = self.client.post(self.ajax_url, data=data)
        self.assertEquals(response.status_code, 200)

        ph = ProjectHours.objects.get()
        self.assertEquals(ProjectHours.objects.count(), 1)
        self.assertEquals(int(response.content), ph.pk)
        self.assertEquals(ph.hours, Decimal("5.0"))

    def test_ajax_create_unsuccessful(self):
        """
        If any of the data is missing, the server response should
        be a 500 error
        """
        self.login_user(self.manager)

        self.assertEquals(ProjectHours.objects.count(), 0)

        self.ajax_posts()

        self.assertEquals(ProjectHours.objects.count(), 0)

    def test_ajax_update_successful(self):
        """
        A put request to the url with the correct data should update
        an existing project hour entry
        """
        self.login_user(self.manager)

        ph = ProjectHours.objects.create(
            hours=Decimal('5.0'),
            project=self.tracked_project,
            user=self.manager
        )

        response = self.client.post(self.ajax_url, data={
            'project': self.tracked_project.pk,
            'user': self.manager.pk,
            'hours': 10,
            'week_start': self.week_start.strftime('%Y-%m-%d')
        })
        self.assertEquals(response.status_code, 200)

        ph = ProjectHours.objects.get()
        self.assertEquals(ph.hours, Decimal("10"))

    def test_ajax_update_unsuccessful(self):
        """
        If the request to update is missing data, the server should respond
        with a 500 error
        """
        self.login_user(self.manager)

        ph = ProjectHours.objects.create(
            hours=Decimal('10.0'),
            project=self.untracked_project,
            user=self.manager
        )

        self.ajax_posts()

        self.assertEquals(ProjectHours.objects.count(), 1)
        self.assertEquals(ph.hours, Decimal('10.0'))

    def test_ajax_delete_successful(self):
        """
        A delete request with a valid pk should delete the project
        hours entry from the database
        """
        self.login_user(self.manager)

        ph = ProjectHours.objects.create(
            hours=Decimal('5.0'),
            project=self.tracked_project,
            user=self.manager
        )

        url = reverse('ajax_schedule_detail', args=(ph.pk,))

        response = self.client.delete(url)
        self.assertEquals(response.status_code, 200)

        self.assertEquals(ProjectHours.objects.count(), 0)

    def test_duplicate_successful(self):
        """
        You can copy hours from the previous week to the currently
        active week. A request with the duplicate key present will
        start the duplication process
        """
        self.login_user(self.manager)
        self.create_project_hours()

        msg = 'Project hours were copied'

        response = self.client.post(self.ajax_url, data={
            'week_update': self.future.strftime('%Y-%m-%d'),
            'duplicate': 'duplicate'
        }, follow=True)
        self.assertEquals(response.status_code, 200)

        messages = response.context['messages']
        self.assertEquals(messages._loaded_messages[0].message, msg)

        ph = ProjectHours.objects.all()
        self.assertEquals(ph.count(), 6)
        self.assertEquals(ph.filter(week_start__gte=self.future).count(), 2)

    def test_duplicate_unsuccessful_params(self):
        """
        Both week_update and duplicate must be present if hours
        duplication is to take place
        """
        self.login_user(self.manager)
        self.create_project_hours()

        response = self.client.post(self.ajax_url, data={
            'week_update': self.future.strftime('%Y-%m-%d')
        }, follow=True)
        self.assertEquals(response.status_code, 500)

        response = self.client.post(self.ajax_url, data={
            'duplicate': 'duplicate'
        }, follow=True)
        self.assertEquals(response.status_code, 500)

        self.assertEquals(ProjectHours.objects.count(), 4)

    def test_duplicate_dates(self):
        """
        If you specify a week and hours current exist for that week,
        the previous weeks hours will be copied over the current entries
        """
        self.login_user(self.manager)
        self.create_project_hours()

        msg = 'Project hours were copied'

        response = self.client.post(self.ajax_url, data={
            'week_update': self.next_week.strftime('%Y-%m-%d'),
            'duplicate': 'duplicate'
        }, follow=True)
        self.assertEquals(response.status_code, 200)

        messages = response.context['messages']
        self.assertEquals(messages._loaded_messages[0].message, msg)

        this_week_qs = ProjectHours.objects.filter(
            week_start=self.week_start
        ).values_list('hours', flat=True)
        next_week_qs = ProjectHours.objects.filter(
            week_start=self.next_week
        ).values_list('hours', flat=True)

        # ValueQuerySets do not like being compared...
        this_week_qs = list(this_week_qs)
        next_week_qs = list(next_week_qs)

        self.assertEquals(ProjectHours.objects.count(), 4)
        self.assertEquals(ProjectHours.objects.filter(
            published=False).count(), 4)
        self.assertEquals(this_week_qs, next_week_qs)

    def test_no_hours_to_copy(self):
        """
        You should be notified if there are no hours to copy
        from the previous week
        """
        self.login_user(self.manager)

        msg = 'There are no hours to copy'

        response = self.client.post(self.ajax_url, data={
            'week_update': self.week_start.strftime('%Y-%m-%d'),
            'duplicate': 'duplicate'
        }, follow=True)
        self.assertEquals(response.status_code, 200)

        messages = response.context['messages']
        self.assertEquals(messages._loaded_messages[0].message, msg)

    def test_publish_hours(self):
        """
        If you post to the edit view, you can publish the hours for
        the given week
        """
        self.login_user(self.manager)
        self.create_project_hours()

        msg = 'Unpublished project hours are now published'

        ph = ProjectHours.objects.filter(published=True)
        self.assertEquals(ph.count(), 0)

        response = self.client.post(self.view_url, follow=True)
        self.assertEquals(response.status_code, 200)

        messages = response.context['messages']
        self.assertEquals(messages._loaded_messages[0].message, msg)

        ph = ProjectHours.objects.filter(published=True)
        self.assertEquals(ph.count(), 2)

        for p in ph:
            self.assertEquals(p.week_start, self.week_start.date())

    def test_publish_hours_unsuccessful(self):
        """
        If you post to the edit view and there are no hours to
        publish, you are told so
        """
        self.login_user(self.manager)
        self.create_project_hours()

        msg = 'There were no hours to publish'

        ProjectHours.objects.update(published=True)

        response = self.client.post(self.view_url, follow=True)
        self.assertEquals(response.status_code, 200)

        messages = response.context['messages']
        self.assertEquals(messages._loaded_messages[0].message, msg)

        ph = ProjectHours.objects.filter(published=True)
        self.assertEquals(ph.count(), 4)

########NEW FILE########
__FILENAME__ = test_timesheet
import datetime
from dateutil.relativedelta import relativedelta
from decimal import Decimal
import random
import urllib

from django.contrib.auth.models import Permission
from django.contrib.contenttypes.models import ContentType
from django.core.urlresolvers import reverse
from django.utils import timezone
from django.test import TestCase

from timepiece import utils
from timepiece.tests.base import ViewTestMixin, LogTimeMixin
from timepiece.tests import factories

from timepiece.crm.utils import grouped_totals
from timepiece.entries.models import Activity, Entry
from timepiece.entries.forms import ClockInForm


class EditableTest(TestCase):

    def setUp(self):
        super(EditableTest, self).setUp()
        self.user = factories.User()
        self.project = factories.Project(type__enable_timetracking=True,
                status__enable_timetracking=True)
        self.entry = factories.Entry(**{
            'user': self.user,
            'project': self.project,
            'start_time': timezone.now() - relativedelta(days=6),
            'end_time':  timezone.now() - relativedelta(days=6),
            'seconds_paused': 0,
            'status': Entry.VERIFIED,
        })
        self.entry2 = factories.Entry(**{
            'user': self.user,
            'project': self.project,
            'start_time': timezone.now() - relativedelta(days=2),
            'end_time':  timezone.now() - relativedelta(days=2),
            'seconds_paused': 0,
            'status': Entry.UNVERIFIED,
        })

    def testUnEditable(self):
        self.assertFalse(self.entry.is_editable)

    def testEditable(self):
        self.assertTrue(self.entry2.is_editable)


class MyLedgerTest(ViewTestMixin, LogTimeMixin, TestCase):

    def setUp(self):
        super(MyLedgerTest, self).setUp()
        self.user = factories.User()
        self.user2 = factories.User()
        self.superuser = factories.Superuser()
        self.devl_activity = factories.Activity(billable=True)
        self.activity = factories.Activity()
        self.url = reverse('view_user_timesheet', args=(self.user.pk,))

    def login_with_permissions(self):
        view_entry_summary = Permission.objects.get(
            codename='view_entry_summary')
        user = factories.User()
        user.user_permissions.add(view_entry_summary)
        user.save()
        self.login_user(user)

    def test_timesheet_view_permission(self):
        """A user with the correct permissions should see the menu"""
        self.login_with_permissions()
        response = self.client.get(self.url)
        self.assertEquals(response.status_code, 200)
        self.assertTrue('user' in response.context['year_month_form'].fields)

    def test_timesheet_view_no_permission(self):
        """A regular user should not see the user menu"""
        self.login_user(self.user)
        response = self.client.get(self.url)
        self.assertTrue(response.status_code, 200)
        self.assertFalse('user' in response.context['year_month_form'].fields)

    def testEmptyTimeSheet(self):
        self.login_user(self.user)
        response = self.client.get(self.url)
        self.assertEquals(response.status_code, 200)
        self.assertEquals(list(response.context['entries']), [])

    def testEmptyHourlySummary(self):
        self.login_user(self.user)
        now = timezone.now()
        empty_month = now + relativedelta(months=1)
        data = {
            'year': empty_month.year,
            'month': empty_month.month,
        }
        url = reverse('view_user_timesheet', args=[self.user.pk])
        response = self.client.get(url, data)
        self.assertEquals(response.status_code, 200)
        self.assertEquals(response.context['grouped_totals'], '')

    def testNotMyLedger(self):
        self.login_user(self.user2)
        response = self.client.get(self.url)
        self.assertEquals(response.status_code, 403)

    def testNoLedger(self):
        self.login_user(self.user2)
        self.url = reverse('dashboard')
        try:
            response = self.client.get(self.url)
        except Exception, e:
            self.fail(e)

    def make_entries(self):
        self.p1 = factories.BillableProject(name='1')
        self.p2 = factories.NonbillableProject(name='2')
        self.p4 = factories.BillableProject(name='4')
        self.p3 = factories.NonbillableProject(name='1')
        days = [
            utils.add_timezone(datetime.datetime(2011, 1, 1)),
            utils.add_timezone(datetime.datetime(2011, 1, 28)),
            utils.add_timezone(datetime.datetime(2011, 1, 31)),
            utils.add_timezone(datetime.datetime(2011, 2, 1)),
            timezone.now(),
        ]
        self.log_time(project=self.p1, start=days[0], delta=(1, 0))
        self.log_time(project=self.p2, start=days[0], delta=(1, 0))
        self.log_time(project=self.p4, start=days[0], delta=(1, 0))
        self.log_time(project=self.p1, start=days[1], delta=(1, 0))
        self.log_time(project=self.p3, start=days[1], delta=(1, 0))
        self.log_time(project=self.p4, start=days[1], delta=(1, 0))
        self.log_time(project=self.p1, start=days[2], delta=(1, 0))
        self.log_time(project=self.p2, start=days[2], delta=(1, 0))
        self.log_time(project=self.p4, start=days[2], delta=(1, 0))
        self.log_time(project=self.p1, start=days[3], delta=(1, 0))
        self.log_time(project=self.p3, start=days[3], delta=(1, 0))
        self.log_time(project=self.p4, start=days[3], delta=(1, 0))
        self.log_time(project=self.p1, start=days[4], delta=(1, 0))
        self.log_time(project=self.p3, start=days[4], delta=(1, 0))
        self.log_time(project=self.p4, start=days[4], delta=(1, 0))

    def testCurrentTimeSheet(self):
        self.login_user(self.user)
        self.make_entries()
        response = self.client.get(self.url)
        self.assertEquals(response.status_code, 200)
        self.assertEqual(len(response.context['entries']), 3)
        self.assertEqual(response.context['summary']['total'], Decimal(3))

    def testOldTimeSheet(self):
        self.login_user(self.user)
        self.make_entries()
        data = {
            'month': 1,
            'year': 2011,
        }
        response = self.client.get(self.url, data)
        self.assertEquals(response.status_code, 200)
        self.assertEqual(len(response.context['entries']), 9)
        self.assertEqual(response.context['summary']['total'], Decimal(9))


class ClockInTest(ViewTestMixin, TestCase):

    def setUp(self):
        super(ClockInTest, self).setUp()
        self.user = factories.User()
        self.user2 = factories.User()
        self.superuser = factories.Superuser()
        permissions = Permission.objects.filter(
            content_type=ContentType.objects.get_for_model(Entry),
            codename__in=('can_clock_in', 'can_clock_out',
            'can_pause', 'change_entry')
        )
        self.user.user_permissions = permissions
        self.user2.user_permissions = permissions
        self.user.save()
        self.user2.save()
        self.activity = factories.Activity(code='WRK',
                name='Work')
        self.devl_activity = factories.Activity(code='devl',
                name='development', billable=True)
        self.sick_activity = factories.Activity(code="sick",
                name="sick/personal", billable=False)
        self.activity_group_all = factories.ActivityGroup(
                name='All')
        self.activity_group_work = factories.ActivityGroup(
                name='Client work')
        activities = Activity.objects.all()
        for activity in activities:
            activity.activity_group.add(self.activity_group_all)
            if activity != self.sick_activity:
                activity.activity_group.add(self.activity_group_work)
        self.business = factories.Business()
        status = factories.StatusAttribute(label='Current',
                enable_timetracking=True)
        type_ = factories.TypeAttribute(label='Web Sites',
                enable_timetracking=True)
        self.project = factories.Project(type=type_,
                status=status, business=self.business, point_person=self.user,
                activity_group=self.activity_group_work)
        self.project2 = factories.Project(type=type_,
                status=status, business=self.business, point_person=self.user2,
                activity_group=self.activity_group_all)
        factories.ProjectRelationship(user=self.user,
                project=self.project)
        self.location = factories.Location()

        self.url = reverse('clock_in')
        self.now = timezone.now()
        self.ten_min_ago = self.now - relativedelta(minutes=10)
        self.clock_in_form = {
            'project': self.project.pk,
            'location': self.location.pk,
            'activity': self.devl_activity.pk,
            'start_time_0': self.ten_min_ago.strftime('%m/%d/%Y'),
            'start_time_1': self.ten_min_ago.strftime('%H:%M:%S'),
        }

    def testClockIn(self):
        """Test the simplest clock in scenario"""
        self.login_user(self.user)
        data = self.clock_in_form
        response = self.client.post(self.url, data, follow=True)
        # Clock in form submission leads to the dashboard page
        # with one active entry
        self.assertRedirects(response, reverse('dashboard'),
                             status_code=302, target_status_code=200)
        entries = Entry.objects.filter(
            end_time__isnull=True, user=self.user
        )
        self.assertEqual(entries.count(), 1)

    def testClockInAutoOut(self):
        """
        Clocking in during an active entry automatically clocks out the current
        entry one second before the new entry.
        """
        self.login_user(self.user)
        entry1 = factories.Entry(**{
            'user': self.user,
            'start_time': self.ten_min_ago,
        })
        data = self.clock_in_form
        data.update({
            'start_time_0': self.now.strftime('%m/%d/%Y'),
            'start_time_1': self.now.strftime('%H:%M:%S'),
        })
        response = self.client.post(self.url, data)
        entries = Entry.objects.all()
        #These clock in times do not overlap
        for entry in entries:
            if entry.is_overlapping():
                self.fail('Overlapping Times')
        #There is one closed entry and open current entry
        closed_entry = entries.get(end_time__isnull=False)
        current_entry = entries.get(end_time__isnull=True)
        #The current start time is one second after the closed entry's end time
        self.assertEqual(closed_entry.end_time + relativedelta(seconds=1),
                         current_entry.start_time)

    def testClockInManyActive(self):
        """
        There should never be more than one active entry. If this happens,
        a 500 error should be raised so that we are notified of the situation.
        """
        self.login_user(self.user)
        entry1 = factories.Entry(**{
            'user': self.user,
            'start_time': self.ten_min_ago,
        })
        entry2 = factories.Entry(**{
            'user': self.user,
            'start_time': self.now - relativedelta(minutes=20),
        })
        data = self.clock_in_form
        data.update({
            'start_time_0': self.now.strftime('%m/%d/%Y'),
            'start_time_1': self.now.strftime('%H:%M:%S'),
        })
        try:
            response = self.client.post(self.url, data)
        except utils.ActiveEntryError as e:
            self.assertEqual(str(e), "Only one active entry is allowed.")
        else:
            self.fail("Only one active entry should be allowed.")
        self.assertEqual(Entry.objects.count(), 2)
        self.assertEqual(Entry.objects.get(pk=entry1.pk), entry1)
        self.assertEqual(Entry.objects.get(pk=entry2.pk), entry2)

    def testClockInCurrentStatus(self):
        """Verify the status of the current entry shows what is expected"""
        self.login_user(self.user)
        entry1 = factories.Entry(**{
            'user': self.user,
            'start_time': self.ten_min_ago,
        })
        data = self.clock_in_form
        data.update({
            'start_time_0': self.now.strftime('%m/%d/%Y'),
            'start_time_1': self.now.strftime('%H:%M:%S'),
        })
        response = self.client.get(self.url, data)
        self.assertEqual(response.context['active'], entry1)

    def testClockInPause(self):
        """
        Test that the user can clock in while the current entry is paused.
        The current entry will be clocked out.
        """
        self.login_user(self.user)
        entry1 = factories.Entry(**{
            'user': self.user,
            'start_time': self.ten_min_ago,
        })
        e_id = Entry.objects.get(pk=entry1.id)
        e_id.pause()
        data = self.clock_in_form
        data.update({
            'start_time_0': self.now.strftime('%m/%d/%Y'),
            'start_time_1': self.now.strftime('%H:%M:%S'),
            'active_comment': 'test comment',
        })
        response = self.client.post(self.url, data, follow=True)
        #obtain entry1 now that it is closed. The hours should be recorded
        e_id = Entry.objects.get(pk=entry1.id)
        self.assertTrue(e_id.is_closed)
        self.assertTrue(e_id.hours)
        self.assertEqual(e_id.comments, 'test comment')

    def testClockInBlock(self):
        """
        The user cannot clock in to a time that is already logged
        """
        self.login_user(self.user)
        entry1_data = {
            'user': self.user,
            'project': self.project,
            'activity': self.devl_activity,
            'start_time': self.ten_min_ago,
            'end_time': self.now,
        }
        entry1 = factories.Entry(**entry1_data)
        entry1_data.update({
            'st_str': self.ten_min_ago.strftime('%H:%M:%S'),
            'end_str': self.now.strftime('%H:%M:%S'),
        })
        blocked_start_time = entry1.start_time + relativedelta(minutes=5)
        data = self.clock_in_form
        data.update({
            'start_time_0': blocked_start_time.strftime('%m/%d/%Y'),
            'start_time_1': blocked_start_time.strftime('%H:%M:%S'),
        })
        #This clock in attempt should be blocked by entry1
        response = self.client.post(self.url, data)
        form = response.context['form']
        self.assertEquals(len(form.errors), 1, form.errors)
        self.assertTrue('__all__' in form.errors, form.errors.keys())

    def testClockInSameTime(self):
        """
        Test that the user cannot clock in with the same start time as the
        active entry
        """
        self.login_user(self.user)
        entry1_data = {
            'user': self.user,
            'start_time': self.now,
            'project': self.project,
            'activity': self.devl_activity,
        }
        entry1 = factories.Entry(**entry1_data)
        entry1_data.update({
            'st_str': self.now.strftime('%H:%M:%S')
        })
        data = self.clock_in_form
        data.update({
            'start_time_0': entry1.start_time.strftime('%m/%d/%Y'),
            'start_time_1': entry1.start_time.strftime('%H:%M:%S'),
        })
        #This clock in attempt should be blocked by entry1 (same start time)
        response = self.client.post(self.url, data)
        self.assertFormError(response, 'form', None, \
            'Please enter a valid start time')
        self.assertFormError(response, 'form', 'start_time', \
            'The start time is on or before the current entry: ' + \
            '%(project)s - %(activity)s starting at %(st_str)s' % entry1_data)

    def testClockInBeforeCurrent(self):
        """
        Test that the user cannot clock in with a start time before the active
        entry
        """
        self.login_user(self.user)
        entry1_data = {
            'user': self.user,
            'project': self.project,
            'activity': self.devl_activity,
            'start_time': self.ten_min_ago,
        }
        entry1 = factories.Entry(**entry1_data)
        entry1_data.update({
            'st_str': self.ten_min_ago.strftime('%H:%M:%S')
        })
        before_entry1 = entry1.start_time - relativedelta(minutes=5)
        data = self.clock_in_form
        data.update({
            'start_time_0': before_entry1.strftime('%m/%d/%Y'),
            'start_time_1': before_entry1.strftime('%H:%M:%S'),
        })
        #This clock in attempt should be blocked by entry1
        #(It is before the start time of the current entry)
        response = self.client.post(self.url, data)
        form = response.context['form']
        self.assertEquals(len(form.errors), 2, form.errors)
        self.assertTrue('start_time' in form.errors, form.errors.keys)
        self.assertTrue('__all__' in form.errors, form.errors.keys)

    def testClockInActiveTooLong(self):
        """
        Test that if the active entry is too long, the clock in form will
        invalidate
        """
        self.login_user(self.user)
        entry1 = factories.Entry(**{
            'user': self.user,
            'start_time': self.now - relativedelta(hours=13),
        })
        end_time = self.now - relativedelta(seconds=1)
        data = self.clock_in_form
        data.update({
            'start_time_0': self.now.strftime('%m/%d/%Y'),
            'start_time_1': self.now.strftime('%H:%M:%S'),
        })
        response = self.client.post(self.url, data)
        err_msg = 'Ending time exceeds starting time by 12 hours ' \
            'or more for {0} on {1} at {2} to {3} at {4}.'.format(
                entry1.project,
                entry1.start_time.strftime('%m/%d/%Y'),
                entry1.start_time.strftime('%H:%M:%S'),
                end_time.strftime('%m/%d/%Y'),
                end_time.strftime('%H:%M:%S')
            )
        self.assertFormError(response, 'form', None, err_msg)

    def test_clockin_error_active_entry(self):
        """
        If you have an active entry and clock in to another,
        you should not be clocked out of the current active entry
        if the clock in form contains errors
        """
        self.login_user(self.user)

        # Create a valid entry and follow the redirect to the homepage
        response = self.client.post(self.url, self.clock_in_form, follow=True)
        self.assertEquals(response.status_code, 200)
        self.assertTrue(response.context['messages'])

        data = self.clock_in_form
        data.update({'start_time_0': None})
        response = self.client.post(self.url, data)

        msg = 'Enter a valid date/time.'
        self.assertFormError(response, 'form', 'start_time', msg)

        active = Entry.objects.get()
        self.assertIsNone(active.end_time)

    def test_clockin_correct_active_entry(self):
        """
        If you clock in with an an active entry, that entry
        should be clocked out
        """
        self.login_user(self.user)

        # Create a valid entry and follow the redirect to the homepage
        response = self.client.post(self.url, self.clock_in_form, follow=True)
        self.assertEquals(response.status_code, 200)
        self.assertTrue(response.context['messages'])

        active = Entry.objects.get()

        data = self.clock_in_form
        start_time = self.now + relativedelta(seconds=10)
        data.update({
            'start_time_0': start_time.strftime('%m/%d/%Y'),
            'start_time_1': start_time.strftime('%H:%M:%S')
        })
        response = self.client.post(self.url, data)

        active = Entry.objects.get(pk=active.pk)
        self.assertIsNotNone(active.end_time)

    def testProjectListFiltered(self):
        self.login_user(self.user)
        response = self.client.get(self.url)
        self.assertEquals(response.status_code, 200)
        projects = list(response.context['form'].fields['project'].queryset)
        self.assertTrue(self.project in projects)
        self.assertFalse(self.project2 in projects)
        self.project.status.enable_timetracking = False
        self.project.status.save()
        response = self.client.get(self.url)
        projects = list(response.context['form'].fields['project'].queryset)
        self.assertTrue(self.project not in projects)

    def testClockInLogin(self):
        response = self.client.get(self.url)
        self.assertEquals(response.status_code, 302)
        self.login_user(self.user)
        response = self.client.get(self.url)
        self.assertEquals(response.status_code, 200)

    def testClockInUnauthorizedProject(self):
        self.login_user(self.user)
        data = self.clock_in_form
        data.update({'project': self.project2.id})
        response = self.client.post(self.url, data)
        self.assertEqual(response.status_code, 200)
        self.assertTrue(response.context['form'].errors)
        err_msg = 'Select a valid choice. That choice is not one of the ' + \
                  'available choices.'
        self.assertFormError(response, 'form', 'project', err_msg)

    def testClockInBadActivity(self):
        self.login_user(self.user)
        data = self.clock_in_form
        data.update({
            'project': self.project.id,
            'activity': self.sick_activity.id,
        })
        response = self.client.post(self.url, data)
        err_msg = 'sick/personal is not allowed for this project. Please '
        err_msg += 'choose among development, and Work'
        self.assertFormError(response, 'form', None, err_msg)

    def test_clock_in_active_comments(self):
        """
        Comments left from editing the current active entry should appear
        if you are clocking in
        """
        entry = factories.Entry(**{
            'user': self.user,
            'start_time': self.ten_min_ago
        })
        entry.comments = u'Some comments'
        entry.save()

        self.login_user(self.user)

        response = self.client.get(self.url)
        self.assertContains(response, 'Some comments')


class AutoActivityTest(ViewTestMixin, LogTimeMixin, TestCase):
    """Test the initial value chosen for activity on clock in form"""

    def setUp(self):
        super(AutoActivityTest, self).setUp()
        self.user = factories.User()
        self.user2 = factories.User()
        self.superuser = factories.Superuser()
        permissions = Permission.objects.filter(
            content_type=ContentType.objects.get_for_model(Entry),
            codename__in=('can_clock_in', 'can_clock_out',
            'can_pause', 'change_entry')
        )
        self.user.user_permissions = permissions
        self.user2.user_permissions = permissions
        self.user.save()
        self.user2.save()
        self.activity = factories.Activity(code='WRK',
                name='Work')
        self.devl_activity = factories.Activity(code='devl',
                name='development', billable=True)
        self.sick_activity = factories.Activity(code="sick",
                name="sick/personal", billable=False)
        self.activity_group_all = factories.ActivityGroup(
                name='All')
        self.activity_group_work = factories.ActivityGroup(
                name='Client work')

        activities = Activity.objects.all()
        for activity in activities:
            activity.activity_group.add(self.activity_group_all)
            if activity != self.sick_activity:
                activity.activity_group.add(self.activity_group_work)
        self.business = factories.Business()
        status = factories.StatusAttribute(label='Current',
                enable_timetracking=True)
        type_ = factories.TypeAttribute(label='Web Sites',
                enable_timetracking=True)
        self.project = factories.Project(type=type_,
                status=status, business=self.business, point_person=self.user,
                activity_group=self.activity_group_work)
        self.project2 = factories.Project(type=type_,
                status=status, business=self.business, point_person=self.user2,
                activity_group=self.activity_group_all)
        factories.ProjectRelationship(user=self.user,
                project=self.project)
        self.location = factories.Location()

    def get_activity(self, project=None):
        if not project:
            project = self.project
        initial = {'project': project.id}
        form = ClockInForm(user=self.user, initial=initial)
        return form.initial['activity']

    def testNewWorker(self):
        """The worker has 0 entries on this project. Activity should = None"""
        self.login_user(self.user)
        self.assertEqual(self.get_activity(), None)

    def testLastWorkedOneEntry(self):
        """The worker has one previous entry on the project"""
        self.login_user(self.user)
        self.log_time(project=self.project, activity=self.devl_activity)
        self.assertEqual(self.get_activity(), self.devl_activity.id)

    def testLastWorkedSeveralEntries(self):
        """The worker has several entries on a project. Use the most recent"""
        self.login_user(self.user)
        for day in xrange(0, 10):
            this_day = utils.add_timezone(datetime.datetime(2011, 1, 1))
            this_day += relativedelta(days=day)
            activity = self.activity if day == 9 else self.devl_activity
            self.log_time(start=this_day, project=self.project,
                          activity=activity)
        self.assertEqual(self.get_activity(), self.activity.id)

    def testLastWorkedSeveralProjects(self):
        """
        Obtain activities contingent on the project when worker is on several
        """
        self.login_user(self.user)
        project1 = self.project
        project2 = self.project2
        for day in xrange(0, 10):
            this_day = utils.add_timezone(datetime.datetime(2011, 1, 1))
            this_day += relativedelta(days=day)
            #Cycle through projects and activities
            project = project1 if day % 2 == 0 else project2
            activity = self.devl_activity if day % 3 == 0 else self.activity
            self.log_time(start=this_day, project=project, activity=activity)
        self.assertEqual(self.get_activity(project1), self.activity.id)
        self.assertEqual(self.get_activity(project2), self.devl_activity.id)


class ClockOutTest(ViewTestMixin, TestCase):

    def setUp(self):
        super(ClockOutTest, self).setUp()
        self.user = factories.User()
        self.user2 = factories.User()
        self.superuser = factories.Superuser()
        permissions = Permission.objects.filter(
            content_type=ContentType.objects.get_for_model(Entry),
            codename__in=('can_clock_in', 'can_clock_out',
            'can_pause', 'change_entry')
        )
        self.user.user_permissions = permissions
        self.user2.user_permissions = permissions
        self.user.save()
        self.user2.save()
        self.activity = factories.Activity(code='WRK',
                name='Work')
        self.devl_activity = factories.Activity(code='devl',
                name='development', billable=True)
        self.sick_activity = factories.Activity(code="sick",
                name="sick/personal", billable=False)
        self.activity_group_all = factories.ActivityGroup(
                name='All')
        self.activity_group_work = factories.ActivityGroup(
                name='Client work')

        activities = Activity.objects.all()
        for activity in activities:
            activity.activity_group.add(self.activity_group_all)
            if activity != self.sick_activity:
                activity.activity_group.add(self.activity_group_work)
        self.business = factories.Business()
        status = factories.StatusAttribute(label='Current',
                enable_timetracking=True)
        type_ = factories.TypeAttribute(label='Web Sites',
            enable_timetracking=True)
        self.project = factories.Project(type=type_,
                status=status, business=self.business, point_person=self.user,
                activity_group=self.activity_group_work)
        self.project2 = factories.Project(type=type_,
                status=status, business=self.business, point_person=self.user2,
                activity_group=self.activity_group_all)
        factories.ProjectRelationship(user=self.user,
                project=self.project)
        self.location = factories.Location()

        self.url = reverse('clock_out')
        self.login_user(self.user)

        # Create an active entry, so that clock out tests don't have to.
        self.default_end_time = timezone.now()
        back = timezone.now() - relativedelta(hours=5)
        self.entry = factories.Entry(**{
            'user': self.user,
            'start_time': back,
            'project': self.project,
            'activity': self.devl_activity,
        })

    def testBasicClockOut(self):
        data = {
            'start_time_0': self.entry.start_time.strftime('%m/%d/%Y'),
            'start_time_1': self.entry.start_time.strftime('%H:%M:%S'),
            'end_time_0': self.default_end_time.strftime('%m/%d/%Y'),
            'end_time_1': self.default_end_time.strftime('%H:%M:%S'),
            'location': self.location.pk,
        }
        response = self.client.post(
            self.url, data,
            follow=True,
        )
        closed_entry = Entry.objects.get(pk=self.entry.pk)
        self.assertTrue(closed_entry.is_closed)

    def testClockOutWithSecondsPaused(self):
        """
        Test that clocking out of an unpaused entry with previous pause time
        calculates the correct amount of unpaused time.
        """
        entry_with_pause = self.entry
        #paused for a total of 1 hour
        entry_with_pause.seconds_paused = 3600
        entry_with_pause.save()
        data = {
            'start_time_0': entry_with_pause.start_time.strftime('%m/%d/%Y'),
            'start_time_1': entry_with_pause.start_time.strftime('%H:%M:%S'),
            'end_time_0': self.default_end_time.strftime('%m/%d/%Y'),
            'end_time_1': self.default_end_time.strftime('%H:%M:%S'),
            'location': self.location.pk,
        }
        response = self.client.post(reverse('clock_out'), data)
        entry_with_pause = Entry.objects.get(pk=entry_with_pause.pk)
        self.assertAlmostEqual(entry_with_pause.hours, 4)

    def testClockOutWhilePaused(self):
        """
        Test that clocking out of a paused entry calculates the correct time
        """
        paused_entry = self.entry
        paused_entry.pause_time = self.entry.start_time \
            + relativedelta(hours=1)
        paused_entry.save()
        data = {
            'start_time_0': paused_entry.start_time.strftime('%m/%d/%Y'),
            'start_time_1': paused_entry.start_time.strftime('%H:%M:%S'),
            'end_time_0': self.default_end_time.strftime('%m/%d/%Y'),
            'end_time_1': self.default_end_time.strftime('%H:%M:%S'),
            'location': self.location.pk,
        }
        response = self.client.post(reverse('clock_out'), data)
        paused_entry = Entry.objects.get(pk=paused_entry.pk)
        self.assertAlmostEqual(paused_entry.hours, 1)

    def testClockOutReverse(self):
        """
        Test that the user can't clock out at a time prior to the starting time
        """
        backward_entry = self.entry
        backward_entry.save()
        #reverse the times
        data = {
            'start_time_0': self.default_end_time.strftime('%m/%d/%Y'),
            'start_time_1': self.default_end_time.strftime('%H:%M:%S'),
            'end_time_0': self.entry.start_time.strftime('%m/%d/%Y'),
            'end_time_1': self.entry.start_time.strftime('%H:%M:%S'),
            'location': self.location.pk,
        }
        response = self.client.post(reverse('clock_out'), data)
        self.assertFormError(response, 'form', None,
            'Ending time must exceed the starting time')

    def testClockOutTooLong(self):
        end_time = self.entry.start_time + relativedelta(hours=13)
        data = {
            'start_time_0': self.entry.start_time.strftime('%m/%d/%Y'),
            'start_time_1': self.entry.start_time.strftime('%H:%M:%S'),
            'end_time_0': end_time.strftime('%m/%d/%Y'),
            'end_time_1': end_time.strftime('%H:%M:%S'),
            'location': self.location.pk,
        }
        response = self.client.post(self.url, data)
        err_msg = 'Ending time exceeds starting time by 12 hours ' \
            'or more for {0} on {1} at {2} to {3} at {4}.'.format(
                self.entry.project,
                self.entry.start_time.strftime('%m/%d/%Y'),
                self.entry.start_time.strftime('%H:%M:%S'),
                end_time.strftime('%m/%d/%Y'),
                end_time.strftime('%H:%M:%S')
            )
        self.assertFormError(response, 'form', None, err_msg)

    def testClockOutPauseTooLong(self):
        paused_entry = self.entry
        paused_entry.seconds_paused = 60 * 60 * 13
        paused_entry.save()
        data = {
            'start_time_0': paused_entry.start_time.strftime('%m/%d/%Y'),
            'start_time_1': paused_entry.start_time.strftime('%H:%M:%S'),
            'end_time_0': self.default_end_time.strftime('%m/%d/%Y'),
            'end_time_1': self.default_end_time.strftime('%H:%M:%S'),
            'location': self.location.pk,
        }
        response = self.client.post(reverse('clock_out'), data)
        err_msg = 'Ending time exceeds starting time by 12 hours ' \
            'or more for {0} on {1} at {2} to {3} at {4}.'.format(
                self.entry.project,
                paused_entry.start_time.strftime('%m/%d/%Y'),
                paused_entry.start_time.strftime('%H:%M:%S'),
                self.default_end_time.strftime('%m/%d/%Y'),
                self.default_end_time.strftime('%H:%M:%S')
            )
        self.assertFormError(response, 'form', None, err_msg)

    def testClockOutOverlap(self):
        """
        Test that the user cannot clock out if the times overlap with an
        existing entry
        """
        # Create a closed and valid entry
        now = timezone.now() - relativedelta(hours=5)
        entry1_data = {
            'user': self.user,
            'project': self.project,
            'activity': self.devl_activity,
            'start_time': now,
            'end_time': self.default_end_time
        }
        entry1 = factories.Entry(**entry1_data)
        entry1_data.update({
            'st_str': entry1.start_time.strftime('%H:%M:%S'),
            'end_str': entry1.end_time.strftime('%H:%M:%S'),
        })

        # Create a form with times that overlap with entry1
        bad_start = entry1.start_time - relativedelta(hours=1)
        bad_end = entry1.end_time + relativedelta(hours=1)
        bad_entry = factories.Entry(**{
            'user': self.user,
            'start_time': bad_start,
            'end_time': bad_end,
        })
        data = {
            'start_time_0': bad_start.strftime('%m/%d/%Y'),
            'start_time_1': bad_start.strftime('%H:%M:%S'),
            'end_time_0': bad_end.strftime('%m/%d/%Y'),
            'end_time_1': bad_end.strftime('%H:%M:%S'),
            'location': self.location.pk,
        }
        # With entry1 on either side, a post with the bad_entry data should
        # fail
        response = self.client.post(reverse('clock_out'), data)
        form = response.context['form']
        self.assertEquals(len(form.errors), 1, form.errors.keys)
        self.assertTrue('__all__' in form.errors, form.errors)

    def test_clocking_out_inactive(self):
        # If clock out when not active, redirect to dashboard
        # (e.g. double-clicked clock out button or clicked it on an old page)

        # setUp clocked us in, so clock out again
        data = {
            'start_time_0': self.entry.start_time.strftime('%m/%d/%Y'),
            'start_time_1': self.entry.start_time.strftime('%H:%M:%S'),
            'end_time_0': self.default_end_time.strftime('%m/%d/%Y'),
            'end_time_1': self.default_end_time.strftime('%H:%M:%S'),
            'location': self.location.pk,
            }
        response = self.client.post(
            self.url, data,
            follow=True,
            )
        # Do it again - make sure we redirect to the dashboard
        response = self.client.post(
            self.url, data,
            follow=False,
            )
        self.assertRedirects(response, reverse('dashboard'),
                             status_code=302, target_status_code=200)



class CheckOverlap(ViewTestMixin, LogTimeMixin, TestCase):
    """
    With entry overlaps, entry.check_overlap method should return True
    With valid entries, check_overlap should return False
    """

    def setUp(self):
        super(CheckOverlap, self).setUp()

        self.user = factories.User()
        self.user2 = factories.User()
        self.superuser = factories.Superuser()
        permissions = Permission.objects.filter(
            content_type=ContentType.objects.get_for_model(Entry),
            codename__in=('can_clock_in', 'can_clock_out',
            'can_pause', 'change_entry')
        )
        self.user.user_permissions = permissions
        self.user2.user_permissions = permissions
        self.user.save()
        self.user2.save()
        self.activity = factories.Activity(code='WRK',
                name='Work')
        self.devl_activity = factories.Activity(code='devl',
                name='development', billable=True)
        self.sick_activity = factories.Activity(code="sick",
                name="sick/personal", billable=False)
        self.activity_group_all = factories.ActivityGroup(
                name='All')
        self.activity_group_work = factories.ActivityGroup(
                name='Client work')

        activities = Activity.objects.all()
        for activity in activities:
            activity.activity_group.add(self.activity_group_all)
            if activity != self.sick_activity:
                activity.activity_group.add(self.activity_group_work)
        self.business = factories.Business()
        status = factories.StatusAttribute(label='Current',
                enable_timetracking=True)
        type_ = factories.TypeAttribute(label='Web Sites',
            enable_timetracking=True)
        self.project = factories.Project(type=type_,
                status=status, business=self.business, point_person=self.user,
                activity_group=self.activity_group_work)
        self.project2 = factories.Project(type=type_,
                status=status, business=self.business, point_person=self.user2,
                activity_group=self.activity_group_all)
        factories.ProjectRelationship(user=self.user,
                project=self.project)
        self.location = factories.Location()

        self.login_user(self.user)
        self.now = timezone.now()
        #define start and end times to create valid entries
        self.start = self.now - relativedelta(days=0, hours=8)
        self.end = self.now - relativedelta(days=0)
        #Create a valid entry for the tests to overlap with
        self.log_time(start=self.start, end=self.end)
        #define bad start times relative to the valid one (just in/outside)
        self.start_before = self.start - relativedelta(minutes=2)
        self.start_inside = self.start + relativedelta(minutes=2)
        self.end_inside = self.end - relativedelta(minutes=2)
        self.end_after = self.end + relativedelta(minutes=2)

    #helper functions
    def use_checkoverlap(self, entries):
        """
        Uses entry.check_overlap given a list of entries returns all overlaps
        """
        user_total_overlaps = 0
        for index_a, entry_a in enumerate(entries):
            for index_b in xrange(index_a, len(entries)):
                entry_b = entries[index_b]
                if entry_a.check_overlap(entry_b):
                    user_total_overlaps += 1
        return user_total_overlaps

    def get_entries(self):
        return Entry.objects.filter(user=self.user)

    #Invalid entries to test against
    def testBeforeAndIn(self):
        self.log_time(start=self.start_before, end=self.end_inside)
        user_total_overlaps = self.use_checkoverlap(self.get_entries())
        self.assertEqual(user_total_overlaps, 1)

    def testAfterAndIn(self):
        self.log_time(start=self.start_inside, end=self.end_after)
        user_total_overlaps = self.use_checkoverlap(self.get_entries())
        self.assertEqual(user_total_overlaps, 1)

    def testInside(self):
        self.log_time(start=self.start_inside, end=self.end_inside)
        user_total_overlaps = self.use_checkoverlap(self.get_entries())
        self.assertEqual(user_total_overlaps, 1)

    def testOutside(self):
        self.log_time(start=self.start_before, end=self.end_after)
        user_total_overlaps = self.use_checkoverlap(self.get_entries())
        self.assertEqual(user_total_overlaps, 1)

    def testOverlapWithPause(self):
        """Overlaps by two minutes. Passes because it has 2 min. of pause"""
        self.log_time(start=self.start_before, end=self.start_inside,
            pause=120)
        user_total_overlaps = self.use_checkoverlap(self.get_entries())
        self.assertEqual(user_total_overlaps, 0)

    def testOverlapWithoutEnoughPause(self):
        """Overlaps by two minutes, but only has 119 seconds of pause"""
        self.log_time(start=self.start_before, end=self.start_inside,
            pause=119)
        user_total_overlaps = self.use_checkoverlap(self.get_entries())
        self.assertEqual(user_total_overlaps, 1)


class CreateEditEntry(ViewTestMixin, TestCase):

    def setUp(self):
        super(CreateEditEntry, self).setUp()

        self.user = factories.User()
        self.user2 = factories.User()
        self.superuser = factories.Superuser()
        permissions = Permission.objects.filter(
            content_type=ContentType.objects.get_for_model(Entry),
            codename__in=('can_clock_in', 'can_clock_out',
            'can_pause', 'change_entry')
        )
        self.user.user_permissions = permissions
        self.user2.user_permissions = permissions
        self.user.save()
        self.user2.save()
        self.activity = factories.Activity(code='WRK',
                name='Work')
        self.devl_activity = factories.Activity(code='devl',
                name='development', billable=True)
        self.sick_activity = factories.Activity(code="sick",
                name="sick/personal", billable=False)
        self.activity_group_all = factories.ActivityGroup(
                name='All')
        self.activity_group_work = factories.ActivityGroup(
                name='Client work')

        activities = Activity.objects.all()
        for activity in activities:
            activity.activity_group.add(self.activity_group_all)
            if activity != self.sick_activity:
                activity.activity_group.add(self.activity_group_work)
        self.business = factories.Business()
        status = factories.StatusAttribute(label='Current',
                enable_timetracking=True)
        type_ = factories.TypeAttribute(label='Web Sites',
            enable_timetracking=True)
        self.project = factories.Project(type=type_,
                status=status, business=self.business, point_person=self.user,
                activity_group=self.activity_group_work)
        self.project2 = factories.Project(type=type_,
                status=status, business=self.business, point_person=self.user2,
                activity_group=self.activity_group_all)
        factories.ProjectRelationship(user=self.user,
                project=self.project)
        self.location = factories.Location()

        self.login_user(self.user)
        self.now = timezone.now()
        valid_start = self.now - relativedelta(days=1)
        valid_end = valid_start + relativedelta(hours=1)
        self.ten_min_ago = self.now - relativedelta(minutes=10)
        self.two_hour_ago = self.now - relativedelta(hours=2)
        self.one_hour_ago = self.now - relativedelta(hours=1)
        #establish data, entries, urls for all tests
        self.default_data = {
            'project': self.project.pk,
            'location': self.location.pk,
            'activity': self.devl_activity.pk,
            'seconds_paused': 0,
            'start_time_0': valid_start.strftime('%m/%d/%Y'),
            'start_time_1': valid_start.strftime('%H:%M:%S'),
            'end_time_0': valid_end.strftime('%m/%d/%Y'),
            'end_time_1': valid_end.strftime('%H:%M:%S'),
        }
        self.closed_entry_data = {
            'user': self.user,
            'project': self.project,
            'activity': self.devl_activity,
            'start_time': self.two_hour_ago,
            'end_time': self.one_hour_ago,
        }
        self.current_entry_data = {
            'user': self.user,
            'project': self.project,
            'activity': self.devl_activity,
            'start_time': self.ten_min_ago,
        }
        self.closed_entry = factories.Entry(**self.closed_entry_data)
        self.current_entry = factories.Entry(**self.current_entry_data)
        self.closed_entry_data.update({
            'st_str': self.two_hour_ago.strftime('%H:%M:%S'),
            'end_str': self.one_hour_ago.strftime('%H:%M:%S'),
        })
        self.current_entry_data.update({
            'st_str': self.ten_min_ago.strftime('%H:%M:%S'),
        })
        self.create_url = reverse('create_entry')
        self.edit_closed_url = reverse('edit_entry',
            args=[self.closed_entry.pk])
        self.edit_current_url = reverse('edit_entry',
            args=[self.current_entry.pk])

    def testCreateEntry(self):
        """
        Test the ability to create a valid new entry
        """
        response = self.client.post(self.create_url, self.default_data,
            follow=True)
        self.assertRedirects(response, reverse('dashboard'),
            status_code=302, target_status_code=200)
        self.assertContains(response,
            'The entry has been created successfully', count=1)

    def testEditClosed(self):
        """
        Test the ability to edit a closed entry, using valid values
        """
        response = self.client.post(self.edit_closed_url, self.default_data,
            follow=True)
        self.assertRedirects(response, reverse('dashboard'),
            status_code=302, target_status_code=200)
        self.assertContains(response,
            'The entry has been updated successfully', count=1)

    def testEditCurrentSameTime(self):
        """
        Test the ability to edit a current entry, not changing the values
        """
        data = self.default_data
        data.update({
            'start_time_0': self.current_entry_data['start_time'].strftime(
                '%m/%d/%Y'),
            'start_time_1': self.current_entry_data['start_time'].strftime(
                '%H:%M:%S'),
        })
        response = self.client.post(self.edit_current_url, data, follow=True)
        #This post should redirect to the dashboard, with the correct message
        #and 1 active entry, because we updated the current entry from setUp
        self.assertRedirects(response, reverse('dashboard'),
            status_code=302, target_status_code=200)
        self.assertContains(response,
            'The entry has been updated successfully', count=1)
        entries = Entry.objects.filter(
            user=self.user, end_time__isnull=True
        )
        self.assertEquals(entries.count(), 1)

    def testEditCurrentDiffTime(self):
        """
        Test the ability to edit a current entry, using valid new values
        """
        data = self.default_data
        new_start = self.current_entry_data['start_time'] + \
            relativedelta(minutes=5)
        data.update({
            'start_time_0': new_start.strftime('%m/%d/%Y'),
            'start_time_1': new_start.strftime('%H:%M:%S'),
        })
        response = self.client.post(self.edit_current_url, data, follow=True)
        #This post should redirect to the dashboard, with the correct message
        #and 1 active entry, because we updated the current entry from setUp
        self.assertRedirects(response, reverse('dashboard'),
            status_code=302, target_status_code=200)
        entries = Entry.objects.filter(
            user=self.user, end_time__isnull=True
        )
        self.assertEquals(entries.count(), 1)

    def testCreateBlockByClosed(self):
        """
        Test that the entry is blocked by closed entries that overlap
        """
        overlap_entry = self.default_data
        overlap_entry.update({
            'start_time_0': self.closed_entry.start_time.strftime('%m/%d/%Y'),
            'start_time_1': self.closed_entry.start_time.strftime('%H:%M:%S'),
            'end_time_0': self.closed_entry.end_time.strftime('%m/%d/%Y'),
            'end_time_1': self.closed_entry.end_time.strftime('%H:%M:%S'),
        })
        response = self.client.post(self.create_url, overlap_entry,
            follow=True)
        form = response.context['form']
        self.assertEquals(len(form.errors), 1, form.errors)
        self.assertTrue('__all__' in form.errors, form.errors.keys())

    def testCreateBlockByCurrent(self):
        """
        Test that the entry is blocked by the current entry when appropriate
        """
        overlap_entry = self.default_data
        overlap_entry.update({
            'start_time_0': self.current_entry.start_time.strftime('%m/%d/%Y'),
            'start_time_1': self.current_entry.start_time.strftime('%H:%M:%S'),
            'end_time_0': self.now.strftime('%m/%d/%Y'),
            'end_time_1': self.now.strftime('%H:%M:%S'),
        })
        response = self.client.post(self.create_url, overlap_entry,
            follow=True)
        form = response.context['form']
        self.assertEquals(len(form.errors), 1, form.errors)
        self.assertTrue('__all__' in form.errors, form.errors.keys())

    def testCreateTooLongEntry(self):
        """
        Test that the entry is blocked if the duration is too long.
        """
        long_entry = self.default_data
        end_time = self.now + relativedelta(hours=13)
        long_entry.update({
            'start_time_0': self.now.strftime('%m/%d/%Y'),
            'start_time_1': self.now.strftime('%H:%M:%S'),
            'end_time_0': end_time.strftime('%m/%d/%Y'),
            'end_time_1': end_time.strftime('%H:%M:%S'),
        })
        response = self.client.post(self.create_url, long_entry, follow=True)
        err_msg = 'Ending time exceeds starting time by 12 hours ' \
            'or more for {0} on {1} at {2} to {3} at {4}.'.format(
                self.project,
                self.now.strftime('%m/%d/%Y'),
                self.now.strftime('%H:%M:%S'),
                end_time.strftime('%m/%d/%Y'),
                end_time.strftime('%H:%M:%S')
            )
        self.assertFormError(response, 'form', None, err_msg)

    def testCreateLongPauseEntry(self):
        """
        Test that the entry is blocked if the duration is too long.
        """
        long_pause = self.default_data
        long_pause['seconds_paused'] = 60 * 60 * 13
        response = self.client.post(self.create_url, long_pause, follow=True)

    def testProjectList(self):
        """
        Make sure the list of available projects conforms to user associations
        """
        response = self.client.get(reverse('create_entry'))
        self.assertEqual(response.status_code, 200)
        projects = list(response.context['form'].fields['project'].queryset)
        self.assertTrue(self.project in projects)
        self.assertTrue(self.project2 not in projects)
        self.project.status.enable_timetracking = False
        self.project.status.save()
        response = self.client.get(reverse('create_entry'))
        projects = list(response.context['form'].fields['project'].queryset)
        self.assertTrue(self.project not in projects)

    def testBadActivity(self):
        """
        Make sure the user cannot add an entry for an activity that is not in
        the project's activity group
        """
        data = self.default_data
        data.update({'activity': self.sick_activity.id})
        response = self.client.post(self.create_url, data)
        err_msg = 'sick/personal is not allowed for this project. Please '
        err_msg += 'choose among development, and Work'
        self.assertFormError(response, 'form', None, err_msg)

    def add_entry_test_helper(self):
        self.login_user(self.user)

        response = self.client.post(self.create_url, data=self.default_data,
            follow=True)
        self.assertEqual(response.status_code, 200)

        msg = 'You cannot add/edit entries after a timesheet has been ' \
            'approved or invoiced. Please correct the start and end times.'
        self.assertEqual([msg], response.context['form'].non_field_errors())

    def test_add_approved_entries(self):
        """
        If your entries have been verified and then approved, you should
        not be able to add entries for that time period
        """
        entry = factories.Entry(**{
            'user': self.user,
            'start_time': self.ten_min_ago,
            'end_time': self.ten_min_ago + relativedelta(minutes=1)
        })
        entry.status = Entry.INVOICED
        entry.save()

        self.add_entry_test_helper()

    def test_add_invoiced_entries(self):
        """
        If your entries have been verified, approved, and invoiced, you
        should not be able to add entries for that time period
        """
        entry = factories.Entry(**{
            'user': self.user,
            'start_time': self.ten_min_ago,
            'end_time': self.ten_min_ago + relativedelta(minutes=1)
        })
        entry.status = Entry.INVOICED
        entry.save()

        self.add_entry_test_helper()

    def edit_entry_helper(self, status='approved'):
        """Helper function for editing approved entries"""
        entry = factories.Entry(**{
            'user': self.user,
            'project': self.project,
            'start_time': self.now - relativedelta(hours=6),
            'end_time': self.now - relativedelta(hours=5),
            'status': status
        })
        url = reverse('edit_entry', args=(entry.pk,))

        data = self.default_data
        data.update({
            'start_time_0': entry.start_time.strftime('%m/%d/%Y'),
            'start_time_1': entry.start_time.strftime('%H:%M:%S'),
            'end_time_0': entry.end_time.strftime('%m/%d/%Y'),
            'end_time_1': entry.end_time.strftime('%H:%M:%S'),
        })

        return url, entry, data

    def test_admin_edit_approved_entry(self):
        """
        An administrator (or anyone with view_payroll_summary perm) should
        be able to edit an entry even if theyve been approved
        """
        self.client.logout()
        self.login_user(self.superuser)

        url, entry, data = self.edit_entry_helper()

        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)

        response = self.client.post(url, data=data, follow=True)
        self.assertEqual(response.status_code, 200)
        self.assertContains(response,
            'The entry has been updated successfully.')

        self.assertEqual(self.user, entry.user)

    def test_user_edit_approved_entry(self):
        """A regular user shouldnt be able to edit an approved entry"""
        url, entry, data = self.edit_entry_helper()

        response = self.client.get(url)
        self.assertEqual(response.status_code, 404)

        response = self.client.post(url, data=data)
        self.assertEqual(response.status_code, 404)

    def test_edit_invoiced_entry(self):
        """You shouldnt be able to edit an invoiced entry"""
        self.client.logout()
        self.login_user(self.superuser)

        url, entry, data = self.edit_entry_helper(Entry.INVOICED)

        response = self.client.post(url, data=data, follow=True)
        self.assertEqual(response.status_code, 200)

        msg = 'You cannot add/edit entries after a timesheet has been ' \
            'approved or invoiced. Please correct the start and end times.'
        self.assertContains(response, msg)


class StatusTest(ViewTestMixin, TestCase):

    def setUp(self):
        super(StatusTest, self).setUp()

        self.user = factories.User()
        self.user2 = factories.User()
        self.superuser = factories.Superuser()
        permissions = Permission.objects.filter(
            content_type=ContentType.objects.get_for_model(Entry),
            codename__in=('can_clock_in', 'can_clock_out',
            'can_pause', 'change_entry')
        )
        self.user.user_permissions = permissions
        self.user2.user_permissions = permissions
        self.user.save()
        self.user2.save()
        self.activity = factories.Activity(code='WRK',
                name='Work')
        self.devl_activity = factories.Activity(code='devl',
                name='development', billable=True)
        self.sick_activity = factories.Activity(code="sick",
                name="sick/personal", billable=False)
        self.activity_group_all = factories.ActivityGroup(
                name='All')
        self.activity_group_work = factories.ActivityGroup(
                name='Client work')

        activities = Activity.objects.all()
        for activity in activities:
            activity.activity_group.add(self.activity_group_all)
            if activity != self.sick_activity:
                activity.activity_group.add(self.activity_group_work)
        self.business = factories.Business()
        status = factories.StatusAttribute(label='Current',
                enable_timetracking=True)
        type_ = factories.TypeAttribute(label='Web Sites',
            enable_timetracking=True)
        self.project = factories.Project(type=type_,
                status=status, business=self.business, point_person=self.user,
                activity_group=self.activity_group_work)
        self.project2 = factories.Project(type=type_,
                status=status, business=self.business, point_person=self.user2,
                activity_group=self.activity_group_all)
        factories.ProjectRelationship(user=self.user,
                project=self.project)
        self.location = factories.Location()

        self.login_user(self.user)
        self.now = timezone.now()
        self.from_date = utils.get_month_start(self.now)
        self.sheet_url = reverse('view_user_timesheet', args=[self.user.pk])

    def verify_url(self, user=None, from_date=None):
        user = user or self.user
        from_date = from_date or self.from_date
        base_url = reverse('change_user_timesheet', args=(user.pk, 'verify'))
        params = {'from_date': from_date.strftime('%Y-%m-%d')}
        params = urllib.urlencode(params)
        return '{0}?{1}'.format(base_url, params)

    def approve_url(self, user=None, from_date=None):
        user = user or self.user
        from_date = from_date or self.from_date
        base_url = reverse('change_user_timesheet', args=(user.pk, 'approve'))
        params = {'from_date': from_date.strftime('%Y-%m-%d')}
        params = urllib.urlencode(params)
        return '{0}?{1}'.format(base_url, params)

    def get_reject_url(self, entry_id):
        "Helper for the reject entry view"
        return reverse('reject_entry', args=[entry_id])

    def login_as_admin(self):
        "Helper to login as an admin user"
        self.admin = factories.Superuser()
        self.login_user(self.admin)

    def login_with_permissions(self, *codenames):
        """Helper to login as a user with correct permissions"""
        perms = Permission.objects.filter(codename__in=codenames)
        self.perm_user = factories.User()
        self.perm_user.user_permissions.add(*perms)
        self.perm_user.save()
        self.login_user(self.perm_user)

    def test_verify_link(self):
        entry = factories.Entry(**{
            'user': self.user,
            'start_time': self.now - relativedelta(hours=1),
            'end_time': self.now
        })

        response = self.client.get(self.sheet_url)
        self.assertTrue(response.status_code, 200)

        self.assertTrue(response.context['show_verify'])
        self.assertFalse(response.context['show_approve'])

    def test_approve_link_no_permission(self):
        """Permission is required to see approve timesheet link."""
        entry = factories.Entry(**{
            'user': self.user,
            'start_time': self.now - relativedelta(hours=1),
            'end_time': self.now,
            'status': Entry.VERIFIED
        })
        response = self.client.get(self.sheet_url)
        self.assertFalse(response.context['show_approve'])

    def test_approve_link(self):
        self.login_with_permissions('view_entry_summary', 'approve_timesheet')
        entry = factories.Entry(**{
            'user': self.user,
            'start_time': self.now - relativedelta(hours=1),
            'end_time': self.now,
            'status': Entry.VERIFIED
        })
        response = self.client.get(self.sheet_url)
        self.assertEquals(response.status_code, 200)

        self.assertTrue(response.context['show_approve'])
        self.assertFalse(response.context['show_verify'])

    def test_no_hours_verify(self):
        response = self.client.get(self.verify_url(), follow=True)
        self.assertEquals(response.status_code, 200)

        msg = 'You cannot verify/approve a timesheet with no hours'
        messages = response.context['messages']
        self.assertEquals(messages._loaded_messages[0].message, msg)

        response = self.client.post(self.verify_url(), follow=True)
        self.assertEquals(messages._loaded_messages[0].message, msg)

    def test_no_hours_approve(self):
        self.login_with_permissions('approve_timesheet', 'view_entry_summary')
        response = self.client.get(self.approve_url(), follow=True)
        self.assertEquals(response.status_code, 200)

        msg = 'You cannot verify/approve a timesheet with no hours'
        messages = response.context['messages']
        self.assertEquals(messages._loaded_messages[0].message, msg)

        response = self.client.post(self.approve_url(), follow=True)
        self.assertEquals(messages._loaded_messages[0].message, msg)

    def test_verify_other_user(self):
        """A user should not be able to verify another's timesheet"""
        entry = factories.Entry(**{
            'user': self.user2,
            'start_time': self.now - relativedelta(hours=1),
            'end_time': self.now,
        })
        url = self.verify_url(self.user2)
        response = self.client.get(url)

        self.assertEquals(response.status_code, 403)
        self.assertEquals(entry.status, Entry.UNVERIFIED)

        response = self.client.post(url, {'do_action': 'Yes'})
        self.assertEquals(response.status_code, 403)
        self.assertEquals(entry.status, Entry.UNVERIFIED)

    def test_approve_user(self):
        """A regular user should not be able to approve their timesheet"""
        entry = factories.Entry(**{
            'user': self.user,
            'start_time': self.now - relativedelta(hours=1),
            'end_time': self.now
        })

        response = self.client.get(self.approve_url())
        self.assertEquals(response.status_code, 403)

        response = self.client.post(self.approve_url(), {'do_action': 'Yes'})
        self.assertEquals(response.status_code, 403)
        self.assertNotEquals(entry.status, Entry.APPROVED)
        self.assertContains(response,
            'Forbidden: You cannot approve this timesheet',
            status_code=403
        )

    def test_approve_other_user(self):
        """A regular user should not be able to approve another's timesheet"""
        entry = factories.Entry(**{
            'user': self.user2,
            'start_time': self.now - relativedelta(hours=1),
            'end_time': self.now
        })

        response = self.client.get(self.approve_url())
        self.assertEquals(response.status_code, 403)

        response = self.client.post(self.approve_url(), {'do_action': 'Yes'})
        self.assertEquals(response.status_code, 403)
        self.assertNotEquals(entry.status, Entry.APPROVED)
        self.assertContains(response,
            'Forbidden: You cannot approve this timesheet',
            status_code=403
        )

    def test_verify_active_entry(self):
        """
        A user shouldnt be able to verify a timesheet if it contains
        an active entry and should be redirect back to the ledger
        """
        self.login_as_admin()

        entry1 = factories.Entry(**{
            'user': self.user,
            'start_time': self.now - relativedelta(hours=5),
            'end_time': self.now - relativedelta(hours=4),
            'status': Entry.UNVERIFIED
        })
        entry2 = factories.Entry(**{
            'user': self.user,
            'start_time': self.now - relativedelta(hours=1),
            'status': Entry.UNVERIFIED
        })

        response = self.client.get(self.verify_url(), follow=True)
        self.assertEquals(response.status_code, 200)

        messages = response.context['messages']
        msg = 'You cannot verify/approve this timesheet while the user {0} ' \
            'has an active entry. Please have them close any active ' \
            'entries.'.format(self.user.get_name_or_username())

        self.assertEquals(messages._loaded_messages[0].message, msg)
        self.assertEquals(entry1.status, Entry.UNVERIFIED)
        self.assertEquals(entry2.status, Entry.UNVERIFIED)

        response = self.client.post(self.verify_url(), follow=True)
        self.assertEquals(response.status_code, 200)
        messages = response.context['messages']

        self.assertEquals(messages._loaded_messages[0].message, msg)
        self.assertEquals(entry1.status, Entry.UNVERIFIED)
        self.assertEquals(entry2.status, Entry.UNVERIFIED)

    def testVerifyButton(self):
        response = self.client.get(self.sheet_url)
        self.assertNotContains(response, self.verify_url())
        entry = factories.Entry(**{
            'user': self.user,
            'start_time': timezone.now() - \
                relativedelta(hours=1),
            'end_time':  timezone.now(),
        })
        response = self.client.get(self.sheet_url)
        self.assertTrue(response.context['show_verify'])
        entry.status = Entry.VERIFIED
        entry.save()
        response = self.client.get(self.sheet_url)
        self.assertFalse(response.context['show_verify'])

    def testApproveButton(self):
        self.login_as_admin()
        response = self.client.get(self.sheet_url)
        self.assertFalse(response.context['show_approve'])
        entry = factories.Entry(**{
            'user': self.user,
            'start_time': timezone.now() - relativedelta(hours=1),
            'end_time':  timezone.now(),
        })
        response = self.client.get(self.sheet_url)
        self.assertFalse(response.context['show_approve'])
        entry.status = Entry.VERIFIED
        entry.save()
        response = self.client.get(self.sheet_url)
        self.assertTrue(response.context['show_approve'])
        entry.status = Entry.APPROVED
        entry.save()
        response = self.client.get(self.sheet_url)
        self.assertFalse(response.context['show_approve'])

    def testVerifyPage(self):
        entry = factories.Entry(**{
            'user': self.user,
            'start_time': timezone.now() - \
                relativedelta(hours=1),
            'end_time':  timezone.now(),
        })
        response = self.client.get(self.verify_url())
        entries = self.user.timepiece_entries.all()
        self.assertEquals(entries[0].status, Entry.UNVERIFIED)
        response = self.client.post(self.verify_url(), {'do_action': 'Yes'})
        self.assertEquals(entries[0].status, Entry.VERIFIED)

    def testApprovePage(self):
        self.login_with_permissions('approve_timesheet', 'view_entry_summary')
        entry = factories.Entry(**{
            'user': self.user,
            'start_time': timezone.now() - relativedelta(hours=1),
            'end_time':  timezone.now(),
        })

        self.assertEquals(entry.status, Entry.UNVERIFIED)
        entry.status = Entry.VERIFIED
        entry.save()

        response = self.client.get(self.approve_url(),)
        self.assertEquals(entry.status, Entry.VERIFIED)

        response = self.client.post(self.approve_url(), {'do_action': 'Yes'})
        entry = Entry.objects.get(pk=entry.pk)
        self.assertEquals(entry.status, Entry.APPROVED)

    def test_reject_user(self):
        """A regular user should not be able to reject an entry"""
        self.login_user(self.user)

        now = timezone.now()
        entry = factories.Entry(**{
            'user': self.user,
            'start_time': now - relativedelta(hours=1),
            'end_time': now,
            'status': Entry.VERIFIED
        })
        url = self.get_reject_url(entry.pk)

        response = self.client.post(url, {'Yes': 'yes'})
        self.assertEquals(entry.status, Entry.VERIFIED)

    def test_reject_other_user(self):
        """
        A regular user should not be able to reject
        another users entry
        """
        self.login_user(self.user2)

        now = timezone.now()
        entry = factories.Entry(**{
            'user': self.user,
            'start_time': now - relativedelta(hours=1),
            'end_time': now,
            'status': Entry.VERIFIED
        })
        url = self.get_reject_url(entry.pk)

        response = self.client.post(url, {'Yes': 'yes'})
        self.assertEquals(entry.status, Entry.VERIFIED)

    def testRejectPage(self):
        self.login_as_admin()
        entry = factories.Entry(**{
            'user': self.user,
            'start_time': timezone.now() - \
                relativedelta(hours=1),
            'end_time':  timezone.now(),
        })
        reject_url = self.get_reject_url(entry.id)

        def check_entry_against_code(status, status_code):
            entry.status = status
            entry.save()
            response = self.client.get(reject_url)
            self.assertEqual(response.status_code, status_code)

        check_entry_against_code(Entry.UNVERIFIED, 302)
        check_entry_against_code(Entry.INVOICED, 302)
        check_entry_against_code(Entry.APPROVED, 200)
        check_entry_against_code(Entry.VERIFIED, 200)
        response = self.client.post(reject_url, {'Yes': 'yes'})
        self.assertTrue(response.status_code, 302)
        entry = Entry.objects.get(user=self.user)
        self.assertEqual(entry.status, Entry.UNVERIFIED)

    def testNotAllowedToRejectTimesheet(self):
        entry = factories.Entry(**{
            'user': self.user,
            'start_time': timezone.now() - \
                relativedelta(hours=1),
            'end_time':  timezone.now(),
        })
        reject_url = self.get_reject_url(entry.id)
        response = self.client.get(reject_url)
        self.assertTrue(response.status_code, 403)

    def testNotAllowedToApproveTimesheet(self):
        response = self.client.get(self.approve_url(),)
        self.assertTrue(response.status_code, 403)

    def testNotAllowedToVerifyTimesheet(self):
        self.login_user(self.user2)
        response = self.client.get(self.verify_url(),)
        self.assertTrue(response.status_code, 403)


class TestTotals(ViewTestMixin, LogTimeMixin, TestCase):

    def setUp(self):
        super(TestTotals, self).setUp()

        self.user = factories.User()
        self.user2 = factories.User()
        self.superuser = factories.Superuser()
        permissions = Permission.objects.filter(
            content_type=ContentType.objects.get_for_model(Entry),
            codename__in=('can_clock_in', 'can_clock_out',
            'can_pause', 'change_entry')
        )
        self.user.user_permissions = permissions
        self.user2.user_permissions = permissions
        self.user.save()
        self.user2.save()
        self.activity = factories.Activity(code='WRK',
                name='Work')
        self.devl_activity = factories.Activity(code='devl',
                name='development', billable=True)
        self.sick_activity = factories.Activity(code="sick",
                name="sick/personal", billable=False)
        self.activity_group_all = factories.ActivityGroup(
                name='All')
        self.activity_group_work = factories.ActivityGroup(
                name='Client work')

        activities = Activity.objects.all()
        for activity in activities:
            activity.activity_group.add(self.activity_group_all)
            if activity != self.sick_activity:
                activity.activity_group.add(self.activity_group_work)
        self.business = factories.Business()
        status = factories.StatusAttribute(label='Current',
                enable_timetracking=True)
        type_ = factories.TypeAttribute(label='Web Sites',
            enable_timetracking=True)
        self.project = factories.Project(type=type_,
                status=status, business=self.business, point_person=self.user,
                activity_group=self.activity_group_work)
        self.project2 = factories.Project(type=type_,
                status=status, business=self.business, point_person=self.user2,
                activity_group=self.activity_group_all)
        factories.ProjectRelationship(user=self.user,
                project=self.project)
        self.location = factories.Location()

        self.p1 = factories.BillableProject(name='1')
        self.p2 = factories.NonbillableProject(name='2')
        self.p4 = factories.BillableProject(name='4')
        #For use with daily totals (Same project, non-billable activity)
        self.p3 = factories.NonbillableProject(name='1')

    def testGroupedTotals(self):
        self.login_user(self.user)
        days = [
            utils.add_timezone(datetime.datetime(2010, 12, 20)),
            utils.add_timezone(datetime.datetime(2010, 12, 27)),
            utils.add_timezone(datetime.datetime(2010, 12, 28)),
            utils.add_timezone(datetime.datetime(2011, 1, 3)),
            utils.add_timezone(datetime.datetime(2011, 1, 4)),
            utils.add_timezone(datetime.datetime(2011, 1, 10)),
            utils.add_timezone(datetime.datetime(2011, 1, 16)),
            utils.add_timezone(datetime.datetime(2011, 1, 17)),
            utils.add_timezone(datetime.datetime(2011, 1, 18)),
            utils.add_timezone(datetime.datetime(2011, 2, 2))
        ]
        # Each week has two days of entries, except 12-20, and 2-2 but these
        # are excluded in the timespan queryset
        for day in days:
            self.log_time(project=self.p1, start=day, delta=(1, 0))
            self.log_time(project=self.p4, start=day, delta=(1, 0))
            if random.choice([True, False]):
                self.log_time(project=self.p2, start=day, delta=(1, 0))
            else:
                self.log_time(project=self.p3, start=day, delta=(1, 0))
        date = utils.add_timezone(datetime.datetime(2011, 1, 19))
        from_date = utils.get_month_start(date)
        to_date = from_date + relativedelta(months=1)
        first_week = utils.get_week_start(from_date)
        entries = Entry.objects.timespan(first_week, to_date=to_date)
        totals = grouped_totals(entries)
        for week, week_totals, days in totals:
            #Jan. 3rd is a monday. Each week should be on a monday
            if week.month == 1:
                self.assertEqual(week.day % 7, 3)
            self.assertEqual(week_totals['billable'], 4)
            self.assertEqual(week_totals['non_billable'], 2)
            self.assertEqual(week_totals['total'], 6)
            for day, projects in days:
                for project, totals in projects[1].items():
                    self.assertEqual(projects[0]['billable'], 2)
                    self.assertEqual(projects[0]['non_billable'], 1)
                    self.assertEqual(projects[0]['total'], 3)
                    if project == self.p1:
                        self.assertEqual(totals['billable'], 1)
                        self.assertEqual(totals['total'], 1)
                    if project == self.p2:
                        self.assertEqual(totals['non_billable'], 1)
                        self.assertEqual(totals['total'], 1)
                    if project == self.p3:
                        self.assertEqual(totals['billable'], 1)
                        self.assertEqual(totals['non_billable'], 1)
                        self.assertEqual(totals['total'], 2)
                    if project == self.p4:
                        self.assertEqual(totals['billable'], 1)
                        self.assertEqual(totals['total'], 1)


class HourlySummaryTest(ViewTestMixin, TestCase):

    def setUp(self):
        super(HourlySummaryTest, self).setUp()

        self.user = factories.User()
        self.user2 = factories.User()
        self.superuser = factories.Superuser()
        permissions = Permission.objects.filter(
            content_type=ContentType.objects.get_for_model(Entry),
            codename__in=('can_clock_in', 'can_clock_out',
            'can_pause', 'change_entry')
        )
        self.user.user_permissions = permissions
        self.user2.user_permissions = permissions
        self.user.save()
        self.user2.save()
        self.activity = factories.Activity(code='WRK',
                name='Work')
        self.devl_activity = factories.Activity(code='devl',
                name='development', billable=True)
        self.sick_activity = factories.Activity(code="sick",
                name="sick/personal", billable=False)
        self.activity_group_all = factories.ActivityGroup(
                name='All')
        self.activity_group_work = factories.ActivityGroup(
                name='Client work')

        activities = Activity.objects.all()
        for activity in activities:
            activity.activity_group.add(self.activity_group_all)
            if activity != self.sick_activity:
                activity.activity_group.add(self.activity_group_work)
        self.business = factories.Business()
        status = factories.StatusAttribute(label='Current',
                enable_timetracking=True)
        type_ = factories.TypeAttribute(label='Web Sites',
            enable_timetracking=True)
        self.project = factories.Project(type=type_,
                status=status, business=self.business, point_person=self.user,
                activity_group=self.activity_group_work)
        self.project2 = factories.Project(type=type_,
                status=status, business=self.business, point_person=self.user2,
                activity_group=self.activity_group_all)
        factories.ProjectRelationship(user=self.user,
                project=self.project)
        self.location = factories.Location()

        self.now = timezone.now()
        self.month = self.now.replace(day=1)
        self.url = reverse('view_user_timesheet', args=(self.user.pk,))
        self.login_user(self.user)

    def create_month_entries(self):
        """Create four entries, one for each week of the month"""
        factories.Entry(**{
            'user': self.user,
            'start_time': self.month,
            'end_time': self.month + relativedelta(hours=1)
        })
        factories.Entry(**{
            'user': self.user,
            'start_time': self.month + relativedelta(weeks=1),
            'end_time': self.month + relativedelta(weeks=1, hours=1)
        })
        factories.Entry(**{
            'user': self.user,
            'start_time': self.month + relativedelta(weeks=2),
            'end_time': self.month + relativedelta(weeks=2, hours=1)
        })
        factories.Entry(**{
            'user': self.user,
            'start_time': self.month + relativedelta(weeks=3),
            'end_time': self.month + relativedelta(weeks=3, hours=1)
        })

    def test_start_of_week(self):
        """Test that the entries start being labeled on the first week, ISO"""
        self.create_month_entries()

        response = self.client.get(self.url)
        self.assertEquals(response.status_code, 200)

        start_date = utils.get_week_start(self.month)
        # Week of {{ week|date:'M j, Y'}}
        msg = 'Week of {0}'.format(start_date.strftime('%b %d, %Y')).replace(" 0", " ")
        self.assertContains(response, msg)

    def test_contains_only_current_entries(self):
        """
        Only entries from the current month should be displayed
        using default data from create_month_entries()
        """
        self.create_month_entries()
        old_entry = factories.Entry(**{
            'user': self.user,
            'start_time': self.month - relativedelta(days=1, hours=1),
            'end_time': self.month - relativedelta(days=1)
        })

        response = self.client.get(self.url)
        self.assertEquals(response.status_code, 200)
        self.assertFalse(old_entry in response.context['entries'])

    def test_single_entry_in_week(self):
        """
        When there is a single entry at the end of an ISO week,
        the view should show the entries from that entire week
        even though they belong in the previous month.

        This occurs in April 2012, so we are using that month
        as the basis for out test case
        """
        april = utils.add_timezone(
            datetime.datetime(month=4, day=1, year=2012)
        )
        march = utils.add_timezone(
            datetime.datetime(month=3, day=26, year=2012)
        )
        factories.Entry(**{
            'user': self.user,
            'start_time': april,
            'end_time': april + relativedelta(hours=1)
        })
        factories.Entry(**{
            'user': self.user,
            'start_time': april + relativedelta(weeks=1),
            'end_time': april + relativedelta(weeks=1, hours=1)
        })
        factories.Entry(**{
            'user': self.user,
            'start_time': march,
            'end_time': march + relativedelta(hours=1)
        })

        response = self.client.get(self.url + '?{0}'.format(
            urllib.urlencode({'year': 2012, 'month': 4})
        ))
        self.assertEquals(response.status_code, 200)
        # entries context object is a ValuesQuerySet
        extra_values = ('start_time', 'end_time', 'comments', 'seconds_paused',
                'id', 'location__name', 'project__name', 'activity__name',
                'status')
        entries = Entry.objects \
            .timespan(april, span='month') \
            .date_trunc('month', extra_values)
        self.assertEquals(list(entries), list(response.context['entries']))


class MonthlyRejectTestCase(ViewTestMixin, TestCase):

    def setUp(self):
        super(MonthlyRejectTestCase, self).setUp()

        self.user = factories.User()
        self.user2 = factories.User()
        self.superuser = factories.Superuser()
        permissions = Permission.objects.filter(
            content_type=ContentType.objects.get_for_model(Entry),
            codename__in=('can_clock_in', 'can_clock_out',
            'can_pause', 'change_entry')
        )
        self.user.user_permissions = permissions
        self.user2.user_permissions = permissions
        self.user.save()
        self.user2.save()
        self.activity = factories.Activity(code='WRK',
                name='Work')
        self.devl_activity = factories.Activity(code='devl',
                name='development', billable=True)
        self.sick_activity = factories.Activity(code="sick",
                name="sick/personal", billable=False)
        self.activity_group_all = factories.ActivityGroup(
                name='All')
        self.activity_group_work = factories.ActivityGroup(
                name='Client work')

        activities = Activity.objects.all()
        for activity in activities:
            activity.activity_group.add(self.activity_group_all)
            if activity != self.sick_activity:
                activity.activity_group.add(self.activity_group_work)
        self.business = factories.Business()
        status = factories.StatusAttribute(label='Current',
                enable_timetracking=True)
        type_ = factories.TypeAttribute(label='Web Sites',
            enable_timetracking=True)
        self.project = factories.Project(type=type_,
                status=status, business=self.business, point_person=self.user,
                activity_group=self.activity_group_work)
        self.project2 = factories.Project(type=type_,
                status=status, business=self.business, point_person=self.user2,
                activity_group=self.activity_group_all)
        factories.ProjectRelationship(user=self.user,
                project=self.project)
        self.location = factories.Location()

        self.now = timezone.now()
        self.data = {
            'month': self.now.month,
            'year': self.now.year,
            'yes': 'Yes'
        }
        self.url = reverse('reject_user_timesheet', args=(self.user.pk,))

    def create_entries(self, date, status):
        """Create entries using a date and with a given status"""
        factories.Entry(**{
            'user': self.user,
            'start_time': date,
            'end_time': date + relativedelta(hours=1),
            'status': status
        })
        factories.Entry(**{
            'user': self.user,
            'start_time': date + relativedelta(hours=2),
            'end_time': date + relativedelta(hours=3),
            'status': status
        })

    def test_page_permissions(self):
        """
        An admin should have the permission to reject a users entries
        and unverify them
        """
        self.login_user(self.superuser)
        self.create_entries(self.now, Entry.VERIFIED)

        response = self.client.get(self.url, data=self.data)
        self.assertEqual(response.status_code, 200)

        response = self.client.post(self.url, data=self.data)

        entries = Entry.no_join.filter(status=Entry.VERIFIED)
        self.assertEquals(entries.count(), 0)

    def test_page_no_permissions(self):
        """
        A regular user should not have the permissions to
        get or post to the page
        """
        self.login_user(self.user)
        self.create_entries(timezone.now(), Entry.VERIFIED)

        response = self.client.get(self.url, data=self.data)
        self.assertEqual(response.status_code, 302)

        response = self.client.post(self.url, data=self.data)

        entries = Entry.no_join.filter(status=Entry.VERIFIED)
        self.assertEquals(entries.count(), 2)

    def test_reject_entries_no_date(self):
        """
        If you are missing the month/year used to filter the entries
        then the reject page should not show
        """
        self.login_user(self.superuser)
        self.create_entries(timezone.now(), Entry.VERIFIED)

        data = {
            'month': self.now.month
        }
        response = self.client.get(self.url, data=data)
        self.assertEqual(response.status_code, 302)

        data = {
            'year': self.now.year
        }
        response = self.client.get(self.url, data=data)
        self.assertEqual(response.status_code, 302)

    def test_reject_entries_no_confirm(self):
        """
        If a post request contains the month/year but is missing the key
        'yes', then the entries are not rejected
        """
        self.login_user(self.superuser)
        self.create_entries(timezone.now(), Entry.VERIFIED)

        data = self.data
        data.pop('yes')

        response = self.client.post(self.url, data=data)

        entries = Entry.no_join.filter(status=Entry.VERIFIED)
        self.assertEquals(entries.count(), 2)

    def test_reject_approved_invoiced_entries(self):
        """Entries that are approved invoiced should not be rejected"""
        self.login_user(self.superuser)
        self.create_entries(timezone.now(), Entry.APPROVED)
        self.create_entries(timezone.now(), Entry.INVOICED)

        response = self.client.post(self.url, data=self.data)

        entries = Entry.no_join.filter(status=Entry.UNVERIFIED)
        self.assertEquals(entries.count(), 0)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url

from timepiece.entries import views


urlpatterns = patterns('',
    url(r'^dashboard/(?:(?P<active_tab>progress|all-entries|online-users)/)?$',
        views.Dashboard.as_view(),
        name='dashboard'),

    # Active entry
    url(r'^entry/clock_in/$',
        views.clock_in,
        name='clock_in'),
    url(r'^entry/clock_out/$',
        views.clock_out,
        name='clock_out'),
    url(r'^entry/toggle_pause/$',
        views.toggle_pause,
        name='toggle_pause'),

    # Entries
    url(r'^entry/add/$',
        views.create_edit_entry,
        name='create_entry'),
    url(r'^entry/(?P<entry_id>\d+)/edit/$',
        views.create_edit_entry,
        name='edit_entry'),
    url(r'^entry/(?P<entry_id>\d+)/reject/$',
        views.reject_entry,
        name='reject_entry'),
    url(r'^entry/(?P<entry_id>\d+)/delete/$',
        views.delete_entry,
        name='delete_entry'),

    # Schedule
    url(r'^schedule/$',
        views.ScheduleView.as_view(),
        name='view_schedule'),
    url(r'^schedule/edit/$',
        views.EditScheduleView.as_view(),
        name='edit_schedule'),
    url(r'^schedule/ajax/$',
        views.ScheduleAjaxView.as_view(),
        name='ajax_schedule'),
    url(r'^schedule/ajax/(?P<assignment_id>\d+)/$',
        views.ScheduleDetailView.as_view(),
        name='ajax_schedule_detail'),
)

########NEW FILE########
__FILENAME__ = views
from copy import deepcopy
import datetime
from dateutil.relativedelta import relativedelta
from decimal import Decimal
from itertools import groupby
import json
import urllib

from django.contrib import messages
from django.contrib.auth.decorators import login_required, permission_required
from django.contrib.auth.models import User, Permission
from django.contrib.contenttypes.models import ContentType
from django.core import exceptions
from django.core.urlresolvers import reverse
from django.db import transaction
from django.db.models import Q
from django.http import HttpResponse, HttpResponseRedirect, Http404
from django.shortcuts import redirect, render
from django.utils.decorators import method_decorator
from django.views.generic import TemplateView, View

from timepiece import utils
from timepiece.forms import DATE_FORM_FORMAT
from timepiece.utils.csv import DecimalEncoder
from timepiece.utils.views import cbv_decorator

from timepiece.crm.models import Project, UserProfile
from timepiece.entries.forms import ClockInForm, ClockOutForm, \
        AddUpdateEntryForm, ProjectHoursForm, ProjectHoursSearchForm
from timepiece.entries.models import Entry, ProjectHours


class Dashboard(TemplateView):
    template_name = 'timepiece/dashboard.html'

    @method_decorator(login_required)
    def dispatch(self, request, active_tab, *args, **kwargs):
        self.active_tab = active_tab or 'progress'
        self.user = request.user
        return super(Dashboard, self).dispatch(request, *args, **kwargs)

    def get_dates(self):
        today = datetime.date.today()
        day = today
        if 'week_start' in self.request.GET:
            param = self.request.GET.get('week_start')
            try:
                day = datetime.datetime.strptime(param, '%Y-%m-%d').date()
            except:
                pass
        week_start = utils.get_week_start(day)
        week_end = week_start + relativedelta(days=6)
        return today, week_start, week_end

    def get_hours_per_week(self, user=None):
        """Retrieves the number of hours the user should work per week."""
        try:
            profile = UserProfile.objects.get(user=user or self.user)
        except UserProfile.DoesNotExist:
            profile = None
        return profile.hours_per_week if profile else Decimal('40.00')

    def get_context_data(self, *args, **kwargs):
        today, week_start, week_end = self.get_dates()

        # Query for the user's active entry if it exists.
        active_entry = utils.get_active_entry(self.user)

        # Process this week's entries to determine assignment progress.
        week_entries = Entry.objects.filter(user=self.user) \
                .timespan(week_start, span='week', current=True) \
                .select_related('project')
        assignments = ProjectHours.objects.filter(user=self.user,
                week_start=week_start.date())
        project_progress = self.process_progress(week_entries, assignments)

        # Total hours that the user is expected to clock this week.
        total_assigned = self.get_hours_per_week(self.user)
        total_worked = sum([p['worked'] for p in project_progress])

        # Others' active entries.
        others_active_entries = Entry.objects.filter(end_time__isnull=True) \
                .exclude(user=self.user).select_related('user', 'project',
                'activity')

        return {
            'active_tab': self.active_tab,
            'today': today,
            'week_start': week_start.date(),
            'week_end': week_end.date(),
            'active_entry': active_entry,
            'total_assigned': total_assigned,
            'total_worked': total_worked,
            'project_progress': project_progress,
            'week_entries': week_entries,
            'others_active_entries': others_active_entries,
        }

    def process_progress(self, entries, assignments):
        """
        Returns a list of progress summary data (pk, name, hours worked, and
        hours assigned) for each project either worked or assigned.
        The list is ordered by project name.
        """
        # Determine all projects either worked or assigned.
        project_q = Q(id__in=assignments.values_list('project__id', flat=True))
        project_q |= Q(id__in=entries.values_list('project__id', flat=True))
        projects = Project.objects.filter(project_q).select_related('business')

        # Hours per project.
        project_data = {}
        for project in projects:
            try:
                assigned = assignments.get(project__id=project.pk).hours
            except ProjectHours.DoesNotExist:
                assigned = Decimal('0.00')
            project_data[project.pk] = {
                'project': project,
                'assigned': assigned,
                'worked': Decimal('0.00'),
            }

        for entry in entries:
            pk = entry.project_id
            hours = Decimal('%.2f' % (entry.get_total_seconds() / 3600.0))
            project_data[pk]['worked'] += hours

        # Sort by maximum of worked or assigned hours (highest first).
        key = lambda x: x['project'].name.lower()
        project_progress = sorted(project_data.values(), key=key)

        return project_progress


@permission_required('entries.can_clock_in')
@transaction.commit_on_success
def clock_in(request):
    """For clocking the user into a project."""
    user = request.user
    # Lock the active entry for the duration of this transaction, to prevent
    # creating multiple active entries.
    active_entry = utils.get_active_entry(user, select_for_update=True)

    initial = dict([(k, v) for k, v in request.GET.items()])
    data = request.POST or None
    form = ClockInForm(data, initial=initial, user=user, active=active_entry)
    if form.is_valid():
        entry = form.save()
        message = 'You have clocked into {0} on {1}.'.format(
                entry.activity.name, entry.project)
        messages.info(request, message)
        return HttpResponseRedirect(reverse('dashboard'))

    return render(request, 'timepiece/entry/clock_in.html', {
        'form': form,
        'active': active_entry,
    })


@permission_required('entries.can_clock_out')
def clock_out(request):
    entry = utils.get_active_entry(request.user)
    if not entry:
        message = "Not clocked in"
        messages.info(request, message)
        return HttpResponseRedirect(reverse('dashboard'))
    if request.POST:
        form = ClockOutForm(request.POST, instance=entry)
        if form.is_valid():
            entry = form.save()
            message = 'You have clocked out of {0} on {1}.'.format(
                    entry.activity.name, entry.project)
            messages.info(request, message)
            return HttpResponseRedirect(reverse('dashboard'))
        else:
            message = 'Please correct the errors below.'
            messages.error(request, message)
    else:
        form = ClockOutForm(instance=entry)
    return render(request, 'timepiece/entry/clock_out.html', {
        'form': form,
        'entry': entry,
    })


@permission_required('entries.can_pause')
def toggle_pause(request):
    """Allow the user to pause and unpause the active entry."""
    entry = utils.get_active_entry(request.user)
    if not entry:
        raise Http404

    # toggle the paused state
    entry.toggle_paused()
    entry.save()

    # create a message that can be displayed to the user
    action = 'paused' if entry.is_paused else 'resumed'
    message = 'Your entry, {0} on {1}, has been {2}.'.format(
            entry.activity.name, entry.project, action)
    messages.info(request, message)

    # redirect to the log entry list
    return HttpResponseRedirect(reverse('dashboard'))


@permission_required('entries.change_entry')
def create_edit_entry(request, entry_id=None):
    if entry_id:
        try:
            entry = Entry.no_join.get(pk=entry_id)
        except Entry.DoesNotExist:
            entry = None
        if not entry or not (entry.is_editable or
                request.user.has_perm('entries.view_payroll_summary')):
            raise Http404
    else:
        entry = None

    entry_user = entry.user if entry else request.user
    if request.method == 'POST':
        form = AddUpdateEntryForm(data=request.POST, instance=entry,
                user=entry_user)
        if form.is_valid():
            entry = form.save()
            if entry_id:
                message = 'The entry has been updated successfully.'
            else:
                message = 'The entry has been created successfully.'
            messages.info(request, message)
            url = request.REQUEST.get('next', reverse('dashboard'))
            return HttpResponseRedirect(url)
        else:
            message = 'Please fix the errors below.'
            messages.error(request, message)
    else:
        initial = dict([(k, request.GET[k]) for k in request.GET.keys()])
        form = AddUpdateEntryForm(instance=entry, user=entry_user,
                initial=initial)

    return render(request, 'timepiece/entry/create_edit.html', {
        'form': form,
        'entry': entry,
    })


@permission_required('entries.view_payroll_summary')
def reject_entry(request, entry_id):
    """
    Admins can reject an entry that has been verified or approved but not
    invoiced to set its status to 'unverified' for the user to fix.
    """
    return_url = request.REQUEST.get('next', reverse('dashboard'))
    try:
        entry = Entry.no_join.get(pk=entry_id)
    except:
        message = 'No such log entry.'
        messages.error(request, message)
        return redirect(return_url)

    if entry.status == Entry.UNVERIFIED or entry.status == Entry.INVOICED:
        msg_text = 'This entry is unverified or is already invoiced.'
        messages.error(request, msg_text)
        return redirect(return_url)

    if request.POST.get('Yes'):
        entry.status = Entry.UNVERIFIED
        entry.save()
        msg_text = 'The entry\'s status was set to unverified.'
        messages.info(request, msg_text)
        return redirect(return_url)
    return render(request, 'timepiece/entry/reject.html', {
        'entry': entry,
        'next': request.REQUEST.get('next'),
    })


@permission_required('entries.delete_entry')
def delete_entry(request, entry_id):
    """
    Give the user the ability to delete a log entry, with a confirmation
    beforehand.  If this method is invoked via a GET request, a form asking
    for a confirmation of intent will be presented to the user. If this method
    is invoked via a POST request, the entry will be deleted.
    """
    try:
        entry = Entry.no_join.get(pk=entry_id, user=request.user)
    except Entry.DoesNotExist:
        message = 'No such entry found.'
        messages.info(request, message)
        url = request.REQUEST.get('next', reverse('dashboard'))
        return HttpResponseRedirect(url)

    if request.method == 'POST':
        key = request.POST.get('key', None)
        if key and key == entry.delete_key:
            entry.delete()
            message = 'Deleted {0} for {1}.'.format(entry.activity.name,
                    entry.project)
            messages.info(request, message)
            url = request.REQUEST.get('next', reverse('dashboard'))
            return HttpResponseRedirect(url)
        else:
            message = 'You are not authorized to delete this entry!'
            messages.error(request, message)

    return render(request, 'timepiece/entry/delete.html', {
        'entry': entry,
    })


class ScheduleMixin(object):

    def dispatch(self, request, *args, **kwargs):
        # Since we use get param in multiple places, attach it to the class
        default_week = utils.get_week_start(datetime.date.today()).date()

        if request.method == 'GET':
            week_start_str = request.GET.get('week_start', '')
        else:
            week_start_str = request.POST.get('week_start', '')

        # Account for an empty string
        self.week_start = default_week if week_start_str == '' \
            else utils.get_week_start(datetime.datetime.strptime(
                week_start_str, '%Y-%m-%d').date())

        return super(ScheduleMixin, self).dispatch(request, *args,
                **kwargs)

    def get_hours_for_week(self, week_start=None):
        """
        Gets all ProjectHours entries in the 7-day period beginning on
        week_start.
        """
        week_start = week_start if week_start else self.week_start
        week_end = week_start + relativedelta(days=7)

        return ProjectHours.objects.filter(
            week_start__gte=week_start, week_start__lt=week_end)


class ScheduleView(ScheduleMixin, TemplateView):
    template_name = 'timepiece/schedule/view.html'

    def dispatch(self, request, *args, **kwargs):
        if not request.user.has_perm('entries.can_clock_in'):
            return HttpResponseRedirect(reverse('auth_login'))

        return super(ScheduleView, self).dispatch(request, *args, **kwargs)

    def get_users_from_project_hours(self, project_hours):
        """
        Gets a list of the distinct users included in the project hours
        entries, ordered by name.
        """
        name = ('user__first_name', 'user__last_name')
        users = project_hours.values_list('user__id', *name).distinct()\
                             .order_by(*name)
        return users

    def get_context_data(self, **kwargs):
        context = super(ScheduleView, self).get_context_data(**kwargs)

        initial = {'week_start': self.week_start}
        form = ProjectHoursSearchForm(initial=initial)

        project_hours = self.get_hours_for_week()
        project_hours = project_hours.values('project__id', 'project__name',
                'user__id', 'user__first_name', 'user__last_name', 'hours',
                'published')
        project_hours = project_hours.order_by('-project__type__billable',
                'project__name')
        if not self.request.user.has_perm('entries.add_projecthours'):
            project_hours = project_hours.filter(published=True)
        users = self.get_users_from_project_hours(project_hours)
        id_list = [user[0] for user in users]
        projects = []

        func = lambda o: o['project__id']
        for project, entries in groupby(project_hours, func):
            entries = list(entries)
            proj_id = entries[0]['project__id']
            name = entries[0]['project__name']
            row = [{} for i in range(len(id_list))]
            for entry in entries:
                index = id_list.index(entry['user__id'])
                hours = entry['hours']
                row[index]['hours'] = row[index].get('hours', 0) + hours
                row[index]['published'] = entry['published']
            projects.append((proj_id, name, row))

        context.update({
            'form': form,
            'week': self.week_start,
            'prev_week': self.week_start - relativedelta(days=7),
            'next_week': self.week_start + relativedelta(days=7),
            'users': users,
            'project_hours': project_hours,
            'projects': projects
        })
        return context


class EditScheduleView(ScheduleMixin, TemplateView):
    template_name = 'timepiece/schedule/edit.html'

    def dispatch(self, request, *args, **kwargs):
        if not request.user.has_perm('entries.add_projecthours'):
            return HttpResponseRedirect(reverse('view_schedule'))

        return super(EditScheduleView, self).dispatch(request, *args,
                **kwargs)

    def get_context_data(self, **kwargs):
        context = super(EditScheduleView, self).get_context_data(**kwargs)

        form = ProjectHoursSearchForm(initial={
            'week_start': self.week_start
        })

        context.update({
            'form': form,
            'week': self.week_start,
            'ajax_url': reverse('ajax_schedule')
        })
        return context

    def post(self, request, *args, **kwargs):
        ph = self.get_hours_for_week(self.week_start).filter(published=False)

        if ph.exists():
            ph.update(published=True)
            msg = 'Unpublished project hours are now published'
        else:
            msg = 'There were no hours to publish'

        messages.info(request, msg)

        param = {
            'week_start': self.week_start.strftime(DATE_FORM_FORMAT)
        }
        url = '?'.join((reverse('edit_schedule'), urllib.urlencode(param),))

        return HttpResponseRedirect(url)


@cbv_decorator(permission_required('entries.add_projecthours'))
class ScheduleAjaxView(ScheduleMixin, View):

    def dispatch(self, request, *args, **kwargs):
        if not request.user.has_perm('entries.add_projecthours'):
            return HttpResponseRedirect(reverse('auth_login'))

        return super(ScheduleAjaxView, self).dispatch(request, *args,
                **kwargs)

    def get_instance(self, data, week_start):
        try:
            user = User.objects.get(pk=data.get('user', None))
            project = Project.objects.get(pk=data.get('project', None))
            hours = data.get('hours', None)
            week = datetime.datetime.strptime(week_start,
                    DATE_FORM_FORMAT).date()

            ph = ProjectHours.objects.get(user=user, project=project,
                    week_start=week)
            ph.hours = Decimal(hours)
        except (exceptions.ObjectDoesNotExist):
            ph = None

        return ph

    def get(self, request, *args, **kwargs):
        """
        Returns the data as a JSON object made up of the following key/value
        pairs:
            project_hours: the current project hours for the week
            projects: the projects that have hours for the week
            all_projects: all of the projects; used for autocomplete
            all_users: all users that can clock in; used for completion
        """
        perm = Permission.objects.filter(
            content_type=ContentType.objects.get_for_model(Entry),
            codename='can_clock_in'
        )
        project_hours = self.get_hours_for_week().values(
            'id', 'user', 'user__first_name', 'user__last_name',
            'project', 'hours', 'published'
        ).order_by('-project__type__billable', 'project__name',
            'user__first_name', 'user__last_name')
        inner_qs = project_hours.values_list('project', flat=True)
        projects = Project.objects.filter(pk__in=inner_qs).values() \
            .order_by('name')
        all_projects = Project.objects.values('id', 'name')
        user_q = Q(groups__permissions=perm) | Q(user_permissions=perm)
        user_q |= Q(is_superuser=True)
        all_users = User.objects.filter(user_q) \
            .values('id', 'first_name', 'last_name')

        data = {
            'project_hours': list(project_hours),
            'projects': list(projects),
            'all_projects': list(all_projects),
            'all_users': list(all_users),
            'ajax_url': reverse('ajax_schedule'),
        }
        return HttpResponse(json.dumps(data, cls=DecimalEncoder),
            mimetype='application/json')

    def duplicate_entries(self, duplicate, week_update):
        def duplicate_builder(queryset, new_date):
            for instance in queryset:
                duplicate = deepcopy(instance)
                duplicate.id = None
                duplicate.published = False
                duplicate.week_start = new_date
                yield duplicate

        def duplicate_helper(queryset, new_date):
            try:
                ProjectHours.objects.bulk_create(
                    duplicate_builder(queryset, new_date)
                )
            except AttributeError:
                for entry in duplicate_builder(queryset, new_date):
                    entry.save()
            msg = 'Project hours were copied'
            messages.info(self.request, msg)

        this_week = datetime.datetime.strptime(week_update,
                DATE_FORM_FORMAT).date()
        prev_week = this_week - relativedelta(days=7)
        prev_week_qs = self.get_hours_for_week(prev_week)
        this_week_qs = self.get_hours_for_week(this_week)

        param = {
            'week_start': week_update
        }
        url = '?'.join((reverse('edit_schedule'),
            urllib.urlencode(param),))

        if not prev_week_qs.exists():
            msg = 'There are no hours to copy'
            messages.warning(self.request, msg)
        else:
            this_week_qs.delete()
            duplicate_helper(prev_week_qs, this_week)
        return HttpResponseRedirect(url)

    def update_week(self, week_start):
        try:
            instance = self.get_instance(self.request.POST, week_start)
        except TypeError:
            msg = 'Parameter week_start must be a date in the format ' \
                'yyyy-mm-dd'
            return HttpResponse(msg, status=500)

        form = ProjectHoursForm(self.request.POST, instance=instance)

        if form.is_valid():
            ph = form.save()
            return HttpResponse(str(ph.pk), mimetype='text/plain')

        msg = 'The request must contain values for user, project, and hours'
        return HttpResponse(msg, status=500)

    def post(self, request, *args, **kwargs):
        """
        Create or update an hour entry for a particular use and project. This
        function expects the following values:
            user: the user pk for the hours
            project: the project pk for the hours
            hours: the actual hours to store
            week_start: the start of the week for the hours

        If the duplicate key is present along with week_update, then items
        will be duplicated from week_update to the current week
        """
        duplicate = request.POST.get('duplicate', None)
        week_update = request.POST.get('week_update', None)
        week_start = request.POST.get('week_start', None)

        if duplicate and week_update:
            return self.duplicate_entries(duplicate, week_update)

        return self.update_week(week_start)


@cbv_decorator(permission_required('entries.add_projecthours'))
class ScheduleDetailView(ScheduleMixin, View):

    def delete(self, request, *args, **kwargs):
        """Remove a project from the database."""
        assignment_id = kwargs.get('assignment_id', None)

        if assignment_id:
            ProjectHours.objects.filter(pk=assignment_id).delete()
            return HttpResponse('ok', mimetype='text/plain')

        return HttpResponse('', status=500)

########NEW FILE########
__FILENAME__ = fields
from django import forms


class UserModelChoiceField(forms.ModelChoiceField):

    def label_from_instance(self, obj):
        return obj.get_name_or_username()


class UserModelMultipleChoiceField(forms.ModelMultipleChoiceField):

    def label_from_instance(self, obj):
        return obj.get_name_or_username()

########NEW FILE########
__FILENAME__ = forms
import datetime
from dateutil.relativedelta import relativedelta
import time

from django import forms
from django.contrib.auth.models import User

from timepiece.fields import UserModelChoiceField

from timepiece.entries.models import Entry


DATE_FORM_FORMAT = '%Y-%m-%d'
INPUT_FORMATS = [DATE_FORM_FORMAT]


class TimepieceSplitDateTimeWidget(forms.SplitDateTimeWidget):

    def __init__(self, *args, **kwargs):
        kwargs['date_format'] = kwargs.get('date_format', DATE_FORM_FORMAT)
        super(TimepieceSplitDateTimeWidget, self).__init__(*args, **kwargs)


class TimepieceDateInput(forms.DateInput):

    def __init__(self, *args, **kwargs):
        kwargs['format'] = kwargs.get('format', DATE_FORM_FORMAT)
        super(TimepieceDateInput, self).__init__(*args, **kwargs)


class DateForm(forms.Form):
    from_date = forms.DateField(label='From', required=False,
        input_formats=INPUT_FORMATS, widget=TimepieceDateInput())
    to_date = forms.DateField(label='To', required=False,
        input_formats=INPUT_FORMATS, widget=TimepieceDateInput())

    def clean(self):
        from_date = self.cleaned_data.get('from_date', None)
        to_date = self.cleaned_data.get('to_date', None)
        if from_date and to_date and from_date > to_date:
            raise forms.ValidationError('The ending date must exceed the '
                    'beginning date.')
        return self.cleaned_data

    def save(self):
        from_date = self.cleaned_data.get('from_date', '')
        to_date = self.cleaned_data.get('to_date', '')
        to_date = to_date + relativedelta(days=1) if to_date else to_date
        return (from_date, to_date)


class YearMonthForm(forms.Form):
    MONTH_CHOICES = [(i, time.strftime('%b', time.strptime(str(i), '%m')))
                     for i in xrange(1, 13)]
    month = forms.ChoiceField(choices=MONTH_CHOICES, label='')
    year = forms.ChoiceField(label='')

    def __init__(self, *args, **kwargs):
        super(YearMonthForm, self).__init__(*args, **kwargs)
        now = datetime.datetime.now()
        this_year = now.year
        this_month = now.month
        try:
            first_entry = Entry.no_join.values('end_time')\
                                       .order_by('end_time')[0]
        except IndexError:
            first_year = this_year
        else:
            first_year = first_entry['end_time'].year
        years = [(year, year) for year in xrange(first_year, this_year + 1)]
        self.fields['year'].choices = years
        initial = kwargs.get('initial')
        if initial:
            this_year = initial.get('year', this_year)
            this_month = initial.get('month', this_month)
        self.fields['year'].initial = this_year
        self.fields['month'].initial = this_month

    def save(self):
        now = datetime.datetime.now()
        this_year = now.year
        this_month = now.month
        month = int(self.cleaned_data.get('month', this_month))
        year = int(self.cleaned_data.get('year', this_year))
        from_date = datetime.datetime(year, month, 1)
        to_date = from_date + relativedelta(months=1)

        return (from_date, to_date)


class UserYearMonthForm(YearMonthForm):
    user = UserModelChoiceField(label='', queryset=None, required=False)

    def __init__(self, *args, **kwargs):
        super(UserYearMonthForm, self).__init__(*args, **kwargs)
        queryset = User.objects.exclude(timepiece_entries=None)\
                               .order_by('first_name')
        self.fields['user'].queryset = queryset

    def save(self):
        from_date, to_date = super(UserYearMonthForm, self).save()
        return (from_date, to_date, self.cleaned_data.get('user', None))

########NEW FILE########
__FILENAME__ = check_entries
from optparse import OptionParser, make_option

from dateutil.relativedelta import relativedelta

from django.contrib.auth.models import User
from django.core.management.base import BaseCommand, CommandError
from django.db.models import Q
from django.utils import timezone

from timepiece import utils
from timepiece.entries.models import Entry


class Command(BaseCommand):
    """
    Management command to check entries for overlapping times.
    Use ./manage.py check_entries --help for more details
    """
    #boiler plate for console programs using optparse
    args = '<user\'s first or last name or user.id> <user\'s first...>...'
    help = """Check the database for entries that overlap.
    Use --help for options"""
    parser = OptionParser()
    parser.usage += """
./manage.py check_entries [<first or last name1> <name2>...<name n>] [OPTIONS]

For options type:
./manage.py check_entries --help
    """

    def make_options(self, *args, **kwargs):
        """
        Define the arguments that can be used with this command
        """
        return (
        #Jenkins arguments to ignore
        make_option('--pep8-exclude',
            dest='ignore_pep8',
            type='str',
            default='',
            help='Jenkins only'),
        ) + (
        make_option('--coverage-exclude',
            dest='ignore_coverage',
            type='str',
            default='',
            help='Jenkins only'),
        ) + (
        make_option('--thisweek',
            action='store_true',
            dest='week',
            default=False,
            help='Show entries from this week only'),
        ) + (
        make_option('--thismonth',
            action='store_true',
            dest='month',
            default=False,
            help='Show entries from this month only'),
        ) + (
        make_option('-y', '--thisyear',
            action='store_true',
            dest='year',
            default=False,
            help='Show entries from this year only'),
        ) + (
        make_option('-a', '--all', '--forever',
            action='store_true',
            dest='all',
            default=False,
            help='Show entries from all recorded history'),
        ) + (
        make_option('-d', '--days',
            dest='days',
            type='int',
            default=0,
            help='Show entries for the last n days only'),
        )

    option_list = BaseCommand.option_list + make_options(*args)
    parser.add_options(option_list)
    (options, args) = parser.parse_args()

    def handle(self, *args, **kwargs):
        """
        main()
        """
        verbosity = kwargs.get('verbosity', 1)
        start = self.find_start(**kwargs)
        users = self.find_users(*args)
        self.show_init(start, *args, **kwargs)
        all_entries = self.find_entries(users, start, *args, **kwargs)
        all_overlaps = self.check_all(all_entries, *args, **kwargs)
        if verbosity >= 1:
            print 'Total overlapping entries: %d' % all_overlaps

    def check_all(self, all_entries, *args, **kwargs):
        """
        Go through lists of entries, find overlaps among each, return the total
        """
        all_overlaps = 0
        while True:
            try:
                user_entries = all_entries.next()
            except StopIteration:
                return all_overlaps
            else:
                user_total_overlaps = self.check_entry(
                    user_entries, *args, **kwargs)
                all_overlaps += user_total_overlaps

    def check_entry(self, entries, *args, **kwargs):
        """
        With a list of entries, check each entry against every other
        """
        verbosity = kwargs.get('verbosity', 1)
        user_total_overlaps = 0
        user = ''
        for index_a, entry_a in enumerate(entries):
            #Show the name the first time through
            if index_a == 0:
                if args and verbosity >= 1 or verbosity >= 2:
                    self.show_name(entry_a.user)
                    user = entry_a.user
            for index_b in range(index_a, len(entries)):
                entry_b = entries[index_b]
                if entry_a.check_overlap(entry_b):
                    user_total_overlaps += 1
                    self.show_overlap(entry_a, entry_b, verbosity=verbosity)
        if user_total_overlaps and user and verbosity >= 1:
            overlap_data = {
                'first': user.first_name,
                'last': user.last_name,
                'total': user_total_overlaps,
            }
            print 'Total overlapping entries for user ' + \
                '%(first)s %(last)s: %(total)d' % overlap_data
        return user_total_overlaps

    def find_start(self, **kwargs):
        """
        Determine the starting point of the query using CLI keyword arguments
        """
        week = kwargs.get('week', False)
        month = kwargs.get('month', False)
        year = kwargs.get('year', False)
        days = kwargs.get('days', 0)
        #If no flags are True, set to the beginning of last billing window
        #to assure we catch all recent violations
        start = timezone.now() - relativedelta(months=1, day=1)
        #Set the start date based on arguments provided through options
        if week:
            start = utils.get_week_start()
        if month:
            start = timezone.now() - relativedelta(day=1)
        if year:
            start = timezone.now() - relativedelta(day=1, month=1)
        if days:
            start = timezone.now() - relativedelta(days=days)
        start -= relativedelta(hour=0, minute=0, second=0, microsecond=0)
        return start

    def find_users(self, *args):
        """
        Returns the users to search given names as args.
        Return all users if there are no args provided.
        """
        if args:
            names = reduce(lambda query, arg: query |
                (Q(first_name__icontains=arg) | Q(last_name__icontains=arg)),
                args, Q())
            users = User.objects.filter(names)
        #If no args given, check every user
        else:
            users = User.objects.all()
        #Display errors if no user was found
        if not users.count() and args:
            if len(args) == 1:
                raise CommandError('No user was found with the name %s' \
                % args[0])
            else:
                arg_list = ', '.join(args)
                raise CommandError('No users found with the names: %s' \
                % arg_list)
        return users

    def find_entries(self, users, start, *args, **kwargs):
        """
        Find all entries for all users, from a given starting point.
        If no starting point is provided, all entries are returned.
        """
        forever = kwargs.get('all', False)
        for user in users:
            if forever:
                entries = Entry.objects.filter(user=user).order_by('start_time')
            else:
                entries = Entry.objects.filter(
                    user=user, start_time__gte=start).order_by(
                    'start_time')
            yield entries

    #output methods
    def show_init(self, start, *args, **kwargs):
        forever = kwargs.get('all', False)
        verbosity = kwargs.get('verbosity', 1)
        if forever:
            if verbosity >= 1:
                print 'Checking overlaps from the beginning ' + \
                    'of time'
        else:
            if verbosity >= 1:
                print 'Checking overlap starting on: ' + \
                    start.strftime('%m/%d/%Y')

    def show_name(self, user):
        print 'Checking %s %s...' % \
        (user.first_name, user.last_name)

    def show_overlap(self, entry_a, entry_b=None, **kwargs):
        def make_output_data(entry):
            return{
                'first_name': entry.user.first_name,
                'last_name': entry.user.last_name,
                'entry': entry.id,
                'start': entry.start_time,
                'end': entry.end_time,
                'project': entry.project
            }
        data_a = make_output_data(entry_a)
        if entry_b:
            data_b = make_output_data(entry_b)
            output = 'Entry %(entry)d for %(first_name)s %(last_name)s from ' \
            % data_a + '%(start)s to %(end)s on %(project)s overlaps ' \
            % data_a + 'entry %(entry)d from %(start)s to %(end)s on ' \
            % data_b + '%(project)s.' % data_b
        else:
            output = 'Entry %(entry)d for %(first_name)s %(last_name)s from ' \
            % data_a + '%(start)s to %(end)s on %(project)s overlaps ' \
            % data_a + 'with another entry.'
        if kwargs.get('verbosity', 1):
            print output

########NEW FILE########
__FILENAME__ = 0001_initial
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        pass

    def backwards(self, orm):
        pass

    models = {
        
    }

    complete_apps = ['timepiece']
########NEW FILE########
__FILENAME__ = models

########NEW FILE########
__FILENAME__ = forms
from django import forms
from django.contrib.auth.models import User

from selectable import forms as selectable

from timepiece.fields import UserModelMultipleChoiceField
from timepiece.forms import DateForm, YearMonthForm

from timepiece.crm.lookups import ProjectLookup
from timepiece.crm.models import Attribute
from timepiece.entries.models import Entry, Activity


class BillableHoursReportForm(DateForm):
    TRUNC_CHOICES = (
        ('day', 'Day'),
        ('week', 'Week'),
        ('month', 'Month'),
    )

    trunc = forms.ChoiceField(label='Group Totals By', choices=TRUNC_CHOICES,
            widget=forms.RadioSelect())
    users = UserModelMultipleChoiceField(required=False, queryset=None,
            widget=forms.CheckboxSelectMultiple())
    activities = forms.ModelMultipleChoiceField(required=False, queryset=None,
            widget=forms.CheckboxSelectMultiple())
    project_types = forms.ModelMultipleChoiceField(required=False,
            queryset=None, widget=forms.CheckboxSelectMultiple())

    def __init__(self, *args, **kwargs):
        """
        If the 'select_all' argument is given, any data values for users,
        activities, and project_types are overwritten with all available
        choices.
        """
        select_all = kwargs.pop('select_all', False)

        super(BillableHoursReportForm, self).__init__(*args, **kwargs)
        self.fields['from_date'].required = True
        self.fields['to_date'].required = True

        user_ids = Entry.no_join.values_list('user', flat=True)
        users = User.objects.filter(id__in=user_ids)
        activities = Activity.objects.all()
        project_types = Attribute.objects.all()

        self.fields['users'].queryset = users
        self.fields['activities'].queryset = activities
        self.fields['project_types'].queryset = project_types

        if select_all:
            self.data['users'] = list(users.values_list('id', flat=True))
            self.data['activities'] = list(activities.values_list('id',
                    flat=True))
            self.data['project_types'] = list(project_types.values_list('id',
                    flat=True))


class ProductivityReportForm(forms.Form):
    ORGANIZE_BY_CHOICES = (
        ('week', 'Week'),
        ('user', 'User'),
    )
    project = selectable.AutoCompleteSelectField(ProjectLookup)
    organize_by = forms.ChoiceField(choices=ORGANIZE_BY_CHOICES,
            widget=forms.RadioSelect(), initial=ORGANIZE_BY_CHOICES[0][0])


class HourlyReportForm(DateForm):
    TRUNC_CHOICES = (
        ('day', 'Day'),
        ('week', 'Week'),
        ('month', 'Month'),
        ('year', 'Year'),
    )

    billable = forms.BooleanField(required=False)
    non_billable = forms.BooleanField(label='Non-billable', required=False)
    paid_leave = forms.BooleanField(required=False)
    trunc = forms.ChoiceField(label='Group Totals By', choices=TRUNC_CHOICES,
            widget=forms.RadioSelect())
    projects = selectable.AutoCompleteSelectMultipleField(ProjectLookup,
            label='Project Name', required=False)

    def __init__(self, *args, **kwargs):
        super(HourlyReportForm, self).__init__(*args, **kwargs)
        self.fields['from_date'].required = True
        self.fields['to_date'].required = True


class PayrollSummaryReportForm(YearMonthForm):
    pass

########NEW FILE########
__FILENAME__ = 0001_initial
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        pass

    def backwards(self, orm):
        pass

    models = {
        
    }

    complete_apps = ['reports']
########NEW FILE########
__FILENAME__ = models

########NEW FILE########
__FILENAME__ = base
import datetime

from django.conf import settings
from django.test import TestCase

from timepiece import utils
from timepiece.tests import factories

from timepiece.reports.utils import generate_dates


class ReportsTestBase(TestCase):

    def setUp(self):
        super(ReportsTestBase, self).setUp()
        self.user = factories.User()
        self.user2 = factories.User()
        self.superuser = factories.Superuser()
        self.devl_activity = factories.Activity(billable=True)
        self.activity = factories.Activity()
        self.sick = factories.Project()
        self.vacation = factories.Project()
        settings.TIMEPIECE_PAID_LEAVE_PROJECTS = {
            'sick': self.sick.pk,
            'vacation': self.vacation.pk,
        }
        self.leave = [self.sick.pk, self.vacation.pk]
        self.p1 = factories.BillableProject(name='1')
        self.p2 = factories.NonbillableProject(name='2')
        self.p4 = factories.BillableProject(name='4')
        self.p3 = factories.NonbillableProject(name='1')
        self.p5 = factories.BillableProject(name='3')
        self.default_projects = [self.p1, self.p2, self.p3, self.p4, self.p5]
        self.default_dates = [
            utils.add_timezone(datetime.datetime(2011, 1, 3)),
            utils.add_timezone(datetime.datetime(2011, 1, 4)),
            utils.add_timezone(datetime.datetime(2011, 1, 10)),
            utils.add_timezone(datetime.datetime(2011, 1, 16)),
            utils.add_timezone(datetime.datetime(2011, 1, 17)),
            utils.add_timezone(datetime.datetime(2011, 1, 18)),
        ]

    def make_entries(self, user=None, projects=None, dates=None,
                 hours=1, minutes=0):
        """Make several entries to help with reports tests"""
        if not user:
            user = self.user
        if not projects:
            projects = self.default_projects
        if not dates:
            dates = self.default_dates
        for project in projects:
            for day in dates:
                self.log_time(project=project, start=day,
                              delta=(hours, minutes), user=user)

    def bulk_entries(self, start=datetime.datetime(2011, 1, 2),
                   end=datetime.datetime(2011, 1, 4)):
        start = utils.add_timezone(start)
        end = utils.add_timezone(end)
        dates = generate_dates(start, end, 'day')
        projects = [self.p1, self.p2, self.p2, self.p4, self.p5, self.sick]
        self.make_entries(projects=projects, dates=dates,
                          user=self.user, hours=2)
        self.make_entries(projects=projects, dates=dates,
                          user=self.user2, hours=1)

    def check_generate_dates(self, start, end, trunc, dates):
        for index, day in enumerate(generate_dates(start, end, trunc)):
            if isinstance(day, datetime.datetime):
                day = day.date()
            self.assertEqual(day, dates[index].date())

########NEW FILE########
__FILENAME__ = test_billable_hours
import datetime
from dateutil.relativedelta import relativedelta
import json

from django.contrib.auth.models import Permission
from django.core.urlresolvers import reverse
from django.db.models import Q

from timepiece.forms import DATE_FORM_FORMAT
from timepiece.tests import factories
from timepiece.tests.base import ViewTestMixin, LogTimeMixin

from timepiece.entries.models import Entry
from timepiece.reports.tests.base import ReportsTestBase


class TestBillableHours(ViewTestMixin, LogTimeMixin, ReportsTestBase):

    def setUp(self):
        super(TestBillableHours, self).setUp()
        self.from_date = datetime.datetime(2011, 1, 2)
        self.to_date = datetime.datetime(2011, 1, 4)
        self.dates_data = ['12/27/2010', '01/03/2011']

        self.url = reverse('report_billable_hours')
        self.perm = Permission.objects.filter(codename='view_entry_summary')
        self.admin = factories.User()
        self.admin.user_permissions = self.perm

    def get_entries_data(self):
        # Account for the day added by the form
        query = Q(end_time__gte=self.from_date,
                end_time__lt=self.to_date + relativedelta(days=1))
        return Entry.objects.date_trunc('week').filter(query)

    def test_access_permission(self):
        """view_entry_summary permission is required to view this report."""
        self.login_user(self.admin)
        response = self.client.get(self.url)
        self.assertEqual(response.status_code, 200)

    def test_access_no_permission(self):
        """view_entry_summary permission is required to view this report."""
        self.login_user(self.user)
        response = self.client.get(self.url)
        self.assertEqual(response.status_code, 302)

    def test_response_data(self):
        """Test that the data returned is correct"""
        self.bulk_entries()
        self.login_user(self.admin)

        response = self.client.get(self.url, data={
            'from_date': self.from_date.strftime(DATE_FORM_FORMAT),
            'to_date': self.to_date.strftime(DATE_FORM_FORMAT),
            'trunc': 'week',
            'users': list(Entry.objects.values_list('user', flat=True)),
            'activities': list(Entry.objects.values_list('activity',
                    flat=True)),
            'project_types': list(Entry.objects.values_list('project__type',
                    flat=True)),
        })
        self.assertEqual(response.status_code, 200)

        entries_data = self.get_entries_data().order_by('user', 'date')
        response_data = json.loads(response.context['data'])

        self.assertEqual(response_data[1][1:], [9, 9])
        self.assertEqual(response_data[2][1:], [18, 18])

########NEW FILE########
__FILENAME__ = test_hourly
import datetime
from decimal import Decimal
from random import randint

from django.contrib.auth.models import Permission
from django.db.models import Q
from django.utils import timezone

from timepiece import utils

from timepiece.entries.models import Entry
from timepiece.reports.tests.base import ReportsTestBase
from timepiece.reports.utils import get_project_totals, generate_dates
from timepiece.tests.base import ViewTestMixin, LogTimeMixin


class TestHourlyReport(ViewTestMixin, LogTimeMixin, ReportsTestBase):
    url_name = 'report_hourly'

    def test_generate_months(self):
        dates = [utils.add_timezone(datetime.datetime(2011, month, 1))
            for month in xrange(1, 13)]
        start = datetime.date(2011, 1, 1)
        end = datetime.date(2011, 12, 1)
        self.check_generate_dates(start, end, 'month', dates)

    def test_generate_weeks(self):
        dates = [
            utils.add_timezone(datetime.datetime(2010, 12, 27)),
            utils.add_timezone(datetime.datetime(2011, 1, 3)),
            utils.add_timezone(datetime.datetime(2011, 1, 10)),
            utils.add_timezone(datetime.datetime(2011, 1, 17)),
            utils.add_timezone(datetime.datetime(2011, 1, 24)),
            utils.add_timezone(datetime.datetime(2011, 1, 31)),
        ]
        start = utils.add_timezone(datetime.datetime(2011, 1, 1))
        end = utils.add_timezone(datetime.datetime(2011, 2, 1))
        self.check_generate_dates(start, end, 'week', dates)

    def test_generate_days(self):
        dates = [utils.add_timezone(datetime.datetime(2011, 1, day))
            for day in xrange(1, 32)]
        start = utils.add_timezone(datetime.datetime(2011, 1, 1))
        end = utils.add_timezone(datetime.datetime(2011, 1, 31))
        self.check_generate_dates(start, end, 'day', dates)

    def check_truncs(self, trunc, billable, non_billable):
        self.make_entries(user=self.user)
        self.make_entries(user=self.user2)
        entries = Entry.objects.date_trunc(trunc)
        for entry in entries:
            if entry['billable']:
                self.assertEqual(entry['hours'], billable)
            else:
                self.assertEqual(entry['hours'], non_billable)

    def test_trunc_month(self):
        self.check_truncs('month', 18, 12)

    def test_trunc_week(self):
        self.check_truncs('week', 6, 4)

    def test_trunc_day(self):
        self.check_truncs('day', 3, 2)

    def get_project_totals(self, date_headers, trunc, query=Q(),
                           hour_type='total'):
        """Helper function for testing project_totals utility directly"""
        entries = Entry.objects.date_trunc(trunc).filter(query)
        if entries:
            pj_totals = get_project_totals(entries, date_headers, hour_type)
            pj_totals = list(pj_totals)
            rows = pj_totals[0][0]
            hours = [hours for name, user_id, hours in rows]
            totals = pj_totals[0][1]
            return hours, totals
        else:
            return ''

    def log_daily(self, start, day2, end):
        self.log_time(project=self.p1, start=start, delta=(1, 0))
        self.log_time(project=self.p1, start=day2, delta=(0, 30))
        self.log_time(project=self.p3, start=day2, delta=(1, 0))
        self.log_time(project=self.p1, start=day2, delta=(3, 0),
                      user=self.user2)
        self.log_time(project=self.sick, start=end, delta=(2, 0),
                      user=self.user2)

    def test_daily_total(self):
        start = utils.add_timezone(datetime.datetime(2011, 1, 1))
        day2 = utils.add_timezone(datetime.datetime(2011, 1, 2))
        end = utils.add_timezone(datetime.datetime(2011, 1, 3))
        self.log_daily(start, day2, end)
        trunc = 'day'
        date_headers = generate_dates(start, end, trunc)
        pj_totals = self.get_project_totals(date_headers, trunc)
        self.assertEqual(pj_totals[0][0],
                         [Decimal('1.00'), Decimal('1.50'), ''])
        self.assertEqual(pj_totals[0][1],
                         ['', Decimal('3.00'), Decimal('2.00')])
        self.assertEqual(pj_totals[1],
                         [Decimal('1.00'), Decimal('4.50'), Decimal('2.00')])

    def test_billable_nonbillable(self):
        start = utils.add_timezone(datetime.datetime(2011, 1, 1))
        day2 = utils.add_timezone(datetime.datetime(2011, 1, 2))
        end = utils.add_timezone(datetime.datetime(2011, 1, 3))
        self.log_daily(start, day2, end)
        trunc = 'day'
        billableQ = Q(project__type__billable=True)
        non_billableQ = Q(project__type__billable=False)
        date_headers = generate_dates(start, end, trunc)
        pj_billable = self.get_project_totals(date_headers, trunc, Q(),
                                              'billable')
        pj_billable_q = self.get_project_totals(date_headers, trunc, billableQ,
                                                'total')
        pj_non_billable = self.get_project_totals(date_headers, trunc, Q(),
                                                  'non_billable')
        pj_non_billable_q = self.get_project_totals(date_headers, trunc,
                                                    non_billableQ, 'total')
        self.assertEqual(list(pj_billable), list(pj_billable_q))
        self.assertEqual(list(pj_non_billable), list(pj_non_billable_q))

    def test_weekly_total(self):
        start = utils.add_timezone(datetime.datetime(2011, 1, 3))
        end = utils.add_timezone(datetime.datetime(2011, 1, 6))
        self.bulk_entries(start, end)
        trunc = 'week'
        date_headers = generate_dates(start, end, trunc)
        pj_totals = self.get_project_totals(date_headers, trunc)
        self.assertEqual(pj_totals[0][0], [48])
        self.assertEqual(pj_totals[0][1], [24])
        self.assertEqual(pj_totals[1], [72])

    def test_monthly_total(self):
        start = utils.add_timezone(datetime.datetime(2011, 1, 1))
        end = utils.add_timezone(datetime.datetime(2011, 3, 1))
        trunc = 'month'
        last_day = randint(5, 10)
        worked1 = randint(1, 3)
        worked2 = randint(1, 3)
        for month in xrange(1, 7):
            for day in xrange(1, last_day + 1):
                day = utils.add_timezone(datetime.datetime(2011, month, day))
                self.log_time(start=day, delta=(worked1, 0), user=self.user)
                self.log_time(start=day, delta=(worked2, 0), user=self.user2)
        date_headers = generate_dates(start, end, trunc)
        pj_totals = self.get_project_totals(date_headers, trunc)
        for hour in pj_totals[0][0]:
            self.assertEqual(hour, last_day * worked1)
        for hour in pj_totals[0][1]:
            self.assertEqual(hour, last_day * worked2)

    def args_helper(self, **kwargs):
        start = utils.add_timezone(
                kwargs.pop('start', datetime.datetime(2011, 1, 2)))
        end = utils.add_timezone(
                kwargs.pop('end', datetime.datetime(2011, 1, 4)))
        defaults = {
            'from_date': start.strftime('%m/%d/%Y'),
            'to_date': end.strftime('%m/%d/%Y'),
            'export': True,
            'billable': True,
            'non_billable': True,
            'paid_leave': True,
            'trunc': 'week',
        }
        defaults.update(kwargs)
        return defaults

    def make_totals(self, args={}):
        """Return CSV from hourly report for verification in tests"""
        self.login_user(self.superuser)
        response = self._get(data=args, follow=True)
        return [item.split(',') \
                for item in response.content.split('\r\n')][:-1]

    def check_totals(self, args, data):
        """assert that project_totals contains the data passed in"""
        totals = self.make_totals(args)
        for row, datum in zip(totals, data):
            self.assertEqual(row[1:], datum)

    def test_form_type__none(self):
        """When no types are checked, no results should be returned."""
        self.bulk_entries()
        args = {'billable': False, 'non_billable': False, 'paid_leave': False}
        args = self.args_helper(**args)
        data = []
        self.check_totals(args, data)

    def test_form_type__all(self):
        """When all types are checked, no filtering should occur."""
        self.bulk_entries()
        args = {'billable': True, 'non_billable': True, 'paid_leave': True}
        args = self.args_helper(**args)
        data = [
            ['01/02/2011', '01/03/2011', 'Total'],
            ['12.00', '24.00', '36.00'],
            ['6.00', '12.00', '18.00'],
        ]
        self.check_totals(args, data)

    def test_form_type__exclude_billable(self):
        """Non-billable or leave entries should be included."""
        self.bulk_entries()
        args = {'billable': False, 'non_billable': True, 'paid_leave': True}
        args = self.args_helper(**args)
        data = [
            ['01/02/2011', '01/03/2011', 'Total'],
            ['6.00', '12.00', '18.00'],
            ['3.00', '6.00', '9.00'],
        ]
        self.check_totals(args, data)

    def test_form_type__exclude_nonbillable(self):
        """Billable or leave entries should be included."""
        self.bulk_entries()
        args = {'billable': True, 'non_billable': False, 'paid_leave': True}
        args = self.args_helper(**args)
        data = [
            ['01/02/2011', '01/03/2011', 'Total'],
            ['8.00', '16.00', '24.00'],
            ['4.00', '8.00', '12.00'],
        ]
        self.check_totals(args, data)

    def test_form_type__exclude_leave(self):
        """No leave entries should be included."""
        self.bulk_entries()
        args = {'billable': True, 'non_billable': True, 'paid_leave': False}
        args = self.args_helper(**args)
        data = [
            ['01/02/2011', '01/03/2011', 'Total'],
            ['10.00', '20.00', '30.00'],
            ['5.00', '10.00', '15.00'],
            ['15.00', '30.00', '45.00'],
        ]
        self.check_totals(args, data)

    def test_form_type__only_billable(self):
        """Billable, non-leave entries should be included."""
        self.bulk_entries()
        args = {'billable': True, 'non_billable': False, 'paid_leave': False}
        args = self.args_helper(**args)
        data = [
            ['01/02/2011', '01/03/2011', 'Total'],
            ['6.00', '12.00', '18.00'],
            ['3.00', '6.00', '9.00'],
            ['9.00', '18.00', '27.00'],
        ]
        self.check_totals(args, data)

    def test_form_type__only_nonbillable(self):
        """Non-billable, non-leave entries should be included."""
        self.bulk_entries()
        args = {'billable': False, 'non_billable': True, 'paid_leave': False}
        args = self.args_helper(**args)
        data = [
            ['01/02/2011', '01/03/2011', 'Total'],
            ['4.00', '8.00', '12.00'],
            ['2.00', '4.00', '6.00'],
            ['6.00', '12.00', '18.00'],
        ]
        self.check_totals(args, data)

    def test_form_type__only_leave(self):
        """Only leave entries should be included."""
        self.bulk_entries()
        args = {'billable': False, 'non_billable': False, 'paid_leave': True}
        args = self.args_helper(**args)
        data = [
            ['01/02/2011', '01/03/2011', 'Total'],
            ['2.00', '4.00', '6.00'],
            ['1.00', '2.00', '3.00'],
        ]
        self.check_totals(args, data)

    def test_form_day(self):
        """Hours should be totaled for each day in the date range."""
        args = {
            'billable': True,
            'non_billable': False,
            'paid_leave': False,
            'trunc': 'day',
        }
        args = self.args_helper(**args)
        data = [
            ['01/02/2011', '01/03/2011', '01/04/2011', 'Total'],
            ['6.00', '6.00', '6.00', '18.00'],
            ['3.00', '3.00', '3.00', '9.00'],
            ['9.00', '9.00', '9.00', '27.00'],
        ]
        self.bulk_entries()
        self.check_totals(args, data)

    def test_form_week(self):
        """Hours should be totaled for each week in the date range."""
        args = {
            'billable': True,
            'non_billable': True,
            'paid_leave': True,
            'trunc': 'week',
        }
        args = self.args_helper(**args)
        data = [
            ['01/02/2011', '01/03/2011', 'Total'],
            ['12.00', '24.00', '36.00'],
            ['6.00', '12.00', '18.00'],
            ['18.00', '36.00', '54.00'],
        ]
        self.bulk_entries()
        self.check_totals(args, data)

    def test_form_month(self):
        """Hours should be totaled for each month in the date range."""
        tz = timezone.get_current_timezone()
        start = datetime.datetime(2011, 1, 4, tzinfo=tz)
        end = datetime.datetime(2011, 3, 28, tzinfo=tz)
        args = {
            'billable': True,
            'non_billable': False,
            'paid_leave': False,
            'trunc': 'month',
        }
        args = self.args_helper(start=start, end=end, **args)
        data = [
            ['01/04/2011', '02/01/2011', '03/01/2011', 'Total'],
            ['168.00', '168.00', '168.00', '504.00'],
            ['84.00', '84.00', '84.00', '252.00'],
            ['252.00', '252.00', '252.00', '756.00'],
        ]
        self.bulk_entries(start, end)
        self.check_totals(args, data)

    def test_form_projects(self):
        """Filter hours for specific projects."""
        #Test project 1
        self.bulk_entries()
        args = {
            'billable': True,
            'non_billable': True,
            'paid_leave': False,
            'trunc': 'day',
            'projects_1': self.p1.id,
        }
        args = self.args_helper(**args)
        data = [
            ['01/02/2011', '01/03/2011', '01/04/2011', 'Total'],
            ['2.00', '2.00', '2.00', '6.00'],
            ['1.00', '1.00', '1.00', '3.00'],
            ['3.00', '3.00', '3.00', '9.00'],
        ]
        self.check_totals(args, data)

        #Test with project 2
        args = {
            'billable': True,
            'non_billable': True,
            'paid_leave': False,
            'trunc': 'day',
            'projects_1': self.p2.id,
        }
        args = self.args_helper(**args)
        data = [
            ['01/02/2011', '01/03/2011', '01/04/2011', 'Total'],
            ['4.00', '4.00', '4.00', '12.00'],
            ['2.00', '2.00', '2.00', '6.00'],
            ['6.00', '6.00', '6.00', '18.00'],
        ]
        self.check_totals(args, data)

        #Test with 2 project filters
        args = {
            'billable': True,
            'non_billable': True,
            'paid_leave': False,
            'trunc': 'day',
            'projects_1': [self.p2.id, self.p4.id],
        }
        args = self.args_helper(**args)
        data = [
            ['01/02/2011', '01/03/2011', '01/04/2011', 'Total'],
            ['6.00', '6.00', '6.00', '18.00'],
            ['3.00', '3.00', '3.00', '9.00'],
            ['9.00', '9.00', '9.00', '27.00'],
        ]
        self.check_totals(args, data)

    def test_no_permission(self):
        """view_entry_summary permission is required to view this report."""
        self.login_user(self.user)
        response = self._get()
        self.assertEqual(response.status_code, 302)

    def test_entry_summary_permission(self):
        """view_entry_summary permission is required to view this report."""
        self.login_user(self.user)
        entry_summ_perm = Permission.objects.get(codename='view_entry_summary')
        self.user.user_permissions.add(entry_summ_perm)
        self.user.save()
        response = self._get()
        self.assertEqual(response.status_code, 200)

########NEW FILE########
__FILENAME__ = test_payroll
import datetime
from decimal import Decimal

from django.conf import settings
from django.core.urlresolvers import reverse
from django.contrib.auth.models import Permission
from django.test import TestCase

from timepiece import utils
from timepiece.tests import factories
from timepiece.tests.base import ViewTestMixin, LogTimeMixin

from timepiece.entries.models import Entry
from timepiece.reports.utils import find_overtime


class PayrollTest(ViewTestMixin, LogTimeMixin, TestCase):

    def setUp(self):
        super(PayrollTest, self).setUp()
        self.user = factories.User()
        self.user2 = factories.User()
        self.superuser = factories.Superuser()
        self.devl_activity = factories.Activity(billable=True)
        self.activity = factories.Activity()
        self.sick = factories.Project(name='sick')
        self.vacation = factories.Project(name='vacation')
        settings.TIMEPIECE_PAID_LEAVE_PROJECTS = {
            'sick': self.sick.pk, 'vacation': self.vacation.pk
        }
        self.next = utils.add_timezone(datetime.datetime(2011, 6, 1))
        self.overtime_before = utils.add_timezone(
            datetime.datetime(2011, 4, 29))
        self.first = utils.add_timezone(datetime.datetime(2011, 5, 1))
        self.first_week = utils.add_timezone(datetime.datetime(2011, 5, 2))
        self.middle = utils.add_timezone(datetime.datetime(2011, 5, 18))
        self.last_billable = utils.add_timezone(datetime.datetime(2011, 5, 28))
        self.last = utils.add_timezone(datetime.datetime(2011, 5, 31))
        self.dates = [
            self.overtime_before, self.first, self.first_week, self.middle,
            self.last, self.last_billable, self.next
        ]
        self.url = reverse('report_payroll_summary')
        self.args = {
            'year': self.first.year,
            'month': self.first.month,
        }

    def make_entry(self, user, start, delta, status='approved', billable=True,
                   project=None):
        self.log_time(start=start, delta=delta, user=user, status=status,
                      billable=billable, project=project)

    def make_logs(self, day=None, user=None, billable_project=None,
            nonbillable_project=None):
        if not user:
            user = self.user
        if not day:
            day = self.first
        billable = self.make_entry(user, day, (3, 30),
                project=billable_project)
        non_billable = self.make_entry(user, day, (2, 0),
                project=nonbillable_project)
        invoiced = self.make_entry(user, day, (5, 30), status=Entry.INVOICED,
                project=billable_project)
        unapproved = self.make_entry(user, day, (6, 0), status=Entry.VERIFIED,
                project=billable_project)
        sick = self.make_entry(user, day, (8, 0), project=self.sick)
        vacation = self.make_entry(user, day, (4, 0), project=self.vacation)

    def all_logs(self, user=None, billable_project=None,
            nonbillable_project=None):
        if not user:
            user = self.user
        for day in self.dates:
            self.make_logs(day, user, billable_project, nonbillable_project)

    def testLastBillable(self):
        """Test the get_last_billable_day utility for validity"""
        months = range(1, 13)
        first_days = [utils.add_timezone(datetime.datetime(2011, month, 1))
            for month in months]
        last_billable = [utils.get_last_billable_day(day).day \
                         for day in first_days]
        #should equal the last saturday of every month in 2011
        self.assertEqual(last_billable,
                         [30, 27, 27, 24, 29, 26, 31, 28, 25, 30, 27, 25])

    def testFindOvertime(self):
        """Test the find_overtime utility for accuracy"""
        self.assertEqual(round(find_overtime([0, 40, 40.01, 41, 40]), 2),
                         1.01)

    def testWeeklyTotals(self):
        self.all_logs(self.user)
        self.all_logs(self.user2)
        self.login_user(self.superuser)
        response = self.client.get(self.url, self.args)
        weekly_totals = response.context['weekly_totals']
        self.assertEqual(weekly_totals[0][0][0][2],
                         [Decimal('22.00'),
                          Decimal('11.00'), '',
                          Decimal('11.00'),
                          Decimal('11.00'), ''
                         ])

    def testWeeklyOvertimes(self):
        """Date_trunc on week should result in correct overtime totals"""
        dates = self.dates
        for day_num in xrange(28, 31):
            dates.append(utils.add_timezone(
                datetime.datetime(2011, 4, day_num)
            ))
        for day_num in xrange(5, 9):
            dates.append(utils.add_timezone(
                datetime.datetime(2011, 5, day_num)
            ))
        for day in dates:
            self.make_logs(day)

        def check_overtime(week0=Decimal('55.00'), week1=Decimal('55.00'),
                           overtime=Decimal('30.00')):
            self.login_user(self.superuser)
            response = self.client.get(self.url, self.args)
            weekly_totals = response.context['weekly_totals'][0][0][0][2]
            self.assertEqual(weekly_totals[0], week0)
            self.assertEqual(weekly_totals[1], week1)
            self.assertEqual(weekly_totals[5], overtime)
        check_overtime()
        #Entry on following Monday doesn't add to week1 or overtime
        self.make_logs(utils.add_timezone(datetime.datetime(2011, 5, 9)))
        check_overtime()
        #Entries in previous month before last_billable do not change overtime
        self.make_logs(utils.add_timezone(datetime.datetime(2011, 4, 24)))
        check_overtime()
        #Entry in previous month after last_billable change week0 and overtime
        self.make_logs(utils.add_timezone(
            datetime.datetime(2011, 4, 25, 1, 0)
        ))
        check_overtime(Decimal('66.00'), Decimal('55.00'), Decimal('41.00'))

    def _setupMonthlyTotals(self):
        """
        Helps set up environment for testing aspects of the monthly payroll
        summary.
        """
        self.billable_project = factories.BillableProject()
        self.nonbillable_project = factories.NonbillableProject()
        self.all_logs(self.user, self.billable_project,
                self.nonbillable_project)
        self.all_logs(self.user2, self.billable_project,
                self.nonbillable_project)
        self.login_user(self.superuser)
        self.response = self.client.get(self.url, self.args)
        self.rows = self.response.context['monthly_totals']
        self.labels = self.response.context['labels']

    def testMonthlyPayrollLabels(self):
        """
        Labels should contain all billable & nonbillable project type labels
        as well as all leave project names.
        """
        self._setupMonthlyTotals()
        self.assertEquals(self.labels['billable'],
                [self.billable_project.type.label])
        self.assertEquals(self.labels['nonbillable'],
                [self.nonbillable_project.type.label])
        self.assertEquals(len(self.labels['leave']), 2)
        self.assertTrue(self.sick.name in self.labels['leave'])
        self.assertTrue(self.vacation.name in self.labels['leave'])

    def testMonthlyPayrollRows(self):
        """Rows should contain monthly totals mapping for each user."""
        self._setupMonthlyTotals()

        # 1 row for each user, plus totals row.
        self.assertEquals(len(self.rows), 2 + 1)

        for row in self.rows[:-1]:  # Exclude totals row.
            work_total = Decimal('55.00')
            self.assertEquals(row['work_total'], work_total)

            # Last entry is summary of status.
            self.assertEquals(len(row['billable']), 1 + 1)
            for entry in row['billable']:
                self.assertEquals(entry['hours'], Decimal('45.00'))
                self.assertEquals(entry['percent'],
                        Decimal('45.00') / work_total * 100)

            # Last entry is summary of status.
            self.assertEquals(len(row['nonbillable']), 1 + 1)
            for entry in row['nonbillable']:
                self.assertEquals(entry['hours'], Decimal('10.00'))
                self.assertEquals(entry['percent'],
                        Decimal('10.00') / work_total * 100)

            self.assertEquals(len(row['leave']), 2 + 1)
            sick_index = self.labels['leave'].index(self.sick.name)
            vacation_index = self.labels['leave'].index(self.vacation.name)
            self.assertEquals(row['leave'][sick_index]['hours'],
                    Decimal('40.00'))
            self.assertEquals(row['leave'][sick_index]['percent'],
                    Decimal('40.00') / Decimal('60.00') * 100)
            self.assertEquals(row['leave'][vacation_index]['hours'],
                    Decimal('20.00'))
            self.assertEquals(row['leave'][vacation_index]['percent'],
                    Decimal('20.00') / Decimal('60.00') * 100)
            self.assertEquals(row['leave'][-1]['hours'], Decimal('60.00'))
            self.assertEquals(row['leave'][-1]['percent'], Decimal('100.00'))

            self.assertEquals(row['grand_total'], Decimal('115.00'))

    def testMonthlyPayrollTotals(self):
        """Last row should contain summary totals over all users."""
        self._setupMonthlyTotals()
        totals = self.rows[-1]

        work_total = Decimal('110.00')
        self.assertEquals(totals['work_total'], work_total)

        self.assertEquals(len(totals['billable']), 1 + 1)
        for entry in totals['billable']:
            self.assertEquals(entry['hours'], Decimal('90.00'))
            self.assertEquals(entry['percent'],
                    Decimal('90.00') / work_total * 100)

        self.assertEquals(len(totals['nonbillable']), 1 + 1)
        for entry in totals['nonbillable']:
            self.assertEquals(entry['hours'], Decimal('20.00'))
            self.assertEquals(entry['percent'],
                    Decimal('20.00') / work_total * 100)

        self.assertEquals(len(totals['leave']), 2 + 1)
        sick_index = self.labels['leave'].index(self.sick.name)
        vacation_index = self.labels['leave'].index(self.vacation.name)
        self.assertEquals(totals['leave'][sick_index]['hours'],
                Decimal('80.00'))
        self.assertEquals(totals['leave'][sick_index]['percent'],
                Decimal('80.00') / Decimal('120.00') * 100)
        self.assertEquals(totals['leave'][vacation_index]['hours'],
                Decimal('40.00'))
        self.assertEquals(totals['leave'][vacation_index]['percent'],
                Decimal('40.00') / Decimal('120.00') * 100)
        self.assertEquals(totals['leave'][-1]['hours'], Decimal('120.00'))
        self.assertEquals(totals['leave'][-1]['percent'], Decimal('100.00'))

        self.assertEquals(totals['grand_total'], Decimal('230.00'))

    def testNoPermission(self):
        """
        Regular users shouldn't be able to retrieve the payroll report
        page.

        """
        self.login_user(self.user)
        response = self.client.get(self.url, self.args)
        self.assertEqual(response.status_code, 302)

    def testSuperUserPermission(self):
        """Super users should be able to retrieve the payroll report page."""
        self.login_user(self.superuser)
        response = self.client.get(self.url, self.args)
        self.assertEqual(response.status_code, 200)

    def testPayrollPermission(self):
        """
        If a regular user is given the view_payroll_summary permission, they
        should be able to retrieve the payroll summary page.

        """
        self.login_user(self.user)
        payroll_perm = Permission.objects.get(codename='view_payroll_summary')
        self.user.user_permissions.add(payroll_perm)
        self.user.save()
        response = self.client.get(self.url, self.args)
        self.assertEqual(response.status_code, 200)

########NEW FILE########
__FILENAME__ = test_productivity
import csv
import datetime
from dateutil.relativedelta import relativedelta
import json

from django.contrib.auth.models import Permission
from django.test import TestCase

from timepiece.tests.base import ViewTestMixin
from timepiece.tests import factories

from timepiece.entries.models import Entry, ProjectHours


class TestProductivityReport(ViewTestMixin, TestCase):
    url_name = 'report_productivity'

    def setUp(self):
        super(TestProductivityReport, self).setUp()
        self.user = factories.User()
        self.permission = Permission.objects.get(codename='view_entry_summary')
        self.user.user_permissions.add(self.permission)
        self.login_user(self.user)

        self.project = factories.Project()
        self.users = []
        self.users.append(factories.User(first_name='User', last_name='1'))
        self.users.append(factories.User(first_name='User', last_name='2'))
        self.users.append(factories.User(first_name='User', last_name='3'))
        self.weeks = []
        self.weeks.append(datetime.datetime(2012, 9, 24))
        self.weeks.append(datetime.datetime(2012, 10, 1))
        self.weeks.append(datetime.datetime(2012, 10, 8))
        self.weeks.append(datetime.datetime(2012, 10, 15))

        self._create_entries()
        self._create_assignments()

    def _create_entries(self):
        for start_time in (self.weeks[1], self.weeks[3]):
            for user in (self.users[1], self.users[2]):
                end_time = start_time + relativedelta(hours=2)
                data = {'user': user, 'start_time': start_time,
                        'end_time': end_time, 'project': self.project}
                factories.Entry(**data)

    def _create_assignments(self):
        for week_start in (self.weeks[0], self.weeks[1]):
            for user in (self.users[0], self.users[1]):
                data = {'user': user, 'week_start': week_start,
                        'project': self.project, 'hours': 2}
                factories.ProjectHours(**data)

    def _unpack(self, response):
        form = response.context['form']
        report = json.loads(response.context['report'])
        organize_by = response.context['type']
        worked = response.context['total_worked']
        assigned = response.context['total_assigned']
        return form, report, organize_by, worked, assigned

    def _check_row(self, row, correct):
        self.assertEqual(len(row), 3)
        self.assertEqual(row[0], correct[0])
        self.assertEqual(float(row[1]), correct[1])
        self.assertEqual(float(row[2]), correct[2])

    def test_not_authenticated(self):
        """User must be logged in to see this report."""
        self.client.logout()
        response = self._get()
        self.assertEqual(response.status_code, 302)  # Redirects to login

    def test_no_permission(self):
        """This report requires permission to view entry summaries."""
        self.user.user_permissions.remove(self.permission)
        response = self._get()
        self.assertEqual(response.status_code, 302)  # Redirects to login

    def test_retrieval(self):
        """No report data should be returned upon initial retrieval."""
        response = self._get()
        self.assertEqual(response.status_code, 200)
        form, report, organize_by, worked, assigned = self._unpack(response)
        self.assertEqual(len(form.errors), 0)
        self.assertEqual(len(report), 0)
        self.assertEqual(organize_by, '')
        self.assertEqual(float(worked), 0.0)
        self.assertEqual(float(assigned), 0.0)

    def test_no_project(self):
        """Form requires specification of project."""
        data = {'organize_by': 'week'}
        response = self._get(data=data)
        self.assertEqual(response.status_code, 200)
        form, report, organize_by, worked, assigned = self._unpack(response)
        self.assertEqual(len(form.errors), 1)
        self.assertTrue('project' in form.errors)
        self.assertEqual(len(report), 0)
        self.assertEqual(organize_by, '')
        self.assertEqual(float(worked), 0.0)
        self.assertEqual(float(assigned), 0.0)

    def test_invalid_project_id(self):
        """Form requires specification of valid project."""
        data = {'organize_by': 'week', 'project_1': 12345}
        response = self._get(data=data)
        self.assertEqual(response.status_code, 200)
        form, report, organize_by, worked, assigned = self._unpack(response)
        self.assertEqual(len(form.errors), 1)
        self.assertTrue('project' in form.errors)
        self.assertEqual(len(report), 0)
        self.assertEqual(organize_by, '')
        self.assertEqual(float(worked), 0.0)
        self.assertEqual(float(assigned), 0.0)

    def test_no_organize_by(self):
        """Form requires specification of organization method."""
        data = {'project_1': self.project.pk}
        response = self._get(data=data)
        self.assertEqual(response.status_code, 200)
        form, report, organize_by, worked, assigned = self._unpack(response)
        self.assertEqual(len(form.errors), 1)
        self.assertTrue('organize_by' in form.errors)
        self.assertEqual(len(report), 0)
        self.assertEqual(organize_by, '')
        self.assertEqual(float(worked), 0.0)
        self.assertEqual(float(assigned), 0.0)

    def test_invalid_organize_by(self):
        """Form requires specification of valid organization method."""
        data = {'project_1': self.project.pk, 'organize_by': 'invalid'}
        response = self._get(data=data)
        self.assertEqual(response.status_code, 200)
        form, report, organize_by, worked, assigned = self._unpack(response)
        self.assertEqual(len(form.errors), 1)
        self.assertTrue('organize_by' in form.errors)
        self.assertEqual(len(report), 0)
        self.assertEqual(organize_by, '')
        self.assertEqual(float(worked), 0.0)
        self.assertEqual(float(assigned), 0.0)

    def test_no_data(self):
        """If no data, report should contain header row only."""
        Entry.objects.filter(project=self.project).delete()
        ProjectHours.objects.filter(project=self.project).delete()
        data = {'project_1': self.project.pk, 'organize_by': 'week'}
        response = self._get(data=data)
        self.assertEqual(response.status_code, 200)
        form, report, organize_by, worked, assigned = self._unpack(response)
        self.assertEqual(len(form.errors), 0)
        self.assertEqual(len(report), 1)
        self.assertEqual(organize_by, 'week')
        self.assertEqual(float(worked), 0.0)
        self.assertEqual(float(assigned), 0.0)

    def test_organize_by_week(self):
        """Report should contain hours per week on the project."""
        data = {'project_1': self.project.pk, 'organize_by': 'week'}
        response = self._get(data=data)
        self.assertEqual(response.status_code, 200)
        form, report, organize_by, worked, assigned = self._unpack(response)
        self.assertEqual(len(form.errors), 0)
        self.assertEqual(organize_by, 'week')
        self.assertEqual(float(worked), 8.0)
        self.assertEqual(float(assigned), 8.0)
        self.assertEqual(len(report), 1 + 4)  # Include header row
        self._check_row(report[1], [u'Sep 24, 2012', 0.0, 4.0])
        self._check_row(report[2], [u'Oct 1, 2012', 4.0, 4.0])
        self._check_row(report[3], [u'Oct 8, 2012', 0.0, 0.0])
        self._check_row(report[4], [u'Oct 15, 2012', 4.0, 0.0])

    def test_organize_by_users(self):
        """Report should contain hours per peron on the project."""
        data = {'project_1': self.project.pk, 'organize_by': 'user'}
        response = self._get(data=data)
        self.assertEqual(response.status_code, 200)
        form, report, organize_by, worked, assigned = self._unpack(response)
        self.assertEqual(len(form.errors), 0)
        self.assertEqual(organize_by, 'user')
        self.assertEqual(float(worked), 8.0)
        self.assertEqual(float(assigned), 8.0)
        self.assertEqual(len(report), 1 + 3)  # Include header row
        self._check_row(report[1], ['User 1', 0.0, 4.0])
        self._check_row(report[2], ['User 2', 4.0, 4.0])
        self._check_row(report[3], ['User 3', 4.0, 0.0])

    def test_export(self):
        """Data should be exported in CSV format."""
        data = {'project_1': self.project.pk, 'organize_by': 'week',
                'export': True}
        response = self._get(data=data)
        self.assertEqual(response.status_code, 200)
        data = dict(response.items())
        self.assertEqual(data['Content-Type'], 'text/csv')
        disposition = 'attachment; filename={0}_productivity.csv'.format(
                self.project.name)
        self.assertTrue(data['Content-Disposition'].startswith(disposition))
        report = response.content.splitlines()
        self.assertEqual(len(report), 1 + 4)  # Include header row

        def parse_csv_row(s):
            """Given a string in CSV format, return a list of strings that
            represent the fields from the CSV line, with e.g. quotes removed"""
            return csv.reader([s]).next()

        self._check_row(parse_csv_row(report[1]), [u'Sep 24, 2012', 0.0, 4.0])
        self._check_row(parse_csv_row(report[2]), [u'Oct 1, 2012', 4.0, 4.0])
        self._check_row(parse_csv_row(report[3]), [u'Oct 8, 2012', 0.0, 0.0])
        self._check_row(parse_csv_row(report[4]), [u'Oct 15, 2012', 4.0, 0.0])

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url
from timepiece.reports import views


urlpatterns = patterns('',
    url(r'^reports/hourly/$',
        views.HourlyReport.as_view(),
        name='report_hourly'),

    url(r'^reports/payroll/$',
        views.report_payroll_summary,
        name='report_payroll_summary'),

    url(r'^reports/billable_hours/$',
        views.BillableHours.as_view(),
        name='report_billable_hours'),

    url(r'^reports/productivity/$',
        views.report_productivity,
        name='report_productivity'),

    url(r'^reports/estimation_accuracy/$',
        views.report_estimation_accuracy,
        name='report_estimation_accuracy'),
)

########NEW FILE########
__FILENAME__ = utils
import datetime
from dateutil import rrule
from dateutil.relativedelta import relativedelta
from decimal import Decimal
from itertools import groupby

from timepiece.utils import get_hours_summary, add_timezone, get_week_start,\
        get_month_start, get_year_start


def date_totals(entries, by):
    """Yield a user's name and a dictionary of their hours"""
    date_dict = {}
    for date, date_entries in groupby(entries, lambda x: x['date']):
        if isinstance(date, datetime.datetime):
            date = date.date()
        d_entries = list(date_entries)

        if by == 'user':
            name = ' '.join((d_entries[0]['user__first_name'],
                    d_entries[0]['user__last_name']))
        elif by == 'project':
            name = d_entries[0]['project__name']
        else:
            name = d_entries[0][by]

        pk = d_entries[0][by]
        hours = get_hours_summary(d_entries)
        date_dict[date] = hours
    return name, pk, date_dict


def find_overtime(dates):
    """Given a list of weekly summaries, return the overtime for each week"""
    return sum([day - 40 for day in dates if day > 40])


def generate_dates(start=None, end=None, by='week'):
    if start:
        start = add_timezone(start)
    if end:
        end = add_timezone(end)
    if by == 'year':
        start = get_year_start(start)
        return rrule.rrule(rrule.YEARLY, dtstart=start, until=end)
    if by == 'month':
        start = get_month_start(start)
        return rrule.rrule(rrule.MONTHLY, dtstart=start, until=end)
    if by == 'week':
        start = get_week_start(start)
        return rrule.rrule(rrule.WEEKLY, dtstart=start, until=end, byweekday=0)
    if by == 'day':
        return rrule.rrule(rrule.DAILY, dtstart=start, until=end)


def get_project_totals(entries, date_headers, hour_type=None, overtime=False,
                   total_column=False, by='user'):
    """
    Yield hour totals grouped by user and date. Optionally including overtime.
    """
    totals = [0 for date in date_headers]
    rows = []
    for thing, thing_entries in groupby(entries, lambda x: x[by]):
        name, thing_id, date_dict = date_totals(thing_entries, by)
        dates = []
        for index, day in enumerate(date_headers):
            if isinstance(day, datetime.datetime):
                day = day.date()
            if hour_type:
                total = date_dict.get(day, {}).get(hour_type, 0)
                dates.append(total)
            else:
                billable = date_dict.get(day, {}).get('billable', 0)
                nonbillable = date_dict.get(day, {}).get('non_billable', 0)
                total = billable + nonbillable
                dates.append({
                    'day': day,
                    'billable': billable,
                    'nonbillable': nonbillable,
                    'total': total
                })
            totals[index] += total
        if total_column:
            dates.append(sum(dates))
        if overtime:
            dates.append(find_overtime(dates))
        dates = [date or '' for date in dates]
        rows.append((name, thing_id, dates))
    if total_column:
        totals.append(sum(totals))
    totals = [total or '' for total in totals]
    yield (rows, totals)


def get_payroll_totals(month_work_entries, month_leave_entries):
    """Summarizes monthly work and leave totals, grouped by user.

    Returns (labels, rows).
        labels -> {'billable': [proj_labels], 'nonbillable': [proj_labels]}
        rows -> [{
            name: name of user,
            billable, nonbillable, leave: [
                {'hours': hours for label, 'percent': % of work or leave total}
            ],
            work_total: sum of billable and nonbillable hours,
            leave_total: sum of leave hours
            grand_total: sum of work_total and leave_total
        }]

    The last entry in each of the billable/nonbillable/leave lists contains a
    summary of the status. The last row contains sum totals for all other rows.
    """
    def _get_user_info(entries):
        """Helper for getting the associated user's first and last name."""
        fname = entries[0].get('user__first_name', '') if entries else ''
        lname = entries[0].get('user__last_name', '') if entries else ''
        name = '{0} {1}'.format(fname, lname).strip()
        user_id = entries[0].get('user', None) if entries else None
        return {'name': name, 'user_id': user_id}

    def _get_index(status, label):
        """
        Returns the index in row[status] (where row is the row corresponding
        to the current user) where hours for the project label should be
        recorded.

        If the label does not exist, then it is added to the labels list.
        Each row and the totals row is updated accordingly.

        Requires that labels, rows, and totals are in scope.
        """
        if label in labels[status]:
            return labels[status].index(label)
        # Otherwise: update labels, rows, and totals to reflect the addition.
        labels[status].append(label)
        for row in rows:
            row[status].insert(-1, {'hours': Decimal(), 'percent': Decimal()})
        totals[status].insert(-1, {'hours': Decimal(), 'percent': Decimal()})
        return len(labels[status]) - 1

    def _construct_row(name, user_id=None):
        """Constructs an empty row for the given name."""
        row = {'name': name, 'user_id': user_id}
        for status in labels.keys():
            # Include an extra entry for summary.
            row[status] = [{'hours': Decimal(), 'percent': Decimal()}
                    for i in range(len(labels[status]) + 1)]
        row['work_total'] = Decimal()
        row['grand_total'] = Decimal()
        return row

    def _add_percentages(row, statuses, total):
        """For each entry in each status, percent = hours / total"""
        if total:
            for status in statuses:
                for i in range(len(row[status])):
                    p = row[status][i]['hours'] / total * 100
                    row[status][i]['percent'] = p

    def _get_sum(row, statuses):
        """Sum the number of hours worked in given statuses."""
        return sum([row[status][-1]['hours'] for status in statuses])

    work_statuses = ('billable', 'nonbillable')
    leave_statuses = ('leave', )
    labels = dict([(status, []) for status in work_statuses + leave_statuses])
    rows = []
    totals = _construct_row('Totals')
    for user, work_entries in groupby(month_work_entries, lambda e: e['user']):

        work_entries = list(work_entries)
        row = _construct_row(**_get_user_info(work_entries))
        rows.append(row)
        for entry in work_entries:
            status = 'billable' if entry['billable'] else 'nonbillable'
            label = entry['project__type__label']
            index = _get_index(status, label)
            hours = entry['hours']
            row[status][index]['hours'] += hours
            row[status][-1]['hours'] += hours
            totals[status][index]['hours'] += hours
            totals[status][-1]['hours'] += hours

        leave_entries = month_leave_entries.filter(user=user)
        status = 'leave'
        for entry in leave_entries:
            label = entry.get('project__name')
            index = _get_index(status, label)
            hours = entry.get('hours')
            row[status][index]['hours'] += hours
            row[status][-1]['hours'] += hours
            totals[status][index]['hours'] += hours
            totals[status][-1]['hours'] += hours

        row['work_total'] = _get_sum(row, work_statuses)
        _add_percentages(row, work_statuses, row['work_total'])
        row['leave_total'] = _get_sum(row, leave_statuses)
        _add_percentages(row, leave_statuses, row['leave_total'])
        row['grand_total'] = row['work_total'] + row['leave_total']

    totals['work_total'] = _get_sum(totals, work_statuses)
    _add_percentages(totals, work_statuses, totals['work_total'])
    totals['leave_total'] = _get_sum(totals, leave_statuses)
    _add_percentages(totals, leave_statuses, totals['leave_total'])
    totals['grand_total'] = totals['work_total'] + totals['leave_total']

    if rows:
        rows.append(totals)
    return labels, rows


def get_week_window(day=None):
    """Returns (Monday, Sunday) of the requested week."""
    start = get_week_start(day)
    return (start, start + relativedelta(days=6))

########NEW FILE########
__FILENAME__ = views
import csv
from dateutil.relativedelta import relativedelta
from itertools import groupby
import json

from django.contrib.auth.decorators import permission_required
from django.db.models import Sum, Q, Min, Max
from django.http import HttpResponse
from django.shortcuts import render
from django.template.defaultfilters import date as date_format_filter
from django.utils import timezone
from django.utils.decorators import method_decorator
from django.views.generic import TemplateView

from timepiece import utils
from timepiece.utils.csv import CSVViewMixin, DecimalEncoder

from timepiece.contracts.models import ProjectContract
from timepiece.entries.models import Entry, ProjectHours
from timepiece.reports.forms import BillableHoursReportForm, HourlyReportForm,\
        ProductivityReportForm, PayrollSummaryReportForm
from timepiece.reports.utils import get_project_totals, get_payroll_totals,\
        generate_dates, get_week_window


class ReportMixin(object):
    """Common data for the Hourly & Billable Hours reports."""

    @method_decorator(permission_required('entries.view_entry_summary'))
    def dispatch(self, request, *args, **kwargs):
        return super(ReportMixin, self).dispatch(request, *args, **kwargs)

    def get_context_data(self, **kwargs):
        """Processes form data to get relevant entries & date_headers."""
        context = super(ReportMixin, self).get_context_data(**kwargs)

        form = self.get_form()
        if form.is_valid():
            data = form.cleaned_data
            start, end = form.save()
            entryQ = self.get_entry_query(start, end, data)
            trunc = data['trunc']
            if entryQ:
                vals = ('pk', 'activity', 'project', 'project__name',
                        'project__status', 'project__type__label')
                entries = Entry.objects.date_trunc(trunc,
                        extra_values=vals).filter(entryQ)
            else:
                entries = Entry.objects.none()

            end = end - relativedelta(days=1)
            date_headers = generate_dates(start, end, by=trunc)
            context.update({
                'from_date': start,
                'to_date': end,
                'date_headers': date_headers,
                'entries': entries,
                'filter_form': form,
                'trunc': trunc,
            })
        else:
            context.update({
                'from_date': None,
                'to_date': None,
                'date_headers': [],
                'entries': Entry.objects.none(),
                'filter_form': form,
                'trunc': '',
            })

        return context

    def get_entry_query(self, start, end, data):
        """Builds Entry query from form data."""
        # Entry types.
        incl_billable = data.get('billable', True)
        incl_nonbillable = data.get('non_billable', True)
        incl_leave = data.get('paid_leave', True)

        # If no types are selected, shortcut & return nothing.
        if not any((incl_billable, incl_nonbillable, incl_leave)):
            return None

        # All entries must meet time period requirements.
        basicQ = Q(end_time__gte=start, end_time__lt=end)

        # Filter by project for HourlyReport.
        projects = data.get('projects', None)
        basicQ &= Q(project__in=projects) if projects else Q()

        # Filter by user, activity, and project type for BillableReport.
        if 'users' in data:
            basicQ &= Q(user__in=data.get('users'))
        if 'activities' in data:
            basicQ &= Q(activity__in=data.get('activities'))
        if 'project_types' in data:
            basicQ &= Q(project__type__in=data.get('project_types'))

        # If all types are selected, no further filtering is required.
        if all((incl_billable, incl_nonbillable, incl_leave)):
            return basicQ

        # Filter by whether a project is billable or non-billable.
        billableQ = None
        if incl_billable and not incl_nonbillable:
            billableQ = Q(activity__billable=True,
                    project__type__billable=True)
        if incl_nonbillable and not incl_billable:
            billableQ = Q(activity__billable=False) |\
                    Q(project__type__billable=False)

        # Filter by whether the entry is paid leave.
        leave_ids = utils.get_setting('TIMEPIECE_PAID_LEAVE_PROJECTS').values()
        leaveQ = Q(project__in=leave_ids)
        if incl_leave:
            extraQ = (leaveQ | billableQ) if billableQ else leaveQ
        else:
            extraQ = (~leaveQ & billableQ) if billableQ else ~leaveQ

        return basicQ & extraQ

    def get_headers(self, date_headers, from_date, to_date, trunc):
        """Adjust date headers & get range headers."""
        date_headers = list(date_headers)

        # Earliest date should be no earlier than from_date.
        if date_headers and date_headers[0] < from_date:
            date_headers[0] = from_date

        # When organizing by week or month, create a list of the range for
        # each date header.
        if date_headers and trunc != 'day':
            count = len(date_headers)
            range_headers = [0] * count
            for i in range(count - 1):
                range_headers[i] = (date_headers[i], date_headers[i + 1] -
                        relativedelta(days=1))
            range_headers[count - 1] = (date_headers[count - 1], to_date)
        else:
            range_headers = date_headers
        return date_headers, range_headers

    def get_previous_month(self):
        """Returns date range for the previous full month."""
        end = utils.get_month_start() - relativedelta(days=1)
        end = utils.to_datetime(end)
        start = utils.get_month_start(end)
        return start, end


class HourlyReport(ReportMixin, CSVViewMixin, TemplateView):
    template_name = 'timepiece/reports/hourly.html'

    def convert_context_to_csv(self, context):
        """Convert the context dictionary into a CSV file."""
        content = []
        date_headers = context['date_headers']

        headers = ['Name']
        headers.extend([date.strftime('%m/%d/%Y') for date in date_headers])
        headers.append('Total')
        content.append(headers)

        if self.export_projects:
            key = 'By Project'
        else:
            key = 'By User'

        summaries = context['summaries']
        summary = summaries[key] if key in summaries else []
        for rows, totals in summary:
            for name, user_id, hours in rows:
                data = [name]
                data.extend(hours)
                content.append(data)
            total = ['Totals']
            total.extend(totals)
            content.append(total)
        return content

    @property
    def defaults(self):
        """Default filter form data when no GET data is provided."""
        # Set default date span to previous week.
        (start, end) = get_week_window(timezone.now() - relativedelta(days=7))
        return {
            'from_date': start,
            'to_date': end,
            'billable': True,
            'non_billable': False,
            'paid_leave': False,
            'trunc': 'day',
            'projects': [],
        }

    def get(self, request, *args, **kwargs):
        self.export_users = request.GET.get('export_users', False)
        self.export_projects = request.GET.get('export_projects', False)
        context = self.get_context_data()
        if self.export_users or self.export_projects:
            kls = CSVViewMixin
        else:
            kls = TemplateView
        return kls.render_to_response(self, context)

    def get_context_data(self, **kwargs):
        context = super(HourlyReport, self).get_context_data(**kwargs)

        # Sum the hours totals for each user & interval.
        entries = context['entries']
        date_headers = context['date_headers']

        summaries = []
        if context['entries']:
            summaries.append(('By User', get_project_totals(
                    entries.order_by('user__last_name', 'user__id', 'date'),
                    date_headers, 'total', total_column=True, by='user')))

            entries = entries.order_by('project__type__label', 'project__name',
                    'project__id', 'date')
            func = lambda x: x['project__type__label']
            for label, group in groupby(entries, func):
                title = label + ' Projects'
                summaries.append((title, get_project_totals(list(group),
                        date_headers, 'total', total_column=True, by='project')))

        # Adjust date headers & create range headers.
        from_date = context['from_date']
        from_date = utils.add_timezone(from_date) if from_date else None
        to_date = context['to_date']
        to_date = utils.add_timezone(to_date) if to_date else None
        trunc = context['trunc']
        date_headers, range_headers = self.get_headers(date_headers,
                from_date, to_date, trunc)

        context.update({
            'date_headers': date_headers,
            'summaries': summaries,
            'range_headers': range_headers,
        })
        return context

    def get_filename(self, context):
        request = self.request.GET.copy()
        from_date = request.get('from_date')
        to_date = request.get('to_date')
        return 'hours_{0}_to_{1}_by_{2}.csv'.format(from_date, to_date,
            context.get('trunc', ''))

    def get_form(self):
        data = self.request.GET or self.defaults
        data = data.copy()  # make mutable
        # Fix booleans - the strings "0" and "false" are True in Python
        for key in ['billable', 'non_billable', 'paid_leave']:
            data[key] = key in data and \
                        str(data[key]).lower() in ('on', 'true', '1')

        return HourlyReportForm(data)


class BillableHours(ReportMixin, TemplateView):
    template_name = 'timepiece/reports/billable_hours.html'

    @property
    def defaults(self):
        """Default filter form data when no GET data is provided."""
        start, end = self.get_previous_month()
        return {
            'from_date': start,
            'to_date': end,
            'trunc': 'week',
        }

    def get_context_data(self, **kwargs):
        context = super(BillableHours, self).get_context_data(**kwargs)

        entries = context['entries']
        date_headers = context['date_headers']
        data_map = self.get_hours_data(entries, date_headers)

        from_date = context['from_date']
        to_date = context['to_date']
        trunc = context['trunc']
        kwargs = {trunc + 's': 1}  # For relativedelta

        keys = sorted(data_map.keys())
        data_list = [['Date', 'Billable', 'Non-billable']]
        for i in range(len(keys)):
            start = keys[i]
            start = start if start >= from_date else from_date
            end = start + relativedelta(**kwargs) - relativedelta(days=1)
            end = end if end <= to_date else to_date

            if start != end:
                label = ' - '.join([date_format_filter(d, 'M j') for d in (start, end)])
            else:
                label = date_format_filter(start, 'M j')
            billable = data_map[keys[i]]['billable']
            nonbillable = data_map[keys[i]]['nonbillable']
            data_list.append([label, billable, nonbillable])

        context.update({
            'data': json.dumps(data_list, cls=DecimalEncoder),
        })
        return context

    def get_form(self):
        if self.request.GET:
            return BillableHoursReportForm(self.request.GET)
        else:
            # Select all available users, activities, and project types.
            return BillableHoursReportForm(self.defaults,
                    select_all=True)

    def get_hours_data(self, entries, date_headers):
        """Sum billable and non-billable hours across all users."""
        project_totals = get_project_totals(entries, date_headers,
                total_column=False) if entries else []

        data_map = {}
        for rows, totals in project_totals:
            for user, user_id, periods in rows:
                for period in periods:
                    day = period['day']
                    if day not in data_map:
                        data_map[day] = {'billable': 0, 'nonbillable': 0}
                    data_map[day]['billable'] += period['billable']
                    data_map[day]['nonbillable'] += period['nonbillable']

        return data_map


@permission_required('entries.view_payroll_summary')
def report_payroll_summary(request):
    date = timezone.now() - relativedelta(months=1)
    from_date = utils.get_month_start(date).date()
    to_date = from_date + relativedelta(months=1)

    year_month_form = PayrollSummaryReportForm(request.GET or None,
        initial={'month': from_date.month, 'year': from_date.year})

    if year_month_form.is_valid():
        from_date, to_date = year_month_form.save()
    last_billable = utils.get_last_billable_day(from_date)
    projects = utils.get_setting('TIMEPIECE_PAID_LEAVE_PROJECTS')
    weekQ = Q(end_time__gt=utils.get_week_start(from_date),
              end_time__lt=last_billable + relativedelta(days=1))
    monthQ = Q(end_time__gt=from_date, end_time__lt=to_date)
    workQ = ~Q(project__in=projects.values())
    statusQ = Q(status=Entry.INVOICED) | Q(status=Entry.APPROVED)
    # Weekly totals
    week_entries = Entry.objects.date_trunc('week').filter(
        weekQ, statusQ, workQ
    )
    date_headers = generate_dates(from_date, last_billable, by='week')
    weekly_totals = list(get_project_totals(week_entries, date_headers,
                                              'total', overtime=True))
    # Monthly totals
    leave = Entry.objects.filter(monthQ, ~workQ
                                  ).values('user', 'hours', 'project__name')
    extra_values = ('project__type__label',)
    month_entries = Entry.objects.date_trunc('month', extra_values)
    month_entries_valid = month_entries.filter(monthQ, statusQ, workQ)
    labels, monthly_totals = get_payroll_totals(month_entries_valid, leave)
    # Unapproved and unverified hours
    entries = Entry.objects.filter(monthQ).order_by()  # No ordering
    user_values = ['user__pk', 'user__first_name', 'user__last_name']
    unverified = entries.filter(status=Entry.UNVERIFIED, user__is_active=True) \
                        .values_list(*user_values).distinct()
    unapproved = entries.filter(status=Entry.VERIFIED) \
                        .values_list(*user_values).distinct()
    return render(request, 'timepiece/reports/payroll_summary.html', {
        'from_date': from_date,
        'year_month_form': year_month_form,
        'date_headers': date_headers,
        'weekly_totals': weekly_totals,
        'monthly_totals': monthly_totals,
        'unverified': unverified,
        'unapproved': unapproved,
        'labels': labels,
    })


@permission_required('entries.view_entry_summary')
def report_productivity(request):
    report = []
    organize_by = None

    form = ProductivityReportForm(request.GET or None)
    if form.is_valid():
        project = form.cleaned_data['project']
        organize_by = form.cleaned_data['organize_by']
        export = request.GET.get('export', False)

        actualsQ = Q(project=project, end_time__isnull=False)
        actuals = Entry.objects.filter(actualsQ)
        projections = ProjectHours.objects.filter(project=project)
        entry_count = actuals.count() + projections.count()

        if organize_by == 'week' and entry_count > 0:
            # Determine the project's time range.
            amin, amax, pmin, pmax = (None, None, None, None)
            if actuals.count() > 0:
                amin = actuals.aggregate(Min('start_time')).values()[0]
                amin = utils.get_week_start(amin).date()
                amax = actuals.aggregate(Max('start_time')).values()[0]
                amax = utils.get_week_start(amax).date()
            if projections.count() > 0:
                pmin = projections.aggregate(Min('week_start')).values()[0]
                pmax = projections.aggregate(Max('week_start')).values()[0]
            current = min(amin, pmin) if (amin and pmin) else (amin or pmin)
            latest = max(amax, pmax) if (amax and pmax) else (amax or pmax)

            # Report for each week during the project's time range.
            while current <= latest:
                next_week = current + relativedelta(days=7)
                actual_hours = actuals.filter(start_time__gte=current,
                        start_time__lt=next_week).aggregate(
                        Sum('hours')).values()[0]
                projected_hours = projections.filter(week_start__gte=current,
                        week_start__lt=next_week).aggregate(
                        Sum('hours')).values()[0]
                report.append([date_format_filter(current, 'M j, Y'),
                        actual_hours or 0, projected_hours or 0])
                current = next_week

        elif organize_by == 'user' and entry_count > 0:
            # Determine all users who worked on or were assigned to the
            # project.
            vals = ('user', 'user__first_name', 'user__last_name')
            ausers = list(actuals.values_list(*vals).distinct())
            pusers = list(projections.values_list(*vals).distinct())
            key = lambda x: (x[1] + x[2]).lower()  # Sort by name
            users = sorted(list(set(ausers + pusers)), key=key)

            # Report for each user.
            for user in users:
                name = '{0} {1}'.format(user[1], user[2])
                actual_hours = actuals.filter(user=user[0]) \
                        .aggregate(Sum('hours')).values()[0]
                projected_hours = projections.filter(user=user[0]) \
                        .aggregate(Sum('hours')).values()[0]
                report.append([name, actual_hours or 0, projected_hours or 0])

        col_headers = [organize_by.title(), 'Worked Hours', 'Assigned Hours']
        report.insert(0, col_headers)

        if export:
            response = HttpResponse(content_type='text/csv')
            filename = '{0}_productivity'.format(project.name)
            content_disp = 'attachment; filename={0}.csv'.format(filename)
            response['Content-Disposition'] = content_disp
            writer = csv.writer(response)
            for row in report:
                writer.writerow(row)
            return response

    return render(request, 'timepiece/reports/productivity.html', {
        'form': form,
        'report': json.dumps(report, cls=DecimalEncoder),
        'type': organize_by or '',
        'total_worked': sum([r[1] for r in report[1:]]),
        'total_assigned': sum([r[2] for r in report[1:]]),
    })

@permission_required('contracts.view_estimation_accuracy')
def report_estimation_accuracy(request):
    """
    Idea from Software Estimation, Demystifying the Black Art, McConnel 2006 Fig 3-3.
    """
    contracts = ProjectContract.objects.filter(
        status=ProjectContract.STATUS_COMPLETE,
        type=ProjectContract.PROJECT_FIXED
    )
    data = [('Target (hrs)', 'Actual (hrs)', 'Point Label')]
    for c in contracts:
        if c.contracted_hours() == 0:
            continue
        pt_label = "%s (%.2f%%)" % (c.name, 
                                    c.hours_worked / c.contracted_hours() * 100)
        data.append((c.contracted_hours(), c.hours_worked, pt_label))
        chart_max = max([max(x[0], x[1]) for x in data[1:]]) #max of all targets & actuals
    return render(request, 'timepiece/reports/estimation_accuracy.html', {
        'data': json.dumps(data, cls=DecimalEncoder),
        'chart_max': chart_max,
    })

########NEW FILE########
__FILENAME__ = timepiece_tags
import datetime
from dateutil.relativedelta import relativedelta
import urllib

from django import template
from django.core.urlresolvers import reverse
from django.db.models import Sum
from django.template.defaultfilters import date as date_format_filter
from django.utils.safestring import mark_safe

from timepiece import utils
from timepiece.forms import DATE_FORM_FORMAT


register = template.Library()


@register.filter
def add_parameters(url, parameters):
    """
    Appends URL-encoded parameters to the base URL. It appends after '&' if
    '?' is found in the URL; otherwise it appends using '?'. Keep in mind that
    this tag does not take into account the value of existing params; it is
    therefore possible to add another value for a pre-existing parameter.

    For example::

        {% url 'this_view' as current_url %}
        {% with complete_url=current_url|add_parameters:request.GET %}
            The <a href="{% url 'other' %}?next={{ complete_url|urlencode }}">
            other page</a> will redirect back to the current page (including
            any GET parameters).
        {% endwith %}
    """
    if parameters:
        sep = '&' if '?' in url else '?'
        return '{0}{1}{2}'.format(url, sep, urllib.urlencode(parameters))
    return url


@register.filter
def add_timezone(date, tz=None):
    """Return the given date with timezone added."""
    return utils.add_timezone(date, tz)


@register.assignment_tag
def create_dict(**kwargs):
    """Utility to create a dictionary from keyword arguments."""
    return kwargs


@register.inclusion_tag('timepiece/date_filters.html')
def date_filters(form_id, options=None, use_range=True):
    if not options:
        options = ('months', 'quarters', 'years')
    filters = {}
    date_format = DATE_FORM_FORMAT  # Expected for dates used in code
    today = datetime.date.today()
    single_day = relativedelta(days=1)
    single_month = relativedelta(months=1)
    single_year = relativedelta(years=1)

    if 'months' in options:
        filters['Past 12 Months'] = []
        from_date = today.replace(day=1) + single_month
        for x in range(12):
            to_date = from_date
            from_date = to_date - single_month
            to_date = to_date - single_day
            filters['Past 12 Months'].append((
                    date_format_filter(from_date, 'M Y'),  # displayed
                    from_date.strftime(date_format) if use_range else "",  # used in code
                    to_date.strftime(date_format)  # used in code
            ))
        filters['Past 12 Months'].reverse()

    if 'years' in options:
        filters['Years'] = []
        start = today.year - 3
        for year in range(start, start + 4):
            from_date = datetime.datetime(year, 1, 1)
            to_date = from_date + single_year - single_day
            filters['Years'].append((
                    str(from_date.year),
                    from_date.strftime(date_format) if use_range else "",
                    to_date.strftime(date_format)
            ))

    if 'quarters' in options:
        filters['Quarters (Calendar Year)'] = []
        to_date = datetime.date(today.year - 1, 1, 1) - single_day
        for x in range(8):
            from_date = to_date + single_day
            to_date = from_date + relativedelta(months=3) - single_day
            filters['Quarters (Calendar Year)'].append((
                    'Q%s %s' % ((x % 4) + 1, from_date.year),
                    from_date.strftime(date_format) if use_range else "",
                    to_date.strftime(date_format)
            ))

    return {'filters': filters, 'form_id': form_id}


@register.simple_tag(takes_context=True)
def get_max_hours(context):
    """Return the largest number of hours worked or assigned on any project."""
    progress = context['project_progress']
    return max([0] + [max(p['worked'], p['assigned']) for p in progress])


@register.simple_tag
def get_uninvoiced_hours(entries, billable=None):
    """Given an iterable of entries, return the total hours that have
    not been invoices. If billable is passed as 'billable' or 'nonbillable',
    limit to the corresponding entries.
    """
    statuses = ('invoiced', 'not-invoiced')
    if billable is not None:
        billable = (billable.lower() == u'billable')
        entries = [e for e in entries if e.activity.billable == billable]
    hours = sum([e.hours for e in entries if e.status not in statuses])
    return hours


@register.filter
def humanize_hours(total_hours, frmt='{hours:02d}:{minutes:02d}:{seconds:02d}',
        negative_frmt=None):
    """Given time in hours, return a string representing the time."""
    seconds = int(float(total_hours) * 3600)
    return humanize_seconds(seconds, frmt, negative_frmt)


@register.filter
def humanize_seconds(total_seconds,
        frmt='{hours:02d}:{minutes:02d}:{seconds:02d}', negative_frmt=None):
    """Given time in int(seconds), return a string representing the time.

    If negative_frmt is not given, a negative sign is prepended to frmt
    and the result is wrapped in a <span> with the "negative-time" class.
    """
    if negative_frmt is None:
        negative_frmt = '<span class="negative-time">-{0}</span>'.format(frmt)
    seconds = abs(int(total_seconds))
    mapping = {
        'hours': seconds // 3600,
        'minutes': seconds % 3600 // 60,
        'seconds': seconds % 3600 % 60,
    }
    if total_seconds < 0:
        result = negative_frmt.format(**mapping)
    else:
        result = frmt.format(**mapping)
    return mark_safe(result)


@register.filter
def multiply(a, b):
    """Return a * b."""
    return float(a) * float(b)


@register.assignment_tag
def project_hours_for_contract(contract, project, billable=None):
    """Total billable hours worked on project for contract.
    If billable is passed as 'billable' or 'nonbillable', limits to
    the corresponding hours.  (Must pass a variable name first, of course.)
    """
    hours = contract.entries.filter(project=project)
    if billable is not None:
        if billable in (u'billable', u'nonbillable'):
            billable = (billable.lower() == u'billable')
            hours = hours.filter(activity__billable=billable)
        else:
            msg = '`project_hours_for_contract` arg 4 must be "billable" ' \
                  'or "nonbillable"'
            raise template.TemplateSyntaxError(msg)
    hours = hours.aggregate(s=Sum('hours'))['s'] or 0
    return hours


@register.simple_tag
def project_report_url_for_contract(contract, project):
    data = {
        'from_date': contract.start_date.strftime(DATE_FORM_FORMAT),
        'to_date': contract.end_date.strftime(DATE_FORM_FORMAT),
        'billable': 1,
        'non_billable': 0,
        'paid_leave': 0,
        'trunc': 'month',
        'projects_1': project.id,
    }
    return '{0}?{1}'.format(reverse('report_hourly'), urllib.urlencode(data))


@register.simple_tag
def project_timesheet_url(project_id, date=None):
    """Shortcut to create a time sheet URL with optional date parameters."""
    return _timesheet_url('view_project_timesheet', project_id, date)


@register.filter
def seconds_to_hours(seconds):
    """Given time in int seconds, return decimal seconds."""
    return round(seconds / 3600.0, 2)


@register.assignment_tag
def sum_hours(entries):
    """Return the sum total of get_total_seconds() for each entry."""
    return sum([e.get_total_seconds() for e in entries])


def _timesheet_url(url_name, pk, date=None):
    """Utility to create a time sheet URL with optional date parameters."""
    url = reverse(url_name, args=(pk,))
    if date:
        params = {'month': date.month, 'year': date.year}
        return '?'.join((url, urllib.urlencode(params)))
    return url


@register.simple_tag
def user_timesheet_url(user_id, date=None):
    """Shortcut to create a time sheet URL with optional date parameters."""
    return _timesheet_url('view_user_timesheet', user_id, date)


@register.filter
def week_start(date):
    """Return the starting day of the week with the given date."""
    return utils.get_week_start(date)

########NEW FILE########
__FILENAME__ = base
from urllib import urlencode
from urlparse import parse_qs, urlparse

from dateutil.relativedelta import relativedelta

from django.core.urlresolvers import reverse, reverse_lazy
from django.conf import settings
from django.contrib.auth import login
from django.http import HttpRequest
from django.utils import timezone
from django.utils.encoding import force_unicode

from . import factories


class ViewTestMixin(object):
    """Utilities for more easily testing views."""
    url_name = ''  # Must be defined by implementing class.

    # These may be defined as either attributes or properties on the
    # implementing class.
    url_kwargs = {}
    url_args = {}
    get_kwargs = {}
    post_data = {}

    login_url = reverse_lazy('auth_login')

    def _url(self, url_name=None, url_args=None, url_kwargs=None,
            get_kwargs=None):
        """Builds a URL with reverse(), then adds GET parameters."""
        url_name = url_name or self.url_name
        url_args = self.url_args if url_args is None else url_args
        url_kwargs = self.url_kwargs if url_kwargs is None else url_kwargs
        get_kwargs = self.get_kwargs if get_kwargs is None else get_kwargs

        url = reverse(url_name, args=url_args, kwargs=url_kwargs)
        if get_kwargs:
            url = '{0}?{1}'.format(url, urlencode(get_kwargs, doseq=True))
        return url

    def _get(self, url_name=None, url_args=None, url_kwargs=None,
            get_kwargs=None, url=None, *args, **kwargs):
        """Convenience wrapper for self.client.get.

        If url is not passed, it is built using url_name, url_args, url_kwargs.
        Get parameters may be added from get_kwargs.
        """
        url = url or self._url(url_name, url_args, url_kwargs, get_kwargs)
        return self.client.get(path=url, *args, **kwargs)

    def _post(self, data=None, url_name=None, url_args=None,
            url_kwargs=None, get_kwargs=None, url=None, *args, **kwargs):
        """Convenience wrapper for self.client.post.

        If url is not passed, it is built using url_name, url_args, url_kwargs.
        Get parameters may be added from get_kwargs.
        """
        url = url or self._url(url_name, url_args, url_kwargs, get_kwargs)
        data = self.post_data if data is None else data
        return self.client.post(path=url, data=data, *args, **kwargs)

    def _post_ajax(self, *args, **kwargs):
        """Convenience wrapper for making an AJAX post."""
        kwargs.setdefault('HTTP_X_REQUESTED_WITH', 'XMLHttpRequest')
        return self._post(*args, **kwargs)

    def _post_raw(self, *args, **kwargs):
        """
        By default, the Django test client interprets POST data as a
        dictionary. By using a different content type, it will take the data
        as is.
        """
        kwargs.setdefault('content_type', 'application/x-www-form-urlencoded')
        return self._post(*args, **kwargs)

    def assertRedirectsNoFollow(self, response, expected_url, use_params=True,
            status_code=302):
        """Checks response redirect without loading the destination page.

        Django's assertRedirects method loads the destination page, which
        requires that the page be renderable in the current test context
        (possibly requiring additional, unrelated setup).
        """
        # Assert that the response has the correct redirect code.
        self.assertEqual(response.status_code, status_code,
                "Response didn't redirect as expected: Response code was {0} "
                "(expected {1})".format(response.status_code, status_code))

        # Assert that the response redirects to the correct base URL.
        # Use force_unicode to force evaluation of anything created by
        # reverse_lazy.
        response_url = force_unicode(response['location'])
        expected_url = force_unicode(expected_url)
        parsed1 = urlparse(response_url)
        parsed2 = urlparse(expected_url)
        self.assertEquals(parsed1.path, parsed2.path,
                "Response did not redirect to the expected URL: Redirect "
                "location was {0} (expected {1})".format(parsed1.path,
                parsed2.path))

        # Optionally assert that the response redirect URL has the correct
        # GET parameters.
        if use_params:
            self.assertDictEqual(parse_qs(parsed1.query),
                    parse_qs(parsed2.query), "Response did not have the GET "
                    "parameters expected: GET parameters were {0} (expected "
                    "{1})".format(parsed1.query or {}, parsed2.query or {}))

    def assertRedirectsToLogin(self, response, login_url=None,
            use_params=False, status_code=302):
        login_url = login_url or self.login_url
        return self.assertRedirectsNoFollow(response, login_url, use_params,
                status_code)

    def login_user(self, user, strict=True):
        """Log in a user without need for a password.

        Adapted from
        http://jameswestby.net/weblog/tech/17-directly-logging-in-a-user-in-django-tests.html
        """
        user.backend = 'django.contrib.auth.backends.ModelBackend'
        engine = __import__(settings.SESSION_ENGINE, fromlist=['SessionStore'])

        # Create a fake request to store login details.
        request = HttpRequest()
        if self.client.session:
            request.session = self.client.session
        else:
            request.session = engine.SessionStore()
        login(request, user)

        # Set the cookie to represent the session.
        session_cookie = settings.SESSION_COOKIE_NAME
        self.client.cookies[session_cookie] = request.session.session_key
        cookie_data = {
            'max-age': None,
            'path': '/',
            'domain': settings.SESSION_COOKIE_DOMAIN,
            'secure': settings.SESSION_COOKIE_SECURE or None,
            'expires': None,
        }
        self.client.cookies[session_cookie].update(cookie_data)

        # Save the session values.
        request.session.save()


class LogTimeMixin(object):

    def log_time(self, delta=None, billable=True, project=None, start=None,
            end=None, status=None, pause=0, activity=None, user=None):
        if not user:
            user = self.user
        if delta and not end:
            hours, minutes = delta
        else:
            hours = 4
            minutes = 0
        if not start:
            start = timezone.now() - relativedelta(hour=0)
            #In case the default would fall off the end of the billing period
            if start.day >= 28:
                start -= relativedelta(days=1)
        if not end:
            end = start + relativedelta(hours=hours, minutes=minutes)
        data = {'user': user,
                'start_time': start,
                'end_time': end,
                'seconds_paused': pause,
                }
        if project:
            data['project'] = project
        else:
            data['project'] = factories.BillableProject()
        if activity:
            data['activity'] = activity
        else:
            if billable:
                data['activity'] = self.devl_activity
            else:
                data['activity'] = self.activity
        if status:
            data['status'] = status
        return factories.Entry(**data)

########NEW FILE########
__FILENAME__ = factories
import datetime
from dateutil.relativedelta import relativedelta
from decimal import Decimal
import factory
from factory.fuzzy import FuzzyDate, FuzzyInteger
import random

from django.contrib.auth import models as auth
from django.contrib.auth.hashers import make_password

from timepiece.contracts import models as contracts
from timepiece.crm import models as crm
from timepiece.entries import models as entries
from timepiece import utils


class User(factory.DjangoModelFactory):
    FACTORY_FOR = auth.User

    # FIXME: Some tests depend on first_name/last_name being unique.
    first_name = factory.Sequence(lambda n: 'Sam{0}'.format(n))
    last_name = factory.Sequence(lambda n: 'Blue{0}'.format(n))
    username = factory.Sequence(lambda n: 'user{0}'.format(n))
    email = factory.Sequence(lambda n: 'user{0}@example.com'.format(n))
    password = factory.LazyAttribute(lambda n: make_password('password'))

    @factory.post_generation
    def permissions(self, create, extracted, **kwargs):
        if create and extracted:
            for perm in extracted:
                if isinstance(perm, basestring):
                    app_label, codename = perm.split('.')
                    perm = auth.Permission.objects.get(
                        content_type__app_label=app_label,
                        codename=codename,
                    )
                self.user_permissions.add(perm)


class Superuser(User):
    is_superuser = True
    is_staff = True


class Group(factory.DjangoModelFactory):
    FACTORY_FOR = auth.Group

    name = factory.Sequence(lambda n: 'group{0}'.format(n))


class ProjectContract(factory.DjangoModelFactory):
    FACTORY_FOR = contracts.ProjectContract

    name = factory.Sequence(lambda n: 'contract{0}'.format(n))
    start_date = datetime.date.today()
    end_date = datetime.date.today() + relativedelta(weeks=2)
    status = contracts.ProjectContract.STATUS_CURRENT,
    type = contracts.ProjectContract.PROJECT_PRE_PAID_HOURLY

    @factory.post_generation
    def contract_hours(self, create, extracted, **kwargs):
        if create:
            num_hours = extracted or random.randint(10, 400)
            for i in range(2):
                ContractHour(contract=self,
                        hours=Decimal(str(num_hours/2.0)))

    @factory.post_generation
    def projects(self, create, extracted, **kwargs):
        if create and extracted:
            self.projects.add(*extracted)


class ContractHour(factory.DjangoModelFactory):
    FACTORY_FOR = contracts.ContractHour

    date_requested = datetime.date.today()
    status = contracts.ContractHour.APPROVED_STATUS
    contract = factory.SubFactory('timepiece.tests.factories.ProjectContract')


class ContractAssignment(factory.DjangoModelFactory):
    FACTORY_FOR = contracts.ContractAssignment

    user = factory.SubFactory('timepiece.tests.factories.User')
    contract = factory.SubFactory('timepiece.tests.factories.ProjectContract')
    start_date = datetime.date.today()
    end_date = datetime.date.today() + relativedelta(weeks=2)


class HourGroup(factory.DjangoModelFactory):
    FACTORY_FOR = contracts.HourGroup

    name = factory.Sequence(lambda n: 'hourgroup{0}'.format(n))


class EntryGroup(factory.DjangoModelFactory):
    FACTORY_FOR = contracts.EntryGroup

    user = factory.SubFactory('timepiece.tests.factories.User')
    project = factory.SubFactory('timepiece.tests.factories.Project')
    end = FuzzyDate(datetime.date.today() - relativedelta(months=1))

class TypeAttribute(factory.DjangoModelFactory):
    FACTORY_FOR = crm.Attribute

    label = factory.Sequence(lambda n: 'type{0}'.format(n))
    type = crm.Attribute.PROJECT_TYPE


class StatusAttribute(factory.DjangoModelFactory):
    FACTORY_FOR = crm.Attribute

    label = factory.Sequence(lambda n: 'status{0}'.format(n))
    type = crm.Attribute.PROJECT_STATUS


class Business(factory.DjangoModelFactory):
    FACTORY_FOR = crm.Business

    name = factory.Sequence(lambda n: 'business{0}'.format(n))


class Project(factory.DjangoModelFactory):
    FACTORY_FOR = crm.Project

    name = factory.Sequence(lambda n: 'project{0}'.format(n))
    business = factory.SubFactory('timepiece.tests.factories.Business')
    point_person = factory.SubFactory('timepiece.tests.factories.User')
    type = factory.SubFactory('timepiece.tests.factories.TypeAttribute')
    status = factory.SubFactory('timepiece.tests.factories.StatusAttribute')


class BillableProject(Project):
    type = factory.SubFactory('timepiece.tests.factories.TypeAttribute', billable=True)
    status = factory.SubFactory('timepiece.tests.factories.StatusAttribute', billable=True)


class NonbillableProject(Project):
    type = factory.SubFactory('timepiece.tests.factories.TypeAttribute', billable=False)
    status = factory.SubFactory('timepiece.tests.factories.StatusAttribute', billable=False)


class RelationshipType(factory.DjangoModelFactory):
    FACTORY_FOR = crm.RelationshipType

    name = factory.Sequence(lambda n: 'reltype{0}'.format(n))


class ProjectRelationship(factory.DjangoModelFactory):
    FACTORY_FOR = crm.ProjectRelationship

    user = factory.SubFactory('timepiece.tests.factories.User')
    project = factory.SubFactory('timepiece.tests.factories.Project')


class UserProfile(factory.DjangoModelFactory):
    FACTORY_FOR = crm.UserProfile

    user = factory.SubFactory('timepiece.tests.factories.User')


class Activity(factory.DjangoModelFactory):
    FACTORY_FOR = entries.Activity

    code = factory.Sequence(lambda n: 'a{0}'.format(n))
    name = factory.Sequence(lambda n: 'activity{0}'.format(n))


class BillableActivityFactory(Activity):
    billable = True


class NonbillableActivityFactory(Activity):
    billable = False


class ActivityGroup(factory.DjangoModelFactory):
    FACTORY_FOR = entries.ActivityGroup

    name = factory.Sequence(lambda n: 'activitygroup{0}'.format(n))


class Location(factory.DjangoModelFactory):
    FACTORY_FOR = entries.Location

    name = factory.Sequence(lambda n: 'location{0}'.format(n))
    slug = factory.Sequence(lambda n: 'location{0}'.format(n))


class Entry(factory.DjangoModelFactory):
    FACTORY_FOR = entries.Entry

    status = entries.Entry.UNVERIFIED
    user = factory.SubFactory('timepiece.tests.factories.User')
    activity = factory.SubFactory('timepiece.tests.factories.Activity')
    project = factory.SubFactory('timepiece.tests.factories.Project')
    location = factory.SubFactory('timepiece.tests.factories.Location')


class ProjectHours(factory.DjangoModelFactory):
    FACTORY_FOR = entries.ProjectHours

    week_start = utils.get_week_start()
    project = factory.SubFactory('timepiece.tests.factories.Project')
    user = factory.SubFactory('timepiece.tests.factories.User')
    hours = FuzzyInteger(0, 20)

########NEW FILE########
__FILENAME__ = test_management
from dateutil.relativedelta import relativedelta

from django.utils import timezone
from django.test import TestCase

from timepiece import utils
from timepiece.management.commands import check_entries
from timepiece.entries.models import Entry

from . import factories


class CheckEntries(TestCase):

    def setUp(self):
        super(CheckEntries, self).setUp()
        self.user = factories.User()
        self.user2 = factories.User()
        self.superuser = factories.Superuser()
        self.project = factories.Project(type__enable_timetracking=True,
                status__enable_timetracking=True, point_person=self.user)

        self.default_data = {
            'user': self.user,
            'project': self.project,
            'seconds_paused': 0,
            'status': Entry.VERIFIED,
        }
        self.good_start = timezone.now() - relativedelta(days=0, hours=8)
        self.good_end = timezone.now() - relativedelta(days=0)
        self.bad_start = timezone.now() - relativedelta(days=1, hours=8)
        self.bad_end = timezone.now() - relativedelta(days=1)
        #Create users for the test
        self.user.first_name = 'first1'
        self.user.last_name = 'last1'
        self.user.save()
        self.user2.first_name = 'first2'
        self.user2.last_name = 'last2'
        self.user2.save()
        self.all_users = [self.user, self.user2, self.superuser]
        #Create a valid entry for all users on every day since 60 days ago
        self.make_entry_bulk(self.all_users, 60)

    #helper functions
    def make_entry(self, **kwargs):
        """
        Make a valid or invalid entry
        make_entry(**kwargs)
        **kwargs can include: start_time, end_time, valid
        Without any kwargs, make_entry makes a valid entry. (first time called)
        With valid=False, makes an invalid entry
        start_time and end_time can be specified.
        If start_time is used without end_time, end_time is 10 mintues later
        """
        valid = kwargs.get('valid', True)
        if valid:
            default_start = self.good_start
            default_end = self.good_end
        else:
            default_start = self.bad_start
            default_end = self.bad_end
        user = kwargs.get('user', self.user)
        start = kwargs.get('start_time', default_start)
        if 'end_time' in kwargs:
            end = kwargs.get('end_time', default_end)
        else:
            if 'start_time' in kwargs:
                end = start + relativedelta(minutes=10)
            else:
                end = default_end
        data = self.default_data
        data.update({
            'user': user,
            'start_time': start,
            'end_time': end,
        })
        factories.Entry(**data)

    def make_entry_bulk(self, users, days, *args, **kwargs):
        """
        Create entries for users listed, from n days ago (but not today)
        make_entry_bulk(users_list, num_days)
        """
        #Test cases may create overlapping entries later
        for user in users:
            self.default_data.update({'user': user})
            #Range uses 1 so that good_start/good_end use today as valid times.
            for day in range(1, days + 1):
                self.default_data.update({
                    'start_time': timezone.now() - \
                                  relativedelta(days=day, minutes=1),
                    'end_time': timezone.now() - relativedelta(days=day,)
                })
                factories.Entry(**self.default_data)

    #tests
    def testFindStart(self):
        """
        With various kwargs, find_start should return the correct date
        """
        #Establish some datetimes
        now = timezone.now()
        today = now - relativedelta(
            hour=0, minute=0, second=0, microsecond=0)
        last_billing = today - relativedelta(months=1, day=1)
        yesterday = today - relativedelta(days=1)
        ten_days_ago = today - relativedelta(days=10)
        thisweek = utils.get_week_start(today)
        thismonth = today - relativedelta(day=1)
        thisyear = today - relativedelta(month=1, day=1)
        #Use command flags to obtain datetimes
        start_default = check_entries.Command().find_start()
        start_yesterday = check_entries.Command().find_start(days=1)
        start_ten_days_ago = check_entries.Command().find_start(days=10)
        start_of_week = check_entries.Command().find_start(week=True)
        start_of_month = check_entries.Command().find_start(month=True)
        start_of_year = check_entries.Command().find_start(year=True)
        #assure the returned datetimes are correct
        self.assertEqual(start_default, last_billing)
        self.assertEqual(start_yesterday, yesterday)
        self.assertEqual(start_ten_days_ago, ten_days_ago)
        self.assertEqual(start_of_week, thisweek)
        self.assertEqual(start_of_month, thismonth)
        self.assertEqual(start_of_year, thisyear)

    def testFindUsers(self):
        """
        With args, find_users should search and return those user objects
        Without args, find_users should return all user objects
        """
        #Find one user by icontains first or last name, return all if no args
        users1 = check_entries.Command().find_users('firsT1')
        users2 = check_entries.Command().find_users('LasT2')
        all_users = check_entries.Command().find_users()
        #obtain instances from the querysets
        user1 = users1.get(pk=self.user.pk)
        user2 = users2.get(pk=self.user2.pk)
        all_1 = all_users.get(pk=self.user.pk)
        all_2 = all_users.get(pk=self.user2.pk)
        all_3 = all_users.get(pk=self.superuser.pk)
        self.assertEqual(users1.count(), 1)
        self.assertEqual(users2.count(), 1)
        self.assertEqual(all_users.count(), 3)
        self.assertEqual(user1, self.user)
        self.assertEqual(user2, self.user2)
        self.assertEqual(all_1, user1)
        self.assertEqual(all_2, user2)
        self.assertEqual(all_3, self.superuser)

    def testFindEntries(self):
        """
        Given a list of users and a starting point, entries should generate a
        list of all entries for each user from that time until now.
        """
        start = check_entries.Command().find_start()
        if start.day == 1:
            start += relativedelta(days=1)
        all_users = check_entries.Command().find_users()
        entries = check_entries.Command().find_entries(all_users, start)
        #Determine the number of days checked
        today = timezone.now() - \
            relativedelta(hour=0, minute=0, second=0, microsecond=0)
        diff = today - start
        days_checked = diff.days
        total_entries = 0
        while True:
            try:
                user_entries = entries.next()
                for entry in user_entries:
                    total_entries += 1
            except StopIteration:
                #Verify that every entry from the start point was returned
                expected_total = days_checked * len(self.all_users)
                self.assertEqual(total_entries, expected_total)
                return

    def testCheckEntry(self):
        """
        Given lists of entries from users, check_entry should return all
        overlapping entries.
        """
        start = check_entries.Command().find_start()
        all_users = check_entries.Command().find_users()
        entries = check_entries.Command().find_entries(all_users, start)
        total_overlaps = 0
        #make some bad entries
        num_days = 5
        self.make_entry_bulk(self.all_users, num_days)
        while True:
            try:
                user_entries = entries.next()
                user_overlaps = check_entries.Command().check_entry(
                    user_entries, verbosity=0)
                total_overlaps += user_overlaps
            except StopIteration:
                self.assertEqual(
                    total_overlaps, num_days * len(self.all_users))
                return

########NEW FILE########
__FILENAME__ = test_templatetags
import datetime
from dateutil.relativedelta import relativedelta
import mock

from django import template
from django.test import TestCase
from django.utils.html import strip_tags

from timepiece import utils
from timepiece.templatetags import timepiece_tags as tags

from . import factories


class HumanizeTimeTestCase(TestCase):

    def test_seconds(self):
        seconds_display = tags.humanize_seconds((5.5 * 3600) + 3)
        expected = u'05:30:03'
        self.assertEquals(seconds_display, expected,
            "Should return {0}, returned {1}".format(expected, seconds_display)
        )

    def test_seconds_negative(self):
        seconds_display = tags.humanize_seconds((-2.5 * 3600) - 4)
        expected = u'-02:30:04'
        self.assertTrue(seconds_display.startswith('<span'))
        self.assertTrue('negative-time' in seconds_display)
        self.assertEquals(strip_tags(seconds_display), expected,
            "Should return {0}, returned {1}".format(expected, seconds_display)
        )

    def test_seconds_overnight(self):
        seconds_display = tags.humanize_seconds((30 * 3600) + 2)
        expected = u'30:00:02'
        self.assertEquals(seconds_display, expected,
            "Should return {0}, returned {1}".format(expected, seconds_display)
        )

    def test_seconds_format(self):
        seconds_display = tags.humanize_seconds(120, '{minutes:02d}:{minutes}')
        expected = u'02:2'
        self.assertEquals(seconds_display, expected,
            "Should return {0}, returned {1}".format(expected, seconds_display)
        )

    def test_seconds_negative_format(self):
        seconds_display = tags.humanize_seconds(-120, None, '-{minutes:02d}')
        expected = u'-02'
        self.assertEquals(seconds_display, expected,
            "Should return {0}, returned {1}".format(expected, seconds_display)
        )

    def test_hours(self):
        hours_display = tags.humanize_hours(7.5)
        expected = u'07:30:00'
        self.assertEquals(hours_display, expected,
            "Should return {0}, returned {1}".format(expected, hours_display)
        )

    def test_hours_format(self):
        hours_display = tags.humanize_hours(7.1, '{minutes:02d}:{minutes}')
        expected = u'06:6'
        self.assertEquals(hours_display, expected,
            "Should return {0}, returned {1}".format(expected, hours_display)
        )


class DateFiltersTagTestCase(TestCase):

    def test_default_options(self):
        # default everything we can
        # response looks like the right format roughly
        retval = tags.date_filters("FORM_ID")
        self.assertEqual("FORM_ID", retval['form_id'])
        filters = retval['filters']
        self.assertIn("Past 12 Months", filters)
        self.assertIn("Years", filters)
        self.assertIn("Quarters (Calendar Year)", filters)
        self.assertEqual(3, len(filters))
        self.assertEqual(2, len(retval))

    def test_months(self):
        # Look more closely at months response
        retval = tags.date_filters("FORM_ID", options=('months',))
        filter = retval['filters']['Past 12 Months']
        self.assertEqual(12, len(filter))
        for name, first_date, last_date in filter:
            # same month  "20xx-mm-dd"
            self.assertEqual(first_date[4:7], last_date[4:7])
            # same year
            self.assertEqual(first_date[:5], last_date[:5])
            # starts on the first
            self.assertEqual("-01", first_date[-3:])

    def test_years(self):
        # Look more closely at years response
        retval = tags.date_filters("FORM_ID", options=('years',))
        filter = retval['filters']['Years']
        self.assertEqual(4, len(filter))
        for year, first_date, last_date in filter:
            # start on jan 1, 20xx  "20xx-01-01"
            self.assertTrue(first_date.startswith("20") and first_date.endswith("-01-01"))
            # end on Dec. 31, 20xx  "20xx-12-31"
            self.assertTrue(last_date.startswith("20") and last_date.endswith("-12-31"))
            # start and end in same year, "20xx-"
            self.assertEqual(year, first_date[:4])
            self.assertEqual(year, last_date[:4])

    def test_quarters(self):
        # Look more closely at quarters response
        retval = tags.date_filters("FORM_ID", options=('quarters',))
        filter = retval['filters']['Quarters (Calendar Year)']
        self.assertEqual(8, len(filter))
        for name, first_date, last_date in filter:
            self.assertTrue(name.startswith("Q"))
            # starts on the first  "20xx-yy-01"
            self.assertEqual("-01", first_date[-3:])
            # start in the quarter we claim to
            self.assertEqual(name[-4:], first_date[:4])
            # start and end in same year
            self.assertEqual(first_date[:5], last_date[:5])

    def test_no_use_range(self):
        # sniff test of turning off use_range
        retval = tags.date_filters("FORM_ID", options=('years',),
            use_range=False)
        filter = retval['filters']['Years']
        for year, first_date, last_date in filter:
            # first date is blank
            self.assertEqual('', first_date)


class TimeTagTestCase(TestCase):

    def test_seconds_to_hours(self):
        # basic math
        self.assertEqual(0.5, tags.seconds_to_hours(1800))
        self.assertEqual(2.0, tags.seconds_to_hours(7200))
        # rounding
        self.assertEqual(2.0, tags.seconds_to_hours(7201))

    def test_week_start(self):
        start = tags.week_start(datetime.date(2013, 1, 10))
        self.assertEqual(start.date(), datetime.date(2013, 1, 7))


class MiscTagTestCase(TestCase):

    def test_get_uninvoiced_hours(self):
        # uninvoiced hours are any hours without status 'invoiced' or
        # 'not-invoiced' [sic]
        class Entry(object):
            def __init__(self, status, hours):
                self.status = status
                self.hours = hours
        entries = [
            Entry('invoiced', 999),
            Entry('not-invoiced', 1),
            Entry('other', 37),
            Entry('shoes', 12)
        ]
        retval = tags.get_uninvoiced_hours(entries)
        self.assertEqual(49, retval)

    def test_project_report_url_for_contract(self):
        with mock.patch('timepiece.templatetags.timepiece_tags.reverse')\
        as reverse:
            reverse.return_value = "Boo"
            dt = datetime.date(2013, 1, 10)
            contract = mock.Mock(start_date=dt, end_date=dt)
            project = mock.Mock(id=54)
            retval = tags.project_report_url_for_contract(contract, project)
            url = 'Boo?billable=1&projects_1=54&from_date=' \
                '2013-01-10&to_date=2013-01-10&non_billable=0' \
                '&paid_leave=0&trunc=month'
            self.assertEqual(url, retval)
            self.assertEqual('report_hourly', reverse.call_args[0][0])


class SumHoursTagTestCase(TestCase):

    def setUp(self):
        class Entry(object):
            def __init__(self, seconds):
                self.seconds = seconds
            def get_total_seconds(self):
                return self.seconds

        self.entries = [
            Entry(1),
            Entry(2.5),
            Entry(5)
        ]

    def test_sum_hours(self):
        retval = tags.sum_hours(self.entries)
        self.assertEqual(8.5, retval)


class ArithmeticTagTestCase(TestCase):

    def test_multiply(self):
        self.assertEqual(1.0, tags.multiply(1, 1))
        self.assertEqual(1.5, tags.multiply(3, 0.5))
        # numbers can be strings
        self.assertEqual(3.0, tags.multiply("1.5", "2"))

    def test_get_max_hours(self):
        ctx = {
            'project_progress': [
                { 'worked': 1, 'assigned': 2},
                { 'worked': 3, 'assigned': 0},
                { 'worked': 2, 'assigned': 1},
            ]
        }
        self.assertEqual(3, tags.get_max_hours(ctx))

    def test_get_max_hours_min_is_zero(self):
        # min of max hours is zero
        ctx = {
            'project_progress': [
                { 'worked': -1, 'assigned': -4},
                { 'worked': -3, 'assigned': -5},
                ]
        }
        self.assertEqual(0, tags.get_max_hours(ctx))


class TestProjectHoursForContract(TestCase):

    def setUp(self):
        self.user = factories.User()

        self.a_project = factories.NonbillableProject()
        self.another_project = factories.NonbillableProject()
        self.billable_project = factories.BillableProject()
        self.project_without_hours = factories.NonbillableProject()
        projects = [
            self.a_project,
            self.another_project,
            self.billable_project,
            self.project_without_hours
        ]

        self.contract = factories.ProjectContract(projects=projects)
        activity = factories.Activity(billable=True)
        unbillable_activity = factories.Activity(billable=False)

        start_time = datetime.datetime.now()
        factories.Entry(project=self.a_project,
                activity=activity, start_time=start_time,
                end_time=start_time + relativedelta(hours=1))
        factories.Entry(project=self.a_project,
                activity=unbillable_activity, start_time=start_time,
                end_time=start_time + relativedelta(hours=16))
        factories.Entry(project=self.another_project,
                activity=activity, start_time=start_time,
                end_time=start_time + relativedelta(hours=2))
        factories.Entry(project=self.billable_project,
                activity=activity, start_time=start_time,
                end_time=start_time + relativedelta(hours=4))
        factories.Entry(project=self.billable_project,
                activity=unbillable_activity, start_time=start_time,
                end_time=start_time + relativedelta(hours=8))

    def test_project_hours_for_contract(self):
        retval = tags.project_hours_for_contract(self.contract, self.a_project)
        # Includes billable and nonbillable by default
        self.assertEqual(17, retval)

    def test_project_hours_for_contract_none(self):
        # Try it with the aggregate returning None
        retval = tags.project_hours_for_contract(self.contract,
            self.project_without_hours)
        self.assertEqual(0, retval)

    def test_project_hours_for_contract_billable(self):
        # only include billable hours
        retval = tags.project_hours_for_contract(self.contract,
            self.billable_project, 'billable')
        self.assertEqual(4, retval)

    def test_project_hours_for_contract_nonbillable(self):
        # only include non-billable hours
        retval = tags.project_hours_for_contract(self.contract,
            self.billable_project, 'nonbillable')
        self.assertEqual(8, retval)

    def test_project_hours_for_contract_badbillable(self):
        # template tag does syntax check on the 'billable' arg
        with self.assertRaises(template.TemplateSyntaxError):
            tags.project_hours_for_contract(self.contract,
                self.a_project, 'invalidarg')


class AddParametersTest(TestCase):

    def test_new_parameters(self):
        """Tag should add parameters to base URL after a '?'."""
        url = '/hello/'
        params = {'foo': 'bar'}
        retval = tags.add_parameters(url, params)
        self.assertEqual(retval, url + '?foo=bar')

    def test_additional_parameters(self):
        """Tag should add parameters to base URL after a '&'."""
        url = '/hello/?user=1'
        params = {'foo': 'bar'}
        retval = tags.add_parameters(url, params)
        self.assertEqual(retval, url + '&foo=bar')

    def test_repeat_parameters(self):
        """Tag should append param even if another value exists for it."""
        url = '/hello/?foo=bar'
        params = {'foo': 'bar'}
        retval = tags.add_parameters(url, params)
        self.assertEqual(retval, url + '&foo=bar')

    def test_no_parameters(self):
        """Tag should return base URL when no parameters are given."""
        url = '/hello/'
        params = {}
        retval = tags.add_parameters(url, params)
        self.assertEqual(retval, url)

    def test_special_chars(self):
        """Tag should escape HTML entities."""
        url = '/hello/'
        params = {'foo': '?'}
        retval = tags.add_parameters(url, params)
        self.assertEqual(retval, url + '?foo=%3F')


class CreateDictTest(TestCase):

    def test_create_dict(self):
        retVal = tags.create_dict(foo='bar', a='b')
        self.assertEquals(len(retVal), 2)
        self.assertEquals(retVal['foo'], 'bar')
        self.assertEquals(retVal['a'], 'b')

    def test_create_empty_dict(self):
        retVal = tags.create_dict()
        self.assertEquals(retVal, {})


class AddTimezoneTest(TestCase):

    def test_add_timezone(self):
        d = datetime.datetime.now()
        retVal = tags.add_timezone(d)
        self.assertEquals(retVal, utils.add_timezone(d))

########NEW FILE########
__FILENAME__ = test_utils
import datetime

from django.test import TestCase
from timepiece.utils import get_active_entry, ActiveEntryError

from timepiece import utils

from . import factories


class UtilityFunctionsTest(TestCase):

    def setUp(self):
        # Setup last billable days
        self.last_billable = [
            utils.add_timezone(datetime.datetime(2012, 3, 25)),
            utils.add_timezone(datetime.datetime(2012, 4, 29)),
            utils.add_timezone(datetime.datetime(2012, 5, 27)),
            utils.add_timezone(datetime.datetime(2012, 6, 24)),
            utils.add_timezone(datetime.datetime(2012, 7, 29)),
            utils.add_timezone(datetime.datetime(2012, 8, 26)),
        ]
        self.dates = [
            utils.add_timezone(datetime.datetime(2012, 3, 12)),
            utils.add_timezone(datetime.datetime(2012, 4, 3)),
            utils.add_timezone(datetime.datetime(2012, 5, 18)),
            utils.add_timezone(datetime.datetime(2012, 6, 20)),
            utils.add_timezone(datetime.datetime(2012, 7, 1)),
            utils.add_timezone(datetime.datetime(2012, 8, 25)),
        ]

    def test_get_last_billable_day(self):
        for idx, date in enumerate(self.dates):
            self.assertEquals(self.last_billable[idx],
                utils.get_last_billable_day(date))


class GetActiveEntryTest(TestCase):

    def setUp(self):
        self.user = factories.User()

    def test_get_active_entry_none(self):
        self.assertIsNone(get_active_entry(self.user))

    def test_get_active_entry_single(self):
        now = datetime.datetime.now()
        entry = factories.Entry(user=self.user, start_time=now)
        # not active
        factories.Entry(user=self.user, start_time=now,
                end_time=now)
        # different user
        factories.Entry(start_time=now)
        self.assertEqual(entry, get_active_entry(self.user))

    def test_get_active_entry_multiple(self):
        now = datetime.datetime.now()
        # two active entries for same user
        factories.Entry(user=self.user, start_time=now)
        factories.Entry(user=self.user, start_time=now)
        self.assertRaises(ActiveEntryError, get_active_entry, self.user)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, include, url
from django.core.urlresolvers import reverse_lazy
from django.views.generic import RedirectView


urlpatterns = patterns('',
    # Redirect the base URL to the dashboard.
    url(r'^$', RedirectView.as_view(url=reverse_lazy('dashboard'))),

    url('', include('timepiece.crm.urls')),
    url('', include('timepiece.contracts.urls')),
    url('', include('timepiece.entries.urls')),
    url('', include('timepiece.reports.urls')),
)

########NEW FILE########
__FILENAME__ = csv
from __future__ import absolute_import

import csv
from decimal import Decimal
from json import JSONEncoder

from django.http import HttpResponse


class DecimalEncoder(JSONEncoder):

    def default(self, obj):
        if isinstance(obj, Decimal):
            return float(obj)
        return super(DecimalEncoder, self).default(obj)


class CSVViewMixin(object):

    def render_to_response(self, context):
        response = HttpResponse(content_type='text/csv')
        fn = self.get_filename(context)
        response['Content-Disposition'] = 'attachment; filename=%s.csv' % fn
        rows = self.convert_context_to_csv(context)
        writer = csv.writer(response)
        for row in rows:
            writer.writerow(row)
        return response

    def get_filename(self, context):
        raise NotImplemented('You must implement this in the subclass')

    def convert_context_to_csv(self, context):
        """Convert the context dictionary into a CSV file."""
        raise NotImplemented('You must implement this in the subclass')

########NEW FILE########
__FILENAME__ = search
from django import forms
from django.db.models import Q
from django.http import Http404
from django.shortcuts import redirect
from django.views.generic import ListView
from django.views.generic.edit import FormMixin

from .views import GetDataFormMixin


class SearchForm(forms.Form):
    """Base form used for searching data."""
    search = forms.CharField(label='', required=False)

    def __init__(self, *args, **kwargs):
        super(SearchForm, self).__init__(*args, **kwargs)
        self.fields['search'].widget.attrs['placeholder'] = 'Search'


class SearchMixin(GetDataFormMixin, FormMixin):
    """Adds the ability to search and filter objects with ListView."""
    form_class = None
    redirect_if_one_result = False

    def filter_results(self, form, queryset):
        if form.is_valid():
            return self.filter_form_valid(form, queryset)
        elif not form.is_bound:
            return self.filter_form_unbound(form, queryset)
        else:
            return self.filter_form_invalid(form, queryset)

    def filter_form_invalid(self, form, queryset):
        """Return no results."""
        return queryset.none()

    def filter_form_valid(self, form, queryset):
        raise NotImplemented("Subclass must implement queryset filtering "
                "when the search form is valid.")

    def filter_form_unbound(self, form, queryset):
        """Return all results."""
        return queryset.all()

    def get(self, request, *args, **kwargs):
        form_class = self.get_form_class()
        self.form = self.get_form(form_class)
        self.object_list = self.get_queryset()
        self.object_list = self.filter_results(self.form, self.object_list)

        allow_empty = self.get_allow_empty()
        if not allow_empty and len(self.object_list) == 0:
            raise Http404("No results found.")

        context = self.get_context_data(form=self.form,
                object_list=self.object_list)
        return self.render_to_response(context)

    def post(self, request, *args, **kwargs):
        return self.get(request, *args, **kwargs)

    def render_to_response(self, context):
        """
        When the user makes a search and there is only one result, redirect
        to the result's detail page rather than rendering the list.
        """
        if self.redirect_if_one_result:
            if self.object_list.count() == 1 and self.form.is_bound:
                return redirect(self.object_list.get().get_absolute_url())
        return super(SearchMixin, self).render_to_response(context)


class SearchListView(SearchMixin, ListView):
    """Basic implementation which uses text search on specific fields."""
    form_class = SearchForm
    search_fields = []

    def filter_form_valid(self, form, queryset):
        search = form.cleaned_data['search']
        query = Q()
        for field in self.search_fields:
            query |= Q(**{field: search})
        return queryset.filter(query)

########NEW FILE########
__FILENAME__ = views
from django.utils.decorators import method_decorator


def cbv_decorator(function_decorator):
    """Allows a function-based decorator to be used on a CBV."""

    def class_decorator(View):
        View.dispatch = method_decorator(function_decorator)(View.dispatch)
        return View
    return class_decorator


class GetDataFormMixin(object):
    """Used with subclasses of FormMixin to use GET data from the request."""

    def get_form_data(self):
        return self.request.GET or None

    def get_form_kwargs(self):
        kwargs = super(GetDataFormMixin, self).get_form_kwargs()
        kwargs.update({
            'data': self.get_form_data(),
        })
        return kwargs

########NEW FILE########
