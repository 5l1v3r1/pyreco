__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# app documentation build configuration file, created by
# sphinx-quickstart on Wed Oct 21 13:18:22 2009.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.append(os.path.abspath('..'))
os.environ['DJANGO_SETTINGS_MODULE'] = 'example.settings'

# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Django Object Permissions'
copyright = u'2009, The Washington Times'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.1'
# The full version, including alpha/beta/rc tags.
release = '0.1'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
html_show_sourcelink = False

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'objectpermissionsdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'app.tex', u'objectpermissions Documentation',
   u'me', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
from django.core.management import execute_manager
try:
    import settings # Assumed to be in the same directory.
except ImportError:
    import sys
    sys.stderr.write("Error: Can't find the file 'settings.py' in the directory containing %r. It appears you've customized things.\nYou'll have to run django-admin.py, passing it your settings module.\n(If the file settings.py does indeed exist, it's causing an ImportError somehow.)\n" % __file__)
    sys.exit(1)

if __name__ == "__main__":
    execute_manager(settings)

########NEW FILE########
__FILENAME__ = settings
# Django settings for example project.

DEBUG = True
TEMPLATE_DEBUG = DEBUG
import os, sys
APP = os.path.abspath(os.path.dirname(os.path.dirname(__file__)))
sys.path.append(APP)

ADMINS = (
    # ('Your Name', 'your_email@domain.com'),
)

MANAGERS = ADMINS

DATABASE_ENGINE = 'sqlite3'           # 'postgresql_psycopg2', 'postgresql', 'mysql', 'sqlite3' or 'oracle'.
DATABASE_NAME = 'dev.db'             # Or path to database file if using sqlite3.
DATABASE_USER = ''             # Not used with sqlite3.
DATABASE_PASSWORD = ''         # Not used with sqlite3.
DATABASE_HOST = ''             # Set to empty string for localhost. Not used with sqlite3.
DATABASE_PORT = ''             # Set to empty string for default. Not used with sqlite3.

# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# If running in a Windows environment this must be set to the same as your
# system time zone.
TIME_ZONE = 'America/Chicago'

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'en-us'

SITE_ID = 1

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

# Absolute path to the directory that holds media.
# Example: "/home/media/media.lawrence.com/"
MEDIA_ROOT = ''

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash if there is a path component (optional in other cases).
# Examples: "http://media.lawrence.com", "http://example.com/media/"
MEDIA_URL = ''

# URL prefix for admin media -- CSS, JavaScript and images. Make sure to use a
# trailing slash.
# Examples: "http://foo.com/media/", "/media/".
ADMIN_MEDIA_PREFIX = '/media/'

# Make this unique, and don't share it with anybody.
SECRET_KEY = 'g2_39yupn*6j4p*cg2%w643jiq-1n_annua*%i8+rq0dx9p=$n'

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.load_template_source',
    'django.template.loaders.app_directories.load_template_source',
#     'django.template.loaders.eggs.load_template_source',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
)

ROOT_URLCONF = 'example.urls'

TEMPLATE_DIRS = (
    # Put strings here, like "/home/html/django_templates" or "C:/www/django/templates".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

INSTALLED_APPS = (
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'objectpermissions',
    'django.contrib.flatpages',
    'simpleapp',
)

########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.contrib.contenttypes import generic
from django.contrib.contenttypes.models import ContentType
from django.contrib.auth.models import User

class SimpleText(models.Model):
    """A Testing app"""
    firstname = models.CharField(blank=True, max_length=255)
    lastname = models.CharField(blank=True, max_length=255)
    favorite_color = models.CharField(blank=True, max_length=255)
    
    def __unicode__(self):
        return self.firstname

class SimpleTaggedItem(models.Model):
    tag = models.SlugField()
    simple_text = models.ForeignKey(SimpleText)

    def __unicode__(self):
        return self.tag

import objectpermissions
permissions = ['perm1', 'perm2', 'perm3', 'perm4']
objectpermissions.register(SimpleText, permissions)
objectpermissions.register(SimpleTaggedItem, permissions)

from django.contrib import admin
from objectpermissions.admin import TabularUserPermInline, StackedUserPermInline

class SimpleTaggedItemInline(admin.TabularInline):
    model = SimpleTaggedItem

class SimpleTextAdmin(admin.ModelAdmin):
    list_display = ('firstname','lastname','favorite_color')
    inlines = [SimpleTaggedItemInline, TabularUserPermInline, ]

admin.site.register(SimpleText, SimpleTextAdmin)
########NEW FILE########
__FILENAME__ = tests
"""
This file demonstrates two different styles of tests (one doctest and one
unittest). These will both pass when you run "manage.py test".

Replace these with more appropriate tests for your application.
"""

from django.test import TestCase

class SimpleTest(TestCase):
    def test_basic_addition(self):
        """
        Tests that 1 + 1 always equals 2.
        """
        self.failUnlessEqual(1 + 1, 2)

__test__ = {"doctest": """
Another way to test that 1 + 1 is equal to 2.

>>> 1 + 1 == 2
True
"""}


########NEW FILE########
__FILENAME__ = views
# Create your views here.

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *

# Uncomment the next two lines to enable the admin:
from django.contrib import admin
admin.autodiscover()

urlpatterns = patterns('',
    # Example:
    # (r'^example/', include('example.foo.urls')),

    # Uncomment the admin/doc line below and add 'django.contrib.admindocs' 
    # to INSTALLED_APPS to enable admin documentation:
    # (r'^admin/doc/', include('django.contrib.admindocs.urls')),

    # Uncomment the next line to enable the admin:
    (r'^admin/', include(admin.site.urls)),
)

########NEW FILE########
__FILENAME__ = admin
from django import forms
from django.contrib.contenttypes import generic

from models import Permission, UserPermission, GroupPermission

class PermissionModelForm(forms.ModelForm):
    """
    A model form that represents the permissions as a multiple choice field.
    """
    perm_list = forms.MultipleChoiceField()
    
    class Meta:
        model=Permission
        exclude=['permission',]
    
    def __init__(self, data=None, files=None, auto_id='id_%s', prefix=None,
                 initial=None, error_class=forms.util.ErrorList, label_suffix=':',
                 empty_permitted=False, instance=None):
        """
        We have to set the value for ``perm_list`` since it isn't a real field.
        
        The value from the instance is set as initial data.
        """
        if initial is None:
            initial = {}
        if instance is not None:
            initial['perm_list'] = instance.perm_list
        super(PermissionModelForm, self).__init__(data, files, auto_id, prefix,
                initial, error_class,label_suffix,empty_permitted, instance)
    
    def clean_perm_list(self):
        """
        Convert the list of number strings into a single integer value
        """
        self.cleaned_data['permission'] = reduce(lambda x,y: int(x)|int(y),self.cleaned_data['perm_list'])
    
    def save(self, commit=True):
        """
        Because ``permission`` was left out, it won't get saved. ``perm_list``
        won't get saved, since it isn't a real field. We set it here and let the
        parent class do the rest.
        """
        self.instance.permission = self.cleaned_data['permission']
        super(PermissionModelForm, self).save(commit)


class UserPermModelForm(PermissionModelForm):
    """
    Subclass the :class:`PermissionModelForm` for :class:`UserPermission`
    """
    class Meta:
        model=UserPermission

class GroupPermModelForm(PermissionModelForm):
    """
    Subclass the :class:`PermissionModelForm` for :class:`GroupPermission`
    """
    class Meta:
        model=GroupPermission


def inline_permission_form_factory(model, Form):
    class InlinePermissionModelForm(Form):
        perm_list = forms.MultipleChoiceField(choices=model.perms.choice_list())
    
    return InlinePermissionModelForm


class InlinePermissionModelAdmin(generic.GenericInlineModelAdmin):
    form = PermissionModelForm
    
    def __init__(self, parent_model, admin_site):
        self.form = inline_permission_form_factory(parent_model, self.form)
        super(InlinePermissionModelAdmin, self).__init__(parent_model, admin_site)


class TabularUserPermInline(InlinePermissionModelAdmin):
    form = UserPermModelForm
    model = UserPermission
    template = 'admin/edit_inline/tabular.html'
    exclude=['permission',]

class StackedUserPermInline(InlinePermissionModelAdmin):
    form = UserPermModelForm
    model=UserPermission
    template = 'admin/edit_inline/stacked.html'

class TabularGroupPermInline(InlinePermissionModelAdmin):
    form = GroupPermModelForm
    model = GroupPermission
    template = 'admin/edit_inline/tabular.html'
    exclude = ['permission',]

class StackedGroupPermInline(InlinePermissionModelAdmin):
    form = GroupPermModelForm
    model = GroupPermission
    template = 'admin/edit_inline/stacked.html'

########NEW FILE########
__FILENAME__ = decorators
try:
    from functools import wraps
except ImportError:
    from django.utils.functional import wraps  # Python 2.3, 2.4 fallback.

from django.conf import settings
from django.contrib.auth import REDIRECT_FIELD_NAME
from django.db.models import Model, get_model
from django.http import HttpResponseRedirect
from django.shortcuts import get_object_or_404
try:
    from django.utils.decorators import auto_adapt_to_methods
except ImportError:
    auto_adapt_to_methods = lambda x: x
from django.utils.http import urlquote

from views import permission_denied

def permission_required(permission, obj_lookup, login_url=settings.LOGIN_URL, 
                        redirect_field_name=REDIRECT_FIELD_NAME, **kwargs):
    """
    Decorator for a view that makes sure that the user has *all* permissions,
    redirects to the log-in page if not logged in.
    
    :param permission: The permission set that the user must have for the object
    :type permission: An ``int``, ``string``, or ``list``
    :param obj_lookup: How to locate the object to test. It specifies the model,
                       `field and lookup <http://docs.djangoproject.com/en/dev/ref/models/querysets/#id7>`_,
                       and the name of the parameter containg the value to lookup
                       to retrieve the object
    :type obj_lookup: ``(<model>, '<field_lookup>', 'view_arg')`` or
                      ``('<appname>.<modelname>', '<field_lookup>', 'view_arg')``
    """
    if isinstance(obj_lookup, (tuple, list)):
        _model, lookup, varname = obj_lookup
    else:
        raise ValueError("The given argument '%s' should be a list or tuple" % obj_lookup)
    
    if issubclass(_model, Model):
        model = _model
    elif isinstance(_model, basestring):
        model = get_model(*model.split("."))
    else:
        raise ValueError("The model passed ('%s') is not a Model class or string in the format 'app.model'." % model)
    value = kwargs.get(varname, None)
    def decorator(view_func):
        def _wrapped_view(request, *args, **kwargs):
            if not request.user.is_authenticated():
                path = urlquote(request.get_full_path())
                return HttpResponseRedirect('%s?%s=%s' % (login_url, redirect_field_name, path))
            
            obj = get_object_or_404(model, **{lookup: value})
            if request.user.has_object_permission(obj, permission):
                return view_func(request, *args, **kwargs)
            return permission_denied(request)
        return wraps(view_func)(_wrapped_view)
    return auto_adapt_to_methods(decorator)
    
########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.contrib.auth.models import User, Group
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes import generic

class UnknownPermission(Exception):
    """
    An attempt was made to query for a permission that was not registered for that model.
    """
    pass


class PermissionManager(models.Manager):
    def all_with_perm(self, permission):
        """
        Return all users that have the permission ``permission`` for this object.
        """
        perm = self.instance.perms.as_int(permission)
        qs = self.get_query_set()
        new_qs = qs.extra(where=['permission & %s = %s',], params=[perm, perm])
        return new_qs


class Permission(models.Model):
    """
    A privilege granted to a specific User or Group to a specific object.
    """
    permission = models.IntegerField(null=True, blank=True, default=0)
    content_type = models.ForeignKey(ContentType)
    object_id = models.PositiveIntegerField()
    content_object = generic.GenericForeignKey('content_type', 'object_id')
    
    class Meta:
        abstract = True
    
    objects = PermissionManager()
    
    @classmethod
    def bits(self, a):
        """
        Convert an integer into a list of 1's or 0's indicating the
        bits set. Modified from http://wiki.python.org/moin/BitManipulation
        
        >>> Permission.bits(10)
        [0, 0, 1, 0, 1, 0]
        
        :param a: The integer to convert
        :type a: ``integer``
        :result: A list of ``1`` and ``0`` corresponding to a bit set or not
        """
        result = []
        oct_bits={'0':[0,0,0],'1':[0,0,1],'2':[0,1,0],'3':[0,1,1],
           '4':[1,0,0],'5':[1,0,1],'6':[1,1,0],'7':[1,1,1]}
        for c in filter(lambda char: char != 'L', oct(a))[1:]:
                result += oct_bits[c]
        return result
    
    @classmethod
    def int_to_perms(self, a):
        """
        Convert an integer used to represent a bitwise setting of integers into a 
        list of integers corresponding to the values of the bits set in the integer.
        
        >>> Permission.int_to_perms(10)
        [8, 2]
        
        :param a: The bitwise permission to convert
        :type a: ``integer``
        :result: A list of integers corresponding to values of the set bits
        """
        result=[]
        bitlist = self.bits(a)
        l = len(bitlist)
        for i in range(l):
            result.insert(0, 1<<i)
        return [i for i in map(lambda x,y: x*y, bitlist, result) if i != 0]
    
    
    def _set_perm_with_list(self, int_list):
        """
        Set the permissions from an integer list
        """
        if isinstance(int_list, int):
            self.permission = int_list
            return
        elif not isinstance(int_list, (list, tuple)):
            raise Exception("The parameter %s is not a list or tuple" % int_list)
        self.permission = reduce(lambda x,y: x | y, int_list)
    
    def _get_perm_as_list(self):
        """
        Return the permission as a list of integers
        """
        return self.int_to_perms(self.permission)
    
    perm_list = property(_get_perm_as_list, _set_perm_with_list, doc="The permissions as an integer list")

class UserPermission(Permission):
    user = models.ForeignKey(User)
    
    def save(self, *a, **kw):
        """
        Send out a signal indicating that a permission was changed
        """
        super(Permission, self).save(*a, **kw)
        from signals import permission_changed
        permission_changed.send(sender=self, to_whom=self.user, to_what=self.content_object)


class GroupPermission(Permission):
    group = models.ForeignKey(Group, null=True)
    
    def save(self, *a, **kw):
        """
        Send out a signal indicating that a permission was changed
        """
        super(Permission, self).save(*a, **kw)
        from signals import permission_changed
        permission_changed.send(sender=self, to_whom=self.group, to_what=self.content_object)


class ModelPermissions(object):
    """
    An object that converts named permissions into a bitwise set of attributes
    """
    def __init__(self, permissions):
        self._perms = permissions[:]
        for num, perm in enumerate(permissions):
            setattr(self, perm, 1<<num)
    
    def __len__(self):
        return len(self._perms)
    
    def __getitem__(self, key):
        if key in self._perms:
            return getattr(self, key)
        else:
            raise KeyError
    
    def __iter__(self):
        for item in self._perms:
            yield item
    
    def iterkeys(self):
        return self.__iter__()
    
    def itervalues(self):
        for item in self._perms:
            yield getattr(self, item)
    
    def keys(self):
        return self._perms
    
    def values(self):
        return [getattr(self, x) for x in self._perms]
    
    def has_key(self, key):
        return self.__contains__(key)
    
    def __contains__(self, value):
        return value in self._perms
    
    def items(self):
        return [(getattr(self, key), key) for key in self._perms]
    
    def as_int(self, perm):
        """
        A utility method to convert several types of arguments into the integer representation.
        
        Converts strings by looking up the name
        Converts a list or tuple by OR'ing the int value for each item
        """
        if isinstance(perm, int):
            valid_perm = perm
        elif isinstance(perm, basestring):
            # Look up the attribute, it will raise an error if it doesn't exist
            valid_perm = getattr(self, perm)
        elif isinstance(perm, (list, tuple)):
            valid_perm = 0
            for item in perm:
                valid_perm |= self.as_int(item)
        else:
            raise UnknownPermission("'%s' is an unknown permission type." % perm)
        return valid_perm
    
    def as_string_list(self, perm):
        """
        A utility method to convert an integer into a list of strings of the selected permissions
        """
        if not isinstance(perm, int):
            raise UnknownPermission("'perm' must be an integer")
        result_list = []
        for key, val in self.items():
            if key & perm == key:
                result_list.append(val)
        return result_list
    
    def as_int_list(self, perm):
        """
        A utility method to convert an integer into a list of integers of the selected permissions
        """
        if not isinstance(perm, int):
            raise UnknownPermission("'perm' must be an integer")
        result_list = []
        for key, val in self.items():
            if key & perm == key:
                result_list.append(key)
        return result_list
        
    def as_choices(self, perm):
        """
        A utility method to convert an integer into a list of integer, string tuples for choices
        """
        if not isinstance(perm, int):
            raise UnknownPermission("'perm' must be an integer")
        result_list = []
        for key, val in self.items():
            if key & perm == key:
                result_list.append((key, val))
        return result_list
    
    def choice_list(self):
        """
        Return a list of integer,string tuples for a choice list
        """
        return self.items()


class UserPermissionRelation(generic.GenericRelation):
    """A generic relation for Object Permissions"""
    
    def __init__(self,**kwargs):
        """Override this to automatically set the "to" field """
        super(UserPermissionRelation, self).__init__(UserPermission, **kwargs)


class GroupPermissionRelation(generic.GenericRelation):
    """A generic relation for Object Permissions"""
    
    def __init__(self,**kwargs):
        """Override this to automatically set the "to" field """
        super(GroupPermissionRelation, self).__init__(GroupPermission, **kwargs)


########NEW FILE########
__FILENAME__ = registration
from django.db.models import FieldDoesNotExist, Q
from django.contrib.contenttypes.models import ContentType
from django.contrib.auth.models import User, Group

from models import UserPermission, GroupPermission, ModelPermissions, UserPermissionRelation, GroupPermissionRelation

class AlreadyRegistered(Exception):
    """
    An attempt was made to register a model for objectpermissions more than once.
    """
    pass

#: Contains all the models that we've registered. A ``list`` of ``Model``\ s
registry = []

def register(model, permissions):
    """
    Register a model and permission set. It adds several functions to the model:
    """
    if model in registry:
        #raise AlreadyRegistered('The model %s has already been registered.' % model.__name__)
        return
    registry.append(model)
    
    opts = model._meta
    try:
        opts.get_field('user_perms_set')
    except FieldDoesNotExist:
        UserPermissionRelation().contribute_to_class(model, 'user_perms_set')
    
    try:
        opts.get_field('group_perms_set')
    except FieldDoesNotExist:
        GroupPermissionRelation().contribute_to_class(model, 'group_perms_set')
    
    setattr(model, 'perms', ModelPermissions(permissions))


# The following functions are added to the User/Group objects

def grant_object_perm(self, instance, perm):
    """
    Grants permission ``perm`` to object ``instance`` for the :class:`User` or 
    :class:`Group` ``self``\ .
    
    This function is added to the :class:`User` and :class:`Group` models and 
    is called as::
    
        a_user.grant_object_perm(an_object_instance, 'read')
    
    :param instance: A Django :class:`Model` instance
    :type instance: :class:`Model`
    :param perm: The permission(s) to grant
    :type perm: ``integer``, ``string``, ``list of string``
    """
    addl_perm = instance.perms.as_int(perm)
    query_args = {}
    if isinstance(self, User):
        try:
            the_permission = instance.user_perms_set.get(user=self)
        except UserPermission.DoesNotExist:
            the_permission = instance.user_perms_set.create(user=self)
    elif isinstance(self, Group):
        try:
            the_permission = instance.group_perms_set.get(group=self)
        except GroupPermission.DoesNotExist:
            the_permission = instance.group_perms_set.create(group=self)
    else:
        raise Exception("This method should only be attached to a User or Group object.")
    the_permission.permission |= addl_perm
    the_permission.save()


def revoke_object_perm(self, instance, perm):
    """
    Remove the permission ``perm`` to object ``instance`` for the :class:`User` or 
    :class:`Group` ``self``\ .
    
    :param instance: A Django :class:`Model` instance
    :type instance: :class:`Model`
    :param perm: The name of the permission to revoke
    :type perm: ``integer``, ``string``, ``list of string``
    """
    remove_perm = instance.perms.as_int(perm)
    
    try:
        if isinstance(self, User):
            the_permission = instance.user_perms_set.get(user=self)
        elif isinstance(self, Group):
            the_permission = instance.group_perms_set.get(group=self)
    except (UserPermission.DoesNotExist, GroupPermission.DoesNotExist):
        # Can't revoke what they don't have
        return 
    the_permission.permission ^= remove_perm
    if the_permission.permission == 0:
        the_permission.delete()
    else:
        the_permission.save()


def revoke_all_object_perm(self, instance):
    """
    Remove all the permissions for this :class:`User` or :class:`Group`\ .
    
    :param instance: A Django :class:`Model` instance
    :type instance: :class:`Model`
    """
    try:
        if isinstance(self, User):
            instance.user_perms_set.get(user=self).delete()
        elif isinstance(self, Group):
            instance.group_perms_set.get(group=self).delete()
    except (UserPermission.DoesNotExist, GroupPermission.DoesNotExist):
        # Can't revoke what they don't have
        return 
    

def set_object_perm(self, instance, perm):
    """
    Sets the permission to the ``perm`` value. Same as revoking all privileges
    and granting ``perm``
    
    :param instance: The object on which to set the permissions
    :type instance:  ``Model``
    :param perm:  The permission(s) that should be set.
    :type perm:   ``int``, ``string`` or ``list of string``
    """
    perms = instance.perms.as_int(perm)
    if isinstance(self, User):
        try:
            the_permission = instance.user_perms_set.get(user=self)
        except UserPermission.DoesNotExist:
            the_permission = instance.user_perms_set.create(user=self)
    elif isinstance(self, Group):
        try:
            the_permission = instance.group_perms_set.get(group=self)
        except GroupPermission.DoesNotExist:
            the_permission = instance.group_perms_set.create(group=self)
    else:
        raise Exception("This method should only be attached to a User or Group object.")
    the_permission.permission = perms
    the_permission.save()


def user_has_object_perm(self, instance, perm, require_all=False):
    """
    Basic testing of user permissions. Permissions can be passed as an int, using the 
    object's ``perms`` attribute::
    
        obj.perms.perm1 + obj.perms.perm2
    
    Permissions can be referenced by name::
    
        'perm1'
    
    Permissions can be referenced by a list of names or ``int``s::
    
        ['perm1', 'perm2']
        [obj.perms.perm1, objs.perms.perm2]
    
    When passing in multiple permissions, you can force the checking that the 
    user has *all* the permissions by passing ``True`` as the third parameter. By
    default it returns ``True`` if the user has *any* of the permissions.
    
    Superusers *always* return ``True``
    
    Inactive users *always* return ``False``
    
    :param instance: The object for which the user may or may not have permissions.
    :type instance:  A Django model subclass that has been registered with :ref:`objectpermissions.register`
    :param perm:     Permission(s) to check for in either an integer, a string or a list of strings
    :type perm:      ``int``, ``string`` or ``list of string``
    :param require_all: Does the user need to have all the permissions? ``True``
                        if they do. **Default:** ``False``
    :type require_all:  ``bool``
    """
    if self.is_superuser:
        return True
    if not self.is_active:
        return False
    
    perms = instance.perms.as_int(perm)
    
    try:
        user_perm = instance.user_perms_set.get(user=self)
        if require_all:
            if user_perm.permission & perms == perms:
                return True
        else:
            if user_perm.permission & perms > 0:
                return True
    except UserPermission.DoesNotExist:
        pass # either the group check will return true, or it returns false at the end
    
    for group in self.groups.all():
        if group.has_object_perm(instance, perms, require_all):
            return True
    return False


def user_has_all_object_perm(self, instance, perm):
    return self.has_object_perm(instance, perm, True)

def user_get_object_permissions(self, instance, format='int'):
    """
    Get the user's permissions for this object, formatted in a specific way.
    
    Format options:
    
    int: One integer with all permissions
    
    string_list: A list of the permission names
    
    int_list: A list of the permission values
    
    choices: A list of integer, string tuples for choice lists
    
    :param instance: A django :class:`Model` instance
    :type instance: :class:`Model`
    :param format: 'int', 'string_list', 'int_list', 'choices'. **Default:** 'int'
    :type format: ``string``
    """
    try:
        user_perm = instance.user_perms_set.get(user=self)
        group_ids = self.groups.all().values_list('id', flat=True)
        group_perms = instance.group_perms_set.filter(group__id__in=group_ids).values_list('permission', flat=True)
        if group_perms:
            gperm = reduce(lambda x,y: x|y,group_perms)
        else:
            gperm = 0
        formatter = getattr(instance.perms, "as_%s" % format, False)
        if formatter:
            return formatter(user_perm.permission|gperm)
        else:
            return user_perm.permission|gperm

    except UserPermission.DoesNotExist:
        if format == 'int':
            return 0
        else:
            return []


def user_get_object_permissions_as_string_list(self, instance):
    """
    Get a list of strings representing the user's permissions for this object
    """
    return self.get_object_perm(instance, 'string_list')


def user_get_object_permissions_as_int_list(self, instance):
    """
    Get a list of strings representing the user's permissions for this object
    """
    return self.get_object_perm(instance, 'int_list')


def user_get_object_permissions_as_choices(self, instance):
    """
    Get a list of strings representing the user's permissions for this object
    """
    return self.get_object_perm(instance, 'choices')


def user_get_objects_with_permission(self, model, permission):
    """
    Return all objects of type model where the user has the passed permissions
    """
    ctype = ContentType.objects.get_for_model(model)
    perms = model.perms.as_int(permission)
    return model.objects.filter(
        Q(pk__in=self.userpermission_set.filter(content_type=ctype).extra(
            where=['permission & %s > 0'], params=[perms]
            ).values_list('object_id', flat=True)) |
        Q(pk__in=GroupPermission.objects.filter(content_type=ctype).filter(
            group__in=self.groups.all()).extra(
            where=['permission & %s > 0'], params=[perms]
            ).values_list('object_id', flat=True)))


def group_get_object_permissions(self, instance, format='int'):
    """
    Get the user's permissions for this object, formatted in a specific way
    """
    try:
        group_perm = instance.group_perms_set.get(group=self)
        formatter = getattr(instance.perms, "as_%s" % format, False)
        if formatter:
            return formatter(group_perm.permission)
        else:
            return group_perm.permission
    except GroupPermission.DoesNotExist:
        if format == 'int':
            return 0
        else:
            return []


def group_get_object_permissions_as_string_list(self, instance):
    """
    Get a list of strings representing the user's permissions for this object
    """
    return self.get_object_perm(instance, 'string_list')


def group_get_object_permissions_as_int_list(self, instance):
    """
    Get a list of strings representing the user's permissions for this object
    """
    return self.get_object_perm(instance, 'int_list')


def group_get_object_permissions_as_choices(self, instance):
    """
    Get a list of strings representing the user's permissions for this object
    """
    return self.get_object_perm(instance, 'choices')


def group_has_object_permission(self, instance, perm, require_all=False):
    """
    Basic testing of permissions. Permissions can be passed as an int, using the 
    object's ``perms`` attribute::
    
        obj.perms.perm1 + obj.perms.perm2
    
    Permissions can be referenced by name::
    
        'perm1'
    
    Permissions can be referenced by a list of names:
    
        ['perm1', 'perm2']
    
    When passing in multiple permissions, you can force the checking that the 
    user has *all* the permissions by passing ``True`` as the third parameter. By
    default it returns ``True`` if the user has *any* of the permissions.
    
    :param instance: The object for which the group may or may not have permissions.
    :type instance:  A Django model subclass that has been registered with :ref:`objectpermissions.register`
    :param perm:     Permission(s) to check for in either an integer, a string or a list of strings
    :type perm:      ``int``, ``string`` or ``list of string``
    :param require_all: Does the user need to have all the permissions? ``True``
                        if they do. **Default:** ``False``
    :type require_all:  ``bool``
    """
    perms = instance.perms.as_int(perm)
    
    try:
        group_perm = instance.group_perms_set.get(group=self)
        
        # Check if it has ANY of the permissions
        if group_perm.permission & perms > 0:
            return True
    except GroupPermission.DoesNotExist:
        pass
    return False


def group_has_all_object_permissions(self, instance, perm):
    return self.has_object_perm(instance, perm, True)


def group_get_objects_with_permission(self, model, permission):
    """
    Return all objects of type model where the group has the passed permissions
    """
    ctype = ContentType.objects.get_for_model(model)
    perms = model.perms.as_int(permission)
    obj_ids = self.grouppermission_set.filter(content_type=ctype).extra(
                where=['permission & %s > 0'], params=[perms]
                ).values_list('object_id', flat=True)
    return model.objects.filter(pk__in=obj_ids)

# The following are added to registered models

if User not in registry:
    registry.append(User)
    setattr(User, 'grant_object_perm', grant_object_perm)
    setattr(User, 'set_object_perm', set_object_perm)
    setattr(User, 'revoke_object_perm', revoke_object_perm)
    setattr(User, 'revoke_all_object_perm', revoke_all_object_perm)
    setattr(User, 'has_object_perm', user_has_object_perm)
    setattr(User, 'has_any_object_perm', user_has_object_perm)
    setattr(User, 'has_all_object_perm', user_has_all_object_perm)
    setattr(User, 'get_object_perm', user_get_object_permissions)
    setattr(User, 'get_object_perm_as_str_list', user_get_object_permissions_as_string_list)
    setattr(User, 'get_object_perm_as_int_list', user_get_object_permissions_as_int_list)
    setattr(User, 'get_object_perm_as_choices', user_get_object_permissions_as_choices)
    setattr(User, 'get_objects_with_perms', user_get_objects_with_permission)
if Group not in registry:
    registry.append(Group)
    setattr(Group, 'grant_object_perm', grant_object_perm)
    setattr(Group, 'set_object_perm', set_object_perm)
    setattr(Group, 'revoke_object_perm', revoke_object_perm)
    setattr(Group, 'revoke_all_object_perm', revoke_all_object_perm)
    setattr(Group, 'has_object_perm', group_has_object_permission)
    setattr(Group, 'has_any_object_perm', group_has_object_permission)
    setattr(Group, 'has_all_object_perm', group_has_all_object_permissions)
    setattr(Group, 'get_object_perm', group_get_object_permissions)
    setattr(Group, 'get_object_perm_as_str_list', group_get_object_permissions_as_string_list)
    setattr(Group, 'get_object_perm_as_int_list', group_get_object_permissions_as_int_list)
    setattr(Group, 'get_object_perm_as_choices', group_get_object_permissions_as_choices)
    setattr(Group, 'get_objects_with_perms', group_get_objects_with_permission)

########NEW FILE########
__FILENAME__ = signals
import django.dispatch

# Whenever a permission object is saved, it sends out the signal. This allows
# models to keep their permissions in sync
permission_changed = django.dispatch.Signal(providing_args=('to_whom', 'to_what'))
########NEW FILE########
__FILENAME__ = tests
from django.test import TestCase
from django.test.client import Client
from django.contrib.flatpages.models import FlatPage
from django.contrib.auth.models import User, Group
from django.contrib.contenttypes.models import ContentType
# Test against flat pages

import objectpermissions
from models import ModelPermissions, UserPermission, GroupPermission
from simpleapp.models import SimpleText, SimpleTaggedItem

class TestModelPermissions(TestCase):
    perms = ['Perm1', 'Perm2', 'Perm3', 'Perm4']
    values = [1,2,4,8]

    def testObjectCapabilities(self):
        mp = ModelPermissions(self.perms)
        
        self.assertEquals(mp.Perm1, 1)
        self.assertEquals(mp.Perm2, 2)
        self.assertEquals(mp.Perm3, 4)
        self.assertEquals(mp.Perm4, 8)
    
    def testDictCapabilities(self):
        mp = ModelPermissions(self.perms)
        
        self.assertEquals(mp['Perm1'], 1)
        self.assertEquals(mp['Perm2'], 2)
        self.assertEquals(mp['Perm3'], 4)
        self.assertEquals(mp['Perm4'], 8)
        
        self.assertTrue('Perm3' in mp)
        self.assertFalse('Perm5' in mp)
        
        self.assertEquals(mp.keys(), self.perms)
        self.assertEquals(mp.values(), self.values)
    
    def testConversion(self):
        mp = ModelPermissions(self.perms)
        
        self.assertEquals(mp.as_int('Perm1'), 1)
        self.assertEquals(mp.as_int(['Perm1', 'Perm2', 'Perm4']), 1 | 2 | 8)
        self.assertEquals(mp.as_int(['Perm3', 'Perm2', 'Perm4']), 4 | 2 | 8)
        self.assertRaises(AttributeError, mp.as_int, ['Perm5', 'Perm2', 'Perm4'])

class TestRegistration(TestCase):
    perms = ['Perm1', 'Perm2', 'Perm3', 'Perm4']
    values = [1,2,4,8]
    fixtures = ['simpleapp.json', ]
    
    def setUp(self):
        self.fp = FlatPage.objects.create(url='dummy/', title="dummy", enable_comments=False, registration_required=False)
        try:
            objectpermissions.register(FlatPage, self.perms)
        except objectpermissions.AlreadyRegistered:
            pass
        self.fp.save()
        
        self.u = User.objects.create_user('simple_guy','simple@guy.com', 'password')
        self.g = Group(name="simple_group")
        self.g.save()
    
    def create_simpletext(self):
        self.st = SimpleText.objects.create(lastname="Daniels",
                                            favorite_color="Red",
                                            firstname="Charlie")
        self.st.simpletaggeditem_set.create(tag="country")
        self.st.simpletaggeditem_set.create(tag="singer")
        
    def testRegiser(self):
        self.assertTrue(hasattr(FlatPage, 'user_perms_set'))
        self.assertTrue(hasattr(FlatPage, 'group_perms_set'))
        self.assertTrue(hasattr(FlatPage, 'perms'))
    
    def testGrantUserPermissions(self):
        fp = self.fp
        u = self.u
        
        u.grant_object_perm(fp, fp.perms.Perm1)
        self.assertTrue(u.has_object_perm(fp, fp.perms.Perm1))
        self.assertFalse(u.has_object_perm(fp, fp.perms.Perm2))
        self.assertFalse(u.has_object_perm(fp, fp.perms.Perm3))
        self.assertTrue(u.has_object_perm(fp, [fp.perms.Perm1+fp.perms.Perm2]))
        self.assertTrue(u.has_any_object_perm(fp, [fp.perms.Perm1+fp.perms.Perm2]))
        self.assertFalse(u.has_all_object_perm(fp, [fp.perms.Perm1+fp.perms.Perm2]))
        
        
        up = UserPermission.objects.get(user=self.u)
        self.assertEquals(up.permission, fp.perms.Perm1)
        self.assertEquals(up.content_type, ContentType.objects.get_for_model(FlatPage))
        self.assertEquals(up.object_id, fp.id)
        
        self.assertEquals(fp.perms.as_string_list(13), ['Perm1', 'Perm3', 'Perm4'])
        self.assertEquals(fp.perms.as_int_list(13), [1,4,8])
        self.assertEquals(fp.perms.as_choices(13), [(1,'Perm1'),(4,'Perm3'),(8,'Perm4')])
        
        u.grant_object_perm(fp, [fp.perms.Perm2, fp.perms.Perm3])
        up = UserPermission.objects.get(user=self.u)
        self.assertEquals(up.content_type, ContentType.objects.get_for_model(FlatPage))
        self.assertEquals(up.object_id, fp.id)
        self.assertEquals(up.permission, fp.perms.Perm1 | fp.perms.Perm2 | fp.perms.Perm3)
    
    def testRevokeUserPermission(self):
        fp = self.fp
        u = self.u
        
        u.grant_object_perm(fp, fp.perms.Perm1)
        self.assertTrue(u.has_object_perm(fp, fp.perms.Perm1))
        
        u.revoke_object_perm(fp, fp.perms.Perm1)
        self.assertFalse(u.has_object_perm(fp, fp.perms.Perm1))
    
    
    def testGetUserPermissions(self):
        fp = self.fp
        u = self.u
        g = self.g
        g.user_set.add(u)
        
        # Clean the slate
        u.revoke_all_object_perm(fp)
        g.revoke_all_object_perm(fp)
        self.assertEquals(u.get_object_perm(fp), 0)
        self.assertEquals(g.get_object_perm(fp), 0)
        self.assertEquals(u.get_object_perm_as_str_list(fp), [])
        self.assertEquals(g.get_object_perm_as_str_list(fp), [])
        
        u.grant_object_perm(fp, fp.perms.Perm1 + fp.perms.Perm4)
        self.assertEquals(u.get_object_perm(fp), 9)
        self.assertEquals(u.get_object_perm_as_str_list(fp), ['Perm1', 'Perm4'])
        self.assertEquals(u.get_object_perm_as_int_list(fp), [1, 8])
        self.assertEquals(u.get_object_perm_as_choices(fp), [(1, 'Perm1'), (8,'Perm4')])
        
        # Test that the group permissions work correctly with the user perms
        g.grant_object_perm(fp, fp.perms.Perm1+fp.perms.Perm3)
        self.assertEquals(u.get_object_perm(fp), fp.perms.Perm1+fp.perms.Perm3+fp.perms.Perm4)
        
        # Revoking the Perm1 for the user, shouldn't change anything because
        # The group also has it
        u.revoke_object_perm(fp, fp.perms.Perm1)
        self.assertEquals(u.get_object_perm(fp), fp.perms.Perm1+fp.perms.Perm3+fp.perms.Perm4)
        
        g.revoke_object_perm(fp, fp.perms.Perm1)
        self.assertEquals(u.get_object_perm(fp), fp.perms.Perm3+fp.perms.Perm4)
    
    def testGetObjectsWithPermission(self):
        fp = self.fp
        u = self.u
        g = self.g
        
        # Clean the slate
        u.revoke_all_object_perm(fp)
        g.revoke_all_object_perm(fp)
        self.assertEquals(u.get_object_perm(fp), 0)
        self.assertEquals(g.get_object_perm(fp), 0)
        
        g.grant_object_perm(fp, fp.perms.Perm1 + fp.perms.Perm4)
        objs = u.get_objects_with_perms(FlatPage, fp.perms.Perm4)
        self.assertEquals(len(objs), 0)
        
        g.user_set.add(u)
        objs = u.get_objects_with_perms(FlatPage, fp.perms.Perm1)
        self.assertEquals(fp, objs[0])
        objs = u.get_objects_with_perms(FlatPage, fp.perms.Perm2)
        self.assertEquals(len(objs), 0)
        
    
    def testSignals(self):
        self.create_simpletext()
        st = self.st
        u = self.u
        g = self.g
        g.user_set.add(u)
        
        def my_user_handler(sender, to_whom, to_what, **kwargs):
            self.assertTrue(isinstance(sender, UserPermission))
            if isinstance(to_what, SimpleText):
                stis = to_what.simpletaggeditem_set.all()
                for item in stis:
                    to_whom.set_object_perm(item, sender.permission)
            else:
                self.assertTrue(isinstance(to_what, SimpleTaggedItem))
        
        def my_group_handler(sender, to_whom, to_what, **kwargs):
            self.assertTrue(isinstance(sender, GroupPermission))
            if isinstance(to_what, SimpleText):
                stis = to_what.simpletaggeditem_set.all()
                for item in stis:
                    to_whom.set_object_perm(item, sender.permission)
            else:
                self.assertTrue(isinstance(to_what, SimpleTaggedItem))
        
        from signals import permission_changed
        permission_changed.connect(my_user_handler)
        
        u.grant_object_perm(st, st.perms.perm1)
        for item in st.simpletaggeditem_set.all():
            self.assertEquals(u.get_object_perm(item), u.get_object_perm(st))
        permission_changed.disconnect(my_user_handler)
        permission_changed.connect(my_group_handler)
        g.grant_object_perm(st, st.perms.perm2)
        for item in st.simpletaggeditem_set.all():
            self.assertEquals(u.get_object_perm(item), u.get_object_perm(st))
        
        

########NEW FILE########
__FILENAME__ = views
from django.http import HttpResponseForbidden #, HttpResponseRedirect, Http404
# from django.shortcuts import render_to_response
from django.template import loader, RequestContext
# from django.utils.translation import ugettext, ugettext_lazy as _


# modified from django-authority
def permission_denied(request, template_name=None, extra_context={}):
    """
    Default 403 handler.

    Templates: `403.html`
    Context:
        request_path
            The path of the requested URL (e.g., '/app/pages/bad_page/')
    """
    if template_name is None:
        template_name = ('403.html',)
    context = {
        'request_path': request.path,
    }
    context.update(extra_context)
    return HttpResponseForbidden(loader.render_to_string(template_name, context,
                                 context_instance=RequestContext(request)))

########NEW FILE########
