<wiki:toc max_depth="3" />
Blade FAQ
========

运行环境
-------

### 为什么blade不能在我的平台运行？

描述：
运行blade , 报syntax error。

解决过程：

1. blade 运行需要python 2.6 以上. 请使用python -V 查看python 版本。
- 装了python 2.7还是报错，确认 ptyhon -V 看到的是新版本，必要时配置PATH环境变量或者重新登录。
- 使用env python, which python 等命令查看python命令到底用的是哪个。

### vim 编辑 BUILD 文件时没有语法高亮
 * 首先确认是否是以 install 的方式安装的
 * 然后检查 ~/.vim/syntax/blade.vim 是否存在，是否指向正确的文件
 * 然后检查 ~/.vimrc 里是否有 autocmd! BufRead,BufNewFile BUILD set filetype=blade
这条命令。
 * 如果问题还没解决，请联系我们。

### 为什么alt用不了？

描述：
alt 用不了

解决过程：

 1. 重新执行install
 - 把 ~/bin 加入到用户profile，重新登录


## 构建问题

### 为什么deps 里有写的依赖target顺序不同，编译结果不同？

描述：
//common/config/ini:ini 在某个库的deps里放置的顺序不同，放前面没有通过，放到后面通过了。

解决过程：

 * 查看编译错误输出，中间有个库su.1.0是prebuilt库。
 * //common/config/ini:ini 放在这个target 前后编译结果不一样。
 * 经查看，su.1.0 依赖//common/config/ini:ini，但是没有编译进静态库。所以
//common/config/ini:ini 放到它后面时，gcc按顺序查找能查找到symbols, 但放在
su.1.0 前就查找不到了，所以输出undefined reference.

结论：

 * 建议尽量源代码编译项目。
 * 减少prebuilt项目，prebuilt库尽量补全依赖的target。

### ccache缓存了错误信息，是不是ccache出问题了？

描述：
编译提示有错误，在源文件里修改后重新编译还是有错误，是不是ccache缓存了告警或者错误信息，没有更新出问题了 ？

解决过程：

 1. 查看ccache manual, ccache在direct mode 可能会有internal error。
 - 告知XFS同事如果再次遇到这个问题，立刻修改配置查看是否是cache自身问题。
 - 同时查看预处理cpp文件后的结果，发现头文件修改没有反映在预处理后的文件里。
 - 应该是包含路径错误，经过查找，build64_release下存在相同的头文件，而且build64_release默认是加到
-I里， 编译时默认加入 -Ibuild64_realease -I.
在build64_realease 首先查找头文件， 因此找到这个同名头文件，XFS同事放了一个文件在这个输出目录里，但是修改的却是
自己的工程文件。

结论：

 * 检查include path。

### 我只有一个没有源代码的库，如何使用
请参考[[#cc_library]]中，关于prebuilt的部分。

### prebuilt 库只有.so文件，我也只需要编译.so 库？
描述：
prebuilt 库只有.so文件，我也只需要编译.so 库

解决过程：

 1. cc_library 如果需要编译为动态库，那么只需要提供动态库。
 - cc_plugin 需要静态库。

结论：
 * 所以prebuilt库最好提供静态库和动态库。
 * 升级到最新blade。

### 手头只有无源代码的静态库，但是我们需要编译动态库
描述：
只提供了静态库，但是我们需要编译动态库 ？

解决过程：

 1. .a files are just archives of .o object files, so all you need to do is unpack the archive and repackage them as a shared object (.so)。
```bash
ar -x mylib.a
gcc -shared *.o -o mylib.so
```
 - 我们提供了脚本自动转, atoso
 - so 不能转为 .a 库。

结论：无源代码时，最好同时得到动态和静态库。

### blade支持环境变量里指定的gcc去编译项目吗？
描述：
想使用特定版本的gcc编译项目。

解决过程：

 * CC=/usr/bin/gcc CXX=/usr/bin/g++ CPP=/usr/bin/cpp LD=/usr/bin/g++ blade targets

结论：

 * 升级到最新blade且注意环境变量的配置要一致，即使用版本一致的编译器和linker。

### 我的代码已经修改了，blade编译还有问题？
描述：
在CI机器上，blade编译有error, 修复错误后从新从svn拉取，但是还是提示相同的错误。

解决过程：
 * 检查文件是否是修改后的copy.
 * 该文件由于在CI机器上是root权限，而该同事登录机器的用户名不是root, 覆盖不了原来的文件。
 * 提示错误的文件是老文件。

结论：
 * 权限切换时需要注意文件的所属者。

### 编译出来的SO库带有路径信息？
描述：
使用Blade编译出来的so库带有路径信息，使用起来麻烦，可以配置更改一下吗 ？

在一个大的项目中，不同的子项目，库完全可能重名，如果人工去协调这个问题，显然是划不来的。
因此，Blade使用库时，总是带有路径信息的，从根本上避免了这个问题。用的时候也带上路径即可。

### 为什么Blade新加的error flag 不起作用？
描述：
使用更新后的Blade编译本地项目发现error flag 没有起作用 ？

解决过程：

 1. 检查Blade是否是最新的。
 - 检查cpp程序是否把error flag 过滤了，如果不支持这个error flag, Blade 不会使用，否则编译报错。
 - 检查后发现gcc版本过低。

结论：

 * 升级gcc。

### blade -c 清除不了项目生成的文件
描述：
blade -c 清除不了项目生成的文件

解决过程：

 - 请先检查命令是否配对使用blade -prelease with blade -prelease -c , blade -pdebug with blade -pdebug -c。

结论：

 * 检查命令。

### 如何显示构建的命令行
我想看到构建过程中中执行的完整命令。
构建时加上 --verbose 参数，就能显示完整的命令行。

### 我修改了源文件，为何还是失败，报错位置也匹配不上(或者没有重新编译)?
首先 alt 到 build 目录下，看看是不是把源代码（或者头文件）放在这里了，由于 Blade 分离了源码和构建结果目录，Blade 也会到构建结果目录找源码优先，而且由于 scons 的限制，还会更优先，因此产生这样的错误，目前还没有好的解决办法。
如果是源文件误放到这里，构建时会显示 Compiling build64_release/...，根据这一点能更容易定位这个问题。

### 如何发布预编译的库?
有些机密的代码，希望以库的方式发布，但同时又依赖了非机密的库（比如common），如何发布呢？
比如这样的库：
```
cc_library(
    name = 'secrity',
    srcs = 'secrity.cpp',
    deps = [
        '//common/base/string:string',
        '//thirdparty/glog:glog',
    ]
)
```
这样发布：
修改 BUILD 文件，去掉 srcs
```
cc_library(
    name = 'secrity',
    prebuilt = True, # srcs 改为这个
    deps = [
        '//common/base/string:string',
        '//thirdparty/glog:glog',
    ]
)
```
同时对外的头文件保持不变，按照cc_library介绍中，prebuild要求的方式组织库即可。
尤其需要注意的是，deps 必须保持不变，且不要把虽然被你一来但却不属于你的项目的库作为预编译库发布出去。

### unrecognized options 是什么意思？
比如 unrecognized options {'link_all_symbols': 1}。
不同的目标有不同的选项参数，如果传了目标所不支持的参数，就会报告这个错误。可能的原因是误用了其他目标的参数，或者拼写错误，对于后一种情况，BLADE的vim语法高亮功能可以帮你更容易看到错误。

### Source file xxx.cc belongs to both xxx and yyy 是什么意思？
比如 Source file cp_test_config.cc belongs to both cc_test xcube/cp/jobcontrol:job_controller_test and cc_test xcube/cp/jobcontrol:job_context_test？

为了避免不必要的重复编译和可能的编译参数不同导致违反 C++ 的[http://en.wikipedia.org/wiki/One_Definition_Rule 一次定义规则]，通常每个源文件应该只属于一个目标，如果一个源文件被多个目标使用，应该写成单独的 cc_library，并在 deps 中依赖这个库。

### 如何开启 C++11
编辑配置文件，加入：
```
cc_config(
    cxxflags='gnu++0x'
)
```

程序故障
---------


<wiki:toc max_depth="2" />

Blade用户手册
============

Blade是什么
---------

软件项目用各种工具来构建代码，最常用的恐怕是GNU Make。但是 GNU Make 虽然本身功能比较强，但是要直接使用的话，也是比较难的。

很多人还在手工编写 Makefile，又没有去写正确的依赖，导致每次不得不先 make clean 才放心，Make的意义大打折扣。这在几个文件的小项目下是没什么问题的，对于大的项目就很不方便了。

Autotools 号称auto，但是还是需要人工写很多东西，运行一系列命令，用起来还是比较复杂，开发人员的学习和使用的门槛很高。

Blade 就是针对这些问题，为腾讯公司基础架构部的[http://storage.it168.com/a2011/1203/1283/000001283196.shtml “台风”云计算平台]项目而开发的新一代构建工具，希望能成为开发者手中的“瑞士军刀”。我们现在把它开源出来，希望能让更多的人得到方便。

Blade 解决的问题
-----------------
* 源文件更新导致需要重新构建。这个 gnu make 都能解决得很好。
* 头文件更新，所以以来这个头文件的源文件都需要重新构建。这个 gnu make 不直接支持，需要搭配 gcc 来生成和更新依赖。
* 库文件更新，所依赖的库文件更新后，程序应该重新连接，GNU Make 可以做到。
* 即使我只构建自己的目标，如果库的源代码变了，库应该重新生成，GNU Make 用递归 Make 无法做到。
* 库文件之间的依赖自动传递，一个库依赖另一个库，库的最终用户不需要关心。
* 构建过程中的警告和错误应该醒目地显示出来。
* 能自动支持台风系统大量使用的 proto buffer，以及方便扩充以支持外来可能引入的新工具。
* 应该能集成自动测试，代码检查等开发常用的功能。

Blade运行条件
---------------
Blade 运行时需要以下条件：

* SCons v2.0 or later   (required)
* Python v2.6 or later  (required)
* ccache v3.1 or later  (optional)

Blade 编译项目时可能需要到：

* swig   v2.0 or later  (required for swig_library)
* flex v2.5 or later    (required for lex_yacc)
* bison v2.1 or later   (required for lex_yacc)

源代码树的组织
------------
Blade要求项目源代码有一个明确的根目录，C++ 中的 #include 的路径也需要从这个目录开始写起，这样有几点好处：

* 有效地避免头文件重名造成的问题。
* 有效地避免库文件的重名。
* 更容易找到需要的文件。
* 提高构建速度。

Blade并不从某个配置文件或者环境变量读取这个信息，因为开发人员往往需要同时有多个目录树并存。Blade获取源代码根的方法是，无论当前从哪一级子目录运行，都从当前目录开始向上查找BLADE_ROOT文件，有这个文件的目录即为源代码树的根。

目前源代码目录需要自己拉取，将来我们会集成到 Blade 中。BLADE_ROOT 文件也需要用户自己创建。方法：
 $ touch BLADE_ROOT

一个源代码树的根目录看起来的样子如下：
 BLADE_ROOT
 common
 thirdparty
 xfs
 xcube
 torca
 your_project
 ...

BUILD文件
--------

Blade 通过一系列的名字为 "BUILD" 的文件（文件名全大写），这些文件需要开发者去编写。每个 BUILD文件通过一组目标描述函数描述了一个目标的源文件，所依赖的其他目标，以及其他一些属性。

### BUILD文件的示例

构建脚本很简单：

范例：common/base/string/BUILD
```python
cc_library(
    name = 'string',
    srcs = [
        'algorithm.cpp',
        'string_number.cpp',
        'string_piece.cpp',
        'format.cpp',
        'concat.cpp'
    ],
    deps = ['//common/base:int']
)
```
也是说明式的，只需要列出目标名，源文件名和依赖名（可以没有）即可。

风格建议
---------
* 四空格缩进，不要用tab字符
* 总是用单引号
* 目标名用小写
* src 里的文件名按字母顺序排列
* deps 里先写本目录内的依赖（:target），后写其他目录内的（//dir:name），分别按字母顺序排列。
* 不同目标之间空一行，前面可以加注释
* 注释的 # 后面空一格，比如 # This is a comment

### 描述目标

Blade用一组target函数来定义目标，这些target的通用属性有：

 * name: 字符串，和路径一起成为target的唯一标识，也决定了构建的输出命名
 * srcs: 列表或字符串，构建该对象需要的源文件，一般在当前目录，或相对于当前目录的子目录中
 * deps: 列表或字符串，该对象所依赖的其它targets

deps的允许的格式：

 * "//path/to/dir/:name" 其他目录下的target，path为从BLADE_ROOT出发的路径，name为被依赖的目标名。看见就知道在哪里。
 * ":name" 当前目录下的target， path可以省略。
 * "#pthread" 系统库。直接写#跟名字即可。

cc_`*` 目标
包括 cc_test, cc_binary, cc_library，CC 目标均支持的参数为：

 * srcs 源文件列表
 * deps 依赖列表
 * incs 头文件路径列表
 * defs 宏定义列表
 * warning 警告设置
 * optimize 优化设置

* 注：thirdparty是我们代码库里的一个特殊目录，里面的代码都是一些第三方库，按照台风系统的代码规范，只允许对这里的代码用incs, defs和warnings，自己开发的代码要按照规范组织。Blade会对这个目录之外的代码使用这些参数发出警告。

|| *字段* || *解释* || *举例* || *备注* ||
|| warning || 是否屏蔽warning  || warning='no' || 默认不屏蔽 warning='yes' , 默认不用写，已开启 ||
|| defs || 用户定义的宏加入编译中 || defs=['_MT'] || 如果用户定义C++关键字，报warning ||
|| incs || 用户定义的include || incs=['poppy/myinc'] || 用户通常不要使用 ||
|| optimize || 用户定义的optimize flags || optimize=['O3'] || 适用于 cc_library cc_binary cc_test proto_library swig_library  cc_plugin resource_library ||


#### cc_library

用于描述C++库目标。
cc_library同时用于构建静态和动态库，默认只构建静态库，只有被dynamic_link=1的cc_binary依赖时或者命令行指定
--generate-dynamic 才生成动态链接库。

举例：
```python
cc_library(
    name='lowercase',
    srcs=['./src/lower/plowercase.cpp'],
    deps=['#pthread'],
    link_all_symbols=False
)
```

参数：

* link_all_symbols=True
库在被静态链接时，确保库里所有的符号都被链接，以保证依赖全局对象构造函数，比如自动注册器的代码能够正常工作。
需要全部链接的部分最好单独拆分出来做成全部链接的库，而不是整个库全都全部链接，否则会无端增大可执行文件的大小。 需要注意的是，link_all_symbols是库自身的属性，不是使用库时的属性。Blade是为大型项目设计的，基于以下因素，我们提倡任何模块都应该有自己的 cc_library，用户程序都应该在deps里写全直接依赖，不提倡创建像boost那样的全头文件的库。
 * 编译速度
 * 将来未知的改变，比如某库一开始只需要头文件就能使用，不依赖标准库之外的任何库，但是后来依赖了MD5，所有使用这个库的代码都要加上新产生的依赖，这与我们设计Blade的初衷是违背的。

要强制用户这样使用，可以在编写代码时，总是编写 .h 对应的 .cpp 文件，并把一部分必然要用到的符号（函数，静态变量）的实现写在里面，即使对于模板库，可以引入一个非模板的基类，或者把非模板部分的实现放到 .cpp 里。

* always_optimize
True: 不论debug版本还是release版本总是被优化。
False: debug版本不作优化。
默认为False。目前只对cc_library有效。

* prebuilt=True
主要应用在thirdparty中从rpm包解来的库，使用这个参数表示不从源码构建。对应的二进制文件必须存在 lib{32,64}_{release,debug} 这样的子目录中。不区分debug/release时可以只有两个实际的目录。

####cc_binary
定义C++可执行文件目标
```python
cc_binary(
    name='prstr',
    srcs=['./src/mystr_main/mystring.cpp'],
    deps=['#pthread',':lowercase',':uppercase','#dl'],
)
```

* dynamic_link=True
目前我们的binary默认为全静态编译以适应云计算平台使用。
如果有应用需要动态编译方式，可以使用此参数指定，此时被此target依赖的所有库都会自动生成对应的动态库供链接。
需要注意的是，dynamic_link只适用于可执行文件，不适用于库。

* export_dynamic=True
常规情况下，so中只引用所依赖的so中的符号，但是对于应用特殊的场合，需要在so中引用宿主可执行文件中的符号，就需要这个选项。
这个选项告诉连接器在可执行文件的动态符号表中加入所有的符号，而不只是用到的其他动态库中的符号。这样就使得在dlopen方式加载的so中可以调用可执行文件中的这些符号。
详情请参考 man ld(1) 中查找 --export-dynamic 的说明。

####cc_test
相当于cc_binary，再加上自动链接gtest和gtest_main
还支持testdata参数， 列表或字符串，文件会被链接到输出所在目录name.runfiles子目录下，比如：testdata/a.txt =>name.runfiles/testdata/a.txt
用blade test子命令，会在成功构建后到name.runfiles目录下自动运行，并输出总结信息。

* testdata=[]
在name.runfiles里建立symbolic link指向工程目录的文件，目前支持
以下几种形式

 * 'file'
在测试程序中使用这个名字本身的形式来访问
 * '//your_proj/path/file'
在测试程序中用"your_proj/path/file"来访问。
 * ('//your_proj/path/file', "new_name")
在测试程序中用"new_name"来访问

可以根据需要自行选择，这些路径都也可以是目录。
```python
cc_test(
    name = 'textfile_test',
    srcs = 'textfile_test.cpp',
    deps = ':io',
    testdata = [
        'test_dos.txt',
        '//your_proj/path/file',
        ('//your_proj/path/file', 'new_name')
    ]
)
```

#### proto_library
用于定义protobuf目标
deps 为import所涉及的其他proto_library
自动依赖protobuf，使用者不需要再显式指定。
构建时自动调用protoc生成cc和h，并且编译成对应的cc_library
```python
proto_library(
    name = 'rpc_meta_info_proto',
    srcs = 'rpc_meta_info.proto',
    deps = ':rpc_option_proto',
)
```
Blade支持proto_library，使得在项目中使用protobuf十分方便。

要引用某 proto 文件生成的头文件，需要从 BLADE_ROOT 的目录开始，只是把 proto 扩展名改为 pb.h 扩展名。
比如 //common/base/string_test.proto 生成的头文件，路径为 "common/base/string_test.pb.h"。

#### thrift_library
用于定义thrift库目标
deps 为import所涉及的其他thrift_library
自动依赖thrift，使用者不需要再显式指定。
构建时自动调用thrift命令生成cpp和h，并且编译成对应的cc_library

```python
thrift_library(
    name = 'shared_thrift',
    srcs = 'shared.thrift',
)
thrift_library(
    name = 'tutorial_thrift',
    srcs = 'tutorial.thrift',
    deps = ':shared_thrift'
)
```

C++中使用生成的头文件时，规则类似proto，需要带上相对BLADE_ROOT的目录前缀。
 * thrift 0.9版（之前版本未测）有个[https://issues.apache.org/jira/browse/THRIFT-1859 bug]，需要修正才能使用，此bug已经在开发版本中[https://builds.apache.org/job/Thrift/633/changes#detail13 修正]

#### lex_yacc_library

srcs 必须为二元列表，后缀分别为ll和yy
构建时自动调用flex和bison, 并且编译成对应的cc_library

```python
lex_yacc_library(
     name = 'parser',
     srcs = [
         'line_parser.ll',
         'line_parser.yy'
     ],
     deps = [
         ":xcubetools",
     ],
     recursive = True
)
```

* recursive=True
生成可重入的C scanner.


#### gen_rule

用于定制自己的目标
outs = []，表示输出的文件列表，需要填写这个域gen_rule才会被执行
cmd, 字符串，表示被调用的命令行
cmd中可含有如下变量，运行时会被替换成srcs和outs中的对应值
$SRCS
$OUTS
$FIRST_SRC
$FIRST_OUT
$BUILD_DIR -- 可被替换为 build[64,32]_[release,debug] 输出目录

```python
gen_rule(
    name='test_gen_target',
    cmd='echo what_a_nice_day;touch test2.c',
    deps=[':test_gen'],                         # 可以有deps , 也可以被别的target依赖
    outs=['test2.c']
)
````

很多用户使用gen_rule动态生成代码文件然后和某个cc_library或者cc_binary一起编译，
需要注意应该尽量在输出目录生成代码文件,如build64_debug下，并且文件的路径名要写对，
如 outs = ['websearch2/project_example/module_1/file_2.cc'], 这样使用
gen_rule生成的文件和库一起编译时就不会发生找不到动态生成的代码文件问题了。

####swig_library

根据.i文件生成相应的python, java 和php cxx模块代码，并且生成对应语言的代码。

```python
swig_library(
    name = 'poppy_client',
    srcs = [
        'poppy_client.i'
    ],
    deps = [
        ':poppy_swig_wrap'
    ],
    warning='yes',
    java_package='com.soso.poppy.swig',   # 生成的java文件的所在package名称
    java_lib_packed=1, # 表示把生成的libpoppy_client_java.so打包到依赖者的jar包里，如java_jar依赖这个swig_library
    optimize=['O3']    # 编译优化选项
)
```

* warning
这里的warning仅仅指swig编译参数cpperraswarn是否被指定了，swig_library默认使用非标准编译告警级别（没有那么严格）。

#### cc_plugin

支持生成target所依赖的库都是静态库.a的so库，即plugin。
```python
cc_plugin(
    name='mystring',
    srcs=['./src/mystr/mystring.cpp'],
    deps=['#pthread',':lowercase',':uppercase','#dl'],
    warning='no',
    defs=['_MT'],
    optimize=['O3']
)
```

cc_plugin 是为 JNI，python 扩展等需要动态库的场合设计的，不应该用于其他目的。

#### resource_library
编译静态资源。

大家都遇到过部署一个可执行程序，还要附带一堆辅助文件才能运行起来的情况吧？
blade通过resource_library，支持把程序运行所需要的数据文件也打包到可执行文件里，
比如poppy下的BUILD文件里用的静态资源：
```python
resource_library(
    name = 'static_resource',
    srcs = [
        'static/favicon.ico',
        'static/forms.html',
        'static/forms.js',
        'static/jquery-1.4.2.min.js',
        'static/jquery.json-2.2.min.js',
        'static/methods.html',
        'static/poppy.html'
    ]
)
```
生成  和 libstatic_resource.a 或者 libstatic_resource.so。
就像一样protobuf那样，编译后后生成一个库libstatic_resource.a，和一个相应的头文件static_resource.h，带路径包含进来即可使用。

在程序中需要包含static_resource.h（带上相对于BLADE_ROOT的路径）和"common/base/static_resource.hpp"，
用 STATIC_RESOURCE 宏来引用数据：
```c
StringPiece data = STATIC_RESOURCE(poppy_static_favicon_ico);
```
STATIC_RESOURCE 的参数是从BLADE_ROOT目录开始的数据文件的文件名，把所有非字母数字和下划线的字符都替换为_。

得到的 data 在程序运行期间一直存在，只可读取，不可写入。

用 static resource 在某些情况下也有一点不方便：就是不能在运行期间更新，因此是否使用，需要根据具体场景自己权衡。

#### java_jar
编译java源代码。
```python
java_jar(
    name = 'poppy_java_client',
    srcs = [
        'src/com/soso/poppy'                 # 这里只需要指定java文件所在目录，不要写上具体java文件列表
    ],
    deps = [
        '//poppy:rpc_meta_info_proto',       # 可以依赖proto_library生成的java文件一起编译打包
        '//poppy:rpc_option_proto',
        '//poppy:rpc_message_proto',
        '//poppy:poppy_client',              # 可以依赖swig_library生成的java文件一起编译打包
        './lib:protobuf-java',               # 可以依赖别的jar包
        './lib:junit',
    ]
)
```
 * prebuilt=True
主要应用在已经编译打包好的java jar 包。

Blade的输出
-----------
构建过程是彩色高亮的
出错信息是彩色的，方便定位错误。

默认生成 native arch 的可执行文件，指定生成 32/64 位结果也很简单，加上 -m32/64即可。
默认生成 release 版本的结果，如果生成 debug 版的，加上 -p debug 即可。
默认构建当前目录，如果当前目录依赖的外面的模块需要重新构建，也会被连带构建起来（Make很难做到）。如果要从当前目录构建所有子目录的目标，也很简单：blade ... 即可。

不同构建选项的结果放在不同的目录下，生成的文件一律按层次也放在这个目录里，不会污染源代码目录。

要清除构建结果（一般不需要），blade clean 即可。

Blade Cache
-----------
blade 支持 cache，可以大幅度加快构建速度。
blade 支持两种cache
* ccache , cache配置使用ccache的配置, 如通过配置 CCACHE_DIR 环境变量指定ccache目录。
* ccache 没有安装，则使用scons cache, 配置细节如下

scons cache需要一个目录，依次按以下顺序检测：
* 命令行参数--cache-dir
* 环境变量BLADE_CACHE_DIR
* 如果均未配置，则不启用cache。
* 空的BLADE_CACHE_DIR变量或者不带参数值的--cache-dir=, 则会禁止cache。

--cache-size 如不指定，则默认为2G，如指定，则使用用户指定的以Gigabyte为单位的大小的cache。
如 --cache-dir='~/user_cache' --cache-size=16 (16 G)大小cache。
用户可以根据需要配置大小，超出大小blade会执行清理工作，限制cache大小在用户指定的cache大小，
请谨慎设置这个大小，因为涉及到构建速度和机器磁盘空间的占用。

测试支持
-------------
Blade test支持增量测试 ，可以加快tests的执行。
已经Pass 的tests 在下一次构建和测试时不需要再跑，除非：

* tests 的任何依赖变化导致其重新生成。
* tests 依赖的测试数据改变，这种依赖为显式依赖，用户需要使用BUILD文件指定，如testdata。
* tests 所在环境变量发生改变。
* test arguments 改变。
* Fail 的test cases ，每次都重跑。

如果需要使用全量测试，使用--full-test option, 如 blade test common/... --full-test ， 全部测试都需要跑。
另外，cc_test 支持了 always_run 属性，用于在增量测试时，不管上次的执行结果，每次总是要跑。
```python
cc_test(
    name = 'zookeeper_test',
    srcs = 'zookeeper_test.cc',
    always_run = True
)
```

Blade test支持并行测试，并行测试把这一次构建后需要跑的test cases并发地run。
blade test [targets] --test-jobs N
-t, --test-jobs N 设置并发测试的并发数，Blade会让N个测试进程并行执行

对于某些因为可能相互干扰而不能并行跑的测试，可以加上 exclusive 属性
```python
cc_test(
    name = 'zookeeper_test',
    srcs = 'zookeeper_test.cc',
    exclusive = True
)
```

命令行参考
---------
```bash
blade `[`action`]` `[`options`]` `[`targets`]`
```

action是一个动作，目前有

* build 表示构建项目
* test  表示构建并且跑单元测试
* clean 表示清除目标的构建结果
* query 查询目标的依赖项与被依赖项
* run   构建并run一个单一目标

targets是一个列表，支持的格式：

* path:name 表示path中的某个target
* path表示path中所有targets
* path/... 表示path中所有targets，并递归包括所有子目录
* :name表示当前目录下的某个target
默认表示当前目录

参数列表：

* -m32,-m64            指定构建目标位数，默认为自动检测
* -p PROFILE           指定debug/release，默认release
* -k, --keep-going     构建过程中遇到错误继续执行（如果是致命错误不能继续）
* -j N,--jobs=N        N路并行编译，多CPU机器上适用
* -t N,--test-jobs=N   N路并行测试，多CPU机器上适用
* --cache-dir=DIR      指定一个cache目录
* --cache-size=SZ      指定cache大小，以G为单位
* --verbose            完整输出所运行的每条命令行
* –h, --help           显示帮助
* --color=yes/no/auto  是否开启彩色
* --generate-dynamic   强制生成动态库
* --generate-java      为proto_library 和 swig_library 生成java文件
* --generate-php       为proto_library 和 swig_library 生成php文件
* --gprof              支持 GNU gprof
* --gcov               支持 GNU gcov 做覆盖率测试

配置
----
Blade 支持三个配置文件

* blade.zip 同一个目录下的 blade.conf，这是全局配置。
* ~/.bladerc 用户 HOME 目录下的 .bladerc 文件，这是用户级的配置。
* BLADE_ROOT 其实也是个配置文件，写在这里的是项目级配置。

后面描述的所有多个参数的配置的每个配置参数都有默认值，并不需要全部写出，也没有顺序要求。

### cc_config
所有c/c++目标的公共配置
```python
cc_config(
    extra_incs = ['thirdparty'],  # 额外的 -I，比如 thirdparty
    warnings = ['-Wall', '-Wextra'...], # C/C++公用警告
    c_warnings = ['-Wall', '-Wextra'...], # C专用警告
    cxx_warnings = ['-Wall', '-Wextra'...], # C++专用警告
    optimize = '-O2', # 优化级别
)
```
所有选项均为可选，如果不存在，则保持先前值。发布带的blade.conf中的警告选项均经过精心挑选，建议保持。

### cc_test_config
构建和运行测试所需的配置
```python
cc_test_config(
    dynamic_link=True,   # 测试程序是否默认动态链接，可以减少磁盘开销，默认为 False
    heap_check='strict', # 开启 gperftools 的 HEAPCHECK，具体取值请参考 gperftools 的文档
    gperftools_libs='//thirdparty/perftools:tcmalloc',  # tcmclloc 库，blade deps 格式
    gperftools_debug_libs='//thirdparty/perftools:tcmalloc_debug', # tcmalloc_debug 库，blade deps 格式
    gtest_libs='//thirdparty/gtest:gtest',  # gtest 的库，blade deps 格式
    gtest_main_libs='//thirdparty/gtest:gtest_main' # gtest_main 的库路径，blade deps 格式
)
```

所有的 config 的列表类型的选项均支持追加模式，用法如下：

```python
cc_config(
    append = config_items(
        warnings = [...]
    )
)
```

注意:

* gtest 1.6开始，去掉了 make install，但是可以绕过[http://blog.csdn.net/chengwenyao18/article/details/7181514 gtest1.6.0安装方法]。
* gtest 库还依赖 pthread，因此gtest_libs需要写成 ['#gtest', '#pthread']
* 或者把源码纳入你的源码树，比如thirdparty下，就可以写成gtest_libs='//thirdparty/gtest:gtest'。

### proto_library_config
编译protobuf需要的配置
```python
proto_library_config(
    protoc='protoc',  # protoc编译器的路径
    protobuf_libs='//thirdparty/protobuf:protobuf', # protobuf库的路径，Blade deps 格式
    protobuf_path='thirdparty', # import 时的 proto 搜索路径，相对于 BLADE_ROOT
    protobuf_include_path = 'thirdparty',  # 编译 pb.cc 时额外的 -I 路径
)
```

### thrift_library_config
编译thrift需要的配置
```python
thrift_library_config(
    thrift='thrift',  # protoc编译器的路径
    thrift_libs='//thirdparty/thrift:thrift', # thrift库的路径，Blade deps 格式
    thrift_path='thirdparty', # thrift中include时的thrift文件的搜索路径，相对于 BLADE_ROOT
    thrift_incs = 'thirdparty',  # 编译 thrift生成的.cpp 时额外的 -I 路径
)
```

所有这些配置项都有默认值，如果不需要覆盖就无需列入相应的参数。默认值都是假设安装到系统目录下，如果你的项目中把这些库放进进了自己的代码中（比如我们内部），请修改相应的配置。

环境变量
----------

Blade还支持以下环境变量：

* TOOLCHAIN_DIR，默认为空
* CPP，默认为cpp
* CXX，默认为c++
* CC，默认为gcc
* LD，默认为c++

TOOLCHAIN_DIR和CPP等组合起来，构成调用工具的完整路径，例如：

调用/usr/bin下的gcc（开发机上的原版gcc）
```bash
TOOLCHAIN_DIR=/usr/bin blade
```
使用clang
```bash
CPP='clang -E' CC=clang CXX=clang++ ld=clang++ blade
```

如同所有的环境变量设置规则，放在命令行前的环境变量，只对这一次调用起作用，如果要后续起作用，用 export，要持久生效，放入 ~/.profile 中。

环境变量的支持将来考虑淘汰，改为配置编译器版本的方式，因此建议暂时不要使用。

辅助命令
------------
### install
blade命令的符号链接会被安装下面的命令到~/bin 下。

### lsrc
列出当前目录下指定的源文件，以blade的srcs列表格式输出。

### genlibbuild
自动生成以目录名为库名的cc_library，以测试文件的名为名的cc_test，proto的BUILD文件，并假设这些测试都依赖这个库

### vim集成
我们编写了vim的blade语法文件，高亮显示blade关键字，install后就会自动生效。

我们编写了 Blade 命令，使得可以在 vim 中直接执行 blade，并快速跳转到出错行（得益于 vim 的 [hquickfix](ttp://easwy.com/blog/archives/advanced-vim-skills-quickfix-mode/) 特性）。

使用时直接在 vim 的 : 模式输入（可带参数）

```vim
:Blade
```

即可构建。

这个命令的源代码在 tools/.vimrc 中。

### alt
在源代码目录和构建目标目录之间跳转

安装
------

执行install脚本即可安装到~/bin下，目前因还在开发阶段，变化还比较快，以软链方式安装，install后不能删除checkout出来的原始目录。
目前blade生成scons脚本，因此还需要安装scons 2.0以上版本。
Blade 需要支持 Python 2.4-2.7.x，不支持 python3。

install使得可以在任何目录下直接执行

```bash
$ blade
```

命令。
如果不行，确保~/bin在你的PATH环境变量里，否则修改 ~/.profile，加入

```bash
export PATH=~/bin:$PATH
```

然后重新登录即可。


我们的理念：解放程序员，提高生产力。用工具来解决非创造性的技术问题。

Sample: template
Minimum spec: SM 1.0

A trivial template project that can be used as a starting point to create new CUDA projects.

Key concepts:

Blade Unified Construction Collection
=======================================

http://code.tencent.com/projects/blade

Overview
-----------------------------

Blade is designed to be a distributed unified building
system. It is powerful and easy to use. It supports
building mulitiple languages, such as c/c++, Java, protobuf
and swig etc. It analyzes the target dependency automatically
and integrates compiling and linking, testing(incremental
testing and parallel testing), static code inspection functions
together. It aims to improve the clarity and simplicity of the
building rules for a project.

Requirements for End Users
-----------------------------

Blade is designed to have fairly minimal requirements
to build your projects, but there are some. Currently we
only support Linux. We will also make our best effort to
support other platforms (e.g. Solaris, Windows).
However, since core members of the Blade project have no
access to these platforms, it may have outstanding issues
there. If you notice any problems on your platform, please
notify michaelpeng@tencent.com or phongchen@tencent.com.
Patches for fixing them are even more welcome!

### Linux requirements ###
These are the basic requirements to use Blade as a source
package.

    * GNU Complier Collection (required)
    * Scons v2.0 or newer (required)
    * Python v2.6 or newer (required)
    * Ccache v3.1 or newer (optional)

If you want to make Blade to have the capability to build
every target it supports, these are the prerequisites.

    * swig v2.0 or newer (required for swig_library)
    * flex v2.5 or newer (required for lex_yacc)
    * bison v2.1 or newer (required for lex_yacc)

Requirements for Contributor
-----------------------------

We welcome patches. If you plan to contribute a patch,
you need to develop and test your patch from (SVN) checkout.
You need to have this requirement to develop. Blade is
written in python.

    * Python version 2.6 or newer (python 3.0 or newer excluded)

Getting the source
-----------------------------

You can directly check out the source from our Subversion (SVN)
repository. The SVN checkout requires a few extra steps and some
extra software packages on your system, but lets you track the
latest development and make patches much more easily, so we
highly encourage it.

### Source Package ###

    Blade is released in versioned source packages which is
    located at this site [1].

    [1] http://code.tencent.com/projects/blade

Setting up the collection
-----------------------------

End users or developers need to execute the install script to
intall Blade into current user environment. Please make sure
that ~/bin is in your PATH environment variable. We establish
several symbolic links that enable you to execute blade command.

Reference
-----------------------------
    [1] http://code.tencent.com/projects/blade
    [2] user manual is inside the package
    [3] developer manual is inside the package

Happy testing!

Documentation in zh_CN
===================

通知
---

* Blade 发布1.1.1，包含以下特性：
 * python 最低版本要求从2.7下降到2.4
 * 修正了python 2.7.0 argparse 模块 bug 带来的问题
 * install 命令支持 zsh
 * 集成cpplint，构建前自动调用cpplint对被更改的代码做代码检查。
 * 新增 cc_config.optimize 选项，可以控制整体默认优化级别。
 * 更新文档

贡献者名单：

* chenjingxu at qiyi dot com
* whuwxl at github dot com
* yeshunping at github dot com
* guanqun at github dot com

概述
---
Blade 是一个现代构建系统，期望的目标是强大而好用，把程序员从构建的繁琐中解放出来。

Blade主要定位于linux下的大型C++项目，密切配合研发流程，比如单元测试，持续集成，覆盖率统计等。但像unix下的文本过滤程序一样，保持相对的独立性，可以单独运行。目前重点支持i386/x86_64 Linux，未来可以考虑支持其他的类Unix系统。

在[腾讯公司“台风”云计算平台](http://wenku.it168.com/d_000434944.shtml)开发过程中，为了解决 GNU Make，Autotools 的难用和繁琐的问题，我们开发了这个全新的构建系统，整个系统基于多个声明式的构建脚本，在构建脚本里，只需要声明要构建什么目标，目标的源代码，以及其直接依赖的其它目标，不需要说明如何构建。大大降低了使用难度，提高了开发效率。

首先，Blade解决了依赖问题。
当你在构建某些目标时，头文件有变化，会自动重新构建。
最方便的是，Blade也能追踪库文件的依赖关系。比如
库 foo 依赖库 common，那么在库 foo 的 BUILD 文件中列入依赖：
```python
cc_library(
    name = 'foo',
    srcs = ...,
    deps = ':common'
)
```
那么对于使用foo的程序，如果没有直接用到common，那么久只需要列出foo，并不需要列出common。
```python
cc_binary(
    name = 'my_app',
    srcs = ...,
    deps = ':foo'
)
```
这样当你的库实现发生变化，增加或者减少库时，并不需要通知库的用户一起改动，Blade自动维护这层间接的依赖关系。当构建my_app时，也会自动检查foo和common是否也需要更新。

说到易用性，除了依赖关系的自动维护，Blade还可以做到，用户只需要敲一行命令，就能把整个目录树的编译链接和单元测试全部搞定。例如：

递归构建和测试common目录下所有的目标
```bash
$ blade test common...
```
以32位模式构建和测试
```bash
$ blade test -m32 common...
```
以调试模式构建和测试
```bash
$ blade test -pdebug common...
```
显然，你可以组合这些标志
```bash
$ blade test -m32 -pdebug common...
```
特点
---
* 自动分析头文件依赖关系，构建受影响的代码。
* 增量编译和链接，只构建因变更受影响而需要重新构建的代码。
* 自动计算库的间接依赖，库的作者只需要写出直接依赖，构建时自动检查所依赖的库是否需要重新构建。
* 在任意代码树的任意子目录下都能构建。
* 支持一次递归构建多个目录下的所有目标，也支持只构建任意的特定的目标。
* 无论构建什么目标，这些目标所依赖的目标也会被自动连坐更新。
* 内置 debug/release 两种构建类型。
* 彩色高亮构建过程中的错误信息。
* 支持 ccache
* 支持 distcc
* 支持基于构建多平台目标
* 支持构建时选择编译器（不同版本的gcc，clang等）
* 支持编译 protobuf，lex, yacc, swig
* 支持自定义规则
* 支持测试，在命令行跑多个测试
* 支持并行测试（多个测试进程并发运行）
* 支持增量测试（无需重新运行的测试程序自动跳过）
* 集成 gperftools，自动检测测试程序的内存泄露
* 构建脚本 vim 语法高亮
* svn 式的子命令命令行接口。
* 支持 bash 命令行补全
* 用 python 编写，无需编译，直接安装使用。

彻底避免以下问题：

* 头文件更新，受影响的模块没有重新构建。
* 被依赖的库需要更新，而构建时没有被更新，比如某子目录依

致谢
---
* Blade 是受 Google 官方博客发表的这篇文章启发而开发的：
[ 云构建：构建系统是如何工作的](http://google-engtools.blogspot.hk/2011/08/build-in-cloud-how-build-system-works.html)
* 现阶段 Blade 生成 [SCons](http://www.scons.org/) 脚本进行构建，因此 Blade 的运行还需要依赖 SCons。
* [Python](http://www.python.org) 是一种简单易用而又强大的语言，我们喜欢python。
* 为了支持python 2.6及更低版本，我们把python 2.7中的argparse.py放入了源码包。
* Google 开放的一些库强大而好用，我们很喜欢，我们把对这些库的支持集成进了Blade中，既方便了库的使用，又增强了 Blade，这些库包括 [glog](http://code.google.com/p/google-glog/), [protobuf](http://code.google.com/p/protobuf/),[gtest](http://code.google.com/p/googletest/), [gproftools](http://code.google.com/p/gperftools/)。

更多文档请参考Blade wiki。

欢迎使用以及帮助我们改进Blade，我们期待你的贡献。

Documentation in en_US
====================
Brief
----
Blade is designed to be a modern building system. It is powerful and easy to use. It supports building multiple languages, such as c/c++, Java, protobuf and swig etc. It analyzes the target dependency automatically and integrates compiling, linking, testing(includes incremental testing and parallel testing) and static code inspection
together. It aims to improve the clarity and simplicity of the building rules for a project.

With Blade, you can compile, link and test multiple targets by just inputting one simple command line.
For example:

Build and test all targets in common directory recursively.
```bash
$ blade test common...
```

Build and test targets as 32 bit
```bash
$ blade test -m32 common...
```
Build and test targets as debug mode
```bash
$ blade test -pdebug common...
```

And you can combine the flags together:
```bash
$ blade test -m32 -pdebug common...
```
Features
-------
* Auto dependency analysis, includes header files and libraries.
* Test integration: built-in support of gtest. Support incremental testing and parallel testing.
* Simple syntax, easy to use.
* Simple command line interface similar to svn.
* Memory leak checking(with gperftools).
* Bash command line completion.
* Colorful diagnostic message displaying.
* Vim integration, includes syntax hi-light, quickfix.

Credit
-----
* Blade is inspired by Google's public information about their building system. Here is a reference article from Google's official blog.
[http://google-engtools.blogspot.hk/2011/08/build-in-cloud-how-build-system-works.html build in cloud: how build system works]
* Blade generates [SCons](http://www.scons.org/) script internally, and it depends on SCons right now.
* [Python](http://www.python.org) is a powerful and easy-to-used language, we like python.
* To support python 2.6, we put argparse.py from python 2.7 into code base.
* Some libraries open sourced by Google, such as
[protobuf](http://code.google.com/p/protobuf/), [gtest](http://code.google.com/p/googletest/), [gproftools](http://code.google.com/p/gperftools/) are handy and powerful, we integrate these libraries into Blade, make them easier to use, and also enhance Blade's ability.

Read our wiki to get more documents. Only Chinese version is ready now, English version is coming soon, sorry for inconvenience.

Welcome to enjoy and help us to improve blade, we are expecting your contribution.

