__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# pyjaco documentation build configuration file, created by
# sphinx-quickstart on Tue Apr 27 13:05:04 2010.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.append(os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'pyjaco'
copyright = u'2010, hp-FEM group at UNR'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.1'
# The full version, including alpha/beta/rc tags.
release = '0.1'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'pyjacodoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'pyjaco.tex', u'pyjaco Documentation',
   u'hp-FEM group at UNR', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True

########NEW FILE########
__FILENAME__ = gol
from pyjaco.decorator import JavaScript, JSVar

@JavaScript()
@JSVar("window", "alert")
def StartGoL():
    window.gol = GoL()

@JavaScript()
class GoL(object):

    @JSVar("document", "Math", "setInterval", "self.canvas")
    def __init__(self):
        self.width = 75
        self.height = 75
        self.canvas = document.getElementById('canvas').getContext('2d')
        self.canvas.fillStyle = 'rgb(0, 0, 0)'
        self.grid = list(range(self.width * self.height))
        for i in range(self.width * self.height):
            self.grid[i] = Random() > 0.5

        setInterval('window.gol.PY$iter()', 250)
        self.draw()

    def get(self, x, y):
        return self.grid[((x + self.width) % self.width) + ((y + self.height) % self.height) * self.width]

    def iter(self):
        toDie = []
        toLive = []
        for x in range(0, self.width):
            for y in range(0, self.height):
                count = 0
                if self.get(x-1, y-1):
                    count += 1
                if self.get(x, y-1):
                    count += 1
                if self.get(x+1, y-1):
                    count += 1
                if self.get(x-1, y):
                    count += 1
                if self.get(x+1, y):
                    count += 1
                if self.get(x-1, y+1):
                    count += 1
                if self.get(x, y+1):
                    count += 1
                if self.get(x+1, y+1):
                    count += 1

                if self.get(x, y):
                    if count < 2:
                        toDie.append(x + y*self.width)
                    elif count > 3:
                        toDie.append(x + y*self.width)
                else:
                    if count == 3:
                        toLive.append(x + y*self.width)

        for i in range(len(toDie)):
            self.grid[toDie[i]] = False
        for i in range(len(toLive)):
            self.grid[toLive[i]] = True

        self.draw()

    @JSVar("self.canvas")
    def draw(self):
        i = 0
        for x in range(0, self.width*10, 10):
            for y in range(0, self.height*10, 10):
                if self.grid[i]:
                    self.canvas.fillRect(x, y, x+10, y+10)
                else:
                    self.canvas.clearRect(x, y, x+10, y+10)
                i += 1


def main():
    print """<html>
<head>
<!--[if IE]><script type="text/javascript" src="http://explorercanvas.googlecode.com/svn/trunk/excanvas.js"></script><![endif]-->
<script language="JavaScript" src="../py-builtins.js"></script>
<script language="JavaScript">
var Random = function() { return float(Math.random()); };
%s
</script>
</head>
<body onLoad="StartGoL()">
    <canvas id="canvas" width="750" height="750"></canvas>
</body>
</html>""" % (str(StartGoL)+"\n"+str(GoL))

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = clicker
@JSVar("jQuery")
def ready():
    jQuery('h1').click(on_click)

@JSVar("jQuery", "Math.random", "Math.floor")
def on_click():
    if jQuery('#when_clicked').html():
        r = Math.floor(Math.random() * 255)
        g = Math.floor(Math.random() * 255)
        b = Math.floor(Math.random() * 255)
        color = "rgb(%d, %d, %d)" %(r,g,b)
        jQuery('#when_clicked').attr('style', 'background-color: ' + color)
    else:
        jQuery('#when_clicked').html("you clicked it!")

jQuery(ready)

########NEW FILE########
__FILENAME__ = pyjados
class TodosApp:
    list_item_template = """<li id="todo_%(id)s">
    <input type="checkbox"/>%(text)s
    </li>"""

    @JSVar("jQuery", "js_add_form", "js_checkbox", "js_stored_todos", "JSON")
    def __init__(self):
        js_add_form = jQuery(js("#add_todo_form"))
        js_add_form.submit(js(self.add_todo))
        js_checkbox = jQuery(js("input[type=checkbox]"))
        js_checkbox.live("click", js(self.complete_todo))
        self.todos = {}
        self.next_id = 1

        js_stored_todos = localStorage.getItem("todolist")

        if js_stored_todos:
            stored_dict = dict(py(JSON.parse(js_stored_todos)))
            self.todos = dict([(int(i), stored_dict[i]) for i in stored_dict.keys()])
            self.next_id = max(self.todos.keys()) + 1

        self.render()

    @JSVar("event", "js_add_box")
    def add_todo(self, js_event):
        js_add_box = jQuery(js("#add_box"))
        self.todos[self.next_id] = py(js_add_box.val())
        js_add_box.val('')
        js_add_box.focus()
        self.next_id += 1
        self.store()
        self.render()
        return js(False)

    @JSVar("event", "jQuery", "todo_item")
    def complete_todo(self, event):
        todo_item = jQuery(event.target).parent()
        id = int(py(todo_item.attr("id"))[5:])
        del self.todos[id]
        self.store()
        todo_item.delay(1500).fadeOut("slow")

    @JSVar("js_todo_items")
    def render(self):
        js_todo_items = jQuery(js("#todo_items"))
        js_todo_items.html("")
        for id, todo in sorted(self.todos.items()):
            js_todo_items.append(js(TodosApp.list_item_template % {
                "id": id,
                "text": todo}))

    @JSVar("localStorage", "JSON")
    def store(self):
        localStorage.setItem("todolist", JSON.stringify(js(self.todos)))

def setup():
    todo_app = TodosApp()

jQuery(js(setup));

########NEW FILE########
__FILENAME__ = triangulation
import pyjaco
from pyjaco.decorator import JavaScript, JSVar

from math import sqrt

def is_on_the_left(c, a, b, pts_list):
   ax, ay = pts_list[a]
   bx, by = pts_list[b]
   cx, cy = pts_list[c]
   ux = float(bx - ax)
   uy = float(by - ay)
   vx = float(cx - ax)
   vy = float(cy - ay)
   return (ux*vy - uy*vx > 0)

def criterion(a, b, c, pts_list):
   ax, ay = pts_list[a]
   bx, by = pts_list[b]
   cx, cy = pts_list[c]
   ux = float(ax - cx)
   uy = float(ay - cy)
   vx = float(bx - cx)
   vy = float(by - cy)
   len_u = sqrt(ux*ux + uy*uy)
   len_v = sqrt(vx*vx + vy*vy)
   return (ux*vx + uy*vy)/(len_u*len_v)

def find_third_point(a, b, pts_list, edges):
    """
    Take a boundary edge (a,b), and in the list of points
    find a point 'c' that lies on the left of ab and maximizes
    the angle acb
    """
    found = 0
    minimum = 10**8   #this is dirty
    c_index = -1
    pt_index = -1
    for c_point in pts_list:
        c_index += 1
        if c_index != a and c_index != b and is_on_the_left(c_index, a, b, pts_list):
            edge_intersects = \
                    edge_intersects_edges((a, c_index), pts_list, edges) or \
                    edge_intersects_edges((b, c_index), pts_list, edges)
            if not edge_intersects:
                crit = criterion(a, b, c_index, pts_list)
                if crit < minimum:
                    minimum = crit
                    pt_index = c_index
                    found = 1
    if found == 0:
        raise TriangulationError("ERROR: Optimal point not found in find_third_point().")
    return pt_index

def lies_inside(c, bdy_edges):
   for edge in bdy_edges:
       a,b = edge
       if c == a or c == b: return False
   return True

def is_boundary_edge(a, b, bdy_edges):
    """
    Checks whether edge (a, b) is in the list of boundary edges
    """
    for edge in bdy_edges:
        a0, b0 = edge
        if a == a0 and b == b0:
            return True
    return False

def triangulate_af(pts_list, bdy_edges):
    """
    Create a triangulation using the advancing front method.
    """
    # create empty list of elements
    elems = []
    bdy_edges = bdy_edges[:]
    # main loop
    while len(bdy_edges) > 0:
        # take the last item from the list of bdy edges (and remove it)
        a,b = bdy_edges.pop()
        c = find_third_point(a, b, pts_list, bdy_edges)
        elems.append((a,b,c))
        if is_boundary_edge(c, a, bdy_edges):
            bdy_edges.remove((c,a))
        else:
            bdy_edges.append((a,c))
        if is_boundary_edge(b, c, bdy_edges):
            bdy_edges.remove((b,c))
        else:
            bdy_edges.append((c,b))
    return elems

def ccw(A, B, C):
    return (C[1]-A[1])*(B[0]-A[0]) > (B[1]-A[1])*(C[0]-A[0])

def intersect(A, B, C, D):
    return ccw(A, C, D) != ccw(B, C, D) and ccw(A, B, C) != ccw(A, B, D)

def two_edges_intersect(nodes, e1, e2):
    """
    Checks whether the two edges intersect.

    It assumes that e1 and e2 are tuples of (a_id, b_id) of ids into the nodes.
    """
    A = nodes[e1[0]]
    B = nodes[e1[1]]
    C = nodes[e2[0]]
    D = nodes[e2[1]]
    return intersect(A, B, C, D)

def edge_intersects_edges(e1, nodes, edges):
    """
    Returns True if 'e1' intersects any edge from 'edges'.
    """
    for i in range(len(edges)):
        e2 = edges[i]
        if e1[1] == e2[0] or e1[0] == e2[1]:
            continue
        if two_edges_intersect(nodes, e1, e2):
            return True
    return False

@JSVar("document", "canvas", "scale", "x0")
def start_triag():
    js_pre = document.getElementById('js_pre')
    setattr(js_pre, 'textContent', "start")
    canvas = document.getElementById('canvas').getContext('2d')
    setattr(js_pre, 'textContent', "triag")
    setattr(js_pre, 'textContent', example1())
    nodes, edges, elems = example2()
    scale = 50
    x0 = 3
    canvas.strokeStyle = 'rgb(0, 0, 255)'

    for el in elems:
        canvas.beginPath()
        x, y = nodes[el[0]]
        canvas.moveTo(x*scale+x0, 200-y*scale)
        x, y = nodes[el[1]]
        canvas.lineTo(x*scale+x0, 200-y*scale)
        x, y = nodes[el[2]]
        canvas.lineTo(x*scale+x0, 200-y*scale)
        x, y = nodes[el[0]]
        canvas.lineTo(x*scale+x0, 200-y*scale)
        canvas.stroke()

    canvas.strokeStyle = 'rgb(0, 255, 0)'
    canvas.beginPath()
    x, y = nodes[0]
    canvas.moveTo(x*scale+x0, 200-y*scale)
    for n in nodes:
        x, y = n
        canvas.lineTo(x*scale+x0, 200-y*scale)
    x, y = nodes[0]
    canvas.lineTo(x*scale+x0, 200-y*scale)
    canvas.stroke()

def example1():
    nodes, edges, elems = example2()
    result = str(nodes) + "\n" + str(edges) + "\n" + str(elems)
    return result

def example2():
    nodes = [
            (0, 0),
            (1, 0),
            (2, 1),
            (2, 2),
            (1, 2),
            (0.5, 1.5),
            (0, 1),
            ]
    edges = [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0)]
    elems = triangulate_af(nodes, edges)
    return nodes, edges, elems


def main():
    funcs = [
            is_on_the_left,
            criterion,
            find_third_point,
            lies_inside,
            is_boundary_edge,
            triangulate_af,
            ccw,
            intersect,
            two_edges_intersect,
            edge_intersects_edges,
            example1,
            example2,
            start_triag,
            ]
    js = pyjaco.Compiler()
    for f in funcs:
       js.append_method(f, f.func_name)
    py_result = example1()

    print """<html>
<head>
<script language="JavaScript" src="../py-builtins.js"></script>
<script language="JavaScript">
  sqrt = function(value) { return float(Math.sqrt(value)); };
</script>
<script language="JavaScript">
%s
</script>
</head>
<body onLoad="start_triag()">
    <h1>Triangulation Demo</h1>
    Python output:<br/>
    <pre id="py_pre">%s</pre>
    JavaScript output:<br/>
    <pre id="js_pre"></pre>
    Canvas:<br/>
    <canvas id="canvas" width="200" height="200"></canvas>
    <br/>
    End of page.
</body>
</html>""" % (js, py_result)


if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = ui
import inspect
import pyjaco
from pyjaco.decorator import JSVar

@JSVar("items")
def get_toolbar():
    items = [
            {"text":'File', "menu": [
                {"text": 'Open...'},
                {"text": 'Save...'},
                '-',
                {"text": 'Close'}
                ]},
            {"text":'Edit', "menu": [
                {'text': 'Undo'},
                {'text': 'Redo'},
                '-',
                {'text': 'Copy'},
                '-',
                {'text': 'Delete selected objects'},
                '-',
                {'text': 'Options'},
                ]},
            {"text":'View', "menu": [
                {'text': 'Zoom best fit'},
                {'text': 'Zoom region'},
                {'text': 'Zoom in'},
                {'text': 'Zoom out'},
                '-',
                {'text': 'Fullscreen mode'},
                '-',
                {'text': 'Scene properties'},
                ]},
            {"text":'Problem', "menu": [
                {'text': 'Operate on nodes'},
                {'text': 'Operate on edges'},
                {'text': 'Operate on labels'},
                {'text': 'Postprocessor'},
                "-",
                {'text': 'Add'},
                "-",
                {'text': 'Select region'},
                {'text': 'Transform'},
                '-',
                {'text': 'Local Values'},
                {'text': 'Surface Integrals'},
                {'text': 'Volume Integrals'},
                {'text': 'Select by marker'},
                ]},
            {"text":'Tools', "menu": [
                {'text': 'Chart'},
                "-",
                {'text': 'Script editor'},
                {'text': 'Run script...'},
                {'text': 'Run command...'},
                '-',
                {'text': 'Report...'},
                {'text': 'Create video...'},
                ]},
            {"text":'Help', "menu": (
                {'text': 'Help', 'handler': menu_help},
                '-',
                {'text': 'About Mesh Editor', 'handler': menu_about},
                )},
            ]
    Toolbar({"renderTo": 'mesh-editor', "items": items})
    items = [
            { "icon": 'http://www.extjs.com/deploy/dev/examples/menu/list-items.gif', "cls": 'x-btn-icon',
                "handler": toolbar_mesh1,
            "tooltip": '<b>Draw Mesh I</b><br/>Show an example mesh' },
            { "icon": 'http://www.extjs.com/deploy/dev/examples/menu/list-items.gif', "cls": 'x-btn-icon',
                "handler": toolbar_mesh2,
            "tooltip": '<b>Draw Mesh II</b><br/>Show an example mesh' },
            { "icon": 'http://www.extjs.com/deploy/dev/examples/menu/list-items.gif', "cls": 'x-btn-icon',
                "handler": toolbar_mesh3,
            "tooltip": '<b>Draw Mesh III</b><br/>Show an example mesh' },
            ]
    Toolbar({"renderTo": 'mesh-editor', "items": items})

@JSVar("items")
def get_panel():
    items = {
            "renderTo": 'mesh-editor',
            "width": '200px',
            "title": 'Mesh',
            "html": "<canvas id='canvas' width='200' height='200'></canvas>",
            "collapsible": true
            }
    p = Panel(items)
    return p

def toolbar_mesh1(b, e):
    canvas = Canvas('canvas')
    canvas.fillStyle = 'rgb(255, 255, 255)'
    canvas.fillRect(0, 0, 200, 200)
    canvas.fillStyle = 'rgb(29, 65, 119)'
    canvas.fillText("Mesh I", 80, 10)
    canvas.strokeStyle = 'rgb(0, 255, 0)'
    canvas.beginPath()
    canvas.moveTo(10, 10)
    canvas.lineTo(20, 50)
    canvas.lineTo(50, 20)
    canvas.lineTo(100, 100)
    canvas.lineTo(10, 10)
    canvas.stroke()

def toolbar_mesh2(b, e):
    canvas = Canvas('canvas')
    canvas.fillStyle = 'rgb(255, 255, 255)'
    canvas.fillRect(0, 0, 200, 200)
    canvas.fillStyle = 'rgb(29, 65, 119)'
    canvas.fillText("Mesh II", 80, 10)
    canvas.strokeStyle = 'rgb(255, 0, 0)'
    canvas.beginPath()
    canvas.moveTo(100, 100)
    canvas.lineTo(200, 50)
    canvas.lineTo(50, 20)
    canvas.lineTo(100, 100)
    canvas.lineTo(100, 10)
    canvas.stroke()

def toolbar_mesh3(b, e):
    canvas = Canvas('canvas')
    canvas.fillStyle = 'rgb(255, 255, 255)'
    canvas.fillRect(0, 0, 200, 200)
    canvas.fillStyle = 'rgb(29, 65, 119)'
    canvas.fillText("Mesh III", 80, 10)
    canvas.strokeStyle = 'rgb(0, 0, 255)'
    canvas.beginPath()
    canvas.moveTo(50, 50)
    canvas.lineTo(100, 180)
    canvas.lineTo(20, 180)
    canvas.lineTo(20, 100)
    canvas.lineTo(50, 50)
    canvas.stroke()

def menu_about(e, t):
    info_box(js("About"), js("FEMhub Mesh Editor, (c) 2010 hp-FEM group at UNR"))

@JSVar("items")
def menu_help(e, t):
    items = {
        "activeTab": 2,
        "width": 600,
        "height": 250,
        "plain": True,
        "defaults": {"autoScroll": True},
        "items":[{
                "title": 'Introduction',
                "html": "This is the mesh editor.<p/><br/>Browse the tabs for more help."
            },{
                "title": 'Mesh',
                "html": "Create the mesh by adding points to the <b>canvas</b>."
            },{
                "title": 'Developing',
                "html": "Documentation:<br/><a href='http://www.extjs.com/deploy/dev/docs/'>ExtJS</a><br/><a href='http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html'>HTML5 Canvas</a>"
            },{
                "title": 'About',
                "html": "Developed by the <a href='http://hpfem.org/'>hp-FEM group</a> at UNR."
            }]
    }
    tabs2 = TabPanel(items)

    items = {
        "renderTo": 'mesh-editor-help',
        "layout": 'fit',
        "width": 500,
        "height": 300,
        "title": "Help",
        "items": tabs2
        }
    w = Window(items)
    w.show()

@JSVar("Ext")
def initialize():
    Ext.get(document.body).update("<div id='mesh-editor'></div><div id='mesh-editor-help'></div>")
    Ext.QuickTips.init()
    get_toolbar()
    get_panel()


#########################################################################
# End of the section that works both on the desktop and in JS.

# JS wrappers for Ext:

class ExtObject(object):

    @JSVar("self._obj")
    def __init__(self, args):
        self._obj = _new(eval(js("Ext." + self.__class__.__name__)), js(args))

    @JSVar("self._obj")
    def _js_(self):
        return self._obj

class Window(ExtObject):

    @JSVar("self._obj")
    def show(self):
        self._obj.show()

class Panel(ExtObject):
    pass

class TabPanel(ExtObject):
    pass

class Toolbar(ExtObject):
    pass

@JSVar("Ext")
def info_box(title, msg):
    Ext.MessageBox.show({
           "title": title,
           "msg": msg,
           "buttons": Ext.MessageBox.OK,
           "animEl": 'mb9',
           "icon": Ext.MessageBox.INFO,
        })

class Canvas(object):

    @JSVar("self._obj", "dom", "Ext", "G_vmlCanvasManager")
    def __init__(self, id):
        dom = Ext.getDom(js(id))
        if js(Ext.isIE):
            # This is needed for IE to emulate the canvas element:
            G_vmlCanvasManager.initElement(dom)
        self._obj = dom.getContext('2d')
        self._obj.clearRect(0, 0, 200, 200)

    @JSVar("self._obj")
    def fillRect(self, x1, y1, w, h):
        self._obj.fillStyle = js(self.fillStyle)
        self._obj.fillRect(js(x1), js(y1), js(w), js(h))

    @JSVar("self._obj")
    def fillText(self, text, x, y):
        self._obj.fillStyle = js(self.fillStyle)
        self._obj.fillText(js(text), js(x), js(y))

    @JSVar("self._obj")
    def beginPath(self):
        self._obj.strokeStyle = js(self.strokeStyle)
        self._obj.beginPath()

    @JSVar("self._obj")
    def moveTo(self, x, y):
        self._obj.moveTo(js(x), js(y))

    @JSVar("self._obj")
    def lineTo(self, x, y):
        self._obj.lineTo(js(x), js(y))

    @JSVar("self._obj")
    def stroke(self):
        self._obj.stroke()

##################################################
# Main code that translates the above to JS

def main():
    funcs = [
            ExtObject,
            Window,
            Panel,
            TabPanel,
            Toolbar,
            info_box,
            Canvas,

            menu_about,
            menu_help,
            get_toolbar,
            get_panel,
            toolbar_mesh1,
            toolbar_mesh2,
            toolbar_mesh3,
            initialize,
            ]
    source = ""
    for f in funcs:
        source += inspect.getsource(f) + "\n"
    js = pyjaco.compile_string(source)

    print """\
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <!--[if IE]><script type="text/javascript" src="http://explorercanvas.googlecode.com/svn/trunk/excanvas.js"></script><![endif]-->
  <link rel="stylesheet" type="text/css" href="http://www.extjs.com/deploy/dev/resources/css/ext-all.css">
  <script type="text/javascript" src="http://www.extjs.com/deploy/dev/adapter/ext/ext-base.js"></script>
  <script type="text/javascript" src="http://www.extjs.com/deploy/dev/ext-all.js"></script>
  <script language="JavaScript" src="../py-builtins.js"></script>
  <title id="page-title">Title</title>
  <script type="text/javascript">
  function _new(cls, args) { return new cls(args); }
%s
  Ext.onReady(initialize);
  </script>
</head>
<body></body>
</html>""" % (js)


if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = htmltest
#!/usr/bin/python

import os.path

template = """<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
  <title>Unittests</title>
  <script src="py-builtins.js" type="text/javascript"></script>
  <script src="jquery-1.6.1.js" type="text/javascript"></script>
</head>
<style type="text/css">
  body { font-family: monospace; }
  table { width: 40em; margin: 0 auto; background-color: #EEE; border-radius: 1em; padding: 1em; }
</style>
<script type="text/javascript">
  $(document).ready(function() {
    out = ""
    py_builtins.print = function() {
      var args = tuple(Array.prototype.slice.call(arguments));
      out += js(str(" ").PY$join(args));
      out += "\\n";
    };

    tests = {}
    res = {}    
    %(tests)s;
    %(res)s;

//    var X = function() { return 42; }; (function() { var X = X(); console.log(X); })();

    // COUNTER_var_ is named funny because it must not collide with
    // the namespace of any test case
    for (var COUNTER_var_ in tests) {
      out = "";
      try {
        eval("(function() {\\n" + tests[COUNTER_var_] + "})();");
        if (out == res[COUNTER_var_]) {
          $("#" + COUNTER_var_).text("OK").css('background-color', 'green');
        } else {
          $("#" + COUNTER_var_).text("FAIL").css('background-color', 'red');
        }
      } catch (e) {
        $("#" + COUNTER_var_).text("CRASH").css('background-color', 'purple');
      }
    }

  });
</script>
<body>
  <table>
    <tr><th>Test name</th><th>Status</th></tr>
    %(rows)s
  </table>
</body>
</html>
"""

js = []
res = []
rows = []

import glob

def encode(s):
    return s.replace("\\", "\\\\").replace("\n", "\\n").replace('\"', '\\\"').replace('\'', '\\\'')

for x in sorted(glob.glob("tests/**/*.py")):
    if not (os.path.exists("%s.js" % x) and os.path.exists("%s.out" % x)):
        continue
    name = x.replace("/", "-").replace(".", "-").replace("_", "-")
    js.append('tests["%s"] = "%s"' % (name, encode(file("%s.js" % x).read()[24:])))
    res.append('res["%s"] = "%s"' % (name, encode(file("%s.out" % x).read())))
    rows.append("<tr><td>%s</td><td id='%s'>Not run</td></tr>" % (name, name))

print template % dict(tests = "\n".join(js), res = "\n".join(res), rows = "\n".join(rows))

########NEW FILE########
__FILENAME__ = javascript
######################################################################
##
## Copyright 2010-2011 Ondrej Certik <ondrej@certik.cz>
## Copyright 2010-2011 Mateusz Paprocki <mattpap@gmail.com>
## Copyright 2011 Christian Iversen <ci@sikkerhed.org>
##
## Permission is hereby granted, free of charge, to any person
## obtaining a copy of this software and associated documentation
## files (the "Software"), to deal in the Software without
## restriction, including without limitation the rights to use,
## copy, modify, merge, publish, distribute, sublicense, and/or sell
## copies of the Software, and to permit persons to whom the
## Software is furnished to do so, subject to the following
## conditions:
##
## The above copyright notice and this permission notice shall be
## included in all copies or substantial portions of the Software.
##
## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
## EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
## OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
## NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
## HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
## WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
## FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
## OTHER DEALINGS IN THE SOFTWARE.
##
######################################################################

import pyjaco.compiler
import ast
from pyjaco.compiler import JSError

class Compiler(pyjaco.compiler.BaseCompiler):

    unary_op = {
        'Invert' : '~',
        'Not'    : '!',
        'UAdd'   : '+',
        'USub'   : '-',
    }

    bool_op = {
        'And'    : '&&',
        'Or'     : '||',
    }

    binary_op = {
        'Add'    : '+',
        'Sub'    : '-',
        'Mult'   : '*',
        'Div'    : '/',
        'Mod'    : '%',
        'LShift' : '<<',
        'RShift' : '>>',
        'BitOr'  : '|',
        'BitXor' : '^',
        'BitAnd' : '&',
    }

    comparison_op = {
            'Eq'    : "==",
            'NotEq' : "!=",
            'Lt'    : "<",
            'LtE'   : "<=",
            'Gt'    : ">",
            'GtE'   : ">=",
            'Is'    : "===",
            'IsNot' : "is not", # Not implemented yet
    }

    def __init__(self, opts):
        super(Compiler, self).__init__(opts)
        self.name_map = self.name_map.copy()
        self.name_map.update({"True": "true", "False": "false", "None": "null"})
        self.opts = opts

    def get_bool_op(self, node):
        return self.bool_op[node.op.__class__.__name__]

    def get_unary_op(self, node):
        return self.unary_op[node.op.__class__.__name__]

    def get_binary_op(self, node):
        return self.binary_op[node.op.__class__.__name__]

    def get_comparison_op(self, node):
        return self.comparison_op[node.__class__.__name__]

    def visit_Name(self, node):
        name = self.name_map.get(node.id, node.id)

        if (name in self.builtin) and not (name in self._scope):
            name = "py_builtins." + name

        return name

    def visit_Global(self, node):
        self._scope.extend(node.names)
        return []

    def visit_FunctionDef(self, node):
        raise JSError("Javascript compiler does not support function definitions")

    def visit_ClassDef(self, node):
        raise JSError("Javascript compiler does not support class definitions")

    def visit_Delete(self, node):
        return ["delete %s;" % ", ".join([self.visit(x) for x in node.targets])]

    def visit_AssignSimple(self, left, right):
        target = left
        value  = right
        if isinstance(target, (ast.Tuple, ast.List)):
            part = self.alloc_var()
            js = ["var %s = %s;" % (part, value)]

            for i, target in enumerate(target.elts):
                var = self.visit(target)
                declare = ""
                if isinstance(target, ast.Name):
                    if not (var in self._scope):
                        self._scope.append(var)
                        declare = "var "
                js.append("%s%s = %s[%d];" % (declare, var, part, i))
        elif isinstance(target, ast.Subscript) and isinstance(target.slice, ast.Index):
            # found index assignment
            if isinstance(target.slice, ast.Str):
                i = self.visit(target.slice)
            else:
                i = '"%s"' % self.visit(target.slice)
            js = ["%s[%s] = %s;" % (self.visit(target.value), self.visit(target.slice), value)]
        elif isinstance(target, ast.Subscript) and isinstance(target.slice, ast.Slice):
            raise JSError("Javascript does not support slice assignments")
        else:
            var = self.visit(target)
            if isinstance(target, ast.Name):
                if not (var in self._scope):
                    self._scope.append(var)
                    declare = "var "
                else:
                    declare = ""
                js = ["%s%s = %s;" % (declare, var, value)]
            elif isinstance(target, ast.Attribute):
                js = ["%s.%s = %s;" % (self.visit(target.value), str(target.attr), value)]
            else:
                raise JSError("Unsupported assignment type")
        return js

    def visit_AugAssign(self, node):
        target = self.visit(node.target)
        value = self.visit(node.value)

        if isinstance(node.op, ast.Pow):
            return ["%s = Math.pow(%s, %s);" % (target, target, value)]
        if isinstance(node.op, ast.FloorDiv):
            return ["%s = Math.floor((%s)/(%s));" % (target, target, value)]

        return ["%s %s= %s;" % (target, self.get_binary_op(node), value)]

    def visit_For(self, node):
        if not isinstance(node.target, ast.Name):
            raise JSError("argument decomposition in 'for' loop is not supported")

        js = []

        for_target = self.visit(node.target)
        for_iter = self.visit(node.iter)

        iter_dummy = self.alloc_var()
        orelse_dummy = self.alloc_var()
        exc_dummy = self.alloc_var()

        if isinstance(node.iter, ast.Call) and isinstance(node.iter.func, ast.Name) and node.iter.func.id == "range" and not node.orelse:
            counter  = self.visit(node.target)
            end_var  = self.alloc_var()
            assert(len(node.iter.args) in (1,2,3))
            if len(node.iter.args) == 1:
                start = "0"
                end   = self.visit(node.iter.args[0])
                step  = "1"
            elif len(node.iter.args) == 2:
                start = self.visit(node.iter.args[0])
                end   = self.visit(node.iter.args[1])
                step  = "1"
            else:
                start = self.visit(node.iter.args[0])
                end   = self.visit(node.iter.args[1])
                step  = self.visit(node.iter.args[2])

            js.append("for (%s = %s; %s < %s; %s += %s) {" % (counter, start, counter, end, counter, step))
            for stmt in node.body:
                js.extend(self.indent(self.visit(stmt)))
            js.append("}")
            return js

        js.append("var %s = iter(%s);" % (iter_dummy, for_iter))
        js.append("var %s = false;" % orelse_dummy)
        js.append("while (1) {")
        js.append("    var %s;" % for_target)
        js.append("    try {")
        js.append("        %s = %s.PY$next();" % (for_target, iter_dummy))
        js.append("    } catch (%s) {" % exc_dummy)
        js.append("        if (py_builtins.isinstance(%s, py_builtins.StopIteration)) {" % exc_dummy)
        js.append("            %s = true;" % orelse_dummy)
        js.append("            break;")
        js.append("        } else {")
        js.append("            throw %s;" % exc_dummy)
        js.append("        }")
        js.append("    }")

        for stmt in node.body:
            js.extend(self.indent(self.visit(stmt)))

        js.append("}")

        if node.orelse:
            js.append("if (%s) {" % orelse_dummy)

            for stmt in node.orelse:
                js.extend(self.indent(self.visit(stmt)))

            js.append("}")

        return js

    def visit_While(self, node):
        js = []

        if not node.orelse:
            js.append("while (%s) {" % self.visit(node.test))
        else:
            orelse_dummy = self.alloc_var()

            js.append("var %s = false;" % orelse_dummy)
            js.append("while (1) {")
            js.append("    if (!(%s)) {" % self.visit(node.test))
            js.append("        %s = true;" % orelse_dummy)
            js.append("        break;")
            js.append("    }")

        for stmt in node.body:
            js.extend(self.indent(self.visit(stmt)))

        js.append("}")

        if node.orelse:
            js.append("if (%s) {" % orelse_dummy)

            for stmt in node.orelse:
                js.extend(self.indent(self.visit(stmt)))

            js.append("}")

        return js

    def visit_If(self, node):
        js = ["if (%s) {" % self.visit(node.test)]

        for stmt in node.body:
            js.extend(self.indent(self.visit(stmt)))

        if node.orelse:
            js.append("} else {")

            for stmt in node.orelse:
                js.extend(self.indent(self.visit(stmt)))

        return js + ["}"]

    def _visit_With(self, node):
        pass

    def _visit_Raise(self, node):
        pass

    def _visit_TryExcept(self, node):
        pass

    def _visit_TryFinally(self, node):
        pass

    def _visit_Import(self, node):
        pass

    def _visit_ImportFrom(self, node):
        pass

    def visit_Lambda(self, node):
        return "\n    function(%s) {%s}" % (self.visit(node.args), self.visit(node.body))

    def visit_BoolOp(self, node):
        return self.get_bool_op(node).join([ "(%s)" % self.visit(val) for val in node.values ])

    def visit_UnaryOp(self, node):
        return "%s(%s)" % (self.get_unary_op(node), self.visit(node.operand))

    def visit_BinOp(self, node):
        if isinstance(node.op, ast.Mod) and isinstance(node.left, ast.Str):
            left = self.visit(node.left)
            if isinstance(node.right, (ast.Tuple, ast.List)):
                right = self.visit(node.right)
                return "sprintf(str(%s), tuple(%s))" % (left, right)
            else:
                right = self.visit(node.right)
                return "sprintf(str(%s), str(%s))" % (left, right)
        left = self.visit(node.left)
        right = self.visit(node.right)

        if isinstance(node.op, ast.Pow):
            return "Math.pow(%s, %s)" % (left, right)
        if isinstance(node.op, ast.FloorDiv):
            return "Math.floor((%s)/(%s))" % (left, right)

        return "(%s) %s (%s)" % (left, self.get_binary_op(node), right)

    def visit_Compare(self, node):
        assert len(node.ops) == 1
        assert len(node.comparators) == 1
        op = node.ops[0]
        comp = node.comparators[0]
        if isinstance(op, ast.In):
            return "%s.__contains__(%s)" % (self.visit(comp), self.visit(node.left))
        elif isinstance(op, ast.NotIn):
            return "!(%s.__contains__(%s))" % (self.visit(comp), self.visit(node.left))
        elif isinstance(op, ast.Eq):
            return "(%s) === (%s)" % (self.visit(node.left), self.visit(comp))
        elif isinstance(op, ast.NotEq):
            return "(%s) !== (%s)" % (self.visit(node.left), self.visit(comp))
        else:
            return "%s %s %s" % (self.visit(node.left), self.get_comparison_op(op), self.visit(comp))

    def visit_Num(self, node):
        return str(node.n)

    def visit_Str(self, node):
        # Uses the Python builtin repr() of a string and the strip string type
        # from it. This is to ensure Javascriptness, even when they use things
        # like b"\\x00" or u"\\u0000".
        return '"%s"' % repr(node.s).lstrip("urb")[1:-1]

    def visit_Call(self, node):
        func = self.visit(node.func)

        if node.keywords:
            keywords = []
            for kw in node.keywords:
                keywords.append("%s: %s" % (kw.arg, self.visit(kw.value)))
            keywords = "{" + ", ".join(keywords) + "}"
            js_args = ", ".join([ self.visit(arg) for arg in node.args ])
            return "%s.args([%s], %s)" % (func, js_args,
                    keywords)
        else:
            if node.starargs is not None:
                raise JSError("star arguments are not supported")

            if node.kwargs is not None:
                raise JSError("keyword arguments are not supported")

            js_args = ", ".join([ self.visit(arg) for arg in node.args ])

            return "%s(%s)" % (func, js_args)

    def visit_Raise(self, node):
        assert node.inst is None
        assert node.tback is None
        return ["throw %s;" % self.visit(node.type)]

    def visit_Attribute(self, node):
        return "%s.%s" % (self.visit(node.value), node.attr)

    def visit_Tuple(self, node):
        els = [self.visit(e) for e in node.elts]
        return "[%s]" % (", ".join(els))

    def visit_Dict(self, node):
        els = []
        for k, v in zip(node.keys, node.values):
            els.append("%s: %s" % (self.visit(k), self.visit(v)))
        return "{%s}" % (", ".join(els))

    def visit_List(self, node):
        els = [self.visit(e) for e in node.elts]
        return "[%s]" % (", ".join(els))

    def visit_Slice(self, node):
        if node.step:
            raise JSError("Javascript does not support slicing in steps")

        if node.lower and node.upper:
            return ".slice(%s, %s)" % (self.visit(node.lower), self.visit(node.upper))

        if node.lower:
            return "[%s]" % (self.visit(node.lower))

        if node.upper:
            return ".slice(0, %s)" % (self.visit(node.upper))

        raise NotImplementedError("Slice")

    def visit_Subscript(self, node):
#        print node.value, node.slice
        if isinstance(node.slice, ast.Index):
            return "%s[%s]" % (self.visit(node.value), self.visit(node.slice))
        else:
            return "%s%s" % (self.visit(node.value), self.visit(node.slice))

    def visit_Index(self, node):
        return self.visit(node.value)


########NEW FILE########
__FILENAME__ = multiplexer
######################################################################
##
## Copyright 2011 Christian Iversen <ci@sikkerhed.org>
##
## Permission is hereby granted, free of charge, to any person
## obtaining a copy of this software and associated documentation
## files (the "Software"), to deal in the Software without
## restriction, including without limitation the rights to use,
## copy, modify, merge, publish, distribute, sublicense, and/or sell
## copies of the Software, and to permit persons to whom the
## Software is furnished to do so, subject to the following
## conditions:
##
## The above copyright notice and this permission notice shall be
## included in all copies or substantial portions of the Software.
##
## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
## EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
## OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
## NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
## HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
## WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
## FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
## OTHER DEALINGS IN THE SOFTWARE.
##
######################################################################

import pyjaco.compiler
import pyjaco.compiler.javascript
import pyjaco.compiler.python
import ast
from pyjaco.compiler import JSError

def dump(node):
    s = "%r -> %s" % (node, ast.dump(node))
    indent = 0
    buf = ""
    for c in s:
        buf += c
        if c == "(":
            indent += 2
            buf += "\n" + " " * indent
        elif c == "=":
            buf = buf[:-1]
            buf += " = "
#            buf += "\n" + " " * indent
        elif c == ")":
            indent -= 2
        elif c == ",":
            buf += "\n" + " " * (indent - 1)
#           buf += "\n" + " " * indent
    print buf

class Compiler(pyjaco.compiler.BaseCompiler):

    def __init__(self, jsvars, opts):
        super(Compiler, self).__init__(opts)
        self.comp_py = pyjaco.compiler.python.Compiler(opts)
        self.comp_js = pyjaco.compiler.javascript.Compiler(opts)

        self.visit_py = self.comp_py.visit
        self.visit_js = self.comp_js.visit
        self.visit_current = None

        self.comp_py.visit = self.visit
        self.comp_js.visit = self.visit

        self.modestack = []
        self.modecache = {}
        self.stack = []

        self.comp_py.stack = self.stack
        self.comp_js.stack = self.stack

        if jsvars:
            self.jsvars = jsvars[:]
        else:
            self.jsvars = []

        self.enter("py")

    def enter(self, mode):
        self.modestack.append(mode)
        if mode == "js":
            self.visit_current = self.visit_js
        elif mode == "py":
            self.visit_current = self.visit_py
        else:
            raise JSError("Trying to enter unsupported mode")

    def leave(self):
        self.modestack.pop()
        self.enter(self.modestack.pop())

    def visit(self, node, multiplex = True):
        self.stack.append(node.__class__.__name__)
        mode = self.get_mode(node)
        if mode:
            self.enter(mode)

        name = 'visit_' + self.name(node)
        if hasattr(self, name) and multiplex:
            res = getattr(self, name)(node)
        else:
            res = self.visit_current(node)

        if mode:
            self.leave()
        self.stack.pop()
        return res

    def get_mode(self, node):
        if not node in self.modecache:
            self.modecache[node] = self.get_mode_simple(node)
        return self.modecache[node]

    def get_mode_simple(self, node):
        if isinstance(node, ast.Call):
            return self.get_mode(node.func)

        elif isinstance(node, ast.Attribute):
            if isinstance(node.value, ast.Name):
                for x in self.jsvars:
                    if len(x) == 1 and node.value.id == x[0]:
                        return "js"
                    elif len(x) == 2 and node.value.id == x[0] and node.attr == x[1]:
                        return "js"
            else:
                return self.get_mode(node.value)

        elif isinstance(node, ast.Name):
            if node.id in [x[0] for x in self.jsvars]:
                return "js"
            else:
                return "py"

        elif isinstance(node, ast.Assign):
            return self.get_mode(node.targets[0])
        elif isinstance(node, ast.AugAssign):
            return self.get_mode(node.target)
        elif isinstance(node, ast.Subscript):
            return self.get_mode(node.value)

    def visit_Assign(self, node):
        return self.visit(node, False)

    def visit_FunctionDef(self, node):
        added = 0
        dec = node.decorator_list
        i = 0
        while i < len(dec):
            if isinstance(dec[i], ast.Call) and isinstance(dec[i].func, ast.Name) and dec[i].func.id == 'JSVar':
                for a in dec[i].args:
                    if isinstance(a, ast.Str):
                        self.jsvars.append(a.s.split("."))
                        added += 1
                    else:
                        raise JSError("JSVar decorator must only be used with string literals")
                del dec[i]
            else:
                i += 1
        res = self.visit(node, False)
        while added:
            self.jsvars.pop()
            added -= 1
        return res

    def visit_Return(self, node):
        return self.visit_current(node)

    def visit_AssignSimple(self, node):
        raise NotImplementedError()

########NEW FILE########
__FILENAME__ = python
######################################################################
##
## Copyright 2010-2011 Ondrej Certik <ondrej@certik.cz>
## Copyright 2010-2011 Mateusz Paprocki <mattpap@gmail.com>
## Copyright 2011 Christian Iversen <ci@sikkerhed.org>
##
## Permission is hereby granted, free of charge, to any person
## obtaining a copy of this software and associated documentation
## files (the "Software"), to deal in the Software without
## restriction, including without limitation the rights to use,
## copy, modify, merge, publish, distribute, sublicense, and/or sell
## copies of the Software, and to permit persons to whom the
## Software is furnished to do so, subject to the following
## conditions:
##
## The above copyright notice and this permission notice shall be
## included in all copies or substantial portions of the Software.
##
## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
## EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
## OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
## NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
## HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
## WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
## FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
## OTHER DEALINGS IN THE SOFTWARE.
##
######################################################################

import ast
import pyjaco.compiler
from pyjaco.compiler import JSError
from pyjaco.compiler.multiplexer import dump

class Compiler(pyjaco.compiler.BaseCompiler):

    obey_getattr_restriction = False

    ops_augassign = {
        "Add"     : "iadd",
        "Sub"     : "isub",
        "Div"     : "idiv",
        "Mult"    : "imul",
        "LShift"  : "ilshift",
        "RShift"  : "irshift",
        "BitOr"   : "ibitor",
        "BitAnd"  : "ibitand",
        "BitXor"  : "ibitxor",
        "FloorDiv": "ifloordiv",
        "Pow"     : "ipow",
    }

    ops_binop = {
        "Add": "add",
        "Sub": "sub",
        "Div": "div",
        "Mod": "mod",
        "Pow": "pow",
        "Mult": "mul",
        "BitOr": "bitor",
        "BitAnd": "bitand",
        "BitXor": "bitxor",
        "LShift": "lshift",
        "RShift": "rshift",
        "FloorDiv": "floordiv",
    }

    ops_compare = {
        "Eq": "eq",
        "NotEq": "ne",
        "Gt": "gt",
        "Lt": "lt",
        "GtE": "ge",
        "LtE": "le",
    }

    def __init__(self, opts):
        super(Compiler, self).__init__(opts)
        self.future_division = False
        self.opts = opts

    def stack_destiny(self, names, skip):
        for name in reversed(self.stack[:-skip]):
            if name in names:
                return name
        else:
            return False

    def visit_Name(self, node):
        name = self.name_map.get(node.id, node.id)

        if (name in self.builtin) and not (name in self._scope):
            name = "py_builtins." + name

        return name

    def visit_Return(self, node):
        if node.value is not None:
            return ["return %s;" % self.visit(node.value)]
        else:
            return ["return None;"]

    def visit_Global(self, node):
        self._scope.extend(node.names)
        return []

    def visit_FunctionDef(self, node):
        defaults = [None] * (len(node.args.args) - len(node.args.defaults)) + node.args.defaults

        if node.args.kwarg:
            kwarg_name = node.args.kwarg
        else:
            kwarg_name = "__kwargs"

        if node.args.vararg:
            vararg_name = node.args.vararg
        else:
            vararg_name = "__varargs"

        if len(node.args.args) and node.args.args[0].id == "self":
            offset = 1
        else:
            offset = 0

        self._scope = [arg.id for arg in node.args.args]

        inclass = self.stack_destiny(["ClassDef", "FunctionDef"], 2) in ["ClassDef"]

        if inclass:
            js = ["function() {"]
        else:
            js = ["var %s = function() {" % (node.name)]

        if inclass or offset == 1:
            js.extend(self.indent(["var self = this;"]))

        newargs = self.alloc_var()

        js.extend(self.indent(["var %s = __kwargs_get(arguments);" % kwarg_name]))
        js.extend(self.indent(["var %s = __varargs_get(arguments);" % vararg_name]))
        js.extend(self.indent(["var %s = Array.prototype.slice.call(arguments).concat(js(%s));" % (newargs, vararg_name)]))
        for i, arg in enumerate(node.args.args[offset:]):
            if not isinstance(arg, ast.Name):
                raise JSError("tuples in argument list are not supported")

            values = dict(i = i, id = self.visit(arg), rawid = arg.id, kwarg = kwarg_name, newargs = newargs, func = node.name)
            if len(self._class_name):
                values['fullfunc'] = "%s.%s" % (self._class_name[-1], node.name)
            else:
                values['fullfunc'] = node.name

            if defaults[i + offset] == None:
                js.extend(self.indent(["var %(id)s = ('%(rawid)s' in %(kwarg)s) ? %(kwarg)s['%(rawid)s'] : %(newargs)s[%(i)d];" % values]))
            else:
                values['default'] = self.visit(defaults[i + offset])
                js.extend(self.indent(["var %(id)s = %(newargs)s[%(i)d];" % values]))
                js.extend(self.indent(["if (%(id)s === undefined) { %(id)s = %(kwarg)s.%(rawid)s === undefined ? %(default)s : %(kwarg)s.%(rawid)s; };" % values]))
            js.extend(self.indent(["delete %(kwarg)s.%(id)s" % values]))
            if self.opts['check_params']:
                js.extend(self.indent(["if (%(id)s === undefined) { \npy_builtins.print('%(fullfunc)s() did not get parameter %(id)s'); }; " % values]))

        if node.name in ["__getattr__", "__setattr__"]:
            js.extend(self.indent(["if (typeof %(id)s === 'string') { %(id)s = str(%(id)s); };" % { 'id': node.args.args[1].id }]))

        if node.args.kwarg:
            js.extend(self.indent(["%s = dict(%s);" % (node.args.kwarg, node.args.kwarg)]))

        if node.args.vararg:
            l = len(node.args.args)
            if inclass:
                l -= 1
            js.extend(self.indent(["%s = tuple(%s.slice(%s));" % (node.args.vararg, newargs, l)]))

        for stmt in node.body:
            js.extend(self.indent(self.visit(stmt)))

        self._scope = []
        if not (node.body and isinstance(node.body[-1], ast.Return)):
            js.append("return None;")
        js.append("}")

        for dec in node.decorator_list:
            js.extend(["%s.PY$%s = %s(%s.PY$__getattr__('%s'));" % (self.heirar, node.name, dec.id, self.heirar, node.name)])

        return js

    def visit_ClassDef(self, node):
        js = []
        bases = [self.visit(n) for n in node.bases]
        if not bases:
            bases = ['object']
        if len(bases) == 0:
            raise JSError("Old-style classes not supported")
        elif len(bases) > 1:
            raise JSError("Multiple inheritance not supported")

        class_name = node.name
        #self._classes remembers all classes defined
        self._classes[class_name] = node

        use_prototypes = "false" if any([isinstance(x, ast.FunctionDef) and x.name == "__call__" for x in node.body]) else "true"
        if len(self._class_name) > 0:
            js.append("__inherit(%s, '%s', %s);" % (bases[0], class_name, use_prototypes))
        else:
            js.append("var %s = __inherit(%s, '%s', %s);" % (class_name, bases[0], class_name, use_prototypes))

        self._class_name.append(class_name)
        heirar = ".PY$".join(self._class_name + [])
        for stmt in node.body:
            if isinstance(stmt, ast.Assign):
                value = self.visit(stmt.value)
                for t in stmt.targets:
                    js.append("%s.PY$%s = %s;" % (heirar, t.id, value))
            elif isinstance(stmt, ast.FunctionDef):
                self.heirar = heirar
                js.append("%s.PY$%s = %s;" % (heirar, stmt.name, "\n".join(self.visit(stmt))))
            elif isinstance(stmt, ast.ClassDef):
                js.append("%s.PY$%s = %s;" % (heirar, stmt.name, "\n".join(self.visit(stmt))))
            elif isinstance(stmt, ast.Expr) and isinstance(stmt.value, ast.Str):
                js.append("\n".join(["/* %s */" % s for s in stmt.value.s.split("\n")]))
            elif isinstance(stmt, ast.Pass):
                # Not required for js
                pass
            else:
                raise JSError("Unsupported class data: %s" % stmt)
        self._class_name.pop()

        return js

    def visit_Delete(self, node):
        return [self.visit_DeleteSimple(part) for part in node.targets]

    def visit_DeleteSimple(self, node):
        if isinstance(node, ast.Subscript) and isinstance(node.slice, ast.Index):
            js = "%s.PY$__delitem__(%s);" % (self.visit(node.value), self.visit(node.slice))
        elif isinstance(node, ast.Subscript) and isinstance(node.slice, ast.Slice):
            js = "%s.PY$__delslice__(%s, %s);" % (self.visit(node.value), self.visit(node.slice.lower), self.visit(node.slice.upper))
        elif isinstance(node, ast.Attribute):
            js = "%s.PY$__delattr__('%s');" % (self.visit(node.value), node.attr)
        elif isinstance(node, ast.Name):
            raise JSError("Javascript does not support deleting variables. Cannot compile")
        else:
            raise JSError("Unsupported delete type: %s" % node)

        return js

    def visit_AssignSimple(self, target, value):
        if isinstance(target, (ast.Tuple, ast.List)):
            dummy = self.alloc_var()
            js = ["var %s = %s;" % (dummy, value)]

            for i, target in enumerate(target.elts):
                var = self.visit(target)
                declare = ""
                if isinstance(target, ast.Name):
                    if not (var in self._scope):
                        self._scope.append(var)
                        declare = "var "
                js.append("%s%s = %s.PY$__getitem__(%d);" % (declare, var, dummy, i))
        elif isinstance(target, ast.Subscript) and isinstance(target.slice, ast.Index):
            # found index assignment
            js = ["%s.PY$__setitem__(%s, %s);" % (self.visit(target.value), self.visit(target.slice), value)]
        elif isinstance(target, ast.Subscript) and isinstance(target.slice, ast.Slice):
            # found slice assignmnet
            js = ["%s.PY$__setslice__(%s, %s, %s);" % (self.visit(target.value), self.visit(target.slice.lower), self.visit(target.slice.upper), value)]
        else:
            var = self.visit(target)
            if isinstance(target, ast.Name):
                if not (var in self._scope):
                    self._scope.append(var)
                    declare = "var "
                else:
                    declare = ""
                js = ["%s%s = %s;" % (declare, var, value)]
            elif isinstance(target, ast.Attribute):
                js = ["%s.PY$__setattr__('%s', %s);" % (self.visit(target.value), str(target.attr), value)]
            else:
                raise JSError("Unsupported assignment type")
        return js

    def visit_AugAssign(self, node):
        target = self.visit(node.target)
        value = self.visit(node.value)

        if not self.future_division and isinstance(node.op, ast.Div):
            node.op = ast.FloorDiv()

        name = node.op.__class__.__name__
        if name in self.ops_augassign:
            return self.visit_AssignSimple(node.target,
                "%s.PY$__%s__(%s)" % (target, self.ops_augassign[name], value))
        else:
            raise JSError("Unsupported AugAssign type %s" % node.op)

    def visit_For(self, node):
        if isinstance(node.target, ast.Name):
            for_target = self.visit(node.target)
        elif isinstance(node.target, ast.Tuple):
            for_target = self.alloc_var()
        else:
            raise JSError("Advanced for-loop decomposition not supported")

        js = []

        if isinstance(node.iter, ast.Call) and isinstance(node.iter.func, ast.Name) and node.iter.func.id == "range" and not node.orelse:
            counter  = self.visit(node.target)
            end_var  = self.alloc_var()
            assert(len(node.iter.args) in (1,2,3))
            if len(node.iter.args) == 1:
                start = "$c0"
                end   = self.visit(node.iter.args[0])
                step  = "$c1"
            elif len(node.iter.args) == 2:
                start = self.visit(node.iter.args[0])
                end   = self.visit(node.iter.args[1])
                step  = "$c1"
            else:
                start = self.visit(node.iter.args[0])
                end   = self.visit(node.iter.args[1])
                step  = self.visit(node.iter.args[2])

            js.append("%s = %s;" % (end_var, end))
            if step <> "$c1":
                step_var = self.alloc_var()
                js.append("%s = %s;" % (step_var, step));
            else:
                step_var = step
            js.append("for (%s = %s; %s.PY$__lt__(%s) == True; %s = %s.PY$__add__(%s)) {" % (counter, start, counter, end_var, counter, counter, step_var))
            for stmt in node.body:
                js.extend(self.indent(self.visit(stmt)))
            js.append("}")
            return js


        for_iter = self.visit(node.iter)

        iter_var = self.alloc_var()
        exc_var = self.alloc_var()

        if node.orelse:
            orelse_var = self.alloc_var()
            js.append("var %s = true;" % orelse_var)

        js.append("var %s;" % for_target);
        for_init = "var %s = iter(%s)" % (iter_var, for_iter)
        for_iter = "%s = $PY.next(%s)" % (for_target, iter_var)
        for_cond = "%s !== null" % (for_target)
        js.append("  for (%s; %s; %s) {" % (for_init, for_iter, for_cond))
        if isinstance(node.target, ast.Tuple):
            js.append("    %s;" % "; ".join(["var %s = %s.PY$__getitem__(%s)" % (x.id, for_target, i) for i, x in enumerate(node.target.elts)]))

        for stmt in node.body:
            js.extend(self.indent(self.visit(stmt)))

        js.append("  }")

        if node.orelse:
            js.append("if (%s) {" % orelse_var)
            for stmt in node.orelse:
                js.extend(self.indent(self.visit(stmt)))
            js.append("  }")

        return js

    def visit_While(self, node):
        js = []

        if node.orelse:
            orelse_var = self.alloc_var()
            js.append("var %s = true;" % orelse_var)

        js.append("while (bool(%s) === True) {" % self.visit(node.test))
        if node.orelse:
            js.extend(self.indent(["var %s = true;" % orelse_var]))

        for stmt in node.body:
            js.extend(self.indent(self.visit(stmt)))

        js.append("}")

        if node.orelse:
            js.append("if (%s) {" % orelse_var)

            for stmt in node.orelse:
                js.extend(self.indent(self.visit(stmt)))

            js.append("}")

        return js

    def visit_If(self, node):
        js = ["if (bool(%s) === True) {" % self.visit(node.test)]

        for stmt in node.body:
            js.extend(self.indent(self.visit(stmt)))

        if node.orelse:
            js.append("} else {")

            for stmt in node.orelse:
                js.extend(self.indent(self.visit(stmt)))

        return js + ["}"]

    def _visit_With(self, node):
        pass

    def visit_TryExcept(self, node):
        if node.orelse:
            raise JSError("Try-Except with else-clause not supported")

        js = []
        js.append("try {")
        for n in node.body:
            js.extend(self.indent(self.visit(n)))
        err = self.alloc_var()
        self._exceptions.append(err)
        js.append("} catch (%s) {" % err)
        catchall = False
        for i, n in enumerate(node.handlers):
            if i > 0:
                pre = "else "
            else:
                pre = ""
            if n.type:
                if isinstance(n.type, ast.Name):
                    js.extend(self.indent(["%sif ($PY.isinstance(%s, %s)) {" % (pre, err, self.visit(n.type))]))
                else:
                    raise JSError("Catching non-simple exceptions not supported")
            else:
                catchall = True
                js.append("%sif (true) {" % (pre))

            if n.name:
                if isinstance(n.name, ast.Name):
                    js.append(self.indent(["var %s = %s;" % (self.visit(n.name), err)])[0])
                else:
                    raise JSError("Catching non-simple exceptions not supported")

            for b in n.body:
                js.extend(self.indent(self.visit(b)))

            js.append("}")

        if not catchall:
            js.append("else { throw %s; }" % err);

        js.append("};")
        self._exceptions.pop()
        return js

    def visit_TryFinally(self, node):
        js = []
        exc_var = self.alloc_var()
        exc_store = self.alloc_var()
        js.append("var %s;" % exc_store)
        js.append("try {")
        for n in node.body:
            js.append("\n".join(self.visit(n)))
        js.append("} catch (%s) { %s = %s; }" % (exc_var, exc_store, exc_var))
        for n in node.finalbody:
            js.append("\n".join(self.visit(n)))
        js.append("if (%s) { throw %s; }" % (exc_store, exc_store))
        return js

    def _visit_Import(self, node):
        pass

    def visit_ImportFrom(self, node):
        if node.module == "__future__":
            if len(node.names) == 1 and node.names[0].name == "division":
                self.future_division = True
            else:
                raise JSError("Unknown import from __future__: %s" % node.names[0].name)
        else:
            raise JSError("Import only supports from __future__ import foo")
        return []

    def visit_Lambda(self, node):
        node_args = self.visit(node.args)
        node_body = self.visit(node.body)
        return "function(%s) {return %s;}" % (node_args, node_body)

    def visit_BoolOp(self, node):
        assign = self.stack_destiny(["Assign", "FunctionDef", "Print", "Call", "comprehension"], 1) in ["Assign", "Print", "Call"]

        if isinstance(node.op, ast.And):
            op = " && "
        elif isinstance(node.op, ast.Or):
            op = " || "
        else:
            raise JSError("Unknown boolean operation %s" % node.op)

        if assign:
            var = self.alloc_var()
            return "function() { var %s; %s; return %s; }()" % (var, op.join(["bool(%s = %s) === True" % (var, self.visit(val)) for val in node.values]), var)
        else:
            return op.join(["bool(%s) === True" % self.visit(val) for val in node.values])

    def visit_UnaryOp(self, node):
        if   isinstance(node.op, ast.USub  ): return "%s.PY$__neg__()"            % (self.visit(node.operand))
        elif isinstance(node.op, ast.UAdd  ): return "%s.PY$__pos__()"            % (self.visit(node.operand))
        elif isinstance(node.op, ast.Invert): return "%s.PY$__invert__()"         % (self.visit(node.operand))
        elif isinstance(node.op, ast.Not   ): return "py_builtins.__not__(%s)" % (self.visit(node.operand))
        else:
            raise JSError("Unsupported unary op %s" % node.op)

    def visit_BinOp(self, node):
        left = self.visit(node.left)
        right = self.visit(node.right)

        if isinstance(node.op, ast.Mod) and isinstance(node.left, ast.Str):
            return "%s.PY$__mod__(%s)" % (left, right)

        if not self.future_division and isinstance(node.op, ast.Div):
            node.op = ast.FloorDiv()

        name = node.op.__class__.__name__

        if name in self.ops_binop:
            return "%s.PY$__%s__(%s)" % (left, self.ops_binop[name], right)
        else:
            raise JSError("Unknown binary operation type %s" % node.op)

    def visit_Compare(self, node):
        assert len(node.ops) == 1
        assert len(node.comparators) == 1
        op = node.ops[0]
        comp = node.comparators[0]

        name = op.__class__.__name__

        if name in self.ops_compare:
            return "%s.PY$__%s__(%s)" % (self.visit(node.left), self.ops_compare[name], self.visit(comp))
        elif isinstance(op, ast.In):
            return "%s.PY$__contains__(%s)" % (self.visit(comp), self.visit(node.left))
        elif isinstance(op, ast.Is):
            return "py_builtins.__is__(%s, %s)" % (self.visit(node.left), self.visit(comp))
        elif isinstance(op, ast.NotIn):
            return "py_builtins.__not__(%s.PY$__contains__(%s))" % (self.visit(comp), self.visit(node.left))
        else:
            raise JSError("Unknown comparison type %s" % node.ops[0])

    def visit_Num(self, node):
        if isinstance(node.n, (int, long)):
            if (0 <= node.n <= 9):
                return "$c%s" % str(node.n)
            elif -2**30 < node.n < 2**30:
                return "int(%s)" % str(node.n)
            else:
                raise JSError("Long integer type outside of javascript range")
        elif isinstance(node.n, float):
            return "float(%s)" % node.n
        else:
            raise JSError("Unknown numeric type: %s" % node.n.__class__.__name__)

    def visit_Str(self, node):
        # Uses the Python builtin repr() of a string and the strip string type
        # from it. This is to ensure Javascriptness, even when they use things
        # like b"\\x00" or u"\\u0000".
        return "str(%s)" % repr(node.s).lstrip("urb")

    def visit_Call(self, node):
        js = []
        func = self.visit(node.func)
        compound = ("Assign" in self.stack) or ("AugAssign" in self.stack) or (self.stack.count("Call") > 1)

        if node.keywords or node.kwargs:
            keywords = []
            for kw in node.keywords:
                keywords.append("%s: %s" % (kw.arg, self.visit(kw.value)))
            if node.kwargs:
                kwparam = ", %s" % self.visit(node.kwargs)
            else:
                kwparam = ""
            kwargs = ["__kwargs_make({%s}%s)" % (", ".join(keywords), kwparam)]
        else:
            kwargs = []

        if node.starargs:
            varargs = ["__varargs_make(%s)" % self.visit(node.starargs)]
        else:
            varargs = []

        js_args = ", ".join([ self.visit(arg) for arg in node.args ] + varargs + kwargs)

        js.append("%s(%s)" % (func, js_args))

        return "\n".join(js)

    def visit_Raise(self, node):
        assert node.inst is None
        assert node.tback is None
        if not node.type:
            return ["throw %s;" % self._exceptions[-1]]
        else:
            if isinstance(node.type, ast.Name) and node.type.id in self.builtin:
                return ["throw %s();" % self.visit(node.type)]
            elif isinstance(node.type, (ast.Call, ast.Name)):
                return ["throw %s;" % self.visit(node.type)]
            else:
                raise JSError("Unknown exception type")

    def visit_Attribute(self, node):
        if node.attr.startswith("__") and self.obey_getattr_restriction:
            return """%s.PY$%s""" % (self.visit(node.value), node.attr)
        else:
            return """%s.PY$__getattr__('%s')""" % (self.visit(node.value), node.attr)

    def visit_Tuple(self, node):
        els = [self.visit(e) for e in node.elts]
        return "tuple([%s])" % (", ".join(els))

    def visit_Dict(self, node):
        els = []
        for k, v in zip(node.keys, node.values):
            els.append("%s, %s" % (self.visit(k), self.visit(v)))
        return "dict([%s])" % (", ".join(els))

    def visit_List(self, node):
        els = [self.visit(e) for e in node.elts]
        return "list([%s])" % (", ".join(els))

    def visit_comprehension(self, node):
        if isinstance(node.target, ast.Name):
            var = self.visit(node.target)
        elif isinstance(node.target, ast.Tuple):
            var = self.alloc_var()
        else:
            raise JSError("Unsupported target type in list comprehension")
        iter_var = self.alloc_var()
        res = "var %s; for (var %s = iter(%s); %s = $PY.next(%s); %s !== null) {\n" % (var, iter_var, self.visit(node.iter), var, iter_var, var)
        if isinstance(node.target, ast.Tuple):
            for i, el in enumerate(node.target.elts):
                if isinstance(el, ast.Name):
                    n = self.visit(el)
                else:
                    raise JSError("Invalid tuple element in list comprehension")
                res += "var %s = %s.PY$__getitem__($c%d);\n" % (n, var, i)

        if node.ifs:
            ifexp = []
            for exp in node.ifs:
                ifexp.append("bool(%s) === False" % self.visit(exp))
            res += "if (%s) { continue; }" % (" || ".join(ifexp))
        return res

    def visit_ListComp(self, node):
        res_var = self.alloc_var()
        exp = "%s.PY$append(%s)" % (res_var, self.visit(node.elt))
        for x in node.generators:
            exp = "%s %s}" % (self.visit(x), exp)

        return "(function() {var %s = list(); %s; return %s})()" % (res_var, exp, res_var)

    def visit_GeneratorExp(self, node):
        if not len(node.generators) == 1:
            raise JSError("Compound generator expressions not supported")
        if not isinstance(node.generators[0].target, ast.Name):
            raise JSError("Non-simple targets in generator expressions not supported")

        return "py_builtins.map(function(%s) {return %s;}, %s)" % (node.generators[0].target.id, self.visit(node.elt), self.visit(node.generators[0].iter))

    def visit_Slice(self, node):
        if node.lower and node.upper and node.step:
            return "slice(%s, %s, %s)" % (self.visit(node.lower),
                    self.visit(node.upper), self.visit(node.step))
        if node.lower and node.upper:
            return "slice(%s, %s)" % (self.visit(node.lower),
                    self.visit(node.upper))
        if node.upper and not node.step:
            return "slice(%s)" % (self.visit(node.upper))
        if node.lower and not node.step:
            return "slice(%s, null)" % (self.visit(node.lower))
        if not node.lower and not node.upper and not node.step:
            return "slice(null)"
        raise NotImplementedError("Slice")

    def visit_Subscript(self, node):
        return "%s.PY$__getitem__(%s)" % (self.visit(node.value), self.visit(node.slice))

    def visit_Index(self, node):
        return self.visit(node.value)

########NEW FILE########
__FILENAME__ = decorator
######################################################################
##
## Copyright 2010-2011 Ondrej Certik <ondrej@certik.cz>
## Copyright 2010-2011 Mateusz Paprocki <mattpap@gmail.com>
## Copyright 2011 Christian Iversen <ci@sikkerhed.org>
## Copyright 2011 Samuel Ytterbrink <neppord@gmail.com>
##
## Permission is hereby granted, free of charge, to any person
## obtaining a copy of this software and associated documentation
## files (the "Software"), to deal in the Software without
## restriction, including without limitation the rights to use,
## copy, modify, merge, publish, distribute, sublicense, and/or sell
## copies of the Software, and to permit persons to whom the
## Software is furnished to do so, subject to the following
## conditions:
##
## The above copyright notice and this permission notice shall be
## included in all copies or substantial portions of the Software.
##
## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
## EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
## OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
## NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
## HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
## WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
## FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
## OTHER DEALINGS IN THE SOFTWARE.
##
######################################################################

import pyjaco

import inspect 

class JSVar(object):
    """Decorates a function by marking an identifier as belonging to JavaScript"""

    def __init__(self, *names):
        self.names = [x.split(".") for x in names]

    def __call__(self, obj):
        return obj

class JavaScript(object):
    """
    Decorator that you can use to convert methods to JavaScript.

    For example this code::

        @JavaScript
        class TestClass(object):
            def __init__(self):
                alert('TestClass created')
                self.reset()

            def reset(self):
                self.value = 0

            def inc(self):
                alert(self.value)
                self.value += 1

        print str(TestClass)

    prints::

        function TestClass() {
            return new _TestClass();
        }
        function _TestClass() {
            this.__init__();
        }
        _TestClass.__name__ = 'TestClass'
        _TestClass.prototype.__class__ = _TestClass
        _TestClass.prototype.__init__ = function() {
            alert("TestClass created");
            this.reset();
        }
        _TestClass.prototype.reset = function() {
            this.value = 0;
        }
        _TestClass.prototype.inc = function() {
            alert(this.value);
            this.value += 1;
        }

    Alternatively, an equivalent way is to use JavaScript() as a function:

        class TestClass(object):
            def __init__(self):
                alert('TestClass created')
                self.reset()

            def reset(self):
                self.value = 0

            def inc(self):
                alert(self.value)
                self.value += 1

        print str(JavaScript(TestClass))

    If you want to call the original function/class as Python, use the
    following syntax::

        js = JavaScript(TestClass)
        test_class = js() # Python instance of TestClass() will be created
        js_class = str(js) # A string with the JS code

    """

    def __init__(self, *args):
        self.jsvars = list(args)
        self._js = None

    def __call__(self, obj):
        lines = inspect.getsource(obj).split("\n")
        if lines[0].startswith("@"):
            lines.pop(0)
        self._js = pyjaco.compile_string("\n".join(lines), self.jsvars)
        return self._js


########NEW FILE########
__FILENAME__ = formater
######################################################################
##
## Copyright 2011 Samuel Ytterbrink <neppord@gmail.com>
##
## Permission is hereby granted, free of charge, to any person
## obtaining a copy of this software and associated documentation
## files (the "Software"), to deal in the Software without
## restriction, including without limitation the rights to use,
## copy, modify, merge, publish, distribute, sublicense, and/or sell
## copies of the Software, and to permit persons to whom the
## Software is furnished to do so, subject to the following
## conditions:
##
## The above copyright notice and this permission notice shall be
## included in all copies or substantial portions of the Software.
##
## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
## EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
## OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
## NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
## HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
## WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
## FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
## OTHER DEALINGS IN THE SOFTWARE.
##
######################################################################

""" A formater module that keeps trac of indentation
"""
class Formater(object):
    """
    A very simple code formater that handles efficient concatenation and indentation of lines.
    """

    def __init__(self, indent_string="    "):
        self.__buffer = []
        self.__indentation = 0
        self.__indent_string = indent_string
        self.__indent_temp = ""
        self.__string_buffer = ""

    def dedent(self):
        """
        Subtracts one indentation level.
        """
        self.__indentation -= 1
        self.__indent_temp = self.__indent_string*self.__indentation

    def indent(self):
        """
        Adds one indentation level.
        """
        self.__indentation += 1
        self.__indent_temp = self.__indent_string*self.__indentation

    def write(self, text, indent=True, newline=True):
        """
        Writes the string text to the buffer with indentation and a newline if not specified otherwise.
        """
        if indent:
            self.__buffer.append(self.__indent_temp)
        self.__buffer.append(text)
        if newline:
            self.__buffer.append("\n")

    def read(self, size=None):
        """
        Returns a string representation of the buffer.
        """
        if size == None:
            text = self.__string_buffer + "".join(self.__buffer)
            self.__buffer = []
            self.__string_buffer = ""
            return text
        else:
            if len(self.__string_buffer) < size:
                self.__string_buffer += "".join(self.__buffer)
                self.__buffer = []
                if len(self.__string_buffer) < size:
                    text, self.__string_buffer = self.__string_buffer, ""
                    return text
                else:
                    text, self.__string_buffer = self.__string_buffer[:size], \
                        self.__string_buffer[size:]
                    return text
            else:
                text, self.__string_buffer = self.__string_buffer[:size], \
                    self.__string_buffer[size:]
                return text


########NEW FILE########
__FILENAME__ = pyjs
#! /usr/bin/env python

import re
import sys
import os.path
import datetime
import time
import traceback
import pkg_resources
from optparse import OptionParser
from pyjaco import Compiler

# extensions of files that can be compiled to .js
VALID_EXTENSIONS = ['.py', '.pyjaco']

OPEN_COMMENT = re.compile("^\s*/\*")
CLOSE_COMMENT = re.compile(".*\*/\s*$")
COMMENT = re.compile("^\s*//")
BLANK = re.compile("^\s*$")

class BuiltinGenerator(object):
    def comment_stripper(self, lines):
        '''Generator that removes all javascript comment lines from a file.
        Takes a sequence of strings as input, generates a sequence of strings
        with comments stripped.
        
        Assumes multi-line comments start with /* and end with */ with no valid
        code other than whitespace before or after the opening and closing
        symbols. In other words, comments like this:

        alert('hello'); /* this is
        a multi line comment */ alert('world')

        would not have the comment stripped.
        '''
        in_multi_comment = False
        for line in lines:
            if in_multi_comment:
                if CLOSE_COMMENT.match(line):
                    in_multi_comment = False
            elif OPEN_COMMENT.match(line):
                in_multi_comment = True
            elif not BLANK.match(line) and not COMMENT.match(line):
                yield line

    def generate_builtins(self):
        '''Combine the builtins shipped with the pyjaco library into a single
        py-builtins.js file.'''
        builtin_lines = []
        js_filenames = sorted(
                [f for f in pkg_resources.resource_listdir("pyjaco", "stdlib") if f.endswith(".js")])
        for js_filename in js_filenames:
            builtin_lines.append("\n/* %-30s*/" % js_filename)
            lines = self.comment_stripper(pkg_resources.resource_string(
                "pyjaco", "stdlib/%s" % js_filename
                ).splitlines())
            builtin_lines.extend(lines)

        return "\n".join(builtin_lines)


def compile_file(infile, outfile, options):
    '''Compile a single python file object to a single javascript output file
    object'''
    if options.builtins == "include":
        builtins = BuiltinGenerator().generate_builtins()

        outfile.write("/*%s*/\n" % "  Standard library  ".center(76, "*"))
        outfile.write(builtins)
        outfile.write("/*%s*/\n" % "  User code  ".center(76, "*"))
    elif options.builtins == "import":
        outfile.write('load("py-builtins.js");\n')

    c = Compiler()
    c.append_string(infile.read())
    outfile.write(str(c))

def run_once(input_filenames, options):
    '''Given the input filenames and collection of options, run the compilation
    step exactly once. Ignores the -w option. If the -w option is passed, then
    this function should be called each time a file changes.'''
    if options.builtins == "generate":
        if input_filenames and (not options.output or not os.path.isdir(options.output)):
            parser.error("--builtins=generate can only be used if --output is a directory or if no input files are specified")

        if options.output: 
            if os.path.isdir(options.output):
                builtin_filename = os.path.join(options.output, "py-builtins.js")
            else:
                builtin_filename = options.output
            builtin_output = open(builtin_filename, "w")
        else:
            builtin_output = sys.stdout

        builtins = BuiltinGenerator().generate_builtins()
        builtin_output.write(builtins)

    if len(input_filenames) == 1 and not os.path.isdir(input_filenames[0]):
        if not options.output:
            output = sys.stdout
        elif os.path.isdir(options.output):
            output_filename = os.path.splitext(os.path.basename(input_filenames[0]))[0]
            output_filename += ".js"
            output = open(os.path.join(options.output, output_filename), "w")
        else:
            output = open(options.output, "w")

        if not options.quiet:
            sys.stderr.write("[%s] compiling %s\n" % (datetime.datetime.now(), input_filenames[0]))
        with open(input_filenames[0]) as input:
            compile_file(input, output, options)
    else:
        if input_filenames and (not options.output or not os.path.isdir(options.output)):
            parser.error("--output must be a directory if the input file is a directory")

        if len(input_filenames) == 1: # input_filenames contains a directory
            input_filenames = [os.path.join(input_filenames[0], f) for f in os.listdir(input_filenames[0]
                ) if os.path.splitext(f)[1] in VALID_EXTENSIONS]

        for input_filename in input_filenames:
            output_filename = os.path.splitext(os.path.basename(input_filename))[0]
            output_filename += ".js"
            if not options.quiet:
                sys.stderr.write("[%s] compiling %s\n" % (datetime.datetime.now(), input_filename))
            with open(input_filename) as input:
                with open(os.path.join(options.output, output_filename), "w") as output:
                    compile_file(input, output, options)

class Monitor:
    '''Class to monitor for changes in a file or directory and recompile if
    they have changed.'''
    def __init__(self, input_filenames, options):
        self.input_filenames = input_filenames
        self.options = options
        self.reset_mtimes()

    def reset_mtimes(self):
        '''reset the modification times to a dict with empty values.'''
        self.mtimes = dict([(f, None) for f in self.filenames])

    @property
    def filenames(self):
        '''Return a list of filenames to be monitored. If the input_filenames
        contains specific files return a list containing those files. Otherwise
        if it is a directory, return the list of files in that directory that
        have .py or .pyjaco extensions.'''
        if len(self.input_filenames) > 1 or not os.path.isdir(self.input_filenames[0]):
            return self.input_filenames
        else: # a single argument containing a directory
            return [os.path.join(self.input_filenames[0], f
                ) for f in os.listdir(self.input_filenames[0]
                    ) if os.path.splitext(f)[1] in VALID_EXTENSIONS]

    def code_changed(self):
        '''Return True if the code has changed since the previous run of this
        method.'''
        filenames = self.filenames
        if len(filenames) != len(self.mtimes):
            # a file was added or deleted, therefore code has changed
            self.reset_mtimes()
            return True

        for filename in filenames:
            stat = os.stat(filename)
            mtime = stat.st_mtime
            mtime = mtime - stat.st_ctime if sys.platform == "win32" else mtime

            if self.mtimes.get(filename) == None:
                self.mtimes[filename] = mtime
                continue

            if mtime != self.mtimes[filename]:
                self.reset_mtimes()
                return True

        return False

    def safe_run_once(self):
        '''Run once, catching any exceptions and printing them, but allowing
        the watcher to continue.'''
        try:
            run_once(self.input_filenames, self.options)
        except Exception as e:
            if not self.options.quiet:
                traceback.print_exc(file=sys.stderr)
                sys.stderr.write("\n")

    def run(self):
        self.safe_run_once()
        while True:
            if self.code_changed():
                self.safe_run_once()

            time.sleep(1)

parser = OptionParser(usage="""%prog [options] <infile>
        
        where infile is the name of a file or directory to be compiled.
        If infile is a directory, all files in that directory that have
        an extension of .py or .pyjaco will be compiled to .js files
        in the output directory.""",
                      description="Python to JavaScript compiler.")


def main():
    parser.add_option("-o", "--output",
                      action = "store",
                      dest   = "output",
                      help   = "write output to OUTPUT, can be a file or directory")

    parser.add_option("-q", "--quiet",
            action = "store_true",
            help = "Do not print informative notes to stderr")

    parser.add_option("-b", "--builtins",
            action = "store",
            dest = "builtins",
            choices = ["include", "import", "generate", "none"],
            default = "none",
            help = "INCLUDE builtins statically in each file\nIMPORT builtins using a load statement in each file\nGENERATE a separate file for builtins (output must be a directory)\nNONE don't include builtins")

    parser.add_option("-I", "--import",
            action = "store_const",
            const = "import",
            dest = "builtins",
            help = "IMPORT builtins using a load statement in each file\n\nThis is an alias for -b import")

    parser.add_option("-w", "--watch",
            action = "store_true",
            dest = "watch",
            default = False,
            help = "Watch the input files for changes and recompile. If the input file is a single file, watch it for changes and recompile. If a directory, recompile if any .py or .pyjaco files in the directory have changes.")

    options, args = parser.parse_args()

    if len(args) == 0 and options.builtins != "generate":
        parser.error("No input path specified. You must supply an input file, or pass --builtins=generate")
    elif len(args) > 1 and not os.path.isdir(options.output):
        parser.error("Multiple input arguments supplied, but output is not a directory.")
    else:
        for arg in args:
            if not os.path.exists(arg):
                parser.error("The input path '%s' does not point to a valid file or directory" % arg)

        if not options.watch:
            run_once(args, options)
        else:
            monitor = Monitor(args, options)
            monitor.run()

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = run_tests
#! /usr/bin/python

import optparse
import testtools.runner
import testtools.util
import testtools.tests
from unittest import installHandler

def main():
    installHandler()
    option_parser = optparse.OptionParser(
        usage="%prog [options] [filenames]",
        description="pyjaco unittests script."
        )
    option_parser.add_option(
        "-a",
        "--run-all",
        action="store_true",
        dest="run_all",
        default=False,
        help="run all tests (including the known-to-fail)"
        )
    option_parser.add_option(
        "-x",
        "--no-error",
        action="store_true",
        dest="no_error",
        default=False,
        help="ignores error (don't display them after tests)"
        )
    option_parser.add_option(
        "-f",
        "--only-failing",
        action="store_true",
        dest="only_failing",
        default=False,
        help="run only failing tests (to check for improvements)"
        )
    options, args = option_parser.parse_args()
    runner = testtools.runner.Py2JsTestRunner(verbosity=2)
    results = None
    try:
        if options.run_all:
            results = runner.run(testtools.tests.ALL)
        elif options.only_failing:
            results = runner.run(testtools.tests.KNOWN_TO_FAIL)
        elif args:
            results = runner.run(testtools.tests.get_tests(args))
        else:
            results = runner.run(testtools.tests.NOT_KNOWN_TO_FAIL)
    except KeyboardInterrupt:
        pass
    if not options.no_error and results and results.errors:
        print
        print "errors:"
        print "  (use -x to skip this part)"
        for test, error in results.errors:
            print
            print "*", str(test), "*"
            print error

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = fib



def fib(x):
    if x == 1:
        return x
    else:
        return x*fib(x-1)

print fib(4)

########NEW FILE########
__FILENAME__ = sqrt
def abs(x):
    if x > 0:
        return x
    else:
        return -x

def sqrt(x):
    eps = 1e-10
    x = float(x)
    r = x/2
    residual = r**2 - x
    while abs(residual) > eps:
        r_d = -residual/(2*r)
        r += r_d
        residual = r**2 - x
    return r

def p(x):
    prec = 11
    l = list(iter(str(x)))[:prec]
    if not "." in l:
        l.append(".")
        l.append("0")
    while len(l) < prec:
        l.append("0")
    s = ""
    for c in l:
        s += c
    return s

print p(sqrt(1))
print p(sqrt(2))
print p(sqrt(3))
print p(sqrt(4))
print p(sqrt(5))
print p(sqrt(6))
print p(sqrt(7000))

########NEW FILE########
__FILENAME__ = triangulation
def abs(x):
    if x > 0:
        return x
    else:
        return -x

def sqrt(x):
    eps = 1e-10
    x = float(x)
    r = x/2
    residual = r**2 - x
    while abs(residual) > eps:
        r_d = -residual/(2*r)
        r += r_d
        residual = r**2 - x
    return r

def is_on_the_left(c, a, b, pts_list):
   ax, ay = pts_list[a]
   bx, by = pts_list[b]
   cx, cy = pts_list[c]
   ux = float(bx - ax)
   uy = float(by - ay)
   vx = float(cx - ax)
   vy = float(cy - ay)
   return (ux*vy - uy*vx > 0)

def criterion(a, b, c, pts_list):
   ax, ay = pts_list[a]
   bx, by = pts_list[b]
   cx, cy = pts_list[c]
   ux = float(ax - cx)
   uy = float(ay - cy)
   vx = float(bx - cx)
   vy = float(by - cy)
   len_u = sqrt(ux*ux + uy*uy)
   len_v = sqrt(vx*vx + vy*vy)
   return (ux*vx + uy*vy)/(len_u*len_v)

def find_third_point(a, b, pts_list, edges):
    """
    Take a boundary edge (a,b), and in the list of points
    find a point 'c' that lies on the left of ab and maximizes
    the angle acb
    """
    found = 0
    minimum = 10**8   #this is dirty
    c_index = -1
    pt_index = -1
    for c_point in pts_list:
        c_index += 1
        if c_index != a and c_index != b and is_on_the_left(c_index, a, b, pts_list):
            edge_intersects = \
                    edge_intersects_edges((a, c_index), pts_list, edges) or \
                    edge_intersects_edges((b, c_index), pts_list, edges)
            if not edge_intersects:
                crit = criterion(a, b, c_index, pts_list)
                if crit < minimum:
                    minimum = crit
                    pt_index = c_index
                    found = 1
    if found == 0:
        raise TriangulationError("ERROR: Optimal point not found in find_third_point().")
    return pt_index

def lies_inside(c, bdy_edges):
   for edge in bdy_edges:
       a,b = edge
       if c == a or c == b: return False
   return True

def is_boundary_edge(a, b, bdy_edges):
    """
    Checks whether edge (a, b) is in the list of boundary edges
    """
    for edge in bdy_edges:
        a0, b0 = edge
        if a == a0 and b == b0:
            return True
    return False

def triangulate_af(pts_list, bdy_edges):
    """
    Create a triangulation using the advancing front method.
    """
    # create empty list of elements
    elems = []
    bdy_edges = bdy_edges[:]
    # main loop
    while bdy_edges != []:
        # take the last item from the list of bdy edges (and remove it)
        a,b = bdy_edges.pop()
        c = find_third_point(a, b, pts_list, bdy_edges)
        elems.append((a,b,c))
        if is_boundary_edge(c, a, bdy_edges):
            bdy_edges.remove((c,a))
        else:
            bdy_edges.append((a,c))
        if is_boundary_edge(b, c, bdy_edges):
            bdy_edges.remove((b,c))
        else:
            bdy_edges.append((c,b))
    return elems

def ccw(A, B, C):
    return (C[1]-A[1])*(B[0]-A[0]) > (B[1]-A[1])*(C[0]-A[0])

def intersect(A, B, C, D):
    return ccw(A, C, D) != ccw(B, C, D) and ccw(A, B, C) != ccw(A, B, D)

def two_edges_intersect(nodes, e1, e2):
    """
    Checks whether the two edges intersect.

    It assumes that e1 and e2 are tuples of (a_id, b_id) of ids into the nodes.
    """
    A = nodes[e1[0]]
    B = nodes[e1[1]]
    C = nodes[e2[0]]
    D = nodes[e2[1]]
    return intersect(A, B, C, D)

def any_edges_intersect(nodes, edges):
    """
    Returns True if any two edges intersect.
    """
    for i in range(len(edges)):
        for j in range(i+1, len(edges)):
            e1 = edges[i]
            e2 = edges[j]
            if e1[1] == e2[0] or e1[0] == e2[1]:
                continue
            if two_edges_intersect(nodes, e1, e2):
                return True
    return False

def edge_intersects_edges(e1, nodes, edges):
    """
    Returns True if "e1" intersects any edge from "edges".
    """
    for i in range(len(edges)):
        e2 = edges[i]
        if e1[1] == e2[0] or e1[0] == e2[1]:
            continue
        if two_edges_intersect(nodes, e1, e2):
            return True
    return False

def example1():
    nodes = [
            (0, 0),
            (1, 0),
            (1, 1),
            (0, 1),
            ]
    edges = [(0, 1), (1, 2), (2, 3), (3, 0)]
    elems = triangulate_af(nodes, edges)
    return nodes, edges, elems

def example2():
    nodes = [
            (0, 0),
            (1, 0),
            (2, 1),
            (2, 2),
            (1, 2),
            (0.5, 1.5),
            (0, 1),
            ]
    edges = [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0)]
    elems = triangulate_af(nodes, edges)
    return nodes, edges, elems

nodes, edges, elems = example1()
print nodes
print edges
print elems
if not any_edges_intersect(nodes, edges):
    print "ok"

print
nodes, edges, elems = example2()
print nodes
print edges
print elems
if not any_edges_intersect(nodes, edges):
    print "ok"

########NEW FILE########
__FILENAME__ = dir_and_startswith

class Foo(object):

    a = 1
    b = 2
    c = 3

f = Foo()
for x in ("a", "b", "c", "d"):
    print "%s: %s" % (x, x in dir(f))

f.d = 4

for x in ("a", "b", "c", "d"):
    print "%s: %s" % (x, x in dir(f))

print filter(lambda x: not x.startswith('__'), dir(f))
print filter(lambda x: not x.endswith('__'), dir(f))

########NEW FILE########
__FILENAME__ = for_step

for x in xrange(19,342,13):
    print x

########NEW FILE########
__FILENAME__ = for_xrange

for x in xrange(1,10):
    print x

########NEW FILE########
__FILENAME__ = globalvar


a = "spam"
b = "eggs"

print a
print b

########NEW FILE########
__FILENAME__ = helloworld

print('hello')
print('hello world')

########NEW FILE########
__FILENAME__ = lambda

y = lambda x:x*x

print y(4)


########NEW FILE########
__FILENAME__ = lambda2

x = lambda x: (lambda x: (lambda x: x + 2)(x+2))(x+2)

print x(2)

########NEW FILE########
__FILENAME__ = lambda3

la = []

for x in range(5):
    la.append((lambda y: lambda q: q + y)(x))
#    la.append(lambda y: (lambda q: q + y)(x))

print la[0](10)
print la[1](10)
print la[2](10)
print la[3](10)
print la[4](10)

########NEW FILE########
__FILENAME__ = lambda4

la = []

for x in range(5):
    la.append(lambda x: (lambda q: q + x)(x))

print la[3](1)

########NEW FILE########
__FILENAME__ = literals

a = 1.234
b = 3
c = 3.45
d = 'cats'

print a
print b
print c
print d

########NEW FILE########
__FILENAME__ = multiassign

x,y,z = (1,2,3)

print x,y,z

########NEW FILE########
__FILENAME__ = none

x = None

if x == None:
    print "x is None/null"
else:
    print "x is not None/null"

########NEW FILE########
__FILENAME__ = print

print 1.23, "foobar", -1, 'x'

########NEW FILE########
__FILENAME__ = raise


a = "hello"

try:
    try:
        print "Trying illegal access"
        x = "abc"
        x.abc()
    except:
        print "Exception raised, re-raising"
        raise
except:
    print "Exception raised"
    pass

########NEW FILE########
__FILENAME__ = range
for x in range(10):
    print x

for x in range(10, 20):
    print x

for x in range(10, 100, 7):
    print x

########NEW FILE########
__FILENAME__ = sumcomp


x = sum(x*x for x in [2,3,4,5,6,7])
print x

########NEW FILE########
__FILENAME__ = try

class MyException(Exception):

    def __init__(self,msg):
        self.msg = msg

    def message(self):
        return self.msg

class MyOtherException(Exception):

    def __init__(self,msg):
        self.msg = msg

    def message(self):
        return self.msg

for index in [1,2]:
    try:
        print 'raising exception...'
        if index==1:
            raise MyException('bar')
        elif index==2:
            raise MyOtherException('foo')
    except MyOtherException, ex2:
        print 'caught other exception:' + ex2.message()
    except MyException, ex:
        print 'caught exception:' + ex.message()
    finally:
        print 'and finally...'

########NEW FILE########
__FILENAME__ = try2

try:
    raise IOError("foo")
except Exception, e:
    print e.message

try:
    raise IOError("foo")
except:
    print "x"

try:
    raise IOError("foo")
except TypeError:
    print "type"
except IOError:
    print "io"
except:
    print "y"

def foo():
    try:
        raise IOError("foo")
    except TypeError, e:
        print e.message

try:
    foo()
except IOError:
    print "z"

########NEW FILE########
__FILENAME__ = try_finally

try:
    1/0
except:
    print "nothing to see here, move along"

try:
    try:
        1/0
    finally:
        print "finally"
except Exception, E:
    print E

########NEW FILE########
__FILENAME__ = try_finally2

try:
    print "no exception"
finally:
    print "done"

########NEW FILE########
__FILENAME__ = bool_values
m = [[], {}, 0.0, 0, "", "0", "x", True, False]

for x in m:
    print "%s: %s" % (bool(x), x)

########NEW FILE########
__FILENAME__ = logicalops

x = True
y = False
z = not y

if x:
    print 'x'
if y:
    print 'y'
if z:
    print 'z'

########NEW FILE########
__FILENAME__ = trueorfalse

literals = ['a','',0,None,1,0.0,1.0,-1,-1.0,-0]

for l in literals:
    if l:
        print "True"
    else:
        print "False"

########NEW FILE########
__FILENAME__ = callclass
class Foo(object):

    def __call__(self):
        print "Indeed!"

f = Foo()
f()

########NEW FILE########
__FILENAME__ = default
g = 99

def f(a, b=1, c="default c", d=g):
    print a
    print b
    print c
    print d

f(0)
f(0, 77)
f(0, 77, "hello")

########NEW FILE########
__FILENAME__ = kwargs
def myfunc(a, b, *c, **d):
    print a
    print b
    for i in c:
        print i
    keys = d.keys()
    keys.sort()
    for i in keys:
        print i
        print d[i]

myfunc(1, 2, bar='a', foo='c')
print
myfunc(1, 2, 3, 4, bar='a', foo='c')

########NEW FILE########
__FILENAME__ = kwargs2
def myfunc(a, b=3, c=4):
    print a
    print b
    print c
    print

myfunc(1)
myfunc(1, 2)
myfunc(1, 2, 3)
myfunc(1, c=3, b=4)
myfunc(1, b=4)

########NEW FILE########
__FILENAME__ = kwargs3
def foo(a, b = None):
    print a, b
    return a

def bar(x):
    return x

print bar(foo(17, b = "foo"))

########NEW FILE########
__FILENAME__ = kwargs4
def myfunc(a, b = 42, c = 10, *d, **e):
    print a
    print b
    print c
    for i in d:
        print i
    keys = e.keys()
    keys.sort()
    for i in keys:
        print i
        print e[i]

myfunc(1, 2, bar='a', foo='c')
print "----"
myfunc(1, 2, 3, 4, bar='a', foo='c')
print "----"
myfunc(1, bar='a', foo='c')
print "----"
myfunc(1, 2, 3, 4, 5, 6, 7, 8)

########NEW FILE########
__FILENAME__ = kwargs5

def foo(a, b, c, d = 10):
    print a, b, c, d

foo(1, 2, 3, 4)
foo(1, 2, 3)
foo(1, 2, 3, d = 20)
foo(1, 2, c = 10, d = 20)
foo(d = 4, c = 3, b = 2, a = 1)
foo(**dict(d = 4, c = 3, b = 2, a = 1))


########NEW FILE########
__FILENAME__ = kwargs6

def fun1(*vargs):
    print vargs

def fun2(*vargs, **kwargs):
    print vargs, kwargs

fun1()
fun1(1,2,3)
fun1(*[1,2,3])
fun1(*[1,2,3] + [4,5,6])
l = [4,5,6]
fun1(*l + l)

for x in [dict(), dict(a = "a")]:
    fun2(**x)
    fun2(1,2,3, **x)
    fun2(*[1,2,3], **x)
    fun2(*[1,2,3] + [4,5,6], **x)
    l = [4,5,6]
    fun2(*l + l, **x)

########NEW FILE########
__FILENAME__ = kwargs7

def foo(x, y, **vals):
    print x, y, vals.keys(), vals.values()

foo(1, 2, z = 3)
foo(y = 2, x = 1, z = 3)
foo(x = 1, y = 2, z = 3, w = 4)
foo(1, 2)

########NEW FILE########
__FILENAME__ = kwvarargs

def foo(a, b, c):
   print a, b, c

foo(1, 2, 3)
foo(1, 2, *[3])
foo(1, *[2, 3])
foo(*[1, 2, 3])

def bar(a, b, c, *vargs):
    print a, b, c, vargs

for x in ([], [4], [4, 5], [4, 5, 6]):
    bar(1, 2, 3, *x)
    bar(1, 2, *[3] + x)
    bar(1, *[2, 3] + x)
    bar(*[1, 2, 3] + x)
    bar(*[1, 2, 3, 4, 5])

def baz(a, b, c, *vargs, **kwargs):
    print a, b, c, vargs, kwargs

for x in ([], [4], [4, 5], [4, 5, 6]):
    baz(1, 2, 3, *x, foo = "bar")
    baz(1, 2, *[3] + x, foo = "bar")
    baz(1, *[2, 3] + x, foo = "bar")
    baz(*[1, 2, 3] + x, foo = "bar")
    baz(*[1, 2, 3, 4, 5], foo = "bar")

########NEW FILE########
__FILENAME__ = return-none

def foo():
    return

print foo()

########NEW FILE########
__FILENAME__ = vargs

def myfunc(a,b,*c):
    print a
    print b
    for i in c:
        print i

myfunc(1,2)
myfunc('a','b','c','d')
myfunc(3,4,5,6,'hello')


########NEW FILE########
__FILENAME__ = class


class foobar(object):
    
    x = 1

    def __init__(self):
        self.foovar = 1

    def foo(self,x):
        self.foovar = self.foovar + x

    def bar(self):
        print self.foovar

f = foobar()
f.bar()
f.foo(1)
f.foo(2)
f.bar()
f.bar()
f.foo(-1)
f.bar()
f.foo(7)
f.bar()



########NEW FILE########
__FILENAME__ = class2
class Class1(object):

    def __init__(self):
        pass

    def test1(self):
        return 5

class Class2(object):

    def test1(self):
        return 6

class Class3(object):

    def test1(self, x):
        return self.test2(x)-1

    def test2(self, x):
        return 2*x

a = Class1()
print a.test1()

a = Class2()
print a.test1()

a = Class3()
print a.test1(3)
print a.test2(3)

########NEW FILE########
__FILENAME__ = class3
class A(object):
    v = 1

a = A()
XX = A
x = XX()
print x.v

########NEW FILE########
__FILENAME__ = class4
def create(cls):
    return cls()

class A(object):
    def m(self):
        print "A.m()"

a = A()
a.m()

b = create(A)
b.m()

########NEW FILE########
__FILENAME__ = class5
def create(cls):
    return cls()

class A:
    def m(self):
        print "A.m()"

a = A()
a.m()

b = create(A)
b.m()

########NEW FILE########
__FILENAME__ = class6
def create(cls):
    return cls()

class A:
    def __init__(self):
      self.msg = "A.m()"
    def m(self):
        print self.msg

a = A()
a.m()

b = create(A)
b.m()

########NEW FILE########
__FILENAME__ = del_attr


class spam:

    def __init__(self):
        self.eggs = 0

    def addegg(self):
        try:
            if self.eggs:
                self.eggs += 1
            else:
                self.eggs = 1
        except:
            self.eggs = 1

    def printit(self):
        try:
            if self.eggs:
                print self.eggs
            else:
                print "no eggs"
        except:
            print "no eggs"

    
s = spam()
s.addegg()
s.addegg()
s.printit()
s.addegg()
s.printit()
del s.eggs
s.printit()
s.addegg()
s.addegg()
s.printit()

########NEW FILE########
__FILENAME__ = docstring

class myclass(object):

    """This is a class that really says something"""

    def __init__(self,msg):
        self.msg = msg

    def saysomething(self):
        print self.msg
        
m = myclass("hello")

m.saysomething()

########NEW FILE########
__FILENAME__ = getattr
class Foo(object):

    def __getattr__(self, key):
        x = key.split("_")
        if len(x) > 1 and x[1] == "foo":
            return "FOO"
        else:
            return "BAR"

f = Foo()
print f.foo_foo
print f.bonk
        

########NEW FILE########
__FILENAME__ = getattr2
class Foo(object):

    def __getattr__(self, key):
        print "In __getattr__"
        return 1

    __foo__ = "42"

f = Foo()
print f.__foo__
print f.bar

########NEW FILE########
__FILENAME__ = nestedclass

class foo(object):

    class bar(object):

        def msg(self):
            print "bar"

    def msg(self):
        print "foo"
        b = self.bar()
        b.msg()

f = foo.bar()
f.msg()
f = foo()
f.msg()

########NEW FILE########
__FILENAME__ = oo

class foo(object):
    
    registered = []

    def __init__(self,val):
        self.fval = val
        self.register(self)

    def inc(self):
        self.fval += 1

    def msg(self):
        return "foo says:"+str(self.fval)

    @staticmethod
    def register(f):
        foo.registered.append(f)

    @staticmethod
    def printregistered():
        for r in foo.registered:
            print r.msg()

a = foo(10)
b = foo(20)
c = foo(30)

a.inc()
a.inc()
c.inc()

print a.msg()
print b.msg()
print c.msg()

print "---"

foo.printregistered()

########NEW FILE########
__FILENAME__ = oo_attributes
class Foobar(object):
    foo = 1
    bar = [1, 2, 3]

my_foobar = Foobar()
print my_foobar.foo
print my_foobar.bar
print Foobar.foo
print Foobar.bar
my_foobar.foo = 2
my_foobar.bar.append(5)
print my_foobar.foo
print my_foobar.bar
print Foobar.foo
print Foobar.bar
Foobar.foo = 3
Foobar.bar.append(6)
print my_foobar.foo
print my_foobar.bar
print Foobar.foo
print Foobar.bar

########NEW FILE########
__FILENAME__ = oo_descriptor_semantics
class cls(object):
    x = 10

obj = cls()
print "cls:", cls.x
print "obj:", obj.x

cls.x = 20
print "cls:", cls.x
print "obj:", obj.x

obj.x = 30
print "cls:", cls.x
print "obj:", obj.x

cls.x = 40
print "cls:", cls.x
print "obj:", obj.x

del obj.x
print "cls:", cls.x
print "obj:", obj.x

########NEW FILE########
__FILENAME__ = oo_diamond

class foobar(object):

    def m1(self):
        print "foobar.m1"

    def m2(self):
        print "foobar.m2"

    def m3(self):
        print "foobar.m3"

    def m4(self):
        print "foobar.m4"


class foo(foobar):

    def m2(self):
        print "foo.m2"

    def m4(self):
        print "foo.m4"

class bar(foobar):

    def m3(self):
        print "bar.m3"

class myfb(foo,bar):

    def m4(self):
        print "myfb.m4"

x = myfb()
x.m1()
x.m2()
x.m3()
x.m4()

########NEW FILE########
__FILENAME__ = oo_inherit

class bar(object):

    def __init__(self,name):
        self.name = name

    def setname(self,name):
        self.name = name

class foo(bar):
    
    registered = []

    def __init__(self,val,name):
        self.fval = val
        self.register(self)
        bar.__init__(self,name)

    def inc(self):
        self.fval += 1

    def msg(self,*varargs):
        txt = ''
        for arg in varargs:
            txt += str(arg)
            txt += ","
        return txt + self.name + " says:"+str(self.fval)

    @staticmethod
    def register(f):
        foo.registered.append(f)

    @staticmethod
    def printregistered():
        for r in foo.registered:
            print r.msg()

a = foo(10,'a')
a.setname('aaa')
b = foo(20,'b')
c = foo(30,'c')

a.inc()
a.inc()
c.inc()

print a.msg()
print b.msg()
print c.msg(2,3,4)

print "---"

foo.printregistered()

########NEW FILE########
__FILENAME__ = oo_inherit2
def show(o):
    """
    This tests that the proper method is called.
    """
    o.msg()

def show2(o):
    """
    This tests oo inheritance.
    """
    o.print_msg()

class A(object):

    def msg(self):
        print "A.msg()"

    def print_msg(self):
        self.msg()

class B(A):

    def msg(self):
        print "B.msg()"


a = A()
show(a)
show2(a)
b = B()
show(b)
show2(b)

########NEW FILE########
__FILENAME__ = oo_inherit3
def show(o):
    """
    This tests that the proper method is called.
    """
    o.msg()

def show2(o):
    """
    This tests oo inheritance.
    """
    o.print_msg()

class A(object):

    def __init__(self):
        self._a = 5

    def msg(self):
        print "A.msg()"

    def print_msg(self):
        self.msg()
        print self._a

class B(A):

    def msg(self):
        print "B.msg()"


a = A()
show(a)
show2(a)
b = B()
show(b)
show2(b)

########NEW FILE########
__FILENAME__ = oo_inherit4
class A(object):

    def __init__(self):
        print self.x

class B(A):

    def __init__(self):
        self.x = 42
        super(B, self).__init__()

b = B()


########NEW FILE########
__FILENAME__ = oo_inherit5
class Foo(object):

    def __init__(self):
        print self.__class__.__name__

class Bar(Foo):

    pass

Foo()
Bar()

########NEW FILE########
__FILENAME__ = oo_inherit_simple

class bar(object):

    def __init__(self,name):
        self.name = name

    def setname(self,name):
        self.name = name

class foo(bar):
    
    registered = []

    def __init__(self,val,name):
        self.fval = val
        self.register(self)
        self.name = name

    def inc(self):
        self.fval += 1

    def msg(self, a=None, b=None, c=None):
        txt = ''
        varargs = a, b, c
        for arg in varargs:
            if arg is None:
                continue
            txt += str(arg)
            txt += ","
        return txt + self.name + " says:"+str(self.fval)

    @staticmethod
    def register(f):
        foo.registered.append(f)

    @staticmethod
    def printregistered():
        for r in foo.registered:
            print r.msg()

a = foo(10,'a')
a.setname('aaa')
b = foo(20,'b')
c = foo(30,'c')

a.inc()
a.inc()
c.inc()

print a.msg()
print b.msg()
print c.msg(2,3,4)

print "---"

foo.printregistered()

########NEW FILE########
__FILENAME__ = oo_inherit_simple2

class bar(object):

    def __init__(self,name):
        self.name = name

    def setname(self,name):
        self.name = name

class foo(bar):
    
    registered = []

    def __init__(self,val,name):
        self.fval = val
        self.register(self)
        bar.__init__(self,name)

    def inc(self):
        self.fval += 1

    def msg(self, a=None, b=None, c=None):
        txt = ''
        varargs = a, b, c
        for arg in varargs:
            if arg is None:
                continue
            txt += str(arg)
            txt += ","
        return txt + self.name + " says:"+str(self.fval)

    @staticmethod
    def register(f):
        foo.registered.append(f)

    @staticmethod
    def printregistered():
        for r in foo.registered:
            print r.msg()

a = foo(10,'a')
a.setname('aaa')
b = foo(20,'b')
c = foo(30,'c')

a.inc()
a.inc()
c.inc()

print a.msg()
print b.msg()
print c.msg(2,3,4)

print "---"

foo.printregistered()

########NEW FILE########
__FILENAME__ = oo_return_class

print "Defining Foo"

class Foo(object):

    @staticmethod
    def test():
        print 42

print "Defining Bar"

class Bar(object):

    def __init__(self, cls):
        self.cls = cls

    def test(self):
        self.cls.test()
        return self.cls

print "Creating Bar"

b = Bar(Foo)

print "Testing Bar"

print b.test() == Foo

# f = Foo()
# f.test()
# print f.__class__
# print Foo

########NEW FILE########
__FILENAME__ = oo_simple_super
class superclass(object):

    def test1(self):
        print "superclass"

class childclass(superclass):

    def test1(self):
        print "child"

    def test2(self):
        super(childclass, self).test1()

    def test3(self):
        self.test1()
        super(childclass, self).test1()


x = childclass()

x.test1()

x.test2()

x.test3()


########NEW FILE########
__FILENAME__ = oo_static_inherit


class a1(object):
    
    @staticmethod
    def msg(val):
        print "a1 static method msg says:"+str(val)

class a2(a1):
    pass

a = a2()

a.msg("hello")
a2.msg("world")

########NEW FILE########
__FILENAME__ = oo_static_inherit2
class Foo(object):

    x = 42

    def foo(self, a):
        print self.x, a

    @staticmethod
    def bar(a):
        print a

f = Foo()

f.foo(10)
Foo.foo(f, 10)

f.bar(20)
Foo.bar(20)

########NEW FILE########
__FILENAME__ = oo_super
class A(object):
    def met(self):
        print 'A.met'
class B(A):
    def met(self):
        print 'B.met'
        super(B,self).met( )
class C(A):
    def met(self):
        print 'C.met'
        super(C,self).met( )
class D(B,C):
    def met(self):
        print 'D.met'
        super(D,self).met( )

D().met()

########NEW FILE########
__FILENAME__ = patching
class Foo(object):

    var = "Foo"

    def bar():
        return "Bar"

f = Foo()
Foo.bar = lambda self: self.var + "Bar"

print f.bar()

########NEW FILE########
__FILENAME__ = super


class baseklass(object):

    def __init__(self,bval):
        self.bval = bval

    def describe(self,arg):
        print "baseklass.describe:"+self.bval+":"+str(arg)

    def describe2(self,**kwargs):
        print "baseklass.describe2:"+self.bval+":"+kwargs['string']

class klass(baseklass):
    
    def __init__(self,val,bval):
        baseklass.__init__(self,bval)
        self.val = val

    def describe(self):
        super(klass,self).describe(10)
        super(klass,self).describe2(string='somestring')
        print "klass.describe:"+self.val

k = klass("world","hello")
k.describe()

########NEW FILE########
__FILENAME__ = convert_tabs_spaces
from glob import glob
files = glob("*.py")
for file in files:
    print "Converting ", file
    f = open(file).read()
    f = f.replace("\t", " "*4)
    open(file, "w").write(f)

########NEW FILE########
__FILENAME__ = del_dict

mydict = {}

mydict["abc"] = "def"
mydict["def"] = "abc"
mydict["xyz"] = "rst"

print mydict["abc"]
print mydict["def"]
print mydict["xyz"]

del mydict["def"]

if "abc" in mydict:
    print "abc in mydict"
else:
    print "abc not in mydict"

if "def" in mydict:
    print "def in mydict"
else:
    print "def not in mydict"

if "xyz" in mydict:
    print "xyz in mydict"
else:
    print "xyz not in mydict"

########NEW FILE########
__FILENAME__ = dictionary-get
d = dict(foo = "foo")

print "starting"
print d.get("foo")
print d.get("bar", "bar")
print d.get("foo", "bar")

########NEW FILE########
__FILENAME__ = dictionary-kwargs

d = dict(a = 2, b = 3, c = 4, d = None)

for a, b in sorted(d.items()):
    print "%s -> %s" % (a, b)

########NEW FILE########
__FILENAME__ = dictionary

foo = { 'a':'b', 'c':'d' }

print foo['a']
print foo['c']

if 'a' in foo:
    print "a in foo"

########NEW FILE########
__FILENAME__ = dictionary2
def dict1():
    a = {1: 3, "s": 4}
    return len(a)

def dict2():
    a = {1: 3, "s": 4}
    b = a[1] + a["s"]
    return b

def dict3():
    a = {}
    a[1] = 3
    a["s"] = 4
    b = a[1] + a["s"]
    return b

print dict1()
print dict2()
print dict3()

########NEW FILE########
__FILENAME__ = dictionary3
x = dict()
x[1] = "1"
x["1"] = "2"

print x

y = dict(x)
y[True] = "true"
y[False] = "false"

print y

print y[1], y[0]

########NEW FILE########
__FILENAME__ = dictionary4
x = dict(foo = "foo")

print x

y = dict(x)

print y

########NEW FILE########
__FILENAME__ = dictionary5

d = dict(a = "a", b = "b")

print d

print list(d)

print dict(d)

print dict(dict(d))

print dict(tuple([tuple(["a", "a"]), tuple(["b", "b"])]))

########NEW FILE########
__FILENAME__ = dictionary_keytype
a = "b"
b = "a"
print {a: b}

########NEW FILE########
__FILENAME__ = keys


x = { 'foo':'bar','aaa':'bbb','xyz':'zyx','spam':'eggs' }

s = x.keys()
s.sort()
for k in s:
    print k + " -> " + x[k]

########NEW FILE########
__FILENAME__ = decorator
def mydecorator(x):

    def wrapped(self, a, b, c):
        out = x(self)
        return "(%s - %s, %s)" % (out, a+b, c)

    return wrapped

class myclass(object):
    def __init__(self,val):
        self.val = val

    @mydecorator
    def describe(self):
        return self.val

m = myclass("hello")
print m.describe(10, 5, "foo")

########NEW FILE########
__FILENAME__ = py_collision
a = 1
if a == 1:
    print "ok"
else:
    print "no"

py_builtins = 1
if py_builtins == 1:
    print "ok"
else:
    print "no"

for py_builtins in range(5):
    a += py_builtins

print a

########NEW FILE########
__FILENAME__ = break

x = 0

while True:
    x = x + 1
    print x
    if x > 10:
        break

########NEW FILE########
__FILENAME__ = continue

for x in xrange(0,20):
    if x > 10 and x < 17:
        continue
    print x

########NEW FILE########
__FILENAME__ = fordecomp

for (x,y,z) in [(1,2,3), (4,5,6), (7,8,9)]:
    print x, y, z



########NEW FILE########
__FILENAME__ = for_in
# iterating over a list
a = [1,2,3,4,5]
for x in a:
    print x

# iterating over a tuple
a = ('cats','dogs','squirrels')
for x in a:
    print x

# iterating over a dictionary
# sort order in python is undefined, so need to sort the results
# explictly before comparing output

a = {'a':1,'b':2,'c':3 }

keys = []
for x in a:
    keys.append(x)

keys.sort()
for k in keys:
    print k

# iterating over a string
a = 'defabc'
for x in a:
    print x


########NEW FILE########
__FILENAME__ = for_orelse

for x in range(5):
    print "iterating", x
else:
    print "finishing up 1 of 2"

for x in range(0):
    print "should not happen"
else:
    print "finishing up 2 of 2"

try:
    for x in range(5):
        print "iterating", x
        if x > 3:
            raise ValueError("too high")
    else:
        print "should not happen"
except:
    pass

########NEW FILE########
__FILENAME__ = for_tuples

L = [(1,2), (3,4), (5,6), (7,8)]

for x,y in L:
    print x, y*10

########NEW FILE########
__FILENAME__ = ifs
def ifs1(x):
    a = 1
    if x:
        a = a + 1
        a *= 2
    else:
        a = a - 1
        a *= 4
    return a

def ifs2(x):
    a = 1
    if x > 0:
        a = a + 1
        a *= 2
    else:
        a = a - 1
        a *= 4
    return a

def ifs3(x):
    a = 1
    if x > 0:
        if x > 10:
            a = 3
        else:
            a = 4
    a = 5
    return a

def ifs4(x):
    a = 1
    if x > 0:
        if x > 10:
            a = 3
        else:
            a = 4
    else:
        a = 5
    return a

print ifs1(True)
print ifs1(False)
print ifs2(1)
print ifs2(-1)
print ifs3(1)
print ifs3(20)
print ifs3(-1)
print ifs4(1)
print ifs4(20)
print ifs4(-1)

########NEW FILE########
__FILENAME__ = loops
def loop1(x):
    a = 0
    for i in range(x):
        x
        a += i
    return a

print loop1(1)
print loop1(2)
print loop1(3)
print loop1(4)
print loop1(5)
print loop1(6)
print loop1(7)

########NEW FILE########
__FILENAME__ = pass

x = 'hello'

if x != 'hello':
    print "1"
    pass
    print "2"
else:
    print "3"
    pass
    print "4"



########NEW FILE########
__FILENAME__ = while

x = 1
while x<10:
    print x
    x = x + 1

########NEW FILE########
__FILENAME__ = while_orelse

x = 5

def count():
    global x
    x -= 1
    return x+1

while count() > 0:
    print x

while count() > 0:
    print x
else:
    print "no iterations"

########NEW FILE########
__FILENAME__ = string_format_combined_simple
a = "well"
b = "seems to work"
c = "something else"
d = 10
f = 15

s = "%s: %d, %s: %d, %s: %d" % (a, d, b, f, c, d)
print s

########NEW FILE########
__FILENAME__ = string_format_d

a = 1.123456
b = 10
c = -30
d = 34
e = 123.456
f = 19892122

# form 0
s = "b=%d" % b
print s

# form 1
s = "b,c,d=%d+%d+%d" % (b,c,d)
print s

# form 2
s = "b=%(b)0d and c=%(c)d and d=%(d)d" % { 'b':b,'c':c,'d':d }
print s

# width,flags
s = "e=%020d e=%+d e=%20d e=%-20d (e=%- 20d)" % (e,e,e,e,e)
print s

########NEW FILE########
__FILENAME__ = string_format_d_simple

a = 1.123456
b = 10
c = -30
d = 34
e = 123.456
f = 19892122

# form 0
s = "b=%d" % b
print s

# form 1
s = "b,c,d=%d+%d+%d" % (b,c,d)
print s

# form 2
#s = "b=%(b)0d and c=%(c)d and d=%(d)d" % { 'b':b,'c':c,'d':d }
print s

# width,flags
#s = "e=%020d e=%+d e=%20d e=%-20d (e=%- 20d)" % (e,e,e,e,e)
print s

########NEW FILE########
__FILENAME__ = string_format_efg

a = 1.123456
b = 0.000000000324324
c = 18347894.2131
d = 0.0
e = -1324323.456
f = -0.000000000019892122

vars = [a,b,c,d,e,f]
codes = ['e','E','f','F','g','G']

fmts = ["a=%e","a=%10.5e","a=%+10.5e","a=%#e"]

for code in codes:
    for fmt in fmts:
        fmt = fmt.replace('e',code)
        for v in vars:
            print fmt + ":", fmt % v

########NEW FILE########
__FILENAME__ = string_format_f_simple
a = 1.123456
b = 10
c = -30
d = 34
e = 123.456789
f = 892122.129899

# form 0
s = "b=%f" % a
print s

# form 1
s = "b,c,d=%f+%f+%f" % (a, e, f)
print s

########NEW FILE########
__FILENAME__ = string_format_i

a = 1.123456
b = 10
c = -30
d = 34
e = 123.456
f = 19892122

# form 0
s = "b=%i" % b
print s

# form 1
s = "b,c,d=%i+%i+%i" % (b,c,d)
print s

# form 2
s = "b=%(b)i and c=%(c)i and d=%(d)i" % { 'b':b,'c':c,'d':d }
print s

# width,flags
s = "e=%020i e=%+i e=%20i e=%-20i (e=%- 20i)" % (e,e,e,e,e)
print s

########NEW FILE########
__FILENAME__ = string_format_o

vals = [0,10,-30,173247,123,19892122]
 
formats = ['%o','%020o', '%-20o', '%#o', '+%o', '+%#o']

for val in vals:
    for fmt in formats:
        print fmt+":", fmt % val

########NEW FILE########
__FILENAME__ = string_format_sfge
n = [10000000, 1000000, 100000, 10000, 1000, 100, 10, 1, 0.1, 0.12, 0.123, 0.1234, 0.00001, 0.000001, 0.0000001, 0.00000001, 0.000000001]

for i, x in enumerate(n):
    print "Number %d" % i
    print "%%s: %s" % x
    print "%%f: %f" % x
    print "%%g: %g" % x
    print "%%e: %e" % x

########NEW FILE########
__FILENAME__ = string_format_s_simple
a = "well"
b = "seems to work"
c = "something else"

# form 0
s = "b=%s" % a
print s

# form 1
s = "b,c,d=%s+%s+%s" % (a, b, c)
print s

########NEW FILE########
__FILENAME__ = string_format_u

a = 1.123456
b = 10
c = -30
d = 34
e = 123.456
f = 19892122

# form 0
s = "b=%u" % b
print s

# form 1
s = "b,c,d=%u+%u+%u" % (b,c,d)
print s

# form 2
s = "b=%(b)0u and c=%(c)u and d=%(d)u" % { 'b':b,'c':c,'d':d }
print s

# width,flags
s = "e=%020u e=%+u e=%20u e=%-20u (e=%- 20u)" % (e,e,e,e,e)
print s

########NEW FILE########
__FILENAME__ = string_format_x

vals = [0,10,-30,173247,123,19892122]
 
formats = ['%x','%020x','%X', '%020X', '%-20x', '%#x']

for val in vals:
    for fmt in formats:
        print fmt+":", fmt % val

########NEW FILE########
__FILENAME__ = and

tests = [(False,False),(False,True),(True,False),(True,True),(True,None),(False,None),(None,True),(None,False)]

def pp(v):
    if v == False:
        return "F"
    if v == True:
        return "T"
    return "?"

for t in tests:
    (b1,b2) = t
    print pp(b1) + " AND " + pp(b2) + "=" + pp(b1 and b2)

########NEW FILE########
__FILENAME__ = append

mylist = []
mylist.append('a')
mylist.append('b')
mylist.append('c')

print mylist[0]
print mylist[1]
print mylist[2]

########NEW FILE########
__FILENAME__ = aug
from __future__ import division

a = 244
b = 23

print a
a += 4
print a
a -= 2
print a
a <<= 4
print a
a >>= 2
print a
a |= 234324
print a
a &= 213213
print a
a ^= 2312
print a
a //= 324
print a
a += 1
print a
a /= 2
print a

print b
b **= 3
print b

########NEW FILE########
__FILENAME__ = bitand

x = 32424
y = 1437
z = x & y
print z

########NEW FILE########
__FILENAME__ = bitor

x = 123215
y = 3423
z = x | y
print z

########NEW FILE########
__FILENAME__ = bitxor
x = 32213
y = 98743
z = x ^ y
print z

########NEW FILE########
__FILENAME__ = cmp

class A(object):

    def __cmp__(self, obj):
        print "A"
        return 1

class B(object):


    def __cmp__(self, obj):
        print "B"
        return -1

a = A()
b = B()

print a == b
print b == a


########NEW FILE########
__FILENAME__ = divfloor

x = 23423
y = 213
z = x // y

print z

########NEW FILE########
__FILENAME__ = expr
from __future__ import division

a = 244
b = 23

print a
print a + 4
print a - 2
print a << 4
print a >> 2
print a | 234324
print a & 213213
print a ^ 2312
print a // 324
print a / 2
print b ** 3

########NEW FILE########
__FILENAME__ = float

a = '123.456'
b = float(a)
print b

########NEW FILE########
__FILENAME__ = floatdiv

from __future__ import division

a = 3
b = 2
c = a / b
print c

########NEW FILE########
__FILENAME__ = gtge

x = 123
y = 233
y2 = 233
z = 892

if x > y:
    print "x > y - incorrect"
else:
    print "not x > y - correct"

if y >= y2:
    print "y >= y2 - correct"
else:
    print "not y >= y2 - incorrect"

if z > x:
    print "z > x - correct"
else:
    print "not z > x - incorrect"

if y >= z:
    print "y >= z - incorrect"
else:
    print "not y >= x - correct"


########NEW FILE########
__FILENAME__ = in


a = { 1:'aaa', 'b':2 }

if 2 in a:
    print "2 in a - incorrect"

if 'b' in a:
    print "b in a - correct"

if 1 in a:
    print "1 in a - correct"

if 3 not in a:
    print "3 not in a - correct"

if 'x' not in a:
    print "x not in a - correct"

########NEW FILE########
__FILENAME__ = int

x = '123'
y = int(x)
print y

########NEW FILE########
__FILENAME__ = isinstance

class Spam(object):

    def __init__(self,value):
        self.value = value

class Eggs(object):

    def __init__(self,value):
        self.value = value

s = Spam(1)
e = Eggs(2)

if isinstance(s,Spam):
    print "s is Spam - correct"

if isinstance(s,Eggs):
    print "s is Eggs - incorrect"

if isinstance(e,Spam):
    print "e is Spam - incorrect"

if isinstance(e,Eggs):
    print "e is Eggs - correct"


########NEW FILE########
__FILENAME__ = len

mylist = [1,2,3]

print len(mylist)

########NEW FILE########
__FILENAME__ = lshift

x = 10
y = x << 3
x <<= 3
print x,y

########NEW FILE########
__FILENAME__ = ltle

x = 123
y = 233
y2 = 233
z = 892

if x < y:
    print "x < y - correct"
else:
    print "not x < y - incorrect"

if y <= y2:
    print "y <= y2 - correct"
else:
    print "not y <= y2 - incorrect"

if z < x:
    print "z < x - incorrect"
else:
    print "not z < x - correct"

if y <= z:
    print "y <= z - correct"
else:
    print "not y <= x - incorrect"


########NEW FILE########
__FILENAME__ = ne


for (x,y) in [(1,2),('aaa','bbb'),(4,4),('a','a')]:
    if x <> y:
        print str(x)+" <> "+str(y)
    else:
        print "not: " + str(x)+" <> "+str(y)



########NEW FILE########
__FILENAME__ = nested_functions
def foo(x):

    def bar(x):

        def quux(x):
            return x + 1

        return quux(x) + 10

    return bar(x) + 100

print foo(0)



class Stuff(object):

    def foo(self, x):

        def bar(x):

            def quux(x):
                return x + 1

            return quux(x) + 10

        return bar(x) + 100

s = Stuff()
print s.foo(0)

########NEW FILE########
__FILENAME__ = or

tests = [(False,False),(False,True),(True,False),(True,True),(True,None),(False,None),(None,True),(None,False)]

def pp(v):
    if v == False:
        return "F"
    if v == True:
        return "T"
    return "?"

for t in tests:
    (b1,b2) = t
    print pp(b1) + " OR " + pp(b2) + "=" + pp(b1 or b2)

########NEW FILE########
__FILENAME__ = pop

a = [1,2,3,4]

print a.pop()


########NEW FILE########
__FILENAME__ = rshift

x = 345
y = x >> 7
x >>= 7
print x,y

########NEW FILE########
__FILENAME__ = sort

l = [3,2,1]

l.sort()

print l[0]
print l[1]
print l[2]

########NEW FILE########
__FILENAME__ = sort23

def getkey(x):
    if x < 5:
        return x + 10
    else:
        return x

def revcmp(a,b):
    if b<a:
        return -1
    if b==a:
        return 0
    return 1

l = [4,7,2,3,8,1,3]

l.sort(revcmp,getkey)

print l[0]
print l[1]
print l[2]

print "---"

l.sort(revcmp,getkey,True)

print l[0]
print l[1]
print l[2]


########NEW FILE########
__FILENAME__ = sort_cmp

def revcmp(a,b):
    if b<a:
        return -1
    if b==a:
        return 0
    return 1

l = [4,7,2,3,8,1,3]

l.sort(revcmp)

print l[0]
print l[1]
print l[2]

########NEW FILE########
__FILENAME__ = str

a = 1
b = str(a)
c = 'x: ' + b
print a
print b
print c

########NEW FILE########
__FILENAME__ = ubitcomp

b = (~1 & 0xFFFF)
print b

########NEW FILE########
__FILENAME__ = uminus

x = -7623
print x

########NEW FILE########
__FILENAME__ = uplus

x = +7623
print x

########NEW FILE########
__FILENAME__ = generator

class generator:

    class iterator:
        def __init__(self,parent):
            self.parent = parent
            self.value = parent.min

        def next(self):
            val = self.value
            if val > self.parent.max:
                raise StopIteration
            self.value += 1
            return val

    def __init__(self,min,max):
        self.min = min
        self.max = max

    def __iter__(self):
        return self.iterator(self)

g = generator(5,10)
for v in g:
    print v

########NEW FILE########
__FILENAME__ = xmlwriter

class StringWriter(object):

    def __init__(self):
        self.contents = ''

    def write(self,text):
        self.contents += text

    def getContents(self):
        return self.contents

class XmlWriter(object):

    class Node(object):

        def __init__(self):
            pass

    class TextNode(Node):
    
        def __init__(self,text):
            self.text = text

        def write(self,writer,indent):
            writer.write(self.text)

    class Element(Node):
    
        def __init__(self,tag):
            self.tag = tag
            self.children = []
            self.attributes = {}
            self.hastext = False

        def addElement(self,tag):
            child = XmlWriter.Element(tag)
            self.children.append(child)
            return child

        def addTextNode(self,text):
            child = XmlWriter.TextNode(text)
            self.children.append(child)
            self.hastext = True
            return child

        def addAttribute(self,name,value):
            self.attributes[name] = value

        def write(self,writer,indent):
            if indent > 0:
                XmlWriter.indent(writer,indent)
            writer.write("<"+self.tag)
            for k in self.attributes:
                writer.write(" "+k+'="'+self.attributes[k]+'"')
            if len(self.children) == 0:
                writer.write(" />")
                return
            writer.write(">")
            for c in self.children:
                c.write(writer,indent+1)
            if not self.hastext:
                XmlWriter.indent(writer,indent)
            writer.write("</"+self.tag+">")

    @staticmethod
    def indent(writer,indent):
        writer.write("\n")
        for x in xrange(0,indent):
            writer.write("  ")

    def createRoot(self,tag):
        self.root = self.Element(tag)
        return self.root

    def write(self,writer):
        self.root.write(writer,0)
        
        
if __name__ == '__main__':
    w = XmlWriter()
    r = w.createRoot("foo")
    r1 = r.addElement("r1")
    r1.addAttribute("spam","eggs")
    r2 = r1.addElement("r2")
    r2.addAttribute("eggs","spam")
    r2.addTextNode("This is some text")
    s = StringWriter()
    w.write(s)
    print s.getContents()


########NEW FILE########
__FILENAME__ = assign_slice

a = [1,2,3,4,5,6,7]

a[4:6] = ['a','b']

def show(x):
    print "----"
    for x in a:
        print x

show(a)


a[2:4] = ['z']

show(a)

a[0:2] = ['abc','def','abc','def']

show(a)

########NEW FILE########
__FILENAME__ = del_list

mylist = [1,2,3,4,5]

del mylist[3]

for x in xrange(0,len(mylist)):
    print mylist[x]

########NEW FILE########
__FILENAME__ = del_slice

mylist = [1,2,3,4,5]

del mylist[1:3]

for x in xrange(0,len(mylist)):
    print mylist[x]

########NEW FILE########
__FILENAME__ = extend

list1 = [1,2,'f',44]
list2 = ['a',99,77]

list3 = list1[:]
list3.extend(list2)

for item in list3:
    print item

########NEW FILE########
__FILENAME__ = filter

l = [1,2,3,4,5,6,7,8,8]

l2 = filter(lambda x:x>4,l)

for v in l2:
    print v



########NEW FILE########
__FILENAME__ = in


l = ['a','b','c']

def intest(item,list):
    if item in list:
        print str(item) + ' is in list'
    else:
        print str(item) + ' is not in list'


intest('a',l)
intest('b',l)
intest(99,l)
intest(0,l)
intest('z',l)
intest('c',l)



########NEW FILE########
__FILENAME__ = index-boolean

x = ["a", "b", "c", "d"]

print x[0]
print x[1]
print x[False]
print x[True]

x[False] = x[True]

print x

########NEW FILE########
__FILENAME__ = insert
a = []
a.insert(0, 1)
print a
a.insert(0, 2)
print a
a.insert(0, 3)
print a
a.insert(1, 4)
print a
a.insert(2, 5)
print a
a.insert(5, 6)
print a

########NEW FILE########
__FILENAME__ = list

x = [1,2,3,'a','b','c']
y = x[2:4]
print x[0]
print x[3]
print y[0]
print y[1]

########NEW FILE########
__FILENAME__ = list2
def list1(n):
    a = []
    a.append(1)
    a.append(2)
    a.append(3)
    a.append(n)
    return a[0] + a[1] + a[2] + a[3]

def list2():
    a = list(range(5))
    return str(a)

def list3():
    a = list(range(5))
    a[0] = 5
    a[4] = 0
    return str(a)

def list4():
    a = [8, 9, 10, 11, 12, 13, 14]
    return a[2:4]

def list5():
    a = [8, 9, 10, 11, 12, 13, 14]
    return a[:4]

def list6():
    a = [8, 9, 10, 11, 12, 13, 14]
    return a[1:6:2]

def list7():
    a = [8, 9, 10, 11, 12, 13, 14]
    return a[:]

def list8():
    a = [8, 9, 10, 11, 12, 13, 14]
    return a[4:]

print list1(4)
print list1(5)
print list2()
print list3()
print list4()
print list5()
print list6()
print list7()
print list8()

########NEW FILE########
__FILENAME__ = listcomp-with-ifs
print [x for x in range(10)]
print [x for x in range(10) if x % 2 == 0]
print [x for x in range(10) if x % 2 == 0 if x < 7]

print [(x, x+1) for x in range(10)]

L = ["fii", "fi", "foo", "fum", "bar", "boo"]

print [x for x in L if x.startswith('fi') or x == "bar"]

########NEW FILE########
__FILENAME__ = listcomp2

for (x,y,z) in [(x,y,z) for x in xrange(0,3) for y in xrange(0,4) for z in xrange(0,5)]:
    if x < y < z: 
        print x,y,z,"x<y<z"



########NEW FILE########
__FILENAME__ = listcomp3
print [(x + y) for x,y in [(1,2), (3,4), (10, 20), (30, 40), (100, 100)]]

########NEW FILE########
__FILENAME__ = map

def foo(x):
    return x*x

y = [1,2,3,4,5]

z = map(foo,y)
for val in z:
    print val

########NEW FILE########
__FILENAME__ = max

l = [4,7,3,4,2,1]

v = max(l)

print v

########NEW FILE########
__FILENAME__ = min

l = [4,7,3,4,2,1]

v = min(l)

print v

########NEW FILE########
__FILENAME__ = reduce

def foo(x,y):
    return x*y

y = [1,2,3,4,5]

z = reduce(foo,y,10)
print z
z = reduce(foo,y)
print z

########NEW FILE########
__FILENAME__ = reverse
a = [1, 2, 3, 4]
a.reverse()
print a

########NEW FILE########
__FILENAME__ = sort

class X(object):

    def __init__(self, x = 20):
        self.x = x

    def __repr__(self):
        return "%s" % self.x

O = [X("x"), X("c"), X("y"), X("A"), X("B"), X("Z"), X("D")]
print O

L = O[:]
L.sort(key = lambda x: x.x)
print L

L = O[:]
L.sort(cmp = lambda a, b: cmp(a.x, b.x))
print L

L = O[:]
L.sort(cmp = lambda a, b: -cmp(b.x, a.x))
print L

L = O[:]
L.sort(key = lambda x: x.x.lower())
print L

########NEW FILE########
__FILENAME__ = subclass
class A(list):

    def my_append(self, a):
        self.append(a)

a = A()
print a
a.append(5)
print a
a.my_append(6)
print a
a.remove(5)
print a

########NEW FILE########
__FILENAME__ = subclass2
class List(object):

    def __init__(self, l=[]):
        self._list = list(l)

    def append(self, x):
        self._list.append(x)

    def remove(self, x):
        self._list.remove(x)

    def __str__(self):
        return str(self._list)

class A(List):

    def my_append(self, a):
        self.append(a)

a = A()
print a
a.append(5)
print a
a.append(6)
print a
a.remove(5)
print a

########NEW FILE########
__FILENAME__ = subclass3
class List(object):

    def __init__(self, l=[]):
        self._list = list(l)

    def append(self, x):
        self._list.append(x)

    def remove(self, x):
        self._list.remove(x)

    def __str__(self):
        return str(self._list)

class Layer(List):
    pass

l1 = Layer()
l1.append(1)
l1.append(2)
l2 = list()
l2.append(3)
l2.append(4)
print l1
print l2

########NEW FILE########
__FILENAME__ = sum

s = [1,2,3,4,5]
t = sum(s)
u = sum([x*x for x in s])
print t,u

########NEW FILE########
__FILENAME__ = sum2
s = [1,2,3,4,5]
print sum(s)

print sum([1, 8, 11])

print sum((1, 8, 11))

########NEW FILE########
__FILENAME__ = xrange

xr = xrange(20,40)

for x in xr:
    print x

########NEW FILE########
__FILENAME__ = zip


l1 = [1,2,3,4,5]
l2 = [5,4,3,2,1]
l3 = [4,4,4,4]

l4 = zip(l1,l2,l3)

for item in l4:
    print "---"
    for val in item:
        print val

########NEW FILE########
__FILENAME__ = classname

from modules.moda import ModA

m = ModA('hello')
m.describe()

mc = m.clone()
mc.describe()

########NEW FILE########
__FILENAME__ = from_import

from imported.modulea import modulea_fn
from imported.moduleb import moduleb_fn as modb_fn
from imported.modulec import *

modulea_fn()
modb_fn()
foo()

########NEW FILE########
__FILENAME__ = import

from imported.modulea import *
import imported.moduleb

modulea_fn()
imported.moduleb.moduleb_fn()

ma = modulea_class()
print ma.msg(1)

mb = imported.moduleb.moduleb_class()
print mb.msg(2)

########NEW FILE########
__FILENAME__ = alias_classes

class spam:

    def __init__(self):
        self.msgtxt = "this is spam"

    def msg(self):
        print self.msgtxt

if __name__ == '__main__':
    s = spam()
    s.msg()

########NEW FILE########
__FILENAME__ = alias_fns

def foo():
    print "this is foo"



########NEW FILE########
__FILENAME__ = modulea

def modulea_fn():

    print "import_modulea.modulea_fn()"

class modulea_class(object):

    def __init__(self):
        pass

    def msg(self,val):
        return "modulea_class:"+str(val)

########NEW FILE########
__FILENAME__ = moduleb

def foo():
    print "foo"

def moduleb_fn():
    print "import_moduleb.moduleb_fn()"

class moduleb_class(object):
    
    def __init__(self):
        pass

    def msg(self,val):
        return "moduleb_class:"+str(val)

########NEW FILE########
__FILENAME__ = modulec

import submodules.submodulea

def foo():
    print "imported.modulec.foo()"
    submodules.submodulea.foo()

########NEW FILE########
__FILENAME__ = moduled

import imported.modulea

def moduled_fn():
    print "import_moduled.moduled_fn()"
    print "calling module a now..."
    imported.modulea.modulea_fn()

########NEW FILE########
__FILENAME__ = submodulea

def foo():
    print "imported.modules.submodules.modulea.foo()"

########NEW FILE########
__FILENAME__ = import_alias

from imported.alias_fns import foo as bar
from imported.alias_classes import spam as eggs

# call imported function
bar()

# call imported class
e = eggs()
e.msg()



########NEW FILE########
__FILENAME__ = import_class


import modules.klasses

k = modules.klasses.klass()

k.sayhello()
modules.klasses.klass.sayhello()


########NEW FILE########
__FILENAME__ = import_diamond

import modules.diamond1
import modules.diamond2

modules.diamond1.run()
modules.diamond2.run()


########NEW FILE########
__FILENAME__ = import_global

import imported.moduleb
import imported.moduled

imported.moduleb.moduleb_fn()
imported.moduled.moduled_fn()

########NEW FILE########
__FILENAME__ = import_multi

import imported.modulec

def foo():
    print "foo"
    imported.modulec.foo()

foo()

########NEW FILE########
__FILENAME__ = diamond1

import submodules.diamondbase

def run():
    print "calling diamond1.run()"
    submodules.diamondbase.run()

########NEW FILE########
__FILENAME__ = diamond2

import submodules.diamondbase

def run():
    print "Calling diamond2.run()"
    submodules.diamondbase.run()

########NEW FILE########
__FILENAME__ = klasses

class baseklass(object):

    @staticmethod
    def sayhello():
        print "baseklass says hello"

class klass(baseklass):

    pass


if __name__ == '__main__':

    k = klass()
    k.sayhello()
    klass.sayhello()
    baseklass.sayhello()

########NEW FILE########
__FILENAME__ = moda


class ModA:

    def __init__(self,val):
        self.val = val

    def clone(self):
        return ModA(self.val)

    def describe(self):
        print self.val

########NEW FILE########
__FILENAME__ = module_name

import submodules.module_name

print "2nd level module __name__:"+__name__

########NEW FILE########
__FILENAME__ = diamondbase

counter = 0

def run():
    global counter
    counter += 1
    print "diamondbase called " + str(counter) + " time(s)"

########NEW FILE########
__FILENAME__ = module_name

print "3rd level module __name__:"+__name__

########NEW FILE########
__FILENAME__ = module_name

import modules.module_name

print "1st level module __name__:"+__name__

########NEW FILE########
__FILENAME__ = rng

from mtrandom import *

def float2str(v,dp):
    s = str(v)
    dotpos = s.find(".")
    if dotpos >= 0:
        return s[:dotpos+dp+1]
    return s

class RNG:
    def __init__(self):
        init = [0x123, 0x234, 0x345, 0x456]
        self.r = MersenneTwister()
        self.r.init_by_array(init,4)

    def next(self):
        return self.r.genrand_res53()

if __name__ == "__main__":
    r = RNG()
    print float2str(r.next(),9)
    print float2str(r.next(),9)
    print float2str(r.next(),9)


########NEW FILE########
__FILENAME__ = closure

def factory(x):

    def fn():
        return x
    
    return fn

a1 = factory("foo")
a2 = factory("bar")
print a1()
print a2()

########NEW FILE########
__FILENAME__ = del_global

x = 1

def foo():
    global x
    del x

print x

foo()

try:
    print x
except:
    print "x is gone"

########NEW FILE########
__FILENAME__ = del_local

x = "ABC"

print x

del x

try:
    print x
except:
    print "x is gone"

########NEW FILE########
__FILENAME__ = embedding
"""pyjaco-verbatim:
function foo(x) {
    print(x);
}
"""

"""pyjaco-skip-begin"""
def foo(x):
    print x
"""pyjaco-skip-end"""

foo('bar')

########NEW FILE########
__FILENAME__ = js-name-collision

class Foo(object):

    default = 42

    def test1(self, default):
        print default

    def test2(self, default = 10):
        print default

print Foo.default
print Foo().test1(default = 21)
print Foo().test2(default = 22)

########NEW FILE########
__FILENAME__ = scope

x = 12

def loopy():
    for x in xrange(0,8):
        print x

loopy()
print x

########NEW FILE########
__FILENAME__ = sideeffect
g = {'i': 0}

def se():
    g["i"] = g["i"] + 1
    return g["i"]

print se() and se() and se()
print g["i"]
print se() or se() or se()
print g["i"]

print se() and se() and se()
print g["i"]
print se() or se() or se()
print g["i"]

if se() and se():
    print "Quite so", se()

if se():
    print "Neat"

def foo():
    if se() and se():
        print "Quite so", se()

    if se():
        print "Neat", se()

    x = se() and se()

x = se() and se()

########NEW FILE########
__FILENAME__ = vars


x = 1
y = 1

def foo():
    x = 3
    x = x + 1
    print x

def bar():
    global y
    y = 3
    y = y + 1
    print y

foo()
bar()
print x
print y

########NEW FILE########
__FILENAME__ = vars2
x = 1
y = 2

def f1():
    x, y = 3, 4
    print [x, y]

def f2():
    global y
    x, y = 5, 6
    print [x, y]

def f3():
    global x
    x, y = 7, 8
    print [x, y]

def f4():
    global x, y
    x, y = 9, 10
    print [x, y]

print [x, y]
f1()
print [x, y]
f2()
print [x, y]
f3()
print [x, y]
f4()
print [x, y]

########NEW FILE########
__FILENAME__ = augassign

a = 1
a += 1
print a
a += 3
print a
a -= 2
print a

########NEW FILE########
__FILENAME__ = augassign2
def f1(x):
    return x

def f2(x):
    return x + 5

def f3(x):
    a = x + 1
    return a - 5

def f3b(x):
    a = x + 1
    a -= 5
    return a

def f3c(x):
    a = float(x) + 1
    a /= 5
    return a

def f3d(x):
    a = x + 1
    a *= 5
    return a

def f3e(x):
    a = x + 1
    a += 5
    return a

def f4(x):
    if x:
        return 5
    else:
        return 6

def f5(x):
    a = 1
    if x:
        a = a + 1
    else:
        a = a - 1
    return a

print f1(3)
print f2(3)
print f3(3)
print f3b(3)
print f3c(3)
print f3d(3)
print f3e(3)
print f4(True)
print f4(False)
print f5(True)
print f5(False)

########NEW FILE########
__FILENAME__ = binaryops

x = 1
y = 2
z = 3

print 10 % z
print y*x
print y-z
print y+x+z
print 10 / 2
print 10 ** 2

########NEW FILE########
__FILENAME__ = float2int

for f in [123.456,1.1,-0.00045,-1.45,1.5,1022423.22]:
    i = int(f)
    print i

########NEW FILE########
__FILENAME__ = valueerror


s1 = "123"
s2 = "123.456"

try:
    f1 = int(s1)
    print str(f1)

    f2 = int(s2)
    print str(f2)
except ValueError, ex:
    print "conversion error"
except:
    print "unknown error"

########NEW FILE########
__FILENAME__ = zerodiv

n = [5, 5.0, 2, 0, 0.1]

for x in n:
    for y in n:
        try:
            print "%s / %s = %s" % (x, y, x / y)
        except ZeroDivisionError:
            print "Oops, divided by 0: (%d / %d)" % (x, y)
        print "%s + %s = %.5f" % (x, y, x + y)
        print "%s - %s = %.5f" % (x, y, x - y)
        print "%s * %s = %.5f" % (x, y, x * y)
        print "%s ** %s = %.5f" % (x, y, x ** y)

print "Finished"


########NEW FILE########
__FILENAME__ = addsubmul

elm = [True, False, "foo", 10, 0, -1, 2.1, ("x", "y"), ["x", "y"], None, dict(x = "y")]

for x in elm:
    for y in elm:
        print "types: %s, %s" % (x.__class__.__name__, y.__class__.__name__)
        try:
            print "%s + %s = %s" % (x, y, x + y)
        except:
            print "no __add__"

        try:
            print "%s - %s = %s" % (x, y, x - y)
        except:
            print "no __sub__"

        try:
            print "%s * %s = %s" % (x, y, x * y)
        except:
            print "no __mul__"

########NEW FILE########
__FILENAME__ = cmp_values

elm = [True, False, "foo", 100, 0, -1, 2.1, ("x", "y"), ["x", "y"], None]

for x in elm:
    for y in elm:
        print "%s > %s = %s" % (x, y, x > y)
        print "%s < %s = %s" % (x, y, x < y)
        print "%s == %s = %s" % (x, y, x == y)
        print "%s cmp %s = %s" % (x, y, cmp(x, y))
        print "  -> %s -- %s => %s" % (x.__class__.__name__, y.__class__.__name__, cmp(x.__class__.__name__, y.__class__.__name__))

########NEW FILE########
__FILENAME__ = comparison

print 1 < 2
print 2 > 1
print 1 <= 1
print 2 >= 2
print 1 == 1
print True and True
print True or False
print False or True
print not False
print not False and not False
print not False or False

########NEW FILE########
__FILENAME__ = conditional-results
print [] or 2
print 2 and []

########NEW FILE########
__FILENAME__ = number_cmp
elm = [0, 1, -1, 0.0, 1.0, -1.0]

for x in elm:
    for y in elm:
        print "%s > %s = %s" % (x, y, x > y)
        print "%s < %s = %s" % (x, y, x < y)
        print "%s == %s = %s" % (x, y, x == y)
        print "%s cmp %s = %s" % (x, y, cmp(x, y))

########NEW FILE########
__FILENAME__ = count

txt = "the quick brown fox jumped over the lazy dogthe"

c = txt.count("the")
print c
c = txt.count("the",0,-20)
print c
c = txt.count("the",3)
print c
c = txt.count("the",4,15)
print c
c = txt.count("the",1,len(txt))
print c
c = txt.count("the",4,len(txt)-1)
print c

########NEW FILE########
__FILENAME__ = find

s = "the quick brown fox"
i = s.find("quick")
print str(i)
i = s.find("dog")
print str(i)
i = s.find("the")
print str(i)

########NEW FILE########
__FILENAME__ = join
a = ["a", "b", "c"]
print "".join(a)
print " ".join(a)
print "x".join(a)
print "x ".join(a)

########NEW FILE########
__FILENAME__ = lstrip0


s1 = "\n\nabc\n\n\n"
s2 = "\t abc\n\t \n"
s3 = " abc "

for s in [s1,s2,s3]:
    print "original("+s+")"
    print "strip("+s.lstrip()+")"

########NEW FILE########
__FILENAME__ = lstrip1


s = "abcxyz"

print "original("+s+")"
print "strip("+s.lstrip("cba")+")"

########NEW FILE########
__FILENAME__ = obj_repr
print ("x", "y")
print ["x", "y"]
print "x"
print repr("x")
print "%r" % (("x", "y"),)
print "%r" % (["x", "y"],)
print "%s" % (("x", "y"),)
print "%s" % (["x", "y"],)

########NEW FILE########
__FILENAME__ = replace

txt = "the quick brown fox jumped over thethe lazy dog"

txt2 = txt.replace("the","a")

print txt
print txt2

print txt.replace("the", "a", 0)
print txt.replace("the", "a", 1)
print txt.replace("the", "a", 2)
print txt.replace("the", "a", 3)
print txt.replace("the", "a", 4)
print txt.replace("the", "a", 50)

########NEW FILE########
__FILENAME__ = rfind

s = "the quick brown quick the fox"
i = s.rfind("quick")
print str(i)
i = s.rfind("dog")
print str(i)
i = s.rfind("the")
print str(i)

########NEW FILE########
__FILENAME__ = rstrip0


s1 = "abc\n\n\n"
s2 = "abc\n\t \n"
s3 = "abc "

for s in [s1,s2,s3]:
    print "original("+s+")"
    print "strip("+s.rstrip()+")"

########NEW FILE########
__FILENAME__ = rstrip1


s = "abcxyz"

print "original("+s+")"
print "strip("+s.rstrip("yzx")+")"

########NEW FILE########
__FILENAME__ = split
s = "the     quick brown fox jumped over the lazy dog"

t = s.split(" ")
for v in t:
    print v

r = s.split("e")
for v in r:
    print v

x = s.split()
for v in x:
    print v

########NEW FILE########
__FILENAME__ = split2
x = str("a / b / c / d")

print x.split("/")
print x.split(" /")
print x.split(" / ")
print x.split(" / ", 0)
print x.split(" / ", 1)
print x.split(" / ", 2)

x = str("xxxxxxxxx")
print x.split("x", 0)
print x.split("x", 1)
print x.split("x", 2)
print x.split("x", 3)
print x.split("y")

########NEW FILE########
__FILENAME__ = splitlines

txt = """
aaa

bcfdss

sdsd
wqarwqr


werewr"""

lines = txt.splitlines()

for line in lines:
    print line

########NEW FILE########
__FILENAME__ = str-repr
el = [0, 0.0, True, False, [1, 2, 3], (1, 2, 3), (1, 2), (1,), (), ((1,),),
      dict(a = "b"), {'0': '1'}, {'0': 1}]

for e in el:
    print repr(e)
    print str(e)


########NEW FILE########
__FILENAME__ = str1
s1 = "some string"

s2 = "some 'x' string"

s3 = 'some "x" string'

s4 = "some \"x\" string"

s5 = """some "x" string"""

s6 = """some "x" string
and some other string too...
"""

if s2 == s3:
    print "ok1"
if s3 == s4:
    print "ok2"
if s3 == s5:
    print "ok3"
if s3 != s6:
    print "ok4"

########NEW FILE########
__FILENAME__ = strings_in_strings
print """"Hello World!" <- should 'mess' up '''thing'''?"""

# Test other strings:
print b"\\x00"
print u"\\u0000"

########NEW FILE########
__FILENAME__ = strip


s1 = "\n\nabc\n\n\n"
s2 = "\t abc\n\t \n"
s3 = " abc "

for s in [s1,s2,s3]:
    print "original("+s+")"
    print "strip("+s.strip()+")"

########NEW FILE########
__FILENAME__ = strip1


s = "yxabcxyz"

print "original("+s+")"
print "strip("+s.strip("yzx")+")"

########NEW FILE########
__FILENAME__ = ulcase


s = "aBcddEzUh"

print s
s = s.upper()
print s
s = s.lower()
print s

########NEW FILE########
__FILENAME__ = zipstring

s1 = "hello"
s2 = "world"
s3 = "abcd"

s4 = zip(s1,s2,s3)

for item in s4:
    print "----"
    for val in item:
        print val

########NEW FILE########
__FILENAME__ = test_compile_js
"""
This test only tests that Python code can be compiled using the pyjaco.

It doesn't test if the resulting javascript makes any sense.
"""

def is_on_the_left(c, a, b, pts_list):
   ax, ay = pts_list[a]
   bx, by = pts_list[b]
   cx, cy = pts_list[c]
   ux = float(bx - ax)
   uy = float(by - ay)
   vx = float(cx - ax)
   vy = float(cy - ay)
   return (ux*vy - uy*vx > 0)

def criterion(a, b, c, pts_list):
   ax, ay = pts_list[a]
   bx, by = pts_list[b]
   cx, cy = pts_list[c]
   ux = float(ax - cx)
   uy = float(ay - cy)
   vx = float(bx - cx)
   vy = float(by - cy)
   len_u = sqrt(ux*ux + uy*uy)
   len_v = sqrt(vx*vx + vy*vy)
   return (ux*vx + uy*vy)/(len_u*len_v)

def find_third_point(a, b, pts_list, edges):
    """
    Take a boundary edge (a,b), and in the list of points
    find a point 'c' that lies on the left of ab and maximizes
    the angle acb
    """
    found = 0
    minimum = exp(100)   #this is dirty
    c_index = -1
    pt_index = -1
    for c_point in pts_list:
        c_index += 1
        if c_index != a and c_index != b and is_on_the_left(c_index, a, b, pts_list):
            edge_intersects = \
                    edge_intersects_edges((a, c_index), pts_list, edges) or \
                    edge_intersects_edges((b, c_index), pts_list, edges)
            if not edge_intersects:
                crit = criterion(a, b, c_index, pts_list)
                if crit < minimum:
                    minimum = crit
                    pt_index = c_index
                    found = 1
    if found == 0:
        raise TriangulationError("ERROR: Optimal point not found in find_third_point().")
    return pt_index

def lies_inside(c, bdy_edges):
   for edge in bdy_edges:
       a,b = edge
       if c == a or c == b: return False
   return True

def is_boundary_edge(a, b, bdy_edges):
    """
    Checks whether edge (a, b) is in the list of boundary edges
    """
    for edge in bdy_edges:
        a0, b0 = edge
        if a == a0 and b == b0:
            return True
    return False

def triangulate_af(pts_list, bdy_edges):
    """
    Create a triangulation using the advancing front method.
    """
    # create empty list of elements
    elems = []
    bdy_edges = bdy_edges[:]
    # main loop
    while bdy_edges != []:
        # take the last item from the list of bdy edges (and remove it)
        a,b = bdy_edges.pop()
        c = find_third_point(a, b, pts_list, bdy_edges)
        elems.append((a,b,c))
        if is_boundary_edge(c, a, bdy_edges):
            bdy_edges.remove((c,a))
        else:
            bdy_edges.append((a,c))
        if is_boundary_edge(b, c, bdy_edges):
            bdy_edges.remove((b,c))
        else:
            bdy_edges.append((c,b))
    return elems

class TestClass(object):
    def __init__(self):
        alert('TestClass created')
        self.reset()

    def reset(self):
        self.value = 0

    def inc(self):
        alert(self.value)
        self.value += 1

class TestClass(object):
    count = 0
    def __init__(self):
        pass
    def next(self):
        self.count += 1
    def test(self):
        alert(self.count)

def onCountClick(event):
    window.testObj.next()
    window.testObj.test()

def helloWorld():
    window.testObj = TestClass.new()

    pushButton = YAHOO.widget.Button.new(
        {
            'label' : 'Hello, World!',
            'id' : 'pushButton',
            'container' : 'pushButtons'
        }
    )
    pushButton.on('click', onButtonClick)
    pushButton2 = YAHOO.widget.Button.new(
        {
            'label' : 'Hello, Dude!',
            'id' : 'pushButton2',
            'container' : 'pushButtons',
            'onclick' : {
                'fn' : onButtonClick,
                'obj' : 'Dude'
            }
        }
    )

    i = 1
    while i <= 3:
        YAHOO.widget.Button.new(
            {
                'label' : 'Hello ' + i + '!',
                'id' : 'pushButtonIter' + i,
                'container' : 'pushButtons',
                'onclick' : {
                    'fn' : onButtonClick,
                    'obj' : 'Person #' + i
                }
            }
        )
        i += 1

    YAHOO.widget.Button.new(
        {
            'label' : 'Count',
            'id' : 'pushButtonCount',
            'container' : 'pushButtons',
            'onclick' : {
                'fn' : onCountClick
            }
        }
    )

def onButtonClick(event, target='World'):
    if target == 'World':
        target = 'Big Blue World'
    alert('Hello, ' + target + '!')

def StartGoL():
    window.gol = GoL.new()

class GoL(object):
    def __init__(self):
        self.width = 75
        self.height = 75
        self.canvas = document.getElementById('canvas').getContext('2d')
        self.canvas.fillStyle = 'rgb(0, 0, 0)'
        self.grid = Array.new(self.width*self.height)
        for i in range(self.width*self.height):
            self.grid[i] = Math.random() > 0.5
        setInterval('window.gol.iter()', 250)
        self.draw()
    def get(self, x, y):
        return self.grid[((x + self.width) % self.width) + ((y + self.height) % self.height) * self.width]
    def iter(self):
        toDie = Array.new(0)
        toLive = Array.new(0)
        for x in range(0, self.width):
            for y in range(0, self.height):
                count = 0
                if self.get(x-1, y-1):
                    count += 1
                if self.get(x, y-1):
                    count += 1
                if self.get(x+1, y-1):
                    count += 1
                if self.get(x-1, y):
                    count += 1
                if self.get(x+1, y):
                    count += 1
                if self.get(x-1, y+1):
                    count += 1
                if self.get(x, y+1):
                    count += 1
                if self.get(x+1, y+1):
                    count += 1

                if self.get(x, y):
                    if count < 2:
                        toDie[toDie.length] = x + y*self.width
                    elif count > 3:
                        toDie[toDie.length] = x + y*self.width
                else:
                    if count == 3:
                        toLive[toLive.length] = x + y*self.width

        for i in range(toDie.length):
            self.grid[toDie[i]] = False
        for i in range(toLive.length):
            self.grid[toLive[i]] = True

        self.draw()
    def draw(self):
        i = 0
        for x in range(0, self.width*10, 10):
            for y in range(0, self.height*10, 10):
                if self.grid[i]:
                    self.canvas.fillRect(x, y, x+10, y+10)
                else:
                    self.canvas.clearRect(x, y, x+10, y+10)
                i += 1

########NEW FILE########
__FILENAME__ = tuple

tup = ('a','b',1,2,3)

print tup[0]
print tup[1]
print tup[2]
print tup[3]
print tup[4]

########NEW FILE########
__FILENAME__ = tuple2
def tuple1(x):
    t = (x, x+1, x+2)
    a, b, c = t
    return a+b+c

def tuple2(n):
    a = 0
    for i in (1, 2, n):
        a += i
    return a

def tuple3():
    a = (1, 3, 5, 4, 9, 1, 2, 3)
    return len(a)

def tuple4(n):
    a = (1, 3, 3, 4, 9, 1, 2, 3)
    return a.count(n)

def tuple5(n):
    a = (1, 3, 3, 4, 9, 1, 2, 3)
    return a.index(n)

def tuple6():
    a = (8, 9, 10, 11, 12, 13, 14)
    return a[2:4]

def tuple7():
    a = (8, 9, 10, 11, 12, 13, 14)
    return a[:4]

def tuple8():
    a = (8, 9, 10, 11, 12, 13, 14)
    return a[1:6:2]

def tuple9():
    a = (8, 9, 10, 11, 12, 13, 14)
    return a[:]

def tuple10():
    a = (8, 9, 10, 11, 12, 13, 14)
    return a[4:]


print tuple1(3)
print tuple2(3)
print tuple2(4)
print tuple3()
print tuple4(1)
print tuple4(3)
print tuple4(4)
print tuple4(5)
print tuple5(1)
print tuple5(4)
print tuple6()
print tuple7()
print tuple8()
print tuple9()
print tuple10()

########NEW FILE########
__FILENAME__ = tuple_cmp
tups = [(1, 1), (1, 2), (1, 3), (1, 2, 1), (1, 2, 2), (1, 2, 10)]

for x in tups:
    for y in tups:
        print "%s cmp %s = %s" % (x, y, cmp(x, y))
        print "%s > %s = %s" % (x, y, x > y)
        print "%s < %s = %s" % (x, y, x < y)

########NEW FILE########
__FILENAME__ = tuple_sort_index
x = [(1,2), (5,6), (7, 8), (9, 9)]
x.append((3,4))
x.append((1,8))
print x
x.sort()
print x
print x.index((1,2))
print x.index((3,4))
print x.index((5,6))

########NEW FILE########
__FILENAME__ = env_tests
"""\
Includes tests that check the setup for the tests.
If the library is compiled and if there is a js interpreter.
"""
import os
import sys
if sys.version_info < (2, 7):
    import unittest2 as unittest
else:
    import unittest
import tempfile
class EnviromentTest(unittest.TestCase):
    "Test case that makes sure that the environment is up and working"
    def reportProgres(self):
        """Should be overloaded by the test result class"""

    def stop(self):
        """Should be overloaded by the test result class"""

    def runTest(self):
        """The actual test goes here."""
        if os.system(
            "echo | js > %s" %
            os.path.join(
                tempfile.gettempdir(),
                tempfile.gettempprefix()
                )
            ):
            self.stop()
            raise RuntimeError("""Can't find the "js" command.""")
        self.reportProgres()
        if not os.path.exists("py-builtins.js"):
            self.stop()
            raise RuntimeError("""Can't find the "py-builtins.js" command.""")
        self.reportProgres()

    def __str__(self):
        return 'Looking for "js" and "py-builtins" [2]: '



########NEW FILE########
__FILENAME__ = known_to_fail
"""lists all the tests that are known to fail"""
KNOWN_TO_FAIL = [
    "tests/class/getattr2.py",
    "tests/class/oo_diamond.py",
    "tests/class/oo_super.py",
    "tests/namespace/del_global.py",
    "tests/namespace/del_local.py",
    "tests/dict/dictionary3.py",
    "tests/list/listcomp2.py",
    "tests/functions/cmp.py",

    "tests/libraries/xmlwriter.py",
    "tests/modules/classname.py",
    "tests/modules/from_import.py",
    "tests/modules/import.py",
    "tests/modules/import_alias.py",
    "tests/modules/import_class.py",
    "tests/modules/import_diamond.py",
    "tests/modules/import_global.py",
    "tests/modules/import_multi.py",
    "tests/modules/module_name.py",
    "tests/modules/rng.py",
    ]

########NEW FILE########
__FILENAME__ = runner
"""\
The special runners that look for progress in a test and have nicer output than
the original."""
import sys
if sys.version_info < (2, 7):
    import unittest2 as unittest
else:
    import unittest

class Py2JsTestResult(unittest.TestResult):
    """Test result class, handling all the results reported by the tests"""

    def __init__(self, *a, **k):
        import testtools.writer
        super(Py2JsTestResult, self).__init__(*a, **k)
        self.__writer = testtools.writer.Writer(a[0])
        self.__faild = False
        self.__color = ""
        self.__state = ""

    def startTest(self, test):
        super(Py2JsTestResult, self).startTest(test)
        test.reportProgres = self.addProgress
        test.stop = self.stop
        self.__writer.write(str(test))
        self.__state = "[Error]"
        self.__color = "Red"

    def stopTest(self, test):
        super(Py2JsTestResult, self).stopTest(test)
        self.__writer.write(self.__state, align="right", color=self.__color)

    def addProgress(self):
        """Part of tests done"""
        self.__writer.write(".")

    def addSuccess(self, test):
        super(Py2JsTestResult, self).addSuccess(test)
        self.__color = "Green"
        self.__state = "[OK]"

    def addUnexpectedSuccess(self, test):
        super(Py2JsTestResult, self).addUnexpectedSuccess(test)
        self.__color = "Green"
        self.__state = "should fail but [OK]"

    def addExpectedFailure(self, test, err):
        super(Py2JsTestResult, self).addExpectedFailure(test, err)
        self.__color = "Purple"
        self.__state = "known to [FAIL]"

    def addFailure(self, test, err):
        super(Py2JsTestResult, self).addFailure(test, err)
        self.__color = "Red"
        self.__state = "[FAIL]"

    def stopTestRun(self):
        super(Py2JsTestResult, self).stopTestRun()
        self.__writer.write("\n")

class Py2JsTestRunner(unittest.TextTestRunner):
    """Test runner with Py2JsTestResult as result class"""
    resultclass = Py2JsTestResult


########NEW FILE########
__FILENAME__ = tests
"""module which finds tests from the test directory and converts them to
the unittest framework classes."""

import testtools.env_tests as env_tests
import testtools.known_to_fail as known_to_fail
import testtools.util as util
import unittest
import glob
import os

def create_cases():
    """Helper function to find all tests in the test folders
    and wrapping them into the correct test class"""

    test_cases = unittest.TestSuite()
    test_cases.addTest(
        unittest.TestLoader().loadTestsFromTestCase(
            env_tests.EnviromentTest
            )
        )

    failing_test_cases = unittest.TestSuite()

    test_paths = glob.glob("tests/test_*.py")
    test_paths.sort()
    for test_path in test_paths:
        test_cases.addTest(
            unittest.TestLoader().loadTestsFromTestCase(
                util.compile_file_test(test_path, os.path.basename(test_path))
                )
            )

    test_paths = glob.glob("tests/test_*.js")
    test_paths.sort()
    for test_path in test_paths:
        test_cases.addTest(
            unittest.TestLoader().loadTestsFromTestCase(
                util.run_with_stdlib(test_path, os.path.basename(test_path))
                )
            )

    test_paths = glob.glob("tests/*/*.py")
    test_paths.sort()
    for test_path in test_paths:
        if (
            test_path.replace("\\","/") not 
            in known_to_fail.KNOWN_TO_FAIL
            ):
            test_cases.addTest(
                unittest.TestLoader().loadTestsFromTestCase(
                    util.compile_and_run_file_test(
                        test_path, 
                        os.path.basename(test_path)
                        )
                    )
                )
        else:
            failing_test_cases.addTest(
                unittest.TestLoader().loadTestsFromTestCase(
                    util.compile_and_run_file_failing_test(
                        test_path, 
                        os.path.basename(test_path)
                        )
                    )
                )
    return test_cases , failing_test_cases

NOT_KNOWN_TO_FAIL, KNOWN_TO_FAIL = create_cases()
ALL = unittest.TestSuite((NOT_KNOWN_TO_FAIL, KNOWN_TO_FAIL))

def get_tests(names):
    """filters out all tests that don't exist in names and
    adds them to a new test suite"""
    def flatten(itr):
        """tries to flatten out a suite to the individual tests"""
        import itertools
        try:
            return itertools.chain.from_iterable(flatten(item) for item in iter)
        except TypeError:
            return itertools.chain(*itr)

    return_suite = unittest.TestSuite()
    return_suite.addTest(
        unittest.TestLoader().loadTestsFromTestCase(
            env_tests.EnviromentTest
            )
        )
    for suite in flatten(iter(ALL)):
        test_name = str(suite._tests[0])
        if any(True for name in names if name in test_name):
            return_suite.addTest(suite)
    return return_suite

def load_tests(_loader, standard_tests, _search_pattern):
    """function called by the unittest framework to find tests in a module"""
    suite = standard_tests
    suite.addTests(ALL)
    return suite

########NEW FILE########
__FILENAME__ = util
"""
Module that defines Tool functions and test runners/result for use with
the unittest library.
"""
import sys
if sys.version_info < (2, 7):
    import unittest2 as unittest
else:
    import unittest
import os
import subprocess
import posixpath

def get_posix_path(path):
    """translates path to a posix path"""
    heads = []
    tail = path
    while tail != '':
        tail, head = os.path.split(tail)
        heads.append(head)
    return posixpath.join(*heads[::-1])

def run_with_stdlib(file_path, file_name=None):
    """Creates a test that runs a js file with the stdlib."""
    file_name = file_name if file_name else file_path

    class TestStdLib(unittest.TestCase):
        """Tests js code with the stdlib"""
        templ = {
            "js_path": file_path, 
            "js_unix_path": get_posix_path(file_path), 
            "js_out_path": file_path + ".out",
            "js_error": file_path + ".err",
            "name": file_name,
        }
        def reportProgres(self):
            """Should be overloaded by the test result class."""
    
        def runTest(self):
            """The actual test goes here."""
            cmd = (
                  'js -f "py-builtins.js" '
                  '-f "%(js_path)s" > "%(js_out_path)s" 2> "%(js_error)s"'
                  )% self.templ
            self.assertEqual(0, subprocess.call([cmd], shell = True))
            self.reportProgres()
        def __str__(self):
            return "%(js_unix_path)s [1]: " % self.templ

    return TestStdLib

def compile_file_test(file_path, file_name=None):
    """Creates a test that tests if a file can be compiled by python"""
    file_name = file_name if file_name else file_path
    
    class CompileFile(unittest.TestCase):
        """Test if a file can be compiled by python."""

        templ = {
            "py_executable": sys.executable,
            "py_path": file_path, 
            "py_unix_path": get_posix_path(file_path), 
            "py_out_path": file_path + ".out",
            "py_error": file_path + ".err",
            "name": file_name,
        }
        def reportProgres(self):
            """Should be overloaded by the test result class"""

        def runTest(self):
            """The actual test goes here."""
            commands = (
                (
                '%(py_executable)s "%(py_path)s" > '
                '"%(py_out_path)s" 2> "%(py_error)s"'
                ) % self.templ,
              )
            for cmd in commands:
                self.assertEqual(0, subprocess.call([cmd], shell = True))
                self.reportProgres()
        def __str__(self):
            return "%(py_unix_path)s [1]: " % self.templ
    return CompileFile




def compile_and_run_file_test(file_path, file_name=None):
    """Creates a test that compiles and runs the python file as js"""
    file_name = file_name if file_name else file_path

    class CompileAndRunFile(unittest.TestCase):
        """Tests that a file can be compiled and run as js"""
        templ = {
        "py_executable": sys.executable,
        "py_path": file_path, 
        "py_unix_path": get_posix_path(file_path),
        "py_out_path": file_path + ".out",
        "js_path": file_path + ".js",
        "js_out_path": file_path + ".js.out",
        "py_error": file_path + ".err",
        "js_error": file_path + ".js.err",
        "compiler_error": file_path + ".comp.err",
        "name": file_name,
        }
        def reportProgres(self):
            """Should be overloaded by the test result class"""

        def runTest(self):
            """The actual test goes here."""
            mtime_src = os.path.getmtime(self.templ['py_path'])
            try:
                mtime_py_res = os.path.getmtime(self.templ['py_out_path'])
            except OSError:
                mtime_py_res = 0
            python_command = (
                '%(py_executable)s "%(py_path)s" > "%(py_out_path)s" 2> '
                '"%(py_error)s"'
                ) % self.templ

            try:
                mtime_js_res = os.path.getmtime(self.templ['js_path'])
            except OSError:
                mtime_js_res = 0
            compile_command = (
                '%(py_executable)s pyjs.py -I -q '
                '"%(py_path)s" > "%(js_path)s" 2> '
                '"%(compiler_error)s"'
                ) % self.templ 

            javascript_command = (
                'js -f "%(js_path)s" > "%(js_out_path)s" 2> '
                '"%(js_error)s"' 
                ) % self.templ

            commands = []
            if mtime_py_res < mtime_src:
                commands.append(python_command)
            if mtime_js_res < mtime_src:
                commands.append(compile_command)
            commands.append(javascript_command)

            for cmd in commands:
                self.assertEqual(0, subprocess.call([cmd], shell = True))
                self.reportProgres()
            self.assertEqual(
                file(self.templ["py_out_path"]).readlines(),
                file(self.templ["js_out_path"]).readlines()
                )
            self.reportProgres()

        def __str__(self):
            return "%(py_unix_path)s [4]: " % self.templ

    return CompileAndRunFile

def compile_and_run_file_failing_test(*a, **k):
    """Turn a test to a failing test"""
    _class = compile_and_run_file_test(*a, **k)

    class FailingTest(_class):
        """Failing test"""
        @unittest.expectedFailure
        def runTest(self):
            return super(FailingTest, self).runTest()

    return FailingTest


########NEW FILE########
__FILENAME__ = writer
"""module with the Writer class that helps write colorful output"""

class Writer(object):
    "Class which helps to print in color and with alignment and width"    

    color_templates = (
        ("Black"       , "0;30"),
        ("Red"         , "0;31"),
        ("Green"       , "0;32"),
        ("Brown"       , "0;33"),
        ("Blue"        , "0;34"),
        ("Purple"      , "0;35"),
        ("Cyan"        , "0;36"),
        ("LightGray"   , "0;37"),
        ("DarkGray"    , "1;30"),
        ("LightRed"    , "1;31"),
        ("LightGreen"  , "1;32"),
        ("Yellow"      , "1;33"),
        ("LightBlue"   , "1;34"),
        ("LightPurple" , "1;35"),
        ("LightCyan"   , "1;36"),
        ("White"       , "1;37"),  )

    colors = dict(color_templates)
    
    c_normal = '\033[0m'
    
    c_color = '\033[%sm'
    
    def __init__(self, in_file = None):
        import sys
        self._line_wrap = False
        self._write_pos = 0
        self._file = in_file or sys.stdout
        #self._file = sys.stdout
        if not (hasattr(self._file, 'isatty') and self._file.isatty()):
            # the stdout is not a terminal, this for example happens if the
            # output is piped to less, e.g. "bin/test | less". In this case,
            # the terminal control sequences would be printed verbatim, so
            # don't use any colors.
            self.write = self.normal_write
        elif sys.platform != "win32":
            # We are on *nix system we can use ansi
            self.write = self.ansi_write
        else:
            try:
                import colorama
                colorama.init(wrap=False)
                self._file = colorama.AnsiToWin32(self._file).stream
                self.write = self.ansi_write
            except ImportError:
                self.write = self.normal_write

    def write(self, text, color="", align="left", width=80):
        """
        Prints a text on the screen.

        It uses file.write(), so no readline library is necessary.

        color ... choose from the colors below, "" means default color
        align ... left/right, left is a normal print, right is aligned on the
                  right hand side of the screen, filled with " " if necessary
        width ... the screen width
        """

    def normal_write(self, text, color="", align="left", width=80):
        "Ignores color but uses alignment and width"
        _color = color
        if align == "right":
            if self._write_pos + len(text) > width:
                # we don't fit on the current line, create a new line
                self.write("\n")
            self.write(" " * (width - self._write_pos - len(text)))

        if self._line_wrap:
            if text != "" and text[0] != "\n":
                self._file.write("\n")

        self._file.write(text)
        self._file.flush()

        next_new_line = text.rfind("\n")

        if next_new_line == -1:
            self._write_pos += len(text)
        else:
            self._write_pos = len(text) - next_new_line - 1
        self._line_wrap = self._write_pos >= width
        self._write_pos %= width


    def ansi_write(self, text, color="", align="left", width=80):
        "Writes with color, alignment and width"
        try:
            return self.normal_write(
                    text=(
                      "%s%s%s" % (
                        self.c_color % self.colors[color], 
                        text, 
                        self.c_normal
                        )
                      if color in self.colors
                      else text 
                      ),
                    color=color,
                    align=align,
                    width=width
                )
        except AssertionError:
            return self.normal_write(
                text=text,
                color=color,
                align=align,
                width=width
                )

########NEW FILE########
