__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Flask MongoAlchemy documentation build configuration file, created by
# sphinx-quickstart on Sat Nov 20 17:56:16 2010.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import os
import sys

sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
sys.path.append(os.path.abspath('_themes'))

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
# sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
# needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
# source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Flask MongoAlchemy'
copyright = u'2010, Francisco Souza'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.5'
# The full version, including alpha/beta/rc tags.
release = '0.5.4'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
# language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
# today = ''
# Else, today_fmt is used as the format for a strftime call.
# today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
# default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
# add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
# add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
# show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
# pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
# modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'flask_small'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
html_theme_options = {
    'index_logo': 'flask-mongoalchemy.png',
    'github_fork': 'cobrateam/flask-mongoalchemy'
}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['_themes']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
# html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
# html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
# html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
# html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
# html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
# html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
# html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
# html_additional_pages = {}

# If false, no module index is generated.
# html_domain_indices = True

# If false, no index is generated.
# html_use_index = True

# If true, the index is split into individual pages for each letter.
# html_split_index = False

# If true, links to the reST sources are added to the pages.
# html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
# html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
# html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
# html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
# html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'FlaskMongoAlchemydoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
# latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
# latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
    ('index', 'FlaskMongoAlchemy.tex', u'Flask MongoAlchemy Documentation',
     u'Francisco Souza', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
# latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
# latex_use_parts = False

# If true, show page references after internal links.
# latex_show_pagerefs = False

# If true, show URL addresses after external links.
# latex_show_urls = False

# Additional stuff for the LaTeX preamble.
# latex_preamble = ''

# Documents to append as an appendix to all manuals.
# latex_appendices = []

# If false, no module index is generated.
# latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'flaskmongoalchemy', u'Flask MongoAlchemy Documentation',
     [u'Francisco Souza'], 1)
]

########NEW FILE########
__FILENAME__ = flask_theme_support
# flasky extensions.  flasky pygments style based on tango style
from pygments.style import Style
from pygments.token import (Keyword, Name, Comment, String, Error,
                            Number, Operator, Generic, Whitespace,
                            Punctuation, Other, Literal)


class FlaskyStyle(Style):
    background_color = "#f8f8f8"
    default_style = ""

    styles = {
        # No corresponding class for the following:
        # Text:                     "", # class:  ''
        Whitespace:                "underline #f8f8f8",       # class: 'w'
        Error:                     "#a40000 border:#ef2929",  # class: 'err'
        Other:                     "#000000",                 # class 'x'

        Comment:                   "italic #8f5902",  # class: 'c'
        Comment.Preproc:           "noitalic",        # class: 'cp'

        Keyword:                   "bold #004461",    # class: 'k'
        Keyword.Constant:          "bold #004461",    # class: 'kc'
        Keyword.Declaration:       "bold #004461",    # class: 'kd'
        Keyword.Namespace:         "bold #004461",    # class: 'kn'
        Keyword.Pseudo:            "bold #004461",    # class: 'kp'
        Keyword.Reserved:          "bold #004461",    # class: 'kr'
        Keyword.Type:              "bold #004461",    # class: 'kt'

        Operator:                  "#582800",        # class: 'o'
        Operator.Word:             "bold #004461",   # class: 'ow' - like keywords

        Punctuation:               "bold #000000",   # class: 'p'

        # because special names such as Name.Class, Name.Function, etc.
        # are not recognized as such later in the parsing, we choose them
        # to look the same as ordinary variables.
        Name:                      "#000000",         # class: 'n'
        Name.Attribute:            "#c4a000",         # class: 'na' - to be revised
        Name.Builtin:              "#004461",         # class: 'nb'
        Name.Builtin.Pseudo:       "#3465a4",         # class: 'bp'
        Name.Class:                "#000000",         # class: 'nc' - to be revised
        Name.Constant:             "#000000",         # class: 'no' - to be revised
        Name.Decorator:            "#888",            # class: 'nd' - to be revised
        Name.Entity:               "#ce5c00",         # class: 'ni'
        Name.Exception:            "bold #cc0000",    # class: 'ne'
        Name.Function:             "#000000",         # class: 'nf'
        Name.Property:             "#000000",         # class: 'py'
        Name.Label:                "#f57900",         # class: 'nl'
        Name.Namespace:            "#000000",         # class: 'nn' - to be revised
        Name.Other:                "#000000",         # class: 'nx'
        Name.Tag:                  "bold #004461",    # class: 'nt' - like a keyword
        Name.Variable:             "#000000",         # class: 'nv' - to be revised
        Name.Variable.Class:       "#000000",         # class: 'vc' - to be revised
        Name.Variable.Global:      "#000000",         # class: 'vg' - to be revised
        Name.Variable.Instance:    "#000000",         # class: 'vi' - to be revised

        Number:                    "#990000",         # class: 'm'

        Literal:                   "#000000",         # class: 'l'
        Literal.Date:              "#000000",         # class: 'ld'

        String:                    "#4e9a06",         # class: 's'
        String.Backtick:           "#4e9a06",         # class: 'sb'
        String.Char:               "#4e9a06",         # class: 'sc'
        String.Doc:                "italic #8f5902",  # class: 'sd' - like a comment
        String.Double:             "#4e9a06",         # class: 's2'
        String.Escape:             "#4e9a06",         # class: 'se'
        String.Heredoc:            "#4e9a06",         # class: 'sh'
        String.Interpol:           "#4e9a06",         # class: 'si'
        String.Other:              "#4e9a06",         # class: 'sx'
        String.Regex:              "#4e9a06",         # class: 'sr'
        String.Single:             "#4e9a06",         # class: 's1'
        String.Symbol:             "#4e9a06",         # class: 'ss'

        Generic:                   "#000000",         # class: 'g'
        Generic.Deleted:           "#a40000",         # class: 'gd'
        Generic.Emph:              "italic #000000",  # class: 'ge'
        Generic.Error:             "#ef2929",         # class: 'gr'
        Generic.Heading:           "bold #000080",    # class: 'gh'
        Generic.Inserted:          "#00A000",         # class: 'gi'
        Generic.Output:            "#888",            # class: 'go'
        Generic.Prompt:            "#745334",         # class: 'gp'
        Generic.Strong:            "bold #000000",    # class: 'gs'
        Generic.Subheading:        "bold #800080",    # class: 'gu'
        Generic.Traceback:         "bold #a40000",    # class: 'gt'
    }

########NEW FILE########
__FILENAME__ = documents
# -*- coding: utf-8 -*-

# Copyright 2014 flask-mongoalchemy authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

from collection import db
from flask.ext.mongoalchemy import BaseQuery
import re


class BookQuery(BaseQuery):

    def starting_with(self, letter):
        regex = r'^' + letter
        return self.filter({'title': re.compile(regex, re.IGNORECASE)})


class Book(db.Document):
    query_class = BookQuery

    title = db.StringField()
    year = db.IntField()

########NEW FILE########
__FILENAME__ = forms
# -*- coding: utf-8 -*-

# Copyright 2014 flask-mongoalchemy authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

import wtforms
from flask.ext import wtf
from wtforms import validators

from collection.documents import Book


class BookForm(wtf.Form):
    document_class = Book
    title = wtforms.TextField(validators=[validators.Required()])
    year = wtforms.IntegerField(validators=[validators.Required()])
    instance = None

    def __init__(self, document=None, *args, **kwargs):
        super(BookForm, self).__init__(*args, **kwargs)
        if document is not None:
            self.instance = document
            self._copy_data_to_form()

    def _copy_data_to_form(self):
        self.title.data = self.instance.title
        self.year.data = self.instance.year

    def save(self):
        if self.instance is None:
            self.instance = self.document_class()
        self.instance.title = self.title.data
        self.instance.year = self.year.data
        self.instance.save()
        return self.instance

########NEW FILE########
__FILENAME__ = views
# -*- coding: utf-8 -*-

# Copyright 2014 flask-mongoalchemy authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

from flask import render_template, redirect, url_for

from collection import app
from collection.forms import BookForm
from collection.documents import Book


@app.route('/books/new', methods=['GET', 'POST'])
def new_book():
    form = BookForm()
    if form.validate_on_submit():
        form.save()
        return redirect(url_for('list_books'))
    return render_template('/books/new.html', form=form)


@app.route('/books')
@app.route('/books/<int:page>')
def list_books(page=1):
    title = u'Books list'
    pagination = Book.query.paginate(page=page, per_page=5)
    return render_template('/books/list_all.html', pagination=pagination, title=title)


@app.route('/books/<letter>')
@app.route('/books/<letter>/<int:page>')
def list_books_filtering(letter, page=1):
    title = u'Books starting with %s' % letter.upper()
    pagination = Book.query.starting_with(letter).paginate(page=page, per_page=5)
    return render_template('/books/list_filtered.html', pagination=pagination,
                           title=title, letter=letter)


@app.route('/books/delete/<id>')
def delete_book(id):
    book = Book.query.get_or_404(id)
    book.remove()
    return redirect(url_for('list_books'))


@app.route('/books/edit/<id>')
def edit_book(id):
    book = Book.query.get(id)
    form = BookForm(document=book)
    return render_template('/books/edit.html', form=form, book=book)


@app.route('/books/edit/<id>', methods=['POST'])
def update_book(id):
    book = Book.query.get(id)
    form = BookForm()
    if form.validate_on_submit():
        form.instance = book
        form.save()
        return redirect(url_for('list_books'))
    form = BookForm(document=book)
    return render_template('/books/edit.html', form=form, book=book)

########NEW FILE########
__FILENAME__ = run
# -*- coding: utf-8 -*-

# Copyright 2010 flask-mongoalchemy authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

from collection import app

if __name__ == '__main__':
    app.run()

########NEW FILE########
__FILENAME__ = test_collection
# -*- coding: utf-8 -*-

# Copyright 2010 flask-mongoalchemy authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

import unittest
import collection


class BooksCollectionTestCase(unittest.TestCase):

    def setUp(self):
        self.app = collection.app.test_client()

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = library
# -*- coding: utf-8 -*-

# Copyright 2014 flask-mongoalchemy authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

from flask import Flask, request
from flask.ext.mongoalchemy import MongoAlchemy
app = Flask(__name__)
app.config['DEBUG'] = True
app.config['MONGOALCHEMY_DATABASE'] = 'library'
db = MongoAlchemy(app)


class Author(db.Document):
    name = db.StringField()


class Book(db.Document):
    title = db.StringField()
    author = db.DocumentField(Author)
    year = db.IntField()


@app.route('/author/new')
def new_author():
    """Creates a new author by a giving name (via GET parameter)

    e.g.: GET /author/new?name=Francisco creates a author named Francisco
    """
    author = Author(name=request.args.get('name', ''))
    author.save()
    return 'Saved :)'


@app.route('/authors/')
def list_authors():
    """List all authors.

    e.g.: GET /authors"""
    authors = Author.query.all()
    content = '<p>Authors:</p>'
    for author in authors:
        content += '<p>%s</p>' % author.name
    return content

if __name__ == '__main__':
    app.run()

########NEW FILE########
__FILENAME__ = meta
# -*- coding: utf-8 -*-

# Copyright 2014 flask-mongoalchemy authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

from mongoalchemy import document


def make_document_class(session, document_class):
    class_dict = document_class.__dict__.copy()
    class_dict.update({'_session': session})
    return type("Document", (document.Document,), class_dict)

########NEW FILE########
__FILENAME__ = helpers
# -*- coding: utf-8 -*-

# Copyright 2014 flask-mongoalchemy authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.


def _make_todo_document(db):
    class Todo(db.Document):
        description = db.StringField()
    return Todo

########NEW FILE########
__FILENAME__ = test_document
# -*- coding: utf-8 -*-

# Copyright 2014 flask-mongoalchemy authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

from tests import BaseAppTestCase


class MongoAlchemyDocumentTestCase(BaseAppTestCase):

    def test_should_be_able_to_save_a_document_on_database_by_calling_its_save_method(self):
        todo = self.Todo(description=u'Reinvent the world')
        todo.save()
        self.assertEqual(self.Todo.query.count(), 1)

    def test_should_be_able_to_remove_a_document_on_database_by_calling_its_remove_method(self):
        todo = self.Todo(description=u'Reinvent the world')
        todo.save()
        self.assertEqual(self.Todo.query.count(), 1)
        todo.remove()
        self.assertEqual(self.Todo.query.count(), 0)

    def test_should_be_equal_by_the_id(self):
        todo = self.Todo(description=u'Reinvent the world')
        todo.save()
        my_new_todo = self.Todo(description=u'Save the world')
        my_new_todo.mongo_id = todo.mongo_id
        self.assertEqual(todo, my_new_todo)
        another_todo = self.Todo(description=u'Destroy the world')
        self.assertNotEqual(todo, another_todo)

    def test_should_be_able_update_a_document_by_calling_its_save_method(self):
        todo = self.Todo(description=u'Reinvent the world')
        todo.save()
        mongo_id = todo.mongo_id
        todo.description = u'Destroy the world.'
        todo.save()
        searched_todo = self.Todo.query.get(mongo_id)
        self.assertEqual(searched_todo.description, u'Destroy the world.')
        self.assertEqual(self.Todo.query.count(), 1)

########NEW FILE########
__FILENAME__ = test_meta
# -*- coding: utf-8 -*-

# Copyright 2010 flask-mongoalchemy authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

from __future__ import absolute_import

from mongoalchemy import document

from flask.ext.mongoalchemy import Document
from flask.ext.mongoalchemy.meta import make_document_class
from tests import BaseAppTestCase


class MetaTestCase(BaseAppTestCase):
    "meta.py test case"

    def test_should_be_able_to_create_a_new_document(self):
        MyDocument = make_document_class(self.db, Document)
        assert issubclass(MyDocument, document.Document)

########NEW FILE########
__FILENAME__ = test_mongoalchemy_object
# -*- coding: utf-8 -*-

# Copyright 2014 flask-mongoalchemy authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

from flask import Flask
from mongoalchemy import fields
from mongoalchemy.session import Session

from flask.ext.mongoalchemy import BaseQuery, ImproperlyConfiguredError, MongoAlchemy
from . import BaseTestCase


class MongoAlchemyObjectTestCase(BaseTestCase):
    "MongoAlchemy itself object tests"

    def setUp(self):
        self.app = Flask(__name__)
        self.app.config['MONGOALCHEMY_DATABASE'] = 'testing'
        self.app.config['TESTING'] = True

    def tearDown(self):
        del(self.app)

    def test_should_provide_a_Document_class_to_be_extended_inside_the_MongoAlchemy_object(self):
        db = MongoAlchemy()
        assert db.Document is not None

    def test_should_provide_a_query_object_for_queries_on_a_document(self):
        db = MongoAlchemy(self.app)

        class Todo(db.Document):
            description = db.StringField()

        self.assertIsInstance(Todo.query, BaseQuery)

    def test_should_provide_a_session_object_on_mongoalchemy_instance(self):
        db = MongoAlchemy(self.app)
        self.assertIsInstance(db.session, Session)

    def test_should_be_possible_to_create_a_customized_query_class(self):
        db = MongoAlchemy(self.app)

        class Query(BaseQuery):
            pass

        class Todo(db.Document):
            description = db.StringField()
            query_class = Query

        self.assertIsInstance(Todo.query, Query)

    def test_invalid_query_is_none(self):
        db = MongoAlchemy()

        class Query(object):
            pass

        class Todo(db.Document):
            description = db.StringField()
            query_class = Query

        assert Todo.query is None

    def test_should_include_all_mongo_alchemy_fields_objects(self):
        db = MongoAlchemy()
        for key in dir(fields):
            assert hasattr(db, key), "should have the %s attribute" % key
        assert hasattr(db, 'DocumentField'), "should have the DocumentField attribute"

    def test_should_be_able_to_instantiate_passing_the_app(self):
        db = MongoAlchemy(self.app)
        assert db.session is not None

    def test_should_be_able_to_instantiate_without_passing_the_app_and_set_it_later(self):
        db = MongoAlchemy()
        assert db.session is None
        db.init_app(self.app)
        assert db.session is not None

    def test_should_contain_a_not_none_query(self):
        "Document.query should never be None"
        db = MongoAlchemy()
        db.init_app(self.app)

        class Person(db.Document):
            name = db.StringField()

        p = Person()
        assert p.query is not None

    def test_should_not_be_able_to_work_without_providing_a_database_name(self):
        with self.assertRaises(ImproperlyConfiguredError):
            app = Flask(__name__)
            MongoAlchemy(app)

    def test_loads_without_database_connection_data(self):
        app = Flask(__name__)
        app.config['MONGOALCHEMY_DATABASE'] = 'my_database'
        MongoAlchemy(app)
        self.assertEqual(app.config['MONGOALCHEMY_SERVER'], 'localhost')
        self.assertEqual(app.config['MONGOALCHEMY_PORT'], '27017')
        self.assertEqual(app.config['MONGOALCHEMY_USER'], None)
        self.assertEqual(app.config['MONGOALCHEMY_PASSWORD'], None)
        self.assertEqual(app.config['MONGOALCHEMY_REPLICA_SET'], '')

    def test_should_be_able_to_create_two_decoupled_mongoalchemy_instances(self):
        app = Flask(__name__)
        app.config['MONGOALCHEMY_DATABASE'] = 'my_database'
        db1 = MongoAlchemy(app)
        db2 = MongoAlchemy(app)
        assert db1.Document is not db2.Document, "two documents should not be the same object"

########NEW FILE########
__FILENAME__ = test_mongodb_uri
# -*- coding: utf-8 -*-

# Copyright 2014 flask-mongoalchemy authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

from tests import BaseTestCase
from flask import Flask


class MongoDBURITestCase(BaseTestCase):
    "MongoDB URI generation"

    def setup(self):
        self.app = Flask(__name__)
        self.app.config['MONGOALCHEMY_DATABASE'] = 'test'

    def test_uri_without_database_name(self):
        from flask.ext.mongoalchemy import _get_mongo_uri
        self.assertEqual(_get_mongo_uri(self.app), 'mongodb://localhost:27017/')

    def test_uri_with_user_only(self):
        self.app.config['MONGOALCHEMY_USER'] = 'luke'
        from flask.ext.mongoalchemy import _get_mongo_uri
        self.assertEqual(_get_mongo_uri(self.app), 'mongodb://luke@localhost:27017/')

    def test_uri_with_user_and_password(self):
        self.app.config['MONGOALCHEMY_USER'] = 'luke'
        self.app.config['MONGOALCHEMY_PASSWORD'] = 'father'
        self.app.config['MONGOALCHEMY_SERVER_AUTH'] = False
        from flask.ext.mongoalchemy import _get_mongo_uri
        self.assertEqual(_get_mongo_uri(self.app), 'mongodb://luke:father@localhost:27017/test')

    def test_mongodb_uri_with_external_server(self):
        self.app.config['MONGOALCHEMY_SERVER'] = 'database.lukehome.com'
        self.app.config['MONGOALCHEMY_PORT'] = '42'
        from flask.ext.mongoalchemy import _get_mongo_uri
        self.assertEqual(_get_mongo_uri(self.app), 'mongodb://database.lukehome.com:42/')

    def test_mongodb_uri_with_options(self):
        self.app.config['MONGOALCHEMY_SERVER'] = 'database.lukehome.com'
        self.app.config['MONGOALCHEMY_OPTIONS'] = 'safe=true'
        from flask.ext.mongoalchemy import _get_mongo_uri
        self.assertEqual(_get_mongo_uri(self.app),
                         'mongodb://database.lukehome.com:27017/?safe=true')

########NEW FILE########
__FILENAME__ = test_pagination
# -*- coding: utf-8 -*-

# Copyright 2010 flask-mongoalchemy authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

from tests import BaseAppTestCase
from werkzeug.exceptions import NotFound


class FlaskMongoAlchemyPaginationTestCase(BaseAppTestCase):
    "Flask-MongoAlchemy Pagination class"

    def setup(self):
        super(FlaskMongoAlchemyPaginationTestCase, self).setup()

        # saving 30 Todo's
        for i in range(4, 34):
            todo = self.Todo(description=u'Write my %dth book' % i)
            todo.save()

    def test_should_provide_a_pages_property(self):
        pagination = self.Todo.query.filter({}).paginate(page=1)
        self.assertEqual(pagination.pages, 2)
        pagination = self.Todo.query.filter({}).paginate(page=1, per_page=50)
        self.assertEqual(pagination.pages, 1)

    def test_should_provide_a_has_next_method(self):
        pagination = self.Todo.query.filter({}).paginate(page=1)
        assert pagination.has_next()
        pagination = self.Todo.query.filter({}).paginate(page=1, per_page=50)
        assert pagination.has_next() is False

    def test_should_provide_a_next_method(self):
        pagination = self.Todo.query.filter({}).paginate(page=1)
        next_page = pagination.next()
        self.assertEqual(next_page.page, 2)
        self.assertEqual(len(next_page.items), 10)
        self._replace_flask_abort()
        next_page.next(error_out=True)
        self.mocker.verify()

    def test_should_provide_a_has_prev_method(self):
        pagination = self.Todo.query.filter({}).paginate(page=2)
        assert pagination.has_prev()
        pagination = self.Todo.query.filter({}).paginate(page=1, per_page=50)
        assert pagination.has_prev() is False
        pagination = self.Todo.query.filter({}).paginate(page=1)
        assert pagination.has_prev() is False

    def test_should_provide_prev_method(self):
        pagination = self.Todo.query.filter({}).paginate(page=2)
        previous_page = pagination.prev()
        self.assertEqual(pagination.page, 2)
        self.assertEqual(previous_page.page, 1)
        self.assertEqual(len(previous_page.items), 20)
        with self.assertRaises(NotFound):
            self._replace_flask_abort_raising_exception()
            previous_page.prev(error_out=True)
            self.mocker.verify()

    def test_should_provide_the_number_of_the_next_page(self):
        pagination = self.Todo.query.filter({}).paginate(page=1)
        self.assertEqual(pagination.next_num, 2)

    def test_should_provide_the_number_of_the_previous_page(self):
        pagination = self.Todo.query.filter({}).paginate(page=2)
        self.assertEqual(pagination.prev_num, 1)

########NEW FILE########
__FILENAME__ = test_query
# -*- coding: utf-8 -*-

# Copyright 2010 flask-mongoalchemy authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

from tests import BaseAppTestCase
from werkzeug.exceptions import NotFound


class FlaskMongoAlchemyQueryTestCase(BaseAppTestCase):
    "Flask-MongoAlchemy BaseQuery class"

    def test_should_provide_a_get_method_on_query_object(self):
        "Should provide a \"get()\" method on Query object"
        todo = self.Todo(description=u'Start something very new')
        todo.save()
        searched_todo = self.Todo.query.get(str(todo.mongo_id))
        self.assertEqual(todo, searched_todo)

    def test_should_return_None_when_querying_for_a_non_existing_document_on_database(self):
        "\"get()\" method should return None when querying for a non-existing document"
        searched_todo = self.Todo.query.get('4e038a23e4206650da0000df')
        assert searched_todo is None

    def test_should_provide_a_get_or_404_method_on_query_object(self):
        "Should provide a \"get_or_404()\" method on Query object"
        self._replace_flask_abort()
        searched_todo = self.Todo.query.get_or_404('4e038a23e4206650da0000df')
        self.mocker.verify()

        todo = self.Todo(description=u'Start something')
        todo.save()
        searched_todo = self.Todo.query.get_or_404(str(todo.mongo_id))
        self.assertEqual(todo, searched_todo)

    def test_should_provide_a_first_or_404_method_on_query_object(self):
        "Should provide a \"first_or_404()\" method on Query object"
        self._replace_flask_abort()
        searched_todo = self.Todo.query.filter({}).first_or_404()
        self.mocker.verify()

        todo1 = self.Todo(description=u'Start something new')
        todo1.save()
        todo2 = self.Todo(description=u'Clean the room')
        todo2.save()
        searched_todo = self.Todo.query.filter({}).first_or_404()
        self.assertEqual(todo1, searched_todo)

    def test_should_provide_a_paginate_method_on_query_object(self):
        for i in range(4, 20):
            todo = self.Todo(description=u'Try something for the %dth time' % i)
            todo.save()
        from flask.ext.mongoalchemy import Pagination
        assert isinstance(self.Todo.query.paginate(page=1, per_page=5), Pagination)

    def test_should_abort_with_404_when_paginating_an_empty_query(self):
        todo = self.Todo(description=u'Do anything weird')
        todo.save()

        self._replace_flask_abort_raising_exception(calls=2)
        self.assertRaises(NotFound,
                          self.Todo.query.filter(self.Todo.description ==
                                                 u'Do anything weird').paginate, page=2)
        self.assertRaises(NotFound,
                          self.Todo.query.filter(self.Todo.description ==
                                                 u'Do anything good').paginate, page=0)
        self.mocker.verify()

    def test_should_return_None_for_wrong_formated_objectids(self):
        todo = self.Todo.query.get("blasphemy")
        assert todo is None

########NEW FILE########
