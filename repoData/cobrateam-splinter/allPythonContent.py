__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# splinter documentation build configuration file, created by
# sphinx-quickstart on Sat Jan  8 23:31:41 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

import os
import sys
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc',]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'splinter'
copyright = u'2011, andrews medina'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.6.0'
# The full version, including alpha/beta/rc tags.
release = '0.6.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'vs'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'nature'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'splinterdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'splinter.tex', u'splinter Documentation',
   u'andrews medina', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'splinter', u'splinter Documentation',
     [u'andrews medina'], 1)
]

########NEW FILE########
__FILENAME__ = run_tests
#!/usr/bin/env python

# Copyright 2013 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

# -*- coding: utf-8 -*-

import argparse
import sys
import unittest
import os

from multiprocessing import Process
try:
    from urllib import urlopen
except ImportError:
    from urllib.request import urlopen

from tests import TESTS_ROOT
from tests.fake_webapp import start_flask_app, EXAMPLE_APP

parser = argparse.ArgumentParser('Run splinter tests')
parser.add_argument('-w', '--which', action='store')
parser.add_argument('-f', '--failfast', action='store_true')
parser.add_argument('-v', '--verbosity', type=int, default=1)


class Env(object):
    pass


env = Env()
env.process = None
env.host, env.port = 'localhost', 5000


def wait_until_start():
    while True:
        try:
            results = urlopen(EXAMPLE_APP)
            if results.code == 404:
                raise Exception('%s returned unexpected 404' % EXAMPLE_APP)
            break
        except IOError:
            pass


def wait_until_stop():
    while True:
        try:
            results = urlopen(EXAMPLE_APP)
            if results.code == 404:
                break
        except IOError:
            break


def start_server():
    sys.stderr = open('/dev/null', 'w')
    env.process = Process(target=start_flask_app, args=(env.host, env.port))
    env.process.daemon = True
    env.process.start()
    wait_until_start()


def stop_server():
    env.process.terminate()
    env.process.join()
    wait_until_stop()


def get_modules(modules_str):
    names = modules_str.split(',')
    modules = []

    for name in names:
        name = name.replace('/', '.').replace('.py', '')
        try:
            module = __import__(name, fromlist='tests')
        except:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            print('Error importing module {}:'.format(name))
            import traceback
            traceback.print_exception(exc_type, exc_value, exc_traceback,
                                      file=sys.stdout)
        modules.append(module)

    return modules


def run_suite(suite, args):
    runner = unittest.TextTestRunner(sys.stdout, True, args.verbosity,
                                     args.failfast)
    return runner.run(suite)


def get_suite_from_modules(modules):
    loader = unittest.TestLoader()
    suite = unittest.TestSuite()

    for module in modules:
        suite.addTest(loader.loadTestsFromModule(module))

    return suite


def get_complete_suite():
    loader = unittest.TestLoader()
    return loader.discover(
        start_dir=TESTS_ROOT,
        top_level_dir=os.path.join(TESTS_ROOT, os.path.pardir)
    )


if __name__ == '__main__':
    try:
        start_server()
    except Exception as e:
        sys.stdout.write("Failed to start test server: %s\n\n" % e)
        sys.exit(1)

    args = parser.parse_args()

    loader = unittest.TestLoader()
    if args.which and args.which != 'tests':
        modules = get_modules(args.which)
        suite = get_suite_from_modules(modules)
    else:
        suite = get_complete_suite()

    result = run_suite(suite, args)
    stop_server()
    sys.exit(len(result.errors) + len(result.failures))

########NEW FILE########
__FILENAME__ = test_facebook_events
# -*- coding: utf-8 -*-

# Copyright 2012 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

"""
This snippet show how to "test" a Facebook feature: the creation of an event.

It creates an event by going to http://www.facebook.com, login and navigate to "Create an event" page.
"""

import os
import unittest
import time
from splinter import Browser


class FacebookEventsTestCase(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls.browser = Browser('firefox')

    @classmethod
    def tearDownClass(cls):
        cls.browser.quit()

    def do_login_if_need(self, username, password):
        if self.browser.is_element_present_by_css('div.menu_login_container'):
            self.browser.fill('email', username)
            self.browser.fill('pass', password)
            self.browser.find_by_css('div.menu_login_container input[type="submit"]').first.click()
            assert self.browser.is_element_present_by_css('li#navAccount')

    def test_create_event(self):
        "Should be able to create an event"
        # Open home and login
        self.browser.visit("http://www.facebook.com")
        self.do_login_if_need(username='user', password='pass')

        # Go to events page
        self.browser.find_by_css('li#navItem_events a').first.click()

        # Click on "Create an event button"
        self.browser.find_by_css('div.uiHeaderTop a.uiButton').first.click()
        time.sleep(1)

        # Uploading the picture
        picture_path = os.path.join(os.path.abspath(os.path.dirname(__file__)), 'img', 'turtles.jpg')
        self.browser.find_by_css('div.eventEditUpload a.uiButton').first.click()

        if not self.browser.is_element_present_by_css('iframe#upload_pic_frame', wait_time=10):
            self.fail("The upload pic iframe didn't appear :(")

        with self.browser.get_iframe('upload_pic_frame') as frame:
            frame.attach_file('pic', picture_path)
            time.sleep(10)

        # Filling the form
        self.browser.fill('event_startIntlDisplay', '5/21/2011')
        self.browser.select('start_time_min', '480')
        self.browser.fill('name', 'Splinter sprint')
        self.browser.fill('location', 'Rio de Janeiro, Brazil')
        self.browser.fill('desc', 'For more info, check out the #cobratem channel on freenode!')

        self.browser.find_by_css('label.uiButton input[type="submit"]').first.click()
        time.sleep(1)

        # Checking if the event was created and we were redirect to its page
        title = self.browser.find_by_css('h1 span').first.text
        assert title == 'Splinter sprint', title

########NEW FILE########
__FILENAME__ = test_google_search
#!/usr/bin/env python

# Copyright 2012 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

import unittest
from splinter import Browser


class TestGoogleSearch(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        cls.browser = Browser()

    @classmethod
    def tearDownClass(cls):
        cls.browser.quit()

    def test_visiting_google_com_returns_a_page_with_Google_in_title(self):
        self.browser.visit('http://www.google.com/')
        self.assertIn('Google', self.browser.title)

    def test_filling_Splinter_in_the_search_box_returns_Splinter_website(self):
        self.browser.visit('http://www.google.com/')
        self.browser.fill('q', 'Splinter')
        search_button = self.browser.find_by_name('btnG').first
        while not search_button.visible:
            # waits for the JavaScript to put the button on the page
            pass
        search_button.click()
        self.assertTrue(self.browser.is_text_present('splinter.cobrateam.info'))


unittest.main()

########NEW FILE########
__FILENAME__ = browser
# -*- coding: utf-8 -*-

# Copyright 2012 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

import sys

from splinter.driver.webdriver.firefox import WebDriver as FirefoxWebDriver
from splinter.driver.webdriver.remote import WebDriver as RemoteWebDriver
from splinter.driver.webdriver.chrome import WebDriver as ChromeWebDriver
from splinter.driver.webdriver.phantomjs import WebDriver as PhantomJSWebDriver
from splinter.exceptions import DriverNotFoundError


_DRIVERS = {
    'firefox': FirefoxWebDriver,
    'remote': RemoteWebDriver,
    'chrome': ChromeWebDriver,
    'phantomjs': PhantomJSWebDriver,
}

if sys.version_info[0] <= 2:
    try:
        from splinter.driver.zopetestbrowser import ZopeTestBrowser
        _DRIVERS['zope.testbrowser'] = ZopeTestBrowser
    except ImportError:
        pass

try:
    import django  # noqa
    from splinter.driver.djangoclient import DjangoClient
    _DRIVERS['django'] = DjangoClient
except ImportError:
    pass

try:
    import flask  # noqa
    from splinter.driver.flaskclient import FlaskClient
    _DRIVERS['flask'] = FlaskClient
except ImportError:
    pass


def Browser(driver_name='firefox', *args, **kwargs):
    """
    Returns a driver instance for the given name.

    When working with ``firefox``, it's possible to provide a profile name
    and a list of extensions.

    If you don't provide any driver_name, then ``firefox`` will be used.

    If there is no driver registered with the provided ``driver_name``, this
    function will raise a :class:`splinter.exceptions.DriverNotFoundError`
    exception.
    """

    try:
        driver = _DRIVERS[driver_name]
    except KeyError:
        raise DriverNotFoundError("No driver for %s" % driver_name)
    return driver(*args, **kwargs)

########NEW FILE########
__FILENAME__ = cookie_manager
# -*- coding: utf-8 -*-

# Copyright 2012 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

from splinter.meta import InheritedDocs


class CookieManagerAPI(InheritedDocs('_CookieManagerAPI', (object,), {})):
    """
    An API that specifies how a splinter driver deals with cookies.

    You can add cookies using the :meth:`add <CookieManagerAPI.add>` method,
    and remove one or all cookies using
    the :meth:`delete <CookieManagerAPI.delete>` method.

    A CookieManager acts like a ``dict``, so you can access the value of a
    cookie through the [] operator, passing the cookie identifier:

        >>> cookie_manager.add({'name': 'Tony'})
        >>> assert cookie_manager['name'] == 'Tony'
    """

    def add(self, cookies):
        """
        Adds a cookie.

        The ``cookie`` parameter is a ``dict`` where each key is an identifier
        for the cookie value (like any ``dict``).

        Example of use:

            >>> cookie_manager.add({'name': 'Tony'})
        """
        raise NotImplementedError

    def delete(self, *cookies):
        """
        Deletes one or more cookies. You can pass all the cookies identifier
        that you want to delete.

        If none identifier is provided, all cookies are deleted.

        Examples:

            >>> cookie_manager.delete() # deletes all cookies
            >>> cookie_manager.delete('name', 'birthday',
                                      'favorite_color') # deletes these three cookies
            >>> cookie_manager.delete('name') # deletes one cookie
        """
        raise NotImplementedError

    def all(self, verbose=False):
        """
        Returns all of the cookies.

            **Note:** If you're using any webdriver and want more info about the cookie, set the `verbose` parameter to `True` (in other drivers, it won't make any difference). In this case, this method will return a list of dicts, each with one cookie's info.

        Examples:

            >>> cookie_manager.add({'name': 'Tony'})
            >>> cookie_manager.all()
            [{'name': 'Tony'}]
        """
        raise NotImplementedError

    def __getitem__(self, item):
        raise NotImplementedError

    def __eq__(self, other_object):
        raise NotImplementedError

########NEW FILE########
__FILENAME__ = djangoclient
# -*- coding: utf-8 -*-

# Copyright 2012 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

from __future__ import with_statement
import os.path
import re
import time
import sys

import lxml.html
from lxml.cssselect import CSSSelector
from splinter.cookie_manager import CookieManagerAPI
from splinter.driver import DriverAPI, ElementAPI
from splinter.element_list import ElementList
from splinter.exceptions import ElementDoesNotExist
from splinter.request_handler.status_code import StatusCode


class CookieManager(CookieManagerAPI):

    def __init__(self, browser_cookies):
        self._cookies = browser_cookies

    def add(self, cookies):
        if isinstance(cookies, list):
            for cookie in cookies:
                for key, value in cookie.items():
                    self._cookies[key] = value
                return
        for key, value in cookies.items():
            self._cookies[key] = value

    def delete(self, *cookies):
        if cookies:
            for cookie in cookies:
                try:
                    del self._cookies[cookie]
                except KeyError:
                    pass
        else:
            self._cookies.clear()

    def all(self, verbose=False):
        cookies = {}
        for key, value in self._cookies.items():
            cookies[key] = value
        return cookies

    def __getitem__(self, item):
        return self._cookies[item].value

    def __eq__(self, other_object):
        if isinstance(other_object, dict):
            cookies_dict = dict([(key, morsel.value)
                                 for key, morsel in self._cookies.items()])
            return cookies_dict == other_object


class DjangoClient(DriverAPI):

    driver_name = "django"

    def __init__(self, user_agent=None, wait_time=2):
        from django.test.client import Client
        self.wait_time = wait_time
        self._browser = Client()
        self._history = []

        self._cookie_manager = CookieManager(self._browser.cookies)
        self._last_urls = []
        self._forms = {}

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        pass

    def _post_load(self):
        self._forms = {}
        try:
            del self._html
        except AttributeError:
            pass
        self.status_code = StatusCode(self._response.status_code, '')

    def visit(self, url):
        self._url = url
        self._response = self._browser.get(url, follow=True)
        self._last_urls.append(url)
        self._post_load()

    def submit(self, form):
        method = form.attrib['method']
        func_method = getattr(self._browser, method.lower())
        action = form.attrib['action']
        if action.strip() != '.':
            url = os.path.join(self._url, form.attrib['action'])
        else:
            url = self._url
        self._url = url
        data = dict(((k, v) for k, v in form.fields.items() if v is not None))
        for key in form.inputs.keys():
            input = form.inputs[key]
            if getattr(input, 'type', '') == 'file' and key in data:
                data[key] = open(data[key], 'rb')
        self._response = func_method(url, data, follow=True)
        self._post_load()
        return self._response

    def back(self):
        self._last_urls.insert(0, self.url)
        self.visit(self._last_urls[1])

    def forward(self):
        try:
            self.visit(self._last_urls.pop())
        except IndexError:
            pass

    def reload(self):
        self.visit(self._url)

    def quit(self):
        pass

    @property
    def htmltree(self):
        try:
            return self._html
        except AttributeError:
            self._html = lxml.html.fromstring(self.html.decode('utf-8'))
            return self._html

    @property
    def title(self):
        html = self.htmltree
        return html.xpath('//title')[0].text_content().strip().encode('utf-8')

    @property
    def html(self):
        return self._response.content

    @property
    def url(self):
        return self._url

    def find_option_by_value(self, value):
        html = self.htmltree
        element = html.xpath('//option[@value="%s"]' % value)[0]
        control = DjangoClientControlElement(element.getparent(), self)
        return ElementList([DjangoClientOptionElement(element, control)], find_by="value", query=value)

    def find_option_by_text(self, text):
        html = self.htmltree
        element = html.xpath('//option[normalize-space(text())="%s"]' % text)[0]
        control = DjangoClientControlElement(element.getparent(), self)
        return ElementList([DjangoClientOptionElement(element, control)], find_by="text", query=text)

    def find_by_css(self, selector):
        xpath = CSSSelector(selector).path
        return self.find_by_xpath(xpath, original_find="css", original_selector=selector)

    def find_by_xpath(self, xpath, original_find=None, original_selector=None):
        html = self.htmltree

        elements = []

        for xpath_element in html.xpath(xpath):
            if self._element_is_link(xpath_element):
                return self._find_links_by_xpath(xpath)
            elif self._element_is_control(xpath_element):
                elements.append((DjangoClientControlElement, xpath_element))
            else:
                elements.append((DjangoClientElement, xpath_element))

        find_by = original_find or "xpath"
        query = original_selector or xpath

        return ElementList([element_class(element, self) for element_class, element in elements], find_by=find_by, query=query)

    def find_by_tag(self, tag):
        return self.find_by_xpath('//%s' % tag, original_find="tag", original_selector=tag)

    def find_by_value(self, value):
        return self.find_by_xpath('//*[@value="%s"]' % value, original_find="value", original_selector=value)

    def find_by_id(self, id_value):
        return self.find_by_xpath('//*[@id="%s"][1]' % id_value, original_find="id", original_selector=id_value)

    def find_by_name(self, name):
        html = self.htmltree

        xpath = '//*[@name="%s"]' % name
        elements = []

        for xpath_element in html.xpath(xpath):
            elements.append(xpath_element)

        find_by = "name"
        query = xpath

        return ElementList([DjangoClientControlElement(element, self) for element in elements], find_by=find_by, query=query)

    def find_link_by_text(self, text):
        return self._find_links_by_xpath("//a[text()='%s']" % text)

    def find_link_by_href(self, href):
        return self._find_links_by_xpath("//a[@href='%s']" % href)

    def find_link_by_partial_href(self, partial_href):
        return self._find_links_by_xpath("//a[contains(@href, '%s')]" % partial_href)

    def find_link_by_partial_text(self, partial_text):
        return self._find_links_by_xpath("//a[contains(normalize-space(.), '%s')]" % partial_text)

    def fill(self, name, value):
        self.find_by_name(name=name).first.fill(value)

    def fill_form(self, field_values):
        for name, value in field_values.items():
            element = self.find_by_name(name)
            control = element.first._control
            control_type = control.get('type')
            if control_type == 'checkbox':
                if value:
                    control.value = value  # control.options
                else:
                    control.value = []
            elif control_type == 'radio':
                control.value = value  # [option for option in control.options if option == value]
            elif control_type == 'select':
                control.value = [value]
            else:
                # text, textarea, password, tel
                control.value = value

    def choose(self, name, value):
        self.find_by_name(name).first._control.value = value

    def check(self, name):
        control = self.find_by_name(name).first._control
        control.value = ['checked']

    def uncheck(self, name):
        control = self.find_by_name(name).first._control
        control.value = []

    def attach_file(self, name, file_path):
        control = self.find_by_name(name).first._control
        control.value = file_path

    def _find_links_by_xpath(self, xpath):
        html = self.htmltree
        links = html.xpath(xpath)
        return ElementList([DjangoClientLinkElement(link, self) for link in links], find_by="xpath", query=xpath)

    def select(self, name, value):
        self.find_by_name(name).first._control.value = value

    def is_text_present(self, text, wait_time=None):
        wait_time = wait_time or self.wait_time
        end_time = time.time() + wait_time

        while time.time() < end_time:
            if self._is_text_present(text):
                return True
        return False

    def _is_text_present(self, text):
        try:
            body = self.find_by_tag('body').first
            return text in body.text
        except ElementDoesNotExist:
            # This exception will be thrown if the body tag isn't present
            # This has occasionally been observed. Assume that the
            # page isn't fully loaded yet
            return False

    def is_text_not_present(self, text, wait_time=None):
        wait_time = wait_time or self.wait_time
        end_time = time.time() + wait_time

        while time.time() < end_time:
            if not self._is_text_present(text):
                return True
        return False

    def _element_is_link(self, element):
        return element.tag == 'a'

    def _element_is_control(self, element):
        return hasattr(element, 'type')

    @property
    def cookies(self):
        return self._cookie_manager


re_extract_inner_html = re.compile(r'^<[^<>]+>(.*)</[^<>]+>$')


class DjangoClientElement(ElementAPI):

    def __init__(self, element, parent):
        self._element = element
        self.parent = parent

    def __getitem__(self, attr):
        return self._element.attrib[attr]

    def find_by_css(self, selector):
        elements = self._element.cssselect(selector)
        return ElementList([self.__class__(element, self) for element in elements])

    def find_by_xpath(self, selector):
        elements = self._element.xpath(selector)
        return ElementList([self.__class__(element, self) for element in elements])

    def find_by_name(self, name):
        elements = self._element.cssselect('[name="%s"]' % name)
        return ElementList([self.__class__(element, self) for element in elements])

    def find_by_tag(self, name):
        elements = self._element.cssselect(name)
        return ElementList([self.__class__(element, self) for element in elements])

    def find_by_value(self, value):
        elements = self._element.cssselect('[value="%s"]' % value)
        return ElementList([self.__class__(element, self) for element in elements])

    def find_by_id(self, id):
        elements = self._element.cssselect('#%s' % id)
        return ElementList([self.__class__(element, self) for element in elements])

    @property
    def value(self):
        return self._element.text_content()

    @property
    def text(self):
        return self.value

    @property
    def outer_html(self):
        return lxml.html.tostring(self._element, encoding='unicode').strip()

    @property
    def html(self):
        return re_extract_inner_html.match(self.outer_html).group(1)

    def has_class(self, class_name):
        return len(self._element.find_class(class_name)) > 0


class DjangoClientLinkElement(DjangoClientElement):

    def __init__(self, element, parent):
        super(DjangoClientLinkElement, self).__init__(element, parent)
        self._browser = parent

    def __getitem__(self, attr):
        return super(DjangoClientLinkElement, self).__getitem__(attr)

    def click(self):
        return self._browser.visit(self["href"])


class DjangoClientControlElement(DjangoClientElement):

    def __init__(self, control, parent):
        self._control = control
        self.parent = parent

    def __getitem__(self, attr):
        return self._control.attrib[attr]

    @property
    def value(self):
        return self._control.value

    @property
    def checked(self):
        return bool(self._control.value)

    def click(self):
        parent_form = self._get_parent_form()
        return self.parent.submit(parent_form).content

    def fill(self, value):
        parent_form = self._get_parent_form()
        if sys.version_info[0] > 2:
            parent_form.fields[self['name']] = value
        else:
            parent_form.fields[self['name']] = value.decode('utf-8')

    def select(self, value):
        self._control.value = value

    def _get_parent_form(self):
        parent_form = next(self._control.iterancestors('form'))
        return self.parent._forms.setdefault(parent_form._name(), parent_form)


class DjangoClientOptionElement(DjangoClientElement):

    def __init__(self, control, parent):
        self._control = control
        self.parent = parent

    def __getitem__(self, attr):
        return self._control.attrib[attr]

    @property
    def text(self):
        return self._control.text

    @property
    def value(self):
        return self._control.attrib['value']

    @property
    def selected(self):
        return self.parent.value == self.value

########NEW FILE########
__FILENAME__ = flaskclient
# -*- coding: utf-8 -*-

# Copyright 2014 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

from __future__ import with_statement
import os.path
import re
import time
import sys

import lxml.html
from lxml.cssselect import CSSSelector
from splinter.cookie_manager import CookieManagerAPI
from splinter.driver import DriverAPI, ElementAPI
from splinter.element_list import ElementList
from splinter.exceptions import ElementDoesNotExist
from splinter.request_handler.status_code import StatusCode


class CookieManager(CookieManagerAPI):

    def __init__(self, browser_cookies):
        self._cookies = browser_cookies

    def add(self, cookies):
        if isinstance(cookies, list):
            for cookie in cookies:
                for key, value in cookie.items():
                    self._cookies.set_cookie('localhost', key, value)
                return
        for key, value in cookies.items():
            self._cookies.set_cookie('localhost', key, value)

    def delete(self, *cookies):
        if cookies:
            for cookie in cookies:
                try:
                    self._cookies.delete_cookie('localhost', cookie)
                except KeyError:
                    pass
        else:
            self._cookies.cookie_jar.clear()

    def all(self, verbose=False):
        cookies = {}
        for cookie in self._cookies.cookie_jar:
            cookies[cookie.name] = cookie.value
        return cookies

    def __getitem__(self, item):
        cookies = dict([(c.name, c) for c in self._cookies.cookie_jar])
        return cookies[item].value

    def __eq__(self, other_object):
        if isinstance(other_object, dict):
            cookies_dict = dict([(c.name, c.value)
                                 for c in self._cookies.cookie_jar])
            return cookies_dict == other_object


class FlaskClient(DriverAPI):

    driver_name = "flask"

    def __init__(self, app, user_agent=None, wait_time=2):
        self.wait_time = wait_time
        app.config['TESTING'] = True
        self._browser = app.test_client()
        self._history = []
        self._cookie_manager = CookieManager(self._browser)
        self._last_urls = []
        self._forms = {}

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        pass

    def _post_load(self):
        self._forms = {}
        try:
            del self._html
        except AttributeError:
            pass
        self.status_code = StatusCode(self._response.status_code, '')

    def visit(self, url):
        self._url = url
        self._response = self._browser.get(url, follow_redirects=True)
        self._last_urls.append(url)
        self._post_load()

    def submit(self, form):
        method = form.attrib['method']
        func_method = getattr(self._browser, method.lower())
        action = form.attrib['action']
        if action.strip() != '.':
            url = os.path.join(self._url, form.attrib['action'])
        else:
            url = self._url
        self._url = url
        data = dict(((k, v) for k, v in form.fields.items() if v is not None))
        for key in form.inputs.keys():
            input = form.inputs[key]
            if getattr(input, 'type', '') == 'file' and key in data:
                data[key] = open(data[key], 'rb')
        self._response = func_method(url, data=data, follow_redirects=True)
        self._post_load()
        return self._response

    def back(self):
        self._last_urls.insert(0, self.url)
        self.visit(self._last_urls[1])

    def forward(self):
        try:
            self.visit(self._last_urls.pop())
        except IndexError:
            pass

    def reload(self):
        self.visit(self._url)

    def quit(self):
        pass

    @property
    def htmltree(self):
        try:
            return self._html
        except AttributeError:
            self._html = lxml.html.fromstring(self.html.decode('utf-8'))
            return self._html

    @property
    def title(self):
        html = self.htmltree
        return html.xpath('//title')[0].text_content().strip().encode('utf-8')

    @property
    def html(self):
        return self._response.data

    @property
    def url(self):
        return self._url

    def find_option_by_value(self, value):
        html = self.htmltree
        element = html.xpath('//option[@value="%s"]' % value)[0]
        control = FlaskClientControlElement(element.getparent(), self)
        return ElementList([FlaskClientOptionElement(element, control)], find_by="value", query=value)

    def find_option_by_text(self, text):
        html = self.htmltree
        element = html.xpath('//option[normalize-space(text())="%s"]' % text)[0]
        control = FlaskClientControlElement(element.getparent(), self)
        return ElementList([FlaskClientOptionElement(element, control)], find_by="text", query=text)

    def find_by_css(self, selector):
        xpath = CSSSelector(selector).path
        return self.find_by_xpath(xpath, original_find="css", original_selector=selector)

    def find_by_xpath(self, xpath, original_find=None, original_selector=None):
        html = self.htmltree

        elements = []

        for xpath_element in html.xpath(xpath):
            if self._element_is_link(xpath_element):
                return self._find_links_by_xpath(xpath)
            elif self._element_is_control(xpath_element):
                elements.append((FlaskClientControlElement, xpath_element))
            else:
                elements.append((FlaskClientElement, xpath_element))

        find_by = original_find or "xpath"
        query = original_selector or xpath

        return ElementList([element_class(element, self) for element_class, element in elements], find_by=find_by, query=query)

    def find_by_tag(self, tag):
        return self.find_by_xpath('//%s' % tag, original_find="tag", original_selector=tag)

    def find_by_value(self, value):
        return self.find_by_xpath('//*[@value="%s"]' % value, original_find="value", original_selector=value)

    def find_by_id(self, id_value):
        return self.find_by_xpath('//*[@id="%s"][1]' % id_value, original_find="id", original_selector=id_value)

    def find_by_name(self, name):
        html = self.htmltree

        xpath = '//*[@name="%s"]' % name
        elements = []

        for xpath_element in html.xpath(xpath):
            elements.append(xpath_element)

        find_by = "name"
        query = xpath

        return ElementList([FlaskClientControlElement(element, self) for element in elements], find_by=find_by, query=query)

    def find_link_by_text(self, text):
        return self._find_links_by_xpath("//a[text()='%s']" % text)

    def find_link_by_href(self, href):
        return self._find_links_by_xpath("//a[@href='%s']" % href)

    def find_link_by_partial_href(self, partial_href):
        return self._find_links_by_xpath("//a[contains(@href, '%s')]" % partial_href)

    def find_link_by_partial_text(self, partial_text):
        return self._find_links_by_xpath("//a[contains(normalize-space(.), '%s')]" % partial_text)

    def fill(self, name, value):
        self.find_by_name(name=name).first.fill(value)

    def fill_form(self, field_values):
        for name, value in field_values.items():
            element = self.find_by_name(name)
            control = element.first._control
            control_type = control.get('type')
            if control_type == 'checkbox':
                if value:
                    control.value = value  # control.options
                else:
                    control.value = []
            elif control_type == 'radio':
                control.value = value  # [option for option in control.options if option == value]
            elif control_type == 'select':
                control.value = [value]
            else:
                # text, textarea, password, tel
                control.value = value

    def choose(self, name, value):
        self.find_by_name(name).first._control.value = value

    def check(self, name):
        control = self.find_by_name(name).first._control
        control.value = ['checked']

    def uncheck(self, name):
        control = self.find_by_name(name).first._control
        control.value = []

    def attach_file(self, name, file_path):
        control = self.find_by_name(name).first._control
        control.value = file_path

    def _find_links_by_xpath(self, xpath):
        html = self.htmltree
        links = html.xpath(xpath)
        return ElementList([FlaskClientLinkElement(link, self) for link in links], find_by="xpath", query=xpath)

    def select(self, name, value):
        self.find_by_name(name).first._control.value = value

    def is_text_present(self, text, wait_time=None):
        wait_time = wait_time or self.wait_time
        end_time = time.time() + wait_time

        while time.time() < end_time:
            if self._is_text_present(text):
                return True
        return False

    def _is_text_present(self, text):
        try:
            body = self.find_by_tag('body').first
            return text in body.text
        except ElementDoesNotExist:
            # This exception will be thrown if the body tag isn't present
            # This has occasionally been observed. Assume that the
            # page isn't fully loaded yet
            return False

    def is_text_not_present(self, text, wait_time=None):
        wait_time = wait_time or self.wait_time
        end_time = time.time() + wait_time

        while time.time() < end_time:
            if not self._is_text_present(text):
                return True
        return False

    def _element_is_link(self, element):
        return element.tag == 'a'

    def _element_is_control(self, element):
        return hasattr(element, 'type')

    @property
    def cookies(self):
        return self._cookie_manager


re_extract_inner_html = re.compile(r'^<[^<>]+>(.*)</[^<>]+>$')


class FlaskClientElement(ElementAPI):

    def __init__(self, element, parent):
        self._element = element
        self.parent = parent

    def __getitem__(self, attr):
        return self._element.attrib[attr]

    def find_by_css(self, selector):
        elements = self._element.cssselect(selector)
        return ElementList([self.__class__(element, self) for element in elements])

    def find_by_xpath(self, selector):
        elements = self._element.xpath(selector)
        return ElementList([self.__class__(element, self) for element in elements])

    def find_by_name(self, name):
        elements = self._element.cssselect('[name="%s"]' % name)
        return ElementList([self.__class__(element, self) for element in elements])

    def find_by_tag(self, name):
        elements = self._element.cssselect(name)
        return ElementList([self.__class__(element, self) for element in elements])

    def find_by_value(self, value):
        elements = self._element.cssselect('[value="%s"]' % value)
        return ElementList([self.__class__(element, self) for element in elements])

    def find_by_id(self, id):
        elements = self._element.cssselect('#%s' % id)
        return ElementList([self.__class__(element, self) for element in elements])

    @property
    def value(self):
        return self._element.text_content()

    @property
    def text(self):
        return self.value

    @property
    def outer_html(self):
        return lxml.html.tostring(self._element, encoding='unicode').strip()

    @property
    def html(self):
        return re_extract_inner_html.match(self.outer_html).group(1)

    def has_class(self, class_name):
        return len(self._element.find_class(class_name)) > 0


class FlaskClientLinkElement(FlaskClientElement):

    def __init__(self, element, parent):
        super(FlaskClientLinkElement, self).__init__(element, parent)
        self._browser = parent

    def __getitem__(self, attr):
        return super(FlaskClientLinkElement, self).__getitem__(attr)

    def click(self):
        return self._browser.visit(self["href"])


class FlaskClientControlElement(FlaskClientElement):

    def __init__(self, control, parent):
        self._control = control
        self.parent = parent

    def __getitem__(self, attr):
        return self._control.attrib[attr]

    @property
    def value(self):
        return self._control.value

    @property
    def checked(self):
        return bool(self._control.value)

    def click(self):
        parent_form = self._get_parent_form()
        return self.parent.submit(parent_form).data

    def fill(self, value):
        parent_form = self._get_parent_form()
        if sys.version_info[0] > 2:
            parent_form.fields[self['name']] = value
        else:
            parent_form.fields[self['name']] = value.decode('utf-8')

    def select(self, value):
        self._control.value = value

    def _get_parent_form(self):
        parent_form = next(self._control.iterancestors('form'))
        return self.parent._forms.setdefault(parent_form._name(), parent_form)


class FlaskClientOptionElement(FlaskClientElement):

    def __init__(self, control, parent):
        self._control = control
        self.parent = parent

    def __getitem__(self, attr):
        return self._control.attrib[attr]

    @property
    def text(self):
        return self._control.text

    @property
    def value(self):
        return self._control.attrib['value']

    @property
    def selected(self):
        return self.parent.value == self.value

########NEW FILE########
__FILENAME__ = chrome
# -*- coding: utf-8 -*-

# Copyright 2012 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

from selenium.webdriver import Chrome
from selenium.webdriver.chrome.options import Options
from splinter.driver.webdriver import BaseWebDriver, WebDriverElement
from splinter.driver.webdriver.cookie_manager import CookieManager


class WebDriver(BaseWebDriver):

    driver_name = "Chrome"

    def __init__(self, user_agent=None, wait_time=2, fullscreen=False,
                 **kwargs):

        options = Options()

        if user_agent is not None:
            options.add_argument("--user-agent=" + user_agent)

        if fullscreen:
            options.add_argument('--kiosk')

        self.driver = Chrome(chrome_options=options, **kwargs)

        self.element_class = WebDriverElement

        self._cookie_manager = CookieManager(self.driver)

        super(WebDriver, self).__init__(wait_time)

########NEW FILE########
__FILENAME__ = cookie_manager
# -*- coding: utf-8 -*-

# Copyright 2012 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.
import sys

if sys.version_info[0] > 2:
    from urllib.parse import urlparse
else:
    from urlparse import urlparse  # NOQA
from splinter.cookie_manager import CookieManagerAPI


class CookieManager(CookieManagerAPI):

    def __init__(self, driver):
        self.driver = driver

    def add(self, cookies):
        if isinstance(cookies, list):
            for cookie in cookies:
                for key, value in cookie.items():
                    self.driver.add_cookie({'name': key, 'value': value})
                return
        for key, value in cookies.items():
            self.driver.add_cookie({'name': key, 'value': value})

    def delete(self, *cookies):
        if cookies:
            for cookie in cookies:
                self.driver.delete_cookie(cookie)
        else:
            self.driver.delete_all_cookies()

    def all(self, verbose=False):
        if not verbose:
            cleaned_cookies = {}
            cookies = self.driver.get_cookies()
            for cookie in cookies:
                cookie_domain = cookie['domain'] if not cookie['domain'].startswith('.') else cookie['domain'][1:]
                if cookie_domain in urlparse(self.driver.current_url).netloc:
                    cleaned_cookies[cookie['name']] = cookie['value']
            return cleaned_cookies
        return self.driver.get_cookies()

    def __getitem__(self, item):
        return self.driver.get_cookie(item)['value']

    def __eq__(self, other_object):
        cookies = {}
        for cookie in self.driver.get_cookies():
            cookies[cookie['name']] = cookie['value']

        if isinstance(other_object, dict):
            return dict(cookies) == other_object

########NEW FILE########
__FILENAME__ = firefox
# -*- coding: utf-8 -*-

# Copyright 2012 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

from selenium.webdriver import Firefox
from selenium.webdriver.firefox.firefox_profile import FirefoxProfile
from splinter.driver.webdriver import BaseWebDriver, WebDriverElement as WebDriverElement
from splinter.driver.webdriver.cookie_manager import CookieManager


class WebDriver(BaseWebDriver):

    driver_name = "Firefox"

    def __init__(self, profile=None, extensions=None, user_agent=None, profile_preferences=None, wait_time=2):
        firefox_profile = FirefoxProfile(profile)
        firefox_profile.set_preference('extensions.logging.enabled', False)
        firefox_profile.set_preference('network.dns.disableIPv6', False)

        if user_agent is not None:
            firefox_profile.set_preference('general.useragent.override', user_agent)

        if profile_preferences:
            for key, value in profile_preferences.items():
                firefox_profile.set_preference(key, value)

        if extensions:
            for extension in extensions:
                firefox_profile.add_extension(extension)

        self.driver = Firefox(firefox_profile)

        self.element_class = WebDriverElement

        self._cookie_manager = CookieManager(self.driver)

        super(WebDriver, self).__init__(wait_time)

########NEW FILE########
__FILENAME__ = phantomjs
from selenium.webdriver import PhantomJS, DesiredCapabilities
from splinter.driver.webdriver import (BaseWebDriver,
                                       WebDriverElement as BaseWebDriverElement)
from splinter.driver.webdriver.cookie_manager import CookieManager


class WebDriverElement(BaseWebDriverElement):
    def right_click(self):
        raise NotImplementedError('Not supported by webdriver.')

    def double_click(self):
        raise NotImplementedError('Not supported by webdriver.')


class WebDriver(BaseWebDriver):
    driver_name = "PhantomJS"
    element_class = WebDriverElement

    def __init__(self, user_agent=None, load_images=True,
                 desired_capabilities=None, wait_time=2,
                 custom_headers={}, **kwargs):
        capabilities = DesiredCapabilities.PHANTOMJS.copy()
        if user_agent is not None:
            capabilities['phantomjs.page.settings.userAgent'] = user_agent
        capabilities['phantomjs.page.settings.loadImages'] = load_images
        if isinstance(custom_headers, dict):
            for name, value in custom_headers.items():
                capabilities['phantomjs.page.customHeaders.%s' % name] = value
        if desired_capabilities:
            capabilities.update(desired_capabilities)

        self.driver = PhantomJS(desired_capabilities=capabilities, **kwargs)

        self._cookie_manager = CookieManager(self.driver)

        super(WebDriver, self).__init__(wait_time)

    def get_alert(self):
        raise NotImplementedError('Currently not implemented by ghostdriver.')

########NEW FILE########
__FILENAME__ = remote
# -*- coding: utf-8 -*-

# Copyright 2013 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

from selenium.webdriver import Remote
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities
from splinter.driver.webdriver import BaseWebDriver, WebDriverElement as BaseWebDriverElement
from splinter.cookie_manager import CookieManagerAPI


class WebDriver(BaseWebDriver):

    driver_name = "Remote webdriver"
    # TODO: This constant belongs in selenium.webdriver.Remote
    DEFAULT_URL = 'http://127.0.0.1:4444/wd/hub'

    def __init__(self, url=DEFAULT_URL, browser='firefox', wait_time=2, **ability_args):
        browsername = browser.upper()
        # Handle case where user specifies IE with a space in it
        if browsername == 'INTERNET EXPLORER':
            browsername = 'INTERNETEXPLORER'
        abilities = getattr(DesiredCapabilities, browsername, {})
        abilities.update(ability_args)
        self.driver = Remote(url, abilities)

        self.element_class = WebDriverElement

        self._cookie_manager = CookieManagerAPI()

        super(WebDriver, self).__init__(wait_time)


class WebDriverElement(BaseWebDriverElement):

    def mouse_over(self):
        """
        Remote Firefox doesn't support mouseover.
        """
        raise NotImplementedError("Remote Firefox doesn't support mouse over")

    def mouse_out(self):
        """
        Remote Firefox doesn't support mouseout.
        """
        raise NotImplementedError("Remote Firefox doesn't support mouseout")

    def double_click(self):
        """
        Remote Firefox doesn't support doubleclick.
        """
        raise NotImplementedError("Remote Firefox doesn't support doubleclick")

    def right_click(self):
        """
        Remote Firefox doesn't support right click'
        """
        raise NotImplementedError("Remote Firefox doesn't support right click")

    def drag_and_drop(self, droppable):
        """
        Remote Firefox doesn't support drag and drop
        """
        raise NotImplementedError("Remote Firefox doesn't support drag an drop")

    mouseover = mouse_over
    mouseout = mouse_out

########NEW FILE########
__FILENAME__ = zopetestbrowser
# -*- coding: utf-8 -*-

# Copyright 2012 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

import re

from lxml.cssselect import CSSSelector
from zope.testbrowser.browser import Browser
from splinter.element_list import ElementList
from splinter.exceptions import ElementDoesNotExist
from splinter.driver import DriverAPI, ElementAPI
from splinter.cookie_manager import CookieManagerAPI

import mimetypes
import lxml.html
import mechanize
import time


class CookieManager(CookieManagerAPI):

    def __init__(self, browser_cookies):
        self._cookies = browser_cookies

    def add(self, cookies):
        if isinstance(cookies, list):
            for cookie in cookies:
                for key, value in cookie.items():
                    self._cookies[key] = value
                return
        for key, value in cookies.items():
            self._cookies[key] = value

    def delete(self, *cookies):
        if cookies:
            for cookie in cookies:
                try:
                    del self._cookies[cookie]
                except KeyError:
                    pass
        else:
            self._cookies.clearAll()

    def all(self, verbose=False):
        cookies = {}
        for key, value in self._cookies.items():
            cookies[key] = value
        return cookies

    def __getitem__(self, item):
        return self._cookies[item]

    def __eq__(self, other_object):
        if isinstance(other_object, dict):
            return dict(self._cookies) == other_object


class ZopeTestBrowser(DriverAPI):

    driver_name = "zope.testbrowser"

    def __init__(self, user_agent=None, wait_time=2):
        self.wait_time = wait_time
        mech_browser = self._get_mech_browser(user_agent)
        self._browser = Browser(mech_browser=mech_browser)

        self._cookie_manager = CookieManager(self._browser.cookies)
        self._last_urls = []

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        pass

    def visit(self, url):
        self._browser.open(url)

    def back(self):
        self._last_urls.insert(0, self.url)
        self._browser.goBack()

    def forward(self):
        try:
            self.visit(self._last_urls.pop())
        except IndexError:
            pass

    def reload(self):
        self._browser.reload()

    def quit(self):
        pass

    @property
    def htmltree(self):
        return lxml.html.fromstring(self.html.decode('utf-8'))

    @property
    def title(self):
        return self._browser.title

    @property
    def html(self):
        return self._browser.contents

    @property
    def url(self):
        return self._browser.url

    def find_option_by_value(self, value):
        html = self.htmltree
        element = html.xpath('//option[@value="%s"]' % value)[0]
        control = self._browser.getControl(element.text)
        return ElementList([ZopeTestBrowserOptionElement(control, self)], find_by="value", query=value)

    def find_option_by_text(self, text):
        html = self.htmltree
        element = html.xpath('//option[normalize-space(text())="%s"]' % text)[0]
        control = self._browser.getControl(element.text)
        return ElementList([ZopeTestBrowserOptionElement(control, self)], find_by="text", query=text)

    def find_by_css(self, selector):
        xpath = CSSSelector(selector).path
        return self.find_by_xpath(xpath, original_find="css", original_selector=selector)

    def find_by_xpath(self, xpath, original_find=None, original_selector=None):
        html = self.htmltree

        elements = []

        for xpath_element in html.xpath(xpath):
            if self._element_is_link(xpath_element):
                return self._find_links_by_xpath(xpath)
            elif self._element_is_control(xpath_element):
                return self.find_by_name(xpath_element.name)
            else:
                elements.append(xpath_element)

        find_by = original_find or "xpath"
        query = original_selector or xpath

        return ElementList([ZopeTestBrowserElement(element, self) for element in elements], find_by=find_by, query=query)

    def find_by_tag(self, tag):
        return self.find_by_xpath('//%s' % tag, original_find="tag", original_selector=tag)

    def find_by_value(self, value):
        return self.find_by_xpath('//*[@value="%s"]' % value, original_find="value", original_selector=value)

    def find_by_id(self, id_value):
        return self.find_by_xpath('//*[@id="%s"][1]' % id_value, original_find="id", original_selector=id_value)

    def find_by_name(self, name):
        elements = []
        index = 0

        while True:
            try:
                control = self._browser.getControl(name=name, index=index)
                elements.append(control)
                index += 1
            except LookupError:
                break
        return ElementList([ZopeTestBrowserControlElement(element, self) for element in elements], find_by="name", query=name)

    def find_link_by_text(self, text):
        return self._find_links_by_xpath("//a[text()='%s']" % text)

    def find_link_by_href(self, href):
        return self._find_links_by_xpath("//a[@href='%s']" % href)

    def find_link_by_partial_href(self, partial_href):
        return self._find_links_by_xpath("//a[contains(@href, '%s')]" % partial_href)

    def find_link_by_partial_text(self, partial_text):
        return self._find_links_by_xpath("//a[contains(normalize-space(.), '%s')]" % partial_text)

    def fill(self, name, value):
        self.find_by_name(name=name).first._control.value = value

    def fill_form(self, field_values):
        for name, value in field_values.items():
            element = self.find_by_name(name)
            control = element.first._control
            if control.type == 'checkbox':
                if value:
                    control.value = control.options
                else:
                    control.value = []
            elif control.type == 'radio':
                control.value = [option for option in control.options if option == value]
            elif control.type == 'select':
                control.value = [value]
            else:
                # text, textarea, password, tel
                control.value = value

    def choose(self, name, value):
        control = self._browser.getControl(name=name)
        control.value = [option for option in control.options if option == value]

    def check(self, name):
        control = self._browser.getControl(name=name)
        control.value = control.options

    def uncheck(self, name):
        control = self._browser.getControl(name=name)
        control.value = []

    def attach_file(self, name, file_path):
        filename = file_path.split('/')[-1]
        control = self._browser.getControl(name=name)
        content_type, _ = mimetypes.guess_type(file_path)
        control.add_file(open(file_path), content_type, filename)

    def _find_links_by_xpath(self, xpath):
        html = self.htmltree
        links = html.xpath(xpath)
        return ElementList([ZopeTestBrowserLinkElement(link, self) for link in links], find_by="xpath", query=xpath)

    def select(self, name, value):
        self.find_by_name(name).first._control.value = [value]

    def is_text_present(self, text, wait_time=None):
        wait_time = wait_time or self.wait_time
        end_time = time.time() + wait_time

        while time.time() < end_time:
            if self._is_text_present(text):
                return True
        return False

    def _is_text_present(self, text):
        try:
            body = self.find_by_tag('body').first
            return text in body.text
        except ElementDoesNotExist:
            # This exception will be thrown if the body tag isn't present
            # This has occasionally been observed. Assume that the
            # page isn't fully loaded yet
            return False

    def is_text_not_present(self, text, wait_time=None):
        wait_time = wait_time or self.wait_time
        end_time = time.time() + wait_time

        while time.time() < end_time:
            if not self._is_text_present(text):
                return True
        return False

    def _element_is_link(self, element):
        return element.tag == 'a'

    def _element_is_control(self, element):
        return hasattr(element, 'type')

    def _get_mech_browser(self, user_agent):
        mech_browser = mechanize.Browser()
        if user_agent is not None:
            mech_browser.addheaders = [("User-agent", user_agent), ]
        return mech_browser

    @property
    def cookies(self):
        return self._cookie_manager


re_extract_inner_html = re.compile(r'^<[^<>]+>(.*)</[^<>]+>$')


class ZopeTestBrowserElement(ElementAPI):

    def __init__(self, element, parent):
        self._element = element
        self.parent = parent

    def __getitem__(self, attr):
        return self._element.attrib[attr]

    def find_by_css(self, selector):
        elements = self._element.cssselect(selector)
        return ElementList([self.__class__(element, self) for element in elements])

    def find_by_xpath(self, selector):
        elements = self._element.xpath(selector)
        return ElementList([self.__class__(element, self) for element in elements])

    def find_by_name(self, name):
        elements = self._element.cssselect('[name="%s"]' % name)
        return ElementList([self.__class__(element, self) for element in elements])

    def find_by_tag(self, name):
        elements = self._element.cssselect(name)
        return ElementList([self.__class__(element, self) for element in elements])

    def find_by_value(self, value):
        elements = self._element.cssselect('[value="%s"]' % value)
        return ElementList([self.__class__(element, self) for element in elements])

    def find_by_id(self, id):
        elements = self._element.cssselect('#%s' % id)
        return ElementList([self.__class__(element, self) for element in elements])

    @property
    def value(self):
        return self._element.text_content()

    @property
    def text(self):
        return self.value

    @property
    def outer_html(self):
        return lxml.html.tostring(self._element, encoding='unicode').strip()

    @property
    def html(self):
        return re_extract_inner_html.match(self.outer_html).group(1)

    def has_class(self, class_name):
        return len(self._element.find_class(class_name)) > 0


class ZopeTestBrowserLinkElement(ZopeTestBrowserElement):

    def __init__(self, element, parent):
        super(ZopeTestBrowserLinkElement, self).__init__(element, parent)
        self._browser = parent._browser

    def __getitem__(self, attr):
        return super(ZopeTestBrowserLinkElement, self).__getitem__(attr)

    def click(self):
        return self._browser.open(self["href"])


class ZopeTestBrowserControlElement(ZopeTestBrowserElement):

    def __init__(self, control, parent):
        self._control = control
        self.parent = parent

    def __getitem__(self, attr):
        return self._control.mech_control.attrs[attr]

    @property
    def value(self):
        return self._control.value

    @property
    def checked(self):
        return bool(self._control.value)

    def click(self):
        return self._control.click()

    def fill(self, value):
        self._control.value = value

    def select(self, value):
        self._control.value = [value]

class ZopeTestBrowserOptionElement(ZopeTestBrowserElement):

    def __init__(self, control, parent):
        self._control = control
        self.parent = parent

    def __getitem__(self, attr):
        return self._control.mech_item.attrs[attr]

    @property
    def text(self):
        return self._control.mech_item.get_labels()[0]._text

    @property
    def value(self):
        return self._control.optionValue

    @property
    def selected(self):
        return self._control.mech_item._selected

########NEW FILE########
__FILENAME__ = element_list
# -*- coding: utf-8 -*-

# Copyright 2012 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

from splinter.exceptions import ElementDoesNotExist


class ElementList(list):
    """
    List of elements. Each member of the list is (usually) an instance
    of :class:`ElementAPI <splinter.driver.ElementAPI>`.

    Beyond the traditional list methods, the ``ElementList`` provides some
    other methods, listed below.

    There is a peculiar behavior on ElementList: you never get an
    ``IndexError``. Instead, you can an :class:`ElementDoesNotExist
    <splinter.exceptions.ElementDoesNotExist>` exception when trying to
    access an inexistent item in the list:

        >>> element_list = ElementList([])
        >>> element_list[0] # raises ElementDoesNotExist
    """

    def __init__(self, list, driver=None, find_by=None, query=None):
        """
        Creates the list.
        """
        self.extend(list)
        self.driver = driver
        self.find_by = find_by
        self.query = query

    def __getitem__(self, index):
        if not isinstance(index, int):
            return self.first[index]
        try:
            return super(ElementList, self).__getitem__(index)
        except IndexError:
            raise ElementDoesNotExist(
                u'no elements could be found with {0} "{1}"'.format(
                    self.find_by, self.query))

    @property
    def first(self):
        """
        An alias to the first element of the list:

            >>> assert element_list[0] == element_list.first
        """
        return self[0]

    @property
    def last(self):
        """
        An alias to the last element of the list:

            >>> assert element_list[-1] == element_list.last
        """
        return self[-1]

    def is_empty(self):
        """
        Returns ``True`` if the list is empty.
        """
        return len(self) == 0

    def __getattr__(self, name):
        try:
            return getattr(self.first, name)
        except (ElementDoesNotExist, AttributeError):
            raise AttributeError(u"'{0}' object has no attribute '{1}'".format(
                self.__class__.__name__, name))

########NEW FILE########
__FILENAME__ = exceptions
# -*- coding: utf-8 -*-

# Copyright 2012 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.


class DriverNotFoundError(Exception):
    """
    Exception raised when a driver is not found.

    Example:

        >>> from splinter import Browser
        >>> b = Browser('unknown driver') # raises DriverNotFoundError
    """
    pass


class ElementDoesNotExist(Exception):
    """
    Exception raised when an element is not found in the page.

    The exception is raised only when someone tries to access the element,
    not when the driver is finding it.

    Example:

        >>> elements = browser.find_by_id('unknown-id') # returns an empty list
        >>> elements[0] # raises ElementDoesNotExist
    """
    pass

########NEW FILE########
__FILENAME__ = meta
# -*- coding: utf-8 -*-

# Copyright 2012 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.


class InheritedDocs(type):

    def __new__(mcs, class_name, bases, dict):
        items_to_patch = [(k, v) for k, v in dict.items()
                          if not k.startswith('__') and not v.__doc__]
        for name, obj in items_to_patch:
            doc = None
            for base in bases:
                if hasattr(base, name):
                    doc = getattr(base, name).__doc__

                    if doc:
                        if type(obj) == type(property()) and not obj.fset:
                            obj.fget.__doc__ = doc
                            dict[name] = property(fget=obj.fget)
                        else:
                            obj.__doc__ = doc
                        break

        return type.__new__(mcs, class_name, bases, dict)

########NEW FILE########
__FILENAME__ = request_handler
# -*- coding: utf-8 -*-

# Copyright 2013 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.
import sys

if sys.version_info[0] > 2:
    from http import client as http_client
    from urllib.parse import urlparse
else:
    import httplib as http_client  # NOQA
    from urlparse import urlparse  # NOQA
import base64
from .status_code import StatusCode


class RequestHandler(object):

    def connect(self, url):
        if not (url.startswith("file:") or url.startswith("about:")):
            self.request_url = url
            self._create_connection()
            self._store_response()
            self.conn.close()
        else:
            self.status_code = StatusCode(200, 'Ok')

    def ensure_success_response(self):
        """
        Guarantee the success on response.

        If response is not success, raises an
        :class:`HttpResponseError <splinter.request_handler.status_code.HttpResponseError>`
        exception.
        """
        self.status_code.is_valid_response()

    def _store_response(self):
        self.response = self.conn.getresponse()
        self.status_code = StatusCode(self.response.status, self.response.reason)

    def _create_connection(self):
        self._parse_url()
        if self.scheme == 'https':
            self.conn = http_client.HTTPSConnection(self.host, self.port)
        else:
            self.conn = http_client.HTTPConnection(self.host, self.port)
        self.conn.putrequest('GET', self.path)
        self.conn.putheader('User-agent', 'python/splinter')
        if self.auth:
            self.conn.putheader("Authorization", "Basic %s" % self.auth)
        self.conn.endheaders()

    def _parse_url(self):
        parsed_url = urlparse(self.request_url)
        if parsed_url.username and parsed_url.password:
            login = '%s:%s' % (parsed_url.username, parsed_url.password)
            if sys.version_info[0] > 2:
                self.auth = base64.standard_b64encode(login.encode('utf-8')).decode("utf-8")
            else:
                self.auth = base64.standard_b64encode(login)
        else:
            self.auth = None
        self.host = parsed_url.hostname
        self.port = parsed_url.port
        self.path = parsed_url.path
        self.scheme = parsed_url.scheme
        if parsed_url.query:
            self.path = parsed_url.path + "?" + parsed_url.query

########NEW FILE########
__FILENAME__ = status_code
# -*- coding: utf-8 -*-

# Copyright 2012 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.


class HttpResponseError(Exception):
    """
    Represents an HTTP response error.
    """

    def __init__(self, code, reason):
        #: Number representing the error (example: 404)
        self.status_code = code

        #: Reason of the fail (example: "Not found")
        self.reason = reason.title()

        #: A message for the error (example: "404 - Not found")
        self.msg = "%s - %s" % (self.status_code, self.reason)

    def __str__(self):
        return self.msg


class StatusCode(object):

    http_errors = (400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411,
                   412, 413, 414, 415, 416, 417, 500, 501, 502, 503, 504, 505)

    def __init__(self, status_code, reason):
        #: A message for the response (example: Success)
        self.reason = reason
        #: Code of the response (example: 200)
        self.code = status_code

    def __eq__(self, other):
        return self.code == other

    def __str__(self):
        return "%s - %s" % (self.code, self.reason)

    def is_valid_response(self):
        """
        Returns ``True`` if the response is valid (:attr:`code` < 400).

        Otherwise, raises an :class:`HttpResponseError <splinter.request_handler.status_code.HttpResponseError>`
        exception.
        """
        if self.code in self.http_errors:
            raise HttpResponseError(self.code, self.reason)
        return True

    def is_success(self):
        """
        Returns ``True`` if the response was succeed, otherwise, returns ``False``.
        """
        if self.code not in self.http_errors:
            return True
        return False

########NEW FILE########
__FILENAME__ = utils
import warnings


def warn_deprecated(method, deprecated_method_name):
    def deprecated_method(*args, **kwargs):
        warnings.warn("'%s' is deprecated, use '%s' instead." % (deprecated_method_name, method.__name__), DeprecationWarning, stacklevel=2)
        return method(*args, **kwargs)
    return deprecated_method

########NEW FILE########
__FILENAME__ = async_finder
# -*- coding: utf-8 -*-

# Copyright 2012 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.


class AsyncFinderTests(object):

    def test_find_by_css_should_found_an_async_element(self):
        "should find element by css found an async element"
        self.browser.find_by_css('.add-async-element').click()
        assert 1 == len(self.browser.find_by_css('.async-element'))

    def test_find_by_xpath_should_found_an_async_element(self):
        "should find by xpath found an async element"
        self.browser.find_by_css('.add-async-element').click()
        assert 1 == len(self.browser.find_by_xpath('//h4'))

    def test_find_by_tag_should_found_an_async_element(self):
        "should find by tag found an async element"
        self.browser.find_by_css('.add-async-element').click()
        assert 1 == len(self.browser.find_by_tag('h4'))

    def test_find_by_id_should_found_an_async_element(self):
        "should find by id found an async element"
        self.browser.find_by_css('.add-async-element').click()
        assert 1 == len(self.browser.find_by_id('async-header'))

    def test_find_by_name_should_found_an_async_element(self):
        "should find by name found an async element"
        self.browser.find_by_css('.add-async-element').click()
        assert 1 == len(self.browser.find_by_name('async-input'))

    def test_find_by_value_should_found_an_async_element(self):
        "should find by value found an async element"
        self.browser.find_by_css('.add-async-element').click()
        assert 1 == len(self.browser.find_by_value('async-header-value'))

########NEW FILE########
__FILENAME__ = base
# -*- coding: utf-8 -*-

# Copyright 2012 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

from .async_finder import AsyncFinderTests
from .click_elements import ClickElementsTest
from .cookies import CookiesTest
from .element_does_not_exist import ElementDoestNotExistTest
from .fake_webapp import EXAMPLE_APP
from .find_elements import FindElementsTest
from .form_elements import FormElementsTest
from .iframes import IFrameElementsTest
from .element import ElementTest
from .is_element_present import IsElementPresentTest
from .is_text_present import IsTextPresentTest
from .mouse_interaction import MouseInteractionTest
from .status_code import StatusCodeTest
from .screenshot import ScreenshotTest
from .type import SlowlyTypeTest
from .popups import PopupWindowsTest


class BaseBrowserTests(ElementTest, FindElementsTest, FormElementsTest, ClickElementsTest, CookiesTest, SlowlyTypeTest, IsTextPresentTest):

    def setUp(self):
        self.fail("You should set up your browser in the setUp() method")

    def test_can_open_page(self):
        "should be able to visit, get title and quit"
        title = self.browser.title
        self.assertEqual(b'Example Title', title)

    def test_can_back_on_history(self):
        "should be able to back on history"
        self.browser.visit("%s/iframe" % EXAMPLE_APP.rstrip('/'))
        self.browser.back()
        self.assertEqual(EXAMPLE_APP, self.browser.url)

    def test_can_forward_on_history(self):
        "should be able to forward history"
        url = "%s/iframe" % EXAMPLE_APP.rstrip('/')
        self.browser.visit(url)
        self.browser.back()
        self.browser.forward()
        self.assertEqual(url, self.browser.url)

    def test_should_have_html(self):
        "should have access to the html"
        html = self.browser.html
        assert b'<title>Example Title</title>' in html
        assert b'<h1 id="firstheader">Example Header</h1>' in html

    def test_should_reload_a_page(self):
        "should reload a page"
        title = self.browser.title
        self.browser.reload()
        self.assertEqual(b'Example Title', title)

    def test_should_have_url(self):
        "should have access to the url"
        self.assertEqual(EXAMPLE_APP, self.browser.url)

    def test_accessing_attributes_of_links(self):
        "should allow link's attributes retrieval"
        foo = self.browser.find_link_by_text('FOO')
        self.assertEqual('http://localhost:5000/foo', foo['href'])

    def test_accessing_attributes_of_inputs(self):
        "should allow input's attributes retrieval"
        button = self.browser.find_by_css('input[name="send"]')
        self.assertEqual('send', button['name'])

    def test_accessing_attributes_of_simple_elements(self):
        "should allow simple element's attributes retrieval"
        header = self.browser.find_by_css('h1')
        self.assertEqual('firstheader', header['id'])

    def test_links_should_have_value_attribute(self):
        foo = self.browser.find_link_by_href('http://localhost:5000/foo')
        self.assertEqual('FOO', foo.value)

    def test_should_receive_browser_on_parent(self):
        "element should contains the browser on \"parent\" attribute"
        element = self.browser.find_by_id("firstheader")
        self.assertEqual(self.browser, element.parent)


class WebDriverTests(BaseBrowserTests, IFrameElementsTest, ElementDoestNotExistTest, IsElementPresentTest, AsyncFinderTests, StatusCodeTest, MouseInteractionTest, PopupWindowsTest, ScreenshotTest):

    def test_can_execute_javascript(self):
        "should be able to execute javascript"
        self.browser.execute_script("$('body').empty()")
        self.assertEqual("", self.browser.find_by_tag("body").value)

    def test_can_evaluate_script(self):
        "should evaluate script"
        self.assertEqual(8, self.browser.evaluate_script("4+4"))

    def test_can_see_the_text_for_an_element(self):
        "should provide text for an element"
        self.assertEqual(self.browser.find_by_id("simple_text").text, "my test text")

    def test_the_text_for_an_element_strips_html_tags(self):
        "should show that the text attribute strips html"
        self.assertEqual(self.browser.find_by_id("text_with_html").text, "another bit of text")

    def test_can_verify_if_a_element_is_visible(self):
        "should provide verify if element is visible"
        self.assertTrue(self.browser.find_by_id("visible").visible)

    def test_can_verify_if_a_element_is_invisible(self):
        "should provide verify if element is invisible"
        self.assertFalse(self.browser.find_by_id("invisible").visible)

    def test_default_wait_time_should_be_2(self):
        "should driver default wait time 2"
        self.assertEqual(2, self.browser.wait_time)

    def test_access_alerts_and_accept_them(self):
        self.browser.visit(EXAMPLE_APP + 'alert')
        self.browser.find_by_tag('h1').click()
        alert = self.browser.get_alert()
        self.assertEqual('This is an alert example.', alert.text)
        alert.accept()

    def test_access_prompts_and_be_able_to_fill_then(self):
        self.browser.visit(EXAMPLE_APP + 'alert')
        self.browser.find_by_tag('h2').click()

        alert = self.browser.get_alert()
        self.assertEqual('What is your name?', alert.text)
        alert.fill_with('Splinter')
        alert.accept()

        response = self.browser.get_alert()
        self.assertEqual('Splinter', response.text)
        response.accept()

    def test_access_confirm_and_accept_and_dismiss_them(self):
        self.browser.visit(EXAMPLE_APP + 'alert')

        self.browser.find_by_tag('h3').click()
        alert = self.browser.get_alert()

        self.assertEqual('Should I continue?', alert.text)
        alert.accept()
        alert = self.browser.get_alert()
        self.assertEqual('You say I should', alert.text)
        alert.accept()

        self.browser.find_by_tag('h3').click()
        alert = self.browser.get_alert()
        self.assertEqual('Should I continue?', alert.text)
        alert.dismiss()
        alert = self.browser.get_alert()
        self.assertEqual('You say I should not', alert.text)
        alert.accept()

    def test_access_confirm_and_accept_and_dismiss_them_using_with(self):
        self.browser.visit(EXAMPLE_APP + 'alert')

        self.browser.find_by_tag('h3').click()
        with self.browser.get_alert() as alert:
            self.assertEqual('Should I continue?', alert.text)
            alert.accept()

        with self.browser.get_alert() as alert:
            self.assertEqual('You say I should', alert.text)
            alert.accept()

        self.browser.find_by_tag('h3').click()
        with self.browser.get_alert() as alert:
            self.assertEqual('Should I continue?', alert.text)
            alert.dismiss()
        with self.browser.get_alert() as alert:
            self.assertEqual('You say I should not', alert.text)
            alert.accept()

    def test_access_alerts_using_with(self):
        "should access alerts using 'with' statement"
        self.browser.visit(EXAMPLE_APP + 'alert')
        self.browser.find_by_tag('h1').click()
        with self.browser.get_alert() as alert:
            self.assertEqual('This is an alert example.', alert.text)
            alert.accept()

########NEW FILE########
__FILENAME__ = click_elements
# -*- coding: utf-8 -*-

# Copyright 2012 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.


class ClickElementsTest(object):

    def test_click_links(self):
        "should allow to click links"
        self.browser.find_link_by_text('FOO').click()
        assert b'BAR!' in self.browser.html

    def test_click_element_by_css_selector(self):
        "should allow to click at elements by css selector"
        self.browser.find_by_css('a[href="http://localhost:5000/foo"]').click()
        assert b'BAR!' in self.browser.html

    def test_click_input_by_css_selector(self):
        "should allow to click at inputs by css selector"
        self.browser.find_by_css('input[name="send"]').click()
        assert b'My name is: Master Splinter' in self.browser.html

    def test_click_link_by_href(self):
        "should allow to click link by href"
        self.browser.click_link_by_href('http://localhost:5000/foo')
        assert b"BAR!" in self.browser.html

    def test_click_link_by_partial_href(self):
        "should allow to click link by partial href"
        self.browser.click_link_by_partial_href('5000/foo')
        assert b"BAR!" in self.browser.html

    def test_click_link_by_text(self):
        "should allow to click link by text"
        self.browser.click_link_by_text('FOO')
        assert b"BAR!" in self.browser.html

    def test_click_link_by_partial_text(self):
        "should allow to click link by partial text"
        self.browser.click_link_by_partial_text("wordier")
        assert b"BAR!" in self.browser.html

########NEW FILE########
__FILENAME__ = cookies
# -*- coding: utf-8 -*-

# Copyright 2012 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

from .fake_webapp import EXAMPLE_APP

class CookiesTest(object):

    def test_create_and_access_a_cookie(self):
        "should be able to create and access a cookie"
        self.browser.cookies.add({'sha': 'zam'})
        self.assertEqual(self.browser.cookies['sha'], 'zam')

    def test_create_many_cookies_at_once_as_dict(self):
        "should be able to create many cookies at once as dict"
        cookies = {'sha': 'zam', 'foo': 'bar'}
        self.browser.cookies.add(cookies)
        self.assertEqual(self.browser.cookies['sha'], 'zam')
        self.assertEqual(self.browser.cookies['foo'], 'bar')

    def test_create_many_cookies_at_once_as_list(self):
        "should be able to create many cookies at once as list"
        cookies = [{'sha': 'zam'}, {'foo': 'bar'}]
        self.browser.cookies.add(cookies)
        self.assertEqual(self.browser.cookies['sha'], 'zam')
        self.assertEqual(self.browser.cookies['foo'], 'bar')

    def test_create_some_cookies_and_delete_them_all(self):
        "should be able to delete all cookies"
        self.browser.cookies.add({'whatever': 'and ever'})
        self.browser.cookies.add({'anothercookie': 'im bored'})
        self.browser.cookies.delete()
        self.assertEqual(self.browser.cookies, {})

    def test_create_and_delete_a_cookie(self):
        "should be able to create and destroy a cookie"
        self.browser.cookies.delete()
        self.browser.cookies.add({'cookie': 'with milk'})
        self.browser.cookies.delete('cookie')
        self.assertEqual(self.browser.cookies, {})

    def test_create_and_delete_many_cookies(self):
        "should be able to create and destroy many cookies"
        self.browser.cookies.delete()
        self.browser.cookies.add({'acookie': 'cooked'})
        self.browser.cookies.add({'anothercookie': 'uncooked'})
        self.browser.cookies.add({'notacookie': 'halfcooked'})
        self.browser.cookies.delete('acookie', 'notacookie')
        self.assertEqual('uncooked', self.browser.cookies['anothercookie'])

    def test_try_to_destroy_an_absent_cookie_and_nothing_happens(self):
        self.browser.cookies.delete()
        self.browser.cookies.add({'foo': 'bar'})
        self.browser.cookies.delete('mwahahahaha')
        self.assertEqual(self.browser.cookies, {'foo': 'bar'})

    def test_create_and_get_all_cookies(self):
        "should be able to create some cookies and retrieve them all"
        self.browser.cookies.delete()
        self.browser.cookies.add({'taco': 'shrimp'})
        self.browser.cookies.add({'lavar': 'burton'})
        self.assertEqual(len(self.browser.cookies.all()), 2)
        self.browser.cookies.delete()
        self.assertEqual(self.browser.cookies.all(), {})

########NEW FILE########
__FILENAME__ = element
# -*- coding: utf-8 -*-

# Copyright 2012 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.


class ElementTest(object):

    def test_element_has_class_when_element_has_the_class_as_first_class(self):
        self.assertTrue(self.browser.find_by_css('.has-class-first').has_class('has-class-first'))

    def test_element_has_class_when_element_has_the_class_as_middle_class(self):
        self.assertTrue(self.browser.find_by_css('.has-class-middle').has_class('has-class-middle'))

    def test_element_has_class_when_element_has_the_class_as_end_class(self):
        self.assertTrue(self.browser.find_by_css('.has-class-end').has_class('has-class-end'))

    def test_element_has_class_when_element_doesnt_have_the_class(self):
        self.assertFalse(self.browser.find_by_css('.has-class-first').has_class('has-class'))

    def test_element_outer_html(self):
        self.assertEqual(
            self.browser.find_by_id('html-property').outer_html,
            u'<div id="html-property" class="outer html classes">inner <div class="inner-html">inner text</div> html test</div>'
        )

    def test_element_html(self):
        self.assertEqual(
            self.browser.find_by_id('html-property').html,
            u'inner <div class="inner-html">inner text</div> html test'
        )

########NEW FILE########
__FILENAME__ = element_does_not_exist
# -*- coding: utf-8 -*-

# Copyright 2012 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

from splinter.exceptions import ElementDoesNotExist


class ElementDoestNotExistTest(object):

    def test_element_query_should_raises_when_element_first_doest_exists(self):
        with self.assertRaises(ElementDoesNotExist):
            self.browser.find_by_css('.element-that-dont-exists').first

    def test_element_list_raises_when_element_last_does_not_exists(self):
        with self.assertRaises(ElementDoesNotExist):
            self.browser.find_by_css('.element-that-dont-exists').last

    def test_element_list_raises_when_element_does_not_exists(self):
        with self.assertRaises(ElementDoesNotExist):
            self.browser.find_by_css('.element-that-dont-exists')[2]

    def test_element_list_raises_with_unicode_query(self):
        with self.assertRaises(ElementDoesNotExist):
            self.browser.find_by_css(u'.element[title=título]').last

    def test_element_list_contains_right_information_and_raises_right_exception(self):
        "element list contains right information about query and raises nice exception message"
        with self.assertRaises(ElementDoesNotExist) as cm:
            element_list = self.browser.find_by_css('.element-that-dont-exists')
            self.assertEqual('css', element_list.find_by)
            self.assertEqual('.element-that-dont-exists', element_list.query)
            element_list.first

        expected_message = 'no elements could be found with css ".element-that-dont-exists"'

        e = cm.exception
        self.assertEqual(expected_message, e.args[0])

    def test_element_list_raises_when_element_first_doesnt_exists_in_element_context(self):
        "element list raises exception with right information in element context"
        with self.assertRaises(ElementDoesNotExist) as cm:
            element_list = self.browser.find_by_css("#inside").find_by_css('.inner-element-that-dont-exists')
            self.assertEqual('css', element_list.find_by)
            self.assertEqual('.inner-element-that-dont-exists', element_list.query)
            element_list.first

        expected_message = 'no elements could be found with css ".inner-element-that-dont-exists"'

        e = cm.exception
        self.assertEqual(expected_message, e.args[0])

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
import os
import sys

if __name__ == "__main__":
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "settings")

    from django.core.management import execute_from_command_line

    execute_from_command_line(sys.argv)

########NEW FILE########
__FILENAME__ = settings
"""
Django settings for fake_django project.

For more information on this file, see
https://docs.djangoproject.com/en/1.6/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/1.6/ref/settings/
"""

# Build paths inside the project like this: os.path.join(BASE_DIR, ...)
import os
BASE_DIR = os.path.dirname(os.path.dirname(__file__))


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/1.6/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = '(*g@g)+!toffn65+q$o)eivqorppbb)%$+f+ybjevymw=d5d8x'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

TEMPLATE_DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = (
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
)

MIDDLEWARE_CLASSES = (
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
)

ROOT_URLCONF = 'urls'

WSGI_APPLICATION = 'fake_django.wsgi.application'


# Database
# https://docs.djangoproject.com/en/1.6/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}

# Internationalization
# https://docs.djangoproject.com/en/1.6/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_L10N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/1.6/howto/static-files/

STATIC_URL = '/static/'

########NEW FILE########
__FILENAME__ = urls
import sys

from django.conf.urls import patterns, include, url
from django.http import HttpResponse

from django.contrib import admin
from django.contrib.auth.decorators import login_required
admin.autodiscover()

sys.path.append('tests')
from fake_webapp import EXAMPLE_HTML, EXAMPLE_IFRAME_HTML, EXAMPLE_ALERT_HTML, EXAMPLE_TYPE_HTML, EXAMPLE_NO_BODY_HTML, EXAMPLE_POPUP_HTML


def index(request):
    return HttpResponse(EXAMPLE_HTML)


def iframed(request):
    return HttpResponse(EXAMPLE_IFRAME_HTML)


def alertd(request):
    return HttpResponse(EXAMPLE_ALERT_HTML)


def type(request):
    return HttpResponse(EXAMPLE_TYPE_HTML)


def no_body(request):
    return HttpResponse(EXAMPLE_NO_BODY_HTML)


def get_name(request):
    return HttpResponse("My name is: Master Splinter")


def get_user_agent(request):
    return HttpResponse(request.user_agent.string)


def upload_file(request):
    if request.method == 'POST':
        f = request.FILES['file']
        buffer = []
        buffer.append("Content-type: %s" % f.content_type)
        buffer.append("File content: %s" % f.read())

        return HttpResponse('|'.join(buffer))


def foo(request):
    return HttpResponse("BAR!")


def query_string(request):
    if request.query_string == "model":
        return HttpResponse("query string is valid")
    else:
        raise Exception('500')


def popup(request):
    return HttpResponse(EXAMPLE_POPUP_HTML)


@login_required
def auth_required(request):
    return HttpResponse("Success!")


urlpatterns = patterns(
    '',
    url(r'^$', index),
    url(r'^iframe$', iframed),
    url(r'^alert$', alertd),
    url(r'^type$', type),
    url(r'^no_body$', no_body),
    url(r'^name$', get_name),
    url(r'^user_agent$', get_user_agent),
    url(r'^upload$', upload_file),
    url(r'^foo$', foo),
    url(r'^query$', query_string),
    url(r'^popup$', popup),
    url(r'^authenticate$', auth_required),
    url(r'^admin/', include(admin.site.urls)),
)

########NEW FILE########
__FILENAME__ = fake_webapp
# -*- coding: utf-8 -*-

# Copyright 2012 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

from flask import Flask, request, abort, Response
from os import path
from functools import wraps


this_folder = path.abspath(path.dirname(__file__))


def read_static(static_name):
    return open(path.join(this_folder, 'static', static_name)).read()

EXAMPLE_APP = "http://127.0.0.1:5000/"
EXAMPLE_HTML = read_static('index.html')
EXAMPLE_IFRAME_HTML = read_static('iframe.html')
EXAMPLE_ALERT_HTML = read_static('alert.html')
EXAMPLE_TYPE_HTML = read_static('type.html')
EXAMPLE_POPUP_HTML = read_static('popup.html')
EXAMPLE_NO_BODY_HTML = read_static('no-body.html')

# Functions for http basic auth. 
# Taken verbatim from http://flask.pocoo.org/snippets/8/
def check_auth(username, password):
    """This function is called to check if a username /
    password combination is valid.
    """
    return username == 'admin' and password == 'secret'

def authenticate():
    """Sends a 401 response that enables basic auth"""
    return Response(
    'Could not verify your access level for that URL.\n'
    'You have to login with proper credentials', 401,
    {'WWW-Authenticate': 'Basic realm="Login Required"'})

def requires_auth(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        auth = request.authorization
        if not auth or not check_auth(auth.username, auth.password):
            return authenticate()
        return f(*args, **kwargs)
    return decorated

app = Flask(__name__)


@app.route('/')
def index():
    return EXAMPLE_HTML


@app.route('/iframe')
def iframed():
    return EXAMPLE_IFRAME_HTML


@app.route('/alert')
def alertd():
    return EXAMPLE_ALERT_HTML


@app.route('/type')
def type():
    return EXAMPLE_TYPE_HTML


@app.route('/no-body')
def no_body():
    return EXAMPLE_NO_BODY_HTML


@app.route('/name', methods=['GET'])
def get_name():
    return "My name is: Master Splinter"


@app.route('/useragent', methods=['GET'])
def get_user_agent():
    return request.user_agent.string


@app.route('/upload', methods=['GET', 'POST'])
def upload_file():
    if request.method == 'POST':
        f = request.files['file']
        buffer = []
        buffer.append("Content-type: %s" % f.content_type)
        buffer.append("File content: %s" % f.stream.read())

        return '|'.join(buffer)


@app.route('/headers', methods=['GET'])
def request_headers():
    return str(request.headers)


@app.route('/foo')
def foo():
    return "BAR!"


@app.route('/query', methods=['GET'])
def query_string():
    if request.query_string == b"model":
        return "query string is valid"
    else:
        abort(500)


@app.route('/popup')
def popup():
    return EXAMPLE_POPUP_HTML

@app.route('/authenticate')
@requires_auth
def auth_required():
    return "Success!"


def start_flask_app(host, port):
    """Runs the server."""
    app.run(host=host, port=port)
    app.config['DEBUG'] = False
    app.config['TESTING'] = False

if __name__ == '__main__':
    app.run()

########NEW FILE########
__FILENAME__ = find_elements
# -*- coding: utf-8 -*-

# Copyright 2012 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

from splinter.driver import ElementAPI
from splinter.element_list import ElementList


class FindElementsTest(object):

    def test_finding_by_css(self):
        "should find by css"
        value = self.browser.find_by_css('h1').value
        self.assertEqual('Example Header', value)

    def test_finding_by_xpath(self):
        "should find elements by xpath"
        value = self.browser.find_by_xpath('//h1').value
        self.assertEqual('Example Header', value)

    def test_finding_by_tag(self):
        "should find elements by tag"
        value = self.browser.find_by_tag('h1').value
        self.assertEqual('Example Header', value)

    def test_finding_by_value(self):
        "should find elements by value"
        value = self.browser.find_by_value('M').value
        id = self.browser.find_by_id('gender-m')
        self.assertEqual(id.value, value)

    def test_finding_by_id(self):
        "should find elements by id"
        value = self.browser.find_by_id("firstheader").value
        self.assertEqual('Example Header', value)

    def test_finding_by_name(self):
        "should find elements by name"
        value = self.browser.find_by_name('query').value
        self.assertEqual('default value', value)

    def test_finding_all_elements_by_css(self):
        "should find elements by css"
        value = self.browser.find_by_css('h1')[0].value
        self.assertEqual('Example Header', value)

    def test_finding_all_elements_by_xpath(self):
        "should find elements by xpath"
        value = self.browser.find_by_xpath('//h1')[0].value
        self.assertEqual('Example Header', value)

    def test_finding_all_elements_by_tag(self):
        "should find elements by tag"
        value = self.browser.find_by_tag('h1')[0].value
        self.assertEqual('Example Header', value)

    def test_finding_all_elements_by_id(self):
        "should find elements by id"
        value = self.browser.find_by_id("firstheader")[0].value
        self.assertEqual('Example Header', value)

    def test_finding_all_elements_by_name(self):
        "should find elements by name"
        value = self.browser.find_by_name('query')[0].value
        self.assertEqual('default value', value)

    def test_finding_all_links_by_text(self):
        "should find links by text"
        link = self.browser.find_link_by_text('Link for Example.com')[0]
        self.assertEqual('http://example.com/', link['href'])

    def test_finding_all_links_by_href(self):
        "should find links by href"
        link = self.browser.find_link_by_href('http://example.com/')[0]
        self.assertEqual('http://example.com/', link['href'])

    def test_finding_all_links_by_partial_href(self):
        "should find links by partial href"
        link = self.browser.find_link_by_partial_href('example.c')[0]
        self.assertEqual('http://example.com/', link['href'])

    def test_finding_all_links_by_partial_text(self):
        "should find links by partial text"
        link = self.browser.find_link_by_partial_text('FOO')[0]
        self.assertEqual('http://localhost:5000/foo', link['href'])

    def test_finding_all_links_by_partial_text_complex_contents(self):
        link = self.browser.find_link_by_partial_text('Complex Link')[0]
        self.assertEqual('http://localhost:5000/foo', link['href'])

    def test_finding_last_element_by_css(self):
        "should find last element by css"
        value = self.browser.find_by_css('h1').last.value
        self.assertEqual('Example Last Header', value)

    def test_finding_last_element_by_xpath(self):
        "should find last element by xpath"
        value = self.browser.find_by_xpath('//h1').last.value
        self.assertEqual('Example Last Header', value)

    def test_finding_last_element_by_tag(self):
        "should find last element by tag"
        value = self.browser.find_by_tag('h1').last.value
        self.assertEqual('Example Last Header', value)

    def test_finding_last_element_by_id(self):
        "should find last element by id"
        value = self.browser.find_by_id("firstheader").last.value
        self.assertEqual('Example Header', value)

    def test_last_element_is_same_than_first_element_in_find_by_id(self):
        "should first element is same than last element in find by id"
        #a html page have contain one element by id
        first = self.browser.find_by_id("firstheader").value
        last = self.browser.find_by_id("firstheader").last.value
        self.assertEqual(first, last)

    def test_finding_last_element_by_name(self):
        "should find last element by name"
        value = self.browser.find_by_name('query').last.value
        self.assertEqual('default last value', value)

    def test_finding_last_link_by_text(self):
        "should find last link by text"
        link = self.browser.find_link_by_text('Link for Example.com').last
        self.assertEqual('http://example.com/last', link['href'])

    def test_finding_last_link_by_href(self):
        "should find last link by href"
        link = self.browser.find_link_by_href('http://example.com/').last
        self.assertEqual('Link for last Example.com', link.text)

    def test_finding_link_by_partial_href(self):
        "should find links by partial href"
        link = self.browser.find_link_by_partial_href('example.c').last
        self.assertEqual('Link for last Example.com', link.text)

    def test_finding_last_link_by_partial_text(self):
        "should find last link by partial text"
        link = self.browser.find_link_by_partial_text('FOO').last
        self.assertEqual('A wordier (and last) link to FOO', link.text)

    def test_finding_element_by_css_using_slice(self):
        "should find element by css using slice"
        value = self.browser.find_by_css('h1')[-1].value
        self.assertEqual('Example Last Header', value)

    def test_finding_element_by_xpath_using_slice(self):
        "should find element by xpath using slice"
        value = self.browser.find_by_xpath('//h1')[-1].value
        self.assertEqual('Example Last Header', value)

    def test_finding_element_by_tag_using_slice(self):
        "should find element by tag using slice"
        value = self.browser.find_by_tag('h1')[-1].value
        self.assertEqual('Example Last Header', value)

    def test_finding_element_by_id_using_slice(self):
        "should find element by id using slice"
        value = self.browser.find_by_id("firstheader")[-1].value
        self.assertEqual('Example Header', value)

    def test_all_elements_is_same_than_first_element_in_find_by_id(self):
        "should all elements is same than first element in find by id"
        #a html page have contain one element by id
        first = self.browser.find_by_id("firstheader").value
        some = self.browser.find_by_id("firstheader")[-1].value
        self.assertEqual(first, some)

    def test_finding_element_by_name_using_slice(self):
        "should find element by name using slice"
        value = self.browser.find_by_name('query')[-1].value
        self.assertEqual('default last value', value)

    def test_finding_link_by_text_using_slice(self):
        "should find link by text using slice"
        link = self.browser.find_link_by_text('Link for Example.com')[-1]
        self.assertEqual('http://example.com/last', link['href'])

    def test_finding_link_by_href_using_slice(self):
        "should find link by href using slice"
        link = self.browser.find_link_by_href('http://example.com/')[-1]
        self.assertEqual('Link for last Example.com', link.text)

    def test_finding_links_by_text(self):
        "should find links by text"
        link = self.browser.find_link_by_text('Link for Example.com')
        self.assertEqual('http://example.com/', link['href'])

    def test_finding_links_by_href(self):
        "should find links by href"
        link = self.browser.find_link_by_href('http://example.com/')
        self.assertEqual('http://example.com/', link['href'])

    def test_find_by_css_in_element_context(self):
        "should find elements by css in element context and should return splinter driver element"
        elements = self.browser.find_by_css("#inside")
        decendent = elements[0].find_by_css('h2')
        self.assertEqual(decendent.text.strip(), 'inside')
        assert isinstance(decendent, ElementList)
        assert isinstance(decendent[0], ElementAPI)

    def test_find_by_xpath_in_element_context(self):
        "should find elements by xpath in element context"
        elements = self.browser.find_by_css("#inside")
        decendent = elements[0].find_by_xpath("//h2")
        self.assertEqual(decendent.text.strip(), 'inside')
        assert isinstance(decendent, ElementList)
        assert isinstance(decendent[0], ElementAPI)

    def test_find_by_name_in_element_context(self):
        "should find elements by name in element context"
        elements = self.browser.find_by_css("#inside")
        decendent = elements[0].find_by_name("upload")
        self.assertEqual(len(decendent), 1)
        assert isinstance(decendent, ElementList)
        assert isinstance(decendent[0], ElementAPI)

    def test_find_by_tag_in_element_context(self):
        "should find elements by tag in element context"
        elements = self.browser.find_by_css("#inside")
        decendent = elements[0].find_by_tag("input")
        self.assertEqual(len(decendent), 1)
        assert isinstance(decendent, ElementList)
        assert isinstance(decendent[0], ElementAPI)

    def test_find_by_id_in_element_context(self):
        "should find elements by id in element context"
        elements = self.browser.find_by_css("#inside")
        decendent = elements[0].find_by_id("visible")
        self.assertEqual(len(decendent), 1)
        assert isinstance(decendent, ElementList)
        assert isinstance(decendent[0], ElementAPI)

    def test_find_by_value_in_element_context(self):
        "should find elements by value in element context"
        elements = self.browser.find_by_css("#inside")
        decendent = elements[0].find_by_value("crazy diamond")
        self.assertEqual(len(decendent), 1)
        assert isinstance(decendent, ElementList)
        assert isinstance(decendent[0], ElementAPI)

########NEW FILE########
__FILENAME__ = form_elements
# -*- coding: utf-8 -*-

# Copyright 2012 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

class FormElementsTest(object):

    def test_can_change_field_value(self):
        "should provide a away to change field value"
        self.browser.fill('query', 'new query')
        value = self.browser.find_by_name('query').value
        self.assertEqual('new query', value)

    def test_should_provide_a_method_on_element_to_change_its_value(self):
        self.browser.find_by_name('query').fill('new query')
        value = self.browser.find_by_name('query').value
        self.assertEqual('new query', value)

    def test_submiting_a_form_and_verifying_page_content(self):
        self.browser.fill('query', 'my name')
        self.browser.find_by_name('send').click()
        assert b'My name is: Master Splinter' in self.browser.html

    def test_can_choose_a_radio_button(self):
        "should provide a way to choose a radio button"
        self.assertFalse(self.browser.find_by_id("gender-m").checked)
        self.browser.choose("gender", "M")
        self.assertTrue(self.browser.find_by_id("gender-m").checked)

    def test_can_find_option_by_value(self):
        "should provide a way to find select option by value"
        self.assertEqual("Rio de Janeiro", self.browser.find_option_by_value("rj").text)

    def test_can_get_value_attribute_for_a_option(self):
        "should option have a value attribute"
        self.assertEqual("rj", self.browser.find_option_by_value("rj")["value"])

    def test_can_find_option_by_text(self):
        "should provide a way to find select option by text"
        self.assertEqual("rj", self.browser.find_option_by_text("Rio de Janeiro").value)

    def test_can_select_a_option(self):
        "should provide a way to select a option"
        self.assertFalse(self.browser.find_option_by_value("rj").selected)
        self.browser.select("uf", "rj")
        self.assertTrue(self.browser.find_option_by_value("rj").selected)

    def test_can_select_a_option_via_element(self):
        "should provide a way to select a option via element"
        self.assertFalse(self.browser.find_option_by_value("rj").selected)
        self.browser.find_by_name("uf").select("rj")
        self.assertTrue(self.browser.find_option_by_value("rj").selected)

    def test_can_check_a_checkbox(self):
        "should provide a way to check a radio checkbox"
        self.assertFalse(self.browser.find_by_name("some-check").checked)
        self.browser.check("some-check")
        self.assertTrue(self.browser.find_by_name("some-check").checked)

    def test_check_keeps_checked_if_called_multiple_times(self):
        "should keep a checkbox checked if check() is called multiple times"
        self.assertFalse(self.browser.find_by_name("some-check").checked)
        self.browser.check("some-check")
        self.browser.check("some-check")
        self.assertTrue(self.browser.find_by_name("some-check").checked)

    def test_can_uncheck_a_checkbox(self):
        "should provide a way to uncheck a radio checkbox"
        self.assertTrue(self.browser.find_by_name("checked-checkbox").checked)
        self.browser.uncheck("checked-checkbox")
        self.assertFalse(self.browser.find_by_name("checked-checkbox").checked)

    def test_uncheck_should_keep_unchecked_if_called_multiple_times(self):
        "should keep a checkbox unchecked if uncheck() is called multiple times"
        self.assertTrue(self.browser.find_by_name("checked-checkbox").checked)
        self.browser.uncheck("checked-checkbox")
        self.browser.uncheck("checked-checkbox")
        self.assertFalse(self.browser.find_by_name("checked-checkbox").checked)

    def test_can_fill_text_field_in_form(self):
        "should provide a away to change field value"
        self.browser.fill_form({'query': 'new query'})
        value = self.browser.find_by_name('query').value
        self.assertEqual('new query', value)

    def test_can_fill_password_field_in_form(self):
        "should provide a way to change password value"
        new_password = 'new password'
        self.browser.fill_form({'password': new_password})
        value = self.browser.find_by_name('password').value
        self.assertEqual(new_password, value)

    def test_can_fill_more_than_one_field_in_form(self):
        "should provide a away to change field value"
        self.browser.fill('query', 'my name')
        self.assertFalse(self.browser.find_by_id("gender-m").checked)
        self.assertFalse(self.browser.find_option_by_value("rj").selected)
        self.assertFalse(self.browser.find_by_name("some-check").checked)
        self.assertTrue(self.browser.find_by_name("checked-checkbox").checked)
        self.browser.fill_form({
            'query': 'another new query',
            'description': 'Just another description value in the textarea',
            'gender': 'M',
            'uf': 'rj',
            'some-check': True,
            'checked-checkbox': False
        })
        query_value = self.browser.find_by_name('query').value
        self.assertEqual('another new query', query_value)
        desc_value = self.browser.find_by_name('description').value
        self.assertEqual('Just another description value in the textarea', desc_value)
        self.assertTrue(self.browser.find_by_id("gender-m").checked)
        self.assertTrue(self.browser.find_option_by_value("rj").selected)
        self.assertTrue(self.browser.find_by_name("some-check").checked)
        self.assertFalse(self.browser.find_by_name("checked-checkbox").checked)

    def test_can_fill_tel_text_field(self):
        "should provide a way to change a tel field value"
        new_telephone = '555-0042'
        self.browser.fill_form({'telephone': new_telephone})
        value = self.browser.find_by_name('telephone').value
        self.assertEqual(new_telephone, value)

    def test_can_fill_unknown_text_field(self):
        "should provide a way to change a unknown text field type that isn't specifically defined"
        new_search_keyword = 'foobar'
        self.browser.fill_form({'search_keyword': new_search_keyword})
        value = self.browser.find_by_name('search_keyword').value
        self.assertEqual(new_search_keyword, value)
########NEW FILE########
__FILENAME__ = iframes
# -*- coding: utf-8 -*-

# Copyright 2012 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

class IFrameElementsTest(object):

    def test_can_work_on_iframes(self):
        """can work on iframes and switch back to the page"""
        with self.browser.get_iframe('iframemodal') as frame:
            value = frame.find_by_tag('h1').value
            self.assertEqual(value, 'IFrame Example Header')
        value = self.browser.find_by_tag('h1').value
        self.assertEqual('Example Header', value)

########NEW FILE########
__FILENAME__ = is_element_present
# -*- coding: utf-8 -*-

# Copyright 2012 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

class IsElementPresentTest(object):

    def test_is_element_present_by_css(self):
        "should is element present by css verify if element is present"
        self.browser.reload()
        self.browser.find_by_css('.add-async-element').click()
        self.assertTrue(self.browser.is_element_present_by_css('.async-element'))

    def test_is_element_present_by_css_using_a_custom_wait_time(self):
        "should is element present by css verify if element is present using a custom wait time"
        self.browser.reload()
        self.browser.find_by_css('.add-async-element').click()
        self.assertTrue(self.browser.is_element_present_by_css('.async-element2', wait_time=3))

    def test_is_element_present_by_css_returns_false_if_element_is_not_present(self):
        "should is element present by css returns False if element is not present"
        self.browser.reload()
        self.assertFalse(self.browser.is_element_present_by_css('.async-elementzz'))

    def test_is_element_not_present_by_css(self):
        "should is element not present by css verify if element is not present"
        self.browser.reload()
        self.assertTrue(self.browser.is_element_not_present_by_css('.async-element'))

    def test_is_element_not_present_by_css_returns_false_if_element_is_present(self):
        "should is element not present by css returns False if element is present"
        self.browser.reload()
        self.assertFalse(self.browser.is_element_not_present_by_css('h1'))

    def test_is_element_not_present_by_css_using_a_custom_wait_time(self):
        "should is element not present by css verify if element is not present using a custom wait time"
        self.browser.reload()
        self.assertTrue(self.browser.is_element_not_present_by_css('.async-element', wait_time=3))

    def test_is_element_present_by_xpath(self):
        "should is element present by xpath verify if element is present"
        self.browser.reload()
        self.browser.find_by_css('.add-async-element').click()
        self.assertTrue(self.browser.is_element_present_by_xpath('//h4'))

    def test_is_element_present_by_xpath_using_a_custom_wait_time(self):
        "should is element present by xpath verify if element is present using a custom wait time"
        self.browser.reload()
        self.browser.find_by_css('.add-async-element').click()
        self.assertTrue(self.browser.is_element_present_by_xpath('//h5', wait_time=3))

    def test_is_element_present_by_xpath_returns_false_if_element_is_not_present(self):
        "should is element present by xpath returns false if element is not present"
        self.browser.reload()
        self.assertFalse(self.browser.is_element_present_by_xpath('//h4'))

    def test_is_element_not_present_by_xpath(self):
        "should is element not present by xpath verify if element is not present"
        self.browser.reload()
        self.assertTrue(self.browser.is_element_not_present_by_xpath('//h4'))

    def test_is_element_not_present_by_xpath_returns_false_if_element_is_present(self):
        "should is element not present by xpath returns false if element is present"
        self.browser.reload()
        self.browser.find_by_css('.add-async-element').click()
        self.assertFalse(self.browser.is_element_not_present_by_xpath('//h4'))

    def test_is_element_not_present_by_xpath_using_a_custom_wait_time(self):
        "should is element not present by xpath verify if element is not present using a custom wait time"
        self.browser.reload()
        self.assertTrue(self.browser.is_element_not_present_by_xpath('//h4', wait_time=3))

    def test_is_element_present_by_tag(self):
        "should is element present by tag verify if element is present"
        self.browser.reload()
        self.browser.find_by_css('.add-async-element').click()
        self.assertTrue(self.browser.is_element_present_by_tag('h4'))

    def test_is_element_present_by_tag_using_a_custom_wait_time(self):
        "should is element present by tag verify if element is present using a custom wait time"
        self.browser.reload()
        self.browser.find_by_css('.add-async-element').click()
        self.assertTrue(self.browser.is_element_present_by_tag('h4', wait_time=3))

    def test_is_element_present_by_tag_returns_false_if_element_is_not_present(self):
        "should is element present by tag returns false if element is not present"
        self.browser.reload()
        self.assertFalse(self.browser.is_element_present_by_tag('h4'))

    def test_is_element_not_present_by_tag(self):
        "should is element not present by tag verify if element is not present"
        self.browser.reload()
        self.assertTrue(self.browser.is_element_not_present_by_tag('h4'))

    def test_is_element_not_present_by_tag_using_a_custom_wait_time(self):
        "should is element not present by tag verify if element is not present using a custom wait time"
        self.browser.reload()
        self.assertTrue(self.browser.is_element_not_present_by_tag('h4', wait_time=3))

    def test_is_element_not_present_by_tag_returns_false_if_element_is_present(self):
        "should is element not present by tag returns false if element is present"
        self.browser.reload()
        self.browser.find_by_css('.add-async-element').click()
        self.assertFalse(self.browser.is_element_not_present_by_tag('h4'))

    def test_is_element_present_by_value(self):
        "should is element present by value verify if element is present"
        self.browser.reload()
        self.browser.find_by_css('.add-async-element').click()
        self.assertTrue(self.browser.is_element_present_by_value('async-header-value'))

    def test_is_element_present_by_value_using_a_custom_wait_time(self):
        "should is element present by value verify if element is present using a custom wait time"
        self.browser.reload()
        self.browser.find_by_css('.add-async-element').click()
        self.assertTrue(self.browser.is_element_present_by_value('async-header-value', wait_time=3))

    def test_is_element_present_by_value_returns_false_if_element_is_not_present(self):
        "should is element present by value returns False if element is not present"
        self.browser.reload()
        self.assertFalse(self.browser.is_element_present_by_value('async-header-value'))

    def test_is_element_not_present_by_value(self):
        "should is element not present by value verify if element is not present"
        self.browser.reload()
        self.assertTrue(self.browser.is_element_not_present_by_value('async-header-value'))

    def test_is_element_not_present_by_value_using_a_custom_wait_time(self):
        "should is element not present by value verify if element is not present using a custom wait time"
        self.browser.reload()
        self.assertTrue(self.browser.is_element_not_present_by_value('async-header-value', wait_time=3))

    def test_is_element_not_present_by_value_returns_false_if_element_is_present(self):
        "should is element not present by value returns False if element is present"
        self.browser.reload()
        self.assertFalse(self.browser.is_element_not_present_by_value('default value'))

    def test_is_element_present_by_id(self):
        "should is element present by id verify if element is present"
        self.browser.reload()
        self.browser.find_by_css('.add-async-element').click()
        self.assertTrue(self.browser.is_element_present_by_id('async-header'))

    def test_is_element_present_by_id_using_a_custom_wait_time(self):
        "should is element present by id verify if element is present using a custom wait time"
        self.browser.reload()
        self.browser.find_by_css('.add-async-element').click()
        self.assertTrue(self.browser.is_element_present_by_id('async-header', wait_time=3))

    def test_is_element_present_by_id_returns_false_if_element_is_not_present(self):
        "should is element present by id returns False if element is not present"
        self.browser.reload()
        self.assertFalse(self.browser.is_element_present_by_id('async-header'))

    def test_is_element_not_present_by_id(self):
        "should is element not present by id verify if element is not present"
        self.browser.reload()
        self.assertTrue(self.browser.is_element_not_present_by_id('async-header'))

    def test_is_element_not_present_by_id_using_a_custom_wait_time(self):
        "should is element not present by id verify if element is not present using a custom wait time"
        self.browser.reload()
        self.assertTrue(self.browser.is_element_not_present_by_id('async-header', wait_time=3))

    def test_is_element_not_present_by_id_returns_false_if_element_is_present(self):
        "should is element not present by id returns False if element is present"
        self.browser.reload()
        self.browser.find_by_css('.add-async-element').click()
        self.assertFalse(self.browser.is_element_not_present_by_id('async-header'))

    def test_is_element_present_by_name(self):
        "should is element present by name verify if element is present"
        self.browser.reload()
        self.browser.find_by_css('.add-async-element').click()
        self.assertTrue(self.browser.is_element_present_by_name('async-input'))

    def test_is_element_present_by_name_using_a_custom_wait_time(self):
        "should is element present by name verify if element is present using a custom wait time"
        self.browser.reload()
        self.browser.find_by_css('.add-async-element').click()
        self.assertTrue(self.browser.is_element_present_by_name('async-input', wait_time=3))

    def test_is_element_present_by_name_returns_false_if_element_is_not_present(self):
        "should is element present by name returns false if element is not present"
        self.browser.reload()
        self.assertFalse(self.browser.is_element_present_by_name('async-input'))

    def test_is_element_not_present_by_name(self):
        "should is element not present by name verify if element is not present"
        self.browser.reload()
        self.assertTrue(self.browser.is_element_not_present_by_name('async-input'))

    def test_is_element_not_present_by_name_using_a_custom_wait_time(self):
        "should is element not present by name verify if element is not present using a custom wait time"
        self.browser.reload()
        self.assertTrue(self.browser.is_element_not_present_by_name('async-input', wait_time=3))

    def test_is_element_not_present_by_name_returns_false_if_element_is_present(self):
        "should is element not present by name returns false if element is present"
        self.browser.reload()
        self.browser.find_by_css('.add-async-element').click()
        self.assertFalse(self.browser.is_element_not_present_by_name('async-input'))

########NEW FILE########
__FILENAME__ = is_text_present
# -*- coding: utf-8 -*-

# Copyright 2012 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.
from .fake_webapp import EXAMPLE_APP


class IsTextPresentTest(object):

    def test_is_text_present(self):
        "should verify if text is present"
        self.assertTrue(self.browser.is_text_present('Example Header'))

    def test_is_text_present_and_should_return_false(self):
        "should verify if text is present and return false"
        self.assertFalse(self.browser.is_text_present('Text that not exist'))

    def test_is_text_present_and_should_wait_time(self):
        "should verify if text is present and wait for five seconds"
        self.browser.find_link_by_text('FOO').click()
        self.assertTrue(self.browser.is_text_present('BAR!', wait_time=5))

    def test_is_text_not_present(self):
        "should verify if text is not present"
        self.assertTrue(
            self.browser.is_text_not_present('Text that not exist'))

    def test_is_text_not_present_and_should_return_false(self):
        "should verify if text is not prasent and return false"
        self.assertFalse(self.browser.is_text_not_present('Example Header'))

    def test_is_text_not_present_and_should_wait_time(self):
        "should verify if text is not present and wait for five seconds"
        self.browser.find_link_by_text('FOO').click()
        self.assertTrue(
            self.browser.is_text_not_present('another text', wait_time=5)
        )

    def test_is_text_present_no_body(self):
        "should work properly (return false) even if there's no body"
        self.browser.visit(EXAMPLE_APP + "no-body")
        self.assertFalse(self.browser.is_text_present('No such text'))

    def test_is_text_not_present_no_body(self):
        "returns true if there's no body"
        self.browser.visit(EXAMPLE_APP + "no-body")
        self.assertTrue(self.browser.is_text_not_present('No such text'))

########NEW FILE########
__FILENAME__ = mouse_interaction
# -*- coding: utf-8 -*-

# Copyright 2012 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

import warnings

from .fake_webapp import EXAMPLE_APP


class MouseInteractionTest(object):

    def test_mouse_over(self):
        "Should be able to perform a mouse over on an element"
        self.browser.visit(EXAMPLE_APP)
        self.browser.find_by_css(".add-element-mouseover").mouse_over()
        assert self.browser.is_element_present_by_id('what-is-your-name')
        self.browser.find_by_css(".add-element-mouseover").mouse_out()

    def test_mouse_out(self):
        "Should be able to perform a mouse out on an element"
        self.browser.visit(EXAMPLE_APP)
        element = self.browser.find_by_css(".add-element-mouseover")
        element.mouse_over()
        element.mouse_out()
        assert not self.browser.is_element_present_by_id('what-is-your-name')

    def test_double_click(self):
        "double click should shows a hidden element"
        self.browser.visit(EXAMPLE_APP)
        button = self.browser.find_by_css(".db-button")
        button.double_click()
        element = self.browser.find_by_css(
            ".should-be-visible-after-double-click"
        )
        assert element.visible
        assert self.browser.is_element_not_present_by_id('what-is-your-name')

    def test_right_click(self):
        "should be able to perform a right click on an element"
        self.browser.visit(EXAMPLE_APP)
        element = self.browser.find_by_css(".right-clicable")
        element.right_click()
        self.assertEqual(
            self.browser.find_by_css('.right-clicable').text,
            'right clicked'
        )

    def test_drag_and_drop(self):
        """
        should be able to perform a drag an element and drop in another element
        """
        droppable = self.browser.find_by_css('.droppable')
        draggable = self.browser.find_by_css('.draggable')
        draggable.drag_and_drop(droppable)
        assert self.browser.find_by_css('.dragged').text == 'yes'

    def test_mouseover_should_be_an_alias_to_mouse_over(self):
        "mouseover should be an alias to mouse_over and be deprecated"
        with warnings.catch_warnings(record=True) as warnings_list:
            self.browser.visit(EXAMPLE_APP)
            warnings.simplefilter("always")
            element = self.browser.find_by_css(".add-element-mouseover")
            element.mouseover()
            warn_message = warnings_list[-1].message
            assert type(warn_message) is DeprecationWarning
            assert 'mouse_over' in warn_message.args[0]

    def test_mouseout_should_be_an_alias_to_mouse_out_and_be_deprecated(self):
        "mouseout should be an alias do mouse_out and be deprecated"
        with warnings.catch_warnings(record=True) as warnings_list:
            self.browser.visit(EXAMPLE_APP)
            warnings.simplefilter("always")
            self.browser.find_by_css(".add-element-mouseover").mouseout()
            warn_message = warnings_list[-1].message
            assert type(warn_message) is DeprecationWarning
            assert 'mouse_out' in warn_message.args[0]

########NEW FILE########
__FILENAME__ = popups
# -*- coding: utf-8 -*-

# Copyright 2012 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

class PopupWindowsTest(object):
    def test_lists_all_windows_as_window_instances(self):
        self.browser.find_by_id("open-popup").click()
        self.assertEqual(len(self.browser.windows), 2)
        for window, handle in zip(self.browser.windows, self.browser.driver.window_handles):
            self.assertEqual(window.name, handle)

    def test_current_is_a_window_instance_pointing_to_current_window(self):
        self.assertEqual(self.browser.windows.current.name, self.browser.driver.current_window_handle)

    def test_set_current_to_window_instance_sets_current_window(self):
        last_current_window = self.browser.windows.current
        self.browser.windows.current = self.browser.windows.current.next
        self.assertNotEqual(self.browser.windows.current, last_current_window)

    def test_next_prev_return_next_prev_windows(self):
        self.browser.find_by_id("open-popup").click()
        self.assertEqual(self.browser.windows.current.next, self.browser.windows.current.prev)
        self.assertNotEqual(self.browser.windows.current, self.browser.windows.current.next)

    def test_is_current_returns_true_if_current_window_else_false(self):
        self.browser.find_by_id("open-popup").click()
        self.assertTrue(self.browser.windows.current.is_current)
        self.assertFalse(self.browser.windows.current.next.is_current)

    def test_set_is_current_to_True_sets_window_to_current(self):
        self.browser.find_by_id("open-popup").click()
        next_window = self.browser.windows.current.next
        self.assertFalse(next_window.is_current)
        next_window.is_current = True
        self.assertEqual(self.browser.windows.current, next_window)
        self.assertTrue(next_window.is_current)

    def test_get_window_by_index(self):
        self.browser.find_by_id("open-popup").click()
        self.assertEqual(self.browser.windows[0].name, self.browser.driver.window_handles[0])

    def test_get_window_by_name(self):
        self.browser.find_by_id("open-popup").click()
        window_handle = self.browser.driver.window_handles[0]
        self.assertEqual(self.browser.windows[window_handle].name, window_handle)

    def test_close_closes_window(self):
        self.browser.find_by_id("open-popup").click()
        current = self.browser.windows.current
        current.next.close()
        self.assertEqual(len(self.browser.windows), 1)
        self.assertEqual(self.browser.windows.current, current)

    def test_close_current_window_expect_previous_window_becomes_current(self):
        self.browser.find_by_id("open-popup").click()
        prev = self.browser.windows.current
        current = prev.next
        prev.next.is_current = True
        current.close()
        self.assertEqual(len(self.browser.windows), 1)
        self.assertEqual(self.browser.windows.current, prev)

    def test_close_others_expect_close_all_other_open_windows(self):
        current = self.browser.windows.current
        self.browser.find_by_id("open-popup").click()
        current.close_others()
        self.assertEqual(self.browser.windows[0], current)
        self.assertEqual(len(self.browser.windows), 1)

########NEW FILE########
__FILENAME__ = screenshot
# -*- coding: utf-8 -*-

# Copyright 2013 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

class ScreenshotTest(object):

    def test_take_screenshot(self):
        "should take a screenshot of the current page"
        filename = self.browser.screenshot()
        self.assertTrue('tmp' in filename)

    def test_take_screenshot_with_prefix(self):
        "should add the prefix to the screenshot file name"
        filename = self.browser.screenshot(name='foobar')
        self.assertTrue('foobar' in filename)

    def test_take_screenshot_with_suffix(self):
        "should add the suffix to the screenshot file name"
        filename = self.browser.screenshot(suffix='jpeg')
        self.assertEqual('jpeg', filename[-4:])

########NEW FILE########
__FILENAME__ = status_code
# -*- coding: utf-8 -*-

# Copyright 2012 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

from .fake_webapp import EXAMPLE_APP
from splinter.request_handler.status_code import HttpResponseError


class StatusCodeTest(object):

    def test_should_visit_an_absent_page_and_get_an_404_error(self):
        with self.assertRaises(HttpResponseError):
            self.browser.visit(EXAMPLE_APP + "this_page_does_not_exists")

    def test_should_visit_index_of_example_app_and_get_200_status_code(self):
        self.browser.visit(EXAMPLE_APP)
        self.assertEqual(200, self.browser.status_code)

    def test_should_be_able_to_print_status_code_with_reason(self):
        self.browser.visit(EXAMPLE_APP)
        self.assertEqual('200 - OK', str(self.browser.status_code))

########NEW FILE########
__FILENAME__ = test_browser
# -*- coding: utf-8 -*-

# Copyright 2013 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

try:
    import __builtin__ as builtins
except ImportError:
    import builtins
import unittest
from imp import reload
import sys

from splinter.exceptions import DriverNotFoundError

from .fake_webapp import EXAMPLE_APP
from .test_webdriver_chrome import chrome_installed
from .test_webdriver_firefox import firefox_installed


class BrowserTest(unittest.TestCase):

    def patch_driver(self, pattern):
        self.old_import = builtins.__import__

        def custom_import(name, *args, **kwargs):
            if pattern in name:
                return None
            return self.old_import(name, *args, **kwargs)

        builtins.__import__ = custom_import

    def unpatch_driver(self, module):
        builtins.__import__ = self.old_import
        reload(module)

    def browser_can_change_user_agent(self, webdriver):
        from splinter import Browser
        browser = Browser(driver_name=webdriver, user_agent="iphone")
        browser.visit(EXAMPLE_APP + "useragent")
        result = b'iphone' in browser.html
        browser.quit()

        return result

    def test_brower_can_still_be_imported_from_splinters_browser_module(self):
        from splinter.browser import Browser

    def test_should_work_even_without_zope_testbrowser(self):
        self.patch_driver('zope')
        from splinter import browser
        reload(browser)
        self.assertNotIn('zope.testbrowser', browser._DRIVERS)
        self.unpatch_driver(browser)

    def test_should_raise_an_exception_when_browser_driver_is_not_found(self):
        with self.assertRaises(DriverNotFoundError):
            from splinter import Browser
            Browser('unknown-driver')

    @unittest.skipIf(not firefox_installed(), 'firefox is not installed')
    def test_firefox_should_be_able_to_change_user_agent(self):
        self.assertTrue(self.browser_can_change_user_agent('firefox'))

    @unittest.skipIf(not chrome_installed(), 'chrome is not installed')
    def test_chrome_should_be_able_to_change_user_agent(self):
        self.assertTrue(self.browser_can_change_user_agent('chrome'))

    @unittest.skipIf(sys.version_info[0] > 2,
                     'zope.testbrowser is not currently compatible with Python 3')
    def test_zope_testbrowser_should_be_able_to_change_user_agent(self):
        self.assertTrue(self.browser_can_change_user_agent('zope.testbrowser'))

########NEW FILE########
__FILENAME__ = test_djangoclient
# -*- coding: utf-8 -*-

# Copyright 2013 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

import os
import sys
import unittest

sys.path.append('tests/fake_django')
os.environ['DJANGO_SETTINGS_MODULE'] = 'settings'

from splinter import Browser
from .base import BaseBrowserTests
from .fake_webapp import EXAMPLE_APP


class DjangoClientDriverTest(BaseBrowserTests, unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls.browser = Browser('django', wait_time=0.1)

    def setUp(self):
        self.browser.visit(EXAMPLE_APP)

    @classmethod
    def tearDownClass(self):
        self.browser.quit()

    def test_should_support_with_statement(self):
        with Browser('django') as internet:
            self.assertIsNotNone(internet)

    def test_attach_file(self):
        "should provide a way to change file field value"
        file_path = os.path.join(
            os.path.abspath(os.path.dirname(__file__)),
            'mockfile.txt'
        )
        self.browser.attach_file('file', file_path)
        self.browser.find_by_name('upload').click()

        html = self.browser.html
        assert b'text/plain' in html
        assert open(file_path).read().encode('utf-8') in html

    def test_forward_to_none_page(self):
        "should not fail when trying to forward to none"
        browser = Browser('django')
        browser.visit(EXAMPLE_APP)
        browser.forward()
        self.assertEqual(EXAMPLE_APP, browser.url)
        browser.quit()

    def test_cant_switch_to_frame(self):
        "zope.testbrowser should not be able to switch to frames"
        with self.assertRaises(NotImplementedError) as cm:
            self.browser.get_iframe('frame_123')
            self.fail()

        e = cm.exception
        self.assertEqual("django doesn't support frames.", e.args[0])

    def test_simple_type(self):
        """
        zope.testbrowser won't support type method
        because it doesn't interact with JavaScript
        """
        with self.assertRaises(NotImplementedError):
            self.browser.type('query', 'with type method')

    def test_simple_type_on_element(self):
        """
        django won't support type method
        because it doesn't interact with JavaScript
        """
        with self.assertRaises(NotImplementedError):
            self.browser.find_by_name('query').type('with type method')

    def test_slowly_typing(self):
        """
        django won't support type method
        because it doesn't interact with JavaScript
        """
        with self.assertRaises(NotImplementedError):
            self.browser.type('query', 'with type method', slowly=True)

    def test_slowly_typing_on_element(self):
        """
        django won't support type method
        on element because it doesn't interac with JavaScript
        """
        with self.assertRaises(NotImplementedError):
            query = self.browser.find_by_name('query')
            query.type('with type method', slowly=True)

    def test_cant_mouseover(self):
        "django should not be able to put the mouse over the element"
        with self.assertRaises(NotImplementedError):
            self.browser.find_by_css('#visible').mouse_over()

    def test_cant_mouseout(self):
        "django should not be able to mouse out of an element"
        with self.assertRaises(NotImplementedError):
            self.browser.find_by_css('#visible').mouse_out()

    def test_links_with_nested_tags_xpath(self):
        links = self.browser.find_by_xpath('//a/span[text()="first bar"]/..')
        self.assertEqual(
            len(links), 1,
            'Found not exactly one link with a span with text "BAR ONE". %s' % (
                map(lambda item: item.outer_html, links)))

    def test_finding_all_links_by_non_ascii_text(self):
        "should find links by non ascii text"
        non_ascii_encodings = {
            'pangram_pl': u'Jeżu klątw, spłódź Finom część gry hańb!',
            'pangram_ja': u'天 地 星 空',
            'pangram_ru': u'В чащах юга жил бы цитрус? Да, но фальшивый экземпляр!',
            'pangram_eo': u'Laŭ Ludoviko Zamenhof bongustas freŝa ĉeĥa manĝaĵo kun spicoj.',
        }
        for key, text in non_ascii_encodings.items():
            link = self.browser.find_link_by_text(text)
            self.assertEqual(key, link['id'])

########NEW FILE########
__FILENAME__ = test_element_list
# -*- coding: utf-8 -*-

# Copyright 2013 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

import unittest

from splinter.element_list import ElementList
from splinter.exceptions import ElementDoesNotExist


class Person(object):
    """Very simple class, just for tests"""

    def __init__(self):
        self.current_action = None

    def walk(self):
        self.current_action = "walking"


class ElementListTest(unittest.TestCase):

    def test_method_that_verifies_if_the_list_is_empty(self):
        "should verify if the list is empty"
        the_list = ElementList([1, 2, 3])
        self.assertFalse(the_list.is_empty())
        self.assertTrue(ElementList([]).is_empty())

    def test_property_first_and_last(self):
        """
        should provide a \"first\" and a \"last\" properties
        which returns the first and last element
        """
        the_list = ElementList([1, 2, 3])
        self.assertEqual(the_list[0], the_list.first)
        self.assertEqual(the_list[2], the_list.last)

    def test_call_method_on_first_element(self):
        """
        when some method is missing on ElementList and
        is present in element, it should be passed
        """
        the_list = ElementList([Person(), Person(), Person()])
        the_list.walk()
        the_person = the_list.first
        self.assertEqual("walking", the_person.current_action)

    def test_raise_exception_on_indexerror(self):
        "should raise ElementDoesNotExist exception on IndexError"
        with self.assertRaises(ElementDoesNotExist):
            ElementList([]).first

    def test_raise_exception_on_indexerror_with_unicode_query(self):
        "should raise ElementDoesNotExist exception on IndexError"
        with self.assertRaises(ElementDoesNotExist):
            ElementList([], query=u'.element[title=título]').first

    def test_raise_attribute_error(self):
        """
        should raise AttributeError when trying to access
        a non-existent method on list and element
        """
        with self.assertRaises(AttributeError):
            the_list = ElementList([Person(), Person()])
            the_list.talk()

    def test_attribute_error_for_empty(self):
        """
        should raise AttributeError when the list is empty
        and someone tries to access a method or property on it
        """
        with self.assertRaises(AttributeError):
            the_list = ElementList([])
            the_list.unknown_method()

    def test_attribute_error_content(self):
        "should raise AttributeError with right content"
        with self.assertRaises(AttributeError) as cm:
            the_list = ElementList([Person(), Person()])
            the_list.talk()

        expected_message = "'ElementList' object has no attribute 'talk'"
        e = cm.exception
        self.assertEqual(expected_message, e.args[0])

    def test_not_found_exception_with_query_and_method(self):
        """
        should receive the find method
        and the query and use them in exception
        """
        with self.assertRaises(ElementDoesNotExist) as cm:
            the_list = ElementList([], find_by="id", query="menu")
            the_list.first

        expected_message = 'no elements could be found with id "menu"'
        e = cm.exception
        self.assertEqual(expected_message, e.args[0])

########NEW FILE########
__FILENAME__ = test_flaskclient
# -*- coding: utf-8 -*-

# Copyright 2014 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

import os
import sys
import unittest

from splinter import Browser
from .base import BaseBrowserTests
from .fake_webapp import app, EXAMPLE_APP


class FlaskClientDriverTest(BaseBrowserTests, unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls.browser = Browser('flask', app=app, wait_time=0.1)

    def setUp(self):
        self.browser.visit(EXAMPLE_APP)

    @classmethod
    def tearDownClass(self):
        self.browser.quit()

    def test_should_support_with_statement(self):
        with Browser('flask', app=app) as internet:
            self.assertIsNotNone(internet)

    def test_attach_file(self):
        "should provide a way to change file field value"
        file_path = os.path.join(
            os.path.abspath(os.path.dirname(__file__)),
            'mockfile.txt'
        )
        self.browser.attach_file('file', file_path)
        self.browser.find_by_name('upload').click()

        html = self.browser.html
        assert b'text/plain' in html
        assert open(file_path).read().encode('utf-8') in html

    def test_forward_to_none_page(self):
        "should not fail when trying to forward to none"
        browser = Browser('flask', app=app)
        browser.visit(EXAMPLE_APP)
        browser.forward()
        self.assertEqual(EXAMPLE_APP, browser.url)
        browser.quit()

    def test_cant_switch_to_frame(self):
        "zope.testbrowser should not be able to switch to frames"
        with self.assertRaises(NotImplementedError) as cm:
            self.browser.get_iframe('frame_123')
            self.fail()

        e = cm.exception
        self.assertEqual("flask doesn't support frames.", e.args[0])

    def test_simple_type(self):
        """
        zope.testbrowser won't support type method
        because it doesn't interact with JavaScript
        """
        with self.assertRaises(NotImplementedError):
            self.browser.type('query', 'with type method')

    def test_simple_type_on_element(self):
        """
        flask won't support type method
        because it doesn't interact with JavaScript
        """
        with self.assertRaises(NotImplementedError):
            self.browser.find_by_name('query').type('with type method')

    def test_slowly_typing(self):
        """
        flask won't support type method
        because it doesn't interact with JavaScript
        """
        with self.assertRaises(NotImplementedError):
            self.browser.type('query', 'with type method', slowly=True)

    def test_slowly_typing_on_element(self):
        """
        flask won't support type method
        on element because it doesn't interac with JavaScript
        """
        with self.assertRaises(NotImplementedError):
            query = self.browser.find_by_name('query')
            query.type('with type method', slowly=True)

    def test_cant_mouseover(self):
        "flask should not be able to put the mouse over the element"
        with self.assertRaises(NotImplementedError):
            self.browser.find_by_css('#visible').mouse_over()

    def test_cant_mouseout(self):
        "flask should not be able to mouse out of an element"
        with self.assertRaises(NotImplementedError):
            self.browser.find_by_css('#visible').mouse_out()

    def test_links_with_nested_tags_xpath(self):
        links = self.browser.find_by_xpath('//a/span[text()="first bar"]/..')
        self.assertEqual(
            len(links), 1,
            'Found not exactly one link with a span with text "BAR ONE". %s' % (
                map(lambda item: item.outer_html, links)))

    def test_finding_all_links_by_non_ascii_text(self):
        "should find links by non ascii text"
        non_ascii_encodings = {
            'pangram_pl': u'Jeżu klątw, spłódź Finom część gry hańb!',
            'pangram_ja': u'天 地 星 空',
            'pangram_ru': u'В чащах юга жил бы цитрус? Да, но фальшивый экземпляр!',
            'pangram_eo': u'Laŭ Ludoviko Zamenhof bongustas freŝa ĉeĥa manĝaĵo kun spicoj.',
        }
        for key, text in non_ascii_encodings.items():
            link = self.browser.find_link_by_text(text)
            self.assertEqual(key, link['id'])

########NEW FILE########
__FILENAME__ = test_meta
# -*- coding: utf-8 -*-

# Copyright 2013 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

import unittest

from splinter.meta import InheritedDocs


class SuperClass(InheritedDocs('_SuperClass', (object,), {})):

    def say_hello(self):
        """
        Says hello
        """
        pass


class SubClass(SuperClass):

    def say_hello(self):
        print("hello")

    @property
    def name(self):
        """
        Stores the name
        """
        pass


class SubSubClass(SubClass):

    def say_hello(self):
        print("I can't say hello")

    say_hi = say_hello

    @property
    def name(self):
        pass


class MetaTest(unittest.TestCase):

    def test_should_include_docs_from_superclass(self):
        "should include doc from superclass"
        self.assertEqual(
            SuperClass.say_hello.__doc__,
            SubClass.say_hello.__doc__
        )

    def test_should_include_docs_from_any_class_in_hierarchy(self):
        "should include doc from any class in hierarchy"
        self.assertEqual(
            SuperClass.say_hello.__doc__,
            SubSubClass.say_hello.__doc__
        )

    def test_change_docs_for_readonly_properties(self):
        "should also change docs for readonly properties"
        self.assertEqual(SubClass.name.__doc__, SubSubClass.name.__doc__)

    def test_should_not_touch_the_class_type(self):
        "shouldn't touch the type of the object"
        self.assertEqual('SubSubClass', SubSubClass.__name__)

########NEW FILE########
__FILENAME__ = test_request_handler
# -*- coding: utf-8 -*-

# Copyright 2012 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

import os
import unittest

from ssl import SSLError

from .fake_webapp import EXAMPLE_APP
from splinter.request_handler.request_handler import RequestHandler
from splinter.request_handler.status_code import HttpResponseError
from tests import TESTS_ROOT


class RequestHandlerTestCase(unittest.TestCase):

    def setUp(self):
        self.request = RequestHandler()
        self.request.connect(EXAMPLE_APP)

    def test_should_receive_an_url_and_get_a_success_response(self):
        self.assertTrue(self.request.status_code.is_success())

    def test_should_start_a_request_with_localhost(self):
        self.assertEqual("127.0.0.1", self.request.host)

    def test_should_start_a_request_with_port_5000(self):
        self.assertEqual(5000, self.request.port)

    def test_should_visit_alert_page_and_get_a_success_response(self):
        request = RequestHandler()
        request.connect(EXAMPLE_APP + "alert")
        self.assertTrue(request.status_code.is_success())

    def test_should_compare_app_index_with_404_and_get_false(self):
        self.assertFalse(self.request.status_code == 404)

    def test_is_success_should_be_false_when_url_does_not_exists(self):
        request = RequestHandler()
        request.connect(EXAMPLE_APP + "page-that-doesnt-exists")
        self.assertFalse(request.status_code.is_success())

    def test_should_get_an_absent_url_and_raise_an_exception(self):
        with self.assertRaises(HttpResponseError):
            request = RequestHandler()
            request.connect(EXAMPLE_APP + "page-that-doesnt-exists")
            request.ensure_success_response()

    def test_should_get_an_exception_and_format_it(self):
        request = RequestHandler()
        request.connect(EXAMPLE_APP + "page-that-doesnt-exists")
        try:
            request.ensure_success_response()
        except HttpResponseError as e:
            exception = e.msg
        self.assertEqual("404 - Not Found", exception)

    def test_should_be_able_to_represent_exception_as_string(self):
        "HttpResponseError exception should be representable as string"
        error = HttpResponseError(404, "Not Found")
        self.assertEqual("404 - Not Found", str(error))

    def test_should_not_connect_to_non_http_protocols(self):
        mockfile_path = "file://%s" % os.path.join(TESTS_ROOT, "mockfile.txt")
        request = RequestHandler()
        request.connect(mockfile_path)
        self.assertTrue(request.status_code.is_success())

    def test_should_connect_to_pages_with_query_string(self):
        request = RequestHandler()
        url = EXAMPLE_APP + "query?model"
        request.connect(url)
        self.assertTrue(request.status_code.is_success())

    def test_should_connect_to_https_protocols(self):
        # We do not run an HTTPS server, but we know we handle https
        # if we get an SSLError accessing a non-HTTPS site.
        with self.assertRaises(SSLError):
            request = RequestHandler()
            url = EXAMPLE_APP.replace('http', 'https')
            request.connect(url)
            self.assertEqual(request.scheme, 'https')

    def test_should_set_user_agent(self):
        request = RequestHandler()
        url = EXAMPLE_APP + 'useragent'
        request.connect(url)
        self.assertEqual(b'python/splinter', request.response.read())

    def test_should_be_able_to_connect_with_basic_auth(self):
        request = RequestHandler()
        url = 'http://admin:secret@localhost:5000/authenticate'
        request.connect(url)
        self.assertEqual(b'Success!', request.response.read())

########NEW FILE########
__FILENAME__ = test_webdriver_chrome
# -*- coding: utf-8 -*-

# Copyright 2013 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

import os
import unittest

from splinter import Browser
from .fake_webapp import EXAMPLE_APP
from .base import WebDriverTests
from selenium.common.exceptions import WebDriverException


def chrome_installed():
    try:
        Browser("chrome")
    except WebDriverException:
        return False
    return True


@unittest.skipIf(not chrome_installed(), 'chrome is not installed')
class ChromeBrowserTest(WebDriverTests, unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls.browser = Browser("chrome")

    @classmethod
    def tearDownClass(cls):
        cls.browser.quit()

    def setUp(self):
        self.browser.visit(EXAMPLE_APP)

    def test_attach_file(self):
        "should provide a way to change file field value"
        file_path = os.path.join(
            os.path.abspath(os.path.dirname(__file__)),
            'mockfile.txt'
        )
        self.browser.attach_file('file', file_path)
        self.browser.find_by_name('upload').click()

        html = self.browser.html
        assert b'text/plain' in html
        assert open(file_path).read().encode('utf-8') in html

    def test_should_support_with_statement(self):
        with Browser('chrome') as internet:
            pass


@unittest.skipIf(not chrome_installed(), 'chrome is not installed')
class ChromeBrowserFullscreenTest(WebDriverTests, unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls.browser = Browser("chrome", fullscreen=True)

    @classmethod
    def tearDownClass(cls):
        cls.browser.quit()

    def setUp(self):
        self.browser.visit(EXAMPLE_APP)

    def test_should_support_with_statement(self):
        with Browser('chrome', fullscreen=True) as internet:
            pass

########NEW FILE########
__FILENAME__ = test_webdriver_firefox
# -*- coding: utf-8 -*-

# Copyright 2013 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

import os
import unittest

from splinter import Browser
from .fake_webapp import EXAMPLE_APP
from .base import WebDriverTests


def firefox_installed():
    try:
        Browser("firefox")
    except OSError:
        return False
    return True


@unittest.skipIf(not firefox_installed(), 'firefox is not installed')
class FirefoxBrowserTest(WebDriverTests, unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        cls.browser = Browser("firefox")

    @classmethod
    def tearDownClass(cls):
        cls.browser.quit()

    def setUp(self):
        self.browser.visit(EXAMPLE_APP)

    def test_attach_file(self):
        "should provide a way to change file field value"
        file_path = os.path.join(
            os.path.abspath(os.path.dirname(__file__)),
            'mockfile.txt'
        )
        self.browser.attach_file('file', file_path)
        self.browser.find_by_name('upload').click()

        html = self.browser.html
        assert b'text/plain' in html
        assert open(file_path).read().encode('utf-8') in html

    def test_should_support_with_statement(self):
        with Browser('firefox') as internet:
            pass


@unittest.skipIf(not firefox_installed(), 'firefox is not installed')
class FirefoxWithExtensionTest(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        extension_path = os.path.join(
            os.path.abspath(os.path.dirname(__file__)),
            'firebug.xpi'
        )
        cls.browser = Browser('firefox', extensions=[extension_path])

    def test_create_a_firefox_instance_with_extension(self):
        "should be able to load an extension"
        self.assertIn(
            'firebug@software.joehewitt.com',
            os.listdir(self.browser.driver.profile.extensionsDir)
        )

    @classmethod
    def tearDownClass(cls):
        cls.browser.quit()


@unittest.skipIf(not firefox_installed(), 'firefox is not installed')
class FirefoxBrowserProfilePreferencesTest(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        preferences = {
            'dom.max_script_run_time': 360,
            'devtools.inspector.enabled': True,
        }
        cls.browser = Browser("firefox", profile_preferences=preferences)

    def test_preference_set(self):
        preferences = self.browser.driver.profile.default_preferences
        self.assertIn('dom.max_script_run_time', preferences)
        value = preferences.get('dom.max_script_run_time')
        self.assertEqual(int(value), 360)

    @classmethod
    def tearDownClass(cls):
        cls.browser.quit()

########NEW FILE########
__FILENAME__ = test_webdriver_phantomjs
import unittest

from splinter import Browser
from .fake_webapp import EXAMPLE_APP
from .base import WebDriverTests


class PhantomJSBrowserTest(WebDriverTests, unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        cls.browser = Browser("phantomjs")

    @classmethod
    def tearDownClass(cls):
        cls.browser.quit()

    def setUp(self):
        self.browser.visit(EXAMPLE_APP)

    def test_get_alert(self):
        with self.assertRaises(NotImplementedError):
            self.browser.get_alert()

    def test_right_click(self):
        with self.assertRaises(NotImplementedError):
            self.browser.find_by_id('visible').right_click()

    def test_double_click(self):
        with self.assertRaises(NotImplementedError):
            self.browser.find_by_id('visible').double_click()

    def test_access_prompts_and_be_able_to_fill_then(self):
        with self.assertRaises(NotImplementedError):
            self.browser.get_alert()

    def test_access_confirm_and_accept_and_dismiss_them_using_with(self):
        with self.assertRaises(NotImplementedError):
            self.browser.get_alert()

    def test_access_confirm_and_accept_and_dismiss_them(self):
        with self.assertRaises(NotImplementedError):
            self.browser.get_alert()

    def test_access_alerts_using_with(self):
        with self.assertRaises(NotImplementedError):
            self.browser.get_alert()

    def test_access_alerts_and_accept_them(self):
        with self.assertRaises(NotImplementedError):
            self.browser.get_alert()

    def test_can_work_on_popups(self):
        # FIXME: Check https://github.com/detro/ghostdriver/issues/180 to see if
        # we can implement this test
        pass


class PhantomJSBrowserTestWithCustomHeaders(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        custom_headers = {'X-Splinter-Customheaders-1': 'Hello',
                          'X-Splinter-Customheaders-2': 'Bye'}
        cls.browser = Browser("phantomjs", custom_headers=custom_headers)

    def test_create_a_phantomjs_with_custom_headers(self):
        self.browser.visit(EXAMPLE_APP + 'headers')
        self.assertTrue(
            self.browser.is_text_present('X-Splinter-Customheaders-1: Hello'))
        self.assertTrue(
            self.browser.is_text_present('X-Splinter-Customheaders-2: Bye'))

    @classmethod
    def tearDownClass(cls):
        cls.browser.quit()

########NEW FILE########
__FILENAME__ = test_webdriver_remote
# -*- coding: utf-8 -*-

# Copyright 2013 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

try:
    from urllib import urlopen
except ImportError:
    from urllib.request import urlopen
import unittest

from splinter import Browser
from .fake_webapp import EXAMPLE_APP
from .base import WebDriverTests

import subprocess


def selenium_server_is_running():
    try:
        from splinter.driver.webdriver.remote import WebDriver
        page_contents = urlopen(WebDriver.DEFAULT_URL).read()
    except IOError:
        return False
    return 'WebDriver Hub' in page_contents


@unittest.skipIf(
    not selenium_server_is_running(),
    'Skipping the remote webdriver tests'
)
class RemoteBrowserTest(WebDriverTests, unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls.browser = Browser("remote")

    @classmethod
    def tearDownClass(cls):
        cls.browser.quit()

    def setUp(self):
        self.browser.visit(EXAMPLE_APP)

    def test_support_with_statement(self):
        "Remote should support with statement"
        with Browser('remote') as remote:
            pass

    def test_mouse_over(self):
        "Remote should not support mouseover"
        with self.assertRaises(NotImplementedError):
            self.browser.find_by_id('visible').mouse_over()

    def test_mouse_out(self):
        "Remote should not support mouseout"
        with self.assertRaises(NotImplementedError):
            self.browser.find_by_id('visible').mouse_out()

    def test_double_click(self):
        "Remote should not support double_click"
        with self.assertRaises(NotImplementedError):
            self.browser.find_by_id('visible').double_click()

    def test_right_click(self):
        "Remote should not support right_click"
        with self.assertRaises(NotImplementedError):
            self.browser.find_by_id('visible').right_click()

    def test_drag_and_drop(self):
        "Remote should not support drag_and_drop"
        with self.assertRaises(NotImplementedError):
            droppable = self.browser.find_by_css('.droppable')
            self.browser.find_by_css('.draggable').drag_and_drop(droppable)

    def test_mouseover_should_be_an_alias_to_mouse_over(self):
        "Remote should not support mouseover"
        with self.assertRaises(NotImplementedError):
            self.browser.find_by_id('visible').mouseover()

    def test_mouseout_should_be_an_alias_to_mouse_out_and_be_deprecated(self):
        "Remote should not support mouseout"
        with self.assertRaises(NotImplementedError):
            self.browser.find_by_id('visible').mouseout()

    def test_create_and_access_a_cookie(self):
        "Remote should not support cookies"
        with self.assertRaises(NotImplementedError):
            self.browser.cookies.add({'sha': 'zam'})

    def test_create_some_cookies_and_delete_them_all(self):
        "Remote should not support cookies"
        with self.assertRaises(NotImplementedError):
            self.browser.cookies.delete()

    def test_create_and_delete_a_cookie(self):
        "Remote should not support cookies"
        with self.assertRaises(NotImplementedError):
            self.browser.cookies.delete('cookie')

    def test_create_and_delete_many_cookies(self):
        "Remote should not support cookies"
        with self.assertRaises(NotImplementedError):
            self.browser.cookies.delete('cookie', 'notacookie')

    def test_try_to_destroy_an_absent_cookie_and_nothing_happens(self):
        "Remote should not support cookies"
        with self.assertRaises(NotImplementedError):
            self.browser.cookies.delete('mwahahahaha')

########NEW FILE########
__FILENAME__ = test_zopetestbrowser
# -*- coding: utf-8 -*-

# Copyright 2013 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

import os
import unittest
import sys

from splinter import Browser
from .base import BaseBrowserTests
from .fake_webapp import EXAMPLE_APP


@unittest.skipIf(sys.version_info[0] > 2,
                 'zope.testbrowser is not currently compatible with Python 3')
class ZopeTestBrowserDriverTest(BaseBrowserTests, unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls.browser = Browser('zope.testbrowser', wait_time=0.1)

    def setUp(self):
        self.browser.visit(EXAMPLE_APP)

    @classmethod
    def tearDownClass(self):
        self.browser.quit()

    def test_should_support_with_statement(self):
        with Browser('zope.testbrowser') as internet:
            pass

    def test_attach_file(self):
        "should provide a way to change file field value"
        file_path = os.path.join(
            os.path.abspath(os.path.dirname(__file__)),
            'mockfile.txt'
        )
        self.browser.attach_file('file', file_path)
        self.browser.find_by_name('upload').click()

        html = self.browser.html
        assert b'text/plain' in html
        assert open(file_path).read().encode('utf-8') in html

    def test_forward_to_none_page(self):
        "should not fail when trying to forward to none"
        browser = Browser('zope.testbrowser')
        browser.visit(EXAMPLE_APP)
        browser.forward()
        self.assertEqual(EXAMPLE_APP, browser.url)
        browser.quit()

    def test_cant_switch_to_frame(self):
        "zope.testbrowser should not be able to switch to frames"
        with self.assertRaises(NotImplementedError) as cm:
            self.browser.get_iframe('frame_123')
            self.fail()

        e = cm.exception
        self.assertEqual("zope.testbrowser doesn't support frames.", e.args[0])

    def test_simple_type(self):
        """
        zope.testbrowser won't support type method
        because it doesn't interact with JavaScript
        """
        with self.assertRaises(NotImplementedError):
            self.browser.type('query', 'with type method')

    def test_simple_type_on_element(self):
        """
        zope.testbrowser won't support type method
        because it doesn't interact with JavaScript
        """
        with self.assertRaises(NotImplementedError):
            self.browser.find_by_name('query').type('with type method')

    def test_slowly_typing(self):
        """
        zope.testbrowser won't support type method
        because it doesn't interact with JavaScript
        """
        with self.assertRaises(NotImplementedError):
            self.browser.type('query', 'with type method', slowly=True)

    def test_slowly_typing_on_element(self):
        """
        zope.testbrowser won't support type method
        on element because it doesn't interac with JavaScript
        """
        with self.assertRaises(NotImplementedError):
            query = self.browser.find_by_name('query')
            query.type('with type method', slowly=True)

    def test_cant_mouseover(self):
        "zope.testbrowser should not be able to put the mouse over the element"
        with self.assertRaises(NotImplementedError):
            self.browser.find_by_css('#visible').mouse_over()

    def test_cant_mouseout(self):
        "zope.testbrowser should not be able to mouse out of an element"
        with self.assertRaises(NotImplementedError):
            self.browser.find_by_css('#visible').mouse_out()

    def test_links_with_nested_tags_xpath(self):
        links = self.browser.find_by_xpath('//a/span[text()="first bar"]/..')
        self.assertEqual(
            len(links), 1,
            'Found not exactly one link with a span with text "BAR ONE". %s' % (
                map(lambda item: item.outer_html, links)))

    def test_finding_all_links_by_non_ascii_text(self):
        "should find links by non ascii text"
        non_ascii_encodings = {
            'pangram_pl': u'Jeżu klątw, spłódź Finom część gry hańb!',
            'pangram_ja': u'天 地 星 空',
            'pangram_ru': u'В чащах юга жил бы цитрус? Да, но фальшивый экземпляр!',
            'pangram_eo': u'Laŭ Ludoviko Zamenhof bongustas freŝa ĉeĥa manĝaĵo kun spicoj.',
        }
        for key, text in non_ascii_encodings.iteritems():
            link = self.browser.find_link_by_text(text)
            self.assertEqual(key, link['id'])

########NEW FILE########
__FILENAME__ = type
# -*- coding: utf-8 -*-

# Copyright 2012 splinter authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

from .fake_webapp import EXAMPLE_APP


class SlowlyTypeTest(object):

    def test_simple_type(self):
        "should provide a away to change field value using type method"
        self.browser.visit(EXAMPLE_APP)
        self.browser.type('query', ' with type method')
        value = self.browser.find_by_name('query').value
        self.assertEqual('default value with type method', value)

        self.browser.type('description', 'type into textarea')
        value = self.browser.find_by_name('description').value
        self.assertEqual('type into textarea', value)

    def test_simple_type_on_element(self):
        self.browser.visit(EXAMPLE_APP)
        self.browser.find_by_name('query').type(' with type method')
        value = self.browser.find_by_name('query').value
        self.assertEqual('default value with type method', value)

        self.browser.find_by_name('description').type('type into textarea')
        value = self.browser.find_by_name('description').value
        self.assertEqual('type into textarea', value)

    def test_slowly_typing(self):
        "should be able to slowly type some text in a field"
        for name in ['type-input', 'type-textarea']:
            self.browser.visit(EXAMPLE_APP + 'type')
            num = 0
            num_max = 6
            for key in self.browser.type(name, 'typing', slowly=True):
                self.assertEqual(self.browser.is_text_present("#%d" % num), True)
                num += 1
            self.assertEqual(num, num_max)

            element = self.browser.find_by_name(name)
            self.assertEqual(element.value, 'typing')

    def test_slowly_typing_on_element(self):
        for name in ['type-input', 'type-textarea']:
            self.browser.visit(EXAMPLE_APP + 'type')
            num = 0
            num_max = 6
            text_input = self.browser.find_by_name(name)
            typing = text_input.type('typing', slowly=True)
            for key in typing:
                self.assertEqual(self.browser.is_text_present("#%d" % num), True)
                num += 1
            self.assertEqual(num, num_max)

            element = self.browser.find_by_name(name)
            self.assertEqual(element.value, 'typing')

########NEW FILE########
