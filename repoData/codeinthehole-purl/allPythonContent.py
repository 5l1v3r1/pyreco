__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# purl documentation build configuration file, created by
# sphinx-quickstart on Thu Jun 14 15:41:49 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('..'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
import datetime
project = u'purl'
copyright = u'%s, David Winterbottom' % datetime.date.today().year

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.

from purl import __version__
version = __version__
# The full version, including alpha/beta/rc tags.
release = __version__

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'purldoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'purl.tex', u'purl Documentation',
   u'David Winterbottom', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'purl', u'purl Documentation',
     [u'David Winterbottom'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'purl', u'purl Documentation',
   u'David Winterbottom', 'purl', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = template
import re
import functools

try:
    from urllib.parse import quote
except ImportError:
    # Python 2
    from urllib import quote

from . import url


__all__ = ['Template', 'expand']


patterns = re.compile("{([^\}]+)}")


class Template(object):

    def __init__(self, url_str):
        self._base = url_str

    def expand(self, variables=None):
        return url.URL(expand(self._base, variables))


def expand(template, variables=None):
    """
    Expand a URL template string using the passed variables
    """
    if variables is None:
        variables = {}
    return patterns.sub(functools.partial(_replace, variables), template)


# Utils

def _flatten(container):
    """
    _flatten a sequence of sequences into a single list
    """
    _flattened = []
    for sequence in container:
        _flattened.extend(sequence)
    return _flattened

# Format functions
# ----------------
# These are responsible for formatting the (key, value) pair into a string

def _format_pair_no_equals(explode, separator, escape, key, value):
    """
    Format a key, value pair but don't include the equals sign
    when there is no value
    """
    if not value:
        return key
    return _format_pair(explode, separator, escape, key, value)

def _format_pair_with_equals(explode, separator, escape, key, value):
    """
    Format a key, value pair including the equals sign
    when there is no value
    """
    if not value:
        return key + '='
    return _format_pair(explode, separator, escape, key, value)

def _format_pair(explode, separator, escape, key, value):
    if isinstance(value, (list, tuple)):
        join_char = ","
        if explode:
            join_char = separator
        try:
            dict(value)
        except:
            # Scalar container
            if explode:
                items = ["%s=%s" % (key, escape(v)) for v in value]
                return join_char.join(items)
            else:
                escaped_value = join_char.join(map(escape, value))
        else:
            # Tuple container
            if explode:
                items = ["%s=%s" % (k, escape(v)) for (k,v) in value]
                return join_char.join(items)
            else:
                items = _flatten(value)
                escaped_value = join_char.join(map(escape, items))
    else:
        escaped_value = escape(value)
    return '%s=%s' % (key, escaped_value)

def _format_default(explode, separator, escape, key, value):
    if isinstance(value, (list, tuple)):
        join_char = ","
        if explode:
            join_char = separator
        try:
            dict(value)
        except:
            # Scalar container
            escaped_value = join_char.join(map(escape, value))
        else:
            # Tuple container
            if explode:
                items = ["%s=%s" % (k, escape(v)) for (k,v) in value]
                escaped_value = join_char.join(items)
            else:
                items = _flatten(value)
                escaped_value = join_char.join(map(escape, items))
    else:
        escaped_value = escape(value)
    return escaped_value


# Modifer functions
# -----------------
# These are responsible for modifying the variable before formatting

_identity = lambda x: x

def _truncate(string, num_chars):
    return string[:num_chars]

# Splitting functions
# -------------------
# These are responsible for splitting a string into a sequence of (key,
# modifier) tuples

def _split_basic(string):
    """
    Split a string into a list of tuples of the form
    (key, modifier_fn, explode) where modifier_fn is a function that applies the
    appropriate modification to the variable.
    """
    tuples = []
    for word in string.split(','):
        # Attempt to split on colon
        parts = word.split(':', 2)
        key, modifier_fn, explode = parts[0], _identity, False
        if len(parts) > 1:
            modifier_fn = functools.partial(
                _truncate, num_chars=int(parts[1]))
        if word[len(word) - 1] == '*':
            key = word[:len(word) - 1]
            explode = True
        tuples.append((key, modifier_fn, explode))
    return tuples

def _split_operator(string):
    return _split_basic(string[1:])

# Escaping functions
# ------------------

def _escape_all(value):
    return quote(str(value), safe="")

def _escape_reserved(value):
    return quote(str(value), safe="/!,.;")

# Operator map
# ------------
# A mapping of:
#     operator -> (prefix, separator, split_fn, escape_fn, format_fn)
operator_map = {
    '+': ('', ',', _split_operator, _escape_reserved, _format_default),
    '#': ('#', ',', _split_operator, _escape_reserved, _format_default),
    '.': ('.', '.', _split_operator, _escape_all, _format_default),
    '/': ('/', '/', _split_operator, _escape_all, _format_default),
    ';': (';', ';', _split_operator, _escape_all, _format_pair_no_equals),
    '?': ('?', '&', _split_operator, _escape_all, _format_pair_with_equals),
    '&': ('&', '&', _split_operator, _escape_all, _format_pair_with_equals),
}
defaults = ('', ',', _split_basic, _escape_all, _format_default)


def _replace(variables, match):
    """
    Return the appropriate replacement for `match` using the passed variables
    """
    expression = match.group(1)

    # Look-up chars and functions for the specified operator
    prefix_char, separator_char, split_fn, escape_fn, format_fn = operator_map.get(
        expression[0], defaults)

    replacements = []
    for key, modify_fn, explode in split_fn(expression):
        if key in variables:
            variable = modify_fn(variables[key])
            replacement = format_fn(explode, separator_char, escape_fn, key, variable)
            replacements.append(replacement)
    return prefix_char + separator_char.join(replacements)

########NEW FILE########
__FILENAME__ = url
from __future__ import unicode_literals

try:
    from urllib.parse import parse_qs, urlencode, urlparse, quote, unquote
except ImportError:
    from urllib import urlencode, quote, unquote
    from urlparse import parse_qs, urlparse
from collections import namedtuple
import sys

import six


# To minimise memory consumption, we use a namedtuple to store all instance
# variables, as well as using the __slots__ attribute.
_URLTuple = namedtuple(
    "_URLTuple", "host username password scheme port path query fragment")


# Encoding helpers


def to_unicode(string):
    """
    Ensure a passed string is unicode
    """
    if isinstance(string, six.binary_type):
        return string.decode('utf8')
    return string


def to_utf8(string):
    """
    Encode a string as a UTF8 bytestring.  This function could be passed a
    bytestring or unicode string so must distinguish between the two.
    """
    if isinstance(string, six.text_type):
        return string.encode('utf8')
    return string


def dict_to_unicode(raw_dict):
    """
    Ensure all keys and values in a dict are unicode.

    The passed dict is assumed to have lists for all values.
    """
    decoded = {}
    for key, value in raw_dict.items():
        decoded[to_unicode(key)] = map(
            to_unicode, value)
    return decoded


def unicode_quote(string, safe='/'):
    if string is None:
        return None
    return quote(to_utf8(string), to_utf8(safe))


def unicode_unquote(string):
    if string is None:
        return None
    if six.PY3:
        return unquote(string)
    return to_unicode(unquote(to_utf8(string)))


def unicode_urlencode(query, doseq=True):
    """
    Custom wrapper around urlencode to support unicode

    Python urlencode doesn't handle unicode well so we need to convert to
    bytestrings before using it:
    http://stackoverflow.com/questions/6480723/urllib-urlencode-doesnt-like-unicode-values-how-about-this-workaround
    """
    pairs = []
    for key, value in query.items():
        if isinstance(value, list):
            value = list(map(to_utf8, value))
        else:
            value = to_utf8(value)
        pairs.append((to_utf8(key), value))
    encoded_query = dict(pairs)
    return urlencode(encoded_query, doseq)


def parse(url_str):
    """
    Extract all parts from a URL string and return them as a dictionary
    """
    url_str = to_unicode(url_str)

    result = urlparse(url_str)
    netloc_parts = result.netloc.split('@')
    if len(netloc_parts) == 1:
        username = password = None
        host = netloc_parts[0]
    else:
        username, password = netloc_parts[0].split(':')
        host = netloc_parts[1]

    if host and ':' in host:
        host = host.split(':')[0]

    return {'host': host,
            'username': username,
            'password': password,
            'scheme': result.scheme,
            'port': result.port,
            'path': result.path,
            'query': result.query,
            'fragment': result.fragment}


class URL(object):
    """
    The constructor can be used in two ways:

    1. Pass a URL string::

        >>> URL('http://www.google.com/search?q=testing').as_string()
        u'http://www.google.com/search?q=testing'

    2. Pass keyword arguments::

        >>> URL(host='www.google.com', path='/search', query='q=testing').as_string()
        u'http://www.google.com/search?q=testing'

    If you pass both a URL string and keyword args, then the values of keyword
    args take precedence.
    """

    __slots__ = ("_tuple",)

    def __init__(self, url_str=None, host=None, username=None, password=None,
                 scheme=None, port=None, path=None, query=None, fragment=None):
        if url_str is not None:
            params = parse(url_str)
        else:
            # Defaults
            params = {'scheme': 'http',
                      'username': None,
                      'password': None,
                      'host': None,
                      'port': None,
                      'path': '/',
                      'query': None,
                      'fragment': None}

        # Kwargs override the url_str
        for var in 'host username password scheme port path query fragment'.split():
            if locals()[var] is not None:
                params[var] = locals()[var]

        # Store the various components in %-encoded form
        self._tuple = _URLTuple(params['host'],
                                unicode_quote(params['username']),
                                unicode_quote(params['password']),
                                params['scheme'],
                                params['port'],
                                params['path'],
                                params['query'],
                                unicode_quote(params['fragment']))

    def __eq__(self, other):
        return self._tuple == other._tuple

    def __ne__(self, other):
        return self._tuple != other._tuple

    def __getstate__(self):
        return tuple(self._tuple)

    def __setstate__(self, state):
        self._tuple = _URLTuple(*state)

    def __hash__(self):
        return hash(self._tuple)

    def __repr__(self):
        return str(self._tuple)

    def __unicode__(self):
        url = self._tuple
        parts = ["%s://" % url.scheme if url.scheme else '',
                 self.netloc(),
                 url.path,
                 '?%s' % url.query if url.query else '',
                 '#%s' % url.fragment if url.fragment else '']
        if url.host is None:
            return ''.join(parts[2:])
        return ''.join(parts)

    __str__ = as_string = __unicode__

    # Accessors / Mutators
    # These use the jQuery overloading style whereby they become mutators if
    # extra args are passed

    def netloc(self):
        """
        Return the netloc
        """
        url = self._tuple
        if url.username and url.password:
            netloc = '%s:%s@%s' % (url.username, url.password, url.host)
        else:
            netloc = url.host
        if url.port:
            netloc = '%s:%s' % (netloc, url.port)
        return netloc

    def host(self, value=None):
        """
        Return the host

        :param string value: new host string
        """
        if value:
            return URL._mutate(self, host=value)
        return self._tuple.host

    domain = host

    def username(self):
        """
        Return the username
        """
        return unicode_unquote(self._tuple.username)

    def password(self):
        """
        Return the password
        """
        return unicode_unquote(self._tuple.password)

    def subdomains(self, value=None):
        """
        Returns a list of subdomains or set the subdomains and returns a
        new :class:`URL` instance.

        :param list value: a list of subdomains
        """
        if value is not None:
            return URL._mutate(self, host='.'.join(value))
        return self.host().split('.')

    def subdomain(self, index, value=None):
        """
        Return a subdomain or set a new value and return a new :class:`URL`
        instance.

        :param integer index: 0-indexed subdomain
        :param string value: New subdomain
        """
        if value is not None:
            subdomains = self.subdomains()
            subdomains[index] = value
            return URL._mutate(self, host='.'.join(subdomains))
        return self.subdomains()[index]

    def scheme(self, value=None):
        """
        Return or set the scheme.

        :param string value: the new scheme to use
        :returns: string or new :class:`URL` instance
        """
        if value:
            return URL._mutate(self, scheme=value)
        return self._tuple.scheme

    def path(self, value=None):
        """
        Return or set the path

        :param string value: the new path to use
        :returns: string or new :class:`URL` instance
        """
        if value:
            if not value.startswith('/'):
                value = '/' + value
            return URL._mutate(self, path=value)
        return self._tuple.path

    def query(self, value=None):
        """
        Return or set the query string

        :param string value: the new query string to use
        :returns: string or new :class:`URL` instance
        """
        if value:
            return URL._mutate(self, query=value)
        return self._tuple.query

    def port(self, value=None):
        """
        Return or set the port

        :param string value: the new port to use
        :returns: string or new :class:`URL` instance
        """
        if value:
            return URL._mutate(self, port=value)
        return self._tuple.port

    def fragment(self, value=None):
        """
        Return or set the fragment (hash)

        :param string value: the new fragment to use
        :returns: string or new :class:`URL` instance
        """
        if value:
            return URL._mutate(self, fragment=value)
        return unicode_unquote(self._tuple.fragment)

    # ====
    # Path
    # ====

    def path_segment(self, index, value=None, default=None):
        """
        Return the path segment at the given index

        :param integer index:
        :param string value: the new segment value
        :param string default: the default value to return if no path segment exists with the given index
        """
        if value is not None:
            segments = list(self.path_segments())
            segments[index] = value
            new_path = '/' + '/'.join(segments)
            if self._tuple.path.endswith('/'):
                new_path += '/'
            return URL._mutate(self, path=new_path)
        try:
            return self.path_segments()[index]
        except IndexError:
            return default

    def path_segments(self, value=None):
        """
        Return the path segments

        :param list value: the new path segments to use
        """
        if value is not None:
            encoded_values = map(unicode_quote, value)
            new_path = '/' + '/'.join(encoded_values)
            return URL._mutate(self, path=new_path)
        parts = self._tuple.path.split('/')
        segments = parts[1:]
        if self._tuple.path.endswith('/'):
            segments.pop()
        segments = map(unicode_unquote, segments)
        return tuple(segments)

    def add_path_segment(self, value):
        """
        Add a new path segment to the end of the current string

        :param string value: the new path segment to use

        Example::

            >>> u = URL('http://example.com/foo/')
            >>> u.add_path_segment('bar').as_string()
            u'http://example.com/foo/bar'
        """
        segments = self.path_segments() + (value,)
        return self.path_segments(segments)

    # ============
    # Query params
    # ============

    def has_query_param(self, key):
        """
        Test if a given query parameter is present

        :param string key: key to test for
        """
        return self.query_param(key) is not None

    def has_query_params(self, keys):
        """
        Test if a given set of query parameters are present

        :param list keys: keys to test for
        """
        return all([self.has_query_param(k) for k in keys])

    def query_param(self, key, value=None, default=None, as_list=False):
        """
        Return or set a query parameter for the given key

        The value can be a list.

        :param string key: key to look for
        :param string default: value to return if ``key`` isn't found
        :param boolean as_list: whether to return the values as a list
        :param string value: the new query parameter to use
        """
        parse_result = self.query_params()
        if value is not None:
            parse_result[key] = value
            return URL._mutate(
                self, query=unicode_urlencode(parse_result, doseq=True))

        try:
            result = parse_result[key]
        except KeyError:
            return default
        if as_list:
            return result
        return result[0] if len(result) == 1 else result

    def append_query_param(self, key, value):
        """
        Append a query parameter

        :param string key: The query param key
        :param string value: The new value
        """
        values = self.query_param(key, as_list=True, default=[])
        values.append(value)
        return self.query_param(key, values)

    def query_params(self, value=None):
        """
        Return or set a dictionary of query params

        :param dict value: new dictionary of values
        """
        if value is not None:
            return URL._mutate(self, query=unicode_urlencode(value, doseq=True))
        query = '' if self._tuple.query is None else self._tuple.query

        # In Python 2.6, urlparse needs a bytestring so we encode and then
        # decode the result.
        if not six.PY3:
            result = parse_qs(to_utf8(query), True)
            return dict_to_unicode(result)

        return parse_qs(query, True)

    def remove_query_param(self, key, value=None):
        """
        Remove a query param from a URL

        Set the value parameter if removing from a list.

        :param string key: The key to delete
        :param string value: The value of the param to delete (of more than one)
        """
        parse_result = self.query_params()
        if value is not None:
            index = parse_result[key].index(value)
            del parse_result[key][index]
        else:
            del parse_result[key]
        return URL._mutate(self, query=unicode_urlencode(parse_result, doseq=True))

    @classmethod
    def _mutate(cls, url, **kwargs):
        args = url._tuple._asdict()
        args.update(kwargs)
        return cls(**args)

    @classmethod
    def from_string(cls, url_str):
        """
        Factory method to create a new instance based on a passed string

        This method is deprecated now
        """
        return cls(url_str)

########NEW FILE########
__FILENAME__ = expansion_tests
import collections

from nose.tools import eq_

from purl.template import expand

# Define variables as in the RFC (http://tools.ietf.org/html/rfc6570)
level2_vars = {
    'var': 'value',
    'hello': 'Hello World!',
    'path': '/foo/bar'
}
level3_vars = level2_vars.copy()
level3_vars.update({
    'empty': '',
    'x': '1024',
    'y': '768'
})
level4_vars = level2_vars.copy()
level4_vars.update({
    'list': ['red', 'green', 'blue'],
    'keys': [('semi', ';'), ('dot', '.'), ('comma', ',')]
})

data = [
    # Level 1
    ('http://example.com/~{username}', {'username': 'hello'}, 'http://example.com/~hello'),
    ('http://example.com/~{username}', {'username': 'hello world'}, 'http://example.com/~hello%20world'),
    # Level 2 - reserved expansion
    ('{+var}', level2_vars, 'value'),
    ('{+hello}', level2_vars, 'Hello%20World!'),
    ('{+path}/here', level2_vars, '/foo/bar/here'),
    ('here?ref={+path}', level2_vars, 'here?ref=/foo/bar'),
    # Level 2 - fragment expansion
    ('X{#var}', level2_vars, 'X#value'),
    ('X{#hello}', level2_vars, 'X#Hello%20World!'),
    # Level 3 - string expansion with multiple variables
    ('map?{x,y}', level3_vars, 'map?1024,768'),
    ('{x,hello,y}', level3_vars, '1024,Hello%20World%21,768'),
    # Level 3 - reserved expansion with multiple variables
    ('{+x,hello,y}', level3_vars, '1024,Hello%20World!,768'),
    ('{+path,x}/here', level3_vars, '/foo/bar,1024/here'),
    # Level 3 - fragment expansion with multiple variables
    ('{#x,hello,y}', level3_vars, '#1024,Hello%20World!,768'),
    ('{#path,x}/here', level3_vars, '#/foo/bar,1024/here'),
    # Level 3 - label expansion
    ('X{.var}', level3_vars, 'X.value'),
    ('X{.x,y}', level3_vars, 'X.1024.768'),
    # Level 3 - path segments, slash prefixed
    ('{/var}', level3_vars, '/value'),
    ('{/var,x}/here', level3_vars, '/value/1024/here'),
    # Level 3 - path segments, semi-colon prefixed
    ('{;x,y}', level3_vars, ';x=1024;y=768'),
    ('{;x,y,empty}', level3_vars, ';x=1024;y=768;empty'),
    # Level 3 - form-style query, ampersand-separated
    ('{?x,y}', level3_vars, '?x=1024&y=768'),
    ('{?x,y,empty}', level3_vars, '?x=1024&y=768&empty='),
    # Level 3 - form-style query continuation
    ('?fixed=yes{&x}', level3_vars, '?fixed=yes&x=1024'),
    ('{&x,y,empty}', level3_vars, '&x=1024&y=768&empty='),
    # Level 4 - string expansion with value modifiers
    ('{var:3}', level4_vars, 'val'),
    ('{var:30}', level4_vars, 'value'),
    ('{list}', level4_vars, 'red,green,blue'),
    ('{list*}', level4_vars, 'red,green,blue'),
    ('{keys}', level4_vars, 'semi,%3B,dot,.,comma,%2C'),
    ('{keys*}', level4_vars, 'semi=%3B,dot=.,comma=%2C'),
    # Level 4 - reserved expansion with value modifiers
    ('{+path:6}/here', level4_vars, '/foo/b/here'),
    ('{+list}', level4_vars, 'red,green,blue'),
    ('{+list*}', level4_vars, 'red,green,blue'),
    ('{+keys}', level4_vars, 'semi,;,dot,.,comma,,'),
    ('{+keys*}', level4_vars, 'semi=;,dot=.,comma=,'),
    # Level 4 - fragment expansion with value modifiers
    ('{#path:6}/here', level4_vars, '#/foo/b/here'),
    ('{#list}', level4_vars, '#red,green,blue'),
    ('{#list*}', level4_vars, '#red,green,blue'),
    ('{#keys}', level4_vars, '#semi,;,dot,.,comma,,'),
    ('{#keys*}', level4_vars, '#semi=;,dot=.,comma=,'),
    # Level 4 - label expansion, dot-prefixed
    ('X{.var:3}', level4_vars, 'X.val'),
    ('X{.list}', level4_vars, 'X.red,green,blue'),
    ('X{.list*}', level4_vars, 'X.red.green.blue'),
    ('X{.keys}', level4_vars, 'X.semi,%3B,dot,.,comma,%2C'),
    ('X{.keys*}', level4_vars, 'X.semi=%3B.dot=..comma=%2C'),
    # Level 4 - path segments, slash-prefixed
    ('{/var:1,var}', level4_vars, '/v/value'),
    ('{/list}', level4_vars, '/red,green,blue'),
    ('{/list*}', level4_vars, '/red/green/blue'),
    ('{/list*,path:4}', level4_vars, '/red/green/blue/%2Ffoo'),
    ('{/keys}', level4_vars, '/semi,%3B,dot,.,comma,%2C'),
    ('{/keys*}', level4_vars, '/semi=%3B/dot=./comma=%2C'),
    # Level 4 - path-style parameters, semicolon-prefixed
    ('{;hello:5}', level4_vars, ';hello=Hello'),
    ('{;list}', level4_vars, ';list=red,green,blue'),
    ('{;list*}', level4_vars, ';list=red;list=green;list=blue'),
    ('{;keys}', level4_vars, ';keys=semi,%3B,dot,.,comma,%2C'),
    ('{;keys*}', level4_vars, ';semi=%3B;dot=.;comma=%2C'),
    # Level 4 - form-style query, ampersand-separated
    ('{?var:3}', level4_vars, '?var=val'),
    ('{?list}', level4_vars, '?list=red,green,blue'),
    ('{?list*}', level4_vars, '?list=red&list=green&list=blue'),
    ('{?keys}', level4_vars, '?keys=semi,%3B,dot,.,comma,%2C'),
    ('{?keys*}', level4_vars, '?semi=%3B&dot=.&comma=%2C'),
    # Level 4 - form-sytyle query continuation
    ('{&var:3}', level4_vars, '&var=val'),
    ('{&list}', level4_vars, '&list=red,green,blue'),
    ('{&list*}', level4_vars, '&list=red&list=green&list=blue'),
    ('{&keys}', level4_vars, '&keys=semi,%3B,dot,.,comma,%2C'),
    ('{&keys*}', level4_vars, '&semi=%3B&dot=.&comma=%2C'),
]
_data = [
    ('{;x,y,empty}', level3_vars, ';x=1024;y=768;empty'),
]


def assert_expansion(template, fields, expected):
    eq_(expand(template, fields), expected)


def test_expansion():
    for template, fields, expected in data:
        yield assert_expansion, template, fields, expected

########NEW FILE########
__FILENAME__ = template_tests
from unittest import TestCase

import purl


class TemplateTests(TestCase):

    def test_basic_expansion(self):
        template = purl.Template('http://example.com{+path,x}/here')
        url = template.expand({'path': '/foo/bar', 'x': 1024})
        self.assertEquals('http://example.com/foo/bar,1024/here',
                          url.as_string())

########NEW FILE########
__FILENAME__ = url_tests
# -*- coding: utf-8 -*-
from __future__ import unicode_literals

from unittest import TestCase
import pickle

try:
    from urllib.parse import quote
except ImportError:
    from urllib import quote

from purl import URL


class ConstructorTests(TestCase):

    def test_url_can_be_created_with_just_host(self):
        u = URL(host='google.com')
        self.assertEqual('http://google.com/', str(u))

    def test_url_can_be_created_with_host_and_schema(self):
        u = URL(host='google.com', scheme='https')
        self.assertEqual('https://google.com/', str(u))

    def test_url_can_be_created_with_host_and_post(self):
        u = URL(host='localhost', port=8000)
        self.assertEqual('http://localhost:8000/', str(u))

    def test_no_args_to_constructor(self):
        u = URL()
        self.assertEqual('/', str(u))

    def test_as_string(self):
        self.assertEqual('/', URL().as_string())

    def test_full_url_can_be_used_as_first_param(self):
        u = URL('https://github.com')
        self.assertEqual('https://github.com', u.as_string())

    def test_kwargs_take_priority_when_used_with_full_url(self):
        u = URL('https://github.com', scheme='http')
        self.assertEqual('http://github.com', u.as_string())


class MoreFactoryTests(TestCase):

    def setUp(self):
        self.url_str = 'https://www.sandbox.paypal.com/webscr?cmd=_express-checkout&token=EC-6469953681606921P&AMT=200&CURRENCYCODE=GBP&RETURNURL=http%3A%2F%2Fexample.com%2Fcheckout%2Fpaypal%2Fresponse%2Fsuccess%2F&CANCELURL=http%3A%2F%2Fexample.com%2Fcheckout%2Fpaypal%2Fresponse%2Fcancel%2F'
        self.url = URL.from_string(self.url_str)

    def test_extracting_query_param(self):
        return_url = self.url.query_param('RETURNURL')
        self.assertEqual('http://example.com/checkout/paypal/response/success/',
                         return_url)


class FactoryTests(TestCase):

    def setUp(self):
        self.url_str = 'http://www.google.com/search/?q=testing#fragment'
        self.url = URL.from_string(self.url_str)

    def test_scheme(self):
        self.assertEqual('http', self.url.scheme())

    def test_fragment(self):
        self.assertEqual('fragment', self.url.fragment())

    def test_path(self):
        self.assertEqual('/search/', self.url.path())

    def test_host(self):
        self.assertEqual('www.google.com', self.url.host())

    def test_string_version(self):
        self.assertEqual(self.url_str, str(self.url))


class EdgeCaseExtractionTests(TestCase):

    def test_no_equals_sign_means_empty_string(self):
        url = URL.from_string('http://www.google.com/blog/article/1?q')
        self.assertEqual('', url.query_param('q'))

    def test_list_extraction(self):
        url = URL.from_string('http://www.google.com/?q=1&q=2&q=3')
        self.assertEqual(['1', '2', '3'], url.query_param('q'))

    def test_username_extraction(self):
        url = URL.from_string('ftp://user:pw@ftp.host')
        self.assertEqual('user', url.username())
        self.assertEqual('pw', url.password())

    def test_username_in_unicode_repr(self):
        u = 'ftp://user:pw@ftp.host'
        url = URL.from_string(u)
        self.assertEqual(u, str(url))

    def test_auth_in_netloc(self):
        url = URL.from_string('ftp://user:pw@ftp.host')
        self.assertEqual('user:pw@ftp.host', url.netloc())

    def test_port_in_netloc(self):
        url = URL.from_string('http://localhost:5000')
        self.assertEqual('localhost', url.host())
        self.assertEqual(5000, url.port())

    def test_port_for_https_url(self):
        url = URL.from_string('https://github.com')
        self.assertEqual(None, url.port())


class SimpleExtractionTests(TestCase):

    def setUp(self):
        self.url = URL.from_string('http://www.google.com/blog/article/1?q=testing')

    def test_has_actual_param(self):
        self.assertTrue(self.url.has_query_param('q'))

    def test_remove_query_param(self):
        new_url = self.url.remove_query_param('q')
        self.assertEqual('http://www.google.com/blog/article/1',
                         new_url.as_string())

    def test_has_query_params(self):
        self.assertTrue(self.url.has_query_params(['q']))

    def test_has_query_params_negative(self):
        self.assertFalse(self.url.has_query_params(['q', 'r']))

    def test_netloc(self):
        self.assertEqual('www.google.com', self.url.netloc())

    def test_path_extraction(self):
        self.assertEqual('1', self.url.path_segment(2))

    def test_port_defaults_to_none(self):
        self.assert_(self.url.port() is None)

    def test_scheme(self):
        self.assertEqual('http', self.url.scheme())

    def test_host(self):
        self.assertEqual('www.google.com', self.url.host())

    def test_domain(self):
        self.assertEqual('www.google.com', self.url.domain())

    def test_subdomains(self):
        self.assertEqual(['www', 'google', 'com'], self.url.subdomains())

    def test_subdomain(self):
        self.assertEqual('www', self.url.subdomain(0))

    def test_invalid_subdomain_raises_indexerror(self):
        self.assertRaises(IndexError, self.url.subdomain, 10)

    def test_path(self):
        self.assertEqual('/blog/article/1', self.url.path())

    def test_query(self):
        self.assertEqual('q=testing', self.url.query())

    def test_query_param_as_list(self):
        self.assertEqual(['testing'], self.url.query_param('q', as_list=True))

    def test_query_params(self):
        self.assertEqual({'q': ['testing']}, self.url.query_params())

    def test_path_extraction_returns_none_if_index_too_large(self):
        self.assert_(self.url.path_segment(14) is None)

    def test_path_extraction_can_take_default_value(self):
        self.assertEqual('hello', self.url.path_segment(3, default='hello'))

    def test_parameter_extraction(self):
        self.assertEqual('testing', self.url.query_param('q'))

    def test_parameter_extraction_with_default(self):
        self.assertEqual('eggs', self.url.query_param('p', default='eggs'))

    def test_parameter_extraction_is_none_if_not_found(self):
        self.assert_(self.url.query_param('p') is None)

    def test_path_segments(self):
        self.assertEqual(('blog', 'article', '1'), self.url.path_segments())


class NoTrailingSlashTests(TestCase):

    def test_path_extraction_without_trailing_slash(self):
        u = URL(host='google.com', path='/blog/article/1')
        self.assertEqual('1', u.path_segment(2))


class BuilderTests(TestCase):

    def test_setting_list_as_query_params(self):
        first = URL.from_string('?q=testing')
        second = URL().query_params(first.query_params())
        self.assertEqual(first.query(), second.query())

    def test_add_path_segment(self):
        url = URL('http://example.com').add_path_segment('one')\
                .add_path_segment('two')\
                .add_path_segment('three')
        self.assertEqual('/one/two/three', url.path())

    def test_setting_single_item_list_as_query_param(self):
        url = URL().query_param('q', ['testing'])
        self.assertEqual('testing', url.query_param('q'))

    def test_setting_list_as_query_param(self):
        url = URL().query_param('q', ['testing', 'eggs'])
        self.assertEqual(['testing', 'eggs'], url.query_param('q', as_list=True))

    def test_build_relative_url(self):
        url = URL().path('searching')
        self.assertEqual('/searching', str(url))

    def test_build_relative_url_with_params(self):
        URL().path('/searching').query_param('q', 'testing')

    def test_build_with_path_segments(self):
        u = URL().path_segments(['path', 'to', 'page'])
        self.assertEqual('/path/to/page', u.as_string())

    def test_set_fragment(self):
        url = URL.from_string('http://www.google.com/').fragment('hello')
        self.assertEqual('hello', url.fragment())

    def test_set_scheme(self):
        url = URL.from_string('http://www.google.com/').scheme('https')
        self.assertEqual('https', url.scheme())

    def test_set_host(self):
        url = URL.from_string('http://www.google.com/').host('maps.google.com')
        self.assertEqual('maps.google.com', url.host())

    def test_set_path(self):
        url = URL.from_string('http://www.google.com/').path('search')
        self.assertEqual('/search', url.path())

    def test_set_query(self):
        url = URL.from_string('http://www.google.com/').query('q=testing')
        self.assertEqual('testing', url.query_param('q'))

    def test_set_port(self):
        url = URL.from_string('http://www.google.com/').port(8000)
        self.assertEqual(8000, url.port())

    def test_set_path_segment(self):
        url = URL.from_string('http://www.google.com/a/b/c/').path_segment(1, 'd')
        self.assertEqual('/a/d/c/', url.path())

    def test_set_query_param(self):
        url = URL.from_string('http://www.google.com/search').query_param('q', 'testing')
        self.assertEqual('testing', url.query_param('q'))

    def test_set_query_params(self):
        url = URL.from_string('http://www.google.com/search').query_params({'q': 'testing'})
        self.assertEqual('testing', url.query_param('q'))

    def test_set_subdomain(self):
        url = URL.from_string('http://www.google.com/search').subdomain(0, 'www2')
        self.assertEqual('www2', url.subdomain(0))

    def test_set_subdomains(self):
        url = URL().subdomains(['www', 'google', 'com'])
        self.assertEqual('http://www.google.com/', str(url))


class MiscTests(TestCase):

    def test_url_can_be_used_as_key_in_dict(self):
        u = URL.from_string('http://google.com')
        {u: 0}

    def test_equality_comparison(self):
        self.assertEqual(URL.from_string('http://google.com'),
                         URL.from_string('http://google.com'))

    def test_negative_equality_comparison(self):
        self.assertNotEqual(URL.from_string('http://google.com'),
                            URL.from_string('https://google.com'))

    def test_urls_are_hashable(self):
        u = URL.from_string('http://google.com')
        hash(u)

    def test_urls_can_be_pickled(self):
        u = URL.from_string('http://google.com')
        pickle.dumps(u)

    def test_urls_can_be_pickled_and_restored(self):
        u = URL.from_string('http://google.com')
        pickled = pickle.dumps(u)
        v = pickle.loads(pickled)
        self.assertEqual(u, v)


class QueryParamListTests(TestCase):

    def test_set_list(self):
        base = URL('http://127.0.0.1/')
        url = base.query_param('q', ['something', 'else'])
        values = url.query_param('q', as_list=True)
        self.assertEqual(['something', 'else'], values)

    def test_remove_item_from_list(self):
        base = URL('http://127.0.0.1/?q=a&q=b')
        url = base.remove_query_param('q', 'a')
        values = url.query_param('q', as_list=True)
        self.assertEqual(['b'], values)

    def test_append_to_existing_list(self):
        base = URL('http://127.0.0.1/?q=a&q=b')
        url = base.append_query_param('q', 'c')
        values = url.query_param('q', as_list=True)
        self.assertEqual(['a', 'b', 'c'], values)

    def test_append_to_nonexistant_list(self):
        base = URL('http://127.0.0.1/?q=a&q=b')
        url = base.append_query_param('p', 'c')
        values = url.query_param('p', as_list=True)
        self.assertEqual(['c'], values)


class UnicodeExtractionTests(TestCase):
    def setUp(self):
        self.unicode_param = 'значение'
        # Python 2.6 requires bytes for quote
        self.urlencoded_param = quote(self.unicode_param.encode('utf8'))
        url = 'http://www.google.com/blog/article/1?q=' + self.urlencoded_param
        self.ascii_url = URL.from_string(url.encode('ascii'))
        # django request.get_full_path() returns url as unicode
        self.unicode_url = URL.from_string(url)

    def test_get_query_param_ascii_url(self):
        param = self.ascii_url.query_param('q')
        self.assertEqual(param, self.unicode_param)

    def test_get_query_param_unicode_url(self):
        param = self.unicode_url.query_param('q')
        self.assertEqual(param, self.unicode_param)


class UnicodeTests(TestCase):

    def setUp(self):
        self.base = URL('http://127.0.0.1/')
        self.text = u'ć'
        self.bytes = self.text.encode('utf8')

    def test_set_unicode_query_param_value(self):
        url = self.base.query_param('q', self.text)
        self.assertEqual(self.text, url.query_param('q'))

    def test_set_bytestring_query_param_value(self):
        url = self.base.query_param('q', self.bytes)
        self.assertEqual(self.text, url.query_param('q'))

    def test_set_unicode_query_param_key(self):
        url = self.base.query_param(self.text, 'value')
        self.assertEqual('value', url.query_param(self.text))

    def test_set_bytestring_query_param_key(self):
        url = self.base.query_param(self.bytes, 'value')
        self.assertEqual('value', url.query_param(self.text))

    def test_append_unicode_query_param(self):
        url = self.base.append_query_param('q', self.text)
        self.assertEqual(self.text, url.query_param('q'))

    def test_append_bytestring_query_param(self):
        url = self.base.append_query_param('q', self.bytes)
        self.assertEqual(self.text, url.query_param('q'))

    def test_set_unicode_query_params(self):
        url = self.base.query_params({'q': self.text})
        self.assertEqual(self.text, url.query_param('q'))

    def test_set_bytestring_query_params(self):
        url = self.base.query_params({'q': self.bytes})
        self.assertEqual(self.text, url.query_param('q'))

    def test_add_unicode_path_segment(self):
        url = self.base.add_path_segment(self.text)
        self.assertEqual(self.text, url.path_segment(0))

    def test_add_bytestring_path_segment(self):
        url = self.base.add_path_segment(self.bytes)
        self.assertEqual(self.text, url.path_segment(0))

    def test_add_bytestring_path_segment(self):
        url = self.base.add_path_segment(self.bytes)
        self.assertEqual(self.text, url.path_segment(0))

    def test_add_unicode_fragment(self):
        url = self.base.fragment(self.text)
        self.assertEqual(self.text, url.fragment())

########NEW FILE########
