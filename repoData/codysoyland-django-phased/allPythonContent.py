__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# django-phased documentation build configuration file, created by
# sphinx-quickstart on Sun Jun 27 00:56:51 2010.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.
import os
import sys

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'phased.test_settings')

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.append(os.path.abspath('..'))

# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'django-phased'
copyright = u'2010 - 2012, Cody Soyland and individual authors'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
try:
    from phased import __version__
    # The short X.Y version.
    version = '.'.join(__version__.split('.')[:2])
    # The full version, including alpha/beta/rc tags.
    release = __version__
except ImportError:
    version = release = 'dev'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
#html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'django-phaseddoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'django-phased.tex', u'django-phased Documentation',
   u'Cody Soyland', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
from django.core.management import execute_manager
try:
    import settings # Assumed to be in the same directory.
except ImportError:
    import sys
    sys.stderr.write("Error: Can't find the file 'settings.py' in the directory containing %r. It appears you've customized things.\nYou'll have to run django-admin.py, passing it your settings module.\n(If the file settings.py does indeed exist, it's causing an ImportError somehow.)\n" % __file__)
    sys.exit(1)

if __name__ == "__main__":
    execute_manager(settings)

########NEW FILE########
__FILENAME__ = settings
import os

BASE_PATH = os.path.dirname(__file__)

DEBUG = True
TEMPLATE_DEBUG = DEBUG

ADMINS = (
    ('Test User', 'test_user@domain.com'),
)

MANAGERS = ADMINS

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3', # Add 'postgresql_psycopg2', 'postgresql', 'mysql', 'sqlite3' or 'oracle'.
        'NAME': 'db.sqlite',                      # Or path to database file if using sqlite3.
        'USER': '',                      # Not used with sqlite3.
        'PASSWORD': '',                  # Not used with sqlite3.
        'HOST': '',                      # Set to empty string for localhost. Not used with sqlite3.
        'PORT': '',                      # Set to empty string for default. Not used with sqlite3.
    }
}

SITE_ID = 1
TIME_ZONE = 'America/Chicago'
LANGUAGE_CODE = 'en-us'
USE_I18N = True
USE_L10N = True

MEDIA_ROOT = os.path.join(BASE_PATH, 'media')
MEDIA_URL = '/media/'
ADMIN_MEDIA_PREFIX = '/media/admin/'

SECRET_KEY = 'zjaa0--6eoq-e=4randg5vwc1621h9_#hraa4l1*7_pcr_*eh9'

TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
)

MIDDLEWARE_CLASSES = (
    'phased.middleware.PhasedRenderMiddleware',
    'phased.middleware.PatchedVaryUpdateCacheMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.cache.FetchFromCacheMiddleware',
)

ROOT_URLCONF = 'example.urls'

TEMPLATE_DIRS = (
    os.path.join(BASE_PATH, 'templates'),
)

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.admin',
    'django.contrib.comments',
    'django.contrib.markup',
    'basic.blog',
    'basic.inlines',
    'tagging',
    'phased',
    'devserver',
)

PHASED_KEEP_CONTEXT = True

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *

from django.contrib import admin
admin.autodiscover()

urlpatterns = patterns('',
    url(r'^blog/', include('basic.blog.urls')),
    url(r'^comments/', include('django.contrib.comments.urls')),
    url(r'^admin/', include(admin.site.urls)),
)

########NEW FILE########
__FILENAME__ = middleware
from django.middleware.cache import UpdateCacheMiddleware
from django.utils.cache import patch_vary_headers
from phased.utils import second_pass_render, drop_vary_headers


class PhasedRenderMiddleware(object):
    """
    Performs a second-phase template rendering on the response and should be
    placed before the UpdateCacheMiddleware
    (or :class:`~phased.middleware.PatchedVaryUpdateCacheMiddleware`) in the
    ``MIDDLEWARE_CLASES`` setting.
    """
    def process_response(self, request, response):
        """
        If the content-type starts with ``text/html`` performs a second-phase
        render on response.content and updates the ``Content-Length`` header
        of the response to reflect the change in size after rendering.
        """
        if not response['content-type'].startswith("text/html"):
            return response
        response.content = second_pass_render(request, response.content)
        response['Content-Length'] = str(len(response.content))
        return response


class PatchedVaryUpdateCacheMiddleware(UpdateCacheMiddleware):
    """
    If ``Vary: Cookie`` is set in the response object, Django's cache
    middleware will vary the cache key based on the value of the cookie.

    This subclass of Django's UpdateCacheMiddleware is designed to cache
    without varying the cache key on cookie contents.
    """
    def process_response(self, request, response):
        """
        This removes the ``Vary: Cookie`` header prior to running the standard
        Django ``UpdateCacheMiddleware.process_response()`` and adds the
        header back after caching so that in-browser caches are aware to vary
        the cache on cookies.
        """
        drop_vary_headers(response, ['Cookie'])
        response = super(PatchedVaryUpdateCacheMiddleware, self).process_response(request, response)
        patch_vary_headers(response, ['Cookie'])
        return response

########NEW FILE########
__FILENAME__ = models
from django.conf import settings
from django.utils.hashcompat import sha_constructor

if not hasattr(settings, 'PHASED_SECRET_DELIMITER'):
    settings.PHASED_SECRET_DELIMITER = sha_constructor(getattr(settings, 'SECRET_KEY', '')).hexdigest()

# quoting the sekrit delimiter to make sure Debug Toolbar doesn't render it
settings.PHASED_SECRET_DELIMITER = '"%s"' % settings.PHASED_SECRET_DELIMITER

########NEW FILE########
__FILENAME__ = phased_tags
from django.conf import settings
from django.template import (Library, Node, Variable,
    TOKEN_BLOCK, TOKEN_COMMENT, TOKEN_TEXT, TOKEN_VAR,
    TemplateSyntaxError, VariableDoesNotExist, Context)
from django.utils.encoding import smart_str
from django.templatetags.cache import CacheNode

from phased.utils import pickle_context, flatten_context, backup_csrf_token, second_pass_render

register = Library()


def parse(parser):
    """
    Parse to the end of a phased block. This is different than Parser.parse()
    in that it does not generate Node objects; it simply yields tokens.
    """
    depth = 0
    while parser.tokens:
        token = parser.next_token()
        if token.token_type == TOKEN_BLOCK:
            if token.contents == 'phased':
                depth += 1
            elif token.contents == 'endphased':
                depth -= 1
        if depth < 0:
            break
        yield token
    if not parser.tokens and depth >= 0:
        parser.unclosed_block_tag(('endphased',))


class PhasedNode(Node):
    """
    Generated by {% phased %} tag. Outputs the literal content of the phased
    block with pickled context, enclosed in a delimited block that can be
    parsed by the second pass rendering middleware.
    """
    def __init__(self, content, var_names):
        self.var_names = var_names
        self.content = content

    def __repr__(self):
        return "<Phased Node: '%s'>" % smart_str(self.content[:25], 'ascii',
                errors='replace')

    def render(self, context):
        # our main context
        storage = Context()

        # stash the whole context if needed
        if getattr(settings, 'PHASED_KEEP_CONTEXT', False):
            storage.update(flatten_context(context))

        # but check if there are variables specifically wanted
        for var_name in self.var_names:
            if var_name[0] in ('"', "'") and var_name[-1] == var_name[0]:
                var_name = var_name[1:-1]
            try:
                storage[var_name] = Variable(var_name).resolve(context)
            except VariableDoesNotExist:
                raise TemplateSyntaxError(
                    '"phased" tag got an unknown variable: %r' % var_name)

        storage = backup_csrf_token(context, storage)

        # lastly return the pre phased template part
        return u'%(delimiter)s%(content)s%(pickled)s%(delimiter)s' % {
            'content': self.content,
            'delimiter': settings.PHASED_SECRET_DELIMITER,
            'pickled': pickle_context(storage),
        }


@register.tag
def phased(parser, token):
    """
    Template tag to denote a template section to render a second time via
    a middleware.

    Usage::

        {% load phased_tags %}
        {% phased with [var1] [var2] .. %}
            .. some content to be rendered a second time ..
        {% endphased %}

    You can pass it a list of context variable names to automatically
    save those variables for the second pass rendering of the template,
    e.g.::

        {% load phased_tags %}
        {% phased with comment_count object %}
            There are {{ comment_count }} comments for "{{ object }}".
        {% endphased %}

    Alternatively you can also set the ``PHASED_KEEP_CONTEXT`` setting to
    ``True`` to automatically keep the whole context for each phased block.

    Note: Lazy objects such as messages and csrf tokens aren't kept.

    """
    literal = ''.join({
        TOKEN_BLOCK: '{%% %s %%}',
        TOKEN_VAR: '{{ %s }}',
        TOKEN_COMMENT: '{# %s #}',
        TOKEN_TEXT: '%s',
    }[token.token_type] % token.contents for token in parse(parser))
    tokens = token.contents.split()
    if len(tokens) > 1 and tokens[1] != 'with':
        raise TemplateSyntaxError(u"'%r' tag requires the second argument to be 'with'." % tokens[0])
        if len(tokens) == 2:
            raise TemplateSyntaxError(u"'%r' tag requires at least one context variable name." % tokens[0])
    return PhasedNode(literal, tokens[2:])


class PhasedCacheNode(CacheNode):
    def render(self, context):
        """
        Template tag that acts like Django's cached tag
        except that it does a second pass rendering.

        Requires `RequestContext` and
        `django.core.context_processors.request` to be in
        TEMPLATE_CONTEXT_PROCESSORS
        """
        content = super(PhasedCacheNode, self).render(context)
        return second_pass_render(context['request'], content)


@register.tag
def phasedcache(parser, token):
    """
    Taken from ``django.templatetags.cache`` and changed ending tag.

    This will cache the contents of a template fragment for a given amount
    of time and do a second pass render on the contents.

    Usage::

        {% load phased_tags %}
        {% phasedcache [expire_time] [fragment_name] %}
            .. some expensive processing ..
            {% phased %}
                .. some request specific stuff ..
            {% endphased %}
        {% endphasedcache %}

    This tag also supports varying by a list of arguments::

        {% load phased_tags %}
        {% phasedcache [expire_time] [fragment_name] [var1] [var2] .. %}
            .. some expensive processing ..
            {% phased %}
                .. some request specific stuff ..
            {% endphased %}
        {% endphasedcache %}

    Each unique set of arguments will result in a unique cache entry.
    The tag will take care that the phased tags are properly rendered.

    It requires usage of ``RequestContext`` and
    ``django.core.context_processors.request`` to be in the
    ``TEMPLATE_CONTEXT_PROCESSORS`` setting.
    """
    nodelist = parser.parse(('endphasedcache',))
    parser.delete_first_token()
    tokens = token.contents.split()
    if len(tokens) < 3:
        raise TemplateSyntaxError(u"'%r' tag requires at least 2 arguments." % tokens[0])
    return PhasedCacheNode(nodelist, tokens[1], tokens[2], tokens[3:])

########NEW FILE########
__FILENAME__ = test_cases
import pickle
import re

from django.contrib.auth.middleware import AuthenticationMiddleware
from django.contrib.sessions.middleware import SessionMiddleware
from django.conf import settings
from django.core.cache import cache
from django.http import HttpResponse
from django.middleware.cache import FetchFromCacheMiddleware, UpdateCacheMiddleware
from django.utils.cache import patch_vary_headers
from django.template import (compile_string, Context,
    TemplateSyntaxError, RequestContext)
from django.test.client import RequestFactory
from django.test import TestCase

try:
    from override_settings import override_settings
except ImportError:
    from django.test.utils import override_settings  # noqa

from phased.utils import (second_pass_render, pickle_context,
    unpickle_context, flatten_context, drop_vary_headers, backup_csrf_token)
from phased.middleware import (PhasedRenderMiddleware,
    PatchedVaryUpdateCacheMiddleware)
from phased import utils


class PhasedTestCase(TestCase):

    def setUp(self):
        self.factory = RequestFactory()
        utils.get_pickle = lambda: pickle
        super(PhasedTestCase, self).setUp()


class TwoPhaseTestCase(PhasedTestCase):
    test_template = (
        "{% load phased_tags %}"
        "{% phased %}"
        "{% if 1 %}test{% endif %}"
        "{% endphased %}"
        "{{ test_var }}"
    )

    def test_phased(self):
        context = Context({'test_var': 'TEST'})
        first_render = compile_string(self.test_template, None).render(context)
        original_context = unpickle_context(first_render)
        self.assertNotEqual(flatten_context(context), original_context)
        pickled_context = pickle_context(Context({'csrf_token': 'NOTPROVIDED'}))
        self.assertEqual(first_render, '%(delimiter)s{%% if 1 %%}test{%% endif %%}%(pickled_context)s%(delimiter)sTEST' %
            dict(delimiter=settings.PHASED_SECRET_DELIMITER, pickled_context=pickled_context))

    def test_second_pass(self):
        request = self.factory.get('/')
        first_render = compile_string(self.test_template, None).render(Context({'test_var': 'TEST'}))
        second_render = second_pass_render(request, first_render)
        self.assertEqual(second_render, 'testTEST')

TwoPhaseTestCase = override_settings(PHASED_KEEP_CONTEXT=False)(TwoPhaseTestCase)


class FancyTwoPhaseTestCase(TwoPhaseTestCase):
    def test_phased(self):
        context = Context({'test_var': 'TEST'})
        first_render = compile_string(self.test_template, None).render(context)
        self.assertEqual(first_render, 'fancydelimiter{%% if 1 %%}test{%% endif %%}%sfancydelimiterTEST' % pickle_context(backup_csrf_token(context)))

    def test_second_pass(self):
        request = self.factory.get('/')
        first_render = compile_string(self.test_template, None).render(Context({'test_var': 'TEST'}))
        second_render = second_pass_render(request, first_render)
        self.assertEqual(second_render, 'testTEST')

FancyTwoPhaseTestCase = override_settings(PHASED_SECRET_DELIMITER="fancydelimiter")(FancyTwoPhaseTestCase)


class NestedTwoPhaseTestCase(TwoPhaseTestCase):
    test_template = (
        "{% load phased_tags %}"
        "{% phased %}"
        "{% load phased_tags %}"
        "{% phased %}"
        "{% if 1 %}first{% endif %}"
        "{% endphased %}"
        "{% if 1 %}second{% endif %}"
        "{% endphased %}"
        "{{ test_var }}"
    )

    def test_phased(self):
        context = Context({'test_var': 'TEST'})
        first_render = compile_string(self.test_template, None).render(context)
        self.assertEqual(first_render, '%(delimiter)s{%% load phased_tags %%}{%% phased %%}{%% if 1 %%}first{%% endif %%}{%% endphased %%}{%% if 1 %%}second{%% endif %%}%(pickled_context)s%(delimiter)sTEST' %
            dict(delimiter=settings.PHASED_SECRET_DELIMITER, pickled_context=pickle_context(backup_csrf_token(context))))

    def test_second_pass(self):
        request = self.factory.get('/')
        first_render = compile_string(self.test_template, None).render(Context({'test_var': 'TEST'}))
        second_render = second_pass_render(request, first_render)
        self.assertEqual(second_render, 'firstsecondTEST')


class StashedTestCase(TwoPhaseTestCase):
    test_template = (
        "{% load phased_tags %}"
        "{% phased %}"
        "{% if 1 %}test{% endif %}"
        "{% if test_condition %}"
        "stashed"
        "{% endif %}"
        "{% endphased %}"
        "{{ test_var }}"
        "{% phased %}"
        "{% if 1 %}test2{% endif %}"
        "{% if test_condition2 %}"
        "stashed"
        "{% endif %}"
        "{% endphased %}"
    )

    @override_settings(PHASED_KEEP_CONTEXT=True)
    def test_phased(self):
        context = Context({'test_var': 'TEST'})
        pickled_context = '{# stashed context: "gAJ9cQAoVQpjc3JmX3Rva2VucQFVC05PVFBST1ZJREVEcQJVCHRlc3RfdmFycQNVBFRFU1RxBHUu" #}'
        first_render = compile_string(self.test_template, None).render(context)
        self.assertEqual(first_render, '%(delimiter)s{%% if 1 %%}test{%% endif %%}{%% if test_condition %%}stashed{%% endif %%}%(pickled_context)s%(delimiter)sTEST%(delimiter)s{%% if 1 %%}test2{%% endif %%}{%% if test_condition2 %%}stashed{%% endif %%}%(pickled_context)s%(delimiter)s' %
            dict(delimiter=settings.PHASED_SECRET_DELIMITER, pickled_context=pickled_context))

    @override_settings(PHASED_KEEP_CONTEXT=True)
    def test_second_pass(self):
        request = self.factory.get('/')
        context = Context({
            'test_var': 'TEST',
            'test_condition': True,
            'test_condition2': True,
        })
        first_render = compile_string(self.test_template, None).render(context)
        second_render = second_pass_render(request, first_render)
        self.assertEqual(second_render, 'teststashedTESTtest2stashed')


class PickyStashedTestCase(StashedTestCase):
    test_template = (
        '{% load phased_tags %}'
        '{% phased with "test_var" test_condition %}'
        '{% if 1 %}test{% endif %}'
        '{% if test_condition %}'
        'stashed'
        '{% endif %}'
        '{% endphased %}'
        '{{ test_var }}'
    )

    def test_phased(self):
        context = Context({'test_var': 'TEST'})
        self.assertRaises(TemplateSyntaxError, compile_string(self.test_template, None).render, context)
        context = Context({
            'test_var': 'TEST',
            'test_condition': True,
        })
        first_render = compile_string(self.test_template, None).render(context)
        pickled_context = '{# stashed context: "gAJ9cQAoVQ50ZXN0X2NvbmRpdGlvbnEBiFUKY3NyZl90b2tlbnECVQtOT1RQUk9WSURFRHEDVQh0ZXN0X3ZhcnEEVQRURVNUcQV1Lg==" #}'
        self.assertEqual(first_render, '%(delimiter)s{%% if 1 %%}test{%% endif %%}{%% if test_condition %%}stashed{%% endif %%}%(pickled_context)s%(delimiter)sTEST' %
            dict(delimiter=settings.PHASED_SECRET_DELIMITER, pickled_context=pickled_context))

    def test_second_pass(self):
        request = self.factory.get('/')
        context = Context({
            'test_var': 'TEST',
            'test_var2': 'TEST2',
            'test_condition': True,
        })
        first_render = compile_string(self.test_template, None).render(context)
        original_context = unpickle_context(first_render)
        self.assertEqual(original_context.get('test_var'), 'TEST')
        second_render = second_pass_render(request, first_render)
        self.assertEqual(second_render, 'teststashedTEST')


class UtilsTestCase(PhasedTestCase):
    def test_flatten(self):
        context = Context({'test_var': 'TEST'})
        context.update({'test_var': 'TEST2', 'abc': 'def'})
        self.assertEqual(flatten_context(context), {'test_var': 'TEST2', 'abc': 'def'})

    def test_flatten_nested(self):
        context = Context({'test_var': 'TEST'})
        context.update(Context({'test_var': 'TEST2', 'abc': 'def'}))
        self.assertEqual(flatten_context(context), {'test_var': 'TEST2', 'abc': 'def'})

    def test_pickling(self):
        self.assertRaises(TemplateSyntaxError, pickle_context, {})
        self.assertEqual(pickle_context(Context()), '{# stashed context: "gAJ9cQAu" #}')
        context = Context({'test_var': 'TEST'})
        template = '<!-- better be careful %s yikes -->'
        self.assertEqual(pickle_context(context), '{# stashed context: "gAJ9cQBVCHRlc3RfdmFycQFVBFRFU1RxAnMu" #}')
        self.assertEqual(pickle_context(context, template), '<!-- better be careful gAJ9cQBVCHRlc3RfdmFycQFVBFRFU1RxAnMu yikes -->')

    def test_unpickling(self):
        self.assertEqual(unpickle_context(pickle_context(Context())), flatten_context(Context()))
        context = Context({'test_var': 'TEST'})
        pickled_context = pickle_context(context)
        unpickled_context = unpickle_context(pickled_context)
        self.assertEqual(flatten_context(context), unpickled_context)

    def test_unpickling_with_template_and_pattern(self):
        context = Context({'test_var': 'TEST'})
        template = '<!-- better be careful %s yikes -->'
        pattern = re.compile(r'.*<!-- better be careful (.*) yikes -->.*')
        pickled_context = pickle_context(context, template)
        unpickled_context = unpickle_context(pickled_context, pattern)
        self.assertEqual(flatten_context(context), unpickled_context)


class PhasedRenderMiddlewareTestCase(PhasedTestCase):
    template = (
        'before '
        '%(delimiter)s '
        'inside{# a comment #} '
        '%(delimiter)s '
        'after'
    )

    def test_basic(self):
        request = self.factory.get('/')
        response = HttpResponse(self.template %
            dict(delimiter=settings.PHASED_SECRET_DELIMITER))

        response = PhasedRenderMiddleware().process_response(request, response)

        self.assertEqual(response.content, 'before  inside  after')

    def test_not_html(self):
        request = self.factory.get('/')
        applied_delimiter = self.template % dict(delimiter=settings.PHASED_SECRET_DELIMITER)
        response = HttpResponse(applied_delimiter, mimetype='application/json')

        response = PhasedRenderMiddleware().process_response(request, response)
        self.assertEqual(response.content, applied_delimiter)


class PatchedVaryUpdateCacheMiddlewareTestCase(PhasedTestCase):

    def setUp(self):
        super(PatchedVaryUpdateCacheMiddlewareTestCase, self).setUp()
        cache.clear()

    def test_no_vary(self):
        """
        Ensure basic caching works.
        """
        request = self.factory.get('/test/no-vary')
        response = HttpResponse()

        SessionMiddleware().process_request(request)
        AuthenticationMiddleware().process_request(request)

        cache_hit = FetchFromCacheMiddleware().process_request(request)
        self.assertEqual(cache_hit, None)

        response = PatchedVaryUpdateCacheMiddleware().process_response(request, response)
        cache_hit = FetchFromCacheMiddleware().process_request(request)

        self.assertTrue(isinstance(cache_hit, HttpResponse))

    def test_vary(self):
        """
        Ensure caching works even when cookies are present and `Vary: Cookie` is on.
        """
        request = self.factory.get('/test/vary')
        request.COOKIES = {'test': 'foo'}
        request.META['HTTP_COOKIE'] = 'test=foo'

        response = HttpResponse()
        patch_vary_headers(response, ['Cookie'])
        response.set_cookie('test', 'foo')

        SessionMiddleware().process_request(request)
        AuthenticationMiddleware().process_request(request)

        cache_hit = FetchFromCacheMiddleware().process_request(request)
        self.assertTrue(cache_hit is None)

        response = PatchedVaryUpdateCacheMiddleware().process_response(request, response)
        cache_hit = FetchFromCacheMiddleware().process_request(request)

        self.assertTrue(isinstance(cache_hit, HttpResponse))

        new_request = self.factory.get('/test/vary')
        # note: not using cookies here. this demonstrates that cookies don't
        # affect the cache key
        cache_hit = FetchFromCacheMiddleware().process_request(new_request)
        self.assertTrue(isinstance(cache_hit, HttpResponse))

    def test_vary_with_original_update_cache_middleware(self):
        """
        Mainly to demonstrate the need to remove the Vary: Cookie header
        during caching. Same basic test as test_vary() but with django's
        UpdateCacheMiddleware instead of PatchedVaryUpdateCacheMiddleware.
        This does not get a cache hit if the cookies are not the same.
        """
        request = self.factory.get('/')
        request.method = 'GET'
        request.COOKIES = {'test': 'foo'}
        request.META['HTTP_COOKIE'] = 'test=foo'

        response = HttpResponse()
        patch_vary_headers(response, ['Cookie'])
        response.set_cookie('test', 'foo')

        SessionMiddleware().process_request(request)
        AuthenticationMiddleware().process_request(request)

        cache_hit = FetchFromCacheMiddleware().process_request(request)
        self.assertEqual(cache_hit, None)

        response = UpdateCacheMiddleware().process_response(request, response)
        cache_hit = FetchFromCacheMiddleware().process_request(request)

        self.assertTrue(isinstance(cache_hit, HttpResponse))

        new_request = self.factory.get('/')
        new_request.method = 'GET'
        # note: not using cookies here. this demonstrates that cookies don't
        # affect the cache key
        cache_hit = FetchFromCacheMiddleware().process_request(new_request)
        self.assertEqual(cache_hit, None)

    def test_drop_vary_headers(self):
        response = HttpResponse()

        self.assertFalse(response.has_header('Vary'))
        patch_vary_headers(response, ['Cookie'])
        self.assertTrue(response.has_header('Vary'))
        self.assertEqual(response['Vary'], 'Cookie')
        patch_vary_headers(response, ['Nomnomnom'])
        self.assertEqual(response['Vary'], 'Cookie, Nomnomnom')
        drop_vary_headers(response, ['Cookie'])
        self.assertEqual(response['Vary'], 'Nomnomnom')
        drop_vary_headers(response, ['Nomnomnom'])
        self.assertFalse(response.has_header('Vary'))


class PhasedCacheTemplateTagTest(PhasedTestCase):
    test_template = (
        "{% load phased_tags %}"
        "OtherPart"
        "{% phasedcache 10000 phased_test %}"
        "{{ test_var }}"
        "{% phased %}"
        "{{ request.path }}"
        "{% endphased %}"
        "{% endphasedcache %}"
        "TEST"
    )

    def setUp(self):
        super(PhasedCacheTemplateTagTest, self).setUp()
        cache.clear()

    def test_phasedcache(self):
        self.assertEqual(len(cache._cache.keys()), 0)
        request = self.factory.get('/')
        context = RequestContext(request, {'test_var': 'Testing'})
        rendering = compile_string(self.test_template, None).render(context)
        self.assertEqual(rendering, 'OtherPartTesting/TEST')
        self.assertEqual(len(cache._cache.keys()), 1)
        cached_value = cache.get('template.cache.phased_test.d41d8cd98f00b204e9800998ecf8427e')
        self.assertIsNotNone(cached_value)
        self.assertTrue(cached_value.startswith('Testing'))
        request = self.factory.get('/path/')
        # Do not make test_var available, should be in cache
        context = RequestContext(request)
        rendering = compile_string(self.test_template, None).render(context)
        self.assertEqual(rendering, 'OtherPartTesting/path/TEST')

########NEW FILE########
__FILENAME__ = test_settings
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': 'phased.sqlite',
    },
}

INSTALLED_APPS = [
    'phased',
]

TEST_RUNNER = 'discover_runner.DiscoverRunner'

SECRET_KEY = '0'

PHASED_KEEP_CONTEXT = True

MIDDLEWARE_CLASSES = (
    'phased.middleware.PhasedRenderMiddleware',
    'phased.middleware.PatchedVaryUpdateCacheMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.cache.FetchFromCacheMiddleware',
)

TEMPLATE_CONTEXT_PROCESSORS = (
    'django.core.context_processors.request',
)

########NEW FILE########
__FILENAME__ = utils
import re
import base64
from django.conf import settings
from django.http import HttpRequest
from django.template import (Parser, Lexer, Token, TOKEN_TEXT,
    COMMENT_TAG_START, COMMENT_TAG_END, TemplateSyntaxError)
from django.template.context import BaseContext, RequestContext, Context
from django.utils.cache import cc_delim_re
from django.utils.functional import Promise, LazyObject
from django.contrib.messages.storage.base import BaseStorage
from django.utils.encoding import smart_str


def get_pickle():
    try:
        import cPickle as pickle
    except ImportError:
        import pickle  # noqa
    return pickle

pickled_context_re = re.compile(r'.*%s stashed context: "(.*)" %s.*' % (COMMENT_TAG_START, COMMENT_TAG_END))
forbidden_classes = (Promise, LazyObject, HttpRequest, BaseStorage)


def second_pass_render(request, content):
    """
    Split on the secret delimiter and generate the token list by passing
    through text outside of phased blocks as single text tokens and tokenizing
    text inside the phased blocks. This ensures that nothing outside of the
    phased blocks is tokenized, thus eliminating the possibility of a template
    code injection vulnerability.
    """
    result = tokens = []
    for index, bit in enumerate(content.split(settings.PHASED_SECRET_DELIMITER)):
        if index % 2:
            tokens = Lexer(bit, None).tokenize()
        else:
            tokens.append(Token(TOKEN_TEXT, bit))

        context = RequestContext(request,
            restore_csrf_token(request, unpickle_context(bit)))
        rendered = Parser(tokens).parse().render(context)

        if settings.PHASED_SECRET_DELIMITER in rendered:
            rendered = second_pass_render(request, rendered)
        result.append(rendered)

    return "".join(result)


def restore_csrf_token(request, storage=None):
    """
    Given the request and a the context used during the second render phase,
    this wil check if there is a CSRF cookie and restores if needed, to
    counteract the way the CSRF framework invalidates the CSRF token after
    each request/response cycle.
    """
    if storage is None:
        storage = {}
    try:
        request.META["CSRF_COOKIE"] = request.COOKIES[settings.CSRF_COOKIE_NAME]
    except KeyError:
        csrf_token = storage.get('csrf_token', None)
        if csrf_token:
            request.META["CSRF_COOKIE"] = csrf_token
    return storage


def backup_csrf_token(context, storage=None):
    """
    Get the CSRF token and convert it to a string (since it's lazy)
    """
    if storage is None:
        storage = Context()
    storage['csrf_token'] = smart_str(context.get('csrf_token', 'NOTPROVIDED'))
    return storage


def drop_vary_headers(response, headers_to_drop):
    """
    Remove an item from the "Vary" header of an ``HttpResponse`` object.
    If no items remain, delete the "Vary" header.
    This does the opposite effect of django.utils.cache.patch_vary_headers.
    """
    if response.has_header('Vary'):
        vary_headers = cc_delim_re.split(response['Vary'])
    else:
        vary_headers = []

    headers_to_drop = [header.lower() for header in headers_to_drop]

    updated_vary_headers = []
    for header in vary_headers:
        if len(header):
            if header.lower() not in headers_to_drop:
                updated_vary_headers.append(header)

    if len(updated_vary_headers):
        response['Vary'] = ', '.join(updated_vary_headers)
    else:
        del response['Vary']


def flatten_context(context, remove_lazy=True):
    """
    Creates a dictionary from a Context instance by traversing
    its dicts list. Can remove unwanted subjects from the result,
    e.g. lazy objects.
    """
    flat_context = {}

    def _flatten(context):
        if isinstance(context, dict):
            for k, v in context.items():
                if isinstance(context, BaseContext):
                    _flatten(context)
                else:
                    flat_context[k] = v
        elif isinstance(context, BaseContext):
            for context_dict in context.dicts:
                _flatten(context_dict)

    # traverse the passed context and update the dictionary accordingly
    _flatten(context)

    if remove_lazy:
        only_allowed = lambda dic: not isinstance(dic[1], forbidden_classes)
        return dict(filter(only_allowed, flat_context.iteritems()))
    return flat_context


def unpickle_context(content, pattern=None):
    """
    Unpickle the context from the given content string or return None.
    """
    pickle = get_pickle()
    if pattern is None:
        pattern = pickled_context_re
    match = pattern.search(content)
    if match:
        return pickle.loads(base64.standard_b64decode(match.group(1)))
    return None


def pickle_context(context, template=None):
    """
    Pickle the given Context instance and do a few optimzations before.
    """
    pickle = get_pickle()
    if not isinstance(context, BaseContext):
        raise TemplateSyntaxError('Phased context is not a Context instance')
    pickled_context = pickle.dumps(flatten_context(context), protocol=pickle.HIGHEST_PROTOCOL)
    if template is None:
        template = '{# stashed context: "%s" #}'
    return template % base64.standard_b64encode(pickled_context)

########NEW FILE########
