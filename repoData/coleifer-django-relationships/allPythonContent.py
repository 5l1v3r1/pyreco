__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# django-relationships documentation build configuration file, created by
# sphinx-quickstart on Wed Jul 13 09:47:16 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'django-relationships'
copyright = u'2011, charles leifer'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.3.0'
# The full version, including alpha/beta/rc tags.
release = '0.3.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'nature'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'django-relationshipsdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'django-relationships.tex', u'django-relationships Documentation',
   u'charles leifer', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'django-relationships', u'django-relationships Documentation',
     [u'charles leifer'], 1)
]

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin

from .compat import User
from .forms import RelationshipStatusAdminForm
from .models import Relationship, RelationshipStatus


class RelationshipInline(admin.TabularInline):
    model = Relationship
    raw_id_fields = ('from_user', 'to_user')
    extra = 1
    fk_name = 'from_user'


class UserRelationshipAdmin(UserAdmin):
    inlines = (RelationshipInline,)


class RelationshipStatusAdmin(admin.ModelAdmin):
    form = RelationshipStatusAdminForm

admin.site.unregister(User)
admin.site.register(User, UserRelationshipAdmin)
admin.site.register(RelationshipStatus, RelationshipStatusAdmin)

########NEW FILE########
__FILENAME__ = compat
import django


# Django 1.5 add support for custom auth user model
if django.VERSION >= (1, 5):
    from django.contrib.auth import get_user_model
    User = get_user_model()
else:
    try:
        from django.contrib.auth.models import User
    except ImportError:
        raise ImportError(u"User model is not to be found.")

# location of patterns, url, include changes in 1.4 onwards
try:
    from django.conf.urls import patterns, url, include
except:
    from django.conf.urls.defaults import patterns, url, include

########NEW FILE########
__FILENAME__ = decorators
from django.shortcuts import get_object_or_404

from .compat import User


def require_user(view):
    def inner(request, username, *args, **kwargs):
        user = get_object_or_404(User, username=username)
        return view(request, user, *args, **kwargs)
    return inner

########NEW FILE########
__FILENAME__ = forms
from django import forms
from django.db.models import Q

from .models import RelationshipStatus


class RelationshipStatusAdminForm(forms.ModelForm):
    class Meta:
        model = RelationshipStatus

    def duplicate_slug_check(self, status_slug):
        status_qs = RelationshipStatus.objects.filter(
            Q(from_slug=status_slug) |
            Q(to_slug=status_slug) |
            Q(symmetrical_slug=status_slug)
        )

        if self.instance.pk:
            status_qs = status_qs.exclude(pk=self.instance.pk)

        if status_qs.exists():
            raise forms.ValidationError('"%s" slug already in use on %s' %
                (status_slug, unicode(status_qs[0])))

    def clean_from_slug(self):
        self.duplicate_slug_check(self.cleaned_data['from_slug'])
        return self.cleaned_data['from_slug']

    def clean_to_slug(self):
        self.duplicate_slug_check(self.cleaned_data['to_slug'])
        return self.cleaned_data['to_slug']

    def clean_symmetrical_slug(self):
        self.duplicate_slug_check(self.cleaned_data['symmetrical_slug'])
        return self.cleaned_data['symmetrical_slug']

    def clean(self):
        if self.errors:
            return self.cleaned_data

        if self.cleaned_data['from_slug'] == self.cleaned_data['to_slug'] or \
           self.cleaned_data['to_slug'] == self.cleaned_data['symmetrical_slug'] or \
           self.cleaned_data['symmetrical_slug'] == self.cleaned_data['from_slug']:
            raise forms.ValidationError('from, to, and symmetrical slugs must be different')

        return self.cleaned_data

########NEW FILE########
__FILENAME__ = listeners
from django.db.models import signals

from .models import RelationshipStatus, Relationship


def mutually_exclusive_fix(sender, instance, created, **kwargs):
    # instance will be the new relationship that was created
    # and since some applications will want to use the default
    # "following" and "blocking" statuses in tandem, this hook
    # handles deleting a "following" status when a "blocking" is
    # added, and vice-versa
    try:
        following = RelationshipStatus.objects.following()
        blocking = RelationshipStatus.objects.blocking()
    except RelationshipStatus.DoesNotExist:
        pass
    else:
        # check to see if the new status is "following" or "blocking"
        other = None
        if instance.status == following:
            other = blocking
        elif instance.status == blocking:
            other = following

        if other:
            # delete any status that may conflict with the new one
            Relationship.objects.filter(
                from_user=instance.from_user,
                to_user=instance.to_user,
                site=instance.site,
                status=other
            ).delete()


DISPATCH_UID = 'relationships.listeners.exclusive_fix'


def attach_relationship_listener(func=mutually_exclusive_fix, dispatch_uid=DISPATCH_UID):
    signals.post_save.connect(func, sender=Relationship, dispatch_uid=dispatch_uid)


def detach_relationship_listener(dispatch_uid=DISPATCH_UID):
    signals.post_save.disconnect(sender=Relationship, dispatch_uid=dispatch_uid)

########NEW FILE########
__FILENAME__ = 0001_initial
from south.db import db
from relationships.models import *


class Migration:

    def forwards(self, orm):

        # Adding model 'RelationshipStatus'
        db.create_table('relationships_relationshipstatus', (
            ('id', orm['relationships.RelationshipStatus:id']),
            ('name', orm['relationships.RelationshipStatus:name']),
            ('verb', orm['relationships.RelationshipStatus:verb']),
            ('from_slug', orm['relationships.RelationshipStatus:from_slug']),
            ('to_slug', orm['relationships.RelationshipStatus:to_slug']),
            ('symmetrical_slug', orm['relationships.RelationshipStatus:symmetrical_slug']),
            ('login_required', orm['relationships.RelationshipStatus:login_required']),
            ('private', orm['relationships.RelationshipStatus:private']),
        ))
        db.send_create_signal('relationships', ['RelationshipStatus'])

        # Adding model 'Relationship'
        db.create_table('relationships_relationship', (
            ('id', orm['relationships.Relationship:id']),
            ('from_user', orm['relationships.Relationship:from_user']),
            ('to_user', orm['relationships.Relationship:to_user']),
            ('status', orm['relationships.Relationship:status']),
            ('created', orm['relationships.Relationship:created']),
        ))
        db.send_create_signal('relationships', ['Relationship'])

        # Creating unique_together for [from_user, to_user, status] on Relationship.
        db.create_unique('relationships_relationship', ['from_user_id', 'to_user_id', 'status_id'])

    def backwards(self, orm):

        # Deleting unique_together for [from_user, to_user, status] on Relationship.
        db.delete_unique('relationships_relationship', ['from_user_id', 'to_user_id', 'status_id'])

        # Deleting model 'RelationshipStatus'
        db.delete_table('relationships_relationshipstatus')

        # Deleting model 'Relationship'
        db.delete_table('relationships_relationship')

    models = {
        'auth.group': {
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'unique_together': "(('content_type', 'codename'),)"},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'blank': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'relationships': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.User']", 'symmetrical': 'False'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'unique_together': "(('app_label', 'model'),)", 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'relationships.relationship': {
            'Meta': {'unique_together': "(('from_user', 'to_user', 'status'),)"},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'from_user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'from_users'", 'to': "orm['auth.User']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'status': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['relationships.RelationshipStatus']"}),
            'to_user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'to_users'", 'to': "orm['auth.User']"})
        },
        'relationships.relationshipstatus': {
            'from_slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '50', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'login_required': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'private': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'symmetrical_slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '50', 'db_index': 'True'}),
            'to_slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '50', 'db_index': 'True'}),
            'verb': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['relationships']

########NEW FILE########
__FILENAME__ = 0002_add_site_fk
from south.db import db
from relationships.models import *


class Migration:

    def forwards(self, orm):

        # Adding field 'Relationship.site'
        db.add_column('relationships_relationship', 'site', orm['relationships.relationship:site'])

    def backwards(self, orm):

        # Deleting field 'Relationship.site'
        db.delete_column('relationships_relationship', 'site_id')

    models = {
        'auth.group': {
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'unique_together': "(('content_type', 'codename'),)"},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'blank': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'relationships': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.User']", 'symmetrical': 'False'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'unique_together': "(('app_label', 'model'),)", 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'relationships.relationship': {
            'Meta': {'unique_together': "(('from_user', 'to_user', 'status'),)"},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'from_user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'from_users'", 'to': "orm['auth.User']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'site': ('django.db.models.fields.related.ForeignKey', [], {'default': '1', 'to': "orm['sites.Site']"}),
            'status': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['relationships.RelationshipStatus']"}),
            'to_user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'to_users'", 'to': "orm['auth.User']"})
        },
        'relationships.relationshipstatus': {
            'from_slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '50', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'login_required': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'private': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'symmetrical_slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '50', 'db_index': 'True'}),
            'to_slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '50', 'db_index': 'True'}),
            'verb': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'sites.site': {
            'Meta': {'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        }
    }

    complete_apps = ['relationships']

########NEW FILE########
__FILENAME__ = 0003_slugs_to_charfields
from south.db import db
from relationships.models import *


class Migration:

    def forwards(self, orm):

        # Deleting unique_together for [symmetrical_slug] on relationshipstatus.
        db.delete_unique('relationships_relationshipstatus', ['symmetrical_slug'])

        # Deleting unique_together for [from_slug] on relationshipstatus.
        db.delete_unique('relationships_relationshipstatus', ['from_slug'])

        # Deleting unique_together for [to_slug] on relationshipstatus.
        db.delete_unique('relationships_relationshipstatus', ['to_slug'])

        # Changing field 'RelationshipStatus.to_slug'
        # (to signature: django.db.models.fields.CharField(max_length=100))
        db.alter_column('relationships_relationshipstatus', 'to_slug', orm['relationships.relationshipstatus:to_slug'])

        # Changing field 'RelationshipStatus.symmetrical_slug'
        # (to signature: django.db.models.fields.CharField(max_length=100))
        db.alter_column('relationships_relationshipstatus', 'symmetrical_slug', orm['relationships.relationshipstatus:symmetrical_slug'])

        # Changing field 'RelationshipStatus.from_slug'
        # (to signature: django.db.models.fields.CharField(max_length=100))
        db.alter_column('relationships_relationshipstatus', 'from_slug', orm['relationships.relationshipstatus:from_slug'])

    def backwards(self, orm):

        # Changing field 'RelationshipStatus.to_slug'
        # (to signature: django.db.models.fields.SlugField(max_length=50, unique=True, db_index=True))
        db.alter_column('relationships_relationshipstatus', 'to_slug', orm['relationships.relationshipstatus:to_slug'])

        # Changing field 'RelationshipStatus.symmetrical_slug'
        # (to signature: django.db.models.fields.SlugField(max_length=50, unique=True, db_index=True))
        db.alter_column('relationships_relationshipstatus', 'symmetrical_slug', orm['relationships.relationshipstatus:symmetrical_slug'])

        # Changing field 'RelationshipStatus.from_slug'
        # (to signature: django.db.models.fields.SlugField(max_length=50, unique=True, db_index=True))
        db.alter_column('relationships_relationshipstatus', 'from_slug', orm['relationships.relationshipstatus:from_slug'])

        # Creating unique_together for [to_slug] on relationshipstatus.
        db.create_unique('relationships_relationshipstatus', ['to_slug'])

        # Creating unique_together for [from_slug] on relationshipstatus.
        db.create_unique('relationships_relationshipstatus', ['from_slug'])

        # Creating unique_together for [symmetrical_slug] on relationshipstatus.
        db.create_unique('relationships_relationshipstatus', ['symmetrical_slug'])

    models = {
        'auth.group': {
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'unique_together': "(('content_type', 'codename'),)"},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'blank': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'relationships': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.User']", 'symmetrical': 'False'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'unique_together': "(('app_label', 'model'),)", 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'relationships.relationship': {
            'Meta': {'unique_together': "(('from_user', 'to_user', 'status'),)"},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'from_user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'from_users'", 'to': "orm['auth.User']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'site': ('django.db.models.fields.related.ForeignKey', [], {'default': '1', 'to': "orm['sites.Site']"}),
            'status': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['relationships.RelationshipStatus']"}),
            'to_user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'to_users'", 'to': "orm['auth.User']"})
        },
        'relationships.relationshipstatus': {
            'from_slug': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'login_required': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'private': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'symmetrical_slug': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'to_slug': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'verb': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'sites.site': {
            'Meta': {'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        }
    }

    complete_apps = ['relationships']

########NEW FILE########
__FILENAME__ = 0004_add_site_to_unique_together
from south.db import db
from relationships.models import *


class Migration:

    def forwards(self, orm):

        # Deleting unique_together for [from_user, to_user, status] on relationship.
        db.delete_unique('relationships_relationship', ['from_user_id', 'to_user_id', 'status_id'])

        # Creating unique_together for [from_user, to_user, status, site] on Relationship.
        db.create_unique('relationships_relationship', ['from_user_id', 'to_user_id', 'status_id', 'site_id'])

    def backwards(self, orm):

        # Deleting unique_together for [from_user, to_user, status, site] on Relationship.
        db.delete_unique('relationships_relationship', ['from_user_id', 'to_user_id', 'status_id', 'site_id'])

        # Creating unique_together for [from_user, to_user, status] on relationship.
        db.create_unique('relationships_relationship', ['from_user_id', 'to_user_id', 'status_id'])

    models = {
        'auth.group': {
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'unique_together': "(('content_type', 'codename'),)"},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'blank': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'relationships': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.User']", 'symmetrical': 'False'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'unique_together': "(('app_label', 'model'),)", 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'relationships.relationship': {
            'Meta': {'unique_together': "(('from_user', 'to_user', 'status', 'site'),)"},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'from_user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'from_users'", 'to': "orm['auth.User']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'site': ('django.db.models.fields.related.ForeignKey', [], {'default': '24', 'related_name': "'relationships'", 'to': "orm['sites.Site']"}),
            'status': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['relationships.RelationshipStatus']"}),
            'to_user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'to_users'", 'to': "orm['auth.User']"})
        },
        'relationships.relationshipstatus': {
            'from_slug': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'login_required': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'private': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'symmetrical_slug': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'to_slug': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'verb': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'sites.site': {
            'Meta': {'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        }
    }

    complete_apps = ['relationships']

########NEW FILE########
__FILENAME__ = 0005_add_weight_column
# encoding: utf-8
from south.db import db
from south.v2 import SchemaMigration


class Migration(SchemaMigration):

    def forwards(self, orm):

        # Adding field 'Relationship.weight'
        db.add_column('relationships_relationship', 'weight', self.gf('django.db.models.fields.FloatField')(default=1.0, null=True, blank=True), keep_default=False)

    def backwards(self, orm):

        # Deleting field 'Relationship.weight'
        db.delete_column('relationships_relationship', 'weight')

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'blank': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'relationships': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'related_to'", 'symmetrical': 'False', 'through': "orm['relationships.Relationship']", 'to': "orm['auth.User']"}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'relationships.relationship': {
            'Meta': {'unique_together': "(('from_user', 'to_user', 'status', 'site'),)", 'object_name': 'Relationship'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'from_user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'from_users'", 'to': "orm['auth.User']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'site': ('django.db.models.fields.related.ForeignKey', [], {'default': '1', 'related_name': "'relationships'", 'to': "orm['sites.Site']"}),
            'status': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['relationships.RelationshipStatus']"}),
            'to_user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'to_users'", 'to': "orm['auth.User']"}),
            'weight': ('django.db.models.fields.FloatField', [], {'default': '1.0', 'null': 'True', 'blank': 'True'})
        },
        'relationships.relationshipstatus': {
            'Meta': {'object_name': 'RelationshipStatus'},
            'from_slug': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'login_required': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'private': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'symmetrical_slug': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'to_slug': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'verb': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'sites.site': {
            'Meta': {'object_name': 'Site', 'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        }
    }

    complete_apps = ['relationships']

########NEW FILE########
__FILENAME__ = models
import django
from django.conf import settings
from django.contrib.sites.models import Site
from django.db import models, connection
from django.db.models.fields.related import create_many_related_manager, ManyToManyRel
from django.utils.translation import ugettext_lazy as _

from .compat import User


class RelationshipStatusManager(models.Manager):
    # convenience methods to handle some default statuses
    def following(self):
        return self.get(from_slug='following')

    def blocking(self):
        return self.get(from_slug='blocking')

    def by_slug(self, status_slug):
        return self.get(
            models.Q(from_slug=status_slug) |
            models.Q(to_slug=status_slug) |
            models.Q(symmetrical_slug=status_slug)
        )


class RelationshipStatus(models.Model):
    name = models.CharField(_('name'), max_length=100)
    verb = models.CharField(_('verb'), max_length=100)
    from_slug = models.CharField(_('from slug'), max_length=100,
        help_text=_("Denote the relationship from the user, i.e. 'following'"))
    to_slug = models.CharField(_('to slug'), max_length=100,
        help_text=_("Denote the relationship to the user, i.e. 'followers'"))
    symmetrical_slug = models.CharField(_('symmetrical slug'), max_length=100,
        help_text=_("When a mutual relationship exists, i.e. 'friends'"))
    login_required = models.BooleanField(_('login required'), default=False,
        help_text=_("Users must be logged in to see these relationships"))
    private = models.BooleanField(_('private'), default=False,
        help_text=_("Only the user who owns these relationships can see them"))

    objects = RelationshipStatusManager()

    class Meta:
        ordering = ('name',)
        verbose_name = _('Relationship status')
        verbose_name_plural = _('Relationship statuses')

    def __unicode__(self):
        return self.name


class Relationship(models.Model):
    from_user = models.ForeignKey(User,
        related_name='from_users', verbose_name=_('from user'))
    to_user = models.ForeignKey(User,
        related_name='to_users', verbose_name=_('to user'))
    status = models.ForeignKey(RelationshipStatus, verbose_name=_('status'))
    created = models.DateTimeField(_('created'), auto_now_add=True)
    weight = models.FloatField(_('weight'), default=1.0, blank=True, null=True)
    site = models.ForeignKey(Site, default=settings.SITE_ID,
        verbose_name=_('site'), related_name='relationships')

    class Meta:
        unique_together = (('from_user', 'to_user', 'status', 'site'),)
        ordering = ('created',)
        verbose_name = _('Relationship')
        verbose_name_plural = _('Relationships')

    def __unicode__(self):
        return (_('Relationship from %(from_user)s to %(to_user)s')
                % {'from_user': self.from_user.username,
                   'to_user': self.to_user.username})

field = models.ManyToManyField(User, through=Relationship,
                               symmetrical=False, related_name='related_to')


class RelationshipManager(User._default_manager.__class__):
    def __init__(self, instance=None, *args, **kwargs):
        super(RelationshipManager, self).__init__(*args, **kwargs)
        self.instance = instance

    def add(self, user, status=None, symmetrical=False):
        """
        Add a relationship from one user to another with the given status,
        which defaults to "following".

        Adding a relationship is by default asymmetrical (akin to following
        someone on twitter).  Specify a symmetrical relationship (akin to being
        friends on facebook) by passing in :param:`symmetrical` = True

        .. note::

            If :param:`symmetrical` is set, the function will return a tuple
            containing the two relationship objects created
        """
        if not status:
            status = RelationshipStatus.objects.following()

        relationship, created = Relationship.objects.get_or_create(
            from_user=self.instance,
            to_user=user,
            status=status,
            site=Site.objects.get_current()
        )

        if symmetrical:
            return (relationship, user.relationships.add(self.instance, status, False))
        else:
            return relationship

    def remove(self, user, status=None, symmetrical=False):
        """
        Remove a relationship from one user to another, with the same caveats
        and behavior as adding a relationship.
        """
        if not status:
            status = RelationshipStatus.objects.following()

        res = Relationship.objects.filter(
            from_user=self.instance,
            to_user=user,
            status=status,
            site__pk=settings.SITE_ID
        ).delete()

        if symmetrical:
            return (res, user.relationships.remove(self.instance, status, False))
        else:
            return res

    def _get_from_query(self, status):
        return dict(
            to_users__from_user=self.instance,
            to_users__status=status,
            to_users__site__pk=settings.SITE_ID,
        )

    def _get_to_query(self, status):
        return dict(
            from_users__to_user=self.instance,
            from_users__status=status,
            from_users__site__pk=settings.SITE_ID
        )

    def get_relationships(self, status, symmetrical=False):
        """
        Returns a QuerySet of user objects with which the given user has
        established a relationship.
        """
        query = self._get_from_query(status)

        if symmetrical:
            query.update(self._get_to_query(status))

        return User.objects.filter(**query)

    def get_related_to(self, status):
        """
        Returns a QuerySet of user objects which have created a relationship to
        the given user.
        """
        return User.objects.filter(**self._get_to_query(status))

    def only_to(self, status):
        """
        Returns a QuerySet of user objects who have created a relationship to
        the given user, but which the given user has not reciprocated
        """
        from_relationships = self.get_relationships(status)
        to_relationships = self.get_related_to(status)
        return to_relationships.exclude(pk__in=from_relationships.values_list('pk'))

    def only_from(self, status):
        """
        Like :method:`only_to`, returns user objects with whom the given user
        has created a relationship, but which have not reciprocated
        """
        from_relationships = self.get_relationships(status)
        to_relationships = self.get_related_to(status)
        return from_relationships.exclude(pk__in=to_relationships.values_list('pk'))

    def exists(self, user, status=None, symmetrical=False):
        """
        Returns boolean whether or not a relationship exists between the given
        users.  An optional :class:`RelationshipStatus` instance can be specified.
        """
        query = dict(
            to_users__from_user=self.instance,
            to_users__to_user=user,
            to_users__site__pk=settings.SITE_ID,
        )

        if status:
            query.update(to_users__status=status)

        if symmetrical:
            query.update(
                from_users__to_user=self.instance,
                from_users__from_user=user,
                from_users__site__pk=settings.SITE_ID
            )

            if status:
                query.update(from_users__status=status)

        return User.objects.filter(**query).exists()

    # some defaults
    def following(self):
        return self.get_relationships(RelationshipStatus.objects.following())

    def followers(self):
        return self.get_related_to(RelationshipStatus.objects.following())

    def blocking(self):
        return self.get_relationships(RelationshipStatus.objects.blocking())

    def blockers(self):
        return self.get_related_to(RelationshipStatus.objects.blocking())

    def friends(self):
        return self.get_relationships(RelationshipStatus.objects.following(), True)


if django.VERSION < (1, 2):

    RelatedManager = create_many_related_manager(RelationshipManager, Relationship)

    class RelationshipsDescriptor(object):
        def __get__(self, instance, instance_type=None):
            qn = connection.ops.quote_name
            manager = RelatedManager(
                model=User,
                core_filters={'related_to__pk': instance._get_pk_val()},
                instance=instance,
                symmetrical=False,
                join_table=qn('relationships_relationship'),
                source_col_name=qn('from_user_id'),
                target_col_name=qn('to_user_id'),
            )
            return manager

elif django.VERSION > (1, 2) and django.VERSION < (1, 4):

    fake_rel = ManyToManyRel(
        to=User,
        through=Relationship)

    RelatedManager = create_many_related_manager(RelationshipManager, fake_rel)

    class RelationshipsDescriptor(object):
        def __get__(self, instance, instance_type=None):
            manager = RelatedManager(
                model=User,
                core_filters={'related_to__pk': instance._get_pk_val()},
                instance=instance,
                symmetrical=False,
                source_field_name='from_user',
                target_field_name='to_user'
            )
            return manager

else:

    fake_rel = ManyToManyRel(
        to=User,
        through=Relationship)

    RelatedManager = create_many_related_manager(RelationshipManager, fake_rel)

    class RelationshipsDescriptor(object):
        def __get__(self, instance, instance_type=None):
            manager = RelatedManager(
                model=User,
                query_field_name='related_to',
                instance=instance,
                symmetrical=False,
                source_field_name='from_user',
                target_field_name='to_user',
                through=Relationship,
            )
            return manager

#HACK
field.contribute_to_class(User, 'relationships')
setattr(User, 'relationships', RelationshipsDescriptor())

########NEW FILE########
__FILENAME__ = models

########NEW FILE########
__FILENAME__ = tests
from django.conf import settings
from django.contrib.sites.models import Site
from django.core.urlresolvers import reverse
from django.template import Template, Context
from django.test import TestCase

from relationships.forms import RelationshipStatusAdminForm
from relationships.listeners import (attach_relationship_listener,
    detach_relationship_listener)
from relationships.models import Relationship, RelationshipStatus
from relationships.utils import (relationship_exists, extract_user_field,
    positive_filter, negative_filter)
from relationships.compat import User


class BaseRelationshipsTestCase(TestCase):
    """
    The fixture data defines:

    - 4 users, The Walrus, John, Paul and Yoko
    - 2 relationship status, Following & Blocking
    - 4 relationships
        - John is following Yoko
        - John is following Paul
        - Yoko is following John
        - Paul is blocking John
    """
    fixtures = ['relationships.json']

    def setUp(self):
        self.walrus = User.objects.get(username='The_Walrus')  # pk 1
        self.john = User.objects.get(username='John')  # pk 2
        self.paul = User.objects.get(username='Paul')  # pk 3
        self.yoko = User.objects.get(username='Yoko')  # pk 4

        self.following = RelationshipStatus.objects.get(from_slug='following')
        self.blocking = RelationshipStatus.objects.get(from_slug='blocking')

        self.site_id = settings.SITE_ID
        settings.SITE_ID = 1

        self.site = Site.objects.get_current()

    def tearDown(self):
        settings.SITE_ID = self.site_id

    def _sort_by_pk(self, list_or_qs):
        annotated = [(item.pk, item) for item in list_or_qs]
        annotated.sort()
        return map(lambda item_tuple: item_tuple[1], annotated)

    def assertQuerysetEqual(self, a, b):
        return self.assertEqual(self._sort_by_pk(a), self._sort_by_pk(b))


class RelationshipsTestCase(BaseRelationshipsTestCase):
    def setUp(self):
        BaseRelationshipsTestCase.setUp(self)
        self.second_site = Site.objects.create(name='ex2.com', domain='ex2.com')

    def test_manager(self):
        rel = self.walrus.relationships.all()
        self.assertQuerysetEqual(rel, [])

        rel = self.john.relationships.all()
        self.assertQuerysetEqual(rel, [self.paul, self.yoko])

        rel = self.paul.relationships.all()
        self.assertQuerysetEqual(rel, [self.john])

        rel = self.yoko.relationships.all()
        self.assertQuerysetEqual(rel, [self.john])

    def test_related_name(self):
        rel = self.walrus.related_to.all()
        self.assertQuerysetEqual(rel, [])

        rel = self.john.related_to.all()
        self.assertQuerysetEqual(rel, [self.paul, self.yoko])

        rel = self.paul.related_to.all()
        self.assertQuerysetEqual(rel, [self.john])

        rel = self.yoko.related_to.all()
        self.assertQuerysetEqual(rel, [self.john])

    def test_inherited_manager_methods(self):
        # does filter work?
        rel = self.john.relationships.filter(username='Paul')
        self.assertQuerysetEqual(rel, [self.paul])

        # does filter work?
        rel = self.walrus.relationships.filter(username='Paul')
        self.assertQuerysetEqual(rel, [])

        # does exclude work?
        rel = self.john.relationships.exclude(username='Paul')
        self.assertQuerysetEqual(rel, [self.yoko])

        # does clear work?
        self.john.relationships.clear()
        rel = self.john.relationships.all()
        self.assertQuerysetEqual(rel, [])

        # make sure yoko's relationship to john is still there
        rel = self.yoko.relationships.all()
        self.assertQuerysetEqual(rel, [self.john])

    def test_add_method(self):
        self.john.relationships.add(self.walrus)

        rel = self.john.relationships.all()
        self.assertQuerysetEqual(rel, [self.walrus, self.paul, self.yoko])

        # check that it wasn't added symmetrically
        rel = self.john.related_to.all()
        self.assertQuerysetEqual(rel, [self.paul, self.yoko])

        # check that it doesn't show up in walrus' relationships
        rel = self.walrus.relationships.all()
        self.assertQuerysetEqual(rel, [])

        # but it *does* show up in walrus' reverse relationships
        rel = self.walrus.related_to.all()
        self.assertQuerysetEqual(rel, [self.john])

        # test that dupes aren't added
        self.john.relationships.add(self.walrus)

        rel = self.john.relationships.all()
        self.assertQuerysetEqual(rel, [self.walrus, self.paul, self.yoko])

    def test_add_symmetrical(self):
        _, _ = self.john.relationships.add(self.walrus, symmetrical=True)

        # should show up in john's relationships
        rel = self.john.relationships.all()
        self.assertQuerysetEqual(rel, [self.walrus, self.paul, self.yoko])

        # should also show up that walrus has a relationship to john
        rel = self.john.related_to.all()
        self.assertQuerysetEqual(rel, [self.walrus, self.paul, self.yoko])

        # and same for walrus...
        rel = self.walrus.relationships.all()
        self.assertQuerysetEqual(rel, [self.john])

        rel = self.walrus.related_to.all()
        self.assertQuerysetEqual(rel, [self.john])

    def test_remove_method(self):
        self.john.relationships.remove(self.yoko)

        # no longer shows up in the relationships
        rel = self.john.relationships.all()
        self.assertQuerysetEqual(rel, [self.paul])

        # the reverse relationship is still intact
        rel = self.john.related_to.all()
        self.assertQuerysetEqual(rel, [self.paul, self.yoko])

        rel = self.yoko.relationships.all()
        self.assertQuerysetEqual(rel, [self.john])

        rel = self.yoko.related_to.all()
        self.assertQuerysetEqual(rel, [])

        # no error
        self.john.relationships.remove(self.yoko)

    def test_remove_symmetrical(self):
        self.john.relationships.remove(self.yoko, symmetrical=True)

        rel = self.john.relationships.all()
        self.assertQuerysetEqual(rel, [self.paul])

        rel = self.john.related_to.all()
        self.assertQuerysetEqual(rel, [self.paul])

        rel = self.yoko.relationships.all()
        self.assertQuerysetEqual(rel, [])

        rel = self.yoko.related_to.all()
        self.assertQuerysetEqual(rel, [])

    def test_custom_methods(self):
        rel = self.john.relationships.following()
        self.assertQuerysetEqual(rel, [self.paul, self.yoko])

        rel = self.john.relationships.followers()
        self.assertQuerysetEqual(rel, [self.yoko])

        rel = self.john.relationships.blocking()
        self.assertQuerysetEqual(rel, [])

        rel = self.john.relationships.blockers()
        self.assertQuerysetEqual(rel, [self.paul])

        rel = self.john.relationships.friends()
        self.assertQuerysetEqual(rel, [self.yoko])

        ###
        rel = self.paul.relationships.following()
        self.assertQuerysetEqual(rel, [])

        rel = self.paul.relationships.followers()
        self.assertQuerysetEqual(rel, [self.john])

        rel = self.paul.relationships.blocking()
        self.assertQuerysetEqual(rel, [self.john])

        rel = self.paul.relationships.blockers()
        self.assertQuerysetEqual(rel, [])

        rel = self.paul.relationships.friends()
        self.assertQuerysetEqual(rel, [])

    def test_exists(self):
        self.assertTrue(self.john.relationships.exists(self.yoko))
        self.assertTrue(self.john.relationships.exists(self.paul))
        self.assertFalse(self.john.relationships.exists(self.walrus))

        self.assertTrue(self.paul.relationships.exists(self.john))
        self.assertFalse(self.paul.relationships.exists(self.yoko))
        self.assertFalse(self.paul.relationships.exists(self.walrus))

    def test_exists_with_status(self):
        self.assertTrue(self.john.relationships.exists(self.yoko, self.following))
        self.assertTrue(self.john.relationships.exists(self.paul, self.following))
        self.assertFalse(self.john.relationships.exists(self.walrus, self.following))

        self.assertFalse(self.john.relationships.exists(self.yoko, self.blocking))
        self.assertFalse(self.john.relationships.exists(self.paul, self.blocking))
        self.assertFalse(self.john.relationships.exists(self.walrus, self.blocking))

        self.assertFalse(self.paul.relationships.exists(self.john, self.following))
        self.assertFalse(self.paul.relationships.exists(self.yoko, self.following))
        self.assertFalse(self.paul.relationships.exists(self.walrus, self.following))

        self.assertTrue(self.paul.relationships.exists(self.john, self.blocking))
        self.assertFalse(self.paul.relationships.exists(self.yoko, self.blocking))
        self.assertFalse(self.paul.relationships.exists(self.walrus, self.blocking))

    def test_oneway_methods(self):
        self.assertQuerysetEqual(self.john.relationships.only_from(self.following), [self.paul])
        self.assertQuerysetEqual(self.john.relationships.only_to(self.following), [])

        self.assertQuerysetEqual(self.john.relationships.only_from(self.blocking), [])
        self.assertQuerysetEqual(self.john.relationships.only_to(self.blocking), [self.paul])

    def test_site_behavior(self):
        # relationships are site-dependent

        # walrus is now following John on the current site
        self.walrus.relationships.add(self.john)

        # walrus is now following Paul on another site
        status = RelationshipStatus.objects.following()
        r, _ = Relationship.objects.get_or_create(
            from_user=self.walrus,
            to_user=self.paul,
            site=self.second_site,
            status=status,
        )

        # the 'following' method is siteified
        self.assertQuerysetEqual(self.walrus.relationships.following(), [self.john])

        # ... the .all() method is not
        self.assertQuerysetEqual(self.walrus.relationships.all(), [self.john, self.paul])

        # remove only works on the current site, so paul will *NOT* be removed
        self.walrus.relationships.remove(self.paul)
        self.assertQuerysetEqual(self.walrus.relationships.all(), [self.john, self.paul])


class RelationshipsListenersTestCase(BaseRelationshipsTestCase):
    def setUp(self):
        BaseRelationshipsTestCase.setUp(self)
        attach_relationship_listener()

    def tearDown(self):
        detach_relationship_listener()
        BaseRelationshipsTestCase.tearDown(self)

    def test_following_and_blocking(self):
        # check initial state, john is following paul & yoko
        self.assertQuerysetEqual(self.john.relationships.following(), [self.paul, self.yoko])

        # when john blocks paul, his 'following' relationship will be deleted
        self.john.relationships.add(self.paul, self.blocking)
        self.assertQuerysetEqual(self.john.relationships.blocking(), [self.paul])
        self.assertQuerysetEqual(self.john.relationships.following(), [self.yoko])

        # check initial state for paul
        self.assertQuerysetEqual(self.paul.relationships.blocking(), [self.john])

        # when paul follows john his 'blocking' relationship will be deleted
        self.paul.relationships.add(self.john, self.following)
        self.assertQuerysetEqual(self.paul.relationships.following(), [self.john])
        self.assertQuerysetEqual(self.paul.relationships.blocking(), [])

    def test_listener_disconnecting(self):
        # this test simply ensures the default behavior
        detach_relationship_listener()

        # have john start blocking paul
        self.john.relationships.add(self.paul, self.blocking)

        # the blocking relationship is created and the original following
        # relationship is left intact
        self.assertQuerysetEqual(self.john.relationships.blocking(), [self.paul])
        self.assertQuerysetEqual(self.john.relationships.following(), [self.paul, self.yoko])

        # have paul start following john
        self.paul.relationships.add(self.john, self.following)

        # the following relationship is created and the original blocking
        # relationship is left intact
        self.assertQuerysetEqual(self.paul.relationships.following(), [self.john])
        self.assertQuerysetEqual(self.paul.relationships.blocking(), [self.john])


class RelationshipsViewsTestCase(BaseRelationshipsTestCase):
    def test_list_views(self):
        url = reverse('relationship_list', args=['John'])
        resp = self.client.get(url)

        self.assertEquals(resp.status_code, 200)
        self.assertQuerysetEqual(resp.context['relationship_list'], self.john.relationships.following())

        url = reverse('relationship_list', args=['John', 'followers'])
        resp = self.client.get(url)
        self.assertEquals(resp.status_code, 200)
        self.assertQuerysetEqual(resp.context['relationship_list'], self.john.relationships.followers())

        url = reverse('relationship_list', args=['John', 'following'])
        resp = self.client.get(url)
        self.assertEquals(resp.status_code, 200)
        self.assertQuerysetEqual(resp.context['relationship_list'], self.john.relationships.following())

        url = reverse('relationship_list', args=['John', 'friends'])
        resp = self.client.get(url)
        self.assertEquals(resp.status_code, 200)
        self.assertQuerysetEqual(resp.context['relationship_list'], self.john.relationships.friends())

        url = reverse('relationship_list', args=['John', 'blocking'])
        resp = self.client.get(url)
        self.assertEqual(resp.status_code, 302)

        self.client.login(username='John', password='John')
        url = reverse('relationship_list', args=['John', 'blocking'])
        resp = self.client.get(url)
        self.assertQuerysetEqual(resp.context['relationship_list'], self.john.relationships.blocking())

        # this is private, only Paul can see who he's blocking
        url = reverse('relationship_list', args=['Paul', 'blocking'])
        resp = self.client.get(url)
        self.assertEqual(resp.status_code, 404)

        # non existant relationship status slug
        url = reverse('relationship_list', args=['John', 'walrus-friends'])
        resp = self.client.get(url)
        self.assertEqual(resp.status_code, 404)

    def test_add_remove_login_required(self):
        # login required
        url = reverse('relationship_add', args=['The_Walrus', 'following'])
        resp = self.client.get(url)
        self.assertEqual(resp.status_code, 302)

        url = reverse('relationship_remove', args=['The_Walrus', 'following'])
        resp = self.client.get(url)
        self.assertEqual(resp.status_code, 302)

    def test_add_remove_requires_post(self):
        self.client.login(username='John', password='John')

        url = reverse('relationship_add', args=['The_Walrus', 'following'])
        resp = self.client.get(url)
        self.assertEqual(resp.status_code, 200)

        # a relationship has not been created yet
        self.assertFalse(self.john.relationships.exists(self.walrus, self.following))

        url = reverse('relationship_remove', args=['Yoko', 'following'])
        resp = self.client.get(url)
        self.assertEqual(resp.status_code, 200)

        # the relationship has not been removed
        self.assertTrue(self.john.relationships.exists(self.yoko, self.following))

    def test_adding(self):
        self.client.login(username='John', password='John')

        url = reverse('relationship_add', args=['The_Walrus', 'following'])
        resp = self.client.post(url)
        self.assertEqual(resp.status_code, 200)

        # the relationship has been created
        self.assertTrue(self.john.relationships.exists(self.walrus, self.following))

        # the relationship is not symmetrical, though
        self.assertFalse(self.walrus.relationships.exists(self.john, self.following))

        # a nonexistant user causes a 404
        url = reverse('relationship_add', args=['Nobody', 'following'])
        resp = self.client.post(url)
        self.assertEqual(resp.status_code, 404)

    def test_adding_symm(self):
        self.client.login(username='John', password='John')

        url = reverse('relationship_add', args=['The_Walrus', 'friends'])
        resp = self.client.post(url)
        self.assertEqual(resp.status_code, 200)

        # the relationship has been created
        self.assertTrue(self.john.relationships.exists(self.walrus, self.following))

        # the relationship is symmetrical
        self.assertTrue(self.walrus.relationships.exists(self.john, self.following))

    def test_removing(self):
        self.client.login(username='John', password='John')

        url = reverse('relationship_remove', args=['Yoko', 'following'])
        resp = self.client.post(url)
        self.assertEqual(resp.status_code, 200)

        self.assertFalse(self.john.relationships.exists(self.yoko, self.following))

        # the symmetrical relationship was not removed
        self.assertTrue(self.yoko.relationships.exists(self.john, self.following))

        # non existant user causes a 404
        url = reverse('relationship_remove', args=['Nobody', 'following'])
        resp = self.client.post(url)
        self.assertEqual(resp.status_code, 404)

    def test_removing_symm(self):
        self.client.login(username='John', password='John')

        url = reverse('relationship_remove', args=['Yoko', 'friends'])
        resp = self.client.post(url)
        self.assertEqual(resp.status_code, 200)

        self.assertFalse(self.john.relationships.exists(self.yoko, self.following))

        # the symmetrical relationship was not removed
        self.assertFalse(self.yoko.relationships.exists(self.john, self.following))


class RelationshipsTagsTestCase(BaseRelationshipsTestCase):
    def test_add_url_filter(self):
        t = Template('{% load relationship_tags %}{{ user|add_relationship_url:"following" }}')
        c = Context({'user': self.paul})

        rendered = t.render(c)
        url = reverse('relationship_add', args=['Paul', 'following'])
        self.assertEqual(rendered, url)

        # check that a symmetrical slug can be used
        t = Template('{% load relationship_tags %}{{ user|add_relationship_url:"friends" }}')
        c = Context({'user': self.paul})

        rendered = t.render(c)
        url = reverse('relationship_add', args=['Paul', 'friends'])
        self.assertEqual(rendered, url)

        t = Template('{% load relationship_tags %}{{ user|add_relationship_url:blocking }}')
        c = Context({'user': self.paul, 'blocking': self.blocking})
        rendered = t.render(c)
        url = reverse('relationship_add', args=['Paul', 'blocking'])
        self.assertEqual(rendered, url)

    def test_remove_url_filter(self):
        t = Template('{% load relationship_tags %}{{ user|remove_relationship_url:"following" }}')
        c = Context({'user': self.paul})
        rendered = t.render(c)
        url = reverse('relationship_remove', args=['Paul', 'following'])
        self.assertEqual(rendered, url)

        # check that a symmetrical slug can be used
        t = Template('{% load relationship_tags %}{{ user|remove_relationship_url:"friends" }}')
        c = Context({'user': self.paul})

        rendered = t.render(c)
        url = reverse('relationship_remove', args=['Paul', 'friends'])
        self.assertEqual(rendered, url)

        t = Template('{% load relationship_tags %}{{ user|remove_relationship_url:blocking }}')
        c = Context({'user': self.paul, 'blocking': self.blocking})
        rendered = t.render(c)
        url = reverse('relationship_remove', args=['Paul', 'blocking'])
        self.assertEqual(rendered, url)

    def test_if_relationship_tag(self):
        t = Template('{% load relationship_tags %}{% if_relationship john paul "following" %}y{% else %}n{% endif_relationship %}')
        c = Context({'john': self.john, 'paul': self.paul})
        rendered = t.render(c)
        self.assertEqual(rendered, 'y')

        t = Template('{% load relationship_tags %}{% if_relationship paul john "following" %}y{% else %}n{% endif_relationship %}')
        c = Context({'john': self.john, 'paul': self.paul})
        rendered = t.render(c)
        self.assertEqual(rendered, 'n')

        t = Template('{% load relationship_tags %}{% if_relationship paul john "followers" %}y{% else %}n{% endif_relationship %}')
        c = Context({'john': self.john, 'paul': self.paul})
        rendered = t.render(c)
        self.assertEqual(rendered, 'y')

        t = Template('{% load relationship_tags %}{% if_relationship paul john "friends" %}y{% else %}n{% endif_relationship %}')
        c = Context({'john': self.john, 'paul': self.paul})
        rendered = t.render(c)
        self.assertEqual(rendered, 'n')

        t = Template('{% load relationship_tags %}{% if_relationship john yoko "friends" %}y{% else %}n{% endif_relationship %}')
        c = Context({'john': self.john, 'yoko': self.yoko})
        rendered = t.render(c)
        self.assertEqual(rendered, 'y')

    def test_status_filters(self):
        # create some groups to filter
        from django.contrib.auth.models import Group
        beatles = Group.objects.create(name='beatles')
        john_yoko = Group.objects.create(name='john_yoko')
        characters = Group.objects.create(name='characters')

        self.walrus.groups.add(characters)

        self.john.groups.add(beatles)
        self.john.groups.add(john_yoko)

        self.paul.groups.add(beatles)

        self.yoko.groups.add(john_yoko)
        self.yoko.groups.add(characters)

        group_qs = Group.objects.all().order_by('name')

        # john is friends w/ yoko so show yoko's groups
        t = Template('{% load relationship_tags %}{% for group in qs|friend_content:user %}{{ group.name }}|{% endfor %}')
        c = Context({'user': self.john, 'qs': group_qs})
        rendered = t.render(c)
        self.assertEqual(rendered, 'characters|john_yoko|')

        # paul is friends w/ nobody, so no groups
        c = Context({'user': self.paul, 'qs': group_qs})
        rendered = t.render(c)
        self.assertEqual(rendered, '')

        # john is following paul & yoko
        t = Template('{% load relationship_tags %}{% for group in qs|following_content:user %}{{ group.name }}|{% endfor %}')
        c = Context({'user': self.john, 'qs': group_qs})
        rendered = t.render(c)
        self.assertEqual(rendered, 'beatles|characters|john_yoko|')

        # yoko is followed by john
        t = Template('{% load relationship_tags %}{% for group in qs|followers_content:user %}{{ group.name }}|{% endfor %}')
        c = Context({'user': self.yoko, 'qs': group_qs})
        rendered = t.render(c)
        self.assertEqual(rendered, 'beatles|john_yoko|')

        # paul is blocking john, so every group but ones with him
        t = Template('{% load relationship_tags %}{% for group in qs|unblocked_content:user %}{{ group.name }}|{% endfor %}')
        c = Context({'user': self.paul, 'qs': group_qs})
        rendered = t.render(c)
        self.assertEqual(rendered, 'characters|')

        # oh no, john is blocking yoko
        self.john.relationships.add(self.yoko, RelationshipStatus.objects.blocking())
        c = Context({'user': self.john, 'qs': group_qs})
        rendered = t.render(c)
        self.assertEqual(rendered, 'beatles|')

        # make sure it works with a model string
        t = Template('{% load relationship_tags %}{% for group in "auth.group"|unblocked_content:user %}{{ group.name }}|{% endfor %}')
        c = Context({'user': self.john})
        rendered = t.render(c)
        self.assertEqual(rendered, 'beatles|')


class RelationshipStatusAdminFormTestCase(BaseRelationshipsTestCase):
    def test_no_dupes(self):
        payload = {
            'name': 'Testing',
            'verb': 'testing',
            'from_slug': 'testing',
            'to_slug': 'testers',
            'symmetrical_slug': 'tests'
        }
        form = RelationshipStatusAdminForm(payload)
        self.assertTrue(form.is_valid())
        test_status = form.save()

        # saving again should work
        form = RelationshipStatusAdminForm(payload, instance=test_status)
        self.assertTrue(form.is_valid())

        payload['from_slug'] = 'testers'
        payload['to_slug'] = 'testing'

        # saving will work since it will not test against the current instance
        form = RelationshipStatusAdminForm(payload, instance=test_status)
        self.assertTrue(form.is_valid())

        # setting the from_slug to the to_slug will raise an error
        payload['from_slug'] = 'testers'
        payload['to_slug'] = 'testers'
        form = RelationshipStatusAdminForm(payload, instance=test_status)
        self.assertFalse(form.is_valid())

        # setting the from_slug to the symmetrical_slug will raise an error
        payload['from_slug'] = 'tests'
        form = RelationshipStatusAdminForm(payload, instance=test_status)
        self.assertFalse(form.is_valid())

        # setting to a pre-existing from_slug will fail
        payload['from_slug'] = 'following'
        form = RelationshipStatusAdminForm(payload)
        self.assertFalse(form.is_valid())
        self.assertTrue('from_slug' in form.errors)

        # setting the from_slug to a pre-existing to_slug will also fail
        payload['from_slug'] = 'followers'
        form = RelationshipStatusAdminForm(payload)
        self.assertFalse(form.is_valid())
        self.assertTrue('from_slug' in form.errors)

        # setting the from_slug to a pre-existing symetrical_slug will also fail
        payload['from_slug'] = 'friends'
        form = RelationshipStatusAdminForm(payload)
        self.assertFalse(form.is_valid())
        self.assertTrue('from_slug' in form.errors)


class RelationshipUtilsTestCase(BaseRelationshipsTestCase):
    def test_extract_user_field(self):
        # just test a known pass and known fail
        from django.contrib.comments.models import Comment
        from django.contrib.sites.models import Site

        self.assertEqual(extract_user_field(Comment), 'user')
        self.assertEqual(extract_user_field(Site), None)

    def test_positive_filter(self):
        following = RelationshipStatus.objects.following()

        # create some groups to filter
        from django.contrib.auth.models import Group
        beatles = Group.objects.create(name='beatles')
        john_yoko = Group.objects.create(name='john_yoko')
        characters = Group.objects.create(name='characters')

        self.walrus.groups.add(characters)

        self.john.groups.add(beatles)
        self.john.groups.add(john_yoko)

        self.paul.groups.add(beatles)

        self.yoko.groups.add(john_yoko)
        self.yoko.groups.add(characters)

        group_qs = Group.objects.all().order_by('name')

        # groups people paul follows are in (nobody)
        paul_following_groups = positive_filter(
            group_qs,
            self.paul.relationships.following(),
            'user')
        self.assertQuerysetEqual(paul_following_groups, [])

        # when paul follows john he will see john's groups
        self.paul.relationships.add(self.john, following)
        paul_following_groups = positive_filter(
            group_qs,
            self.paul.relationships.following(),
            'user')
        self.assertQuerysetEqual(paul_following_groups, [beatles, john_yoko])

        # now john's + walrus's
        self.paul.relationships.add(self.walrus, following)
        paul_following_groups = positive_filter(
            group_qs,
            self.paul.relationships.following(),
            'user')
        self.assertQuerysetEqual(paul_following_groups, [beatles, characters, john_yoko])

        # everybody's - distinct groups, no dupes
        self.paul.relationships.add(self.yoko, following)
        paul_following_groups = positive_filter(
            group_qs,
            self.paul.relationships.following(),
            'user')
        self.assertQuerysetEqual(paul_following_groups, [beatles, characters, john_yoko])

        # just groups walrus & yoko are in
        self.paul.relationships.remove(self.john, following)
        paul_following_groups = positive_filter(
            group_qs,
            self.paul.relationships.following(),
            'user')
        self.assertQuerysetEqual(paul_following_groups, [characters, john_yoko])

        # just walrus' groups
        self.paul.relationships.remove(self.yoko)
        paul_following_groups = positive_filter(
            group_qs,
            self.paul.relationships.following(),
            'user')
        self.assertQuerysetEqual(paul_following_groups, [characters])

        self.paul.relationships.remove(self.walrus)

    def test_negative_filter(self):
        blocking = RelationshipStatus.objects.blocking()

        # create some groups to filter
        from django.contrib.auth.models import Group
        beatles = Group.objects.create(name='beatles')
        john_yoko = Group.objects.create(name='john_yoko')
        characters = Group.objects.create(name='characters')

        self.walrus.groups.add(characters)

        self.john.groups.add(beatles)
        self.john.groups.add(john_yoko)

        self.paul.groups.add(beatles)

        self.yoko.groups.add(john_yoko)
        self.yoko.groups.add(characters)

        group_qs = Group.objects.all().order_by('name')

        # groups people paul blocks are *not* in (yoko & walrus)
        # since john is in the john_yoko group, just characters will show up
        paul_blocking_groups = negative_filter(
            group_qs,
            self.paul.relationships.blocking(),
            'user')
        self.assertQuerysetEqual(paul_blocking_groups, [characters])

        # block yoko and no groups
        self.paul.relationships.add(self.yoko, blocking)
        paul_blocking_groups = negative_filter(
            group_qs,
            self.paul.relationships.blocking(),
            'user')
        self.assertQuerysetEqual(paul_blocking_groups, [])

        # block walrus - everyone is blocked, no groups
        self.paul.relationships.add(self.walrus, blocking)
        paul_blocking_groups = negative_filter(
            group_qs,
            self.paul.relationships.blocking(),
            'user')
        self.assertQuerysetEqual(paul_blocking_groups, [])

        # unblock john and we'll get beatles
        self.paul.relationships.remove(self.john, blocking)
        paul_blocking_groups = negative_filter(
            group_qs,
            self.paul.relationships.blocking(),
            'user')
        self.assertQuerysetEqual(paul_blocking_groups, [beatles])

        # unblock yoko
        self.paul.relationships.remove(self.yoko, blocking)
        paul_blocking_groups = negative_filter(
            group_qs,
            self.paul.relationships.blocking(),
            'user')
        self.assertQuerysetEqual(paul_blocking_groups, [beatles, john_yoko])

        # unblock walrus and we have them all
        self.paul.relationships.remove(self.walrus, blocking)
        paul_blocking_groups = negative_filter(
            group_qs,
            self.paul.relationships.blocking(),
            'user')
        self.assertQuerysetEqual(paul_blocking_groups, [beatles, characters, john_yoko])

    def test_relationship_exists(self):
        self.assertTrue(relationship_exists(self.john, self.yoko, 'following'))
        self.assertTrue(relationship_exists(self.john, self.yoko, 'followers'))
        self.assertTrue(relationship_exists(self.john, self.yoko, 'friends'))

        self.assertTrue(relationship_exists(self.yoko, self.john, 'following'))
        self.assertTrue(relationship_exists(self.yoko, self.john, 'followers'))
        self.assertTrue(relationship_exists(self.yoko, self.john, 'friends'))

        self.assertTrue(relationship_exists(self.john, self.paul, 'following'))
        self.assertFalse(relationship_exists(self.john, self.paul, 'followers'))
        self.assertFalse(relationship_exists(self.john, self.paul, 'friends'))

        self.assertFalse(relationship_exists(self.paul, self.john, 'following'))
        self.assertTrue(relationship_exists(self.paul, self.john, 'followers'))
        self.assertFalse(relationship_exists(self.paul, self.john, 'friends'))

        self.assertTrue(relationship_exists(self.paul, self.john, 'blocking'))
        self.assertFalse(relationship_exists(self.paul, self.john, 'blockers'))

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *
from django.contrib import admin
admin.autodiscover()

urlpatterns = patterns('',
    (r'^admin/', include(admin.site.urls)),
    url(r'^relationships/', include('relationships.urls')),
)

########NEW FILE########
__FILENAME__ = relationship_tags
from django import template
from django.core.urlresolvers import reverse
from django.db.models.loading import get_model
from django.template import TemplateSyntaxError
from django.utils.functional import wraps
from relationships.models import RelationshipStatus
from relationships.utils import positive_filter, negative_filter

register = template.Library()


class IfRelationshipNode(template.Node):
    def __init__(self, nodelist_true, nodelist_false, *args):
        self.nodelist_true = nodelist_true
        self.nodelist_false = nodelist_false
        self.from_user, self.to_user, self.status = args
        self.status = self.status.replace('"', '')  # strip quotes

    def render(self, context):
        from_user = template.resolve_variable(self.from_user, context)
        to_user = template.resolve_variable(self.to_user, context)

        if from_user.is_anonymous() or to_user.is_anonymous():
            return self.nodelist_false.render(context)

        try:
            status = RelationshipStatus.objects.by_slug(self.status)
        except RelationshipStatus.DoesNotExist:
            raise template.TemplateSyntaxError('RelationshipStatus not found')

        if status.from_slug == self.status:
            val = from_user.relationships.exists(to_user, status)
        elif status.to_slug == self.status:
            val = to_user.relationships.exists(from_user, status)
        else:
            val = from_user.relationships.exists(to_user, status, symmetrical=True)

        if val:
            return self.nodelist_true.render(context)

        return self.nodelist_false.render(context)


@register.tag
def if_relationship(parser, token):
    """
    Determine if a certain type of relationship exists between two users.
    The ``status`` parameter must be a slug matching either the from_slug,
    to_slug or symmetrical_slug of a RelationshipStatus.

    Example::

        {% if_relationship from_user to_user "friends" %}
            Here are pictures of me drinking alcohol
        {% else %}
            Sorry coworkers
        {% endif_relationship %}

        {% if_relationship from_user to_user "blocking" %}
            damn seo experts
        {% endif_relationship %}
    """
    bits = list(token.split_contents())
    if len(bits) != 4:
        raise TemplateSyntaxError("%r takes 3 arguments:\n%s" % (bits[0], if_relationship.__doc__))
    end_tag = 'end' + bits[0]
    nodelist_true = parser.parse(('else', end_tag))
    token = parser.next_token()
    if token.contents == 'else':
        nodelist_false = parser.parse((end_tag,))
        parser.delete_first_token()
    else:
        nodelist_false = template.NodeList()
    return IfRelationshipNode(nodelist_true, nodelist_false, *bits[1:])


@register.filter
def add_relationship_url(user, status):
    """
    Generate a url for adding a relationship on a given user.  ``user`` is a
    User object, and ``status`` is either a relationship_status object or a
    string denoting a RelationshipStatus

    Usage::

        href="{{ user|add_relationship_url:"following" }}"
    """
    if isinstance(status, RelationshipStatus):
        status = status.from_slug
    return reverse('relationship_add', args=[user.username, status])


@register.filter
def remove_relationship_url(user, status):
    """
    Generate a url for removing a relationship on a given user.  ``user`` is a
    User object, and ``status`` is either a relationship_status object or a
    string denoting a RelationshipStatus

    Usage::

        href="{{ user|remove_relationship_url:"following" }}"
    """
    if isinstance(status, RelationshipStatus):
        status = status.from_slug
    return reverse('relationship_remove', args=[user.username, status])


def positive_filter_decorator(func):
    def inner(qs, user):
        if isinstance(qs, basestring):
            model = get_model(*qs.split('.'))
            if not model:
                return []
            qs = model._default_manager.all()
        if user.is_anonymous():
            return qs.none()
        return func(qs, user)
    inner._decorated_function = getattr(func, '_decorated_function', func)
    return wraps(func)(inner)


def negative_filter_decorator(func):
    def inner(qs, user):
        if isinstance(qs, basestring):
            model = get_model(*qs.split('.'))
            if not model:
                return []
            qs = model._default_manager.all()
        if user.is_anonymous():
            return qs
        return func(qs, user)
    inner._decorated_function = getattr(func, '_decorated_function', func)
    return wraps(func)(inner)


@register.filter
@positive_filter_decorator
def friend_content(qs, user):
    return positive_filter(qs, user.relationships.friends())


@register.filter
@positive_filter_decorator
def following_content(qs, user):
    return positive_filter(qs, user.relationships.following())


@register.filter
@positive_filter_decorator
def followers_content(qs, user):
    return positive_filter(qs, user.relationships.followers())


@register.filter
@negative_filter_decorator
def unblocked_content(qs, user):
    return negative_filter(qs, user.relationships.blocking())

########NEW FILE########
__FILENAME__ = urls
from .compat import patterns, url


urlpatterns = patterns('relationships.views',
    url(r'^$', 'relationship_redirect', name='relationship_list_base'),
    url(r'^(?P<username>[\w.@+-]+)/(?:(?P<status_slug>[\w-]+)/)?$', 'relationship_list', name='relationship_list'),
    url(r'^add/(?P<username>[\w.@+-]+)/(?P<status_slug>[\w-]+)/$', 'relationship_handler', {'add': True}, name='relationship_add'),
    url(r'^remove/(?P<username>[\w.@+-]+)/(?P<status_slug>[\w-]+)/$', 'relationship_handler', {'add': False}, name='relationship_remove'),
)

########NEW FILE########
__FILENAME__ = utils
from .compat import User
from .models import RelationshipStatus


def relationship_exists(from_user, to_user, status_slug='following'):
    status = RelationshipStatus.objects.by_slug(status_slug)
    if status.from_slug == status_slug:
        return from_user.relationships.exists(to_user, status)
    elif status.to_slug == status_slug:
        return to_user.relationships.exists(from_user, status)
    else:
        return from_user.relationships.exists(to_user, status, True)


def extract_user_field(model):
    for field in model._meta.fields + model._meta.many_to_many:
        if field.rel and field.rel.to == User:
            return field.name
    for rel in model._meta.get_all_related_many_to_many_objects():
        if rel.model == User:
            return rel.var_name


def positive_filter(qs, user_qs, user_lookup=None):
    if not user_lookup:
        user_lookup = extract_user_field(qs.model)

    if not user_lookup:
        return qs.none()  # default to returning none

    query = {'%s__in' % user_lookup: user_qs}

    return qs.filter(**query).distinct()


def negative_filter(qs, user_qs, user_lookup=None):
    if not user_lookup:
        user_lookup = extract_user_field(qs.model)

    if not user_lookup:
        return qs  # default to returning all

    query = {'%s__in' % user_lookup: user_qs}

    return qs.exclude(**query).distinct()

########NEW FILE########
__FILENAME__ = views
import json

from django.conf import settings
from django.contrib.auth.decorators import login_required
from django.core.urlresolvers import reverse
from django.http import Http404, HttpResponseRedirect, HttpResponse
from django.shortcuts import render
from django.utils.http import urlquote
from django.views.generic import ListView

from .decorators import require_user
from .models import RelationshipStatus


@login_required
def relationship_redirect(request):
    return HttpResponseRedirect(reverse('relationship_list', args=[request.user.username]))


def _relationship_list(request, queryset, template_name=None, *args, **kwargs):
    return ListView.as_view(
        queryset=queryset,
        template_name=template_name,
        paginate_by=20,
        context_object_name='relationship_list'
    )(request, page=int(request.GET.get('page', 0)), *args, **kwargs)


def get_relationship_status_or_404(status_slug):
    try:
        return RelationshipStatus.objects.by_slug(status_slug)
    except RelationshipStatus.DoesNotExist:
        raise Http404


@require_user
def relationship_list(request, user, status_slug=None,
                      template_name='relationships/relationship_list.html'):
    if not status_slug:
        status = RelationshipStatus.objects.following()
        status_slug = status.from_slug
    else:
        # get the relationship status object we're talking about
        status = get_relationship_status_or_404(status_slug)

    # do some basic authentication
    if status.login_required and not request.user.is_authenticated():
        path = urlquote(request.get_full_path())
        tup = settings.LOGIN_URL, 'next', path
        return HttpResponseRedirect('%s?%s=%s' % tup)

    if status.private and not request.user == user:
        raise Http404

    # get a queryset of users described by this relationship
    if status.from_slug == status_slug:
        qs = user.relationships.get_relationships(status=status)
    elif status.to_slug == status_slug:
        qs = user.relationships.get_related_to(status=status)
    else:
        qs = user.relationships.get_relationships(status=status, symmetrical=True)

    ec = dict(
        from_user=user,
        status=status,
        status_slug=status_slug,
    )

    return _relationship_list(request, qs, template_name, extra_context=ec)


@login_required
@require_user
def relationship_handler(request, user, status_slug, add=True,
                         template_name='relationships/confirm.html',
                         success_template_name='relationships/success.html'):

    status = get_relationship_status_or_404(status_slug)
    is_symm = status_slug == status.symmetrical_slug

    if request.method == 'POST':
        if add:
            request.user.relationships.add(user, status, is_symm)
        else:
            request.user.relationships.remove(user, status, is_symm)

        if request.is_ajax():
            response = {'result': '1'}
            return HttpResponse(json.dumps(response), mimetype="application/json")

        if request.GET.get('next'):
            return HttpResponseRedirect(request.GET['next'])

        template_name = success_template_name

    return render(request,
        template_name,
        {'to_user': user, 'status': status, 'add': add})

########NEW FILE########
__FILENAME__ = runtests
#!/usr/bin/env python
import sys
from os.path import dirname, abspath

import django
from django.conf import settings

if len(sys.argv) > 1 and 'postgres' in sys.argv:
    sys.argv.remove('postgres')
    db_engine = 'django.db.backends.postgresql_psycopg2'
    db_name = 'test_main'
else:
    db_engine = 'django.db.backends.sqlite3'
    db_name = ''

if not settings.configured:
    if django.VERSION < (1, 4):
        tl = (
            'django.template.loaders.filesystem.load_template_source',
            'django.template.loaders.app_directories.load_template_source',
        )
    else:
        tl = (
            'django.template.loaders.filesystem.Loader',
            'django.template.loaders.app_directories.Loader',
        )
    settings.configure(
        DATABASES=dict(default=dict(ENGINE=db_engine, NAME=db_name)),
        SITE_ID=1,
        TEMPLATE_LOADERS=tl,
        MIDDLEWARE_CLASSES=(
            'django.middleware.common.CommonMiddleware',
            'django.contrib.sessions.middleware.SessionMiddleware',
            'django.contrib.auth.middleware.AuthenticationMiddleware',
        ),
        ROOT_URLCONF='relationships.relationships_tests.urls',
        INSTALLED_APPS=[
            'django.contrib.admin',
            'django.contrib.auth',
            'django.contrib.contenttypes',
            'django.contrib.sessions',
            'django.contrib.sites',
            'relationships',
            'relationships.relationships_tests',
        ],
    )

from django.test.utils import get_runner


def runtests(*test_args):
    if not test_args:
        test_args = ['relationships_tests']
    parent = dirname(abspath(__file__))
    sys.path.insert(0, parent)
    TestRunner = get_runner(settings)
    test_runner = TestRunner(verbosity=1, interactive=True)
    failures = test_runner.run_tests(test_args)
    sys.exit(failures)


if __name__ == '__main__':
    runtests(*sys.argv[1:])

########NEW FILE########
