__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# micawber documentation build configuration file, created by
# sphinx-quickstart on Tue Apr 17 13:43:41 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'micawber'
copyright = u'2013, charles leifer'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.3.0'
# The full version, including alpha/beta/rc tags.
release = '0.3.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'nature'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'micawberdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'micawber.tex', u'micawber Documentation',
   u'charles leifer', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'micawber', u'micawber Documentation',
     [u'charles leifer'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'micawber', u'micawber Documentation',
   u'charles leifer', 'micawber', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
from django.core.management import execute_manager
import imp
try:
    imp.find_module('settings') # Assumed to be in the same directory.
except ImportError:
    import sys
    sys.stderr.write("Error: Can't find the file 'settings.py' in the directory containing %r. It appears you've customized things.\nYou'll have to run django-admin.py, passing it your settings module.\n" % __file__)
    sys.exit(1)

import settings

if __name__ == "__main__":
    execute_manager(settings)

########NEW FILE########
__FILENAME__ = settings
import os

#### MICAWBER SETTINGS

# add a template filter called "oembed_no_urlize" that will not automatically
# convert URLs to clickable links in the event a provider is not found for
# the given url
MICAWBER_TEMPLATE_EXTENSIONS = [
    ('oembed_no_urlize', {'urlize_all': False}),
]

# by default, micawber will use the "bootstrap_basic" providers, but should you
# wish to use embedly you can try out the second example.  You can also provide
# your own ProviderRegistry with a path to a module and either a callable or
# ProviderRegistry instance
MICAWBER_PROVIDERS = 'micawber.contrib.mcdjango.providers.bootstrap_basic'
#MICAWBER_PROVIDERS = 'micawber.contrib.mcdjango.providers.bootstrap_embedly'

# if you are using embed.ly you can specify an API key that will be used with
# the bootstrap_embedly provider setting
# MICAWBER_EMBEDLY_KEY = 'foofoo'

# since template filters are limited to a single optional parameter, you can
# specify defaults, such as a maxwidth you prefer to use or an api key
#MICAWBER_DEFAULT_SETTINGS = {
#    'key': 'your-embedly-api-key',
#    'maxwidth': 600,
#    'maxheight': 600,
#}

#### END MICAWBER SETTINGS

CURRENT_DIR = os.path.dirname(__file__)

DEBUG = True
TEMPLATE_DEBUG = DEBUG

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': 'django_ex.db',
    }
}

SITE_ID = 1

SECRET_KEY = 'fapfapfap'

STATIC_URL = '/static/'
STATICFILES_DIRS = (
    os.path.join(CURRENT_DIR, 'static'),
)

STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
)


TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
)

ROOT_URLCONF = 'django_ex.urls'

TEMPLATE_DIRS = (
    os.path.join(CURRENT_DIR, 'templates'),
)

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.staticfiles',
    'micawber.contrib.mcdjango',
)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import patterns, include, url

urlpatterns = patterns('',
    url(r'^$', 'django_ex.views.example_view', name='example_view'),
)

########NEW FILE########
__FILENAME__ = views
from django.shortcuts import render_to_response

def example_view(request):
    text = request.GET.get('text', 'http://www.youtube.com/watch?v=nda_OSWeyn8')
    html = request.GET.get('html', """
<p>This is a test</p>
<p>http://www.youtube.com/watch?v=nda_OSWeyn8</p>
<p>This will get rendered as a link: http://www.youtube.com/watch?v=nda_OSWeyn8</p>
<p>This will not be modified: <a href="http://www.google.com/">http://www.youtube.com/watch?v=nda_OSWeyn8</a></p>
    """)
    return render_to_response('example.html', dict(
        text=text,
        html=html,
    ))

########NEW FILE########
__FILENAME__ = app
from flask import Flask, render_template, request
from micawber.providers import bootstrap_basic
from micawber.contrib.mcflask import add_oembed_filters

app = Flask(__name__)
app.config['DEBUG'] = True

oembed_providers = bootstrap_basic()
add_oembed_filters(app, oembed_providers)

@app.route('/')
def example_view():
    text = request.args.get('text', 'http://www.youtube.com/watch?v=nda_OSWeyn8')
    html = request.args.get('html', """
<p>This is a test</p>
<p>http://www.youtube.com/watch?v=nda_OSWeyn8</p>
<p>This will get rendered as a link: http://www.youtube.com/watch?v=nda_OSWeyn8</p>
<p>This will not be modified: <a href="http://www.google.com/">http://www.youtube.com/watch?v=nda_OSWeyn8</a></p>
    """)
    return render_template('example.html', text=text, html=html)

if __name__ == '__main__':
    app.run()

########NEW FILE########
__FILENAME__ = example
import pprint
from micawber import bootstrap_embedly, ProviderException

def main():
    print 'Please wait, loading providers from embed.ly'
    providers = bootstrap_embedly()

    while 1:
        url = raw_input('Enter a url (or q to quit): ')
        if url.lower().strip() == 'q':
            break

        try:
            result = providers.request(url)
        except ProviderException:
            print 'No provider found for that url :/'
        else:
            print 'Data for %s\n====================================================' % url
            pprint.pprint(result)

if __name__ == '__main__':
    print 'Welcome to the example!'
    main()

########NEW FILE########
__FILENAME__ = cache
from __future__ import with_statement
import os
import pickle
from contextlib import closing
try:
    from redis import Redis
except ImportError:
    Redis = None


class Cache(object):
    def __init__(self):
        self._cache = {}

    def get(self, k):
        return self._cache.get(k)

    def set(self, k, v):
        self._cache[k] = v


class PickleCache(Cache):
    def __init__(self, filename='cache.db'):
        self.filename = filename
        self._cache = self.load()
    
    def load(self):
        if os.path.exists(self.filename):
            with closing(open(self.filename)) as fh:
                contents = fh.read()
            return pickle.loads(contents)
        return {}

    def save(self):
        with closing(open(self.filename, 'w')) as fh:
            fh.write(pickle.dumps(self._cache))


if Redis:
    class RedisCache(Cache):
        def __init__(self, namespace='micawber', **conn):
            self.namespace = namespace
            self.key_fn = lambda self, k: '%s.%s' % (self.namespace, k)
            self.conn = Redis(**conn)
        
        def get(self, k):
            cached = self.conn.get(self.key_fn(k))
            if cached:
                return pickle.loads(cached)
        
        def set(self, k, v):
            self.conn.set(self.key_fn(k), pickle.dumps(v))

########NEW FILE########
__FILENAME__ = compat
import sys

PY3 = sys.version_info >= (3,)

if PY3:
    from urllib.request import Request, urlopen, URLError, HTTPError
    from urllib.parse import urlencode
    text_type = str
    string_types = str,
    def get_charset(response):
        return response.headers.get_param('charset')
else:
    from urllib2 import Request, urlopen, URLError, HTTPError
    from urllib import urlencode
    text_type = unicode
    string_types = basestring,
    def get_charset(response):
        return response.headers.getparam('charset')

########NEW FILE########
__FILENAME__ = models

########NEW FILE########
__FILENAME__ = tests
from django.template import Context
from django.template import Template
from django.test import TestCase

from micawber.parsers import parse_text
from micawber.test_utils import BaseTestCase
from micawber.test_utils import test_cache
from micawber.test_utils import test_pr
from micawber.test_utils import test_pr_cache
from micawber.test_utils import TestProvider


class MicawberDjangoTestCase(TestCase, BaseTestCase):
    def render(self, s, **params):
        s = '{%% load micawber_tags %%}%s' % s
        return Template(s).render(Context(params)).strip()

    def test_oembed_alt(self):
        from micawber.contrib.mcdjango import extension

        def custom_handler(url, response_data):
            return url

        oembed_alt = extension(
            'oembed_alt',
            urlize_all=False,
            block_handler=custom_handler)

        text = '\n'.join((
            'this is the first line',
            'http://photo-test2',
            'this is the third line http://photo-test2',
            'http://photo-test2 this is the fourth line'))
        rendered = self.render('{{ text|oembed_alt }}', text=text)
        self.assertEqual(rendered.splitlines(), [
            'this is the first line',
            self.full_pairs['http://photo-test2'],
            'this is the third line http://photo-test2',
            'http://photo-test2 this is the fourth line',
        ])

    def test_fix_wh(self):
        from micawber.contrib.mcdjango import fix_width_height
        self.assertEqual(fix_width_height('300x400', {}), {'maxwidth': 300, 'maxheight': 400})
        self.assertEqual(fix_width_height('300', {}), {'maxwidth': 300})

    def test_provider_loading(self):
        from micawber.contrib.mcdjango import providers
        self.assertEqual(providers, test_pr)

    def test_oembed_filter_multiline_plain(self):
        for url, expected in self.full_pairs.items():
            expected_inline = self.inline_pairs[url]
            frame = 'this is inline: %s\n%s\nand yet another %s'

            test_str = frame % (url, url, url)

            parsed = self.render('{{ test_str|oembed }}', test_str=test_str)
            self.assertEqual(parsed, frame % (expected_inline, expected, expected_inline))

    def test_oembed_filter_multiline_html(self):
        for url, expected in self.full_pairs.items():
            expected_inline = self.inline_pairs[url]
            frame = '<p>%s</p>\n<p>this is inline: %s</p>\n<p>\n%s\n</p><p>last test\n%s\n</p>'

            test_str = frame % (url, url, url, url)

            parsed = self.render('{{ test_str|oembed_html }}', test_str=test_str)
            self.assertHTMLEqual(parsed, frame % (expected, expected_inline, expected, expected_inline))

        for url, expected in self.full_pairs.items():
            expected_inline = self.inline_pairs[url]
            frame = '<p><a href="#foo">%s</a></p>\n<p>this is inline: %s</p>\n<p>last test\n%s\n</p>'

            test_str = frame % (url, url, url)

            parsed = self.render('{{ test_str|oembed_html }}', test_str=test_str)
            self.assertHTMLEqual(parsed, frame % (url, expected_inline, expected_inline))

    def test_urlize(self):
        u1 = 'http://fappio.com/'
        u2 = 'http://google.com/fap/'
        u1h = '<a href="%s">%s</a>' % (u1, u1)
        u2h = '<a href="%s">%s</a>' % (u2, u2)
        for url, expected in self.full_pairs.items():
            expected_inline = self.inline_pairs[url]
            frame = 'test %s\n%s\n%s\nand another %s'

            test_str = frame % (u1, u2, url, url)

            parsed = self.render('{{ test_str|oembed }}', test_str=test_str)
            self.assertEqual(parsed, frame % (u1h, u2h, expected, expected_inline))

    def test_oembed_filter_extension(self):
        for url, expected in self.full_pairs.items():
            expected_inline = self.inline_pairs[url]
            frame = 'test http://fappio.com\nhttp://google.com\n%s\nand another %s'

            test_str = frame % (url, url)

            parsed = self.render('{{ test_str|oembed_no_urlize }}', test_str=test_str)
            self.assertEqual(parsed, frame % (expected, expected_inline))

    def test_extract_filter(self):
        blank = 'http://fapp.io/foo/'
        frame = 'test %s\n%s\n%s\n%s at last'
        frame_html = '<p>test %s</p><p><a href="foo">%s</a> %s</p><p>%s</p>'

        t = """{% for url, data in test_str|extract_oembed %}{{ url }}\n{% endfor %}"""
        t2 = """{% for url, data in test_str|extract_oembed_html %}{{ url }}\n{% endfor %}"""

        for url, expected in self.data_pairs.items():
            test_str = frame % (url, blank, url, blank)
            rendered = self.render(t, test_str=test_str)
            self.assertEqual(rendered, url)

            test_str = frame_html % (url, blank, url, blank)
            rendered = self.render(t, test_str=test_str)
            self.assertEqual(rendered, url)

########NEW FILE########
__FILENAME__ = models

########NEW FILE########
__FILENAME__ = providers
from django.conf import settings
from django.core.cache import cache

from micawber.providers import bootstrap_basic as _bootstrap_basic, bootstrap_embedly as _bootstrap_embedly


def bootstrap_basic():
    return _bootstrap_basic(cache)

def bootstrap_embedly():
    key = getattr(settings, 'MICAWBER_EMBEDLY_KEY', None)
    params = {}
    if key:
        params['key'] = key
    return _bootstrap_embedly(cache, **params)

########NEW FILE########
__FILENAME__ = micawber_tags
from micawber.contrib.mcdjango import register

########NEW FILE########
__FILENAME__ = mcflask
from flask import Markup
from micawber import parse_text, parse_html, extract, extract_html


def oembed(s, providers, urlize_all=True, html=False, **params):
    if html:
        fn = parse_html
    else:
        fn = parse_text
    return Markup(fn(s, providers, urlize_all, **params))

def extract_oembed(s, providers, html=False, **params):
    if html:
        fn = extract_html
    else:
        fn = extract
    return fn(s, providers, **params)

def add_oembed_filters(app, providers):
    def _oembed(s, urlize_all=True, html=False, **params):
        return oembed(s, providers, urlize_all, html, **params)

    def _extract_oembed(s, html=False, **params):
        return extract_oembed(s, providers, html, **params)

    app.jinja_env.filters['oembed'] = _oembed
    app.jinja_env.filters['extract_oembed'] = _extract_oembed

########NEW FILE########
__FILENAME__ = providers
import re

from micawber.providers import Provider


class ImageProvider(Provider):
    """
    Simple little hack to render any image URL as an <img> tag, use with care

    Usage:

    pr = micawber.bootstrap_basic()
    pr.register(ImageProvider.regex, ImageProvider(''))
    """
    regex = 'http://.+?\.(jpg|gif|png)'

    def request(self, url, **params):
        return {
            'url': url,
            'type': 'photo',
            'title': '',
        }


class GoogleMapsProvider(Provider):
    """
    Render a map URL as an embedded map

    Usage:

    pr = micawber.bootstrap_basic()
    pr.register(GoogleMapsProvider.regex, GoogleMapsProvider(''))
    """
    regex = r'^https?://maps.google.com/maps\?([^\s]+)'
    
    valid_params = ['q', 'z']
    
    def request(self, url, **params):
        url_params = re.match(self.regex, url).groups()[0]
        url_params = url_params.replace('&amp;', '&').split('&')
        
        map_params = ['output=embed']
        
        for param in url_params:
            k, v = param.split('=', 1)
            if k in self.valid_params:
                map_params.append(param)
        
        width = int(params.get('maxwidth', 640))
        height = int(params.get('maxheight', 480))
        html = '<iframe width="%d" height="%d" frameborder="0" scrolling="no" marginheight="0" marginwidth="0" src="http://maps.google.com/maps?%s"></iframe>' % \
            (width, height, '&amp;'.join(map_params))
        
        return {
            'height': height,
            'html': html,
            'provider_name': 'Google maps',
            'title': '',
            'type': 'rich',
            'version': '1.0',
            'width': width,
        }

########NEW FILE########
__FILENAME__ = exceptions
class ProviderException(Exception):
    pass

class ProviderNotFoundException(ProviderException):
    pass

########NEW FILE########
__FILENAME__ = parsers
import re
from .compat import text_type
try:
    import simplejson as json
except ImportError:
    import json
try:
    from BeautifulSoup import BeautifulSoup
    bs_kwargs = {'convertEntities': BeautifulSoup.HTML_ENTITIES}
except ImportError:
    try:
        from bs4 import BeautifulSoup
        bs_kwargs = {} # BS4 converts entities by default
    except ImportError:
        BeautifulSoup = None

from micawber.exceptions import ProviderException


url_pattern = '(https?://[-A-Za-z0-9+&@#/%?=~_()|!:,.;]*[-A-Za-z0-9+&@#/%=~_|])'
url_re = re.compile(url_pattern)
standalone_url_re = re.compile('^\s*' + url_pattern + '\s*$')

block_elements = set([
    'address', 'blockquote', 'center', 'dir', 'div', 'dl', 'fieldset', 'form',
    'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'isindex', 'menu', 'noframes',
    'noscript', 'ol', 'p', 'pre', 'table', 'ul', 'dd', 'dt', 'frameset', 'li',
    'tbody', 'td', 'tfoot', 'th', 'thead', 'tr', 'button', 'del', 'iframe',
    'ins', 'map', 'object', 'script', '[document]'
])

skip_elements = set(['a', 'pre', 'code'])


def full_handler(url, response_data, **params):
    if response_data['type'] == 'link':
        return '<a href="%(url)s" title="%(title)s">%(title)s</a>' % response_data
    elif response_data['type'] == 'photo':
        return '<a href="%(url)s" title="%(title)s"><img alt="%(title)s" src="%(url)s" /></a>' % response_data
    else:
        return response_data['html']

def inline_handler(url, response_data, **params):
    return '<a href="%(url)s" title="%(title)s">%(title)s</a>' % response_data

def urlize(url):
    return '<a href="%s">%s</a>' % (url, url)

def extract(text, providers, **params):
    all_urls = set()
    urls = []
    extracted_urls = {}

    for url in re.findall(url_re, text):
        if url in all_urls:
            continue

        all_urls.add(url)
        urls.append(url)
        try:
            extracted_urls[url] = providers.request(url, **params)
        except ProviderException:
            pass

    return urls, extracted_urls

def parse_text_full(text, providers, urlize_all=True, handler=full_handler, **params):
    all_urls, extracted_urls = extract(text, providers, **params)
    replacements = {}

    for url in all_urls:
        if url in extracted_urls:
            replacements[url] = handler(url, extracted_urls[url], **params)
        elif urlize_all:
            replacements[url] = urlize(url)

    # go through the text recording URLs that can be replaced
    # taking note of their start & end indexes
    urls = re.finditer(url_re, text)
    matches = []
    for match in urls:
        if match.group() in replacements:
            matches.append([match.start(), match.end(), match.group()])

    # replace the URLs in order, offsetting the indices each go
    for indx, (start, end, url) in enumerate(matches):
        replacement = replacements[url]
        difference = len(replacement) - len(url)

        # insert the replacement between two slices of text surrounding the
        # original url
        text = text[:start] + replacement + text[end:]

        # iterate through the rest of the matches offsetting their indices
        # based on the difference between replacement/original
        for j in range(indx + 1, len(matches)):
            matches[j][0] += difference
            matches[j][1] += difference

    return text

def parse_text(text, providers, urlize_all=True, handler=full_handler, block_handler=inline_handler, **params):
    lines = text.splitlines()
    parsed = []

    for line in lines:
        if standalone_url_re.match(line):
            url = line.strip()
            try:
                response = providers.request(url, **params)
            except ProviderException:
                if urlize_all:
                    line = urlize(url)
            else:
                line = handler(url, response, **params)
        else:
            line = parse_text_full(line, providers, urlize_all, block_handler, **params)

        parsed.append(line)

    return '\n'.join(parsed)

def parse_html(html, providers, urlize_all=True, handler=full_handler, block_handler=inline_handler, **params):
    if not BeautifulSoup:
        raise Exception('Unable to parse HTML, please install BeautifulSoup or use the text parser')

    soup = BeautifulSoup(html, **bs_kwargs)

    for url in soup.findAll(text=re.compile(url_re)):
        if not _inside_skip(url):
            if _is_standalone(url):
                url_handler = handler
            else:
                url_handler = block_handler

            url_unescaped = url.string
            replacement = parse_text_full(url_unescaped, providers, urlize_all, url_handler, **params)
            url.replaceWith(BeautifulSoup(replacement))

    return text_type(soup)

def extract_html(html, providers, **params):
    if not BeautifulSoup:
        raise Exception('Unable to parse HTML, please install BeautifulSoup or use the text parser')

    soup = BeautifulSoup(html, **bs_kwargs)
    all_urls = set()
    urls = []
    extracted_urls = {}

    for url in soup.findAll(text=re.compile(url_re)):
        if _inside_skip(url):
            continue

        block_all, block_ext = extract(text_type(url), providers, **params)
        for extracted_url in block_all:
            if extracted_url in all_urls:
                continue

            extracted_urls.update(block_ext)
            urls.append(extracted_url)
            all_urls.add(extracted_url)

    return urls, extracted_urls

def _is_standalone(soup_elem):
    if standalone_url_re.match(soup_elem):
        return soup_elem.parent.name in block_elements
    return False

def _inside_skip(soup_elem):
    parent = soup_elem.parent
    while parent is not None:
        if parent.name in skip_elements:
            return True
        parent = parent.parent
    return False

########NEW FILE########
__FILENAME__ = providers
import hashlib
import pickle
import re
import socket
from .compat import urlencode, Request, urlopen, URLError, HTTPError, get_charset
try:
    import simplejson as json
except ImportError:
    import json

from micawber.exceptions import ProviderException, ProviderNotFoundException


class Provider(object):
    socket_timeout = 3.0
    user_agent = 'python-micawber'

    def __init__(self, endpoint, **kwargs):
        self.endpoint = endpoint
        self.base_params = {'format': 'json'}
        self.base_params.update(kwargs)

    def fetch(self, url):
        socket.setdefaulttimeout(self.socket_timeout)
        req = Request(url, headers={'User-Agent': self.user_agent})
        try:
            resp = fetch(req)
        except URLError:
            return False
        except HTTPError:
            return False
        except socket.timeout:
            return False
        return resp

    def encode_params(self, url, **extra_params):
        params = dict(self.base_params)
        params.update(extra_params)
        params['url'] = url
        return urlencode(sorted(params.items()))

    def request(self, url, **extra_params):
        encoded_params = self.encode_params(url, **extra_params)

        endpoint_url = self.endpoint
        if '?' in endpoint_url:
            endpoint_url = '%s&%s' % (endpoint_url.rstrip('&'), encoded_params)
        else:
            endpoint_url = '%s?%s' % (endpoint_url, encoded_params)

        response = self.fetch(endpoint_url)
        if response:
            return self.handle_response(response, url)
        else:
            raise ProviderException('Error fetching "%s"' % endpoint_url)

    def handle_response(self, response, url):
        json_data = json.loads(response)
        if 'url' not in json_data:
            json_data['url'] = url
        if 'title' not in json_data:
            json_data['title'] = json_data['url']
        return json_data


def make_key(*args, **kwargs):
    return hashlib.md5(pickle.dumps((args, kwargs))).hexdigest()


def url_cache(fn):
    def inner(self, url, **params):
        if self.cache:
            key = make_key(url, params)
            data = self.cache.get(key)
            if not data:
                data = fn(self, url, **params)
                self.cache.set(key, data)
            return data
        return fn(self, url, **params)
    return inner


def fetch(request):
    resp = urlopen(request)
    if resp.code < 200 or resp.code >= 300:
        return False

    # by RFC, default HTTP charset is ISO-8859-1
    charset = get_charset(resp) or 'iso-8859-1'

    content = resp.read().decode(charset)
    resp.close()
    return content


class ProviderRegistry(object):
    def __init__(self, cache=None):
        self._registry = {}
        self.cache = cache

    def register(self, regex, provider):
        self._registry[regex] = provider

    def unregister(self, regex):
        del(self._registry[regex])

    def __iter__(self):
        return iter(self._registry.items())

    def provider_for_url(self, url):
        for regex, provider in self:
            if re.match(regex, url):
                return provider

    @url_cache
    def request(self, url, **params):
        provider = self.provider_for_url(url)
        if provider:
            return provider.request(url, **params)
        raise ProviderNotFoundException('Provider not found for "%s"' % url)


def bootstrap_basic(cache=None):
    # complements of oembed.com#section7
    pr = ProviderRegistry(cache)

    # b
    pr.register('http://blip.tv/\S+', Provider('http://blip.tv/oembed'))

    # c
    pr.register('http://chirb.it/\S+', Provider('http://chirb.it/oembed.json'))
    pr.register('https://www.circuitlab.com/circuit/\S+', Provider('https://www.circuitlab.com/circuit/oembed'))
    pr.register('http://www.collegehumor.com/video/\S+', Provider('http://www.collegehumor.com/oembed.json'))

    # d
    pr.register('https?://(www\.)?dailymotion\.com/\S+', Provider('http://www.dailymotion.com/services/oembed'))

    # f
    pr.register('http://\S*?flickr.com/\S+', Provider('http://www.flickr.com/services/oembed/'))
    pr.register('http://flic\.kr/\S*', Provider('http://www.flickr.com/services/oembed/'))
    pr.register('https?://(www\.)?funnyordie\.com/videos/\S+', Provider('http://www.funnyordie.com/oembed'))

    # g
    pr.register(r'https?://gist.github.com/\S*', Provider('https://github.com/api/oembed'))

    # h
    pr.register('http://www.hulu.com/watch/\S+', Provider('http://www.hulu.com/api/oembed.json'))

    # i
    pr.register('http://www.ifixit.com/Guide/View/\S+', Provider('http://www.ifixit.com/Embed'))
    pr.register('http://\S*imgur\.com/\S+', Provider('http://api.imgur.com/oembed')),
    pr.register('http://instagr(\.am|am\.com)/p/\S+', Provider('http://api.instagram.com/oembed'))

    # j
    pr.register('http://www.jest.com/(video|embed)/\S+', Provider('http://www.jest.com/oembed.json'))

    # m
    pr.register('http://www.mobypicture.com/user/\S*?/view/\S*', Provider('http://api.mobypicture.com/oEmbed'))
    pr.register('http://moby.to/\S*', Provider('http://api.mobypicture.com/oEmbed'))

    # p
    pr.register('http://i\S*.photobucket.com/albums/\S+', Provider('http://photobucket.com/oembed'))
    pr.register('http://gi\S*.photobucket.com/groups/\S+', Provider('http://photobucket.com/oembed'))
    pr.register('http://www.polleverywhere.com/(polls|multiple_choice_polls|free_text_polls)/\S+', Provider('http://www.polleverywhere.com/services/oembed/'))
    pr.register('https?://(.+\.)?polldaddy\.com/\S*', Provider('http://polldaddy.com/oembed/'))

    # q
    pr.register('http://qik.com/video/\S+', Provider('http://qik.com/api/oembed.json'))

    # r
    pr.register('http://\S*.revision3.com/\S+', Provider('http://revision3.com/api/oembed/'))

    # s
    pr.register('http://www.slideshare.net/[^\/]+/\S+', Provider('http://www.slideshare.net/api/oembed/2'))
    pr.register('http://slidesha\.re/\S*', Provider('http://www.slideshare.net/api/oembed/2'))
    pr.register('http://\S*.smugmug.com/\S*', Provider('http://api.smugmug.com/services/oembed/'))
    pr.register('https://\S*?soundcloud.com/\S+', Provider('http://soundcloud.com/oembed'))
    pr.register('https?://speakerdeck\.com/\S*', Provider('https://speakerdeck.com/oembed.json')),
    pr.register('https?://(www\.)?scribd\.com/\S*', Provider('http://www.scribd.com/services/oembed'))

    # t
    pr.register('https?://(www\.)?twitter.com/\S+/status(es)?/\S+', Provider('https://api.twitter.com/1/statuses/oembed.json'))

    # v
    pr.register('http://\S*.viddler.com/\S*', Provider('http://lab.viddler.com/services/oembed/'))
    pr.register('http://vimeo.com/\S+', Provider('http://vimeo.com/api/oembed.json'))
    pr.register('https://vimeo.com/\S+', Provider('https://vimeo.com/api/oembed.json'))

    # y
    pr.register('http://(\S*.)?youtu(\.be/|be\.com/watch)\S+', Provider('http://www.youtube.com/oembed'))
    pr.register('https://(\S*.)?youtu(\.be/|be\.com/watch)\S+', Provider('http://www.youtube.com/oembed?scheme=https&'))
    pr.register('http://(\S*\.)?yfrog\.com/\S*', Provider('http://www.yfrog.com/api/oembed'))

    # w
    pr.register('http://\S+.wordpress.com/\S+', Provider('http://public-api.wordpress.com/oembed/'))
    pr.register('https?://wordpress.tv/\S+', Provider('http://wordpress.tv/oembed/'))

    return pr


def bootstrap_embedly(cache=None, **params):
    endpoint = 'http://api.embed.ly/1/oembed'
    schema_url = 'http://api.embed.ly/1/services/python'

    pr = ProviderRegistry(cache)

    # fetch the schema
    contents = fetch(schema_url)
    json_data = json.loads(contents)

    for provider_meta in json_data:
        for regex in provider_meta['regex']:
            pr.register(regex, Provider(endpoint, **params))
    return pr


def bootstrap_noembed(cache=None, **params):
    endpoint = 'http://noembed.com/embed'
    schema_url = 'http://noembed.com/providers'

    pr = ProviderRegistry(cache)

    # fetch the schema
    contents = fetch(schema_url)
    json_data = json.loads(contents)

    for provider_meta in json_data:
        for regex in provider_meta['patterns']:
            pr.register(regex, Provider(endpoint, **params))
    return pr


def bootstrap_oembedio(cache=None, **params):
    endpoint = 'http://oembed.io/api'
    schema_url = 'http://oembed.io/providers'

    pr = ProviderRegistry(cache)

    # fetch the schema
    contents = fetch(schema_url)
    json_data = json.loads(contents)

    for provider_meta in json_data:
        pr.register(provider_meta['s'], Provider(endpoint, **params))
    return pr

########NEW FILE########
__FILENAME__ = tests
from micawber import *
from micawber.test_utils import test_pr, test_cache, test_pr_cache, TestProvider, BaseTestCase


class ProviderTestCase(BaseTestCase):
    def test_provider_matching(self):
        provider = test_pr.provider_for_url('http://link-test1')
        self.assertFalse(provider is None)
        self.assertEqual(provider.endpoint, 'link')

        provider = test_pr.provider_for_url('http://photo-test1')
        self.assertFalse(provider is None)
        self.assertEqual(provider.endpoint, 'photo')

        provider = test_pr.provider_for_url('http://video-test1')
        self.assertFalse(provider is None)
        self.assertEqual(provider.endpoint, 'video')

        provider = test_pr.provider_for_url('http://rich-test1')
        self.assertFalse(provider is None)
        self.assertEqual(provider.endpoint, 'rich')

        provider = test_pr.provider_for_url('http://none-test1')
        self.assertTrue(provider is None)

    def test_provider(self):
        resp = test_pr.request('http://link-test1')
        self.assertEqual(resp, {'title': 'test1', 'type': 'link', 'url': 'http://link-test1'})

        resp = test_pr.request('http://photo-test2')
        self.assertEqual(resp, {'title': 'ptest2', 'type': 'photo', 'url': 'test2.jpg'})

        resp = test_pr.request('http://video-test1')
        self.assertEqual(resp, {'title': 'vtest1', 'type': 'video', 'html': '<test1>video</test1>', 'url': 'http://video-test1'})

        resp = test_pr.request('http://link-test1', width=100)
        self.assertEqual(resp, {'title': 'test1', 'type': 'link', 'url': 'http://link-test1', 'width': 99})

        self.assertRaises(ProviderException, test_pr.request, 'http://not-here')
        self.assertRaises(ProviderException, test_pr.request, 'http://link-test3')

    def test_caching(self):
        resp = test_pr_cache.request('http://link-test1')
        self.assertCached('http://link-test1', resp)

        # check that its the same as what we tested in the previous case
        resp2 = test_pr.request('http://link-test1')
        self.assertEqual(resp, resp2)

        resp = test_pr_cache.request('http://photo-test2')
        self.assertCached('http://photo-test2', resp)

        resp = test_pr_cache.request('http://video-test1')
        self.assertCached('http://video-test1', resp)

        self.assertEqual(len(test_cache._cache), 3)

    def test_caching_params(self):
        resp = test_pr_cache.request('http://link-test1')
        self.assertCached('http://link-test1', resp)

        resp_p = test_pr_cache.request('http://link-test1', width=100)
        self.assertCached('http://link-test1', resp_p, width=100)

        self.assertFalse(resp == resp_p)


class ParserTestCase(BaseTestCase):
    def test_parse_text_full(self):
        for url, expected in self.full_pairs.items():
            parsed = parse_text_full(url, test_pr)
            self.assertHTMLEqual(parsed, expected)

        # the parse_text_full will replace even inline content
        for url, expected in self.full_pairs.items():
            parsed = parse_text_full('this is inline: %s' % url, test_pr)
            self.assertHTMLEqual(parsed, 'this is inline: %s' % expected)

        for url, expected in self.full_pairs.items():
            parsed = parse_html('<p>%s</p>' % url, test_pr)
            self.assertHTMLEqual(parsed, '<p>%s</p>' % expected)

    def test_parse_text(self):
        for url, expected in self.inline_pairs.items():
            parsed = parse_text('this is inline: %s' % url, test_pr)
            self.assertHTMLEqual(parsed, 'this is inline: %s' % expected)

        # if the link comes on its own line it gets included in full
        for url, expected in self.full_pairs.items():
            parsed = parse_text(url, test_pr)
            self.assertHTMLEqual(parsed, expected)

        # links inside block tags will render as inline
        frame = '<p>Testing %s</p>'
        for url, expected in self.inline_pairs.items():
            parsed = parse_html(frame % (url), test_pr)
            self.assertHTMLEqual(parsed, frame % (expected))

        # links inside <a> tags won't change at all
        frame = '<p><a href="%s">%s</a></p>'
        for url, expected in self.inline_pairs.items():
            parsed = parse_html(frame % (url, url), test_pr)
            self.assertHTMLEqual(parsed, frame % (url, url))

        # links within tags within a tags are fine too
        frame = '<p><a href="%s"><span>%s</span></a></p>'
        for url, expected in self.inline_pairs.items():
            parsed = parse_html(frame % (url, url), test_pr)
            self.assertHTMLEqual(parsed, frame % (url, url))

    def test_multiline(self):
        for url, expected in self.full_pairs.items():
            expected_inline = self.inline_pairs[url]
            frame = 'this is inline: %s\n%s\nand yet another %s'

            test_str = frame % (url, url, url)

            parsed = parse_text(test_str, test_pr)
            self.assertHTMLEqual(parsed, frame % (expected_inline, expected, expected_inline))

        for url, expected in self.full_pairs.items():
            expected_inline = self.inline_pairs[url]
            frame = '%s\nthis is inline: %s\n%s'

            test_str = frame % (url, url, url)

            parsed = parse_text(test_str, test_pr)
            self.assertHTMLEqual(parsed, frame % (expected, expected_inline, expected))

        # test mixing multiline with p tags
        for url, expected in self.full_pairs.items():
            expected_inline = self.inline_pairs[url]
            frame = '<p>%s</p>\n<p>this is inline: %s</p>\n<p>\n%s\n</p><p>last test\n%s\n</p>'

            test_str = frame % (url, url, url, url)

            parsed = parse_html(test_str, test_pr)
            self.assertHTMLEqual(parsed, frame % (expected, expected_inline, expected, expected_inline))

        for url, expected in self.full_pairs.items():
            expected_inline = self.inline_pairs[url]
            frame = '<p><a href="#foo">%s</a></p>\n<p>this is inline: %s</p>\n<p>last test\n%s\n</p>'

            test_str = frame % (url, url, url)

            parsed = parse_html(test_str, test_pr)
            self.assertHTMLEqual(parsed, frame % (url, expected_inline, expected_inline))

    def test_multiline_full(self):
        for url, expected in self.full_pairs.items():
            frame = 'this is inline: %s\n%s\nand yet another %s'

            test_str = frame % (url, url, url)

            parsed = parse_text_full(test_str, test_pr)
            self.assertHTMLEqual(parsed, frame % (expected, expected, expected))

    def test_urlize(self):
        blank = 'http://fapp.io/foo/'
        blank_e = '<a href="http://fapp.io/foo/">http://fapp.io/foo/</a>'
        for url, expected in self.full_pairs.items():
            expected_inline = self.inline_pairs[url]
            frame = 'test %s\n%s\n%s\nand finally %s'

            test_str = frame % (url, blank, url, blank)

            parsed = parse_text(test_str, test_pr)
            self.assertHTMLEqual(parsed, frame % (expected_inline, blank_e, expected, blank_e))

            parsed = parse_text(test_str, test_pr, urlize_all=False)
            self.assertHTMLEqual(parsed, frame % (expected_inline, blank, expected, blank))

            parsed = parse_text_full(test_str, test_pr)
            self.assertHTMLEqual(parsed, frame % (expected, blank_e, expected, blank_e))

            parsed = parse_text_full(test_str, test_pr, urlize_all=False)
            self.assertHTMLEqual(parsed, frame % (expected, blank, expected, blank))

            parsed = parse_html(test_str, test_pr)
            self.assertHTMLEqual(parsed, frame % (expected_inline, blank_e, expected_inline, blank_e))

            parsed = parse_html(test_str, test_pr, urlize_all=False)
            self.assertHTMLEqual(parsed, frame % (expected_inline, blank, expected_inline, blank))

            frame = '<p>test %s</p>\n<a href="foo">%s</a>\n<a href="foo2">%s</a>\n<p>and finally %s</p>'

            test_str = frame % (url, blank, url, blank)

            parsed = parse_html(test_str, test_pr)
            self.assertHTMLEqual(parsed, frame % (expected_inline, blank, url, blank_e))

            parsed = parse_html(test_str, test_pr, urlize_all=False)
            self.assertHTMLEqual(parsed, frame % (expected_inline, blank, url, blank))

    def test_extract(self):
        blank = 'http://fapp.io/foo/'
        frame = 'test %s\n%s\n%s\n%s at last'
        frame_html = '<p>test %s</p><p><a href="foo">%s</a> %s</p><p>%s</p>'

        for url, expected in self.data_pairs.items():
            all_urls, extracted = extract(frame % (url, blank, url, blank), test_pr)
            self.assertEqual(all_urls, [url, blank])

            if 'url' not in expected:
                expected['url'] = url
            if 'title' not in expected:
                expected['title'] = expected['url']
            self.assertEqual(extracted, {url: expected})

            all_urls, extracted = extract_html(frame_html % (url, url, blank, blank), test_pr)
            self.assertEqual(all_urls, [url, blank])

            if 'url' not in expected:
                expected['url'] = url
            self.assertEqual(extracted, {url: expected})

    def test_outside_of_markup(self):
        frame = '%s<p>testing</p>'
        for url, expected in self.full_pairs.items():
            parsed = parse_html(frame % (url), test_pr)
            self.assertHTMLEqual(parsed, frame % (expected))

    def test_html_entities(self):
        frame_html = '<p>test %s</p><p><a href="foo">%s</a></p>'

        for url, expected in self.data_pairs.items():
            esc_url = url.replace('&', '&amp;')
            all_urls, extracted = extract_html(frame_html % (esc_url, esc_url), test_pr)
            self.assertEqual(all_urls, [url])

            if 'url' not in expected:
                expected['url'] = url
            if 'title' not in expected:
                expected['title'] = expected['url']
            self.assertEqual(extracted, {url: expected})

            rendered = parse_html('<p>%s</p>' % esc_url, test_pr)
            self.assertHTMLEqual(rendered, '<p>%s</p>' % self.full_pairs[url])

########NEW FILE########
__FILENAME__ = test_utils
import unittest
try:
    import simplejson as json
except ImportError:
    import json

from micawber import *
from micawber.parsers import BeautifulSoup, bs_kwargs
from micawber.providers import make_key


class TestProvider(Provider):
    test_data = {
        # link
        'link?format=json&url=http%3A%2F%2Flink-test1': {'title': 'test1', 'type': 'link'},
        'link?format=json&url=http%3A%2F%2Flink-test2': {'title': 'test2', 'type': 'link'},

        # photo
        'photo?format=json&url=http%3A%2F%2Fphoto-test1': {'title': 'ptest1', 'url': 'test1.jpg', 'type': 'photo'},
        'photo?format=json&url=http%3A%2F%2Fphoto-test2': {'title': 'ptest2', 'url': 'test2.jpg', 'type': 'photo'},

        # video
        'video?format=json&url=http%3A%2F%2Fvideo-test1': {'title': 'vtest1', 'html': '<test1>video</test1>', 'type': 'video'},
        'video?format=json&url=http%3A%2F%2Fvideo-test2': {'title': 'vtest2', 'html': '<test2>video</test2>', 'type': 'video'},

        # rich
        'rich?format=json&url=http%3A%2F%2Frich-test1': {'title': 'rtest1', 'html': '<test1>rich</test1>', 'type': 'rich'},
        'rich?format=json&url=http%3A%2F%2Frich-test2': {'title': 'rtest2', 'html': '<test2>rich</test2>', 'type': 'rich'},

        # with param
        'link?format=json&url=http%3A%2F%2Flink-test1&width=100': {'title': 'test1', 'type': 'link', 'width': 99},

        # no title
        'photo?format=json&url=http%3A%2F%2Fphoto-notitle': {'url': 'notitle.jpg', 'type': 'photo'},
    }

    def fetch(self, url):
        if url in self.test_data:
            return json.dumps(self.test_data[url])
        return False

test_pr = ProviderRegistry()

test_cache = Cache()
test_pr_cache = ProviderRegistry(test_cache)

for pr in (test_pr, test_pr_cache):
    pr.register('http://link\S*', TestProvider('link'))
    pr.register('http://photo\S*', TestProvider('photo'))
    pr.register('http://video\S*', TestProvider('video'))
    pr.register('http://rich\S*', TestProvider('rich'))

class BaseTestCase(unittest.TestCase):
    def setUp(self):
        test_cache._cache = {}

        self.full_pairs = {
            'http://link-test1': '<a href="http://link-test1" title="test1">test1</a>',
            'http://photo-test2': '<a href="test2.jpg" title="ptest2"><img alt="ptest2" src="test2.jpg" /></a>',
            'http://video-test1': '<test1>video</test1>',
            'http://rich-test2': '<test2>rich</test2>',
            'http://photo-notitle': '<a href="notitle.jpg" title="notitle.jpg"><img alt="notitle.jpg" src="notitle.jpg" /></a>',
        }

        self.inline_pairs = {
            'http://link-test1': '<a href="http://link-test1" title="test1">test1</a>',
            'http://photo-test2': '<a href="test2.jpg" title="ptest2">ptest2</a>',
            'http://video-test1': '<a href="http://video-test1" title="vtest1">vtest1</a>',
            'http://rich-test2': '<a href="http://rich-test2" title="rtest2">rtest2</a>',
            'http://rich-test2': '<a href="http://rich-test2" title="rtest2">rtest2</a>',
            'http://photo-notitle': '<a href="notitle.jpg" title="notitle.jpg">notitle.jpg</a>',
        }

        self.data_pairs = {
            'http://link-test1': {'title': 'test1', 'type': 'link'},
            'http://photo-test2': {'title': 'ptest2', 'url': 'test2.jpg', 'type': 'photo'},
            'http://video-test1': {'title': 'vtest1', 'html': '<test1>video</test1>', 'type': 'video'},
            'http://rich-test2': {'title': 'rtest2', 'html': '<test2>rich</test2>', 'type': 'rich'},
            'http://photo-notitle': {'url': 'notitle.jpg', 'type': 'photo'},
        }

    def assertCached(self, url, data, **params):
        key = make_key(url, params)
        self.assertTrue(key in test_cache._cache)
        self.assertEqual(test_cache._cache[key], data)


    def assertHTMLEqual(self, first, second, msg=None):
        first = BeautifulSoup(first, **bs_kwargs)
        second = BeautifulSoup(second, **bs_kwargs)
        self.assertEqual(first, second, msg)

########NEW FILE########
__FILENAME__ = runtests
#!/usr/bin/env python
import os
import sys
import unittest

from micawber import tests


def run_django_tests():
    try:
        import django
    except ImportError:
        print('Skipping django tests')
        return
    else:
        print('Running django integration tests')

    providers = 'micawber.contrib.mcdjango.mcdjango_tests.tests.test_pr'
    extensions = (
        ('oembed_no_urlize', {'urlize_all': False}),
    )

    from django.conf import settings
    if not settings.configured:
        settings.configure(
            DATABASES={
                'default': {
                    'ENGINE': 'django.db.backends.sqlite3',
                    },
                },
            SITE_ID=1,
            INSTALLED_APPS=[
                'django.contrib.auth',
                'django.contrib.contenttypes',
                'django.contrib.sessions',
                'django.contrib.sites',
                'micawber.contrib.mcdjango',
                'micawber.contrib.mcdjango.mcdjango_tests',
            ],
            MICAWBER_PROVIDERS=providers,
            MICAWBER_TEMPLATE_EXTENSIONS=extensions,
        )
    else:
        settings.MICAWBER_PROVIDERS = providers
        settings.MICAWBER_TEMPLATE_EXTENSIONS = extensions

    from django.test.simple import DjangoTestSuiteRunner
    parent = os.path.dirname(os.path.abspath(__file__))
    sys.path.insert(0, parent)
    return DjangoTestSuiteRunner(
        verbosity=1, interactive=True).run_tests(['mcdjango_tests'])


def runtests(*test_args):
    print("Running micawber tests")
    errors = failures = False
    suite = unittest.TestLoader().loadTestsFromModule(tests)
    result = unittest.TextTestRunner(verbosity=2).run(suite)
    if result.failures:
        failures = True
    if result.errors:
        errors = True
    if not (errors or failures):
        print("All micawber tests passed")
    
    dj_failures = run_django_tests()
    
    if failures or errors or dj_failures:
        sys.exit(1)
    
    sys.exit(0)

if __name__ == '__main__':
    runtests(*sys.argv[1:])

########NEW FILE########
