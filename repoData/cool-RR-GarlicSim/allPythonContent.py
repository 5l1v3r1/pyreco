__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# garlicsim documentation build configuration file, created by
# sphinx-quickstart on Wed May 12 17:33:00 2010.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.append(os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.intersphinx']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.txt'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'garlicsim'
copyright = u'2009-2011, Ram Rachum'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.6.3'
# The full version, including alpha/beta/rc tags.
release = '0.6.3'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
#pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'theme'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['.']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'garlicsimdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'garlicsim.tex', u'garlicsim Documentation',
   u'Ram Rachum', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/': None}
########NEW FILE########
__FILENAME__ = base_cruncher
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `BaseCruncher` class.

See its documentation for more information. See the `crunchers` package for a
collection of crunchers.
'''

import copy

from garlicsim.general_misc.third_party import abc

from garlicsim.general_misc import abc_tools

import garlicsim


class BaseCruncher(object):
    '''
    A worker that produces new simulation states using the step function.
    
    A cruncher receives a state (or a history browser) from the main program,
    and then it repeatedly applies the step function of the simulation to
    produce more states. Those states are then put in the cruncher's
    `.work_queue`. They are then taken by the main program when
    `Project.sync_crunchers` is called, and put into the tree.

    The cruncher also receives a crunching profile from the main program. The
    crunching profile specifes how far the cruncher should crunch the
    simulation, and which arguments it should pass to the step function.
    
    This is an abstract base class. For a collection of actual crunchers, check
    out the `crunchers` package. It contains different crunchers which work in
    different ways, but are to a certain extent interchangable. Different kinds
    of crunchers have different advantages and disadvantges relatively to each
    other, and which cruncher you should use for your project depends on the
    situation.
    '''
    
    __metaclass__ = abc.ABCMeta

    
    gui_explanation = None
    '''
    A relatively non-technical explanation about the cruncher type.
    
    This will be displayed to GUI users who may not be programmers.
    '''

    
    def __init__(self, crunching_manager, initial_state, crunching_profile):
        
        self.crunching_manager = crunching_manager
        '''
        Crunching manager which recruites, manages and retires this cruncher.
        '''
        assert isinstance(self.crunching_manager,
                          garlicsim.asynchronous_crunching.CrunchingManager)
        
        self.project = crunching_manager.project
        '''The project on which this cruncher operates.'''
        assert isinstance(self.project, garlicsim.Project)
        
        self.initial_state = initial_state
        '''The initial state given to the cruncher.'''
        assert isinstance(self.initial_state, garlicsim.data_structures.State)
        
        self.crunching_profile = copy.deepcopy(crunching_profile)
        '''The crunching profile that this cruncher will adhere to.'''
        assert isinstance(self.crunching_profile,
                          garlicsim.asynchronous_crunching.CrunchingProfile)
        
    
    @abc_tools.abstract_static_method
    def can_be_used_with_simpack_grokker(simpack_grokker):
        '''
        Return whether this cruncher type can be used with a simpack grokker.
        
        (Static method.)
        '''
        
    
    @abc.abstractmethod
    def start(self):
        '''
        Start the cruncher so it will start crunching and delivering states.
        '''
    
        
    @abc.abstractmethod
    def retire(self):
        '''Retire the cruncher, making it shut down.'''
    
    
    @abc.abstractmethod
    def update_crunching_profile(self, profile):
        '''Update the cruncher's crunching profile.'''
        
    
    @abc.abstractmethod
    def is_alive(self):
        '''Report whether the cruncher is alive and crunching.'''
        
########NEW FILE########
__FILENAME__ = pi_cloud_cruncher
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `PiCloudCruncher` class, which is merely a placeholder.

See its documentation for more information.

The real `PiCloudCruncher` will probably be released in GarlicSim 0.7 in
mid-2011.
'''

from garlicsim.general_misc import string_tools
from garlicsim.general_misc.reasoned_bool import ReasonedBool

import garlicsim
from garlicsim.asynchronous_crunching import BaseCruncher


apology = ('PiCloudCruncher is not implemented in this version! This is just '
           'a placeholder. PiCloudCruncher is scheduled to be released in '
           'GarlicSim 0.7, which will be available in mid-2011.')


class PiCloudCruncher(BaseCruncher):
    '''
    Placeholder for the real `PiCloudCruncher`, which could crunch on PiCloud.
    
    The real `PiCloudCruncher` will probably be released in GarlicSim 0.7 in
    mid-2011.
    
    `PiCloudCruncher` will be able to crunch the simulation on the cloud using
    PiCloud, a proprietary cloud solution. Visit http://picloud.com for more
    details.
    
    This will relieve the user's computer from crunching the simulation,
    allowing parallel computation of many tree forks.
    
    Using `PiCloudCruncher` will require an internet connection and a paid
    PiCloud account. (It's really cheap though.)
    '''
    
    gui_explanation = string_tools.docstring_trim(
    '''
    `PiCloudCruncher`:
    
     - Works by using the `cloud` module supplied by PiCloud, Inc.
     
     - Offloads the crunching into the cloud, relieving this computer of the CPU
       stress.
       
     - Requires a working internet connection and a PiCloud account. Visit
       http://picloud.com to get one.
       
     - Costs money, charged by the millisecond. It's really cheap though. See
       the PiCloud website for pricing details.
    ''')
    
    
    
    @staticmethod
    def can_be_used_with_simpack_grokker(simpack_grokker):
        '''
        Return whether `PiCloudCruncher` can be used with a simpack grokker.
        
        Since this class is just a placeholder, the answer is invariably
        `False`.
        '''
        return ReasonedBool(
            False,
            apology
        )
    
    
    def __init__(self, *args, **kwargs):
        raise NotImplementedError(apology)
########NEW FILE########
__FILENAME__ = process
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `Process` class.

See its documentation for more info.
'''

import multiprocessing
import Queue
import sys
import os

try:
    import garlicsim.general_misc.process_priority
except Exception:
    pass

import garlicsim
from garlicsim.asynchronous_crunching import \
     BaseCruncher, CrunchingProfile, ObsoleteCruncherError


class Process(multiprocessing.Process):
    '''The actual system process used by `ProcessCruncher`.'''
    # One of the reasons that `Process` is a separate entity from
    # `ProcessCruncher` is that because the way the `multiprocessing` module
    # works, all arguments to `Process.__init__` must be pickleable, which would
    # prevent us from getting the crunching manager as an argument, since it's
    # not pickleable.
    
    def __init__(self, step_iterator_getter, initial_state, crunching_profile):        
        multiprocessing.Process.__init__(self)
        
        self.step_iterator_getter = step_iterator_getter
        '''
        Function that return a step iterator given a state and step profile.
        '''
        
        self.initial_state = initial_state
        '''
        First state given to the process from which it crunches more states.
        '''       
        
        self.crunching_profile = crunching_profile
        
        self.daemon = True

        self.work_queue = multiprocessing.Queue(
            garlicsim.asynchronous_crunching.CRUNCHER_QUEUE_SIZE
        )
        '''
        Queue for putting completed work to be picked up by the main thread.
        
        In this queue the cruncher will put the states that it produces, in
        chronological order. If the cruncher reaches a simulation ends, it will
        put an `EndMarker` in this queue.
        '''
        
        self.order_queue = multiprocessing.Queue()
        '''Queue for receiving instructions from the main thread.'''
    
        
    def set_low_priority(self):
        '''Set a low priority for this process.'''
        
        try:
            sys.getwindowsversion()
        except Exception:
            is_windows = False
        else:
            is_windows = True

        if is_windows:
            try:
                garlicsim.general_misc.process_priority.set_process_priority(0)
            except Exception:
                pass
        else:
            try:
                os.nice(1)
            except Exception:
                pass

            
    def run(self):
        '''
        Internal method.
        
        This is called when the cruncher is started. It just calls the
        `main_loop` method in a try clause, excepting `ObsoleteCruncherError`;
        That exception means that the cruncher has been retired in the middle of
        its job, so it is propagated up to this level, where it causes the
        cruncher to terminate.
        '''
        try:
            self.main_loop()
        except ObsoleteCruncherError:
            return

        
    def main_loop(self):
        '''
        The main loop of the cruncher.
        
        Crunches the simulations repeatedly until either:

         1. The crunching profile is satisfied. (i.e. we have reached a
            high-enough clock reading,)
        
        or
        
         2. A 'retire' order has been received,
         
        or 
        
         3. We have reached a simulation end. (i.e. the step function raised
            `WorldEnded`.)
            
        or 
        
         4. We have received a new crunching profile which has a different step
            profile than the one we started with. We can't change step profile
            on the fly, so we simply retire and let the crunching manager 
            recruit a new cruncher.
            
        '''
        self.set_low_priority()
        
        state = self.initial_state
        
        self.step_profile = self.crunching_profile.step_profile
        
        self.iterator = self.step_iterator_getter(self.initial_state,
                                                  self.step_profile)
        
        order = None
        
        try:
            for state in self.iterator:
                self.work_queue.put(state)
                self.check_crunching_profile(state)
                order = self.get_order()
                if order:
                    self.process_order(order) 
        except garlicsim.misc.WorldEnded:
            self.work_queue.put(
                garlicsim.asynchronous_crunching.misc.EndMarker()
            )

            
    def check_crunching_profile(self, state):
        '''
        Check if the cruncher crunched enough states. If so retire.
        
        The crunching manager specifies how much the cruncher should crunch.
        We consult with it to check if the cruncher has finished, and if it did
        we retire the cruncher.
        '''
        if self.crunching_profile.state_satisfies(state):
            raise ObsoleteCruncherError("We're done working, the clock target "
                                        "has been reached. Shutting down.")
    
        
    def get_order(self):
        '''
        Attempt to read an order from the `.order_queue`, if one has been sent.
        
        Returns the order.
        '''
        try:
            return self.order_queue.get(block=False)
        except Queue.Empty:
            return None
    
        
    def process_order(self, order):
        '''Process an order receieved from `.order_queue`.'''
        
        if order == 'retire':
            raise ObsoleteCruncherError("Cruncher received a 'retire' order; "
                                        "Shutting down.")
        
        elif isinstance(order, CrunchingProfile):
            self.process_crunching_profile_order(order)
            
            
            
    def process_crunching_profile_order(self, order):
        '''Process an order to update the crunching profile.'''
        if self.crunching_profile.step_profile != order.step_profile:
            raise ObsoleteCruncherError('Step profile changed; shutting down. '
                                        'Crunching manager should create a '
                                        'new cruncher.')
        self.crunching_profile = order

########NEW FILE########
__FILENAME__ = process_cruncher
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `ProcessCruncher` class.

See its documentation for more information.
'''

import sys

from garlicsim.general_misc.reasoned_bool import ReasonedBool
from garlicsim.general_misc import string_tools
from garlicsim.general_misc import import_tools

import garlicsim
from garlicsim.asynchronous_crunching import BaseCruncher


multiprocessing_missing_text = (
    "`ProcessCruncher` can't be used because the "
    "`multiprocessing` module isn't installed.%s" % (
        (
            " You may find a backport of it for Python 2.5 here: "
            "http://pypi.python.org/pypi/multiprocessing"
        ) if sys.version_info[:2] <= (2, 5) else ''
    )
)

        
class ProcessCruncher(BaseCruncher):
    '''
    Cruncher that crunches from a process.
    
    A cruncher is a worker which crunches the simulation. It receives a state
    from the main program, and then it repeatedly applies the step function of
    the simulation to produce more states. Those states are then put in the
    cruncher's `.work_queue`. They are then taken by the main program when
    `Project.sync_crunchers` is called, and put into the tree.
        
    Read more about crunchers in the documentation of the `crunchers` package.
    
    The advantage of `ProcessCruncher` over `ThreadCruncher` is that
    `ProcessCruncher` is able to run on a different core of the processor in the
    machine, thus using the full power of the processor.
    '''
    
    
    gui_explanation = string_tools.docstring_trim(
    '''
    `ProcessCruncher`:
    
     - Works from a `multiprocessing.Process`.
    
     - Able to run on a different core of the processor than the main process 
       or other ProcessCrunchers, thus utilizing the full power of the
       processor.
     '''
    )
    
    
    def __init__(self, crunching_manager, initial_state, crunching_profile):
        
        BaseCruncher.__init__(self, crunching_manager, initial_state, 
                              crunching_profile)
        
        if not import_tools.exists('multiprocessing'):
            raise Exception(multiprocessing_missing_text)
        
        from .process import Process
        
        self.process = Process(
            self.project.simpack_grokker.get_step_iterator,
            initial_state,
            crunching_profile
        )
        '''The actual process which does the crunching.'''
        
        self.work_queue = self.process.work_queue
        '''
        Queue for putting completed work to be picked up by the main thread.
        
        In this queue the cruncher will put the states that it produces, in
        chronological order. If the cruncher reaches a simulation ends, it will
        put an `EndMarker` in this queue.
        '''
        
        self.order_queue = self.process.order_queue
        '''Queue for receiving instructions from the main thread.'''
     
    
    @staticmethod
    def can_be_used_with_simpack_grokker(simpack_grokker):
        '''
        Return whether `ProcessCruncher` can be used with `simpack_grokker`.
        
        For `ProcessCruncher` to be usable, the `multiprocessing` module must be
        installed. Assuming it's installed, `ProcessCruncher` can be used if and
        only if the simpack is not history-dependent.
        '''
        
        if not import_tools.exists('multiprocessing'):
            return ReasonedBool(
                False,
                multiprocessing_missing_text
            )
        
        elif simpack_grokker.history_dependent:
            return ReasonedBool(
                False,
                "`ProcessCruncher` can't be used in history-dependent "
                "simulations because processes don't share memory."
            )
        
        else:
            return True

        
    def start(self):
        '''
        Start the cruncher so it will start crunching and delivering states.
        '''
        self.process.start()

            
    def retire(self):
        '''
        Retire the cruncher. Process-safe.
        
        Causes it to shut down as soon as it receives the order.
        '''
        self.order_queue.put('retire')
        
        
    def update_crunching_profile(self, profile):
        '''Update the cruncher's crunching profile. Process-safe.'''
        self.order_queue.put(profile)
        
        
    def is_alive(self):
        '''Report whether the cruncher is alive and crunching.'''
        return self.process.is_alive()
        
        
    
########NEW FILE########
__FILENAME__ = thread_cruncher
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `ThreadCruncher` class.

See its documentation for more information.
'''

import threading
import Queue
import copy

from garlicsim.general_misc import string_tools

import garlicsim
from garlicsim.asynchronous_crunching import \
     BaseCruncher, HistoryBrowser, ObsoleteCruncherError, CrunchingProfile


__all__ = ['ThreadCruncher']


class ThreadCruncher(threading.Thread, BaseCruncher):
    '''
    ThreadCruncher is cruncher that works from a thread.
    
    A cruncher is a worker which crunches the simulation. It receives a state
    from the main program, and then it repeatedly applies the step function of
    the simulation to produce more states. Those states are then put in the
    cruncher's `.work_queue`. They are then taken by the main program when
    `Project.sync_crunchers` is called, and put into the tree.
        
    Read more about crunchers in the documentation of the `crunchers` package.
    
    The advantages of `ThreadCruncher` over `ProcessCruncher` are:
    1. `ThreadCruncher` is able to handle simulations that are
       history-dependent, which would have been very hard to implement in a 
       Process, since processes don't share memory, while threads do share
       memory trivially.
    2. `ThreadCruncher` is based on the `threading` module, which is stabler
       and more mature than the `multiprocessing` module.
    3. `ThreadCruncher` is much easier to debug than `ProcessCruncher`, since
       there are currently many more tools for debugging Python threads than
       Python processes.
    4. On a single-core computer, `ThreadCruncher` may be faster than
       `ProcessCruncher` because of shared memory.
    '''
    
    gui_explanation = string_tools.docstring_trim(
    '''
    `ThreadCruncher`:
    
     - Works from a `threading.Thread`.
    
     - Able to handle simulations that are history-dependent.
    
     - Based on the `threading` module, which is stabler and more mature than
       the `multiprocessing` module.
    
     - Easy to debug.
    
     - On a single-core computer, it may be faster than `ProcessCruncher` because
       of shared memory.
     '''
    )
    
    
    @staticmethod
    def can_be_used_with_simpack_grokker(simpack_grokker):
        '''
        Return whether `ThreadCruncher` can be used with a simpack grokker.
        
        The answer is always `True`.
        '''
        return True
    
    
    def __init__(self, crunching_manager, initial_state, crunching_profile):
        BaseCruncher.__init__(self, crunching_manager,
                              initial_state, crunching_profile)
        threading.Thread.__init__(self)
        
        self.step_iterator_getter = \
            self.project.simpack_grokker.get_step_iterator
        self.history_dependent = self.project.simpack_grokker.history_dependent
        
        self.daemon = True

        self.work_queue = Queue.Queue(
            garlicsim.asynchronous_crunching.CRUNCHER_QUEUE_SIZE
        )
        '''
        Queue for putting completed work to be picked up by the main thread.
        
        In this queue the cruncher will put the states that it produces, in
        chronological order. If the cruncher reaches a simulation ends, it will
        put an `EndMarker` in this queue.
        '''

        self.order_queue = Queue.Queue()
        '''Queue for receiving instructions from the main thread.'''

        
    def run(self):
        '''
        Internal method.
        
        This is called when the cruncher is started. It just calls the
        `main_loop` method in a `try` clause, excepting `ObsoleteCruncherError`;
        That exception means that the cruncher has been retired in the middle of
        its job, so it is propagated up to this level, where it causes the
        cruncher to terminate.
        '''
        try:
            self.main_loop()
        except ObsoleteCruncherError:
            return

        
    def main_loop(self):
        '''
        The main loop of the cruncher.
        
        Crunches the simulations repeatedly until either:

         1. The crunching profile is satisfied. (i.e. we have reached a
            high-enough clock reading,)
        
        or
        
         2. A 'retire' order has been received,
         
        or 
        
         3. We have reached a simulation end. (i.e. the step function raised
            `WorldEnded`.)
            
        or 
        
         4. We have received a new crunching profile which has a different step
            profile than the one we started with. We can't change step profile
            on the fly, so we simply retire and let the crunching manager 
            recruit a new cruncher.
            
        '''
        
        self.step_profile = self.crunching_profile.step_profile
        
        if self.history_dependent:
            self.history_browser = HistoryBrowser(cruncher=self)
            thing = self.history_browser
        else:
            thing = self.initial_state

        self.iterator = self.step_iterator_getter(thing, self.step_profile)
            
        order = None
        
        try:
            for state in self.iterator:
                self.work_queue.put(state)
                self.check_crunching_profile(state)
                order = self.get_order()
                if order:
                    self.process_order(order)
        except garlicsim.misc.WorldEnded:
            self.work_queue.put(
                garlicsim.asynchronous_crunching.misc.EndMarker()
            )

        
    def check_crunching_profile(self, state):
        '''
        Check if the cruncher crunched enough states. If so retire.
        
        The crunching manager specifies how much the cruncher should crunch.
        We consult with it to check if the cruncher has finished, and if it did
        we retire the cruncher.
        '''
        if self.crunching_profile.state_satisfies(state):
            raise ObsoleteCruncherError("We're done working, the clock target "
                                        "has been reached. Shutting down.")

        
    def get_order(self):
        '''
        Attempt to read an order from the `.order_queue`, if one has been sent.
        
        Returns the order.
        '''
        try:
            return self.order_queue.get(block=False)
        except Queue.Empty:
            return None

        
    def process_order(self, order):
        '''Process an order receieved from `.order_queue`.'''
        if order == 'retire':
            raise ObsoleteCruncherError("Cruncher received a 'retire' order; "
                                        "Shutting down.")
        
        elif isinstance(order, CrunchingProfile):
            self.process_crunching_profile_order(order)
            
            
    def process_crunching_profile_order(self, order):
        '''Process an order to update the crunching profile.'''
        if self.crunching_profile.step_profile != order.step_profile:
            raise ObsoleteCruncherError('Step profile changed; shutting down. '
                                        'Crunching manager should create a '
                                        'new cruncher.')
        self.crunching_profile = order

        
    def retire(self):
        '''
        Retire the cruncher. Thread-safe.
        
        Causes it to shut down as soon as it receives the order.
        '''
        self.order_queue.put('retire')        
        
        
    def update_crunching_profile(self, profile):
        '''Update the cruncher's crunching profile. Thread-safe.'''
        self.order_queue.put(profile)
        
        
    is_alive = threading.Thread.isAlive
    '''Crutch for Python 2.5 and below.'''
    


########NEW FILE########
__FILENAME__ = crunching_manager
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `CrunchingManager` class.

See its documentation for more information.
'''

from __future__ import with_statement

from garlicsim.general_misc import queue_tools
from garlicsim.general_misc import decorator_tools
import garlicsim.general_misc.change_tracker
from garlicsim.general_misc.infinity import infinity
from garlicsim.general_misc import misc_tools
from garlicsim.general_misc import address_tools
from garlicsim.general_misc import cute_iter_tools

import garlicsim
import garlicsim.data_structures
import garlicsim.misc
from . import crunchers
from .crunching_profile import CrunchingProfile
from .base_cruncher import BaseCruncher
from garlicsim.misc.step_profile import StepProfile
from .misc import EndMarker


__all__ = ['CrunchingManager']


@decorator_tools.decorator
def with_tree_lock(method, *args, **kwargs):
    '''
    Decorator for using the tree lock (in write mode) as a context manager.
    '''
    self = args[0]
    with self.project.tree.lock.write:
        return method(*args, **kwargs)


class CrunchingManager(object):
    '''
    A crunching manager manages the background crunching for a project.
    
    Every project creates a crunching manager. The job of the crunching manager
    is to coordinate the crunchers, creating and retiring them as necessary.
    The main use of a crunching manager is through its sync_workers methods,
    which goes over all the crunchers and all the nodes of the tree that need
    to be crunched, making sure the crunchers are working on these nodes, and
    collecting work from them to implement into the tree.
    
    The crunching manager contains a list of jobs as an attribute `.jobs`. See
    documentation for garlicsim.asynchronous_crunching.Job for more info about
    jobs. The crunching manager will employ crunchers in order to complete the
    jobs. It will then take work from these crunchers, put it into the tree,
    and delete the jobs when they are completed.
    '''
  
    def __init__(self, project):        
        
        self.project = project
        
        self.jobs = []
        '''
        The jobs that the crunching manager will be responsible for doing.
        
        These are of the class `garlicsim.asynchronous_crunching.Job`.
        '''
        
        self.crunchers = {}
        '''Dict that maps each job to the cruncher reponsible for doing it.'''
        
        self.step_profiles = {}
        '''
        Dict that maps each cruncher to its step options profile.
        
        This exists because if the step profile for a job changes, we need to
        retire the cruncher and make a new one; crunchers can't change step
        profiles on the fly. So we use this dict to track which step profile
        each cruncher uses.
        '''
        
        self.crunching_profiles_change_tracker = \
            garlicsim.general_misc.change_tracker.ChangeTracker()
        '''
        A change tracker which tracks changes made to crunching profiles.
        
        This is used to update the crunchers if the crunching profile for the
        job they're working on has been changed.
        '''
        
        available_cruncher_types = \
            self.project.simpack_grokker.available_cruncher_types
        
        if not available_cruncher_types:
            raise garlicsim.misc.GarlicSimException(
                "The `%s` simpack doesn't allow using any of the cruncher "
                "types we have installed." % self.project.simpack.__name__
            )
            
        
        self.cruncher_type = available_cruncher_types[0]
        '''
        The cruncher type that we will use to crunch the simulation.
        
        All crunchers that the crunching manager will create will be of this
        type. The user may assign a different cruncher type to `.cruncher_type`,
        and on the next call to `.sync_crunchers` the crunching manager will
        retire all the existing crunchers and replace them with crunchers of the
        new type.
        '''
        
        
    @with_tree_lock
    def sync_crunchers(self):
        '''
        Take work from the crunchers, and give them new instructions if needed.
        
        Talks with all the crunchers, takes work from them for implementing
        into the tree, retiring crunchers or recruiting new crunchers as
        necessary.

        Returns the total amount of nodes that were added to the tree in the
        process.
        '''
        # This is one of the most technical and sensitive functions in all of
        # GarlicSim-land. Be careful if you're trying to make changes.

        total_added_nodes = garlicsim.misc.NodesAdded(0)
        '''int-oid in which we track the number of nodes added to the tree.'''
        
        # The first thing we do is iterate over the crunchers whose jobs have
        # been terminated. We take work from them, put it into the tree, and
        # promptly retire them, deleting them from `self.crunchers`.
        
        for (job, cruncher) in self.crunchers.copy().items():
            if not (job in self.jobs):
                (added_nodes, new_leaf) = \
                    self.__add_work_to_tree(cruncher, job, retire=True)
                total_added_nodes += added_nodes
                del self.crunchers[job]

                
        # In this point all the crunchers in `.crunchers` have an active job
        # associated with them.
        #
        # Now we'll iterate over the active jobs.
        
        for job in self.jobs[:]:
            
            
            if job not in self.crunchers:
                
                # If there is no cruncher associated with the job, we create
                # one. (As long as the job is unfinished, and the node isn't in
                # editing.) And that's it for this job, we `continue` to the
                # next one.
                
                if not job.is_done():
                    self.__conditional_create_cruncher(job)
                else: # job.is_done() is True
                    self.jobs.remove(job)
                continue

            # job in self.crunchers
            #
            # Okay, so it's an active job. We'll take work from the cruncher and
            # put it in the tree, updating the job to point at `new_leaf`, which
            # is the node (leaf) containing the most recent state produced by
            # the cruncher.
            #
            # The cruncher may either be active and crunching, or it may have
            # stopped, (because of a `WorldEnded` exception, or other reasons.)
            
            cruncher = self.crunchers[job]
            
            (added_nodes, new_leaf) = self.__add_work_to_tree(cruncher,
                                                              job)
            total_added_nodes += added_nodes

            job.node = new_leaf
            
            # We took work from the cruncher, now it's time to decide if we want
            # the cruncher to keep running or not. We will also update its
            # crunching profile, if that has been changed on the job.
            
            if not job.is_done():
                
                # (We have called `job.is_done` again because the job's node may
                # have changed, and possibly the new node *does* satisfy the
                # job's crunching profile that the previous node didn't.)
                
                crunching_profile = job.crunching_profile
                
                if cruncher.is_alive() and \
                   (type(cruncher) is self.cruncher_type):
                    
                    # The job is not done, the cruncher's still working and it
                    # is of the right type. In this case, the only thing left to
                    # do is check if the crunching profile changed.

                    # First we'll check if the step profile changed:
                    
                    if crunching_profile.step_profile != \
                       self.step_profiles[cruncher]:
                        
                        # If it did, we immediately replace the cruncher,
                        # because crunchers can't change step profile on the
                        # fly.
                        
                        if cruncher.is_alive():
                            cruncher.retire()
                        
                        self.__conditional_create_cruncher(job)
                        
                        continue
                    
                        
                    # At this point we know that the step profile hasn't
                    # changed, but possibly some other part (i.e. clock target)
                    # has changed, and if so we update the cruncher about it.
                        
                    if self.crunching_profiles_change_tracker.check_in \
                       (crunching_profile):
                        
                        cruncher.update_crunching_profile(crunching_profile)
                        
                        continue
                        
                else: 
                    
                    # Either the cruncher died, or it is of the wrong type. The
                    # latter happens when the user changes
                    # `crunching_manager.cruncher_type` in the middle of
                    # simulating. In any case, this cruncher is done for.
                    
                    cruncher.retire() # In case it's not totally dead.
                    
                    self.__conditional_create_cruncher(job)
                    
                    continue
                    
                    
            else: # job.is_done() is True
                
                # The job is done; we remove it from the job list, and retire
                # and delete the cruncher.
                
                self.jobs.remove(job)
                if cruncher.is_alive():
                    cruncher.retire()
                del self.crunchers[job]

            
        return total_added_nodes

    
    
    def __conditional_create_cruncher(self, job):
        '''
        Create a cruncher to crunch the node, unless there is reason not to.
        '''
        node = job.node
        crunching_profile = job.crunching_profile
        
        if node.still_in_editing is False:
            cruncher = self.cruncher_type(self, node.state, crunching_profile)
            cruncher.start()
            self.crunchers[job] = cruncher
            
            self.crunching_profiles_change_tracker.check_in(crunching_profile)
            self.step_profiles[cruncher] = \
                crunching_profile.step_profile
            
    
    def get_jobs_by_node(self, node):
        '''
        Get all the jobs that should be done on the specified node.
        
        This is every job whose `.node` attribute is the given node/
        '''
        return [job for job in self.jobs if (job.node is node)]

    
    def __add_work_to_tree(self, cruncher, job, retire=False):
        '''
        Take work from cruncher and add to tree at the specified job's node.
        
        If `retire` is set to `True`, retires the cruncher. Keep in mind that
        if the cruncher gives an `EndMarker`, it will be retired regardless of
        the `retire` argument.
        
        Returns `(number, leaf)`, where `number` is the number of nodes that
        were added, and `leaf` is the last node that was added.
        '''
        
        tree = self.project.tree
        node = job.node
        
        current_node = node
        counter = 0
        
        queue_iterator = queue_tools.iterate(
            cruncher.work_queue,
            limit_to_original_size=True,
            _prefetch_if_no_qsize=True
        )
        
        for thing in queue_iterator:
            
            if isinstance(thing, garlicsim.data_structures.State):
                counter += 1
                current_node = tree.add_state(
                    thing,
                    parent=current_node,
                    step_profile=self.step_profiles[cruncher],            
                )
                # todo optimization: save step profile in variable, it's
                # wasteful to do a dict lookup every state.
            
            elif isinstance(thing, EndMarker):
                tree.make_end(node=current_node,
                              step_profile=self.step_profiles[cruncher])
                job.resulted_in_end = True
                
            else:
                raise TypeError('Unexpected object `%s` in work queue' % thing)
                        
        if retire or job.resulted_in_end:
            cruncher.retire()
        
        nodes_added = garlicsim.misc.NodesAdded(counter)

        return (nodes_added, current_node)
    
    
    def __repr__(self):
        '''
        Get a string representation of the crunching manager.
        
        Example output:
        <garlicsim.asynchronous_crunching.CrunchingManager
        currently employing 2 crunchers to handle 2 jobs at 0x1f699b0>
        '''
        
        crunchers_count = len(self.crunchers)
        job_count = len(self.jobs)
                                   
        return (
            '<%s currently employing %s crunchers to handle %s jobs at %s>' %
            (
                address_tools.describe(type(self), shorten=True),
                crunchers_count,
                job_count,
                hex(id(self))
            )
        )
    

########NEW FILE########
__FILENAME__ = crunching_profile
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `CrunchingProfile` class.

See its documentation for more information.
'''

import garlicsim.misc


class CrunchingProfile(object):
    '''Instructions that a cruncher follows when crunching the simulation.'''
    
    def __init__(self, clock_target, step_profile):
        '''
        Construct the CrunchingProfile.
        
        `clock_target` is the clock until which we want to crunch.
        `step_profile` is the step profile we want to use.
        '''
        
        self.clock_target = clock_target
        '''We crunch until we get a clock of `.clock_target` or higher.'''

        assert isinstance(step_profile, garlicsim.misc.StepProfile)
        self.step_profile = step_profile
        '''The step profile we want to be used with the step function.'''
  
        
    def state_satisfies(self, state):
        '''
        Check whether a state has a clock high enough to satisfy this profile.
        '''
        return state.clock >= self.clock_target

    
    def raise_clock_target(self, clock_target):
        '''Make `.clock_target` at least as big as the given `clock_target`.'''
        if self.clock_target < clock_target:
            self.clock_target = clock_target
    
            
    def __eq__(self, other):
        return isinstance(other, CrunchingProfile) and \
               self.clock_target == other.clock_target and \
               self.step_profile == other.step_profile

    
    __hash__ = None
    # `CrunchingProfile` is mutable so it should never be hashed.

    
    def __ne__(self, other):
        return not self.__eq__(other)

    
    def __repr__(self):
        '''
        Get a string representation of the crunching profile.
        
        Example output:
        
            CrunchingProfile(clock_target=infinity,
            step_profile=life.State.step(<state>))
        '''
        return 'CrunchingProfile(clock_target=%s, step_profile=%s)' % (
            self.clock_target,
            self.step_profile.__repr__(short_form=True)
        )
        
    
    
    
########NEW FILE########
__FILENAME__ = history_browser
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `HistoryBrowser` class.

See its documentation for more info.
'''

from __future__ import with_statement

import threading

from garlicsim.general_misc import binary_search
from garlicsim.general_misc import queue_tools
from garlicsim.general_misc import decorator_tools
from garlicsim.general_misc.context_manager import ContextManager

import garlicsim.misc
from .obsolete_cruncher_error import ObsoleteCruncherError


__all__ = ['HistoryBrowser']


@decorator_tools.decorator
def with_self(method, *args, **kwargs):
    '''Decorator for using the history browser as a context manager.'''
    self = args[0]
    with self:
        return method(*args, **kwargs)

    
class HistoryBrowser(garlicsim.misc.BaseHistoryBrowser, ContextManager):
    '''
    A device for requesting information about the history of the simulation.
    
    A `HistoryBrowser` is a device for requesting information about the history
    of the simulation. It is intended to be used by `ThreadCruncher` in
    simulations that are history-dependent.
    
    With a `HistoryBrowser` one can request states from the simulation's
    timeline. States can be requested by clock time or position in the timeline
    or by other measures; see documentation for this class's methods.
    
    Since we do not know whether the states we request have been implemented in
    the tree already, or they are still in the `.work_queue`, it's the job of
    the `HistoryBrowser` to find that out. This is done transperantly for the
    user.
    
    When using a `HistoryBroswer`, the lock of the project's tree is acquired
    for reading. That acquiring action can also be invoked by using
    `HistoryBrowser` as a context manager.
    '''
        
    def __init__(self, cruncher):
        self.cruncher = cruncher
        self.project = cruncher.project
        self.tree = self.project.tree
        self.tree_lock = self.project.tree.lock
    
        
    def manage_context(self):
        '''
        Manage the `HistoryBrowser` context, using the tree lock in read mode.
        '''
        with self.tree_lock.read:
            yield self

        
    @with_self
    def get_last_state(self):
        '''
        Get the last state in the timeline. Identical to `.__getitem__(-1)`.
        '''
        return self[-1]

    
    @with_self
    def __getitem__(self, index):
        '''Get a state by its position in the timeline.'''
        assert isinstance(index, int)
        if index < 0:
            return self.__get_item_negative(index)
        else: # index >= 0
            return self.__get_item_positive(index)

        
    @with_self
    def __get_item_negative(self, index):
        '''
        Get a state by its position in the timeline. Negative indices only.
        '''
        try:
            return self.__get_item_from_queue(index)
        except IndexError:
            # The requested state is in the tree
            queue_size = self.cruncher.work_queue.qsize()
            new_index = index + queue_size
            our_node = self.__get_our_node()
            path = our_node.make_containing_path()
            result_node = path.__getitem__(new_index, tail=our_node)
            return result_node.state
            
    
    @with_self
    def __get_item_positive(self, index):
        '''
        Get a state by its position in the timeline. Positive indices only.
        '''
        our_node = self.__get_our_node()
        path = our_node.make_containing_path()
        try:
            result_node = path.__getitem__(index, tail=our_node)
            return result_node.state
        
        except IndexError:
            path_length = path.__len__(tail=our_node)
            # todo: Probably inefficient: We're plowing through the path again.
            new_index = index - path_length
            try:
                return self.__get_item_from_queue(new_index)
            except IndexError:
                queue_length = self.cruncher.work_queue.qsize()
                timeline_length = queue_length + path_length
                message = 'You asked for node number ' + str(index) + \
                          ' while the timeline has only ' + timeline_length + \
                          ' states, comprised by ' + path_length + \
                          ' states in the tree and ' + queue_length + \
                          ' states in the queue.'
                raise IndexError(message)

            
    @with_self
    def __get_item_from_queue(self, index):
        '''
        Obtain an item by index number from the work_queue of our cruncher.
        '''
        return queue_tools.get_item(self.cruncher.work_queue, index)

    
    @with_self
    def get_state_by_monotonic_function(self, function, value,
                                        rounding=binary_search.CLOSEST):
        '''
        Get a state by specifying a measure function and a desired value.
        
        The function must be a monotonic rising function on the timeline.
        
        See documentation of `binary_search.roundings` for details about
        rounding options.
        '''
        
        assert issubclass(rounding, binary_search.Rounding)
        
        tree_result = self.__get_both_states_by_monotonic_function_from_tree \
                      (function, value)
        
        if tree_result[1] is not None:
            # Then there is no need to check the queue even.
            return binary_search.make_both_data_into_preferred_rounding\
                   (tree_result, function, value, rounding)
        
        else:
            queue_result = self.__get_state_by_monotonic_function_from_queue \
                           (function, value, rounding=binary_search.BOTH)
            none_count = list(queue_result).count(None)
            if none_count == 0:
                # The result is entirely in the queue
                return binary_search.make_both_data_into_preferred_rounding\
                       (queue_result, function, value, rounding)
            elif none_count == 1:
                # The result is either before the past edge of the queue or
                # after its future edge.
                if queue_result[1] is None:
                    # The result is beyond the future edge of the queue.
                    return binary_search.\
                           make_both_data_into_preferred_rounding\
                           (queue_result, function, value, rounding)
                else: # queue_result[0] == None
                    # Getting tricky: The result is somewhere in the middle
                    # between the queue and the tree.
                    combined_result = (tree_result[0], queue_result[1])
                    return binary_search.\
                           make_both_data_into_preferred_rounding\
                           (combined_result, function, value, rounding)
    
            else:
                assert none_count == 2
                # The queue is just totally empty.
                return binary_search.make_both_data_into_preferred_rounding \
                       (tree_result, function, value, rounding)

            
    @with_self   
    def __get_both_states_by_monotonic_function_from_tree(self, function,
                                                          value):
        '''
        Get two states from the tree with value surrounding the desired value.

        The function must be a monotonic rising function on the timeline.
        
        This uses the `binary_search.BOTH` rounding. See its documentation.
        '''
        our_node = self.__get_our_node()
        path = our_node.make_containing_path()
        new_function = lambda node: function(node.state)
        
        result_in_nodes = path.get_node_by_monotonic_function \
            (new_function, value, binary_search.BOTH, tail_node=our_node)
        
        result = tuple((node.state if node is not None else None) \
                       for node in result_in_nodes)
        
        return result
    
    
    @with_self
    def __get_state_by_monotonic_function_from_queue(
        self, function, value, rounding=binary_search.CLOSEST):
        '''
        Get a state from the queue only by measure function and desired value.
        
        The function must by a monotonic rising function on the timeline.
        
        See documentation of `garlicsim.general_misc.binary_search.roundings`
        for details about rounding options.
        '''
        assert issubclass(rounding, binary_search.Rounding)
        queue = self.cruncher.work_queue
        queue_as_list = queue_tools.queue_as_list(queue)
        # todo: Probably inefficient, should access them one by one
        
        return binary_search.binary_search\
               (queue_as_list, function, value, rounding)

    
    @with_self
    def __len__(self):
        '''
        Get the length of the timeline in nodes.
        
        This means the sum of:
        1. The length of the `.work_queue` of our cruncher.
        2. The length of the path in the tree which leads to our node, up to
           our node.
        '''
        queue_length = self.cruncher.work_queue.qsize()
        
        our_node = self.__get_our_node()
        our_path = our_node.make_containing_path()
        path_length = our_path.__len__(tail=our_node)
        
        return queue_length + path_length

    
    @with_self
    def __get_our_node(self):
        '''Get the node that the current cruncher is assigned to work on.'''
        jobs_to_crunchers = self.project.crunching_manager.crunchers.items()
        
        nodes_that_are_us = \
            [job.node for (job, cruncher) in jobs_to_crunchers \
             if cruncher == self.cruncher]
        
        num = len(nodes_that_are_us)
        assert num <= 1
        if num == 1:
            our_node = nodes_that_are_us[0]
        else: # num == 0
            raise ObsoleteCruncherError
        return our_node
        
    
########NEW FILE########
__FILENAME__ = job
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `Job` class.

See its documentation for more info.
'''

import garlicsim

# At bottom:
# from .crunching_profile import CrunchingProfile


class Job(object):
    '''
    A job of crunching the simulation from a given node.
        
    A job specifies a node and a crunching profile. It means we should crunch
    from `node` according to the cruncing profile.
    '''
    # todo: should there be other helpful methods here?
    
    def __init__(self, node, crunching_profile):
        
        assert isinstance(node, garlicsim.data_structures.Node)
        self.node = node
        '''The node from which we need to crunch.'''
        
        assert isinstance(crunching_profile, CrunchingProfile)
        self.crunching_profile = crunching_profile
        '''The crunching profile to be used for crunching.'''
        
        self.resulted_in_end = False
        '''
        Flag marking that the job has resulted in an end of the simulation.
        '''
  
        
    def is_done(self):
        '''
        Return whether the job is done, i.e. enough crunching has been done.
        '''
        return self.crunching_profile.state_satisfies(self.node.state) or \
               self.resulted_in_end
    
        
    def __repr__(self): #todo: ensure not subclass?
        '''
        Get a string representation of the job.
        
        Example output: 

            Job(node=<garlicsim.data_structures.node.Node with clock 17,
            untouched, blockful, crunched with life.State.step(<state>),
            at 0x20664b0>, crunching_profile=CrunchingProfile(clock_target=100,
            step_profile=life.State.step(<state>))
        '''
        # todo: too long, should shorten
        
        stuff = []
        stuff.append("node=%s" % self.node)
        stuff.append("crunching_profile=%s" % self.crunching_profile)
        temp = ", ".join(stuff)
        return ("Job(%s)" % temp)
    
    
from .crunching_profile import CrunchingProfile

########NEW FILE########
__FILENAME__ = end_marker
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `EndMarker` class.

See its documentation for more info.
'''


class EndMarker(object):
    '''
    A marker used by crunchers to say that the simulation reached its end.
    
    This is used only in endable simulations. When the step function raises a
    `WorldEnded` exception, signifying that the simulation has ended, the
    cruncher will place an `EndMarker` in the work queue. (Where otherwise
    states will be placed.)
    
    The crunching manager will recognize the `EndMarker` and put an `End` to 
    the timeline.
    '''
    # todo: should allow putting a message, given by the `WorldEnded`, that 
    # will be attached to the `End`.

########NEW FILE########
__FILENAME__ = obsolete_cruncher_error
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `ObsoleteCruncherError` exception.

See its documentation for more info.
'''

class ObsoleteCruncherError(BaseException):
    '''
    The cruncher that got this exception raised became obsolte.
    
    The cruncher is trying to do work, but in the meantime the main program
    decided that the work assigned to this cruncher is no longer wanted, and
    should therefore be stopped.
    '''
    # Inherits from BaseException because it is an exit exception    
    # todo: I heard that `BaseException.message` is deprecated! Problematic?
    # Maybe make `CuteBaseException`?

########NEW FILE########
__FILENAME__ = project
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `Project` class.

See its documentation for more information.
'''

from __future__ import with_statement

from garlicsim.general_misc import cute_iter_tools
import garlicsim.general_misc.read_write_lock
from garlicsim.general_misc.infinity import infinity
from garlicsim.general_misc import decorator_tools
from garlicsim.general_misc import misc_tools
from garlicsim.general_misc import address_tools

import garlicsim.data_structures
import garlicsim.misc.simpack_grokker
import garlicsim.misc.step_profile

from .crunching_manager import CrunchingManager
from .job import Job
from .crunching_profile import CrunchingProfile


__all__ = ['Project']


@decorator_tools.decorator
def with_tree_lock(method, *args, **kwargs):
    '''
    Decorator used in `Project`'s methods to acquire/release the tree lock.
    
    The tree lock will be acquired in write mode before calling the method, and
    released after the method is finished. (Note that it's a reentrant lock, so
    it may still be owned by the current thread after releasing.)
    '''
    self = args[0]
    with self.tree.lock.write:
        return method(*args, **kwargs)


class Project(object):
    '''
    A simulation project. This is the flagship class of `garlicsim`.
    
    You create a project when you want to do a simulation which will crunch
    in the background with worker threads or worker processes.

    A project contains within it a tree.
        
    The crunching is taken care of by the `CrunchingManager` which is a part of
    every project. The `CrunchingManager` employs crunchers (which may be, for
    example, worker threads or worker processes,) to get the work done. To make
    the crunching manager take work from the crunchers and coordinate them, 
    call the `.sync_crunchers` method of the project.
    
    The crunching manager contains a list of jobs as an attribute `.jobs`. See
    documentation for `garlicsim.asynchronous_crunching.Job` for more info 
    about jobs. The crunching manager will employ crunchers in order to 
    complete the jobs. It will then take work from these crunchers, put it 
    into the tree, and delete the jobs when they are completed.
    '''

    def __init__(self, simpack):
        
        if isinstance(simpack, garlicsim.misc.SimpackGrokker):
            # The user entered a simpack grokker instead of a simpack; let's be
            # nice and handle it.
            simpack_grokker = simpack
            simpack = simpack_grokker.simpack
            
            
        self.simpack = simpack
        '''The simpack determines what kind of simulation we're doing.'''
        
        self.simpack_grokker = garlicsim.misc.SimpackGrokker(simpack)
        '''Encapsulates our simpack and gives useful information and tools.'''

        self.tree = garlicsim.data_structures.Tree()
        '''The time tree in which we store all simulation states.'''
        
        self.crunching_manager = CrunchingManager(self)
        '''Crunching manager which recruits, manages and retires crunchers.'''
        
        self.default_step_function = self.simpack_grokker.default_step_function
        '''The step function that we use by default.'''
    

    def create_root(self, *args, **kwargs):
        '''
        Create a parentless node whose state is a simple plain state.
        
        The simulation package has to define the method `State.create_root` for
        this to work.
        
        Returns the node.
        '''
        state = self.simpack.State.create_root(*args, **kwargs)
        return self.root_this_state(state)

    
    def create_messy_root(self, *args, **kwargs):
        '''
        Creates a parentless node whose state is a random and messy state.
        
        The simulation package has to define the method
        `State.create_messy_root` for this to work.
        
        Returns the node.
        '''
        state = self.simpack.State.create_messy_root(*args, **kwargs)
        return self.root_this_state(state)

    
    def root_this_state(self, state):
        '''
        Take a state, wrap it in a node and add to the tree without a parent.
        
        Returns the node.
        '''
        return self.tree.add_state(state)

    
    def ensure_buffer(self, node, clock_buffer=0):
        '''
        Ensure there's a large enough buffer of nodes after `node`.

        This method will ensure that every path that starts at `node` will have
        a clock buffer of at least `clock_buffer` after `node`. If there isn't,
        the leaves of `node` will be crunched until there's a buffer of
        `clock_buffer` between `node` and each of the leaves.
        '''
        leaves_dict = node.get_all_leaves(max_clock_distance=clock_buffer)
        new_clock_target = node.state.clock + clock_buffer
        
        for leaf in leaves_dict.copy():
            if leaf.ends: # todo: Not every end should count.
                del leaves_dict[leaf]
        
        for item in leaves_dict.items():

            leaf = item[0]
            
            jobs_of_leaf = self.crunching_manager.get_jobs_by_node(leaf)
            
            if not jobs_of_leaf:
                step_profile = leaf.step_profile or \
                    self.build_step_profile()
                crunching_profile = CrunchingProfile(new_clock_target,
                                                     step_profile)
                job = Job(leaf, crunching_profile)
                self.crunching_manager.jobs.append(job)
                continue
            
            for job in jobs_of_leaf:
                job.crunching_profile.raise_clock_target(new_clock_target)
            
    
    def ensure_buffer_on_path(self, node, path, clock_buffer=0):
        '''
        Ensure there's a large enough buffer of nodes after `node` on `path`.

        This method will ensure that on the given path there will be a clock
        buffer of at least `clock_buffer` after `node`. If there isn't, the
        leaf at the end of the path will be crunched until the buffer is big
        enough.
        '''
        
        leaf = path.get_last_node(head=node)
        if leaf.ends: # todo: Not every end should count, I think.
            return
        
        new_clock_target = node.state.clock + clock_buffer     

        jobs_of_leaf = self.crunching_manager.get_jobs_by_node(leaf)
        
        if jobs_of_leaf:
            job = jobs_of_leaf[-1]
            # We only want to take one job. We're guessing the last, and 
            # therefore the most recent one, will be the most wanted by the
            # user.
            job.crunching_profile.raise_clock_target(new_clock_target)
            return job
        else:
            step_profile = leaf.step_profile or self.build_step_profile()
            crunching_profile = CrunchingProfile(new_clock_target,
                                                 step_profile)
            job = Job(leaf, crunching_profile)
            self.crunching_manager.jobs.append(job)
            return job

        
    def fork_to_edit(self, template_node):
        '''
        "Duplicate" the node, marking the new one as touched.
        
        The new node will have the same parent as `template_node`. The state of
        the new node is usually modified by the user after it is created, and
        after that the node is finalized and used in simulation.
        
        This is useful when you want to make some changes in the world state
        and see what they will cause in the simulation.
        
        Returns the node.
        '''
        return self.tree.fork_to_edit(template_node)

    
    def begin_crunching(self, node, clock_buffer, *args, **kwargs):
        '''
        Start a new crunching job from `node`, possibly forking the simulation.
        
        On the next call to `.sync_crunchers`, a cruncher will start working on
        the new job.
        
        If there are already jobs on that node, they will all be crunched
        independently of each other to create different forks.
        
        Any `*args` or `**kwargs` will be packed in a `StepProfile` and passed
        to the step function. You may pass a `StepProfile` yourself and it will
        be noticed and used.
        
        Returns the job.
        '''
        
        # todo: Inputting `clock_buffer=None` should produce infinitesimal
        # clock buffer.
        
        step_profile = self.build_step_profile(*args, **kwargs)
        
        clock_target = node.state.clock + clock_buffer
        
        crunching_profile = CrunchingProfile(clock_target, step_profile)
        
        job = Job(node, crunching_profile)
        
        self.crunching_manager.jobs.append(job)
        
        return job
    

    def sync_crunchers(self):
        '''
        Take work from the crunchers, and give them new instructions if needed.
        
        Talks with all the crunchers, takes work from them for implementing
        into the tree, retiring crunchers or recruiting new crunchers as
        necessary.

        Returns the total amount of nodes that were added to the tree in the
        process.
        '''        
        return self.crunching_manager.sync_crunchers()
    
    
    @with_tree_lock
    def simulate(self, node, iterations=1, *args, **kwargs):
        '''
        Simulate from the given node for the given number of iterations.
        
        The results are implemented the results into the tree. Note that the
        crunching for this is done synchronously, i.e. in the currrent thread.
        
        If you wish, in `*args` and `**kwargs` you may specify simulation
        parameters and/or a specific step function to use. (You may specify a
        step function either as the first positional argument or the
        `step_function` keyword argument.) You may also pass in an existing
        step profile.
        
        Returns the final node.
        '''
        # todo: is simulate a good name? Need to say it's synchronously
        
        step_profile = self.build_step_profile(*args, **kwargs)
        
        if self.simpack_grokker.history_dependent:
            return self.__history_dependent_simulate(node, iterations,
                                                     step_profile)
        else:
            return self.__non_history_dependent_simulate(node, iterations,
                                                         step_profile)
        
        
    @with_tree_lock        
    def __history_dependent_simulate(self, node, iterations,
                                     step_profile):
        '''
        Simulate from the given node for the given number of iterations.
        
        (Internal function for history-dependent simulations only.)
        
        The results are implemented the results into the tree. Note that the
        crunching for this is done synchronously, i.e. in the currrent thread.
        
        A step profile may be passed to be used with the step function.
        
        Returns the final node.
        '''
        
        step_profile = self.build_step_profile()
        
        path = node.make_containing_path()
        history_browser = garlicsim.synchronous_crunching.HistoryBrowser(
            path,
            tail_node=node
        )
        
        iterator = self.simpack_grokker.get_step_iterator(history_browser,
                                                          step_profile)
        finite_iterator = cute_iter_tools.shorten(iterator, iterations)
        
        current_node = node
        first_run = True
        try:
            for current_state in finite_iterator:
                current_node = self.tree.add_state(current_state,
                                                   parent=current_node,
                                                   step_profile=step_profile)
                history_browser.tail_node = current_node
                if first_run:
                    history_browser.path = current_node.make_containing_path()
                    # Just once, after the first run, we set the path of the
                    # history browser to be the new tail_node's path. Why?
                    
                    # Because just after the first run we've created the first
                    # new node, possibly causing a fork. Because of the new
                    # fork, the original path that we created at the beginning
                    # of this method will get confused and take the old
                    # timeline instead of the new timeline. (And it wouldn't
                    # even have the `tail_node` to stop it, because that would
                    # be on the new timeline.) So we create a new path for the
                    # history browser. We only need to do this once, because
                    # after the first node we work on one straight timeline and
                    # we don't fork the tree any more.
        
        except garlicsim.misc.WorldEnded:
            self.tree.make_end(current_node, step_profile)
            
        return current_node
    
    
    @with_tree_lock
    def __non_history_dependent_simulate(self, node, iterations,
                                         step_profile):
        '''
        Simulate from the given node for the given number of iterations.
        
        (Internal function for non-history-dependent simulations only.)
        
        The results are implemented the results into the tree. Note that the
        crunching for this is done synchronously, i.e. in the currrent thread.
        
        A step profile may be passed to be used with the step function.
        
        Returns the final node.
        '''
        
        state = node.state
                
        iterator = self.simpack_grokker.get_step_iterator(state, step_profile)
        finite_iterator = cute_iter_tools.shorten(iterator, iterations)
        
        current_node = node
        
        try:
            for current_state in finite_iterator:
                current_node = self.tree.add_state(current_state,
                                                   parent=current_node,
                                                   step_profile=step_profile)
        except garlicsim.misc.WorldEnded:
            self.tree.make_end(current_node, step_profile)
            
        return current_node
    
    
    def iter_simulate(self, node, iterations=1, *args, **kwargs):
        '''
        Simulate from the given node for the given number of iterations.
        
        The results are implemented into the tree. Note that the crunching for
        this is done synchronously, i.e. in the currrent thread.
        
        This returns a generator that yields all the nodes one-by-one, from the
        initial node to the final one.
            
        If you wish, in `*args` and `**kwargs` you may specify simulation
        parameters and/or a specific step function to use. (You may specify a
        step function either as the first positional argument or the
        `step_function` keyword argument.) You may also pass in an existing
        step profile.
        '''
        
        step_profile = self.build_step_profile(*args, **kwargs)
        
        if self.simpack_grokker.history_dependent:
            return self.__history_dependent_iter_simulate(node, iterations,
                                                          step_profile)
        else:
            return self.__non_history_dependent_iter_simulate(node, iterations,
                                                              step_profile)
        
                
    def __history_dependent_iter_simulate(self, node, iterations,
                                          step_profile):
        '''
        Simulate from the given node for the given number of iterations.
        
        (Internal function for history-dependent simulations only.)
        
        The results are implemented into the tree. Note that the crunching for
        this is done synchronously, i.e. in the currrent thread.
        
        This returns a generator that yields all the nodes one-by-one, from the
        initial node to the final one.
        
        A step profile may be passed to be used with the step function.
        '''
        
        path = node.make_containing_path()
        history_browser = garlicsim.synchronous_crunching.HistoryBrowser(
            path,
            tail_node=node
        )
        
        iterator = self.simpack_grokker.get_step_iterator(history_browser,
                                                          step_profile)
        finite_iterator = cute_iter_tools.shorten(iterator, iterations)
        finite_iterator_with_lock = cute_iter_tools.iter_with(
            finite_iterator,
            self.tree.lock.write
        )
        
        current_node = node
        
        yield current_node
        
        try:
            for current_state in finite_iterator_with_lock:
                                
                current_node = self.tree.add_state(current_state,
                                                   parent=current_node,
                                                   step_profile=step_profile)
                
                history_browser.tail_node = current_node
                history_browser.path = current_node.make_containing_path()
                # Similarly to the `__history_dependent_simulate` method, here
                # we also need to recreate the path. But in this case we need
                # to do it not only on the first run, but on *each* run of the
                # loop, because this is a generator, and the user may wreak
                # havoc with the tree between `yield`s, causing our original
                # path not to lead to the `tail_node` anymore.
                
                # todo optimize: The fact we recreate a path every time might
                # be costly.
                    
                yield current_node
        
        except garlicsim.misc.WorldEnded:
            self.tree.make_end(current_node, step_profile)
                
    
    def __non_history_dependent_iter_simulate(self, node, iterations,
                                              step_profile=None):
        '''
        Simulate from the given node for the given number of iterations.
        
        (Internal function for non-history-dependent simulations only.)
        
        The results are implemented into the tree. Note that the crunching for
        this is done synchronously, i.e. in the currrent thread.
        
        This returns a generator that yields all the nodes one-by-one, from the
        initial node to the final one.
        
        A step profile may be passed to be used with the step function.
        '''

        state = node.state
                
        iterator = self.simpack_grokker.get_step_iterator(state, step_profile)
        finite_iterator = cute_iter_tools.shorten(iterator, iterations)
        finite_iterator_with_lock = cute_iter_tools.iter_with(
            finite_iterator,
            self.tree.lock.write
        )
        
        current_node = node
        
        yield current_node
        
        try:
            for current_state in finite_iterator_with_lock:
                current_node = self.tree.add_state(current_state,
                                                   parent=current_node,
                                                   step_profile=step_profile)
                yield current_node
        
        except garlicsim.misc.WorldEnded:
            self.tree.make_end(current_node, step_profile)
            
    
    def __getstate__(self):
        project_vars = dict(vars(self))
        
        del project_vars['crunching_manager']
        del project_vars['simpack_grokker']
        
        project_vars['___cruncher_type_of_crunching_manager'] = \
            self.crunching_manager.cruncher_type
        
        return project_vars
    
    
    def __setstate__(self, project_vars):
        self.__init__(project_vars["simpack"])
        self.__dict__.update(project_vars)
        self.crunching_manager.cruncher_type = \
            project_vars['___cruncher_type_of_crunching_manager']
            
        
        
    def __repr__(self):
        '''
        Get a string representation of the project.
        
        Example output:
        
        <garlicsim.Project containing 101 nodes and employing 4 crunchers at
        0x1f668d0>
        '''
        # Todo: better have the simpack mentioned here
        
        # todo: show cruncher types, even listing for different types if there
        # are different types. Length is not a problem because this is a rare
        # condition.
        
        nodes_count = len(self.tree.nodes)
        crunchers_count = len(self.crunching_manager.crunchers)
                                   
        return '<%s containing %s nodes and employing %s crunchers at %s>' % \
               (
                   address_tools.describe(type(self), shorten=True),
                   nodes_count,
                   crunchers_count,
                   hex(id(self))
               )
        
    
    def build_step_profile(self, *args, **kwargs):
        '''
        Build a step profile smartly.
        
        The canonical way to build a step profile is to provide it with a step
        function, `*args` and `**kwargs`. But in this function we're being a
        little smarter so the user will have less work.
        
        You do not need to enter a step function; we will use the default one,
        unless you specify a different one as `step_function`.
        
        You may also pass in a step profile as `step_profile`, and it will be
        noticed and used.
        '''
        # We are providing this method despite the fact that the simpack
        # grokker already provides a `.build_step_profile` method; this is
        # because here we are using the *project's* default step function,
        # which the user is allowed to change.
        parse_arguments_to_step_profile = \
            garlicsim.misc.StepProfile.build_parser(
                self.default_step_function
            )
        
        step_profile = parse_arguments_to_step_profile(*args, **kwargs)
        return step_profile
        
        
        
        
########NEW FILE########
__FILENAME__ = bootstrap
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
A bootstrap module for garlicsim.

It checks all prerequisites are installed.
'''

import sys

### Confirming correct Python version: ########################################
#                                                                             #
if sys.version_info[0] >= 3:
    raise Exception('This package is not compatible with Python 3.x. Use '
                    '`garlicsim_py3` instead.')
if sys.version_info[1] <= 4:
    raise Exception('This package requires Python 2.5 and upwards. (Not '
                    'including 3.x).')
#                                                                             #
### Finished confirming correct Python version. ###############################


frozen = getattr(sys, 'frozen', None)


def __check_prerequisites():
    '''
    Check that all modules required for `garlicsim` are installed.
    
    Returns a list of some imported modules: A reference to this list should be
    kept alive so to prevent the imported modules from being garbage-collected,
    which would cause Python to load them twice, which would needlessly
    increase startup time.
    '''
    
    modules = []
    
    class MissingModule(Exception):
        '''A required module is not found.'''
    
    def check_pkg_resources():
        try:
            import pkg_resources
        except ImportError:
            raise MissingModule("`pkg_resources` is required, but it's not "
                                "currently installed on your system. It comes "
                                "with `distribute`, so please install it "
                                "according to the instructions here: "
                                "pypi.python.org/pypi/distribute")
        else:
            return [pkg_resources]
    
    def check_distribute():
        if frozen:
            # Can't check that `distribute` is installed when frozen with
            # `py2exe`.
            return []
        import pkg_resources
        try:
            pkg_resources.require('distribute')
        except pkg_resources.DistributionNotFound:
            raise MissingModule("`distribute` is required, but it's not "
                                "currently installed on your system. Please "
                                "install it according to the instructions "
                                "here: pypi.python.org/pypi/distribute")
        else:
             # Returning empty list because we didn't import `distribute`:
            return []
        
    checkers = [check_pkg_resources, check_distribute]
    
    for checker in checkers:
        modules += checker()
    
    return modules


def __check_problematic_psyco_version():
    if 'psyco' in sys.modules:
        psyco = sys.modules['psyco']
        if psyco.version_info[0] >= 2:
            import warnings
            warnings.warn("You seem to have Psyco version 2 (or newer) "
                          "installed. It might conflict with `garlicsim`, so "
                          "you may want to avoid using it. Psyco version 1.6 "
                          "is fine and recommended.")

__modules_list = __check_prerequisites()

__check_problematic_psyco_version()


########NEW FILE########
__FILENAME__ = python26_site
"""Append module search paths for third-party packages to sys.path.

****************************************************************
* This module is automatically imported during initialization. *
****************************************************************

In earlier versions of Python (up to 1.5a3), scripts or modules that
needed to use site-specific modules would place ``import site''
somewhere near the top of their code.  Because of the automatic
import, this is no longer necessary (but code that does it still
works).

This will append site-specific paths to the module search path.  On
Unix (including Mac OSX), it starts with sys.prefix and
sys.exec_prefix (if different) and appends
lib/python<version>/site-packages as well as lib/site-python.
On other platforms (such as Windows), it tries each of the
prefixes directly, as well as with lib/site-packages appended.  The
resulting directories, if they exist, are appended to sys.path, and
also inspected for path configuration files.

A path configuration file is a file whose name has the form
<package>.pth; its contents are additional directories (one per line)
to be added to sys.path.  Non-existing directories (or
non-directories) are never added to sys.path; no directory is added to
sys.path more than once.  Blank lines and lines beginning with
'#' are skipped. Lines starting with 'import' are executed.

For example, suppose sys.prefix and sys.exec_prefix are set to
/usr/local and there is a directory /usr/local/lib/python2.5/site-packages
with three subdirectories, foo, bar and spam, and two path
configuration files, foo.pth and bar.pth.  Assume foo.pth contains the
following:

  # foo package configuration
  foo
  bar
  bletch

and bar.pth contains:

  # bar package configuration
  bar

Then the following directories are added to sys.path, in this order:

  /usr/local/lib/python2.5/site-packages/bar
  /usr/local/lib/python2.5/site-packages/foo

Note that bletch is omitted because it doesn't exist; bar precedes foo
because bar.pth comes alphabetically before foo.pth; and spam is
omitted because it is not mentioned in either path configuration file.

After these path manipulations, an attempt is made to import a module
named sitecustomize, which can perform arbitrary additional
site-specific customizations.  If this import fails with an
ImportError exception, it is silently ignored.

"""

import sys
import os
import __builtin__

# Prefixes for site-packages; add additional prefixes like /usr/local here
PREFIXES = [sys.prefix, sys.exec_prefix]
# Enable per user site-packages directory
# set it to False to disable the feature or True to force the feature
ENABLE_USER_SITE = None
# for distutils.commands.install
USER_SITE = None
USER_BASE = None


def makepath(*paths):
    dir = os.path.abspath(os.path.join(*paths))
    return dir, os.path.normcase(dir)


def abs__file__():
    """Set all module' __file__ attribute to an absolute path"""
    for m in sys.modules.values():
        if hasattr(m, '__loader__'):
            continue   # don't mess with a PEP 302-supplied __file__
        try:
            m.__file__ = os.path.abspath(m.__file__)
        except AttributeError:
            continue


def removeduppaths():
    """ Remove duplicate entries from sys.path along with making them
    absolute"""
    # This ensures that the initial path provided by the interpreter contains
    # only absolute pathnames, even if we're running from the build directory.
    L = []
    known_paths = set()
    for dir in sys.path:
        # Filter out duplicate paths (on case-insensitive file systems also
        # if they only differ in case); turn relative paths into absolute
        # paths.
        dir, dircase = makepath(dir)
        if not dircase in known_paths:
            L.append(dir)
            known_paths.add(dircase)
    sys.path[:] = L
    return known_paths

# XXX This should not be part of site.py, since it is needed even when
# using the -S option for Python.  See http://www.python.org/sf/586680
def addbuilddir():
    """Append ./build/lib.<platform> in case we're running in the build dir
    (especially for Guido :-)"""
    from distutils.util import get_platform
    s = "build/lib.%s-%.3s" % (get_platform(), sys.version)
    if hasattr(sys, 'gettotalrefcount'):
        s += '-pydebug'
    s = os.path.join(os.path.dirname(sys.path[-1]), s)
    sys.path.append(s)


def _init_pathinfo():
    """Return a set containing all existing directory entries from sys.path"""
    d = set()
    for dir in sys.path:
        try:
            if os.path.isdir(dir):
                dir, dircase = makepath(dir)
                d.add(dircase)
        except TypeError:
            continue
    return d


def addpackage(sitedir, name, known_paths):
    """Process a .pth file within the site-packages directory:
       For each line in the file, either combine it with sitedir to a path
       and add that to known_paths, or execute it if it starts with 'import '.
    """
    if known_paths is None:
        _init_pathinfo()
        reset = 1
    else:
        reset = 0
    fullname = os.path.join(sitedir, name)
    try:
        f = open(fullname, "rU")
    except IOError:
        return
    with f:
        for line in f:
            if line.startswith("#"):
                continue
            if line.startswith(("import ", "import\t")):
                exec line
                continue
            line = line.rstrip()
            dir, dircase = makepath(sitedir, line)
            if not dircase in known_paths and os.path.exists(dir):
                sys.path.append(dir)
                known_paths.add(dircase)
    if reset:
        known_paths = None
    return known_paths


def addsitedir(sitedir, known_paths=None):
    """Add 'sitedir' argument to sys.path if missing and handle .pth files in
    'sitedir'"""
    if known_paths is None:
        known_paths = _init_pathinfo()
        reset = 1
    else:
        reset = 0
    sitedir, sitedircase = makepath(sitedir)
    if not sitedircase in known_paths:
        sys.path.append(sitedir)        # Add path component
    try:
        names = os.listdir(sitedir)
    except os.error:
        return
    dotpth = os.extsep + "pth"
    names = [name for name in names if name.endswith(dotpth)]
    for name in sorted(names):
        addpackage(sitedir, name, known_paths)
    if reset:
        known_paths = None
    return known_paths


def check_enableusersite():
    """Check if user site directory is safe for inclusion

    The function tests for the command line flag (including environment var),
    process uid/gid equal to effective uid/gid.

    None: Disabled for security reasons
    False: Disabled by user (command line option)
    True: Safe and enabled
    """
    if sys.flags.no_user_site:
        return False

    if hasattr(os, "getuid") and hasattr(os, "geteuid"):
        # check process uid == effective uid
        if os.geteuid() != os.getuid():
            return None
    if hasattr(os, "getgid") and hasattr(os, "getegid"):
        # check process gid == effective gid
        if os.getegid() != os.getgid():
            return None

    return True


def addusersitepackages(known_paths):
    """Add a per user site-package to sys.path

    Each user has its own python directory with site-packages in the
    home directory.

    USER_BASE is the root directory for all Python versions

    USER_SITE is the user specific site-packages directory

    USER_SITE/.. can be used for data.
    """
    global USER_BASE, USER_SITE, ENABLE_USER_SITE
    env_base = os.environ.get("PYTHONUSERBASE", None)

    def joinuser(*args):
        return os.path.expanduser(os.path.join(*args))

    #if sys.platform in ('os2emx', 'riscos'):
    #    # Don't know what to put here
    #    USER_BASE = ''
    #    USER_SITE = ''
    if os.name == "nt":
        base = os.environ.get("APPDATA") or "~"
        USER_BASE = env_base if env_base else joinuser(base, "Python")
        USER_SITE = os.path.join(USER_BASE,
                                 "Python" + sys.version[0] + sys.version[2],
                                 "site-packages")
    else:
        USER_BASE = env_base if env_base else joinuser("~", ".local")
        USER_SITE = os.path.join(USER_BASE, "lib",
                                 "python" + sys.version[:3],
                                 "site-packages")

    if ENABLE_USER_SITE and os.path.isdir(USER_SITE):
        addsitedir(USER_SITE, known_paths)
    return known_paths


def addsitepackages(known_paths):
    """Add site-packages (and possibly site-python) to sys.path"""
    sitedirs = []
    seen = []

    for prefix in PREFIXES:
        if not prefix or prefix in seen:
            continue
        seen.append(prefix)

        if sys.platform in ('os2emx', 'riscos'):
            sitedirs.append(os.path.join(prefix, "Lib", "site-packages"))
        elif os.sep == '/':
            sitedirs.append(os.path.join(prefix, "lib",
                                        "python" + sys.version[:3],
                                        "site-packages"))
            sitedirs.append(os.path.join(prefix, "lib", "site-python"))
        else:
            sitedirs.append(prefix)
            sitedirs.append(os.path.join(prefix, "lib", "site-packages"))

        if sys.platform == "darwin":
            # for framework builds *only* we add the standard Apple
            # locations. Currently only per-user, but /Library and
            # /Network/Library could be added too
            if 'Python.framework' in prefix:
                sitedirs.append(
                    os.path.expanduser(
                        os.path.join("~", "Library", "Python",
                                     sys.version[:3], "site-packages")))

    for sitedir in sitedirs:
        if os.path.isdir(sitedir):
            addsitedir(sitedir, known_paths)

    return known_paths


def setBEGINLIBPATH():
    """The OS/2 EMX port has optional extension modules that do double duty
    as DLLs (and must use the .DLL file extension) for other extensions.
    The library search path needs to be amended so these will be found
    during module import.  Use BEGINLIBPATH so that these are at the start
    of the library search path.

    """
    dllpath = os.path.join(sys.prefix, "Lib", "lib-dynload")
    libpath = os.environ['BEGINLIBPATH'].split(';')
    if libpath[-1]:
        libpath.append(dllpath)
    else:
        libpath[-1] = dllpath
    os.environ['BEGINLIBPATH'] = ';'.join(libpath)


def setquit():
    """Define new built-ins 'quit' and 'exit'.
    These are simply strings that display a hint on how to exit.

    """
    if os.sep == ':':
        eof = 'Cmd-Q'
    elif os.sep == '\\':
        eof = 'Ctrl-Z plus Return'
    else:
        eof = 'Ctrl-D (i.e. EOF)'

    class Quitter(object):
        def __init__(self, name):
            self.name = name
        def __repr__(self):
            return 'Use %s() or %s to exit' % (self.name, eof)
        def __call__(self, code=None):
            # Shells like IDLE catch the SystemExit, but listen when their
            # stdin wrapper is closed.
            try:
                sys.stdin.close()
            except:
                pass
            raise SystemExit(code)
    __builtin__.quit = Quitter('quit')
    __builtin__.exit = Quitter('exit')


class _Printer(object):
    """interactive prompt objects for printing the license text, a list of
    contributors and the copyright notice."""

    MAXLINES = 23

    def __init__(self, name, data, files=(), dirs=()):
        self.__name = name
        self.__data = data
        self.__files = files
        self.__dirs = dirs
        self.__lines = None

    def __setup(self):
        if self.__lines:
            return
        data = None
        for dir in self.__dirs:
            for filename in self.__files:
                filename = os.path.join(dir, filename)
                try:
                    fp = file(filename, "rU")
                    data = fp.read()
                    fp.close()
                    break
                except IOError:
                    pass
            if data:
                break
        if not data:
            data = self.__data
        self.__lines = data.split('\n')
        self.__linecnt = len(self.__lines)

    def __repr__(self):
        self.__setup()
        if len(self.__lines) <= self.MAXLINES:
            return "\n".join(self.__lines)
        else:
            return "Type %s() to see the full %s text" % ((self.__name,)*2)

    def __call__(self):
        self.__setup()
        prompt = 'Hit Return for more, or q (and Return) to quit: '
        lineno = 0
        while 1:
            try:
                for i in range(lineno, lineno + self.MAXLINES):
                    print self.__lines[i]
            except IndexError:
                break
            else:
                lineno += self.MAXLINES
                key = None
                while key is None:
                    key = raw_input(prompt)
                    if key not in ('', 'q'):
                        key = None
                if key == 'q':
                    break

def setcopyright():
    """Set 'copyright' and 'credits' in __builtin__"""
    __builtin__.copyright = _Printer("copyright", sys.copyright)
    if sys.platform[:4] == 'java':
        __builtin__.credits = _Printer(
            "credits",
            "Jython is maintained by the Jython developers (www.jython.org).")
    else:
        __builtin__.credits = _Printer("credits", """\
    Thanks to CWI, CNRI, BeOpen.com, Zope Corporation and a cast of thousands
    for supporting Python development.  See www.python.org for more information.""")
    here = os.path.dirname(os.__file__)
    __builtin__.license = _Printer(
        "license", "See http://www.python.org/%.3s/license.html" % sys.version,
        ["LICENSE.txt", "LICENSE"],
        [os.path.join(here, os.pardir), here, os.curdir])


class _Helper(object):
    """Define the built-in 'help'.
    This is a wrapper around pydoc.help (with a twist).

    """

    def __repr__(self):
        return "Type help() for interactive help, " \
               "or help(object) for help about object."
    def __call__(self, *args, **kwds):
        import pydoc
        return pydoc.help(*args, **kwds)

def sethelper():
    __builtin__.help = _Helper()

def aliasmbcs():
    """On Windows, some default encodings are not provided by Python,
    while they are always available as "mbcs" in each locale. Make
    them usable by aliasing to "mbcs" in such a case."""
    if sys.platform == 'win32':
        import locale, codecs
        enc = locale.getdefaultlocale()[1]
        if enc.startswith('cp'):            # "cp***" ?
            try:
                codecs.lookup(enc)
            except LookupError:
                import encodings
                encodings._cache[enc] = encodings._unknown
                encodings.aliases.aliases[enc] = 'mbcs'

def setencoding():
    """Set the string encoding used by the Unicode implementation.  The
    default is 'ascii', but if you're willing to experiment, you can
    change this."""
    encoding = "ascii" # Default value set by _PyUnicode_Init()
    if 0:
        # Enable to support locale aware default string encodings.
        import locale
        loc = locale.getdefaultlocale()
        if loc[1]:
            encoding = loc[1]
    if 0:
        # Enable to switch off string to Unicode coercion and implicit
        # Unicode to string conversion.
        encoding = "undefined"
    if encoding != "ascii":
        # On Non-Unicode builds this will raise an AttributeError...
        sys.setdefaultencoding(encoding) # Needs Python Unicode build !


def execsitecustomize():
    """Run custom site specific code, if available."""
    try:
        import sitecustomize
    except ImportError:
        pass
    except Exception:
        if sys.flags.verbose:
            sys.excepthook(*sys.exc_info())
        else:
            print >>sys.stderr, \
                "'import sitecustomize' failed; use -v for traceback"


def execusercustomize():
    """Run custom user specific code, if available."""
    try:
        import usercustomize
    except ImportError:
        pass
    except Exception:
        if sys.flags.verbose:
            sys.excepthook(*sys.exc_info())
        else:
            print>>sys.stderr, \
                "'import usercustomize' failed; use -v for traceback"


def main():
    global ENABLE_USER_SITE

    abs__file__()
    known_paths = removeduppaths()
    if (os.name == "posix" and sys.path and
        os.path.basename(sys.path[-1]) == "Modules"):
        addbuilddir()
    if ENABLE_USER_SITE is None:
        ENABLE_USER_SITE = check_enableusersite()
    known_paths = addusersitepackages(known_paths)
    known_paths = addsitepackages(known_paths)
    if sys.platform == 'os2emx':
        setBEGINLIBPATH()
    setquit()
    setcopyright()
    sethelper()
    aliasmbcs()
    setencoding()
    execsitecustomize()
    if ENABLE_USER_SITE:
        execusercustomize()
    # Remove sys.setdefaultencoding() so that users cannot change the
    # encoding after initialization.  The test for presence is needed when
    # this module is run as a script, because this code is executed twice.
    if hasattr(sys, "setdefaultencoding"):
        del sys.setdefaultencoding

main()

def _script():
    help = """\
    %s [--user-base] [--user-site]

    Without arguments print some useful information
    With arguments print the value of USER_BASE and/or USER_SITE separated
    by '%s'.

    Exit codes with --user-base or --user-site:
      0 - user site directory is enabled
      1 - user site directory is disabled by user
      2 - uses site directory is disabled by super user
          or for security reasons
     >2 - unknown error
    """
    args = sys.argv[1:]
    if not args:
        print "sys.path = ["
        for dir in sys.path:
            print "    %r," % (dir,)
        print "]"
        print "USER_BASE: %r (%s)" % (USER_BASE,
            "exists" if os.path.isdir(USER_BASE) else "doesn't exist")
        print "USER_SITE: %r (%s)" % (USER_SITE,
            "exists" if os.path.isdir(USER_SITE) else "doesn't exist")
        print "ENABLE_USER_SITE: %r" %  ENABLE_USER_SITE
        sys.exit(0)

    buffer = []
    if '--user-base' in args:
        buffer.append(USER_BASE)
    if '--user-site' in args:
        buffer.append(USER_SITE)

    if buffer:
        print os.pathsep.join(buffer)
        if ENABLE_USER_SITE:
            sys.exit(0)
        elif ENABLE_USER_SITE is False:
            sys.exit(1)
        elif ENABLE_USER_SITE is None:
            sys.exit(2)
        else:
            sys.exit(3)
    else:
        import textwrap
        print textwrap.dedent(help % (sys.argv[0], os.pathsep))
        sys.exit(10)

if __name__ == '__main__':
    _script()

########NEW FILE########
__FILENAME__ = block
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
A module that Defines the `Block` class and the related BlockError exception.

See the documentation of Block for more information.
'''

from garlicsim.general_misc import logic_tools
from garlicsim.general_misc import misc_tools
from garlicsim.general_misc import address_tools

from garlicsim.misc import GarlicSimException

from .tree_member import TreeMember
# from .node import Node (at bottom of file.)


__all__ = ['Block', 'BlockError']


class BlockError(GarlicSimException):
    '''Block-related exception.'''

    
class Block(TreeMember):
    '''
    Succession of similar natural nodes in the tree.
    
    Blocks make the tree more organized and easy to browse, and improve
    performance.

    When you're doing a simulation, often you'll have a succession of 1000+
    natural nodes, which were created "organically", each from its parent,
    by simulation. Having a block to group these nodes together imporves
    efficiency.

    Who qualifies to get wrapped in a block? A succession of untouched nodes,
    which:
        1. Is at least 2 nodes in number.
        2. All members, except the last one, must have no ends, and no
           children except their successor in the block.
        3. The last node may have any kinds of children and ends.
        4. All members share the same `.step_profile`.

    If you want to check whether a certain node is in a block or not,
    check its `.block` attribute.

    '''
    # todo: Possibly add a `children` property that will get from the last
    # node. Will simplify a lot of code. (Possibly `parent` too.)
    
    def __init__(self, node_list):
        '''Construct a block from the members of `node_list`.'''
        
        self.alive = True
        '''Flag saying whether this block is alive.'''
        
        self.step_profile = None
        '''Step profile with which all the nodes in the block were crunched.'''
        
        self.__node_list = []
        self.add_node_list(node_list)

        
    def soft_get_block(self):
        '''Get the block.'''
        return self
    
    
    def append_node(self, node):
        '''
        Append a single node to the block.
        
        If the block's node list is empty, the node will be added
        unconditionally. If the node list contains some nodes, the new node
        must be either a child of the last node or the parent of the first one.
        '''
        
        assert self.alive
        
        if not self.__node_list:
            # If the node list is `[]`, let's make it `[node]`.
            self.__node_list.append(node)
            node.block = self
            self.step_profile = node.step_profile
            return
        
        if node.step_profile != self.step_profile:
            raise BlockError('Tried to add node which has a different step '
                             'profile.')
            
        
        # If the flow reached here, the block is not empty.
        last_in_block = self.__node_list[-1]
        if node.parent == last_in_block:
            # We're appending the node to the tail of the block.
            self.__node_list.append(node)
            node.block = self
            return
        
        first_in_block = self.__node_list[0]
        if node == first_in_block.parent:
            # We're appending the node to the head of the block.
            self.__node_list.insert(0, node)
            node.block = self
            return
        
        raise BlockError('Tried to add a node which is not a direct '
                         'successor or a direct ancestor of the block.')

    
    def add_node_list(self, node_list):
        '''
        Add a list of nodes to the block.
        
        These nodes must already be successive to each other.
        
        Also, one of the following conditions must be true:
        
            1. The first node in the list is a child of the last node in the
               block.
               
            2. The last node in the list is the parent of the first node in
               the block.
        '''
        
        assert self.alive
        
        if not node_list:
            return
        
        if len(node_list) == 1:
            self.append_node(node_list[0])
            return
        
        if not logic_tools.all_equal((node.step_profile for node
                                      in node_list)):
            raise BlockError("Tried to add node list that doesn't share the "
                             "same step profile.")
        
        sample_step_profile = node_list[0].step_profile
        
        if self.__node_list and \
           sample_step_profile != self.step_profile:
            raise BlockError('Tried to add node list which contains node that '
                             'has a different step profile.')
        
        # We now make sure the node_list is successive, untouched, and has no
        # unwanted children.
        for i in xrange(len(node_list)):
            if (i >= 1) and (node_list[i].parent != node_list[i-1]):
                raise BlockError('Tried to add non-consecutive nodes to block.')
            if (len(node_list) - i >= 2) and (len(node_list[i].children) != 1):
                raise BlockError("Tried to add to the block a node which "
                                 "doesn't have exactly one child, and not as "
                                 "the last node in the block.")
            if node_list[i].touched:
                raise BlockError('Tried to add touched nodes to block.')
        
        if not self.__node_list:
            # If the node list is empty, our job is simple.
            self.__node_list = list(node_list)
            for node in node_list:
                node.block = self
            self.step_profile = sample_step_profile
            return
        
        if node_list[0].parent == self.__node_list[-1]:
            self.__node_list = self.__node_list + node_list
        elif self.__node_list[0].parent == node_list[-1]:
            self.__node_list = node_list + self.__node_list
        else:
            raise BlockError('List of nodes is not adjacent to existing nodes.')

        for node in node_list:
            node.block = self

            
    def split(self, node):
        '''
        Split the block into two blocks.
        
        `node` would be the last node of the first block of the two. If either
        of the new blocks will contain just one node, that block will get
        deleted and the single node will become blockless.
        '''
        assert self.alive
        assert node in self
        i = self.__node_list.index(node)
        second_list = self.__node_list[i+1:]
        self.__node_list = self.__node_list[:i+1]
        if len(second_list) >= 2:
            Block(second_list)
        else:
            for node in second_list:
                node.block = None
        if len(self.__node_list) <= 1:
            self.delete()


    def delete(self):
        '''Delete the block, leaving all its nodes without a block.'''
        assert self.alive
        for node in self:
            node.block = None
        self.__node_list = []
        self.alive = False

        
    def __delitem__(self, i):
        '''
        Remove a node or a slice of nodes from the block.
        
        Nodes are specified by index number, whether you're removing a single
        node or a slice of them.
        
        When removing a single node, only an edge node can be removed.
        
        Can only remove an edge node.        
        '''
        # todo: allow removing nodes from middle
        # todo: change argument name `i` and seperate to two methods.
        # todo: allow specifying by nodes instead of numbers, both in slices
        # and in single.
        assert self.alive
        
        if isinstance(i, int):
            if (i == 0) or (i == -1) or \
               (i == len(self) - 1) or (i == -len(self)):
                self.__node_list[i].block = None
                return self.__node_list.__delitem__(i)
            elif (-len(self) < i < len(self) - 1):
                    raise BlockError("Can't remove a node from the middle of "
                                     "a block")
            else:
                raise IndexError("Tried to remove a node by index, while the "
                                 "index was bigger than the block's length.")
        
        elif isinstance(i, slice):
            if i.start < 0:
                i.start += len(self)
            if i.stop < 0:
                i.stop += len(self)
            
            assert 0 <= i.start <= i.stop < len(self)
            
            head_node, tail_node = [self[index] for index in (i.start, i.stop)]
            
            self.split(tail_node)

            if self.alive is False:                
                return
            
            if i.start >= 1:
                self.split(head_node.parent)
                
            if head_node.block is not None:
                head_node.block.delete()
            
        else:
            raise NotImplementedError

    
    def __contains__(self, thing):
        '''Return whether `thing` is a node which this block contains.'''
        # The argument is called `thing` and not `node` because we want to let
        # people put a block in, and we'll just give them False. Saves them
        # checking themselves if what they got is a node.
        assert self.alive
        return isinstance(thing, Node) and thing.block is self

    
    def __iter__(self):
        '''Iterate over the nodes in the block.'''
        assert self.alive
        return self.__node_list.__iter__()

    
    def __len__(self):
        '''Return the number of nodes in the block.'''
        assert self.alive
        return len(self.__node_list)

    
    def __getitem__(self, index):
        '''Get a node by index number from the block'''
        assert self.alive
        return self.__node_list.__getitem__(index)
    
    
    # def __getslice__(self, *args, **kwargs): #todo: can drop because of getitem?
    #     return self.__node_list.__getslice__(*args, **kwargs)

    
    def index(self, node):
        '''Get the index number of the specified node in the block.'''
        assert self.alive
        return self.__node_list.index(node)
    
    
    def is_overlapping(self, tree_member):
        '''
        Return whether this block overlaps with the given tree member.
        
        `tree_member` may be a block, in which case overlapping means being the
        same block. `tree_member` can also be a node, in which case overlapping
        means the node is contained in this block.
        '''
        assert self.alive
        
        if tree_member is None: return False
        if isinstance(tree_member, Block):
            return (self is tree_member)
        else:
            assert isinstance(tree_member, Node)
            return (tree_member in self)
    
    
    def make_containing_path(self):
        '''
        Create a path that contains this block.
        
        There may be multiple different paths that contain this block. This
        will return the one which points to the newest possible forks.
        
        Returns the path.
        '''
        return self[0].make_containing_path()
        
    
    
    def all_possible_paths(self):
        '''
        Get a list of all possible paths that contain this block.
        
        Note: There may be paths that contain this node which will not be
        identical to one of the paths given here, because these other paths may
        specify decisions that are not even on the same root as these paths.
        '''
        return self[0].all_possible_paths()
    
    
    
    def make_past_path(self):
        '''
        Create a path that contains this block.
        
        There may be multiple different paths that contain this node. This will
        return a path that doesn't specify any decisions after this node.
        '''
        return self[0].make_past_path()


    
    def get_all_leaves(self, max_nodes_distance=None, max_clock_distance=None):
        '''
        Get all leaves that are descendents of this block.
        
        Only leaves with a distance of at most `max_nodes_distance` in nodes or
        `max_clock_distance` in clock are returned. (Note this is an OR
        relation between the two condintions)
        
        Returns a dict of the form:
        
        {
            leaf1: {
                'nodes_distance': nodes_distance1,
                'clock_distance': clock_distance1,
            },            
            leaf2: {
                'nodes_distance': nodes_distance2,
                'clock_distance': clock_distance2,
            },
            # ...
        }
            
        '''
        return self[-1].make_containing_path(max_nodes_distance,
                                             max_clock_distance)

    
    
    def get_ancestor(self, generations=1, round=False):
        '''
        Get an ancestor of this block.
        
        `generations` specifies the number of generation that the returned
        ancestor should be above the current block. `round` determines how this
        method will behave if it was asked for too many generations back, and
        not enough existed. If `round` is `True`, it will return the root. If
        `round` is `False`, it will raise a `NodeLookupError`.
        '''
        return self[0].get_ancestor(generations, round)

    
    def get_root(self):
        '''
        Get the root of this block.
        
        This means the node which is the parent of the parent of the parent
        of... the parent of this block.
        '''
        return self[0].get_root()

    
    def __repr__(self):
        '''
        Get a string representation of the block.
        
        Example output:
        <garlicsim.data_structures.Block of length 40 crunched with
        life.State.step(<state>), t=0.1) at 0x1c84d70>
        '''
        assert self.alive # todo: say "Dead block"
        return '<%s of length %s, crunched with %s at %s>' % \
               (
                   address_tools.describe(type(self), shorten=True),
                   len(self),
                   self.step_profile.__repr__(short_form=True),
                   hex(id(self))
               )
        
from .node import Node
########NEW FILE########
__FILENAME__ = end
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `End` class.

See its documentation for more information.
'''

from garlicsim.general_misc import misc_tools
from garlicsim.general_misc import address_tools

from .tree_member import TreeMember
from .node import Node
# from .block import Block (At bottom of file)
    

class End(TreeMember):
    '''
    An end of the simulation.
    
    An `End` signifies that the simulation has ended. This is relevant in only
    some simpacks; some simpacks have a concept of ending the simulation, and
    some don't. When a simulation was crunched and reached its end on some
    timeline, the last node on that timeline will have an `End` object added to
    its `.ends` list.
    '''
    
    def __init__(self, tree, parent, step_profile=None):
        
        self.tree = tree
        '''The tree in which this end resides.'''
        
        assert isinstance(parent, Node)
        self.parent = parent
        '''
        The parent node of this end.
        
        Note that this parent node will not have this end as a child; it will
        list the end in its `.ends` attribute.
        '''
        
        self.parent.ends.append(self)
        
        self.step_profile = step_profile
        '''The step options profile with which the end was reached.'''
        
        if parent.block and not parent.is_last_on_block():
            parent.block.split(parent)
        
        
    def __len__(self):
        '''Just return 1. This is useful because of blocks.'''
        return 1

    
        
    def soft_get_block(self):
        '''
        Just return `self`.
        
        (This is a method of all `TreeMember`s that returns the block that the
        tree member belongs to, if there is one. But an end never belongs to a
        block.)
        '''
        return self

    
    def make_containing_path(self):
        '''
        Create a path that leads to this end.
        
        Returns the path.
        '''
        return self.parent.make_containing_path()
    

    def all_possible_paths(self):
        '''
        Get a list of all possible paths that lead to this end.
        
        (This method was invented for nodes and blocks and makes sense for
        them; for an end, it will just return the one single path that leads to
        it, since there can't be any forks after an end.)
        
        Note: There may be paths that contain this end which will not be
        identical to one of the paths given here, because these other paths may
        specify decisions that are not even on the same root as these paths.
        '''
        return self.parent.all_possible_paths()
    
    
    def make_past_path(self):
        '''
        Create a path that leads to this end.
        
        (This method was invented for nodes and blocks and makes sense for
        them; for an end, the "past path" is identical to the one made by
        `make_containing_path`, since there can't be any forks after an end.)
        
        Returns the path.
        '''
        return self.parent.make_past_path()

    
    def get_all_leaves(self, max_nodes_distance=None, max_clock_distance=None):
        '''
        Get `{}`.
        
        (This method was invented for nodes and blocks and makes sense for
        them; there are no leaves, or anything else for that matter, that come
        after an end.)
        '''
        
        return {}

    
    def get_ancestor(self, generations=1, round=False):
        '''
        Get an ancestor of this end.
        
        `generations` specifies the number of generation that the returned
        ancestor should be above the current end. `round` determines how this
        method will behave if it was asked for too many generations back, and
        not enough existed. If `round` is `True`, it will return the root. If
        `round` is `False`, it will raise a `NodeLookupError`. 
        '''

        assert generations >= 0
        if generations == 0:
            return self
        if generations >= 1:
            return self.parent(generations - 1, round)

            
    def get_root(self):
        '''
        Get the root of this end.
        
        This means the node which is the parent of the parent of the parent
        of... the parent of this end.
        '''
        return self.parent.get_root()
    
    
    
    def is_overlapping(self, other):
        '''
        Return whether this end overlaps with the given entity.
        
        Returns True only if `other` is the same end.
        '''
        return self is other
    
    
    def __repr__(self):
        '''
        Get a string representation of the end.
        
        Example output:        
        <garlicsim.data_structures.End from state with clock 6.5, crunched with
        life.State.step(<state>), at 0x1ffde70>
        '''
        
        return '<%s from state with clock %s, crunched with %s, at %s>' % \
            (
                address_tools.describe(type(self), shorten=True),
                self.parent.state.clock,
                self.step_profile,
                hex(id(self))
            )
        

from .block import Block


########NEW FILE########
__FILENAME__ = node
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `Node` class and related exceptions.

See documentation of `Node` for more information.
'''

from garlicsim.general_misc.infinity import infinity
from garlicsim.general_misc import misc_tools
from garlicsim.general_misc import address_tools

from garlicsim.misc import GarlicSimException

from .state import State
from .tree_member import TreeMember
# from .path import Path (at bottom of file.)
# from .block import Block (at bottom of file.)


__all__ = ['Node', 'NodeError', 'NodeLookupError']


class NodeError(GarlicSimException):
    '''Node-related Exception.'''

class NodeLookupError(NodeError, LookupError):
    '''A node-related lookup was requested but no result was found.'''
    
    
class Node(TreeMember):
    '''
    Nodes are used to organize states in a tree.
    
    A node encapsulates a state with the attribute `.state`. 
    
    Most nodes are untouched, a.k.a. natural, but some nodes are touched.
    A touched node is a node whose state was not formed naturally by a
    simulation step: It was created by the user, either from scratch or based
    on another state.
    '''
    # todo: Maybe node should not reference tree?
    
    def __init__(self, tree, state, parent=None, step_profile=None,
                 touched=False):
        '''
        Construct the node.
        
        `tree` is the tree in which this node resides. `state` is the state it
        should contain. `parent` is its parent node in the tree, which may be
        `None` for a root. `step_profile` is the step profile with which the
        state was crunched, which may be None for a state that was created from
        scratch. `touched` is whether the state was modified/created from
        scratch, in contrast to having been produced by crunching.
        '''
        
        self.tree = tree
        '''The tree in which this node resides.'''
        
        self.state = state
        '''The state contained in the node.'''
        
        self.parent = parent
        '''The parent node of this node.'''
        
        self.step_profile = step_profile
        '''
        The step profile with which the contained state was created.
        
        For an untouched node, this must be a real `StepProfile`. Only a
        touched node which was created from scratch should have `None` for its
        step profile.
        '''
        
        self.touched = touched
        '''Says whether the node is a touched node.'''
        
        self.block = None
        '''
        A node may be a member of a block. See class `Block` for more details.
        '''

        self.children = []
        '''
        A list of:
            1. Nodes whose states were produced by simulation from this node.
            2. Nodes who were "created by editing" from one of the nodes in the
               aforementioned set.
        '''

        self.derived_nodes = []
        '''
        List of nodes who were created by editing from this node.
        
        These nodes should have the same parent as this node.
        '''

        self.still_in_editing = False
        '''
        A flag that is raised for a node which is "still in editing".
        
        This means that its state is still being edited and was not yet
        finalized, thus no crunching should be made from the node until it is
        finalized.
        '''
        
        self.ends = []
        '''
        The ends whose parent is this node.
        
        This means, world ends that were arrived to on a timeline terminating
        with this node.
        '''
  
        
    def __len__(self):
        '''Just return 1. This is useful because of blocks.'''
        return 1

    
    def finalize(self):
        '''
        Finalize the node, assuming it's in currectly in editing mode.
        
        Before an edited node is finalized, it cannot be crunched from and
        cannot have children. (i.e. nodes that follow it in time.) After
        getting finalized, it may be crunched from and be assigned children.
        '''
        if self.still_in_editing is False:
            if self.touched:
                message = ('You tried to finalize a touched node, but it has '
                           'already been finalized.')
            else: # self.touched is False
                message = ("You tried to finalize an untouched node. "
                           "Untouched nodes can't be edited, so they have no "
                           "concept of being finalized.")
            raise NodeError(message)
        
        self.still_in_editing = False

        
    def soft_get_block(self):
        '''
        If this node is a member of a block, return the block.
        
        Otherwise, return the node itself.
        '''
        return self.block or self

    
    def make_containing_path(self):
        '''
        Create a path that contains this node.
        
        There may be multiple different paths that contain this node. This will
        return the one which points to the newest possible forks.
        
        Returns the path.
        '''
        
        path = self.make_past_path()
        
        path.get_last_node()
        # Calling this will make the path notice the forks in the nodes beyond
        # this node and put them in its `.decisions` dict.
        
        return path
    
        
    def all_possible_paths(self):
        '''
        Get a list of all possible paths that contain this node.
        
        Note: There may be paths that contain this node which will not be
        identical to one of the paths given here, because these other paths
        may specify decisions that are not even on the same root as these
        paths.
        '''
        #todo: possibly add `reversed` option
        past_path = self.make_past_path()
        paths = []
        fork = None
        for thing in past_path.iterate_blockwise(head=self):
            real_thing = thing[-1] if isinstance(thing, Block) else thing
            if len(real_thing.children):
                fork = real_thing
                break
        
        if fork:
            for kid in fork.children:
                paths += kid.all_possible_paths()
            return paths
        else: # fork is None and real_thing is the final node of the path
            # In this case there are no forks after our node, we just return
            # the past_path which we have driven to its last node. (Not that it
            # has any forks to decide on anyway.)
            return [past_path]

        
    def make_past_path(self):
        '''
        Create a path that contains this node.
        
        There may be multiple different paths that contain this node. This will
        return a path that doesn't specify any decisions after this node.
        '''
        path = Path(self.tree)

        current = self
        while True:
            if current.block is not None:
                current = current.block[0]
            parent = current.parent
            if parent is None:
                path.root = current
                break
            if len(parent.children) > 1:
                path.decisions[parent] = current
            current = parent

        return path

    
    def get_all_leaves(self, max_nodes_distance=None, max_clock_distance=None):
        '''
        Get all leaves that are descendents of this node.
        
        Only leaves with a distance of at most `max_nodes_distance` in nodes or
        `max_clock_distance` in clock are returned. (Note this is an OR
        relation between the two condintions)
        
        Returns a dict of the form:
        
        {
            leaf1: {
                'nodes_distance': nodes_distance1,
                'clock_distance': clock_distance1,
            },            
            leaf2: {
                'nodes_distance': nodes_distance2,
                'clock_distance': clock_distance2,
            },
            # ...
        }
            
        '''
        if max_nodes_distance is None:
            max_nodes_distance = infinity
        if max_clock_distance is None:
            max_clock_distance = infinity
                    
        nodes = {self: {'nodes_distance': 0, 'clock_distance': 0}}
        leaves = {}

        while nodes:
            item = nodes.popitem()
            node = item[0]
            nodes_distance = item[1]['nodes_distance']
            clock_distance = item[1]['clock_distance']
            
            if nodes_distance > max_nodes_distance and \
               clock_distance > max_clock_distance:
                continue
            
            kids = node.children
            
            if not kids:
                # We have a leaf!
                leaves[node] = {
                    'nodes_distance': nodes_distance,
                    'clock_distance': clock_distance,
                }
                continue
            
            if (node.block is None) or node.is_last_on_block():
                for kid in kids:
                    nodes[kid] = {
                        'nodes_distance': nodes_distance + 1,
                        'clock_distance': kid.state.clock - self.state.clock,
                    }
                continue
            else:
                block = node.block
                index = block.index(node)
                rest_of_block = (len(block) - index - 1)
                
                # We know the node isn't the last on the block, because we
                # checked for that before.

                last = block[-1]
                nodes[last] = {
                    'nodes_distance': nodes_distance + rest_of_block,
                    'clock_distance': last.state.clock - self.state.clock,
                }
                continue
            
        return leaves

    
    def get_ancestor(self, generations=1, round=False):
        '''
        Get an ancestor of this node.
        
        `generations` specifies the number of generation that the returned
        ancestor should be above the current node. `round` determines how this
        method will behave if it was asked for too many generations back, and
        not enough existed. If `round` is `True`, it will return the root. If
        `round` is `False`, it will raise a `NodeLookupError`.
        '''

        assert generations >= 0
        if generations == 0:
            return self
        if generations == 1:
            if self.parent:
                return self.parent
            else: # self.parent is None
                if round:
                    return self
                else: # round is False
                    raise NodeLookupError("You asked for the node's parent, "
                                          "but it's a root.") 
                
        block = self.block
        if block:
            our_index = block.index(self)
            wanted_index = our_index - generations
            if wanted_index >= 0:
                return block[wanted_index]
            else: # wanted_index < 0
                first_node = block[0]
                parent_of_first = first_node.parent
                if parent_of_first is None:
                    if round:
                        return first_node
                    else: # round is False
                        raise NodeLookupError(
                            "You asked for too many generations back. This "
                            "node's ancestry line doesn't go back that far."
                        )
                
                return parent_of_first.get_ancestor(-wanted_index-1,
                                                    round=round)
        
        assert self.block is None
        if self.parent:
            return self.parent.get_ancestor(generations - 1, round)
        else:
            if round:
                return self
            else: # round is False
                raise NodeLookupError("You asked for too many generations "
                                      "back. This node's ancestry line "
                                      "doesn't go back that far.")

            
    def get_root(self):
        '''
        Get the root of this node.
        
        This means the node which is the parent of the parent of the parent
        of... the parent of this node.
        '''
        lowest = self.block[0] if self.block else self
        while lowest.parent is not None:
            lowest = lowest.parent
            if lowest.block:
                lowest = lowest.block[0]
        return lowest
    
    
    def is_last_on_block(self):
        '''Return whether the node the last one on its block.'''
        return self.block and (self.block.index(self) == len(self.block) - 1)

    
    def is_first_on_block(self):
        '''Return whether the node the first one on its block.'''
        return self.block and (self.block.index(self) == 0)

    
    def is_overlapping(self, tree_member):
        '''
        Return whether this node overlaps with the given `tree_member`.
        
        `tree_member` may be a node, in which case overlapping means being the
        same node. `tree_member` can also be a block, in which case overlapping
        means this node is contained in the block.
        '''
        if tree_member is None: return False
        if isinstance(tree_member, Node):
            return (self is tree_member)
        else:
            assert isinstance(tree_member, Block)
            return (self in tree_member)

        
    def __repr__(self):
        '''
        Get a string representation of the node.
        
        Example output:        
        <garlicsim.data_structures.Node with clock 6.5, untouched, blockful,
        crunched with life.State.step(<state>), at 0x1ffde70>
        '''
        return '<%s%s, %s%s%s, %s, %sat %s>' % (
            address_tools.describe(type(self), shorten=True),
            ' with clock %s' % self.state.clock if hasattr(self.state, 'clock') else '',
            'root, ' if (self.parent is None) else '',
            'leaf, ' if (len(self.children) == 0) else '',
            'touched' if self.touched else 'untouched',
            'blockful' if self.block else 'blockless',
            'crunched with %s, ' % self.step_profile.__repr__(short_form=True)
            if self.step_profile else '',
            hex(id(self))
        )

from .path import Path
from .block import Block



########NEW FILE########
__FILENAME__ = node_range
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `NodeRange` class.

See its documentation for more info.
'''

from garlicsim.general_misc import cute_iter_tools
from garlicsim.general_misc import misc_tools
from garlicsim.general_misc import address_tools

from .node import Node
from .block import Block


class NodeRange(object):
    '''A consecutive range of nodes.'''

    def __init__(self, head, tail):
        '''
        Construct a NodeRange.
        
        `head` is the node or block in which this range starts.
        
        `tail` is the node or block in which this range ends.
        '''
        
        self.head = head
        '''The node or block in which this range starts.'''
        
        self.tail = tail
        '''The node or block in which this range ends.'''
    
        
    def make_path(self):
        '''Make a path that goes through this node range.'''
        node_around_tail = self.tail if isinstance(self.tail, Node) else \
                           self.tail[0]
        return node_around_tail.make_containing_path()

    
    def _sanity_check(self):
        '''
        Assert there are no obvious problems with this node range.
        
        This checks that the tail node/block is a descendent of the head
        node/block.
        '''
        path = self.make_path()
        assert (self.head in path.__iter__(tail=self.tail))
        
        
    def __iter__(self):
        '''Iterate on the nodes in this range.'''
        return self.make_path().__iter__(head=self.head, tail=self.tail)

    
    def iterate_blockwise(self):
        '''
        Iterate on the nodes in this range, returning blocks where possible.
        '''
        path = self.make_path()
        return path.iterate_blockwise(head=self.head, tail=self.tail)

    
    def __contains__(self, node):
        '''Return whether `node` is in this node range.'''
        # todo: can do blocks?
        path = self.make_path()
        return path.__contains__(node, head=self.head, tail=self.tail)

    
    def clone_with_blocks_dissolved(self):
        '''
        Make a node range that is specified with nodes and not blocks.
        
        A node range will be constructed that in this point of time is
        equivalent to the original node range, but whose `head` and `tail` are
        specified as nodes and not as blocks.
        '''
        if isinstance(self.head, Block):
            new_head = self.head[0]
        else:
            new_head = self.head
        if isinstance(self.tail, Block):
            new_tail = self.tail[-1]
        else:
            new_tail = self.tail
        
        return NodeRange(new_head, new_tail)

    
    def get_outside_children(self):
        '''
        Get all the non-member children nodes of nodes which are members.
        
        This returns every node which is (a) a child of a node in this node
        range and (b) not in this node range itself.
        '''
        outside_children = []
        for thing in self.iterate_blockwise():
            candidate = thing if isinstance(thing, Node) else thing[-1]
            outside_children += [child for child in candidate.children if child
                                 not in self]
        return outside_children

    
    def copy(self):
        '''Shallow-copy the node range.'''
        return type(self)(self.head, self.tail)

    __copy__ = copy

    
    def __repr__(self):
        '''
        Get a string representation of the node range.
        
        Example output:
        <garlicsim.data_structures.NodeRange, from node with clock 2 to block
        that ends at clock 102, containing 101 nodes total, at 0x291c550>
        '''
        return '<%s, from %s %s to %s %s, containing %s nodes total, at %s>' \
               % (
                   
                   address_tools.describe(type(self), shorten=True),
                   
                   'block that starts at clock' if isinstance(self.head, Block)
                   else 'node with clock',
                   
                   self.head[0].state.clock if isinstance(self.head, Block)
                   else self.head.state.clock,
                   
                   'block that ends at clock' if \
                   isinstance(self.tail, Block) else 'node with clock',
                   
                   self.tail[-1].state.clock if isinstance(self.tail, Block) \
                   else self.tail.state.clock,
                   
                   cute_iter_tools.get_length(self),
                
                   hex(id(self))
               )
    
    
    def __eq__(self, other):
        if not isinstance(other, NodeRange):
            return False
        r1 = self.clone_with_blocks_dissolved()
        r2 = other.clone_with_blocks_dissolved()
        return (r1.head is r2.head) and (r1.tail is r2.tail)

    
    def __req__(self, other):
        return self.__eq__(other)
    
########NEW FILE########
__FILENAME__ = node_selection
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `NodeSelection` class.

See its documentation for more info.
'''

from garlicsim.misc import GarlicSimException
from garlicsim.general_misc import sequence_tools

from .node import Node
from .node_range import NodeRange


__all__ = ['NodeSelection']


class CompletelyCompact(GarlicSimException):
    '''The NodeSelection is already completely compact.'''
    

class NodeSelection(object):
    '''
    A selection of nodes.
    
    A `NodeSelection` could be described as a "set" of nodes, though the nodes
    are not specified one by one, but as a collection of node ranges.
    '''
    
    def __init__(self, ranges=()):
        '''
        Construct the `NodeSelection`.
        
        `ranges` is a list of node ranges that this selection will be made of.
        '''
        self.ranges = [ranges] if isinstance(ranges, NodeRange) else \
                      list(ranges)
        
    def compact(self):
        '''
        Compact the `NodeSelection`.
        
        This'll make it use the minimum number of node ranges while still
        containing exactly the same nodes.
        '''
        for node_range in self.ranges:
            node_range._sanity_check()
        
        try:
            while True:
                self.__partially_compact()
        except CompletelyCompact:
            return
            
        
    def __partially_compact(self):
        '''Try to make the NodeSelection a bit more compact.'''
        # todo: consider defining a canonic decomposition of a node selection
        # to node ranges. This will make a few things easier, like checking
        # equality.
        first, second = None, None
        for (r1, r2) in sequence_tools.combinations(self.ranges, 2):
            if r1.head in r2:
                second, first = r1, r2
                break
            elif r2.head in r1:
                first, second = r1, r2
                break
            else:
                pass
        if first is not None and second is not None:
            if second.tail in first:
                pass
            else: # second.tail not in first
                for current in second:
                    if current not in first:
                        break
                if current.parent is first.tail:
                    self.ranges.remove(first)
                    new_range = NodeRange(head=first.head, tail=second.tail)
                else:
                    new_range = NodeRange(head=current, tail=second.tail)
                self.ranges.append(new_range)
              
            self.ranges.remove(second)
            return
        else:
            raise CompletelyCompact

        
    def __iter__(self):
        '''Iterate over the nodes that are members of this `NodeSelection`.'''
        for node_range in self.ranges:
            for node in node_range:
                yield node

                
    def __or__(self, other):
        '''Perform union between two `NodeSelections` and return the result.'''
        assert isinstance(other, NodeSelection)
        return NodeSelection(self.ranges + other.ranges)
    
    
    def __ror__(self, other):
        return self.__or__(other)

    
    def __eq__(self, other):
        # Currently horribly inefficient
        if not isinstance(other, NodeSelection):
            return False # todo: should be NotImplemented?
        return set(self) == set(other)

    
    def __req__(self, other):
        return self.__eq__(other)

    
    def copy(self):
        '''Shallow-copy the `NodeSelection`.'''
        klass = type(self)
        return klass((node_range.copy() for node_range in self.ranges))
    
    __copy__ = copy
    
    
########NEW FILE########
__FILENAME__ = path
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
A module that Defines the `Path` class and a few related exceptions.

See its documentation for more information.
'''

import copy as copy_module # Avoiding name clash.
import __builtin__

from garlicsim.general_misc import binary_search
from garlicsim.general_misc import misc_tools
from garlicsim.general_misc import address_tools
from garlicsim.general_misc import cute_iter_tools

from garlicsim.misc import GarlicSimException

from .node import Node
from .block import Block
# from .tree import Tree (at bottom of the file)


__all__ = ['Path', 'PathError', 'PathOutOfRangeError', 'TailNotReached',
           'HeadNotReached']


### Definining path-related exceptions: #######################################
#                                                                             #

class PathError(GarlicSimException):
    '''Path-related exception.'''

    
class PathLookupError(PathError, LookupError):
    '''Path-related exception.'''    

    
class PathOutOfRangeError(PathError, IndexError):
    '''Nodes are requested from the path which are out of its range.'''

    
class TailNotReached(PathError): 
    '''
    A tail node/block is specified but it turns out not to be on the path.
    '''
    # todo: consider subclass from one of the obscure exceptions like
    # LookupError

    
class HeadNotReached(PathError):
    '''
    A head node/block is specified but it turns out not to be on the path.
    '''

#                                                                             #
### Finished definining path-related exceptions. ##############################
    

class Path(object):
    '''
    A path represents a line of nodes in a tree.
    
    A tree may be complex and contain many junctions, but a path is a direct
    line through it. Therefore, a path object contains information about which
    child to choose when going through a node which has multiple children.
    
    Some of `Path`'s method accept `head` and `tail` parameters for specifying
    a sub-range inside the path. It should be noted that this range will
    include both endpoints.
    '''
    
    def __init__(self, tree, root=None, decisions={}):
        '''
        Construct the path.
        
        `tree` is the tree that this path is on. `root` is the node from which
        the path begins. `decisions` is a dictionary of the form
        {node_which_forks: node_to_continue_to, ... }. It usually contains as
        keys only nodes that have more than one child.
        '''

        self.tree = tree
        '''The tree that this path is on.'''
        
        self.root = root
        '''The root node.'''
        
        self.decisions = dict(decisions)
        '''
        The decisions dict says which fork of the road the path chooses.
        It's of the form {node_which_forks: node_to_continue_to, ... }
        '''
         # todo: Use shallow copy instead of dict.__init__. Will allow
         # dictoids.

         
    def __len__(self, head=None, tail=None):
        '''
        Get the length of the path in nodes.
        
        You can optionally specify `head` and/or `tail`, which may be either
        nodes or blocks.
        '''
        if head is None and self.root is None:
            return 0
            
        return sum(len(thing) for thing in 
                   self.iterate_blockwise(head=head, tail=tail))


    def __iter__(self, head=None, tail=None):
        '''
        Iterate over the nodes in the path.
        
        You can optionally specify `head` and/or `tail`, which may be either
        nodes or blocks.
        '''
        if head is None:
            if self.root is None:
                raise StopIteration
            current = self.root
        else:
            current = head
        
        current = current if isinstance(current, Node) else current[0]
            
        while True:
            
            yield current
            
            if tail is not None:
                if current is tail:
                    raise StopIteration
                elif isinstance(tail, Block) and (current in tail):
                    if current.is_last_on_block():
                        raise StopIteration
                        
            try:
                current = self.next_node(current)           
            except PathOutOfRangeError:
                if tail is not None:
                    raise TailNotReached
                raise StopIteration

            
    def __reversed__(self):
        '''Iterate over the nodes in the path in reverse order.'''
        # todo: may add head and tail
        try:
            current_node = self[-1]
        except PathOutOfRangeError:
            raise StopIteration
        while current_node is not None:
            yield current_node
            current_node = current_node.parent
            
            
    def iterate_blockwise(self, head=None, tail=None):
        '''
        Iterate on the path, yielding blocks when possible.
        
        You may optionally specify `head` and/or `tail`, which may be either
        nodes or blocks.
        '''

        if head is None:
            if self.root is None:
                raise StopIteration
            current = self.root
        else: # head is not None
            current = head
            if isinstance(head, Node) and head.block is not None and \
               head.is_first_on_block() is False:
                # We are starting iteration on a node in a block. (And it's not
                # the first one on the block.) We will not yield its block at
                # all. We'll yield all the nodes one by one until the next
                # node/block in the tree.
                index_of_head = head.block.index(head)
                for current in head.block[index_of_head:]:
                    yield current
                    if current is tail:
                        raise StopIteration
                    
                assert current is head.block[-1]
                
                try:
                    current = self.next_node(current)
                except PathOutOfRangeError:
                    if tail is not None:
                        raise TailNotReached
                    raise StopIteration
                
        while True:
            if current.block is not None:
                if tail is not None:
                    if tail is current.block:
                        yield current.block
                        raise StopIteration
                    elif tail in current.block:
                        index_of_tail = current.block.index(tail)
                        for thing in current.block[ 0 : (index_of_tail + 1) ]:
                            yield thing
                        raise StopIteration
                    else: # tail isn't here
                        current = current.block
                        yield current    
                else: # tail is None
                    current = current.block
                    yield current
            else: # current.block is None
                yield current
                if current.is_overlapping(tail):
                    raise StopIteration
            try:
                current = self.next_node(current)
            except PathOutOfRangeError:
                if tail is not None:
                    raise TailNotReached
                raise StopIteration
    
            
    def iterate_blockwise_reversed(self, head=None, tail=None):
        '''
        Iterate backwards on the path, yielding blocks when possible.
        
        You may optionally specify `head` and/or `tail`, which may be either
        nodes or blocks.
        '''
        if tail is None:
            try:
                tail = self.get_last_node()
            except PathOutOfRangeError:
                raise StopIteration
        
        current = tail
        if isinstance(tail, Node) and tail.block is not None and \
           tail.is_last_on_block() is False:
            # We are starting iteration on a node in a block. (And it's not the
            # last one on the block.) We will not yield its block at all. We'll
            # yield all the nodes one by one until the previous node/block in
            # the tree.
            index_of_tail = tail.block.index(tail)
            for current in tail.block[ index_of_tail : : -1 ]:
                yield current
                if current is head:
                    raise StopIteration

            assert current is tail.block[0]
            
            if isinstance(current, Node):
                current = current.parent
            else: # isinstance(current, Block)
                current = current[0].parent
            if current is None:
                if head is not None:
                    raise HeadNotReached
                raise StopIteration
                
        while True:
            if current.block is not None:
                if head is not None:
                    if head is current.block:
                        yield current.block
                        raise StopIteration
                    elif head in current.block:
                        index_of_head = current.block.index(head)
                        for thing in current.block[:(index_of_head - 1):-1]:
                            yield thing
                        raise StopIteration
                else: # head is None
                    current = current.block
                    yield current
            else: # current.block is None
                yield current
                if current.is_overlapping(head):
                    raise StopIteration

            if isinstance(current, Node):
                current = current.parent
            else: # isinstance(current, Block)
                current = current[0].parent
            if current is None:
                if head is not None:
                    raise HeadNotReached
                raise StopIteration
            

    def __contains__(self, thing, head=None, tail=None):
        '''
        Return whether the path contains the specified node/block.

        You may optionally specify `head` and/or `tail`, which may be either
        nodes or blocks.
        '''
        
        assert isinstance(thing, Node) or isinstance(thing, Block)

        for candidate in self.iterate_blockwise(head=head, tail=tail):
            if candidate is thing:
                return True
            elif isinstance(candidate, Block) and thing in candidate:
                return True
            
        return False


    def next_node(self, thing):
        '''
        Return the node on the path which is next after `thing`.
        
        If we've come to a fork for which we have no key in the decisions dict,
        we choose the first child node in the parent node's `children`, and
        update the decisions dict to point to it as well.
        '''
        
        # We're dealing with the case of 1 child first, because it's the most
        # common.
        real_thing = thing if isinstance(thing, Node) else thing[-1]
        kids = real_thing.children
        if len(kids) == 1:
            return kids[0]
        
        if (thing in self.decisions) or (real_thing in self.decisions):
            return self.decisions.get(thing, None) or \
                   self.decisions.get(real_thing, None)
        
        if len(kids) > 1:
            kid = kids[0]
            # Whether it should take `kids[0]` or `kids[-1]` is a subject for
            # debate. The question is, when you update the tree, do you want
            # the old paths to point to the new nodes or the old?
            self.decisions[real_thing] = kid
            return kid

        else: # no kids
            raise PathOutOfRangeError

    

    def __getitem__(self, index, tail=None):
        '''
        Get a node by its index number in the path.

        You may optionally specify a `tail` node.
        '''
        #todo: allow slicing? make Path.states for this and for iterating?
        #todo: generalize `tail` to blocks
        assert isinstance(index, int)
        
        if index >= 0:
            return self.__get_item_positive(index, tail=tail)
        else:
            return self.__get_item_negative(index, tail=tail)

        
    def __get_item_negative(self, index, tail=None):
        '''
        Get a node by its index number in the path. Negative indices only.

        You may optionally specify a `tail`.
        '''
        if tail is None:
            tail = self.get_last_node()
        else:
            assert isinstance(tail, Node) or isinstance(tail, Block)
        if index == -1:
            return tail
        
        my_index = -1
        
        if tail.block:
            block = tail.block
            index_of_tail = block.index(tail)
            
            my_index -= (index_of_tail)
            
            if my_index <= index:
                return block[index - my_index]
            
            tail = tail.block[0]
        
        my_index += 1
            
        for thing in self.iterate_blockwise_reversed(tail=tail):
            my_index -= len(thing)
            if my_index <= index:
                if isinstance(thing, Block):
                    return thing[(index - my_index)]
                else:
                    assert my_index == index
                    return thing
                
        raise PathOutOfRangeError
        
    
    def __get_item_positive(self, index, tail=None):
        '''
        Get a node by its index number in the path. Positive indices only.

        You may optionally specify a `tail` node.
        '''
        # todo: supports blocks?
        my_index = -1
        answer = None
        for thing in self.iterate_blockwise(tail=tail):
            my_index += len(thing)
            if my_index >= index:
                if isinstance(thing, Block):
                    answer = thing[(index-my_index) - 1]
                    break 
                else:
                    assert my_index == index
                    answer = thing
                    break
        if answer is not None:
            return answer
        raise PathOutOfRangeError

    
    def get_last_node(self, head=None):
        '''
        Get the last node in the path.
        
        You may optionally specify `head`, which may be either a node or block.
        '''

        # Setting to `None` before loop, so we know if loop was empty:
        thing = None 
        
        for thing in self.iterate_blockwise(head=head):
            pass

        if isinstance(thing, Block):
            return thing[-1]
        elif isinstance(thing, Node):
            return thing
        else: # thing is None
            raise PathOutOfRangeError("You asked for the last node in the "
                                      "path, but it's completely empty.")

        
    def get_ends_of_last_node(self, head=None):
        '''Get the ends of the last node in the path.'''
        last_node = self.get_last_node(head=head)
        return last_node.ends
        
        
    def get_node_by_clock(self, clock, rounding=binary_search.CLOSEST,
                          tail_node=None):
        '''
        Get a node according to its clock.
        
        See documentation of `binary_search.roundings` for details about
        rounding options.
        
        You may optionally specify a `tail_node`.
        '''
        
        my_function = lambda node: node.state.clock
        return self.get_node_by_monotonic_function(function=my_function,
                                                   value=clock,
                                                   rounding=rounding,
                                                   tail_node=tail_node)    
        
    
    def get_node_by_monotonic_function(self, function, value,
                                       rounding=binary_search.CLOSEST,
                                       tail_node=None):
        '''
        Get a node by specifying a measure function and a desired value.
        
        The function must be a monotonic rising function on the timeline.
        
        See documentation of `binary_search.roundings` for details about
        rounding options.
        
        You may optionally specify a `tail_node`.
        '''
        
        assert issubclass(rounding, binary_search.Rounding)
        
        both = \
             self.__get_node_by_monotonic_function_with_both_rounding(function,
                                                                      value)
        if tail_node is not None:
            new_both = list(both)
            tail_clock = tail_node.state.clock
            if new_both[0] and new_both[0].state.clock > tail_clock:
                new_both[0] = tail_node
            if new_both[1] and new_both[1].state.clock > tail_clock:
                new_both[1] = None
            both = tuple(new_both)
            
        binary_search_profile = \
            binary_search.BinarySearchProfile(self, function, value, both)
        
        return binary_search_profile.results[rounding]
                    
    
    def __get_node_by_monotonic_function_with_both_rounding(self, function,
                                                            value):
        '''
        Get a node by specifying a measure function and a desired value.
        
        The function must be a monotonic rising function on the timeline.
        
        The rounding option used is `binary_search.BOTH`.
        
        Note that this function does not let you specify a tail node. Currently
        we're not optimizing for the case where you have a tail node and this
        function might waste resources exploring beyond it.
        '''
        
        root = self.root
        
        cmp_root = cmp(function(root), value)
        
        if cmp_root == 1: # function(root) > value
            return (None, root)
        if cmp_root == 0: # function(root) == value
            return (root, root)

        assert cmp_root == -1 # and function(root) < value
        
        # Now we've established that the first node in the path has a strictly
        # lower value than what we're looking for.
        
        # A rule we will strictly obey in this function: `low` will always be a
        # member whose value is lower than the desired value. (Strictly lower,
        # meaning not lower-or-equal.)
        
        low = self.root
        
        for thing in self.iterate_blockwise():
            
            # Rule: Every time we inspect a new node/block, `low` will be the
            # node that is its immediate parent. i.e. The highest node possible
            # from those that we have previously examined.
            
            if isinstance(thing, Block):
                
                block = thing
                
                first = block[0]

                cmp_first = cmp(function(first), value)
                
                if cmp_first == -1: # function(first) < value
                    low = first
                
                elif cmp_first == 0: # function(first) == value
                    return (first, first)
                    
                else: # cmp_first == 1 and function(first) > value
                    return (low, first)
                    
                
                # At this point we know that the first node in the block has a
                # strictly lower value than the target value.
                
                last = block[-1]
                
                cmp_last = cmp(function(last), value)
                
                if cmp_last == -1: # function(last) < value
                    low = last
                    continue
                
                elif cmp_last == 0: # function(last) == value                
                    return (last, last)
                
                else: # cmp_last == 1 and function(last) > value
                    # The two final results are both in the block.
                    return binary_search.binary_search(
                        block, function, value, rounding=binary_search.BOTH
                    )
                    
                
            else: # thing is a Node
                
                node = thing
                
                cmp_node = cmp(function(node), value)
                                
                if cmp_node == -1: # function(node) < value
                    low = node
                    continue
                elif cmp_node == 0: # function(node) == value
                    return (node, node)
                else: # function(node) > value
                    return (low, node)
        

        # If the flow reached here, that means that even the last node in the
        # path has lower value than the value we're looking for.
        
        return (low, None)
            
    
    def get_node_occupying_timepoint(self, timepoint):
        '''
        Get the node which "occupies" the given timepoint.
        
        A node is considered to "occupy" a timepoint if it is the
        highest-clocked node before the timepoint, AND there exists another
        node which has a clock higher than timepoint (that higher node is not
        returned, it just has to exist for the first node to qualify as
        "occupying".)
        
        If no such node exists, returns `None`.
        '''
        return self.get_node_by_clock(timepoint,
                                      rounding=binary_search.LOW_IF_BOTH)
    

    def get_existing_time_segment(self, start_time, end_time):
        '''
        Get the existing time segment between `start_time` and `end_time`.
        
        Example: 
        
            In the path the first node's clock reading is 3.2, the last is
            7.6.
            `start_time` is 2 and `end_time` is 5.
            The function will return [3.2, 5].
        '''

        clock_of_first = self.root.state.clock
        clock_of_last = self.get_last_node().state.clock
        
        if clock_of_first <= end_time and clock_of_last >= start_time:
            return [max(clock_of_first, start_time),
                    min(clock_of_last, end_time)]
        else:
            return None
    
        
    def modify_to_include_node(self, node):
        '''
        Modify the path to include the specified node.
        
        Optimization note: Don't try to check whether `node in path` before
        calling this method. It's more efficient to just call this method
        without checking first.
        '''
        new_path = node.make_past_path()
        self.root = new_path.root
        self.decisions.update(new_path.decisions)
    
    
    def states(self):
        '''Iterate over the states of the nodes in this path.'''
        # todo: Make fancier, like dict.keys in Py3. Probably create as object
        # in __init__
        for node in self:
            yield node.state
        
            
    def _get_lower_path(self, node):
        '''
        Get a lower path than this one.
        
        "Lower" means that in some point in the past the other path goes
        through a child node with a lower index number (in `children`) than
        this path.
        
        This method will return the highest path that is just below this path.
        '''
        return self._get_higher_path(node, _reverse=True)
                
    
    def _get_higher_path(self, node, _reverse=False):
        '''
        Get a higher path than this one.
        
        "Higher" means that in some point in the past the other path goes
        through a child node with a higher index number (in `children`) than
        this path.
        
        This method will return the lowest path that is just above this path.
        '''

        my_iter = __builtin__.reversed if _reverse else iter
        
        wanted_clock = node.state.clock
        
        for (kid, parent) in cute_iter_tools.consecutive_pairs(reversed(self)):
            if len(parent.children) == 1:
                continue
            my_index = parent.children.index(kid)

            if _reverse:
                if my_index > 0:
                    kids_to_try = parent.children[:my_index]
                    break
            
            if not _reverse:
                if my_index < len(parent.children) -1:
                    kids_to_try = parent.children[my_index+1:]
                    break
        else:
            raise PathLookupError('This path is the %s one.' % \
                                  ('lowest' if _reverse else 'highest'))
        
        for node in my_iter(kids_to_try):
            paths = node.all_possible_paths() # todo: make reversed argument
            for path in my_iter(paths):
                assert isinstance(path, Path)
                if path[-1].state.clock >= wanted_clock:
                    return path
        
        raise PathLookupError('This path is the %s one which extends enough '
                              'in the future to the clock of the specified  '
                              'node.' % ('lowest' if _reverse else 'highest'))
               
            
    def __repr__(self):
        '''
        Get a string representation of the path.
        
        Example output:
        <garlicsim.data_structures.Path of length 43 at 0x1c822d0>
        '''
        return '<%s of length %s at %s>' % \
               (
                   address_tools.describe(type(self), shorten=True),
                   len(self),
                   hex(id(self))
               )
    
    
    def copy(self):
        '''Make a shallow copy of the path.'''
        
        # Most of these things don't need duplicating, but just for
        # completeness' sake:
        tree = self.tree
        root = self.root
        decisions = self.decisions.copy()
        
        path = Path(tree=tree, root=root, decisions=decisions)
        
        return path
    
    __copy__ = copy
    
    
    def __eq__(self, other):
        # Currently horribly inefficient
        assert isinstance(other, Path)
        return list(self) == list(other)

    
    def __req__(self, other):
        return self.__eq__(other)
    
    
from .tree import Tree
########NEW FILE########
__FILENAME__ = state
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `State` class.

See its documentation for more info.
'''

from garlicsim.general_misc import misc_tools
from garlicsim.general_misc import address_tools
from garlicsim.general_misc.function_anchoring_type import \
     FunctionAnchoringType

import garlicsim


class State(object):
    '''
    A state describes a world state in the world of the simulation.
    
    It contains information about a "frozen moment" in the simulation.

    All the information about the state of the simulation should be saved in
    attributes of the state object.

    When a state is created, a `.clock` attribute should be assigned to it,
    specifying what time it is in this state.

    A state object must always be pickleable, as do all the attributes assigned
    to it.
    '''
    
    __metaclass__ = FunctionAnchoringType
    
    
    def __repr__(self):
        '''
        Get a string representation of the state.
        
        Example output:
        <garlicsim.data_structures.State with clock 32.3 at 0x1c822d0>
        ''' 
        return '<%s %sat %s>' % \
               (
                   address_tools.describe(type(self), shorten=True),
                   ('with clock %s ' % self.clock) if hasattr(self, 'clock')
                   else '',
                   hex(id(self))
               )

    create_root = None
    create_messy_root = None
    
    # Python 2.5 doesn't have `type.__eq__`, so we supply one:
    __eq__ = lambda self, other: (id(self) == id(other))
    
        

########NEW FILE########
__FILENAME__ = tree
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `Tree` class and the related `TreeError` exception.

See their documentation for more information.
'''

import copy

from garlicsim.general_misc import misc_tools
from garlicsim.general_misc import address_tools
from garlicsim.general_misc.nifty_collections import OrderedSet

import garlicsim.misc
from garlicsim.misc import GarlicSimException

# In bottom of file:
# `from .node import Node`
# `from .block import Block`
# `from .end import End`


__all__ = ["Tree", "TreeError"]


class TreeError(GarlicSimException):
    '''Tree-related exception.'''

    
class Tree(object):
    '''
    A time tree, (generalization of timeline,) of the simulation.

    A tree is used within a project to organize everything that is happenning
    in the simulation.
    
    Often, when doing a simulation, the tree will be a degenerate tree, i.e. a
    straight, long succession of nodes with no more than one child each. The
    meaning of one node in the tree being another node's child is that the
    child node comes after the parent node in the timeline.
    
    Trees are useful, because they give you the ability to "split" or "fork"
    the simulation at any node you wish, allowing you to explore and analyze
    different scenarios in parallel in the same simulation.

    Each node in the tree may have a parent, or may not, in which case it will
    also be called a root and be a member of `.roots`.
    '''
    def __init__(self):
        
        self.nodes = []
        '''List of nodes that belong to the tree.'''
        
        self.roots = []
        '''List of roots (parentless nodes) of the tree.'''
        
        self.lock = garlicsim.general_misc.read_write_lock.ReadWriteLock()
        '''
        A read-write lock that guards access to the tree.
        
        We need such a thing because some simulations are history-dependent and
        require reading from the tree in the same time that `.sync_crunchers`
        could potentially be writing to it.
        '''

        
    def fork_to_edit(self, template_node):
        '''
        "Duplicate" the node, marking the new one as touched.
        
        The new node will have the same parent as `template_node`. The state of
        the new node is usually modified by the user after it is created, and
        after that the node is finalized and used in simulation.
        
        This is useful when you want to make some changes in the world state
        and see what they will cause in the simulation.
        
        Returns the node.
        '''
        new_state = \
            garlicsim.misc.state_deepcopy.state_deepcopy(template_node.state)

        parent = template_node.parent
        new_step_profile = copy.copy(template_node.step_profile)
        new_node = self.add_state(new_state, parent,
                                  step_profile=new_step_profile,
                                  template_node=template_node)
        new_node.still_in_editing = True
        return new_node


    def add_state(self, state, parent=None, step_profile=None,
                  template_node=None):
        '''
        Wrap `state` in a node and add to the tree.
        
        Returns the node.
        '''
        touched = (parent is None) or (template_node is not None)
        
        my_node = Node(
            self,
            state,
            step_profile=copy.copy(step_profile),
            touched=touched
        )
        
        self.__add_node(my_node, parent, template_node)
        return my_node


    def __add_node(self, node, parent=None, template_node=None):
        '''
        Add a node to the tree.
        
        It may be a natural node or a touched node. If it's a natural node you
        may not specify a template_node.
        
        Returns the node.
        '''
        if template_node is not None:
            if parent != template_node.parent:
                raise TreeError("Parent you specified and parent of "
                                "`template_node` aren't the same!")
            if not node.touched:
                raise TreeError("You tried adding an untouched state to a "
                                "tree while specifying a `template_node`.")
            template_node.derived_nodes.append(node)
            

        self.nodes.append(node)

        if parent:
            if not hasattr(node.state, 'clock'):
                node.state.clock = parent.state.clock + 1

            node.parent = parent
            parent.children.append(node)
            
            if parent.block:
                
                if len(parent.children) == 1:
                    
                    if (not node.touched) and \
                       (parent.step_profile == node.step_profile):
                        
                        parent.block.append_node(node)
                        
                else: # parent.children > 1

                    if not (parent is parent.block[-1]):
                        
                        parent.block.split(parent)
                        
            else: # parent.block is None
                
                if (not node.touched) and \
                   (not parent.touched) and \
                   (len(parent.children)==1) and \
                   (parent.step_profile == node.step_profile):
                    
                    Block([parent, node])
                
                        
        else: # parent is None
            if not hasattr(node.state, "clock"):
                node.state.clock = 0
            self.roots.append(node)
            return node

    
    def make_end(self, node, step_profile):
        '''
        Create an end after the specified node.
        
        Must specify a step profile with which this end was reached.
        '''
        end = End(self, node, step_profile)
        return end
    

    def all_possible_paths(self):
        '''Return all the possible paths this tree may entertain.'''
        result = []
        for root in self.roots:
            result += root.all_possible_paths()
        return result


    def get_step_profiles(self):
        '''Get an ordered set of all the step profiles used in this tree.'''
        tree_members_iterator = \
            self.iterate_tree_members(include_blockful_nodes=False)
        
        step_profiles = OrderedSet(
            tree_member.step_profile for tree_member in tree_members_iterator
        )
        
        if None in step_profiles:
            step_profiles.remove(None)
        
        return step_profiles
    
    
    def iterate_tree_members(self, include_blockful_nodes=True):
        '''
        Iterate over all the members (nodes, blocks, ends) in this tree.
        
        By default, all nodes will be included; you may specify
        `include_blockful_nodes=False` to exclude them. (Their block will be
        included.)
        '''
        members_to_explore = self.roots[:]
        while members_to_explore:
            member = members_to_explore.pop()
            yield member
            if isinstance(member, Block):
                if include_blockful_nodes:
                    for node in member:
                        yield node
                children = member[-1].children
                ends = member[-1].ends
            elif isinstance(member, End):
                children = ()
                ends = ()
            else:
                children = member.children
                ends = member.ends
            
            members_to_explore += [kid.soft_get_block() for kid in children]
            members_to_explore += ends
        
        
    
    
    def delete_node_selection(self, node_selection):
        '''
        Delete a node selection from the tree.
        
        Any nodes that will be orphaned by this deletion will become roots.
        '''
                
        stitch = False
        # todo: this is supposed to be an argument allowing the children to be
        # stitched to the new parent, but I'm currently forcing it to be false
        # because I haven't decided yet how I will handle stitching.
        
        node_selection.compact()
        for node_range in node_selection.ranges:
            self.delete_node_range(node_range) #, stitch=stitch)

            
    def delete_node_range(self, node_range):
        '''
        Delete a node range from the tree.
        
        Any nodes that will be orphaned by this deletion will become roots.
        '''
        
        stitch = False
        # todo: This is supposed to be an argument allowing the children to be
        # stitched to the new parent, but I'm currently forcing it to be
        # `False` because I haven't decided yet how I will handle stitching.
        
        head_node = node_range.head if isinstance(node_range.head, Node) \
                     else node_range.head[0]
        
        tail_node = node_range.tail if isinstance(node_range.tail, Node) \
                     else node_range.tail[-1]
        
        if head_node in self.roots:
            self.roots.remove(head_node)
                        
        big_parent = head_node.parent
        if big_parent is not None:
            big_parent.children.remove(head_node)
        
        outside_children = node_range.get_outside_children()
            
        for node in node_range:
            self.nodes.remove(node)

        current_block = None
        last_block_change = None
        for node in node_range:
            if node.block is not current_block:
                if current_block is not None:
                    del current_block[current_block.index(last_block_change) :
                                      current_block.index(node.parent)]
                current_block = node.block
                last_block_change = node
                
        if current_block is not None:
            del current_block[current_block.index(last_block_change) :
                              current_block.index(tail_node)]
                    
        parent_to_use = big_parent if (stitch is True) else None
        for node in outside_children:
            node.parent = parent_to_use
            if parent_to_use is None:
                self.roots.append(node)
        
    
    
    """ todo: In construction:
    def move_node_range(self, node_range):
        pass
    
    def copy_node_range(self, node_range, head=None, tail=None):
        pass
    """

    
    def __repr__(self):
        '''
        Get a string representation of the tree.
        
        Example output:        
        <garlicsim.data_structures.Tree with 1 roots, 233 nodes and 3 possible
        paths at 0x1f6ae70>
        '''
        return '<%s with %s roots, %s nodes and %s possible paths at %s>' % \
               (
                   address_tools.describe(type(self), shorten=True),
                   len(self.roots),
                   len(self.nodes),
                   len(self.all_possible_paths()),
                   hex(id(self))
               )
    
    
    def __getstate__(self):
        my_dict = dict(self.__dict__)
        del my_dict['lock']
        return my_dict
    
    
    def __setstate__(self, pickled_tree_state):
        self.__init__()
        self.__dict__.update(pickled_tree_state)
        
        
    
from .node import Node
from .block import Block
from .end import End

########NEW FILE########
__FILENAME__ = tree_member
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `TreeMember` class.

See its documentation for more information.
'''

from garlicsim.general_misc.third_party import abc
    
    
class TreeMember(object):
    '''
    A member of the tree.
    
    This is an abstract base class for all kinds of objects that are members of
    a tree.
    '''
    # todo: add .step_profile as abstract
    
    __metaclass__ = abc.ABCMeta
  
    @abc.abstractmethod
    def __len__(self):
        '''
        Get the length of the tree member.
        
        For a node or an end, this will be 1. For a block, it will be the
        number of contained nodes.
        '''
        raise NotImplementedError

        
    @abc.abstractmethod
    def soft_get_block(self):
        '''
        Get the block that this tree member is on, or itself if it's a block.
        
        If it's not a part of a block, return itself.
        '''
        
    
    @abc.abstractmethod
    def make_containing_path(self):
        '''
        Create a path that contains this tree member.
        
        There may be multiple different paths that contain this tree member.
        This will return the one which points to the newest possible forks.
        Returns the path.
        '''
        
    
    @abc.abstractmethod
    def all_possible_paths(self):
        '''
        Get a list of all possible paths that contain this tree member.
        
        Note: There may be paths that contain this tree member which will not
        be identical to one of the paths given here, because these other paths
        may specify decisions that are not even on the same root as these
        paths.
        '''
    
    
    @abc.abstractmethod
    def make_past_path(self):
        '''
        Create a path that contains this tree member.
        
        There may be multiple different paths that contain this tree member.
        This will return a path that doesn't specify any decisions after this
        tree member.
        '''


    @abc.abstractmethod
    def get_all_leaves(self, max_nodes_distance=None, max_clock_distance=None):
        '''
        Get all leaves that are descendents of this tree member.
        
        Only leaves with a distance of at most `max_nodes_distance` in nodes or
        `max_clock_distance` in clock are returned. (Note this is an OR
        relation between the two condintions)
        
        Returns a dict of the form:
        
        {
            leaf1: {
                'nodes_distance': nodes_distance1,
                'clock_distance': clock_distance1,
            },            
            leaf2: {
                'nodes_distance': nodes_distance2,
                'clock_distance': clock_distance2,
            },
            # ...
        }
            
        '''

    
    @abc.abstractmethod
    def get_ancestor(self, generations=1, round=False):
        '''
        Get an ancestor of this tree member.
        
        `generations` specifies the number of generation that the returned
        ancestor should be above the current tree member. `round` determines
        how this method will behave if it was asked for too many generations
        back, and not enough existed. If `round` is `True`, it will return the
        root. If `round` is `False`, it will raise a `NodeLookupError`.
        '''

    
    @abc.abstractmethod
    def get_root(self):
        '''
        Get the root of this tree member.
        
        This means the node which is the parent of the parent of the parent
        of... the parent of this tree member.
        '''
    
    
    @abc.abstractmethod
    def is_overlapping(self, tree_member):
        '''
        Return whether this tree member overlaps with the given tree member.
        '''

########NEW FILE########
__FILENAME__ = abc_tools
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Defines tools related to abstract base classes from the `abc` module.'''


class abstract_static_method(staticmethod):
    '''
    A combination of `abc.abstractmethod` and `staticmethod`.
    
    This class is good only for documentation; it doesn't enforce overriding
    methods to be static.
    '''
    __slots__ = ()
    __isabstractmethod__ = True
    
    def __init__(self, function):
        super(abstract_static_method, self).__init__(function)
        function.__isabstractmethod__ = True

########NEW FILE########
__FILENAME__ = object_to_string
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Module for describing Python objects as strings.'''

import types
import re

from garlicsim.general_misc import import_tools
from garlicsim.general_misc import dict_tools
from garlicsim.general_misc import caching

# Doing at bottom:
# from .string_to_object import _get_object_by_address, resolve
from .shared import (_address_pattern, _contained_address_pattern,
                     _get_parent_and_dict_from_namespace)

# maybe todo: when shortening, check that we're not using stuff that was
# excluded from `__all__`(if one exists.)


_unresolvable_string_pattern = re.compile("<[^<>]*?'[^<>]*?'[^<>]*?>")
'''Pattern for unresorvable strings, like "<type 'list'>".'''


_address_in_unresolvable_string_pattern = re.compile("[^']*?'([^']*?)'[^']*?")
'''
Pattern for extracting address from unresorvable strings.

For example, matching "type 'list'" would result in `match.groups() ==
('list',)`.
'''


def describe(obj, shorten=False, root=None, namespace={}):
    '''
    Describe a Python object has a string.
    
    For example:

        >>> describe([1, 2, {3: email.encoders}])
        '[1, 2, {3: 4}]'
    
    
    All the parameters are used for trying to give as short of a description as
    possible. The shortening is done only for addresses within the string.
    (Like 'email.encoders'.)
    
    `shorten=True` would try to skip redundant intermediate nodes. For example,
    if asked to describe `garlicsim.synchronous_crunching.simulate` with
    `shorten` on, it will return 'garlicsim.simulate', because the `simulate`
    function is available at this shorter address as well.
    
    The parameters `root` and `namespace` help shorten addresses some more.
    It's assumed we can express any address in relation to `root`, or in
    relation to an item in `namespace`. For example, if `root=garlicsim` or
    `namespace=garlicsim.__dict__`, we could describe `garlicsim.simulate` as
    simply 'simulate'.
    '''
    
    # If it's the easy case of a module/function/class or something like that,
    # we solve it by simply using `get_address`:
    if isinstance(obj, types.ModuleType) or \
       (hasattr(obj, '__module__') and hasattr(obj, '__name__')):
        
        return get_address(obj, shorten=shorten, root=root,
                            namespace=namespace)
    
    
    # What we do is take a `repr` of the object, and try to make it less ugly.
    # For example, given the object `{3: email.encoders}`:
    raw_result = repr(obj)
    # Our `raw_result` would be "{3: <module 'email.encoders' from
    # 'c:\Python25\lib\email\encoders.pyc'>}", which is not pretty at all. Our
    # goal is to take all these <nasty parts> from that string and replacing
    # them with the actual addresses of the objects, if possible.
    
    current_result = raw_result
        
    while True:

        current_result_changed = False
        
        ugly_reprs = _unresolvable_string_pattern.findall(current_result)
        
        for ugly_repr in ugly_reprs:
            # An `ugly_repr` is something like "<type 'list'>"
            
            # We try to extract an address from it:...
            re_match = _address_in_unresolvable_string_pattern.match(ugly_repr)
        
            # ...But if we can't, we just let it go ugly:
            if not re_match:
                continue
            
            address_of_ugly_repr = re_match.groups()[0]
            
            try:
                object_candidate = get_object_by_address(address_of_ugly_repr)
                # (Not using `root` and `namespace` cause it's an address
                # manufactured by `repr`.)
            except Exception:
                continue
            

            if repr(object_candidate) == ugly_repr:

                # We have a winner! We found the actual object that this
                # `ugly_repr` was trying to refer to:
                object_winner = object_candidate
                
                # Let's replace `ugly_repr` with the actual address of the
                # object:
                pretty_address = get_address(object_winner, root=root,
                                              namespace=namespace)
                current_result = current_result.replace(ugly_repr,
                                                        pretty_address)
                current_result_changed = True
          
        if current_result_changed:
            # We `continue` on the while loop, just in case some `ugly_repr` we
            # might be able to fix is still there:
            continue
        
        break
    
    return current_result


@caching.cache()
def get_address(obj, shorten=False, root=None, namespace={}):
    '''
    Get the address of a Python object.
    
    This only works for objects that have addresses, like modules, classes,
    functions, methods, etc. It usually doesn't work on instances created
    during the program. (e.g. `[1, 2]` doesn't have an address.)
    '''
    # todo: Support classes inside classes. Currently doesn't work because
    # Python doesn't tell us inside in which class an inner class was defined.
    # We'll probably have to do some kind of search.
    
    if not (isinstance(obj, types.ModuleType) or hasattr(obj, '__module__')):
        raise TypeError("`%s` is not a module, nor does it have a "
                        "`.__module__` attribute, therefore we can't get its "
                        "address." % (obj,))
    
    if isinstance(obj, types.ModuleType):
        address = obj.__name__
    elif isinstance(obj, types.MethodType):
        address = '.'.join((obj.__module__, obj.im_class.__name__,
                            obj.__name__))
    else:
        address= '.'.join((obj.__module__, obj.__name__))

    # Now our attempt at an address is in `address`. Let's `try` to resolve
    # that address to see if it's right and we get the same object:        
    try:
        object_candidate = get_object_by_address(address)
    except Exception:
        confirmed_object_address = False 
    else:
        is_same_object = \
            (obj == object_candidate) if isinstance(obj, types.MethodType) \
            else (obj is object_candidate)
        confirmed_object_address = is_same_object
        
    if not confirmed_object_address:
        # We weren't able to confirm that the `address` we got is the correct
        # one for this object, so we won't even try to shorten it in any way,
        # just return what we got and hoped we didn't disappoint the user too
        # badly:
        return address

    assert confirmed_object_address is True
    # We confirmed we got the right `address`! Now we can try to shorten it
    # some, if the user specified so in the arguments:

    ### Shortening the address using `root` and/or `namespace`: ###############
    #                                                                         #
    
    if root or namespace:
        
        # Ensuring `root` and `namespace` are actual objects:
        if isinstance(root, basestring):
            root = get_object_by_address(root)            
        if isinstance(namespace, basestring):
            namespace = get_object_by_address(namespace)


        if namespace:
            
            (_useless, original_namespace_dict) = \
                _get_parent_and_dict_from_namespace(namespace)
            
            def my_filter(key, value):
                name = getattr(value, '__name__', '')
                return isinstance(name, basestring) and name.endswith(key)

            namespace_dict = dict_tools.filter_items(
                original_namespace_dict,
                my_filter
            )
                
            namespace_dict_keys = namespace_dict.keys()
            namespace_dict_values = namespace_dict.values()
            
            
        # Split to address parts:
        address_parts = address.split('.')
        # e.g., `['garlicsim', 'misc', 'step_copy', 'StepCopy']`.
        
        heads = ['.'.join(address_parts[:i]) for i in
                 xrange(1, len(address_parts) + 1)]
        # `heads` is something like: `['garlicsim', 'garlicsim.misc',
        # 'garlicsim.misc.step_copy', 'garlicsim.misc.step_copy.StepCopy']`

        
        for head in reversed(heads):
            object_ = get_object_by_address(head)
            if root:
                if object_ is root:
                    root_short_name = root.__name__.rsplit('.', 1)[-1]
                    address = address.replace(head, root_short_name, 1)
                    break
            if namespace:
                if object_ in namespace_dict_values:
                    fitting_keys = [key for key in namespace_dict_keys if
                                    namespace_dict[key] is object_]
                    key = min(fitting_keys, key=len)
                    address = address.replace(head, key, 1)

    #                                                                         #
    ### Finshed shortening address using `root` and/or `namespace`. ###########
                    

    # If user specified `shorten=True`, let the dedicated `shorten_address`
    # function drop redundant intermediate nodes:
    if shorten:
        address = shorten_address(address, root=root, namespace=namespace)
        
    
    # A little fix to avoid describing something like `list` as
    # `__builtin__.list`:
    if address.startswith('__builtin__.'):
        shorter_address = address.replace('__builtin__.', '', 1)
        if get_object_by_address(shorter_address) == obj:
            address = shorter_address

            
    return address


def shorten_address(address, root=None, namespace={}):
    '''
    Shorten an address by dropping redundant intermediate nodes.
    
    For example, 'garlicsim.synchronous_crunching.simulate' could be shortened
    to 'garlicsim.simulate', because the `simulate` function is available at
    this shorter address as well.
    
    Note: `root` and `namespace` are only provided in order to access the
    object. This function doesn't do root- or namespace-shortening.
    '''

    assert _address_pattern.match(address)
    
    if '.' not in address:
        # It's a single-level address; nothing to shorten.
        return address
    
    original_address_parts = address.split('.')
    address_parts = original_address_parts[:]
    
    new_address = address
    
    for i in range(2 - len(original_address_parts), 1):
        
        if i == 0:
            i = None
            # Yeah, this is weird. When `i == 0`, I want to slice `[:i]` and
            # get everything. So I change `i` to `None`.
            
        head = '.'.join(address_parts[:i])

        # Let me explain what `head` is. Assume we got an address of
        # `a.b.c.d.e`, which is shortable to `a.b.d.e`. (Dropping the `c`
        # node.) So in this for loop we're iterating over the differnt "heads"
        # of the address. So `head` will first be `a.b`, then on the next
        # iteration `a.b.c`, then `a.b.c.d`, then finally `a.b.c.d.e`. (We're
        # skipping the first head `a` because a single-level address can't be
        # shortened.)
        
        # For every `head`, we try to `_tail_shorten` it:
        new_head = _tail_shorten(head, root=root, namespace=namespace)
        
        if new_head != head:
            # Tail-shortening was successful! So something like `a.b.c.d` was
            # shortened to `a.b.d`. We replace the old address with the new
            # short one:
            new_address = new_address.replace(head, new_head, 1)
            address_parts = address.split('.')
            
    # After we looped on all the different possible heads of the address and
    # tail-shortened each of them that we can, `new_address` has the
    # maximally-shortened address:
    return new_address


def _tail_shorten(address, root=None, namespace={}):
    '''
    Shorten an address by eliminating tails. Internal function.
    
    When we say tail here, we mean a tail ending just before the final node of
    the address, not including the final one. For example, the tails of
    'a.b.c.d.e' would be 'd', 'c.d', 'b.c.d' and 'a.b.c.d'.
    
    For example, if given an address 'a.b.c.d.e', we'll check if we can access
    the same object with 'a.b.c.e'. If so we try 'a.b.e'. If so we try 'a.e'.
    When it stops working, we take the last address that worked and return it.
    
    Note: `root` and `namespace` are only provided in order to access the
    object. This function doesn't do root- or namespace-shortening.
    '''
    if '.' not in address:
        # Nothing to shorten
        return address
    
    parent_address, child_name = address.rsplit('.', 1)
    child = get_object_by_address(address, root=root, namespace=namespace)
    
    current_parent_address = parent_address
    
    last_successful_parent_address = current_parent_address
    
    while True:
        # Removing the last component from the parent address:
        current_parent_address = '.'.join(
            current_parent_address.split('.')[:-1]
        )
        
        if not current_parent_address:
            # We've reached the top module and it's successful, can break now.
            break
        
        current_parent = get_object_by_address(current_parent_address,
                                               root=root,
                                               namespace=namespace)
        
        candidate_child = getattr(current_parent, child_name, None)
        
        if candidate_child is child:
            last_successful_parent_address = current_parent_address
        else:
            break
        
    return '.'.join((last_successful_parent_address, child_name))

    
from .string_to_object import get_object_by_address, resolve
########NEW FILE########
__FILENAME__ = shared
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Various objects and tools for `address_tools`.'''

import re


_address_pattern = re.compile(
    "^(?P<address>([a-zA-Z_][0-9a-zA-Z_]*)(\.[a-zA-Z_][0-9a-zA-Z_]*)*)$"
)
'''Pattern for Python addresses, like 'email.encoders'.'''


_contained_address_pattern = re.compile(
    "(?P<address>([a-zA-Z_][0-9a-zA-Z_]*)(\.[a-zA-Z_][0-9a-zA-Z_]*)*)"
)
'''
Pattern for strings containing Python addresses, like '{email.encoders: 1}'.
'''


def _get_parent_and_dict_from_namespace(namespace):
    '''
    Extract the parent object and `dict` from `namespace`.
    
    For the `namespace`, the user can give either a parent object
    (`getattr(namespace, address) is obj`) or a `dict`-like namespace
    (`namespace[address] is obj`).
    
    Returns `(parent_object, namespace_dict)`.
    '''
    
    if hasattr(namespace, '__getitem__') and hasattr(namespace, 'keys'):
        parent_object = None
        namespace_dict = namespace
        
    else:
        parent_object = namespace
        namespace_dict = vars(parent_object)
        
    return (parent_object, namespace_dict)
########NEW FILE########
__FILENAME__ = string_to_object
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Module for resolving strings into Python objects.'''

import types

from garlicsim.general_misc import import_tools
from garlicsim.general_misc import dict_tools
from garlicsim.general_misc import re_tools

# from . import object_to_string (at bottom of file.)
from .shared import (_contained_address_pattern, _address_pattern,
                     _get_parent_and_dict_from_namespace)


def resolve(string, root=None, namespace={}):
    '''
    Resolve an address into a Python object. A more powerful version of `eval`.
    
    The main advantage it has over `eval` is that it automatically imports
    whichever modules are needed to resolve the string.
    
    For example:
    
        >>> address_tools.resolve('[list, [1, 2], email]')
        [<type 'list'>, [1, 2], <module 'email' from
        'c:\Python27\lib\email\__init__.pyc'>]
        
    `root` is an object (usually a module) whose attributes will be looked at
    when searching for the object. `namespace` is a `dict` whose keys will be
    searched as well.
    '''
    
    # Resolving '' to `None`:
    if string == '':
        return None
    
    # If the string is a simple address, like 'email.encoders', our job is
    # easy:
    if _address_pattern.match(string):        
        return get_object_by_address(string, root=root, namespace=namespace)

    # Getting the true namespace `dict`:
    (_useless, namespace_dict) = _get_parent_and_dict_from_namespace(namespace)
    
    # We're putting items into `our_namespace` instead of using the given
    # namespace `dict`:...
    our_namespace = {}
    our_namespace.update(namespace_dict)
    # ...because we intend to modify it, and we don't want to be modifying the
    # user's arguments.
    
    # The string that we have is not a plain address, but it may contain plain
    # addresses. For example, '{email.encoders: 1}' contains an address. We
    # find all these contained addresses:
    re_matches = re_tools.searchall(_contained_address_pattern, string)
    addresses = [re_match.group('address') for re_match in re_matches]
    
    # We make sure all the addresses are (1) imported and (2) in
    # `our_namespace` dict, so we could access them when we `eval` the string:
    for address in addresses:
        try:
            get_object_by_address(address, root=root, namespace=namespace)
        except Exception:
            pass
        else:
            big_parent_name = address.split('.', 1)[0] 
            big_parent = get_object_by_address(big_parent_name, root=root,
                                                namespace=namespace)
            our_namespace[big_parent_name] = big_parent
            
    
    return eval(string, our_namespace)
    

def get_object_by_address(address, root=None, namespace={}):
    '''
    Get an object by its address.
    
    For example:
    
        >>> get_object_by_address('email.encoders')
        <module 'email.encoders' from 'c:\Python27\lib\email\encoders.pyc'>
    
    `root` is an object (usually a module) whose attributes will be looked at
    when searching for the object. `namespace` is a `dict` whose keys will be
    searched as well.    
    '''
    # todo: should know what exception this will raise if the address is bad /
    # object doesn't exist.
    
    if not _address_pattern.match(address):
        raise ValueError("'%s' is not a legal address." % address)
    
    ###########################################################################
    # Before we start, we do some pre-processing of `root` and `namespace`:   #
    
    # We are letting the user input (base)strings for `root` and `namespace`,
    # so if he did that, we'll get the actual objects.
    
    if root:
        # First for `root`:
        if isinstance(root, basestring):
            root = get_object_by_address(root)
        root_short_name = root.__name__.rsplit('.', 1)[-1]
        
    if namespace:
        # And then for `namespace`:
        if isinstance(namespace, basestring):
            namespace = get_object_by_address(namespace)
            
        parent_object, namespace_dict = _get_parent_and_dict_from_namespace(
            namespace
        )
    else:
        parent_object, namespace_dict = None, None
            
        
    # Finished pre-processing `root` and `namespace`.                         #
    ###########################################################################
    
    
    ###########################################################################
    # The implementation is recursive: We handle the case of a single-level
    # address, like 'email'. If we get a multi-level address (i.e. contains a
    # dot,) like 'email.encoders', we use this function twice, first to get
    # `email`, and then from it to get `email.encoders`.
    
    if '.' not in address:
        
        ### Here we solve the basic case of a single-level address: ###########
        #                                                                     #
        
        # Let's rule out the easy option that the requested object is the root:
        if root and (address == root_short_name):
            return root
    
        if parent_object:
                
            if isinstance(parent_object, types.ModuleType) and \
               hasattr(parent_object, '__path__'):
                                
                # `parent_object` is a package. The wanted object may be a
                # module. Let's try importing it:
                
                import_tools.import_if_exists(
                    '.'.join((parent_object.__name__, address)),
                    silent_fail=True
                )
                # Not keeping reference, just importing so we could get later.
        
        # We know we have a `namespace_dict` to take the object from, and we
        # might have a `parent_object` we can take the object from by using
        # `getattr`. We always have a `namespace_dict`, but not always a
        # `parent_object`.
        #
        
        
        # We are going to prefer to do `getattr` from `parent_object`, if one
        # exists, rather than using `namespace_dict`. This is because some
        # attributes may not be present on an object's `__dict__`, and we want
        # to be able to catch them:
        
        # The first place we'll try to take the object from is the
        # `parent_object`. We try this before `namespace_dict` because
        # `parent_object` may have `__getattr__` or similar magic and our
        # object might be found through that:
        if parent_object and hasattr(parent_object, address):
            return getattr(parent_object, address)
        
        # Next is the `namespace_dict`:
        elif namespace_dict and (address in namespace_dict):
            return namespace_dict[address]
        
        # Last two options:
        else:
            try:
                # It may be a built-in:
                return eval(address) 
            except Exception:
                # Or a module:
                return import_tools.normal_import(address)
        
        #                                                                     #
        ### Finished solving the basic case of a single-level address. ########
            
        
    else: # '.' in address
        
        ### If we get a composite address, we solve recursively: ##############
        #                                                                     #
        
        first_object_address, second_object_address = address.rsplit('.', 1)
        
        first_object = get_object_by_address(first_object_address, root=root,
                                             namespace=namespace)

        second_object = get_object_by_address(second_object_address,
                                              namespace=first_object)
        
        return second_object
    
        #                                                                     #
        ### Finished solving recursively for a composite address. #############
        

from . import object_to_string
########NEW FILE########
__FILENAME__ = arguments_profile
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `ArgumentsProfile` class.

See its documentation for more details.
'''

from garlicsim.general_misc import cute_inspect
from garlicsim.general_misc import cheat_hashing
from garlicsim.general_misc.nifty_collections import OrderedDict
from garlicsim.general_misc import dict_tools
from garlicsim.general_misc import cmp_tools
from garlicsim.general_misc.infinity import infinity


class ArgumentsProfile(object):
    '''
    A canonical arguments profile for a function.
    
    (This should be used only on functions that don't modify the arguments they
    receive. Also, you should never modify any arguments you use in an
    arguments profile, even outside the function.)
    
    What is an arguments profile and what is it good for?
    
    It's possible to call the same function with the same arguments in
    different ways. For example, take this function:

        def f(a, bb=2, ccc=3, **kwargs):
            return (a, bb, ccc)
            
    You can call it like `f(1)` or `f(a=1)` or `f(1, ccc=3, bb=2, **{})` or
    many other different ways which will result in exactly the same arguments.
    
    To organize the different ways a function can be called, an arguments
    profile provides a canonical way to call the function, so all the different
    examples in the last paragraphs would be reduced to the same canonical
    arguments profile. (In this case `f(1)`.)
    
    The canonical arguments profile is defined as the one which satisfies the
    following criteria, with the first one being the most important, the second
    one being a tie-breaker to the first, and the third one being a tie-breaker
    to the second:
    
     1. It has as few characters as possible. (e.g. `f(1)` is better than    
        `f(1, 2)`.)
        
     2. It has as many keyword arguments as possible. (e.g. `f(bb=3)` is
        better than `f(1, 3)`.)
        
     3. The extraneous keywords (i.e. `**kwargs`) are sorted alphabetically, 
        with "_" being the highest/last character. (e.g. `f(1, cat=7, meow=7,
        _house=7)` is better than `f(1, _house=7, meow=7, cat=7)`)
    
    # Accessing the data of an arguments profile #
    
    Say you have this function:
    
        def f(x, y, *args, **kwargs):
            pass
    
    And you create an arguments profile:
    
        arguments_profile = ArgumentsProfile(f, 1, 2, 3, 4, meow='frr')
            
    There are two ways to access the data of this arguments profile:
    
     1. Use `arguments_profile.args` and `arguments_profile.kwargs`, which are,
        respectively, a tuple of positional arguments and an ordered dict of
        keyword arguments. In this case, `.args` would be `(1, 2, 3, 4)` and
        `.kwargs` would be `OrderedDict((('meow', 'frr'),))`.
        
     2. Use `arguments_profile`'s ordered-dict-like interface. A few examples:
     
            arguments_profile['x'] == 1
            arguments_profile['y'] == 2
            arguments_profile['*'] == (3, 4)
            arguments_profile['meow'] == 'frr'
            
        The special asterisk argument indicates the arguments that go into
        `*args`.
        
    '''
    # todo: we're using an ad-hoc third way, `self.getcallargs_result`, think
    # hard about that...
    
    def __init__(self, function, *args, **kwargs):
        '''
        Construct the arguments profile.
        
        `*args` and `**kwargs` are the arguments that go into the `function`.
        '''
        
        if not callable(function):
            raise Exception('%s is not a callable object.' % function)
        self.function = function
        
        raw_args = args
        raw_kwargs = kwargs
        del args, kwargs
        
        self.args = ()
        '''Tuple of positional arguments.'''
        
        self.kwargs = OrderedDict()
        '''Ordered dict of keyword arguments.'''
        
        
        args_spec = cute_inspect.getargspec(function)
        
        (s_args, s_star_args, s_star_kwargs, s_defaults) = args_spec
        
        # `getargspec` has a weird policy, when inspecting a function with no
        # defaults, to give a `defaults` of `None` instead of the more
        # consistent `()`. We fix that here:
        if s_defaults is None:
            s_defaults = ()
        
        getcallargs_result = cute_inspect.getcallargs(function,
                                                      *raw_args,
                                                      **raw_kwargs)
        self.getcallargs_result = getcallargs_result
        
        
        # The number of args which have default values:
        n_defaultful_args = len(s_defaults)
        # The word "defaultful" means "something which has a default."
        
        #######################################################################
        #######################################################################
        # Now we'll create the arguments profile, using a 4-phases algorithm. #
        #                                                                     #
        
        #######################################################################
        # Phase 1: We specify all the args that don't have a default as
        # positional args:
        defaultless_args = s_args[:-n_defaultful_args] if n_defaultful_args \
                           else s_args[:]
        self.args += tuple(
            dict_tools.get_list(getcallargs_result, defaultless_args)
        )

        
        #######################################################################
        # Phase 2: We now have to deal with args that have a default. Some of
        # them, possibly none and possibly all of them, should be given
        # positionally. Some of them, possibly none, should be given by
        # keyword. And some of them, possibly none and possibly all of them,
        # should not be given at all. It is our job to figure out in which way
        # each argument should be given.
        
        # In this variable:
        n_defaultful_args_to_specify_positionally = None
        # We will put the number of defaultful arguments that should be
        # specified positionally.
        
        defaultful_args = s_args[-n_defaultful_args:] if n_defaultful_args \
                          else []
        
        # `dict` that maps from argument name to default value:
        defaults = OrderedDict(zip(defaultful_args, s_defaults))
        
        defaultful_args_differing_from_defaults = set((
            defaultful_arg for defaultful_arg in defaultful_args
            if defaults[defaultful_arg] != getcallargs_result[defaultful_arg]
        ))
        
        if s_star_args and getcallargs_result[s_star_args]:
            # We have some arguments that go into `*args`! This means that we
            # don't even need to think hard, we can already be sure that we're
            # going to have to specify *all* of the defaultful arguments
            # positionally, otherwise it will be impossible to put arguments in
            # `*args`.
            n_defaultful_args_to_specify_positionally = n_defaultful_args
            
            
        else:

            # `dict` mapping from each defaultful arg to the "price" of
            # specifying its value:
            prices_of_values = OrderedDict((
                (defaultful_arg, len(repr(getcallargs_result[defaultful_arg])))
                 for defaultful_arg in defaultful_args
            ))
            # The price is simply the string length of the value's `repr`.
            
            # `dict` mapping from each defaultful arg to the "price" of
            # specifying it as a keyword (not including the length of the
            # value):
            prices_of_keyword_prefixes = OrderedDict(
                ((defaultful_arg, len(defaultful_arg)+1) for 
                 defaultful_arg in defaultful_args)
            )
            # For example, if we have a defaultful arg "gravity_strength", then
            # specifiying it by keyword will require using the string
            # "gravity_strength=", which is 17 characters long, therefore the
            # price is 17.
            
            # Now we need to decide just how many defaultful args we are going
            # to specify positionally. The options are anything from `0` to
            # `n_defaultful_args`. We're going to go one by one, and calcluate
            # the price for each candidate, and put it in this dict:
            total_price_for_n_dasp_candidate = OrderedDict()
            # (The `n_dasp` here is an abbreivation of the
            # `n_defaultful_args_to_specify_positionally` variable defined
            # before.)
            #
            # After we have the price for each option, we'll select the one
            # with the lowest price.
            
            # One thing to do before iterating on the candidates is to find out
            # whether the "lonely comma discount" is in effect.
            #
            # The "lonely comma discount" is given when there's nothing but
            # defaultful arguments to this function, and therefore the number
            # of ", " strings needed here is not `candidate`, but `candidate -
            # 1`, unless of course candidate is zero.
            
            if not defaultless_args and \
                (not s_star_args or not getcallargs_result[s_star_args]) and \
                (not s_star_kwargs or not getcallargs_result[s_star_kwargs]):
                
                lonely_comma_discount_may_be_given = True
            
            else:
                
                lonely_comma_discount_may_be_given = False
            
            # Now we iterate on the candidates to find out which one has the
            # lowest price:
            
            for candidate in xrange(n_defaultful_args + 1):

                defaultful_args_to_specify_positionally = \
                    defaultful_args[:candidate]
                
                price_for_positionally_specified_defaultful_args = \
                    2 * candidate + \
                    sum(
                        dict_tools.get_list(
                            prices_of_values,
                            defaultful_args_to_specify_positionally
                        )
                    )
                # The `2 * candidate` addend is to account for the ", " parts
                # between the arguments.
                    
                defaultful_args_to_specify_by_keyword = filter(
                    defaultful_args_differing_from_defaults.__contains__,
                    defaultful_args[candidate:]
                )
                
                price_for_defaultful_args_specified_by_keyword = \
                    2 * len(defaultful_args_to_specify_by_keyword) + \
                    sum(
                        dict_tools.get_list(
                            prices_of_keyword_prefixes,
                            defaultful_args_to_specify_by_keyword
                        )
                    ) + \
                    sum(
                        dict_tools.get_list(
                            prices_of_values,
                            defaultful_args_to_specify_by_keyword
                        )
                    )
                # The `2 * len(...)` addend is to account for the ", " parts
                # between the arguments.
                
                # Now we need to figure out if this candidate gets the "lonely
                # comma discount".
                if lonely_comma_discount_may_be_given and \
                   (defaultful_args_to_specify_by_keyword or \
                    defaultful_args_to_specify_positionally):
                    
                    lonely_comma_discount = -2
                    
                else:
                    lonely_comma_discount = 0
                
                price = price_for_positionally_specified_defaultful_args + \
                        price_for_defaultful_args_specified_by_keyword + \
                        lonely_comma_discount
                
                total_price_for_n_dasp_candidate[candidate] = price


            # Finished iterating on candidates! Time to pick our winner.
                
            minimum_price = min(total_price_for_n_dasp_candidate.itervalues())
            
            leading_candidates = [
                candidate for candidate in 
                total_price_for_n_dasp_candidate.iterkeys() if
                total_price_for_n_dasp_candidate[candidate] == minimum_price
            ]
            
            if len(leading_candidates) == 1:
                # We finished with one candidate which has the minimum price.
                # This is our winner.
                (winner,) = leading_candidates
                n_defaultful_args_to_specify_positionally = winner
            
            else:
                # We have a draw! We're gonna have to settle it by picking the
                # lowest candidate, because in our definition of "canonical
                # arguments profile", our second priority after "as few
                # characters as possible" is "as many keyword arguments as
                # possible".
                winner = leading_candidates[0]
                
            n_defaultful_args_to_specify_positionally = winner
            
        # We have a winner! Now we know exactly which defaultful args should
        # be specified positionally and which should be specified by
        # keyword.
            
        # First we add the positionally specified:
            
        defaultful_args_to_specify_positionally = \
            defaultful_args[:n_defaultful_args_to_specify_positionally]
        self.args += tuple(
            (getcallargs_result[defaultful_arg] for defaultful_arg
             in defaultful_args_to_specify_positionally)
        )
        
        # Now we add those specified by keyword:

        defaultful_args_to_specify_by_keyword = filter(
                defaultful_args_differing_from_defaults.__contains__,
                defaultful_args[n_defaultful_args_to_specify_positionally:]
            )
        for defaultful_arg in defaultful_args_to_specify_by_keyword:
            self.kwargs[defaultful_arg] = getcallargs_result[defaultful_arg]
                
        
        #######################################################################
        # Phase 3: Add the star args:
        
        if s_star_args and getcallargs_result[s_star_args]:
            
            assert not self.kwargs
            # Just making sure that no non-star args were specified by keyword,
            # which would make it impossible for us to put stuff in `*args`.
            
            self.args += getcallargs_result[s_star_args]        

            
        #######################################################################
        # Phase 4: Add the star kwargs:
        
        if s_star_kwargs and getcallargs_result[s_star_kwargs]:
            
            # We can't just add the `**kwargs` as is; we need to add them
            # according to canonical ordering. So we need to sort them first.
            
            unsorted_star_kwargs_names = \
                getcallargs_result[s_star_kwargs].keys()
            sorted_star_kwargs_names = sorted(
                unsorted_star_kwargs_names,
                cmp=cmp_tools.underscore_hating_cmp
            )
            
            sorted_star_kwargs = OrderedDict(
                zip(
                    sorted_star_kwargs_names,
                    dict_tools.get_list(
                        getcallargs_result[s_star_kwargs],
                        sorted_star_kwargs_names
                    )
                )
            )
            
            
            self.kwargs.update(sorted_star_kwargs)
            
        # Our 4-phases algorithm is done! The argument profile is canonical.  #
        #######################################################################
        #######################################################################
        
        
        #######################################################################
        # Now a bit of post-processing:
        
        _arguments = OrderedDict()
        
        dict_of_positional_arguments = OrderedDict(
            dict_tools.filter_items(
                getcallargs_result,
                lambda key, value: ((key not in self.kwargs) and \
                                    (key != s_star_args) and \
                                    (key != s_star_kwargs))
            )
        )
        dict_of_positional_arguments.sort(key=s_args.index)
        _arguments.update(dict_of_positional_arguments)
        
        if s_star_args:
            _arguments['*'] = getcallargs_result[s_star_args]
            
        _arguments.update(self.kwargs)
        
        self._arguments = _arguments
        '''Ordered dict of arguments, both positional- and keyword-.'''
        
        # Caching the hash, since its computation can take a long time:
        self._hash = cheat_hashing.cheat_hash(
            (
                self.function,
                self.args,
                tuple(self.kwargs)
            )
        )
        
        
    def __getitem__(self, argument_name):
        '''Get the value of a specified argument.'''
        return self._arguments.__getitem__(argument_name)
        
    
    def get(self, argument_name, default=None):
        '''Get the value of a specified argument, if missing get `default`.'''
        return self._arguments.get(argument_name, default)
    
    
    def keys(self):
        '''Get all the argument names.'''
        return self._arguments.keys()
    
    
    def values(self):
        '''Get all the argument values.'''
        return self._arguments.values()
    
    
    def items(self):
        '''Get a tuple of all the `(argument_name, argument_value)` item.'''
        return self._arguments.items()
    
    
    def __iter__(self):
        '''Iterate on the argument names according to their order.'''
        return self._arguments.__iter__()
    
    
    def iterkeys(self):
        '''Iterate on the argument names according to their order.'''
        return self._arguments.iterkeys()
    
    
    def itervalues(self):        
        '''Iterate on the argument value according to their order.'''
        return self._arguments.itervalues()
        
    
    def iteritems(self):
        '''Iterate on `(argument_name, argument_value)` items by order.'''
        return self._arguments.iteritems()
    
    
    def __contains__(self, argument_name):
        '''Return whether the arguments profile contains the given argument.'''
        return self._arguments.__contains__(argument_name)
    
    
    @classmethod
    def create_from_dld_format(cls, function, args_dict, star_args_list,
                               star_kwargs_dict):
        '''
        Create an arguments profile from data given in "dict-list-dict" format.
        
        The "dict-list-dict" format means that in addition to a function, we
        get a `dict` of arguments, a `list` of `*args`, and a `dict` of
        `**kwargs`.
        '''
        args_spec = cute_inspect.getargspec(function)
        new_args = [args_dict[name] for name in args_spec.args] + \
                   list(star_args_list)
        return cls(function, *new_args, **star_kwargs_dict)
        
            
                    
    def __eq__(self, other):
        # todo: maybe raise warning when unbound method is compared with same
        # method just bound with the object passed to the unbound method, and
        # the result of both functions would be the same, but we're not smart
        # enough to say it's the same arguments profile, so raise a warning.
        if not isinstance(other, ArgumentsProfile):
            return NotImplemented
        # Note that we're comparing the functions with a `==` here. This lesson
        # cost me a couple of days: `MyClass.method == MyClass.method` but
        # `MyClass.method is not MyClass.method`.
        return (self.function == other.function) and \
               (self.args == other.args) and \
               (self.kwargs == other.kwargs)
    
    
    def __hash__(self):
        return self._hash
                    

########NEW FILE########
__FILENAME__ = binary_search_profile
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `BinarySearchProfile` class.

See its documentation for more info.
'''


from .roundings import (Rounding, roundings, LOW, LOW_IF_BOTH,
                        LOW_OTHERWISE_HIGH, HIGH, HIGH_IF_BOTH,
                        HIGH_OTHERWISE_LOW, EXACT, CLOSEST, CLOSEST_IF_BOTH,
                        BOTH)

from .functions import (binary_search, binary_search_by_index,
                        make_both_data_into_preferred_rounding)
        
        
class BinarySearchProfile(object):
    '''
    A profile of binary search results.
    
    A binary search profile allows to access all kinds of aspects of the
    results of a binary search, while not having to execute the search more
    than one time.
    '''
    
    def __init__(self, sequence, function, value, both=None):
        '''
        Construct a `BinarySearchProfile`.
        
        `sequence` is the sequence through which the search is made. `function`
        is a monotonically rising function on the sequence. `value` is the
        wanted value.
        
        In the `both` argument you may put binary search results (with the BOTH
        rounding option.) This will prevent the constructor from performing the
        search itself. It will use the results you provided when giving its
        analysis.
        '''

        if both is None:
            both = binary_search(sequence, function, value, BOTH)
        
        self.results = {}
        '''
        `results` is a dict from rounding options to results that were obtained
        using each function.
        '''
        
        for rounding in roundings:
            self.results[rounding] = \
                make_both_data_into_preferred_rounding(both, function, value,
                                                       rounding)
        none_count = list(both).count(None)
        
        self.all_empty = (none_count == 2)
        '''Flag saying whether the sequence is completely empty.'''
        
        self.one_side_empty = (none_count == 1)
        '''Flag saying whether the value is outside the sequence's scope.'''
        
        self.is_surrounded = (none_count == 0)
        '''Flag saying whether the value is inside the sequence's scope.'''
            
        self.had_to_compromise = {
            LOW_OTHERWISE_HIGH:
                self.results[LOW_OTHERWISE_HIGH] is not self.results[LOW],
            HIGH_OTHERWISE_LOW:
                self.results[HIGH_OTHERWISE_LOW] is not self.results[HIGH],
        }
        '''
        Dictionary from "otherwise"-style roundings to bool.
        
        What this means is whether the "otherwise" route was taken. See
        documentation of LOW_OTHERWISE_HIGH for more info.
        '''
        
        self.got_none_because_no_item_on_other_side = {
            LOW_IF_BOTH:
                self.results[LOW_IF_BOTH] is not self.results[LOW],
            HIGH_IF_BOTH:
                self.results[HIGH_IF_BOTH] is not self.results[HIGH],
            CLOSEST_IF_BOTH:
                self.results[CLOSEST_IF_BOTH] is not self.results[CLOSEST],
        }
        '''
        Dictionary from "if both"-style roundings to bool.
        
        What this means is whether the result was none because the BOTH result
        wasn't full. See documentation of LOW_IF_BOTH for more info.
        '''
        
        for d in [self.had_to_compromise,
                  self.got_none_because_no_item_on_other_side]:
            
            for rounding in roundings:
                if rounding not in d:
                    d[rounding] = None
        
########NEW FILE########
__FILENAME__ = functions
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Module for doing a binary search in a sequence.'''

# Todo: wrap all things in tuples?
# 
# todo: add option to specify `cmp`.
# 
# todo: i think `binary_search_by_index` should have the core logic, and the
# other one will use it. I think this will save many sequence accesses, and
# some sequences can be expensive.
#
# todo: ensure there are no `if variable` checks where we're thinking of None
# but the variable might be False

from .roundings import (Rounding, roundings, LOW, LOW_IF_BOTH,
                        LOW_OTHERWISE_HIGH, HIGH, HIGH_IF_BOTH,
                        HIGH_OTHERWISE_LOW, EXACT, CLOSEST, CLOSEST_IF_BOTH,
                        BOTH)

def binary_search_by_index(sequence, function, value, rounding=CLOSEST):
    '''
    Do a binary search, returning answer as index number.
    
    Similiar to binary_search (refer to its documentation for more info). The
    difference is that instead of returning a result in terms of sequence
    items, it returns the indexes of these items in the sequence.
    
    For documentation of rounding options, check `binary_search.roundings`.
    ''' 
    if function is None:
        function = lambda x: x
    my_range = xrange(len(sequence))
    fixed_function = lambda index: function(sequence[index])
    result = binary_search(my_range, fixed_function, value, rounding)
    return result


def binary_search(sequence, function, value, rounding=CLOSEST):
    '''
    Do a binary search through a sequence.
    
    It is assumed that `function` is a monotonic rising function on `sequence`.
    
    For all rounding options, a return value of None is returned if no matching
    item is found. (In the case of `rounding=BOTH`, either of the items in the
    tuple may be `None`)
    
    Note: This function uses `None` to express its inability to find any
    matches; therefore, you better not use it on sequences in which None is a
    possible item.
    
    For documentation of rounding options, check `binary_search.roundings`.
    '''
    
    # todo: can break this into `__binary_search_with_both_rounding`

    # todo: i think this should be changed to return tuples
    
    assert issubclass(rounding, Rounding)
    
    if function is None:
        function = lambda x: x
    
    if not sequence:
        if rounding is BOTH:
            return (None, None)
        else:
            return None
    
    get = lambda number: function(sequence[number])

    low = 0
    high = len(sequence) - 1

    low_value, high_value = get(low), get(high)

    
    if low_value >= value:

        if rounding is BOTH:
            return tuple((None if low_value > value else
                          sequence[low], sequence[low]))
        
        if rounding in (HIGH, HIGH_OTHERWISE_LOW, CLOSEST) or \
           (low_value==value and rounding is EXACT):
            return sequence[low]
        
        else:
            # rounding in (LOW*, *_IF_BOTH) or (rounding is EXACT and
            # low_value!=value)
            return None

        
    if high_value <= value:

        if rounding is BOTH:
            return (sequence[high],
                    None if high_value < value else sequence[high])
        
        if rounding in (LOW, LOW_OTHERWISE_HIGH, CLOSEST) or \
           (low_value==value and rounding is EXACT):
            return sequence[high]
        
        else:
            # rounding in (HIGH*, *_IF_BOTH) or (rounding is EXACT and
            # low_value!=value)
            return None
        

    # Now we know the value is somewhere inside the sequence.
    
    
    while high - low > 1:
        medium = (low + high) // 2
        medium_value = get(medium)
        if medium_value > value:
            high = medium; high_value = medium_value
            continue
        if medium_value < value:
            low = medium; low_value = medium_value
            continue
        if medium_value == value:
            if rounding is BOTH:
                return (sequence[medium], sequence[medium])
            after_medium = medium + 1;
            after_medium_value = get(after_medium)
            if after_medium_value == value:
                low = medium; low_value = medium_value
                high = after_medium; high_value = after_medium_value
                break
            else: # get(medium+1) > value
                high = medium; high_value = medium_value
                low = medium - 1; low_value = get(low)
                break
    
    both = (sequence[low], sequence[high])
    
    return make_both_data_into_preferred_rounding(both, function,
                                                  value, rounding)


def make_both_data_into_preferred_rounding(both, function, value, rounding):
    '''
    Convert results gotten using `BOTH` to a different rounding option.
    
    This function takes the return value from `binary_search` (or other such
    functions) with `rounding=BOTH` as the parameter `both`. It then gives the
    data with a different rounding, specified with the parameter `rounding`.
    '''
    # todo optimize and organize: break to individual functions, put in
    # `BinarySearchProfile`
    if rounding is BOTH:
        return both
    
    elif rounding is LOW:
        return both[0]
    
    elif rounding is LOW_IF_BOTH:
        return both[0] if both[1] is not None else None
    
    elif rounding is LOW_OTHERWISE_HIGH:
        return both[0] if both[0] is not None else both[1]
    
    elif rounding is HIGH:
        return both[1]
    
    elif rounding is HIGH_IF_BOTH:
        return both[1] if both[0] is not None else None
    
    elif rounding is HIGH_OTHERWISE_LOW:
        return both[1] if both[1] is not None else both[0]
    
    elif rounding is EXACT:
        results = [state for state in both if
                   (state is not None and function(state) == value)]
        return results[0] if results else None
    
    elif rounding in (CLOSEST, CLOSEST_IF_BOTH):
        if rounding is CLOSEST_IF_BOTH:
            if None in both:
                return None
        if both[0] is None: return both[1]
        if both[1] is None: return both[0]
        distances = [abs(function(state)-value) for state in both]
        if distances[0] <= distances[1]:
            return both[0]
        else:
            return both[1]
        
        
########NEW FILE########
__FILENAME__ = roundings
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Defines different rounding options for binary search.'''

# todo: Confirm that `*_IF_BOTH` options are used are used in all places that
# currently ~use them.

class Rounding(object):
    '''Base class for rounding options for binary search.'''


    
class BOTH(Rounding):
    '''
    Get a tuple `(low, high)` of the 2 items that surround the specified value.
    
    If there's an exact match, gives it twice in the tuple, i.e. `(match,
    match)`.
    '''
    
class EXACT(Rounding):
    '''Get the item that has exactly the same value has the specified value.'''
    
    
class CLOSEST(Rounding):
    '''Get the item which has a value closest to the specified value.'''

    
class LOW(Rounding):
    '''
    Get the item with a value that is just below the specified value.
    
    i.e. the highest item which has a value lower or equal to the specified
    value.
    '''

    
class HIGH(Rounding):
    '''
    Get the item with a value that is just above the specified value.
    
    i.e. the lowest item which has a value higher or equal to the specified
    value.
    '''

    
class LOW_IF_BOTH(Rounding):
    '''
    Get the item with a value that is just below the specified value.
    
    i.e. the highest item which has a value lower or equal to the specified
    value.
    
    Before it returns the item, it checks if there also exists an item with a
    value *higher* than the specified value. If there isn't, it returns `None`.
    '''
    
    
class HIGH_IF_BOTH(Rounding):
    '''
    Get the item with a value that is just above the specified value.
    
    i.e. the lowest item which has a value higher or equal to the specified
    value.
    
    Before it returns the item, it checks if there also exists an item with a
    value *lower* than the specified value. If there isn't, it returns `None`.
    '''
    
    
class CLOSEST_IF_BOTH(Rounding):
    '''
    Get the item which has a value closest to the specified value.
    
    Before it returns the item, it checks if there also exists an item which is
    "on the other side" of the specified value. e.g. if the closest item is
    higher than the specified item, it will confirm that there exists an item
    *below* the specified value. (And vice versa.) If there isn't it returns
    `None`.

    '''
    
class LOW_OTHERWISE_HIGH(Rounding):
    '''
    Get the item with a value that is just below the specified value.
    
    i.e. the highest item which has a value lower or equal to the specified
    value.
    
    If there is no item below, give the one just above.
    '''

    
class HIGH_OTHERWISE_LOW(Rounding):
    '''
    Get the item with a value that is just above the specified value.
    
    i.e. the lowest item which has a value higher or equal to the specified
    value.
    
    If there is no item above, give the one just below.
    '''

    
roundings = (LOW, LOW_IF_BOTH, LOW_OTHERWISE_HIGH, HIGH, HIGH_IF_BOTH,
             HIGH_OTHERWISE_LOW, EXACT, CLOSEST, CLOSEST_IF_BOTH, BOTH)
'''List of all the available roundings.'''
########NEW FILE########
__FILENAME__ = cache
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `cache` decorator.

See its documentation for more details.
'''
# todo: examine thread-safety

import functools

from garlicsim.general_misc import decorator_tools

from garlicsim.general_misc.sleek_refs import SleekCallArgs
from garlicsim.general_misc.infinity import infinity
from garlicsim.general_misc import misc_tools
from garlicsim.general_misc.nifty_collections import OrderedDict


@decorator_tools.helpful_decorator_builder
def cache(max_size=infinity):
    '''
    Cache a function, saving results so they won't have to be computed again.
    
    This decorator understands function arguments. For example, it understands
    that for a function like this:

        @cache()
        def f(a, b=2):
            return whatever
            
    The calls `f(1)` or `f(1, 2)` or `f(b=2, a=1)` are all identical, and a
    cached result saved for one of these calls will be used for the others.
    
    All the arguments are sleekreffed to prevent memory leaks. Sleekref is a
    variation of weakref. Sleekref is when you try to weakref an object, but if
    it's non-weakreffable, like a `list` or a `dict`, you maintain a normal,
    strong reference to it. (See documentation of
    `garlicsim.general_misc.sleek_refs` for more details.) Thanks to
    sleekreffing you can avoid memory leaks when using weakreffable arguments,
    but if you ever want to use non-weakreffable arguments you are still able
    to. (Assuming you don't mind the memory leaks.)
    
    You may optionally specify a `max_size` for maximum number of cached
    results to store; old entries are thrown away according to a
    least-recently-used alogrithm. (Often abbreivated LRU.)
    '''
    # todo idea: figure how how complex the function's argspec is, and then
    # compile a function accordingly, so functions with a simple argspec won't
    # have to go through so much shit. update: probably it will help only for
    # completely argumentless function. so do one for those.

    def decorator(function):
        
        # In case we're being given a function that is already cached:
        if getattr(function, 'is_cached', False): return function
        
        if max_size == infinity:
            
            cache_dict = {}

            def cached(function, *args, **kwargs):
                sleek_call_args = \
                    SleekCallArgs(cache_dict, function, *args, **kwargs)
                try:
                    return cached._cache[sleek_call_args]
                except KeyError:
                    cached._cache[sleek_call_args] = value = \
                          function(*args, **kwargs)
                    return value
    
        else: # max_size < infinity
            
            cache_dict = OrderedDict()
            
            def cached(function, *args, **kwargs):
                sleek_call_args = \
                    SleekCallArgs(cache_dict, function, *args, **kwargs)
                try:
                    result = cached._cache[sleek_call_args]
                    cached._cache.move_to_end(sleek_call_args)
                    return result
                except KeyError:
                    cached._cache[sleek_call_args] = value = \
                        function(*args, **kwargs)
                    if len(cached._cache) > max_size:
                        cached._cache.popitem(last=False)
                    return value
                    
        cached._cache = cache_dict
        
        result = decorator_tools.decorator(cached, function)
        
        def cache_clear():
            '''Clear the cache, deleting all saved results.'''
            cached._cache.clear()    
        result.cache_clear = cache_clear
        
        result.is_cached = True
        
        return result
        
    return decorator

########NEW FILE########
__FILENAME__ = cached_property
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `CachedProperty` class.

See its documentation for more details.
'''


class CachedProperty(object):
    '''
    A property that is calculated (a) lazily and (b) only once for an object.
    
    Usage:
    
        class MyObject(object):
        
            # ... Regular definitions here
        
            def _get_personality(self):
                print('Calculating personality...')
                time.sleep(5) # Time consuming process that creates personality
                return 'Nice person'
        
            personality = CachedProperty(_get_personality)
    
    '''
    def __init__(self, getter, doc=None, name=None):
        '''
        Construct the cached property.
        
        You may optionally pass in the name that this property has in the
        class; this will save a bit of processing later.
        '''
        self.getter = getter
        self.our_name = name
        self.__doc__ = doc or getattr(getter, '__doc__', None)
        
        
    def __get__(self, obj, our_type=None):

        if obj is None:
            # We're being accessed from the class itself, not from an object
            return self
        
        value = self.getter(obj)
        
        if not self.our_name:
            if not our_type:
                our_type = type(obj)
            (self.our_name,) = (name for name in dir(our_type) if
                                getattr(our_type, name, None) is self)
        
        setattr(obj, self.our_name, value)
        
        return value

    

########NEW FILE########
__FILENAME__ = cached_type
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `CachedType` metaclass.

See its documentation for more details.
'''

from garlicsim.general_misc.sleek_refs import SleekCallArgs


class SelfPlaceholder(object):
    '''Placeholder for `self` when storing call-args.''' 


class CachedType(type):
    '''
    A metaclass for sharing instances.
        
    For example, if you have a class like this:
    
        class Grokker(object):
            
            __metaclass__ = caching.CachedType
            
            def __init__(self, a, b=2):
                self.a = a
                self.b = b
                
    Then all the following calls would result in just one instance:
    
        Grokker(1) is Grokker(1, 2) is Grokker(b=2, a=1) is Grokker(1, **{})
    
    This metaclass understands keyword arguments.
    
    All the arguments are sleekreffed to prevent memory leaks. Sleekref is a
    variation of weakref. Sleekref is when you try to weakref an object, but if
    it's non-weakreffable, like a `list` or a `dict`, you maintain a normal,
    strong reference to it. (See documentation of
    `garlicsim.general_misc.sleek_refs` for more details.) Thanks to
    sleekreffing you can avoid memory leaks when using weakreffable arguments,
    but if you ever want to use non-weakreffable arguments you are still able
    to. (Assuming you don't mind the memory leaks.)
    '''
    
    def __new__(mcls, *args, **kwargs):
        result = super(CachedType, mcls).__new__(mcls, *args, **kwargs)
        result.__cache = {}
        return result

    
    def __call__(cls, *args, **kwargs):
        sleek_call_args = SleekCallArgs(
            cls.__cache,
            cls.__init__,
            *((SelfPlaceholder,) + args),
            **kwargs
        )
        try:
            return cls.__cache[sleek_call_args]
        except KeyError:
            cls.__cache[sleek_call_args] = value = \
                super(CachedType, cls).__call__(*args, **kwargs)
            return value

########NEW FILE########
__FILENAME__ = change_tracker
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `ChangeTracker` class.

See its documentation for more information.
'''

import cPickle

from garlicsim.general_misc.nifty_collections import WeakKeyIdentityDict


class ChangeTracker(object): 
    '''
    Tracks changes in objects that are registered with it.
    
    To register an object, use `.check_in(obj)`. It will return `True`. Every
    time `.check_in` will be called with the same object, it will return
    whether the object changed since the last time it was checked in.
    '''
    
    def __init__(self):
        self.library = WeakKeyIdentityDict()
        '''dictoid mapping from objects to their last pickle value.'''
        
        
    def check_in(self, thing):
        '''        
        Check in an object for change tracking.
        
        The first time you check in an object, it will return `True`. Every
        time `.check_in` will be called with the same object, it will return
        whether the object changed since the last time it was checked in.
        '''
        
        new_pickle = cPickle.dumps(thing, 2)
        
        if thing not in self.library:
            self.library[thing] = new_pickle
            return True
        
        # thing in self.library
        
        previous_pickle = self.library[thing]
        if previous_pickle == new_pickle:
            return False
        else:
            self.library[thing] = new_pickle
            return True
    
        
    def __contains__(self, thing):
        '''Return whether `thing` is tracked.'''
        return self.library.__contains__(thing)


########NEW FILE########
__FILENAME__ = cheat_hash
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `cheat_hash` function for cheat-hashing mutable objects.

See its documentation for more details.
'''

from garlicsim.general_misc.infinity import infinity

from .cheat_hash_functions import (cheat_hash_dict, cheat_hash_object, 
                                   cheat_hash_sequence, cheat_hash_set)


dispatch_map = {
    object: cheat_hash_object,
    tuple: cheat_hash_sequence,
    list: cheat_hash_sequence,
    dict: cheat_hash_dict,
    set: cheat_hash_set
}
'''`dict` mapping from a type to a function that cheat-hashes it.'''


def cheat_hash(thing):
    '''
    Cheat-hash an object. Works on mutable objects.
    
    This is a replacement for `hash` which generates something like an hash for
    an object, even if it is mutable, unhashable and/or refers to
    mutable/unhashable objects.
    
    This is intended for situtations where you have mutable objects that you
    never modify, and you want to be able to hash them despite Python not
    letting you.
    '''
    thing_type = type(thing)
    matching_types = \
        [type_ for type_ in dispatch_map if issubclass(thing_type, type_)]
    
    mro = thing_type.mro()
    
    matching_type = min(
        matching_types,
        key=lambda type_: (mro.index(type_) if type_ in mro else infinity)
    )
    
    return dispatch_map[matching_type](thing)
    
        
        
            
########NEW FILE########
__FILENAME__ = cheat_hash_functions
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Defines functions for cheat-hashing various types.'''

# todo: there are some recommended hash implementations in `_abcoll`, maybe
# they'll help


def cheat_hash_object(thing):
    '''Cheat-hash an `object`.'''
    try:
        return hash(thing)
    except Exception:
        return id(thing)

    
def cheat_hash_set(my_set):
    '''Cheat-hash a `set`.'''
    hashables = set()
    unhashables = set()
    for thing in my_set:
        try:
            hash(thing)
        except Exception:
            unhashables.add(thing)
        else:
            hashables.add(thing)
            
    return hash(
        (
            frozenset(hashables),
            tuple(sorted(cheat_hash(thing) for thing in unhashables))
        )
    )    


def cheat_hash_sequence(my_sequence):
    '''Cheat-hash a sequence.'''
    hashables = []
    unhashables = []
    for thing in my_sequence:
        try:
            hash(thing)
        except Exception:
            unhashables.append(thing)
        else:
            hashables.append(thing)
            
    return hash(
        (
            tuple(hashables),
            tuple(cheat_hash(thing) for thing in unhashables)
        )
    )    


def cheat_hash_dict(my_dict):
    '''Cheat-hash a `dict`.'''
    hashable_items = []
    unhashable_items = []
    for key, value in my_dict.iteritems():
        try:
            hash((key, value))
        except Exception:
            unhashable_items.append((key, value))
        else:
            hashable_items.append((key, value))
            
    return hash(
        (
            tuple(sorted(hashable_items)),
            tuple(cheat_hash(thing) for thing in sorted(unhashable_items))
        )
    )

from .cheat_hash import cheat_hash
########NEW FILE########
__FILENAME__ = cmp_tools
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Defines various tools for comparisons.'''

import sys


def underscore_hating_cmp(a, b):
    '''Compare two strings, counting the "_" character as highest.'''
    assert isinstance(a, basestring) and isinstance(b, basestring)
    return cmp(
        unicode(a).replace('_', unichr(sys.maxunicode)),
        unicode(b).replace('_', unichr(sys.maxunicode))
    )
########NEW FILE########
__FILENAME__ = context_manager
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `ContextManager` and `ContextManagerType` classes.

Using these classes to define context managers allows using such context
managers as decorators (in addition to their normal use) and supports writing
context managers in a new form called `manage_context`. (As well as the
original forms).

Inherit all your context managers from `ContextManager` (or decorate your
generator functions with `ContextManagerType`) to enjoy all the benefits
described below.


Defining context managers
-------------------------

There are 3 different ways in which context managers can be defined, and each
has their own advantages and disadvantages over the others.

 1. The classic way to define a context manager is to define a class with 
    `__enter__` and `__exit__` methods. This is allowed, and if you do this
    you should still inherit from `ContextManager`. Example:
     
        class MyContextManager(ContextManager):
            def __enter__(self):
                pass # preparation
            def __exit__(self, type_=None, value=None, traceback=None):
                pass # cleanup
     
 2. As a decorated generator, like so:
    
        @ContextManagerType
        def MyContextManager():
            # preparation
            try:
                yield
            finally:
                pass # cleanup
                
    The advantage of this approach is its brevity, and it may be a good fit for
    relatively simple context managers that don't require defining an actual
    class.
                
    This usage is nothing new; it's also available when using the standard
    library's `contextlib.contextmanager` decorator. One thing that is allowed
    here that `contextlib` doesn't allow is to yield the context manager itself
    by doing `yield SelfHook`.
    
 3. The third and novel way is by defining a class with a `manage_context`
    method which returns a decorator. Example:
    
        class MyContextManager(ContextManager):
            def manage_context(self):
                do_some_preparation()
                with other_context_manager:
                    yield self
                    
    This approach is sometimes cleaner than defining `__enter__` and
    `__exit__`; especially when using another context manager inside
    `manage_context`. In our example we did `with other_context_manager` in our
    `manage_context`, which is shorter, more idiomatic and less
    double-underscore-y than the equivalent classic definition:

        class MyContextManager(object):
                def __enter__(self):
                    do_some_preparation()
                    other_context_manager.__enter__()
                    return self
                def __exit__(self, *exc):
                    return other_context_manager.__exit__(*exc)
    
    Another advantage of this approach over `__enter__` and `__exit__` is that
    it's better at handling exceptions, since any exceptions would be raised
    inside `manage_context` where we could `except` them, which is much more
    idiomatic than the way `__exit__` handles exceptions, which is by receiving
    their type and returning whether to swallow them or not.
    
These were the different ways of *defining* a context manager. Now let's see
the different ways of *using* a context manager:


Using context managers
----------------------

There are 2 different ways in which context managers can be used:

 1. The plain old honest-to-Guido `with` keyword:
 
       with MyContextManager() as my_context_manager:
           do_stuff()
           
 2. As a decorator to a function
 
        @MyContextManager()
        def do_stuff():
           pass # doing stuff
           
    When the `do_stuff` function will be called, the context manager will be
    used. This functionality is also available in the standard library of
    Python 3.2+ by using `contextlib.ContextDecorator`, but here it is combined
    with all the other goodies given by `ContextManager`.

    
That's it. Inherit all your context managers from `ContextManager` (or decorate
your generator functions with `ContextManagerType`) to enjoy all these
benefits.
'''

# todo: review the few external tests that I'm skipping.

# todo: test using as abc with other abstract functions

# todo: can make a helpful exception message for when the user decorates with
# `ContextManager` instead of `ContextManagerType`

# todo: for case of decorated generator, possibly make getstate (or whatever)
# that will cause it to be pickled by reference to the decorated function


from __future__ import with_statement

import types
import sys
from garlicsim.general_misc.third_party import abc

from garlicsim.general_misc import decorator_tools


class SelfHook(object):
    '''
    Hook that a context manager can yield in order to yield itself.

    This is useful in context managers which are created from a generator
    function, where the user can't do `yield self` because `self` doesn't exist
    yet.
    
    Example:
    
        @ContextGeneratorType
        def MyContextManager(lock):
            with lock.read:
                yield SelfHook
                
        with MyContextManager(my_lock) as my_context_manager:
            assert isinstance(my_context_manager, MyContextManager)
    
    '''
    # todo: make uninstantiable


class ContextManagerTypeType(type):
    '''Metaclass for `ContextManagerType`. Shouldn't be used directly.'''
    
    def __call__(cls, *args):
        '''
        Create a new `ContextManager`.
        
        This can work in two ways, depending on which arguments are given:
        
         1. The classic `type.__call__` way. If `name, bases, namespace` are
            passed in, `type.__call__` will be used normally.
            
         2. As a decorator for a generator function. For example:
            
                @ContextManagerType
                def MyContextManager():
                    # preparation
                    try:
                        yield
                    finally:
                        pass # cleanup
                        
            What happens here is that the function (in this case
            `MyContextManager`) is passed directly into
            `ContextManagerTypeType.__call__`. So we create a new
            `ContextManager` subclass for it, and use the original generator as
            its `.manage_context` function.
                        
        '''
        if len(args) == 1:
            (function,) = args
            assert callable(function)
            name = function.__name__
            bases = (ContextManager,)
            namespace_dict = {
                'manage_context': staticmethod(function),
                '__init__': ContextManager.\
                            _ContextManager__init_lone_manage_context
            }
            return super(ContextManagerTypeType, cls).__call__(
                name,
                bases,
                namespace_dict
            )
            
        else:
            return super(ContextManagerTypeType, cls).__call__(*args)


class ContextManagerType(abc.ABCMeta):
    '''
    Metaclass for `ContextManager`.
    
    Use this directly as a decorator to create a `ContextManager` from a
    generator function.
    
    Example:
    
        @ContextManagerType
        def MyContextManager():
            # preparation
            try:
                yield
            finally:
                pass # cleanup
                
    The resulting context manager could be called either with the `with`
    keyword or by using it as a decorator to a function.
                
    For more details, see documentation of the containing module,
    `garlicsim.general_misc.context_manager`.
    '''
    
    __metaclass__ = ContextManagerTypeType

    
    def __new__(mcls, name, bases, namespace):
        '''
        Create either `ContextManager` itself or a subclass of it.
        
        For subclasses of `ContextManager`, if a `manage_context` method is
        available, we will use `__enter__` and `__exit__` that will use the
        generator returned by `manage_context`.
        '''
        if 'manage_context' in namespace:
            manage_context = namespace['manage_context']
            if '__enter__' in namespace:
                raise Exception(
                    'You defined both an `__enter__` method and a '
                    '`manage_context` method-- That is unallowed. You need to '
                    '*either* define a `manage_context` method *or* an '
                    '`__enter__` and `__exit__` pair.'
                )
            if '__exit__' in namespace:
                raise Exception(
                    'You defined both an `__exit__` method and a '
                    '`manage_context` method-- That is unallowed. You need to '
                    '*either* define a `manage_context` method *or* an '
                    '`__enter__` and `__exit__` pair.'
                )
            namespace['__enter__'] = \
                ContextManager._ContextManager__enter_using_manage_context
            namespace['__exit__'] = \
                ContextManager._ContextManager__exit_using_manage_context
            
        result_class = super(ContextManagerType, mcls).__new__(
            mcls,
            name,
            bases,
            namespace
        )
        
        
        if (not result_class.__is_the_base_context_manager_class()) and \
           ('manage_context' not in namespace) and \
           hasattr(result_class, 'manage_context'):
            
            # What this `if` just checked for is: Is this a class that doesn't
            # define `manage_context`, but whose base context manager class
            # *does* define `manage_context`?
            #
            # If so, we need to be careful. It's okay for this class to be
            # using the enter/exit pair provided by the base `manage_context`;
            # It's also okay for this class to override these with its own
            # `__enter__` and `__exit__` implementations; but it's *not* okay
            # for this class to define just one of these methods, say
            # `__enter__`, because then it will not have an `__exit__` to work
            # with.
            
            our_enter_uses_manage_context = (
                getattr(result_class.__enter__, 'im_func',
                result_class.__enter__) == ContextManager.\
                _ContextManager__enter_using_manage_context.im_func
            )
            
            our_exit_uses_manage_context = (
                getattr(result_class.__exit__, 'im_func',
                result_class.__exit__) == ContextManager.\
                _ContextManager__exit_using_manage_context.im_func
            )
            
            if our_exit_uses_manage_context and not \
               our_enter_uses_manage_context:
                
                assert '__enter__' in namespace
            
                raise Exception("The %s class defines an `__enter__` method, "
                                "but not an `__exit__` method; we cannot use "
                                "the `__exit__` method of its base context "
                                "manager class because it uses the "
                                "`manage_context` generator function." %
                                result_class)

            
            if our_enter_uses_manage_context and not \
               our_exit_uses_manage_context:
                
                assert '__exit__' in namespace
                
                raise Exception("The %s class defines an `__exit__` method, "
                                "but not an `__enter__` method; we cannot use "
                                "the `__enter__` method of its base context "
                                "manager class because it uses the "
                                "`manage_context` generator function." %
                                result_class)
            
        return result_class

    
    def __is_the_base_context_manager_class(cls):
        '''
        Return whether `cls` is `ContextManager`.
        
        It's an ugly method, but unfortunately it's necessary because at one
        point we want to test if a class is `ContextManager` before
        `ContextManager` is defined in this module.
        '''
        
        return (
            (cls.__name__ == 'ContextManager') and
            (cls.__module__ == 'garlicsim.general_misc.context_manager') and
            (cls.mro() == [cls, object])
        )
                
    
class ContextManager(object):
    '''
    Allows running preparation code before a given suite and cleanup after.
    
    To make a context manager, use `ContextManager` as a base class and either
    (a) define `__enter__` and `__exit__` methods or (b) define a
    `manage_context` method that returns a generator. An alternative way to
    create a context manager is to define a generator function and decorate it
    with `ContextManagerType`.
    
    In any case, the resulting context manager could be called either with the
    `with` keyword or by using it as a decorator to a function.
                
    For more details, see documentation of the containing module,
    `garlicsim.general_misc.context_manager`.
    '''
    
    
    __metaclass__ = ContextManagerType

    
    def __call__(self, function):
        '''Decorate `function` to use this context manager when it's called.'''
        def inner(function_, *args, **kwargs):
            with self:
                return function_(*args, **kwargs)
        return decorator_tools.decorator(inner, function)
    
    
    @abc.abstractmethod
    def __enter__(self):
        '''Prepare for suite execution.'''

    
    @abc.abstractmethod
    def __exit__(self, type_=None, value=None, traceback=None):
        '''Cleanup after suite execution.'''
    

    def __init_lone_manage_context(self, *args, **kwargs):
        '''
        Initialize a `ContextManager` made from a lone generator function.
        '''
        self._ContextManager__args = args
        self._ContextManager__kwargs = kwargs
        self._ContextManager__generators = []
    
    
    def __enter_using_manage_context(self):
        '''
        Prepare for suite execution.
        
        This is used as `__enter__` for context managers that use a
        `manage_context` function.
        '''
        if not hasattr(self, '_ContextManager__generators'):
            self._ContextManager__generators = []
        
        new_generator = self.manage_context(
            *getattr(self, '_ContextManager__args', ()),
            **getattr(self, '_ContextManager__kwargs', {})
        )
        assert isinstance(new_generator, types.GeneratorType)
        self._ContextManager__generators.append(new_generator)
        
        
        try:
            generator_return_value = new_generator.next()
            return self if (generator_return_value is SelfHook) else \
                   generator_return_value
        
        except StopIteration:
            raise RuntimeError("The generator didn't yield even one time; it "
                               "must yield one time exactly.")
    
        
    def __exit_using_manage_context(self, type_, value, traceback):
        '''
        Cleanup after suite execution.
        
        This is used as `__exit__` for context managers that use a
        `manage_context` function.
        '''
        generator = self._ContextManager__generators.pop()
        assert isinstance(generator, types.GeneratorType)
        
        if type_ is None:
            try:
                generator.next()
            except StopIteration:
                return
            else:
                raise RuntimeError(
                    "The generator didn't stop after the yield; possibly you "
                    "have more than one `yield` in the generator function? "
                    "The generator function must yield exactly one time.")
        else:
            if value is None:
                # Need to force instantiation so we can reliably
                # tell if we get the same exception back
                value = type_()
            try:
                generator.throw(type_, value, traceback)
            except StopIteration, exc:
                # Suppress the exception *unless* it's the same exception that
                # was passed to throw().  This prevents a StopIteration
                # raised inside the "with" statement from being suppressed
                return exc is not value
            except:
                # only re-raise if it's *not* the exception that was
                # passed to throw(), because __exit__() must not raise
                # an exception unless __exit__() itself failed.  But throw()
                # has to raise the exception to signal propagation, so this
                # fixes the impedance mismatch between the throw() protocol
                # and the __exit__() protocol.
                #
                if sys.exc_info()[1] is not value:
                    raise
            else:
                raise RuntimeError(
                    "The generator didn't stop after calling its `.throw()`; "
                    "Possibly you have more than one `yield` in the generator "
                    "function? The generator function must yield exactly one "
                    "time."
                )
            
            
class BlankContextManager(ContextManager):
    '''A context manager that does nothing.'''
    def manage_context(self):
        yield self

########NEW FILE########
__FILENAME__ = copy_mode
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `CopyMode` class.

See its documentation for more information.
'''


class CopyMode(dict):
    '''
    Passed as a memo to `deepcopy` to specify how objects should be copied.

    This type is meant to be subclassed. `__deepcopy__` methods may check which
    class the memo is to know what kind of deepcopying they should do.
    
    Typical usage:
    
        class NetworkStyleCopying(CopyMode): pass
            
        class Something(object):
            def __deepcopy__(self, memo):
                if isinstance(memo, NetworkStlyeCopying):
                    # Do network-style copying, whatever that means.
                else:
                    # Do normal copying.
                    
        s = Something()
        
        new_copy = copy.deepcopy(s, NetworkStyleCopying())
        # Now the new copy will be created using network style copying
    '''
    __repr__ = object.__repr__
########NEW FILE########
__FILENAME__ = copy_tools
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines tools related to copying and deepcopying operations.
'''

import copy


def deepcopy_as_simple_object(thing, memo=None):
    '''
    Deepcopy an object as a simple `object`, ignoring any __deepcopy__ method.
    '''
    if memo is None:
        memo = {}
    klass = thing.__class__
    new_thing = klass.__new__(klass)
    memo[id(thing)] = new_thing
    for (name, subthing) in vars(thing).iteritems():
        new_thing.__dict__[name] = copy.deepcopy(subthing, memo)
    return(new_thing)
        
    
########NEW FILE########
__FILENAME__ = forked_inspect
"""Get useful information from live Python objects.

This module encapsulates the interface provided by the internal special
attributes (func_*, co_*, im_*, tb_*, etc.) in a friendlier fashion.
It also provides some help for examining source code and class layout.

Here are some of the useful functions provided by this module:

    ismodule(), isclass(), ismethod(), isfunction(), isgeneratorfunction(),
        isgenerator(), istraceback(), isframe(), iscode(), isbuiltin(),
        isroutine() - check object types
    getmembers() - get members of an object that satisfy a given condition

    getfile(), getsourcefile(), getsource() - find an object's source code
    getdoc(), getcomments() - get documentation on an object
    getmodule() - determine the module that an object came from
    getclasstree() - arrange classes so as to represent their hierarchy

    getargspec(), getargvalues(), getcallargs() - get info about function arguments
    formatargspec(), formatargvalues() - format an argument spec
    getouterframes(), getinnerframes() - get info about frames
    currentframe() - get the current stack frame
    stack(), trace() - get info about frames on the stack or in a traceback
"""

# This module is in the public domain.  No warranties.

__author__ = 'Ka-Ping Yee <ping@lfw.org>'
__date__ = '1 Jan 2001'

import sys
import os
import types
import string
import re
import dis
import imp
import tokenize
import linecache
from operator import attrgetter
from garlicsim.general_misc.third_party.namedtuple import namedtuple

# These constants are from Include/code.h.
CO_OPTIMIZED, CO_NEWLOCALS, CO_VARARGS, CO_VARKEYWORDS = 0x1, 0x2, 0x4, 0x8
CO_NESTED, CO_GENERATOR, CO_NOFREE = 0x10, 0x20, 0x40
# See Include/object.h
TPFLAGS_IS_ABSTRACT = 1 << 20

# ----------------------------------------------------------- type-checking
def ismodule(object):
    """Return true if the object is a module.

    Module objects provide these attributes:
        __doc__         documentation string
        __file__        filename (missing for built-in modules)"""
    return isinstance(object, types.ModuleType)

def isclass(object):
    """Return true if the object is a class.

    Class objects provide these attributes:
        __doc__         documentation string
        __module__      name of module in which this class was defined"""
    return isinstance(object, (type, types.ClassType))

def ismethod(object):
    """Return true if the object is an instance method.

    Instance method objects provide these attributes:
        __doc__         documentation string
        __name__        name with which this method was defined
        im_class        class object in which this method belongs
        im_func         function object containing implementation of method
        im_self         instance to which this method is bound, or None"""
    return isinstance(object, types.MethodType)

def ismethoddescriptor(object):
    """Return true if the object is a method descriptor.

    But not if ismethod() or isclass() or isfunction() are true.

    This is new in Python 2.2, and, for example, is true of int.__add__.
    An object passing this test has a __get__ attribute but not a __set__
    attribute, but beyond that the set of attributes varies.  __name__ is
    usually sensible, and __doc__ often is.

    Methods implemented via descriptors that also pass one of the other
    tests return false from the ismethoddescriptor() test, simply because
    the other tests promise more -- you can, e.g., count on having the
    im_func attribute (etc) when an object passes ismethod()."""
    return (hasattr(object, "__get__")
            and not hasattr(object, "__set__") # else it's a data descriptor
            and not ismethod(object)           # mutual exclusion
            and not isfunction(object)
            and not isclass(object))

def isdatadescriptor(object):
    """Return true if the object is a data descriptor.

    Data descriptors have both a __get__ and a __set__ attribute.  Examples are
    properties (defined in Python) and getsets and members (defined in C).
    Typically, data descriptors will also have __name__ and __doc__ attributes
    (properties, getsets, and members have both of these attributes), but this
    is not guaranteed."""
    return (hasattr(object, "__set__") and hasattr(object, "__get__"))

if hasattr(types, 'MemberDescriptorType'):
    # CPython and equivalent
    def ismemberdescriptor(object):
        """Return true if the object is a member descriptor.

        Member descriptors are specialized descriptors defined in extension
        modules."""
        return isinstance(object, types.MemberDescriptorType)
else:
    # Other implementations
    def ismemberdescriptor(object):
        """Return true if the object is a member descriptor.

        Member descriptors are specialized descriptors defined in extension
        modules."""
        return False

if hasattr(types, 'GetSetDescriptorType'):
    # CPython and equivalent
    def isgetsetdescriptor(object):
        """Return true if the object is a getset descriptor.

        getset descriptors are specialized descriptors defined in extension
        modules."""
        return isinstance(object, types.GetSetDescriptorType)
else:
    # Other implementations
    def isgetsetdescriptor(object):
        """Return true if the object is a getset descriptor.

        getset descriptors are specialized descriptors defined in extension
        modules."""
        return False

def isfunction(object):
    """Return true if the object is a user-defined function.

    Function objects provide these attributes:
        __doc__         documentation string
        __name__        name with which this function was defined
        func_code       code object containing compiled function bytecode
        func_defaults   tuple of any default values for arguments
        func_doc        (same as __doc__)
        func_globals    global namespace in which this function was defined
        func_name       (same as __name__)"""
    return isinstance(object, types.FunctionType)

def isgeneratorfunction(object):
    """Return true if the object is a user-defined generator function.

    Generator function objects provides same attributes as functions.

    See help(isfunction) for attributes listing."""
    return bool((isfunction(object) or ismethod(object)) and
                object.func_code.co_flags & CO_GENERATOR)

def isgenerator(object):
    """Return true if the object is a generator.

    Generator objects provide these attributes:
        __iter__        defined to support interation over container
        close           raises a new GeneratorExit exception inside the
                        generator to terminate the iteration
        gi_code         code object
        gi_frame        frame object or possibly None once the generator has
                        been exhausted
        gi_running      set to 1 when generator is executing, 0 otherwise
        next            return the next item from the container
        send            resumes the generator and "sends" a value that becomes
                        the result of the current yield-expression
        throw           used to raise an exception inside the generator"""
    return isinstance(object, types.GeneratorType)

def istraceback(object):
    """Return true if the object is a traceback.

    Traceback objects provide these attributes:
        tb_frame        frame object at this level
        tb_lasti        index of last attempted instruction in bytecode
        tb_lineno       current line number in Python source code
        tb_next         next inner traceback object (called by this level)"""
    return isinstance(object, types.TracebackType)

def isframe(object):
    """Return true if the object is a frame object.

    Frame objects provide these attributes:
        f_back          next outer frame object (this frame's caller)
        f_builtins      built-in namespace seen by this frame
        f_code          code object being executed in this frame
        f_exc_traceback traceback if raised in this frame, or None
        f_exc_type      exception type if raised in this frame, or None
        f_exc_value     exception value if raised in this frame, or None
        f_globals       global namespace seen by this frame
        f_lasti         index of last attempted instruction in bytecode
        f_lineno        current line number in Python source code
        f_locals        local namespace seen by this frame
        f_restricted    0 or 1 if frame is in restricted execution mode
        f_trace         tracing function for this frame, or None"""
    return isinstance(object, types.FrameType)

def iscode(object):
    """Return true if the object is a code object.

    Code objects provide these attributes:
        co_argcount     number of arguments (not including * or ** args)
        co_code         string of raw compiled bytecode
        co_consts       tuple of constants used in the bytecode
        co_filename     name of file in which this code object was created
        co_firstlineno  number of first line in Python source code
        co_flags        bitmap: 1=optimized | 2=newlocals | 4=*arg | 8=**arg
        co_lnotab       encoded mapping of line numbers to bytecode indices
        co_name         name with which this code object was defined
        co_names        tuple of names of local variables
        co_nlocals      number of local variables
        co_stacksize    virtual machine stack space required
        co_varnames     tuple of names of arguments and local variables"""
    return isinstance(object, types.CodeType)

def isbuiltin(object):
    """Return true if the object is a built-in function or method.

    Built-in functions and methods provide these attributes:
        __doc__         documentation string
        __name__        original name of this function or method
        __self__        instance to which a method is bound, or None"""
    return isinstance(object, types.BuiltinFunctionType)

def isroutine(object):
    """Return true if the object is any kind of function or method."""
    return (isbuiltin(object)
            or isfunction(object)
            or ismethod(object)
            or ismethoddescriptor(object))

def isabstract(object):
    """Return true if the object is an abstract base class (ABC)."""
    return bool(isinstance(object, type) and object.__flags__ & TPFLAGS_IS_ABSTRACT)

def getmembers(object, predicate=None):
    """Return all members of an object as (name, value) pairs sorted by name.
    Optionally, only return members that satisfy a given predicate."""
    results = []
    for key in dir(object):
        try:
            value = getattr(object, key)
        except AttributeError:
            continue
        if not predicate or predicate(value):
            results.append((key, value))
    results.sort()
    return results

Attribute = namedtuple('Attribute', 'name kind defining_class object')

def classify_class_attrs(cls):
    """Return list of attribute-descriptor tuples.

    For each name in dir(cls), the return list contains a 4-tuple
    with these elements:

        0. The name (a string).

        1. The kind of attribute this is, one of these strings:
               'class method'    created via classmethod()
               'static method'   created via staticmethod()
               'property'        created via property()
               'method'          any other flavor of method
               'data'            not a method

        2. The class which defined this attribute (a class).

        3. The object as obtained directly from the defining class's
           __dict__, not via getattr.  This is especially important for
           data attributes:  C.data is just a data object, but
           C.__dict__['data'] may be a data descriptor with additional
           info, like a __doc__ string.
    """

    mro = getmro(cls)
    names = dir(cls)
    result = []
    for name in names:
        # Get the object associated with the name.
        # Getting an obj from the __dict__ sometimes reveals more than
        # using getattr.  Static and class methods are dramatic examples.
        if name in cls.__dict__:
            obj = cls.__dict__[name]
        else:
            obj = getattr(cls, name)

        # Figure out where it was defined.
        homecls = getattr(obj, "__objclass__", None)
        if homecls is None:
            # search the dicts.
            for base in mro:
                if name in base.__dict__:
                    homecls = base
                    break

        # Get the object again, in order to get it from the defining
        # __dict__ instead of via getattr (if possible).
        if homecls is not None and name in homecls.__dict__:
            obj = homecls.__dict__[name]

        # Also get the object via getattr.
        obj_via_getattr = getattr(cls, name)

        # Classify the object.
        if isinstance(obj, staticmethod):
            kind = "static method"
        elif isinstance(obj, classmethod):
            kind = "class method"
        elif isinstance(obj, property):
            kind = "property"
        elif (ismethod(obj_via_getattr) or
              ismethoddescriptor(obj_via_getattr)):
            kind = "method"
        else:
            kind = "data"

        result.append(Attribute(name, kind, homecls, obj))

    return result

# ----------------------------------------------------------- class helpers
def _searchbases(cls, accum):
    # Simulate the "classic class" search order.
    if cls in accum:
        return
    accum.append(cls)
    for base in cls.__bases__:
        _searchbases(base, accum)

def getmro(cls):
    "Return tuple of base classes (including cls) in method resolution order."
    if hasattr(cls, "__mro__"):
        return cls.__mro__
    else:
        result = []
        _searchbases(cls, result)
        return tuple(result)

# -------------------------------------------------- source code extraction
def indentsize(line):
    """Return the indent size, in spaces, at the start of a line of text."""
    expline = string.expandtabs(line)
    return len(expline) - len(string.lstrip(expline))

def getdoc(object):
    """Get the documentation string for an object.

    All tabs are expanded to spaces.  To clean up docstrings that are
    indented to line up with blocks of code, any whitespace than can be
    uniformly removed from the second line onwards is removed."""
    try:
        doc = object.__doc__
    except AttributeError:
        return None
    if not isinstance(doc, types.StringTypes):
        return None
    return cleandoc(doc)

def cleandoc(doc):
    """Clean up indentation from docstrings.

    Any whitespace that can be uniformly removed from the second line
    onwards is removed."""
    try:
        lines = string.split(string.expandtabs(doc), '\n')
    except UnicodeError:
        return None
    else:
        # Find minimum indentation of any non-blank lines after first line.
        margin = sys.maxint
        for line in lines[1:]:
            content = len(string.lstrip(line))
            if content:
                indent = len(line) - content
                margin = min(margin, indent)
        # Remove indentation.
        if lines:
            lines[0] = lines[0].lstrip()
        if margin < sys.maxint:
            for i in range(1, len(lines)): lines[i] = lines[i][margin:]
        # Remove any trailing or leading blank lines.
        while lines and not lines[-1]:
            lines.pop()
        while lines and not lines[0]:
            lines.pop(0)
        return string.join(lines, '\n')

def getfile(object):
    """Work out which source or compiled file an object was defined in."""
    if ismodule(object):
        if hasattr(object, '__file__'):
            return object.__file__
        raise TypeError('{!r} is a built-in module'.format(object))
    if isclass(object):
        object = sys.modules.get(object.__module__)
        if hasattr(object, '__file__'):
            return object.__file__
        raise TypeError('{!r} is a built-in class'.format(object))
    if ismethod(object):
        object = object.im_func
    if isfunction(object):
        object = object.func_code
    if istraceback(object):
        object = object.tb_frame
    if isframe(object):
        object = object.f_code
    if iscode(object):
        return object.co_filename
    raise TypeError('{!r} is not a module, class, method, '
                    'function, traceback, frame, or code object'.format(object))

ModuleInfo = namedtuple('ModuleInfo', 'name suffix mode module_type')

def getmoduleinfo(path):
    """Get the module name, suffix, mode, and module type for a given file."""
    filename = os.path.basename(path)
    suffixes = map(lambda info:
                   (-len(info[0]), info[0], info[1], info[2]),
                    imp.get_suffixes())
    suffixes.sort() # try longest suffixes first, in case they overlap
    for neglen, suffix, mode, mtype in suffixes:
        if filename[neglen:] == suffix:
            return ModuleInfo(filename[:neglen], suffix, mode, mtype)

def getmodulename(path):
    """Return the module name for a given file, or None."""
    info = getmoduleinfo(path)
    if info: return info[0]

def getsourcefile(object):
    """Return the filename that can be used to locate an object's source.
    Return None if no way can be identified to get the source.
    """
    filename = getfile(object)
    if string.lower(filename[-4:]) in ('.pyc', '.pyo'):
        filename = filename[:-4] + '.py'
    for suffix, mode, kind in imp.get_suffixes():
        if 'b' in mode and string.lower(filename[-len(suffix):]) == suffix:
            # Looks like a binary file.  We want to only return a text file.
            return None
    if os.path.exists(filename):
        return filename
    # only return a non-existent filename if the module has a PEP 302 loader
    if hasattr(getmodule(object, filename), '__loader__'):
        return filename
    # or it is in the linecache
    if filename in linecache.cache:
        return filename

def getabsfile(object, _filename=None):
    """Return an absolute path to the source or compiled file for an object.

    The idea is for each object to have a unique origin, so this routine
    normalizes the result as much as possible."""
    if _filename is None:
        _filename = getsourcefile(object) or getfile(object)
    return os.path.normcase(os.path.abspath(_filename))

modulesbyfile = {}
_filesbymodname = {}

def getmodule(object, _filename=None):
    """Return the module an object was defined in, or None if not found."""
    if ismodule(object):
        return object
    if hasattr(object, '__module__'):
        return sys.modules.get(object.__module__)
    # Try the filename to modulename cache
    if _filename is not None and _filename in modulesbyfile:
        return sys.modules.get(modulesbyfile[_filename])
    # Try the cache again with the absolute file name
    try:
        file = getabsfile(object, _filename)
    except TypeError:
        return None
    if file in modulesbyfile:
        return sys.modules.get(modulesbyfile[file])
    # Update the filename to module name cache and check yet again
    # Copy sys.modules in order to cope with changes while iterating
    for modname, module in sys.modules.items():
        if ismodule(module) and hasattr(module, '__file__'):
            f = module.__file__
            if f == _filesbymodname.get(modname, None):
                # Have already mapped this module, so skip it
                continue
            _filesbymodname[modname] = f
            f = getabsfile(module)
            # Always map to the name the module knows itself by
            modulesbyfile[f] = modulesbyfile[
                os.path.realpath(f)] = module.__name__
    if file in modulesbyfile:
        return sys.modules.get(modulesbyfile[file])
    # Check the main module
    main = sys.modules['__main__']
    if not hasattr(object, '__name__'):
        return None
    if hasattr(main, object.__name__):
        mainobject = getattr(main, object.__name__)
        if mainobject is object:
            return main
    # Check builtins
    builtin = sys.modules['__builtin__']
    if hasattr(builtin, object.__name__):
        builtinobject = getattr(builtin, object.__name__)
        if builtinobject is object:
            return builtin

def findsource(object):
    """Return the entire source file and starting line number for an object.

    The argument may be a module, class, method, function, traceback, frame,
    or code object.  The source code is returned as a list of all the lines
    in the file and the line number indexes a line in that list.  An IOError
    is raised if the source code cannot be retrieved."""
    file = getsourcefile(object)
    if not file:
        raise IOError('source code not available')
    module = getmodule(object, file)
    if module:
        lines = linecache.getlines(file, module.__dict__)
    else:
        lines = linecache.getlines(file)
    if not lines:
        raise IOError('could not get source code')

    if ismodule(object):
        return lines, 0

    if isclass(object):
        name = object.__name__
        pat = re.compile(r'^(\s*)class\s*' + name + r'\b')
        # make some effort to find the best matching class definition:
        # use the one with the least indentation, which is the one
        # that's most probably not inside a function definition.
        candidates = []
        for i in range(len(lines)):
            match = pat.match(lines[i])
            if match:
                # if it's at toplevel, it's already the best one
                if lines[i][0] == 'c':
                    return lines, i
                # else add whitespace to candidate list
                candidates.append((match.group(1), i))
        if candidates:
            # this will sort by whitespace, and by line number,
            # less whitespace first
            candidates.sort()
            return lines, candidates[0][1]
        else:
            raise IOError('could not find class definition')

    if ismethod(object):
        object = object.im_func
    if isfunction(object):
        object = object.func_code
    if istraceback(object):
        object = object.tb_frame
    if isframe(object):
        object = object.f_code
    if iscode(object):
        if not hasattr(object, 'co_firstlineno'):
            raise IOError('could not find function definition')
        lnum = object.co_firstlineno - 1
        pat = re.compile(r'^(\s*def\s)|(.*(?<!\w)lambda(:|\s))|^(\s*@)')
        while lnum > 0:
            if pat.match(lines[lnum]): break
            lnum = lnum - 1
        return lines, lnum
    raise IOError('could not find code object')

def getcomments(object):
    """Get lines of comments immediately preceding an object's source code.

    Returns None when source can't be found.
    """
    try:
        lines, lnum = findsource(object)
    except (IOError, TypeError):
        return None

    if ismodule(object):
        # Look for a comment block at the top of the file.
        start = 0
        if lines and lines[0][:2] == '#!': start = 1
        while start < len(lines) and string.strip(lines[start]) in ('', '#'):
            start = start + 1
        if start < len(lines) and lines[start][:1] == '#':
            comments = []
            end = start
            while end < len(lines) and lines[end][:1] == '#':
                comments.append(string.expandtabs(lines[end]))
                end = end + 1
            return string.join(comments, '')

    # Look for a preceding block of comments at the same indentation.
    elif lnum > 0:
        indent = indentsize(lines[lnum])
        end = lnum - 1
        if end >= 0 and string.lstrip(lines[end])[:1] == '#' and \
            indentsize(lines[end]) == indent:
            comments = [string.lstrip(string.expandtabs(lines[end]))]
            if end > 0:
                end = end - 1
                comment = string.lstrip(string.expandtabs(lines[end]))
                while comment[:1] == '#' and indentsize(lines[end]) == indent:
                    comments[:0] = [comment]
                    end = end - 1
                    if end < 0: break
                    comment = string.lstrip(string.expandtabs(lines[end]))
            while comments and string.strip(comments[0]) == '#':
                comments[:1] = []
            while comments and string.strip(comments[-1]) == '#':
                comments[-1:] = []
            return string.join(comments, '')

class EndOfBlock(Exception): pass

class BlockFinder:
    """Provide a tokeneater() method to detect the end of a code block."""
    def __init__(self):
        self.indent = 0
        self.islambda = False
        self.started = False
        self.passline = False
        self.last = 1

    def tokeneater(self, type, token, srow_scol, erow_ecol, line):
        srow, scol = srow_scol
        erow, ecol = erow_ecol
        if not self.started:
            # look for the first "def", "class" or "lambda"
            if token in ("def", "class", "lambda"):
                if token == "lambda":
                    self.islambda = True
                self.started = True
            self.passline = True    # skip to the end of the line
        elif type == tokenize.NEWLINE:
            self.passline = False   # stop skipping when a NEWLINE is seen
            self.last = srow
            if self.islambda:       # lambdas always end at the first NEWLINE
                raise EndOfBlock
        elif self.passline:
            pass
        elif type == tokenize.INDENT:
            self.indent = self.indent + 1
            self.passline = True
        elif type == tokenize.DEDENT:
            self.indent = self.indent - 1
            # the end of matching indent/dedent pairs end a block
            # (note that this only works for "def"/"class" blocks,
            #  not e.g. for "if: else:" or "try: finally:" blocks)
            if self.indent <= 0:
                raise EndOfBlock
        elif self.indent == 0 and type not in (tokenize.COMMENT, tokenize.NL):
            # any other token on the same indentation level end the previous
            # block as well, except the pseudo-tokens COMMENT and NL.
            raise EndOfBlock

def getblock(lines):
    """Extract the block of code at the top of the given list of lines."""
    blockfinder = BlockFinder()
    try:
        tokenize.tokenize(iter(lines).next, blockfinder.tokeneater)
    except (EndOfBlock, IndentationError):
        pass
    return lines[:blockfinder.last]

def getsourcelines(object):
    """Return a list of source lines and starting line number for an object.

    The argument may be a module, class, method, function, traceback, frame,
    or code object.  The source code is returned as a list of the lines
    corresponding to the object and the line number indicates where in the
    original source file the first line of code was found.  An IOError is
    raised if the source code cannot be retrieved."""
    lines, lnum = findsource(object)

    if ismodule(object): return lines, 0
    else: return getblock(lines[lnum:]), lnum + 1

def getsource(object):
    """Return the text of the source code for an object.

    The argument may be a module, class, method, function, traceback, frame,
    or code object.  The source code is returned as a single string.  An
    IOError is raised if the source code cannot be retrieved."""
    lines, lnum = getsourcelines(object)
    return string.join(lines, '')

# --------------------------------------------------- class tree extraction
def walktree(classes, children, parent):
    """Recursive helper function for getclasstree()."""
    results = []
    classes.sort(key=attrgetter('__module__', '__name__'))
    for c in classes:
        results.append((c, c.__bases__))
        if c in children:
            results.append(walktree(children[c], children, c))
    return results

def getclasstree(classes, unique=0):
    """Arrange the given list of classes into a hierarchy of nested lists.

    Where a nested list appears, it contains classes derived from the class
    whose entry immediately precedes the list.  Each entry is a 2-tuple
    containing a class and a tuple of its base classes.  If the 'unique'
    argument is true, exactly one entry appears in the returned structure
    for each class in the given list.  Otherwise, classes using multiple
    inheritance and their descendants will appear multiple times."""
    children = {}
    roots = []
    for c in classes:
        if c.__bases__:
            for parent in c.__bases__:
                if not parent in children:
                    children[parent] = []
                children[parent].append(c)
                if unique and parent in classes: break
        elif c not in roots:
            roots.append(c)
    for parent in children:
        if parent not in classes:
            roots.append(parent)
    return walktree(roots, children, None)

# ------------------------------------------------ argument list extraction
Arguments = namedtuple('Arguments', 'args varargs keywords')

def getargs(co):
    """Get information about the arguments accepted by a code object.

    Three things are returned: (args, varargs, varkw), where 'args' is
    a list of argument names (possibly containing nested lists), and
    'varargs' and 'varkw' are the names of the * and ** arguments or None."""

    if not iscode(co):
        raise TypeError('{!r} is not a code object'.format(co))

    nargs = co.co_argcount
    names = co.co_varnames
    args = list(names[:nargs])
    step = 0

    # The following acrobatics are for anonymous (tuple) arguments.
    for i in range(nargs):
        if args[i][:1] in ('', '.'):
            stack, remain, count = [], [], []
            while step < len(co.co_code):
                op = ord(co.co_code[step])
                step = step + 1
                if op >= dis.HAVE_ARGUMENT:
                    opname = dis.opname[op]
                    value = ord(co.co_code[step]) + ord(co.co_code[step+1])*256
                    step = step + 2
                    if opname in ('UNPACK_TUPLE', 'UNPACK_SEQUENCE'):
                        remain.append(value)
                        count.append(value)
                    elif opname == 'STORE_FAST':
                        stack.append(names[value])

                        # Special case for sublists of length 1: def foo((bar))
                        # doesn't generate the UNPACK_TUPLE bytecode, so if
                        # `remain` is empty here, we have such a sublist.
                        if not remain:
                            stack[0] = [stack[0]]
                            break
                        else:
                            remain[-1] = remain[-1] - 1
                            while remain[-1] == 0:
                                remain.pop()
                                size = count.pop()
                                stack[-size:] = [stack[-size:]]
                                if not remain: break
                                remain[-1] = remain[-1] - 1
                            if not remain: break
            args[i] = stack[0]

    varargs = None
    if co.co_flags & CO_VARARGS:
        varargs = co.co_varnames[nargs]
        nargs = nargs + 1
    varkw = None
    if co.co_flags & CO_VARKEYWORDS:
        varkw = co.co_varnames[nargs]
    return Arguments(args, varargs, varkw)

ArgSpec = namedtuple('ArgSpec', 'args varargs keywords defaults')

def getargspec(func):
    """Get the names and default values of a function's arguments.

    A tuple of four things is returned: (args, varargs, varkw, defaults).
    'args' is a list of the argument names (it may contain nested lists).
    'varargs' and 'varkw' are the names of the * and ** arguments or None.
    'defaults' is an n-tuple of the default values of the last n arguments.
    """

    if ismethod(func):
        func = func.im_func
    if not isfunction(func):
        raise TypeError('{!r} is not a Python function'.format(func))
    args, varargs, varkw = getargs(func.func_code)
    return ArgSpec(args, varargs, varkw, func.func_defaults)

ArgInfo = namedtuple('ArgInfo', 'args varargs keywords locals')

def getargvalues(frame):
    """Get information about arguments passed into a particular frame.

    A tuple of four things is returned: (args, varargs, varkw, locals).
    'args' is a list of the argument names (it may contain nested lists).
    'varargs' and 'varkw' are the names of the * and ** arguments or None.
    'locals' is the locals dictionary of the given frame."""
    args, varargs, varkw = getargs(frame.f_code)
    return ArgInfo(args, varargs, varkw, frame.f_locals)

def joinseq(seq):
    if len(seq) == 1:
        return '(' + seq[0] + ',)'
    else:
        return '(' + string.join(seq, ', ') + ')'

def strseq(object, convert, join=joinseq):
    """Recursively walk a sequence, stringifying each element."""
    if type(object) in (list, tuple):
        return join(map(lambda o, c=convert, j=join: strseq(o, c, j), object))
    else:
        return convert(object)

def formatargspec(args, varargs=None, varkw=None, defaults=None,
                  formatarg=str,
                  formatvarargs=lambda name: '*' + name,
                  formatvarkw=lambda name: '**' + name,
                  formatvalue=lambda value: '=' + repr(value),
                  join=joinseq):
    """Format an argument spec from the 4 values returned by getargspec.

    The first four arguments are (args, varargs, varkw, defaults).  The
    other four arguments are the corresponding optional formatting functions
    that are called to turn names and values into strings.  The ninth
    argument is an optional function to format the sequence of arguments."""
    specs = []
    if defaults:
        firstdefault = len(args) - len(defaults)
    for i, arg in enumerate(args):
        spec = strseq(arg, formatarg, join)
        if defaults and i >= firstdefault:
            spec = spec + formatvalue(defaults[i - firstdefault])
        specs.append(spec)
    if varargs is not None:
        specs.append(formatvarargs(varargs))
    if varkw is not None:
        specs.append(formatvarkw(varkw))
    return '(' + string.join(specs, ', ') + ')'

def formatargvalues(args, varargs, varkw, locals,
                    formatarg=str,
                    formatvarargs=lambda name: '*' + name,
                    formatvarkw=lambda name: '**' + name,
                    formatvalue=lambda value: '=' + repr(value),
                    join=joinseq):
    """Format an argument spec from the 4 values returned by getargvalues.

    The first four arguments are (args, varargs, varkw, locals).  The
    next four arguments are the corresponding optional formatting functions
    that are called to turn names and values into strings.  The ninth
    argument is an optional function to format the sequence of arguments."""
    def convert(name, locals=locals,
                formatarg=formatarg, formatvalue=formatvalue):
        return formatarg(name) + formatvalue(locals[name])
    specs = []
    for i in range(len(args)):
        specs.append(strseq(args[i], convert, join))
    if varargs:
        specs.append(formatvarargs(varargs) + formatvalue(locals[varargs]))
    if varkw:
        specs.append(formatvarkw(varkw) + formatvalue(locals[varkw]))
    return '(' + string.join(specs, ', ') + ')'

def getcallargs(func, *positional, **named):
    """Get the mapping of arguments to values.

    A dict is returned, with keys the function argument names (including the
    names of the * and ** arguments, if any), and values the respective bound
    values from 'positional' and 'named'."""
    args, varargs, varkw, defaults = getargspec(func)
    f_name = func.__name__
    arg2value = {}

    # The following closures are basically because of tuple parameter unpacking.
    assigned_tuple_params = []
    def assign(arg, value):
        if isinstance(arg, str):
            arg2value[arg] = value
        else:
            assigned_tuple_params.append(arg)
            value = iter(value)
            for i, subarg in enumerate(arg):
                try:
                    subvalue = next(value)
                except StopIteration:
                    raise ValueError('need more than %d %s to unpack' %
                                     (i, 'values' if i > 1 else 'value'))
                assign(subarg,subvalue)
            try:
                next(value)
            except StopIteration:
                pass
            else:
                raise ValueError('too many values to unpack')
    def is_assigned(arg):
        if isinstance(arg,str):
            return arg in arg2value
        return arg in assigned_tuple_params
    if ismethod(func) and func.im_self is not None:
        # implicit 'self' (or 'cls' for classmethods) argument
        positional = (func.im_self,) + positional
    num_pos = len(positional)
    num_total = num_pos + len(named)
    num_args = len(args)
    num_defaults = len(defaults) if defaults else 0
    for arg, value in zip(args, positional):
        assign(arg, value)
    if varargs:
        if num_pos > num_args:
            assign(varargs, positional[-(num_pos-num_args):])
        else:
            assign(varargs, ())
    elif 0 < num_args < num_pos:
        raise TypeError('%s() takes %s %d %s (%d given)' % (
            f_name, 'at most' if defaults else 'exactly', num_args,
            'arguments' if num_args > 1 else 'argument', num_total))
    elif num_args == 0 and num_total:
        raise TypeError('%s() takes no arguments (%d given)' %
                        (f_name, num_total))
    for arg in args:
        if isinstance(arg, str) and arg in named:
            if is_assigned(arg):
                raise TypeError("%s() got multiple values for keyword "
                                "argument '%s'" % (f_name, arg))
            else:
                assign(arg, named.pop(arg))
    if defaults:    # fill in any missing values with the defaults
        for arg, value in zip(args[-num_defaults:], defaults):
            if not is_assigned(arg):
                assign(arg, value)
    if varkw:
        assign(varkw, named)
    elif named:
        unexpected = next(iter(named))
        if isinstance(unexpected, unicode):
            unexpected = unexpected.encode(sys.getdefaultencoding(), 'replace')
        raise TypeError("%s() got an unexpected keyword argument '%s'" %
                        (f_name, unexpected))
    unassigned = num_args - len([arg for arg in args if is_assigned(arg)])
    if unassigned:
        num_required = num_args - num_defaults
        raise TypeError('%s() takes %s %d %s (%d given)' % (
            f_name, 'at least' if defaults else 'exactly', num_required,
            'arguments' if num_required > 1 else 'argument', num_total))
    return arg2value

# -------------------------------------------------- stack frame extraction

Traceback = namedtuple('Traceback', 'filename lineno function code_context index')

def getframeinfo(frame, context=1):
    """Get information about a frame or traceback object.

    A tuple of five things is returned: the filename, the line number of
    the current line, the function name, a list of lines of context from
    the source code, and the index of the current line within that list.
    The optional second argument specifies the number of lines of context
    to return, which are centered around the current line."""
    if istraceback(frame):
        lineno = frame.tb_lineno
        frame = frame.tb_frame
    else:
        lineno = frame.f_lineno
    if not isframe(frame):
        raise TypeError('{!r} is not a frame or traceback object'.format(frame))

    filename = getsourcefile(frame) or getfile(frame)
    if context > 0:
        start = lineno - 1 - context//2
        try:
            lines, lnum = findsource(frame)
        except IOError:
            lines = index = None
        else:
            start = max(start, 1)
            start = max(0, min(start, len(lines) - context))
            lines = lines[start:start+context]
            index = lineno - 1 - start
    else:
        lines = index = None

    return Traceback(filename, lineno, frame.f_code.co_name, lines, index)

def getlineno(frame):
    """Get the line number from a frame object, allowing for optimization."""
    # FrameType.f_lineno is now a descriptor that grovels co_lnotab
    return frame.f_lineno

def getouterframes(frame, context=1):
    """Get a list of records for a frame and all higher (calling) frames.

    Each record contains a frame object, filename, line number, function
    name, a list of lines of context, and index within the context."""
    framelist = []
    while frame:
        framelist.append((frame,) + getframeinfo(frame, context))
        frame = frame.f_back
    return framelist

def getinnerframes(tb, context=1):
    """Get a list of records for a traceback's frame and all lower frames.

    Each record contains a frame object, filename, line number, function
    name, a list of lines of context, and index within the context."""
    framelist = []
    while tb:
        framelist.append((tb.tb_frame,) + getframeinfo(tb, context))
        tb = tb.tb_next
    return framelist

if hasattr(sys, '_getframe'):
    currentframe = sys._getframe
else:
    currentframe = lambda _=None: None

def stack(context=1):
    """Return a list of records for the stack above the caller's frame."""
    return getouterframes(sys._getframe(1), context)

def trace(context=1):
    """Return a list of records for the stack below the current exception."""
    return getinnerframes(sys.exc_info()[2], context)

########NEW FILE########
__FILENAME__ = cute_iter_tools
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Defines functions for manipulating iterators.'''
# todo: make something like `filter` except it returns first found, or raises
# exception

from __future__ import with_statement

import itertools
import __builtin__

from garlicsim.general_misc.infinity import infinity


def consecutive_pairs(iterable, wrap_around=False):
    '''
    Iterate over successive pairs from the iterable.
    
    If `wrap_around=True`, will include a `(last_item, first_item)` pair at the
    end.
        
    Example: if the iterable is [0, 1, 2, 3], then its `consecutive_pairs`
    would be `[(0, 1), (1, 2), (2, 3)]`. (Except it would be an iterator and
    not an actual list.)
    '''
    iterator = iter(iterable)
    
    try:
        first_item = iterator.next()
    except StopIteration:
        raise StopIteration
    
    old = first_item
    
    for current in iterator:
        yield (old, current)
        old = current
        
    if wrap_around:
        yield (current, first_item)
        
    
def shorten(iterable, n):
    '''
    Shorten an iterable to length `n`.
    
    Iterate over the given iterable, but stop after `n` iterations (Or when the
    iterable stops iteration by itself.)
    
    `n` may be infinite.
    '''

    if n == infinity:
        for thing in iterable:
            yield thing
        raise StopIteration
    
    assert isinstance(n, int)

    if n == 0:
        raise StopIteration
    
    for i, thing in enumerate(iterable):
        yield thing
        if i + 1 == n: # Checking `i + 1` to avoid pulling an extra item.
            raise StopIteration
        
        
def enumerate(reversible, reverse_index=False):
    '''
    Iterate over `(i, item)` pairs, where `i` is the index number of `item`.
    
    This is an extension of the builtin `enumerate`. What it allows is to get a
    reverse index, by specifying `reverse_index=True`. This causes `i` to count
    down to zero instead of up from zero, so the `i` of the last member will be
    zero.
    '''
    if reverse_index is False:
        return __builtin__.enumerate(reversible)
    else:
        my_list = list(__builtin__.enumerate(reversed(reversible)))
        my_list.reverse()
        return my_list

    
def is_iterable(thing):
    '''Return whether an object is iterable.'''
    if hasattr(type(thing), '__iter__'):
        return True
    else:
        try:
            iter(thing)
        except TypeError:
            return False
        else:
            return True
        

def get_length(iterable):
    '''Get the length of an iterable.'''
    i = 0
    for thing in iterable:
        i += 1
    return i


def product(*args, **kwargs):
    '''
    Cartesian product of input iterables.

    Equivalent to nested for-loops in a generator expression. `product(A, B)`
    returns the same as `((x,y) for x in A for y in B)`.
    
    More examples:
    
        list(product('ABC', 'xy')) == ['Ax', 'Ay', 'Bx', 'By', 'Cx', 'Cy']
        
        list(product(range(2), repeat=2) == ['00', '01', '10', '11']
        
    '''
    # todo: revamp, probably take from stdlib
    pools = map(tuple, args) * kwargs.get('repeat', 1)
    result = [[]]
    for pool in pools:
        result = [x + [y] for x in result for y in pool]
    for prod in result:
        yield tuple(prod)


def iter_with(iterable, context_manager):
    '''Iterate on `iterable`, `with`ing the context manager on every `next`.'''
    
    while True:
        
        with context_manager:
            next_item = iterable.next()
            # You may notice that we are not `except`ing a StopIteration here;
            # If we get one, it'll just get propagated and end *this* iterator.
            # todo: I just realized this will probably cause a bug where
            # `__exit__` will get the `StopIteration`! Make failing tests and
            # fix.
        
        yield next_item
        
        
########NEW FILE########
__FILENAME__ = base_profile
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Wraps the `cProfile` module, fixing a little bug in `runctx`.
'''

from cProfile import *

from .pstats_troubleshooting import troubleshoot_pstats
troubleshoot_pstats()
del troubleshoot_pstats


def runctx(statement, globals, locals, filename=None, sort=-1):
    """Run statement under profiler, supplying your own globals and locals,
    optionally saving results in filename.

    statement and filename have the same semantics as profile.run
    """
    prof = Profile()
    result = None
    try:
        try:
            prof = prof.runctx(statement, globals, locals)
        except SystemExit:
            pass
    finally:
        if filename is not None:
            prof.dump_stats(filename)
        else:
            result = prof.print_stats(sort)
    return result


########NEW FILE########
__FILENAME__ = cute_profile
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `profile_ready` decorator.

See its documentation for more details.
'''

import functools

from garlicsim.general_misc import decorator_tools

from . import base_profile


def profile_ready(condition=None, off_after=True, sort=2):
    '''
    Decorator for setting a function to be ready for profiling.
    
    For example:
    
        @profile_ready()
        def f(x, y):
            do_something_long_and_complicated()
            
    The advantages of this over regular `cProfile` are:
    
     1. It doesn't interfere with the function's return value.
     
     2. You can set the function to be profiled *when* you want, on the fly.
     
    How can you set the function to be profiled? There are a few ways:
    
    You can set `f.profiling_on=True` for the function to be profiled on the
    next call. It will only be profiled once, unless you set
    `f.off_after=False`, and then it will be profiled every time until you set
    `f.profiling_on=False`.
    
    You can also set `f.condition`. You set it to a condition function taking
    as arguments the decorated function and any arguments (positional and
    keyword) that were given to the decorated function. If the condition
    function returns `True`, profiling will be on for this function call,
    `f.condition` will be reset to `None` afterwards, and profiling will be
    turned off afterwards as well. (Unless, again, `f.off_after` is set to
    `False`.)
    
    `sort` is an `int` specifying which column the results will be sorted by.
    '''
    
    
    def decorator(function):
        
        def inner(function_, *args, **kwargs):
            
            if decorated_function.condition is not None:
                
                if decorated_function.condition is True or \
                   decorated_function.condition(
                       decorated_function.original_function,
                       *args,
                       **kwargs
                       ):
                    
                    decorated_function.profiling_on = True
                    
            if decorated_function.profiling_on:
                
                if decorated_function.off_after:
                    decorated_function.profiling_on = False
                    decorated_function.condition = None
                    
                # This line puts it in locals, weird:
                decorated_function.original_function
                
                base_profile.runctx(
                    'result = '
                    'decorated_function.original_function(*args, **kwargs)',
                    globals(), locals(), sort=decorated_function.sort
                )                
                return locals()['result']
            
            else: # decorated_function.profiling_on is False
                
                return decorated_function.original_function(*args, **kwargs)
            
        decorated_function = decorator_tools.decorator(inner, function)
        
        decorated_function.original_function = function
        decorated_function.profiling_on = None
        decorated_function.condition = condition
        decorated_function.off_after = off_after
        decorated_function.sort = sort
        
        return decorated_function
    
    return decorator


########NEW FILE########
__FILENAME__ = pstats_troubleshooting
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `troubleshoot_pstats` function.

See its documentation for more details.
'''

import os

from garlicsim.general_misc import import_tools


def troubleshoot_pstats():
    '''
    Let the user know if there might be an error importing `pstats`.
    
    Raises an exception if it thinks it caught the problem. So if this function
    didn't raise an exception, it means it didn't manage to diagnose the
    problem.
    '''    
    if not import_tools.exists('pstats') and os.name == 'posix':
        
        raise ImportError(
            "The required `pstats` Python module is not installed on your "
            "computer. Since you are using Linux, it's possible that this is "
            "because some Linux distributions don't include `pstats` by "
            "default. You should be able to fix this by installing the "
            "`python-profiler` package in your OS's package manager. "
            "(Possibly you will have to get this package from the multiverse.)"
        )
    
        
########NEW FILE########
__FILENAME__ = cute_testing
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''This module defines tools for testing.'''

import re

from garlicsim.general_misc.third_party import unittest2

from garlicsim.general_misc import cute_inspect
from garlicsim.general_misc.context_manager import ContextManager
from garlicsim.general_misc.exceptions import CuteException
from garlicsim.general_misc import logic_tools


class Failure(CuteException, AssertionError):
    '''A test has failed.'''


class RaiseAssertor(ContextManager):
    '''
    Asserts that a certain exception was raised in the suite. You may use a
    snippet of text that must appear in the exception message or a regex that
    the exception message must match.
    
    Example:
    
        with RaiseAssertor(ZeroDivisionError, 'modulo by zero'):
            1/0
    
    '''
    
    def __init__(self, exception_type=Exception, text='',
                 assert_exact_type=False):
        '''
        Construct the `RaiseAssertor`.
        
        `exception_type` is an exception type that the exception must be of;
        `text` may be either a snippet of text that must appear in the
        exception's message, or a regex pattern that the exception message must
        match. Specify `assert_exact_type=False` if you want to assert that the
        exception is of the exact `exception_type` specified, and not a
        subclass of it.
        '''
        
        self.exception_type = exception_type
        '''The type of exception that should be raised.'''
        
        self.text = text
        '''The snippet or regex that the exception message must match.'''
        
        self.exception = None
        '''The exception that was caught.'''
        
        self.assert_exact_type = assert_exact_type
        '''
        Flag saying whether we require an exact match to `exception_type`.
        
        If set to `False`, a subclass of `exception_type` will also be
        acceptable.
        '''
        
        
    def manage_context(self):
        '''Manage the `RaiseAssertor'`s context.'''
        try:
            yield self
        except self.exception_type, exception:
            self.exception = exception
            if self.assert_exact_type:
                if self.exception_type is not type(exception):
                    assert issubclass(type(exception), self.exception_type)
                    raise Failure(
                        "The exception `%s` was raised, and it *is* an "
                        "instance of the `%s` we were expecting; but its type "
                        "is not `%s`, it's `%s`, which is a subclass of `%s`, "
                        "but you specified `assert_exact_type=True`, so "
                        "subclasses aren't acceptable." % (repr(exception),
                        self.exception_type.__name__,
                        self.exception_type.__name__, type(exception).__name__,
                        self.exception_type.__name__)
                    )
            if self.text:
                message = exception.args[0]
                if isinstance(self.text, basestring):
                    if self.text not in message:
                        raise Failure("A `%s` was raised but %s wasn't in its "
                                      "message." % (self.exception_type,
                                      repr(self.text)))
                else:
                    # It's a regex pattern
                    if not self.text.match(message):
                        raise Failure("A `%s` was raised but it didn't match "
                                      "the given regex." % self.exception_type)
        except BaseException, different_exception:
            raise Failure(
                "%s was excpected, but a different exception %s was raised "
                "instead." % (self.exception_type, type(different_exception))
            )
        else:
            raise Failure("%s wasn't raised." % self.exception_type)

                    
def assert_same_signature(*callables):
    '''Assert that all the `callables` have the same function signature.'''
    arg_specs = [cute_inspect.getargspec(callable_) for callable_ in callables]
    if not logic_tools.all_equal(arg_specs, exhaustive=True):
        raise Failure('Not all the callables have the same signature.')
    
    
class _MissingAttribute(object):
    '''Object signifying that an attribute was not found.'''
    # todo: make uninstanciable

    
def assert_polite_wrapper(wrapper, wrapped=None, same_signature=True):
    '''
    Assert that `wrapper` is a polite function wrapper around `wrapped`.
    
    A function wrapper (usually created by a decorator) has a few
    responsibilties; maintain the same name, signature, documentation etc. of
    the original function, and a few others. Here we check that the wrapper did
    all of those things.
    '''
    # todo: in all decorators, should be examining the wrapped function's dict
    # and update the new one with it. can't test for this here though, cause
    # the decorator has the right to change them.
    if wrapped is None:
        wrapped = wrapper.__wrapped__
    if same_signature:
        assert_same_signature(wrapper, wrapped)
    for attribute in ('__module__', '__name__', '__doc__', '__annotations__'):
        assert getattr(wrapper, attribute, _MissingAttribute) == \
               getattr(wrapped, attribute, _MissingAttribute)
    assert wrapper.__wrapped__ == wrapped
    
########NEW FILE########
__FILENAME__ = decorator_tools
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Tools for decorators.'''

import functools
import inspect
import types

from garlicsim.general_misc.third_party import decorator as \
                                               michele_decorator_module

def decorator(caller, func=None):
    '''
    Create a decorator.
    
    `decorator(caller)` converts a caller function into a decorator;
    `decorator(caller, func)` decorates a function using a caller.
    '''
    if func is not None: # returns a decorated function
        evaldict = func.func_globals.copy()
        evaldict['_call_'] = caller
        evaldict['_func_'] = func
        result = michele_decorator_module.FunctionMaker.create(
            func, "return _call_(_func_, %(shortsignature)s)",
            evaldict, undecorated=func)
        result.__wrapped__ = func
        return result
    else: # returns a decorator
        if isinstance(caller, functools.partial):
            return functools.partial(decorator, caller)
        # otherwise assume caller is a function
        first = inspect.getargspec(caller)[0][0] # first arg
        evaldict = caller.func_globals.copy()
        evaldict['_call_'] = caller
        evaldict['decorator'] = decorator
        return michele_decorator_module.FunctionMaker.create(
            '%s(%s)' % (caller.__name__, first), 
            'return decorator(_call_, %s)' % first,
            evaldict, undecorated=caller,
            doc=caller.__doc__, module=caller.__module__)

 
def helpful_decorator_builder(decorator_builder):
    '''
    Take a decorator builder and return a "helpful" version of it.
    
    A decorator builder is a function that returns a decorator. A decorator
    is used like this:

        @foo
        def bar():
            pass
            
    While a decorator *builder* is used like this 
    
        @foo()
        def bar():
            pass
            
    The parentheses are the difference.
    
    Sometimes the user forgets to put parentheses after the decorator builder;
    in that case, a helpful decorator builder is one that raises a helpful
    exception, instead of an obscure one. Decorate your decorator builders with
    `helpful_decorator_builder` to make them raise a helpful exception when the
    user forgets the parentheses.
            
    Limitations:
    
      - Do not use this on decorators that may take a function object as their
        first argument.
    
      - Cannot be used on classes.
      
    '''

    assert isinstance(decorator_builder, types.FunctionType)
    
    def inner(same_decorator_builder, *args, **kwargs):
        
        if args and isinstance(args[0], types.FunctionType):            
            function = args[0]
            function_name = function.__name__
            decorator_builder_name = decorator_builder.__name__
            raise TypeError('It seems that you forgot to add parentheses '
                            'after `@%s` when decorating the `%s` '
                            'function.' % (decorator_builder_name,
                            function_name))
        else:
            return decorator_builder(*args, **kwargs)
        
    return decorator(inner, decorator_builder)
        
########NEW FILE########
__FILENAME__ = dict_tools
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Defines several functions that may be useful when working with dicts.'''


def filter_items(d, condition):
    '''
    Get new dict with items from `d` that satisfy the `condition` functions.
    
    `condition` is a function that takes a key and a value.
    
    The newly created dict will be of the same class as `d`, e.g. if you passed
    an ordered dict as `d`, the result will be an ordered dict, using the
    correct order.
    '''
    # todo future: possibly shallow-copy `d` to allow for dict classes that
    # have more state, (like default factory.)
    dict_type = type(d)
    return dict_type(
        (key, value) for (key, value) in d.iteritems() if condition(key, value)
    )


def get_list(d, iterable):
    '''Get a list of values corresponding to an `iterable` of keys.'''
    return [d[key] for key in iterable]


def get_contained(d, container):
    '''Get a list of the values in the dict whose keys are in `container`.'''
    return [value for (key, value) in d.iteritems() if (key in container)]


def fancy_string(d, indent=0):
    '''Show a dict as a string, slightly nicer than dict.__repr__.'''

    small_space = ' ' * indent
    
    big_space = ' ' * (indent + 4)
    
    huge_space = ' ' * (indent + 8)
    
    def show(thing, indent=0):
        space = ' ' * indent
        enter_then_space = '\n' + space
        return repr(thing).replace('\n', enter_then_space)
    
    temp1 = (
        (big_space + repr(key) + ':\n' + huge_space + show(value, indent + 8))
        for(key, value) in d.items())
    
    temp2 = small_space + '{\n' + ',\n'.join(temp1) + '\n' + small_space +'}'
    
    return temp2
    

def reverse_with_set_values(d):
    '''
    Reverse the dict, with the values of the new dict being sets.
    
    Example:
    
        reverse_with_set_values({1: 2, 3: 4, 'meow': 2}) = \
            {2: set([1, 'meow']), 4: set([3])}
            
    '''
    new_dict = {}
    for key, value in d.iteritems():
        if value not in new_dict:
            new_dict[value] = []
        new_dict[value].append(key)
    
    # Making into sets:
    for key, value in new_dict.copy().iteritems():
        new_dict[key] = set(value)
        
    return new_dict
########NEW FILE########
__FILENAME__ = exceptions
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Defines exceptions.'''


class CuteException(Exception):
    '''
    Exception that uses its first line of documentation in lieu of a message.
    '''

    def __init__(self, message=None):
        # We use `None` as the default for `message`, so the user can input ''
        # to force an empty message.
        
        if message is None:
            if self.__doc__ and (type(self) is not CuteException):
                message = self.__doc__.strip().split('\n')[0] 
                # Getting the first line of the documentation
            else:
                message = ''
                
        Exception.__init__(self, message)
        
        self.message = message
        '''
        The message of the exception, detailing what went wrong.
        
        We provide this `.message` attribute despite `BaseException.message`
        being deprecated in Python. The message can also be accessed as the
        Python-approved `BaseException.args[0]`.
        '''

        
########NEW FILE########
__FILENAME__ = function_anchoring_type
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `FunctionAnchoringType` class.

See its documentation for more details.
'''

import sys
import types

from garlicsim.general_misc import misc_tools
from garlicsim.general_misc import import_tools
from garlicsim.general_misc import address_tools


class FunctionAnchoringType(type):
    '''
    Metaclass for working around Python's problems with pickling functions.
    
    Python has a hard time pickling functions that are not at module level,
    because when unpickling them, Python looks for them only on the module
    level.
    
    What we do in this function is create a reference to each of the class's
    functions on the module level. We call this "anchoring." Note that we're
    only anchoring the *functions*, not the *methods*. Methods *can* be pickled
    by Python, but plain functions, like those created by `staticmethod`,
    cannot.
    
    This workaround is hacky, yes, but it seems like the best solution until
    Python learns how to pickle non-module-level functions.
    '''
    def __new__(mcls, name, bases, namespace_dict):
        my_type = super(FunctionAnchoringType, mcls).__new__(mcls,
                                                             name,
                                                             bases,
                                                             namespace_dict)
        
        # We want the type's `vars`, but we want them "getted," and not in a
        # `dict`, so we'll get method objects instead of plain functions.
        my_getted_vars = misc_tools.getted_vars(my_type)
        # Repeat after me: "Getted, not dict."
        
        functions_to_anchor = [value for key, value in my_getted_vars.items()
                               if isinstance(value, types.FunctionType) and not
                               misc_tools.is_magic_variable_name(key)]
        for function in functions_to_anchor:
            module_name = function.__module__
            module = sys.modules[module_name]
            function_name = function.__name__
            
            # Since this metaclass is a hacky enough solution as it is, let's
            # be careful and ensure no object is already defined by the same
            # name in the module level: (todotest)
            try:
                already_defined_object = getattr(module, function_name)
            except AttributeError:
                # Good, there is no object defined under our anchor address.
                # This is the normal case.
                setattr(module, function_name, function)
            else:
                # Something already exists at the anchor address; let's be
                # careful.
                if already_defined_object is not function:
                    raise Exception("An object `%s.%s` already exists! Can't "
                                    "anchor function." % \
                                    (module_name, function_name))
        return my_type
                    
    
########NEW FILE########
__FILENAME__ = identities
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `HasIdentity` class.

See its documentation for more information.
'''

from garlicsim.general_misc import caching
from garlicsim.general_misc.persistent import CrossProcessPersistent


class HasIdentity(object):
    '''
    An object that has a persistent identity.
    
    When you make deepcopies of this object using `DontCopyPersistent()`, the
    new copies will have the same "identity" as the original object:
    
        >>> class A(HasIdentity):
        ...     pass
        >>> a0 = A()
        >>> a1 = copy.deepcopy(a0, DontCopyPersistent)
        >>> a0.has_same_identity_as(a1)
        True
        >>> a0 & a1 # Shortcut for `has_same_identity_as`
        True
        
    (`DontCopyPersistent` is available as
    `garlicsim.general_misc.persistent.DontCopyPersistent`)    
    '''
    def __init__(self):
        self.__identity = CrossProcessPersistent()
        '''The object's persistent identity.'''

        
    def has_same_identity_as(self, other):
        '''Does `other` have the same identity as us?'''
        if not isinstance(other, HasIdentity):
            return NotImplemented
        return self.__identity.has_same_uuid_as(other.__identity)
    
    __and__ = has_same_identity_as
    
    
    @caching.CachedProperty
    def personality(self):
        '''Personality containing a human name and two colors.'''
        return self.__identity.personality
        
        
########NEW FILE########
__FILENAME__ = import_tools
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Defines various tools related to importing.'''

import sys
import os.path
import imp
import zipimport

from garlicsim.general_misc import package_finder
from garlicsim.general_misc import caching

    

def import_all(package, exclude='__init__', silent_fail=False):
    '''
    Import all the modules and packages that live inside the given package.
    
    This is not recursive. Modules and packages defined inside a subpackage
    will not be imported (of course, that subpackage itself may import them
    anyway.)
    
    You may specify a module/package to exclude, which is by default
    `__init__`.
    
    Returns a list with all the imported modules and packages.
    
    todo: only tested with __init__ passed in
    '''
    
    paths = package_finder.get_packages_and_modules_filenames(package)
    
    names = {}
    for path in paths:
        name = os.path.splitext(os.path.split(path)[1])[0]
        if name == exclude:
            continue
        full_name = package.__name__ + '.' + name
        names[path] = full_name
        
    d = {}
    
    for (path, name) in names.items():
        try:
            d[name] = normal_import(name)
        except Exception:
            if not silent_fail:
                raise
    
    return d


def normal_import(module_name):
    '''
    Import a module.
    
    This function has several advantages over `__import__`:
    
     1. It avoids the weird `fromlist=['']` that you need to give `__import__`
        in order for it to return the specific module you requested instead of 
        the outermost package, and
    
     2. It avoids a weird bug in Linux, where importing using `__import__` can
        lead to a `module.__name__` containing two consecutive dots.
        
    '''
    if '.' in module_name:
        package_name, submodule_name = module_name.rsplit('.', 1)
        package = __import__(module_name)
        return reduce(getattr, [package] + module_name.split('.')[1:])
    else:
        return __import__(module_name)
    

@caching.cache() # todo: clear cache if sys.path changes
def import_if_exists(module_name, silent_fail=False):
    '''
    Import module by name and return it, only if it exists.
    
    If `silent_fail` is `True`, will return `None` if the module doesn't exist.
    If `silent_fail` is False, will raise `ImportError`.
    
    `silent_fail` applies only to whether the module exists or not; if it does
    exist, but there's an error importing it... *release the hounds.*
    
    I mean, we just raise the error.
    '''    
    if '.' in module_name:
        package_name, submodule_name = module_name.rsplit('.', 1)
        package = import_if_exists(package_name, silent_fail=silent_fail)
        if not package:
            assert silent_fail is True
            return None
        package_path = package.__path__
        try:
            imp.find_module(submodule_name, package_path)
        except ImportError:
            if silent_fail is True:
                return None
            else: # silent_fail is False
                raise
    else: # '.' not in module_name
        try:
            imp.find_module(module_name)
        except ImportError:
            if silent_fail is True:
                return None
            else: # silent_fail is False
                raise

    # Not actually using the result of `imp.find_module`, just want to know
    # that it worked and the module exists. We'll let `normal_import` find the
    # module again, assuming its finding procedure will work exactly the same
    # as `imp`'s.
        
    return normal_import(module_name)


def _module_exists_in_some_zip_path(module_name):
    '''
    Return whether a module by the name `module_name` exists in a zip archive.
    
    Used internally by `exists`.
    '''
    assert '.' not in module_name
    
    zip_paths = [path for path in sys.path if '.zip' in path]
    # todo: Find better way to filter zip paths.
    
    for zip_path in zip_paths:

        # Trying to create a zip importer:
        try:
            zip_importer = zipimport.zipimporter(zip_path)
        except zipimport.ZipImportError:
            continue
            # Excepted `ZipImportError` because we may have zip paths in
            # `sys.path` that don't really exist, which causes `zipimport` to
            # raise `ZipImportError`.
            #
            # todo: should find smarter way of catching this, excepting
            # `ZipImportError` is not a good idea.
        
        if zip_importer.find_module(module_name) is not None:    
            return True
        else:
            continue
        
    return False


def exists(module_name):
    '''
    Return whether a module by the name `module_name` exists.
    
    This seems to be the best way to carefully import a module.
    
    Currently implemented for top-level packages only. (i.e. no dots.)
    
    Supports modules imported from a zip file.
    '''
    assert '.' not in module_name
    try:
        imp.find_module(module_name)
    except ImportError:
        return _module_exists_in_some_zip_path(module_name)
    else:
        return True

    
# Unused for now:

#def import_by_path(path, name=None):
    #'''
    #Import module/package by path.
    
    #You may specify a name: This is helpful only if it's an hierarchical name,
    #i.e. a name with dots like "orange.claw.hammer". This will become the
    #imported module's __name__ attribute. Otherwise only the short name,
    #"hammer", will be used, which might cause problems in some cases. (Like
    #when using multiprocessing.)
    #'''
    #short_name = os.path.splitext(os.path.split(path)[1])[0]
    #if name is None: name = short_name
    #path_to_dir = os.path.dirname(path)
    #my_file = None
    #try:
        #(my_file, pathname, description) = \
            #imp.find_module(short_name, [path_to_dir])
        #module = imp.load_module(name, my_file, pathname, description)
    #finally:
        #if my_file is not None:
            #my_file.close()
        
    #return module
########NEW FILE########
__FILENAME__ = infinity
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `Infinity` class and related exceptions.

See their documentation for more info.
'''

from garlicsim.general_misc.exceptions import CuteException
from garlicsim.general_misc import math_tools


__all__ = ['infinity', 'InfinityError', 'InfinityRaceError']


def is_floatable(x):
    try:
        float(x)
        return True
    except Exception:
        return False

    
def is_nonfractional(x):
    try:
        int(x)
        return int(x) == x
    except Exception:
        return False
        
    
class InfinityRaceError(CuteException):
    '''
    An "infinity race" between two infinite sizes.
    
    A calculation is being made between two quantities that involve infinity,
    and the two infinities are "pitted" against each other in a way which makes
    it impossible to determine what the result of the computation would be.
    '''

    
class InfinityError(CuteException):
    '''infinity-related exception.'''

    
class Infinity(object):
    '''
    A class for infinity numbers.
    
    There are only two distinct instances of this class: infinity and
    (-infinity).
    '''
    #todo: add __assign__ or whatever it's called
    #todo: add more interoperability with float(inf). (Need to detect its
    #existance)    
    #todo: calling it Infinity is a bit wrong./
    
    def __init__(self, direction=1):
        self.direction = direction
        
    def __abs__(self):
        return infinity
    
    def __add__(self, other):
        if isinstance(other, Infinity):
            if self.direction == other.direction:
                return self
            else:
                raise InfinityRaceError
        elif is_floatable(other):
            return self
        
    def __sub__(self, other):
        return self.__add__(-other)
    
    def __cmp__(self, other):
        if isinstance(other, Infinity):
            d_cmp = cmp(self.direction, other.direction)
            if d_cmp != 0:
                return d_cmp
            else:
                raise InfinityRaceError
        elif is_floatable(other):
            return self.direction
        else:
            raise NotImplementedError
    def __div__(self, other):
        if isinstance(other, Infinity):
            raise InfinityRaceError
        elif is_floatable(other):
            s = math_tools.sign(other)
            if s==0:
                raise InfinityRaceError
            else:
                return Infinity(direction=self.direction * s)
            
    def __float__(self):
        raise ValueError("Can't convert infinite number to float")
    
    def __mul__(self, other):
        if isinstance(other, Infinity):
            return Infinity(self.direction * other.direction)
        elif is_floatable(other):
            s = math_tools.sign(other)
            if s==0:
                raise InfinityRaceError
            else:
                return Infinity(direction=self.direction * s)
            
    def __neg__(self):
        return Infinity(-self.direction)
    
    def __nonzero__(self):
        return True
    
    def __pos__(self):
        return self
    
    def __pow__(self, other):
        if isinstance(other, Infinity):
            raise object # todo
        elif is_floatable(other):
            s = math_tools.sign(other)
            if s==0:
                raise InfinityRaceError
            else:
                if self.direction==1:
                    if s==1:
                        return self
                    if s==-1:
                        return 0
                else: #self.direction == -1
                    if is_nonfractional(other):
                        if s==-1:
                            return 0
                        if s==1:
                            if s % 2 == 0:                                
                                return Infinity()
                            else:                    
                                return Infinity(-1)                            
                    else: # is_nonfractional(other) is False
                        raise ValueError("Negative number cannot be raised "
                                         "to a fractional power")            
          
                
    def __rpow__(self, other):
        if isinstance(other, Infinity):
            return other.__pow__(self)
        elif not is_floatable(other):
            raise NotImplementedError
        else: # is_floatable(number) is True
            raise NotImplementedError # todo
        
    def __radd__(self, other):
        return self.__add__(other)
    
    def __rsub__(self, other):
        return ( - self.__sub__(other))
    
    def __rmul__(self, other):
        return self.__mul__(other)
    
    __truediv__ = __floordiv__ = __div__
    
    def __eq__(self, other):

        if isinstance(other, Infinity):
            return other.direction == self.direction
        
        elif isinstance(other, float):
            # We're checking to see if `other` is equal to `float('inf')` or
            # `-float('inf')`. But we must `try` it carefully, because in Python
            # 2.5 there is no `float('inf')`.
            #
            # Todo: It seems this takes precedence over `float.__eq__`,
            # fortunately. How come this happens?
            try:
                float_inf = float('inf')
            except ValueError:
                return False
            
            if other == float_inf:
                return self.direction == 1
            elif other == -float_inf:
                return self.direction == -1
            else:
                return False
            
        else: # `other` is not any kind of infinity
            return False
        
    
    def __neq__(self, other):
        return not self.__eq__(other)
    
    def __repr__(self):
        if self.direction==1:
            suffix=''
        else: # self.direction == -1
            suffix='-'
        return suffix + 'infinity'
        

infinity = Infinity()



########NEW FILE########
__FILENAME__ = introspection_tools
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Defines various introspection tools, similar to the stdlib's `inspect`.'''

from garlicsim.general_misc import cute_inspect

from garlicsim.general_misc.nifty_collections import OrderedDict


def get_default_args_dict(function):
    '''
    Get ordered dict from arguments which have a default to their default.
    
    Example:
    
        >>> def f(a, b, c=1, d='meow'): pass
        >>> get_default_args_dict(f)
        OrderedDict([('c', 1), ('d', 'meow')])
        
    '''
    arg_spec = cute_inspect.getargspec(function)
    (s_args, s_star_args, s_star_kwargs, s_defaults) = arg_spec
        
    # `getargspec` has a weird policy, when inspecting a function with no
    # defaults, to give a `defaults` of `None` instead of the more consistent
    # `()`. We fix that here:
    if s_defaults is None:
        s_defaults = ()
    
    # The number of args which have default values:
    n_defaultful_args = len(s_defaults)
    
    defaultful_args = s_args[-n_defaultful_args:] if n_defaultful_args \
                       else []
    
    return OrderedDict(zip(defaultful_args, s_defaults))
    
    
########NEW FILE########
__FILENAME__ = logic_tools
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''This module defines logic-related tools.'''

from garlicsim.general_misc import cute_iter_tools
from garlicsim.general_misc import sequence_tools


def all_equal(iterable, exhaustive=False):
    '''
    Return whether all elements in the iterable are equal to each other.
    
    If `exhaustive` is set to `False`, it's assumed that the equality relation
    is transitive, therefore not every member is tested against every other
    member. So in a list of size `n`, `n-1` equality checks will be made.
    
    If `exhaustive` is set to `True`, every member will be checked against
    every other member. So in a list of size `n`, `(n*(n-1))/2` equality checks
    will be made.
    '''
    # todo: Maybe I should simply check if `len(set(iterable)) == 1`? Will not
    # work for unhashables.
    
    if exhaustive is True:
        pairs = sequence_tools.combinations(list(iterable), 2)
    else: # exhaustive is False
        pairs = cute_iter_tools.consecutive_pairs(iterable)
        
    return all(a==b for (a, b) in pairs)


def logic_max(iterable, relation=lambda a, b: (a >= b)):
    '''
    Get a list of maximums from the iterable.
        
    `relation` is allowed to be a partial order.
    '''
    sequence = list(iterable)
    
    maximal_elements = []
    
    for candidate in sequence:
        if all(relation(candidate, thing) for thing in sequence):
            maximal_elements.append(candidate)
    
    return maximal_elements
        
########NEW FILE########
__FILENAME__ = math_tools
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''This module defines math-related tools.'''

from __future__ import division


def sign(x):
    '''Get the sign of a number.'''
    if x > 0:
        return 1
    if x == 0:
        return 0
    assert x < 0
    return -1


def round_to_int(x, up=False):
    '''
    Round a number to an `int`.
    
    This is mostly used for floating points. By default, it will round the
    number down, unless the `up` argument is set to `True` and then it will
    round up.
    
    If you want to round a number to the closest `int`, just use
    `int(round(x))`.
    '''
    rounded_down = int(x // 1)
    if up:
        return int(x) if (isinstance(x, float) and x.is_integer()) \
               else rounded_down + 1
    else:
        return rounded_down
########NEW FILE########
__FILENAME__ = misc_tools
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''This module defines miscellaneous tools.'''

import re
import math
import types

from garlicsim.general_misc import cute_iter_tools


def is_subclass(candidate, base_class):
    '''
    Check if `candidate` is a subclass of `base_class`.
    
    You may pass in a tuple of base classes instead of just one, and it will
    check whether `candidate` is a subclass of any of these base classes.
    
    This has 2 advantages of over the built-in `issubclass`:
    
     1. It doesn't throw an exception if `candidate` is not a type. (Python
        issue 10569.)
     2. It manually checks for a `__subclasscheck__` method on `base_class`.
        This is helpful for Python 2.5 compatibility because Python started
        using `__subclasscheck__` in its built-in `issubclass` starting from
        Python 2.6.
        
    '''
    # todo: disable ability to use nested iterables.
    if cute_iter_tools.is_iterable(base_class):
        return any(is_subclass(candidate, single_base_class) for 
                   single_base_class in base_class)
    elif not isinstance(candidate, (type, types.ClassType)):
        return False
    elif hasattr(base_class, '__subclasscheck__'):
        return base_class.__subclasscheck__(candidate)
    else:
        return issubclass(candidate, base_class)


def get_mro_depth_of_method(type_, method_name):
    '''
    Get the mro-depth of a method.
    
    This means, the index number in `type_`'s MRO of the base class that
    defines this method.
    '''
    assert isinstance(method_name, basestring)
    mro = type_.mro()
    
    assert mro[0] is type_
    method = getattr(mro[0], method_name)
    assert method is not None

    for deepest_index, base_class in reversed(list(enumerate(mro))):
        if hasattr(base_class, method_name) and \
           getattr(base_class, method_name) == method:
            break
        
    return deepest_index


def frange(start, finish=None, step=1.):
    '''
    Make a `list` containing an arithmetic progression of numbers.

    This is an extension of the builtin `range`; it allows using floating point
    numbers.
    '''
    if finish is None:
        finish, start = start, 0.
    else:
        start = float(start)

    count = int(math.ceil(finish - start)/step)
    return (start + n*step for n in range(count))
    

def getted_vars(thing, _getattr=getattr):
    '''
    The `vars` of an object, but after we used `getattr` to get them.
    
    This is useful because some magic (like descriptors or `__getattr__`
    methods) need us to use `getattr` for them to work. For example, taking
    just the `vars` of a class will show functions instead of methods, while
    the "getted vars" will have the actual method objects.
    
    You may provide a replacement for the built-in `getattr` as the `_getattr`
    argument.
    '''
    # todo: can make "fallback" option, to use value from original `vars` if
    # get is unsuccessful.
    my_vars = vars(thing)
    return dict((name, _getattr(thing, name)) for name in my_vars.iterkeys())



_ascii_variable_pattern = re.compile('^[a-zA-Z_][0-9a-zA-Z_]*$')
def is_legal_ascii_variable_name(name):
    '''Return whether `name` is a legal name for a Python variable.'''
    return bool(_ascii_variable_pattern.match(name))


def is_magic_variable_name(name):
    '''Return whether `name` is a name of a magic variable (e.g. '__add__'.)'''
    return is_legal_ascii_variable_name(name) and \
           len(name) >= 5 and \
           name[:2] == name[-2:] == '__'


def get_actual_type(thing):
    '''
    Get the actual type (or class) of an object.
    
    This is used instead of `type(thing)` for compaibility with old-style
    classes.
    '''
    
    return getattr(thing, '__class__', None) or type(thing)
    # Using `.__class__` instead of `type` because of goddamned old-style
    # classes. When you do `type` on an instance of an old-style class, you
    # just get the useless `InstanceType`. But wait, there's more! We can't
    # just take `thing.__class__` because the old-style classes themselves,
    # i.e. the classes and not the instances, do not have a `.__class__`
    # attribute at all! Therefore we are using `type` as a fallback.
    #
    # I don't like old-style classes, that's what I'm saying.
    
    
def is_number(x):
    '''Return whether `x` is a number.'''
    try:
        x + 1
    except Exception:
        return False
    else:
        return True
    
def identity_function(thing):
    '''
    Return `thing`.
    
    This function is useful when you want to use an identity function but can't
    define a lambda one because it wouldn't be pickleable. Also using this
    function might be faster as it's prepared in advance.
    '''
    return thing
########NEW FILE########
__FILENAME__ = monkeypatching_tools
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Tools for monkeypatching.'''

import types
from garlicsim.general_misc import decorator_tools


@decorator_tools.helpful_decorator_builder
def monkeypatch_method(class_, name=None):
    '''
    Monkeypatch a method into a class.
    
    Example:
    
        class A(object):
            pass
    
        @monkeypatch_method(A)
        def my_method(a):
            return (a, 'woo!')
        
        a = A()
        
        assert a.my_method() == (a, 'woo!')
        
    You may use the `name` argument to specify a method name different from the
    function's name.
    '''
    def decorator(function):
        # Note that unlike most decorators, this decorator retuns the function
        # it was given without modifying it. It modifies the class only.
        name_ = name or function.__name__
        new_method = types.MethodType(function, None, class_)
        # todo: Last line was: `new_method = types.MethodType(function,
        # class_)`, is subtly wrong, make tests to prove
        setattr(class_, name_, new_method)
        return function
    return decorator
########NEW FILE########
__FILENAME__ = monkeypatch_copy_reg
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''This module monkey-patches the pickling dispatch table using `copy_reg`.'''

# todo: alters global state, yuck! Maybe check before if it's already set to
# something?

import copy_reg
import types
import __builtin__

from garlicsim.general_misc import import_tools


###############################################################################

def reduce_method(method):
    '''Reducer for methods.'''
    return (
        getattr,
        (
            
            method.im_self or method.im_class,
            # `im_self` for bound methods, `im_class` for unbound methods.
            
            method.im_func.__name__
        
        )
    )

copy_reg.pickle(types.MethodType, reduce_method)


###############################################################################


def reduce_module(module):
    '''Reducer for modules.'''
    return (import_tools.normal_import, (module.__name__,))

copy_reg.pickle(types.ModuleType, reduce_module)


###############################################################################


def _get_ellipsis():
    '''Get the `Ellipsis`.'''
    return Ellipsis

def reduce_ellipsis(ellipsis):
    '''Reducer for `Ellipsis`.'''
    return (
        _get_ellipsis,
        ()
    )

copy_reg.pickle(types.EllipsisType, reduce_ellipsis)


###############################################################################



########NEW FILE########
__FILENAME__ = counter
# forked from Python 2.7

from garlicsim.general_misc.third_party.abcs_collection import Mapping
from operator import itemgetter as _itemgetter, eq as _eq
import heapq as _heapq
from itertools import (repeat as _repeat, chain as _chain,
                       starmap as _starmap, ifilter as _ifilter, 
                       imap as _imap)

class Counter(dict):
    '''Dict subclass for counting hashable items.  Sometimes called a bag
    or multiset.  Elements are stored as dictionary keys and their counts
    are stored as dictionary values.

    >>> c = Counter('abracadabra')      # count elements from a string

    >>> c.most_common(3)                # three most common elements
    [('a', 5), ('r', 2), ('b', 2)]
    >>> sorted(c)                       # list all unique elements
    ['a', 'b', 'c', 'd', 'r']
    >>> ''.join(sorted(c.elements()))   # list elements with repetitions
    'aaaaabbcdrr'
    >>> sum(c.values())                 # total of all counts
    11

    >>> c['a']                          # count of letter 'a'
    5
    >>> for elem in 'shazam':           # update counts from an iterable
    ...     c[elem] += 1                # by adding 1 to each element's count
    >>> c['a']                          # now there are seven 'a'
    7
    >>> del c['r']                      # remove all 'r'
    >>> c['r']                          # now there are zero 'r'
    0

    >>> d = Counter('simsalabim')       # make another counter
    >>> c.update(d)                     # add in the second counter
    >>> c['a']                          # now there are nine 'a'
    9

    >>> c.clear()                       # empty the counter
    >>> c
    Counter()

    Note:  If a count is set to zero or reduced to zero, it will remain
    in the counter until the entry is deleted or the counter is cleared:

    >>> c = Counter('aaabbc')
    >>> c['b'] -= 2                     # reduce the count of 'b' by two
    >>> c.most_common()                 # 'b' is still in, but its count is zero
    [('a', 3), ('c', 1), ('b', 0)]

    '''
    # References:
    #   http://en.wikipedia.org/wiki/Multiset
    #   http://www.gnu.org/software/smalltalk/manual-base/html_node/Bag.html
    #   http://www.demo2s.com/Tutorial/Cpp/0380__set-multiset/Catalog0380__set-multiset.htm
    #   http://code.activestate.com/recipes/259174/
    #   Knuth, TAOCP Vol. II section 4.6.3

    def __init__(self, iterable=None, **kwds):
        '''Create a new, empty Counter object.  And if given, count elements
        from an input iterable.  Or, initialize the count from another mapping
        of elements to their counts.

        >>> c = Counter()                           # a new, empty counter
        >>> c = Counter('gallahad')                 # a new counter from an iterable
        >>> c = Counter({'a': 4, 'b': 2})           # a new counter from a mapping
        >>> c = Counter(a=4, b=2)                   # a new counter from keyword args

        '''
        self.update(iterable, **kwds)

    def __missing__(self, key):
        'The count of elements not in the Counter is zero.'
        # Needed so that self[missing_item] does not raise KeyError
        return 0

    def most_common(self, n=None):
        '''List the n most common elements and their counts from the most
        common to the least.  If n is None, then list all element counts.

        >>> Counter('abracadabra').most_common(3)
        [('a', 5), ('r', 2), ('b', 2)]

        '''
        # Emulate Bag.sortedByCount from Smalltalk
        if n is None:
            return sorted(self.iteritems(), key=_itemgetter(1), reverse=True)
        return _heapq.nlargest(n, self.iteritems(), key=_itemgetter(1))

    def elements(self):
        '''Iterator over elements repeating each as many times as its count.

        >>> c = Counter('ABCABC')
        >>> sorted(c.elements())
        ['A', 'A', 'B', 'B', 'C', 'C']

        # Knuth's example for prime factors of 1836:  2**2 * 3**3 * 17**1
        >>> prime_factors = Counter({2: 2, 3: 3, 17: 1})
        >>> product = 1
        >>> for factor in prime_factors.elements():     # loop over factors
        ...     product *= factor                       # and multiply them
        >>> product
        1836

        Note, if an element's count has been set to zero or is a negative
        number, elements() will ignore it.

        '''
        # Emulate Bag.do from Smalltalk and Multiset.begin from C++.
        return _chain(*_starmap(_repeat, self.iteritems()))

    # Override dict methods where necessary

    @classmethod
    def fromkeys(cls, iterable, v=None):
        # There is no equivalent method for counters because setting v=1
        # means that no element can have a count greater than one.
        raise NotImplementedError(
            'Counter.fromkeys() is undefined.  Use Counter(iterable) instead.')

    def update(self, iterable=None, **kwds):
        '''Like dict.update() but add counts instead of replacing them.

        Source can be an iterable, a dictionary, or another Counter instance.

        >>> c = Counter('which')
        >>> c.update('witch')           # add elements from another iterable
        >>> d = Counter('watch')
        >>> c.update(d)                 # add elements from another counter
        >>> c['h']                      # four 'h' in which, witch, and watch
        4

        '''
        # The regular dict.update() operation makes no sense here because the
        # replace behavior results in the some of original untouched counts
        # being mixed-in with all of the other counts for a mismash that
        # doesn't have a straight-forward interpretation in most counting
        # contexts.  Instead, we implement straight-addition.  Both the inputs
        # and outputs are allowed to contain zero and negative counts.

        if iterable is not None:
            if Mapping.__instancecheck__(iterable):
                if self:
                    self_get = self.get
                    for elem, count in iterable.iteritems():
                        self[elem] = self_get(elem, 0) + count
                else:
                    dict.update(self, iterable) # fast path when counter is empty
            else:
                self_get = self.get
                for elem in iterable:
                    self[elem] = self_get(elem, 0) + 1
        if kwds:
            self.update(kwds)

    def subtract(self, iterable=None, **kwds):
        '''Like dict.update() but subtracts counts instead of replacing them.
        Counts can be reduced below zero.  Both the inputs and outputs are
        allowed to contain zero and negative counts.

        Source can be an iterable, a dictionary, or another Counter instance.

        >>> c = Counter('which')
        >>> c.subtract('witch')             # subtract elements from another iterable
        >>> c.subtract(Counter('watch'))    # subtract elements from another counter
        >>> c['h']                          # 2 in which, minus 1 in witch, minus 1 in watch
        0
        >>> c['w']                          # 1 in which, minus 1 in witch, minus 1 in watch
        -1

        '''
        if iterable is not None:
            self_get = self.get
            if Mapping.__instancecheck__(iterable):
                for elem, count in iterable.items():
                    self[elem] = self_get(elem, 0) - count
            else:
                for elem in iterable:
                    self[elem] = self_get(elem, 0) - 1
        if kwds:
            self.subtract(kwds)

    def copy(self):
        'Like dict.copy() but returns a Counter instance instead of a dict.'
        return Counter(self)

    def __delitem__(self, elem):
        'Like dict.__delitem__() but does not raise KeyError for missing values.'
        if elem in self:
            dict.__delitem__(self, elem)

    def __repr__(self):
        if not self:
            return '%s()' % self.__class__.__name__
        items = ', '.join(map('%r: %r'.__mod__, self.most_common()))
        return '%s({%s})' % (self.__class__.__name__, items)

    # Multiset-style mathematical operations discussed in:
    #       Knuth TAOCP Volume II section 4.6.3 exercise 19
    #       and at http://en.wikipedia.org/wiki/Multiset
    #
    # Outputs guaranteed to only include positive counts.
    #
    # To strip negative and zero counts, add-in an empty counter:
    #       c += Counter()

    def __add__(self, other):
        '''Add counts from two counters.

        >>> Counter('abbb') + Counter('bcc')
        Counter({'b': 4, 'c': 2, 'a': 1})

        '''
        if not isinstance(other, Counter):
            return NotImplemented
        result = Counter()
        for elem in set(self) | set(other):
            newcount = self[elem] + other[elem]
            if newcount > 0:
                result[elem] = newcount
        return result

    def __sub__(self, other):
        ''' Subtract count, but keep only results with positive counts.

        >>> Counter('abbbc') - Counter('bccd')
        Counter({'b': 2, 'a': 1})

        '''
        if not isinstance(other, Counter):
            return NotImplemented
        result = Counter()
        for elem in set(self) | set(other):
            newcount = self[elem] - other[elem]
            if newcount > 0:
                result[elem] = newcount
        return result

    def __or__(self, other):
        '''Union is the maximum of value in either of the input counters.

        >>> Counter('abbb') | Counter('bcc')
        Counter({'b': 3, 'c': 2, 'a': 1})

        '''
        if not isinstance(other, Counter):
            return NotImplemented
        result = Counter()
        for elem in set(self) | set(other):
            p, q = self[elem], other[elem]
            newcount = q if p < q else p
            if newcount > 0:
                result[elem] = newcount
        return result

    def __and__(self, other):
        ''' Intersection is the minimum of corresponding counts.

        >>> Counter('abbb') & Counter('bcc')
        Counter({'b': 1})

        '''
        if not isinstance(other, Counter):
            return NotImplemented
        result = Counter()
        if len(self) < len(other):
            self, other = other, self
        for elem in _ifilter(self.__contains__, other):
            p, q = self[elem], other[elem]
            newcount = p if p < q else q
            if newcount > 0:
                result[elem] = newcount
        return result
########NEW FILE########
__FILENAME__ = ordered_dict
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `OrderedDict` class.

See its documentation for more information.
'''


from UserDict import DictMixin


class OrderedDict(dict, DictMixin):
    '''Dict that maintains order of items.'''

    def __init__(self, *args, **kwds):
        if len(args) > 1:
            raise TypeError('expected at most 1 arguments, got %d' % len(args))
        try:
            self.__end
        except AttributeError:
            self.clear()
        self.update(*args, **kwds)

        
    def clear(self):
        '''D.clear() -> None.  Remove all items from D.'''
        self.__end = end = []
        end += [None, end, end]         # sentinel node for doubly linked list
        self.__map = {}                 # key --> [key, prev, next]
        dict.clear(self)

        
    def __setitem__(self, key, value):
        if key not in self:
            end = self.__end
            curr = end[1]
            curr[2] = end[1] = self.__map[key] = [key, curr, end]
        dict.__setitem__(self, key, value)

        
    def __delitem__(self, key):
        dict.__delitem__(self, key)
        key, prev, next = self.__map.pop(key)
        prev[2] = next
        next[1] = prev

        
    def __iter__(self):
        end = self.__end
        curr = end[2]
        while curr is not end:
            yield curr[0]
            curr = curr[2]

            
    def __reversed__(self):
        end = self.__end
        curr = end[1]
        while curr is not end:
            yield curr[0]
            curr = curr[1]

            
    def popitem(self, last=True):
        '''
        D.popitem() -> (k, v), remove and return some (key, value) pair as a
        2-tuple; but raise KeyError if D is empty
        '''
        if not self:
            raise KeyError('dictionary is empty')
        if last:
            key = reversed(self).next()
        else:
            key = iter(self).next()
        value = self.pop(key)
        return key, value

    
    def __reduce__(self):
        items = [[k, self[k]] for k in self]
        tmp = self.__map, self.__end
        del self.__map, self.__end
        inst_dict = vars(self).copy()
        self.__map, self.__end = tmp
        if inst_dict:
            return (self.__class__, (items,), inst_dict)
        return self.__class__, (items,)

    
    def keys(self):
        return list(self)

    
    setdefault = DictMixin.setdefault
    update = DictMixin.update
    pop = DictMixin.pop
    values = DictMixin.values
    items = DictMixin.items
    iterkeys = DictMixin.iterkeys
    itervalues = DictMixin.itervalues
    iteritems = DictMixin.iteritems

    
    def __repr__(self):
        if not self:
            return '%s()' % (self.__class__.__name__,)
        return '%s(%r)' % (self.__class__.__name__, self.items())

    
    def copy(self):
        return self.__class__(self)

    
    @classmethod
    def fromkeys(cls, iterable, value=None):
        d = cls()
        for key in iterable:
            d[key] = value
        return d

    
    def __eq__(self, other):
        if isinstance(other, OrderedDict):
            if len(self) != len(other):
                return False
            for p, q in  zip(self.items(), other.items()):
                if p != q:
                    return False
            return True
        return dict.__eq__(self, other)

    
    def __ne__(self, other):
        return not self == other

    
    def move_to_end(self, key, last=True):
        '''Move an existing element to the end (or beginning if last==False).

        Raises KeyError if the element does not exist.
        When last=True, acts like a fast version of self[key]=self.pop(key).

        '''
        link = self.__map[key]
        link_prev = link[1]
        link_next = link[2]
        link_prev[2] = link_next
        link_next[1] = link_prev
        end = self.__end
        if last:
            last = end[1]
            link[1] = last
            link[2] = end
            last[2] = end[1] = link
        else:
            first = end[2]
            link[1] = end
            link[2] = first
            end[2] = first[1] = link

    
    def sort(self, key=None):
        '''
        Sort the items according to their keys, changing the order in-place.
        
        The optional `key` argument, (not to be confused with the dictionary
        keys,) will be passed to the `sorted` function as a key function.
        '''
        sorted_keys = sorted(self.keys(), key=key)
        for key in sorted_keys[1:]:
            self.move_to_end(key)
        
            
    def index(self, key):
        '''Get the index number of `key`.'''
        if key not in self:
            raise KeyError
        for i, key_ in enumerate(self):
            if key_ == key:
                return i
        raise RuntimeError
                
########NEW FILE########
__FILENAME__ = ordered_set
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `OrderedSet` class.

See its documentation for more details.
'''
# todo: revamp

from garlicsim.general_misc.third_party import abcs_collection


KEY, PREV, NEXT = range(3)


class OrderedSet(abcs_collection.MutableSet):
    '''
    A set with an order.
    
    You can also think of this as a list which doesn't allow duplicate items
    and whose `__contains__` method is O(1).
    '''

    def __init__(self, iterable=None):
        self.end = end = [] 
        end += [None, end, end]         # sentinel node for doubly linked list
        self.map = {}                   # key --> [key, prev, next]
        if iterable is not None:
            self |= iterable

    def __len__(self):
        return len(self.map)

    def __contains__(self, key):
        return key in self.map

    def add(self, key):
        """
        Add an element to a set.
    
        This has no effect if the element is already present.
        """
        if key not in self.map:
            end = self.end
            curr = end[PREV]
            curr[NEXT] = end[PREV] = self.map[key] = [key, curr, end]

    def discard(self, key):
        """
        Remove an element from a set if it is a member.
    
        If the element is not a member, do nothing.
        """
        if key in self.map:        
            key, prev, next = self.map.pop(key)
            prev[NEXT] = next
            next[PREV] = prev

    def __iter__(self):
        end = self.end
        curr = end[NEXT]
        while curr is not end:
            yield curr[KEY]
            curr = curr[NEXT]

    def __reversed__(self):
        end = self.end
        curr = end[PREV]
        while curr is not end:
            yield curr[KEY]
            curr = curr[PREV]

    def pop(self, last=True):
        """Remove and return an arbitrary set element."""
        if not self:
            raise KeyError('set is empty')
        key = reversed(self).next() if last else iter(self).next()
        self.discard(key)
        return key

    def __repr__(self):
        if not self:
            return '%s()' % (self.__class__.__name__,)
        return '%s(%r)' % (self.__class__.__name__, list(self))

    def __eq__(self, other):
        if isinstance(other, OrderedSet):
            return len(self) == len(other) and list(self) == list(other)
        return set(self) == set(other)

    def __del__(self):
        self.clear()                    # remove circular references
        # todo: is this really needed? i'm worried about this making the gc not
        # drop circulary-referencing objects.

########NEW FILE########
__FILENAME__ = weak_key_default_dict
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `WeakKeyDefaultDict` class.

See its documentation for more details.
'''
# todo: revamp

import UserDict
from weakref import ref


class WeakKeyDefaultDict(UserDict.UserDict, object): #todo: needs testing
    '''
    A weak key dictionary which can use a default factory.
    
    This is a combination of `weakref.WeakKeyDictionary` and
    `collections.defaultdict`.
    
    The keys are referenced weakly, so if there are no more references to the
    key, it gets removed from this dict.
    
    If a "default factory" is supplied, when a key is attempted that doesn't
    exist the default factory will be called to create its new value.
    '''
    
    def __init__(self, *args, **kwargs):
        '''
        Construct the `WeakKeyDefaultDict`.
        
        You may supply a `default_factory` as a keyword argument.
        '''
        self.default_factory = None
        if 'default_factory' in kwargs:
            self.default_factory = kwargs.pop('default_factory')
        elif len(args) > 0 and callable(args[0]):
            self.default_factory = args[0]
            args = args[1:]
        
        self.data = {}
        def remove(k, selfref=ref(self)):
            self = selfref()
            if self is not None:
                del self.data[k]
        self._remove = remove
        if args:
            self.update(args[0])

            
    def __missing__(self, key):
        '''Get a value for a key which isn't currently registered.'''
        if self.default_factory is not None:
            self[key] = value = self.default_factory()
            return value
        else: # self.default_factory is None
            raise KeyError(key)

        
    def __repr__(self, recurse=set()):
        type_name = type(self).__name__
        if id(self) in recurse:
            return "%s(...)" % type_name
        try:
            recurse.add(id(self))
            return "%s(%s, %s)" % (
                type_name,
                repr(self.default_factory),
                super(WeakKeyDefaultDict, self).__repr__()
            )
        finally:
            recurse.remove(id(self))

            
    def copy(self): # todo: needs testing
        return type(self)(self, default_factory=self.default_factory)
    
    __copy__ = copy

    
    def __reduce__(self):
        """
        __reduce__ must return a 5-tuple as follows:

           - factory function
           - tuple of args for the factory function
           - additional state (here None)
           - sequence iterator (here None)
           - dictionary iterator (yielding successive (key, value) pairs

           This API is used by pickle.py and copy.py.
        """
        return \
            (type(self), (self.default_factory,), None, None, self.iteritems())

    
    def __delitem__(self, key):
        del self.data[ref(key)]

        
    def __getitem__(self, key):
        try:
            return self.data[ref(key)]
        except KeyError:
            missing_method = getattr(type(self), '__missing__', None)
            if missing_method:
                return missing_method(self, key)
            else:
                raise

            
    def __setitem__(self, key, value):
        self.data[ref(key, self._remove)] = value

        
    def get(self, key, default=None):
        return self.data.get(ref(key),default)

    
    def has_key(self, key):
        try:
            wr = ref(key)
        except TypeError:
            return 0
        return wr in self.data

    
    def __contains__(self, key):
        try:
            wr = ref(key)
        except TypeError:
            return 0
        return wr in self.data

    
    def items(self):
        """ D.items() -> list of D's (key, value) pairs, as 2-tuples """
        L = []
        for key, value in self.data.items():
            o = key()
            if o is not None:
                L.append((o, value))
        return L

    
    def iteritems(self):
        """ D.iteritems() -> an iterator over the (key, value) items of D """
        for wr, value in self.data.iteritems():
            key = wr()
            if key is not None:
                yield key, value

                
    def iterkeyrefs(self):
        """Return an iterator that yields the weak references to the keys.

        The references are not guaranteed to be 'live' at the time
        they are used, so the result of calling the references needs
        to be checked before being used.  This can be used to avoid
        creating references that will cause the garbage collector to
        keep the keys around longer than needed.

        """
        return self.data.iterkeys()

    
    def iterkeys(self):
        """ D.iterkeys() -> an iterator over the keys of D """
        for wr in self.data.iterkeys():
            obj = wr()
            if obj is not None:
                yield obj

                
    def __iter__(self):
        return self.iterkeys()

    
    def itervalues(self):
        """ D.itervalues() -> an iterator over the values of D """
        return self.data.itervalues()

    
    def keyrefs(self):
        """Return a list of weak references to the keys.

        The references are not guaranteed to be 'live' at the time
        they are used, so the result of calling the references needs
        to be checked before being used.  This can be used to avoid
        creating references that will cause the garbage collector to
        keep the keys around longer than needed.

        """
        return self.data.keys()

    
    def keys(self):
        """ D.keys() -> list of D's keys """
        L = []
        for wr in self.data.keys():
            o = wr()
            if o is not None:
                L.append(o)
        return L

    
    def popitem(self):
        """ D.popitem() -> (k, v), remove and return some (key, value) pair 
        as a 2-tuple; but raise KeyError if D is empty """
        while 1:
            key, value = self.data.popitem()
            o = key()
            if o is not None:
                return o, value

            
    def pop(self, key, *args):
        """ D.pop(k[,d]) -> v, remove specified key and return the 
        corresponding value. If key is not found, d is returned if given,
        otherwise KeyError is raised """
        return self.data.pop(ref(key), *args)

    
    def setdefault(self, key, default=None):
        """D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D"""
        return self.data.setdefault(ref(key, self._remove),default)

    
    def update(self, dict=None, **kwargs):
        """D.update(E, **F) -> None. Update D from E and F: for k in E: D[k] =
        E[k] (if E has keys else: for (k, v) in E: D[k] = v) then: for k in F:
        D[k] = F[k] """
        
        d = self.data
        if dict is not None:
            if not hasattr(dict, "items"):
                dict = type({})(dict)
            for key, value in dict.items():
                d[ref(key, self._remove)] = value
        if len(kwargs):
            self.update(kwargs)
            
            
########NEW FILE########
__FILENAME__ = weak_key_identity_dict
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `WeakKeyIdentityDict` class.

See its documentation for more details.
'''
# todo: revamp

import weakref
import UserDict


__all__ = ['WeakKeyIdentityDict']


class IdentityRef(weakref.ref):
    '''A weak reference to an object, hashed by identity and not contents.'''
    
    def __init__(self, thing, callback=None):
        weakref.ref.__init__(self, thing, callback)
        self._hash = id(thing)
        
        
    def __hash__(self):
        return self._hash


class WeakKeyIdentityDict(UserDict.UserDict, object):
    """
    A weak key dictionary which cares about the keys' identities.
    
    This is a fork of `weakref.WeakKeyDictionary`. Like in the original
    `WeakKeyDictionary`, the keys are referenced weakly, so if there are no
    more references to the key, it gets removed from this dict.
    
    The difference is that `WeakKeyIdentityDict` cares about the keys'
    identities and not their contents, so even unhashable objects like lists
    can be used as keys. The value will be tied to the object's identity and
    not its contents.
    """

    def __init__(self, dict_=None):
        self.data = {}
        def remove(k, selfref=weakref.ref(self)):
            self = selfref()
            if self is not None:
                del self.data[k]
        self._remove = remove
        if dict_ is not None: self.update(dict_)

        
    def __delitem__(self, key):
        del self.data[IdentityRef(key)]

        
    def __getitem__(self, key):
        return self.data[IdentityRef(key)]

    
    def __repr__(self):
        return "<WeakKeyIdentityDict at %s>" % id(self)

    
    def __setitem__(self, key, value):
        self.data[IdentityRef(key, self._remove)] = value

        
    def copy(self):
        """ D.copy() -> a shallow copy of D """
        new = WeakKeyIdentityDict()
        for key, value in self.data.items():
            o = key()
            if o is not None:
                new[o] = value
        return new

    
    def get(self, key, default=None):
        """ D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None. """
        return self.data.get(IdentityRef(key),default)

    
    def __contains__(self, key):
        try:
            wr = IdentityRef(key)
        except TypeError:
            return 0
        return wr in self.data


    has_key = __contains__
    
    
    def items(self):
        """ D.items() -> list of D's (key, value) pairs, as 2-tuples """
        L = []
        for key, value in self.data.items():
            o = key()
            if o is not None:
                L.append((o, value))
        return L

    
    def iteritems(self):
        """ D.iteritems() -> an iterator over the (key, value) items of D """
        for wr, value in self.data.iteritems():
            key = wr()
            if key is not None:
                yield key, value

                
    def iterkeyrefs(self):
        """Return an iterator that yields the weak references to the keys.

        The references are not guaranteed to be 'live' at the time
        they are used, so the result of calling the references needs
        to be checked before being used.  This can be used to avoid
        creating references that will cause the garbage collector to
        keep the keys around longer than needed.

        """
        return self.data.iterkeys()

    
    def iterkeys(self):
        """ D.iterkeys() -> an iterator over the keys of D """
        for wr in self.data.iterkeys():
            obj = wr()
            if obj is not None:
                yield obj

    def __iter__(self):
        return self.iterkeys()

    
    def itervalues(self):
        """ D.itervalues() -> an iterator over the values of D """
        return self.data.itervalues()

    
    def keyrefs(self):
        """Return a list of weak references to the keys.

        The references are not guaranteed to be 'live' at the time
        they are used, so the result of calling the references needs
        to be checked before being used.  This can be used to avoid
        creating references that will cause the garbage collector to
        keep the keys around longer than needed.

        """
        return self.data.keys()

    
    def keys(self):
        """ D.keys() -> list of D's keys """
        L = []
        for wr in self.data.keys():
            o = wr()
            if o is not None:
                L.append(o)
        return L

    
    def popitem(self):
        """ D.popitem() -> (k, v), remove and return some (key, value) pair 
        as a 2-tuple; but raise KeyError if D is empty """
        while True:
            key, value = self.data.popitem()
            o = key()
            if o is not None:
                return o, value

            
    def pop(self, key, *args):
        """ D.pop(k[,d]) -> v, remove specified key and return the
        corresponding value. If key is not found, d is returned if given,
        otherwise KeyError is raised """
        return self.data.pop(IdentityRef(key), *args)

    
    def setdefault(self, key, default=None):
        """D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D"""
        return self.data.setdefault(IdentityRef(key, self._remove),default)

    
    def update(self, dict=None, **kwargs):
        """ D.update(E, **F) -> None. Update D from E and F: for k in E: D[k] =
        E[k] (if E has keys else: for (k, v) in E: D[k] = v) then: for k in F:
        D[k] = F[k] """
        
        d = self.data
        if dict is not None:
            if not hasattr(dict, "items"):
                dict = type({})(dict)
            for key, value in dict.items():
                d[IdentityRef(key, self._remove)] = value
        if len(kwargs):
            self.update(kwargs)

########NEW FILE########
__FILENAME__ = package_finder
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines functions related to finding Python packages.

See documentation of get_packages for more info.

This module is hacky.
'''

import glob
import os
import types

from garlicsim.general_misc import dict_tools


_extensions_by_priority = ['.pyo', '.pyc', '.pyw', '.py']
'''List of possible extenstions of Python modules, ordered by priority.'''


def get_packages(root, include_self=False, recursive=False, self_in_name=True):
    '''
    Find all sub-packages.
    
    `root` may be a module, package, or a path.
    # todo: module? really?
    '''
    
    if isinstance(root, types.ModuleType):
        root_module = root
        root_path = os.path.dirname(root_module.__file__)
    else:
        assert isinstance(root, basestring)
        root_path = os.path.abspath(root)
        # Not making root_module, it might not be imported.
    
    root_module_name = os.path.split(root_path)[1]

    ######################################################
    
    result = []
    
    if include_self:
        result.append('')
        
    for entry in os.listdir(root_path):
        full_path = os.path.join(root_path, entry)
        if is_package(full_path):
            if recursive:
                result += ['.' + thing for thing in 
                           get_packages(full_path, include_self=True,
                                        recursive=True)]
            else:
                result.append('.' + entry)
    
    if self_in_name:
        return [(root_module_name + thing) for thing in result]
    else:
        return result
    

def get_packages_and_modules_filenames(root, recursive=False):
    '''
    Find the filenames of all of the packages and modules inside the package.
    
    `root` may be a module, package, or a path.
    todo: module? really?
    todo: needs testing
    '''
        
    if isinstance(root, types.ModuleType):
        root_module = root
        root_path = os.path.dirname(root_module.__file__)
    elif isinstance(root, str):
        root_path = os.path.abspath(root)
        # Not making `root_module`, it might not be imported.
    
    ######################################################
    
    result = []
        
    for entry in os.listdir(root_path):
        
        full_path = os.path.join(root_path, entry)
        
        if is_module(full_path):
            result.append(entry)
            continue
            
        elif is_package(full_path):
            result.append(entry)
            if recursive:
                inner_results = get_packages_and_modules_filenames(
                    full_path,
                    recursive=True
                )
                result += [os.path.join(entry, thing) for thing in
                           inner_results]
    
    ### Filtering out duplicate filenames for the same module: ################
    #                                                                         #
                
    filename_to_module_name = dict((
        (filename, os.path.splitext(filename)[0]) for filename in result
    ))
    module_name_to_filenames = \
        dict_tools.reverse_with_set_values(filename_to_module_name)
    
    for module_name, filenames in module_name_to_filenames.iteritems():
        if len(filenames) <= 1:
            # Does this save us from the case of packages?
            continue
        filenames_by_priority = sorted(
            filenames,
            key=lambda filename:
                _extensions_by_priority.index(os.path.splitext(filename)[1]),
        )
        redundant_filenames = filenames_by_priority[1:]
        for redundant_filename in redundant_filenames:
            result.remove(redundant_filename)
        
    #                                                                         #
    ### Done filtering duplicate filenames for the same module. ###############
    
    
    return [os.path.join(os.path.dirname(full_path), entry) for entry in
            result]


def is_package(path):
    '''Is the given path a Python package?'''
    return os.path.isdir(path) and \
           glob.glob(os.path.join(path, '__init__.*'))


def is_module(path):
    '''Is the given path a Python single-file module?'''
    extension = os.path.splitext(path)[1]
    return extension.lower() in ['.py', '.pyc', '.pyo', '.pyw']


########NEW FILE########
__FILENAME__ = path_tools
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Defines various tools related to file-system paths.'''

import sys
import os.path
import glob
import types


def list_sub_folders(path):
    '''List all the immediate sub-folders of the folder at `path`.'''
    assert os.path.isdir(path)
    files_and_folders = glob.glob(os.path.join(path, '*'))
    folders = filter(os.path.isdir, files_and_folders)
    return folders


def get_path_of_package(package):
    '''Get the path of a Python package, i.e. where its modules would be.'''
    path = package.__file__
    dir_path, file_name = os.path.split(path)
    assert '__init__' in file_name
    return dir_path


def get_root_path_of_module(module):
    '''
    Get the root path of a module.
    
    This is the path that should be in `sys.path` for the module to be
    importable. Note that this would give the same answer for
    `my_package.my_sub_package.my_module` as for `my_package`; it only cares
    about the root module.
    '''
    assert isinstance(module, types.ModuleType)
    module_name = module.__name__
    root_module_name = module_name.split('.', 1)[0]
    root_module = sys.modules[root_module_name]
    path_of_root_module = root_module.__file__
    dir_path, file_name = os.path.split(path_of_root_module)
    if '__init__' in file_name:
         # It's a package.
        result = os.path.normpath(os.path.join(dir_path, '..'))
    else:
        # It's a one-file module, not a package.
        result = dir_path
    
    assert result in map(os.path.abspath, sys.path) 
    return result


########NEW FILE########
__FILENAME__ = copy_modes
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `DontCopyPersistent` class.

See its documentation for more information.
'''

from garlicsim.general_misc.copy_mode import CopyMode

class DontCopyPersistent(CopyMode):
    '''
    A copy mode under which `Persistent` objects aren't actually copied.
    
    When a `Persistent` is getting deepcopied with this mode, a reference to
    the original object would be returned instead of actually deepcopying it.
    
    Keep in mind that if the `Persistent` holds reference to additional
    objects, they too will not really be copied under this mode.
    '''


########NEW FILE########
__FILENAME__ = cross_process_persistent
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `CrossProcessPersistent` class.

See its documentation for more information.



Note: This module is still experimental.

todo: need to lock library to avoid thread trouble?
'''

import uuid
import weakref

from garlicsim.general_misc import caching
from garlicsim.general_misc import copy_tools

from .copy_modes import DontCopyPersistent
from .persistent import Persistent
from .personality import Personality


library = weakref.WeakValueDictionary()


class UuidToken(object):
    '''Token which contains a uuid with its attribute `.uuid`'''
    def __init__(self, uuid):
        self.uuid = uuid

        
class CrossProcessPersistent(Persistent):
    '''
    Object that sometimes shouldn't really be duplicated.

    Say some plain object references a `CrossProcessPersistent` object. Then
    that plain object gets deepcopied with the `DontCopyPersistent` copy mode.
    The plain object will get deepcopied, but the `CrossProcessPersistent`
    object under it will not! The new copy of the plain object will refer to
    the same old copy of the `CrossProcessPersistent` object.
    
    This is useful for objects which are read-only and possibly heavy. You may
    use `CrossProcessPersistent` as a base class for these kinds of objects.
    
    Keep in mind that a `CrossProcessPersistent` is read-only. This means that
    starting from the first time that it is copied or put in a queue, it should
    not be changed.

    There is no mechanism that enforces that the user doesn't change the
    object, so the user must remember not to change it.
    
    What this class adds over `Persistent`, is that when a
    `CrossProcessPersistent` is passed around between processes in queues, each
    process retains only one copy of it.
    
    Note: This class is still experimental.
    '''
    
    _is_atomically_pickleable = True
    
    
    def __new__(cls, *args, **kwargs):
        
        # Here we need to check in what context `__new__` was called.
        # There are two options:
        #   1. The object is being created.
        #   2. The object is being unpickled.
        # We check whether we are getting a uuid token. If we are, it's
        # unpickling. If we don't, it's creation.
        
        if len(args) == 1 and (not kwargs) and isinstance(args[0], UuidToken):
            received_uuid = args[0].uuid
        else:
            received_uuid = None
            
        if received_uuid: # The object is being unpickled
            thing = library.get(received_uuid, None)
            if thing:
                thing._CrossProcessPersistent__skip_setstate = True
                return thing
            else: # This object does not exist in our library yet; let's add it
                thing = super(CrossProcessPersistent, cls).__new__(cls)
                thing._CrossProcessPersistent__uuid = received_uuid
                library[received_uuid] = thing
                return thing
                
        else: # The object is being created
            thing = super(CrossProcessPersistent, cls).__new__(cls)
            new_uuid = uuid.uuid4()
            thing._CrossProcessPersistent__uuid = new_uuid
            library[new_uuid] = thing
            return thing

        
    def has_same_uuid_as(self, other):
        '''Does `other` have the same uuid as us?'''
        if not isinstance(other, CrossProcessPersistent):
            return NotImplemented
        return self.__uuid == other.__uuid

    
    def __getstate__(self):
        my_dict = dict(self.__dict__)
        del my_dict['_CrossProcessPersistent__uuid']
        return my_dict

    
    def __getnewargs__(self):
        return (UuidToken(self._CrossProcessPersistent__uuid),)

    
    def __setstate__(self, state):
        if self.__dict__.pop('_CrossProcessPersistent__skip_setstate', None):
            return
        else:
            self.__dict__.update(state)

            
    def __reduce_ex__(self, protocol):
        if protocol < 2:
            raise Exception(
                "You're trying to pickle a `CrossProcessPersistent` object "
                "using protocol %s. You must use protocol 2 or "
                "upwards." % protocol
            )
        else:
            return object.__reduce_ex__(self, protocol)
            
        
    def __deepcopy__(self, memo):
        '''
        Deepcopy the object. If `DontCopyPersistent` is given, only mock-copy.
        
        When this method receieves an instance of `DontCopyPersistent` as a
        memo dictionary, it will not actually `deepcopy` the object but only
        return a reference to the original object.
        '''
        if isinstance(memo, DontCopyPersistent):
            memo[id(self)] = self
            return self
        else:
            new_copy = copy_tools.deepcopy_as_simple_object(self, memo)
            new_copy._Persistent__uuid = uuid.uuid4()
            try:
                del self.personality
            except AttributeError:
                pass
            return new_copy

        
    personality = caching.CachedProperty(
        Personality,
        doc='''Personality containing a human name and two colors.'''
    )




########NEW FILE########
__FILENAME__ = persistent
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `Persistent` class.

See its documentation for more information.



Note: This module is still experimental

todo: need to raise an exception if we're getting pickled with
an old protocol?

todo: make it polite to other similar classes. Perhaps make it a metaclass?
'''
from .copy_modes import DontCopyPersistent
from garlicsim.general_misc import copy_tools


__all__ = ['Persistent']


class Persistent(object):
    '''
    Object that sometimes shouldn't really be duplicated.

    Say some plain object references a `Persistent` object. Then that plain
    object gets deepcopied with the `DontCopyPersistent` copy mode. The plain
    object will get deepcopied, but the `Persistent` object under it will not!
    The new copy of the plain object will refer to the same old copy of the
    `Persistent` object.
    
    This is useful for objects which are read-only and possibly heavy. You may
    use `Persistent` as a base class for these kinds of objects.
    
    Keep in mind that a `Persistent` is read-only. This means that starting
    from the first time that it is copied or put in a queue, it should not be
    changed.

    There is no mechanism that enforces that the user doesn't change the
    object, so the user must remember not to change it.
    
    Note: This class is still experimental.
    '''    
    
    def __deepcopy__(self, memo):
        '''
        Deepcopy the object. If `DontCopyPersistent` is given, only mock-copy.
        
        When this method receieves an instance of `DontCopyPersistent` as a
        memo dictionary, it will not actually deepcopy the object but only
        return a reference to the original object.
        '''
        if isinstance(memo, DontCopyPersistent):
            memo[id(self)] = self
            return self
        else:
            new_copy = copy_tools.deepcopy_as_simple_object(self, memo)
            return new_copy
    
        
    def __copy__(self):
        return self
    
########NEW FILE########
__FILENAME__ = personality
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `Personality` class.

See its documentation for more information.
'''

import colorsys
from .persistent import Persistent


class Personality(object):
    '''
    A bunch of easy-to-remember attributes associated with a persistent object.
    
    These attributes include:
      * A human name
      * A light color
      * A dark color
    
    Each persistent object has a personality associated with it, generated
    automatically from its `uuid`. The personality makes it easy for humans to
    identify the persistent object.
    
    Colors are specified in RGB.
    '''
    
    def __init__(self, persistent):

        assert isinstance(persistent, Persistent)
        
        from . import human_names

        color_resolution = 100
        
        u = int(persistent._CrossProcessPersistent__uuid)
        
        (u, human_name_seed) = divmod(u, 5494)        
        self.human_name = human_names.name_list[human_name_seed]
        '''A human name. (e.g. "Jeffrey".)'''
        
        color_seeds = []
        for i in range(4):
            (u, new_color_seed) = divmod(u, color_resolution)
            color_seeds.append(new_color_seed)
        

        normalized_color_seeds = \
            [color_seed * (1.0/color_resolution) for color_seed in color_seeds]
        
        light_color_hls = \
            (normalized_color_seeds[0], 0.9, normalized_color_seeds[1])
        dark_color_hls = \
            (normalized_color_seeds[2], 0.3, normalized_color_seeds[3])
        
        self.light_color = colorsys.hls_to_rgb(*light_color_hls)
        '''A light color in RGB. (e.g. `(0.98, 0.86, 0.81)`.)'''
        
        self.dark_color = colorsys.hls_to_rgb(*dark_color_hls)
        '''A dark color in RGB. (e.g. `(0.58, 0.01, 0.35)`.)'''
        
                          
                        
                          

########NEW FILE########
__FILENAME__ = pickle_tools
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Defines various tools for pickling and unpickling.'''


import re
import cPickle as pickle_module
import pickle # Importing just to get dispatch table, not pickling with it.
import copy_reg
import types

from garlicsim.general_misc import address_tools
from garlicsim.general_misc import misc_tools


def is_atomically_pickleable(thing):
    '''
    Return whether `thing` is an atomically pickleable object.
    
    "Atomically-pickleable" means that it's pickleable without considering any
    other object that it contains or refers to. For example, a `list` is
    atomically pickleable, even if it contains an unpickleable object, like a
    `threading.Lock()`.
    
    However, the `threading.Lock()` itself is not atomically pickleable.
    '''
    my_type = misc_tools.get_actual_type(thing)
    return _is_type_atomically_pickleable(my_type, thing)


def _is_type_atomically_pickleable(type_, thing=None):
    '''Return whether `type_` is an atomically pickleable type.'''
    try:
        return _is_type_atomically_pickleable.cache[type_]
    except KeyError:
        pass
    
    if thing is not None:
        assert isinstance(thing, type_)
        
    # Sub-function in order to do caching without crowding the main algorithm:
    def get_result():
        
        # We allow a flag for types to painlessly declare whether they're
        # atomically pickleable:
        if hasattr(type_, '_is_atomically_pickleable'):
            return type_._is_atomically_pickleable
        
        # Weird special case: `threading.Lock` objects don't have `__class__`.
        # We assume that objects that don't have `__class__` can't be pickled.
        # (With the exception of old-style classes themselves.)
        if not hasattr(thing, '__class__') and \
           (not isinstance(thing, types.ClassType)):
            return False
        
        if not issubclass(type_, object):
            return True
        
        def assert_legit_pickling_exception(exception):
            '''Assert that `exception` reports a problem in pickling.'''
            message = exception.args[0]
            segments = [
                "can't pickle",
                'should only be shared between processes through inheritance',
                'cannot be passed between processes or pickled'
            ]
            assert any((segment in message) for segment in segments)
            # todo: turn to warning
        
        if type_ in pickle.Pickler.dispatch:
            return True
            
        reduce_function = copy_reg.dispatch_table.get(type_)
        if reduce_function:
            try:
                reduce_result = reduce_function(thing)
            except Exception, exception:
                assert_legit_pickling_exception(exception)
                return False
            else:
                return True
        
        reduce_function = getattr(type_, '__reduce_ex__', None)
        if reduce_function:
            try:
                reduce_result = reduce_function(thing, 0)
                # (The `0` is the protocol argument.)
            except Exception, exception:
                assert_legit_pickling_exception(exception)
                return False
            else:
                return True
            
        reduce_function = getattr(type_, '__reduce__', None)
        if reduce_function:
            try:
                reduce_result = reduce_function(thing)
            except Exception, exception:
                assert_legit_pickling_exception(exception)
                return False
            else:
                return True
        
        return False

    result = get_result()
    _is_type_atomically_pickleable.cache[type_] = result
    return result
    
_is_type_atomically_pickleable.cache = {}
 

class FilteredObject(object):
    '''Placeholder for an object that was filtered out when pickling.'''
    def __init__(self, about): 
        self.about = about 
    def __repr__(self): 
        return 'FilteredObject(%s)' % repr(self.about) 
    def __getattr__(self, key):
        return FilteredObject('%s.%s' % (self.about, key))
        

_filtered_string_pattern = re.compile(
    r'^Filtered by pickle_tools \((?P<description>.*?)\)$'
)
 
class CutePickler(object): 
    '''
    Pickler which filters out non-pickleable objects.
    
    When the pickler comes upon a non-pickleable object it replaces it with a
    marker which will cause it to become a `FilteredObject` upon unpickling.
    
    (Not subclassing `cPickle.Pickler` because it doesn't support subclassing.)
    '''
    def __init__(self, file_, protocol=0): 
        pickler = self.pickler = pickle_module.Pickler(file_, protocol) 
        pickler.persistent_id = self.persistent_id
        self.dump, self.clear_memo = \
            pickler.dump, pickler.clear_memo

        
    def persistent_id(self, obj):
        if self.pre_filter:
            passed_pre_filter = self.pre_filter(obj)
        else:
            passed_pre_filter = True
        
        if passed_pre_filter and is_atomically_pickleable(obj): 
            return None 
        else:
            return 'Filtered by pickle_tools (%s)' % \
                   address_tools.describe(obj)
        
    def pre_filter(self, thing):
        '''Pre-filter `thing`, returning `False` if it shouldn't be pickled.'''
        return True
 
    
class CuteUnpickler(object): 
    '''
    Unpickler which replaces non-pickleable objects with `FilteredObject`s.
    
    When the corresponding `CutePickler` came upon non-pickleable objects it
    replacef them with a markers which will cause `CuteUnpickler` to replace
    them with `FilteredObject` instances upon unpickling.
    
    (Not subclassing `cPickle.Unpickler` because it doesn't support
    subclassing.)
    '''
    def __init__(self, file_): 
        unpickler = self.unpickler = pickle_module.Unpickler(file_) 
        unpickler.persistent_load = self.persistent_load
        self.load = unpickler.load
        self.noload = getattr(unpickler, 'noload', None)
        # (Defaulting to `None` because `pickle.Unpickler` doesn't have
        # `noload`.)

    def persistent_load(self, id_string):
        match = _filtered_string_pattern.match(id_string)
        if match:
            description = match.groupdict()['description']            
            return FilteredObject(description) 
        else: 
            raise pickle_module.UnpicklingError('Invalid persistent id')
 
 
    
########NEW FILE########
__FILENAME__ = process_priority
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `set_process_priority` function.

See its documentation for more info.
'''

import win32process, win32con, win32api

def set_process_priority(priority, pid=None):
    '''
    Set the priority of a Windows process.
    
    Priority is a value between 0-5 where 2 is normal priority. Default sets
    the priority of the current Python process but can take any valid process
    ID.
    '''
    
    priorityclasses = [
        win32process.IDLE_PRIORITY_CLASS,
        win32process.BELOW_NORMAL_PRIORITY_CLASS,
        win32process.NORMAL_PRIORITY_CLASS,
        win32process.ABOVE_NORMAL_PRIORITY_CLASS,
        win32process.HIGH_PRIORITY_CLASS,
        win32process.REALTIME_PRIORITY_CLASS
    ]
    
    if pid is None:
        pid = win32api.GetCurrentProcessId()
    handle = win32api.OpenProcess(win32con.PROCESS_ALL_ACCESS, True, pid)
    win32process.SetPriorityClass(handle, priorityclasses[priority])
########NEW FILE########
__FILENAME__ = queue_tools
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Defines various functions for working with queues.'''

from __future__ import with_statement

import Queue as queue_module
import sys

from garlicsim.general_misc import caching
from garlicsim.general_misc import import_tools


def is_multiprocessing_queue(queue):
    '''Return whether `queue` is a multiprocessing queue.'''
    return queue.__module__.startswith('multiprocessing')


def dump(queue):
    '''
    Empty all pending items in a queue and return them in a list.
    
    Use only when no other processes/threads are reading from the queue.
    '''
    return list(iterate(queue))


def iterate(queue, block=False, limit_to_original_size=False,
            _prefetch_if_no_qsize=False):
    '''
    Iterate over the items in the queue.
    
    `limit_to_original_size=True` will limit the number of the items fetched to
    the original number of items in the queue in the beginning.
    '''
    if limit_to_original_size:
        
        if is_multiprocessing_queue(queue) and \
           not _platform_supports_multiprocessing_qsize():
            
            if _prefetch_if_no_qsize:
                for item in dump(queue):
                    yield item
                raise StopIteration
            raise NotImplementedError(
                "This platform doesn't support `qsize` for `multiprocessing` "
                "queues, so you can't iterate on it while limiting to "
                "original queue size. What you can do is set "
                "`_prefetch_if_no_qsize=True` to have the entire queue "
                "prefetched before yielding the items."
            )
        for i in xrange(queue.qsize()):
            try:
                yield queue.get(block=block)
            except queue_module.Empty:
                raise StopIteration
    else: # not limit_to_original_size
        while True:
            try:
                yield queue.get(block=block)
            except queue_module.Empty:
                raise StopIteration


def get_item(queue, i):
    '''
    Get an item from the queue by index number without removing any items.
    
    Note: This was designed for `Queue.Queue`. Don't try to use this, for
    example, on `multiprocessing.Queue`.
    '''
    with queue.mutex:
        return queue.queue[i]

    
def queue_as_list(queue):
    '''
    Get all the items in the queue as a `list` without removing them.
    
    Note: This was designed for `Queue.Queue`. Don't try to use this, for
    example, on `multiprocessing.Queue`.
    '''
    with queue.mutex:
        return list(queue.queue)
    

@caching.cache()
def _platform_supports_multiprocessing_qsize():
    '''
    Return whether this platform supports `multiprocessing.Queue().qsize()`.
    
    I'm looking at you, Mac OS.
    '''
    if 'multiprocessing' not in sys.modules:
        if not import_tools.exists('multiprocessing'):
            return False
    import multiprocessing
    multiprocessing_queue = multiprocessing.Queue()
    try:
        multiprocessing_queue.qsize()
    except NotImplementedError:
        return False
    else:
        return True
########NEW FILE########
__FILENAME__ = random_tools
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Defines various tools for creating randomness.'''

import random


def random_partition(sequence, partition_size, allow_reminder=False):
    '''
    Randomly partition `sequence` into partitions of size `partition_size`.
    
    Example:
    
        >>> random_partition([0, 1, 2, 3, 4, 5], 2)
        [(0, 2), (1, 4), (3, 5)]
    
    '''
    if allow_reminder:
        raise NotImplementedError
    if len(sequence) % partition_size != 0:
        raise Exception("You set `allow_reminder=False`, but there's a "
                        "reminder of %s left." % \
                        (len(sequence) % partition_size))
    
    shuffled_sequence = shuffled(sequence)

    subsequences = [shuffled_sequence[i::partition_size] for i in
                    xrange(partition_size)]
    
    return zip(*subsequences)


def shuffled(sequence):
    '''
    Return a list with all the items from `sequence` shuffled.
    
    Example:
    
        >>> random_tools.shuffled([0, 1, 2, 3, 4, 5])
        [0, 3, 5, 1, 4, 2]
        
    '''
    sequence_copy = sequence[:]
    random.shuffle(sequence_copy)
    return sequence_copy
########NEW FILE########
__FILENAME__ = original_read_write_lock
# -*- coding: iso-8859-15 -*-
'''locks.py - Read-Write lock thread lock implementation

See the class documentation for more info.

Copyright (C) 2007, Heiko Wundram.
Released under the BSD-license.
'''

# Imports
# -------

from threading import Condition, Lock, currentThread
from time import time


# Read write lock
# ---------------

class ReadWriteLock(object):
    '''Read-Write lock class. A read-write lock differs from a standard
    threading.RLock() by allowing multiple threads to simultaneously hold a
    read lock, while allowing only a single thread to hold a write lock at the
    same point of time.

    When a read lock is requested while a write lock is held, the reader
    is blocked; when a write lock is requested while another write lock is
    held or there are read locks, the writer is blocked.

    Writers are always preferred by this implementation: if there are blocked
    threads waiting for a write lock, current readers may request more read
    locks (which they eventually should free, as they starve the waiting
    writers otherwise), but a new thread requesting a read lock will not
    be granted one, and block. This might mean starvation for readers if
    two writer threads interweave their calls to acquireWrite() without
    leaving a window only for readers.

    In case a current reader requests a write lock, this can and will be
    satisfied without giving up the read locks first, but, only one thread
    may perform this kind of lock upgrade, as a deadlock would otherwise
    occur. After the write lock has been granted, the thread will hold a
    full write lock, and not be downgraded after the upgrading call to
    acquireWrite() has been match by a corresponding release().
    '''

    def __init__(self):
        '''Initialize this read-write lock.'''

        # Condition variable, used to signal waiters of a change in object
        # state.
        self.__condition = Condition(Lock())

        # Initialize with no writers.
        self.__writer = None
        self.__upgradewritercount = 0
        self.__pendingwriters = []

        # Initialize with no readers.
        self.__readers = {}

    def acquireRead(self,timeout=None):
        '''Acquire a read lock for the current thread, waiting at most
        timeout seconds or doing a non-blocking check in case timeout is <= 0.

        In case timeout is None, the call to acquireRead blocks until the
        lock request can be serviced.

        In case the timeout expires before the lock could be serviced, a
        RuntimeError is thrown.'''

        if timeout is not None:
            endtime = time() + timeout
        me = currentThread()
        self.__condition.acquire()
        try:
            if self.__writer is me:
                # If we are the writer, grant a new read lock, always.
                self.__writercount += 1
                return
            while True:
                if self.__writer is None:
                    # Only test anything if there is no current writer.
                    if self.__upgradewritercount or self.__pendingwriters:
                        if me in self.__readers:
                            # Only grant a read lock if we already have one
                            # in case writers are waiting for their turn.
                            # This means that writers can't easily get starved
                            # (but see below, readers can).
                            self.__readers[me] += 1
                            return
                        # No, we aren't a reader (yet), wait for our turn.
                    else:
                        # Grant a new read lock, always, in case there are
                        # no pending writers (and no writer).
                        self.__readers[me] = self.__readers.get(me,0) + 1
                        return
                if timeout is not None:
                    remaining = endtime - time()
                    if remaining <= 0:
                        # Timeout has expired, signal caller of this.
                        raise RuntimeError("Acquiring read lock timed out")
                    self.__condition.wait(remaining)
                else:
                    self.__condition.wait()
        finally:
            self.__condition.release()

    def acquireWrite(self,timeout=None):
        '''Acquire a write lock for the current thread, waiting at most
        timeout seconds or doing a non-blocking check in case timeout is <= 0.

        In case the write lock cannot be serviced due to the deadlock
        condition mentioned above, a ValueError is raised.

        In case timeout is None, the call to acquireWrite blocks until the
        lock request can be serviced.

        In case the timeout expires before the lock could be serviced, a
        RuntimeError is thrown.'''

        if timeout is not None:
            endtime = time() + timeout
        me, upgradewriter = currentThread(), False
        self.__condition.acquire()
        try:
            if self.__writer is me:
                # If we are the writer, grant a new write lock, always.
                self.__writercount += 1
                return
            elif me in self.__readers:
                # If we are a reader, no need to add us to pendingwriters,
                # we get the upgradewriter slot.
                if self.__upgradewritercount:
                    # If we are a reader and want to upgrade, and someone
                    # else also wants to upgrade, there is no way we can do
                    # this except if one of us releases all his read locks.
                    # Signal this to user.
                    raise ValueError(
                        "Inevitable dead lock, denying write lock"
                        )
                upgradewriter = True
                self.__upgradewritercount = self.__readers.pop(me)
            else:
                # We aren't a reader, so add us to the pending writers queue
                # for synchronization with the readers.
                self.__pendingwriters.append(me)
            while True:
                if not self.__readers and self.__writer is None:
                    # Only test anything if there are no readers and writers.
                    if self.__upgradewritercount:
                        if upgradewriter:
                            # There is a writer to upgrade, and it's us. Take
                            # the write lock.
                            self.__writer = me
                            self.__writercount = self.__upgradewritercount + 1
                            self.__upgradewritercount = 0
                            return
                        # There is a writer to upgrade, but it's not us.
                        # Always leave the upgrade writer the advance slot,
                        # because he presumes he'll get a write lock directly
                        # from a previously held read lock.
                    elif self.__pendingwriters[0] is me:
                        # If there are no readers and writers, it's always
                        # fine for us to take the writer slot, removing us
                        # from the pending writers queue.
                        # This might mean starvation for readers, though.
                        self.__writer = me
                        self.__writercount = 1
                        self.__pendingwriters = self.__pendingwriters[1:]
                        return
                if timeout is not None:
                    remaining = endtime - time()
                    if remaining <= 0:
                        # Timeout has expired, signal caller of this.
                        if upgradewriter:
                            # Put us back on the reader queue. No need to
                            # signal anyone of this change, because no other
                            # writer could've taken our spot before we got
                            # here (because of remaining readers), as the test
                            # for proper conditions is at the start of the
                            # loop, not at the end.
                            self.__readers[me] = self.__upgradewritercount
                            self.__upgradewritercount = 0
                        else:
                            # We were a simple pending writer, just remove us
                            # from the FIFO list.
                            self.__pendingwriters.remove(me)
                        raise RuntimeError("Acquiring write lock timed out")
                    self.__condition.wait(remaining)
                else:
                    self.__condition.wait()
        finally:
            self.__condition.release()

    def release(self):
        '''Release the currently held lock.

        In case the current thread holds no lock, a ValueError is thrown.'''

        me = currentThread()
        self.__condition.acquire()
        try:
            if self.__writer is me:
                # We are the writer, take one nesting depth away.
                self.__writercount -= 1
                if not self.__writercount:
                    # No more write locks; take our writer position away and
                    # notify waiters of the new circumstances.
                    self.__writer = None
                    self.__condition.notifyAll()
            elif me in self.__readers:
                # We are a reader currently, take one nesting depth away.
                self.__readers[me] -= 1
                if not self.__readers[me]:
                    # No more read locks, take our reader position away.
                    del self.__readers[me]
                    if not self.__readers:
                        # No more readers, notify waiters of the new
                        # circumstances.
                        self.__condition.notifyAll()
            else:
                raise ValueError("Trying to release unheld lock")
        finally:
            self.__condition.release()

########NEW FILE########
__FILENAME__ = read_write_lock
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
See documentation of class `ReadWriteLock` defined in this module.
'''
# todo: organize.

from . import original_read_write_lock


__all__ = ['ReadWriteLock']


class ContextManager(object):
    def __init__(self, lock, acquire_func):
        self.lock = lock
        self.acquire_func = acquire_func
    def __enter__(self, *args, **kwargs):
        self.acquire_func()
    def __exit__(self, *args, **kwargs):
        self.lock.release()

        
class ReadWriteLock(original_read_write_lock.ReadWriteLock):
    '''
    A ReadWriteLock subclassed from a different ReadWriteLock class defined
    in the module original_read_write_lock.py, (See the documentation of the
    original class for more details.)
    
    This subclass adds two context managers, one for reading and one for
    writing.
    
    Usage:
    
    lock = ReadWriteLock()
    with lock.read:
        pass #perform read operations here
    with lock.write:
        pass #perform write operations here
    '''
    # todo: rename from acquireRead style to acquire_read style
    def __init__(self, *args, **kwargs):
        original_read_write_lock.ReadWriteLock.__init__(self, *args, **kwargs)
        self.read = ContextManager(self, self.acquireRead)
        self.write = ContextManager(self, self.acquireWrite)
########NEW FILE########
__FILENAME__ = reasoned_bool
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `ReasonedBool` class.

See its documentation for more details.
'''


class ReasonedBool(object):
    '''
    A variation on `bool` that also gives a `.reason`.
    
    This is useful when you want to say "This is False because... (reason.)"
    
    Unfortunately this class is not a subclass of `bool`, since Python doesn't
    allow subclassing `bool`.    
    '''

    def __init__(self, value, reason=None):
        '''
        Construct the `ReasonedBool`.
        
        `reason` is the reason *why* it has a value of `True` or `False`. It is
        usually a string, but is allowed to be of any type.
        '''
        self.value = bool(value)
        self.reason = reason
        
        
    def __repr__(self):
        if self.reason is not None:
            return '<%s because %s>' % (self.value, repr(self.reason))
        else: # self.reason is None
            return '<%s with no reason>' % self.value

        
    def __eq__(self, other):
        return bool(self) == other
    
    
    def __neq__(self, other):
        return not self.__eq__(other)

    
    def __bool__(self):
        return self.value
    __nonzero__ = __bool__
########NEW FILE########
__FILENAME__ = re_tools
# Copyright 2009-2010 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Defines miscellaneous tools.'''

import re


def searchall(pattern, string, flags=0):
    '''
    Return all the substrings of `string` that match `pattern`.
    
    Note: Currently returns only non-overlapping matches.
    '''
    if isinstance(pattern, basestring):
        pattern = re.compile(pattern, flags=flags)
    matches = []
    start = 0
    end = len(string)
    
    while True:
        match = pattern.search(string, start, end)
        if match:
            matches.append(match)
            start = match.end()
        else:
            break
    
    return matches
        
########NEW FILE########
__FILENAME__ = sequence_tools
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Defines various tools for manipulating sequences.'''

import itertools

from garlicsim.general_misc.nifty_collections import Counter

        
def are_equal_regardless_of_order(seq1, seq2):
    '''
    Return whether the two sequences are equal in the elements they contain,
    regardless of the order of the elements.
    
    Currently will fail for items that have problems with comparing.
    '''
    return Counter(seq1) == Counter(seq2)
        

def flatten(iterable):
    '''
    Flatten a sequence, returning a sequence of all its items' items.
    
    For example, `flatten([[1, 2], [3], [4, 'meow']]) == [1, 2, 3, 4, 'meow']`.
    '''
    
    iterator = iter(iterable)
    try:
        first_item = iterator.next()
    except StopIteration:
        return []
    return sum(iterator, first_item)


def combinations(sequence, n=None, start=0):
    '''
    Iterate over combinations of items from the sequence.

    `n` specifies the number of items. (Use `None` for all possible sizes
    together.) `start` specifies the index number of the member from which to
    start giving combinations. (Keep the default of `start=0` for doing the
    whole sequence.)
    
    Example:
    
    `combinations([1, 2, 3, 4], n=2)` would be, in list form: `[[1, 2], [1, 3],
    [1, 4], [2, 3], [2, 4], [3, 4]]`.
    '''
    
    if n is None:
        length = len(sequence) - start
        iterators = (combinations(sequence, n=i, start=start) for i
                     in xrange(1, length + 1))
        for item in itertools.chain(*iterators):
            yield item
        
    elif n == 1:
        for thing in itertools.islice(sequence, start, None):
            yield [thing]
    else:
        assert n > 1
        for (i, thing) in itertools.islice(enumerate(sequence), start, None):
            for sub_result in combinations(sequence, n - 1, start=(i + 1)):
                yield [thing] + sub_result


### Not using now, might want in future:

#def is_sequence(thing):
    #return hasattr(thing, '__len__') and hasattr(thing, '__getitem__') and\
    #hasattr(thing, '__iter__') and 
    #pass

#def heads(sequence, include_empty=False, include_full=True):    
    #for i in range(0 if include_empty else 1, len(sequence)):
        #yield sequence[:i]
    #if include_full:
        #yield sequence[:]
########NEW FILE########
__FILENAME__ = cute_sleek_value_dict
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `CuteSleekValueDict` class.

See its documentation for more details.
'''

import weakref
import UserDict

from .sleek_ref import SleekRef
from .exceptions import SleekRefDied


__all__ = ['CuteSleekValueDict']


class CuteSleekValueDict(UserDict.UserDict, object):
    """
    A dictionary which sleekrefs its values and propagates their callback.
    
    When a value is garbage-collected, it (1) removes itself from this dict and
    (2) calls the dict's own `callback` function.
    
    This class is like `weakref.WeakValueDictionary`, except (a) it uses
    sleekrefs instead of weakrefs and (b) when a value dies, it calls a
    callback.
    
    See documentation of `garlicsim.general_misc.sleek_refs.SleekRef` for more
    details about sleekreffing.
    """
    
    def __init__(self, callback, *args, **kwargs):
        self.callback = callback
        def remove(sleek_ref, weak_ref_to_csvd=weakref.ref(self)):
            csvd = weak_ref_to_csvd()
            if csvd is not None:
                del csvd.data[sleek_ref.key]
                csvd.callback()
        self._remove = remove
        UserDict.UserDict.__init__(self, *args, **kwargs)

        
    def __getitem__(self, key):
        try:            
            return self.data[key]()
        except (KeyError, SleekRefDied):
            missing_method = getattr(type(self), '__missing__', None)
            if missing_method:
                return missing_method(self, key)
            else:
                raise KeyError(key)
            
        
    def __contains__(self, key):
        try:
            self.data[key]()
        except (KeyError, SleekRefDied):
            return False
        else:
            return True

    
    def __eq__(self, other):
        if len(self) != len(other):
            return False
        for key, value in self.iteritems():
            if other[key] != value:
                return False
        return True
            
    
    has_key = __contains__

    
    def __repr__(self):
        return 'CuteSleekValueDict(%s, %s)' % (
            self.callback,
            dict(self)
        )

    
    def __setitem__(self, key, value):
        self.data[key] = KeyedSleekRef(value, self._remove, key)

        
    def copy(self):
        '''Shallow copy the `CuteSleekValueDict`.'''
        new_csvd = type(self)(self.callback)
        new_csvd.update(self)
        return new_csvd
        
    
    __copy__ = copy
        

    def get(self, key, default=None):
        """ D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None. """
        try:
            return self.data[key]()
        except (KeyError, SleekRefDied):
            return default

            
    def items(self):
        """ D.items() -> list of D's (key, value) pairs, as 2-tuples """
        my_items = []
        for key, sleek_ref in self.data.items():
            try:
                thing = sleek_ref()
            except SleekRefDied:
                pass
            else:
                my_items.append((key, thing))
        return my_items

    
    def iteritems(self):
        """ D.iteritems() -> an iterator over the (key, value) items of D """
        for key, sleek_ref in self.data.iteritems():
            try:
                thing = sleek_ref()
            except SleekRefDied:
                pass
            else:
                yield key, thing

                
    def iterkeys(self):
        """ D.iterkeys() -> an iterator over the keys of D """
        return self.data.iterkeys()

    
    def __iter__(self):
        return self.data.iterkeys()

    
    def itervaluerefs(self):
        """Return an iterator that yields the weak references to the values.

        The references are not guaranteed to be 'live' at the time
        they are used, so the result of calling the references needs
        to be checked before being used.  This can be used to avoid
        creating references that will cause the garbage collector to
        keep the values around longer than needed.

        """
        return self.data.itervalues()

    
    def itervalues(self):
        """ D.itervalues() -> an iterator over the values of D """
        for sleek_ref in self.data.itervalues():
            try:
                yield sleek_ref()
            except SleekRefDied:
                pass

                
    def popitem(self):
        """ D.popitem() -> (k, v), remove and return some (key, value) pair 
        as a 2-tuple; but raise KeyError if D is empty """
        while True:
            key, sleek_ref = self.data.popitem()
            try:
                return key, sleek_ref()
            except SleekRefDied:
                pass

            
    def pop(self, key, *args):
        """ D.pop(k[,d]) -> v, remove specified key and return the 
        corresponding value. If key is not found, d is returned if given,
        otherwise KeyError is raised """
        try:
            return self.data.pop(key)()
        except (KeyError, SleekRefDied):
            if args:
                (default,) = args
                return default
            raise KeyError(key)
        
        
    def setdefault(self, key, default=None):
        """D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D"""
        try:
            return self[key]
        except KeyError:
            self[key] = default
            return default

        
    def update(self, *other_dicts, **kwargs):
        """D.update(E, **F) -> None. Update D from E and F: for k in E: D[k] =
        E[k] (if E has keys else: for (k, v) in E: D[k] = v) then: for k in F:
        D[k] = F[k] """
        if other_dicts:
            (other_dict,) = other_dicts        
            if not hasattr(other_dict, 'items'):
                other_dict = dict(other_dict)
            for key, value in other_dict.items():
                self[key] = value
                
        if kwargs:
            self.update(kwargs)

            
    def valuerefs(self):
        """Return a list of weak references to the values.

        The references are not guaranteed to be 'live' at the time
        they are used, so the result of calling the references needs
        to be checked before being used.  This can be used to avoid
        creating references that will cause the garbage collector to
        keep the values around longer than needed.

        """
        return self.data.values()

    
    def values(self):
        """ D.values() -> list of D's values """
        my_values = []
        for sleek_ref in self.data.values():
            try:
                my_values.append(sleek_ref())
            except SleekRefDied:
                pass
        return my_values
    
    
    @classmethod
    def fromkeys(cls, iterable, value=None, callback=(lambda: None)):
        """ dict.fromkeys(S[,v]) -> New csvdict with keys from S and values
        equal to v. v defaults to None. """
        new_csvd = cls(callback)
        for key in iterable:
            new_csvd[key] = value
        return new_csvd


class KeyedSleekRef(SleekRef):
    """Sleekref whose weakref (if one exists) holds reference to a key."""

    def __new__(cls, thing, callback, key):
        self = SleekRef.__new__(cls)
        return self

    
    def __init__(self, thing, callback, key):
        super(KeyedSleekRef, self).__init__(thing, callback)
        if self.ref:
            self.ref.key = key


########NEW FILE########
__FILENAME__ = exceptions
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Defines exceptions.'''

from garlicsim.general_misc.exceptions import CuteException


class SleekRefDied(CuteException):
    '''You tried to access a sleekref's value but it's already dead.'''
########NEW FILE########
__FILENAME__ = sleek_call_args
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `SleekCallArgs` class.

See its documentation for more details.
'''

from garlicsim.general_misc import cute_inspect
from garlicsim.general_misc import cheat_hashing

from .sleek_ref import SleekRef
from .cute_sleek_value_dict import CuteSleekValueDict


__all__ = ['SleekCallArgs']

    
class SleekCallArgs(object):
    '''
    A bunch of call args with a sleekref to them.
    
    "Call args" is a mapping of which function arguments get which values.
    For example, for a function:
    
        def f(a, b=2):
            pass
            
    The calls `f(1)`, `f(1, 2)` and `f(b=2, a=1)` all share the same call args.
    
    All the argument values are sleekreffed to avoid memory leaks. (See
    documentation of `garlicsim.general_misc.sleek_refs.SleekRef` for more
    details.)
    '''
    # What if we one of the args gets gc'ed before this SCA gets added to the
    # dictionary? It will render this SCA invalid, but we'll still be in the
    # dict. So make note to user: Always keep reference to args and kwargs
    # until the SCA gets added to the dict.
    def __init__(self, containing_dict, function, *args, **kwargs):
        '''
        Construct the `SleekCallArgs`.
        
        `containing_dict` is the `dict` we'll try to remove ourselves from when
        one of our sleekrefs dies. `function` is the function for which we
        calculate call args from `*args` and `**kwargs`.
        '''
        
        self.containing_dict = containing_dict
        '''
        `dict` we'll try to remove ourselves from when 1 of our sleekrefs dies.
        '''
        
        args_spec = cute_inspect.getargspec(function)
        star_args_name, star_kwargs_name = \
                      args_spec.varargs, args_spec.keywords
        
        call_args = cute_inspect.getcallargs(function, *args, **kwargs)
        del args, kwargs
        
        self.star_args_refs = []
        '''Sleekrefs to star-args.'''
        
        if star_args_name:
            star_args = call_args.pop(star_args_name, None)
            if star_args:
                self.star_args_refs = [SleekRef(star_arg, self.destroy) for
                                       star_arg in star_args]
        
        self.star_kwargs_refs = {}
        '''Sleerefs to star-kwargs.'''
        if star_kwargs_name:            
            star_kwargs = call_args.pop(star_kwargs_name, {})
            if star_kwargs:
                self.star_kwargs_refs = CuteSleekValueDict(self.destroy,
                                                           star_kwargs)
        
        self.args_refs = CuteSleekValueDict(self.destroy, call_args)
        '''Mapping from argument name to value, sleek-style.'''
        
        # In the future the `.args`, `.star_args` and `.star_kwargs` attributes
        # may change, so we must record the hash now:
        self._hash = cheat_hashing.cheat_hash(
            (
                self.args,
                self.star_args,
                self.star_kwargs
            )
        )
        
        
    
    args = property(lambda self: dict(self.args_refs))
    '''The arguments.'''
    
    star_args = property(
        lambda self:
            tuple((star_arg_ref() for star_arg_ref in self.star_args_refs))
    )
    '''Extraneous arguments. (i.e. `*args`.)'''
    
    star_kwargs = property(lambda self: dict(self.star_kwargs_refs))
    '''Extraneous keyword arguments. (i.e. `*kwargs`.)'''
    
        
    def destroy(self, _=None):
        '''Delete ourselves from our containing `dict`.'''
        if self.containing_dict:
            try:
                del self.containing_dict[self]
            except KeyError:
                pass
        
    
    def __hash__(self):
        return self._hash

    
    def __eq__(self, other):
        if not isinstance(other, SleekCallArgs):
            return NotImplemented
        return self.args == other.args and \
               self.star_args == other.star_args and \
               self.star_kwargs == other.star_kwargs
    
    
########NEW FILE########
__FILENAME__ = sleek_ref
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `SleekRef` class.

See its documentation for more info.
'''

import weakref
import UserDict

from garlicsim.general_misc import cute_inspect

from .exceptions import SleekRefDied


__all__ = ['SleekRef']


class Ref(weakref.ref):
    '''
    A weakref.
    
    What this adds over `weakref.ref` is the ability to add custom attributes.
    '''


class SleekRef(object):
    '''
    Sleekref tries to reference an object weakly but if can't does it strongly.
    
    The problem with weakrefs is that some objects can't be weakreffed, for
    example `list` and `dict` objects. A sleekref tries to create a weakref to
    an object, but if it can't (like for a `list`) it creates a strong one
    instead.
    
    Thanks to sleekreffing you can avoid memory leaks when manipulating
    weakreffable object, but if you ever want to use non-weakreffable objects
    you are still able to. (Assuming you don't mind the memory leaks or stop
    them some other way.)
    
    When you call a dead sleekref, it doesn't return `None` like weakref; it
    raises `SleekRefDied`. Therefore, unlike weakref, you can store `None` in a
    sleekref.
    '''
    def __init__(self, thing, callback=None):
        '''
        Construct the sleekref.
        
        `thing` is the object we want to sleekref. `callback` is the callable
        to call when the weakref to the object dies. (Only relevant for
        weakreffable objects.)
        '''
        self.callback = callback
        if callback and not callable(callback):
            raise TypeError('%s is not a callable object.' % callback)
        
        self.is_none = (thing is None)
        '''Flag saying whether `thing` is `None`.'''
        
        if self.is_none:
            self.ref = self.thing = None
            
        else: # not self.is_none (i.e. thing is not None)
            try:
                self.ref = Ref(thing, callback)
                '''The weak reference to the object. (Or `None`.)'''
            except TypeError:
                self.ref = None
                self.thing = thing
                '''The object, if non-weakreffable.'''
            else:
                self.thing = None
                
            
    def __call__(self):
        '''
        Obtain the sleekreffed object. Raises `SleekRefDied` if reference died.
        '''
        if self.ref:
            result = self.ref()
            if result is None:
                raise SleekRefDied
            else:
                return result
        elif self.thing is not None:
            return self.thing
        else:
            assert self.is_none
            return None
########NEW FILE########
__FILENAME__ = string_tools
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''This module defines string-related tools.'''

import sys
import re


def camelcase_to_underscore(s):
    '''
    Convert a string from camelcase to underscore.
    
    Example: camelcase_to_underscore('HelloWorld') == 'hello_world'
    '''
    return re.sub('(((?<=[a-z])[A-Z])|([A-Z](?![A-Z]|$)))', '_\\1', s).\
           lower().strip('_')


def camelcase_to_spacecase(s):
    '''
    Convert a string from camelcase to spacecase.
    
    Example: camelcase_to_underscore('HelloWorld') == 'Hello world'
    '''
    if s == '': return s
    character_process = lambda c: (' ' + c.lower()) if c.isupper() else c
    return s[0] + ''.join(character_process(c) for c in s[1:])


def docstring_trim(docstring):
    '''Trim a docstring, removing redundant tabs.'''
    if not docstring:
        return ''
    # Convert tabs to spaces (following the normal Python rules)
    # and split into a list of lines:
    lines = docstring.expandtabs().splitlines()
    # Determine minimum indentation (first line doesn't count):
    indent = sys.maxint
    for line in lines[1:]:
        stripped = line.lstrip()
        if stripped:
            indent = min(indent, len(line) - len(stripped))
    # Remove indentation (first line is special):
    trimmed = [lines[0].strip()]
    if indent < sys.maxint:
        for line in lines[1:]:
            trimmed.append(line[indent:].rstrip())
    # Strip off trailing and leading blank lines:
    while trimmed and not trimmed[-1]:
        trimmed.pop()
    while trimmed and not trimmed[0]:
        trimmed.pop(0)
        
    return '\n'.join(trimmed)
    
########NEW FILE########
__FILENAME__ = sys_tools
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Defines various `sys`-related tools.'''


from __future__ import with_statement

import os
import sys
import cStringIO
import subprocess

from garlicsim.general_misc.context_manager import (ContextManager,
                                                    BlankContextManager)
from garlicsim.general_misc.temp_value_setters import TempValueSetter


class OutputCapturer(ContextManager):
    '''
    Context manager for catching all system output generated during suite.

    Example:
    
        with OutputCapturer() as output_capturer:
            print('woo!')
            
        assert output_capturer.output == 'woo!\n'
        
    The boolean arguments `stdout` and `stderr` determine, respectively,
    whether the standard-output and the standard-error streams will be
    captured.
    '''
    def __init__(self, stdout=True, stderr=True):
        self.string_io = cStringIO.StringIO()
        
        if stdout:
            self._stdout_temp_setter = \
                TempValueSetter((sys, 'stdout'), self.string_io)
        else: # not stdout
            self._stdout_temp_setter = BlankContextManager()
            
        if stderr:
            self._stderr_temp_setter = \
                TempValueSetter((sys, 'stderr'), self.string_io)
        else: # not stderr
            self._stderr_temp_setter = BlankContextManager()
        
    def manage_context(self):
        '''Manage the `OutputCapturer`'s context.'''
        with self._stdout_temp_setter:
            with self._stderr_temp_setter:
                yield self
        
    output = property(lambda self: self.string_io.getvalue(),
                      doc='''The string of output that was captured.''')

        
class TempSysPathAdder(ContextManager):
    '''
    Context manager for temporarily adding paths to `sys.path`.
    
    Removes the path(s) after suite.
    
    Example:
    
        with TempSysPathAdder('path/to/fubar/package'):
            import fubar
            fubar.do_stuff()
            
    '''
    def __init__(self, addition):
        '''
        Construct the `TempSysPathAdder`.
        
        `addition` may be a path or a sequence of paths.
        '''
        if isinstance(addition, basestring):
            addition = [addition]
        for entry in addition:
            assert isinstance(entry, basestring)
        self.addition = addition

        
    def __enter__(self):
        self.entries_not_in_sys_path = [entry for entry in self.addition if
                                        entry not in sys.path]
        sys.path += self.entries_not_in_sys_path
        return self
    

    def __exit__(self, *args, **kwargs):
        
        for entry in self.entries_not_in_sys_path:
            
            # We don't allow anyone to remove it except for us:
            assert entry in sys.path 
            
            sys.path.remove(entry)

            
frozen = getattr(sys, 'frozen', None)
'''
The "frozen string", if we are frozen, otherwise `None`.

This is useful for checking if we are frozen, e.g. with py2exe.
'''


# May want in future:
#def execute(command):
    #with OutputCapturer() as output_capturer:
        #subprocess.Popen(command, shell=True)
    #return output_capturer.output
    
########NEW FILE########
__FILENAME__ = temp_file_tools
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Defines various tools related to temporary files.'''

from __future__ import with_statement

import tempfile
import shutil

from garlicsim.general_misc.context_manager import ContextManager



class TemporaryFolder(ContextManager):
    '''
    Context manager that creates a temporary folder and deletes it after usage.
    
    After the suite finishes, the temporary folder and all its files and
    subfolders will be deleted.
    
    Example:
    
        with TemporaryFolder() as temporary_folder_path:
            
            # We have a temporary folder!
            assert os.path.isdir(temporary_folder_path)
            
            # We can create files in it:
            open(os.path.join(temporary_folder_path, 'my_file'), 'w')
            
        # The suite is finished, now it's all cleaned:
        assert not os.path.exists(temporary_folder_path)
       
    Use the `suffix` and `prefix` string arguments to dictate a suffix and/or a
    prefix to the temporary folder's name in the filesystem.        
    '''

    def __init__(self, suffix='', prefix=tempfile.template):
        self.suffix = suffix
        self.prefix = prefix
        self.path = None
        self._closed = False

        
    def __enter__(self):
        assert not self._closed
        self.path = tempfile.mkdtemp(suffix=self.suffix, prefix=self.prefix)
        return self.path

    
    def __exit__(self, type_, value, traceback):
        assert not self._closed
        shutil.rmtree(self.path)
        self._closed = True
        
    
    def __str__(self):        
        return self.path or ''

########NEW FILE########
__FILENAME__ = temp_recursion_limit_setter
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `TempRecursionLimitSetter` class.

See its documentation for more details.
'''

import sys

from .temp_value_setter import TempValueSetter


class TempRecursionLimitSetter(TempValueSetter):
    '''
    Context manager for temporarily changing the recurstion limit.
    
    The temporary recursion limit comes into effect before the suite starts,
    and the original recursion limit returns after the suite finishes.
    '''
    
    def __init__(self, recursion_limit):
        '''
        Construct the `TempRecursionLimitSetter`.
        
        `recursion_limit` is the temporary recursion limit to use.
        '''
        assert isinstance(recursion_limit, int)
        TempValueSetter.__init__(
            self,
            (sys.getrecursionlimit, sys.setrecursionlimit),
            value=recursion_limit
        )
########NEW FILE########
__FILENAME__ = temp_value_setter
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `TempValueSetter` class.

See its documentation for more details.
'''

from garlicsim.general_misc import address_tools
from garlicsim.general_misc.context_manager import ContextManager


__all__ = ['TempValueSetter']


class NotInDict(object):
    '''Object signifying that the key was not found in the dict.'''
    # todo: make uninstanciable


class TempValueSetter(ContextManager):
    '''
    Context manager for temporarily setting a value to a variable.
    
    The value is set to the variable before the suite starts, and gets reset
    back to the old value after the suite finishes.
    '''
    
    def __init__(self, variable, value):
        '''
        Construct the `TempValueSetter`.
        
        `variable` may be either an `(object, attribute_string)`, a `(dict,
        key)` pair, or a `(getter, setter)` pair.
        
        `value` is the temporary value to set to the variable.
        '''

        #######################################################################
        # We let the user input either an `(object, attribute_string)`, a
        # `(dict, key)` pair, or a `(getter, setter)` pair. So now it's our job
        # to inspect `variable` and figure out which one of these options the
        # user chose, and then obtain from that a `(getter, setter)` pair that
        # we could use.
        
        bad_input_exception = Exception(
            '`variable` must be either an `(object, attribute_string)` pair, '
            'a `(dict, key)` pair, or a `(getter, setter)` pair.'
        )
        
        try:
            first, second = variable
        except Exception:
            raise bad_input_exception
        if hasattr(first, '__getitem__') and hasattr(first, 'get') and \
           hasattr(first, '__setitem__') and hasattr(first, '__delitem__'):
            # `first` is a dictoid; so we were probably handed a `(dict, key)`
            # pair.
            self.getter = lambda: first.get(second, NotInDict)
            self.setter = lambda value: (first.__setitem__(second, value) if 
                                         value is not NotInDict else
                                         first.__delitem__(second))
            ### Finished handling the `(dict, key)` case. ###
            
        elif callable(second):
            # `second` is a callable; so we were probably handed a `(getter,
            # setter)` pair.
            if not callable(first):
                raise bad_input_exception
            self.getter, self.setter = first, second
            ### Finished handling the `(getter, setter)` case. ###
        else:
            # All that's left is the `(object, attribute_string)` case.
            if not isinstance(second, basestring):
                raise bad_input_exception
            
            parent, attribute_name = first, second
            self.getter = lambda: getattr(parent, attribute_name)
            self.setter = lambda value: setattr(parent, attribute_name, value)
            ### Finished handling the `(object, attribute_string)` case. ###

        #
        #
        ### Finished obtaining a `(getter, setter)` pair from `variable`. #####
        
            
        self.getter = self.getter
        '''Getter for getting the current value of the variable.'''
        
        self.setter = self.setter
        '''Setter for Setting the the variable's value.'''
        
        self.value = value
        '''The value to temporarily set to the variable.'''

        
    def __enter__(self):
        
        self.old_value = self.getter()
        '''The old value of the variable, before entering the suite.'''
        
        self.setter(self.value)

        # In `__exit__` we'll want to check if anyone changed the value of the
        # variable in the suite, which is unallowed. But we can't compare to
        # `.value`, because sometimes when you set a value to a variable, some
        # mechanism modifies that value fore various reasons, resulting in a
        # supposedly equivalent, but not identical, value. For example this
        # happens when you set the current working directory on Mac OS.
        #
        # So here we record the value right after setting, and after any
        # possible processing the system did to it:
        self._value_right_after_setting = self.getter()
        
        return self
        
        
    def __exit__(self, *args, **kwargs):

        # Asserting no-one inside the suite changed our variable:
        assert self.getter() == self._value_right_after_setting
        
        self.setter(self.old_value)
        
########NEW FILE########
__FILENAME__ = temp_working_directory_setter
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `TempWorkingDirectorySetter` class.

See its documentation for more details.
'''

import os

from .temp_value_setter import TempValueSetter


class TempWorkingDirectorySetter(TempValueSetter):
    '''
    Context manager for temporarily changing the working directory.
    
    The temporary working directory is set before the suite starts, and the
    original working directory is used again after the suite finishes.
    '''
    def __init__(self, working_directory):
        '''
        Construct the `TempWorkingDirectorySetter`.
        
        `working_directory` is the temporary working directory to use.
        '''
        assert isinstance(working_directory, basestring)
        TempValueSetter.__init__(self,
                                 (os.getcwd, os.chdir),
                                 value=working_directory)
########NEW FILE########
__FILENAME__ = abc
# Ram's notes: This is cut out of Python 2.6's `abc` module. If we could get a
# 2.5-compliant port of `WeakSet`, we'll be able to upgrade to the `abc` module
# of Python 2.7.
#
# I modified the original module to use my own `_is_subclass` instead of the
# builtin `issubclass`. `_is_subclass` looks for an existing
# `__subclasscheck__` method before calling `issubclass`, which is critical on
# Python 2.5 which doesn't support `__subclasscheck__` natively.
#
# I also included a no-op base `__subclasshook__` method, because Python 2.5
# objects don't have one.

# Copyright 2007 Google, Inc. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

"""Abstract Base Classes (ABCs) according to PEP 3119."""


def _is_subclass(a, b):
    '''
    Is `a` a subclass of `b`?
    
    Looks for `__subclasscheck__` manually, for Python 2.5 compatibility.
    '''
    if hasattr(b, '__subclasscheck__'):
        return b.__subclasscheck__(a)
    else:
        return issubclass(a, b)


def abstractmethod(funcobj):
    """A decorator indicating abstract methods.

    Requires that the metaclass is ABCMeta or derived from it.  A
    class that has a metaclass derived from ABCMeta cannot be
    instantiated unless all of its abstract methods are overridden.
    The abstract methods can be called using any of the normal
    'super' call mechanisms.

    Usage:

        class C:
            __metaclass__ = ABCMeta
            @abstractmethod
            def my_abstract_method(self, ...):
                ...
    """
    funcobj.__isabstractmethod__ = True
    return funcobj


class abstractproperty(property):
    """A decorator indicating abstract properties.

    Requires that the metaclass is ABCMeta or derived from it.  A
    class that has a metaclass derived from ABCMeta cannot be
    instantiated unless all of its abstract properties are overridden.
    The abstract properties can be called using any of the normal
    'super' call mechanisms.

    Usage:

        class C:
            __metaclass__ = ABCMeta
            @abstractproperty
            def my_abstract_property(self):
                ...

    This defines a read-only property; you can also define a read-write
    abstract property using the 'long' form of property declaration:

        class C:
            __metaclass__ = ABCMeta
            def getx(self): ...
            def setx(self, value): ...
            x = abstractproperty(getx, setx)
    """
    __isabstractmethod__ = True


class ABCMeta(type):

    """Metaclass for defining Abstract Base Classes (ABCs).

    Use this metaclass to create an ABC.  An ABC can be subclassed
    directly, and then acts as a mix-in class.  You can also register
    unrelated concrete classes (even built-in classes) and unrelated
    ABCs as 'virtual subclasses' -- these and their descendants will
    be considered subclasses of the registering ABC by the built-in
    issubclass() function, but the registering ABC won't show up in
    their MRO (Method Resolution Order) nor will method
    implementations defined by the registering ABC be callable (not
    even via super()).

    """

    # A global counter that is incremented each time a class is
    # registered as a virtual subclass of anything.  It forces the
    # negative cache to be cleared before its next use.
    _abc_invalidation_counter = 0

    def __new__(mcls, name, bases, namespace):
        cls = super(ABCMeta, mcls).__new__(mcls, name, bases, namespace)
        # Compute set of abstract method names
        abstracts = set(name
                     for name, value in namespace.items()
                     if getattr(value, "__isabstractmethod__", False))
        for base in bases:
            for name in getattr(base, "__abstractmethods__", set()):
                value = getattr(cls, name, None)
                if getattr(value, "__isabstractmethod__", False):
                    abstracts.add(name)
        cls.__abstractmethods__ = frozenset(abstracts)
        # Set up inheritance registry
        cls._abc_registry = set()
        cls._abc_cache = set()
        cls._abc_negative_cache = set()
        cls._abc_negative_cache_version = ABCMeta._abc_invalidation_counter
        return cls

    def register(cls, subclass):
        """Register a virtual subclass of an ABC."""
        if not isinstance(cls, type):
            raise TypeError("Can only register classes")
        if _is_subclass(subclass, cls):
            return  # Already a subclass
        # Subtle: test for cycles *after* testing for "already a subclass";
        # this means we allow X.register(X) and interpret it as a no-op.
        if _is_subclass(cls, subclass):
            # This would create a cycle, which is bad for the algorithm below
            raise RuntimeError("Refusing to create an inheritance cycle")
        cls._abc_registry.add(subclass)
        ABCMeta._abc_invalidation_counter += 1  # Invalidate negative cache

    def _dump_registry(cls, file=None):
        """Debug helper to print the ABC registry."""
        print >> file, "Class: %s.%s" % (cls.__module__, cls.__name__)
        print >> file, "Inv.counter: %s" % ABCMeta._abc_invalidation_counter
        for name in sorted(cls.__dict__.keys()):
            if name.startswith("_abc_"):
                value = getattr(cls, name)
                print >> file, "%s: %r" % (name, value)

    def __instancecheck__(cls, instance):
        """Override for isinstance(instance, cls)."""
        # Inline the cache checking when it's simple.
        subclass = getattr(instance, '__class__', None)
        if subclass in cls._abc_cache:
            return True
        subtype = type(instance)
        if subtype is subclass or subclass is None:
            if (cls._abc_negative_cache_version ==
                ABCMeta._abc_invalidation_counter and
                subtype in cls._abc_negative_cache):
                return False
            # Fall back to the subclass check.
            return cls.__subclasscheck__(subtype)
        return (cls.__subclasscheck__(subclass) or
                cls.__subclasscheck__(subtype))

    def __subclasscheck__(cls, subclass):
        """Override for issubclass(subclass, cls)."""
        # Check cache
        if subclass in cls._abc_cache:
            return True
        # Check negative cache; may have to invalidate
        if cls._abc_negative_cache_version < ABCMeta._abc_invalidation_counter:
            # Invalidate the negative cache
            cls._abc_negative_cache = set()
            cls._abc_negative_cache_version = ABCMeta._abc_invalidation_counter
        elif subclass in cls._abc_negative_cache:
            return False
        # Check the subclass hook
        ok = cls.__subclasshook__(subclass)
        if ok is not NotImplemented:
            assert isinstance(ok, bool)
            if ok:
                cls._abc_cache.add(subclass)
            else:
                cls._abc_negative_cache.add(subclass)
            return ok
        # Check if it's a direct subclass
        if cls in getattr(subclass, '__mro__', ()):
            cls._abc_cache.add(subclass)
            return True
        # Check if it's a subclass of a registered class (recursive)
        for rcls in cls._abc_registry:
            if _is_subclass(subclass, rcls):
                cls._abc_cache.add(subclass)
                return True
        # Check if it's a subclass of a subclass (recursive)
        for scls in cls.__subclasses__():
            if _is_subclass(subclass, scls):
                cls._abc_cache.add(subclass)
                return True
        # No dice; update negative cache
        cls._abc_negative_cache.add(subclass)
        return False

    def __subclasshook__(self, candidate):
        return NotImplemented
########NEW FILE########
__FILENAME__ = abcs_collection
# Ram's note: This is cut out of Python 2.7's `_abcoll` module.

# Copyright 2007 Google, Inc. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

"""Abstract Base Classes (ABCs) for collections, according to PEP 3119.

DON'T USE THIS MODULE DIRECTLY!  The classes here should be imported
via collections; they are defined here only to alleviate certain
bootstrapping issues.  Unit tests are in test_collections.
"""

from .abc import ABCMeta, abstractmethod
import sys

__all__ = ["Hashable", "Iterable", "Iterator",
           "Sized", "Container", "Callable",
           "Set", "MutableSet",
           "Mapping", "MutableMapping",
           "MappingView", "KeysView", "ItemsView", "ValuesView",
           "Sequence", "MutableSequence",
           ]

### ONE-TRICK PONIES ###

def _hasattr(C, attr):
    try:
        return any(attr in B.__dict__ for B in C.__mro__)
    except AttributeError:
        # Old-style class
        return hasattr(C, attr)


class Hashable:
    __metaclass__ = ABCMeta

    @abstractmethod
    def __hash__(self):
        return 0

    @classmethod
    def __subclasshook__(cls, C):
        if cls is Hashable:
            try:
                for B in C.__mro__:
                    if "__hash__" in B.__dict__:
                        if B.__dict__["__hash__"]:
                            return True
                        break
            except AttributeError:
                # Old-style class
                if getattr(C, "__hash__", None):
                    return True
        return NotImplemented


class Iterable:
    __metaclass__ = ABCMeta

    @abstractmethod
    def __iter__(self):
        while False:
            yield None

    @classmethod
    def __subclasshook__(cls, C):
        if cls is Iterable:
            if _hasattr(C, "__iter__"):
                return True
        return NotImplemented

Iterable.register(str)


class Iterator(Iterable):

    @abstractmethod
    def next(self):
        raise StopIteration

    def __iter__(self):
        return self

    @classmethod
    def __subclasshook__(cls, C):
        if cls is Iterator:
            if _hasattr(C, "next"):
                return True
        return NotImplemented


class Sized:
    __metaclass__ = ABCMeta

    @abstractmethod
    def __len__(self):
        return 0

    @classmethod
    def __subclasshook__(cls, C):
        if cls is Sized:
            if _hasattr(C, "__len__"):
                return True
        return NotImplemented


class Container:
    __metaclass__ = ABCMeta

    @abstractmethod
    def __contains__(self, x):
        return False

    @classmethod
    def __subclasshook__(cls, C):
        if cls is Container:
            if _hasattr(C, "__contains__"):
                return True
        return NotImplemented


class Callable:
    __metaclass__ = ABCMeta

    @abstractmethod
    def __call__(self, *args, **kwds):
        return False

    @classmethod
    def __subclasshook__(cls, C):
        if cls is Callable:
            if _hasattr(C, "__call__"):
                return True
        return NotImplemented


### SETS ###


class Set(Sized, Iterable, Container):
    """A set is a finite, iterable container.

    This class provides concrete generic implementations of all
    methods except for __contains__, __iter__ and __len__.

    To override the comparisons (presumably for speed, as the
    semantics are fixed), all you have to do is redefine __le__ and
    then the other operations will automatically follow suit.
    """

    def __le__(self, other):
        if not isinstance(other, Set):
            return NotImplemented
        if len(self) > len(other):
            return False
        for elem in self:
            if elem not in other:
                return False
        return True

    def __lt__(self, other):
        if not isinstance(other, Set):
            return NotImplemented
        return len(self) < len(other) and self.__le__(other)

    def __gt__(self, other):
        if not isinstance(other, Set):
            return NotImplemented
        return other < self

    def __ge__(self, other):
        if not isinstance(other, Set):
            return NotImplemented
        return other <= self

    def __eq__(self, other):
        if not isinstance(other, Set):
            return NotImplemented
        return len(self) == len(other) and self.__le__(other)

    def __ne__(self, other):
        return not (self == other)

    @classmethod
    def _from_iterable(cls, it):
        '''Construct an instance of the class from any iterable input.

        Must override this method if the class constructor signature
        does not accept an iterable for an input.
        '''
        return cls(it)

    def __and__(self, other):
        if not isinstance(other, Iterable):
            return NotImplemented
        return self._from_iterable(value for value in other if value in self)

    def isdisjoint(self, other):
        for value in other:
            if value in self:
                return False
        return True

    def __or__(self, other):
        if not isinstance(other, Iterable):
            return NotImplemented
        chain = (e for s in (self, other) for e in s)
        return self._from_iterable(chain)

    def __sub__(self, other):
        if not isinstance(other, Set):
            if not isinstance(other, Iterable):
                return NotImplemented
            other = self._from_iterable(other)
        return self._from_iterable(value for value in self
                                   if value not in other)

    def __xor__(self, other):
        if not isinstance(other, Set):
            if not isinstance(other, Iterable):
                return NotImplemented
            other = self._from_iterable(other)
        return (self - other) | (other - self)

    # Sets are not hashable by default, but subclasses can change this
    __hash__ = None

    def _hash(self):
        """Compute the hash value of a set.

        Note that we don't define __hash__: not all sets are hashable.
        But if you define a hashable set type, its __hash__ should
        call this function.

        This must be compatible __eq__.

        All sets ought to compare equal if they contain the same
        elements, regardless of how they are implemented, and
        regardless of the order of the elements; so there's not much
        freedom for __eq__ or __hash__.  We match the algorithm used
        by the built-in frozenset type.
        """
        MAX = sys.maxint
        MASK = 2 * MAX + 1
        n = len(self)
        h = 1927868237 * (n + 1)
        h &= MASK
        for x in self:
            hx = hash(x)
            h ^= (hx ^ (hx << 16) ^ 89869747)  * 3644798167
            h &= MASK
        h = h * 69069 + 907133923
        h &= MASK
        if h > MAX:
            h -= MASK + 1
        if h == -1:
            h = 590923713
        return h

Set.register(frozenset)


class MutableSet(Set):

    @abstractmethod
    def add(self, value):
        """Add an element."""
        raise NotImplementedError

    @abstractmethod
    def discard(self, value):
        """Remove an element.  Do not raise an exception if absent."""
        raise NotImplementedError

    def remove(self, value):
        """Remove an element. If not a member, raise a KeyError."""
        if value not in self:
            raise KeyError(value)
        self.discard(value)

    def pop(self):
        """Return the popped value.  Raise KeyError if empty."""
        it = iter(self)
        try:
            value = next(it)
        except StopIteration:
            raise KeyError
        self.discard(value)
        return value

    def clear(self):
        """This is slow (creates N new iterators!) but effective."""
        try:
            while True:
                self.pop()
        except KeyError:
            pass

    def __ior__(self, it):
        for value in it:
            self.add(value)
        return self

    def __iand__(self, it):
        for value in (self - it):
            self.discard(value)
        return self

    def __ixor__(self, it):
        if it is self:
            self.clear()
        else:
            if not isinstance(it, Set):
                it = self._from_iterable(it)
            for value in it:
                if value in self:
                    self.discard(value)
                else:
                    self.add(value)
        return self

    def __isub__(self, it):
        if it is self:
            self.clear()
        else:
            for value in it:
                self.discard(value)
        return self

MutableSet.register(set)


### MAPPINGS ###


class Mapping(Sized, Iterable, Container):

    @abstractmethod
    def __getitem__(self, key):
        raise KeyError

    def get(self, key, default=None):
        try:
            return self[key]
        except KeyError:
            return default

    def __contains__(self, key):
        try:
            self[key]
        except KeyError:
            return False
        else:
            return True

    def iterkeys(self):
        return iter(self)

    def itervalues(self):
        for key in self:
            yield self[key]

    def iteritems(self):
        for key in self:
            yield (key, self[key])

    def keys(self):
        return list(self)

    def items(self):
        return [(key, self[key]) for key in self]

    def values(self):
        return [self[key] for key in self]

    # Mappings are not hashable by default, but subclasses can change this
    __hash__ = None

    def __eq__(self, other):
        if not isinstance(other, Mapping):
            return NotImplemented
        return dict(self.items()) == dict(other.items())

    def __ne__(self, other):
        return not (self == other)

class MappingView(Sized):

    def __init__(self, mapping):
        self._mapping = mapping

    def __len__(self):
        return len(self._mapping)

    def __repr__(self):
        return '{0.__class__.__name__}({0._mapping!r})'.format(self)


class KeysView(MappingView, Set):

    @classmethod
    def _from_iterable(self, it):
        return set(it)

    def __contains__(self, key):
        return key in self._mapping

    def __iter__(self):
        for key in self._mapping:
            yield key


class ItemsView(MappingView, Set):

    @classmethod
    def _from_iterable(self, it):
        return set(it)

    def __contains__(self, item):
        key, value = item
        try:
            v = self._mapping[key]
        except KeyError:
            return False
        else:
            return v == value

    def __iter__(self):
        for key in self._mapping:
            yield (key, self._mapping[key])


class ValuesView(MappingView):

    def __contains__(self, value):
        for key in self._mapping:
            if value == self._mapping[key]:
                return True
        return False

    def __iter__(self):
        for key in self._mapping:
            yield self._mapping[key]


class MutableMapping(Mapping):

    @abstractmethod
    def __setitem__(self, key, value):
        raise KeyError

    @abstractmethod
    def __delitem__(self, key):
        raise KeyError

    __marker = object()

    def pop(self, key, default=__marker):
        try:
            value = self[key]
        except KeyError:
            if default is self.__marker:
                raise
            return default
        else:
            del self[key]
            return value

    def popitem(self):
        try:
            key = next(iter(self))
        except StopIteration:
            raise KeyError
        value = self[key]
        del self[key]
        return key, value

    def clear(self):
        try:
            while True:
                self.popitem()
        except KeyError:
            pass

    def update(*args, **kwds):
        if len(args) > 2:
            raise TypeError("update() takes at most 2 positional "
                            "arguments ({} given)".format(len(args)))
        elif not args:
            raise TypeError("update() takes at least 1 argument (0 given)")
        self = args[0]
        other = args[1] if len(args) >= 2 else ()

        if isinstance(other, Mapping):
            for key in other:
                self[key] = other[key]
        elif hasattr(other, "keys"):
            for key in other.keys():
                self[key] = other[key]
        else:
            for key, value in other:
                self[key] = value
        for key, value in kwds.items():
            self[key] = value

    def setdefault(self, key, default=None):
        try:
            return self[key]
        except KeyError:
            self[key] = default
        return default

MutableMapping.register(dict)


### SEQUENCES ###


class Sequence(Sized, Iterable, Container):
    """All the operations on a read-only sequence.

    Concrete subclasses must override __new__ or __init__,
    __getitem__, and __len__.
    """

    @abstractmethod
    def __getitem__(self, index):
        raise IndexError

    def __iter__(self):
        i = 0
        try:
            while True:
                v = self[i]
                yield v
                i += 1
        except IndexError:
            return

    def __contains__(self, value):
        for v in self:
            if v == value:
                return True
        return False

    def __reversed__(self):
        for i in reversed(range(len(self))):
            yield self[i]

    def index(self, value):
        for i, v in enumerate(self):
            if v == value:
                return i
        raise ValueError

    def count(self, value):
        return sum(1 for v in self if v == value)

Sequence.register(tuple)
Sequence.register(basestring)
Sequence.register(buffer)
Sequence.register(xrange)


class MutableSequence(Sequence):

    @abstractmethod
    def __setitem__(self, index, value):
        raise IndexError

    @abstractmethod
    def __delitem__(self, index):
        raise IndexError

    @abstractmethod
    def insert(self, index, value):
        raise IndexError

    def append(self, value):
        self.insert(len(self), value)

    def reverse(self):
        n = len(self)
        for i in range(n//2):
            self[i], self[n-i-1] = self[n-i-1], self[i]

    def extend(self, values):
        for v in values:
            self.append(v)

    def pop(self, index=-1):
        v = self[index]
        del self[index]
        return v

    def remove(self, value):
        del self[self.index(value)]

    def __iadd__(self, values):
        self.extend(values)
        return self

MutableSequence.register(list)

########NEW FILE########
__FILENAME__ = decorator
##########################     LICENCE     ###############################
##
##   Copyright (c) 2005-2011, Michele Simionato
##   All rights reserved.
##
##   Redistributions of source code must retain the above copyright 
##   notice, this list of conditions and the following disclaimer.
##   Redistributions in bytecode form must reproduce the above copyright
##   notice, this list of conditions and the following disclaimer in
##   the documentation and/or other materials provided with the
##   distribution. 

##   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
##   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
##   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
##   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
##   HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
##   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
##   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
##   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
##   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
##   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
##   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
##   DAMAGE.

"""
Decorator module, see http://pypi.python.org/pypi/decorator
for the documentation.
"""

__version__ = '3.3.0'

__all__ = ["decorator", "FunctionMaker", "partial"]

import sys, re, inspect

try:
    from functools import partial
except ImportError: # for Python version < 2.5
    class partial(object):
        "A simple replacement of functools.partial"
        def __init__(self, func, *args, **kw):
            self.func = func
            self.args = args                
            self.keywords = kw
        def __call__(self, *otherargs, **otherkw):
            kw = self.keywords.copy()
            kw.update(otherkw)
            return self.func(*(self.args + otherargs), **kw)

if sys.version >= '3':
    from inspect import getfullargspec
else:
    class getfullargspec(object):
        "A quick and dirty replacement for getfullargspec for Python 2.X"
        def __init__(self, f):
            self.args, self.varargs, self.varkw, self.defaults = \
                inspect.getargspec(f)
            self.kwonlyargs = []
            self.kwonlydefaults = None
            self.annotations = getattr(f, '__annotations__', {})
        def __iter__(self):
            yield self.args
            yield self.varargs
            yield self.varkw
            yield self.defaults

DEF = re.compile('\s*def\s*([_\w][_\w\d]*)\s*\(')

# basic functionality
class FunctionMaker(object):
    """
    An object with the ability to create functions with a given signature.
    It has attributes name, doc, module, signature, defaults, dict and
    methods update and make.
    """
    def __init__(self, func=None, name=None, signature=None,
                 defaults=None, doc=None, module=None, funcdict=None):
        self.shortsignature = signature
        if func:
            # func can be a class or a callable, but not an instance method
            self.name = func.__name__
            if self.name == '<lambda>': # small hack for lambda functions
                self.name = '_lambda_' 
            self.doc = func.__doc__
            self.module = func.__module__
            if inspect.isfunction(func):
                argspec = getfullargspec(func)
                for a in ('args', 'varargs', 'varkw', 'defaults', 'kwonlyargs',
                          'kwonlydefaults', 'annotations'):
                    setattr(self, a, getattr(argspec, a))
                for i, arg in enumerate(self.args):
                    setattr(self, 'arg%d' % i, arg)
                self.signature = inspect.formatargspec(
                    formatvalue=lambda val: "", *argspec)[1:-1]
                allargs = list(self.args)
                if self.varargs:
                    allargs.append('*' + self.varargs)
                if self.varkw:
                    allargs.append('**' + self.varkw)
                try:
                    self.shortsignature = ', '.join(allargs)
                except TypeError: # exotic signature, valid only in Python 2.X
                    self.shortsignature = self.signature
                self.dict = func.__dict__.copy()
        # func=None happens when decorating a caller
        if name:
            self.name = name
        if signature is not None:
            self.signature = signature
        if defaults:
            self.defaults = defaults
        if doc:
            self.doc = doc
        if module:
            self.module = module
        if funcdict:
            self.dict = funcdict
        # check existence required attributes
        assert hasattr(self, 'name')
        if not hasattr(self, 'signature'):
            raise TypeError('You are decorating a non function: %s' % func)

    def update(self, func, **kw):
        "Update the signature of func with the data in self"
        func.__name__ = self.name
        func.__doc__ = getattr(self, 'doc', None)
        func.__dict__ = getattr(self, 'dict', {})
        func.func_defaults = getattr(self, 'defaults', ())
        callermodule = sys._getframe(3).f_globals.get('__name__', '?')
        func.__module__ = getattr(self, 'module', callermodule)
        func.__dict__.update(kw)

    def make(self, src_templ, evaldict=None, addsource=False, **attrs):
        "Make a new function from a given template and update the signature"
        src = src_templ % vars(self) # expand name and signature
        evaldict = evaldict or {}
        mo = DEF.match(src)
        if mo is None:
            raise SyntaxError('not a valid function template\n%s' % src)
        name = mo.group(1) # extract the function name
        names = set([name] + [arg.strip(' *') for arg in 
                             self.shortsignature.split(',')])
        for n in names:
            if n in ('_func_', '_call_'):
                raise NameError('%s is overridden in\n%s' % (n, src))
        if not src.endswith('\n'): # add a newline just for safety
            src += '\n' # this is needed in old versions of Python
        try:
            code = compile(src, '<string>', 'single')
            # print >> sys.stderr, 'Compiling %s' % src
            exec code in evaldict
        except:
            print >> sys.stderr, 'Error in generated code:'
            print >> sys.stderr, src
            raise
        func = evaldict[name]
        if addsource:
            attrs['__source__'] = src
        self.update(func, **attrs)
        return func

    @classmethod
    def create(cls, obj, body, evaldict, defaults=None,
               doc=None, module=None, addsource=True,**attrs):
        """
        Create a function from the strings name, signature and body.
        evaldict is the evaluation dictionary. If addsource is true an attribute
        __source__ is added to the result. The attributes attrs are added,
        if any.
        """
        if isinstance(obj, str): # "name(signature)"
            name, rest = obj.strip().split('(', 1)
            signature = rest[:-1] #strip a right parens            
            func = None
        else: # a function
            name = None
            signature = None
            func = obj
        self = cls(func, name, signature, defaults, doc, module)
        ibody = '\n'.join('    ' + line for line in body.splitlines())
        return self.make('def %(name)s(%(signature)s):\n' + ibody, 
                        evaldict, addsource, **attrs)
  
def decorator(caller, func=None):
    """
    decorator(caller) converts a caller function into a decorator;
    decorator(caller, func) decorates a function using a caller.
    """
    if func is not None: # returns a decorated function
        evaldict = func.func_globals.copy()
        evaldict['_call_'] = caller
        evaldict['_func_'] = func
        return FunctionMaker.create(
            func, "return _call_(_func_, %(shortsignature)s)",
            evaldict, undecorated=func)
    else: # returns a decorator
        if isinstance(caller, partial):
            return partial(decorator, caller)
        # otherwise assume caller is a function
        first = inspect.getargspec(caller)[0][0] # first arg
        evaldict = caller.func_globals.copy()
        evaldict['_call_'] = caller
        evaldict['decorator'] = decorator
        return FunctionMaker.create(
            '%s(%s)' % (caller.__name__, first), 
            'return decorator(_call_, %s)' % first,
            evaldict, undecorated=caller,
            doc=caller.__doc__, module=caller.__module__)

########NEW FILE########
__FILENAME__ = namedtuple
# Ram's note: This is cut out of Python 2.7's `collections` module.


from keyword import iskeyword as _iskeyword
from operator import itemgetter as _itemgetter, eq as _eq
from garlicsim.general_misc.nifty_collections import OrderedDict
import sys as _sys


################################################################################
### namedtuple
################################################################################

def namedtuple(typename, field_names, verbose=False, rename=False):
    """Returns a new subclass of tuple with named fields.

    >>> Point = namedtuple('Point', 'x y')
    >>> Point.__doc__                   # docstring for the new class
    'Point(x, y)'
    >>> p = Point(11, y=22)             # instantiate with positional args or keywords
    >>> p[0] + p[1]                     # indexable like a plain tuple
    33
    >>> x, y = p                        # unpack like a regular tuple
    >>> x, y
    (11, 22)
    >>> p.x + p.y                       # fields also accessable by name
    33
    >>> d = p._asdict()                 # convert to a dictionary
    >>> d['x']
    11
    >>> Point(**d)                      # convert from a dictionary
    Point(x=11, y=22)
    >>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields
    Point(x=100, y=22)

    """

    # Parse and validate the field names.  Validation serves two purposes,
    # generating informative error messages and preventing template injection attacks.
    if isinstance(field_names, basestring):
        field_names = field_names.replace(',', ' ').split() # names separated by whitespace and/or commas
    field_names = tuple(map(str, field_names))
    if rename:
        names = list(field_names)
        seen = set()
        for i, name in enumerate(names):
            if (not all(c.isalnum() or c=='_' for c in name) or _iskeyword(name)
                or not name or name[0].isdigit() or name.startswith('_')
                or name in seen):
                names[i] = '_%d' % i
            seen.add(name)
        field_names = tuple(names)
    for name in (typename,) + field_names:
        if not all(c.isalnum() or c=='_' for c in name):
            raise ValueError('Type names and field names can only contain alphanumeric characters and underscores: %r' % name)
        if _iskeyword(name):
            raise ValueError('Type names and field names cannot be a keyword: %r' % name)
        if name[0].isdigit():
            raise ValueError('Type names and field names cannot start with a number: %r' % name)
    seen_names = set()
    for name in field_names:
        if name.startswith('_') and not rename:
            raise ValueError('Field names cannot start with an underscore: %r' % name)
        if name in seen_names:
            raise ValueError('Encountered duplicate field name: %r' % name)
        seen_names.add(name)

    # Create and fill-in the class template
    numfields = len(field_names)
    argtxt = repr(field_names).replace("'", "")[1:-1]   # tuple repr without parens or quotes
    reprtxt = ', '.join('%s=%%r' % name for name in field_names)
    template = '''class %(typename)s(tuple):
        '%(typename)s(%(argtxt)s)' \n
        __slots__ = () \n
        _fields = %(field_names)r \n
        def __new__(_cls, %(argtxt)s):
            'Create new instance of %(typename)s(%(argtxt)s)'
            return _tuple.__new__(_cls, (%(argtxt)s)) \n
        @classmethod
        def _make(cls, iterable, new=tuple.__new__, len=len):
            'Make a new %(typename)s object from a sequence or iterable'
            result = new(cls, iterable)
            if len(result) != %(numfields)d:
                raise TypeError('Expected %(numfields)d arguments, got %%d' %% len(result))
            return result \n
        def __repr__(self):
            'Return a nicely formatted representation string'
            return '%(typename)s(%(reprtxt)s)' %% self \n
        def _asdict(self):
            'Return a new OrderedDict which maps field names to their values'
            return OrderedDict(zip(self._fields, self)) \n
        def _replace(_self, **kwds):
            'Return a new %(typename)s object replacing specified fields with new values'
            result = _self._make(map(kwds.pop, %(field_names)r, _self))
            if kwds:
                raise ValueError('Got unexpected field names: %%r' %% kwds.keys())
            return result \n
        def __getnewargs__(self):
            'Return self as a plain tuple.  Used by copy and pickle.'
            return tuple(self) \n\n''' % locals()
    for i, name in enumerate(field_names):
        template += "        %s = _property(_itemgetter(%d), doc='Alias for field number %d')\n" % (name, i, i)
    if verbose:
        print template

    # Execute the template string in a temporary namespace and
    # support tracing utilities by setting a value for frame.f_globals['__name__']
    namespace = dict(_itemgetter=_itemgetter, __name__='namedtuple_%s' % typename,
                     OrderedDict=OrderedDict, _property=property, _tuple=tuple)
    try:
        exec template in namespace
    except SyntaxError, e:
        raise SyntaxError(e.message + ':\n' + template)
    result = namespace[typename]

    # For pickling to work, the __module__ variable needs to be set to the frame
    # where the named tuple is created.  Bypass this step in enviroments where
    # sys._getframe is not defined (Jython for example) or sys._getframe is not
    # defined for arguments greater than 0 (IronPython).
    try:
        result.__module__ = _sys._getframe(1).f_globals.get('__name__', '__main__')
    except (AttributeError, ValueError):
        pass

    return result
########NEW FILE########
__FILENAME__ = case
"""Test case implementation"""

import sys
import difflib
import pprint
import re
import unittest
import warnings

from garlicsim.general_misc.third_party.unittest2 import result
from garlicsim.general_misc.third_party.unittest2.util import (
    safe_repr, safe_str, strclass,
    unorderable_list_difference
)

from garlicsim.general_misc.third_party.unittest2.compatibility import wraps

__unittest = True


def _is_instance(a, b):
    if hasattr(b, '__instancecheck__'):
        return b.__instancecheck__(a)
    else:
        return isinstance(a, b)


DIFF_OMITTED = ('\nDiff is %s characters long. '
                 'Set self.maxDiff to None to see it.')

class SkipTest(Exception):
    """
    Raise this exception in a test to skip it.

    Usually you can use TestResult.skip() or one of the skipping decorators
    instead of raising this directly.
    """

class _ExpectedFailure(Exception):
    """
    Raise this when a test is expected to fail.

    This is an implementation detail.
    """

    def __init__(self, exc_info):
        # can't use super because Python 2.4 exceptions are old style
        Exception.__init__(self)
        self.exc_info = exc_info

class _UnexpectedSuccess(Exception):
    """
    The test was supposed to fail, but it didn't!
    """

def _id(obj):
    return obj

def skip(reason):
    """
    Unconditionally skip a test.
    """
    def decorator(test_item):
        if not (isinstance(test_item, type) and issubclass(test_item, TestCase)):
            @wraps(test_item)
            def skip_wrapper(*args, **kwargs):
                raise SkipTest(reason)
            test_item = skip_wrapper
        
        test_item.__unittest_skip__ = True
        test_item.__unittest_skip_why__ = reason
        return test_item
    return decorator

def skipIf(condition, reason):
    """
    Skip a test if the condition is true.
    """
    if condition:
        return skip(reason)
    return _id

def skipUnless(condition, reason):
    """
    Skip a test unless the condition is true.
    """
    if not condition:
        return skip(reason)
    return _id


def expectedFailure(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        try:
            func(*args, **kwargs)
        except Exception:
            raise _ExpectedFailure(sys.exc_info())
        raise _UnexpectedSuccess
    return wrapper


class _AssertRaisesContext(object):
    """A context manager used to implement TestCase.assertRaises* methods."""

    def __init__(self, expected, test_case, expected_regexp=None):
        self.expected = expected
        self.failureException = test_case.failureException
        self.expected_regexp = expected_regexp

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, tb):
        if exc_type is None:
            try:
                exc_name = self.expected.__name__
            except AttributeError:
                exc_name = str(self.expected)
            raise self.failureException(
                "%s not raised" % (exc_name,))
        if not issubclass(exc_type, self.expected):
            # let unexpected exceptions pass through
            return False
        self.exception = exc_value # store for later retrieval
        if self.expected_regexp is None:
            return True

        expected_regexp = self.expected_regexp
        if isinstance(expected_regexp, basestring):
            expected_regexp = re.compile(expected_regexp)
        if not expected_regexp.search(str(exc_value)):
            raise self.failureException('"%s" does not match "%s"' %
                     (expected_regexp.pattern, str(exc_value)))
        return True


class _TypeEqualityDict(object):
    
    def __init__(self, testcase):
        self.testcase = testcase
        self._store = {}
    
    def __setitem__(self, key, value):
        self._store[key] = value
    
    def __getitem__(self, key):
        value = self._store[key]
        if isinstance(value, basestring):
            return getattr(self.testcase, value)
        return value
    
    def get(self, key, default=None):
        if key in self._store:
            return self[key]
        return default


class TestCase(unittest.TestCase):
    """A class whose instances are single test cases.

    By default, the test code itself should be placed in a method named
    'runTest'.

    If the fixture may be used for many test cases, create as
    many test methods as are needed. When instantiating such a TestCase
    subclass, specify in the constructor arguments the name of the test method
    that the instance is to execute.

    Test authors should subclass TestCase for their own tests. Construction
    and deconstruction of the test's environment ('fixture') can be
    implemented by overriding the 'setUp' and 'tearDown' methods respectively.

    If it is necessary to override the __init__ method, the base class
    __init__ method must always be called. It is important that subclasses
    should not change the signature of their __init__ method, since instances
    of the classes are instantiated automatically by parts of the framework
    in order to be run.
    """

    # This attribute determines which exception will be raised when
    # the instance's assertion methods fail; test methods raising this
    # exception will be deemed to have 'failed' rather than 'errored'

    failureException = AssertionError

    # This attribute sets the maximum length of a diff in failure messages
    # by assert methods using difflib. It is looked up as an instance attribute
    # so can be configured by individual tests if required.

    maxDiff = 80*8

    # This attribute determines whether long messages (including repr of
    # objects used in assert methods) will be printed on failure in *addition*
    # to any explicit message passed.

    longMessage = True
    
    # Attribute used by TestSuite for classSetUp
    
    _classSetupFailed = False

    def __init__(self, methodName='runTest'):
        """Create an instance of the class that will use the named test
           method when executed. Raises a ValueError if the instance does
           not have a method with the specified name.
        """
        self._testMethodName = methodName
        self._resultForDoCleanups = None
        try:
            testMethod = getattr(self, methodName)
        except AttributeError:
            raise ValueError("no such test method in %s: %s" % \
                  (self.__class__, methodName))
        self._testMethodDoc = testMethod.__doc__
        self._cleanups = []

        # Map types to custom assertEqual functions that will compare
        # instances of said type in more detail to generate a more useful
        # error message.
        self._type_equality_funcs = _TypeEqualityDict(self)
        self.addTypeEqualityFunc(dict, 'assertDictEqual')
        self.addTypeEqualityFunc(list, 'assertListEqual')
        self.addTypeEqualityFunc(tuple, 'assertTupleEqual')
        self.addTypeEqualityFunc(set, 'assertSetEqual')
        self.addTypeEqualityFunc(frozenset, 'assertSetEqual')
        self.addTypeEqualityFunc(unicode, 'assertMultiLineEqual')

    def addTypeEqualityFunc(self, typeobj, function):
        """Add a type specific assertEqual style function to compare a type.

        This method is for use by TestCase subclasses that need to register
        their own type equality functions to provide nicer error messages.

        Args:
            typeobj: The data type to call this function on when both values
                    are of the same type in assertEqual().
            function: The callable taking two arguments and an optional
                    msg= argument that raises self.failureException with a
                    useful error message when the two arguments are not equal.
        """
        self._type_equality_funcs[typeobj] = function

    def addCleanup(self, function, *args, **kwargs):
        """Add a function, with arguments, to be called when the test is
        completed. Functions added are called on a LIFO basis and are
        called after tearDown on test failure or success.

        Cleanup items are called even if setUp fails (unlike tearDown)."""
        self._cleanups.append((function, args, kwargs))

    def setUp(self):
        "Hook method for setting up the test fixture before exercising it."
    
    @classmethod
    def setUpClass(cls):
        "Hook method for setting up class fixture before running tests in the class."

    @classmethod
    def tearDownClass(cls):
        "Hook method for deconstructing the class fixture after running all tests in the class."

    def tearDown(self):
        "Hook method for deconstructing the test fixture after testing it."

    def countTestCases(self):
        return 1

    def defaultTestResult(self):
        return result.TestResult()

    def shortDescription(self):
        """Returns a one-line description of the test, or None if no
        description has been provided.

        The default implementation of this method returns the first line of
        the specified test method's docstring.
        """
        doc = self._testMethodDoc
        return doc and doc.split("\n")[0].strip() or None


    def id(self):
        return "%s.%s" % (strclass(self.__class__), self._testMethodName)

    def __eq__(self, other):
        if type(self) is not type(other):
            return NotImplemented

        return self._testMethodName == other._testMethodName

    def __ne__(self, other):
        return not self == other

    def __hash__(self):
        return hash((type(self), self._testMethodName))

    def __str__(self):
        return "%s (%s)" % (self._testMethodName, strclass(self.__class__))

    def __repr__(self):
        return "<%s testMethod=%s>" % \
               (strclass(self.__class__), self._testMethodName)
    
    def _addSkip(self, result, reason):
        addSkip = getattr(result, 'addSkip', None)
        if addSkip is not None:
            addSkip(self, reason)
        else:
            warnings.warn("Use of a TestResult without an addSkip method is deprecated", 
                          DeprecationWarning, 2)
            result.addSuccess(self)

    def run(self, result=None):
        orig_result = result
        if result is None:
            result = self.defaultTestResult()
            startTestRun = getattr(result, 'startTestRun', None)
            if startTestRun is not None:
                startTestRun()

        self._resultForDoCleanups = result
        result.startTest(self)
        
        testMethod = getattr(self, self._testMethodName)
        
        if (getattr(self.__class__, "__unittest_skip__", False) or 
            getattr(testMethod, "__unittest_skip__", False)):
            # If the class or method was skipped.
            try:
                skip_why = (getattr(self.__class__, '__unittest_skip_why__', '')
                            or getattr(testMethod, '__unittest_skip_why__', ''))
                self._addSkip(result, skip_why)
            finally:
                result.stopTest(self)
            return
        try:
            success = False
            try:
                self.setUp()
            except SkipTest, e:
                self._addSkip(result, str(e))
            except Exception:
                result.addError(self, sys.exc_info())
            else:
                try:
                    testMethod()
                except self.failureException:
                    result.addFailure(self, sys.exc_info())
                except _ExpectedFailure, e:
                    addExpectedFailure = getattr(result, 'addExpectedFailure', None)
                    if addExpectedFailure is not None:
                        addExpectedFailure(self, e.exc_info)
                    else: 
                        warnings.warn("Use of a TestResult without an addExpectedFailure method is deprecated", 
                                      DeprecationWarning)
                        result.addSuccess(self)
                except _UnexpectedSuccess:
                    addUnexpectedSuccess = getattr(result, 'addUnexpectedSuccess', None)
                    if addUnexpectedSuccess is not None:
                        addUnexpectedSuccess(self)
                    else:
                        warnings.warn("Use of a TestResult without an addUnexpectedSuccess method is deprecated", 
                                      DeprecationWarning)
                        result.addFailure(self, sys.exc_info())
                except SkipTest, e:
                    self._addSkip(result, str(e))
                except Exception:
                    result.addError(self, sys.exc_info())
                else:
                    success = True

                try:
                    self.tearDown()
                except Exception:
                    result.addError(self, sys.exc_info())
                    success = False

            cleanUpSuccess = self.doCleanups()
            success = success and cleanUpSuccess
            if success:
                result.addSuccess(self)
        finally:
            result.stopTest(self)
            if orig_result is None:
                stopTestRun = getattr(result, 'stopTestRun', None)
                if stopTestRun is not None:
                    stopTestRun()

    def doCleanups(self):
        """Execute all cleanup functions. Normally called for you after
        tearDown."""
        result = self._resultForDoCleanups
        ok = True
        while self._cleanups:
            function, args, kwargs = self._cleanups.pop(-1)
            try:
                function(*args, **kwargs)
            except Exception:
                ok = False
                result.addError(self, sys.exc_info())
        return ok

    def __call__(self, *args, **kwds):
        return self.run(*args, **kwds)

    def debug(self):
        """Run the test without collecting errors in a TestResult"""
        self.setUp()
        getattr(self, self._testMethodName)()
        self.tearDown()
        while self._cleanups:
            function, args, kwargs = self._cleanups.pop(-1)
            function(*args, **kwargs)

    def skipTest(self, reason):
        """Skip this test."""
        raise SkipTest(reason)

    def fail(self, msg=None):
        """Fail immediately, with the given message."""
        raise self.failureException(msg)

    def assertFalse(self, expr, msg=None):
        "Fail the test if the expression is true."
        if expr:
            msg = self._formatMessage(msg, "%s is not False" % safe_repr(expr))
            raise self.failureException(msg)

    def assertTrue(self, expr, msg=None):
        """Fail the test unless the expression is true."""
        if not expr:
            msg = self._formatMessage(msg, "%s is not True" % safe_repr(expr))
            raise self.failureException(msg)

    def _formatMessage(self, msg, standardMsg):
        """Honour the longMessage attribute when generating failure messages.
        If longMessage is False this means:
        * Use only an explicit message if it is provided
        * Otherwise use the standard message for the assert

        If longMessage is True:
        * Use the standard message
        * If an explicit message is provided, plus ' : ' and the explicit message
        """
        if not self.longMessage:
            return msg or standardMsg
        if msg is None:
            return standardMsg
        try:
            return '%s : %s' % (standardMsg, msg)
        except UnicodeDecodeError:
            return '%s : %s' % (safe_str(standardMsg), safe_str(msg))


    def assertRaises(self, excClass, callableObj=None, *args, **kwargs):
        """Fail unless an exception of class excClass is thrown
           by callableObj when invoked with arguments args and keyword
           arguments kwargs. If a different type of exception is
           thrown, it will not be caught, and the test case will be
           deemed to have suffered an error, exactly as for an
           unexpected exception.

           If called with callableObj omitted or None, will return a
           context object used like this::

                with self.assertRaises(SomeException):
                    do_something()

           The context manager keeps a reference to the exception as
           the 'exception' attribute. This allows you to inspect the
           exception after the assertion::

               with self.assertRaises(SomeException) as cm:
                   do_something()
               the_exception = cm.exception
               self.assertEqual(the_exception.error_code, 3)
        """
        if callableObj is None:
            return _AssertRaisesContext(excClass, self)
        try:
            callableObj(*args, **kwargs)
        except excClass:
            return
        
        if hasattr(excClass,'__name__'):
            excName = excClass.__name__
        else:
            excName = str(excClass)
        raise self.failureException, "%s not raised" % excName

    def _getAssertEqualityFunc(self, first, second):
        """Get a detailed comparison function for the types of the two args.

        Returns: A callable accepting (first, second, msg=None) that will
        raise a failure exception if first != second with a useful human
        readable error message for those types.
        """
        #
        # NOTE(gregory.p.smith): I considered isinstance(first, type(second))
        # and vice versa.  I opted for the conservative approach in case
        # subclasses are not intended to be compared in detail to their super
        # class instances using a type equality func.  This means testing
        # subtypes won't automagically use the detailed comparison.  Callers
        # should use their type specific assertSpamEqual method to compare
        # subclasses if the detailed comparison is desired and appropriate.
        # See the discussion in http://bugs.python.org/issue2578.
        #
        if type(first) is type(second):
            asserter = self._type_equality_funcs.get(type(first))
            if asserter is not None:
                return asserter

        return self._baseAssertEqual

    def _baseAssertEqual(self, first, second, msg=None):
        """The default assertEqual implementation, not type specific."""
        if not first == second:
            standardMsg = '%s != %s' % (safe_repr(first), safe_repr(second))
            msg = self._formatMessage(msg, standardMsg)
            raise self.failureException(msg)

    def assertEqual(self, first, second, msg=None):
        """Fail if the two objects are unequal as determined by the '=='
           operator.
        """
        assertion_func = self._getAssertEqualityFunc(first, second)
        assertion_func(first, second, msg=msg)

    def assertNotEqual(self, first, second, msg=None):
        """Fail if the two objects are equal as determined by the '=='
           operator.
        """
        if not first != second:
            msg = self._formatMessage(msg, '%s == %s' % (safe_repr(first), 
                                                           safe_repr(second)))
            raise self.failureException(msg)

    def assertAlmostEqual(self, first, second, places=None, msg=None, delta=None):
        """Fail if the two objects are unequal as determined by their
           difference rounded to the given number of decimal places
           (default 7) and comparing to zero, or by comparing that the
           between the two objects is more than the given delta.

           Note that decimal places (from zero) are usually not the same
           as significant digits (measured from the most signficant digit).

           If the two objects compare equal then they will automatically
           compare almost equal.
        """
        if first == second:
            # shortcut
            return
        if delta is not None and places is not None:
            raise TypeError("specify delta or places not both")
        
        if delta is not None:
            if abs(first - second) <= delta:
                return
        
            standardMsg = '%s != %s within %s delta' % (safe_repr(first), 
                                                        safe_repr(second), 
                                                        safe_repr(delta))
        else:
            if places is None:
                places = 7
                
            if round(abs(second-first), places) == 0:
                return
        
            standardMsg = '%s != %s within %r places' % (safe_repr(first), 
                                                          safe_repr(second), 
                                                          places)
        msg = self._formatMessage(msg, standardMsg)
        raise self.failureException(msg)

    def assertNotAlmostEqual(self, first, second, places=None, msg=None, delta=None):
        """Fail if the two objects are equal as determined by their
           difference rounded to the given number of decimal places
           (default 7) and comparing to zero, or by comparing that the
           between the two objects is less than the given delta.

           Note that decimal places (from zero) are usually not the same
           as significant digits (measured from the most signficant digit).

           Objects that are equal automatically fail.
        """
        if delta is not None and places is not None:
            raise TypeError("specify delta or places not both")
        if delta is not None:
            if not (first == second) and abs(first - second) > delta:
                return
            standardMsg = '%s == %s within %s delta' % (safe_repr(first), 
                                                        safe_repr(second),
                                                        safe_repr(delta))
        else:
            if places is None:
                places = 7
            if not (first == second) and round(abs(second-first), places) != 0:
                return
            standardMsg = '%s == %s within %r places' % (safe_repr(first), 
                                                         safe_repr(second),
                                                         places)

        msg = self._formatMessage(msg, standardMsg)
        raise self.failureException(msg)

    # Synonyms for assertion methods

    # The plurals are undocumented.  Keep them that way to discourage use.
    # Do not add more.  Do not remove.
    # Going through a deprecation cycle on these would annoy many people.
    assertEquals = assertEqual
    assertNotEquals = assertNotEqual
    assertAlmostEquals = assertAlmostEqual
    assertNotAlmostEquals = assertNotAlmostEqual
    assert_ = assertTrue

    # These fail* assertion method names are pending deprecation and will
    # be a DeprecationWarning in 3.2; http://bugs.python.org/issue2578
    def _deprecate(original_func):
        def deprecated_func(*args, **kwargs):
            warnings.warn(
                ('Please use %s instead.' % original_func.__name__),
                PendingDeprecationWarning, 2)
            return original_func(*args, **kwargs)
        return deprecated_func

    failUnlessEqual = _deprecate(assertEqual)
    failIfEqual = _deprecate(assertNotEqual)
    failUnlessAlmostEqual = _deprecate(assertAlmostEqual)
    failIfAlmostEqual = _deprecate(assertNotAlmostEqual)
    failUnless = _deprecate(assertTrue)
    failUnlessRaises = _deprecate(assertRaises)
    failIf = _deprecate(assertFalse)

    def assertSequenceEqual(self, seq1, seq2,
                            msg=None, seq_type=None, max_diff=80*8):
        """An equality assertion for ordered sequences (like lists and tuples).

        For the purposes of this function, a valid ordered sequence type is one
        which can be indexed, has a length, and has an equality operator.

        Args:
            seq1: The first sequence to compare.
            seq2: The second sequence to compare.
            seq_type: The expected datatype of the sequences, or None if no
                    datatype should be enforced.
            msg: Optional message to use on failure instead of a list of
                    differences.
            max_diff: Maximum size off the diff, larger diffs are not shown
        """
        if seq_type is not None:
            seq_type_name = seq_type.__name__
            if not isinstance(seq1, seq_type):
                raise self.failureException('First sequence is not a %s: %s'
                                            % (seq_type_name, safe_repr(seq1)))
            if not isinstance(seq2, seq_type):
                raise self.failureException('Second sequence is not a %s: %s'
                                            % (seq_type_name, safe_repr(seq2)))
        else:
            seq_type_name = "sequence"

        differing = None
        try:
            len1 = len(seq1)
        except (TypeError, NotImplementedError):
            differing = 'First %s has no length.    Non-sequence?' % (
                    seq_type_name)

        if differing is None:
            try:
                len2 = len(seq2)
            except (TypeError, NotImplementedError):
                differing = 'Second %s has no length.    Non-sequence?' % (
                        seq_type_name)

        if differing is None:
            if seq1 == seq2:
                return

            seq1_repr = repr(seq1)
            seq2_repr = repr(seq2)
            if len(seq1_repr) > 30:
                seq1_repr = seq1_repr[:30] + '...'
            if len(seq2_repr) > 30:
                seq2_repr = seq2_repr[:30] + '...'
            elements = (seq_type_name.capitalize(), seq1_repr, seq2_repr)
            differing = '%ss differ: %s != %s\n' % elements

            for i in xrange(min(len1, len2)):
                try:
                    item1 = seq1[i]
                except (TypeError, IndexError, NotImplementedError):
                    differing += ('\nUnable to index element %d of first %s\n' %
                                 (i, seq_type_name))
                    break

                try:
                    item2 = seq2[i]
                except (TypeError, IndexError, NotImplementedError):
                    differing += ('\nUnable to index element %d of second %s\n' %
                                 (i, seq_type_name))
                    break

                if item1 != item2:
                    differing += ('\nFirst differing element %d:\n%s\n%s\n' %
                                 (i, item1, item2))
                    break
            else:
                if (len1 == len2 and seq_type is None and
                    type(seq1) != type(seq2)):
                    # The sequences are the same, but have differing types.
                    return

            if len1 > len2:
                differing += ('\nFirst %s contains %d additional '
                             'elements.\n' % (seq_type_name, len1 - len2))
                try:
                    differing += ('First extra element %d:\n%s\n' %
                                  (len2, seq1[len2]))
                except (TypeError, IndexError, NotImplementedError):
                    differing += ('Unable to index element %d '
                                  'of first %s\n' % (len2, seq_type_name))
            elif len1 < len2:
                differing += ('\nSecond %s contains %d additional '
                             'elements.\n' % (seq_type_name, len2 - len1))
                try:
                    differing += ('First extra element %d:\n%s\n' %
                                  (len1, seq2[len1]))
                except (TypeError, IndexError, NotImplementedError):
                    differing += ('Unable to index element %d '
                                  'of second %s\n' % (len1, seq_type_name))
        standardMsg = differing
        diffMsg = '\n' + '\n'.join(
            difflib.ndiff(pprint.pformat(seq1).splitlines(),
                          pprint.pformat(seq2).splitlines()))

        standardMsg = self._truncateMessage(standardMsg, diffMsg)
        msg = self._formatMessage(msg, standardMsg)
        self.fail(msg)

    def _truncateMessage(self, message, diff):
        max_diff = self.maxDiff
        if max_diff is None or len(diff) <= max_diff:
            return message + diff
        return message + (DIFF_OMITTED % len(diff))

    def assertListEqual(self, list1, list2, msg=None):
        """A list-specific equality assertion.

        Args:
            list1: The first list to compare.
            list2: The second list to compare.
            msg: Optional message to use on failure instead of a list of
                    differences.

        """
        self.assertSequenceEqual(list1, list2, msg, seq_type=list)

    def assertTupleEqual(self, tuple1, tuple2, msg=None):
        """A tuple-specific equality assertion.

        Args:
            tuple1: The first tuple to compare.
            tuple2: The second tuple to compare.
            msg: Optional message to use on failure instead of a list of
                    differences.
        """
        self.assertSequenceEqual(tuple1, tuple2, msg, seq_type=tuple)

    def assertSetEqual(self, set1, set2, msg=None):
        """A set-specific equality assertion.

        Args:
            set1: The first set to compare.
            set2: The second set to compare.
            msg: Optional message to use on failure instead of a list of
                    differences.

        assertSetEqual uses ducktyping to support
        different types of sets, and is optimized for sets specifically
        (parameters must support a difference method).
        """
        try:
            difference1 = set1.difference(set2)
        except TypeError, e:
            self.fail('invalid type when attempting set difference: %s' % e)
        except AttributeError, e:
            self.fail('first argument does not support set difference: %s' % e)

        try:
            difference2 = set2.difference(set1)
        except TypeError, e:
            self.fail('invalid type when attempting set difference: %s' % e)
        except AttributeError, e:
            self.fail('second argument does not support set difference: %s' % e)

        if not (difference1 or difference2):
            return

        lines = []
        if difference1:
            lines.append('Items in the first set but not the second:')
            for item in difference1:
                lines.append(repr(item))
        if difference2:
            lines.append('Items in the second set but not the first:')
            for item in difference2:
                lines.append(repr(item))

        standardMsg = '\n'.join(lines)
        self.fail(self._formatMessage(msg, standardMsg))

    def assertIn(self, member, container, msg=None):
        """Just like self.assertTrue(a in b), but with a nicer default message."""
        if member not in container:
            standardMsg = '%s not found in %s' % (safe_repr(member), 
                                                   safe_repr(container))
            self.fail(self._formatMessage(msg, standardMsg))

    def assertNotIn(self, member, container, msg=None):
        """Just like self.assertTrue(a not in b), but with a nicer default message."""
        if member in container:
            standardMsg = '%s unexpectedly found in %s' % (safe_repr(member), 
                                                            safe_repr(container))
            self.fail(self._formatMessage(msg, standardMsg))

    def assertIs(self, expr1, expr2, msg=None):
        """Just like self.assertTrue(a is b), but with a nicer default message."""
        if expr1 is not expr2:
            standardMsg = '%s is not %s' % (safe_repr(expr1), safe_repr(expr2))
            self.fail(self._formatMessage(msg, standardMsg))

    def assertIsNot(self, expr1, expr2, msg=None):
        """Just like self.assertTrue(a is not b), but with a nicer default message."""
        if expr1 is expr2:
            standardMsg = 'unexpectedly identical: %s' % (safe_repr(expr1),)
            self.fail(self._formatMessage(msg, standardMsg))

    def assertDictEqual(self, d1, d2, msg=None):
        self.assert_(isinstance(d1, dict), 'First argument is not a dictionary')
        self.assert_(isinstance(d2, dict), 'Second argument is not a dictionary')

        if d1 != d2:
            standardMsg = '%s != %s' % (safe_repr(d1, True), safe_repr(d2, True))
            diff = ('\n' + '\n'.join(difflib.ndiff(
                           pprint.pformat(d1).splitlines(),
                           pprint.pformat(d2).splitlines())))
            standardMsg = self._truncateMessage(standardMsg, diff)
            self.fail(self._formatMessage(msg, standardMsg))

    def assertDictContainsSubset(self, expected, actual, msg=None):
        """Checks whether actual is a superset of expected."""
        missing = []
        mismatched = []
        for key, value in expected.iteritems():
            if key not in actual:
                missing.append(key)
            elif value != actual[key]:
                mismatched.append('%s, expected: %s, actual: %s' %
                                  (safe_repr(key), safe_repr(value), 
                                   safe_repr(actual[key])))

        if not (missing or mismatched):
            return

        standardMsg = ''
        if missing:
            standardMsg = 'Missing: %s' % ','.join(safe_repr(m) for m in 
                                                    missing)
        if mismatched:
            if standardMsg:
                standardMsg += '; '
            standardMsg += 'Mismatched values: %s' % ','.join(mismatched)

        self.fail(self._formatMessage(msg, standardMsg))

    def assertItemsEqual(self, expected_seq, actual_seq, msg=None):
        """An unordered sequence specific comparison. It asserts that
        expected_seq and actual_seq contain the same elements. It is
        the equivalent of::
        
            self.assertEqual(sorted(expected_seq), sorted(actual_seq))

        Raises with an error message listing which elements of expected_seq
        are missing from actual_seq and vice versa if any.
        
        Asserts that each element has the same count in both sequences.
        Example:
            - [0, 1, 1] and [1, 0, 1] compare equal.
            - [0, 0, 1] and [0, 1] compare unequal.
        """
        try:
            expected = sorted(expected_seq)
            actual = sorted(actual_seq)
        except TypeError:
            # Unsortable items (example: set(), complex(), ...)
            expected = list(expected_seq)
            actual = list(actual_seq)
            missing, unexpected = unorderable_list_difference(
                expected, actual, ignore_duplicate=False
            )
        else:
            return self.assertSequenceEqual(expected, actual, msg=msg)

        errors = []
        if missing:
            errors.append('Expected, but missing:\n    %s' % 
                           safe_repr(missing))
        if unexpected:
            errors.append('Unexpected, but present:\n    %s' % 
                           safe_repr(unexpected))
        if errors:
            standardMsg = '\n'.join(errors)
            self.fail(self._formatMessage(msg, standardMsg))

    def assertMultiLineEqual(self, first, second, msg=None):
        """Assert that two multi-line strings are equal."""
        self.assert_(isinstance(first, basestring), (
                'First argument is not a string'))
        self.assert_(isinstance(second, basestring), (
                'Second argument is not a string'))

        if first != second:
            standardMsg = '%s != %s' % (safe_repr(first, True), safe_repr(second, True))
            diff = '\n' + ''.join(difflib.ndiff(first.splitlines(True),
                                                       second.splitlines(True)))
            standardMsg = self._truncateMessage(standardMsg, diff)
            self.fail(self._formatMessage(msg, standardMsg))

    def assertLess(self, a, b, msg=None):
        """Just like self.assertTrue(a < b), but with a nicer default message."""
        if not a < b:
            standardMsg = '%s not less than %s' % (safe_repr(a), safe_repr(b))
            self.fail(self._formatMessage(msg, standardMsg))

    def assertLessEqual(self, a, b, msg=None):
        """Just like self.assertTrue(a <= b), but with a nicer default message."""
        if not a <= b:
            standardMsg = '%s not less than or equal to %s' % (safe_repr(a), safe_repr(b))
            self.fail(self._formatMessage(msg, standardMsg))

    def assertGreater(self, a, b, msg=None):
        """Just like self.assertTrue(a > b), but with a nicer default message."""
        if not a > b:
            standardMsg = '%s not greater than %s' % (safe_repr(a), safe_repr(b))
            self.fail(self._formatMessage(msg, standardMsg))

    def assertGreaterEqual(self, a, b, msg=None):
        """Just like self.assertTrue(a >= b), but with a nicer default message."""
        if not a >= b:
            standardMsg = '%s not greater than or equal to %s' % (safe_repr(a), safe_repr(b))
            self.fail(self._formatMessage(msg, standardMsg))

    def assertIsNone(self, obj, msg=None):
        """Same as self.assertTrue(obj is None), with a nicer default message."""
        if obj is not None:
            standardMsg = '%s is not None' % (safe_repr(obj),)
            self.fail(self._formatMessage(msg, standardMsg))

    def assertIsNotNone(self, obj, msg=None):
        """Included for symmetry with assertIsNone."""
        if obj is None:
            standardMsg = 'unexpectedly None'
            self.fail(self._formatMessage(msg, standardMsg))

    def assertIsInstance(self, obj, cls, msg=None):
        """Same as self.assertTrue(isinstance(obj, cls)), with a nicer
        default message."""
        if not _is_instance(obj, cls):
            standardMsg = '%s is not an instance of %r' % (safe_repr(obj), cls)
            self.fail(self._formatMessage(msg, standardMsg))

    def assertNotIsInstance(self, obj, cls, msg=None):
        """Included for symmetry with assertIsInstance."""
        if _is_instance(obj, cls):
            standardMsg = '%s is an instance of %r' % (safe_repr(obj), cls)
            self.fail(self._formatMessage(msg, standardMsg))

    def assertRaisesRegexp(self, expected_exception, expected_regexp,
                           callable_obj=None, *args, **kwargs):
        """Asserts that the message in a raised exception matches a regexp.

        Args:
            expected_exception: Exception class expected to be raised.
            expected_regexp: Regexp (re pattern object or string) expected
                    to be found in error message.
            callable_obj: Function to be called.
            args: Extra args.
            kwargs: Extra kwargs.
        """
        if callable_obj is None:
            return _AssertRaisesContext(expected_exception, self, expected_regexp)
        try:
            callable_obj(*args, **kwargs)
        except expected_exception, exc_value:
            if isinstance(expected_regexp, basestring):
                expected_regexp = re.compile(expected_regexp)
            if not expected_regexp.search(str(exc_value)):
                raise self.failureException('"%s" does not match "%s"' %
                         (expected_regexp.pattern, str(exc_value)))
        else:
            if hasattr(expected_exception, '__name__'): 
                excName = expected_exception.__name__
            else: 
                excName = str(expected_exception)
            raise self.failureException, "%s not raised" % excName


    def assertRegexpMatches(self, text, expected_regexp, msg=None):
        """Fail the test unless the text matches the regular expression."""
        if isinstance(expected_regexp, basestring):
            expected_regexp = re.compile(expected_regexp)
        if not expected_regexp.search(text):
            msg = msg or "Regexp didn't match"
            msg = '%s: %r not found in %r' % (msg, expected_regexp.pattern, text)
            raise self.failureException(msg)

    def assertNotRegexpMatches(self, text, unexpected_regexp, msg=None):
        """Fail the test if the text matches the regular expression."""
        if isinstance(unexpected_regexp, basestring):
            unexpected_regexp = re.compile(unexpected_regexp)
        match = unexpected_regexp.search(text)
        if match:
            msg = msg or "Regexp matched"
            msg = '%s: %r matches %r in %r' % (msg,
                                               text[match.start():match.end()],
                                               unexpected_regexp.pattern,
                                               text)
            raise self.failureException(msg)

class FunctionTestCase(TestCase):
    """A test case that wraps a test function.

    This is useful for slipping pre-existing test functions into the
    unittest framework. Optionally, set-up and tidy-up functions can be
    supplied. As with TestCase, the tidy-up ('tearDown') function will
    always be called if the set-up ('setUp') function ran successfully.
    """

    def __init__(self, testFunc, setUp=None, tearDown=None, description=None):
        super(FunctionTestCase, self).__init__()
        self._setUpFunc = setUp
        self._tearDownFunc = tearDown
        self._testFunc = testFunc
        self._description = description

    def setUp(self):
        if self._setUpFunc is not None:
            self._setUpFunc()

    def tearDown(self):
        if self._tearDownFunc is not None:
            self._tearDownFunc()

    def runTest(self):
        self._testFunc()

    def id(self):
        return self._testFunc.__name__

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return NotImplemented

        return self._setUpFunc == other._setUpFunc and \
               self._tearDownFunc == other._tearDownFunc and \
               self._testFunc == other._testFunc and \
               self._description == other._description

    def __ne__(self, other):
        return not self == other

    def __hash__(self):
        return hash((type(self), self._setUpFunc, self._tearDownFunc,
                     self._testFunc, self._description))

    def __str__(self):
        return "%s (%s)" % (strclass(self.__class__),
                            self._testFunc.__name__)

    def __repr__(self):
        return "<%s testFunc=%s>" % (strclass(self.__class__),
                                     self._testFunc)

    def shortDescription(self):
        if self._description is not None:
            return self._description
        doc = self._testFunc.__doc__
        return doc and doc.split("\n")[0].strip() or None

########NEW FILE########
__FILENAME__ = collector
import os
import sys
from garlicsim.general_misc.third_party.unittest2.loader import defaultTestLoader

def collector():
    # import __main__ triggers code re-execution
    __main__ = sys.modules['__main__']
    setupDir = os.path.abspath(os.path.dirname(__main__.__file__))
    return defaultTestLoader.discover(setupDir)

########NEW FILE########
__FILENAME__ = compatibility
import os
import sys

try:
    from functools import wraps
except ImportError:
    # only needed for Python 2.4
    def wraps(_):
        def _wraps(func):
            return func
        return _wraps

__unittest = True

def _relpath_nt(path, start=os.path.curdir):
    """Return a relative version of a path"""

    if not path:
        raise ValueError("no path specified")
    start_list = os.path.abspath(start).split(os.path.sep)
    path_list = os.path.abspath(path).split(os.path.sep)
    if start_list[0].lower() != path_list[0].lower():
        unc_path, rest = os.path.splitunc(path)
        unc_start, rest = os.path.splitunc(start)
        if bool(unc_path) ^ bool(unc_start):
            raise ValueError("Cannot mix UNC and non-UNC paths (%s and %s)"
                                                                % (path, start))
        else:
            raise ValueError("path is on drive %s, start on drive %s"
                                                % (path_list[0], start_list[0]))
    # Work out how much of the filepath is shared by start and path.
    for i in range(min(len(start_list), len(path_list))):
        if start_list[i].lower() != path_list[i].lower():
            break
    else:
        i += 1

    rel_list = [os.path.pardir] * (len(start_list)-i) + path_list[i:]
    if not rel_list:
        return os.path.curdir
    return os.path.join(*rel_list)

# default to posixpath definition
def _relpath_posix(path, start=os.path.curdir):
    """Return a relative version of a path"""

    if not path:
        raise ValueError("no path specified")
    
    start_list = os.path.abspath(start).split(os.path.sep)
    path_list = os.path.abspath(path).split(os.path.sep)

    # Work out how much of the filepath is shared by start and path.
    i = len(os.path.commonprefix([start_list, path_list]))

    rel_list = [os.path.pardir] * (len(start_list)-i) + path_list[i:]
    if not rel_list:
        return os.path.curdir
    return os.path.join(*rel_list)

if os.path is sys.modules.get('ntpath'):
    relpath = _relpath_nt
else:
    relpath = _relpath_posix

########NEW FILE########
__FILENAME__ = loader
"""Loading unittests."""

import os
import re
import sys
import traceback
import types
import unittest

from fnmatch import fnmatch

from garlicsim.general_misc.third_party.unittest2 import case, suite

try:
    from os.path import relpath
except ImportError:
    from garlicsim.general_misc.third_party.unittest2.compatibility import relpath

__unittest = True


def _CmpToKey(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) == -1
    return K


# what about .pyc or .pyo (etc)
# we would need to avoid loading the same tests multiple times
# from '.py', '.pyc' *and* '.pyo'
VALID_MODULE_NAME = re.compile(r'[_a-z]\w*\.py$', re.IGNORECASE)


def _make_failed_import_test(name, suiteClass):
    message = 'Failed to import test module: %s' % name
    if hasattr(traceback, 'format_exc'):
        # Python 2.3 compatibility
        # format_exc returns two frames of discover.py as well
        message += '\n%s' % traceback.format_exc()
    return _make_failed_test('ModuleImportFailure', name, ImportError(message),
                             suiteClass)

def _make_failed_load_tests(name, exception, suiteClass):
    return _make_failed_test('LoadTestsFailure', name, exception, suiteClass)

def _make_failed_test(classname, methodname, exception, suiteClass):
    def testFailure(self):
        raise exception
    attrs = {methodname: testFailure}
    TestClass = type(classname, (case.TestCase,), attrs)
    return suiteClass((TestClass(methodname),))
    

class TestLoader(unittest.TestLoader):
    """
    This class is responsible for loading tests according to various criteria
    and returning them wrapped in a TestSuite
    """
    testMethodPrefix = 'test'
    sortTestMethodsUsing = cmp
    suiteClass = suite.TestSuite
    _top_level_dir = None

    def loadTestsFromTestCase(self, testCaseClass):
        """Return a suite of all tests cases contained in testCaseClass"""
        if issubclass(testCaseClass, suite.TestSuite):
            raise TypeError("Test cases should not be derived from TestSuite."
                            " Maybe you meant to derive from TestCase?")
        testCaseNames = self.getTestCaseNames(testCaseClass)
        if not testCaseNames and hasattr(testCaseClass, 'runTest'):
            testCaseNames = ['runTest']
        loaded_suite = self.suiteClass(map(testCaseClass, testCaseNames))
        return loaded_suite

    def loadTestsFromModule(self, module, use_load_tests=True):
        """Return a suite of all tests cases contained in the given module"""
        tests = []
        for name in dir(module):
            obj = getattr(module, name)
            if isinstance(obj, type) and issubclass(obj, unittest.TestCase):
                tests.append(self.loadTestsFromTestCase(obj))

        load_tests = getattr(module, 'load_tests', None)
        tests = self.suiteClass(tests)
        if use_load_tests and load_tests is not None:
            try:
                return load_tests(self, tests, None)
            except Exception, e:
                return _make_failed_load_tests(module.__name__, e,
                                               self.suiteClass)
        return tests

    def loadTestsFromName(self, name, module=None):
        """Return a suite of all tests cases given a string specifier.

        The name may resolve either to a module, a test case class, a
        test method within a test case class, or a callable object which
        returns a TestCase or TestSuite instance.

        The method optionally resolves the names relative to a given module.
        """
        parts = name.split('.')
        if module is None:
            parts_copy = parts[:]
            while parts_copy:
                try:
                    module = __import__('.'.join(parts_copy))
                    break
                except ImportError:
                    del parts_copy[-1]
                    if not parts_copy:
                        raise
            parts = parts[1:]
        obj = module
        for part in parts:
            parent, obj = obj, getattr(obj, part)

        if isinstance(obj, types.ModuleType):
            return self.loadTestsFromModule(obj)
        elif isinstance(obj, type) and issubclass(obj, unittest.TestCase):
            return self.loadTestsFromTestCase(obj)
        elif (isinstance(obj, types.UnboundMethodType) and
              isinstance(parent, type) and
              issubclass(parent, case.TestCase)):
            return self.suiteClass([parent(obj.__name__)])
        elif isinstance(obj, unittest.TestSuite):
            return obj
        elif hasattr(obj, '__call__'):
            test = obj()
            if isinstance(test, unittest.TestSuite):
                return test
            elif isinstance(test, unittest.TestCase):
                return self.suiteClass([test])
            else:
                raise TypeError("calling %s returned %s, not a test" %
                                (obj, test))
        else:
            raise TypeError("don't know how to make test from: %s" % obj)

    def loadTestsFromNames(self, names, module=None):
        """Return a suite of all tests cases found using the given sequence
        of string specifiers. See 'loadTestsFromName()'.
        """
        suites = [self.loadTestsFromName(name, module) for name in names]
        return self.suiteClass(suites)

    def getTestCaseNames(self, testCaseClass):
        """Return a sorted sequence of method names found within testCaseClass
        """
        def isTestMethod(attrname, testCaseClass=testCaseClass,
                         prefix=self.testMethodPrefix):
            return attrname.startswith(prefix) and \
                hasattr(getattr(testCaseClass, attrname), '__call__')
        testFnNames = filter(isTestMethod, dir(testCaseClass))
        if self.sortTestMethodsUsing:
            testFnNames.sort(key=_CmpToKey(self.sortTestMethodsUsing))
        return testFnNames

    def discover(self, start_dir, pattern='test*.py', top_level_dir=None):
        """Find and return all test modules from the specified start
        directory, recursing into subdirectories to find them. Only test files
        that match the pattern will be loaded. (Using shell style pattern
        matching.)

        All test modules must be importable from the top level of the project.
        If the start directory is not the top level directory then the top
        level directory must be specified separately.

        If a test package name (directory with '__init__.py') matches the
        pattern then the package will be checked for a 'load_tests' function. If
        this exists then it will be called with loader, tests, pattern.

        If load_tests exists then discovery does  *not* recurse into the package,
        load_tests is responsible for loading all tests in the package.

        The pattern is deliberately not stored as a loader attribute so that
        packages can continue discovery themselves. top_level_dir is stored so
        load_tests does not need to pass this argument in to loader.discover().
        """
        set_implicit_top = False
        if top_level_dir is None and self._top_level_dir is not None:
            # make top_level_dir optional if called from load_tests in a package
            top_level_dir = self._top_level_dir
        elif top_level_dir is None:
            set_implicit_top = True
            top_level_dir = start_dir

        top_level_dir = os.path.abspath(top_level_dir)

        if not top_level_dir in sys.path:
            # all test modules must be importable from the top level directory
            # should we *unconditionally* put the start directory in first
            # in sys.path to minimise likelihood of conflicts between installed
            # modules and development versions?
            sys.path.insert(0, top_level_dir)
        self._top_level_dir = top_level_dir

        is_not_importable = False
        if os.path.isdir(os.path.abspath(start_dir)):
            start_dir = os.path.abspath(start_dir)
            if start_dir != top_level_dir:
                is_not_importable = not os.path.isfile(os.path.join(start_dir, '__init__.py'))
        else:
            # support for discovery from dotted module names
            try:
                __import__(start_dir)
            except ImportError:
                is_not_importable = True
            else:
                the_module = sys.modules[start_dir]
                top_part = start_dir.split('.')[0]
                start_dir = os.path.abspath(os.path.dirname((the_module.__file__)))
                if set_implicit_top:
                    self._top_level_dir = os.path.abspath(os.path.dirname(os.path.dirname(sys.modules[top_part].__file__)))
                    sys.path.remove(top_level_dir)

        if is_not_importable:
            raise ImportError('Start directory is not importable: %r' % start_dir)

        tests = list(self._find_tests(start_dir, pattern))
        return self.suiteClass(tests)

    def _get_name_from_path(self, path):
        path = os.path.splitext(os.path.normpath(path))[0]

        _relpath = relpath(path, self._top_level_dir)
        assert not os.path.isabs(_relpath), "Path must be within the project"
        assert not _relpath.startswith('..'), "Path must be within the project"

        name = _relpath.replace(os.path.sep, '.')
        return name

    def _get_module_from_name(self, name):
        __import__(name)
        return sys.modules[name]

    def _match_path(self, path, full_path, pattern):
        # override this method to use alternative matching strategy
        return fnmatch(path, pattern)
    
    def _find_tests(self, start_dir, pattern):
        """Used by discovery. Yields test suites it loads."""
        paths = os.listdir(start_dir)

        for path in paths:
            full_path = os.path.join(start_dir, path)
            if os.path.isfile(full_path):
                if not VALID_MODULE_NAME.match(path):
                    # valid Python identifiers only
                    continue
                if not self._match_path(path, full_path, pattern):
                    continue
                # if the test file matches, load it
                name = self._get_name_from_path(full_path)
                try:
                    module = self._get_module_from_name(name)
                except:
                    yield _make_failed_import_test(name, self.suiteClass)
                else:
                    mod_file = os.path.abspath(getattr(module, '__file__', full_path))
                    realpath = os.path.splitext(mod_file)[0]
                    fullpath_noext = os.path.splitext(full_path)[0]
                    if realpath.lower() != fullpath_noext.lower():
                        module_dir = os.path.dirname(realpath)
                        mod_name = os.path.splitext(os.path.basename(full_path))[0]
                        expected_dir = os.path.dirname(full_path)
                        msg = ("%r module incorrectly imported from %r. Expected %r. "
                               "Is this module globally installed?")
                        raise ImportError(msg % (mod_name, module_dir, expected_dir))
                    yield self.loadTestsFromModule(module)
            elif os.path.isdir(full_path):
                if not os.path.isfile(os.path.join(full_path, '__init__.py')):
                    continue

                load_tests = None
                tests = None
                if fnmatch(path, pattern):
                    # only check load_tests if the package directory itself matches the filter
                    name = self._get_name_from_path(full_path)
                    package = self._get_module_from_name(name)
                    load_tests = getattr(package, 'load_tests', None)
                    tests = self.loadTestsFromModule(package, use_load_tests=False)

                if load_tests is None:
                    if tests is not None:
                        # tests loaded from package file
                        yield tests
                    # recurse into the package
                    for test in self._find_tests(full_path, pattern):
                        yield test
                else:
                    try:
                        yield load_tests(self, tests, pattern)
                    except Exception, e:
                        yield _make_failed_load_tests(package.__name__, e,
                                                      self.suiteClass)

defaultTestLoader = TestLoader()


def _makeLoader(prefix, sortUsing, suiteClass=None):
    loader = TestLoader()
    loader.sortTestMethodsUsing = sortUsing
    loader.testMethodPrefix = prefix
    if suiteClass:
        loader.suiteClass = suiteClass
    return loader

def getTestCaseNames(testCaseClass, prefix, sortUsing=cmp):
    return _makeLoader(prefix, sortUsing).getTestCaseNames(testCaseClass)

def makeSuite(testCaseClass, prefix='test', sortUsing=cmp,
              suiteClass=suite.TestSuite):
    return _makeLoader(prefix, sortUsing, suiteClass).loadTestsFromTestCase(testCaseClass)

def findTestCases(module, prefix='test', sortUsing=cmp,
                  suiteClass=suite.TestSuite):
    return _makeLoader(prefix, sortUsing, suiteClass).loadTestsFromModule(module)

########NEW FILE########
__FILENAME__ = main
"""Unittest main program"""

import sys
import os
import types

from garlicsim.general_misc.third_party.unittest2 import loader, runner
try:
    from garlicsim.general_misc.third_party.unittest2.signals import installHandler
except ImportError:
    installHandler = None

__unittest = True

FAILFAST     = "  -f, --failfast   Stop on first failure\n"
CATCHBREAK   = "  -c, --catch      Catch control-C and display results\n"
BUFFEROUTPUT = "  -b, --buffer     Buffer stdout and stderr during test runs\n"

USAGE_AS_MAIN = """\
Usage: %(progName)s [options] [tests]

Options:
  -h, --help       Show this message
  -v, --verbose    Verbose output
  -q, --quiet      Minimal output
%(failfast)s%(catchbreak)s%(buffer)s
Examples:
  %(progName)s test_module                       - run tests from test_module
  %(progName)s test_module.TestClass             - run tests from
                                                   test_module.TestClass
  %(progName)s test_module.TestClass.test_method - run specified test method

[tests] can be a list of any number of test modules, classes and test
methods.

Alternative Usage: %(progName)s discover [options]

Options:
  -v, --verbose    Verbose output
%(failfast)s%(catchbreak)s%(buffer)s  -s directory     Directory to start discovery ('.' default)
  -p pattern       Pattern to match test files ('test*.py' default)
  -t directory     Top level directory of project (default to
                   start directory)

For test discovery all test modules must be importable from the top
level directory of the project.
"""

USAGE_FROM_MODULE = """\
Usage: %(progName)s [options] [test] [...]

Options:
  -h, --help       Show this message
  -v, --verbose    Verbose output
  -q, --quiet      Minimal output
%(failfast)s%(catchbreak)s%(buffer)s
Examples:
  %(progName)s                               - run default set of tests
  %(progName)s MyTestSuite                   - run suite 'MyTestSuite'
  %(progName)s MyTestCase.testSomething      - run MyTestCase.testSomething
  %(progName)s MyTestCase                    - run all 'test*' test methods
                                               in MyTestCase
"""


class TestProgram(object):
    """A command-line program that runs a set of tests; this is primarily
       for making test modules conveniently executable.
    """
    USAGE = USAGE_FROM_MODULE
    
    # defaults for testing
    failfast = catchbreak = buffer = progName = None

    def __init__(self, module='__main__', defaultTest=None,
                 argv=None, testRunner=None,
                 testLoader=loader.defaultTestLoader, exit=True,
                 verbosity=1, failfast=None, catchbreak=None, buffer=None):
        if isinstance(module, basestring):
            self.module = __import__(module)
            for part in module.split('.')[1:]:
                self.module = getattr(self.module, part)
        else:
            self.module = module
        if argv is None:
            argv = sys.argv

        self.exit = exit
        self.verbosity = verbosity
        self.failfast = failfast
        self.catchbreak = catchbreak
        self.buffer = buffer
        self.defaultTest = defaultTest
        self.testRunner = testRunner
        self.testLoader = testLoader
        self.progName = os.path.basename(argv[0])
        self.parseArgs(argv)
        self.runTests()

    def usageExit(self, msg=None):
        if msg:
            print msg
        usage = {'progName': self.progName, 'catchbreak': '', 'failfast': '',
                 'buffer': ''}
        if self.failfast != False:
            usage['failfast'] = FAILFAST
        if self.catchbreak != False and installHandler is not None:
            usage['catchbreak'] = CATCHBREAK
        if self.buffer != False:
            usage['buffer'] = BUFFEROUTPUT
        print self.USAGE % usage
        sys.exit(2)

    def parseArgs(self, argv):
        if len(argv) > 1 and argv[1].lower() == 'discover':
            self._do_discovery(argv[2:])
            return

        import getopt
        long_opts = ['help', 'verbose', 'quiet', 'failfast', 'catch', 'buffer']
        try:
            options, args = getopt.getopt(argv[1:], 'hHvqfcb', long_opts)
            for opt, value in options:
                if opt in ('-h','-H','--help'):
                    self.usageExit()
                if opt in ('-q','--quiet'):
                    self.verbosity = 0
                if opt in ('-v','--verbose'):
                    self.verbosity = 2
                if opt in ('-f','--failfast'):
                    if self.failfast is None:
                        self.failfast = True
                    # Should this raise an exception if -f is not valid?
                if opt in ('-c','--catch'):
                    if self.catchbreak is None and installHandler is not None:
                        self.catchbreak = True
                    # Should this raise an exception if -c is not valid?
                if opt in ('-b','--buffer'):
                    if self.buffer is None:
                        self.buffer = True
                    # Should this raise an exception if -b is not valid?
            if len(args) == 0 and self.defaultTest is None:
                # createTests will load tests from self.module
                self.testNames = None
            elif len(args) > 0:
                self.testNames = args
                if __name__ == '__main__':
                    # to support python -m unittest ...
                    self.module = None
            else:
                self.testNames = (self.defaultTest,)
            self.createTests()
        except getopt.error, msg:
            self.usageExit(msg)

    def createTests(self):
        if self.testNames is None:
            self.test = self.testLoader.loadTestsFromModule(self.module)
        else:
            self.test = self.testLoader.loadTestsFromNames(self.testNames,
                                                           self.module)

    def _do_discovery(self, argv, Loader=loader.TestLoader):
        # handle command line args for test discovery
        self.progName = '%s discover' % self.progName
        import optparse
        parser = optparse.OptionParser()
        parser.prog = self.progName
        parser.add_option('-v', '--verbose', dest='verbose', default=False,
                          help='Verbose output', action='store_true')
        if self.failfast != False:
            parser.add_option('-f', '--failfast', dest='failfast', default=False,
                              help='Stop on first fail or error', 
                              action='store_true')
        if self.catchbreak != False and installHandler is not None:
            parser.add_option('-c', '--catch', dest='catchbreak', default=False,
                              help='Catch ctrl-C and display results so far', 
                              action='store_true')
        if self.buffer != False:
            parser.add_option('-b', '--buffer', dest='buffer', default=False,
                              help='Buffer stdout and stderr during tests', 
                              action='store_true')
        parser.add_option('-s', '--start-directory', dest='start', default='.',
                          help="Directory to start discovery ('.' default)")
        parser.add_option('-p', '--pattern', dest='pattern', default='test*.py',
                          help="Pattern to match tests ('test*.py' default)")
        parser.add_option('-t', '--top-level-directory', dest='top', default=None,
                          help='Top level directory of project (defaults to start directory)')

        options, args = parser.parse_args(argv)
        if len(args) > 3:
            self.usageExit()

        for name, value in zip(('start', 'pattern', 'top'), args):
            setattr(options, name, value)
        
        # only set options from the parsing here
        # if they weren't set explicitly in the constructor
        if self.failfast is None:
            self.failfast = options.failfast
        if self.catchbreak is None and installHandler is not None:
            self.catchbreak = options.catchbreak
        if self.buffer is None:
            self.buffer = options.buffer
        
        if options.verbose:
            self.verbosity = 2

        start_dir = options.start
        pattern = options.pattern
        top_level_dir = options.top

        loader = Loader()
        self.test = loader.discover(start_dir, pattern, top_level_dir)

    def runTests(self):
        if self.catchbreak:
            installHandler()
        if self.testRunner is None:
            self.testRunner = runner.TextTestRunner
        if isinstance(self.testRunner, (type, types.ClassType)):
            try:
                testRunner = self.testRunner(verbosity=self.verbosity,
                                             failfast=self.failfast,
                                             buffer=self.buffer)
            except TypeError:
                # didn't accept the verbosity, buffer or failfast arguments
                testRunner = self.testRunner()
        else:
            # it is assumed to be a TestRunner instance
            testRunner = self.testRunner
        self.result = testRunner.run(self.test)
        if self.exit:
            sys.exit(not self.result.wasSuccessful())

main = TestProgram

def main_():
    TestProgram.USAGE = USAGE_AS_MAIN
    main(module=None)


########NEW FILE########
__FILENAME__ = result
"""Test result object"""

import sys
import traceback
import unittest

from StringIO import StringIO

from garlicsim.general_misc.third_party.unittest2 import util
from garlicsim.general_misc.third_party.unittest2.compatibility import wraps

__unittest = True

def failfast(method):
    @wraps(method)
    def inner(self, *args, **kw):
        if getattr(self, 'failfast', False):
            self.stop()
        return method(self, *args, **kw)
    return inner


STDOUT_LINE = '\nStdout:\n%s'
STDERR_LINE = '\nStderr:\n%s'

class TestResult(unittest.TestResult):
    """Holder for test result information.

    Test results are automatically managed by the TestCase and TestSuite
    classes, and do not need to be explicitly manipulated by writers of tests.

    Each instance holds the total number of tests run, and collections of
    failures and errors that occurred among those test runs. The collections
    contain tuples of (testcase, exceptioninfo), where exceptioninfo is the
    formatted traceback of the error that occurred.
    """
    _previousTestClass = None
    _moduleSetUpFailed = False
    
    def __init__(self):
        self.failfast = False
        self.failures = []
        self.errors = []
        self.testsRun = 0
        self.skipped = []
        self.expectedFailures = []
        self.unexpectedSuccesses = []
        self.shouldStop = False
        self.buffer = False
        self._stdout_buffer = None
        self._stderr_buffer = None
        self._original_stdout = sys.stdout
        self._original_stderr = sys.stderr
        self._mirrorOutput = False
    
    def startTest(self, test):
        "Called when the given test is about to be run"
        self.testsRun += 1
        self._mirrorOutput = False
        if self.buffer:
            if self._stderr_buffer is None:
                self._stderr_buffer = StringIO()
                self._stdout_buffer = StringIO()
            sys.stdout = self._stdout_buffer
            sys.stderr = self._stderr_buffer

    def startTestRun(self):
        """Called once before any tests are executed.

        See startTest for a method called before each test.
        """

    def stopTest(self, test):
        """Called when the given test has been run"""
        if self.buffer:
            if self._mirrorOutput:
                output = sys.stdout.getvalue()
                error = sys.stderr.getvalue()
                if output:
                    if not output.endswith('\n'):
                        output += '\n'
                    self._original_stdout.write(STDOUT_LINE % output)
                if error:
                    if not error.endswith('\n'):
                        error += '\n'
                    self._original_stderr.write(STDERR_LINE % error)
                
            sys.stdout = self._original_stdout
            sys.stderr = self._original_stderr
            self._stdout_buffer.seek(0)
            self._stdout_buffer.truncate()
            self._stderr_buffer.seek(0)
            self._stderr_buffer.truncate()
        self._mirrorOutput = False
        

    def stopTestRun(self):
        """Called once after all tests are executed.

        See stopTest for a method called after each test.
        """

    @failfast
    def addError(self, test, err):
        """Called when an error has occurred. 'err' is a tuple of values as
        returned by sys.exc_info().
        """
        self.errors.append((test, self._exc_info_to_string(err, test)))
        self._mirrorOutput = True

    @failfast
    def addFailure(self, test, err):
        """Called when an error has occurred. 'err' is a tuple of values as
        returned by sys.exc_info()."""
        self.failures.append((test, self._exc_info_to_string(err, test)))
        self._mirrorOutput = True

    def addSuccess(self, test):
        "Called when a test has completed successfully"
        pass

    def addSkip(self, test, reason):
        """Called when a test is skipped."""
        self.skipped.append((test, reason))

    def addExpectedFailure(self, test, err):
        """Called when an expected failure/error occured."""
        self.expectedFailures.append(
            (test, self._exc_info_to_string(err, test)))

    @failfast
    def addUnexpectedSuccess(self, test):
        """Called when a test was expected to fail, but succeed."""
        self.unexpectedSuccesses.append(test)

    def wasSuccessful(self):
        "Tells whether or not this result was a success"
        return (len(self.failures) + len(self.errors) == 0)

    def stop(self):
        "Indicates that the tests should be aborted"
        self.shouldStop = True

    def _exc_info_to_string(self, err, test):
        """Converts a sys.exc_info()-style tuple of values into a string."""
        exctype, value, tb = err
        # Skip test runner traceback levels
        while tb and self._is_relevant_tb_level(tb):
            tb = tb.tb_next
        if exctype is test.failureException:
            # Skip assert*() traceback levels
            length = self._count_relevant_tb_levels(tb)
            msgLines = traceback.format_exception(exctype, value, tb, length)
        else:
            msgLines = traceback.format_exception(exctype, value, tb)
        
        if self.buffer:
            output = sys.stdout.getvalue()
            error = sys.stderr.getvalue()            
            if output:
                if not output.endswith('\n'):
                    output += '\n'
                msgLines.append(STDOUT_LINE % output)
            if error:
                if not error.endswith('\n'):
                    error += '\n'
                msgLines.append(STDERR_LINE % error)
        return ''.join(msgLines)

    def _is_relevant_tb_level(self, tb):
        return '__unittest' in tb.tb_frame.f_globals

    def _count_relevant_tb_levels(self, tb):
        length = 0
        while tb and not self._is_relevant_tb_level(tb):
            length += 1
            tb = tb.tb_next
        return length

    def __repr__(self):
        return "<%s run=%i errors=%i failures=%i>" % \
               (util.strclass(self.__class__), self.testsRun, len(self.errors),
                len(self.failures))

########NEW FILE########
__FILENAME__ = runner
"""Running tests"""

import sys
import time
import unittest

from garlicsim.general_misc.third_party.unittest2 import result

try:
    from garlicsim.general_misc.third_party.unittest2.signals import registerResult
except ImportError:
    def registerResult(_):
        pass
    
__unittest = True


class _WritelnDecorator(object):
    """Used to decorate file-like objects with a handy 'writeln' method"""
    def __init__(self,stream):
        self.stream = stream

    def __getattr__(self, attr):
        if attr in ('stream', '__getstate__'):
            raise AttributeError(attr)
        return getattr(self.stream,attr)

    def writeln(self, arg=None):
        if arg:
            self.write(arg)
        self.write('\n') # text-mode streams translate to \r\n if needed


class TextTestResult(result.TestResult):
    """A test result class that can print formatted text results to a stream.

    Used by TextTestRunner.
    """
    separator1 = '=' * 70
    separator2 = '-' * 70

    def __init__(self, stream, descriptions, verbosity):
        super(TextTestResult, self).__init__()
        self.stream = stream
        self.showAll = verbosity > 1
        self.dots = verbosity == 1
        self.descriptions = descriptions

    def getDescription(self, test):
        doc_first_line = test.shortDescription()
        if self.descriptions and doc_first_line:
            return '\n'.join((str(test), doc_first_line))
        else:
            return str(test)

    def startTest(self, test):
        super(TextTestResult, self).startTest(test)
        if self.showAll:
            self.stream.write(self.getDescription(test))
            self.stream.write(" ... ")
            self.stream.flush()

    def addSuccess(self, test):
        super(TextTestResult, self).addSuccess(test)
        if self.showAll:
            self.stream.writeln("ok")
        elif self.dots:
            self.stream.write('.')
            self.stream.flush()

    def addError(self, test, err):
        super(TextTestResult, self).addError(test, err)
        if self.showAll:
            self.stream.writeln("ERROR")
        elif self.dots:
            self.stream.write('E')
            self.stream.flush()

    def addFailure(self, test, err):
        super(TextTestResult, self).addFailure(test, err)
        if self.showAll:
            self.stream.writeln("FAIL")
        elif self.dots:
            self.stream.write('F')
            self.stream.flush()

    def addSkip(self, test, reason):
        super(TextTestResult, self).addSkip(test, reason)
        if self.showAll:
            self.stream.writeln("skipped %r" % (reason,))
        elif self.dots:
            self.stream.write("s")
            self.stream.flush()

    def addExpectedFailure(self, test, err):
        super(TextTestResult, self).addExpectedFailure(test, err)
        if self.showAll:
            self.stream.writeln("expected failure")
        elif self.dots:
            self.stream.write("x")
            self.stream.flush()

    def addUnexpectedSuccess(self, test):
        super(TextTestResult, self).addUnexpectedSuccess(test)
        if self.showAll:
            self.stream.writeln("unexpected success")
        elif self.dots:
            self.stream.write("u")
            self.stream.flush()

    def printErrors(self):
        if self.dots or self.showAll:
            self.stream.writeln()
        self.printErrorList('ERROR', self.errors)
        self.printErrorList('FAIL', self.failures)

    def printErrorList(self, flavour, errors):
        for test, err in errors:
            self.stream.writeln(self.separator1)
            self.stream.writeln("%s: %s" % (flavour, self.getDescription(test)))
            self.stream.writeln(self.separator2)
            self.stream.writeln("%s" % err)

    def stopTestRun(self):
        super(TextTestResult, self).stopTestRun()
        self.printErrors()


class TextTestRunner(unittest.TextTestRunner):
    """A test runner class that displays results in textual form.

    It prints out the names of tests as they are run, errors as they
    occur, and a summary of the results at the end of the test run.
    """
    resultclass = TextTestResult

    def __init__(self, stream=sys.stderr, descriptions=True, verbosity=1,
                    failfast=False, buffer=False, resultclass=None):
        self.stream = _WritelnDecorator(stream)
        self.descriptions = descriptions
        self.verbosity = verbosity
        self.failfast = failfast
        self.buffer = buffer
        if resultclass is not None:
            self.resultclass = resultclass

    def _makeResult(self):
        return self.resultclass(self.stream, self.descriptions, self.verbosity)

    def run(self, test):
        "Run the given test case or test suite."
        result = self._makeResult()
        result.failfast = self.failfast
        result.buffer = self.buffer
        registerResult(result)
        
        startTime = time.time()
        startTestRun = getattr(result, 'startTestRun', None)
        if startTestRun is not None:
            startTestRun()
        try:
            test(result)
        finally:
            stopTestRun = getattr(result, 'stopTestRun', None)
            if stopTestRun is not None:
                stopTestRun()
            else:
                result.printErrors()
        stopTime = time.time()
        timeTaken = stopTime - startTime
        if hasattr(result, 'separator2'):
            self.stream.writeln(result.separator2)
        run = result.testsRun
        self.stream.writeln("Ran %d test%s in %.3fs" %
                            (run, run != 1 and "s" or "", timeTaken))
        self.stream.writeln()
        
        expectedFails = unexpectedSuccesses = skipped = 0
        try:
            results = map(len, (result.expectedFailures,
                                result.unexpectedSuccesses,
                                result.skipped))
            expectedFails, unexpectedSuccesses, skipped = results
        except AttributeError:
            pass
        infos = []
        if not result.wasSuccessful():
            self.stream.write("FAILED")
            failed, errored = map(len, (result.failures, result.errors))
            if failed:
                infos.append("failures=%d" % failed)
            if errored:
                infos.append("errors=%d" % errored)
        else:
            self.stream.write("OK")
        if skipped:
            infos.append("skipped=%d" % skipped)
        if expectedFails:
            infos.append("expected failures=%d" % expectedFails)
        if unexpectedSuccesses:
            infos.append("unexpected successes=%d" % unexpectedSuccesses)
        if infos:
            self.stream.writeln(" (%s)" % (", ".join(infos),))
        else:
            self.stream.write("\n")
        return result

########NEW FILE########
__FILENAME__ = signals
import signal
import weakref

from garlicsim.general_misc.third_party.unittest2.compatibility import wraps

__unittest = True


class _InterruptHandler(object):
    def __init__(self, default_handler):
        self.called = False
        self.default_handler = default_handler

    def __call__(self, signum, frame):
        installed_handler = signal.getsignal(signal.SIGINT)
        if installed_handler is not self:
            # if we aren't the installed handler, then delegate immediately
            # to the default handler
            self.default_handler(signum, frame)
            
        if self.called:
            self.default_handler(signum, frame)
        self.called = True
        for result in _results.keys():
            result.stop()

_results = weakref.WeakKeyDictionary()
def registerResult(result):
    _results[result] = 1

def removeResult(result):
    return bool(_results.pop(result, None))

_interrupt_handler = None
def installHandler():
    global _interrupt_handler
    if _interrupt_handler is None:
        default_handler = signal.getsignal(signal.SIGINT)
        _interrupt_handler = _InterruptHandler(default_handler)
        signal.signal(signal.SIGINT, _interrupt_handler)


def removeHandler(method=None):
    if method is not None:
        @wraps(method)
        def inner(*args, **kwargs):
            initial = signal.getsignal(signal.SIGINT)
            removeHandler()
            try:
                return method(*args, **kwargs)
            finally:
                signal.signal(signal.SIGINT, initial)
        return inner

    global _interrupt_handler
    if _interrupt_handler is not None:
        signal.signal(signal.SIGINT, _interrupt_handler.default_handler)

########NEW FILE########
__FILENAME__ = suite
"""TestSuite"""

import sys
import unittest
from garlicsim.general_misc.third_party.unittest2 import case, util

__unittest = True


class BaseTestSuite(unittest.TestSuite):
    """A simple test suite that doesn't provide class or module shared fixtures.
    """
    def __init__(self, tests=()):
        self._tests = []
        self.addTests(tests)

    def __repr__(self):
        return "<%s tests=%s>" % (util.strclass(self.__class__), list(self))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return NotImplemented
        return list(self) == list(other)

    def __ne__(self, other):
        return not self == other

    # Can't guarantee hash invariant, so flag as unhashable
    __hash__ = None

    def __iter__(self):
        return iter(self._tests)

    def countTestCases(self):
        cases = 0
        for test in self:
            cases += test.countTestCases()
        return cases

    def addTest(self, test):
        # sanity checks
        if not hasattr(test, '__call__'):
            raise TypeError("%r is not callable" % (repr(test),))
        if isinstance(test, type) and issubclass(test,
                                                 (case.TestCase, TestSuite)):
            raise TypeError("TestCases and TestSuites must be instantiated "
                            "before passing them to addTest()")
        self._tests.append(test)

    def addTests(self, tests):
        if isinstance(tests, basestring):
            raise TypeError("tests must be an iterable of tests, not a string")
        for test in tests:
            self.addTest(test)

    def run(self, result):
        for test in self:
            if result.shouldStop:
                break
            test(result)
        return result

    def __call__(self, *args, **kwds):
        return self.run(*args, **kwds)

    def debug(self):
        """Run the tests without collecting errors in a TestResult"""
        for test in self:
            test.debug()


class TestSuite(BaseTestSuite):
    """A test suite is a composite test consisting of a number of TestCases.

    For use, create an instance of TestSuite, then add test case instances.
    When all tests have been added, the suite can be passed to a test
    runner, such as TextTestRunner. It will run the individual test cases
    in the order in which they were added, aggregating the results. When
    subclassing, do not forget to call the base class constructor.
    """
    

    def run(self, result):
        self._wrapped_run(result)
        self._tearDownPreviousClass(None, result)
        self._handleModuleTearDown(result)
        return result

    def debug(self):
        """Run the tests without collecting errors in a TestResult"""
        debug = _DebugResult()
        self._wrapped_run(debug, True)
        self._tearDownPreviousClass(None, debug)
        self._handleModuleTearDown(debug)

    ################################
    # private methods
    def _wrapped_run(self, result, debug=False):
        for test in self:
            if result.shouldStop:
                break
            
            if _isnotsuite(test):
                self._tearDownPreviousClass(test, result)
                self._handleModuleFixture(test, result)
                self._handleClassSetUp(test, result)
                result._previousTestClass = test.__class__
                
                if (getattr(test.__class__, '_classSetupFailed', False) or 
                    getattr(result, '_moduleSetUpFailed', False)):
                    continue
            
            if hasattr(test, '_wrapped_run'):
                test._wrapped_run(result, debug)
            elif not debug:
                test(result)
            else:
                test.debug()
    
    def _handleClassSetUp(self, test, result):
        previousClass = getattr(result, '_previousTestClass', None)
        currentClass = test.__class__
        if currentClass == previousClass:
            return
        if result._moduleSetUpFailed:
            return
        if getattr(currentClass, "__unittest_skip__", False):
            return
        
        try:
            currentClass._classSetupFailed = False
        except TypeError:
            # test may actually be a function
            # so its class will be a builtin-type
            pass
            
        setUpClass = getattr(currentClass, 'setUpClass', None)
        if setUpClass is not None:
            try:
                setUpClass()
            except Exception, e:
                if isinstance(result, _DebugResult):
                    raise
                currentClass._classSetupFailed = True
                className = util.strclass(currentClass)
                errorName = 'setUpClass (%s)' % className
                self._addClassOrModuleLevelException(result, e, errorName)
    
    def _get_previous_module(self, result):
        previousModule = None
        previousClass = getattr(result, '_previousTestClass', None)
        if previousClass is not None:
            previousModule = previousClass.__module__
        return previousModule
        
        
    def _handleModuleFixture(self, test, result):
        previousModule = self._get_previous_module(result)
        currentModule = test.__class__.__module__
        if currentModule == previousModule:
            return
        
        self._handleModuleTearDown(result)

        
        result._moduleSetUpFailed = False
        try:
            module = sys.modules[currentModule]
        except KeyError:
            return
        setUpModule = getattr(module, 'setUpModule', None)
        if setUpModule is not None:
            try:
                setUpModule()
            except Exception, e:
                if isinstance(result, _DebugResult):
                    raise
                result._moduleSetUpFailed = True
                errorName = 'setUpModule (%s)' % currentModule
                self._addClassOrModuleLevelException(result, e, errorName)

    def _addClassOrModuleLevelException(self, result, exception, errorName):
        error = _ErrorHolder(errorName)
        addSkip = getattr(result, 'addSkip', None)
        if addSkip is not None and isinstance(exception, case.SkipTest):
            addSkip(error, str(exception))
        else:
            result.addError(error, sys.exc_info())
    
    def _handleModuleTearDown(self, result):
        previousModule = self._get_previous_module(result)
        if previousModule is None:
            return
        if result._moduleSetUpFailed:
            return
            
        try:
            module = sys.modules[previousModule]
        except KeyError:
            return

        tearDownModule = getattr(module, 'tearDownModule', None)
        if tearDownModule is not None:
            try:
                tearDownModule()
            except Exception, e:
                if isinstance(result, _DebugResult):
                    raise
                errorName = 'tearDownModule (%s)' % previousModule
                self._addClassOrModuleLevelException(result, e, errorName)
    
    def _tearDownPreviousClass(self, test, result):
        previousClass = getattr(result, '_previousTestClass', None)
        currentClass = test.__class__
        if currentClass == previousClass:
            return
        if getattr(previousClass, '_classSetupFailed', False):
            return
        if getattr(result, '_moduleSetUpFailed', False):
            return
        if getattr(previousClass, "__unittest_skip__", False):
            return
        
        tearDownClass = getattr(previousClass, 'tearDownClass', None)
        if tearDownClass is not None:
            try:
                tearDownClass()
            except Exception, e:
                if isinstance(result, _DebugResult):
                    raise
                className = util.strclass(previousClass)
                errorName = 'tearDownClass (%s)' % className
                self._addClassOrModuleLevelException(result, e, errorName)


class _ErrorHolder(object):
    """
    Placeholder for a TestCase inside a result. As far as a TestResult
    is concerned, this looks exactly like a unit test. Used to insert
    arbitrary errors into a test suite run.
    """
    # Inspired by the ErrorHolder from Twisted:
    # http://twistedmatrix.com/trac/browser/trunk/twisted/trial/runner.py

    # attribute used by TestResult._exc_info_to_string
    failureException = None

    def __init__(self, description):
        self.description = description

    def id(self):
        return self.description

    def shortDescription(self):
        return None

    def __repr__(self):
        return "<ErrorHolder description=%r>" % (self.description,)

    def __str__(self):
        return self.id()

    def run(self, result):
        # could call result.addError(...) - but this test-like object
        # shouldn't be run anyway
        pass

    def __call__(self, result):
        return self.run(result)

    def countTestCases(self):
        return 0

def _isnotsuite(test):
    "A crude way to tell apart testcases and suites with duck-typing"
    try:
        iter(test)
    except TypeError:
        return True
    return False


class _DebugResult(object):
    "Used by the TestSuite to hold previous class when running in debug."
    _previousTestClass = None
    _moduleSetUpFailed = False
    shouldStop = False

########NEW FILE########
__FILENAME__ = util
"""Various utility functions."""

__unittest = True


_MAX_LENGTH = 80
def safe_repr(obj, short=False):
    try:
        result = repr(obj)
    except Exception:
        result = object.__repr__(obj)
    if not short or len(result) < _MAX_LENGTH:
        return result
    return result[:_MAX_LENGTH] + ' [truncated]...'

def safe_str(obj):
    try:
        return str(obj)
    except Exception:
        return object.__str__(obj)

def strclass(cls):
    return "%s.%s" % (cls.__module__, cls.__name__)

def sorted_list_difference(expected, actual):
    """Finds elements in only one or the other of two, sorted input lists.

    Returns a two-element tuple of lists.    The first list contains those
    elements in the "expected" list but not in the "actual" list, and the
    second contains those elements in the "actual" list but not in the
    "expected" list.    Duplicate elements in either input list are ignored.
    """
    i = j = 0
    missing = []
    unexpected = []
    while True:
        try:
            e = expected[i]
            a = actual[j]
            if e < a:
                missing.append(e)
                i += 1
                while expected[i] == e:
                    i += 1
            elif e > a:
                unexpected.append(a)
                j += 1
                while actual[j] == a:
                    j += 1
            else:
                i += 1
                try:
                    while expected[i] == e:
                        i += 1
                finally:
                    j += 1
                    while actual[j] == a:
                        j += 1
        except IndexError:
            missing.extend(expected[i:])
            unexpected.extend(actual[j:])
            break
    return missing, unexpected

def unorderable_list_difference(expected, actual, ignore_duplicate=False):
    """Same behavior as sorted_list_difference but
    for lists of unorderable items (like dicts).

    As it does a linear search per item (remove) it
    has O(n*n) performance.
    """
    missing = []
    unexpected = []
    while expected:
        item = expected.pop()
        try:
            actual.remove(item)
        except ValueError:
            missing.append(item)
        if ignore_duplicate:
            for lst in expected, actual:
                try:
                    while True:
                        lst.remove(item)
                except ValueError:
                    pass
    if ignore_duplicate:
        while actual:
            item = actual.pop()
            unexpected.append(item)
            try:
                while True:
                    actual.remove(item)
            except ValueError:
                pass
        return missing, unexpected

    # anything left in actual is unexpected
    return missing, actual

########NEW FILE########
__FILENAME__ = __main__
"""Main entry point"""

import sys
if sys.argv[0].endswith("__main__.py"):
    sys.argv[0] = "unittest2"

__unittest = True

from garlicsim.general_misc.third_party.unittest2.main import main_
main_()

########NEW FILE########
__FILENAME__ = count_calls
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `count_calls` decorator.

See its documentation for more details.
'''

from garlicsim.general_misc import decorator_tools


def count_calls(function):
    '''
    Decorator for counting the calls made to a function.

    The number of calls is available in the decorated function's `.call_count`
    attribute.
    
    Example usage:
    
        >>> @count_calls
        ... def f(x):
        ...     return x*x
        ... 
        >>> f(3)
        9
        >>> f(6)
        36
        >>> f.call_count
        2
        >>> f(9)
        81
        >>> f.call_count
        3
    
    '''
    def _count_calls(function, *args, **kwargs):
        decorated_function.call_count += 1
        return function(*args, **kwargs)
    
    decorated_function = decorator_tools.decorator(_count_calls, function)
    
    decorated_function.call_count = 0
    
    return decorated_function


########NEW FILE########
__FILENAME__ = temp_function_call_counter
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `TempFunctionCallCounter` context manager.

See its documentation for more details.
'''

import sys

from garlicsim.general_misc import cute_iter_tools
from garlicsim.general_misc import address_tools

from garlicsim.general_misc.temp_value_setters import TempValueSetter
from .count_calls import count_calls


class TempFunctionCallCounter(TempValueSetter):
    '''
    Temporarily counts the number of calls made to a function.
    
    Example:
    
        f()
        with TempFunctionCallCounter(f) as counter:
            f()
            f()
        assert counter.call_count == 2
        
    '''
    
    def __init__(self, function):
        '''
        Construct the `TempFunctionCallCounter`.
        
        For `function`, you may pass in either a function object, or a
        `(parent_object, function_name)` pair, or a `(getter, setter)` pair.
        '''
        
        if cute_iter_tools.is_iterable(function):
            first, second = function
            if isinstance(second, basestring):
                actual_function = getattr(first, second)
            else:
                assert callable(first) and callable(second)
                actual_function = first() # `first` is the getter in this case.
                
        else: # not cute_iter_tools.is_iterable(function)
            assert callable(function)
            actual_function = function
            try:
                address = address_tools.object_to_string.get_address(function)
                parent_object_address, function_name = address.rsplit('.', 1)
                parent_object = address_tools.resolve(parent_object_address)
            except Exception:
                raise Exception("Couldn't obtain parent/name pair from "
                                "function; supply one manually or "
                                "alternatively supply a getter/setter pair.")
            first, second = parent_object, function_name
            
        self.call_counting_function = count_calls(actual_function)
        
        TempValueSetter.__init__(
            self,
            (first, second),
            value=self.call_counting_function
        )
        
        
    call_count = property(
        lambda self: getattr(self.call_counting_function, 'call_count', 0)
    )
    '''The number of calls that were made to the function.'''
    
    
########NEW FILE########
__FILENAME__ = version_info
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `VersionInfo` class.

See its documentation for more details.
'''

from operator import itemgetter as _itemgetter
from garlicsim.general_misc.nifty_collections import OrderedDict


class VersionInfo(tuple):
    '''
    Version number. This is a variation on a `namedtuple`.
    
    Example:
    
        VersionInfo(1, 2, 0) == \
            VersionInfo(major=1, minor=2, micro=0) == \
            (1, 2, 0)
    '''
    
    __slots__ = () 

    
    _fields = ('major', 'minor', 'micro') 

    
    def __new__(_cls, major, minor, micro):
        '''Create new instance of VersionInfo(major, minor, micro).'''
        return tuple.__new__(_cls, (major, minor, micro)) 

    
    @classmethod
    def _make(cls, iterable, new=tuple.__new__, len=len):
        '''Make a new VersionInfo object from a sequence or iterable.'''
        result = new(cls, iterable)
        if len(result) != 3:
            raise TypeError('Expected 3 arguments, got %d' % len(result))
        return result 

    
    def __repr__(self):
        '''Return a nicely formatted representation string.'''
        return 'VersionInfo(major=%r, minor=%r, micro=%r)' % self 

    
    def _asdict(self):
        '''Return a new OrderedDict which maps field names to their values.'''
        return OrderedDict(zip(self._fields, self)) 

    
    def _replace(_self, **kwargs):
        '''
        Make a VersionInfo object replacing specified fields with new values.
        '''
        result = \
            _self._make(map(kwargs.pop, ('major', 'minor', 'micro'),_self))
        if kwargs:
            raise ValueError('Got unexpected field names: %r' % kwargs.keys())
        return result 
    
    
    def __getnewargs__(self):
        '''Return self as a plain tuple.  Used by copy and pickle.'''
        return tuple(self) 
    
    
    major = property(_itemgetter(0), doc='Alias for field number 0')
    
    
    minor = property(_itemgetter(1), doc='Alias for field number 1')
    
    
    micro = property(_itemgetter(2), doc='Alias for field number 2')
########NEW FILE########
__FILENAME__ = auto_clock_generator
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `AutoClockGenerator` class.

See its documentation for more info.
'''

from garlicsim.general_misc import decorator_tools


__all__ = ['AutoClockGenerator']


@decorator_tools.decorator
def store(method, *args, **kwargs):
    '''Decorator for saving current state's clock for next autoclocking.'''
    self = args[0]
    result = method(*args, **kwargs)
    self.last_state_clock = result
    return result


class AutoClockGenerator(object):
    '''
    Device for ensuring that states have good clock readings.
    
    This is useful so the user could be lazy and not write code that advances
    the clock reading of a state.
    
    If we get a state with no clock reading, we give it a clock reading of one
    plus the last state's clock reading.
    
    If `detect_static` is set to `True`, we give the same treatment to states
    that have a clock reading which is identical to the last state's.
    '''
    
    def __init__(self, detect_static=False):
        '''
        Construct the auto-clock generator.
        
        If `detect_static` is set to `True`, we also check if a state's clock
        is is identical to the last state's clock. If so we advance it by one.
        '''
        self.last_state_clock = None
        self.detect_static = detect_static
        
        
    @store
    def make_clock(self, state):
        '''
        Obtain a clock reading for given state.
        
        If the state already has one, return it; if not, return the clock
        reading of the last state plus one; if this is the first state, return
        0.
        
        Important: The new clock is not added to the state. The state is not
        modified at all. The clock reading is merely returned and the user may
        attach it to the state himself.
        '''
        if hasattr(state, 'clock'):
            if not self.detect_static:
                return state.clock
            else: # self.detect_static is True
                if state.clock == self.last_state_clock:
                    return state.clock + 1
                else:
                    return state.clock
        else:
            if self.last_state_clock is not None: # can be 0
                return self.last_state_clock + 1
            else:       
                return 0
            
            
########NEW FILE########
__FILENAME__ = base_history_browser
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `BaseHistoryBrowser` class.

See its documentation for more info.
'''

import garlicsim.general_misc.third_party.abc as abc
from garlicsim.general_misc import binary_search


__all__ = ['BaseHistoryBrowser']


get_state_clock = lambda state: state.clock


class BaseHistoryBrowser(object):
    '''
    A device for requesting information about the history of the simulation.

    With a `HistoryBrowser` one can request states from the simulation's
    timeline. States can be requested by clock time or position in the timeline
    or by other measures; see documentation for this class's methods.
    
    This is an abstract base class from which all history browsers should
    subclass.
    '''
    
    __metaclass__ = abc.ABCMeta

    
    @abc.abstractmethod
    def get_last_state(self):
        '''
        Get the last state in the timeline.
        
        Identical to `.__getitem__(-1).`
        '''

        
    @abc.abstractmethod
    def __getitem__(self, i):
        '''Get a state by its position in the timeline.'''

                
    @abc.abstractmethod
    def get_state_by_monotonic_function(self, function, value, rounding):
        '''
        Get a state by specifying a measure function and a desired value.
        
        The function must be a monotonic rising function on the timeline.
        
        See documentation of `garlicsim.general_misc.binary_search.roundings`
        for details about rounding options.
        '''
        
        
    @abc.abstractmethod
    def __len__(self):
        '''Get the length of the timeline in nodes.'''
    
        
    def get_state_by_clock(self, clock, rounding=binary_search.CLOSEST):
        '''
        Get a state by specifying desired clock time.
        
        See documentation of `garlicsim.general_misc.binary_search.roundings`
        for details about rounding options.
        '''
        assert issubclass(rounding, binary_search.Rounding)
        return self.get_state_by_monotonic_function\
               (function=get_state_clock, value=clock, rounding=rounding)
    
    
########NEW FILE########
__FILENAME__ = base_step_iterator
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `BaseStepIterator` class.

See its documentation for more information.
'''

import copy

from garlicsim.general_misc.third_party import abc
from garlicsim.general_misc.third_party.abcs_collection import Iterator

import garlicsim


class BaseStepIterator(Iterator, object):
    '''
    An iterator that uses a simpack's step function to produce states.
    
    A step iterator uses the simpack's original step function (or generator)
    under the hood.
    
    The step iterator automatically adds `.clock` readings if the states
    produced by the step function are missing them.
    
    This is an abstract base class; the `garlicsim.misc.step_iterators` package
    contains a collection of step iterators, one for each step type.
    '''
    __metaclass__ = abc.ABCMeta

    
    @abc.abstractmethod
    def __init__(self, state_or_history_browser, step_profile):
        pass

    
    @abc.abstractmethod
    def next(self):
        '''Crunch the next state.'''
        
########NEW FILE########
__FILENAME__ = decorators
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `history_cache` decorator.

See its documentation for more information.
'''

# todo perhaps reorganize
#todo: make sure the cache gets lost on pickling

from __future__ import with_statement

import weakref
import functools

import garlicsim


def history_cache(function, *args, **kwargs):
    '''
    Caching decorator for functions that take a history browser.
    
    This decorator should be used only on functions that have exactly one
    argument which is a history browser. (For example, in a cellular automata
    simulation you might want a function that takes a history browser and tells
    you how many cells changed value between the most recent state and the one
    before it.)
    
    Note that the raw function will take a history browser, but the decorated
    function will take a node, for which a history browser will be created and
    fed into the original function.
    
    On any subsequent calls to the function given the same node, the
    pre-calcluated value will be given from the cache instead of calculating it
    again.
    '''
    if hasattr(function, 'node_cache'):
        return function
    
    def cached(node):
        assert isinstance(node, garlicsim.data_structures.Node)
        if node in cached.node_cache:
            return cached.node_cache[node]
        else:
            path = node.make_containing_path()
            with node.tree.lock.read:
                history_browser = \
                    garlicsim.synchronous_crunching.HistoryBrowser(
                        path=path,
                        tail_node=node
                    )
            value = function(history_browser)
            cached.node_cache[node] = value
            return value
            
    cached.node_cache = weakref.WeakKeyDictionary()
    
    functools.update_wrapper(cached, function)
    cached.__wrapped__ = function
    
    return cached

########NEW FILE########
__FILENAME__ = exceptions
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Defines a collection of exceptions.'''

from garlicsim.general_misc.exceptions import CuteException


class GarlicSimException(CuteException):
    '''GarlicSim-related exception.'''

class GarlicSimWarning(Warning):
    '''GarlicSim-related warning.'''
    

class InvalidSimpack(GarlicSimException):
    '''Trying to load an invalid simpack.'''

class SimpackError(GarlicSimException):
    '''A simpack behaved unexpectedly.'''
    
class WorldEnded(GarlicSimException):
    '''The simulation has ended.'''

    
del CuteException
########NEW FILE########
__FILENAME__ = nodes_added
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `NodesAdded` class.

See its documentation for more information.
'''

class NodesAdded(int):
    '''
    `sync_crunchers` functions return a `NodesAdded` object instead of an int.
    
    `NodesAdded` is just a subclass of `int` which has a nice `__repr__` saying
    '<7 nodes were added to the tree>' instead of just '7'.
    '''    
    # todo: this class is borderline redundant. Also, I think Maciej said not
    # to subclass builtin types in his pycon talk.
    def __repr__(self):
        return '<' + int.__repr__(self) + ' nodes were added to the tree>'
    
    def __add__(self, other):
        # If it's being added to another `NodesAdded`, keep it as a
        # `NodesAdded` object.
        int_result = int.__add__(self, other)
        if isinstance(other, NodesAdded):
            return NodesAdded(int_result)
        else:
            return int_result
        
    __radd__ = __add__
    
    def __sub__(self, other):
        # If it's being substracted with another `NodesAdded`, keep it as a
        # `NodesAdded` object.
        int_result = int.__sub__(self, other)
        if isinstance(other, NodesAdded):
            return NodesAdded(int_result)
        else:
            return int_result
        
    __rsub__ = __sub__
    
    def __pos__(self):
        return self
    
    def __neg__(self):
        return NodesAdded(int.__neg__(self))
            
########NEW FILE########
__FILENAME__ = settings
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Defines settings.'''


class Setting(object):
    '''
    A setting.
    
    These are used as classes without insantiating.
    '''

class DeterminismSetting(Setting):
    '''
    A setting of determinism.
    
    When `garlicsim` knows that a certain step profile is deterministic, it can
    help it analyze the simulation. For example, it lets GarlicSim detect when
    the simulation has reached a constant/repetitive state.
    '''

class UNDETERMINISTIC(DeterminismSetting):
    '''Completely not deterministic -- has a random element.'''

class SUPPOSEDLY_DETERMINISTIC(DeterminismSetting):
    '''
    Means deterministic in principle, but not absolutely.
    
    For example, in some simpacks rounding errors may make states that should
    otherwise be equal not be equal.
    '''
    # todo: possibly rename, use thesaurus

class DETERMINISTIC(DeterminismSetting):
    '''
    Absolutely deterministic.
    
    There is no random or fuzzy element in the step function, and given
    identical input states it is guaranteed to return identical output states.
    '''


########NEW FILE########
__FILENAME__ = misc
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Defines miscellaneous objects for `simpack_grokker`.'''


def default_determinism_function(step_profile):
    '''
    The default determinism function.
    
    Just returns `None`, meaning we have no idea whether the step profile is
    deterministic.
    '''
    return None


class DefaultCRUNCHERS(object):
    '''The default `CRUNCHERS` setting, which just asks the simpack grokker.'''
    def __init__(self, simpack_grokker):
        self.simpack_grokker = simpack_grokker
    def __call__(self, cruncher_type):
        return cruncher_type.can_be_used_with_simpack_grokker(
            self.simpack_grokker
        )


########NEW FILE########
__FILENAME__ = settings
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `Settings` class.

See its documentation for more info.
'''

from . import misc

class Settings(object):
    '''A set of settings for a simpack.'''
    # todo: subclass from a pretty vars-shower
    
    def __init__(self, simpack_grokker):
        
        self.CRUNCHERS = misc.DefaultCRUNCHERS(simpack_grokker)
        '''
        Crunchers that this simpack says it can use.
        
        Crunchers can be specified in different ways. You may specify a
        cruncher type, or the string name of a cruncher type, or a list of
        either of those, or a filter function for cruncher types.
        
        This is useful because some simpacks can't be used with certain kinds
        of crunchers.
        '''
        
        self.DETERMINISM_FUNCTION = misc.default_determinism_function
        '''
        Function that takes a step profile and says whether it's deterministic.
        
        What this function says is, "If you do a simulation using this step
        profile, then you will have a deterministic simulation." (Or
        undeterministic, depends on the step profile.)
        
        This is useful because it allows `garlicsim` to detect if a simulation
        has reached a repititive state, so it can stop the crunching right
        there and avoid wasting resources.

        Note that this function does not return `True` or `False`: It returns a
        `DeterminismSetting` class. For details about those, see documentation
        in `garlicsim.misc.settings_constants.settings`.
        
        The function will return `None` if it's unknown whether the step
        profile is deterministic.
        '''

        self.SCALAR_STATE_FUNCTIONS = []
        '''
        List of scalar state functions given by the simpack.
        
        A scalar state function is a function from a state to a real number.
        It's recommended to decorate these with
        `garlicsim.general_misc.caching.cache`
        '''
        
        self.SCALAR_HISTORY_FUNCTIONS = []
        '''
        List of scalar history functions given by the simpack.
        
        A scalar history function is a function from a history browser to a
        real number. These should be decorated by
        `garlicsim.misc.cached.history_cache`.
        '''
########NEW FILE########
__FILENAME__ = simpack_grokker
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `SimpackGrokker` class.

See its documentation for more details.
'''

import types

from garlicsim.general_misc import import_tools
from garlicsim.general_misc import misc_tools
from garlicsim.general_misc import cute_iter_tools
from garlicsim.general_misc.reasoned_bool import ReasonedBool
from garlicsim.general_misc.nifty_collections import OrderedDict
from garlicsim.general_misc import caching

import garlicsim
from garlicsim.misc import InvalidSimpack, simpack_tools
from garlicsim.misc import step_iterators as step_iterators_module
from . import misc

from .settings import Settings
from .step_type import StepType
from . import step_types


class SimpackGrokker(object):
    '''Encapsulates a simpack and gives useful information and tools.'''
    
    __metaclass__ = caching.CachedType

    @staticmethod
    def create_from_state(state):
        '''
        Create a simpack grokker from a state object, possibly using cached.
        '''
        simpack = simpack_tools.get_from_state(state)
        return SimpackGrokker(simpack)
    
    
    def __init__(self, simpack):
        self.simpack = simpack
        self.__init_analysis()
        self.__init_analysis_settings()
        self.__init_analysis_cruncher_types()

        
    def __init_analysis(self):
        '''Analyze the simpack.'''
        
        simpack = self.simpack
        
        try:
            State = simpack.State
        except AttributeError:
            raise InvalidSimpack("The `%s` simpack does not define a `State` "
                                 "class." % simpack.__name__.rsplit('.')[-1])
        
        if not misc_tools.is_subclass(State, garlicsim.data_structures.State):
            raise InvalidSimpack("The `%s` simpack defines a `State` class, "
                                 "but it's not a subclass of "
                                 "`garlicsim.data_structures.State`." % \
                                 simpack.__name__.rsplit('.')[-1])


        state_methods = dict(
            (name, value) for (name, value) in
            misc_tools.getted_vars(State).iteritems() if callable(value)
        )

        self.step_functions_by_type = dict((step_type, []) for step_type in
                                           step_types.step_types_list)
        '''dict mapping from each step type to step functions of that type.'''
        
        
        for method in state_methods.itervalues():
            step_type = StepType.get_step_type(method)
            if step_type:
                self.step_functions_by_type[step_type].append(method)
            
                
        if self.step_functions_by_type[step_types.HistoryStep] or \
           self.step_functions_by_type[step_types.HistoryStepGenerator]:
            
            self.history_dependent = True

            self.all_step_functions = (
                self.step_functions_by_type[step_types.HistoryStepGenerator] +
                self.step_functions_by_type[step_types.HistoryStep]
            )
            
            if (self.step_functions_by_type[step_types.SimpleStep] or
                self.step_functions_by_type[step_types.StepGenerator] or
                self.step_functions_by_type[step_types.InplaceStep] or
                self.step_functions_by_type[step_types.InplaceStepGenerator]):
                
                raise InvalidSimpack("The `%s` simpack is defining both a "
                                     "history-dependent step and a "
                                     "non-history-dependent step - which "
                                     "is forbidden." % \
                                     simpack.__name__.rsplit('.')[-1])
        else: # No history step defined
            
            self.history_dependent = False
            
            self.all_step_functions = (
                self.step_functions_by_type[step_types.StepGenerator] + \
                self.step_functions_by_type[step_types.SimpleStep] + \
                self.step_functions_by_type[step_types.InplaceStepGenerator] +\
                self.step_functions_by_type[step_types.InplaceStep]
            )
            
            
        # (no-op assignments, just for docs:)
        
        self.history_dependent = self.history_dependent
        '''Flag saying whether the simpack looks at previous states.'''
        
        self.all_step_functions = self.all_step_functions
        '''
        All the step functions that the simpack provides, sorted by priority.
        '''
               
        if not self.all_step_functions:
            raise InvalidSimpack("The `%s` simpack has not defined any kind "
                                 "of step function." % \
                                 simpack.__name__.rsplit('.')[-1])
        
        self.default_step_function = self.all_step_functions[0]
        '''
        The default step function. Will be used if we don't specify another.
        '''
        
        
    def __init_analysis_settings(self):
        '''Analyze the simpack to produce a Settings object.'''
        # todo: consider doing this in `Settings.__init__`
        
        # We want to access the `.settings` of our simpack, but we don't know
        # if our simpack is a module or some other kind of object. So if it's a
        # module, we'll `try` to import `settings`.
        
        self.settings = Settings(self)
        
        if isinstance(self.simpack, types.ModuleType) and \
           not hasattr(self.simpack, 'settings'):
            
            # The `if` that we did here means: "If there's reason to suspect
            # that `self.simpack.settings` is a module that exists but hasn't
            # been imported yet."
            
            settings_module_name = ''.join((
                self.simpack.__name__,
                '.settings'
            ))
            
            import_tools.import_if_exists(settings_module_name,
                                          silent_fail=True)
            # This imports the `settings` submodule, if it exists, but it
            # does *not* keep a reference to it. We'll access `settings` as
            # an attribute of the simpack below.
            
        # Checking if there are original settings at all. If there aren't,
        # we're done.
        if hasattr(self.simpack, 'settings'):
            
            original_settings = getattr(self.simpack, 'settings')
            
            for setting_name in vars(self.settings).keys():
                if hasattr(original_settings, setting_name):
                    value = getattr(original_settings, setting_name)
                    setattr(self.settings, setting_name, value)
            # todo: currently throws away unrecognized attributes from the
            # simpack's settings.
                

    def __init_analysis_cruncher_types(self):
        '''Figure out which crunchers this simpack can use.'''
        
        # todo: possibly fix `CRUNCHERS` to some canonical state in `.settings`
        from garlicsim.asynchronous_crunching import crunchers, BaseCruncher
        simpack = self.simpack
        
        self.cruncher_types_availability = OrderedDict()
        '''dict mapping from cruncher type to whether it can be used.'''
        
        self.available_cruncher_types = []
        '''The cruncher types that this simpack can use.'''
        
        CRUNCHERS = self.settings.CRUNCHERS

        
        if isinstance(CRUNCHERS, basestring):
            (cruncher_type,) = \
                [cruncher_type_ for cruncher_type_ in
                 crunchers.cruncher_types_list if
                 cruncher_type_.__name__ == CRUNCHERS]
            self.available_cruncher_types = [cruncher_type]
            self.cruncher_types_availability[cruncher_type] = True
        
            ### Giving unavailability reasons: ################################
            #                                                                 #
            unavailable_cruncher_types = \
                [cruncher_type_ for cruncher_type_ in
                 crunchers.cruncher_types_list if cruncher_type_ not in
                 self.available_cruncher_types]
            self.cruncher_types_availability.update(dict(
                (
                    unavailable_cruncher_type,
                    ReasonedBool(
                        False,
                        'The `%s` simpack specified `%s` as the only '
                        'available cruncher type.' % \
                        (simpack.__name__.rsplit('.')[-1],
                         cruncher_type.__name__)
                    )
                ) for unavailable_cruncher_type in unavailable_cruncher_types
            ))
            #                                                                 #
            ###################################################################

        
        elif misc_tools.is_subclass(CRUNCHERS, BaseCruncher):
            cruncher_type = CRUNCHERS
            self.available_cruncher_types = [cruncher_type]
            self.cruncher_types_availability[cruncher_type] = True
            
            ### Giving unavailability reasons: ################################
            #                                                                 #
            unavailable_cruncher_types = \
                [cruncher_type_ for cruncher_type_ in
                 crunchers.cruncher_types_list if cruncher_type_ not in
                 self.available_cruncher_types]
            self.cruncher_types_availability.update(dict(
                (
                    unavailable_cruncher_type,
                    ReasonedBool(
                        False,
                        'The `%s` simpack specified `%s` as the only '
                        'available cruncher type.' % \
                        (simpack.__name__.rsplit('.')[-1],
                         cruncher_type.__name__)
                    )
                ) for unavailable_cruncher_type in unavailable_cruncher_types
            ))
            #                                                                 #
            ###################################################################
            
        
        elif cute_iter_tools.is_iterable(CRUNCHERS):
            self.available_cruncher_types = []
            for item in CRUNCHERS:
                if isinstance(item, basestring):
                    (cruncher_type,) = \
                        [cruncher_type_ for cruncher_type_ in
                         crunchers.cruncher_types_list if
                         cruncher_type_.__name__ == item]
                else:
                    assert misc_tools.is_subclass(item, BaseCruncher)
                    cruncher_type = item
                self.available_cruncher_types.append(cruncher_type)
                self.cruncher_types_availability[cruncher_type] = True

            ### Giving unavailability reasons: ################################
            #                                                                 #
            unavailable_cruncher_types = \
                [cruncher_type_ for cruncher_type_ in
                 crunchers.cruncher_types_list if cruncher_type_ not in
                 self.available_cruncher_types]
            self.cruncher_types_availability.update(dict(
                (
                    unavailable_cruncher_type,
                    ReasonedBool(
                        False,
                        'The `%s` simpack specified a list of available '
                        'crunchers and `%s` is not in it.' % \
                        (simpack.__name__.rsplit('.')[-1],
                         unavailable_cruncher_type.__name__)
                    )
                    
                ) for unavailable_cruncher_type in unavailable_cruncher_types
            ))
            #                                                                 #
            ###################################################################
            
        
        elif callable(CRUNCHERS):
            assert not isinstance(CRUNCHERS, BaseCruncher)
            self.available_cruncher_types = \
                [cruncher_type_ for cruncher_type_ in
                 crunchers.cruncher_types_list if
                 CRUNCHERS(cruncher_type_)]
            for available_cruncher_type in self.available_cruncher_types:
                self.cruncher_types_availability[available_cruncher_type] = \
                    True
            
            ### Giving unavailability reasons: ################################
            #                                                                 #
            unavailable_cruncher_types = \
                [cruncher_type_ for cruncher_type_ in
                 crunchers.cruncher_types_list if cruncher_type_ not in
                 self.available_cruncher_types]
            for unavailable_cruncher_type in unavailable_cruncher_types:
                reason = getattr(
                    CRUNCHERS(unavailable_cruncher_type),
                    'reason',
                    'No reason was given for `%s` not being accepted.' % \
                    unavailable_cruncher_type.__name__
                )
                self.cruncher_types_availability[
                    unavailable_cruncher_type
                    ] = ReasonedBool(False, reason)
            #                                                                 #
            ###################################################################
            
        #######################################################################
            
        else:
            raise InvalidSimpack("The `CRUNCHERS` setting must be either a "
                                 "cruncher type (or name string), a list of "
                                 "cruncher types, or a filter function for "
                                 "cruncher types. You supplied `%s`, which is "
                                 "neither." % CRUNCHERS)

        
    def step(self, state_or_history_browser, step_profile):
        '''
        Perform a step of the simulation.
        
        The step profile will specify which parameters to pass to the simpack's
        step function.
        '''
        # todo: probably inefficient, but this method is probably not used much
        # anyway.
        
        step_iterator = self.get_step_iterator(state_or_history_browser,
                                               step_profile)
        return step_iterator.next()
    
            
    def get_step_iterator(self, state_or_history_browser, step_profile):
        '''
        Get a step iterator for crunching states of the simulation.
        
        The step profile will specify which parameters to pass to the simpack's
        step function.
        '''
        
        step_function = step_profile.step_function
        step_type = StepType.get_step_type(step_function)
        
        return step_type.step_iterator_class(state_or_history_browser,
                                             step_profile)
        
    
    def get_inplace_step_iterator(self, state, step_profile):
        '''
        Get an inplace step iterator which modifies the state in place.
        
        On every iteration of the inplace step iterator, `state` will be
        changed to be the next moment in the simulation. No new state objects
        will be created.
        
        This can only be used with inplace step functions.
        '''
        
        step_function = step_profile.step_function
        step_type = StepType.get_step_type(step_function)
        
        if step_type not in (step_types.InplaceStep,
                             step_types.InplaceStepGenerator):
            raise Exception("Can't get an inplace step iterator for the step "
                            "function you're using, because it's not an "
                            "inplace step function, it's a %s." % 
                            step_type.verbose_name)
        
        return step_type.inplace_step_iterator_class(
            state,
            step_profile
        )
    
    
    def is_inplace_iterator_available(self, step_profile):
        '''
        Return whether `step_profile` allows using an inplace step iterator.
        
        Only step profiles that use an inplace step function (or generator)
        allow using inplace step iterators.
        '''
        step_function = step_profile.step_function
        step_type = StepType.get_step_type(step_function)
        
        return (step_type in (step_types.InplaceStep,
                              step_types.InplaceStepGenerator))
        
    

    def build_step_profile(self, *args, **kwargs):
        '''
        Build a step profile smartly.
        
        The canonical way to build a step profile is to provide it with a step
        function, `*args` and `**kwargs`. But in this function we're being a
        little smarter so the user will have less work.
        
        You do not need to enter a step function; we will use the default one,
        unless you specify a different one as `step_function`.
        
        You may also pass in a step profile as `step_profile`, and it will be
        noticed and used.
        '''
        parse_arguments_to_step_profile = \
            garlicsim.misc.StepProfile.build_parser(
                self.default_step_function
            )
        
        step_profile = parse_arguments_to_step_profile(*args, **kwargs)
        return step_profile

########NEW FILE########
__FILENAME__ = step_type
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `StepType` class and its base instance, `BaseStep`.

See its documentation for more details.
'''
# todo: does this mixed abc enforce anything, with our custom `__call__`?
# todo: allow function with 'step' to opt-out of being a step function

import types

from garlicsim.general_misc.third_party import abc

from garlicsim.general_misc import logic_tools
from garlicsim.general_misc import caching


class StepType(abc.ABCMeta):
    '''
    A type of step function.
    
    There are several different types of step functions with different
    advantages and disadvantages. See the
    `garlicsim.misc.simpack_grokker.step_types` package for a collection of
    various step types.
    
    You don't need to interact with step types (i.e. instances of this
    metaclass) in order to make step functions; if they have the appropriate
    name identifier in their name, they will be associated with a step type
    automaticaly. For example, a function called `meow_step_generator` will
    automatically be identified as a `StepGenerator`. (Which is one example of
    an instance of this metaclass.) So `isinstance(meow_step_generator,
    StepGenerator)` will be `True` and
    `StepType.get_step_type(meow_step_generator)` will be `StepGenerator`.
    
    One place where you do need to use this class is if your step function has
    a custom name. For example, you have a function `yambambula` and you want
    it to be identified as a `StepGenerator`. So you define it like this:
    
        @garlicsim.misc.simpack_grokker.step_types.StepGenerator
        def yambambula(self):
           ...
    
    Then the `yambambula` function will be identified as a step generator.
    '''

    def __call__(cls, step_function):
        '''
        Create a step function.
        
        Only necessary for step functions that don't have a valid name
        identifier (like "step") in their name.
        
        Usually used as a decorator.
        '''
        
        step_function._BaseStepType__step_type = cls
        return step_function

    
    def __instancecheck__(cls, thing):
        '''
        Check whether `thing` is a step function of this type.
        
        Given the base class `BaseType` as `cls`, it will check whether `thing`
        is a step function in general.
        '''
        
        step_type = StepType.get_step_type(thing)
        if step_type:
            return issubclass(step_type, cls)
        else:
            assert step_type is None
            return False
        
    
    @staticmethod
    def get_step_type(thing):
        '''Get what type of step function `thing` is.'''
        
        if hasattr(thing, '_BaseStepType__step_type'):
            return thing._BaseStepType__step_type
        
        if not callable(thing) or not hasattr(thing, '__name__'):
            return None
        
        step_types = BaseStep.__subclasses__()
        
        all_name_identifiers = [cls_.name_identifier for cls_ in step_types]        
                
        matching_name_identifiers = \
            [name_identifier for name_identifier in all_name_identifiers if
             name_identifier in thing.__name__]
        
        if not matching_name_identifiers:
            step_type = None
                    
        else:
            (maximal_matching_name_identifier,) = logic_tools.logic_max(
                matching_name_identifiers,
                relation=str.__contains__
            )
            
            (step_type,) = \
                [step_type for step_type in step_types if
                 step_type.name_identifier == maximal_matching_name_identifier]
        
        actual_function = (
            thing.im_func if
            isinstance(thing, types.MethodType)
            else thing
        )
        actual_function._BaseStepType__step_type = step_type
            
        return step_type
        
                
class BaseStep(object):
    '''Abstract step function. See documentation of `StepType`.'''
    
    __metaclass__ = StepType


    name_identifier = abc.abstractproperty()
    '''
    String that automatically identifies a step function's type.
    
    For example, `StepGenerator` has a `.name_identifier` of
    `'step_generator'`, so any function containing it (like
    `my_cool_step_generator`) will be automatically identified as a step
    generator.
    '''
    
    
    verbose_name = abc.abstractproperty()
    '''The verbose name of the step type.'''

    
    step_iterator_class = abc.abstractproperty()
    '''The step iterator class used for steps of this step type.'''    
    
    
########NEW FILE########
__FILENAME__ = step_types
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
A collection of step types.

See documentation for
`garlicsim.misc.simpack_grokker.step_type.StepType` for more details.
'''

from .step_type import BaseStep
from garlicsim.misc import step_iterators


class SimpleStep(BaseStep):
    '''The simplest step function. Takes a state and returns a new one.'''
    step_iterator_class = step_iterators.StepIterator
    name_identifier = 'step'
    verbose_name = 'simple step function'


class StepGenerator(BaseStep):
    '''
    A step generator takes an initial state and keeps yielding states from it.
    
    Some steps are easier to write as a step generator, because every time they
    yield a state they remember in which line they paused and what the values
    of all the local variables are.
    '''
    step_iterator_class = step_iterators.StepGeneratorIterator
    name_identifier = 'step_generator'
    verbose_name = 'step generator'
    
    
class HistoryStep(BaseStep):
    '''
    A history step function takes a history browser and returns a new state.
    
    The advantage of the history function is that it allows looking not only at
    the last state but at all the states in the timeline. This is necessary for
    some types of simulations.
    '''
    step_iterator_class = step_iterators.HistoryStepIterator
    name_identifier = 'history_step'
    verbose_name = 'history step function'


class HistoryStepGenerator(BaseStep):
    '''
    A history step generator takes a history browser and yields new states.
    
    This combines the advantages of a history step function and a step
    generator; it works as a generator which can be more convenient and it can
    look at the simulation history which is necessary for some simulations.
    
    (1.1.2011 - Not yet implemented, sorry.)
    '''
    step_iterator_class = NotImplemented
    name_identifier = 'history_step_generator'
    verbose_name = 'history step generator'
    
    
class InplaceStep(BaseStep):
    '''
    Inplace step function takes a state and modifies it to be the next state.
    
    The advantage of the inplace step function is that it doesn't need to
    create a new state object, so it may have better performance than a simple
    step function. But if the user still wants it to create new state objects,
    (which is necessary in order to make a tree,) `garlicsim` will
    automatically `deepcopy` all the states given from the inplace step
    function. So it can be used both ways.
    '''
    step_iterator_class = step_iterators.DuplicatingStepIterator
    inplace_step_iterator_class = step_iterators.InplaceStepIterator
    name_identifier = 'inplace_step'
    verbose_name = 'inplace step function'
    
    
class InplaceStepGenerator(BaseStep):
    '''
    Inplace step generator is a step generator that does the step in-place.
    
    On every iteration, the inplace step generator modifies the current state
    to be the next state.
    
    The inplace step generator combines the advantages an inplace step function
    and a step generator: It works as a generator which can be more convenient
    and it allows modifying the state in-place to improve performance.
    '''
    step_iterator_class = step_iterators.DuplicatingStepGeneratorIterator
    inplace_step_iterator_class = step_iterators.InplaceStepGeneratorIterator
    name_identifier = 'inplace_step_generator'
    verbose_name = 'inplace step generator'


step_types_list = [SimpleStep, StepGenerator, HistoryStep,
                   HistoryStepGenerator, InplaceStep, InplaceStepGenerator]
'''List of all the step types.'''

########NEW FILE########
__FILENAME__ = simpack_tools
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Defines various tools for working with simpacks.'''

from garlicsim.general_misc import address_tools
from garlicsim.general_misc import import_tools
from garlicsim.general_misc import caching

import garlicsim.misc.simpack_grokker


def get_from_state(state):
    '''Find the simpack that a state class (or a state instance) belong to.'''
    state_class = state if isinstance(state, type) else type(state)
    return _get_from_state_class(state_class)
    

@caching.cache()
def _get_from_state_class(state_class):
    '''
    Find the simpack that a state class belongs to.
    
    Internal use.
    '''
    assert state_class.__name__ == 'State' # remove this limitation
    short_address = address_tools.describe(state_class, shorten=True)
    simpack_name = '.'.join(short_address.split('.')[:-1])
    simpack = import_tools.normal_import(simpack_name)
        
    garlicsim.misc.simpack_grokker.SimpackGrokker(simpack)
    # Not saving the reference: But it'll get cached because `SimpackGrokker`
    # is a `CachedType`.
        
    return simpack

########NEW FILE########
__FILENAME__ = state_deepcopy
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `StateCopy` class and `state_deepcopy` function.

See their documentation for more information.
'''

import copy

from garlicsim.general_misc.copy_mode import CopyMode
from garlicsim.general_misc.persistent import DontCopyPersistent


class StateCopy(DontCopyPersistent, CopyMode):
    '''
    A copy mode used in a step function to generate the next state.
    
    A popular design pattern in step functions is to `deepcopy` the old state,
    modify it, and then return it as the new state. When this is done, you
    should pass `StepCopy()` into the `deepcopy` function as a memo. This
    assures that certain objects get copied in the right way for this context.
    '''

    
def state_deepcopy(state):
    '''
    Deepcopy a state, producing an identical duplicate state.
    
    One of the differences between this and plain `deepcopy` is that this
    function makes sure not to copy `Persistent` objects.
    '''
    return copy.deepcopy(state,
                         StateCopy())
########NEW FILE########
__FILENAME__ = duplicating_step_generator_iterator
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `DuplicatingStepGeneratorIterator` class.

See its documentation for more information.
'''

import copy

import garlicsim
from garlicsim.misc import BaseStepIterator, SimpackError, AutoClockGenerator


class DuplicatingStepGeneratorIterator(BaseStepIterator):
    '''
    An iterator that uses a simpack's inplace step generator to produce states.
    
    Despite the fact that this iterator uses an *inplace* step generator under
    the hood, it produces a new distinct state on every iteration. It does that
    by deepcopying the state on every iteration.
    
    The step iterator automatically increments the state's `.clock` by 1 if the
    original step generator doesn't change the `.clock` itself.
    '''
    
    def __init__(self, state, step_profile):
        
        self.current_state = state
        '''
        The current state that will be crunched from on the next iteration.
        '''
        
        self._state_of_raw_generator = None
                
        assert garlicsim.misc.simpack_grokker.step_types.InplaceStepGenerator.\
               __instancecheck__(step_profile.step_function)
        
        self.step_function = step_profile.step_function
        '''The step function that will perform step for us.'''
        
        self.step_profile = step_profile
        '''
        The step profile which contains the arguments given to step function.
        '''
        
        self.auto_clock_generator = AutoClockGenerator(detect_static=True)
        '''Auto-clock generator which ensures all states have good `.clock`.'''
        
        self.auto_clock_generator.make_clock(self.current_state)
        
        self.__build_raw_generator()

    
    def __build_raw_generator(self):
        '''Build a raw generator which will perform step for us.'''
        self._state_of_raw_generator = \
            garlicsim.misc.state_deepcopy.state_deepcopy(self.current_state)
        self.raw_generator = self.step_profile.step_function(
            self._state_of_raw_generator,
            *self.step_profile.args,
            **self.step_profile.kwargs
        )
        
    
    
    def next(self):
        '''Crunch the next state.'''
        try:        
            try:
                yielded_value = self.raw_generator.next()
            except StopIteration:
                self.__build_raw_generator()
                yielded_value = self.raw_generator.next()
                
            assert yielded_value is None
                
            self._auto_clock(self._state_of_raw_generator)
                
            self.current_state = garlicsim.misc.state_deepcopy.state_deepcopy(
                self._state_of_raw_generator
            )
            
        except StopIteration:
                raise SimpackError('The inplace step generator `%s` raised '
                                   '`StopIteration` without yielding even '
                                   'once.' % self.step_profile.step_function)
                
        return self.current_state
                
        
    def _auto_clock(self, state):
        '''
        If the raw generator didn't advance the state's clock, advance it by 1.
        '''
        state.clock = self.auto_clock_generator.make_clock(state)
        

    

########NEW FILE########
__FILENAME__ = duplicating_step_iterator
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `DuplicatingStepIterator` class.

See its documentation for more information.
'''

import copy

import garlicsim
from garlicsim.misc import BaseStepIterator, SimpackError, AutoClockGenerator


class DuplicatingStepIterator(BaseStepIterator):
    '''
    An iterator that uses a simpack's inplace step function to produce states.
    
    Despite the fact that this iterator uses an *inplace* step function under
    the hood, it produces a new distinct state on every iteration. It does that
    by deepcopying the state on every iteration.
    
    The step iterator automatically increments the state's `.clock` by 1 if the
    original step function doesn't change the `.clock` itself.
    '''
    
    def __init__(self, state, step_profile):
        
        self.current_state = state
        '''
        The current state that will be crunched from on the next iteration.
        '''
                
        assert garlicsim.misc.simpack_grokker.step_types.InplaceStep.\
               __instancecheck__(step_profile.step_function)
        
        self.step_function = step_profile.step_function
        '''The step function that will perform step for us.'''
        
        self.step_profile = step_profile
        '''
        The step profile which contains the arguments given to step function.
        '''
        
        self.auto_clock_generator = AutoClockGenerator(detect_static=True)
        '''Auto-clock generator which ensures all states have `.clock`.'''
        
        self.auto_clock_generator.make_clock(self.current_state)
        
        
    def next(self):
        '''Crunch the next state.'''
        new_state = \
            garlicsim.misc.state_deepcopy.state_deepcopy(self.current_state)
        
        return_value = self.step_function(new_state,
                                          *self.step_profile.args,
                                          **self.step_profile.kwargs)
        assert return_value is None
        
        self._auto_clock(new_state)
        self.current_state = new_state
        return self.current_state
                
        
    def _auto_clock(self, state):
        '''
        If the step function didn't advance the state's clock, advance it by 1.
        '''
        state.clock = self.auto_clock_generator.make_clock(state)
        

    

########NEW FILE########
__FILENAME__ = history_step_iterator
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `HistoryStepIterator` class.

See its documentation for more information.
'''

import garlicsim
from garlicsim.misc import BaseStepIterator, SimpackError, AutoClockGenerator


class HistoryStepIterator(BaseStepIterator):
    '''
    An iterator that uses a simpack's history step function to produce states.
    
    The step iterator automatically adds `.clock` readings if the states
    produced by the step function are missing them.
    '''
    
    def __init__(self, history_browser, step_profile):
        
        assert isinstance(history_browser, garlicsim.misc.BaseHistoryBrowser)
        self.history_browser = history_browser
        '''The history browser that the history step function will use.'''
        
        self.history_step_function = step_profile.step_function
        '''The history step function that will produce states for us.'''
        
        self.step_profile = step_profile
        '''
        The step profile which contains the arguments given to step function.
        '''
           
        self.auto_clock_generator = AutoClockGenerator()
        '''Auto-clock generator which ensures all states have `.clock`.'''
        
        self.auto_clock_generator.make_clock(
            self.history_browser.get_last_state()
        )
        
    
    def next(self):
        '''Crunch the next state.'''
        state = self.history_step_function(
            self.history_browser,
            *self.step_profile.args,
            **self.step_profile.kwargs
        )
        self._auto_clock(state)
        return state
    
        
    def _auto_clock(self, state):
        '''If the state has no clock reading, give it one automatically.'''
        state.clock = self.auto_clock_generator.make_clock(state)

    

########NEW FILE########
__FILENAME__ = inplace_step_generator_iterator
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `InplaceStepGeneratorIterator` class.

See its documentation for more information.
'''

import copy

import garlicsim
from garlicsim.misc import BaseStepIterator, SimpackError, AutoClockGenerator


class InplaceStepGeneratorIterator(BaseStepIterator):
    '''
    Step iterator that uses an inplace step generator to perform step in place.
    
    A step iterator uses the simpack's original step function (or in this case
    inplace step generator) under the hood.
    
    This is an *inplace* step iterator; it doesn't produce new states, it
    modifies an existing one in place. It keeps yielding the same state, except
    it modifies it on each iteration.
    
    The step iterator automatically increments the state's `.clock` by 1 if the
    step generator doesn't change the `.clock` itself.
    
    If the simpack's step generator will terminate, this iterator will make a
    fresh one without alerting the user.
    '''
    
    def __init__(self, state, step_profile):
        
        self.current_state = state
        '''
        The current state that will be crunched from on the next iteration.
        '''
        
        assert garlicsim.misc.simpack_grokker.step_types.InplaceStepGenerator.\
               __instancecheck__(step_profile.step_function)
        
        self.step_function = step_profile.step_function
        '''The step function that will produce states for us.'''
        
        self.step_profile = step_profile
        '''
        The step profile which contains the arguments given to step function.
        '''
        
        self.auto_clock_generator = AutoClockGenerator(detect_static=True)
        '''Auto-clock generator which ensures all states have good `.clock`.'''
        
        self.auto_clock_generator.make_clock(self.current_state)
        
        self.__build_raw_generator()

    
    def __build_raw_generator(self):
        '''Build a raw generator which will perform steps for us.'''
        self.raw_generator = self.step_profile.step_function(
            self.current_state,
            *self.step_profile.args,
            **self.step_profile.kwargs
        )
        
    
    def next(self):
        '''Crunch the next state.'''
        try:        
            try:
                yielded_value = self.raw_generator.next()
            except StopIteration:
                self.__build_raw_generator()
                yielded_value = self.raw_generator.next()
                
            assert yielded_value is None
                
            self._auto_clock(self.current_state)
            
        except StopIteration:
                raise SimpackError('The inplace step generator `%s` raised '
                                   '`StopIteration` without yielding even '
                                   'once.' % self.step_profile.step_function)
                
        return self.current_state
                
        
    def _auto_clock(self, state):
        '''
        If the raw generator didn't advance the state's clock, advance it by 1.
        '''
        state.clock = self.auto_clock_generator.make_clock(state)
        

########NEW FILE########
__FILENAME__ = inplace_step_iterator
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `InplaceStepIterator` class.

See its documentation for more information.
'''

import copy

import garlicsim
from garlicsim.misc import BaseStepIterator, SimpackError, AutoClockGenerator


class InplaceStepIterator(BaseStepIterator):
    '''
    Step iterator that uses an inplace step function to perform step in place.
    
    A step iterator uses the simpack's original step function (in this case
    inplace step function) under the hood.
    
    This is an *inplace* step iterator; it doesn't produce new states, it
    modifies an existing one in place. It keeps yielding the same state, except
    it modifies it on each iteration.
    
    The step iterator automatically increments the state's `.clock` by 1 if the
    original step function doesn't change the `.clock` itself.
    '''
    
    def __init__(self, state, step_profile):
        
        self.current_state = state
        '''
        The current state that will be crunched from on the next iteration.
        '''
                
        assert garlicsim.misc.simpack_grokker.step_types.InplaceStep.\
               __instancecheck__(step_profile.step_function)
        
        self.step_function = step_profile.step_function
        '''The step function that will perform step for us.'''
        
        self.step_profile = step_profile
        '''
        The step profile which contains the arguments given to step function.
        '''
        
        self.auto_clock_generator = AutoClockGenerator(detect_static=True)
        '''Auto-clock generator which ensures all states have good `.clock`.'''
        
        self.auto_clock_generator.make_clock(self.current_state)
        
        
    def next(self):
        '''Crunch the next state.'''        
        
        return_value = self.step_function(self.current_state,
                                          *self.step_profile.args,
                                          **self.step_profile.kwargs)
        assert return_value is None
        
        self._auto_clock(self.current_state)
        return self.current_state
                
        
    def _auto_clock(self, state):
        '''
        If the step function didn't advance the state's clock, advance it by 1.
        '''
        state.clock = self.auto_clock_generator.make_clock(state)
        

########NEW FILE########
__FILENAME__ = step_generator_iterator
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `StepGeneratorIterator` class.

See its documentation for more information.
'''

import garlicsim
from garlicsim.misc import BaseStepIterator, SimpackError, AutoClockGenerator


class StepGeneratorIterator(BaseStepIterator):
    '''
    An iterator that uses a simpack's step generator to produce states.
    
    A step iterator uses the simpack's original step function (or in this case
    generator) under the hood.
    
    The step iterator automatically adds `.clock` readings if the states
    produced by the step function are missing them.
    
    If the simpack's step generator will terminate, this iterator will make a
    fresh one without alerting the user.
    '''
    
    def __init__(self, state, step_profile):
        
        self.current_state = state
        '''
        The current state that will be crunched from on the next iteration.
        '''
        
        self.step_function = step_profile.step_function
        '''The step generator that will `yield` states for us.'''
        
        
        self.step_profile = step_profile
        '''
        The step profile which contains the arguments given to step function.
        '''
        
        self.auto_clock_generator = AutoClockGenerator()
        '''Auto-clock generator which ensures all states have `.clock`.'''
        
        self.__build_raw_generator()
                    
        self.auto_clock_generator.make_clock(self.current_state)
        
            
    def __build_raw_generator(self):
        '''Build a raw generator which will provide the states for us.'''
        self.raw_generator = self.step_profile.step_function(
            self.current_state,
            *self.step_profile.args,
            **self.step_profile.kwargs
        )
    
    
    def next(self):
        '''Crunch the next state.'''
        try:        
            try:
                self.current_state = self.raw_generator.next()
            except StopIteration:
                self.__build_raw_generator()
                self.current_state = self.raw_generator.next()
        except StopIteration:
                raise SimpackError('The step generator %s raised '
                                   '`StopIteration` without yielding even one '
                                   'state.' % self.step_profile.step_function)
                
        self._auto_clock(self.current_state)
        return self.current_state
                
        
    def _auto_clock(self, state):
        '''If the state has no clock reading, give it one automatically.'''
        state.clock = self.auto_clock_generator.make_clock(state)
        

    

########NEW FILE########
__FILENAME__ = step_iterator
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `StepIterator` class.

See its documentation for more information.
'''

import garlicsim
from garlicsim.misc import BaseStepIterator, SimpackError, AutoClockGenerator


class StepIterator(BaseStepIterator):
    '''
    An iterator that uses a simpack's step function to produce states.
    
    The step iterator automatically adds `.clock` readings if the states
    produced by the step function are missing them.
    '''
    
    def __init__(self, state, step_profile):
        
        self.current_state = state
        '''
        The current state that will be crunched from on the next iteration.
        '''
        
        self.step_function = step_profile.step_function
        '''The step function that will produce states for us.'''
        
        self.step_profile = step_profile
        '''
        The step profile which contains the arguments given to step function.
        '''
        
        self.auto_clock_generator = AutoClockGenerator()
        '''Auto-clock generator which ensures all states have `.clock`.'''
        
        self.auto_clock_generator.make_clock(self.current_state)
        
        
    def next(self):
        '''Crunch the next state.'''
        self.current_state = self.step_function(self.current_state,
                                                *self.step_profile.args,
                                                **self.step_profile.kwargs)
        self._auto_clock(self.current_state)
        return self.current_state
                
        
    def _auto_clock(self, state):
        '''If the state has no clock reading, give it one automatically.'''
        state.clock = self.auto_clock_generator.make_clock(state)
        

    

########NEW FILE########
__FILENAME__ = step_profile
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `StepProfile` class.

See its documentation for more information.
'''

import copy

from garlicsim.general_misc import caching
from garlicsim.general_misc import cute_inspect
from garlicsim.general_misc.arguments_profile import ArgumentsProfile
from garlicsim.general_misc import address_tools
from garlicsim.misc.exceptions import GarlicSimException

import garlicsim

from garlicsim.misc.simpack_grokker.step_type import BaseStep


__all__ = ['StepProfile']


class Placeholder(object):
    '''A placeholder used instead of a state or a history browser.'''


class StepProfile(ArgumentsProfile):
    '''
    Profile for doing simulation step, specifying step function and arguments.
    
    Using different step profiles, you can crunch your simulation in different
    ways, using different world laws, different contsants and different
    algorithm, within the same project.

    The step profile contains three things:
    
      1. A reference to the step fucntion. (`.step_function`)
      2. A `tuple` of arguments. (`.args`)
      3. A `dict` of keyword arguments. (`.kwargs`)
      
    For example, if you're doing a simulation of Newtonian Mechanics, you can
    create a step profile with `kwargs` of {'G': 3.0} in order to change the
    graviational constant of the simulation on-the-fly.
    '''

    
    __metaclass__ = caching.CachedType
    
    
    def __init__(self, step_function, *args, **kwargs):
        '''
        Construct the step profile.
        
        Give the `*args` and/or `**kwargs` that you want to use for the step
        function.
        '''
        
        # Perhaps we were passed a `StepProfile` object instead of args
        # and kwargs? If so load that one, cause we're all cool and nice.
        candidate = None
        if len(args) == 1 and len(kwargs) == 0:
            candidate = args[0]
        if len(args) == 0 and len(kwargs) == 1 and \
           ('step_profile' in kwargs):
            candidate = kwargs['step_profile']
        
        if isinstance(candidate, StepProfile):
            ArgumentsProfile.__init__(self, candidate.step_function,
                                      *((Placeholder,) + candidate.args),
                                      **candidate.kwargs)
        else:
            ArgumentsProfile.__init__(self, step_function,
                                      *((Placeholder,) + args),
                                      **kwargs)

        assert self.args[0] is Placeholder
        
        self.args = self.args[1:]
        '''The `*args` that will be passed to the step function.'''
        
        self.kwargs = self.kwargs
        '''The `*kwargs` that will be passed to the step function.'''
        
        self.step_function = self.function
        '''The step function that will be used to crunch the simulation.'''
        
    
    @staticmethod
    @caching.cache()    
    def build_parser(default_step_function):
        '''
        Create a parser which builds a step profile smartly.
        
        The canonical way to build a step profile is to provide it with a step
        function, `*args` and `**kwargs`. But in the parser we're being a
        little smarter so the user will have less work.
        
        A `default_step_function` must be given, which the parser will use if
        no other step function will be given to it.
        '''
        
        def parse_arguments_to_step_profile(*args, **kwargs):
            '''
            Build a step profile smartly.
        
            The canonical way to build a step profile is to provide it with a
            step function, `*args` and `**kwargs`. But in this function we're
            being a little smarter so the user will have less work.
            
            You do not need to enter a step function; we will use the default
            one, unless you specify a different one as `step_function`.
            
            You may also pass in a step profile as `step_profile`, and it will
            be noticed and used.
            '''
        
            # We have two candidates to check now: `args[0]` and
            # `kwargs['step_function']`. We'll check the latter first, because
            # that's more explicit and there's less chance we'll be catching
            # some other object by mistake.
            #
            # So we start with `kwargs`:
            
            if 'step_function' in kwargs:
                kwargs_copy = kwargs.copy()
                step_function = kwargs_copy.pop('step_function')
                
                
                assert BaseStep.__instancecheck__(step_function)
                # If the user specified 'step_function', he's not going to get
                # away with it not being an actual step function.
    
                return StepProfile(step_function, *args, **kwargs_copy)
            
            
            if 'step_profile' in kwargs:
                kwargs_copy = kwargs.copy()
                step_profile = kwargs_copy.pop('step_profile')
                
                if step_profile is None:
                    # We let the user specify `step_profile=None` if he wants
                    # to get the default step profile.
                    return StepProfile(default_step_function)
                    
                else: # step_profile is not None
                    if not isinstance(step_profile, StepProfile):
                        raise GarlicSimException(
                            "You passed in `%s` as a keyword argument with a "
                            "keyword of `step_profile`, but it's not a step "
                            "profile." % step_profile
                        )
                    return step_profile
    
            
            # No step function in `kwargs`. We'll try `args`:
            
            elif args:
                
                candidate = args[0]
                
                if isinstance(candidate, StepProfile):
                    return candidate
                
                elif BaseStep.__instancecheck__(candidate):
                    args_copy = args[1:]
                    return StepProfile(
                        candidate,
                        *args_copy,
                        **kwargs
                    )
                  
            
            
            return StepProfile(default_step_function, *args, **kwargs)
        
        return parse_arguments_to_step_profile
                
    
    def __repr__(self, short_form=False, root=None, namespace={}):
        '''
        Get a string representation of the step profile.
        
        Example output with `short_form=False`:
        
            StepProfile(<unbound method State.step>, 'billinear', t=7)
            
        Use `short_form=True` for the shorter form:
        
            my_simpack.State.step(<state>, 'billinear', t=7)
            
        `root` and `namespace` will be used for shortening the function
        address.
        '''
        
        if short_form:
            
            if root is None:
                # Let's try to guess the simpack to have a shorter result:
                root = self._guess_simpack()
                # (When `_guess_simpack` fails, it returns `None`, so we're
                # safe.)
                    
            describe = lambda thing: address_tools.describe(
                thing,
                shorten=True,
                root=root,
                namespace=namespace
            )
        else: # not short_form
            describe = repr

        args_string = ', '.join((describe(thing) for thing in self.args))
        kwargs_string = ', '.join(
            ('='.join((str(key), describe(value))) for
            (key, value) in self.kwargs.iteritems())
        )
        strings = filter(None, (args_string, kwargs_string))
        big_string = ', '.join(strings)
        
            
        if short_form:
            step_function_address = describe(self.step_function)
            final_big_string = ', '.join(
                filter(
                    None,
                    (
                        '<state>',
                        big_string
                    )
                )
            )
            return '%s(%s)' % (
                step_function_address,
                final_big_string
            )
            
        else:
            final_big_string = ', '.join(
                filter(
                    None,
                    (
                        describe(self.step_function),
                        big_string
                    )
                )
            )
            return '%s(%s)' % (type(self).__name__, final_big_string)
    

    @classmethod
    def create_from_dld_format(cls, step_function, args_dict, star_args_list,
                               star_kwargs_dict):
        '''
        Create a step profile from data given in the "dict-list-dict" format.
        
        The "dict-list-dict" format means that in addition to a step function,
        we get a `dict` of arguments, a `list` of `*args`, and a `dict` of
        `**kwargs`.
        '''
        args_spec = cute_inspect.getargspec(step_function)
        new_args = [args_dict[name] for name in args_spec.args[1:]] + \
                   list(star_args_list)
        return cls(step_function, *new_args, **star_kwargs_dict)
        
    
    def _guess_simpack(self):
        '''`try` to guess the simpack that this step profile belongs to.'''
        try:
            module = \
                address_tools.resolve(self.step_function.__module__)
        except Exception:
            return None
        else:
            if hasattr(module, 'State'):
                if issubclass(module.State, garlicsim.data_structures.State):
                    return garlicsim.misc.simpack_tools.\
                           _get_from_state_class(module.State)
                
                
                
                           
    def __eq__(self, other):
        return isinstance(other, StepProfile) and \
               ArgumentsProfile.__eq__(self, other)

    
    def __ne__(self, other):
        return not self.__eq__(other)
    
    
########NEW FILE########
__FILENAME__ = settings
from .state import State

import garlicsim


########### *All* of the settings in this module are optional. ################


# CRUNCHERS = garlicsim.asynchronous_crunching.crunchers.ThreadCruncher

# Cruncher types that this simpack says it can use.
#
# Cruncher types can be specified in different ways. You may specify either (a)
# a cruncher type, or (b) the string name of a cruncher type, or (c) a list of
# either of those (sorted by priority,) or (d) a filter function for cruncher
# types.
# 
# This is useful because some simpacks can't be used with certain kinds of
# crunchers.


# DETERMINISM_FUNCTION = \
#     garlicsim.misc.simpack_grokker.misc.default_determinism_function

# Function that takes a step profile and says whether its deterministic.
#
# What this function says is, "If you do a simulation using this step profile,
# then you will have a deterministic simulation." (Or undeterministic, depends
# on the step profile.)
#
# This is useful because it allows garlicsim to detect if a simulation has
# reached a repititive state, so it can stop the crunching right there and
# avoid wasting resources. (01.01.2011 - Still not implemented, sorry.)
#
# Note that this function does not return `True` or `False`: It returns a
# `DeterminismSetting` class. For details about those, see documentation in
# `garlicsim.misc.settings_constants.settings`.
#
# The function will return `None` if it's unknown whether the step profile is
# deterministic.

########NEW FILE########
__FILENAME__ = state


import garlicsim.data_structures


class State(garlicsim.data_structures.State):
    # This is your `State` subclass. Your state objects should contain all the
    # information there is about a moment of time in your simulation.
    
    def __init__(self):
        pass
    
    
    def step(self):
        # This function is the heart of your simpack. What it does is take an
        # existing world state, and output the next world state.
        #
        # This is where all the crunching gets done. This function defines the
        # laws of your simulation world.
        # 
        # The step function is one of the very few things that your simpack
        # **must** define. Almost all of the other definitions are optional.
        pass
    
        
    #@staticmethod
    #def create_root():
        # In this function you create a root state. This usually becomes the
        # first state in your simulation. You can make this function do
        # something simple: For example, if you're simulating a Life cellular
        # automata, you can make this function create an empty board.
        #
        # This function may take arguments, if you wish, to be used in making
        # the state. For example, in a Life simulation you may want to specify
        # the width and height of the board using arguments to this function.
        #
        # This function returns the newly-created state.

    
    #@staticmethod
    #def create_messy_root():
        # In this function you create a messy root state. This usually becomes
        # the first state in your simulation.
        #
        # Why messy? Because sometimes you want to have fun in your
        # simulations. You want to create a world where there's a lot of mess,
        # with many objects interacting with each other. This is a good way to
        # test-drive your simulation.
        #
        # This function may take arguments, if you wish, to be used in making
        # the state. For example, in a Life simulation you may want to specify
        # the width and height of the board using arguments to this function.
        #
        # This function returns the newly-created state.
                                 
    
    #def step_generator(self):
    #    yield None
    #    pass
    #
    # Do you want to use a step generator as your step function? If so, you may
    # uncomment the above and fill it in, and it will be used instead of the
    # normal step function.
    # 
    # A step generator is similar to a regular step function: it takes a
    # starting state, and computes the next state. But it doesn't `return` it,
    # it `yield`s it. And then it doesn't exit, it just keeps on crunching and
    # yielding more states one by one.
    # 
    # A step generator is useful when you want to set up some environment
    # and/or variables when you do your crunching. It can help you save
    # resources, because you won't have to do all that initialization every
    # time garlicsim computes a step.
    #
    # (You may write your step generator to terminate at some point or to never
    # terminate-- Both ways are handled by `garlicsim`.)
    
    

########NEW FILE########
__FILENAME__ = settings
# from .widgets import state_viewer as _
# from .widgets import state_creation_dialog as _
# from . import widgets


########### *All* of the settings in this module are optional. ################


# BIG_WORKSPACE_WIDGETS = [widgets.state_viewer.StateViewer]

# Widgets to show in the middle of the frame. These must be subclasses of
# `garlicsim_wx.widgets.workspace_widget.WorkspaceWidget`.
#
# This is where you usually put your main widget that displays your states.


# SMALL_WORKSPACE_WIDGETS = []

# (01.01.2011 - Still not implemented, sorry.)
#
# Small widgets to show in the frame. These must be subclasses of
# `garlicsim_wx.widgets.workspace_widget.WorkspaceWidget`.
#
# This is where you usually put small tools.


# SEEK_BAR_GRAPHS = []

# (01.01.2011 - Still not implemented, sorry.)
#
# List of scalar functions that should be shown as graphs in the seek bar.
#
# These may be either scalar state functions or scalar history functions.


# STATE_CREATION_DIALOG = widgets.state_creation_dialog
#
# Dialog for creating a root state.
########NEW FILE########
__FILENAME__ = state_creation_dialog
import wx
import garlicsim.data_structures
from garlicsim_wx.widgets.general_misc.cute_dialog import CuteDialog



class StateCreationDialog(CuteDialog):
    # This is where you define a dialog for creating a root state.
    #
    # When someone loads your simpack into `garlicsim_wx` and starts a new
    # simulation, the first thing he sees is the state creation dialog. The
    # state creation dialog is a convenient way to create the first state in
    # your program.
    #
    # This dialog should display some kind of form for the user to fill out.
    # This will usually ask the user question about how they want their initial
    # state to be. For example, for a Life simpack the dialog will ask what
    # should be the width and height of the new state.
    
    def __init__(self, frame):
        CuteDialog.__init__(self, frame, title='Creating a root state')
        
        self.frame = frame

        # ...

        
    def start(self):
        # The `start` method will be used by `garlicsim_wx` after the dialog
        # has been created to make the dialog appear on the screen, and to
        # create a state object from the data that the dialog has collected
        # from the user. Returns a state, or `None` if the user hit "cancel" or
        # something.
        if self.ShowModal() == wx.ID_OK:
            # state = ...
            pass
        else:
            state = None
        return state
        


    
    
########NEW FILE########
__FILENAME__ = state_viewer
import wx

import garlicsim_wx


class StateViewer(wx.Panel,
                  garlicsim_wx.widgets.WorkspaceWidget):
    # Here you create a widget that will display your state graphically on the
    # screen.
    
    def __init__(self, frame):
            
        # We need to call the __init__ of both our base classes:
        wx.Panel.__init__(self, frame,
                          style=wx.SUNKEN_BORDER)        
        garlicsim_wx.widgets.WorkspaceWidget.__init__(self, frame)
        
        self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM) # Solves Windows flicker
        
        self.Bind(wx.EVT_PAINT, self.on_paint)
        self.Bind(wx.EVT_SIZE, self.on_size)
        
        # ...
        

        # This next bit will cause the widget to get updated every time the
        # active state in the GUI is changed:
        self.gui_project.active_node_changed_emitter.add_output(
            lambda: self.set_state(self.gui_project.get_active_state())
        )


    def set_state(self, state):
        # Here you set the state to be displayed.
        self.state = state
        self.Refresh()
        
        
    def on_paint(self, event):
        # This is your EVT_PAINT handler, which draws the state on the widget.
        
        event.Skip()
        
        dc = wx.PaintDC(self)
        
        # ...
                
        
    def on_size(self, event):
        # An EVT_SIZE handler. Just some wxPython thing that I think you're
        # supposed to do.
        self.Refresh()


########NEW FILE########
__FILENAME__ = start_simpack
#!/usr/bin/env python
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Script for starting a new simpack.

This is a script for creating a skeleton for a `garlicsim` simpack. Use this
when you want to make a new simpack to have the basic folders and files created
for you.

Usage:

    start_simpack.py my_simpack_name

The simpack will be created in the current path, in a directory with the name
of the simpack.
'''

from __future__ import with_statement

import os.path
import sys
import re
import shutil

import pkg_resources

from garlicsim.scripts import simpack_template
simpack_template_package_name = simpack_template.__name__

    
def _walk_folder(package_name, folder):
    '''
    Walk on subfolders of a folder using `pkg_resources`.

    `package_name` is the name of the package in which this folder lives.
    `folder` is the path of the folder.
    
    Of course, since we are operating using `pkg_resources`, all paths are
    relative to the `pkg_resources`-managed package.
    '''
    folders = [folder]
    
    while folders:
        folder = folders.pop()
        for f in pkg_resources.resource_listdir(package_name, folder):
            path = '/'.join((folder, f))
            if pkg_resources.resource_isdir(package_name, path):
                folders.append(path)
            else:
                yield path
        

def _make_path_to_file(file_):
    '''
    Create the folders needed before creating a file.
    
    Given a path to a file that doesn't exist, this function creates all the
    folders up to the file, so the file could be later created without thinking
    whether these folders exist or not.
    '''
    folder = os.path.split(file_)[0]
    if os.path.isdir(folder):
        return
    parent_folder = os.path.split(folder)[0]
    _make_path_to_file(folder)
    os.mkdir(folder)
    
                
    
def start_simpack(containing_folder, name):
    '''
    Create a new simpack.
    
    This is the main function of this module. `containing_folder` is the folder
    in which the simpack folder should be created. `name` is the name of the
    new simpack, which will also be the name of its folder.
    '''
    
    if not re.search(r'^[_a-zA-Z]\w*$', name): # If not valid folder name.
        # Provide a smart error message, depending on the error.
        if not re.search(r'^[_a-zA-Z]', name):
            message = 'make sure the name begins with a letter or underscore'
        else:
            message = 'use only numbers, letters and underscores'
        raise Exception('%r is not a valid simpack name. Please %s.' %
                        (name, message))
    folder = os.path.join(containing_folder, name)
    
    os.mkdir(folder)
    
    for file in _walk_folder(simpack_template_package_name, 'simpack_name'):
        
        if os.path.splitext(file)[1] in ('.pyc', '.pyo'):
            continue
        
        dest_file = '/'.join(
            (containing_folder, file.replace('simpack_name', name))
        )
        
        _make_path_to_file(dest_file)
        
        source_string = \
            pkg_resources.resource_string(simpack_template_package_name, file)
            
        with open(dest_file, 'w') as destination:
            
            string_to_write = source_string\
                            .replace('\r', '')\
                            .replace('simpack_name', name)
            
            destination.write(string_to_write)
            
        try:
            shutil.copymode('/'.join(('simpack_template', file)), dest_file)
            _make_writeable(dest_file)
        except Exception:
            pass
    print('`%s` simpack created successfully! Explore the `%s` folder and '
          'start filling in the contents of your new simpack.' % (name, name))
                
    
def _make_writeable(filename):
    '''
    Make sure that the file is writeable. Useful if our source is read-only.
    '''
    import stat
    if sys.platform.startswith('java'):
        # On Jython there is no os.access()
        return
    if not os.access(filename, os.W_OK):
        st = os.stat(filename)
        new_permissions = stat.S_IMODE(st.st_mode) | stat.S_IWUSR
        os.chmod(filename, new_permissions)

        
def show_help():
    '''Print some help text that describes how to use this script.'''
    print(__doc__)

 
def start(argv=None):
    if argv is None:
        argv = sys.argv
    if len(argv) != 2:
        show_help()
        return
    arg = argv[1]

    if arg == '--help':
        show_help()
        return
    
    start_simpack(os.curdir, arg)


if __name__ == '__main__':
    start()
    
########NEW FILE########
__FILENAME__ = history_browser
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `HistoryBrowser` class.

See its documentation for more info.
'''

import garlicsim.general_misc.binary_search as binary_search
import garlicsim.general_misc.queue_tools as queue_tools
import garlicsim.misc


__all__ = ['HistoryBrowser']


get_state_clock = lambda state: state.clock


class HistoryBrowser(garlicsim.misc.BaseHistoryBrowser):
    '''
    A device for requesting information about the history of the simulation.
    
    A `HistoryBrowser` is a device for requesting information about the history
    of the simulation. It is intended to be used by crunchers in simulations
    that are history-dependent.
    
    This specific kind of history browser, defined in the
    `synchronous_crunching` package, is intended for synchronously-crunched
    simulations in which there are no worker processes/threads doing the
    crunching. Therefore, its job is quite simple; it recieves a path in its
    constructor and it handles all state requests from that path.
    '''
    
    def __init__(self, path, tail_node=None):
        #todo: maybe not require path, just calculate from node?
        self.path = path
        '''
        This is the path, from which all states will be taken when requested.
        '''
        
        self.tail_node = tail_node
        '''
        An optional tail node, in which the path ends.
        
        If not specified, it will be None, meaning that the path would go on
        until its last node.
        
        If this option is specified, you will have to update the `.tail_node`
        of the history browser every time you use the step function. (That's
        because you've added a node to the tree, and that node should now be
        the `.tail_node`.)
        '''
     
        
    def get_last_state(self):
        '''Get the last state in the timeline. Identical to __getitem__(-1).'''
        return self.tail_node.state if self.tail_node else self[-1]

    
    def __getitem__(self, index):
        '''Get a state by its position in the timeline.'''
        assert isinstance(index, int)
        return self.path.__getitem__(index, tail=self.tail_node).state

    
    def get_state_by_monotonic_function(self, function, value,
                                        rounding=binary_search.CLOSEST):
        '''
        Get a state by specifying a measure function and a desired value.
        
        The function must be a monotonic rising function on the timeline.
        
        See documentation of `binary_search.roundings` for details about
        rounding options.
        '''
        assert issubclass(rounding, binary_search.Rounding)
        
        new_function = lambda node: function(node.state)
        result_in_nodes = self.path.get_node_by_monotonic_function(
            new_function,
            value,
            rounding,
            tail_node=self.tail_node
        )
        
        if rounding is binary_search.BOTH:
            result = tuple((node.state if node is not None else None)
                           for node in result_in_nodes)
        else:
            result = result_in_nodes.state if result_in_nodes is not None \
                   else None
            
        return result

    
    def __len__(self):
        '''Get the length of the timeline in nodes.'''
        return self.path.__len__(tail=self.tail_node)
    
    
########NEW FILE########
__FILENAME__ = iter_simulate
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `iter_simulate` function.

See its documentation for more info.
'''

import copy

from garlicsim.general_misc import cute_iter_tools

import garlicsim
import garlicsim.misc
from . import history_browser as history_browser_module # Avoiding name clash


__all__ = ['iter_simulate']



def iter_simulate(state, iterations, *args, **kwargs):
    '''
    Simulate from the given state for the given number of iterations.

    This returns a generator that yields all the states one-by-one, from the
    initial state to the final one.
    
    If you wish, in `*args` and `**kwargs` you may specify simulation
    parameters and/or a specific step function to use. (You may specify a step
    function either as the first positional argument or the `step_function`
    keyword argument.) You may also pass in an existing step profile.
    '''
    simpack_grokker = garlicsim.misc.SimpackGrokker.create_from_state(state)
    
    parse_arguments_to_step_profile = garlicsim.misc.StepProfile.build_parser(
        simpack_grokker.default_step_function
    )
    step_profile = parse_arguments_to_step_profile(*args, **kwargs)
    
    
    if not hasattr(state, 'clock'):
        state = garlicsim.misc.state_deepcopy.state_deepcopy(state)
        state.clock = 0
                      
    if simpack_grokker.history_dependent:
        return _history_iter_simulate(simpack_grokker, state, iterations,
                                      step_profile)
    else: # It's a non-history-dependent simpack
        return _non_history_iter_simulate(simpack_grokker, state, iterations,
                                          step_profile)

    
def _history_iter_simulate(simpack_grokker, state, iterations, step_profile):
    '''
    Simulate from the given state for the given number of iterations.
    
    (Internal function for history-dependent simulations only.)

    This returns a generator that yields all the states one-by-one, from the
    initial state to the final one.
    '''
    
    tree = garlicsim.data_structures.Tree()
    root = tree.add_state(state, parent=None)
    path = root.make_containing_path()
    history_browser = history_browser_module.HistoryBrowser(path)
    
    iterator = simpack_grokker.get_step_iterator(history_browser, step_profile)
    finite_iterator = cute_iter_tools.shorten(iterator, iterations)
    
    current_node = root
    current_state = current_node.state
    
    yield current_state
    
    world_ended = False
    try:
        for current_state in finite_iterator:
            yield current_state
            current_node = tree.add_state(current_state, parent=current_node)
    except garlicsim.misc.WorldEnded:
        world_ended = True
    
    # Not doing anything with `world_ended` yet
    
    raise StopIteration
    

def _non_history_iter_simulate(simpack_grokker, state, iterations,
                               step_profile):
    '''
    Simulate from the given state for the given number of iterations.
    
    (Internal function for non-history-dependent simulations only.)

    This returns a generator that yields all the states one-by-one, from the
    initial state to the final one.
    '''
    
    iterator = simpack_grokker.get_step_iterator(state, step_profile)
    finite_iterator = cute_iter_tools.shorten(iterator, iterations)
    
    current_state = state
    
    yield current_state
    
    world_ended = False
    try:
        for current_state in finite_iterator:
            yield current_state
    except garlicsim.misc.WorldEnded:
        world_ended = True

    # Not doing anything with `world_ended` yet
    
    raise StopIteration

########NEW FILE########
__FILENAME__ = list_simulate
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `list_simulate` function.

See its documentation for more info.
'''

import copy

from garlicsim.general_misc import cute_iter_tools

import garlicsim
import garlicsim.misc
from . import history_browser as history_browser_module # Avoiding name clash


__all__ = ['list_simulate']


def list_simulate(state, iterations, *args, **kwargs):
    '''
    Simulate from the given state for the given number of iterations.
    
    Returns a list that spans all the states, from the initial one given to
    the final one.
    
    If you wish, in `*args` and `**kwargs` you may specify simulation
    parameters and/or a specific step function to use. (You may specify a step
    function either as the first positional argument or the `step_function`
    keyword argument.) You may also pass in an existing step profile.
    '''
    simpack_grokker = garlicsim.misc.SimpackGrokker.create_from_state(state)
    
    parse_arguments_to_step_profile = garlicsim.misc.StepProfile.build_parser(
        simpack_grokker.default_step_function
    )
    step_profile = parse_arguments_to_step_profile(*args, **kwargs)
    
    if not hasattr(state, 'clock'):
        state = garlicsim.misc.state_deepcopy.state_deepcopy(state)
        state.clock = 0
                      
    if simpack_grokker.history_dependent:
        return _history_list_simulate(simpack_grokker, state, iterations,
                                      step_profile)
    else: # It's a non-history-dependent simpack
        return _non_history_list_simulate(simpack_grokker, state, iterations,
                                          step_profile)

    
def _history_list_simulate(simpack_grokker, state, iterations,
                           step_profile):
    '''
    Simulate from the given state for the given number of iterations.

    (Internal function for history-dependent simulations only.)    
    
    Returns a list that spans all the states, from the initial one given to
    the final one.
    '''
    
    tree = garlicsim.data_structures.Tree()
    root = tree.add_state(state, parent=None)
    path = root.make_containing_path()
    history_browser = history_browser_module.HistoryBrowser(path)
    
    iterator = simpack_grokker.get_step_iterator(history_browser, step_profile)
    finite_iterator = cute_iter_tools.shorten(iterator, iterations)
    
    current_node = root
    current_state = current_node.state
    
    world_ended = False
    try:
        for current_state in finite_iterator:
            current_node = tree.add_state(current_state, parent=current_node)
    except garlicsim.misc.WorldEnded:
        world_ended = True
    
    # Not doing anything with `world_ended` yet
        
    return [node.state for node in path]


def _non_history_list_simulate(simpack_grokker, state, iterations,
                               step_profile):
    '''
    Simulate from the given state for the given number of iterations.
    
    (Internal function for non-history-dependent simulations only.)
    
    Returns a list that spans all the states, from the initial one given to
    the final one.
    '''

    tree = garlicsim.data_structures.Tree()
    root = tree.add_state(state, parent=None)
    path = root.make_containing_path()
    
    iterator = simpack_grokker.get_step_iterator(state, step_profile)
    finite_iterator = cute_iter_tools.shorten(iterator, iterations)
    
    current_node = root
    current_state = current_node.state
    
    world_ended = False
    try:
        for current_state in finite_iterator:
            current_node = tree.add_state(current_state, parent=current_node)
    except garlicsim.misc.WorldEnded:
        world_ended = True

    # Not doing anything with `world_ended` yet
    
    return [node.state for node in path]


########NEW FILE########
__FILENAME__ = simulate
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `simulate` function.

See its documentation for more info.
'''

import copy
import warnings

from garlicsim.general_misc import cute_iter_tools

import garlicsim
import garlicsim.misc
from . import history_browser as history_browser_module # Avoiding name clash

__all__ = ['simulate']


def simulate(state, iterations=1, *args, **kwargs):
    '''
    Simulate from the given state for the given number of iterations.

    If you wish, in `*args` and `**kwargs` you may specify simulation
    parameters and/or a specific step function to use. (You may specify a step
    function either as the first positional argument or the `step_function`
    keyword argument.) You may also pass in an existing step profile.
    
    Returns the final state of the simulation.
    '''
    simpack_grokker = garlicsim.misc.SimpackGrokker.create_from_state(state)
    
    parse_arguments_to_step_profile = garlicsim.misc.StepProfile.build_parser(
        simpack_grokker.default_step_function
    )
    step_profile = parse_arguments_to_step_profile(*args, **kwargs)

    if not hasattr(state, 'clock'):
        # todo: make mechanism to prevent deepcopying twice, both here and
        # in inplace handling.
        state = garlicsim.misc.state_deepcopy.state_deepcopy(state)
        state.clock = 0
    
    if simpack_grokker.history_dependent:
        return __history_simulate(simpack_grokker, state, iterations,
                                  step_profile)
    else: # It's a non-history-dependent simpack
        return __non_history_simulate(simpack_grokker, state, iterations,
                                      step_profile)

    
def __history_simulate(simpack_grokker, state, iterations, step_profile):
    '''    
    Simulate from the given state for the given number of iterations.
    
    (Internal function, for history-dependent simulations only)
    
    Returns the final state of the simulation.
    '''
            
    tree = garlicsim.data_structures.Tree()
    root = tree.add_state(state, parent=None)
    path = root.make_containing_path()
    history_browser = history_browser_module.HistoryBrowser(path)
    
    iterator = simpack_grokker.get_step_iterator(history_browser, step_profile)
    finite_iterator = cute_iter_tools.shorten(iterator, iterations)
    
    current_node = root
    current_state = current_node.state
    
    try:
        for current_state in finite_iterator:
            current_node = tree.add_state(current_state, parent=current_node)
    except garlicsim.misc.WorldEnded:
        pass
        
    final_state = current_state
    # Which is still here as the last value from the `for` loop.
    
    return final_state


def __non_history_simulate(simpack_grokker, state, iterations, step_profile):
    '''
    Simulate from the given state for the given number of iterations.
    
    (Internal function, for non-history-dependent simulations only.)
    
    Returns the final state of the simulation.
    '''
    
    # We try to get an inplace step iterator, if our simpack supplies one.
    # Otherwise we use a regular one. The reason we do it here in
    # `__non_history_simulate` is because this function gives the user only the
    # final state, without keeping any states in between. Therefore we can
    # afford doing the steps inplace, and we get better performance because we
    # don't deepcopy states.
    if simpack_grokker.is_inplace_iterator_available(step_profile) is True:
        state_copy = garlicsim.misc.state_deepcopy.state_deepcopy(state)
        iterator = \
            simpack_grokker.get_inplace_step_iterator(state_copy, step_profile)
        
    else: # Inplace iterator is not available
        iterator = simpack_grokker.get_step_iterator(state, step_profile)
    
    finite_iterator = cute_iter_tools.shorten(iterator, iterations)
    current_state = state
    
    try:
        for current_state in finite_iterator:
            pass
    except garlicsim.misc.WorldEnded:
        pass    
    
    final_state = current_state
    # Which is still here as the last value from the `for` loop.
    
    return final_state
########NEW FILE########
__FILENAME__ = _test_garlicsim
#!/usr/bin/env python

# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Script for launching `garlicsim` tests when installed in local Python.'''


import test_garlicsim


if __name__ == '__main__':
    test_garlicsim.invoke_nose()
########NEW FILE########
__FILENAME__ = shared
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Tools for testing `garlicsim`.'''


from garlicsim.general_misc import import_tools

import garlicsim 


def verify_simpack_settings(sample_simpack):
    '''
    Verfiy that `sample_simpack` has all the testing flags with valid values.
    '''
    import_tools.normal_import(
        sample_simpack.__name__ + '._test_settings'
    )
    _test_settings = sample_simpack._test_settings
    assert isinstance(_test_settings.ENDABLE, bool)
    bool(_test_settings.VALID)
    assert (_test_settings.PROBLEM is None) or \
           issubclass(_test_settings.PROBLEM, Exception)
    assert isinstance(_test_settings.HISTORY_DEPENDENT, bool)
    assert isinstance(_test_settings.N_STEP_FUNCTIONS, int)
    if _test_settings.DEFAULT_STEP_FUNCTION is not None:
        assert callable(_test_settings.DEFAULT_STEP_FUNCTION)
    if _test_settings.DEFAULT_STEP_FUNCTION_TYPE is not None:
        assert issubclass(
            _test_settings.DEFAULT_STEP_FUNCTION_TYPE,
            garlicsim.misc.simpack_grokker.step_type.BaseStep
        )
    assert isinstance(_test_settings.CONSTANT_CLOCK_INTERVAL, int) or \
           _test_settings.CONSTANT_CLOCK_INTERVAL is None
    assert isinstance(_test_settings.CRUNCHERS_LIST, list)
    for cruncher_type in _test_settings.CRUNCHERS_LIST:
        assert issubclass(cruncher_type,
                          garlicsim.asynchronous_crunching.BaseCruncher)
        
    # Making sure there aren't any extraneous settings, so we'll know we
    # checked everything:
    settings_names = [name for name in dir(_test_settings) if name.isupper()]
    assert len(settings_names) == 9

########NEW FILE########
__FILENAME__ = shared
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Tools for testing `garlicsim.asynchronous_crunching`.'''

from garlicsim.asynchronous_crunching.crunchers import ThreadCruncher


class MustachedThreadCruncher(ThreadCruncher):
    '''A trivial subclass of `ThreadCruncher` for use in testing.'''
########NEW FILE########
__FILENAME__ = state
import garlicsim.data_structures


class State(garlicsim.data_structures.State):
    
    def __init__(self):
        pass
    
    def step(self):
        return State()
    
    def step_generator(self):
        yield State()
        raise StopIteration
        
    @staticmethod
    def create_root():
        return State()
    
########NEW FILE########
__FILENAME__ = _test_settings
from garlicsim.general_misc import import_tools

import garlicsim

from .state import State

ENDABLE = False
PROBLEM = None
VALID = True
CONSTANT_CLOCK_INTERVAL = None
HISTORY_DEPENDENT = False
N_STEP_FUNCTIONS = 1
DEFAULT_STEP_FUNCTION = State.step_generator
DEFAULT_STEP_FUNCTION_TYPE = \
    garlicsim.misc.simpack_grokker.step_types.StepGenerator
CRUNCHERS_LIST = \
    [garlicsim.asynchronous_crunching.crunchers.ThreadCruncher] + \
    (
        [garlicsim.asynchronous_crunching.crunchers.ProcessCruncher] if 
        import_tools.exists('multiprocessing')
        else []
    )
########NEW FILE########
__FILENAME__ = state
from garlicsim.general_misc.infinity import infinity
from garlicsim.general_misc import binary_search

import garlicsim.data_structures


class State(garlicsim.data_structures.State):
    
    def __init__(self):
        pass
    
    @staticmethod
    def history_step(history_browser):
        assert isinstance(
            history_browser,
            garlicsim.misc.base_history_browser.BaseHistoryBrowser
        )
        first_state = history_browser[0]
        last_state = history_browser[-1]
        assert last_state is history_browser.get_last_state()
        n_states = len(history_browser)
        # todo: If ever doing `BaseHistoryBrowser.__iter__`, should test it here
        # and compare to other methods.
        assert last_state is history_browser[n_states - 1]
        assert first_state is history_browser[-n_states]
        if n_states >= 2:
            second_state = history_browser[1]
            second_to_last_state = history_browser[-2]
            assert second_state is history_browser[- n_states + 1]
            assert second_to_last_state is history_browser[n_states - 2]
            if n_states >= 3:
                assert first_state.clock < second_state.clock <= \
                       second_to_last_state.clock < last_state.clock
            
        assert history_browser.get_state_by_clock(-infinity) is first_state
        assert history_browser.get_state_by_clock(infinity) is last_state
        
        assert history_browser.get_state_by_clock(
            -infinity,
            binary_search.roundings.BOTH
        ) == (None, first_state)
        assert history_browser.get_state_by_clock(
            infinity,
            binary_search.roundings.BOTH
        ) == (last_state, None)
        
            
        
        return State()
        
    @staticmethod
    def create_root():
        return State()
    
########NEW FILE########
__FILENAME__ = _test_settings
import garlicsim

from .state import State

ENDABLE = False
PROBLEM = None
VALID = True
CONSTANT_CLOCK_INTERVAL = None
HISTORY_DEPENDENT = True
N_STEP_FUNCTIONS = 1
DEFAULT_STEP_FUNCTION = State.history_step
DEFAULT_STEP_FUNCTION_TYPE = \
    garlicsim.misc.simpack_grokker.step_types.HistoryStep
CRUNCHERS_LIST = [garlicsim.asynchronous_crunching.crunchers.ThreadCruncher]
########NEW FILE########
__FILENAME__ = state
import garlicsim.data_structures


class State(garlicsim.data_structures.State):
    
    def __init__(self):
        pass
    
    def step(self):
        return State()
        
    @staticmethod
    def create_root():
        return State()
    
########NEW FILE########
__FILENAME__ = _test_settings
from garlicsim.general_misc import import_tools

import garlicsim

from .state import State

ENDABLE = False
PROBLEM = None
VALID = True
CONSTANT_CLOCK_INTERVAL = None
HISTORY_DEPENDENT = False
N_STEP_FUNCTIONS = 1
DEFAULT_STEP_FUNCTION = State.step
DEFAULT_STEP_FUNCTION_TYPE = \
    garlicsim.misc.simpack_grokker.step_types.SimpleStep
CRUNCHERS_LIST = \
    [garlicsim.asynchronous_crunching.crunchers.ThreadCruncher] + \
    (
        [garlicsim.asynchronous_crunching.crunchers.ProcessCruncher] if 
        import_tools.exists('multiprocessing')
        else []
    )
########NEW FILE########
__FILENAME__ = settings
import garlicsim

CRUNCHERS = [garlicsim.asynchronous_crunching.crunchers.ThreadCruncher]
########NEW FILE########
__FILENAME__ = state
import garlicsim.data_structures


class State(garlicsim.data_structures.State):
    
    def __init__(self):
        pass
    
    def step(self):
        return State()
        
    @staticmethod
    def create_root():
        return State()
    
########NEW FILE########
__FILENAME__ = _test_settings
import garlicsim

from .state import State

ENDABLE = False
PROBLEM = None
VALID = True
CONSTANT_CLOCK_INTERVAL = None
HISTORY_DEPENDENT = False
N_STEP_FUNCTIONS = 1
DEFAULT_STEP_FUNCTION = State.step
DEFAULT_STEP_FUNCTION_TYPE = \
    garlicsim.misc.simpack_grokker.step_types.SimpleStep
CRUNCHERS_LIST = [garlicsim.asynchronous_crunching.crunchers.ThreadCruncher]
########NEW FILE########
__FILENAME__ = settings
import garlicsim


def CRUNCHERS(cruncher_type):
    return cruncher_type is \
        garlicsim.asynchronous_crunching.crunchers.ThreadCruncher
########NEW FILE########
__FILENAME__ = state
import garlicsim.data_structures


class State(garlicsim.data_structures.State):
    
    def __init__(self):
        pass
    
    def step(self):
        return State()
        
    @staticmethod
    def create_root():
        return State()
    
########NEW FILE########
__FILENAME__ = _test_settings
import garlicsim

from .state import State

ENDABLE = False
PROBLEM = None
VALID = True
CONSTANT_CLOCK_INTERVAL = None
HISTORY_DEPENDENT = False
N_STEP_FUNCTIONS = 1
DEFAULT_STEP_FUNCTION = State.step
DEFAULT_STEP_FUNCTION_TYPE = \
    garlicsim.misc.simpack_grokker.step_types.SimpleStep
CRUNCHERS_LIST = [garlicsim.asynchronous_crunching.crunchers.ThreadCruncher]
########NEW FILE########
__FILENAME__ = settings
CRUNCHERS = ['ThreadCruncher']
########NEW FILE########
__FILENAME__ = state
import garlicsim.data_structures


class State(garlicsim.data_structures.State):
    
    def __init__(self):
        pass
    
    def step(self):
        return State()
        
    @staticmethod
    def create_root():
        return State()
    
########NEW FILE########
__FILENAME__ = _test_settings
import garlicsim

from .state import State

ENDABLE = False
PROBLEM = None
VALID = True
CONSTANT_CLOCK_INTERVAL = None
HISTORY_DEPENDENT = False
N_STEP_FUNCTIONS = 1
DEFAULT_STEP_FUNCTION = State.step
DEFAULT_STEP_FUNCTION_TYPE = \
    garlicsim.misc.simpack_grokker.step_types.SimpleStep
CRUNCHERS_LIST = [garlicsim.asynchronous_crunching.crunchers.ThreadCruncher]
########NEW FILE########
__FILENAME__ = state
import garlicsim.data_structures


class State(garlicsim.data_structures.State):
    
    def __init__(self):
        pass
    
    def step(self):
        return State()
    
    def step_generator(self):
        current_state = self
        while True:
            current_state = current_state.step()
            yield current_state
        
    @staticmethod
    def create_root():
        return State()
    
########NEW FILE########
__FILENAME__ = _test_settings
from garlicsim.general_misc import import_tools

import garlicsim

from .state import State

ENDABLE = False
PROBLEM = None
VALID = True
CONSTANT_CLOCK_INTERVAL = None
HISTORY_DEPENDENT = False
N_STEP_FUNCTIONS = 2
DEFAULT_STEP_FUNCTION = State.step_generator
DEFAULT_STEP_FUNCTION_TYPE = \
    garlicsim.misc.simpack_grokker.step_types.StepGenerator
CRUNCHERS_LIST = \
    [garlicsim.asynchronous_crunching.crunchers.ThreadCruncher] + \
    (
        [garlicsim.asynchronous_crunching.crunchers.ProcessCruncher] if 
        import_tools.exists('multiprocessing')
        else []
    )
########NEW FILE########
__FILENAME__ = tests
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Testing module for `garlicsim.asynchronous_crunching`.'''

from __future__ import division

import os
import types
import time
import itertools

import nose

from garlicsim.general_misc import cute_iter_tools
from garlicsim.general_misc import math_tools
from garlicsim.general_misc import path_tools
from garlicsim.general_misc import import_tools
from garlicsim.general_misc.infinity import infinity
from garlicsim.general_misc.nifty_collections import OrderedSet

import garlicsim

import test_garlicsim


def test():
    '''Test `garlicsim.asynchronous_crunching`.'''
    
    from . import simpacks as simpacks_package
    
    # Collecting all the test simpacks:
    simpacks = import_tools.import_all(simpacks_package).values()
    
    # Making sure that we didn't miss any simpack by counting the number of
    # sub-folders in the `simpacks` folder:
    simpacks_dir = \
        os.path.dirname(simpacks_package.__file__)
    assert len(path_tools.list_sub_folders(simpacks_dir)) == \
           len(simpacks)
    
    for simpack in simpacks:
        
        test_garlicsim.verify_simpack_settings(simpack)
        
        cruncher_types = \
            garlicsim.misc.SimpackGrokker(simpack).available_cruncher_types
        
        for cruncher_type in cruncher_types:
            
            yield check, simpack, cruncher_type


        
def check(simpack, cruncher_type):
    
    my_simpack_grokker = garlicsim.misc.SimpackGrokker(simpack)
    
    assert my_simpack_grokker is garlicsim.misc.SimpackGrokker(simpack)
    # Ensuring caching works.
    
    assert not simpack._test_settings.ENDABLE
    
    assert garlicsim.misc.simpack_grokker.step_type.StepType.get_step_type(
        my_simpack_grokker.default_step_function
    ) == simpack._test_settings.DEFAULT_STEP_FUNCTION_TYPE
    
    step_profile = my_simpack_grokker.build_step_profile()
    deterministic = \
        my_simpack_grokker.settings.DETERMINISM_FUNCTION(step_profile)
    
    
    state = simpack.State.create_root()
    
    
    prev_state = state
    for i in [1, 2, 3, 4]:
        new_state = garlicsim.simulate(state, i)
        assert new_state.clock >= getattr(prev_state, 'clock', 0)
        prev_state = new_state
    
    result = garlicsim.list_simulate(state, 4)
    for item in result:
        assert isinstance(item, garlicsim.data_structures.State)
        assert isinstance(item, simpack.State)
    
    assert isinstance(result, list)
    assert len(result) == 5
        
    
    iter_result = garlicsim.iter_simulate(state, 4)
        
    assert not hasattr(iter_result, '__getitem__')
    assert hasattr(iter_result, '__iter__')
    iter_result_in_list = list(iter_result)
    del iter_result
    assert len(iter_result_in_list) == len(result) == 5

    
    ### Setting up a project to run asynchronous tests:
    
    project = garlicsim.Project(simpack)
        
    project.crunching_manager.cruncher_type = cruncher_type
    
    assert project.tree.lock._ReadWriteLock__writer is None
    
    root = project.root_this_state(state)
    
    
    project.begin_crunching(root, 4)

    total_nodes_added = 0    
    while project.crunching_manager.jobs:
        time.sleep(0.1)
        total_nodes_added += project.sync_crunchers()
        
    assert total_nodes_added == 4
    
    assert len(project.tree.nodes) == 5
    assert len(project.tree.roots) == 1
    
    paths = project.tree.all_possible_paths()
    
    assert len(paths) == 1
    
    (my_path,) = paths
        
    assert len(my_path) == 5
    
    node_1 = my_path[1]
    assert node_1.state.clock == 1
    
    node_2 = project.simulate(node_1, 3)
    
    assert len(project.tree.nodes) == 8
    assert len(project.tree.roots) == 1
    
    assert len(project.tree.all_possible_paths()) == 2

    block_1, block_2 = [node.block for node in node_1.children]
    assert isinstance(block_1, garlicsim.data_structures.Block)
    assert isinstance(block_2, garlicsim.data_structures.Block)
    assert block_1.soft_get_block() is block_1
    assert block_2.soft_get_block() is block_2
    assert block_1.is_overlapping(block_1)
    assert block_2.is_overlapping(block_2)
    assert not block_1.is_overlapping(block_2)
    assert not block_2.is_overlapping(block_1)
    block_path_1 = block_1.make_containing_path()
    block_path_2 = block_2.make_containing_path()
    assert block_path_1 == block_path_1
    assert block_path_1 != block_path_2
    assert (block_1[0] in block_path_1) and (block_1[-1] in block_path_1)
    assert (block_2[0] in block_path_2) and (block_2[-1] in block_path_2)
    assert block_1.get_root() is block_2.get_root()
    
        
 
    tree_members_iterator = \
        project.tree.iterate_tree_members(include_blockful_nodes=False)
    assert tree_members_iterator.__iter__() is tree_members_iterator
    tree_members = list(tree_members_iterator)
    assert (block_1 in tree_members) and (block_2 in tree_members)
    for tree_member in tree_members:
        if isinstance(tree_member, garlicsim.data_structures.Node):
            assert tree_member.block is None
    
    tree_members_iterator_including_blockful_nodes = \
        project.tree.iterate_tree_members(include_blockful_nodes=True)
    assert tree_members_iterator_including_blockful_nodes.__iter__() is \
        tree_members_iterator_including_blockful_nodes
    tree_members_including_blockful_nodes = \
        list(tree_members_iterator_including_blockful_nodes)
    
    blockful_nodes = \
        [member for member in tree_members_including_blockful_nodes if 
         member not in tree_members]
    for blockful_node in blockful_nodes:
        assert isinstance(blockful_node, garlicsim.data_structures.Node)
        assert isinstance(blockful_node.block, garlicsim.data_structures.Block)
        assert blockful_node.block is blockful_node.soft_get_block()
    assert set(tree_members).\
        issubset(set(tree_members_including_blockful_nodes))
    
    tree_step_profiles = project.tree.get_step_profiles()
    assert isinstance(tree_step_profiles, OrderedSet)
    assert tree_step_profiles == [step_profile]
    
########NEW FILE########
__FILENAME__ = test_pi_cloud_cruncher
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

import nose.tools

import garlicsim
from garlicsim.asynchronous_crunching.crunchers import PiCloudCruncher


def test_pi_cloud_cruncher():
    '''Test the `PiCloudCruncher` placeholder.'''
    # Allowing either `TypeError` or `NotImplementedError`:
    try:
        nose.tools.assert_raises(TypeError, PiCloudCruncher)
    except Exception:
        nose.tools.assert_raises(NotImplementedError, PiCloudCruncher)
    
        
    from test_garlicsim.test_misc.test_simpack_grokker.simpacks import simpack
    simpack_grokker = garlicsim.misc.SimpackGrokker(simpack)
    
    availability = \
        PiCloudCruncher.can_be_used_with_simpack_grokker(simpack_grokker)
    assert availability == False
########NEW FILE########
__FILENAME__ = state
import garlicsim.data_structures
from garlicsim.misc import WorldEnded

class State(garlicsim.data_structures.State):
    
    def __init__(self):
        pass
    
    @staticmethod
    def history_step(history_browser):
        assert isinstance(history_browser, garlicsim.misc.BaseHistoryBrowser)
        last_state = history_browser.get_last_state()
        last_state_clock = getattr(last_state, 'clock', 0)
        if last_state_clock >= 4:
            raise WorldEnded
        new_state = State()
        new_state.clock = last_state_clock + 1
        return new_state
        
    @staticmethod
    def create_root():
        return State()
    
########NEW FILE########
__FILENAME__ = _test_settings
import garlicsim

from .state import State

HISTORY_DEPENDENT = True
N_STEP_FUNCTIONS = 1
DEFAULT_STEP_FUNCTION = State.history_step
DEFAULT_STEP_FUNCTION_TYPE = \
    garlicsim.misc.simpack_grokker.step_types.HistoryStep
CONSTANT_CLOCK_INTERVAL = 1
ENDABLE = True
PROBLEM = None
VALID = True
CRUNCHERS_LIST = [garlicsim.asynchronous_crunching.crunchers.ThreadCruncher]

########NEW FILE########
__FILENAME__ = state
import garlicsim.data_structures
from garlicsim.misc import WorldEnded

class State(garlicsim.data_structures.State):
    
    def __init__(self):
        pass
    
    def step(self):
        if getattr(self, 'clock', 0) >= 4:
            raise WorldEnded
        return State()
        
    @staticmethod
    def create_root():
        return State()
    
########NEW FILE########
__FILENAME__ = _test_settings
from garlicsim.general_misc import import_tools

import garlicsim

from .state import State

HISTORY_DEPENDENT = False
N_STEP_FUNCTIONS = 1
DEFAULT_STEP_FUNCTION = State.step
DEFAULT_STEP_FUNCTION_TYPE = \
    garlicsim.misc.simpack_grokker.step_types.SimpleStep
CONSTANT_CLOCK_INTERVAL = 1
ENDABLE = True
PROBLEM = None
VALID = True
CRUNCHERS_LIST = \
    [garlicsim.asynchronous_crunching.crunchers.ThreadCruncher] + \
    (
        [garlicsim.asynchronous_crunching.crunchers.ProcessCruncher] if 
        import_tools.exists('multiprocessing')
        else []
    )

########NEW FILE########
__FILENAME__ = state
import garlicsim.data_structures
from garlicsim.misc import WorldEnded

class State(garlicsim.data_structures.State):
    
    def __init__(self):
        pass
    
    def step_generator(self):
        current_state = self
        while True:    
            if current_state.clock >= 4:
                raise WorldEnded
            old_clock = getattr(current_state, 'clock', 0)
            current_state = State()
            current_state.clock = old_clock + 1
            yield current_state
    
    def step(self):
        if getattr(self, 'clock', 0) >= 4:
            raise WorldEnded
        return State()
            
    @staticmethod
    def create_root():
        return State()
    
########NEW FILE########
__FILENAME__ = _test_settings
from garlicsim.general_misc import import_tools

import garlicsim

from .state import State

HISTORY_DEPENDENT = False
N_STEP_FUNCTIONS = 2
DEFAULT_STEP_FUNCTION_TYPE = \
    garlicsim.misc.simpack_grokker.step_types.StepGenerator
DEFAULT_STEP_FUNCTION = State.step_generator
CONSTANT_CLOCK_INTERVAL = 1
ENDABLE = True
PROBLEM = None
VALID = True
CRUNCHERS_LIST = \
    [garlicsim.asynchronous_crunching.crunchers.ThreadCruncher] + \
    (
        [garlicsim.asynchronous_crunching.crunchers.ProcessCruncher] if 
        import_tools.exists('multiprocessing')
        else []
    )
########NEW FILE########
__FILENAME__ = state
import garlicsim.data_structures
from garlicsim.misc import WorldEnded

class State(garlicsim.data_structures.State):
    
    def __init__(self):
        pass
    
    def step_generator(self):
        current_state = self
        while True:    
            if current_state.clock >= 4:
                raise WorldEnded
            old_clock = getattr(current_state, 'clock', 0)
            current_state = State()
            current_state.clock = old_clock + 1
            yield current_state
            
    @staticmethod
    def create_root():
        return State()
    
########NEW FILE########
__FILENAME__ = _test_settings
from garlicsim.general_misc import import_tools

import garlicsim

from .state import State

HISTORY_DEPENDENT = False
N_STEP_FUNCTIONS = 1
DEFAULT_STEP_FUNCTION = State.step_generator
DEFAULT_STEP_FUNCTION_TYPE = \
    garlicsim.misc.simpack_grokker.step_types.StepGenerator
CONSTANT_CLOCK_INTERVAL = 1
ENDABLE = True
PROBLEM = None
VALID = True
CRUNCHERS_LIST = \
    [garlicsim.asynchronous_crunching.crunchers.ThreadCruncher] + \
    (
        [garlicsim.asynchronous_crunching.crunchers.ProcessCruncher] if 
        import_tools.exists('multiprocessing')
        else []
    )
########NEW FILE########
__FILENAME__ = test_endable
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.


from __future__ import division

import os
import types
import time
import itertools
import cPickle, pickle

import nose

from garlicsim.general_misc import cute_iter_tools
from garlicsim.general_misc import math_tools
from garlicsim.general_misc import path_tools
from garlicsim.general_misc import import_tools
from garlicsim.general_misc.infinity import infinity
from garlicsim.general_misc.nifty_collections import OrderedSet

import garlicsim

import test_garlicsim

from ..shared import MustachedThreadCruncher


def non_ending_inplace_step(state):
    '''A no-op inplace step that doesn't end the simulation.'''
    pass


def non_ending_history_step(history_browser):
    '''A minimal history step that doesn't end the simulation.'''
    old_state = history_browser[-1]
    new_state = garlicsim.misc.state_deepcopy.state_deepcopy(old_state)
    new_state.clock += 1
    return new_state


def test_endable():
    '''
    Test handling of endable simpacks.
    
    All simpacks end when they get a world-state with clock reading of 4 or
    more.
    '''
    
    from . import simpacks as simpacks_package
    
    # Collecting all the test simpacks:
    simpacks = import_tools.import_all(simpacks_package).values()
    
    # Making sure that we didn't miss any simpack by counting the number of
    # sub-folders in the `simpacks` folder:
    simpacks_dir = \
        os.path.dirname(simpacks_package.__file__)
    assert len(path_tools.list_sub_folders(simpacks_dir)) == \
           len(simpacks)
    
    for simpack in simpacks:

        test_garlicsim.verify_simpack_settings(simpack)
        
        cruncher_types = \
            garlicsim.misc.SimpackGrokker(simpack).available_cruncher_types
        
        for cruncher_type in cruncher_types:
            yield check, simpack, cruncher_type

        
def check(simpack, cruncher_type):
    
    assert simpack._test_settings.ENDABLE is True
    assert simpack._test_settings.CONSTANT_CLOCK_INTERVAL == 1
    
    my_simpack_grokker = garlicsim.misc.SimpackGrokker(simpack)
    
    assert my_simpack_grokker is garlicsim.misc.SimpackGrokker(simpack)
    # Ensuring caching works.
    
    assert garlicsim.misc.simpack_grokker.step_type.StepType.get_step_type(
        my_simpack_grokker.default_step_function
    ) == simpack._test_settings.DEFAULT_STEP_FUNCTION_TYPE
    
    step_profile = my_simpack_grokker.build_step_profile()
    deterministic = \
        my_simpack_grokker.settings.DETERMINISM_FUNCTION(step_profile)
    
    state = simpack.State.create_root()
    
    ### Running for short periods synchronically so it doesn't end: ###########
    #                                                                         #
    
    # Whether we run the simulation for one, two, three, or four iterations,
    # the simulation doesn't end.
    prev_state = state
    for i in [1, 2, 3, 4]:
        new_state = garlicsim.simulate(state, i)
        assert new_state.clock >= getattr(prev_state, 'clock', 0)
        prev_state = new_state
    
    result = garlicsim.list_simulate(state, 4)
    for item in result:
        assert isinstance(item, garlicsim.data_structures.State)
        assert isinstance(item, simpack.State)
    
    assert isinstance(result, list)
    assert len(result) == 5
        
    
    iter_result = garlicsim.iter_simulate(state, 4)
        
    assert not hasattr(iter_result, '__getitem__')
    assert hasattr(iter_result, '__iter__')
    iter_result_in_list = list(iter_result)
    del iter_result
    assert len(iter_result_in_list) == len(result) == 5
    
    #                                                                         #
    ### Done running for short periods synchronically so it doesn't end. ######
    
    ### Now, let's run it for longer periods synchronically to make it end: ###
    #                                                                         #
    
    for i in [5, 6, 7]:
        new_state = garlicsim.simulate(state, i)
        assert new_state.clock == 4
    
    result = garlicsim.list_simulate(state, 7)
    
    assert isinstance(result, list)
    assert len(result) == 5
        
    
    iter_result = garlicsim.iter_simulate(state, 7)
        
    assert not hasattr(iter_result, '__getitem__')
    assert hasattr(iter_result, '__iter__')
    iter_result_in_list = list(iter_result)
    del iter_result
    assert len(iter_result_in_list) == len(result) == 5
        
    #                                                                         #
    ### Done running for longer periods synchronically to make it end. ########
    
    ### Setting up a project to run asynchronous tests:
    
    project = garlicsim.Project(simpack) 
        
    project.crunching_manager.cruncher_type = cruncher_type
    
    assert project.tree.lock._ReadWriteLock__writer is None
    
    root = project.root_this_state(state)
    
    def get_all_ends():
        return [member for member in project.tree.iterate_tree_members() if 
                isinstance(member, garlicsim.data_structures.End)]
    
    assert len(get_all_ends()) == 0
    
    ### Running for short periods asynchronically so it doesn't end: ##########
    #                                                                         #
    
    project.begin_crunching(root, 4)

    total_nodes_added = 0    
    while project.crunching_manager.jobs:
        time.sleep(0.1)
        total_nodes_added += project.sync_crunchers()
        
    assert total_nodes_added == 4
    
    assert len(project.tree.nodes) == 5
    assert len(project.tree.roots) == 1
    
    paths = project.tree.all_possible_paths()
    
    assert len(paths) == 1
    
    (my_path,) = paths
        
    assert len(my_path) == 5
    
    node_1 = my_path[1]
    assert node_1.state.clock == 1
    
    node_2 = project.simulate(node_1, 3)
    
    assert len(project.tree.nodes) == 8
    assert len(project.tree.roots) == 1
    
    assert len(project.tree.all_possible_paths()) == 2
    
    assert len(get_all_ends()) == 0
    
    #                                                                         #
    ### Done running for short periods asynchronically so it doesn't end. #####
    
    ### Now, let's run it for longer periods asynchronically to make it end: ##
    #                                                                         #
    
    node_3 = my_path.next_node(node_1)
    assert node_3.state.clock == 2
    project.begin_crunching(node_3, 3)
    
    total_nodes_added = 0
    while project.crunching_manager.jobs:
        time.sleep(0.1)
        total_nodes_added += project.sync_crunchers()
    assert total_nodes_added == 2 # Would have been 3 without the end!
    
    assert len(get_all_ends()) == 1
    
    # So now `node_3`'s newer path has an end:
    ended_path = node_3.all_possible_paths()[1]
    isinstance(ended_path, garlicsim.data_structures.Path)
    (end,) = ended_path.get_ends_of_last_node() # (Asserting there's one end.)
    assert isinstance(end, garlicsim.data_structures.End)
    
    assert len(project.tree.nodes) == 10
    
    paths = project.tree.all_possible_paths()
    assert len(paths) == 3
    
    assert [len(p) for p in paths] == [5, 5, 5]
    
    
    # Ensuring buffer on `ended_path` from `node_3` won't cause a new job to be
    # created since we have a path to an existing end:
    project.ensure_buffer_on_path(node_3, ended_path, 10)
    project.ensure_buffer_on_path(node_3, ended_path, 1000)
    project.ensure_buffer_on_path(node_3, ended_path, infinity)
    total_nodes_added = 0    
    assert not project.crunching_manager.jobs
    assert len(project.tree.nodes) == 10
    
    # These `ensure_buffer_on_path` calls shouldn't have added any ends:
    assert len(get_all_ends()) == 1
    
    # But `node_3` has the older path coming out of it which goes all the way to
    # clock 4 but doesn't terminate in an `End`:
    other_path = node_3.all_possible_paths()[0]
    assert other_path.get_ends_of_last_node() == []
    
    # And when we `ensure_buffer` from `node_3`, it will ensure a buffer on that
    # path also, and cause an `End` to be created there:
    project.ensure_buffer(node_3, 1000)
    total_nodes_added = 0    
    while project.crunching_manager.jobs:
        time.sleep(0.1)
        total_nodes_added += project.sync_crunchers()
    assert len(project.tree.nodes) == 10
    assert len(get_all_ends()) == 2
    
    
    plain_root = project.create_root()
    
    assert len(project.tree.roots) == 2
    assert len(project.tree.all_possible_paths()) == 4
    assert len(project.tree.nodes) == 11
    
    iterator = project.iter_simulate(node_1, 10)
    new_node = iterator.next()
    assert new_node is node_1
    assert len(project.tree.nodes) == 11
    
    assert project.tree.lock._ReadWriteLock__writer is None
    
    new_node = iterator.next()
    assert new_node is not node_1
    assert new_node.parent is node_1
    assert len(project.tree.nodes) == 12
    
    bunch_of_new_nodes = tuple(iterator)
    consecutive_pairs = cute_iter_tools.consecutive_pairs(bunch_of_new_nodes)
    for parent_node, kid_node in consecutive_pairs:
        assert project.tree.lock._ReadWriteLock__writer is None
        assert isinstance(parent_node, garlicsim.data_structures.Node)
        assert isinstance(kid_node, garlicsim.data_structures.Node)
        assert parent_node.children == [kid_node]
        assert kid_node.parent is parent_node
        
    assert len(project.tree.nodes) == 14

    assert len(get_all_ends()) == 3
    
        
    tree_members_iterator = \
        project.tree.iterate_tree_members(include_blockful_nodes=False)
    assert tree_members_iterator.__iter__() is tree_members_iterator
    tree_members = list(tree_members_iterator)
    for tree_member in tree_members:
        if isinstance(tree_member, garlicsim.data_structures.Node):
            assert tree_member.block is None
            
    tree_members_iterator_including_blockful_nodes = \
        project.tree.iterate_tree_members()
    assert tree_members_iterator_including_blockful_nodes.__iter__() is \
        tree_members_iterator_including_blockful_nodes
    tree_members_including_blockful_nodes = \
        list(tree_members_iterator_including_blockful_nodes)
    
    
    blockful_nodes = \
        [member for member in tree_members_including_blockful_nodes if 
         member not in tree_members]
    assert len(blockful_nodes) >= 1
    for blockful_node in blockful_nodes:
        assert isinstance(blockful_node, garlicsim.data_structures.Node)
        assert isinstance(blockful_node.block, garlicsim.data_structures.Block)
        assert blockful_node.block is blockful_node.soft_get_block()
    assert set(tree_members).\
        issubset(set(tree_members_including_blockful_nodes))
    
    tree_step_profiles = project.tree.get_step_profiles()
    assert isinstance(tree_step_profiles, OrderedSet)
    assert tree_step_profiles == [step_profile]
    
    ends = [member for member in tree_members if 
            isinstance(member, garlicsim.data_structures.End)]
    assert len(ends) == 3
    for end in ends:
        assert end in tree_members_including_blockful_nodes
        
    ### Testing `Project.simulate`: ###########################################
    #                                                                         #
    
    project.simulate(root, 4)
    assert len(get_all_ends()) == 3
    
    project.simulate(root, 5)
    assert len(get_all_ends()) == 4
    
    #                                                                         #
    ### Finished testing `Project.simulate`. ##################################
    
    ### Testing end creation in middle of block: ##############################
    #                                                                         #
    
    my_non_ending_step = non_ending_history_step if \
        my_simpack_grokker.history_dependent else non_ending_inplace_step
    
    nodes_in_tree = len(project.tree.nodes)
    nodes = list(project.iter_simulate(root, 8, my_non_ending_step))
    assert len(project.tree.nodes) == nodes_in_tree + 8
    
    middle_node = nodes[-4]
    assert middle_node.state.clock == 5
    assert nodes[1].block == middle_node.block == nodes[-1].block
    assert len(middle_node.block) == 8
    

    project.begin_crunching(middle_node, infinity, step_profile)
    total_nodes_added = 0
    assert project.crunching_manager.jobs
    while project.crunching_manager.jobs:
        time.sleep(0.1)
        total_nodes_added += project.sync_crunchers()
    assert total_nodes_added == 0
    
    assert len(middle_node.ends) == 1
    assert middle_node.block is not nodes[-1].block
    assert len(middle_node.block) == 5
    assert len(nodes[-1].block) == 3
        
    #                                                                         #
    ### Finished testing end creation in middle of block. #####################
    
    
    
########NEW FILE########
__FILENAME__ = test_garlicsim_lib_simpacks
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Test `garlicsim_lib` simpacks.'''

from __future__ import division

import types
import time
import itertools
import cPickle, pickle

import nose

from garlicsim.general_misc import cute_iter_tools
from garlicsim.general_misc import math_tools
from garlicsim.general_misc.infinity import infinity

import garlicsim
from garlicsim_lib.simpacks import life
from garlicsim_lib.simpacks import prisoner
from garlicsim_lib.simpacks import _history_test
from garlicsim_lib.simpacks import queue

from .shared import MustachedThreadCruncher

FUZZ = 0.0001
'''Fuzziness of floats.'''


def _is_deterministic(simpack):
    return simpack.__name__.split('.')[-1] == 'life'


def test():
    '''Test `garlicsim_lib` simpacks.'''
    simpacks = [life, prisoner, _history_test, queue]
    
    for simpack in simpacks:
        
        cruncher_types = \
            garlicsim.misc.SimpackGrokker(simpack).available_cruncher_types
        
        for cruncher_type in cruncher_types:
            yield check, simpack, cruncher_type
        

        
def check(simpack, cruncher_type):
    
    my_simpack_grokker = garlicsim.misc.SimpackGrokker(simpack)
    
    assert my_simpack_grokker is garlicsim.misc.SimpackGrokker(simpack)
    # Ensuring caching works.
    
    empty_step_profile = garlicsim.misc.StepProfile(
        my_simpack_grokker.default_step_function
    )
    
    state = simpack.State.create_messy_root() if \
          simpack.State.create_messy_root else \
          simpack.State.create_root()
    
    new_state = garlicsim.simulate(state, 3)
    
    result = garlicsim.list_simulate(state, 3)
    for item in result:
        assert isinstance(item, garlicsim.data_structures.State)
        assert isinstance(item, simpack.State)
    
    assert isinstance(result, list)
    assert len(result) == 4
    
    if _is_deterministic(simpack):    
        for old, new in cute_iter_tools.consecutive_pairs(result):
            assert new == my_simpack_grokker.step(old, empty_step_profile)
            
    
    iter_result = garlicsim.iter_simulate(state, 3)
    
    
    assert not hasattr(iter_result, '__getitem__')
    assert hasattr(iter_result, '__iter__')
    iter_result_in_list = list(iter_result)
    del iter_result
    assert len(iter_result_in_list) == len(result) == 4
    if _is_deterministic(simpack):
        assert iter_result_in_list == result
        assert iter_result_in_list[-1] == new_state == result[-1]
        
    
    
    project = garlicsim.Project(simpack)
    
    # Ensure that `Project.__init__` can take simpack grokker:
    alterante_project = garlicsim.Project(my_simpack_grokker)
    project.simpack is alterante_project.simpack
    project.simpack_grokker is alterante_project.simpack_grokker
    
    
    project.crunching_manager.cruncher_type = cruncher_type
    
    assert project.tree.lock._ReadWriteLock__writer is None
    
    root = project.root_this_state(state)
    
    project.begin_crunching(root, 4)

    total_nodes_added = 0    
    while project.crunching_manager.jobs:
        time.sleep(0.1)
        total_nodes_added += project.sync_crunchers()
        
    x = total_nodes_added
    
    if x < 4:
        # For simpacks with long time intervals, we make sure at least 4 nodes
        # were created.
        path = root.make_containing_path()
        leaf = path[-1]
        project.simulate(
            leaf,
            math_tools.round_to_int(4 - x, up=True)
        )
        x += path.__len__(head=path.next_node(leaf))
            
    assert len(project.tree.nodes) == x + 1
    assert len(project.tree.roots) == 1
    
    paths = project.tree.all_possible_paths()
    
    assert len(paths) == 1
    
    (my_path,) = paths
        
    assert len(my_path) == x + 1
    
    node_1 = my_path[1]
    
    node_2 = project.simulate(node_1, 3)
    
    assert len(project.tree.nodes) == x + 1 + 3
    assert len(project.tree.roots) == 1
    
    assert len(project.tree.all_possible_paths()) == 2
    
    
    ### Testing project pickling and unpickling: ##############################
    #                                                                         #
    pickled_project = pickle.dumps(project, protocol=2)
    
    unpickled_project = cPickle.loads(pickled_project)
    path_pairs = itertools.izip(project.tree.all_possible_paths(),
                                unpickled_project.tree.all_possible_paths())
    
    if simpack.State.__eq__ != garlicsim.data_structures.State.__eq__:
        
        for path_of_original, path_of_duplicate in path_pairs:
            
            state_pairs = itertools.izip(path_of_original.states(),
                                         path_of_duplicate.states())
            for state_of_original, state_of_duplicate in state_pairs:
                
                assert state_of_original == state_of_duplicate
    #                                                                         #
    ### Finished testing project pickling and unpickling. #####################
            
    
    
    node_3 = my_path.next_node(node_1)
    
    project.begin_crunching(node_3, 3)
    
    total_nodes_added = 0
    while project.crunching_manager.jobs:
        time.sleep(0.1)
        total_nodes_added += project.sync_crunchers()
    y = total_nodes_added
        
    if y < 3:
        # For simpacks with long time intervals, we make sure at least 3 nodes
        # were created.
        path = node_3.children[1].make_containing_path()
        leaf = path[-1]
        project.simulate(
            leaf,
            math_tools.round_to_int(3 - y, up=True)
        )
        y += path.__len__(head=path.next_node(leaf))
    
    
    assert len(project.tree.nodes) == x + y + 4
    
    paths = project.tree.all_possible_paths()
    assert len(paths) == 3
    
    assert [len(p) for p in paths] == [x + 1, 3 + y, 5]
    
    for (_path_1, _path_2) in cute_iter_tools.consecutive_pairs(paths):
        assert _path_1._get_higher_path(node=root) == _path_2
        
    for _path in paths:
        assert _path.copy() == _path
    
    
    project.ensure_buffer(node_3, 3)

    total_nodes_added = 0
    while project.crunching_manager.jobs:
        time.sleep(0.1)
        total_nodes_added += project.sync_crunchers()
    
    assert len(project.tree.nodes) == x + y + 4 + total_nodes_added
    assert len(project.tree.all_possible_paths()) == 3
    
    assert project.tree.lock._ReadWriteLock__writer is None
    
    two_paths = node_3.all_possible_paths()
    
    assert len(two_paths) == 2
    (path_1, path_2) = two_paths
    get_clock_buffer = lambda path: (path[-1].state.clock - node_3.state.clock)
    (clock_buffer_1, clock_buffer_2) = [get_clock_buffer(p) for p in two_paths]
    
    project.ensure_buffer_on_path(node_3, path_1, get_clock_buffer(path_1) * 1.2)
    
    total_nodes_added = 0
    while project.crunching_manager.jobs:
        time.sleep(0.1)
        total_nodes_added += project.sync_crunchers()
    
    (old_clock_buffer_1, old_clock_buffer_2) = (clock_buffer_1, clock_buffer_2)
    (clock_buffer_1, clock_buffer_2) = [get_clock_buffer(p) for p in two_paths]
    
    assert clock_buffer_1 / old_clock_buffer_1 >= 1.2 - FUZZ
    assert clock_buffer_2 == old_clock_buffer_2
    
    project.ensure_buffer_on_path(node_3, path_2, get_clock_buffer(path_2) * 1.3)
    
    total_nodes_added = 0
    while project.crunching_manager.jobs:
        time.sleep(0.1)
        total_nodes_added += project.sync_crunchers()
    
    (old_clock_buffer_1, old_clock_buffer_2) = (clock_buffer_1, clock_buffer_2)
    (clock_buffer_1, clock_buffer_2) = [get_clock_buffer(p) for p in two_paths]
    
    assert clock_buffer_1 == old_clock_buffer_1
    assert clock_buffer_2 / old_clock_buffer_2 >= 1.3 - FUZZ
    
    
    
    plain_root = project.create_root()
    
    assert len(project.tree.roots) == 2
    
    assert len(project.tree.all_possible_paths()) == 4
    
    
    
    assert project.tree.lock._ReadWriteLock__writer is None
    
    number_of_nodes = len(project.tree.nodes)
    iterator = project.iter_simulate(plain_root, 5)
    
    assert project.tree.lock._ReadWriteLock__writer is None
    
    new_node = iterator.next()
    assert new_node is plain_root
    assert len(project.tree.nodes) == number_of_nodes
    
    assert project.tree.lock._ReadWriteLock__writer is None
    
    new_node = iterator.next()
    assert new_node is not plain_root
    assert new_node.parent is plain_root
    assert len(project.tree.nodes) == number_of_nodes + 1
    
    bunch_of_new_nodes = tuple(iterator)
    consecutive_nodes = cute_iter_tools.consecutive_pairs(bunch_of_new_nodes)
    for parent_node, kid_node in consecutive_nodes:
        assert project.tree.lock._ReadWriteLock__writer is None
        assert isinstance(parent_node, garlicsim.data_structures.Node)
        assert isinstance(kid_node, garlicsim.data_structures.Node)
        assert parent_node.children == [kid_node]
        assert kid_node.parent is parent_node
        
    assert len(project.tree.nodes) == number_of_nodes + 5
    
    (alternate_path,) = plain_root.all_possible_paths()
    assert isinstance(alternate_path, garlicsim.data_structures.Path)
    assert alternate_path == plain_root.make_containing_path()
    assert len(alternate_path) == 6
    all_except_root = list(alternate_path)[1:]
    
    ((_key, _value),) = plain_root.get_all_leaves().items()
    assert _key is alternate_path[-1]
    assert _value['nodes_distance'] == 5
    assert 'clock_distance' in _value # Can't know the value of that.
    
    block = all_except_root[0].block
    assert isinstance(block, garlicsim.data_structures.Block)
    for node in all_except_root:
        assert isinstance(node, garlicsim.data_structures.Node)
        assert node.block is node.soft_get_block() is block
        nose.tools.assert_raises(garlicsim.data_structures.NodeError,
                                 node.finalize)
        assert node.get_root() is plain_root
        assert node.get_ancestor(generations=0) is node
        assert node.get_ancestor(generations=infinity, round=True) is \
            plain_root
        nose.tools.assert_raises(
            garlicsim.data_structures.node.NodeLookupError,
            lambda: node.get_ancestor(generations=infinity, round=False)
        )
        nose.tools.assert_raises(
            garlicsim.data_structures.node.NodeLookupError,
            lambda: node.get_ancestor(generations=100, round=False)
        )
        if node.is_last_on_block():
            assert block[-1] is node
            assert node.get_ancestor(generations=2, round=False) is \
                block[-3]
            assert node.get_ancestor(generations=1, round=True) is \
                block[-2] is node.parent
        if node.is_first_on_block():
            assert block[0] is node
        
    assert set(all_except_root) == set(block)
    
    second_on_block = block[1]
    second_to_last_on_block = block[-2]
    assert second_to_last_on_block.state.clock > second_on_block.state.clock
    assert list(
        alternate_path.iterate_blockwise(
            second_on_block,
            second_to_last_on_block
        )
    ) == list(block[1:-1])
    assert list(
        alternate_path.iterate_blockwise_reversed(
            second_on_block,
            second_to_last_on_block
        )
    ) == list(block[-2:0:-1])
    
    ### Testing path methods: #################################################
    #                                                                         #

    empty_path = garlicsim.data_structures.Path(project.tree)
    assert len(empty_path) == 0
    assert list(empty_path) == []
    assert list(reversed(empty_path)) == []
    assert list(empty_path.iterate_blockwise()) == []
    assert list(empty_path.iterate_blockwise_reversed()) == []
    
    
    for (path, other_path) in [(path_1, path_2), (path_2, path_1)]:
        assert isinstance(path, garlicsim.data_structures.Path)
        assert path[-1] is path.get_last_node()
        node_list = list(path)
        reversed_node_list = list(reversed(path))
        assert node_list == list(reversed(reversed_node_list))
        assert list(path.iterate_blockwise()) == \
            list(reversed(list(path.iterate_blockwise_reversed(tail=path[-1]))))
        stranger_node = other_path[-1] 
        assert stranger_node not in path
        nose.tools.assert_raises(
            garlicsim.data_structures.path.TailNotReached,
            lambda: list(path.__iter__(tail=stranger_node))
        )
        
    
    #                                                                         #
    ### Finished testing path methods. ########################################
    
    
    if simpack.State.create_messy_root is not None:
        messy_root = project.create_messy_root()
        assert len(project.tree.roots) == 3
        assert messy_root is project.tree.roots[-1]
        assert isinstance(messy_root.state, simpack.State)
        
    
    
    
        
    
    
    
########NEW FILE########
__FILENAME__ = state
import time

import garlicsim.data_structures
from garlicsim.misc import WorldEnded


class State(garlicsim.data_structures.State):
    
    def __init__(self):
        pass
    
    @staticmethod
    def history_step(history_browser):
        assert isinstance(history_browser, garlicsim.misc.BaseHistoryBrowser)
        
        time.sleep(0.1)
        last_state = history_browser.get_last_state()
        last_state_clock = getattr(last_state, 'clock', 0)
        new_state = State()
        new_state.clock = last_state_clock + 1
        return new_state
        
    @staticmethod
    def create_root():
        return State()
    
########NEW FILE########
__FILENAME__ = _test_settings
import garlicsim

from .state import State

HISTORY_DEPENDENT = True
N_STEP_FUNCTIONS = 1
DEFAULT_STEP_FUNCTION = State.history_step
DEFAULT_STEP_FUNCTION_TYPE = \
    garlicsim.misc.simpack_grokker.step_types.HistoryStep
CONSTANT_CLOCK_INTERVAL = 1
ENDABLE = False
PROBLEM = None
VALID = True
CRUNCHERS_LIST = [garlicsim.asynchronous_crunching.crunchers.ThreadCruncher]

########NEW FILE########
__FILENAME__ = state
import time

import garlicsim.data_structures
from garlicsim.misc import WorldEnded

class State(garlicsim.data_structures.State):
    
    def __init__(self):
        pass
    
    def step(self):
        time.sleep(0.1)
        return State()
        
    @staticmethod
    def create_root():
        return State()
    
########NEW FILE########
__FILENAME__ = _test_settings
from garlicsim.general_misc import import_tools

import garlicsim

from .state import State

HISTORY_DEPENDENT = False
N_STEP_FUNCTIONS = 1
DEFAULT_STEP_FUNCTION = State.step
DEFAULT_STEP_FUNCTION_TYPE = \
    garlicsim.misc.simpack_grokker.step_types.SimpleStep
CONSTANT_CLOCK_INTERVAL = 1
ENDABLE = False
PROBLEM = None
VALID = True
CRUNCHERS_LIST = \
    [garlicsim.asynchronous_crunching.crunchers.ThreadCruncher] + \
    (
        [garlicsim.asynchronous_crunching.crunchers.ProcessCruncher] if 
        import_tools.exists('multiprocessing')
        else []
    )

########NEW FILE########
__FILENAME__ = state
import time

import garlicsim.data_structures
from garlicsim.misc import WorldEnded


class State(garlicsim.data_structures.State):
    
    def __init__(self):
        pass
    
    def step_generator(self):
        current_state = self
        while True:
            time.sleep(0.1)
            old_clock = getattr(current_state, 'clock', 0)
            current_state = State()
            current_state.clock = old_clock + 1
            yield current_state
    
    def step(self):
        time.sleep(0.1)
        return State()
            
    @staticmethod
    def create_root():
        return State()
    
########NEW FILE########
__FILENAME__ = _test_settings
from garlicsim.general_misc import import_tools

import garlicsim

from .state import State

HISTORY_DEPENDENT = False
N_STEP_FUNCTIONS = 2
DEFAULT_STEP_FUNCTION_TYPE = \
    garlicsim.misc.simpack_grokker.step_types.StepGenerator
DEFAULT_STEP_FUNCTION = State.step_generator
CONSTANT_CLOCK_INTERVAL = 1
ENDABLE = False
PROBLEM = None
VALID = True
CRUNCHERS_LIST = \
    [garlicsim.asynchronous_crunching.crunchers.ThreadCruncher] + \
    (
        [garlicsim.asynchronous_crunching.crunchers.ProcessCruncher] if 
        import_tools.exists('multiprocessing')
        else []
    )
########NEW FILE########
__FILENAME__ = tests
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.


from __future__ import division
from __future__ import with_statement

import re
import os
import types
import time
import itertools
import cPickle, pickle

import nose

from garlicsim.general_misc import cute_iter_tools
from garlicsim.general_misc import math_tools
from garlicsim.general_misc import path_tools
from garlicsim.general_misc import address_tools
from garlicsim.general_misc import import_tools
from garlicsim.general_misc.infinity import infinity

import garlicsim

import test_garlicsim

from ..shared import MustachedThreadCruncher


def test():
    '''Test changing things while crunching.'''
    from . import simpacks as simpacks_package
    
    # Collecting all the test simpacks:
    simpacks = import_tools.import_all(simpacks_package).values()
    
    # Making sure that we didn't miss any simpack by counting the number of
    # sub-folders in the `simpacks` folder:
    simpacks_dir = \
        os.path.dirname(simpacks_package.__file__)
    assert len(path_tools.list_sub_folders(simpacks_dir)) == \
           len(simpacks)
    
    for simpack in simpacks:
        
        test_garlicsim.verify_simpack_settings(simpack)
        
        cruncher_types = \
            garlicsim.misc.SimpackGrokker(simpack).available_cruncher_types
        
        for cruncher_type in cruncher_types:
            yield check, simpack, cruncher_type

        
def check(simpack, cruncher_type):
    
    
    my_simpack_grokker = garlicsim.misc.SimpackGrokker(simpack)
    
    assert my_simpack_grokker is garlicsim.misc.SimpackGrokker(simpack)
    # Ensuring caching works.
    
    assert garlicsim.misc.simpack_grokker.step_type.StepType.get_step_type(
        my_simpack_grokker.default_step_function
    ) == simpack._test_settings.DEFAULT_STEP_FUNCTION_TYPE
    
    step_profile = my_simpack_grokker.build_step_profile()
    deterministic = \
        my_simpack_grokker.settings.DETERMINISM_FUNCTION(step_profile)
    
    state = simpack.State.create_root()
    
    
    project = garlicsim.Project(simpack)
        
    project.crunching_manager.cruncher_type = cruncher_type
    
    assert project.tree.lock._ReadWriteLock__writer is None
    
    root = project.root_this_state(state)

    def run_sync_crunchers_until_we_get_at_least_one_node():
        while not project.sync_crunchers():
            time.sleep(0.1)

    ### Test changing clock target on the fly: ################################
    #                                                                         #

    huge_number = 10 ** 20
    different_huge_number = huge_number + 1
    assert different_huge_number - huge_number == 1
    
    job = project.begin_crunching(root, huge_number)    
    run_sync_crunchers_until_we_get_at_least_one_node()
    (cruncher,) = project.crunching_manager.crunchers.values()
    
    ## An interlude to test `__repr__` methods: ###############################
    
    step_profile_description = repr(job.crunching_profile.step_profile)
    assert step_profile_description == \
        'StepProfile(%s)' % simpack._test_settings.DEFAULT_STEP_FUNCTION
    
    short_step_profile_description = \
            job.crunching_profile.step_profile.__repr__(short_form=True)
    assert short_step_profile_description == \
        '%s(<state>)' % address_tools.describe(
            simpack._test_settings.DEFAULT_STEP_FUNCTION,
            shorten=True,
            root=simpack,
        )
    
    crunching_profile_description = repr(job.crunching_profile)
    assert crunching_profile_description == \
           'CrunchingProfile(clock_target=%d, step_profile=%s)' % \
           (huge_number, short_step_profile_description)
    
    job_description = repr(job)
    assert job_description == 'Job(node=%s, crunching_profile=%s)' % \
           (repr(job.node), crunching_profile_description)
    
    crunching_manager_description = repr(project.crunching_manager)
    assert re.match(
        ('^<.*?CrunchingManager currently employing 1 crunchers to '
         'handle 1 jobs at .*?>$'),
        crunching_manager_description
    )
    
    project_description = repr(project)
    assert re.match(
        '<.*?Project containing .*? nodes and employing 1 crunchers at .*?>',
        project_description
    )
    
    # Assert the job cruncher is not unequal to itself:
    assert not job.crunching_profile.__ne__(job.crunching_profile)
    
    ## Finished interlude to test `__repr__` methods. #########################
        
    job.crunching_profile.raise_clock_target(different_huge_number)
    # Letting our crunching manager update our cruncher about the new clock
    # target:
    project.sync_crunchers()
    assert not job.is_done()
    (same_cruncher,) = project.crunching_manager.crunchers.values()
    # todo: On slow machines cruncher doesn't get created fast enough for the
    # above assert to work. Probably make some function that waits for it.
    assert same_cruncher is cruncher
    
    # Deleting jobs so the cruncher will stop:
    del project.crunching_manager.jobs[:]
    project.sync_crunchers()
    assert not project.crunching_manager.jobs
    assert not project.crunching_manager.crunchers
    
    #                                                                         #
    ### Finish testing changing clock target on the fly. ######################
    
    ### Test changing step profile on the fly: ################################
    #                                                                         #
    
    # For simpacks providing more than one step function, we'll test changing
    # between them. This will exercise the crunching manager's policy of
    # switching crunchers immediately when the step profile for a job gets
    # changed.
    if simpack._test_settings.N_STEP_FUNCTIONS >= 2:        
        default_step_function, alternate_step_function = \
            my_simpack_grokker.all_step_functions[:2]
        job = project.begin_crunching(root, infinity)
        assert job.crunching_profile.step_profile.step_function == \
               default_step_function
        run_sync_crunchers_until_we_get_at_least_one_node()
        (cruncher,) = project.crunching_manager.crunchers.values()
        alternate_step_profile = \
            garlicsim.misc.StepProfile(alternate_step_function)
        job.crunching_profile.step_profile = alternate_step_profile
        # Letting our crunching manager get a new cruncher for our new step
        # profile:
        project.sync_crunchers()
        (new_cruncher,) = project.crunching_manager.crunchers.values()
        assert new_cruncher is not cruncher
        last_node_with_default_step_profile = job.node
        assert not last_node_with_default_step_profile.children # It's a leaf
        assert last_node_with_default_step_profile.\
               step_profile.step_function == default_step_function
        # Another `sync_crunchers`:
        run_sync_crunchers_until_we_get_at_least_one_node()
        # And now we have some new nodes with the alternate step profile.
        (first_node_with_alternate_step_profile,) = \
            last_node_with_default_step_profile.children
        path = last_node_with_default_step_profile.make_containing_path()
 
        nodes_with_alternate_step_profile = list(
            path.__iter__(head=first_node_with_alternate_step_profile)
        )
        for node in nodes_with_alternate_step_profile:
            assert node.step_profile == alternate_step_profile
        
        # Deleting jobs so the cruncher will stop:
        del project.crunching_manager.jobs[:]
        project.sync_crunchers()
        assert not project.crunching_manager.jobs
        assert not project.crunching_manager.crunchers
        
    #                                                                         #
    ### Finished testing changing step profile on the fly. ####################
    
    ### Testing cruncher type switching: ######################################
    #                                                                         #
    
    job_1 = project.begin_crunching(root, clock_buffer=infinity)
    job_2 = project.begin_crunching(root, clock_buffer=infinity)
    
    assert len(project.crunching_manager.crunchers) == 0
    assert project.sync_crunchers() == 0
    assert len(project.crunching_manager.crunchers) == 2
    (cruncher_1, cruncher_2) = project.crunching_manager.crunchers.values()
    assert type(cruncher_1) is cruncher_type
    assert type(cruncher_2) is cruncher_type
    
    time.sleep(0.2) # Letting the crunchers start working
    
    project.crunching_manager.cruncher_type = MustachedThreadCruncher
    project.sync_crunchers()
    assert len(project.crunching_manager.crunchers) == 2
    (cruncher_1, cruncher_2) = project.crunching_manager.crunchers.values()
    assert type(cruncher_1) is MustachedThreadCruncher
    assert type(cruncher_2) is MustachedThreadCruncher
    
    project.crunching_manager.cruncher_type = cruncher_type
    project.sync_crunchers()
    assert len(project.crunching_manager.crunchers) == 2
    (cruncher_1, cruncher_2) = project.crunching_manager.crunchers.values()
    assert type(cruncher_1) is cruncher_type
    assert type(cruncher_2) is cruncher_type
    
    # Deleting jobs so the crunchers will stop:
    del project.crunching_manager.jobs[:]
    project.sync_crunchers()
    assert not project.crunching_manager.jobs
    assert not project.crunching_manager.crunchers
    
    #                                                                         #
    ### Finished testing cruncher type switching. #############################
    
    
    
########NEW FILE########
__FILENAME__ = test_node_selection_and_range
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Tests for `node_selection` and `node_range`.'''

import copy
import nose
from garlicsim.general_misc import logic_tools

import garlicsim
from garlicsim import data_structures as ds
from garlicsim_lib.simpacks import life

def test_node_selection_and_range():
    '''Test `node_selection` and `node_range`.'''
    root_state = life.State.create_root(2, 2)
    project = garlicsim.Project(life)
    tree = project.tree
    root = project.root_this_state(root_state)
    leaf1 = project.simulate(root, 10)
    temp_path = root.make_containing_path()
    middle_node = temp_path[5]
    leaf2 = project.simulate(middle_node, 10)
    
    # Now we have a tree with a fork in it, in `middle_node`
    
    path1 = leaf1.make_containing_path() # creating only after leaf2
    path2 = leaf2.make_containing_path()    
    
    range1 = ds.NodeRange(root, leaf1)
    assert path1 == range1.make_path()
    range2 = ds.NodeRange(root, leaf2)
    assert path2 == range2.make_path()
    
    ns1 = ds.NodeSelection([range1, range2])
    ns2 = ns1.copy()
    assert ns1 == ns2
    
    ns2.compact()
    assert ns1 == ns2
    
    range1blocky = ds.NodeRange(root, leaf1.block)
    range2blocky = ds.NodeRange(root, leaf2.block)
    ns3 = ds.NodeSelection([range1blocky, range2blocky])
    
    ns4 = ns3.copy()
    ns4.compact()
    
    logic_tools.all_equal((ns1, ns2, ns3, ns4), exhaustive=True)
    
    all_ranges = sum((ns.ranges for ns in (ns1, ns2, ns3, ns4)), [])
    
    for range in all_ranges:
        assert range == range.clone_with_blocks_dissolved()
    
    assert len(tree.nodes) == 21
    
    #####################
    alt_tree, alt_ns1 = copy.deepcopy((tree, ns1))
    alt_tree.delete_node_selection(alt_ns1)
    assert len(alt_tree.nodes) == 0
    assert len(alt_tree.roots) == 0
    #####################

    assert len(tree.nodes) == 21
    
    middle_node_grandparent = middle_node.parent.parent    
    
    middle_node_grandchild_1 = path1.next_node(path1.next_node(middle_node))
    middle_node_grandchild_2 = path2.next_node(path2.next_node(middle_node))
    
    assert middle_node_grandchild_1 is not middle_node_grandchild_2
    
    small_range_1 = ds.NodeRange(middle_node_grandparent,
                                 middle_node_grandchild_1)
    small_range_2 = ds.NodeRange(middle_node_grandparent,
                                 middle_node_grandchild_2)
    
    assert small_range_1 != small_range_2
    
    small_ns = ds.NodeSelection((small_range_1, small_range_2))
    
    #####################
    alt_tree, alt_small_range_1 = copy.deepcopy((tree, small_range_1))
    alt_tree.delete_node_range(alt_small_range_1)
    assert len(alt_tree.roots) == 3
    assert len(alt_tree.nodes) == 16
    #####################
    
    #####################
    alt_tree, alt_small_range_2 = copy.deepcopy((tree, small_range_2))
    alt_tree.delete_node_range(alt_small_range_2)
    assert len(alt_tree.roots) == 3
    assert len(alt_tree.nodes) == 16
    #####################
    
    #####################
    alt_tree, alt_small_ns = copy.deepcopy((tree, small_ns))
    alt_tree.delete_node_selection(alt_small_ns)
    assert len(alt_tree.roots) == 3
    assert len(alt_tree.nodes) == 14
    #####################
    
    assert len(tree.nodes) == 21
    
########NEW FILE########
__FILENAME__ = test
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Testing module for tutorial-1.'''

import re
import time

def test():
    '''Test tutorial-1.'''
    life_board_pattern = re.compile('^(([ #]{45}\n){24})([ #]{45})$')
    import garlicsim
    from garlicsim_lib.simpacks import life
    state = life.State.create_messy_root()
    assert life_board_pattern.match(repr(state))
    assert repr(type(state)) == \
        "<class 'garlicsim_lib.simpacks.life.state.State'>"
    new_state = garlicsim.simulate(state)
    assert life_board_pattern.match(repr(new_state))
    new_state = garlicsim.simulate(state, 20)
    assert life_board_pattern.match(repr(new_state))
    result = garlicsim.list_simulate(state, 20)
    assert repr(type(result)) == "<type 'list'>"
    assert len(result) == 21
    assert life_board_pattern.match(repr(result[0]))
    assert result[0] == state
    assert life_board_pattern.match(repr(result[-1]))
    assert life_board_pattern.match(repr(result[7]))
    repr(garlicsim.iter_simulate(state, 5)) # Not testing cause of pypy et al.
    assert (list(garlicsim.iter_simulate(state, 5)) == \
            garlicsim.list_simulate(state, 5))
    
    project = garlicsim.Project(life)
    state = life.State.create_diehard()
    assert life_board_pattern.match(repr(state))
    assert repr(state).count('#') == 7
    root = project.root_this_state(state)
    assert repr(root) == \
        ('<garlicsim.data_structures.Node with clock 0, '
         'root, leaf, touched, blockless, at %s>' % hex(id(root)))
    project.begin_crunching(root, 50)
    _result = project.sync_crunchers()
    assert repr(_result) == '<0 nodes were added to the tree>'
    (cruncher,) = project.crunching_manager.crunchers.values()
    while cruncher.is_alive():
        time.sleep(0.1)
    _result = project.sync_crunchers()
    assert repr(_result) == '<50 nodes were added to the tree>'
    assert repr(project.tree) == (
        '<garlicsim.data_structures.Tree with 1 roots, '
        '51 nodes and 1 possible paths at %s>' % hex(id(project.tree))
    )
    (path,) = project.tree.all_possible_paths()
    assert repr(path) == (
        '<garlicsim.data_structures.Path of length 51 '
        'at %s>' % hex(id(path))
    )    
    assert repr(path[-1]) == (
        '<garlicsim.data_structures.Node with clock 50, leaf, untouched, '
        'blockful, crunched with life.State.step_generator(<state>), at '
        '%s>' % hex(id(path[-1])))
    _state = path[-1].state
    assert repr(_state).count('#') == 24
    assert life_board_pattern.match(repr(_state))
    node = path[27]
    assert repr(node.state).count('#') == 20
    assert life_board_pattern.match(repr(node.state))
    new_node = project.fork_to_edit(node)
    new_node.state.board.set(28, 13, True)
    assert repr(new_node.state).count('#') == 21
    assert life_board_pattern.match(repr(new_node.state))
    new_node.finalize()
    assert repr(project.tree) == (
        '<garlicsim.data_structures.Tree with 1 roots, '
        '52 nodes and 2 possible paths at %s>' % hex(id(project.tree))
    )
    project.ensure_buffer(root, 50)
    _result = project.sync_crunchers()
    assert repr(_result) == '<0 nodes were added to the tree>'
    (cruncher,) = project.crunching_manager.crunchers.values()
    while cruncher.is_alive():
        time.sleep(0.1)
    _result = project.sync_crunchers()
    assert repr(_result) == '<23 nodes were added to the tree>'
    new_path = new_node.make_containing_path()
    assert repr(new_path[-1].state).count('#') == 49
    assert life_board_pattern.match(repr(new_path[-1].state))



########NEW FILE########
__FILENAME__ = test
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Testing module for tutorial-2.'''

from __future__ import with_statement
from __future__ import division

import os.path
import shutil
import tempfile
import re
import types
import glob

from garlicsim.general_misc.temp_value_setters import \
    TempWorkingDirectorySetter
from garlicsim.general_misc import sys_tools
from garlicsim.general_misc import import_tools
from garlicsim.general_misc import cute_inspect
from garlicsim.general_misc import temp_file_tools

import garlicsim.scripts.simpack_template.simpack_name.state
import garlicsim.scripts.start_simpack
start_simpack_file = garlicsim.scripts.start_simpack.__file__

state_module_contents_for_coinflip = \
"""import random
import garlicsim.data_structures


class State(garlicsim.data_structures.State):

    def __init__(self, balance, last_bet_result=0):

        garlicsim.data_structures.State.__init__(self)

        self.balance = balance
        '''The current balance of our account, i.e. how much money we have.'''

        self.last_bet_result = last_bet_result
        '''How much we won/lost in the last bet. `-100` means we lost $100.'''


    def step(self):

        if self.balance >= 6000:
            raise garlicsim.misc.WorldEnded

        # First we need to calculate how much we're going to bet in this round.

        if self.last_bet_result >= 0:
            # Meaning either (1) we just started the simulation or (2) we
            # just won $100.
            amount_to_bet = 100 # We're starting a new cycle

        else:
            # If the flow reached here it means we just lost. So we
            # should bet double the amount:
            amount_to_bet = - 2 * self.last_bet_result

        if amount_to_bet > self.balance:
            # If we don't have the amount we should bet, we stop the simulation.
            # True, we can try to bet whatever's left, but for simplicity's sake
            # we won't do that now.
            raise garlicsim.misc.WorldEnded

        # Let's bet!
        bet_result = random.choice([amount_to_bet, - amount_to_bet])

        new_balance = self.balance + bet_result

        new_state = State(new_balance, bet_result)

        return new_state


    @staticmethod
    def create_root():
        return State(balance=5000)"""

def test():
    '''Test tutorial-2.'''
    # Asserting we don't have a `_coin_flip` on path already in some other
    # place:
    assert not import_tools.exists('_coin_flip')
    
    with temp_file_tools.TemporaryFolder(prefix='temp_test_garlicsim_') \
                                                          as temp_folder:
        with TempWorkingDirectorySetter(temp_folder):
            with sys_tools.OutputCapturer() as output_capturer:
                garlicsim.scripts.start_simpack.start(
                    argv=['start_simpack.py', '_coin_flip']
                )
            assert output_capturer.output == \
                ('`_coin_flip` simpack created successfully! Explore the '
                 '`_coin_flip` folder and start filling in the contents of '
                 'your new simpack.\n')
            simpack_path = os.path.join(temp_folder, '_coin_flip')
            assert os.path.isdir(simpack_path)
                                                                      
            state_module_path = os.path.join(simpack_path, 'state.py')
            
            assert_module_was_copied_with_correct_newlines(
                state_module_path,
                garlicsim.scripts.simpack_template.simpack_name.state
            )
            
            with open(state_module_path, 'w') as state_file:
                state_file.write(state_module_contents_for_coinflip)
                
                         
            with sys_tools.TempSysPathAdder(temp_folder):
                import _coin_flip
                
                assert _coin_flip.__doc__ == '\n_coin_flip description.\n'
                assert _coin_flip.name == '_coin_flip'                
                
                state = _coin_flip.State.create_root()
                assert repr(vars(state)) == \
                       "{'balance': 5000, 'last_bet_result': 0}"

                new_state = garlicsim.simulate(state, 5)
                assert repr(vars(new_state)) == \
                "{'balance': %s, 'clock': %s, 'last_bet_result': %s}" % \
                (new_state.balance, new_state.clock, new_state.last_bet_result)
                
                from garlicsim.general_misc.infinity import infinity
                
                got_winner = False
                got_loser = False
                while not (got_winner and got_loser):
                    new_state = garlicsim.simulate(state, infinity)
                    assert repr(vars(new_state)) == \
                           ("{'balance': %s, 'clock': %s, 'last_bet_result': "
                            "%s}" % (new_state.balance, new_state.clock,
                            new_state.last_bet_result))
                    assert new_state.balance <= 6000
                    if new_state.balance == 6000:
                        assert new_state.last_bet_result > 0
                        got_winner = True
                        continue
                    else:
                        assert new_state.last_bet_result < 0
                        assert new_state.balance <= \
                            (-2) * new_state.last_bet_result
                        got_loser = True
                        continue
                    
                states = garlicsim.list_simulate(state, infinity)
                len(states)
                assert re.match(
                    r'^\[5000(, \d+)+\]$',
                    repr([s.balance for s in states])
                )
                
                def get_end_balance():
                    return garlicsim.simulate(state, infinity).balance
                results = [get_end_balance() for i in range(100)]
                assert 3000 < (sum(results) / len(results)) < 6000
                assert 0.4 < (results.count(6000)/len(results)) < 0.95
            
            
    
        
def assert_module_was_copied_with_correct_newlines(destination_path,
                                                   source_module):
    '''
    Assert `source_module` was copied to `destination_path` with good newlines.
    
    e.g, on Linux/Mac the file should use '\n' for newlines, on Windows it
    should use '\r\n'.
    '''
    
    assert os.path.isfile(destination_path)
    assert isinstance(source_module, types.ModuleType)
    
    number_of_newlines = cute_inspect.getsource(source_module).count('\n')
    
    with open(destination_path, 'rb') as destination_file:
        destination_string = destination_file.read()
        
    assert destination_string.count(os.linesep) == number_of_newlines
    
    if os.linesep == '\n':
        assert '\r\n' not in destination_string
########NEW FILE########
__FILENAME__ = test_abstract_static_method
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Testing module for `garlicsim.general_misc.abc_tools.abstract_static_method`.
'''

import sys

import nose

from garlicsim.general_misc.abc_tools import abstract_static_method
from garlicsim.general_misc.third_party import abc


def test_instantiate_without_subclassing():
    '''Test you can't instantiate a class with an `abstract_static_method`.'''
    
    if sys.version_info[:2] <= (2, 5):
        raise nose.SkipTest("Python 2.5 and below can't enforce abstract "
                            "methods.")
    
    class A(object):
        __metaclass__ = abc.ABCMeta
        
        @abstract_static_method
        def f():
            pass
         
    nose.tools.assert_raises(TypeError, lambda: A())
    
        
def test_override():
    '''
    Can't instantiate subclass that doesn't override `abstract_static_method`.
    '''
    
    class B(object):
        __metaclass__ = abc.ABCMeta
        
        @abstract_static_method
        def f():
            pass
    
    class C(B):
        @staticmethod
        def f():
            return 7
        
    c = C()
    
    assert C.f() == c.f() == 7
    
    
########NEW FILE########
__FILENAME__ = test_describe
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Testing module for `garlicsim.general_misc.address_tools.describe`.'''

from __future__ import with_statement

import nose

from garlicsim.general_misc import import_tools
from garlicsim.general_misc.temp_value_setters import TempValueSetter

import garlicsim
from garlicsim.general_misc.address_tools import (describe,
                                                  resolve)


prefix = __name__ + '.'



def test_locally_defined_class():
    
    ###########################################################################
    # Testing for locally defined class:
    
    
    if garlicsim.__version_info__ <= (0, 6, 3):
        raise nose.SkipTest("This test doesn't pass in `garlicsim` version "
                            "0.6.3 and below, because `describe` doesn't "
                            "support nested classes yet.")
    
    result = describe(A.B)
    assert result == prefix + 'A.B'
    assert resolve(result) is A.B
    
    result = describe(A.C.D.deeper_method)
    assert result == prefix + 'A.C.D.deeper_method'
    assert resolve(result) == A.C.D.deeper_method
    
    result = describe(A.C.D.deeper_method, root=A.C)
    assert result == 'C.D.deeper_method'
    assert resolve(result, root=A.C) == A.C.D.deeper_method
    
    result = describe(A.C.D.deeper_method, root='A.C.D')
    assert result == 'D.deeper_method'
    assert resolve(result, root='A.C.D') == A.C.D.deeper_method
    
    
def test_stdlib():
    '''Test `describe` for various stdlib modules.'''
    
    import email.encoders
    result = describe(email.encoders)
    assert result == 'email.encoders'
    assert resolve(result) is email.encoders
    
    result = describe(email.encoders, root=email.encoders)
    assert result == 'encoders'
    assert resolve(result, root=email.encoders) is email.encoders
    
    result = describe(email.encoders, namespace=email)
    assert result == 'encoders'
    assert resolve(result, namespace=email) is email.encoders
    
    result = describe(email.encoders, root=email.encoders, namespace=email)
    assert result == 'encoders'
    assert resolve(result, root=email.encoders, namespace=email) is \
           email.encoders
    
    
def test_garlicsim():
    '''Test `describe` for various `garlicsim` modules.'''
    
    import garlicsim
    result = describe(garlicsim.data_structures.state.State)
    assert result == 'garlicsim.data_structures.state.State'
    assert resolve(result) is garlicsim.data_structures.state.State
    
    result = describe(garlicsim.data_structures.state.State, shorten=True)
    assert result == 'garlicsim.data_structures.State'
    assert resolve(result) is garlicsim.data_structures.state.State
    
    result = describe(garlicsim.Project, shorten=True)
    assert result == 'garlicsim.Project'
    assert resolve(result) is garlicsim.Project
    
    # When a root or namespace is given, it's top priority to use it, even if
    # it prevents shorterning and results in an overall longer address:
    result = describe(garlicsim.Project, shorten=True,
                      root=garlicsim.asynchronous_crunching)
    assert result == 'asynchronous_crunching.Project'
    assert resolve(result, root=garlicsim.asynchronous_crunching) is \
           garlicsim.Project
    
    result = describe(garlicsim.Project, shorten=True,
                      namespace=garlicsim)
    assert result == 'Project'
    assert resolve(result, namespace=garlicsim) is garlicsim.Project
    
    result = describe(garlicsim.Project, shorten=True,
                         namespace=garlicsim.__dict__)
    assert result == 'Project'
    assert resolve(result, namespace=garlicsim.__dict__) is \
           garlicsim.Project
    
    result = describe(garlicsim.Project, shorten=True,
                      namespace='garlicsim')
    assert result == 'Project'
    assert resolve(result, namespace='garlicsim') is garlicsim.Project
    
    result = describe(garlicsim.Project, shorten=True,
                      namespace='garlicsim.__dict__')
    assert result == 'Project'
    assert resolve(result, namespace='garlicsim.__dict__') is \
           garlicsim.Project
    
    result = describe(garlicsim.data_structures.state.State, root=garlicsim)
    assert result == 'garlicsim.data_structures.state.State'
    assert resolve(result, root=garlicsim) is \
           garlicsim.data_structures.state.State
    
    
    import garlicsim_lib.simpacks.life
    
    result = describe(garlicsim_lib.simpacks.life.state.State.step)
    assert result == 'garlicsim_lib.simpacks.life.state.State.step'
    
    result = describe(garlicsim_lib.simpacks.life.state.State.step,
                      shorten=True)
    assert result == 'garlicsim_lib.simpacks.life.State.step'
    
    result = describe(garlicsim_lib.simpacks.life.state.State.step,
                      root=garlicsim_lib.simpacks.life)
    assert result == 'life.state.State.step'
    
    result = describe(garlicsim_lib.simpacks.life.state.State.step,
                      namespace=garlicsim_lib.simpacks)
    assert result == 'life.state.State.step'
    
    result = describe(garlicsim_lib.simpacks.life.state.State.step,
                      root=garlicsim_lib.simpacks.life, shorten=True)
    assert result == 'life.State.step'
    
    
def test_local_modules():
    '''Test `describe` on local, relatively-imported modules.'''
    import garlicsim
    
    from .sample_module_tree import w
    
    z = resolve('w.x.y.z', root=w)

    result = describe(z, root=w)
    assert result == 'w.x.y.z'
    
    result = describe(z, shorten=True, root=w)
    assert result == 'w.y.z'
    
    result = describe(z, shorten=True, root=w)
    assert result == 'w.y.z'
    
    result = describe(z, shorten=True, root=w, namespace='email')
    assert result == 'w.y.z'
    
    result = describe(z, shorten=True, root=garlicsim, namespace=w)
    assert result == 'y.z'
    
    result = describe(z, shorten=True, root=w.x)
    assert result == 'x.y.z'
    
    
def test_ignore_confusing_namespace():
    '''Test that `describe` doesn't use a confusing namespace item.'''
    import email.encoders
    import marshal
    
    result = describe(
        email,
        shorten=True,
        namespace={'e': email}
    )
    assert result == 'email' # Not shortening to 'e', that would be confusing.
    
    result = describe(
        email.encoders,
        namespace={'e': email, 'email': email}
    )
    assert result == 'email.encoders'
    
    result = describe(
        email.encoders,
        root=marshal,
        namespace={'e': email, 'email': email}
    )
    assert result == 'email.encoders'
    
    
    
def test_address_in_expression():
    '''Test `describe` works for an address inside an expression.'''
    
    import email.encoders
    import marshal
    
    assert describe([object, email.encoders, marshal]) == \
           '[object, email.encoders, marshal]'
    
    assert describe([email.encoders, 7, (1, 3), marshal]) == \
           '[email.encoders, 7, (1, 3), marshal]'
    

def test_multiprocessing_lock():
    '''Test `describe` works for `multiprocessing.Lock()`.'''
    if not import_tools.exists('multiprocessing'):
        raise nose.SkipTest('`multiprocessing` not installed')
    import multiprocessing
    lock = multiprocessing.Lock()
    describe(lock)
    
    
def test_bad_module_name():
    '''
    Test `describe` works for objects with bad `__module__` attribute.
    
    The `__module__` attribute usually says where an object can be reached. But
    in some cases, like when working in a shell, you can't really access the
    objects from that non-existant module. So `describe` must not fail for
    these cases.
    '''
    
    import email

    non_sensical_module_name = '__whoop_dee_doo___rrrar'
    
    my_locals = locals().copy()
    my_locals['__name__'] = non_sensical_module_name
    
    exec 'def f(): pass' in my_locals
    exec ('class A(object):\n'
          '    def m(self): pass\n') in my_locals
    
    f, A = my_locals['f'], my_locals['A']
    
    assert describe(f) == \
        '.'.join((non_sensical_module_name, 'f'))
    assert describe(f, shorten=True, root=email, namespace={}) == \
        '.'.join((non_sensical_module_name, 'f'))
    
    assert describe(A) == \
        '.'.join((non_sensical_module_name, 'A'))
    assert describe(A, shorten=True, root=email, namespace={}) == \
        '.'.join((non_sensical_module_name, 'A'))
    
    assert describe(A.m) == \
        '.'.join((non_sensical_module_name, 'A.m'))
    assert describe(A.m, shorten=True, root=email, namespace={}) == \
        '.'.join((non_sensical_module_name, 'A.m'))
    

def test_function_in_something():
    '''Test `describe` doesn't fail when describing `{1: sum}`.'''
    if garlicsim.__version_info__ <= (0, 6, 3):
        raise nose.SkipTest("This test doesn't pass in `garlicsim` version "
                            "0.6.3 and below.")
    assert describe({1: sum}) == '{1: sum}'
    assert describe((sum, sum, list, chr)) == '(sum, sum, list, chr)'
    

def test_function_in_main():
    '''Test that a function defined in `__main__` is well-described.'''

    ###########################################################################
    # We can't really define a function in `__main__` in this test, so we
    # emulate it:
    with TempValueSetter((globals(), '__name__'), '__main__'):
        def f(x):
            pass
    assert f.__module__ == '__main__'
    import __main__
    __main__.f = f
    del __main__
    #
    ###########################################################################
    
    assert describe(f) == '__main__.f'
    assert resolve(describe(f)) is f
    
    

########NEW FILE########
__FILENAME__ = test_resolve
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Testing module for `garlicsim.general_misc.address_tools.resolve`.'''

import nose.tools

from garlicsim.general_misc.address_tools import describe, resolve


# Class tree we'll try to some resolvings on:
class A(object):
    def method(self):
        pass
    class B(object):
        def deep_method(self):
            pass
    class C(object):
        def deep_method(self):
            pass
        class D(object):
            def deeper_method(self):
                pass
            

prefix = __name__ + '.'


def test_locally_defined_class():
    '''Test `resolve` on a locally defined class tree.'''
    
    assert resolve(prefix + 'A') is A
    assert resolve(prefix + 'A.B') is A.B
    assert resolve(prefix + 'A.method') == A.method
    assert resolve('method', namespace=A) == A.method
    assert resolve(prefix + 'A.B.deep_method') == A.B.deep_method
    assert resolve('B.deep_method', namespace=A) == A.B.deep_method
    assert resolve(prefix + 'A.C.D') is A.C.D
    assert resolve(prefix + 'A.C.D.deeper_method') == \
           A.C.D.deeper_method
    
    assert resolve('D.deeper_method', root=(prefix + 'A.C.D')) == \
           A.C.D.deeper_method
    assert resolve('D.deeper_method', root=A.C.D, namespace='email') == \
           A.C.D.deeper_method
    assert resolve('A', root=A) == A

    
def test_stdlib():    
    '''Test `resolve` on stdlib modules.'''
    
    result = resolve('email')
    import email
    import marshal
    assert result is email
    
    assert resolve('email') is \
           resolve('email.email') is \
           resolve('email.email.email') is \
           resolve('email.email.email.email') is email
    
    result = resolve('email.base64mime.a2b_base64')
    assert result is email.base64mime.a2b_base64
    
    result = resolve('email.email.encoders.base64.b32decode')
    assert result is email.encoders.base64.b32decode
    
    result = resolve('base64.b32decode',
                        root='email.email.encoders.base64')
    assert result is email.encoders.base64.b32decode
    
    result = resolve('base64.b32decode',
                        namespace='email.email.encoders')
    assert result is email.encoders.base64.b32decode
    
    result = resolve('base64.b32decode', root=marshal,
                        namespace='email.email.encoders')
    assert result is email.encoders.base64.b32decode
    
    assert resolve('object') is object
    
    
def test_garlicsim():
    '''Test `resolve` on `garlicsim` modules.'''
    
    result = resolve('garlicsim.general_misc')
    import garlicsim
    assert garlicsim.general_misc is result
    
    result = resolve('garlicsim.general_misc.persistent.'
                     'cross_process_persistent.'
                     'CrossProcessPersistent.personality')
    result2 = \
        resolve('general_misc.persistent.CrossProcessPersistent.personality', 
                namespace=garlicsim)
    result3 = resolve('persistent.CrossProcessPersistent.personality',
                         root=garlicsim.general_misc.persistent,
                         namespace='email')
    assert result is result2 is result3 is garlicsim.general_misc.persistent.\
           cross_process_persistent.CrossProcessPersistent.personality
    
    result = resolve('data_structures.end.End',
                        root=garlicsim.data_structures)
    result2 = resolve('data_structures.End',
                        root=garlicsim.data_structures)
    result3 = resolve('data_structures.End', namespace='garlicsim')
    assert result is result2 is garlicsim.data_structures.end.End
    
    import email
    assert resolve('garlicsim', namespace={'e': email})
    
    
def test_address_in_expression():
        
    result = resolve('[object, email.encoders, marshal]')
    import email, marshal, garlicsim
    assert result == [object, email.encoders, marshal]
    
    assert resolve('[email.encoders, 7, (1, 3), marshal]') == \
           [email.encoders, 7, (1, 3), marshal]
    
    result = resolve('{email: marshal, object: 7, garlicsim: garlicsim}')
    import garlicsim
    assert result == {email: marshal, object: 7, garlicsim: garlicsim}
    
    assert resolve('{email: marshal, object: 7, garlicsim: garlicsim}') == \
           {email: marshal, object: 7, garlicsim: garlicsim}
    
    assert resolve('{Project: simulate}', namespace=garlicsim) == \
           {garlicsim.Project: garlicsim.simulate}
    
    assert resolve('{asynchronous_crunching.Project: simulate}',
                   root=garlicsim.asynchronous_crunching,
                   namespace=garlicsim) == \
           {garlicsim.asynchronous_crunching.Project: garlicsim.simulate}

    assert resolve('garlicsim if 4 else e', namespace={'e': email}) is \
           garlicsim
    

def test_illegal_input():
    '''Test `resolve` raises exception when given illegal input.'''
    
    nose.tools.assert_raises(Exception,
                             resolve,
                             'asdgfasdgas if 4 else asdfasdfa ')
    
    nose.tools.assert_raises(Exception,
                             resolve,
                             'dgf sdfg sdfga ')
    
    nose.tools.assert_raises(Exception,
                             resolve,
                             '4- ')
########NEW FILE########
__FILENAME__ = test_arguments_profile
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Testing module for `garlicsim.general_misc.arguments_profile.ArgumentsProfile`.
'''

from __future__ import with_statement

import sys

import nose

from garlicsim.general_misc.arguments_profile import ArgumentsProfile
from garlicsim.general_misc.nifty_collections import OrderedDict
from garlicsim.general_misc import cute_testing


def test_only_defaultless():
    '''
    Test `ArgumentsProfile` on a function with defaultless arguments only.
    '''
    def func(a, b, c): pass
    
    a1 = ArgumentsProfile(func, 1, 2, 3)
    assert a1.args == (1, 2, 3)
    assert not a1.kwargs
    
    a2 = ArgumentsProfile(func, 1, c=3, b=2)
    a3 = ArgumentsProfile(func, c=3, a=1, b=2)
    a4 = ArgumentsProfile(func, 1, **{'c': 3, 'b': 2})
    a5 = ArgumentsProfile(func, **OrderedDict((('c', 3), ('b', 2), ('a', 1))))
    assert a1 == a2 == a3 == a4 == a5
    
    for arg_prof in [a1, a2, a3, a4, a5]:
        
        ### Testing `.iteritems`: #############################################
        #                                                                     #
        assert dict(arg_prof) == {'a': 1, 'b': 2, 'c': 3}
        assert OrderedDict(arg_prof) == \
            OrderedDict((('a', 1), ('b', 2), ('c', 3)))
        #                                                                     #
        ### Finished testing `.iteritems`. ####################################
        
        ### Testing `.__getitem__`: ###########################################
        #                                                                     #
        assert (arg_prof['a'], arg_prof['b'], arg_prof['c']) == (1, 2, 3)
        with cute_testing.RaiseAssertor(KeyError):
            arg_prof['non_existing_key']
        #                                                                     #
        ### Finished testing `.__getitem__`. ##################################
        
        ### Testing `.get`: ###################################################
        #                                                                     #
        assert arg_prof.get('a') == arg_prof.get('a', 'asdfasdf') == 1
        assert arg_prof.get('non_existing_key', 7) == 7
        assert arg_prof.get('non_existing_key') is None
        #                                                                     #
        ### Finished testing `.get`. ##########################################
            
    
    
def test_simplest_defaultful():
    '''
    Test `ArgumentsProfile` on a function with defaultful arguments.
    '''
    def func(a, b, c='three', d='four'): pass
    
    a1 = ArgumentsProfile(func, 'one', 'two')
    assert a1.args == ('one', 'two')
    assert not a1.kwargs
    
    a2 = ArgumentsProfile(func, 'one', 'two', 'three')
    a3 = ArgumentsProfile(func, 'one', 'two', 'three', 'four')
    assert a1 == a2 == a3
    
    a4 = ArgumentsProfile(func, 'one', 'two', 'dynamite')
    assert a1 != a4
    assert a4.args == ('one', 'two', 'dynamite')
    assert not a4.kwargs
    
    a5 = ArgumentsProfile(func, 'one', 'two', c='dynamite')
    a6 = ArgumentsProfile(func, 'one', 'two', 'dynamite', 'four')
    a7 = ArgumentsProfile(func, 'one', 'two', c='dynamite', d='four')
    a8 = ArgumentsProfile(func, 'one', 'two', 'dynamite', d='four')
    a9 = ArgumentsProfile(func, a='one', b='two', c='dynamite', d='four')
    a10 = ArgumentsProfile(func, d='four', c='dynamite', b='two', a='one')
    a11 = ArgumentsProfile(func, 'one', c='dynamite', d='four', b='two')
    assert a4 == a5 == a6 == a7 == a8 == a9 == a10 == a11
    
    a12 = ArgumentsProfile(func, 'one', 'two', d='bang')
    assert a12.args == ('one', 'two')
    assert a12.kwargs == OrderedDict((('d', 'bang'),))
    
    a13 = ArgumentsProfile(func, 'one', 'two', 'three', d='bang')
    a14 = ArgumentsProfile(func, 'one', 'two', c='three', d='bang')
    a15 = ArgumentsProfile(func, 'one', 'two', 'three', 'bang')
    a16 = ArgumentsProfile(func, a='one', b='two', c='three', d='bang')
    a17 = ArgumentsProfile(func, b='two', c='three', d='bang', a='one')
    assert a13 == a14 == a15 == a16 == a17
        
    
def test_defaultful_long_first():
    '''
    Test `ArgumentsProfile` on function with long first defaultful argument.
    '''
    def func(a, b, creativity=3, d=4): pass
    
    a1 = ArgumentsProfile(func, 1, 2)
    assert a1.args == (1, 2)
    assert not a1.kwargs
    
    a2 = ArgumentsProfile(func, 1, 2, 3, 4)
    a3 = ArgumentsProfile(func, a=1, b=2, creativity=3, d=4)
    a4 = ArgumentsProfile(func, creativity=3, d=4, a=1, b=2)
    a5 = ArgumentsProfile(func, 1, 2, creativity=3, d=4)
    assert a1 == a2 == a3 == a4 == a5
    
    a6 = ArgumentsProfile(func, 1, 2, d='booyeah')
    assert a6.args == (1, 2)
    assert a6.kwargs == OrderedDict((('d', 'booyeah'),))
    
    a7 = ArgumentsProfile(func, 1, 2, 3, 'booyeah')
    a8 = ArgumentsProfile(func, 1, 2, creativity=3, d='booyeah')
    assert a6 == a7 == a8
    
    
def test_defaultful_long_last():
    '''
    Test `ArgumentsProfile` on function with long last defaultful argument.
    
    The point is that `ArgumentsProfile` prefers specifying all arguments
    leading to the last long one rather than specifying the keyword, because it
    results in a shorter overall call.
    '''
    def func(a, b, c=3, dragon=4): pass
    
    a1 = ArgumentsProfile(func, 1, 2)
    assert a1.args == (1, 2)
    assert not a1.kwargs
    
    a2 = ArgumentsProfile(func, 1, 2, 3, 4)
    a3 = ArgumentsProfile(func, a=1, b=2, c=3, dragon=4)
    a4 = ArgumentsProfile(func, c=3, dragon=4, a=1, b=2)
    a5 = ArgumentsProfile(func, 1, 2, c=3, dragon=4)
    assert a1 == a2 == a3 == a4 == a5
    
    a6 = ArgumentsProfile(func, 1, 2, dragon='booyeah')
    assert a6.args == (1, 2, 3, 'booyeah')
    assert not a6.kwargs
    
    a7 = ArgumentsProfile(func, 1, 2, 3, 'booyeah')
    a8 = ArgumentsProfile(func, 1, 2, c=3, dragon='booyeah')
    assert a6 == a7 == a8
    
    
def test_many_defaultfuls_some_long():
    '''
    Test `ArgumentsProfile` with many defaultful arguments, some of them long.
    '''
    
    def func(a, b, c=3, dragon=4, e=5, f=6, glide=7, human=8): pass
        
    a1 = ArgumentsProfile(func, 1, 2, glide='boom')
    assert a1.args == (1, 2)
    assert a1.kwargs == OrderedDict((('glide', 'boom'),))
    
    a2 = ArgumentsProfile(func, 1, 2, 3, 4, 5, 6, 'boom')
    a3 = ArgumentsProfile(func, 1, 2, 3, glide='boom')
    assert a1 == a2 == a3
    
    a4 = ArgumentsProfile(func, 1, 2, glide='boom', human='pow')
    a5 = ArgumentsProfile(func, 1, 2, 3, 4, 5, 6, 'boom', 'pow')
    # edge case, second priority
    assert a4.args == (1, 2)
    assert a4.kwargs == OrderedDict((('glide', 'boom'), ('human', 'pow')))
    assert a4 == a5
    
    
def test_many_defaultfuls_some_long_2():
    '''
    Test `ArgumentsProfile` with many defaultful arguments, some of them long.
    '''
    def func(a, b, c=3, dragon=4, e=5, f=6, glide=7, human=8, iris=9): pass
        
    a1 = ArgumentsProfile(func, 1, 2, glide='boom')
    assert a1.args == (1, 2)
    assert a1.kwargs == OrderedDict((('glide', 'boom'),))
    
    a2 = ArgumentsProfile(func, 1, 2, 3, 4, 5, 6, 'boom')
    a3 = ArgumentsProfile(func, 1, 2, 3, glide='boom')
    assert a1 == a2 == a3
    
    a4 = ArgumentsProfile(func, 1, 2, glide='boom',
                          human='pow', iris='badabang')
    a5 = ArgumentsProfile(func, 1, 2, 3, 4, 5, 6, 'boom', 'pow', 'badabang')
    assert a4 == a5
    assert a4.args == (1, 2, 3, 4, 5, 6, 'boom', 'pow', 'badabang')
    assert not a4.kwargs
    
    
def test_defaultful_and_star_args():
    '''Test `ArgumentsProfile` with defaultful arguments and `*args`.'''
    def func(a, b, c=3, draconian=4, *args): pass
        
    a1 = ArgumentsProfile(func, 1, 2)
    assert a1.args == (1, 2)
    assert not a1.kwargs
    
    a2 = ArgumentsProfile(func, 1, 2, draconian='kapow')
    assert a2.args == (1, 2, 3, 'kapow')
    assert not a2.kwargs
    
    a3 = ArgumentsProfile(func, 1, 2, 3, 'kapow')
    assert a2 == a3
    
    a4 = ArgumentsProfile(func, 1, 2, 3, 'kapow', 'meow_frr')
    assert a4.args == (1, 2, 3, 'kapow', 'meow_frr')
    assert not a4.kwargs
    
    
def test_many_defaultfuls_and_star_args():
    '''Test `ArgumentsProfile` with many defaultful arguments and `*args`.'''
    def func(a, b, c='three', d='four', e='five', f='six', *args): pass
    
    a1 = ArgumentsProfile(func, 'one', 'two', f='roar')
    assert a1.args == ('one', 'two')
    assert a1.kwargs == OrderedDict((('f', 'roar'),))
    
    a2 = ArgumentsProfile(func, 'one', 'two', 'three', 'four', 'five', 'roar')
    assert a1 == a2
        
    # Specifying `*args`, so can't specify pre-`*args` arguments by keyword:
    a3 = ArgumentsProfile(func, 'one', 'two', 'three', 'four', 'five', 'roar',
                          'meow_frr')
    assert a3.args == ('one', 'two', 'three', 'four', 'five', 'roar',
                       'meow_frr')
    assert not a3.kwargs
    
    a4 = ArgumentsProfile(func, 'one', 'two', 'three', 'four', 'five', 'six',
                          3, 1, 4, 1, 5, 9, 2)
    assert a4.args == ('one', 'two', 'three', 'four', 'five', 'six',
                       3, 1, 4, 1, 5, 9, 2)
    assert not a4.kwargs
    assert a4['*'] == (3, 1, 4, 1, 5, 9, 2)
    
    
def test_defaultfuls_and_star_kwargs():
    '''Test `ArgumentsProfile` with defaultful arguments and `**kwargs`.'''
    def func(a, b, c=3, d=4, **kwargs): pass
    
    a1 = ArgumentsProfile(func, 1, 2)
    assert a1.args == (1, 2)
    assert not a1.kwargs
    
    # Alphabetic ordering among the `**kwargs`, but `d` is first because it's a
    # non-star:
    a2 = ArgumentsProfile(func, 1, 2, d='bombastic', zany=True, blue=True)
    assert a2.args == (1, 2)
    assert a2.kwargs == OrderedDict(
        (('d', 'bombastic'), ('blue', True), ('zany', True))
    )
    
    a3 = ArgumentsProfile(func, 1, b=2, blue=True, d='bombastic', zany=True)
    a4 = ArgumentsProfile(func, zany=True, a=1, b=2, blue=True, d='bombastic')
    a5 = ArgumentsProfile(func, 1, 2, 3, 'bombastic', zany=True, blue=True)
    assert a2 == a3 == a4 == a5
    
    for arg_prof in [a2, a3, a4, a5]:
        # Testing `.iteritems`:
        assert OrderedDict(arg_prof) == OrderedDict(
            (('a', 1), ('b', 2), ('c', 3), ('d', 'bombastic'), ('blue', True),
             ('zany', True))
        )
        
        ### Testing `.__getitem__`: ###########################################
        #                                                                     #
        assert (arg_prof['a'], arg_prof['b'], arg_prof['c'], arg_prof['d'],
                arg_prof['blue'], arg_prof['zany']) == \
               (1, 2, 3, 'bombastic', True, True)
        
        with cute_testing.RaiseAssertor(KeyError):
            arg_prof['non_existing_key']
        #                                                                     #
        ### Finished testing `.__getitem__`. ##################################
        
        ### Testing `.get`: ###################################################
        #                                                                     #
        assert arg_prof.get('d') == arg_prof.get('d', 7) == 'bombastic'
        assert arg_prof.get('non_existing_key', 7) == 7
        assert arg_prof.get('non_existing_key') is None
        #                                                                     #
        ### Finished testing `.get`. ##########################################
        
        ### Testing `.iterkeys`, `.keys` and `__iter__`: ######################
        #                                                                     #
        assert list(arg_prof.iterkeys()) == list(arg_prof.keys()) == \
            list(arg_prof) == ['a', 'b', 'c', 'd', 'blue', 'zany']
        #                                                                     #
        ### Finished testing `.iterkeys`, `.keys` and `__iter__`. #############
        
        ### Testing `.itervalues` and `.values`: ##############################
        #                                                                     #
        assert list(arg_prof.itervalues()) == list(arg_prof.values()) == \
            [1, 2, 3, 'bombastic', True, True]
        #                                                                     #
        ### Finished testing `.itervalues` and `.values`. #####################
        
        ### Testing `.__contains__`: ##########################################
        #                                                                     #
        for key in arg_prof:
            assert key in arg_prof
        assert 'agaofgnafgadf' not in arg_prof
        assert '**' not in arg_prof
        #                                                                     #
        ### Finished testing `.__contains__`. #################################
    

def test_many_defaultfuls_and_star_args_and_star_kwargs():
    '''
    Test `ArgumentsProfile` with defaultful arguments, `*args` and `**kwargs`.
    '''
    def func(a, b, c='three', d='four', e='five', f='six', *args, **kwargs):
        pass
    
    func(None, None)
    
    a1 = ArgumentsProfile(func, 'one', 'two', f='boomboomboom', __awesome=True,
                          big=True)
    assert a1.args == ('one', 'two')
    assert a1.kwargs == OrderedDict(
        (('f', 'boomboomboom'), ('big', True), ('__awesome', True))
    )
    
    a2 = ArgumentsProfile(func, 'one', 'two', 'three', 'four', 'five',
                          'bombastic', 'meow_frr', __funky=None, zany=True,
                          _wet=False, blue=True)
    assert a2.args == ('one', 'two', 'three', 'four', 'five', 'bombastic',
                       'meow_frr')
    assert a2.kwargs == OrderedDict(
        (('blue', True), ('zany', True), ('_wet', False), ('__funky', None))
    )
    
    a3 = ArgumentsProfile(func, 'one', 'two', 'three', 'four', 'five',
                          'bombastic', 'meow_frr', zany=True, __funky=None,
                          blue=True, _wet=False, **OrderedDict())
    assert a2 == a3
    
    
    for arg_prof in [a2, a3]:
        # Testing `.iteritems`:
        assert OrderedDict(arg_prof) == OrderedDict(
            (('a', 'one'), ('b', 'two'), ('c', 'three'), ('d', 'four'),
             ('e', 'five'), ('f', 'bombastic'), ('*', ('meow_frr',)),
             ('blue', True), ('zany', True), ('_wet', False),
             ('__funky', None))
        )
        
        ### Testing `.__getitem__`: ###########################################
        #                                                                     #
        assert (arg_prof['a'], arg_prof['b'], arg_prof['c'], arg_prof['d'],
                arg_prof['e'], arg_prof['f'], arg_prof['*'], arg_prof['blue'],
                arg_prof['zany'],  arg_prof['_wet'], arg_prof['__funky']) == \
               ('one', 'two', 'three', 'four', 'five', 'bombastic',
                ('meow_frr',), True, True, False, None)
        
        with cute_testing.RaiseAssertor(KeyError):
            arg_prof['non_existing_key']
        #                                                                     #
        ### Finished testing `.__getitem__`. ##################################
        
        ### Testing `.get`: ###################################################
        #                                                                     #
        assert arg_prof.get('d') == arg_prof.get('d', 7) == 'four'
        assert arg_prof.get('non_existing_key', 7) == 7
        assert arg_prof.get('non_existing_key') is None
        #                                                                     #
        ### Finished testing `.get`. ##########################################
        
        ### Testing `.iterkeys`, `.keys` and `__iter__`: ######################
        #                                                                     #
        assert list(arg_prof.iterkeys()) == list(arg_prof.keys()) == \
            list(arg_prof) == \
            ['a', 'b', 'c', 'd', 'e', 'f', '*', 'blue', 'zany', '_wet',
             '__funky']
        #                                                                     #
        ### Finished testing `.iterkeys`, `.keys` and `__iter__`. #############
        
        ### Testing `.itervalues` and `.values`: ##############################
        #                                                                     #
        assert list(arg_prof.itervalues()) == list(arg_prof.values()) == \
            ['one', 'two', 'three', 'four', 'five', 'bombastic', ('meow_frr',),
             True, True, False, None]
        #                                                                     #
        ### Finished testing `.itervalues` and `.values`. #####################
        
        ### Testing `.iteritems` and `.items`: ################################
        #                                                                     #
        items_1 = list(arg_prof.iteritems())
        items_2 = arg_prof.items()
        assert items_1 == items_2 == zip(arg_prof.keys(), arg_prof.values())
        #                                                                     #
        ### Finished testing `.iteritems` and `.items`. #######################
        
        ### Testing `.__contains__`: ##########################################
        #                                                                     #
        for key in arg_prof:
            assert key in arg_prof
        #                                                                     #
        ### Finished testing `.__contains__`. #################################

    
def test_method_equality():
    '''
    Test for bug where methods are compared with `is` instead of `==`.
    
    This causes failure with both bound and unbound methods.
    '''
    
    class C(object):
        def my_method(self, *args):
            pass

    c1 = C()
    c2 = C()
        
    assert ArgumentsProfile(C.my_method, c1) == \
           ArgumentsProfile(C.my_method, c1)
    
    assert ArgumentsProfile(C.my_method, c1, 7, 'meow') == \
           ArgumentsProfile(C.my_method, c1, 7, 'meow')
    
    assert ArgumentsProfile(C.my_method, c1) != \
           ArgumentsProfile(C.my_method, c1, 7, 'meow')
    
    
    
    assert ArgumentsProfile(C.my_method, c1) != ArgumentsProfile(c1.my_method)
    
    assert ArgumentsProfile(C.my_method, c2) != ArgumentsProfile(c1.my_method)
    
    assert ArgumentsProfile(c1.my_method) == ArgumentsProfile(c1.my_method)
    
    assert ArgumentsProfile(c1.my_method, 7, 'meow') == \
           ArgumentsProfile(c1.my_method, 7, 'meow')
    
    assert ArgumentsProfile(c1.my_method) != ArgumentsProfile(c1.my_method, 7,
                                                              'meow')
    
    assert ArgumentsProfile(c1.my_method) != ArgumentsProfile(c2.my_method)
    
    assert ArgumentsProfile(c1.my_method, 7, 'meow') != \
           ArgumentsProfile(c2.my_method, 7, 'meow')
    

def test_unhashable():
    '''Test hashing of `ArgumentsProfile` that has unhashable arguments.'''
    def func(a, b, c=3, d=4, **kwargs):
        pass
    
    a1 = ArgumentsProfile(func, 7, {1: 2})
    assert a1.args == (7, {1: 2})
    assert not a1.kwargs
    hash(a1)
    
    a2 = ArgumentsProfile(func, 7, ({'a': 'b'},), set([1, (3, 4)]),
                          meow=[1, 2, {1: [1, 2]}])
    assert a2.args == (7, ({'a': 'b'},), set([1, (3, 4)]))
    assert a2.kwargs == OrderedDict(
        (('meow', [1, 2, {1: [1, 2]}]),)
    )

    d = {a1: 1, a2: 2}
    assert d[a1] == 1
    assert d[a2] == 2

    
def test_unhashable_star_empty():
    '''Test `ArgumentsProfile` hashing and handling of `*()`.'''
    
    def func(a, b, c=3, d=4, **kwargs):
        pass
    assert sys.version_info[0] == 2
    assert sys.version_info[1] >= 5
    if sys.version_info[1] == 5:
        raise nose.SkipTest("Python 2.5 can't compile this test.")
        
        
    a2 = ArgumentsProfile(func, 7, ({'a': 'b'},), set([1, (3, 4)]),
                          meow=[1, 2, {1: [1, 2]}])
    assert a2.args == (7, ({'a': 'b'},), set([1, (3, 4)]))
    assert a2.kwargs == OrderedDict(
        (('meow', [1, 2, {1: [1, 2]}]),)
    )
    
    
    
    # Python 2.5 can't compile the following, so we're compiling it dynamically
    # so as to not prevent Python 2.5 from being able to compile this module:
    exec("a3 = ArgumentsProfile(func, *(), b=({'a': 'b'},),"
                               "c=set([1, (3, 4)]), a=7,"
                               "meow=[1, 2, {1: [1, 2]}])")
    assert a3.args == (7, ({'a': 'b'},), set([1, (3, 4)]))
    assert a3.kwargs == OrderedDict(
        (('meow', [1, 2, {1: [1, 2]}]),)
    )
    assert hash(a2) == hash(a3)
    
    

########NEW FILE########
__FILENAME__ = test_cache
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Testing module for `garlicsim.general_misc.caching.cache`.'''

from __future__ import with_statement

import re
import gc
import weakref

import nose.tools

from garlicsim.general_misc.caching import cache
from garlicsim.general_misc import cute_testing


def counting_func(a=1, b=2, *args, **kwargs):
    '''Function that returns a bigger number every time.'''
    if not hasattr(counting_func, 'i'):
        counting_func.i = 0
    try:
        return counting_func.i
    finally:
        counting_func.i = (counting_func.i + 1)

        
def test_basic():
    '''Test basic workings of `cache`.'''
    f = cache()(counting_func)
    
    assert f() == f() == f(1, 2) == f(a=1, b=2)
    
    assert f() != f('boo')
    
    assert f('boo') == f('boo') == f(a='boo')
    
    assert f('boo') != f(meow='frrr')
    
    assert f(meow='frrr') == f(1, meow='frrr') == f(a=1, meow='frrr')
    

def test_weakref():
    '''Test that `cache` weakrefs weakreffable arguments.'''
    f = cache()(counting_func)
    
    class A(object): pass
    
    a = A()
    result = f(a)
    assert result == f(a) == f(a) == f(a)
    a_ref = weakref.ref(a)    
    del a
    gc.collect()
    assert a_ref() is None
    
    a = A()
    result = f(meow=a)
    assert result == f(meow=a) == f(meow=a) == f(meow=a)
    a_ref = weakref.ref(a)
    del a
    gc.collect()
    
    assert a_ref() is None
    
    
def test_lru():
    '''Test the least-recently-used algorithm for forgetting cached results.'''
    
    f = cache(max_size=3)(counting_func)
    
    r0, r1, r2 = f(0), f(1), f(2)
    
    assert f(0) == f(0) == r0 == f(0)
    assert f(1) == f(1) == r1 == f(1)
    assert f(2) == f(2) == r2 == f(2)
    
    r3 = f(3)
    
    assert f(0) != r0 # Now we recalculated `f(0)` so we forgot `f(1)`
    assert f(2) == f(2) == r2 == f(2)
    assert f(3) == f(3) == r3 == f(3)
    
    new_r1 = f(1)
    
    # Requesting these:
    f(3)
    f(1)
    # So `f(2)` will be the least-recently-used.
    
    r4 = f(4) # Now `f(2)` has been thrown out.
    
    new_r2 = f(2) # And now `f(3)` is thrown out
    assert f(2) != r2
    
    assert f(1) == new_r1 == f(1)
    assert f(4) == r4 == f(4)
    assert f(2) == new_r2 == f(2)
    
    # Now `f(1)` is the least-recently-used.
    
    r5 = f(5) # Now `f(1)` has been thrown out.
    
    assert f(4) == r4 == f(4)
    assert f(5) == r5 == f(5)
    
    assert f(1) != new_r1
    

def test_unhashable_arguments():
    '''Test `cache` works with unhashable arguments.'''
    
    f = cache()(counting_func)
    
    
    assert f(set((1, 2))) == f(set((1, 2)))
    
    assert f(7, set((1, 2))) != f(8, set((1, 2)))
    
    assert f('boo') != f(meow='frrr')
    
    assert f(meow={1: [1, 2], 2: frozenset([3, 'b'])}) == \
           f(1, meow={1: [1, 2], 2: frozenset([3, 'b'])})
    
    
def test_helpful_message_when_forgetting_parentheses():
    '''Test user gets a helpful exception when when forgetting parentheses.'''

    def confusedly_forget_parentheses():
        @cache
        def f(): pass
        
    with cute_testing.RaiseAssertor(
        TypeError,
        'It seems that you forgot to add parentheses after `@cache` when '
        'decorating the `f` function.'
    ):
        
        confusedly_forget_parentheses()
    
    
    
def test_signature_preservation():
    '''Test that a function's signature is preserved after decorating.'''
    
    f = cache()(counting_func)
    assert f() == f() == f(1, 2) == f(a=1, b=2)
    cute_testing.assert_same_signature(f, counting_func)
    
    def my_func(qq, zz=1, yy=2, *args): pass
    my_func_cached = cache(max_size=7)(my_func)
    cute_testing.assert_same_signature(my_func, my_func_cached)
    
    def my_other_func(**kwargs): pass
    my_func_cached = cache()(my_func)
    cute_testing.assert_same_signature(my_func, my_func_cached)
    
    
def test_api():
    '''Test the API of cached functions.'''
    f = cache()(counting_func)
    g = cache(max_size=3)(counting_func)
    
    for cached_function in (f, g):
    
        assert not hasattr(cached_function, 'cache')
        cute_testing.assert_polite_wrapper(cached_function, counting_func)
        
        result_1 = cached_function(1)
        assert cached_function(1) == result_1 == cached_function(1)
        
        cached_function.cache_clear()
        
        result_2 = cached_function(1)
        
        assert cached_function(1) == result_2 == cached_function(1)
        assert result_1 != result_2 == cached_function(1) != result_1
        
        # Asserting we're not using `dict.clear` or something:
        assert cached_function.cache_clear.__name__ == 'cache_clear'
        
        
def test_double_caching():
    '''Test that `cache` detects and prevents double-caching of functions.'''
    f = cache()(counting_func)
    g = cache()(f)
    
    assert f is g
    
########NEW FILE########
__FILENAME__ = test_cached_property
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Testing module for `garlicsim.general_misc.caching.CachedProperty`.
'''

import nose

from garlicsim.general_misc.caching import (cache, CachedType,
                                            CachedProperty)


def counting_func(self):
    '''Return a bigger number every time.'''
    if not hasattr(counting_func, 'i'):
        counting_func.i = 0
    try:
        return counting_func.i
    finally:
        counting_func.i = (counting_func.i + 1)
    
        
def test():
    '''Test basic workings of `CachedProperty`.'''    
    class A(object):
        personality = CachedProperty(counting_func)
    
    assert isinstance(A.personality, CachedProperty)
        
    a1 = A()
    assert a1.personality == a1.personality == a1.personality
    
    a2 = A()
    assert a2.personality == a2.personality == a2.personality 
    
    assert a2.personality == a1.personality + 1


def test_as_decorator():
    '''Test `CachedProperty` can work as a decorator.'''
    class B(object):
        @CachedProperty
        def personality(self):
            if not hasattr(B.personality, 'i'):
                B.personality.i = 0
            try:
                return B.personality.i
            finally:
                B.personality.i = (B.personality.i + 1)
    
    assert isinstance(B.personality, CachedProperty)                
                
    b1 = B()
    assert b1.personality == b1.personality == b1.personality

    
    b2 = B()
    assert b2.personality == b2.personality == b2.personality 
    
    assert b2.personality == b1.personality + 1
        
    
def test_with_name():
    '''Test `CachedProperty` works with correct name argument.'''
    class A(object):
        personality = CachedProperty(counting_func, name='personality')
    
    a1 = A()
    assert a1.personality == a1.personality == a1.personality
    
    a2 = A()
    assert a2.personality == a2.personality == a2.personality 
    
    assert a2.personality == a1.personality + 1
        
    
def test_with_wrong_name():
    '''Test `CachedProperty`'s behavior with wrong name argument.'''
        
    class A(object):
        personality = CachedProperty(counting_func, name='meow')
    
    a1 = A()
    assert a1.personality == a1.meow == a1.personality - 1 == \
           a1.personality - 2
    
    a2 = A()
    assert a2.personality == a2.meow == a2.personality - 1 == \
           a2.personality - 2
    
    
def test_on_false_object():
    '''Test `CachedProperty` on class that evaluates to `False`.'''
    
    class C(object):
        @CachedProperty
        def personality(self):
            if not hasattr(C.personality, 'i'):
                C.personality.i = 0
            try:
                return C.personality.i
            finally:
                C.personality.i = (C.personality.i + 1)
        
        def __bool__(self):
            return False
        
        __nonzero__ = __bool__
        
    assert isinstance(C.personality, CachedProperty)
                
    c1 = C()
    assert not c1
    assert c1.personality == c1.personality == c1.personality
    
    c2 = C()
    assert not c2
    assert c2.personality == c2.personality == c2.personality 
    
    assert c2.personality == c1.personality + 1
    
    
def test_doc():
    '''Test the `doc` argument for setting the property's docstring.'''
    class A(object):
        personality = CachedProperty(counting_func)
        
    assert A.personality.__doc__ ==  'Return a bigger number every time.'
    
    
    class B(object):
        personality = CachedProperty(
            counting_func,
            doc='''Ooga booga.'''
        )
        
    assert B.personality.__doc__ ==  'Ooga booga.'
    
    
    class C(object):
        undocced_property = CachedProperty(
            lambda self: 1/0,
        )
        
    assert C.undocced_property.__doc__ is None
    
########NEW FILE########
__FILENAME__ = test_cached_type
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Testing module for `garlicsim.general_misc.caching.CachedType`.
'''

from garlicsim.general_misc.caching import CachedType

        
def test():
    '''Test basic workings of `CachedType`.'''
    class A(object):
        __metaclass__ = CachedType
        def __init__(self, a=1, b=2, *args, **kwargs):
            pass
        
    assert A() is A(1) is A(b=2) is A(1, 2) is A(1, b=2)
    assert A() is not A(3) is not A(b=7) is not A(1, 2, 'meow') is not A(x=9)
    
########NEW FILE########
__FILENAME__ = test_cheat_hashing
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Testing module for `garlicsim.general_misc.abc_tools.abstract_static_method`.
'''

import copy

from garlicsim.general_misc.cheat_hashing import cheat_hash


def test_cheat_hash():
    '''Test `cheat_hash` on various objects.'''
    
    things = [
        1,
        7,
        4.5,
        [1, 2, 3.4],
        (1, 2, 3.4),
        {1: 2, 3: 4.5},
        set((1, 2, 3.4)),
        [1, [1, 2], 3],
        [1, {frozenset((1, 2)): 'meow'}, 3],
        sum,
        None,
        (None, {None: None})
    ]
    
    things_copy = copy.deepcopy(things)
        
    for thing, thing_copy in zip(things, things_copy):
        assert cheat_hash(thing) == cheat_hash(thing) == \
               cheat_hash(thing_copy) == cheat_hash(thing_copy)
        
########NEW FILE########
__FILENAME__ = test_abstractness
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Module for testing the abstract methods of `ContextManager`.'''

from __future__ import with_statement

import sys

import nose

from garlicsim.general_misc.context_manager import (ContextManager,
                                                    ContextManagerType,
                                                    SelfHook)

def test_abstractness():
    '''
    A non-abstract-overriding `ContextManager` subclass can't be instantiated.
    '''
    if sys.version_info[:2] <= (2, 5):
        raise nose.SkipTest("Python 2.5 doesn't enforce abstractness.")
    
    class EmptyContextManager(ContextManager):
        pass

    class EnterlessContextManager(ContextManager):
        def __exit__(self, type_, value, traceback):
            pass
        
    class ExitlessContextManager(ContextManager):
        def __enter__(self):
            pass
        
    def f():
        EmptyContextManager()
    
    def g():
        EnterlessContextManager()
    
    def h():
        ExitlessContextManager()
         
    nose.tools.assert_raises(TypeError, f)
    nose.tools.assert_raises(TypeError, g)
    nose.tools.assert_raises(TypeError, h)


def test_can_instantiate_when_defining_manage_context():
    '''
    A `manage_context`-defining `ContextManager` subclass can be instantiated.
    '''
    class MyContextManager(ContextManager):
        def manage_context(self):
            yield self
    MyContextManager()


def test_can_instantiate_when_defining_enter_exit():
    '''
    An enter/exit -defining `ContextManager` subclass can be instantiated.
    '''
    class AnotherContextManager(ContextManager):
        def __enter__(self):
            pass
        def __exit__(self, type_, value, traceback):
            pass
    AnotherContextManager()
    
########NEW FILE########
__FILENAME__ = test_context_manager
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Test the `garlicsim.general_misc.context_manager` module.'''

from __future__ import with_statement 

from garlicsim.general_misc import cute_testing

from garlicsim.general_misc.context_manager import (ContextManager,
                                                    ContextManagerType,
                                                    SelfHook)

flag = None
exception_type_caught = None


def test_generator():
    '''Test a context manager made from a generator.'''
    @ContextManagerType
    def MyContextManager(value):
        global flag, exception_type_caught
        former_value = flag
        flag = value
        try:
            yield
        finally:
            flag = former_value
            
    check_context_manager_type(MyContextManager,
                               self_returning=False,
                               error_catching=False)
    

def test_error_catching_generator():
    '''Test an error-catching context manager made from a generator.'''
    
    @ContextManagerType
    def MyContextManager(value):
        global flag, exception_type_caught
        former_value = flag
        flag = value
        try:
            yield
        except Exception, exception:
            exception_type_caught = type(exception)
        finally:
            flag = former_value
            
    check_context_manager_type(MyContextManager,
                               self_returning=False,
                               error_catching=True)


def test_self_returning_generator():
    '''Test a self-returning context manager made from a generator.'''
    @ContextManagerType
    def MyContextManager(value):
        global flag, exception_type_caught
        former_value = flag
        flag = value
        try:
            yield SelfHook
        finally:
            flag = former_value
            
    check_context_manager_type(MyContextManager,
                               self_returning=True,
                               error_catching=False)
    

def test_self_returning_error_catching_generator():
    '''
    Test a self-returning error-catching context manager made from a generator.
    '''
    @ContextManagerType
    def MyContextManager(value):
        global flag, exception_type_caught
        former_value = flag
        flag = value
        try:
            yield SelfHook
        except Exception, exception:
            exception_type_caught = type(exception)
        finally:
            flag = former_value
            
    check_context_manager_type(MyContextManager,
                               self_returning=True,
                               error_catching=True)
    
    
def test_manage_context():
    '''Test a context manager that uses a `manage_context` method.'''
    class MyContextManager(ContextManager):
        def __init__(self, value):
            self.value = value
        
        def manage_context(self):
            global flag, exception_type_caught
            former_value = flag
            flag = self.value
            try:
                yield
            finally:
                flag = former_value
            
    check_context_manager_type(MyContextManager,
                               self_returning=False,
                               error_catching=False)
        
    
def test_error_catching_manage_context():
    '''Test an error-catching `manage_context`-powered context manager.'''
    class MyContextManager(ContextManager):
        def __init__(self, value):
            self.value = value
        
        def manage_context(self):
            global flag, exception_type_caught
            former_value = flag
            flag = self.value
            try:
                yield
            except Exception, exception:
                exception_type_caught = type(exception)
            finally:
                flag = former_value
            
    check_context_manager_type(MyContextManager,
                               self_returning=False,
                               error_catching=True)
    
    
def test_self_returning_manage_context():
    '''Test a self-returning `manage_context`-powered context manager.'''
    class MyContextManager(ContextManager):
        def __init__(self, value):
            self.value = value
        
        def manage_context(self):
            global flag
            former_value = flag
            flag = self.value
            try:
                yield self
            finally:
                flag = former_value
            
    check_context_manager_type(MyContextManager,
                               self_returning=True,
                               error_catching=False)
    
    
def test_self_returning_error_catching_manage_context():
    '''
    Test a self-returning error-catching `manage_context` context manager.
    '''
    class MyContextManager(ContextManager):
        def __init__(self, value):
            self.value = value
        
        def manage_context(self):
            global flag, exception_type_caught
            former_value = flag
            flag = self.value
            try:
                yield self
            except Exception, exception:
                exception_type_caught = type(exception)
            finally:
                flag = former_value
            
    check_context_manager_type(MyContextManager,
                               self_returning=True,
                               error_catching=True)

    
def test_manage_context_overriding_generator():
    '''
    Test a `manage_context` context manager overriding one made from generator.
    '''
    @ContextManagerType
    def MyBaseContextManager(value):
        raise Exception('This code is supposed to be overridden.')
        yield
    
    class MyContextManager(MyBaseContextManager):
        def __init__(self, value):
            self.value = value
        
        def manage_context(self):
            global flag, exception_type_caught
            former_value = flag
            flag = self.value
            try:
                yield self
            except Exception, exception:
                exception_type_caught = type(exception)
            finally:
                flag = former_value
            
    check_context_manager_type(MyContextManager,
                               self_returning=True,
                               error_catching=True)
    
    
def test_manage_context_overriding_manage_context():
    '''
    Test a `manage_context`-powered context manager overriding another one.
    '''    
    class MyBaseContextManager(ContextManager):
        def __init__(self, value):
            self.value = value
        
        def manage_context(self):
            raise Exception('This code is supposed to be overridden.')
            yield
            
    class MyContextManager(MyBaseContextManager):
        def __init__(self, value):
            self.value = value
        
        def manage_context(self):
            global flag, exception_type_caught
            former_value = flag
            flag = self.value
            try:
                yield self
            except Exception, exception:
                exception_type_caught = type(exception)
            finally:
                flag = former_value
            
    check_context_manager_type(MyContextManager,
                               self_returning=True,
                               error_catching=True)
    
    
def test_manage_context_overriding_enter_exit():
    '''
    Test `manage_context` context manager overriding one made from enter/exit.
    '''
    
    class MyBaseContextManager(ContextManager):
        def __init__(self, value):
            self.value = value
            self._former_values = []
        
        def __enter__(self):
            raise Exception('This code is supposed to be overridden.')
            
        def __exit__(self, type_=None, value=None, traceback=None):
            raise Exception('This code is supposed to be overridden.')

            
    class MyContextManager(MyBaseContextManager):
        def __init__(self, value):
            self.value = value
        
        def manage_context(self):
            global flag, exception_type_caught
            former_value = flag
            flag = self.value
            try:
                yield self
            except Exception, exception:
                exception_type_caught = type(exception)
            finally:
                flag = former_value
            
    check_context_manager_type(MyContextManager,
                               self_returning=True,
                               error_catching=True)
    
    
def test_enter_exit():
    '''Test an enter/exit context manager.'''
    class MyContextManager(ContextManager):
        def __init__(self, value):
            self.value = value
            self._former_values = []
        
        def __enter__(self):
            global flag
            self._former_values.append(flag)
            flag = self.value
            
        def __exit__(self, type_=None, value=None, traceback=None):
            global flag
            flag = self._former_values.pop()
    
    check_context_manager_type(MyContextManager,
                               self_returning=False,
                               error_catching=False)

    
def test_error_catching_enter_exit():
    '''Test an error-catching enter/exit context manager.'''
    class MyContextManager(ContextManager):
        def __init__(self, value):
            self.value = value
            self._former_values = []
        
        def __enter__(self):
            global flag
            self._former_values.append(flag)
            flag = self.value
            
        def __exit__(self, type_=None, value=None, traceback=None):
            global flag, exception_type_caught
            flag = self._former_values.pop()
            if type_:
                exception_type_caught = type_
                return True
    
    check_context_manager_type(MyContextManager,
                               self_returning=False,
                               error_catching=True)

    
def test_self_returning_enter_exit():
    '''Test a self-returning enter/exit context manager.'''
    class MyContextManager(ContextManager):
        def __init__(self, value):
            self.value = value
            self._former_values = []
        
        def __enter__(self):
            global flag
            self._former_values.append(flag)
            flag = self.value
            return self
            
        def __exit__(self, type_=None, value=None, traceback=None):
            global flag
            flag = self._former_values.pop()
    
    check_context_manager_type(MyContextManager,
                               self_returning=True,
                               error_catching=False)

    
def test_error_catching_self_returning_enter_exit():
    '''Test an error-catching self-returning enter/exit context manager.'''
    class MyContextManager(ContextManager):
        def __init__(self, value):
            self.value = value
            self._former_values = []
        
        def __enter__(self):
            global flag
            self._former_values.append(flag)
            flag = self.value
            return self
            
        def __exit__(self, type_=None, value=None, traceback=None):
            global flag, exception_type_caught
            flag = self._former_values.pop()
            if type_:
                exception_type_caught = type_
                return True
    
    check_context_manager_type(MyContextManager,
                               self_returning=True,
                               error_catching=True)
    
    
def test_enter_exit_overriding_generator():
    '''
    Test an enter/exit context manager overriding one made from generator.
    '''
    @ContextManagerType
    def MyBaseContextManager(value):
        raise Exception('This code is supposed to be overridden.')
        yield
        
    class MyContextManager(MyBaseContextManager):
        def __init__(self, value):
            self.value = value
            self._former_values = []
        
        def __enter__(self):
            global flag
            self._former_values.append(flag)
            flag = self.value
            return self
            
        def __exit__(self, type_=None, value=None, traceback=None):
            global flag, exception_type_caught
            flag = self._former_values.pop()
            if type_:
                exception_type_caught = type_
                return True
    
    check_context_manager_type(MyContextManager,
                               self_returning=True,
                               error_catching=True)


def test_enter_exit_overriding_manage_context():
    '''
    Test enter/exit context manager overriding one made from `manage_context`.
    '''
    class MyBaseContextManager(ContextManager):
        def __init__(self, value):
            self.value = value
        
        def manage_context(self):
            raise Exception('This code is supposed to be overridden.')
            yield
    
    class MyContextManager(MyBaseContextManager):
        def __init__(self, value):
            self.value = value
            self._former_values = []
        
        def __enter__(self):
            global flag
            self._former_values.append(flag)
            flag = self.value
            return self
            
        def __exit__(self, type_=None, value=None, traceback=None):
            global flag, exception_type_caught
            flag = self._former_values.pop()
            if type_:
                exception_type_caught = type_
                return True
    
    check_context_manager_type(MyContextManager,
                               self_returning=True,
                               error_catching=True)


def test_enter_exit_overriding_enter_exit():
    '''Test an enter/exit context manager overriding another one.'''
    
    class MyBaseContextManager(ContextManager):
        def __init__(self, value):
            self.value = value
            self._former_values = []
        
        def __enter__(self):
            raise Exception('This code is supposed to be overridden.')
            
        def __exit__(self, type_=None, value=None, traceback=None):
            raise Exception('This code is supposed to be overridden.')
        
    
    class MyContextManager(MyBaseContextManager):
        def __init__(self, value):
            self.value = value
            self._former_values = []
        
        def __enter__(self):
            global flag
            self._former_values.append(flag)
            flag = self.value
            return self
            
        def __exit__(self, type_=None, value=None, traceback=None):
            global flag, exception_type_caught
            flag = self._former_values.pop()
            if type_:
                exception_type_caught = type_
                return True
    
    check_context_manager_type(MyContextManager,
                               self_returning=True,
                               error_catching=True)

    
def test_enter_subclassing_exit():
    '''
    Test one defining `__enter__` subclassing from one that defines `__exit__`.
    '''
    
    class MyBaseContextManager(ContextManager):
        def __init__(self, value):
            self.value = value
            self._former_values = []
            
        def __exit__(self, type_=None, value=None, traceback=None):
            global flag, exception_type_caught
            flag = self._former_values.pop()
            if type_:
                exception_type_caught = type_
                return True
        
    
    class MyContextManager(MyBaseContextManager):
        def __init__(self, value):
            self.value = value
            self._former_values = []
        
        def __enter__(self):
            global flag
            self._former_values.append(flag)
            flag = self.value
            return self
    
    check_context_manager_type(MyContextManager,
                               self_returning=True,
                               error_catching=True)
    
    
def test_exit_subclassing_enter():
    '''
    Test one defining `__exit__` subclassing from one that defines `__enter__`.
    '''
    
    class MyBaseContextManager(ContextManager):
        def __init__(self, value):
            self.value = value
            self._former_values = []
            
        def __enter__(self):
            global flag
            self._former_values.append(flag)
            flag = self.value
            return self
        
    
    class MyContextManager(MyBaseContextManager):
        def __init__(self, value):
            self.value = value
            self._former_values = []
            
        def __exit__(self, type_=None, value=None, traceback=None):
            global flag, exception_type_caught
            flag = self._former_values.pop()
            if type_:
                exception_type_caught = type_
                return True
        
    
    check_context_manager_type(MyContextManager,
                               self_returning=True,
                               error_catching=True)
    
    
def check_context_manager_type(context_manager_type,
                               self_returning,
                               error_catching):
    '''
    Run checks on a context manager.
    
    `self_returning` is a flag saying whether the context manager's `__enter__`
    method returns itself. (For the `as` keyword after `with`.)
    
    `error_catching` says whether the context manager catches exceptions it
    gets and updates the `exception_type_caught` global.
    '''
    
    global flag, exception_type_caught
    
    assert flag is None
    assert exception_type_caught is None
    
    ### Testing simple case: ##################################################
    #                                                                         #
    with context_manager_type(7) as return_value:
        assert flag == 7
        if self_returning:
            assert isinstance(return_value, context_manager_type)
        else: # self_returning is False
            assert return_value is None
    #                                                                         #
    ### Finished testing simple case. #########################################
        
    assert flag is None
    assert exception_type_caught is None
    
    ### Testing creating context manager before `with`: #######################
    #                                                                         #
    my_context_manager = context_manager_type(1.1)
    assert isinstance(my_context_manager, context_manager_type)
    with my_context_manager as return_value:
        assert flag == 1.1
        if self_returning:
            assert return_value is my_context_manager
        else: # self_returning is False
            assert return_value is None
    #                                                                         #
    ### Finished testing creating context manager before `with`. ##############
    
    assert flag is None
    assert exception_type_caught is None

    ### Testing decorated function: ###########################################
    #                                                                         #
    @context_manager_type('meow')
    def f():
        assert flag == 'meow'
        
    f()
    assert flag is None
    assert exception_type_caught is None
    #                                                                         #
    ### Finished testing decorated function. ##################################
    
    ### Testing manually decorated function: ##################################
    #                                                                         #
    def g(a, b=2, **kwargs):
        assert flag == 'meow'
        
    new_g = context_manager_type('meow')(g)
        
    with cute_testing.RaiseAssertor(AssertionError):
        g('whatever')
        
    assert flag is None
    assert exception_type_caught is None

    new_g('whatever')
    assert flag is None
    assert exception_type_caught is None
    cute_testing.assert_polite_wrapper(new_g, g)
    #                                                                         #
    ### Finished testing manually decorated function. #########################
    
    ### Testing deep nesting: #################################################
    #                                                                         #
    my_context_manager = context_manager_type(123)
    assert flag is None
    with my_context_manager:
        assert flag == 123
        with my_context_manager:
            assert flag == 123
            with my_context_manager:
                assert flag == 123
                with my_context_manager:
                    assert flag == 123
                    with my_context_manager:
                        assert flag == 123
                    assert flag == 123
                assert flag == 123
            assert flag == 123
        assert flag == 123
    assert flag is None
    
    with context_manager_type(1) as return_value_1:
        assert flag == 1
        with context_manager_type(2) as return_value_2:
            assert flag == 2
            with return_value_1 or context_manager_type(1):
                assert flag == 1
            assert flag == 2
        assert flag == 1
    assert flag is None
    #                                                                         #
    ### Finished testing deep nesting. ########################################
    
    
    ###########################################################################
    ###########################################################################
    ### Now while raising exceptions:
        
    ### Testing simple case: ##################################################
    #                                                                         #
    try:    
        with context_manager_type(7) as return_value:
            assert flag == 7
            if self_returning:
                assert isinstance(return_value, context_manager_type)
            else: # self_returning is False
                assert return_value is None
            raise TypeError('ooga booga')
        
    except Exception, exception:
        assert not error_catching
        assert type(exception) is TypeError
        
    else:
        assert error_catching
        assert exception_type_caught is TypeError
        exception_type_caught = None
    #                                                                         #
    ### Finished testing simple case. #########################################
        
    assert flag is None
    
    ### Testing creating context manager before `with`: #######################
    #                                                                         #
    my_context_manager = context_manager_type(1.1)
    assert isinstance(my_context_manager, context_manager_type) 
    try:
        with my_context_manager as return_value:
            assert flag == 1.1
            if self_returning:
                assert return_value is my_context_manager
            else: # self_returning is False
                assert return_value is None
            {}[3]
    
    except Exception, exception:
        assert not error_catching
        assert exception_type_caught is None
        assert type(exception) is KeyError
        
    else:
        assert error_catching
        assert exception_type_caught is KeyError
        exception_type_caught = None
    #                                                                         #
    ### Finished testing creating context manager before `with`. ##############
        
    assert flag is None
    assert exception_type_caught is None

    ### Testing decorated function: ###########################################
    #                                                                         #
    @context_manager_type('meow')
    def f():
        assert flag == 'meow'
        1/0
    
    try:
        f()
    except Exception, exception:
        assert not error_catching
        assert exception_type_caught is None
        assert type(exception) is ZeroDivisionError        
    else:
        assert error_catching
        assert exception_type_caught is ZeroDivisionError
        exception_type_caught = None
    #                                                                         #
    ### Finished testing decorated function. ##################################
        
    assert flag is None
    exception_type_caught = None
    
    ### Testing manually decorated function: ##################################
    #                                                                         #
    def g(a, b=2, **kwargs):
        assert flag == 'meow'
        eval('Ooga booga I am a syntax error.')

    with cute_testing.RaiseAssertor(AssertionError):
        g('whatever')
        
    assert flag is None
    assert exception_type_caught is None
    
    new_g = context_manager_type('meow')(g)
        
    assert flag is None
    assert exception_type_caught is None
    cute_testing.assert_polite_wrapper(new_g, g)
    
    try:
        new_g('whatever')
    except Exception, exception:
        assert not error_catching
        assert exception_type_caught is None
        assert type(exception) is SyntaxError
    else:
        assert error_catching
        assert exception_type_caught is SyntaxError
        exception_type_caught = None
    #                                                                         #
    ### Finished testing manually decorated function. ########################
    
    ### Testing deep nesting: #################################################
    #                                                                         #
    my_context_manager = context_manager_type(123)
    assert flag is None
    try:
        with my_context_manager:
            assert flag == 123
            with my_context_manager:
                assert flag == 123
                with my_context_manager:
                    assert flag == 123
                    with my_context_manager:
                        assert flag == 123
                        with my_context_manager:
                            assert flag == 123
                            raise StopIteration
                        assert flag == 123
                    assert flag == 123
                assert flag == 123
            assert flag == 123
            
    except Exception, exception:
        assert not error_catching
        assert exception_type_caught is None
        assert type(exception) is StopIteration
        
    else:
        assert error_catching
        assert exception_type_caught is StopIteration
        exception_type_caught = None
        
    assert flag is None

    
    try:
        with context_manager_type(1) as return_value_1:
            assert flag == 1
            with context_manager_type(2) as return_value_2:
                assert flag == 2
                with return_value_1 or context_manager_type(1):
                    assert flag == 1
                    raise NotImplementedError
                assert flag == 2
            assert flag == 1
            
    except Exception, exception:
        assert not error_catching
        assert exception_type_caught is None
        assert type(exception) is NotImplementedError
        
    else:
        assert error_catching
        assert exception_type_caught is NotImplementedError
        exception_type_caught = None
        
    assert flag is None
    #                                                                         #
    ### Finished testing deep nesting. ########################################
    
########NEW FILE########
__FILENAME__ = test_external
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Tests taken from Python's `contextlib'.'''

from __future__ import with_statement

import sys

import nose
from garlicsim.general_misc.third_party import unittest2

import garlicsim
from garlicsim.general_misc.context_manager import (ContextManager,
                                                    ContextManagerType)


class ContextManagerTestCase(unittest2.TestCase):

    def test_contextmanager_plain(self):
        state = []
        @ContextManagerType
        def woohoo():
            state.append(1)
            yield 42
            state.append(999)
        with woohoo() as x:
            self.assertEqual(state, [1])
            self.assertEqual(x, 42)
            state.append(x)
        self.assertEqual(state, [1, 42, 999])

    def test_contextmanager_finally(self):
        state = []
        @ContextManagerType
        def woohoo():
            state.append(1)
            try:
                yield 42
            finally:
                state.append(999)
        with self.assertRaises(ZeroDivisionError):
            with woohoo() as x:
                self.assertEqual(state, [1])
                self.assertEqual(x, 42)
                state.append(x)
                raise ZeroDivisionError()
        self.assertEqual(state, [1, 42, 999])

    def test_contextmanager_no_reraise(self):
        @ContextManagerType
        def whee():
            yield
        ctx = whee()
        ctx.__enter__()
        # Calling __exit__ should not result in an exception
        self.assertFalse(ctx.__exit__(TypeError, TypeError("foo"), None))

    def test_contextmanager_trap_yield_after_throw(self):
        @ContextManagerType
        def whoo():
            try:
                yield
            except:
                yield
        ctx = whoo()
        ctx.__enter__()
        self.assertRaises(
            RuntimeError, ctx.__exit__, TypeError, TypeError("foo"), None
        )

    def test_contextmanager_except(self):
        state = []
        @ContextManagerType
        def woohoo():
            state.append(1)
            try:
                yield 42
            except ZeroDivisionError, e:
                state.append(e.args[0])
                self.assertEqual(state, [1, 42, 999])
        with woohoo() as x:
            self.assertEqual(state, [1])
            self.assertEqual(x, 42)
            state.append(x)
            raise ZeroDivisionError(999)
        self.assertEqual(state, [1, 42, 999])

    def _create_contextmanager_attribs(self):
        if garlicsim.__version_info__ <= (0, 6, 3):
            raise nose.SkipTest
        def attribs(**kw):
            def decorate(func):
                for k,v in kw.items():
                    setattr(func,k,v)
                return func
            return decorate
        @ContextManagerType
        @attribs(foo='bar')
        def baz(spam):
            """Whee!"""
        return baz

    def test_contextmanager_attribs(self):
        baz = self._create_contextmanager_attribs()
        self.assertEqual(baz.__name__,'baz')
        self.assertEqual(baz.foo, 'bar')

    @unittest2.skipIf(hasattr(sys, 'flags') and sys.flags.optimize >= 2,
                      "Docstrings are omitted with -O2 and above")
    def test_contextmanager_doc_attrib(self):
        if garlicsim.__version_info__ <= (0, 6, 3):
            raise nose.SkipTest('Not sure what to do about this.')
        baz = self._create_contextmanager_attribs()
        self.assertEqual(baz.__doc__, "Whee!")


class MyContextManager(ContextManager):
    started = False
    exc = None
    catch = False

    def __enter__(self):
        self.started = True
        return self

    def __exit__(self, *exc):
        self.exc = exc
        return self.catch


class TestContextDecorator(unittest2.TestCase):

    def test_contextdecorator(self):
        context = MyContextManager()
        with context as result:
            self.assertIs(result, context)
            self.assertTrue(context.started)

        self.assertEqual(context.exc, (None, None, None))


    def test_contextdecorator_with_exception(self):
        context = MyContextManager()

        def f():
            with context:
                raise NameError('foo')
        self.assertRaises(NameError, f)
        self.assertIsNotNone(context.exc)
        self.assertIs(context.exc[0], NameError)

        context = MyContextManager()
        context.catch = True
        with context:
            raise NameError('foo')
        self.assertIsNotNone(context.exc)
        self.assertIs(context.exc[0], NameError)


    def test_decorator(self):
        context = MyContextManager()

        @context
        def test():
            self.assertIsNone(context.exc)
            self.assertTrue(context.started)
        test()
        self.assertEqual(context.exc, (None, None, None))


    def test_decorator_with_exception(self):
        context = MyContextManager()

        @context
        def test():
            self.assertIsNone(context.exc)
            self.assertTrue(context.started)
            raise NameError('foo')

        self.assertRaises(NameError, test)
        self.assertIsNotNone(context.exc)
        self.assertIs(context.exc[0], NameError)


    def test_decorating_method(self):
        context = MyContextManager()

        class Test(object):

            @context
            def method(self, a, b, c=None):
                self.a = a
                self.b = b
                self.c = c

        # these tests are for argument passing when used as a decorator
        test = Test()
        test.method(1, 2)
        self.assertEqual(test.a, 1)
        self.assertEqual(test.b, 2)
        self.assertEqual(test.c, None)

        test = Test()
        test.method('a', 'b', 'c')
        self.assertEqual(test.a, 'a')
        self.assertEqual(test.b, 'b')
        self.assertEqual(test.c, 'c')

        test = Test()
        test.method(a=1, b=2)
        self.assertEqual(test.a, 1)
        self.assertEqual(test.b, 2)


    def test_typo_enter(self):
        if garlicsim.__version_info__ <= (0, 6, 3):
            raise nose.SkipTest
        class MyContextManager(ContextManager):
            def __unter__(self):
                pass
            def __exit__(self, *exc):
                pass

        with self.assertRaises(AttributeError):
            with MyContextManager():
                pass


    def test_typo_exit(self):
        if garlicsim.__version_info__ <= (0, 6, 3):
            raise nose.SkipTest
        class MyContextManager(ContextManager):
            def __enter__(self):
                pass
            def __uxit__(self, *exc):
                pass

        with self.assertRaises(AttributeError):
            with MyContextManager():
                pass


    def test_contextdecorator_as_mixin(self):
        
        class somecontext(object):
            started = False
            exc = None

            def __enter__(self):
                self.started = True
                return self

            def __exit__(self, *exc):
                self.exc = exc

        class MyContextManager(somecontext, ContextManager):
            pass

        context = MyContextManager()
        @context
        def test():
            self.assertIsNone(context.exc)
            self.assertTrue(context.started)
        test()
        self.assertEqual(context.exc, (None, None, None))


    def test_contextmanager_as_decorator(self):
        state = []
        @ContextManagerType
        def woohoo(y):
            state.append(y)
            yield
            state.append(999)

        @woohoo(1)
        def test(x):
            self.assertEqual(state, [1])
            state.append(x)
        test('something')
        self.assertEqual(state, [1, 'something', 999])



########NEW FILE########
__FILENAME__ = test_problematic_context_managers
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Testing module for various problematic context managers.'''

from __future__ import with_statement

import nose

from garlicsim.general_misc import cute_testing

from garlicsim.general_misc.context_manager import (ContextManager,
                                                    ContextManagerType,
                                                    SelfHook)

def test_defining_enter_and_manage_context():
    '''
    Test context manager class defining both `__enter__` and `manage_context`.
    '''
    
    with cute_testing.RaiseAssertor(
        Exception,
        'both an `__enter__` method and a'
        ):
        
        class MyContextManager(ContextManager):
            def manage_context(self):
                yield self
            def __enter__(self):
                return self

            
def test_defining_exit_and_manage_context():
    '''
    Test context manager class defining both `__exit__` and `manage_context`.
    '''
    
    with cute_testing.RaiseAssertor(
        Exception,
        'both an `__exit__` method and a'
        ):
        
        class MyContextManager(ContextManager):
            def manage_context(self):
                yield self
            def __exit__(self, *exc):
                pass

            
def test_defining_enter_on_top_of_manage_context():
    '''
    Test an `__enter__`-definer inheriting from a `manage_context`-definer.
    '''
    class MyBaseContextManager(ContextManager):
        def manage_context(self):
            yield self
            
    with cute_testing.RaiseAssertor(
        Exception,
        "defines an `__enter__` method, but not an `__exit__` method"
        ):
        
        class MyContextManager(MyBaseContextManager):
            def __enter__(self):
                return self
            
            
def test_defining_exit_on_top_of_manage_context():
    '''
    Test an `__exit__`-definer inheriting from a `manage_context`-definer.
    '''
    
    class MyBaseContextManager(ContextManager):
        def manage_context(self):
            yield self
            
    with cute_testing.RaiseAssertor(
        Exception,
        "defines an `__exit__` method, but not an `__enter__` method"
        ):
        
        class MyContextManager(MyBaseContextManager):
            def __exit__(self, *exc):
                pass
########NEW FILE########
__FILENAME__ = test_is_iterable
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Testing module for `garlicsim.general_misc.cute_iter_tools.is_iterable`.'''

import nose.tools

from garlicsim.general_misc.infinity import infinity
from garlicsim.general_misc import cute_iter_tools
from garlicsim.general_misc.cute_iter_tools import is_iterable


def test():
    '''Test basic workings of `is_iterable`.'''
    
    iterables = [
        [1, 2, 3],
        (1, 2),
        {},
        (),
        [[1]],
        'asdfasdf',
        ''
    ]
    
    non_iterables = [
        dict,
        list,
        type,
        None,
        True,
        False,
        Exception,
        lambda x: x
    ]
    
    for iterable in iterables:
        assert is_iterable(iterable)
        
    for non_iterable in non_iterables:
        assert not is_iterable(non_iterable)
########NEW FILE########
__FILENAME__ = test_shorten
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Testing module for `garlicsim.general_misc.cute_iter_tools.shorten`.'''

import nose.tools

from garlicsim.general_misc.infinity import infinity
from garlicsim.general_misc import cute_iter_tools
from garlicsim.general_misc.cute_iter_tools import shorten


def test():
    '''Test basic workings of `shorten`.'''
    my_range = [0, 1, 2, 3, 4]

    short_iterator = shorten(my_range, 3)
    assert short_iterator.__iter__() is short_iterator
    
    assert list(shorten(my_range, 0)) == []
    assert list(shorten(my_range, 1)) == range(1)
    assert list(shorten(my_range, 2)) == range(2)
    assert list(shorten(my_range, 3)) == range(3)
    assert list(shorten(my_range, 4)) == range(4)
    
    assert list(shorten(my_range, infinity)) == my_range
    assert list(shorten(iter(my_range), infinity)) == my_range

    
def test_dont_pull_extra_item():
    '''Test that `shorten` doesn't pull an extra member from the iterable.'''
    def generator():
        yield 1
        yield 2
        yield 3
        raise Exception

    nose.tools.assert_raises(Exception, lambda: list(generator()))
    
    iterator_1 = shorten(generator(), 4)
    nose.tools.assert_raises(Exception, lambda: list(iterator_1))
    
    iterator_2 = shorten(generator(), infinity)
    nose.tools.assert_raises(Exception, lambda: list(iterator_2))
    
    iterator_3 = shorten(generator(), 3)
    list(iterator_3) # Pulling exactly three so we avoid the exception.
########NEW FILE########
__FILENAME__ = shared
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Defines tools for testing `garlicsim.general_misc.cute_profile`.'''

from __future__ import with_statement

import sys

from garlicsim.general_misc.sys_tools import OutputCapturer
from garlicsim.general_misc import logic_tools

segments = ('function calls in', 'Ordered by', 'ncalls', 'tottime', 'percall',
            'cumtime')


def call_and_check_if_profiled(f):
    '''Call the function `f` and return whether it profiled itself.'''
    
    with OutputCapturer() as output_capturer:
        f()
    
    output = output_capturer.output
        
    segments_found = [(segment in output) for segment in segments]
    
    if not logic_tools.all_equal(segments_found):
        raise Exception("Some segments were found, but some weren't; can't "
                        "know if this was a profiled call or not. Possibly "
                        "some of our segments are wrong.")
    
    return segments_found[0]
    
    
    
########NEW FILE########
__FILENAME__ = test_cute_profile
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Testing module for `garlicsim.general_misc.cute_profile`.
'''

from garlicsim.general_misc import cute_profile
from garlicsim.general_misc import cute_testing

from .shared import call_and_check_if_profiled


def func(x, y, z=3):
    '''Function that does some meaningless number-juggling.'''
    sum([1, 2, 3])
    set([1, 2]) | set([2, 3])
    return x, y, z



def test_simple():
    '''Test the basic workings of `profile_ready`.'''
    f = cute_profile.profile_ready()(func)
    assert call_and_check_if_profiled(lambda: f(1, 2)) is False
    assert call_and_check_if_profiled(lambda: f(1, 2)) is False
    f.profiling_on = True
    assert call_and_check_if_profiled(lambda: f(1, 2)) is True
    assert call_and_check_if_profiled(lambda: f(1, 2)) is False
    
    
    f = cute_profile.profile_ready(condition=True)(func)
    assert call_and_check_if_profiled(lambda: f(1, 2)) is True
    assert call_and_check_if_profiled(lambda: f(1, 2)) is False
    f.profiling_on = False
    assert call_and_check_if_profiled(lambda: f(1, 2)) is False
    assert call_and_check_if_profiled(lambda: f(1, 2)) is False
    
    
    f = cute_profile.profile_ready(condition=True, off_after=False)(func)
    assert call_and_check_if_profiled(lambda: f(1, 2)) is True
    assert call_and_check_if_profiled(lambda: f(1, 2)) is True
    f.profiling_on = True
    assert call_and_check_if_profiled(lambda: f(1, 2)) is True
    assert call_and_check_if_profiled(lambda: f(1, 2)) is True
    
    
    f = cute_profile.profile_ready(off_after=True)(func)
    assert call_and_check_if_profiled(lambda: f(1, 2)) is False
    assert call_and_check_if_profiled(lambda: f(1, 2)) is False
    f.profiling_on = True
    assert call_and_check_if_profiled(lambda: f(1, 2)) is True
    assert call_and_check_if_profiled(lambda: f(1, 2)) is False
    assert call_and_check_if_profiled(lambda: f(1, 2)) is False
    f.profiling_on = True
    assert call_and_check_if_profiled(lambda: f(1, 2)) is True
    assert call_and_check_if_profiled(lambda: f(1, 2)) is False
    assert call_and_check_if_profiled(lambda: f(1, 2)) is False
    f.condition = lambda f, *args, **kwargs: True
    assert call_and_check_if_profiled(lambda: f(1, 2)) is True
    assert call_and_check_if_profiled(lambda: f(1, 2)) is False
    assert call_and_check_if_profiled(lambda: f(1, 2)) is False
    
    
    
def test_method():
    '''Test that `profile_ready` works as a method decorator.'''
    
    class A(object):
        def __init__(self):
            self.x = 0
                
        @cute_profile.profile_ready(off_after=False)
        def increment(self):
            sum([1, 2, 3])
            self.x += 1
            
    a = A()
    assert a.x == 0
    assert call_and_check_if_profiled(a.increment) is False
    assert a.x == 1
    assert call_and_check_if_profiled(a.increment) is False
    assert a.x == 2
    assert call_and_check_if_profiled(a.increment) is False
    assert a.x == 3

    a.increment.im_func.profiling_on = True
    
    assert call_and_check_if_profiled(a.increment) is True
    assert a.x == 4
    assert call_and_check_if_profiled(a.increment) is True
    assert a.x == 5
    assert call_and_check_if_profiled(a.increment) is True
    assert a.x == 6
    
    a.increment.im_func.off_after = True
    
    assert call_and_check_if_profiled(a.increment) is True
    assert a.x == 7
    assert call_and_check_if_profiled(a.increment) is False
    assert a.x == 8
    assert call_and_check_if_profiled(a.increment) is False
    assert a.x == 9
    
    a.increment.im_func.profiling_on = True
    
    assert call_and_check_if_profiled(a.increment) is True
    assert a.x == 10
    assert call_and_check_if_profiled(a.increment) is False
    assert a.x == 11
    assert call_and_check_if_profiled(a.increment) is False
    assert a.x == 12
    
    

def test_condition():
    '''Test the `condition` argument of `profile_ready`.'''

    x = 7
    
    @cute_profile.profile_ready(condition=lambda function, y: x == y,
                                off_after=False)
    def f(y):
        pass
    
    # Condition is `False`:
    assert call_and_check_if_profiled(lambda: f(5)) is False
    assert call_and_check_if_profiled(lambda: f(6)) is False
    
    # Condition is `True`:
    assert call_and_check_if_profiled(lambda: f(7)) is True
    
    # So now profiling is on regardless of condition:
    assert call_and_check_if_profiled(lambda: f(8)) is True
    assert call_and_check_if_profiled(lambda: f(9)) is True
    assert call_and_check_if_profiled(lambda: f(4)) is True
    assert call_and_check_if_profiled(lambda: f('frr')) is True
    
    # Setting profiling off:
    f.profiling_on = False
        
    # So no profiling now:
    assert call_and_check_if_profiled(lambda: f(4)) is False
    assert call_and_check_if_profiled(lambda: f('frr')) is False
    
    # Until the condition becomes `True` again: (And this time, for fun, with a
    # different `x`:)
    x = 9
    assert call_and_check_if_profiled(lambda: f(9)) is True
    
    # So now, again, profiling is on regardless of condition:
    assert call_and_check_if_profiled(lambda: f(4)) is True
    assert call_and_check_if_profiled(lambda: f('frr')) is True
    
    # Let's give it a try with `.off_after = True`:
    f.off_after = True
    
    # Setting profiling off again:
    f.profiling_on = False
    
    # And for fun set a different `x`:
    x = 'wow'
    
    # Now profiling is on only when the condition is fulfilled, and doesn't
    # stay on after:
    assert call_and_check_if_profiled(lambda: f('ooga')) is False
    assert call_and_check_if_profiled(lambda: f('booga')) is False
    assert call_and_check_if_profiled(lambda: f('wow')) is True
    assert call_and_check_if_profiled(lambda: f('meow')) is False
    assert call_and_check_if_profiled(lambda: f('kabloom')) is False
    
    # In fact, after successful profiling the condition gets reset to `None`:
    assert f.condition is None
    
    # So now if we'll call the function again, even if the (former) condition
    # is `True`, there will be no profiling:
    assert call_and_check_if_profiled(lambda: f(9)) is False
    
    # So if we want to use a condition again, we have to set it ourselves:
    f.condition = lambda f, y: isinstance(y, float)
    
    # And again (since `.off_after == True`) profiling will turn on for just
    # one time when the condition evaluates to `True` :
    assert call_and_check_if_profiled(lambda: f('kabloom')) is False
    assert call_and_check_if_profiled(lambda: f(3)) is False
    assert call_and_check_if_profiled(lambda: f(3.1)) is True
    assert call_and_check_if_profiled(lambda: f(3.1)) is False
    assert call_and_check_if_profiled(lambda: f(-4.9)) is False
    
    
def test_perfects():
    '''Test `cute_profile` on a function that finds perfect numbers.'''
    
    def get_divisors(x):
        return [i for i in xrange(1, x) if (x % i == 0)]
    
    def is_perfect(x):
        return sum(get_divisors(x)) == x
    
    @cute_profile.profile_ready()
    def get_perfects(top):
        return [i for i in xrange(1, top) if is_perfect(i)]
    
    result = get_perfects(30)
    get_perfects.profiling_on = True
    def f():
        assert get_perfects(30) == result
    assert call_and_check_if_profiled(f) is True
    
    
def test_polite_wrapper():
    '''
    Test that `profile_ready` decorator produces a polite function wrapper.
    
    e.g. that the name, documentation and signature of the original function
    are used in the wrapper function, and a few other things.
    '''
    cute_testing.assert_polite_wrapper(
        cute_profile.profile_ready()(func),
        func
    )
########NEW FILE########
__FILENAME__ = test_garlicsim_wx_doesnt_import
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Testing module for `garlicsim.general_misc.cute_profile`.'''

import sys

import nose

import garlicsim


def test_garlicsim_wx_doesnt_import():
    '''
    Test that importing `garlicsim_wx` doesn't import `cute_profile`.'
    
    It's important that `garlicsim` and `garlicsim_wx` won't import
    `cute_profile` by default since on Ubuntu the required `pstats` module
    isn't always available, and we wouldn't want to send the user to download
    it if he just wants to use `garlicsim` (or `_wx`) and the `cute_profile`
    module itself.
    '''
    # Ideally we should be ensuring here that `garlicsim` isn't imported, or
    # unimporting it somehow. I don't know how to reliably do that yet, so I
    # just assume that `nose` imported only `garlicsim` without importing
    # `garlicsim.general_misc.cute_profile`.
    
    if garlicsim.__version_info__ <= (0, 6, 3):
        raise nose.SkipTest("Don't know how to ensure nose/wing start test "
                            "with nothing imported")
    import garlicsim_wx
    assert 'garlicsim_wx' in sys.modules
    assert 'garlicsim' in sys.modules
    assert 'garlicsim.general_misc.cute_profile' not in sys.modules
########NEW FILE########
__FILENAME__ = test_assert_same_signature
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Testing module for `garlicsim.general_misc.cute_testing.assert_same_signature`.
'''

from __future__ import with_statement

from garlicsim.general_misc.third_party import decorator as decorator_module

from garlicsim.general_misc.cute_testing import (assert_same_signature,
                                                 RaiseAssertor,
                                                 Failure)


def test():
    '''Test the basic workings of `assert_same_signature`.'''
    
    def f(a, b=1, **kwargs):
        pass
    def g(a, b=1, **kwargs):
        pass
    def h(z):
        pass
    
    assert_same_signature(f, g)
    with RaiseAssertor(Failure):
        assert_same_signature(f, h)
    with RaiseAssertor(Failure):
        assert_same_signature(g, h)
        
        
    new_f = decorator_module.decorator(
        lambda *args, **kwargs: None,
        f
    )
    
    assert_same_signature(f, g, new_f)
    with RaiseAssertor(Failure):
        assert_same_signature(new_f, h)
        
        
    new_h = decorator_module.decorator(
        lambda *args, **kwargs: None,
        h
    )
    
    assert_same_signature(h, new_h)
    with RaiseAssertor(Failure):
        assert_same_signature(new_h, new_f)
    with RaiseAssertor(Failure):
        assert_same_signature(new_h, new_f, g)
    with RaiseAssertor(Failure):
        assert_same_signature(new_h, f)
        
    assert_same_signature(new_h, h, new_h, new_h)                         
                            
########NEW FILE########
__FILENAME__ = test_raise_assertor
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Testing module for `garlicsim.general_misc.cute_testing.RaiseAssertor`.'''

from __future__ import with_statement

import re

import nose

from garlicsim.general_misc import cute_testing
from garlicsim.general_misc.cute_testing import RaiseAssertor, Failure


class MyException(Exception):
    pass


def test_basic():
    '''Test the basic workings of `RaiseAssertor`.'''
    with RaiseAssertor(Exception):
        raise Exception
    with RaiseAssertor(Exception):
        raise TypeError
    
    def f():
        with RaiseAssertor(ZeroDivisionError):
            raise MyException
    nose.tools.assert_raises(Failure, f)
    with RaiseAssertor(Failure):
        f()
    
    def g():
        with RaiseAssertor(Exception):
            pass
    nose.tools.assert_raises(Failure, g)
    with RaiseAssertor(Failure):
        g()
    
    def h():
        with RaiseAssertor(RuntimeError, 'booga'):
            pass
    nose.tools.assert_raises(Failure, h)
    with RaiseAssertor(Failure):
        h()
    
    with RaiseAssertor(Failure) as raise_assertor:
        assert isinstance(raise_assertor, RaiseAssertor)
        with RaiseAssertor(RuntimeError):
            {}[0]
            
    assert isinstance(raise_assertor.exception, Exception)
            

def test_decorator():
    '''Test using `RaiseAssertor` as a decorator.'''
    @RaiseAssertor(ZeroDivisionError)
    def f():
        1/0
        
    f()
    
    cute_testing.assert_polite_wrapper(f)

    
def test_string():
    '''
    Test using `RaiseAssertor` specifying sub-string of the exception message.
    '''
    with RaiseAssertor(Exception, 'wer'):
        raise TypeError('123qwerty456')
    
    with RaiseAssertor(Failure):
        with RaiseAssertor(Exception, 'ooga booga'):
            raise TypeError('123qwerty456')
        
    with RaiseAssertor(Failure):
        with RaiseAssertor(OSError, 'wer'):
            raise SyntaxError('123qwerty456')
        
        
def test_regex():
    '''
    Test using `RaiseAssertor` specifying regex pattern for exception message.
    '''
    with RaiseAssertor(Exception, re.compile('^123\w*?456$')):
        raise TypeError('123qwerty456')
    
    with RaiseAssertor(Failure):
        with RaiseAssertor(Exception, re.compile('^ooga b?ooga$')):
            raise TypeError('123qwerty456')
        
    with RaiseAssertor(Failure):
        with RaiseAssertor(OSError, re.compile('^123\w*?456$')):
            raise SyntaxError('123qwerty456')
        

def test_assert_exact_type():
    '''Test `RaiseAssertor`'s `assert_exact_type` option.'''
    with RaiseAssertor(LookupError):
        raise KeyError("Look at me, I'm a KeyError")
    
    error_message = (
        "The exception `KeyError(\"Look at me, I'm a KeyError\",)` was "
        "raised, and it *is* an instance of the `LookupError` we were "
        "expecting; but its type is not `LookupError`, it's `KeyError`, which "
        "is a subclass of `LookupError`, but you specified "
        "`assert_exact_type=True`, so subclasses aren't acceptable."
    )
    
    with RaiseAssertor(Failure, error_message):
        with RaiseAssertor(LookupError, assert_exact_type=True):
            raise KeyError("Look at me, I'm a KeyError")    
    
        
        
        
########NEW FILE########
__FILENAME__ = test_has_identity
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Testing module for `identities.HasIdentity`.'''

import copy
import pickle

from garlicsim.general_misc import identities


class A(identities.HasIdentity):
    pass


def test_has_identity():
    '''Test the basic workings of `HasIdentity`.'''
    
    x0 = A()
    y0 = A()
    z0 = A()
    
    assert x0.has_same_identity_as(x0)
    assert y0.has_same_identity_as(y0)
    assert z0.has_same_identity_as(z0)
    
    assert x0 & x0
    assert y0 & y0
    assert z0 & z0
    
    assert not x0.has_same_identity_as(y0)
    assert not y0.has_same_identity_as(x0)
    assert not x0.has_same_identity_as(z0)
    assert not z0.has_same_identity_as(x0)
    assert not y0.has_same_identity_as(z0)
    assert not z0.has_same_identity_as(y0)
    
    assert not x0 & y0
    assert not y0 & x0
    assert not x0 & z0
    assert not z0 & x0
    assert not y0 & z0
    assert not z0 & y0
    
    ### Testing deepcopies: ###################################################
    #                                                                         #
    x1 = copy.deepcopy(x0)
    y1 = copy.deepcopy(y0)
    z1 = copy.deepcopy(z0)
    
    assert x0 & x1
    assert y0 & y1
    assert z0 & z1
    
    assert x0.has_same_identity_as(x1)
    assert x1.has_same_identity_as(x0)
    assert y0.has_same_identity_as(y1)
    assert y1.has_same_identity_as(y0)
    assert z0.has_same_identity_as(z1)
    assert z1.has_same_identity_as(z0)
    #                                                                         #
    ### Finished testing deepcopies. ##########################################
    
    ### Testing picked-unpickled copies: ######################################
    #                                                                         #
    x2 = pickle.loads(pickle.dumps(x0, protocol=2))
    y2 = pickle.loads(pickle.dumps(y0, protocol=2))
    z2 = pickle.loads(pickle.dumps(z0, protocol=2))
    
    assert x2 & x1
    assert y2 & y1
    assert z2 & z1
    
    assert x2.has_same_identity_as(x1)
    assert x1.has_same_identity_as(x2)
    assert y2.has_same_identity_as(y1)
    assert y1.has_same_identity_as(y2)
    assert z2.has_same_identity_as(z1)
    assert z1.has_same_identity_as(z2)
    #                                                                         #
    ### Finished testing picked-unpickled copies. #############################

    
########NEW FILE########
__FILENAME__ = test
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Testing module for `garlicsim.general_misc.import_tools.exists`.'''

import nose.tools

from garlicsim.general_misc import import_tools
from garlicsim.general_misc.import_tools import exists

def test():
    '''Test the basic workings of `exists`.'''
    assert not exists('adfgadbnv5nrn')
    assert not exists('45gse_e5b6_DFDF')
    assert not exists('VWEV65hnrt___a4')
    assert exists('email')
    assert exists('re')
    assert exists('sys')
    nose.tools.assert_raises(Exception, lambda: exists('email.encoders'))
########NEW FILE########
__FILENAME__ = test_zip
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Testing `import_tools.exists` on modules available through zip archives.'''

# todotest: test package in zip, zip in zip, multiple root-level modules in
# zip.

from __future__ import with_statement

import os
import tempfile
import shutil

import pkg_resources
import nose.tools

from garlicsim.general_misc import sys_tools
from garlicsim.general_misc import cute_testing
from garlicsim.general_misc import import_tools
from garlicsim.general_misc import temp_file_tools
from garlicsim.general_misc.import_tools import exists

from . import resources as __resources_package
resources_package = __resources_package.__name__


def test_zip():
    '''Test `exists` works on zip-imported modules.'''
    
    assert not exists('zip_imported_module_bla_bla')
    
    zip_string = pkg_resources.resource_string(resources_package,
                                               'archive_with_module.zip')
    
    with temp_file_tools.TemporaryFolder(prefix='temp_test_garlicsim_') \
                                                          as temp_folder:

        temp_zip_path = os.path.join(temp_folder, 'archive_with_module.zip')
        
        with open(temp_zip_path, 'wb') as temp_zip_file:
            
            temp_zip_file.write(zip_string)            
                
        assert not exists('zip_imported_module_bla_bla')
        
        with sys_tools.TempSysPathAdder(temp_zip_path):
            assert exists('zip_imported_module_bla_bla')
            import zip_imported_module_bla_bla
            assert zip_imported_module_bla_bla.__doc__ == \
                   ('Module for testing `import_tools.exists` on zip-archived '
                    'modules.')
            
########NEW FILE########
__FILENAME__ = test_get_default_args_dict
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Testing for `garlicsim.general_misc.introspection_tools.get_default_args_dict`.
'''

from garlicsim.general_misc.introspection_tools import get_default_args_dict
from garlicsim.general_misc.nifty_collections import OrderedDict


def test():
    '''Test the basic workings of `get_default_args_dict`.'''
    def f(a, b, c=3, d=4):
        pass
    
    assert get_default_args_dict(f) == \
        OrderedDict((('c', 3), ('d', 4)))
    
    
def test_generator():
    '''Test `get_default_args_dict` on a generator function.'''
    def f(a, meow='frr', d={}):
        yield None
    
    assert get_default_args_dict(f) == \
        OrderedDict((('meow', 'frr'), ('d', {})))
    
    
def test_empty():
    '''Test `get_default_args_dict` on a function with no defaultful args.'''
    def f(a, b, c, *args, **kwargs):
        pass
    
    assert get_default_args_dict(f) == \
        OrderedDict()
    
########NEW FILE########
__FILENAME__ = test_get_mro_depth_of_method
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Testing module for `garlicsim.general_misc.misc_tools.get_mro_depth_of_method`.
'''

from garlicsim.general_misc.misc_tools import get_mro_depth_of_method


def test():
    '''Test the basic workings of `get_mro_depth_of_method`.'''
    class A(object):
        def a_method(self):
            pass
    
    class B(A):
        def b_method(self):
            pass
        
    class C(A):
        def c_method(self):
            pass
        
    class D(object):
        def d_method(self):
            pass
        
    class E(B, D, C):
        def e_method(self):
            pass
        
    assert get_mro_depth_of_method(A, 'a_method') == 0
    
    assert get_mro_depth_of_method(B, 'a_method') == 1
    assert get_mro_depth_of_method(B, 'b_method') == 0
    
    assert get_mro_depth_of_method(C, 'a_method') == 1
    assert get_mro_depth_of_method(C, 'c_method') == 0
    
    assert get_mro_depth_of_method(D, 'd_method') == 0
    
    assert get_mro_depth_of_method(E, 'e_method') == 0
    assert get_mro_depth_of_method(E, 'b_method') == 1
    assert get_mro_depth_of_method(E, 'd_method') == 2
    assert get_mro_depth_of_method(E, 'c_method') == 3
    assert get_mro_depth_of_method(E, 'a_method') == 4
    
########NEW FILE########
__FILENAME__ = test_is_legal_variable_name
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Testing module for `garlicsim.general_misc.misc_tools.is_legal_variable_name`.
'''

from garlicsim.general_misc.misc_tools import is_legal_ascii_variable_name


def test():
    '''Test `is_legal_variable_name` on various legal and illegal inputs.'''
    legals = ['qwerqw', 'wer23434f3', 'VDF4vr', '_4523ga', 'AGF___43___4_',
              '_', '__', '___']
    illegals = ['1dgfads', 'aga`fdg', '-haeth', '4gag5h+sdfh.', '.afdg',
                'fdga"adfg', 'afdga afd']
    
    for legal in legals:
        assert is_legal_ascii_variable_name(legal)
    
    for illegal in illegals:
        assert not is_legal_ascii_variable_name(illegal)
########NEW FILE########
__FILENAME__ = test_monkeypatching_tools
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Testing module for `garlicsim.general_misc.monkeypatching_tools`.'''

from __future__ import with_statement

from garlicsim.general_misc import cute_testing

from garlicsim.general_misc import monkeypatching_tools


def test():
    '''Test basic workings of `monkeypatch_method`.'''
    
    class A(object):
        pass

    @monkeypatching_tools.monkeypatch_method(A)
    def meow(a):
        return 1
    
    a = A()
    
    assert a.meow() == meow(a) == 1
    
    @monkeypatching_tools.monkeypatch_method(A, 'roar')
    def woof(a):
        return 2
    
    assert a.roar() == woof(a) == 2
    
    assert not hasattr(a, 'woof')
    
    del meow, woof
    
    
def test_helpful_message_when_forgetting_parentheses():
    '''Test user gets a helpful exception when when forgetting parentheses.'''

    def confusedly_forget_parentheses():
        @monkeypatching_tools.monkeypatch_method
        def f(): pass
        
    with cute_testing.RaiseAssertor(
        TypeError,
        'It seems that you forgot to add parentheses after '
        '`@monkeypatch_method` when decorating the `f` function.'
    ):
        
        confusedly_forget_parentheses()
########NEW FILE########
__FILENAME__ = test_external
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Testing module for `nifty_collections.Counter`.'''

from random import randrange
import copy
import pickle
import cPickle
from garlicsim.general_misc.third_party.abcs_collection import Mapping

from garlicsim.general_misc.third_party import unittest2

from garlicsim.general_misc import misc_tools

from garlicsim.general_misc.nifty_collections import Counter


class TestCounter(unittest2.TestCase):

    def test_basics(self):
        c = Counter('abcaba')
        self.assertEqual(c, Counter({'a':3 , 'b': 2, 'c': 1}))
        self.assertEqual(c, Counter(a=3, b=2, c=1))
        self.assertIsInstance(c, dict)
        self.assertIsInstance(c, Mapping)
        self.assertTrue(misc_tools.is_subclass(Counter, dict))
        self.assertTrue(misc_tools.is_subclass(Counter, Mapping))
        self.assertEqual(len(c), 3)
        self.assertEqual(sum(c.values()), 6)
        self.assertEqual(sorted(c.values()), [1, 2, 3])
        self.assertEqual(sorted(c.keys()), ['a', 'b', 'c'])
        self.assertEqual(sorted(c), ['a', 'b', 'c'])
        self.assertEqual(sorted(c.items()),
                         [('a', 3), ('b', 2), ('c', 1)])
        self.assertEqual(c['b'], 2)
        self.assertEqual(c['z'], 0)
    
        self.assertEqual(c.has_key('c'), True)
        self.assertEqual(c.has_key('z'), False)
        
        self.assertEqual(c.__contains__('c'), True)
        self.assertEqual(c.__contains__('z'), False)
        self.assertEqual(c.get('b', 10), 2)
        self.assertEqual(c.get('z', 10), 10)
        self.assertEqual(c, dict(a=3, b=2, c=1))
        self.assertEqual(repr(c), "Counter({'a': 3, 'b': 2, 'c': 1})")
        self.assertEqual(c.most_common(), [('a', 3), ('b', 2), ('c', 1)])
        for i in range(5):
            self.assertEqual(c.most_common(i),
                             [('a', 3), ('b', 2), ('c', 1)][:i])
        self.assertEqual(''.join(sorted(c.elements())), 'aaabbc')
        c['a'] += 1         # increment an existing value
        c['b'] -= 2         # sub existing value to zero
        del c['c']          # remove an entry
        del c['c']          # make sure that del doesn't raise KeyError
        c['d'] -= 2         # sub from a missing value
        c['e'] = -5         # directly assign a missing value
        c['f'] += 4         # add to a missing value
        self.assertEqual(c, dict(a=4, b=0, d=-2, e=-5, f=4))
        self.assertEqual(''.join(sorted(c.elements())), 'aaaaffff')
        self.assertEqual(c.pop('f'), 4)
        self.assertNotIn('f', c)
        for i in range(3):
            elem, cnt = c.popitem()
            self.assertNotIn(elem, c)
        c.clear()
        self.assertEqual(c, {})
        self.assertEqual(repr(c), 'Counter()')
        self.assertRaises(NotImplementedError, Counter.fromkeys, 'abc')
        self.assertRaises(TypeError, hash, c)
        c.update(dict(a=5, b=3))
        c.update(c=1)
        c.update(Counter('a' * 50 + 'b' * 30))
        c.update()          # test case with no args
        c.__init__('a' * 500 + 'b' * 300)
        c.__init__('cdc')
        c.__init__()
        self.assertEqual(c, dict(a=555, b=333, c=3, d=1))
        self.assertEqual(c.setdefault('d', 5), 1)
        self.assertEqual(c['d'], 1)
        self.assertEqual(c.setdefault('e', 5), 5)
        self.assertEqual(c['e'], 5)

    def test_copying(self):
        # Check that counters are copyable, deepcopyable, picklable, and
        #have a repr/eval round-trip
        words = Counter('which witch had which witches wrist watch'.split())
        update_test = Counter()
        update_test.update(words)
        for i, dup in enumerate([
                    words.copy(),
                    copy.copy(words),
                    copy.deepcopy(words),
                    pickle.loads(pickle.dumps(words, 0)),
                    pickle.loads(pickle.dumps(words, 1)),
                    pickle.loads(pickle.dumps(words, 2)),
                    pickle.loads(pickle.dumps(words, -1)),
                    cPickle.loads(cPickle.dumps(words, 0)),
                    cPickle.loads(cPickle.dumps(words, 1)),
                    cPickle.loads(cPickle.dumps(words, 2)),
                    cPickle.loads(cPickle.dumps(words, -1)),
                    eval(repr(words)),
                    update_test,
                    Counter(words),
                    ]):
            msg = (i, dup, words)
            self.assertTrue(dup is not words)
            self.assertEqual(dup, words)
            self.assertEqual(len(dup), len(words))
            self.assertEqual(type(dup), type(words))

    def test_conversions(self):
        # Convert to: set, list, dict
        s = 'she sells sea shells by the sea shore'
        self.assertEqual(sorted(Counter(s).elements()), sorted(s))
        self.assertEqual(sorted(Counter(s)), sorted(set(s)))
        self.assertEqual(dict(Counter(s)), dict(Counter(s).items()))
        self.assertEqual(set(Counter(s)), set(s))

    def test_invariant_for_the_in_operator(self):
        c = Counter(a=10, b=-2, c=0)
        for elem in c:
            self.assertTrue(elem in c)
            self.assertIn(elem, c)

    def test_multiset_operations(self):
        # Verify that adding a zero counter will strip zeros and negatives
        c = Counter(a=10, b=-2, c=0) + Counter()
        self.assertEqual(dict(c), dict(a=10))

        elements = 'abcd'
        for i in range(1000):
            # test random pairs of multisets
            p = Counter(dict((elem, randrange(-2,4)) for elem in elements))
            p.update(e=1, f=-1, g=0)
            q = Counter(dict((elem, randrange(-2,4)) for elem in elements))
            q.update(h=1, i=-1, j=0)
            for counterop, numberop in [
                (Counter.__add__, lambda x, y: max(0, x+y)),
                (Counter.__sub__, lambda x, y: max(0, x-y)),
                (Counter.__or__, lambda x, y: max(0,x,y)),
                (Counter.__and__, lambda x, y: max(0, min(x,y))),
            ]:
                result = counterop(p, q)
                for x in elements:
                    self.assertEqual(numberop(p[x], q[x]), result[x],
                                     (counterop, x, p, q))
                # verify that results exclude non-positive counts
                self.assertTrue(x>0 for x in result.values())

        elements = 'abcdef'
        for i in range(100):
            # verify that random multisets with no repeats are exactly like
            # sets
            p = Counter(dict((elem, randrange(0, 2)) for elem in elements))
            q = Counter(dict((elem, randrange(0, 2)) for elem in elements))
            for counterop, setop in [
                (Counter.__sub__, set.__sub__),
                (Counter.__or__, set.__or__),
                (Counter.__and__, set.__and__),
            ]:
                counter_result = counterop(p, q)
                set_result = setop(set(p.elements()), set(q.elements()))
                self.assertEqual(counter_result, dict.fromkeys(set_result, 1))

    def test_subtract(self):
        c = Counter(a=-5, b=0, c=5, d=10, e=15,g=40)
        c.subtract(a=1, b=2, c=-3, d=10, e=20, f=30, h=-50)
        self.assertEqual(
            c,
            Counter(a=-6, b=-2, c=8, d=0, e=-5, f=-30, g=40, h=50)
        )
        c = Counter(a=-5, b=0, c=5, d=10, e=15,g=40)
        c.subtract(Counter(a=1, b=2, c=-3, d=10, e=20, f=30, h=-50))
        self.assertEqual(
            c,
            Counter(a=-6, b=-2, c=8, d=0, e=-5, f=-30, g=40, h=50)
        )
        c = Counter('aaabbcd')
        c.subtract('aaaabbcce')
        self.assertEqual(c, Counter(a=-1, b=0, c=-1, d=1, e=-1))
########NEW FILE########
__FILENAME__ = test
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Testing module for `nifty_collections.ordered_dict.OrderedDict`.'''

from __future__ import with_statement

from garlicsim.general_misc import cute_testing

from garlicsim.general_misc.nifty_collections.ordered_dict import OrderedDict


def test_sort():
    '''Test the `OrderedDict.sort` method.'''
    ordered_dict = OrderedDict(((1, 'a'), (2, 'b'), (3, 'c')))
    ordered_dict_copy = ordered_dict.copy()
    assert ordered_dict == ordered_dict_copy
    ordered_dict.sort()
    assert ordered_dict == ordered_dict_copy
        
    ordered_dict_copy.sort(key=(lambda x: -x))
    assert ordered_dict != ordered_dict_copy
    assert ordered_dict == dict(ordered_dict) == ordered_dict_copy
    
    ordered_dict[4] = ordered_dict_copy[4] = 'd'
    assert ordered_dict != ordered_dict_copy
    assert ordered_dict == dict(ordered_dict) == ordered_dict_copy
    
    ordered_dict_copy.sort(key=ordered_dict_copy.__getitem__)
    assert ordered_dict == ordered_dict_copy
    
    ordered_dict_copy.sort(key=(lambda x: -x))
    assert ordered_dict != ordered_dict_copy
    assert ordered_dict == dict(ordered_dict) == ordered_dict_copy
    
    ordered_dict.sort(key=(lambda x: -x))
    assert ordered_dict == ordered_dict_copy
    
    
def test_index():
    '''Test the `OrderedDict.index` method.'''
    ordered_dict = OrderedDict(((1, 'a'), (2, 'b'), (3, 'c')))
    assert ordered_dict.index(1) == 0
    assert ordered_dict.index(3) == 2
    assert ordered_dict.index(2) == 1
    
    ordered_dict[2] = 'b'
    
    assert ordered_dict.index(1) == 0
    assert ordered_dict.index(3) == 2
    assert ordered_dict.index(2) == 1
    
    ordered_dict['meow'] = 'frr'
    
    assert ordered_dict.index('meow') == 3
    
    with cute_testing.RaiseAssertor(KeyError):
        ordered_dict.index('Non-existing key')
########NEW FILE########
__FILENAME__ = test
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Testing module for `WeakKeyIdentityDict`.'''

import nose

from garlicsim.general_misc.nifty_collections import WeakKeyIdentityDict


class WeakreffableList(list):
    '''A `list` subclass which can be weakreffed.'''


def test():
    '''Test the basic workings of `WeakKeyIdentityDict`.'''
    wki_dict = WeakKeyIdentityDict()
    my_weakreffable_list = WeakreffableList([1, 2])
    wki_dict[my_weakreffable_list] = 7
    assert my_weakreffable_list in wki_dict
    assert wki_dict[my_weakreffable_list] == 7
    identical_weakreffable_list = WeakreffableList([1, 2])
    assert identical_weakreffable_list not in wki_dict
    nose.tools.assert_raises(KeyError,
                             lambda: wki_dict[identical_weakreffable_list])
    
    my_weakreffable_list.append(3)
    assert my_weakreffable_list in wki_dict
    assert wki_dict[my_weakreffable_list] == 7
    
    del wki_dict[my_weakreffable_list]
    assert my_weakreffable_list not in wki_dict
    nose.tools.assert_raises(KeyError,
                             lambda: wki_dict[my_weakreffable_list])
########NEW FILE########
__FILENAME__ = test_generic
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Run generic weakref tests on `WeakKeyIdentityDict`.'''

import gc
import sys
import unittest
import UserList
import weakref
import operator

from test_garlicsim.third_party import forked_mapping_tests

from garlicsim.general_misc.nifty_collections import WeakKeyIdentityDict

# Used in ReferencesTestCase.test_ref_created_during_del() .
ref_from_del = None

class C:
    def method(self):
        pass


class Callable:
    bar = None

    def __call__(self, x):
        self.bar = x


def create_function():
    def f(): pass
    return f

def create_bound_method():
    return C().method

def create_unbound_method():
    return C.method


class TestBase(unittest.TestCase):

    def setUp(self):
        self.cbcalled = 0

    def callback(self, ref):
        self.cbcalled += 1



class Object:
    def __init__(self, arg):
        self.arg = arg
    def __repr__(self):
        return "<Object %r>" % self.arg


class MappingTestCase(TestBase):

    COUNT = 10

    def test_make_weak_keyed_dict_from_dict(self):
        o = Object(3)
        dict = WeakKeyIdentityDict({o:364})
        self.assertTrue(dict[o] == 364)

        
    def test_make_weak_keyed_dict_from_weak_keyed_dict(self):
        o = Object(3)
        dict1 = WeakKeyIdentityDict({o:364})
        dict2 = WeakKeyIdentityDict(dict1)
        self.assertTrue(dict1[o] == 364)

        
    def make_weak_keyed_dict(self):
        dict_ = WeakKeyIdentityDict()
        objects = map(Object, range(self.COUNT))
        for o in objects:
            dict_[o] = o.arg
        return dict_, objects


    def test_weak_keyed_dict_popitem(self):
        key1, value1, key2, value2 = C(), "value 1", C(), "value 2"
        weakdict = WeakKeyIdentityDict()
        weakdict[key1] = value1
        weakdict[key2] = value2
        self.assertTrue(len(weakdict) == 2)
        k, v = weakdict.popitem()
        self.assertTrue(len(weakdict) == 1)
        if k is key1:
            self.assertTrue(v is value1)
        else:
            self.assertTrue(v is value2)
        k, v = weakdict.popitem()
        self.assertTrue(len(weakdict) == 0)
        if k is key1:
            self.assertTrue(v is value1)
        else:
            self.assertTrue(v is value2)

        
    def test_weak_keyed_dict_setdefault(self):
        key, value1, value2 = C(), "value 1", "value 2"
        self.assertTrue(value1 is not value2,
                        "invalid test"
                        " -- value parameters must be distinct objects")
        weakdict = WeakKeyIdentityDict()
        o = weakdict.setdefault(key, value1)
        assert o is value1
        assert key in weakdict
        assert weakdict.get(key) is value1
        assert weakdict[key] is value1

        o = weakdict.setdefault(key, value2)
        assert o is value1
        assert key in weakdict
        assert weakdict.get(key) is value1
        assert weakdict[key] is value1

        
    def test_update(self):
        #
        #  This exercises d.update(), len(d), d.keys(), in d,
        #  d.get(), d[].
        #
        dict_ = {C(): 1, C(): 2, C(): 3}
        weakdict = WeakKeyIdentityDict()
        weakdict.update(dict_)
        self.assertEqual(len(weakdict), len(dict_))
        for k in weakdict.keys():
            assert k in dict_
            v = dict_.get(k)
            assert v is weakdict[k]
            assert v is weakdict.get(k)
        for k in dict_.keys():
            assert k in weakdict
            v = dict_[k]
            assert v is weakdict[k]
            assert v is weakdict.get(k)
            
        
    def test_weak_keyed_delitem(self):
        d = WeakKeyIdentityDict()
        o1 = Object('1')
        o2 = Object('2')
        d[o1] = 'something'
        d[o2] = 'something'
        self.assertTrue(len(d) == 2)
        del d[o1]
        self.assertTrue(len(d) == 1)
        self.assertTrue(d.keys() == [o2])


    def test_weak_keyed_bad_delitem(self):
        d = WeakKeyIdentityDict()
        o = Object('1')
        # An attempt to delete an object that isn't there should raise
        # KeyError.  It didn't before 2.3.
        self.assertRaises(KeyError, d.__delitem__, o)
        self.assertRaises(KeyError, d.__getitem__, o)

        # If a key isn't of a weakly referencable type, __getitem__ and
        # __setitem__ raise TypeError.  __delitem__ should too.
        self.assertRaises(TypeError, d.__delitem__,  13)
        self.assertRaises(TypeError, d.__getitem__,  13)
        self.assertRaises(TypeError, d.__setitem__,  13, 13)

        
    def test_weak_keyed_cascading_deletes(self):
        # SF bug 742860.  For some reason, before 2.3 __delitem__ iterated
        # over the keys via self.data.iterkeys().  If things vanished from
        # the dict during this (or got added), that caused a RuntimeError.

        d = WeakKeyIdentityDict()
        mutate = False

        class C(object):
            def __init__(self, i):
                self.value = i
            def __hash__(self):
                return hash(self.value)
            def __eq__(self, other):
                if mutate:
                    # Side effect that mutates the dict, by removing the
                    # last strong reference to a key.
                    del objs[-1]
                return self.value == other.value

        objs = [C(i) for i in range(4)]
        for o in objs:
            d[o] = o.value
        del o   # now the only strong references to keys are in objs
        # Find the order in which iterkeys sees the keys.
        objs = d.keys()
        # Reverse it, so that the iteration implementation of __delitem__
        # has to keep looping to find the first object we delete.
        objs.reverse()

        # Turn on mutation in C.__eq__.  The first time thru the loop,
        # under the iterkeys() business the first comparison will delete
        # the last item iterkeys() would see, and that causes a
        #     RuntimeError: dictionary changed size during iteration
        # when the iterkeys() loop goes around to try comparing the next
        # key.  After this was fixed, it just deletes the last object *our*
        # "for o in obj" loop would have gotten to.
        mutate = True
        count = 0
        for o in objs:
            count += 1
            del d[o]
        self.assertEqual(len(d), 0)
        self.assertEqual(count, 2)

        
class WeakKeyIdentityDictTestCase(
    forked_mapping_tests.BasicTestMappingProtocol
    ):
    """Check that WeakKeyDictionary conforms to the mapping protocol"""
    __ref = {Object("key1"):1, Object("key2"):2, Object("key3"):3}
    type2test = WeakKeyIdentityDict
    def _reference(self):
        return self.__ref.copy()


########NEW FILE########
__FILENAME__ = test_cross_process_persistent
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Testing module for `garlicsim.general_misc.persistent.CrossProcessPersistent`.
'''

from __future__ import with_statement

import copy
import pickle
import cPickle
from garlicsim.general_misc.third_party import abc

import nose

from garlicsim.general_misc import cute_iter_tools
from garlicsim.general_misc import cute_testing
from garlicsim.general_misc import import_tools
from garlicsim.general_misc import queue_tools

from garlicsim.general_misc import persistent
from garlicsim.general_misc.persistent import CrossProcessPersistent


class AbstractCrossProcessPersistent(CrossProcessPersistent):
    '''
    An abstract cross-process persistent.
    
    This is needed to test CPP's interaction with `__abstractmethods__`.
    '''
    __metaclass__ = abc.ABCMeta
    
    @abc.abstractmethod
    def f(self):
        pass
    
class A(AbstractCrossProcessPersistent):
    def f(self):
        pass
    



def test():
    '''Test the basic workings of `CrossProcessPersistent`.'''
    checkers = [_check_deepcopying, _check_process_passing]
    cross_process_persistent_classes = [A, CrossProcessPersistent]
    
    iterator = cute_iter_tools.product(
        checkers,
        cross_process_persistent_classes,
    )
    
    for checker, cross_process_persistent_class in iterator:
        yield checker, cross_process_persistent_class
    
        
def _check_deepcopying(cross_process_persistent_class):
    '''Test that CPPs maintain their identities when faux-deepcopied.'''
    cross_process_persistent = cross_process_persistent_class()
    cross_process_persistent_deepcopy = copy.deepcopy(cross_process_persistent)
    assert cross_process_persistent_deepcopy is not cross_process_persistent
    
    cross_process_persistent_faux_deepcopy = copy.deepcopy(
        cross_process_persistent,
        persistent.DontCopyPersistent()
    )
    assert cross_process_persistent_faux_deepcopy is cross_process_persistent
    
if import_tools.exists('multiprocessing'):
    
    import multiprocessing
    
    class Process(multiprocessing.Process):
        '''Process used when testing to assert CPPs' identities.'''
        
        def __init__(self):
            multiprocessing.Process.__init__(self)
            
            self.work_queue = multiprocessing.Queue()
            '''Queue for receiving `(index, cpp)` pairs from main process.'''
            
            self.processed_items_queue = multiprocessing.Queue()
            '''Queue for giving back the main process the items it gives us.'''
            
            self.message_queue = multiprocessing.Queue()
            '''Queue for reporting to the main process about actions we do.'''
            
            self.library = {}
            '''Dict mapping from ints to CPPs.'''
            
        def run(self):
            for number, item in queue_tools.iterate(self.work_queue, block=True):
                if number in self.library:
                    assert self.library[number] is item
                    other_items = [value for (key, value) in self.library.items()
                                   if key != number]
                    for other_item in other_items:
                        assert other_item is not item
                    self.processed_items_queue.put(item)
                    self.message_queue.put('Asserted identity.')
                else: # number not in self.library
                    self.library[number] = item
                    self.processed_items_queue.put(item)
                    self.message_queue.put('Stored object.')
        
    
def _check_process_passing(cross_process_persistent_class):
    '''
    Test that CPPs maintain their identities when passed between processes.
    '''
    if not import_tools.exists('multiprocessing'):
        raise nose.SkipTest('`multiprocessing` is not installed.')
    
    cpp_1 = cross_process_persistent_class()
    cpp_2 = cross_process_persistent_class()
    cpp_3 = cross_process_persistent_class()
    
    process = Process()
    process.start()
    
    process.work_queue.put((1, cpp_1))
    assert process.message_queue.get(timeout=10) == 'Stored object.'
    assert process.processed_items_queue.get(timeout=10) is cpp_1
    
    process.work_queue.put((1, cpp_1))
    assert process.message_queue.get(timeout=10) == 'Asserted identity.'
    assert process.processed_items_queue.get(timeout=10) is cpp_1
    
    process.work_queue.put((2, cpp_2))
    assert process.message_queue.get(timeout=10) == 'Stored object.'
    assert process.processed_items_queue.get(timeout=10) is cpp_2
    
    process.work_queue.put((1, cpp_1))
    assert process.message_queue.get(timeout=10) == 'Asserted identity.'
    assert process.processed_items_queue.get(timeout=10) is cpp_1
    
    process.work_queue.put((2, cpp_2))
    assert process.message_queue.get(timeout=10) == 'Asserted identity.'
    assert process.processed_items_queue.get(timeout=10) is cpp_2
    
    process.work_queue.put((3, cpp_3))
    assert process.message_queue.get(timeout=10) == 'Stored object.'
    assert process.processed_items_queue.get(timeout=10) is cpp_3
    
    process.work_queue.put((3, cpp_3))
    assert process.message_queue.get(timeout=10) == 'Asserted identity.'
    assert process.processed_items_queue.get(timeout=10) is cpp_3
    
    process.work_queue.put((1, cpp_1))
    assert process.message_queue.get(timeout=10) == 'Asserted identity.'
    assert process.processed_items_queue.get(timeout=10) is cpp_1
    
    process.terminate()


def test_personality():
    '''Test that a `CrossProcessPersistent` has a `.personality`.'''
    a = A()
    cross_process_persistent = CrossProcessPersistent()
    assert isinstance(a.personality,
                      persistent.Personality)
    assert isinstance(cross_process_persistent.personality,
                      persistent.Personality)
    
    
def test_helpful_warnings_for_old_protocols():
    '''
    Test that helpful errors are given when trying to pickle with old protocol.
    '''
    pickle_modules = [pickle, cPickle]
    cross_process_persistents = [A(), CrossProcessPersistent()]
    old_protocols = [0, 1]
    
    iterator = cute_iter_tools.product(
        pickle_modules,
        cross_process_persistents,
        old_protocols
    )
    
    for pickle_module, cross_process_persistent, old_protocol in iterator:
        yield (_check_helpful_warnings_for_old_protocols, 
               pickle_module,
               cross_process_persistent,
               old_protocol)
            
    
def _check_helpful_warnings_for_old_protocols(pickle_module,
                                              cross_process_persistent,
                                              old_protocol):
    '''
    Test that helpful errors are given when trying to pickle with old protocol.
    '''
    assert old_protocol < 2
    with cute_testing.RaiseAssertor(text=('protocol %s' % old_protocol)):
        pickle_module.dumps(cross_process_persistent,
                            protocol=old_protocol)
########NEW FILE########
__FILENAME__ = test_personality
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Testing module for `garlicsim.general_misc.persistent.personality.Personality`.
'''

import colorsys

from garlicsim.general_misc.persistent import CrossProcessPersistent


def test():
    '''Test the basic workings of `Personality`.'''
    cpp_1 = CrossProcessPersistent()
    cpp_2 = CrossProcessPersistent()
    cpp_3 = CrossProcessPersistent()
    
    personality_1 = cpp_1.personality
    personality_2 = cpp_2.personality
    personality_3 = cpp_3.personality
    
    human_name_1 = personality_1.human_name
    human_name_2 = personality_2.human_name
    human_name_3 = personality_3.human_name
    
    assert isinstance(human_name_1, basestring)
    assert isinstance(human_name_2, basestring)
    assert isinstance(human_name_3, basestring)
    
    light_color_1 = personality_1.light_color
    light_color_2 = personality_2.light_color
    light_color_3 = personality_3.light_color
    dark_color_1 = personality_1.dark_color
    dark_color_2 = personality_2.dark_color
    dark_color_3 = personality_3.dark_color
    
    for light_color in (light_color_1, light_color_2, light_color_3):
        hls_value = colorsys.rgb_to_hls(*light_color)
        lightness = hls_value[1]
        assert 0.85 < lightness < 0.95
        
    for dark_color in (dark_color_1, dark_color_2, dark_color_3):
        hls_value = colorsys.rgb_to_hls(*dark_color)
        lightness = hls_value[1]
        assert 0.25 < lightness < 0.35
    
    assert (human_name_1, light_color_1, dark_color_1) != \
           (human_name_2, light_color_2, dark_color_2) != \
           (human_name_3, light_color_3, dark_color_3) != \
           (human_name_1, light_color_1, dark_color_1)
    
    
########NEW FILE########
__FILENAME__ = shared
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Defines tools for testing `garlicsim.general_misc.pickle_tools`'''


class PickleableObject(object):
    _is_atomically_pickleable = True
    

class NonPickleableObject(object):
    _is_atomically_pickleable = False
    
########NEW FILE########
__FILENAME__ = test_cute_pickling
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Testing module for `CutePickler` and `CuteUnpickler`.'''

import threading
from cStringIO import StringIO 
import tempfile

# We're importing `pickle_module` from `pickle_tools`, so we get the exact same
# pickle module it's using. (Giving it the freedom to change between `cPickle`
# and `pickle`.)
from garlicsim.general_misc.pickle_tools import pickle_module

import nose

from garlicsim.general_misc import import_tools

from garlicsim.general_misc import pickle_tools
from garlicsim.general_misc.pickle_tools import CutePickler, CuteUnpickler

from .shared import PickleableObject, NonPickleableObject

    
class Object(object):
    pass


def test_totally_pickleable():
    '''Test cute-(un)pickling on totally pickleable objects.'''
    
    totally_pickleable_things = [
        [1, 2, (3, 4)],
        {1: 2, 3: set((1, 2, 3))},
        None, True, False,
        (1, 2, 'meow'),
        u'qweqweqasd',
    ]
    
    for thing in totally_pickleable_things:
        stream = StringIO() 
        pickler = CutePickler(stream)
        pickler.dump(thing) 
 
        stream.seek(0) 
        unpickler = CuteUnpickler(stream) 
        unpickled_thing = unpickler.load() 
        assert unpickled_thing == thing
        

        
def test_without_multiprocessing():
    '''
    Test cute-(un)pickling on various objects, not incl. `multiprocessing`.
    '''
    totally_pickleable_things = [
        [1, 2, (3, 4)],
        {1: 2, 3: set((1, 2, 3))},
        None, True, False,
        (1, 2, 'meow'),
        u'qweqweqasd',
        PickleableObject()
    ]
    
    thing = Object()
    thing.a, thing.b, thing.c, thing.d, thing.e, thing.f, thing.g, thing.h = \
         totally_pickleable_things
    
    thing.x = threading.Lock()
    thing.z = NonPickleableObject()
    
    stream = StringIO() 
    pickler = CutePickler(stream)
    pickler.dump(thing) 

    stream.seek(0) 
    unpickler = CuteUnpickler(stream) 
    unpickled_thing = unpickler.load() 
    
    assert thing.a == unpickled_thing.a
    assert thing.b == unpickled_thing.b
    assert thing.c == unpickled_thing.c
    assert thing.d == unpickled_thing.d
    assert thing.e == unpickled_thing.e
    assert thing.f == unpickled_thing.f
    assert thing.g == unpickled_thing.g
    # Regarding `.h`, we just check the type cause there's no `__eq__`:
    assert type(thing.h) == type(unpickled_thing.h)
    
    assert thing.x != unpickled_thing.x
    assert thing.z != unpickled_thing.z
    
    assert isinstance(unpickled_thing.x, pickle_tools.FilteredObject)
    assert isinstance(unpickled_thing.z, pickle_tools.FilteredObject)
    
    
def test():
    '''Test cute-(un)pickling on various objects.'''
    if not import_tools.exists('multiprocessing'):
        raise nose.SkipTest('`multiprocessing` is not installed.')
    
    import multiprocessing
    
    totally_pickleable_things = [
        [1, 2, (3, 4)],
        {1: 2, 3: set((1, 2, 3))},
        None, True, False,
        (1, 2, 'meow'),
        u'qweqweqasd',
        PickleableObject()
    ]
    
    thing = Object()
    thing.a, thing.b, thing.c, thing.d, thing.e, thing.f, thing.g, thing.h = \
         totally_pickleable_things
    
    thing.x = threading.Lock()
    thing.y = multiprocessing.Lock()
    thing.z = NonPickleableObject()
    
    stream = StringIO() 
    pickler = CutePickler(stream)
    pickler.dump(thing) 

    stream.seek(0) 
    unpickler = CuteUnpickler(stream) 
    unpickled_thing = unpickler.load() 
    
    assert thing.a == unpickled_thing.a
    assert thing.b == unpickled_thing.b
    assert thing.c == unpickled_thing.c
    assert thing.d == unpickled_thing.d
    assert thing.e == unpickled_thing.e
    assert thing.f == unpickled_thing.f
    assert thing.g == unpickled_thing.g
    # Regarding `.h`, we just check the type cause there's no `__eq__`:
    assert type(thing.h) == type(unpickled_thing.h)
    
    assert thing.x != unpickled_thing.x
    assert thing.y != unpickled_thing.y
    assert thing.z != unpickled_thing.z
    
    assert isinstance(unpickled_thing.x, pickle_tools.FilteredObject)
    assert isinstance(unpickled_thing.y, pickle_tools.FilteredObject)
    assert isinstance(unpickled_thing.z, pickle_tools.FilteredObject)
    
    
    
    
    
########NEW FILE########
__FILENAME__ = test_is_atomically_pickleable
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Testing module for `is_atomically_pickleable`.'''

from __future__ import with_statement

import threading
import StringIO
import cStringIO

# We're importing `pickle_module` from `pickle_tools`, so we get the exact same
# pickle module it's using. (Giving it the freedom to change between `cPickle`
# and `pickle`.)
from garlicsim.general_misc.pickle_tools import pickle_module

import nose

from garlicsim.general_misc import import_tools

from garlicsim.general_misc import pickle_tools

from .shared import PickleableObject, NonPickleableObject


def is_pickle_successful(thing):
    '''`try` to pickle `thing` and return whether it worked.'''
    try:
        string = pickle_module.dumps(thing)
        unpickled_thing = pickle_module.loads(string)
    except Exception:
        return False
    else:
        return True

    
def test_simple_atomically_pickleables():
    '''Test `is_atomically_pickleable` on atomically pickleable objects.'''
    pickleables = [
        None, True, False,
        1, 1.1, -3, 3+4.5j,
        'roar', u'Meow!',
        {1: 3, 'frr': 'meow'},
        ['one', 'two', (3, 4)],
        set([1, 2, 3, 1]),
        frozenset((1, 2, 3, 1, 'meow', frozenset())),
        StringIO.StringIO(),
        sum, slice, type
    ]
    
    atomically_pickleables = [
        set([threading.Lock()]),
        [threading.Lock()],
    ]
    
    for thing in pickleables:
        assert pickle_tools.is_atomically_pickleable(thing)
        assert is_pickle_successful(thing)
        
    for thing in atomically_pickleables:
        assert pickle_tools.is_atomically_pickleable(thing)
        
        
        
def test_non_atomically_pickleables_multiprocessing():
    '''
    Test `is_atomically_pickleable` on non-atomically pickleable objects.
    
    Not including `multiprocessing` objects.
    '''
    
    if not import_tools.exists('multiprocessing'):
        raise nose.SkipTest('`multiprocessing` is not installed.')
    
    import multiprocessing

    non_pickleables = [
        multiprocessing.Lock(),
        multiprocessing.BoundedSemaphore(),
        multiprocessing.Condition(),
        multiprocessing.JoinableQueue(),
        multiprocessing.Pool(),
        multiprocessing.Queue(),
        multiprocessing.RLock(),
        multiprocessing.Semaphore(),
    ]
        
    for thing in non_pickleables:
        assert not pickle_tools.is_atomically_pickleable(thing)
        assert not is_pickle_successful(thing)
    
    assert not pickle_tools.is_atomically_pickleable(NonPickleableObject())
    # Not trying to actually pickle this test object, cause it will actually
    # work.

    
def test_partially_pickleables_multiprocessing():
    '''
    "Partially-pickleable" means an object which is atomically pickleable but
    not pickleable.
    '''

    if not import_tools.exists('multiprocessing'):
        raise nose.SkipTest('`multiprocessing` is not installed.')
    
    import multiprocessing
    
    x = PickleableObject()
    x.lock = threading.Lock()
    
    partially_pickleables = [
        x,
        [multiprocessing.BoundedSemaphore()],
        {1: multiprocessing.Lock(), 2: 3},
        set([multiprocessing.Queue(), x])
    ]
    
    for thing in partially_pickleables:
        assert pickle_tools.is_atomically_pickleable(thing)
        assert not is_pickle_successful(thing)
        
        
def test_non_atomically_pickleables():
    '''Test `is_atomically_pickleable` on non-atomically pickleable objects.'''

    non_pickleables = [
        threading.Lock(),
        cStringIO.StringIO()
    ]
        
    for thing in non_pickleables:
        assert not pickle_tools.is_atomically_pickleable(thing)
        assert not is_pickle_successful(thing)
    
    assert not pickle_tools.is_atomically_pickleable(NonPickleableObject())
    # Not trying to actually pickle this test object, cause it will actually
    # work.

    
def test_partially_pickleables():
    '''
    Test `is_atomically_pickleable` on partially pickleable objects.
    
    "Partially-pickleable" means an object which is atomically pickleable but
    not pickleable.
    '''
    
    x = PickleableObject()
    x.lock = threading.Lock()
    
    partially_pickleables = [
        x,
        [threading.Lock()],
        {1: threading.Lock(), 2: 3},
        set([threading.Lock(), x])
    ]
    
    for thing in partially_pickleables:
        assert pickle_tools.is_atomically_pickleable(thing)
        assert not is_pickle_successful(thing)

### Testing old-style classes: ################################################
#                                                                             #
        
class A: # Ooh, look at me! I'm not inheriting from `object`!
    pass

class AtomicallyNonpickleable:
    _is_atomically_pickleable = False
    
class AtomicallyPickleable:
    _is_atomically_pickleable = True
        
        
        
def test_old_style_classes():
    '''Test `is_atomically_pickleable` on old style classes objects.'''
    
    # I hate old-style classes. I hope they'll die soon.
    
    assert pickle_tools.is_atomically_pickleable(A()) is True
    assert pickle_tools.is_atomically_pickleable(
        AtomicallyNonpickleable()
        ) is False
    assert pickle_tools.is_atomically_pickleable(
        AtomicallyPickleable()
        ) is True
    
    # The classes themselves are all pickleable:
    assert pickle_tools.is_atomically_pickleable(A) is True
    assert pickle_tools.is_atomically_pickleable(
        AtomicallyNonpickleable
        ) is True
    assert pickle_tools.is_atomically_pickleable(
        AtomicallyPickleable
        ) is True
    
    
#                                                                             #
### Finished testing old-style classes. #######################################

########NEW FILE########
__FILENAME__ = test_using_c_pickle
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Test that `cute_pickle` uses `cPickle` and not `pickle`.'''


from garlicsim.general_misc import pickle_tools

def test():
    '''Test that `cute_pickle` uses `cPickle` and not `pickle`.'''
    import cPickle
    assert pickle_tools.pickle_module is cPickle
########NEW FILE########
__FILENAME__ = test_reasoned_bool
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Testing module for `garlicsim.general_misc.reasoned_bool.ReasonedBool`.'''

from garlicsim.general_misc.reasoned_bool import ReasonedBool

def test():
    '''Test the basic workings of `ReasonedBool`.'''
    assert True == ReasonedBool(True)
    assert True == ReasonedBool(True, "Because I feel like it")
    assert ReasonedBool(True)
    assert ReasonedBool(True, "Because I feel like it")
    assert bool(ReasonedBool(True)) is True
    assert bool(ReasonedBool(True, "Because I feel like it")) is True
    
    assert False == ReasonedBool(False)
    assert False == ReasonedBool(False, "Because I don't feel like it")
    assert not ReasonedBool(False)
    assert not ReasonedBool(False, "Because I don't feel like it")
    assert bool(ReasonedBool(False)) is False
    assert bool(ReasonedBool(False, "Because I don't feel like it")) is False
    
    
    assert ReasonedBool(True, "Meow") == ReasonedBool(True, "Woof")
    
    assert ReasonedBool(False, "Meow") == ReasonedBool(False, "Woof")
    
########NEW FILE########
__FILENAME__ = test_re_tools
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Testing module for `garlicsim.general_misc.re_tools`.
'''

import re

from garlicsim.general_misc import re_tools
from garlicsim.general_misc.re_tools import searchall


def test_searchall():
    '''Test the basic workings of `searchall`.'''
    s = 'asdf df sfg s'
    result = searchall('(\w+)', s)
    assert len(result) == 4
########NEW FILE########
__FILENAME__ = test_combinations
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Testing module for `garlicsim.general_misc.sequence_tools.combinations`.'''

import nose.tools

from garlicsim.general_misc.sequence_tools import combinations
from garlicsim.general_misc import sequence_tools


def test():
    '''Test basic workings of `combinations`.'''
    my_range = [0, 1, 2, 3, 4]
    
    
    assert list(combinations(xrange(4), n=2)) == [
        [0, 1], [0, 2], [0, 3], [1, 2], [1, 3], [2, 3]
    ]
    
    assert list(combinations(xrange(4), 3)) == [
        [0, 1, 2], [0, 1, 3], [0, 2, 3], [1, 2, 3]
    ]
    
    assert tuple(combinations('meowfrr', 5)) == (
        ['m', 'e', 'o', 'w', 'f'], ['m', 'e', 'o', 'w', 'r'],
        ['m', 'e', 'o', 'w', 'r'], ['m', 'e', 'o', 'f', 'r'],
        ['m', 'e', 'o', 'f', 'r'], ['m', 'e', 'o', 'r', 'r'],
        ['m', 'e', 'w', 'f', 'r'], ['m', 'e', 'w', 'f', 'r'],
        ['m', 'e', 'w', 'r', 'r'], ['m', 'e', 'f', 'r', 'r'],
        ['m', 'o', 'w', 'f', 'r'], ['m', 'o', 'w', 'f', 'r'],
        ['m', 'o', 'w', 'r', 'r'], ['m', 'o', 'f', 'r', 'r'],
        ['m', 'w', 'f', 'r', 'r'], ['e', 'o', 'w', 'f', 'r'],
        ['e', 'o', 'w', 'f', 'r'], ['e', 'o', 'w', 'r', 'r'],
        ['e', 'o', 'f', 'r', 'r'], ['e', 'w', 'f', 'r', 'r'],
        ['o', 'w', 'f', 'r', 'r']
    )
    
    assert list(combinations(xrange(5), n=2, start=2)) == \
           list(combinations(xrange(2, 5), n=2))
    
    
def test_all_sizes():
    '''Test using `n=None` so combinations of all sizes are returned.'''
    assert list(combinations(xrange(4))) == sequence_tools.flatten(
        list(combinations(xrange(4), i)) for i in xrange(1, 4+1)
    )
########NEW FILE########
__FILENAME__ = shared
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Tools for testing `garlicsim.general_misc.sleek_refs`.'''

import weakref

def _is_weakreffable(thing):
    '''Return whether a weakref can be created to `thing`.'''
    try:
        weakref.ref(thing)
    except TypeError:
        return False
    else:
        return True

    
class A(object):
    '''A class with a static method.'''
    @staticmethod
    def s():
        pass

    
def counter(*args, **kwargs):
    '''Function that returns a higher number every time it's called.'''
    if not hasattr(counter, 'count'):
        counter.count = 0
    result = counter.count
    counter.count += 1
    return result

########NEW FILE########
__FILENAME__ = tests
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Testing module for `garlicsim.general_misc.sleek_refs.CuteSleekValueDict`.
'''

import gc
import weakref

from garlicsim.general_misc import sequence_tools

from garlicsim.general_misc.sleek_refs import (SleekCallArgs,
                                               SleekRef,
                                               CuteSleekValueDict)

from ..shared import _is_weakreffable, A, counter
        
        
def test():
    '''Test the basic workings of `CuteSleekValueDict`.'''
    volatile_things = [A(), 1, 4.5, 'meow', u'woof', [1, 2], (1, 2), {1: 2},
                       set([1, 2, 3])]
    unvolatile_things = [A.s, __builtins__, list, type,  list.append, str.join,
                         sum]
    
    # Using len(csvd) as our key; just to guarantee we're not running over an
    # existing key.
        
    csvd = CuteSleekValueDict(counter)
    
    while volatile_things:
        volatile_thing = volatile_things.pop()
        if _is_weakreffable(volatile_thing):
            csvd[len(csvd)] = volatile_thing
            count = counter()
            del volatile_thing
            gc.collect()
            assert counter() == count + 2
        else:
            csvd[len(csvd)] = volatile_thing
            count = counter()
            del volatile_thing
            gc.collect()
            assert counter() == count + 1

            
    while unvolatile_things:
        unvolatile_thing = unvolatile_things.pop()
        csvd = CuteSleekValueDict(counter)
        
        csvd[len(csvd)] = unvolatile_thing
        count = counter()
        del unvolatile_thing
        gc.collect()
        assert counter() == count + 1
        
        
def test_one_by_one():
    volatile_things = [A(), 1, 4.5, 'meow', u'woof', [1, 2], (1, 2), {1: 2},
                       set([1, 2, 3])]
    unvolatile_things = [A.s, __builtins__, list, type,  list.append, str.join,
                         sum]
    
    # Using len(csvd) as our key; just to guarantee we're not running over an
    # existing key.
        
    while volatile_things:
        volatile_thing = volatile_things.pop()
        csvd = CuteSleekValueDict(counter)
        if _is_weakreffable(volatile_thing):
            csvd[len(csvd)] = volatile_thing
            count = counter()
            del volatile_thing
            gc.collect()
            assert counter() == count + 2
        else:
            csvd[len(csvd)] = volatile_thing
            count = counter()
            del volatile_thing
            gc.collect()
            assert counter() == count + 1
            
    while unvolatile_things:
        unvolatile_thing = unvolatile_things.pop()
        csvd = CuteSleekValueDict(counter)
        
        csvd[len(csvd)] = unvolatile_thing
        count = counter()
        del unvolatile_thing
        gc.collect()
        assert counter() == count + 1
        
        
def test_none():
    '''Test that `CuteSleekValueDict` can handle a value of `None`.'''

    d = {
        1: None,
        2: None,
        (1,): None,
        (1, (1,)): None,
        sum: None,
        None: None
    }
    
    csvd = CuteSleekValueDict(
        counter,
        d
    )
    

    assert sequence_tools.are_equal_regardless_of_order(csvd.keys(),
                                                        d.keys())
    
    assert sequence_tools.are_equal_regardless_of_order(csvd.values(),
                                                        d.values())
    
    assert sequence_tools.are_equal_regardless_of_order(csvd.items(),
                                                        d.items())
    

    for key in csvd.iterkeys():
        assert key in csvd
        assert csvd[key] is None
    
    
        

########NEW FILE########
__FILENAME__ = test_generic_dict_tests
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Run generic `dict` tests on `CuteSleekValueDict`.'''

from __future__ import with_statement

import sys
import UserDict
import random
import string
import gc
import weakref

import nose
from garlicsim.general_misc.third_party import unittest2

from garlicsim.general_misc.sleek_refs import CuteSleekValueDict


null_callback = lambda: None
null_callback()


class GenericDictTest(unittest2.TestCase):
    
    def test_constructor(self):
        # calling built-in types without argument must return empty
        self.assertEqual(
            CuteSleekValueDict(null_callback),
            CuteSleekValueDict(null_callback)
        )
        self.assertIsNot(
            CuteSleekValueDict(null_callback),
            CuteSleekValueDict(null_callback)
        )

        
    def test_bool(self):
        self.assertIs(
            not CuteSleekValueDict(null_callback),
            True
        )
        self.assertTrue(CuteSleekValueDict(null_callback, {1: 2}))
        self.assertIs(bool(CuteSleekValueDict(null_callback)), False)
        self.assertIs(
            bool(CuteSleekValueDict(null_callback, {1: 2})),
            True
        )

        
    def test_keys(self):
        d = CuteSleekValueDict(null_callback)
        self.assertEqual(d.keys(), [])
        d = CuteSleekValueDict(null_callback, {'a': 1, 'b': 2})
        k = d.keys()
        self.assertTrue(d.has_key('a'))
        self.assertTrue(d.has_key('b'))

        self.assertRaises(TypeError, d.keys, None)

        
    def test_values(self):
        d = CuteSleekValueDict(null_callback)
        self.assertEqual(d.values(), [])
        d = CuteSleekValueDict(null_callback, {1: 2})
        self.assertEqual(d.values(), [2])

        self.assertRaises(TypeError, d.values, None)

        
    def test_items(self):
        d = CuteSleekValueDict(null_callback)
        self.assertEqual(d.items(), [])

        d = CuteSleekValueDict(null_callback, {1: 2})
        self.assertEqual(d.items(), [(1, 2)])

        self.assertRaises(TypeError, d.items, None)

        
    def test_has_key(self):
        d = CuteSleekValueDict(null_callback)
        self.assertFalse(d.has_key('a'))
        d = CuteSleekValueDict(null_callback, {'a': 1, 'b': 2})
        k = d.keys()
        k.sort()
        self.assertEqual(k, ['a', 'b'])

        self.assertRaises(TypeError, d.has_key)

        
    def test_contains(self):
        d = CuteSleekValueDict(null_callback)
        self.assertNotIn('a', d)
        self.assertFalse('a' in d)
        self.assertTrue('a' not in d)
        d = CuteSleekValueDict(null_callback, {'a': 1, 'b': 2})
        self.assertIn('a', d)
        self.assertIn('b', d)
        self.assertNotIn('c', d)

        self.assertRaises(TypeError, d.__contains__)

        
    def test_len(self):
        d = CuteSleekValueDict(null_callback)
        self.assertEqual(len(d), 0)
        d = CuteSleekValueDict(null_callback, {'a': 1, 'b': 2})
        self.assertEqual(len(d), 2)

        
    def test_getitem(self):
        d = CuteSleekValueDict(null_callback, {'a': 1, 'b': 2})
        self.assertEqual(d['a'], 1)
        self.assertEqual(d['b'], 2)
        d['c'] = 3
        d['a'] = 4
        self.assertEqual(d['c'], 3)
        self.assertEqual(d['a'], 4)
        del d['b']
        self.assertEqual(
            d,
            CuteSleekValueDict(null_callback, {'a': 4, 'c': 3})
        )

        self.assertRaises(TypeError, d.__getitem__)

        class BadEq(object):
            def __eq__(self, other):
                raise Exc()
            def __hash__(self):
                return 24

        d = CuteSleekValueDict(null_callback)
        d[BadEq()] = 42
        self.assertRaises(KeyError, d.__getitem__, 23)

        class Exc(Exception): pass

        class BadHash(object):
            fail = False
            def __hash__(self):
                if self.fail:
                    raise Exc()
                else:
                    return 42

        x = BadHash()
        d[x] = 42
        x.fail = True
        self.assertRaises(Exc, d.__getitem__, x)

        
    def test_clear(self):
        d = CuteSleekValueDict(null_callback, {1: 1, 2: 2, 3: 3})
        d.clear()
        self.assertEqual(d, CuteSleekValueDict(null_callback))

        self.assertRaises(TypeError, d.clear, None)

        
    def test_update(self):
        d = CuteSleekValueDict(null_callback)
        d.update(CuteSleekValueDict(null_callback, {1: 100}))
        d.update({2: 20})
        d.update(CuteSleekValueDict(null_callback, {1: 1, 2: 2, 3: 3}))
        self.assertEqual(
            d,
            CuteSleekValueDict(null_callback, {1: 1, 2: 2, 3: 3})
        )

        d.update()
        self.assertEqual(
            d,
            CuteSleekValueDict(null_callback, {1: 1, 2: 2, 3: 3})
        )

        self.assertRaises((TypeError, AttributeError), d.update, None)

        class SimpleUserDict:
            def __init__(self):
                self.d = CuteSleekValueDict(
                    null_callback,
                    {1: 1, 2: 2, 3: 3}
                )
            def keys(self):
                return self.d.keys()
            def __getitem__(self, i):
                return self.d[i]
            
        d.clear()
        d.update(SimpleUserDict())
        self.assertEqual(
            d,
            CuteSleekValueDict(null_callback, {1: 1, 2: 2, 3: 3})
        )

        class Exc(Exception): pass

        d.clear()
        class FailingUserDict:
            def keys(self):
                raise Exc
        self.assertRaises(Exc, d.update, FailingUserDict())

        class FailingUserDict:
            def keys(self):
                class BogonIter:
                    def __init__(self):
                        self.i = 1
                    def __iter__(self):
                        return self
                    def next(self):
                        if self.i:
                            self.i = 0
                            return 'a'
                        raise Exc
                return BogonIter()
            def __getitem__(self, key):
                return key
        self.assertRaises(Exc, d.update, FailingUserDict())

        class FailingUserDict:
            def keys(self):
                class BogonIter:
                    def __init__(self):
                        self.i = ord('a')
                    def __iter__(self):
                        return self
                    def next(self):
                        if self.i <= ord('z'):
                            rtn = chr(self.i)
                            self.i += 1
                            return rtn
                        raise StopIteration
                return BogonIter()
            def __getitem__(self, key):
                raise Exc
        self.assertRaises(Exc, d.update, FailingUserDict())

        class badseq(object):
            def __iter__(self):
                return self
            def next(self):
                raise Exc()

        self.assertRaises(Exc,
                          CuteSleekValueDict(null_callback).update,
                          badseq())

        self.assertRaises(
            ValueError,
            CuteSleekValueDict(null_callback).update,
            [(1, 2, 3)]
        )

        
    def test_fromkeys(self):
        self.assertEqual(
            CuteSleekValueDict.fromkeys('abc'),
            CuteSleekValueDict(null_callback,
                                     {'a': None, 'b': None, 'c': None}
                                     )
        )
        
        d = CuteSleekValueDict(null_callback)
        self.assertIsNot(d.fromkeys('abc'), d)
        self.assertEqual(
            d.fromkeys('abc'),
            CuteSleekValueDict(null_callback,
                                     {'a': None, 'b': None, 'c': None})
        )
        self.assertEqual(
            d.fromkeys((4, 5), 0),
            CuteSleekValueDict(null_callback, {4: 0, 5: 0})
        )
        self.assertEqual(
            d.fromkeys([]),
            CuteSleekValueDict(null_callback)
        )
        
        def g():
            yield 1
        self.assertEqual(
            d.fromkeys(g()),
            CuteSleekValueDict(null_callback, {1: None})
        )
        
        self.assertRaises(
            TypeError,
            CuteSleekValueDict(null_callback).fromkeys,
            3
        )

        class CSVDoid(CuteSleekValueDict): pass
        self.assertEqual(
            CSVDoid.fromkeys('a'),
            CuteSleekValueDict(null_callback, {'a': None})
        )
        self.assertEqual(
            CSVDoid(null_callback).fromkeys('a'),
            CuteSleekValueDict(null_callback, {'a': None})
        )
        self.assertIsInstance(
            CSVDoid.fromkeys('a'),
            CSVDoid
        )
        self.assertIsInstance(
            CSVDoid(null_callback).fromkeys('a'),
            CSVDoid
        )

        class myCSVD(CuteSleekValueDict):
            def __new__(cls, callback):
                return UserDict.UserDict()
        ud = myCSVD.fromkeys('ab')
        self.assertEqual(
            ud,
            CuteSleekValueDict(null_callback, {'a': None, 'b': None})
        )
        self.assertIsInstance(
            ud,            
            UserDict.UserDict
        )
        self.assertRaises(TypeError, CuteSleekValueDict.fromkeys)

        class Exc(Exception): pass

        class badCSVD1(CuteSleekValueDict):
            def __init__(self, callback):
                raise Exc()

        self.assertRaises(Exc, badCSVD1.fromkeys, [1])

        class BadSeq(object):
            def __iter__(self):
                return self
            def next(self):
                raise Exc()

        self.assertRaises(Exc, CuteSleekValueDict.fromkeys, BadSeq())

        class badCSVD2(dict):
            def __setitem__(self, key, value):
                raise Exc()

        self.assertRaises(Exc, badCSVD2.fromkeys, [1])

        # test fast path for dictionary inputs
        d = CuteSleekValueDict(null_callback, zip(range(6), range(6)))
        self.assertEqual(
            CuteSleekValueDict.fromkeys(d, 0),
            CuteSleekValueDict(null_callback, zip(range(6), [0]*6)))

        
    def test_copy(self):
        d = CuteSleekValueDict(null_callback, {1: 1, 2: 2, 3: 3})
        self.assertEqual(
            d.copy(),
            CuteSleekValueDict(null_callback, {1: 1, 2: 2, 3: 3})
        )
        self.assertEqual(
            CuteSleekValueDict(null_callback).copy(),
            CuteSleekValueDict(null_callback)
        )
        self.assertRaises(TypeError, d.copy, None)

        
    def test_get(self):
        d = CuteSleekValueDict(null_callback)
        self.assertIs(d.get('c'), None)
        self.assertEqual(d.get('c', 3), 3)
        d = CuteSleekValueDict(null_callback, {'a': 1, 'b': 2})
        self.assertIs(d.get('c'), None)
        self.assertEqual(d.get('c', 3), 3)
        self.assertEqual(d.get('a'), 1)
        self.assertEqual(d.get('a', 3), 1)
        self.assertRaises(TypeError, d.get)
        self.assertRaises(TypeError, d.get, None, None, None)

    def test_setdefault(self):
        d = CuteSleekValueDict(null_callback)
        self.assertIs(d.setdefault('key0'), None)
        d.setdefault('key0', [])
        self.assertIs(d.setdefault('key0'), None)
        d.setdefault('key', []).append(3)
        self.assertEqual(d['key'][0], 3)
        d.setdefault('key', []).append(4)
        self.assertEqual(len(d['key']), 2)
        self.assertRaises(TypeError, d.setdefault)

        class Exc(Exception): pass

        class BadHash(object):
            fail = False
            def __hash__(self):
                if self.fail:
                    raise Exc()
                else:
                    return 42

        x = BadHash()
        d[x] = 42
        x.fail = True
        self.assertRaises(Exc, d.setdefault, x, [])

        
    def test_popitem(self):
        for copymode in -1, +1:
            # -1: b has same structure as a
            # +1: b is a.copy()
            for log2size in range(12):
                size = 2**log2size
                a = CuteSleekValueDict(null_callback)
                b = CuteSleekValueDict(null_callback)
                for i in range(size):
                    a[repr(i)] = i
                    if copymode < 0:
                        b[repr(i)] = i
                if copymode > 0:
                    b = a.copy()
                for i in range(size):
                    ka, va = ta = a.popitem()
                    self.assertEqual(va, int(ka))
                    kb, vb = tb = b.popitem()
                    self.assertEqual(vb, int(kb))
                    self.assertFalse(copymode < 0 and ta != tb)
                self.assertFalse(a)
                self.assertFalse(b)

        d = CuteSleekValueDict(null_callback)
        self.assertRaises(KeyError, d.popitem)

        
    def test_pop(self):
        # Tests for pop with specified key
        d = CuteSleekValueDict(null_callback)
        k, v = 'abc', 'def'
        d[k] = v
        self.assertRaises(KeyError, d.pop, 'ghi')

        self.assertEqual(d.pop(k), v)
        self.assertEqual(len(d), 0)

        self.assertRaises(KeyError, d.pop, k)

        # verify longs/ints get same value when key > 32 bits
        # (for 64-bit archs).  See SF bug #689659.
        x = 4503599627370496L
        y = 4503599627370496
        h = CuteSleekValueDict(
            null_callback,
            {x: 'anything', y: 'something else'}
        )
        self.assertEqual(h[x], h[y])

        self.assertEqual(d.pop(k, v), v)
        d[k] = v
        self.assertEqual(d.pop(k, 1), v)

        self.assertRaises(TypeError, d.pop)

        class Exc(Exception): pass

        class BadHash(object):
            fail = False
            def __hash__(self):
                if self.fail:
                    raise Exc()
                else:
                    return 42

        x = BadHash()
        d[x] = 42
        x.fail = True
        self.assertRaises(Exc, d.pop, x)

        
    def test_mutatingiteration(self):
        # changing dict size during iteration
        d = CuteSleekValueDict(null_callback)
        d[1] = 1
        with self.assertRaises(RuntimeError):
            for i in d:
                d[i+1] = 1

                
    #def test_le(self):
        #self.assertFalse(
            #CuteSleekValueDict(null_callback) < \
            #CuteSleekValueDict(null_callback)
        #)
        #self.assertFalse(
            #CuteSleekValueDict(null_callback, {1: 2}) < \
            #CuteSleekValueDict(null_callback, {1L: 2L})
        #)

        #class Exc(Exception): pass

        #class BadCmp(object):
            #def __eq__(self, other):
                #raise Exc()
            #def __hash__(self):
                #return 42

        #d1 = CuteSleekValueDict(null_callback, {BadCmp(): 1})
        #d2 = CuteSleekValueDict(null_callback, {1: 1})

        #with self.assertRaises(Exc):
            #d1 < d2

            
    def test_missing(self):
        # Make sure dict doesn't have a __missing__ method
        self.assertFalse(hasattr(CuteSleekValueDict, "__missing__"))
        self.assertFalse(
            hasattr(CuteSleekValueDict(null_callback), "__missing__")
        )
        # Test several cases:
        # (D) subclass defines __missing__ method returning a value
        # (E) subclass defines __missing__ method raising RuntimeError
        # (F) subclass sets __missing__ instance variable (no effect)
        # (G) subclass doesn't define __missing__ at a all
        class D(CuteSleekValueDict):
            def __missing__(self, key):
                return 42
        d = D(null_callback, CuteSleekValueDict(null_callback, {1: 2, 3: 4}))
        self.assertEqual(d[1], 2)
        self.assertEqual(d[3], 4)
        self.assertNotIn(2, d)
        self.assertNotIn(2, d.keys())
        self.assertEqual(d[2], 42)

        class E(CuteSleekValueDict):
            def __missing__(self, key):
                raise RuntimeError(key)
        e = E(null_callback)
        with self.assertRaises(RuntimeError) as c:
            e[42]
        self.assertEqual(c.exception.args, (42,))

        class F(dict):
            def __init__(self):
                # An instance variable __missing__ should have no effect
                self.__missing__ = lambda key: None
        f = F()
        with self.assertRaises(KeyError) as c:
            f[42]
        #self.assertEqual(c.exception.args, (42,))

        class G(dict):
            pass
        g = G()
        with self.assertRaises(KeyError) as c:
            g[42]
        #self.assertEqual(c.exception.args, (42,))

    def test_tuple_keyerror(self):
        # SF #1576657
        d = CuteSleekValueDict(null_callback)
        with self.assertRaises(KeyError) as c:
            d[(1,)]
        #self.assertEqual(c.exception.args, ((1,),))

        
    def test_bad_key(self):
        # Dictionary lookups should fail if __cmp__() raises an exception.
        class CustomException(Exception):
            pass

        class BadDictKey:
            def __hash__(self):
                return hash(self.__class__)

            def __cmp__(self, other):
                if isinstance(other, self.__class__):
                    raise CustomException
                return other

        d = CuteSleekValueDict(null_callback)
        x1 = BadDictKey()
        x2 = BadDictKey()
        d[x1] = 1
        locals()['CuteSleekValueDict'] = CuteSleekValueDict
        locals()['null_callback'] = null_callback
        for stmt in ['d[x2] = 2',
                     'z = d[x2]',
                     'x2 in d',
                     'd.has_key(x2)',
                     'd.get(x2)',
                     'd.setdefault(x2, 42)',
                     'd.pop(x2)',
                     'd.update(CuteSleekValueDict(null_callback, {x2: 2}))']:
            with self.assertRaises(CustomException):
                exec stmt in locals()

                
    def test_resize1(self):
        # Dict resizing bug, found by Jack Jansen in 2.2 CVS development.
        # This version got an assert failure in debug build, infinite loop in
        # release build.  Unfortunately, provoking this kind of stuff requires
        # a mix of inserts and deletes hitting exactly the right hash codes in
        # exactly the right order, and I can't think of a randomized approach
        # that would be *likely* to hit a failing case in reasonable time.

        d = CuteSleekValueDict(null_callback)
        for i in range(5):
            d[i] = i
        for i in range(5):
            del d[i]
        for i in range(5, 9):  # i==8 was the problem
            d[i] = i

            
    def test_resize2(self):
        # Another dict resizing bug (SF bug #1456209).
        # This caused Segmentation faults or Illegal instructions.

        class X(object):
            def __hash__(self):
                return 5
            def __eq__(self, other):
                if resizing:
                    d.clear()
                return False
        d = CuteSleekValueDict(null_callback)
        resizing = False
        d[X()] = 1
        d[X()] = 2
        d[X()] = 3
        d[X()] = 4
        d[X()] = 5
        # now trigger a resize
        resizing = True
        d[9] = 6

        
    def test_empty_presized_dict_in_freelist(self):
        # Bug #3537: if an empty but presized dict with a size larger
        # than 7 was in the freelist, it triggered an assertion failure
        with self.assertRaises(ZeroDivisionError):
            d = CuteSleekValueDict(
                null_callback,
                {'a': 1 // 0, 'b': None, 'c': None, 'd': None, 'e': None,
                 'f': None, 'g': None, 'h': None}
            )
        d = CuteSleekValueDict(null_callback)

    
    def test_container_iterator(self):
        # Bug #3680: tp_traverse was not implemented for dictiter objects

        if sys.version_info[:2] == (2, 5):
            raise nose.SkipTest('Bug 3680 will not be fixed in Python 2.5')
        
        class C(object):
            pass
        iterators = (CuteSleekValueDict.iteritems,
                     CuteSleekValueDict.itervalues,
                     CuteSleekValueDict.iterkeys)
        for i in iterators:
            obj = C()
            ref = weakref.ref(obj)
            container = CuteSleekValueDict(null_callback, {obj: 1})
            obj.x = i(container)
            del obj, container
            gc.collect()
            self.assertIs(ref(), None, "Cycle was not collected")
    

    

########NEW FILE########
__FILENAME__ = test_sleek_call_args
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Testing module for `garlicsim.general_misc.sleek_refs.SleekCallArgs`.'''

import gc
import weakref
from garlicsim.general_misc.sleek_refs import (SleekCallArgs,
                                               SleekRef,
                                               CuteSleekValueDict)

from .shared import _is_weakreffable, A, counter


def f(*args, **kwargs): pass


def test():
    '''Test the basic workings of `SleekCallArgs`.'''
    sca_dict = {}
    
    args = (1, 2)
    sca1 = SleekCallArgs(sca_dict, f, *args)
    sca_dict[sca1] = 'meow'
    del args
    gc.collect()
    assert len(sca_dict) == 1
    
    args = (1, A())
    sca2 = SleekCallArgs(sca_dict, f, *args)
    sca_dict[sca2] = 'meow'
    del args
    gc.collect()
    assert len(sca_dict) == 1
    
    
def test_unhashable():
    '''Test `SleekCallArgs` on unhashable arguments.'''
    sca_dict = {}
    
    args = ([1, 2], {1: [1, 2]}, set(['a', 1]))
    sca1 = SleekCallArgs(sca_dict, f, *args)
    hash(sca1)
    sca_dict[sca1] = 'meow'
    del args
    gc.collect()
    # GCed because there's a `set` in `args`, and it's weakreffable:
    assert len(sca_dict) == 0
    
    kwargs = {
        'a': {1: 2},
        'b': [
            set(),
            set(
                (
                    frozenset((3, 4)),
                )
            )
        ]
    }
    sca2 = SleekCallArgs(sca_dict, f, **kwargs)
    hash(sca2)
    sca_dict[sca2] = 'meow'
    del kwargs
    gc.collect()
    # Not GCed because all objects in `kwargs` are not weakreffable:
    assert len(sca_dict) == 1
    
########NEW FILE########
__FILENAME__ = test_sleek_ref
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Testing module for `garlicsim.general_misc.sleek_refs.SleekRef`.'''

import gc
import weakref

import nose.tools

from garlicsim.general_misc.sleek_refs import (SleekCallArgs,
                                               SleekRef,
                                               SleekRefDied,
                                               CuteSleekValueDict)

from .shared import _is_weakreffable, A, counter

    
def test_sleek_ref():
    '''Test the basic workings of `SleekRef`.'''

    volatile_things = [A(), 1, 4.5, 'meow', u'woof', [1, 2], (1, 2), {1: 2},
                       set([1, 2, 3]), (None, 3, {None: 4})]
    unvolatile_things = [A.s, __builtins__, list, type,  list.append, str.join,
                         sum, None]
    
    while volatile_things:
        volatile_thing = volatile_things.pop()
        sleek_ref = SleekRef(volatile_thing, counter)
        assert sleek_ref() is volatile_thing
        if _is_weakreffable(volatile_thing):
            count = counter()
            del volatile_thing
            gc.collect()
            assert counter() == count + 2
            nose.tools.assert_raises(SleekRefDied, sleek_ref)
        else:
            count = counter()
            del volatile_thing
            gc.collect()
            assert counter() == count + 1
            assert sleek_ref() is not None
    
    while unvolatile_things:
        unvolatile_thing = unvolatile_things.pop()
        sleek_ref = SleekRef(unvolatile_thing, counter)
        assert sleek_ref() is unvolatile_thing
        
        count = counter()
        del unvolatile_thing
        gc.collect()
        assert counter() == count + 1
        # Testing if it will raise SleekRefDied:
        sleek_ref()

########NEW FILE########
__FILENAME__ = test_output_capturer
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Testing module for `garlicsim.general_misc.sys_tools.OutputCapturer`.'''

from __future__ import with_statement

import sys

from garlicsim.general_misc.sys_tools import OutputCapturer


def test():
    '''Test the basic workings of `OutputCapturer`.'''
    with OutputCapturer() as output_capturer:
        print('meow')
    assert output_capturer.output == 'meow\n'
    
    
def test_nested():
    '''Test an `OutputCapturer` inside an `OutputCapturer`.'''
    with OutputCapturer() as output_capturer_1:
        print('123')
        with OutputCapturer() as output_capturer_2:
            print('456')
        assert output_capturer_2.output == '456\n'
    assert output_capturer_1.output == '123\n'
    

def test_streams():
    '''Test capturing different streams with `OutputCapturer`.'''
    with OutputCapturer() as catch_all_output_capturer:
        with OutputCapturer(True, False) as stdout_output_capturer:
            print('Woo!')
            sys.stdout.write('frrr.')
            sys.stderr.write('qwerty')
        assert stdout_output_capturer.output == 'Woo!\nfrrr.'
        assert catch_all_output_capturer.output == 'qwerty'
        
        with OutputCapturer(False, False) as blank_output_capturer:
            print('zort')
            sys.stdout.write('zort')
            sys.stderr.write('zort')
        assert blank_output_capturer.output == ''
        assert catch_all_output_capturer.output.endswith('zort\nzortzort')
        
        with OutputCapturer(stdout=False) as stderr_output_capturer:
            print('one')
            sys.stdout.write('two')
            sys.stderr.write('three')
            
            with OutputCapturer():
                print('spam')
                sys.stdout.write('spam')
                sys.stderr.write('spam')
                
        assert stderr_output_capturer.output == 'three'
        assert catch_all_output_capturer.output.endswith('one\ntwo')
        assert 'spam' not in stderr_output_capturer.output
        assert 'spam' not in catch_all_output_capturer.output
        
            
        

########NEW FILE########
__FILENAME__ = test_temp_sys_path_adder
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Testing module for `garlicsim.general_misc.sys_tools.TempSysPathAdder`.
'''

from __future__ import with_statement

import sys

from garlicsim.general_misc.sys_tools import TempSysPathAdder

def test_single():
    '''Test using `TempSysPathAdder` to add a single path.'''
    other_path = 'afdgfasgg38gjh3908ga'
    assert other_path not in sys.path
    with TempSysPathAdder(other_path):
        assert other_path in sys.path
    assert other_path not in sys.path
    
    
def test_multiple():
    '''Test using `TempSysPathAdder` to add multiple paths.'''
    other_paths = ['wf43f3_4f', 'argaer\\5g_']
    for other_path in other_paths:
        assert other_path not in sys.path
    with TempSysPathAdder(other_paths):
        for other_path in other_paths:
            assert other_path in sys.path
    for other_path in other_paths:
        assert other_path not in sys.path
    
########NEW FILE########
__FILENAME__ = test_temporary_folder
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Testing module for `temp_file_tools.TemporaryFolder`.'''

from __future__ import with_statement

import tempfile
import os.path

import nose.tools

import garlicsim

from garlicsim.general_misc.temp_file_tools import TemporaryFolder


def test_basic():
    '''Test the basic working of `TemporaryFolder`.'''
    with TemporaryFolder() as tf1path:
        assert isinstance(tf1path, str)
        assert os.path.exists(tf1path)
        assert os.path.isdir(tf1path)
        
        tf2 = TemporaryFolder()
        with tf2 as tf2path:
            assert str(tf2) == tf2.path == tf2path
            assert os.path.exists(str(tf2))
            assert os.path.isdir(str(tf2))
            
        assert not os.path.exists(str(tf2))
        assert not os.path.isdir(tf2path)
                
        assert os.path.exists(tf1path)
        assert os.path.isdir(tf1path)
        
        file_path = os.path.join(tf1path, 'my_file')
        with open(file_path, 'w') as my_file:
            my_file.write('Woo hoo!')
        
        assert os.path.exists(file_path)
        assert os.path.isfile(file_path)
        
        with open(file_path, 'r') as my_file:
            assert my_file.read() == 'Woo hoo!'
            
    assert not os.path.exists(tf1path)
    assert not os.path.isdir(tf1path)
    
    assert not os.path.exists(file_path)
    assert not os.path.isdir(file_path)
    


########NEW FILE########
__FILENAME__ = test_recursion_limit_setter
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Tests for `garlicsim.general_misc.temp_value_setters.TempRecursionLimitSetter`.
'''

from __future__ import with_statement

import sys

from garlicsim.general_misc import cute_testing

from garlicsim.general_misc.temp_value_setters import TempRecursionLimitSetter


def test():
    '''Test basic workings of `TempRecursionLimitSetter`.'''
    old_recursion_limit = sys.getrecursionlimit()
    assert sys.getrecursionlimit() == old_recursion_limit
    with TempRecursionLimitSetter(old_recursion_limit + 3):
        assert sys.getrecursionlimit() == old_recursion_limit + 3
    assert sys.getrecursionlimit() == old_recursion_limit


def test_as_decorator():
    '''Test `TempRecursionLimitSetter` when used as a decorator.'''
    old_recursion_limit = sys.getrecursionlimit()
    @TempRecursionLimitSetter(1234)
    def f():
        assert sys.getrecursionlimit() == 1234
    assert sys.getrecursionlimit() == old_recursion_limit
    f()
    assert sys.getrecursionlimit() == old_recursion_limit
    
    cute_testing.assert_polite_wrapper(f)
########NEW FILE########
__FILENAME__ = test_temp_value_setter
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Testing module for `garlicsim.general_misc.temp_value_setters.TempValueSetter`.
'''

from __future__ import with_statement

from garlicsim.general_misc import cute_testing

from garlicsim.general_misc.temp_value_setters import TempValueSetter


class Object(object):
    pass


def test_simple():
    '''
    Test `TempValueSetter` with variable inputted as `(obj, attribute_name)`.
    '''
    a = Object()
    a.x = 1
    
    assert a.x == 1
    with TempValueSetter((a, 'x'), 2):
        assert a.x == 2
    assert a.x == 1
    

def test_setter_getter():
    '''Test `TempValueSetter` with variable inputted as `(getter, setter)`.'''
    a = Object()
    a.x = 1
    getter = lambda: getattr(a, 'x')
    setter = lambda value: setattr(a, 'x', value)
    
    
    assert a.x == 1
    with TempValueSetter((getter, setter), 2):
        assert a.x == 2
    assert a.x == 1
    
    
def test_dict_key():
    '''Test `TempValueSetter` with variable inputted as `(dict, key)`.'''
    a = {1: 2}
    
    assert a[1] == 2
    with TempValueSetter((a, 1), 'meow'):
        assert a[1] == 'meow'
    assert a[1] == 2
    
    b = {}
    
    assert sum not in b
    with TempValueSetter((b, sum), 7):
        assert b[sum] == 7
    assert sum not in b

    
def test_as_decorator():
    '''Test `TempValueSetter` used as a decorator.'''
    def a(): pass
    a.x = 1
    
    @TempValueSetter((a, 'x'), 2)
    def f():
        assert a.x == 2
    assert a.x == 1
    f()
    assert a.x == 1
    
    cute_testing.assert_polite_wrapper(f)
########NEW FILE########
__FILENAME__ = test_temp_working_directory_setter
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Testing `garlicsim.general_misc.temp_value_setters.TempWorkingDirectorySetter`.
'''

from __future__ import with_statement

import os
import shutil
import tempfile

from garlicsim.general_misc import cute_testing
from garlicsim.general_misc import temp_file_tools

from garlicsim.general_misc.temp_value_setters import \
     TempWorkingDirectorySetter

class MyException(Exception):
    pass

def test():
    '''Test basic workings of `TempWorkingDirectorySetter`.'''
    with temp_file_tools.TemporaryFolder(prefix='temp_test_garlicsim_') \
                                                          as temp_folder:
        old_cwd = os.getcwd()
        with TempWorkingDirectorySetter(temp_folder):
            
            # Note that on Mac OS, the working dir will be phrased differently,
            # so we can't do `assert os.getcwd() == temp_dir`. Instead we'll
            # create a small file and check we can access it:
            
            with open('just_a_file', 'w') as my_file:
                my_file.write('One two three.')
            
            with open('just_a_file', 'r') as my_file:
                assert my_file.read() == 'One two three.'
        
        with open(os.path.join(temp_folder, 'just_a_file'), 'r') as my_file:
            assert my_file.read() == 'One two three.'
        
        assert os.getcwd() == old_cwd
    
    
def test_exception():
    '''Test `TempWorkingDirectorySetter` recovering from exception in suite.'''
    # Not using `assert_raises` here because getting the `with` suite in there
    # would be tricky.
    with temp_file_tools.TemporaryFolder(prefix='temp_test_garlicsim_') \
                                                          as temp_folder:
        old_cwd = os.getcwd()
        try:
            with TempWorkingDirectorySetter(temp_folder):
                
                # Note that on Mac OS, the working dir will be phrased
                # differently, so we can't do `assert os.getcwd() ==
                # temp_folder`. Instead we'll create a small file and check we
                # can access it:
                
                with open('just_a_file', 'w') as my_file:
                    my_file.write('One two three.')
                
                with open('just_a_file', 'r') as my_file:
                    assert my_file.read() == 'One two three.'
                
                raise MyException
            
        except MyException:

            with open(os.path.join(temp_folder, 'just_a_file'), 'r') \
                                                           as my_file:
                assert my_file.read() == 'One two three.'
                
        else:
            raise Exception
        
        with open(os.path.join(temp_folder, 'just_a_file'), 'r') as my_file:
            assert my_file.read() == 'One two three.'

        
def test_as_decorator():
    '''Test `TempWorkingDirectorySetter` used as a decorator.'''
    with temp_file_tools.TemporaryFolder(prefix='temp_test_garlicsim_') \
                                                          as temp_folder:
        old_cwd = os.getcwd()
        @TempWorkingDirectorySetter(temp_folder)
        def f():
            # Note that on Mac OS, the working dir will be phrased differently,
            # so we can't do `assert os.getcwd() == temp_folder`. Instead we'll
            # create a small file and check we can access it:
            
            with open('just_a_file', 'w') as my_file:
                my_file.write('One two three.')
            
            with open('just_a_file', 'r') as my_file:
                assert my_file.read() == 'One two three.'
                
        f()
        
        cute_testing.assert_polite_wrapper(f)
        
        with open(os.path.join(temp_folder, 'just_a_file'), 'r') as my_file:
            assert my_file.read() == 'One two three.'
        
        assert os.getcwd() == old_cwd
        
########NEW FILE########
__FILENAME__ = state
import garlicsim.data_structures


class State(garlicsim.data_structures.State):
    
    def __init__(self):
        self.list = []
        self.cross_process_persistent = \
            garlicsim.general_misc.persistent.CrossProcessPersistent()
        self.clock = 0

        
    def inplace_step_generator(self):
        self.clock +=1
        yield
            
        
    @staticmethod
    def create_root():
        return State()
    
########NEW FILE########
__FILENAME__ = _test_settings
from garlicsim.general_misc import import_tools

import garlicsim

from .state import State

ENDABLE = False
PROBLEM = None
VALID = True
CONSTANT_CLOCK_INTERVAL = 1
HISTORY_DEPENDENT = False
N_STEP_FUNCTIONS = 1
DEFAULT_STEP_FUNCTION = State.inplace_step_generator
DEFAULT_STEP_FUNCTION_TYPE = \
    garlicsim.misc.simpack_grokker.step_types.InplaceStepGenerator
CRUNCHERS_LIST = \
    [garlicsim.asynchronous_crunching.crunchers.ThreadCruncher] + \
    (
        [garlicsim.asynchronous_crunching.crunchers.ProcessCruncher] if 
        import_tools.exists('multiprocessing')
        else []
    )
########NEW FILE########
__FILENAME__ = state
import garlicsim.data_structures


class State(garlicsim.data_structures.State):
    
    def __init__(self):
        self.list = []
        self.cross_process_persistent = \
            garlicsim.general_misc.persistent.CrossProcessPersistent()
        self.clock = 0

        
    def inplace_step(self):
        self.clock += 1
        
        
    @staticmethod
    def create_root():
        return State()
    
########NEW FILE########
__FILENAME__ = _test_settings
from garlicsim.general_misc import import_tools

import garlicsim

from .state import State

ENDABLE = False
PROBLEM = None
VALID = True
CONSTANT_CLOCK_INTERVAL = 1
HISTORY_DEPENDENT = False
N_STEP_FUNCTIONS = 1
DEFAULT_STEP_FUNCTION = State.inplace_step
DEFAULT_STEP_FUNCTION_TYPE = \
    garlicsim.misc.simpack_grokker.step_types.InplaceStep
CRUNCHERS_LIST = \
    [garlicsim.asynchronous_crunching.crunchers.ThreadCruncher] + \
    (
        [garlicsim.asynchronous_crunching.crunchers.ProcessCruncher] if 
        import_tools.exists('multiprocessing')
        else []
    )
########NEW FILE########
__FILENAME__ = state
import garlicsim.data_structures


class State(garlicsim.data_structures.State):
    
    def __init__(self):
        self.list = []
        self.cross_process_persistent = \
            garlicsim.general_misc.persistent.CrossProcessPersistent()
        self.clock = 0

        
    def inplace_step_generator(self):
        while True:
            self.clock +=1
            yield

            
    @staticmethod
    def create_root():
        return State()
    
########NEW FILE########
__FILENAME__ = _test_settings
from garlicsim.general_misc import import_tools

import garlicsim

from .state import State

ENDABLE = False
PROBLEM = None
VALID = True
CONSTANT_CLOCK_INTERVAL = 1
HISTORY_DEPENDENT = False
N_STEP_FUNCTIONS = 1
DEFAULT_STEP_FUNCTION = State.inplace_step_generator
DEFAULT_STEP_FUNCTION_TYPE = \
    garlicsim.misc.simpack_grokker.step_types.InplaceStepGenerator
CRUNCHERS_LIST = \
    [garlicsim.asynchronous_crunching.crunchers.ThreadCruncher] + \
    (
        [garlicsim.asynchronous_crunching.crunchers.ProcessCruncher] if 
        import_tools.exists('multiprocessing')
        else []
    )
########NEW FILE########
__FILENAME__ = test_inplace
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Testing module for inplace step functions.'''

from __future__ import division
from __future__ import with_statement

import os
import types
import time
import itertools

import nose

from garlicsim.general_misc import cute_iter_tools
from garlicsim.general_misc import math_tools
from garlicsim.general_misc import path_tools
from garlicsim.general_misc import import_tools
from garlicsim.general_misc.infinity import infinity
from garlicsim.general_misc.nifty_collections import OrderedSet
from garlicsim.general_misc.tracing_tools import TempFunctionCallCounter

import garlicsim

import test_garlicsim


class StateDeepcopyCounter(TempFunctionCallCounter):
    '''Counts how many times `state_deepcopy` was called.'''
    def __init__(self):
        TempFunctionCallCounter.__init__(
            self,
            garlicsim.misc.state_deepcopy.state_deepcopy
        )


def test():
    '''Test inplace step functions.'''
    
    from . import simpacks as simpacks_package
    
    # Collecting all the test simpacks:
    simpacks = import_tools.import_all(simpacks_package).values()
    
    # Making sure that we didn't miss any simpack by counting the number of
    # sub-folders in the `simpacks` folder:
    simpacks_dir = \
        os.path.dirname(simpacks_package.__file__)
    assert len(path_tools.list_sub_folders(simpacks_dir)) == \
           len(simpacks)
    
    for simpack in simpacks:        
        
        test_garlicsim.verify_simpack_settings(simpack)
        
        cruncher_types = \
            garlicsim.misc.SimpackGrokker(simpack).available_cruncher_types
        
        for cruncher_type in cruncher_types:
            yield check, simpack, cruncher_type


        
def check(simpack, cruncher_type):
    '''
    Run checks on a simpack that uses inplace step functions.
    '''
    my_simpack_grokker = garlicsim.misc.SimpackGrokker(simpack)
    
    assert simpack._test_settings.DEFAULT_STEP_FUNCTION_TYPE in \
           [garlicsim.misc.simpack_grokker.step_types.InplaceStep,
            garlicsim.misc.simpack_grokker.step_types.InplaceStepGenerator]
    
    assert garlicsim.misc.simpack_grokker.step_type.StepType.get_step_type(
        my_simpack_grokker.default_step_function
    ) == simpack._test_settings.DEFAULT_STEP_FUNCTION_TYPE
    
    assert simpack._test_settings.CONSTANT_CLOCK_INTERVAL == 1
    
    step_profile = my_simpack_grokker.build_step_profile()
    
    state = simpack.State.create_root()
    assert state.clock == 0
    
    
    with StateDeepcopyCounter() as state_deepcopy_counter:
        state_1 = garlicsim.simulate(state)
    assert state.clock == 0
    assert state_1.clock == 1
    assert state_1 is not state
    assert state_1.list is not state.list
    assert state_1.cross_process_persistent is state.cross_process_persistent
    n_state_deepcopy_operations = state_deepcopy_counter.call_count
    assert 1 <= n_state_deepcopy_operations <= 2
    
    
    with StateDeepcopyCounter() as state_deepcopy_counter:
        state_2 = garlicsim.simulate(state, 2)
    assert state.clock == 0
    assert state_1.clock == 1
    assert state_2.clock == 2
    assert state_2 is not state
    assert state_2.list is not state.list
    assert state_2.cross_process_persistent is state.cross_process_persistent
    assert n_state_deepcopy_operations == state_deepcopy_counter.call_count

    
    with StateDeepcopyCounter() as state_deepcopy_counter:
        state_10 = garlicsim.simulate(state, 10)
    assert state.clock == 0
    assert state_1.clock == 1
    assert state_2.clock == 2
    assert state_10.clock == 10
    assert state_10 is not state
    assert state_10 is not state_2
    assert state_10.list is not state.list
    assert state_10.list is not state_2.list
    assert state_10.cross_process_persistent is state.cross_process_persistent
    assert n_state_deepcopy_operations == state_deepcopy_counter.call_count
    

    ###########################################################################
    #                                                                         #
    
    with StateDeepcopyCounter() as state_deepcopy_counter:
        garlicsim.list_simulate(state, 3)
    n_state_deepcopy_operations_for_3_in_list = \
        state_deepcopy_counter.call_count
    
    with StateDeepcopyCounter() as state_deepcopy_counter:
        garlicsim.list_simulate(state, 4)
    n_state_deepcopy_operations_for_4_in_list = \
        state_deepcopy_counter.call_count
    
    assert n_state_deepcopy_operations_for_4_in_list > \
           n_state_deepcopy_operations_for_3_in_list
    
    #                                                                         #
    ###########################################################################
        
        
    prev_state = state
    for i in [1, 2, 3, 4]:
        new_state = garlicsim.simulate(state, i)
        assert new_state.clock >= getattr(prev_state, 'clock', 0)
        assert new_state is not prev_state
        assert new_state.list is not prev_state.list
        assert new_state.cross_process_persistent is \
               prev_state.cross_process_persistent
        prev_state = new_state
    
    result = garlicsim.list_simulate(state, 4)
    for item in result:
        assert isinstance(item, garlicsim.data_structures.State)
        assert isinstance(item, simpack.State)
    
    assert isinstance(result, list)
    assert len(result) == 5
        
    
    iter_result = garlicsim.iter_simulate(state, 4)
        
    assert not hasattr(iter_result, '__getitem__')
    assert hasattr(iter_result, '__iter__')
    iter_result_in_list = list(iter_result)
    del iter_result
    assert len(iter_result_in_list) == len(result) == 5

    
    ### Setting up a project to run asynchronous tests:
    
    project = garlicsim.Project(simpack)
        
    project.crunching_manager.cruncher_type = cruncher_type
    
    assert project.tree.lock._ReadWriteLock__writer is None
    
    root = project.root_this_state(state)
    
    
    project.begin_crunching(root, 4)

    total_nodes_added = 0    
    while project.crunching_manager.jobs:
        time.sleep(0.1)
        total_nodes_added += project.sync_crunchers()
        
    assert total_nodes_added == 4
    
    assert len(project.tree.nodes) == 5
    assert len(project.tree.roots) == 1
    
    paths = project.tree.all_possible_paths()
    
    assert len(paths) == 1
    
    (my_path,) = paths
        
    assert len(my_path) == 5
    
    node_1 = my_path[1]
    assert node_1.state.clock == 1
    
    node_2 = project.simulate(node_1, 3)
    
    assert len(project.tree.nodes) == 8
    assert len(project.tree.roots) == 1
    
    assert len(project.tree.all_possible_paths()) == 2

    block_1, block_2 = [node.block for node in node_1.children]
    assert isinstance(block_1, garlicsim.data_structures.Block)
    assert isinstance(block_2, garlicsim.data_structures.Block)
    assert block_1.soft_get_block() is block_1
    assert block_2.soft_get_block() is block_2
    assert block_1.is_overlapping(block_1)
    assert block_2.is_overlapping(block_2)
    assert not block_1.is_overlapping(block_2)
    assert not block_2.is_overlapping(block_1)
    block_path_1 = block_1.make_containing_path()
    block_path_2 = block_2.make_containing_path()
    assert block_path_1 == block_path_1
    assert block_path_1 != block_path_2
    assert (block_1[0] in block_path_1) and (block_1[-1] in block_path_1)
    assert (block_2[0] in block_path_2) and (block_2[-1] in block_path_2)
    assert block_1.get_root() is block_2.get_root()
    
        
 
    tree_members_iterator = \
        project.tree.iterate_tree_members(include_blockful_nodes=False)
    assert tree_members_iterator.__iter__() is tree_members_iterator
    tree_members = list(tree_members_iterator)
    assert (block_1 in tree_members) and (block_2 in tree_members)
    for tree_member in tree_members:
        if isinstance(tree_member, garlicsim.data_structures.Node):
            assert tree_member.block is None
    
    tree_members_iterator_including_blockful_nodes = \
        project.tree.iterate_tree_members(include_blockful_nodes=True)
    assert tree_members_iterator_including_blockful_nodes.__iter__() is \
        tree_members_iterator_including_blockful_nodes
    tree_members_including_blockful_nodes = \
        list(tree_members_iterator_including_blockful_nodes)
    
    blockful_nodes = \
        [member for member in tree_members_including_blockful_nodes if 
         member not in tree_members]
    for blockful_node in blockful_nodes:
        assert isinstance(blockful_node, garlicsim.data_structures.Node)
        assert isinstance(blockful_node.block, garlicsim.data_structures.Block)
        assert blockful_node.block is blockful_node.soft_get_block()
    assert set(tree_members).\
        issubset(set(tree_members_including_blockful_nodes))
    
    tree_step_profiles = project.tree.get_step_profiles()
    assert isinstance(tree_step_profiles, OrderedSet)
    assert tree_step_profiles == [step_profile]
    
########NEW FILE########
__FILENAME__ = test_cached_state_and_history_functions
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

import copy
import nose

import garlicsim
from garlicsim_lib.simpacks import life
from garlicsim.misc import caching
from garlicsim.general_misc import cute_testing


def test_cached_state_function():
    
    def live_cells(state):
        live_cells.called_flag = True
        return state.board._Board__list.count(True)
    
    cached_live_cells = garlicsim.general_misc.caching.cache()(live_cells)
    
    s = life.State.create_root(5, 5)
    
    assert live_cells(s) == cached_live_cells(s) == cached_live_cells(s)
    
    live_cells.called_flag = False
    
    cached_live_cells(s)
    
    assert live_cells.called_flag is False
    
    
    l = garlicsim.list_simulate(s, 10)
    
    result_1 = [cached_live_cells(s) for s in l[0:5]]
        
    assert live_cells.called_flag is True
    live_cells.called_flag = False
    
    
    result_2 = [cached_live_cells(s) for s in l[0:5]]
    
    assert live_cells.called_flag is False
    
    assert result_1 == result_2
    
    
    result_1 = [cached_live_cells(s) for s in l]
        
    assert live_cells.called_flag is True
    live_cells.called_flag = False
    
    result_2 = [cached_live_cells(s) for s in l]
    
    assert live_cells.called_flag is False
    
    assert result_1 == result_2
    
    
    
def test_cached_history_function():
    
    def changes(history_browser):
        '''
        Return how many cells changed between most recent state and its parent.
        '''
        changes.called_flag = True
        try:
            state = history_browser[-1]
            last_state = history_browser[-2]
        except IndexError:
            return None
        board, last_board = state.board, last_state.board
        board_size = len(board._Board__list)
        counter = 0
        for i in xrange(board_size):
            if board._Board__list[i] != last_board._Board__list[i]:
                counter += 1
        return counter
    
    cached_changes = caching.history_cache(changes)
    
    cute_testing.assert_polite_wrapper(cached_changes, changes,
                                       same_signature=False)
    
    s = life.State.create_messy_root(5, 5)
    
    p = garlicsim.Project(life)
    
    r = p.root_this_state(s)
    
    leaf = p.simulate(r, 10)
    
    path = leaf.make_containing_path()
        
    result_1 = [cached_changes(node) for node in list(path)[0:5]]
        
    assert changes.called_flag is True
    changes.called_flag = False
    
    
    result_2 = [cached_changes(node) for node in list(path)[0:5]]
    
    assert changes.called_flag is False
    
    assert result_1 == result_2
    
    
    result_1 = [cached_changes(node) for node in list(path)]
        
    assert changes.called_flag is True
    changes.called_flag = False
    
    
    result_2 = [cached_changes(node) for node in list(path)]
    
    assert changes.called_flag is False
    
    assert result_1 == result_2
    


########NEW FILE########
__FILENAME__ = state
import garlicsim.data_structures


class State(garlicsim.data_structures.State):
    
    def __init__(self):
        pass
    
    @staticmethod
    def history_step(history_browser):
        return State()
        
    @staticmethod
    def create_root():
        return State()
    
########NEW FILE########
__FILENAME__ = _test_settings
import garlicsim

from .state import State

ENDABLE = False
PROBLEM = None
VALID = True
CONSTANT_CLOCK_INTERVAL = None
HISTORY_DEPENDENT = True
N_STEP_FUNCTIONS = 1
DEFAULT_STEP_FUNCTION = State.history_step
DEFAULT_STEP_FUNCTION_TYPE = \
    garlicsim.misc.simpack_grokker.step_types.HistoryStep
CRUNCHERS_LIST = [garlicsim.asynchronous_crunching.crunchers.ThreadCruncher]
########NEW FILE########
__FILENAME__ = state
import garlicsim.data_structures


class State(garlicsim.data_structures.State):
    
    def __init__(self):
        pass
    
    def step(self):
        return State()
        
    @staticmethod
    def create_root():
        return State()
    
########NEW FILE########
__FILENAME__ = _test_settings
from garlicsim.general_misc import import_tools

import garlicsim

from .state import State

ENDABLE = False
PROBLEM = None
VALID = True
CONSTANT_CLOCK_INTERVAL = None
HISTORY_DEPENDENT = False
N_STEP_FUNCTIONS = 1
DEFAULT_STEP_FUNCTION = State.step
DEFAULT_STEP_FUNCTION_TYPE = \
    garlicsim.misc.simpack_grokker.step_types.SimpleStep
CRUNCHERS_LIST = \
    [garlicsim.asynchronous_crunching.crunchers.ThreadCruncher] + \
    (
        [garlicsim.asynchronous_crunching.crunchers.ProcessCruncher] if 
        import_tools.exists('multiprocessing')
        else []
    )
########NEW FILE########
__FILENAME__ = settings
import garlicsim

CRUNCHERS = garlicsim.asynchronous_crunching.crunchers.ThreadCruncher
########NEW FILE########
__FILENAME__ = state
import garlicsim.data_structures


class State(garlicsim.data_structures.State):
    
    def __init__(self):
        pass
    
    def step(self):
        return State()
        
    @staticmethod
    def create_root():
        return State()
    
########NEW FILE########
__FILENAME__ = _test_settings
import garlicsim

from .state import State

ENDABLE = False
PROBLEM = None
VALID = True
CONSTANT_CLOCK_INTERVAL = None
HISTORY_DEPENDENT = False
N_STEP_FUNCTIONS = 1
DEFAULT_STEP_FUNCTION = State.step
DEFAULT_STEP_FUNCTION_TYPE = \
    garlicsim.misc.simpack_grokker.step_types.SimpleStep
CRUNCHERS_LIST = [garlicsim.asynchronous_crunching.crunchers.ThreadCruncher]
########NEW FILE########
__FILENAME__ = settings
import garlicsim

CRUNCHERS = [garlicsim.asynchronous_crunching.crunchers.ThreadCruncher]
########NEW FILE########
__FILENAME__ = state
import garlicsim.data_structures


class State(garlicsim.data_structures.State):
    
    def __init__(self):
        pass
    
    def step(self):
        return State()
        
    @staticmethod
    def create_root():
        return State()
    
########NEW FILE########
__FILENAME__ = _test_settings
import garlicsim

from .state import State

ENDABLE = False
PROBLEM = None
VALID = True
CONSTANT_CLOCK_INTERVAL = None
HISTORY_DEPENDENT = False
N_STEP_FUNCTIONS = 1
DEFAULT_STEP_FUNCTION = State.step
DEFAULT_STEP_FUNCTION_TYPE = \
    garlicsim.misc.simpack_grokker.step_types.SimpleStep
CRUNCHERS_LIST = [garlicsim.asynchronous_crunching.crunchers.ThreadCruncher]
########NEW FILE########
__FILENAME__ = settings
import garlicsim


def CRUNCHERS(cruncher_type):
    return cruncher_type is \
        garlicsim.asynchronous_crunching.crunchers.ThreadCruncher
########NEW FILE########
__FILENAME__ = state
import garlicsim.data_structures


class State(garlicsim.data_structures.State):
    
    def __init__(self):
        pass
    
    def step(self):
        return State()
        
    @staticmethod
    def create_root():
        return State()
    
########NEW FILE########
__FILENAME__ = _test_settings
import garlicsim

from .state import State

ENDABLE = False
PROBLEM = None
VALID = True
CONSTANT_CLOCK_INTERVAL = None
HISTORY_DEPENDENT = False
N_STEP_FUNCTIONS = 1
DEFAULT_STEP_FUNCTION = State.step
DEFAULT_STEP_FUNCTION_TYPE = \
    garlicsim.misc.simpack_grokker.step_types.SimpleStep
CRUNCHERS_LIST = [garlicsim.asynchronous_crunching.crunchers.ThreadCruncher]
########NEW FILE########
__FILENAME__ = settings
CRUNCHERS = 'ThreadCruncher'
########NEW FILE########
__FILENAME__ = state
import garlicsim.data_structures


class State(garlicsim.data_structures.State):
    
    def __init__(self):
        pass
    
    def step(self):
        return State()
        
    @staticmethod
    def create_root():
        return State()
    
########NEW FILE########
__FILENAME__ = _test_settings
import garlicsim

from .state import State

ENDABLE = False
PROBLEM = None
VALID = True
CONSTANT_CLOCK_INTERVAL = None
HISTORY_DEPENDENT = False
N_STEP_FUNCTIONS = 1
DEFAULT_STEP_FUNCTION = State.step
DEFAULT_STEP_FUNCTION_TYPE = \
    garlicsim.misc.simpack_grokker.step_types.SimpleStep
CRUNCHERS_LIST = [garlicsim.asynchronous_crunching.crunchers.ThreadCruncher]
########NEW FILE########
__FILENAME__ = settings
CRUNCHERS = ['ThreadCruncher']
########NEW FILE########
__FILENAME__ = state
import garlicsim.data_structures


class State(garlicsim.data_structures.State):
    
    def __init__(self):
        pass
    
    def step(self):
        return State()
        
    @staticmethod
    def create_root():
        return State()
    
########NEW FILE########
__FILENAME__ = _test_settings
import garlicsim

from .state import State

ENDABLE = False
PROBLEM = None
VALID = True
CONSTANT_CLOCK_INTERVAL = None
HISTORY_DEPENDENT = False
N_STEP_FUNCTIONS = 1
DEFAULT_STEP_FUNCTION = State.step
DEFAULT_STEP_FUNCTION_TYPE = \
    garlicsim.misc.simpack_grokker.step_types.SimpleStep
CRUNCHERS_LIST = [garlicsim.asynchronous_crunching.crunchers.ThreadCruncher]
########NEW FILE########
__FILENAME__ = state
import garlicsim.data_structures


class State(garlicsim.data_structures.State):
    
    def __init__(self):
        pass
    
    @garlicsim.misc.simpack_grokker.step_types.SimpleStep
    def ooga_booga(self):
        return State()
        
    @staticmethod
    def create_root():
        return State()
    
########NEW FILE########
__FILENAME__ = _test_settings
from garlicsim.general_misc import import_tools

import garlicsim

from .state import State

ENDABLE = False
PROBLEM = None
VALID = True
CONSTANT_CLOCK_INTERVAL = None
HISTORY_DEPENDENT = False
N_STEP_FUNCTIONS = 1
DEFAULT_STEP_FUNCTION = State.ooga_booga
DEFAULT_STEP_FUNCTION_TYPE = \
    garlicsim.misc.simpack_grokker.step_types.SimpleStep
CRUNCHERS_LIST = \
    [garlicsim.asynchronous_crunching.crunchers.ThreadCruncher] + \
    (
        [garlicsim.asynchronous_crunching.crunchers.ProcessCruncher] if 
        import_tools.exists('multiprocessing')
        else []
    )
########NEW FILE########
__FILENAME__ = state
import garlicsim.data_structures


class State(garlicsim.data_structures.State):
    
    def __init__(self):
        pass
    
    def step(self):
        return State()
    
    def step_generator(self):
        current_state = self
        while True:
            current_state = current_state.step()
            yield current_state
        
    @staticmethod
    def create_root():
        return State()
    
########NEW FILE########
__FILENAME__ = _test_settings
from garlicsim.general_misc import import_tools

import garlicsim

from .state import State

ENDABLE = False
PROBLEM = None
VALID = True
CONSTANT_CLOCK_INTERVAL = None
HISTORY_DEPENDENT = False
N_STEP_FUNCTIONS = 2
DEFAULT_STEP_FUNCTION = State.step_generator
DEFAULT_STEP_FUNCTION_TYPE = \
    garlicsim.misc.simpack_grokker.step_types.SimpleStep
CRUNCHERS_LIST = \
    [garlicsim.asynchronous_crunching.crunchers.ThreadCruncher] + \
    (
        [garlicsim.asynchronous_crunching.crunchers.ProcessCruncher] if 
        import_tools.exists('multiprocessing')
        else []
    )
########NEW FILE########
__FILENAME__ = state
import garlicsim.data_structures

    
########NEW FILE########
__FILENAME__ = _test_settings
from garlicsim.general_misc import import_tools
from garlicsim.general_misc.reasoned_bool import ReasonedBool

import garlicsim
from garlicsim.misc import InvalidSimpack



ENDABLE = False
PROBLEM = None
VALID = ReasonedBool(
    False,
    reason=InvalidSimpack("The `simpack_without_state_class` simpack does not "
                          "define a `State` class.")
)
CONSTANT_CLOCK_INTERVAL = None
HISTORY_DEPENDENT = False
N_STEP_FUNCTIONS = 0
DEFAULT_STEP_FUNCTION = None
DEFAULT_STEP_FUNCTION_TYPE = None
CRUNCHERS_LIST = \
    [garlicsim.asynchronous_crunching.crunchers.ThreadCruncher] + \
    (
        [garlicsim.asynchronous_crunching.crunchers.ProcessCruncher] if 
        import_tools.exists('multiprocessing')
        else []
    )
########NEW FILE########
__FILENAME__ = state
import garlicsim.data_structures


class State(garlicsim.data_structures.State):
    
    def __init__(self):
        pass
        
    @staticmethod
    def create_root():
        return State()
    
########NEW FILE########
__FILENAME__ = _test_settings
from garlicsim.general_misc import import_tools
from garlicsim.general_misc.reasoned_bool import ReasonedBool

import garlicsim
from garlicsim.misc import InvalidSimpack


from .state import State

ENDABLE = False
PROBLEM = None
VALID = ReasonedBool(
    False,
    reason=InvalidSimpack("The `simpack_without_step_function` simpack has "
                          "not defined any kind of step function.")
)
CONSTANT_CLOCK_INTERVAL = None
HISTORY_DEPENDENT = False
N_STEP_FUNCTIONS = 0
DEFAULT_STEP_FUNCTION = None
DEFAULT_STEP_FUNCTION_TYPE = None
CRUNCHERS_LIST = \
    [garlicsim.asynchronous_crunching.crunchers.ThreadCruncher] + \
    (
        [garlicsim.asynchronous_crunching.crunchers.ProcessCruncher] if 
        import_tools.exists('multiprocessing')
        else []
    )
########NEW FILE########
__FILENAME__ = settings
CRUNCHERS = None
########NEW FILE########
__FILENAME__ = state
import garlicsim.data_structures


class State(garlicsim.data_structures.State):
    
    def __init__(self):
        pass
    
    def step(self):
        return State()
        
    @staticmethod
    def create_root():
        return State()
    
########NEW FILE########
__FILENAME__ = _test_settings
from garlicsim.general_misc import import_tools
from garlicsim.general_misc.reasoned_bool import ReasonedBool

import garlicsim
from garlicsim.misc import InvalidSimpack

from .state import State


ENDABLE = False
PROBLEM = None
VALID = ReasonedBool(
    False,
    reason=InvalidSimpack("The `CRUNCHERS` setting must be either a "
                          "cruncher type (or name string), a list of "
                          "cruncher types, or a filter function for "
                          "cruncher types. You supplied `None`, which is "
                          "neither.")
)
CONSTANT_CLOCK_INTERVAL = None
HISTORY_DEPENDENT = False
N_STEP_FUNCTIONS = 1
DEFAULT_STEP_FUNCTION = None
DEFAULT_STEP_FUNCTION_TYPE = None
CRUNCHERS_LIST = \
    [garlicsim.asynchronous_crunching.crunchers.ThreadCruncher] + \
    (
        [garlicsim.asynchronous_crunching.crunchers.ProcessCruncher] if 
        import_tools.exists('multiprocessing')
        else []
    )
########NEW FILE########
__FILENAME__ = state
import garlicsim.data_structures


class State(object):
    
    def __init__(self):
        pass
    
    def step(self):
        return State()
        
    @staticmethod
    def create_root():
        return State()
    
########NEW FILE########
__FILENAME__ = _test_settings
from garlicsim.general_misc import import_tools
from garlicsim.general_misc.reasoned_bool import ReasonedBool

import garlicsim
from garlicsim.misc import InvalidSimpack

from .state import State


ENDABLE = False
PROBLEM = None
VALID = ReasonedBool(
    False,
    reason=InvalidSimpack("The `simpack_with_bad_state_class` simpack "
                          "defines a `State` class, but it's not a subclass "
                          "of `garlicsim.data_structures.State`.")
)
CONSTANT_CLOCK_INTERVAL = None
HISTORY_DEPENDENT = False
N_STEP_FUNCTIONS = 0
DEFAULT_STEP_FUNCTION = None
DEFAULT_STEP_FUNCTION_TYPE = None
CRUNCHERS_LIST = \
    [garlicsim.asynchronous_crunching.crunchers.ThreadCruncher] + \
    (
        [garlicsim.asynchronous_crunching.crunchers.ProcessCruncher] if 
        import_tools.exists('multiprocessing')
        else []
    )
########NEW FILE########
__FILENAME__ = state
import garlicsim.data_structures


class State(garlicsim.data_structures.State):
    
    def __init__(self):
        pass
    
    def step(self):
        return State()
    
    @staticmethod
    def history_step(history_browser):
        raise NotImplementedError
        yield None
        
    @staticmethod
    def create_root():
        return State()
    
########NEW FILE########
__FILENAME__ = _test_settings
from garlicsim.general_misc import import_tools
from garlicsim.general_misc.reasoned_bool import ReasonedBool

import garlicsim
from garlicsim.misc import InvalidSimpack

from .state import State


ENDABLE = False
PROBLEM = None
VALID = ReasonedBool(
    False,
    reason=InvalidSimpack("The `simpack_with_both_history_and_non_history` "
                          "simpack is defining both a history-dependent step "
                          "and a non-history-dependent step - which is "
                          "forbidden.")
)
CONSTANT_CLOCK_INTERVAL = None
HISTORY_DEPENDENT = False
N_STEP_FUNCTIONS = 2
DEFAULT_STEP_FUNCTION = None
DEFAULT_STEP_FUNCTION_TYPE = None
CRUNCHERS_LIST = \
    [garlicsim.asynchronous_crunching.crunchers.ThreadCruncher] + \
    (
        [garlicsim.asynchronous_crunching.crunchers.ProcessCruncher] if 
        import_tools.exists('multiprocessing')
        else []
    )
########NEW FILE########
__FILENAME__ = test_invalid_simpacks
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Testing module for invalid simpacks.'''

from __future__ import with_statement

import os

import nose

from garlicsim.general_misc import import_tools
from garlicsim.general_misc import path_tools
from garlicsim.general_misc import cute_testing
from garlicsim.general_misc.reasoned_bool import ReasonedBool

import garlicsim
from garlicsim.misc.simpack_grokker import SimpackGrokker
from garlicsim.misc.exceptions import InvalidSimpack

import test_garlicsim


def test_simpacks():
    '''Test invalid simpacks.'''
    from . import simpacks as invalid_simpacks_package
    
    # Collecting all the test simpacks:
    simpacks = import_tools.import_all(invalid_simpacks_package).values()
    
    # Making sure that we didn't miss any simpack by counting the number of
    # sub-folders in the `simpacks` folder:
    simpacks_dir = \
        os.path.dirname(invalid_simpacks_package.__file__)
    assert len(path_tools.list_sub_folders(simpacks_dir)) == \
           len(simpacks)
    
    for simpack in simpacks:
        test_garlicsim.verify_simpack_settings(simpack)
        yield check_simpack, simpack

        
def check_simpack(simpack):
    '''Check that the invalid `simpack` raises the correct exception.'''
    _test_settings = simpack._test_settings
    VALID = _test_settings.VALID
    assert not VALID
    assert isinstance(VALID, ReasonedBool)
    exception_we_should_get = VALID.reason
    assert isinstance(exception_we_should_get, InvalidSimpack)
    
    with cute_testing.RaiseAssertor(type(exception_we_should_get),
                                    exception_we_should_get.message,
                                    assert_exact_type=True):
        
        SimpackGrokker(simpack)
########NEW FILE########
__FILENAME__ = settings
# Raising an `ImportError` intentionally to see that `SimpackGrokker`
# doesn't ignore it:
raise ImportError('Artifical `ImportError`.')
########NEW FILE########
__FILENAME__ = state
import garlicsim.data_structures


class State(garlicsim.data_structures.State):
    
    def __init__(self):
        pass
    
    def step(self):
        return State()
        
    @staticmethod
    def create_root():
        return State()
    
########NEW FILE########
__FILENAME__ = _test_settings
from garlicsim.general_misc import import_tools

import garlicsim

from .state import State


PROBLEM = ImportError
ENDABLE = False
VALID = False
CONSTANT_CLOCK_INTERVAL = None
HISTORY_DEPENDENT = False
N_STEP_FUNCTIONS = 0
DEFAULT_STEP_FUNCTION = None
DEFAULT_STEP_FUNCTION_TYPE = None
CRUNCHERS_LIST = \
    [garlicsim.asynchronous_crunching.crunchers.ThreadCruncher] + \
    (
        [garlicsim.asynchronous_crunching.crunchers.ProcessCruncher] if 
        import_tools.exists('multiprocessing')
        else []
    )
########NEW FILE########
__FILENAME__ = settings
ooga booga, i am a syntax error
########NEW FILE########
__FILENAME__ = state
import garlicsim.data_structures


class State(garlicsim.data_structures.State):
    
    def __init__(self):
        pass
    
    def step(self):
        return State()
        
    @staticmethod
    def create_root():
        return State()
    
########NEW FILE########
__FILENAME__ = _test_settings
from garlicsim.general_misc import import_tools

import garlicsim

from .state import State


PROBLEM = SyntaxError
ENDABLE = False
VALID = False
CONSTANT_CLOCK_INTERVAL = None
HISTORY_DEPENDENT = False
N_STEP_FUNCTIONS = 0
DEFAULT_STEP_FUNCTION = None
DEFAULT_STEP_FUNCTION_TYPE = None
CRUNCHERS_LIST = \
    [garlicsim.asynchronous_crunching.crunchers.ThreadCruncher] + \
    (
        [garlicsim.asynchronous_crunching.crunchers.ProcessCruncher] if 
        import_tools.exists('multiprocessing')
        else []
    )
########NEW FILE########
__FILENAME__ = settings
# Raising a `ZeroDivisionError` intentionally to see that `SimpackGrokker`
# doesn't ignore it:
1/0
########NEW FILE########
__FILENAME__ = state
import garlicsim.data_structures


class State(garlicsim.data_structures.State):
    
    def __init__(self):
        pass
    
    def step(self):
        return State()
        
    @staticmethod
    def create_root():
        return State()
    
########NEW FILE########
__FILENAME__ = _test_settings
from garlicsim.general_misc import import_tools

import garlicsim

from .state import State


PROBLEM = ZeroDivisionError
ENDABLE = False
VALID = False
CONSTANT_CLOCK_INTERVAL = None
HISTORY_DEPENDENT = False
N_STEP_FUNCTIONS = 0
DEFAULT_STEP_FUNCTION = None
DEFAULT_STEP_FUNCTION_TYPE = None
CRUNCHERS_LIST = \
    [garlicsim.asynchronous_crunching.crunchers.ThreadCruncher] + \
    (
        [garlicsim.asynchronous_crunching.crunchers.ProcessCruncher] if 
        import_tools.exists('multiprocessing')
        else []
    )
########NEW FILE########
__FILENAME__ = test_problematic_simpacks
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Testing module for problematic simpacks.'''

from __future__ import with_statement

import os

import nose

from garlicsim.general_misc import import_tools
from garlicsim.general_misc import path_tools
from garlicsim.general_misc import cute_testing
from garlicsim.general_misc.reasoned_bool import ReasonedBool

import garlicsim
from garlicsim.misc.simpack_grokker import SimpackGrokker
from garlicsim.misc.exceptions import InvalidSimpack

import test_garlicsim


def test_simpacks():
    '''Test problematic simpacks.'''
    from . import simpacks as problematic_simpacks_package
    
    # Collecting all the test simpacks:
    simpacks = import_tools.import_all(problematic_simpacks_package).values()
    
    # Making sure that we didn't miss any simpack by counting the number of
    # sub-folders in the `simpacks` folder:
    simpacks_dir = \
        os.path.dirname(problematic_simpacks_package.__file__)
    assert len(
        path_tools.list_sub_folders(simpacks_dir)
        ) == len(simpacks)
    
    for simpack in simpacks:
        test_garlicsim.verify_simpack_settings(simpack)
        yield check_simpack, simpack

        
def check_simpack(simpack):
    '''Check that the problematic `simpack` raises the correct exception.'''
    _test_settings = simpack._test_settings
    PROBLEM = _test_settings.PROBLEM
    assert PROBLEM
    assert issubclass(PROBLEM, Exception)
           
    with cute_testing.RaiseAssertor(PROBLEM, assert_exact_type=True):
        SimpackGrokker(simpack)
########NEW FILE########
__FILENAME__ = test_simpack_grokker
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

import os

import nose

from garlicsim.general_misc import sequence_tools
from garlicsim.general_misc import import_tools
from garlicsim.general_misc import path_tools

import garlicsim
from garlicsim.misc.simpack_grokker import SimpackGrokker, Settings
from garlicsim.misc.simpack_grokker.step_type import StepType, BaseStep

import test_garlicsim


def test_simpacks():
    from . import simpacks as simpacks_package
    
    # Collecting all the test simpacks:
    simpacks = import_tools.import_all(simpacks_package).values()
    
    # Making sure that we didn't miss any simpack by counting the number of
    # sub-folders in the `simpacks` folder:
    simpacks_dir = os.path.dirname(simpacks_package.__file__)
    assert len(path_tools.list_sub_folders(simpacks_dir)) == \
           len(simpacks)
    
    for simpack in simpacks:
        test_garlicsim.verify_simpack_settings(simpack)
        yield check_simpack, simpack

        
def check_simpack(simpack):

    _test_settings = simpack._test_settings
    
    simpack_grokker = SimpackGrokker(simpack)
    

    # Test the caching:
    assert simpack_grokker is SimpackGrokker(simpack)

    
    step_profile = simpack_grokker.build_step_profile()
    assert step_profile.function == simpack_grokker.default_step_function
    assert isinstance(step_profile, garlicsim.misc.StepProfile)
    assert (not step_profile.args) and (not step_profile.kwargs)

    
    assert len(simpack_grokker.all_step_functions) == \
           _test_settings.N_STEP_FUNCTIONS 

    
    state = simpack.State.create_root()
    assert SimpackGrokker.create_from_state(state) is simpack_grokker

    
    assert simpack_grokker.available_cruncher_types == \
           simpack._test_settings.CRUNCHERS_LIST
    assert simpack_grokker.available_cruncher_types == \
           [cruncher for cruncher, availability in 
            simpack_grokker.cruncher_types_availability.items()
            if availability]    
    assert all(        
        issubclass(cruncher, garlicsim.asynchronous_crunching.BaseCruncher)
        for cruncher in simpack_grokker.cruncher_types_availability.keys()
    )

    
    assert simpack_grokker.default_step_function == \
           _test_settings.DEFAULT_STEP_FUNCTION
    
    
    assert simpack_grokker.history_dependent == \
           _test_settings.HISTORY_DEPENDENT

    
    settings = simpack_grokker.settings
    assert isinstance(settings, Settings)
    assert callable(settings.DETERMINISM_FUNCTION)

    
    if not simpack_grokker.history_dependent:
        assert isinstance(simpack_grokker.step(state, step_profile),
                          simpack.State)        
        iterator = simpack_grokker.get_step_iterator(state, step_profile)
        assert iterator.__iter__() is iterator

    
    step_types = simpack_grokker.step_functions_by_type.keys()
    assert all(issubclass(step_type, BaseStep) for step_type in step_types)
    
    # Fetched in a different way than `simpack_grokker.all_step_functions`:
    all_step_functions = sequence_tools.flatten(
        simpack_grokker.step_functions_by_type.values()
    )
    assert all(
        issubclass(StepType.get_step_type(step_function), BaseStep) for
        step_function in all_step_functions
    )
    assert len(all_step_functions) == _test_settings.N_STEP_FUNCTIONS
    
    
    
    

    
    
########NEW FILE########
__FILENAME__ = test
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

import sys

import nose.tools

from garlicsim.misc.simpack_grokker.step_type import BaseStep, StepType
from garlicsim.misc.simpack_grokker import step_types as step_types_module

step_types = [thing for thing in vars(step_types_module).values() if 
              getattr(thing, '__module__', '').endswith('step_types')]

def test():
    assert type(BaseStep) is StepType
    for step_type in step_types:
        assert issubclass(step_type, BaseStep)
        assert type(step_type) is StepType
     
        
def test_uncached_step_function():
    
    if sys.version_info[:2] <= (2, 5):
        raise nose.SkipTest("Python 2.5 doesn't use `__instancecheck__`.")
    
    def my_step(state):
        raise NotImplementedError()
    
    assert not hasattr(my_step, '_BaseStepType__step_type')
    
    assert isinstance(my_step, BaseStep)
    
    
    assert hasattr(my_step, '_BaseStepType__step_type')
    
    assert isinstance(my_step, step_types_module.SimpleStep)
     
        
def test_uncached_step_function_25():
    
    def my_step(state):
        raise NotImplementedError()
    
    assert not hasattr(my_step, '_BaseStepType__step_type')
    
    assert BaseStep.__instancecheck__(my_step)
    
    
    assert hasattr(my_step, '_BaseStepType__step_type')
    
    assert step_types_module.SimpleStep.__instancecheck__(my_step)
########NEW FILE########
__FILENAME__ = state
import garlicsim.data_structures


class State(garlicsim.data_structures.State):
    
    def __init__(self):
        pass
    
    def step(self, a=1, b=2, c=3, *args, **kwargs):
        return State()
    
    def alternate_step(self, x=1, y=2, z=3):
        return State()
    
    @staticmethod
    def create_root():
        return State()
    
########NEW FILE########
__FILENAME__ = _test_settings
from garlicsim.general_misc import import_tools

import garlicsim

from .state import State

ENDABLE = False
PROBLEM = None
VALID = True
CONSTANT_CLOCK_INTERVAL = None
HISTORY_DEPENDENT = False
N_STEP_FUNCTIONS = 1
DEFAULT_STEP_FUNCTION = State.step
DEFAULT_STEP_FUNCTION_TYPE = \
    garlicsim.misc.simpack_grokker.step_types.SimpleStep
CRUNCHERS_LIST = \
    [garlicsim.asynchronous_crunching.crunchers.ThreadCruncher] + \
    (
        [garlicsim.asynchronous_crunching.crunchers.ProcessCruncher] if 
        import_tools.exists('multiprocessing')
        else []
    )
########NEW FILE########
__FILENAME__ = test_build_parser
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Testing module for `garlicsim.misc.StepProfile.build_parser`.'''

import nose.tools

import garlicsim
from test_garlicsim.shared import verify_simpack_settings

from garlicsim.misc import StepProfile

from . import simpack


def test():
    '''Test the basic workings of `StepProfile.build_parser`.'''
    
    verify_simpack_settings(simpack)
    simpack_grokker = garlicsim.misc.SimpackGrokker(simpack)
    
    parse = StepProfile.build_parser(simpack.State.step)
    alternate_parse = StepProfile.build_parser(simpack.State.alternate_step)
    none_parse = StepProfile.build_parser(None)
    
    
    default_step_profile = parse()
    
    step_profile = parse(1, 2, 3)
    assert step_profile == default_step_profile == StepProfile(
        simpack.State.step,
        1, 2, 3
    )
    assert step_profile == \
           alternate_parse(step_profile) == \
           none_parse(step_profile) == \
           alternate_parse(step_profile=step_profile)
    
    assert parse(step_profile=None) == step_profile
    
    
    different_step_profile = parse(4, 5, 6, meow='frrr')
    assert different_step_profile == parse(a=4, c=6, b=5, meow='frrr', **{})
    assert different_step_profile == parse(different_step_profile)
    assert different_step_profile == parse(step_profile=different_step_profile)
    
    assert different_step_profile != step_profile
    

    alternate_step_profile = alternate_parse()
    assert alternate_step_profile == alternate_parse(z=3) == \
           alternate_parse(1, y=2)
    assert alternate_parse(step_profile.step_function, 4, 5, 6) == \
           alternate_parse(
               step_function=step_profile.step_function, a=4, b=5, c=6
               ) == \
           parse(4, 5, 6)
    assert alternate_parse(step_profile=step_profile) == step_profile
    
    assert none_parse(step_profile) == step_profile
    assert none_parse(step_profile=step_profile) == step_profile
    assert none_parse(different_step_profile) == different_step_profile
    assert none_parse(step_profile.step_function) == step_profile
    assert none_parse(step_function=alternate_step_profile.step_function) == \
           alternate_step_profile
    assert none_parse(alternate_step_profile.step_function, 2) == \
           alternate_parse(x=2)
    
    # Step function or step profile must be given to `none_parse`:
    nose.tools.assert_raises(
        Exception,
        lambda: none_parse(1, 2, 3, 4, 5)
    )
    
    # `alternate_step` doesn't take **kwargs:
    nose.tools.assert_raises(
        Exception,
        lambda: alternate_parse(boom='kaplaow')
    )
########NEW FILE########
__FILENAME__ = test_start_simpack
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

from __future__ import with_statement

import tempfile
import shutil
import glob

from garlicsim.general_misc import sys_tools
from garlicsim.general_misc import temp_file_tools
from garlicsim.general_misc.temp_value_setters import \
     TempWorkingDirectorySetter

import garlicsim.scripts


_help_text = '''
Script for starting a new simpack.

This is a script for creating a skeleton for a `garlicsim` simpack. Use this
when you want to make a new simpack to have the basic folders and files created
for you.

Usage:

    start_simpack.py my_simpack_name

The simpack will be created in the current path, in a directory with the name
of the simpack.
'''
        

def test_implicit_help():
    '''Test help text comes up when giving no arguments.'''
    with temp_file_tools.TemporaryFolder(prefix='temp_test_garlicsim_') \
                                                          as temp_folder:
        with TempWorkingDirectorySetter(temp_folder):
            with sys_tools.OutputCapturer() as output_capturer:
                garlicsim.scripts.start_simpack.start(
                    argv=['start_simpack.py']
                )
            assert output_capturer.output == _help_text + '\n'
            assert glob.glob('*') == []
        

def test_explicit_help():
    '''Test help text comes up when '--help' argument.'''
    with temp_file_tools.TemporaryFolder(prefix='temp_test_garlicsim_') \
                                                          as temp_folder:
        with TempWorkingDirectorySetter(temp_folder):
            with sys_tools.OutputCapturer() as output_capturer:
                garlicsim.scripts.start_simpack.start(
                    argv=['start_simpack.py', '--help']
                )
            assert output_capturer.output == _help_text + '\n'
            assert glob.glob('*') == []
########NEW FILE########
__FILENAME__ = forked_mapping_tests
from garlicsim.general_misc.third_party import unittest2

__test__ = False

class BasicTestMappingProtocol(unittest2.TestCase):
    # This base class can be used to check that an object conforms to the
    # mapping protocol

    # Functions that can be useful to override to adapt to dictionary
    # semantics
    type2test = None # which class is being tested (overwrite in subclasses)

    def _reference(self):
        """Return a dictionary of values which are invariant by storage
        in the object under test."""
        return {1:2, "key1":"value1", "key2":(1,2,3)}
    def _empty_mapping(self):
        """Return an empty mapping object"""
        return self.type2test()
    def _full_mapping(self, data):
        """Return a mapping object with the value contained in data
        dictionary"""
        x = self._empty_mapping()
        for key, value in data.items():
            x[key] = value
        return x

    def __init__(self, *args, **kw):
        unittest2.TestCase.__init__(self, *args, **kw)
        self.reference = self._reference().copy()

        # A (key, value) pair not in the mapping
        key, value = self.reference.popitem()
        self.other = {key:value}

        # A (key, value) pair in the mapping
        key, value = self.reference.popitem()
        self.inmapping = {key:value}
        self.reference[key] = value

    def test_read(self):
        # Test for read only operations on mapping
        p = self._empty_mapping()
        p1 = dict(p) #workaround for singleton objects
        d = self._full_mapping(self.reference)
        if d is p:
            p = p1
        #Indexing
        for key, value in self.reference.items():
            self.assertEqual(d[key], value)
        knownkey = self.other.keys()[0]
        self.assertRaises(KeyError, lambda:d[knownkey])
        #len
        self.assertEqual(len(p), 0)
        self.assertEqual(len(d), len(self.reference))
        #in
        for k in self.reference:
            self.assertIn(k, d)
        for k in self.other:
            self.assertNotIn(k, d)
        #cmp
        self.assertEqual(cmp(p,p), 0)
        self.assertEqual(cmp(d,d), 0)
        self.assertEqual(cmp(p,d), -1)
        self.assertEqual(cmp(d,p), 1)
        #__non__zero__
        if p: self.fail("Empty mapping must compare to False")
        if not d: self.fail("Full mapping must compare to True")
        # keys(), items(), iterkeys() ...
        def check_iterandlist(iter, lst, ref):
            self.assertTrue(hasattr(iter, 'next'))
            self.assertTrue(hasattr(iter, '__iter__'))
            x = list(iter)
            self.assertTrue(set(x)==set(lst)==set(ref))
        check_iterandlist(d.iterkeys(), d.keys(), self.reference.keys())
        check_iterandlist(iter(d), d.keys(), self.reference.keys())
        check_iterandlist(d.itervalues(), d.values(), self.reference.values())
        check_iterandlist(d.iteritems(), d.items(), self.reference.items())
        #get
        key, value = d.iteritems().next()
        knownkey, knownvalue = self.other.iteritems().next()
        self.assertEqual(d.get(key, knownvalue), value)
        self.assertEqual(d.get(knownkey, knownvalue), knownvalue)
        self.assertNotIn(knownkey, d)

    def test_write(self):
        # Test for write operations on mapping
        p = self._empty_mapping()
        #Indexing
        for key, value in self.reference.items():
            p[key] = value
            self.assertEqual(p[key], value)
        for key in self.reference.keys():
            del p[key]
            self.assertRaises(KeyError, lambda:p[key])
        p = self._empty_mapping()
        #update
        p.update(self.reference)
        self.assertEqual(dict(p), self.reference)
        items = p.items()
        p = self._empty_mapping()
        p.update(items)
        self.assertEqual(dict(p), self.reference)
        d = self._full_mapping(self.reference)
        #setdefault
        key, value = d.iteritems().next()
        knownkey, knownvalue = self.other.iteritems().next()
        self.assertEqual(d.setdefault(key, knownvalue), value)
        self.assertEqual(d[key], value)
        self.assertEqual(d.setdefault(knownkey, knownvalue), knownvalue)
        self.assertEqual(d[knownkey], knownvalue)
        #pop
        self.assertEqual(d.pop(knownkey), knownvalue)
        self.assertNotIn(knownkey, d)
        self.assertRaises(KeyError, d.pop, knownkey)
        default = 909
        d[knownkey] = knownvalue
        self.assertEqual(d.pop(knownkey, default), knownvalue)
        self.assertNotIn(knownkey, d)
        self.assertEqual(d.pop(knownkey, default), default)
        #popitem
        key, value = d.popitem()
        self.assertNotIn(key, d)
        self.assertEqual(value, self.reference[key])
        p=self._empty_mapping()
        self.assertRaises(KeyError, p.popitem)

    def test_constructor(self):
        self.assertEqual(self._empty_mapping(), self._empty_mapping())

    def test_bool(self):
        self.assertTrue(not self._empty_mapping())
        self.assertTrue(self.reference)
        self.assertTrue(bool(self._empty_mapping()) is False)
        self.assertTrue(bool(self.reference) is True)

    def test_keys(self):
        d = self._empty_mapping()
        self.assertEqual(d.keys(), [])
        d = self.reference
        self.assertIn(self.inmapping.keys()[0], d.keys())
        self.assertNotIn(self.other.keys()[0], d.keys())
        self.assertRaises(TypeError, d.keys, None)

    def test_values(self):
        d = self._empty_mapping()
        self.assertEqual(d.values(), [])

        self.assertRaises(TypeError, d.values, None)

    def test_items(self):
        d = self._empty_mapping()
        self.assertEqual(d.items(), [])

        self.assertRaises(TypeError, d.items, None)

    def test_len(self):
        d = self._empty_mapping()
        self.assertEqual(len(d), 0)

    def test_getitem(self):
        d = self.reference
        self.assertEqual(d[self.inmapping.keys()[0]], self.inmapping.values()[0])

        self.assertRaises(TypeError, d.__getitem__)

    def test_update(self):
        # mapping argument
        d = self._empty_mapping()
        d.update(self.other)
        self.assertEqual(d.items(), self.other.items())

        # No argument
        d = self._empty_mapping()
        d.update()
        self.assertEqual(d, self._empty_mapping())

        # item sequence
        d = self._empty_mapping()
        d.update(self.other.items())
        self.assertEqual(d.items(), self.other.items())

        # Iterator
        d = self._empty_mapping()
        d.update(self.other.iteritems())
        self.assertEqual(d.items(), self.other.items())

        # FIXME: Doesn't work with UserDict
        # self.assertRaises((TypeError, AttributeError), d.update, None)
        self.assertRaises((TypeError, AttributeError), d.update, 42)

        outerself = self
        class SimpleUserDict:
            def __init__(self):
                self.d = outerself.reference
            def keys(self):
                return self.d.keys()
            def __getitem__(self, i):
                return self.d[i]
        d.clear()
        d.update(SimpleUserDict())
        i1 = d.items()
        i2 = self.reference.items()
        i1.sort()
        i2.sort()
        self.assertEqual(i1, i2)

        class Exc(Exception): pass

        d = self._empty_mapping()
        class FailingUserDict:
            def keys(self):
                raise Exc
        self.assertRaises(Exc, d.update, FailingUserDict())

        d.clear()

        class FailingUserDict:
            def keys(self):
                class BogonIter:
                    def __init__(self):
                        self.i = 1
                    def __iter__(self):
                        return self
                    def next(self):
                        if self.i:
                            self.i = 0
                            return 'a'
                        raise Exc
                return BogonIter()
            def __getitem__(self, key):
                return key
        self.assertRaises(Exc, d.update, FailingUserDict())

        class FailingUserDict:
            def keys(self):
                class BogonIter:
                    def __init__(self):
                        self.i = ord('a')
                    def __iter__(self):
                        return self
                    def next(self):
                        if self.i <= ord('z'):
                            rtn = chr(self.i)
                            self.i += 1
                            return rtn
                        raise StopIteration
                return BogonIter()
            def __getitem__(self, key):
                raise Exc
        self.assertRaises(Exc, d.update, FailingUserDict())

        d = self._empty_mapping()
        class badseq(object):
            def __iter__(self):
                return self
            def next(self):
                raise Exc()

        self.assertRaises(Exc, d.update, badseq())

        self.assertRaises(ValueError, d.update, [(1, 2, 3)])

    # no test_fromkeys or test_copy as both os.environ and selves don't support it

    def test_get(self):
        d = self._empty_mapping()
        self.assertTrue(d.get(self.other.keys()[0]) is None)
        self.assertEqual(d.get(self.other.keys()[0], 3), 3)
        d = self.reference
        self.assertTrue(d.get(self.other.keys()[0]) is None)
        self.assertEqual(d.get(self.other.keys()[0], 3), 3)
        self.assertEqual(d.get(self.inmapping.keys()[0]), self.inmapping.values()[0])
        self.assertEqual(d.get(self.inmapping.keys()[0], 3), self.inmapping.values()[0])
        self.assertRaises(TypeError, d.get)
        self.assertRaises(TypeError, d.get, None, None, None)

    def test_setdefault(self):
        d = self._empty_mapping()
        self.assertRaises(TypeError, d.setdefault)

    def test_popitem(self):
        d = self._empty_mapping()
        self.assertRaises(KeyError, d.popitem)
        self.assertRaises(TypeError, d.popitem, 42)

    def test_pop(self):
        d = self._empty_mapping()
        k, v = self.inmapping.items()[0]
        d[k] = v
        self.assertRaises(KeyError, d.pop, self.other.keys()[0])

        self.assertEqual(d.pop(k), v)
        self.assertEqual(len(d), 0)

        self.assertRaises(KeyError, d.pop, k)


class TestMappingProtocol(BasicTestMappingProtocol):
    def test_constructor(self):
        BasicTestMappingProtocol.test_constructor(self)
        self.assertTrue(self._empty_mapping() is not self._empty_mapping())
        self.assertEqual(self.type2test(x=1, y=2), {"x": 1, "y": 2})

    def test_bool(self):
        BasicTestMappingProtocol.test_bool(self)
        self.assertTrue(not self._empty_mapping())
        self.assertTrue(self._full_mapping({"x": "y"}))
        self.assertTrue(bool(self._empty_mapping()) is False)
        self.assertTrue(bool(self._full_mapping({"x": "y"})) is True)

    def test_keys(self):
        BasicTestMappingProtocol.test_keys(self)
        d = self._empty_mapping()
        self.assertEqual(d.keys(), [])
        d = self._full_mapping({'a': 1, 'b': 2})
        k = d.keys()
        self.assertIn('a', k)
        self.assertIn('b', k)
        self.assertNotIn('c', k)

    def test_values(self):
        BasicTestMappingProtocol.test_values(self)
        d = self._full_mapping({1:2})
        self.assertEqual(d.values(), [2])

    def test_items(self):
        BasicTestMappingProtocol.test_items(self)

        d = self._full_mapping({1:2})
        self.assertEqual(d.items(), [(1, 2)])

    def test_has_key(self):
        d = self._empty_mapping()
        self.assertTrue(not d.has_key('a'))
        d = self._full_mapping({'a': 1, 'b': 2})
        k = d.keys()
        k.sort()
        self.assertEqual(k, ['a', 'b'])

        self.assertRaises(TypeError, d.has_key)

    def test_contains(self):
        d = self._empty_mapping()
        self.assertNotIn('a', d)
        self.assertTrue(not ('a' in d))
        self.assertTrue('a' not in d)
        d = self._full_mapping({'a': 1, 'b': 2})
        self.assertIn('a', d)
        self.assertIn('b', d)
        self.assertNotIn('c', d)

        self.assertRaises(TypeError, d.__contains__)

    def test_len(self):
        BasicTestMappingProtocol.test_len(self)
        d = self._full_mapping({'a': 1, 'b': 2})
        self.assertEqual(len(d), 2)

    def test_getitem(self):
        BasicTestMappingProtocol.test_getitem(self)
        d = self._full_mapping({'a': 1, 'b': 2})
        self.assertEqual(d['a'], 1)
        self.assertEqual(d['b'], 2)
        d['c'] = 3
        d['a'] = 4
        self.assertEqual(d['c'], 3)
        self.assertEqual(d['a'], 4)
        del d['b']
        self.assertEqual(d, {'a': 4, 'c': 3})

        self.assertRaises(TypeError, d.__getitem__)

    def test_clear(self):
        d = self._full_mapping({1:1, 2:2, 3:3})
        d.clear()
        self.assertEqual(d, {})

        self.assertRaises(TypeError, d.clear, None)

    def test_update(self):
        BasicTestMappingProtocol.test_update(self)
        # mapping argument
        d = self._empty_mapping()
        d.update({1:100})
        d.update({2:20})
        d.update({1:1, 2:2, 3:3})
        self.assertEqual(d, {1:1, 2:2, 3:3})

        # no argument
        d.update()
        self.assertEqual(d, {1:1, 2:2, 3:3})

        # keyword arguments
        d = self._empty_mapping()
        d.update(x=100)
        d.update(y=20)
        d.update(x=1, y=2, z=3)
        self.assertEqual(d, {"x":1, "y":2, "z":3})

        # item sequence
        d = self._empty_mapping()
        d.update([("x", 100), ("y", 20)])
        self.assertEqual(d, {"x":100, "y":20})

        # Both item sequence and keyword arguments
        d = self._empty_mapping()
        d.update([("x", 100), ("y", 20)], x=1, y=2)
        self.assertEqual(d, {"x":1, "y":2})

        # iterator
        d = self._full_mapping({1:3, 2:4})
        d.update(self._full_mapping({1:2, 3:4, 5:6}).iteritems())
        self.assertEqual(d, {1:2, 2:4, 3:4, 5:6})

        class SimpleUserDict:
            def __init__(self):
                self.d = {1:1, 2:2, 3:3}
            def keys(self):
                return self.d.keys()
            def __getitem__(self, i):
                return self.d[i]
        d.clear()
        d.update(SimpleUserDict())
        self.assertEqual(d, {1:1, 2:2, 3:3})

    def test_fromkeys(self):
        self.assertEqual(self.type2test.fromkeys('abc'), {'a':None, 'b':None, 'c':None})
        d = self._empty_mapping()
        self.assertTrue(not(d.fromkeys('abc') is d))
        self.assertEqual(d.fromkeys('abc'), {'a':None, 'b':None, 'c':None})
        self.assertEqual(d.fromkeys((4,5),0), {4:0, 5:0})
        self.assertEqual(d.fromkeys([]), {})
        def g():
            yield 1
        self.assertEqual(d.fromkeys(g()), {1:None})
        self.assertRaises(TypeError, {}.fromkeys, 3)
        class dictlike(self.type2test): pass
        self.assertEqual(dictlike.fromkeys('a'), {'a':None})
        self.assertEqual(dictlike().fromkeys('a'), {'a':None})
        self.assertTrue(dictlike.fromkeys('a').__class__ is dictlike)
        self.assertTrue(dictlike().fromkeys('a').__class__ is dictlike)
        # FIXME: the following won't work with UserDict, because it's an old style class
        # self.assertTrue(type(dictlike.fromkeys('a')) is dictlike)
        class mydict(self.type2test):
            def __new__(cls):
                return UserDict.UserDict()
        ud = mydict.fromkeys('ab')
        self.assertEqual(ud, {'a':None, 'b':None})
        # FIXME: the following won't work with UserDict, because it's an old style class
        # self.assertIsInstance(ud, UserDict.UserDict)
        self.assertRaises(TypeError, dict.fromkeys)

        class Exc(Exception): pass

        class baddict1(self.type2test):
            def __init__(self):
                raise Exc()

        self.assertRaises(Exc, baddict1.fromkeys, [1])

        class BadSeq(object):
            def __iter__(self):
                return self
            def next(self):
                raise Exc()

        self.assertRaises(Exc, self.type2test.fromkeys, BadSeq())

        class baddict2(self.type2test):
            def __setitem__(self, key, value):
                raise Exc()

        self.assertRaises(Exc, baddict2.fromkeys, [1])

    def test_copy(self):
        d = self._full_mapping({1:1, 2:2, 3:3})
        self.assertEqual(d.copy(), {1:1, 2:2, 3:3})
        d = self._empty_mapping()
        self.assertEqual(d.copy(), d)
        self.assertIsInstance(d.copy(), d.__class__)
        self.assertRaises(TypeError, d.copy, None)

    def test_get(self):
        BasicTestMappingProtocol.test_get(self)
        d = self._empty_mapping()
        self.assertTrue(d.get('c') is None)
        self.assertEqual(d.get('c', 3), 3)
        d = self._full_mapping({'a' : 1, 'b' : 2})
        self.assertTrue(d.get('c') is None)
        self.assertEqual(d.get('c', 3), 3)
        self.assertEqual(d.get('a'), 1)
        self.assertEqual(d.get('a', 3), 1)

    def test_setdefault(self):
        BasicTestMappingProtocol.test_setdefault(self)
        d = self._empty_mapping()
        self.assertTrue(d.setdefault('key0') is None)
        d.setdefault('key0', [])
        self.assertTrue(d.setdefault('key0') is None)
        d.setdefault('key', []).append(3)
        self.assertEqual(d['key'][0], 3)
        d.setdefault('key', []).append(4)
        self.assertEqual(len(d['key']), 2)

    def test_popitem(self):
        BasicTestMappingProtocol.test_popitem(self)
        for copymode in -1, +1:
            # -1: b has same structure as a
            # +1: b is a.copy()
            for log2size in range(12):
                size = 2**log2size
                a = self._empty_mapping()
                b = self._empty_mapping()
                for i in range(size):
                    a[repr(i)] = i
                    if copymode < 0:
                        b[repr(i)] = i
                if copymode > 0:
                    b = a.copy()
                for i in range(size):
                    ka, va = ta = a.popitem()
                    self.assertEqual(va, int(ka))
                    kb, vb = tb = b.popitem()
                    self.assertEqual(vb, int(kb))
                    self.assertTrue(not(copymode < 0 and ta != tb))
                self.assertTrue(not a)
                self.assertTrue(not b)

    def test_pop(self):
        BasicTestMappingProtocol.test_pop(self)

        # Tests for pop with specified key
        d = self._empty_mapping()
        k, v = 'abc', 'def'

        # verify longs/ints get same value when key > 32 bits (for 64-bit archs)
        # see SF bug #689659
        x = 4503599627370496L
        y = 4503599627370496
        h = self._full_mapping({x: 'anything', y: 'something else'})
        self.assertEqual(h[x], h[y])

        self.assertEqual(d.pop(k, v), v)
        d[k] = v
        self.assertEqual(d.pop(k, 1), v)
########NEW FILE########
__FILENAME__ = settings
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Settings module for the `life` simpack'''


from .state import determinism_function

DETERMINISM_FUNCTION = determinism_function
########NEW FILE########
__FILENAME__ = state
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `State` class.

See its documentation for more information.
'''

import random
import itertools

import garlicsim.data_structures


class State(garlicsim.data_structures.State):
    '''World state. A frozen moment in time in the simulation world.'''

    @staticmethod
    def create_diehard(width=45, height=25):
        '''
        Create the Diehard Metushelah.
        
        It looks like this:
        
                   #
             ##
              #   ###

        '''
        state = State()
        state.board = Board.create_diehard(width, height)
        return state

    
    @staticmethod
    def create_root(width=45, height=25, fill='empty'):
        '''
        Create a plain and featureless world state.
        
        `fill` may be either 'empty', 'full', or 'random'.
        '''
        state = State()
        state.board = Board(width, height, fill)
        return state

    
    @staticmethod
    def create_messy_root(width=45, height=25):
        '''Create a state with a random board.'''
        return State.create_root(width, height, fill='random')
    

    def step_generator(self, birth=[3], survival=[2, 3], randomness=0):
        '''
        Perform a simulation step by yielding the next state every time.
        
        `birth` is the list of numbers of live neighbors that a dead cell
        should have in order to become alive. `survival` is a list of the
        numbers of live neighbors that a living cell should have in order to
        stay alive. `randomness` is a float between 0 and 1, and is the amount
        of randomness that should come into the board, e.g. a randomness of
        `0.1` would introduce a random cell once in approximately 10 cells.
        `randomness` may also be given as `False` or `True` for `0` or `1`
        respectively.
        '''
        # This isn't really more efficient than regular step; this is just a
        # demonstration that `garlicsim` can handle step generators.
        current_state = self
        while True:
            current_state = current_state.step(birth=birth, survival=survival,
                                               randomness=randomness)
            yield current_state
    
    
    def step(self, birth=[3], survival=[2, 3], randomness=0, *args, **kwargs):
        '''
        Return the next state in time.
        
        `birth` is the list of numbers of live neighbors that a dead cell
        should have in order to become alive. `survival` is a list of the
        numbers of live neighbors that a living cell should have in order to
        stay alive. `randomness` is a float between 0 and 1, and is the amount
        of randomness that should come into the board, e.g. a randomness of
        `0.1` would introduce a random cell once in approximately 10 cells.
        `randomness` may also be given as `False` or `True` for `0` or `1`
        respectively.
        '''
        old_board = self.board
        new_board = Board(parent=old_board,
                          birth=birth,
                          survival=survival,
                          randomness=randomness)
        new_state = State()
        new_state.board = new_board
        return new_state
    
    
    @garlicsim.general_misc.caching.cache()
    def get_n_live_cells(self):
        '''Return how many live cells there are in the board.'''
        return self.board._Board__list.count(True)

    def __repr__(self):
        return self.board.__repr__()
    
    def __eq__(self, other):
        return isinstance(other, State) and self.board == other.board
    
    def __ne__(self, other):
        return not self.__eq__(other)
    
    def __sub__(self, other): # todo: experimental, test
        if isinstance(other, State):
            return sum(
                (x-y) for (x, y) in itertools.izip(
                    self.board._Board__list,
                    other.board._Board__list
                )
            )
                
        else:
            return NotImplemented
            
    


class Board(object):
    '''A Life board of cells which may be either dead or alive.''' 
    
    def __init__(self, width=None, height=None, fill='empty', parent=None,
                 birth=[3], survival=[2, 3], randomness=0):
        '''
        Constructor.
        
        If `parent` is specified, makes a board which is descendent from the
        parent.
        '''
        if parent:
            assert width == height == None
            self.width, self.height = (parent.width, parent.height)
            self.__list = [None] * parent.width * parent.height
            for x in xrange(parent.width):
                for y in xrange(parent.height):
                    self.set(
                        x, 
                        y, 
                        parent.cell_will_become(x,
                                                y,
                                                birth=birth,
                                                survival=survival,
                                                randomness=randomness)
                    )
            return
                
        assert fill in ['empty', 'full', 'random']
        
        if fill == 'empty':
            make_cell = lambda: False
        elif fill == 'full':
            make_cell = lambda: True
        elif fill == 'random':    
            make_cell = lambda: random.choice([True, False])

        self.width, self.height = (width, height)
        self.__list = []
        for i in xrange(self.width*self.height):
            self.__list.append(make_cell())
        
    
    def get(self, x, y):
        '''Get the value of cell `(x, y)` in the board.'''
        return self.__list[ (x % self.width) * self.height + (y%self.height) ]

    
    def set(self, x, y, value):
        '''
        Set the value of cell `(x, y)` in the board to the specified value.
        '''
        self.__list[ (x%self.width) * self.height + (y%self.height) ] = value

        
    def get_live_neighbors_count(self, x, y):
        '''Get the number of live neighbors a cell has.'''
        result = 0
        for i in [-1 ,0 ,1]:
            for j in [-1, 0 ,1]:
                if i==j==0:
                    continue
                if self.get(x+i, y+j) is True:
                    result += 1
        return result

    
    def cell_will_become(self, x, y, birth=[3], survival=[2, 3],
                         randomness=0):
        '''Get the value that cell `(x, y)` will have in the next turn.'''
        if randomness:
            if random.random() <= randomness:
                return random.choice([True, False])
        n = self.get_live_neighbors_count(x, y)
        if self.get(x, y) is True:
            if n in survival:
                return True
            else:
                return False
        else: # self.get(x, y) is False
            if n in birth:
                return True
            else:
                return False

            
    def __repr__(self):
        '''Display the board, ASCII-art style.'''
        cell = lambda x, y: "#" if self.get(x, y) is True else " "
        row = lambda y: "".join(cell(x, y) for x in xrange(self.width))
        return "\n".join(row(y) for y in xrange(self.height))

    
    def __eq__(self, other):
        return isinstance(other, Board) and self.__list == other.__list
    
    
    def __ne__(self, other):
        return not self.__eq__(other)
    
            
    @staticmethod
    def create_diehard(width=45, height=25):
        '''
        Create the Diehard Metushelah.
        
        It looks like this:
        
                   #
             ##
              #   ###

        '''
        board = Board(width, height)
        (x, y) = (width//2, height//2)
        for (i, j) in [(6, 0), (0, 1), (1, 1), (1, 2), (5, 2), (6, 2), (7, 2)]:
            board.set(x + i, y + j, True)
            
        return board



def determinism_function(step_profile):
    '''Get determinism class of `step_profile`.'''
    if step_profile['randomness']:
        return garlicsim.misc.settings_constants.UNDETERMINISTIC
    else:
        return garlicsim.misc.settings_constants.DETERMINISTIC


   

"""
@garlicsim.misc.caching.history_cache
def changes(history_browser):
    '''
    Return how many cells changed between the most recent state and its parent.
    '''
    try:
        state = history_browser[-1]
        last_state = history_browser[-2]
    except IndexError:
        return None
    board, last_board = state.board, last_state.board
    board_size = len(board._Board__list)
    counter = 0
    for i in xrange(board_size):
        if board._Board__list[i] != last_board._Board__list[i]:
            counter += 1
    return counter
"""
########NEW FILE########
__FILENAME__ = settings
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Settings module for the `wx` component of the `life` simpack.'''


from . import widgets

#SEEK_BAR_GRAPHS = [State.get_n_live_cells, changes]
BIG_WORKSPACE_WIDGETS = [widgets.BoardViewer]
SMALL_WORKSPACE_WIDGETS = []
STATE_CREATION_DIALOG = widgets.StateCreationDialog
########NEW FILE########
__FILENAME__ = board_viewer
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Defines the `BoardViewer` class.'''

import wx
import wx.lib.scrolledpanel as scrolled

from garlicsim_wx.general_misc import wx_tools

import garlicsim_wx


class BoardViewer(scrolled.ScrolledPanel,
                  garlicsim_wx.widgets.WorkspaceWidget):
    '''Widget for displaying a Life board.'''
    
    def __init__(self, frame):
              
        scrolled.ScrolledPanel.__init__(self, frame,
                                        style=wx.SUNKEN_BORDER)
        
        garlicsim_wx.widgets.WorkspaceWidget.__init__(self, frame)
        
        self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM)
        
        self.SetupScrolling()
        
        self.Bind(wx.EVT_PAINT, self.on_paint)
        self.Bind(wx.EVT_SIZE, self.on_size)
        self.Bind(wx.EVT_MOUSE_EVENTS, self.on_mouse_event)

        self.border_width = 1
        self.square_size = 7
        self.board = None
        
        self._buffer_bitmap = wx.EmptyBitmap(1, 1)
        
        self.gui_project.active_node_changed_emitter.add_output(
            lambda: self.set_state(self.gui_project.get_active_state())
        )

        self.redraw_needed_flag = True
        
        
    def unscreenify(self, x, y):
        '''Translate screen coordinates to board coordinates.'''
        if self.board is None:
            return None
        screen_tuple = self.CalcUnscrolledPosition(x, y)
        result = [(thing // (self.border_width + self.square_size)) for
                  thing in screen_tuple]
        if (0 <= result[0] < self.board.width) and \
           (0 <= result[1] < self.board.height):
            return tuple(result)
        else:
            return None

        
    def set_state(self, state):
        '''Set the state to be displayed.'''
        if state is not None:
            self.set_board(state.board)

            
    def set_board(self, board):
        '''Set the board to be displayed.'''
        if board is not self.board:
            self.board = board
            self.redraw_needed_flag = True
            self.Refresh()

            
    def _get_size_from_board(self):
        '''
        Get the size the widget should be by inspecting the size of the board.
        '''
        if self.board:
            return (
                self.board.width * (self.square_size + self.border_width),
                self.board.height * (self.square_size + self.border_width)
            )
        else:
            return (1, 1)

        
    def _draw_buffer_bitmap(self):
        '''Draw the buffer bitmap, which `on_paint` will draw to the screen.'''
        
        board = self.board
        
        (w, h) = self._get_size_from_board()
        self._buffer_bitmap = wx.EmptyBitmap(w, h)
        
        dc = wx.MemoryDC(self._buffer_bitmap)
        
        
        dc.SetPen(wx.TRANSPARENT_PEN)
        dc.SetBrush(wx.Brush('#d4d0c8'))
        dc.DrawRectangle(0, 0, w, h)
        
        if board is None:
            return
        
        white_brush = wx.Brush('White')
        black_brush = wx.Brush('Black')
        rectangles = []
        brushes = []
        for x in xrange(board.width):
            for y in xrange(board.height):
                rectangles.append([(self.square_size + self.border_width) * x,
                                   (self.square_size + self.border_width) * y,
                                   self.square_size,
                                   self.square_size])
                brushes.append(black_brush if board.get(x,y) is True
                               else white_brush)

        transparent_pen = wx.Pen('#000000', 0, wx.TRANSPARENT)
        
        dc.DrawRectangleList(rectangles, transparent_pen, brushes)

        
    def on_paint(self, event):
        '''Paint event handler.'''
        
        event.Skip()
        
        (w, h) = self._get_size_from_board()
        self.SetVirtualSize((w, h))
        
        if self.redraw_needed_flag is True:
            self._draw_buffer_bitmap()
            self.redraw_needed_flag = False
                
        dc = wx.BufferedPaintDC(self)
        
        dc.SetBackground(wx_tools.get_background_brush())
        dc.Clear()
        
        dc.DrawBitmapPoint(self._buffer_bitmap,
                           self.CalcScrolledPosition((0, 0)))
        
                
        
    def on_size(self, event):
        '''EVT_SIZE handler.'''
        self.Refresh()
        if event is not None:

            event.Skip()

    def on_mouse_event(self, event):
        '''Mouse event handler.'''
        
        if event.LeftDown():
            pos = event.GetPositionTuple()
            thing = self.unscreenify(*pos)
            if thing is not None:
                (x, y) = thing
                old_value = self.board.get(x,y)
                new_value = (not old_value)

                new_state = self.gui_project.editing_state()
                new_board = new_state.board
                new_board.set(x, y, new_value)
            
                self.redraw_needed_flag = True

        self.Refresh()

########NEW FILE########
__FILENAME__ = state_creation_dialog
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `StateCreationDialog` class.

See its documentation for more info.
'''

import random
import warnings
import functools

import wx

from garlicsim_wx.widgets.general_misc.cute_dialog import CuteDialog

import garlicsim.data_structures


class StateCreationDialog(CuteDialog):
    '''Initial dialog for creating a root state.'''
    
    def __init__(self, frame):
        CuteDialog.__init__(self, frame, title='Creating a root state')
        
        self.frame = frame
        self.simpack = frame.gui_project.simpack

        hbox1 = wx.BoxSizer(wx.HORIZONTAL)
        self.x_title = x_title = wx.StaticText(self, -1, 'Width: ')
        self.x_textctrl = x_textctrl = wx.TextCtrl(self, -1, '45')
        self.y_title = y_title = wx.StaticText(self, -1, 'Height: ')
        self.y_textctrl = y_textctrl = wx.TextCtrl(self, -1, '25')
        hbox1.Add(x_title, 0, wx.ALIGN_CENTER | wx.EXPAND | wx.ALL, 5)
        hbox1.Add(x_textctrl, 0, wx.EXPAND | wx.ALIGN_CENTER | wx.RIGHT, 40)
        hbox1.Add(y_title, 0, wx.EXPAND | wx.ALIGN_CENTER | wx.RIGHT, 10)
        hbox1.Add(y_textctrl, 0, wx.EXPAND | wx.ALIGN_CENTER | wx.RIGHT, 5)

        hbox2 = wx.BoxSizer(wx.HORIZONTAL)
        self.empty = empty = wx.RadioButton(self, -1, 'All empty',
                                            style=wx.RB_GROUP)
        self.full = full = wx.RadioButton(self, -1, 'All full')
        self.random = random = wx.RadioButton(self, -1, 'Random')
        random.SetValue(True)
        hbox2.Add(empty, 0, wx.ALIGN_CENTER | wx.ALL, 5)
        hbox2.Add(full, 0, wx.ALIGN_CENTER | wx.ALL, 5)
        hbox2.Add(random, 0, wx.ALIGN_CENTER | wx.ALL, 5)
        
        vbox = wx.BoxSizer(wx.VERTICAL)

        last_hbox = wx.BoxSizer(wx.HORIZONTAL)
        ok = wx.Button(self, wx.ID_OK, 'Create state')
        ok.SetDefault()
        self.Bind(wx.EVT_BUTTON, self.on_ok, id=ok.GetId())
        cancel = wx.Button(self, wx.ID_CANCEL, 'Cancel')
        self.Bind(wx.EVT_BUTTON, self.on_cancel, id=cancel.GetId())
        last_hbox.Add(ok, 0)
        last_hbox.Add(cancel, 0, wx.LEFT, 5)

        vbox.Add(hbox1, 0, wx.ALIGN_CENTER | wx.TOP | wx.BOTTOM, 10)
        vbox.Add(hbox2, 0, wx.ALIGN_CENTER | wx.TOP | wx.BOTTOM, 10)
        vbox.Add(last_hbox, 1, wx.ALIGN_CENTER |  wx.BOTTOM, 10)

        self.SetSizer(vbox)
        vbox.Fit(self)
        ok.SetFocus()

        
    def on_ok(self, e=None):
        '''Do 'okay' on the dialog.'''

        def complain(message):
            dialog = wx.MessageDialog(self, message, 'Error',
                                      wx.ICON_ERROR | wx.OK)
            try:
                dialog.ShowModal()
            finally:
                dialog.Destroy()

        self.info = {}

        try:
            self.info['width'] = int(self.x_textctrl.GetValue())
        except ValueError:
            complain('Bad width!')
            return

        try:
            self.info['height'] = int(self.y_textctrl.GetValue())
        except ValueError:
            complain('Bad height!')
            return

        self.info['fill'] = 'full' if self.full.GetValue() else \
            'empty' if self.empty.GetValue() else 'random'

        self.EndModal(wx.ID_OK)

        
    def on_cancel(self, e=None):
        '''Do 'cancel' on the dialog.'''
        self.EndModal(wx.ID_CANCEL)

        
    def start(self):
        '''Start the dialog to make a new state.'''
        if self.ShowModal() == wx.ID_OK:
            width, height, fill = (
                self.info['width'],
                self.info['height'],
                self.info['fill']
            )
            state = self.simpack.State.create_root(width, height, fill)
        else:
            state = None
        self.Destroy()
        return state
        


########NEW FILE########
__FILENAME__ = base_player
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `BasePlayer` abstact base class.

See its documentation for more information.
'''

from garlicsim.general_misc.third_party import abc

from garlicsim.general_misc import identities

from .player_type import PlayerType


class BasePlayer(identities.HasIdentity):
    '''
    A player that plays prisoner's dilemma, gaining and losing points.
    
    This is an abstract base class; subclass this to implement actual playing
    strategies.
    '''
    
    __metaclass__ = PlayerType

    color = None
    '''
    Name of color that will represent this player class in a GUI. Optional.
    '''
        
    def __init__(self):
        identities.HasIdentity.__init__(self)
        
        self.points = 0
        '''The number of points that the player has.'''
        
        
    @abc.abstractmethod
    def make_move(self, round):
        '''
        Decide which move to make.
        
        Abstract method.
        
        `round` is the round number in the match, starting with 0.
        
        Note that no information about the other player is given to this
        method. Any state that a player subclass wants to have should be
        created by it and saved as data attributes to the player instance.
        
        Returns a boolean, `True` is "be nice" and `False` is "be mean".
        '''
        
    
    def other_player_played(self, move):
        '''
        The other player played `move` in the last round.
        
        A player subclass may implement here something that saves this move and
        takes it into account on subsequent rounds.
        '''
        pass
    
    
    def play_game(player_1, player_2, round):
        '''
        Have `player_1` and `player_2` play against each other.
        
        Each player will gain or lose points according to the outcome of the
        game.
        '''        
        assert isinstance(player_1, BasePlayer)
        assert isinstance(player_2, BasePlayer)
    
        player_1_move = player_1.make_move(round)
        player_2_move = player_2.make_move(round)
    
        assert isinstance(player_1_move, bool)
        assert isinstance(player_2_move, bool)
    
        ### Calculating outcome of game in points for each player: ############
        #                                                                     #
        if player_1_move is True and player_2_move is True:
            player_1.points += 1
            player_2.points += 1
            
        elif player_1_move is True and player_2_move is False:
            player_1.points += -4
            player_2.points += 2
            
        elif player_1_move is False and player_2_move is True:
            player_1.points += 2
            player_2.points += -4
            
        elif player_1_move is False and player_2_move is False:
            player_1.points += -1
            player_2.points += -1
        #                                                                     #
        ### Finished calculating outcome of game in points for each player. ###
    
        player_1.other_player_played(player_2_move)
        player_2.other_player_played(player_1_move)
########NEW FILE########
__FILENAME__ = angel
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `Angel` player type.

See its documentation for more information.
'''

from ..base_player import BasePlayer


class Angel(BasePlayer):
    '''Player which always plays nice.'''
    
    color = 'White'
    
    def make_move(self, round):
        '''Play nice.'''
        return True

########NEW FILE########
__FILENAME__ = devil
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `Devil` player type.

See its documentation for more information.
'''

from ..base_player import BasePlayer


class Devil(BasePlayer):
    '''Player which always plays mean.'''
    
    color = 'Black'
    
    def make_move(self, round):
        '''Play mean.'''
        return False
########NEW FILE########
__FILENAME__ = tit_for_tat
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `TitForTat` player type.

See its documentation for more information.
'''

from ..base_player import BasePlayer


class TitForTat(BasePlayer):
    '''
    Player which plays nice on the 1st round and afterwards imitates opponent.
    
    On the first round this player will always play nice. On every subsequent
    round, it will play the move that the opponent played on the previous
    round.
    
    This is a good strategy, because it allows the `TitForTat` player to
    cooperate with other `TitForTat` players and with `Angel` players, but it
    doesn't let any `Devil` players exploit it.
    '''
    
    color = 'Blue'
    
    def make_move(self, round):
        '''Play nice on 1st round, afterwards imitate opponent.'''
        if round == 0:
            self.last_play = None
            return True
        else:
            return self.last_play

    def other_player_played(self, move):
        '''Save the opponent's move so we can do the same on the next round.'''
        self.last_play = move


########NEW FILE########
__FILENAME__ = player_type
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `PlayerType` metaclass.

See its documentation for more information.
'''

from __future__ import absolute_import

import random
from garlicsim.general_misc.third_party import abc

from garlicsim.general_misc import caching


class PlayerType(abc.ABCMeta):
    '''Metaclass for player types.'''
        
    @caching.CachedProperty
    def wx_color(cls):
        '''The wxPython color that represents this player type in the GUI.'''
        import wx
        return wx.NamedColour(cls.color or 'Red')
    
    
    @staticmethod
    def create_player_of_random_type():
        '''Create a player of a random player type.'''
        from .players import player_types_list
        player_type = random.choice(player_types_list)
        return player_type()
        
########NEW FILE########
__FILENAME__ = settings
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Settings modules for the `prisoner` simpack.'''
########NEW FILE########
__FILENAME__ = state
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `State` class.

See its documentation for more information.
'''


import random

from garlicsim.general_misc import random_tools
from garlicsim.general_misc.infinity import infinity


import garlicsim.data_structures

from .player_type import PlayerType
from .base_player import BasePlayer
from .players import player_types_list


class State(garlicsim.data_structures.State):
    '''World state. A frozen moment in time in the simulation world.'''
    
    def __init__(self, players, round=-1, match=0, n_rounds=7):
        '''
        Constructor.
        
        `players` is a list of players, i.e. instances of `BasePlayer`, that
        will play against each other. `round` is the round number, with `-1`
        being the preparation pseudo-round. `match` is the match number.
        `n_rounds` is the number of rounds in a match.
        '''
        
        assert -1 <= round <= (n_rounds - 1)
        self.round = round
        '''
        The round number.
        
        `-1` is the preparation pseudo-round, `0` is the first round, and
        `n_rounds - 1` is the last round in the match .
        '''
        
        assert 0 <= match <= infinity
        self.match = match
        '''The match number, going from `0` to infinity.'''
        
        assert all(isinstance(player, BasePlayer) for player in players)
        self.players = players
        '''The list of players that play against each other.'''
        
        assert n_rounds >= 1
        self.n_rounds = n_rounds
        '''The number of rounds in a match.'''
        
    
    @staticmethod
    def create_root(n_players=70, n_rounds=7):
        '''Create a plain and featureless world state.'''
        state = State(
            players=[player_types_list[i % len(player_types_list)]() for i
                     in xrange(n_players)],
            n_rounds=n_rounds
        )
        state._prepare_for_new_match(replace_loser=False)
        return state
    
    
    @staticmethod
    def create_messy_root(n_players=70, n_rounds=7):
        '''Create a random and messy world state.'''
        state = State(
            players=[PlayerType.create_player_of_random_type() for i
                     in xrange(n_players)],
            n_rounds=n_rounds
        )
        state._prepare_for_new_match(replace_loser=False)
        return state
    
        
    def inplace_step(self):
        '''Modify the state in-place to make it the next moment in time.'''
        
        self.clock += 1
    
        self.round += 1
        if self.round == self.n_rounds:
            self.round = -1
            self.match += 1
            self._prepare_for_new_match()
            return
    
        for player_1, player_2 in self.player_pairs:
            BasePlayer.play_game(player_1, player_2, self.round)
    
    
    def _prepare_for_new_match(self, replace_loser=True):
        '''
        Prepare a state with a `.round` of `-1` for the new match.
        
        Round -1 is a pseudo round in which the players get partitioned into
        pairs randomly. The two players in each player will play against each
        other in every round in the match, after which they'll be reassigned a
        new opponent.
        
        If `replace_loser` is set to `True`, the player with the least points
        will be removed and replaced with a player from a random player type.
        '''
        assert self.round == -1
        
        if replace_loser:
            loser = self.get_player_with_least_points()
            self.players.remove(loser)
            self.players.append(PlayerType.create_player_of_random_type())
    
        self.player_pairs = random_tools.random_partition(self.players, 2)
        
        
    def get_player_with_least_points(self):
        '''Get the player which has the lowest number of points.'''
        return min(self.players, key=lambda player: player.points)

    
    def get_n_players_of_given_type(self, player_type):
        '''Get the number of existing players of the type `player_type`.'''
        return len([player for player in self.players
                    if isinstance(player, player_type)])


########NEW FILE########
__FILENAME__ = settings
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Settings module for the `wx` component of the `prisoner` simpack.'''

from . import widgets

SEEK_BAR_GRAPHS = []
BIG_WORKSPACE_WIDGETS = [widgets.StateViewer]
SMALL_WORKSPACE_WIDGETS = []
########NEW FILE########
__FILENAME__ = state_viewer
1# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `StateViewer` class.

See its documentation for more information.
'''

import math

import wx
import wx.lib.agw.piectrl as piectrl

import garlicsim_wx

from garlicsim_lib.simpacks import prisoner


class StateViewer(wx.Panel, garlicsim_wx.widgets.WorkspaceWidget):
    '''Widget for viewing a `prisoner` state.'''
    def __init__(self, frame):
        wx.Panel.__init__(self, frame)
        garlicsim_wx.widgets.WorkspaceWidget.__init__(self, frame)

        self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM)
        
        self.pie_ctrl = piectrl.PieCtrl(self, style=wx.NO_BORDER)
        
        self.sizer_v = wx.BoxSizer(wx.VERTICAL)
        self.sizer_h = wx.BoxSizer(wx.HORIZONTAL)
        self.sizer_v.Add(self.sizer_h, 1, wx.EXPAND)
        self.sizer_h.Add(self.pie_ctrl, 1, wx.EXPAND)
        
        self.SetSizer(self.sizer_v)
        self.sizer_v.Layout()
        
        font = wx.Font(12, wx.SWISS, wx.NORMAL, wx.BOLD, True, 'Arial')
        self.pie_ctrl.GetLegend().SetLabelFont(font)
        self.pie_ctrl.SetAngle(math.pi)
    
        self.pie_part_dict = {}
        for player_type in prisoner.players.player_types_list:
            part = piectrl.PiePart()
            part.SetLabel(player_type.__name__)
            part.SetValue(1)
            part.SetColour(player_type.wx_color)
            self.pie_ctrl._series.append(part)
            self.pie_part_dict[player_type] = part
            
        self.gui_project.active_node_changed_or_modified_emitter.add_output(
            lambda: self.show_state(self.gui_project.get_active_state())
        )
            
    def show_state(self, state):
        '''Show a state onscreen.'''
        if state is None:
            return
        for player_type in prisoner.players.player_types_list:
            part = self.pie_part_dict[player_type]
            value = state.get_n_players_of_given_type(player_type)
            part.SetValue(value)
        self.Refresh()

########NEW FILE########
__FILENAME__ = client
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `Client` class.

See its documentation for more information.
'''

from garlicsim.general_misc import identities

import garlicsim


class Client(identities.HasIdentity):
    '''A client which needs to be served in a facility.'''
    def __init__(self):
        identities.HasIdentity.__init__(self)

        


########NEW FILE########
__FILENAME__ = event
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `Event` class.

See its documentation for more information.
'''


class Event(object):
    '''
    An event which will happen in the future.
    
    An event has a `.time_left` property, saying how much time there is until
    the event happens, and an `.action` property which gets called when the
    event happens.
    '''
    
    def __init__(self, time_left, action):
        assert time_left > 0
        self.time_left = time_left
        self.action = action
        self.done = False

        
    def _get_time_left(self):
        return self.time_left
########NEW FILE########
__FILENAME__ = event_set
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `EventSet` class.

See its documentation for more information.
'''

from .event import Event


class EventSet(object):
    '''A set of events that happen in the same "world".'''
    
    def __init__(self):
        self.events = []
        '''Sorted list of all the events in the system.'''
    
        
    def create_event(self, time_left, action):
        '''
        Create a new event in this event set.

        Returns the new event.
        '''
        event = Event(time_left, action)
        
        self.events.append(event)
        self.events.sort(key=Event._get_time_left)
        
        return event

    
    def do_next_event(self):
        '''
        Pass the time until the closest pending event(s), making them happen.
        
        Return the amount of time that was passed.
        '''
        if not self.events:
            raise Exception('No pending events.')
            
        closest_event = self.events.pop(0)
        
        for event in self.events:
            event.time_left -= closest_event.time_left
            
        closest_event.action()
        
        return closest_event.time_left
    
########NEW FILE########
__FILENAME__ = facility
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `Server` class.

See its documentation for more information.
'''

from garlicsim.general_misc import identities

import garlicsim
from .server import Server


class Facility(identities.HasIdentity):
    '''A facility in which there are servers serving clients.'''
    
    def __init__(self, event_set, servers=[], clients=[]):
        identities.HasIdentity.__init__(self)
        
        self.event_set = event_set
        '''
        An event set for events such as servers finishing or clients arriving.
        '''
        
        self.servers = servers
        '''List of all the servers in the facility.'''
        
        self.clients = clients
        '''
        List of all the clients, both those getting served and those on queue.
        '''
        
        self.waiting_clients = clients[:]
        '''List of all the clients waiting in the queue.'''
        
        
    def create_server(self, mean_service_time):
        '''Create a new server for this facility.'''
        new_server = Server(
            event_set=self.event_set,
            facility=self,
            mean_service_time=mean_service_time
        )
        self.servers.append(new_server)
        return new_server

    
    def add_client(self, client):
        '''Add a new client to this facility, to be served by a server.'''
        self.clients.append(client)
        if not self.waiting_clients: # Queue is empty, no waiting clients
            # If there's an idle server, have it service the new client:
            idle_servers = list(self.idle_servers_generator())
            if idle_servers:
                first_idle_server = idle_servers[0]
                first_idle_server.service_client(client)
            else:
                self.waiting_clients.append(client)
        else: # There are clients awaiting in the queue
            self.waiting_clients.append(client)
            
            
    def idle_servers_generator(self):
        '''Generator that yields servers in the facility that are idle.'''
        for server in self.servers:
            if not server.is_busy():
                yield server
            
            
    def feed_client(self, server):
        '''
        Order a server to start servicing the first client in the queue.
        
        The server must be idle.
        '''
        assert not server.is_busy()
        if self.waiting_clients:
            client = self.waiting_clients.pop(0)
            server.service_client(client)
        
    
    def finished_client_count(self):
        '''Return the number of clients that were served by all servers.'''
        return sum((server.client_counter for server in self.servers))
        
    
    def __repr__(self):
        return ('<facility with %s clients, %s of which stand in queue. %s '
                'clients were served total.>' % \
                (
                    len(self.clients),
                    len(self.waiting_clients),
                    self.finished_client_count()
                )
                )
        
                    

 
########NEW FILE########
__FILENAME__ = math_tools
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''This module defines various mathematical tools.'''

from __future__ import division

import random

def time_for_next_occurence(mean_time_for_next_occurence):
    '''
    Given a mean time between occurences, generate the time for next occurence.
    
    Only for occurences that obey a Poisson distribution.
    '''
    return random.expovariate(1 / mean_time_for_next_occurence)


 
########NEW FILE########
__FILENAME__ = population
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `Population` class.

See its documentation for more information.
'''

from garlicsim.general_misc.infinity import infinity
from garlicsim.general_misc import identities
import garlicsim

from . import math_tools

from .client import Client


class Population(identities.HasIdentity):
    '''A population which generates clients.'''
    def __init__(self, event_set, facility, size=infinity, mean_arrival_time=1):
        '''
        Constructor.
        
        `mean_arrival_time` is the mean time between arrivals.
        '''
        identities.HasIdentity.__init__(self)
        if not (size == infinity):
            raise NotImplementedError
        
        self.size = size
        '''
        The size of the population.
        
        If it's finite, then when there are plenty of clients in the facility
        new clients are less likely to arrive, because there are less potential
        clients available.
        '''
        
        self.mean_arrival_time = mean_arrival_time
        '''The mean time between arrivals of clients.'''
        
        self.event_set = event_set
        '''Event set for events such as new clients arriving.'''
        
        self.facility = facility
        '''The facility in which clients are served.'''
        
        self.next_arrival = None
        '''The event of the next arrival.'''
        
        self.schedule_next_arrival()
        
        
    def schedule_next_arrival(self):
        '''Schedule the next arrival of a client from the population.'''
        assert self.next_arrival is None
        self.next_arrival = self.event_set.create_event(
            math_tools.time_for_next_occurence(self.mean_arrival_time),
            self.make_arrival
        )
    
        
    def make_arrival(self):
        '''Create a client and put it into the facility.'''
        client = Client()
        self.facility.add_client(client)
        self.next_arrival = None
        self.schedule_next_arrival()
        return client


########NEW FILE########
__FILENAME__ = server
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `Server` class.

See its documentation for more information.
'''

from garlicsim.general_misc import identities
import garlicsim

from . import math_tools


class Server(identities.HasIdentity):
    '''A server which serves clients in a facility.'''
    
    def __init__(self, event_set, facility, mean_service_time):
        '''
        Constructor.
        
        `mean_service_time` is the mean time it takes to service a client.
        '''
        identities.HasIdentity.__init__(self)
        
        self.event_set = event_set
        '''Event set for events such as the end of a client's service.'''
        
        self.facility = facility
        '''The facility in which clients are served.'''
        
        self.mean_service_time = mean_service_time
        '''The mean time it takes the server to service a client.'''
        
        self.current_client = None
        '''The current client being serviced by this server.'''
        
        self.finish_service_event = None
        '''
        The event when this server will finish serving the current client.
        '''
        
        self.client_counter = 0
        '''A counter for the number of clients that this server served.'''
    
        
    def service_client(self, client):
        '''
        Service a client.
        
        The server must be idle.
        '''
        assert self.current_client is None and \
               self.finish_service_event is None
        self.current_client = client
        self.finish_service_event = self.event_set.create_event(
            math_tools.time_for_next_occurence(self.mean_service_time),
            self.finish_client
        )
        
        
    def finish_client(self):
        '''Finish serving the currently served client.'''
        assert self.current_client is not None
        self.client_counter += 1
        client = self.current_client 
        self.current_client = None
        self.finish_service_event = None
        self.facility.clients.remove(client)
        self.facility.feed_client(self)
        
        
    def is_busy(self):
        '''Is this server busy serving a client?'''
        return (self.current_client is not None)

    
    def __repr__(self):
        return '<Server (%s) who served %s clients>' % (
            'busy' if self.is_busy() else 'free',
            self.client_counter
        )
        

 
########NEW FILE########
__FILENAME__ = settings
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Settings module for the `queue` simpack.'''

########NEW FILE########
__FILENAME__ = state
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.
'''
This module defines the `State` class.

See its documentation for more information.
'''

from __future__ import division

from garlicsim.general_misc.infinity import infinity
import garlicsim

from . import events as events_module
from .facility import Facility
from .population import Population


class State(garlicsim.data_structures.State):
    '''World state. A frozen moment in time in the simulation world.'''
    
    def __init__(self, event_set, facility, servers, population):
        garlicsim.data_structures.State.__init__(self)
        
        self.event_set = event_set
        '''Event set for events such as new clients arriving.'''
        	
        self.facility = facility
        '''The facility in which clients wait to be serviced.'''
        
        self.servers = servers
        '''Servers which service the clients.'''
        
        self.population = population
        '''Population from which the clients arrive.'''

        
    @staticmethod
    def create_root(n_servers=3, population_size=infinity, mean_arrival_time=1,
                    mean_service_time=3):
        '''Create a plain and featureless world state.'''
        
        event_set = events_module.EventSet()
        
        facility = Facility(event_set=event_set)
        
        for i in range(n_servers):
            facility.create_server(mean_service_time=mean_service_time)
                    
        population = Population(
            event_set=event_set,
            facility=facility,
            size=population_size,
            mean_arrival_time=mean_arrival_time
        )
        
        return State(
            event_set=event_set,
            facility=facility,
            servers=facility.servers,
            population=population
        )
    
    
    def inplace_step(self):
        '''Modify the state in-place to make it the next moment in time.'''
        
        # todo good idea: t=None means step to next client. If given int just
        # do many steps. (What with cut last?)
        
        time_passed = self.event_set.do_next_event()
        self.clock += time_passed

        
########NEW FILE########
__FILENAME__ = settings
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Settings module for the `wx` component of the `prisoner` simpack.'''

from . import widgets

SEEK_BAR_GRAPHS = []
BIG_WORKSPACE_WIDGETS = [widgets.StateViewer]
SMALL_WORKSPACE_WIDGETS = []
########NEW FILE########
__FILENAME__ = state_viewer
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `StateViewer` class.

See its documentation for more information.
'''

import itertools

import wx
import wx.lib.scrolledpanel

import garlicsim
import garlicsim_wx
from garlicsim.general_misc.infinity import infinity
from garlicsim_wx.general_misc import wx_tools


class StateViewer(wx.lib.scrolledpanel.ScrolledPanel,
                  garlicsim_wx.widgets.WorkspaceWidget):
    '''Widget for showing a state of the `queue` simpack.'''
    def __init__(self, frame):
        wx.lib.scrolledpanel.ScrolledPanel.__init__(self, frame,
                                                    style=wx.SUNKEN_BORDER)
        garlicsim_wx.widgets.WorkspaceWidget.__init__(self, frame)
        
        self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM)
        
        self.SetupScrolling()
        
        self.Bind(wx.EVT_PAINT, self.on_paint)
        self.Bind(wx.EVT_SIZE, self.on_size)
        
        self.state = None
        '''The current state being displayed.'''
        
        self.font = wx.Font(12, wx.FONTFAMILY_TELETYPE, wx.FONTSTYLE_NORMAL,
                            wx.FONTWEIGHT_BOLD, face='Courier New')        
        
        self.gui_project.active_node_changed_or_modified_emitter.add_output(
            lambda: self.load_state(self.gui_project.get_active_state())
        )

        
    def load_state(self, state):
        '''Set the state to be displayed.'''
        if state is None:
            return
        self.state = state
        self.Refresh()

        
    def on_paint(self, event):
        '''Paint event handler.'''
        
        event.Skip()
        
        state = self.state
        dc = wx.BufferedPaintDC(self)
        
        dc.SetBackground(wx_tools.get_background_brush())
        dc.Clear()
        
        if state is None:
            return
        
        dc.SetBackgroundMode(wx.SOLID)
        dc.SetFont(self.font)
        
        
        ### Drawing servers: ##################################################
        #                                                                     #
        servers = state.servers
        
        for (i, server) in enumerate(servers):

            personality = server.personality
            
            name, light_color, dark_color = (
                personality.human_name,
                wx_tools.rgb_to_wx_color(personality.light_color),
                wx_tools.rgb_to_wx_color(personality.dark_color)
            )
            
            x0 = 10 + 200 * i
            y0 = 10
            
            pen = wx.Pen(light_color, 5)
            dc.SetPen(pen)
            
            dc.SetBrush(wx.TRANSPARENT_BRUSH)
            
            dc.DrawRectanglePointSize((x0, y0), (180, 50))
            
            dc.SetTextBackground(light_color)
            dc.SetTextForeground(dark_color)
                        
            dc.DrawText('Server %s' % name, x0, y0)
            
            client = server.current_client
            
            if client is None:
                dc.SetTextBackground('#d4d0c8')
                dc.SetTextForeground('#000000')
                dc.DrawText('Idle', x0 + 10, y0 + 22)
            
            else:
                
                client_personality = client.personality
                
                client_name, client_light_color, client_dark_color = (
                    client_personality.human_name,
                    wx_tools.rgb_to_wx_color(client_personality.light_color),
                    wx_tools.rgb_to_wx_color(client_personality.dark_color)
                )
                
                dc.SetTextBackground(client_light_color)
                dc.SetTextForeground(client_dark_color)
                dc.DrawText(client_name, x0 + 10, y0 + 22)
        #                                                                     #
        ### Finished drawing servers. #########################################
                
        
        ### Drawing population: ###############################################
        #                                                                     #
        assert state.population.size == infinity
        
        dc.SetTextBackground('#d4d0c8')
        dc.SetTextForeground('#000000')
        
        dc.DrawTextList(['Population:', 'Infinite'], [(10, 70), (10, 89)])
        #                                                                     #
        ### Finished drawing population. ######################################
        
        
        ### Drawing waiting clients: ##########################################
        #                                                                     #
        dc.SetTextBackground('#d4d0c8')
        dc.SetTextForeground('#000000')
        
        dc.DrawText('Clients in queue:', 150, 70)
        
        waiting_clients = state.facility.waiting_clients
        
        dc.DrawTextList(
            textList=
                [client.personality.human_name for client in waiting_clients],
            coords=
                [(150, 89 + (19 * i)) for i in range(len(waiting_clients))],
            foregrounds=
                [wx_tools.rgb_to_wx_color(client.personality.dark_color) for
                 client in waiting_clients],
            backgrounds=
                [wx_tools.rgb_to_wx_color(client.personality.light_color) for
                 client in waiting_clients]
        )
        #                                                                     #
        ### Finished drawing waiting clients. #################################
        

    def on_size(self, event):
        '''Refresh the widget.'''
        self.Refresh()
        event.Skip()


########NEW FILE########
__FILENAME__ = settings
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Settings module for the `life` simpack'''


from .state import determinism_function

DETERMINISM_FUNCTION = determinism_function
########NEW FILE########
__FILENAME__ = state
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `State` class.

See its documentation for more information.
'''

import random
import itertools

import garlicsim.data_structures


class State(garlicsim.data_structures.State):
    '''World state. A frozen moment in time in the simulation world.'''

    @staticmethod
    def create_diehard(width=45, height=25):
        '''
        Create the Diehard Metushelah.
        
        It looks like this:
        
                   #
             ##
              #   ###

        '''
        state = State()
        state.board = Board.create_diehard(width, height)
        return state

    
    @staticmethod
    def create_root(width=45, height=25, fill='empty'):
        '''
        Create a plain and featureless world state.
        
        `fill` may be either 'empty', 'full', or 'random'.
        '''
        state = State()
        state.board = Board(width, height, fill)
        return state

    
    @staticmethod
    def create_messy_root(width=45, height=25):
        '''Create a state with a random board.'''
        return State.create_root(width, height, fill='random')
    

    def step_generator(self, birth=[3], survival=[2, 3], randomness=0):
        '''
        Perform a simulation step by yielding the next state every time.
        
        `birth` is the list of numbers of live neighbors that a dead cell
        should have in order to become alive. `survival` is a list of the
        numbers of live neighbors that a living cell should have in order to
        stay alive. `randomness` is a float between 0 and 1, and is the amount
        of randomness that should come into the board, e.g. a randomness of
        `0.1` would introduce a random cell once in approximately 10 cells.
        `randomness` may also be given as `False` or `True` for `0` or `1`
        respectively.
        '''
        # This isn't really more efficient than regular step; this is just a
        # demonstration that `garlicsim` can handle step generators.
        current_state = self
        while True:
            
            if current_state.get_n_live_cells() < \
               (current_state.board.width * \
                current_state.board.height) / 10.:
                raise garlicsim.misc.WorldEnded
            
            current_state = current_state.step(birth=birth, survival=survival,
                                               randomness=randomness)
            
            
            yield current_state
    
    
    def step(self, birth=[3], survival=[2, 3], randomness=0, *args, **kwargs):
        '''
        Return the next state in time.
        
        `birth` is the list of numbers of live neighbors that a dead cell
        should have in order to become alive. `survival` is a list of the
        numbers of live neighbors that a living cell should have in order to
        stay alive. `randomness` is a float between 0 and 1, and is the amount
        of randomness that should come into the board, e.g. a randomness of
        `0.1` would introduce a random cell once in approximately 10 cells.
        `randomness` may also be given as `False` or `True` for `0` or `1`
        respectively.
        '''
        old_board = self.board
        new_board = Board(parent=old_board,
                          birth=birth,
                          survival=survival,
                          randomness=randomness)
        new_state = State()
        new_state.board = new_board
        return new_state
    
    
    @garlicsim.general_misc.caching.cache()
    def get_n_live_cells(self):
        '''Return how many live cells there are in the board.'''
        return self.board._Board__list.count(True)

    def __repr__(self):
        return self.board.__repr__()
    
    def __eq__(self, other):
        return isinstance(other, State) and self.board == other.board
    
    def __ne__(self, other):
        return not self.__eq__(other)
    
    def __sub__(self, other): # todo: experimental, test
        if isinstance(other, State):
            return sum(
                (x-y) for (x, y) in itertools.izip(
                    self.board._Board__list,
                    other.board._Board__list
                )
            )
                
        else:
            return NotImplemented
            
    


class Board(object):
    '''A Life board of cells which may be either dead or alive.''' 
    
    def __init__(self, width=None, height=None, fill='empty', parent=None,
                 birth=[3], survival=[2, 3], randomness=0):
        '''
        Constructor.
        
        If `parent` is specified, makes a board which is descendent from the
        parent.
        '''
        if parent:
            assert width == height == None
            self.width, self.height = (parent.width, parent.height)
            self.__list = [None] * parent.width * parent.height
            for x in xrange(parent.width):
                for y in xrange(parent.height):
                    self.set(
                        x, 
                        y, 
                        parent.cell_will_become(x,
                                                y,
                                                birth=birth,
                                                survival=survival,
                                                randomness=randomness)
                    )
            return
                
        assert fill in ['empty', 'full', 'random']
        
        if fill == 'empty':
            make_cell = lambda: False
        elif fill == 'full':
            make_cell = lambda: True
        elif fill == 'random':    
            make_cell = lambda: random.choice([True, False])

        self.width, self.height = (width, height)
        self.__list = []
        for i in xrange(self.width*self.height):
            self.__list.append(make_cell())
        
    
    def get(self, x, y):
        '''Get the value of cell `(x, y)` in the board.'''
        return self.__list[ (x % self.width) * self.height + (y%self.height) ]

    
    def set(self, x, y, value):
        '''
        Set the value of cell `(x, y)` in the board to the specified value.
        '''
        self.__list[ (x%self.width) * self.height + (y%self.height) ] = value

        
    def get_live_neighbors_count(self, x, y):
        '''Get the number of live neighbors a cell has.'''
        result = 0
        for i in [-1 ,0 ,1]:
            for j in [-1, 0 ,1]:
                if i==j==0:
                    continue
                if self.get(x+i, y+j) is True:
                    result += 1
        return result

    
    def cell_will_become(self, x, y, birth=[3], survival=[2, 3],
                         randomness=0):
        '''Get the value that cell `(x, y)` will have in the next turn.'''
        if randomness:
            if random.random() <= randomness:
                return random.choice([True, False])
        n = self.get_live_neighbors_count(x, y)
        if self.get(x, y) is True:
            if n in survival:
                return True
            else:
                return False
        else: # self.get(x, y) is False
            if n in birth:
                return True
            else:
                return False

            
    def __repr__(self):
        '''Display the board, ASCII-art style.'''
        cell = lambda x, y: "#" if self.get(x, y) is True else " "
        row = lambda y: "".join(cell(x, y) for x in xrange(self.width))
        return "\n".join(row(y) for y in xrange(self.height))

    
    def __eq__(self, other):
        return isinstance(other, Board) and self.__list == other.__list
    
    
    def __ne__(self, other):
        return not self.__eq__(other)
    
            
    @staticmethod
    def create_diehard(width=45, height=25):
        '''
        Create the Diehard Metushelah.
        
        It looks like this:
        
                   #
             ##
              #   ###

        '''
        board = Board(width, height)
        (x, y) = (width//2, height//2)
        for (i, j) in [(6, 0), (0, 1), (1, 1), (1, 2), (5, 2), (6, 2), (7, 2)]:
            board.set(x + i, y + j, True)
            
        return board



def determinism_function(step_profile):
    '''Get determinism class of `step_profile`.'''
    if step_profile['randomness']:
        return garlicsim.misc.settings_constants.UNDETERMINISTIC
    else:
        return garlicsim.misc.settings_constants.DETERMINISTIC


   

"""
@garlicsim.misc.caching.history_cache
def changes(history_browser):
    '''
    Return how many cells changed between the most recent state and its parent.
    '''
    try:
        state = history_browser[-1]
        last_state = history_browser[-2]
    except IndexError:
        return None
    board, last_board = state.board, last_state.board
    board_size = len(board._Board__list)
    counter = 0
    for i in xrange(board_size):
        if board._Board__list[i] != last_board._Board__list[i]:
            counter += 1
    return counter
"""
########NEW FILE########
__FILENAME__ = settings
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Settings module for the `wx` component of the `life` simpack.'''


from . import widgets

#SEEK_BAR_GRAPHS = [State.get_n_live_cells, changes]
BIG_WORKSPACE_WIDGETS = [widgets.BoardViewer]
SMALL_WORKSPACE_WIDGETS = []
STATE_CREATION_DIALOG = widgets.StateCreationDialog
########NEW FILE########
__FILENAME__ = board_viewer
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Defines the `BoardViewer` class.'''

import wx
import wx.lib.scrolledpanel as scrolled

from garlicsim_wx.general_misc import wx_tools

import garlicsim_wx


class BoardViewer(scrolled.ScrolledPanel,
                  garlicsim_wx.widgets.WorkspaceWidget):
    '''Widget for displaying a Life board.'''
    
    def __init__(self, frame):
              
        scrolled.ScrolledPanel.__init__(self, frame,
                                        style=wx.SUNKEN_BORDER)
        
        garlicsim_wx.widgets.WorkspaceWidget.__init__(self, frame)
        
        self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM)
        
        self.SetupScrolling()
        
        self.Bind(wx.EVT_PAINT, self.on_paint)
        self.Bind(wx.EVT_SIZE, self.on_size)
        self.Bind(wx.EVT_MOUSE_EVENTS, self.on_mouse_event)

        self.border_width = 1
        self.square_size = 7
        self.board = None
        
        self._buffer_bitmap = wx.EmptyBitmap(1, 1)
        
        self.gui_project.active_node_changed_emitter.add_output(
            lambda: self.set_state(self.gui_project.get_active_state())
        )

        self.redraw_needed_flag = True
        
        
    def unscreenify(self, x, y):
        '''Translate screen coordinates to board coordinates.'''
        if self.board is None:
            return None
        screen_tuple = self.CalcUnscrolledPosition(x, y)
        result = [(thing // (self.border_width + self.square_size)) for
                  thing in screen_tuple]
        if (0 <= result[0] < self.board.width) and \
           (0 <= result[1] < self.board.height):
            return tuple(result)
        else:
            return None

        
    def set_state(self, state):
        '''Set the state to be displayed.'''
        if state is not None:
            self.set_board(state.board)

            
    def set_board(self, board):
        '''Set the board to be displayed.'''
        if board is not self.board:
            self.board = board
            self.redraw_needed_flag = True
            self.Refresh()

            
    def _get_size_from_board(self):
        '''
        Get the size the widget should be by inspecting the size of the board.
        '''
        if self.board:
            return (
                self.board.width * (self.square_size + self.border_width),
                self.board.height * (self.square_size + self.border_width)
            )
        else:
            return (1, 1)

        
    def _draw_buffer_bitmap(self):
        '''Draw the buffer bitmap, which `on_paint` will draw to the screen.'''
        
        board = self.board
        
        (w, h) = self._get_size_from_board()
        self._buffer_bitmap = wx.EmptyBitmap(w, h)
        
        dc = wx.MemoryDC(self._buffer_bitmap)
        
        
        dc.SetPen(wx.TRANSPARENT_PEN)
        dc.SetBrush(wx.Brush('#d4d0c8'))
        dc.DrawRectangle(0, 0, w, h)
        
        if board is None:
            return
        
        white_brush = wx.Brush('White')
        black_brush = wx.Brush('Black')
        rectangles = []
        brushes = []
        for x in xrange(board.width):
            for y in xrange(board.height):
                rectangles.append([(self.square_size + self.border_width) * x,
                                   (self.square_size + self.border_width) * y,
                                   self.square_size,
                                   self.square_size])
                brushes.append(black_brush if board.get(x,y) is True
                               else white_brush)

        transparent_pen = wx.Pen('#000000', 0, wx.TRANSPARENT)
        
        dc.DrawRectangleList(rectangles, transparent_pen, brushes)

        
    def on_paint(self, event):
        '''Paint event handler.'''
        
        event.Skip()
        
        (w, h) = self._get_size_from_board()
        self.SetVirtualSize((w, h))
        
        if self.redraw_needed_flag is True:
            self._draw_buffer_bitmap()
            self.redraw_needed_flag = False
                
        dc = wx.BufferedPaintDC(self)
        
        dc.SetBackground(wx_tools.get_background_brush())
        dc.Clear()
        
        dc.DrawBitmapPoint(self._buffer_bitmap,
                           self.CalcScrolledPosition((0, 0)))
        
                
        
    def on_size(self, event):
        '''EVT_SIZE handler.'''
        self.Refresh()
        if event is not None:

            event.Skip()

    def on_mouse_event(self, event):
        '''Mouse event handler.'''
        
        if event.LeftDown():
            pos = event.GetPositionTuple()
            thing = self.unscreenify(*pos)
            if thing is not None:
                (x, y) = thing
                old_value = self.board.get(x,y)
                new_value = (not old_value)

                new_state = self.gui_project.editing_state()
                new_board = new_state.board
                new_board.set(x, y, new_value)
            
                self.redraw_needed_flag = True

        self.Refresh()

########NEW FILE########
__FILENAME__ = state_creation_dialog
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `StateCreationDialog` class.

See its documentation for more info.
'''

import random
import warnings
import functools

import wx

from garlicsim_wx.widgets.general_misc.cute_dialog import CuteDialog

import garlicsim.data_structures


class StateCreationDialog(CuteDialog):
    '''Initial dialog for creating a root state.'''
    
    def __init__(self, frame):
        CuteDialog.__init__(self, frame, title='Creating a root state')
        
        self.frame = frame
        self.simpack = frame.gui_project.simpack

        hbox1 = wx.BoxSizer(wx.HORIZONTAL)
        self.x_title = x_title = wx.StaticText(self, -1, 'Width: ')
        self.x_textctrl = x_textctrl = wx.TextCtrl(self, -1, '45')
        self.y_title = y_title = wx.StaticText(self, -1, 'Height: ')
        self.y_textctrl = y_textctrl = wx.TextCtrl(self, -1, '25')
        hbox1.Add(x_title, 0, wx.ALIGN_CENTER | wx.EXPAND | wx.ALL, 5)
        hbox1.Add(x_textctrl, 0, wx.EXPAND | wx.ALIGN_CENTER | wx.RIGHT, 40)
        hbox1.Add(y_title, 0, wx.EXPAND | wx.ALIGN_CENTER | wx.RIGHT, 10)
        hbox1.Add(y_textctrl, 0, wx.EXPAND | wx.ALIGN_CENTER | wx.RIGHT, 5)

        hbox2 = wx.BoxSizer(wx.HORIZONTAL)
        self.empty = empty = wx.RadioButton(self, -1, 'All empty',
                                            style=wx.RB_GROUP)
        self.full = full = wx.RadioButton(self, -1, 'All full')
        self.random = random = wx.RadioButton(self, -1, 'Random')
        random.SetValue(True)
        hbox2.Add(empty, 0, wx.ALIGN_CENTER | wx.ALL, 5)
        hbox2.Add(full, 0, wx.ALIGN_CENTER | wx.ALL, 5)
        hbox2.Add(random, 0, wx.ALIGN_CENTER | wx.ALL, 5)
        
        vbox = wx.BoxSizer(wx.VERTICAL)

        last_hbox = wx.BoxSizer(wx.HORIZONTAL)
        ok = wx.Button(self, wx.ID_OK, 'Create state')
        ok.SetDefault()
        self.Bind(wx.EVT_BUTTON, self.on_ok, id=ok.GetId())
        cancel = wx.Button(self, wx.ID_CANCEL, 'Cancel')
        self.Bind(wx.EVT_BUTTON, self.on_cancel, id=cancel.GetId())
        last_hbox.Add(ok, 0)
        last_hbox.Add(cancel, 0, wx.LEFT, 5)

        vbox.Add(hbox1, 0, wx.ALIGN_CENTER | wx.TOP | wx.BOTTOM, 10)
        vbox.Add(hbox2, 0, wx.ALIGN_CENTER | wx.TOP | wx.BOTTOM, 10)
        vbox.Add(last_hbox, 1, wx.ALIGN_CENTER |  wx.BOTTOM, 10)

        self.SetSizer(vbox)
        vbox.Fit(self)
        ok.SetFocus()

        
    def on_ok(self, e=None):
        '''Do 'okay' on the dialog.'''

        def complain(message):
            dialog = wx.MessageDialog(self, message, 'Error',
                                      wx.ICON_ERROR | wx.OK)
            try:
                dialog.ShowModal()
            finally:
                dialog.Destroy()

        self.info = {}

        try:
            self.info['width'] = int(self.x_textctrl.GetValue())
        except ValueError:
            complain('Bad width!')
            return

        try:
            self.info['height'] = int(self.y_textctrl.GetValue())
        except ValueError:
            complain('Bad height!')
            return

        self.info['fill'] = 'full' if self.full.GetValue() else \
            'empty' if self.empty.GetValue() else 'random'

        self.EndModal(wx.ID_OK)

        
    def on_cancel(self, e=None):
        '''Do 'cancel' on the dialog.'''
        self.EndModal(wx.ID_CANCEL)

        
    def start(self):
        '''Start the dialog to make a new state.'''
        if self.ShowModal() == wx.ID_OK:
            width, height, fill = (
                self.info['width'],
                self.info['height'],
                self.info['fill']
            )
            state = self.simpack.State.create_root(width, height, fill)
        else:
            state = None
        self.Destroy()
        return state
        


########NEW FILE########
__FILENAME__ = state
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

import copy
import math
from math import pi
import random

import garlicsim.data_structures

class State(garlicsim.data_structures.State):
    '''World state. A frozen moment in time in the simulation world.'''
    
    def __init__(self, left, left_vel, right):
        self.left = left
        self.left_vel = left_vel
        self.right = right

    @staticmethod
    def create_root():
        return State(0, 0, 0)

    @staticmethod
    def create_messy_root():
        return State(
            random.random() * 2 * pi,
            0,
            random.random() * 2 * pi
        )
       
    @staticmethod
    def history_step(history_browser, t=0.1):
    
        last_state = history_browser.get_last_state()
        new_state = garlicsim.misc.state_deepcopy.state_deepcopy(last_state)
        new_state.clock += t
        
        useless_state = history_browser.get_state_by_clock(10000000)
        assert useless_state.clock == last_state.clock
        
        new_state.left_vel += random.random() * 0.2 - 0.1
        new_state.left += new_state.left_vel * t
        
        past_state = history_browser.get_state_by_clock(new_state.clock - 20)
        if past_state is not None:
            new_state.right = past_state.left
            
        return new_state

########NEW FILE########
__FILENAME__ = settings
from . import widgets

SEEK_BAR_GRAPHS = []
BIG_WORKSPACE_WIDGETS = [widgets.StateViewer]
SMALL_WORKSPACE_WIDGETS = []
########NEW FILE########
__FILENAME__ = state_viewer
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `StateViewer` class.

See its documentation for more information.
'''

import math
import wx

from garlicsim_wx.general_misc import wx_tools

import garlicsim_wx


class StateViewer(wx.Window, garlicsim_wx.widgets.WorkspaceWidget):
    '''Widget for showing a state onscreen.'''
    def __init__(self, frame):
        wx.Window.__init__(self, frame, style=wx.SUNKEN_BORDER)
        garlicsim_wx.widgets.WorkspaceWidget.__init__(self, frame)
        
        self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM)
        
        self.left = None
        self.right = None
        self.Bind(wx.EVT_PAINT, self.on_paint)
        self.radius = 60
        
        self.gui_project.active_node_changed_or_modified_emitter.add_output(
            lambda: self.load_state(self.gui_project.get_active_state())
        )
        
    def on_paint(self, event):
        '''Paint event handler.'''
        event.Skip()
        dc = wx.BufferedPaintDC(self)
                
        dc.SetBackground(wx_tools.get_background_brush())
        dc.Clear()
        
        dc.SetBrush(wx.Brush("white", wx.TRANSPARENT))
        for [side, pos] in [[self.left, (100, 100)], [self.right, (300, 100)]]:
            
            dc.SetPen(wx.Pen("black", 2))
            dc.DrawCirclePoint(pos, self.radius)
            
            if side is not None:
                point = (pos[0] + math.cos(side) * self.radius,
                         pos[1] + math.sin(side) * self.radius)
                dc.SetPen(wx.Pen("red", 20))
                dc.DrawLinePoint(point, point)
    
    def load_state(self, state):
        '''Load a state and show it onscreen.'''
        if state is None:
            return
        self.left, self.right = state.left, state.right
        self.Refresh()
        
########NEW FILE########
__FILENAME__ = base_player
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `BasePlayer` abstact base class.

See its documentation for more information.
'''

from garlicsim.general_misc.third_party import abc

from garlicsim.general_misc import identities

from .player_type import PlayerType


class BasePlayer(identities.HasIdentity):
    '''
    A player that plays prisoner's dilemma, gaining and losing points.
    
    This is an abstract base class; subclass this to implement actual playing
    strategies.
    '''
    
    __metaclass__ = PlayerType

    color = None
    '''
    Name of color that will represent this player class in a GUI. Optional.
    '''
        
    def __init__(self):
        identities.HasIdentity.__init__(self)
        
        self.points = 0
        '''The number of points that the player has.'''
        
        
    @abc.abstractmethod
    def make_move(self, round):
        '''
        Decide which move to make.
        
        Abstract method.
        
        `round` is the round number in the match, starting with 0.
        
        Note that no information about the other player is given to this
        method. Any state that a player subclass wants to have should be
        created by it and saved as data attributes to the player instance.
        
        Returns a boolean, `True` is "be nice" and `False` is "be mean".
        '''
        
    
    def other_player_played(self, move):
        '''
        The other player played `move` in the last round.
        
        A player subclass may implement here something that saves this move and
        takes it into account on subsequent rounds.
        '''
        pass
    
    
    def play_game(player_1, player_2, round):
        '''
        Have `player_1` and `player_2` play against each other.
        
        Each player will gain or lose points according to the outcome of the
        game.
        '''        
        assert isinstance(player_1, BasePlayer)
        assert isinstance(player_2, BasePlayer)
    
        player_1_move = player_1.make_move(round)
        player_2_move = player_2.make_move(round)
    
        assert isinstance(player_1_move, bool)
        assert isinstance(player_2_move, bool)
    
        ### Calculating outcome of game in points for each player: ############
        #                                                                     #
        if player_1_move is True and player_2_move is True:
            player_1.points += 1
            player_2.points += 1
            
        elif player_1_move is True and player_2_move is False:
            player_1.points += -4
            player_2.points += 2
            
        elif player_1_move is False and player_2_move is True:
            player_1.points += 2
            player_2.points += -4
            
        elif player_1_move is False and player_2_move is False:
            player_1.points += -1
            player_2.points += -1
        #                                                                     #
        ### Finished calculating outcome of game in points for each player. ###
    
        player_1.other_player_played(player_2_move)
        player_2.other_player_played(player_1_move)
########NEW FILE########
__FILENAME__ = angel
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `Angel` player type.

See its documentation for more information.
'''

from ..base_player import BasePlayer


class Angel(BasePlayer):
    '''Player which always plays nice.'''
    
    color = 'White'
    
    def make_move(self, round):
        '''Play nice.'''
        return True

########NEW FILE########
__FILENAME__ = devil
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `Devil` player type.

See its documentation for more information.
'''

from ..base_player import BasePlayer


class Devil(BasePlayer):
    '''Player which always plays mean.'''
    
    color = 'Black'
    
    def make_move(self, round):
        '''Play mean.'''
        return False
########NEW FILE########
__FILENAME__ = tit_for_tat
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `TitForTat` player type.

See its documentation for more information.
'''

from ..base_player import BasePlayer


class TitForTat(BasePlayer):
    '''
    Player which plays nice on the 1st round and afterwards imitates opponent.
    
    On the first round this player will always play nice. On every subsequent
    round, it will play the move that the opponent played on the previous
    round.
    
    This is a good strategy, because it allows the `TitForTat` player to
    cooperate with other `TitForTat` players and with `Angel` players, but it
    doesn't let any `Devil` players exploit it.
    '''
    
    color = 'Blue'
    
    def make_move(self, round):
        '''Play nice on 1st round, afterwards imitate opponent.'''
        if round == 0:
            self.last_play = None
            return True
        else:
            return self.last_play

    def other_player_played(self, move):
        '''Save the opponent's move so we can do the same on the next round.'''
        self.last_play = move


########NEW FILE########
__FILENAME__ = player_type
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `PlayerType` metaclass.

See its documentation for more information.
'''

from __future__ import absolute_import

import random
from garlicsim.general_misc.third_party import abc

from garlicsim.general_misc import caching


class PlayerType(abc.ABCMeta):
    '''Metaclass for player types.'''
        
    @caching.CachedProperty
    def wx_color(cls):
        '''The wxPython color that represents this player type in the GUI.'''
        import wx
        return wx.NamedColour(cls.color or 'Red')
    
    
    @staticmethod
    def create_player_of_random_type():
        '''Create a player of a random player type.'''
        from .players import player_types_list
        player_type = random.choice(player_types_list)
        return player_type()
        
########NEW FILE########
__FILENAME__ = settings
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Settings modules for the `prisoner` simpack.'''
########NEW FILE########
__FILENAME__ = state
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `State` class.

See its documentation for more information.
'''


import random

from garlicsim.general_misc import random_tools
from garlicsim.general_misc.infinity import infinity
from garlicsim.general_misc.persistent import CrossProcessPersistent

import garlicsim.data_structures

from .player_type import PlayerType
from .base_player import BasePlayer
from .players import player_types_list


BaseForHandicap = [object, CrossProcessPersistent][1]

class Handicap(BaseForHandicap):
    def __init__(self, thing, meow):
        self.thing, self.meow = thing, meow
        self.big_list = [random.random() for i in range(100000)]


class State(garlicsim.data_structures.State):
    '''World state. A frozen moment in time in the simulation world.'''
    
    def __init__(self, players, round=-1, match=0, n_rounds=7):
        '''
        Constructor.
        
        `players` is a list of players, i.e. instances of `BasePlayer`, that
        will play against each other. `round` is the round number, with `-1`
        being the preparation pseudo-round. `match` is the match number.
        `n_rounds` is the number of rounds in a match.
        '''
        
        assert -1 <= round <= (n_rounds - 1)
        self.round = round
        '''
        The round number.
        
        `-1` is the preparation pseudo-round, `0` is the first round, and
        `n_rounds - 1` is the last round in the match .
        '''
        
        assert 0 <= match <= infinity
        self.match = match
        '''The match number, going from `0` to infinity.'''
        
        assert all(isinstance(player, BasePlayer) for player in players)
        self.players = players
        '''The list of players that play against each other.'''
        
        assert n_rounds >= 1
        self.n_rounds = n_rounds
        '''The number of rounds in a match.'''
        
        self.handicap = Handicap('The thing', meow='The meow')
        
    
    @staticmethod
    def create_root(n_players=70, n_rounds=7):
        '''Create a plain and featureless world state.'''
        state = State(
            players=[player_types_list[i % len(player_types_list)]() for i
                     in xrange(n_players)],
            n_rounds=n_rounds
        )
        state._prepare_for_new_match(replace_loser=False)
        return state
    
    
    @staticmethod
    def create_messy_root(n_players=70, n_rounds=7):
        '''Create a random and messy world state.'''
        state = State(
            players=[PlayerType.create_player_of_random_type() for i
                     in xrange(n_players)],
            n_rounds=n_rounds
        )
        state._prepare_for_new_match(replace_loser=False)
        return state
    
        
    def inplace_step(self):
        '''Modify the state in-place to make it the next moment in time.'''
        
        self.clock += 1
    
        self.round += 1
        if self.round == self.n_rounds:
            self.round = -1
            self.match += 1
            self._prepare_for_new_match()
            return
    
        for player_1, player_2 in self.player_pairs:
            BasePlayer.play_game(player_1, player_2, self.round)
    
    
    def _prepare_for_new_match(self, replace_loser=True):
        '''
        Prepare a state with a `.round` of `-1` for the new match.
        
        Round -1 is a pseudo round in which the players get partitioned into
        pairs randomly. The two players in each player will play against each
        other in every round in the match, after which they'll be reassigned a
        new opponent.
        
        If `replace_loser` is set to `True`, the player with the least points
        will be removed and replaced with a player from a random player type.
        '''
        assert self.round == -1
        
        if replace_loser:
            loser = self.get_player_with_least_points()
            self.players.remove(loser)
            self.players.append(PlayerType.create_player_of_random_type())
    
        self.player_pairs = random_tools.random_partition(self.players, 2)
        
        
    def get_player_with_least_points(self):
        '''Get the player which has the lowest number of points.'''
        return min(self.players, key=lambda player: player.points)

    
    def get_n_players_of_given_type(self, player_type):
        '''Get the number of existing players of the type `player_type`.'''
        return len([player for player in self.players
                    if isinstance(player, player_type)])


########NEW FILE########
__FILENAME__ = settings
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Settings module for the `wx` component of the `prisoner` simpack.'''

from . import widgets

SEEK_BAR_GRAPHS = []
BIG_WORKSPACE_WIDGETS = [widgets.StateViewer]
SMALL_WORKSPACE_WIDGETS = []
########NEW FILE########
__FILENAME__ = state_viewer
1# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `StateViewer` class.

See its documentation for more information.
'''

import math

import wx
import wx.lib.agw.piectrl as piectrl

import garlicsim_wx

from garlicsim_lib.simpacks import _prisoner_persistent_test as prisoner


class StateViewer(wx.Panel, garlicsim_wx.widgets.WorkspaceWidget):
    '''Widget for viewing a `prisoner` state.'''
    def __init__(self, frame):
        wx.Panel.__init__(self, frame)
        garlicsim_wx.widgets.WorkspaceWidget.__init__(self, frame)

        self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM)
        
        self.pie_ctrl = piectrl.PieCtrl(self, style=wx.NO_BORDER)
        
        self.sizer_v = wx.BoxSizer(wx.VERTICAL)
        self.sizer_h = wx.BoxSizer(wx.HORIZONTAL)
        self.sizer_v.Add(self.sizer_h, 1, wx.EXPAND)
        self.sizer_h.Add(self.pie_ctrl, 1, wx.EXPAND)
        
        self.SetSizer(self.sizer_v)
        self.sizer_v.Layout()
        
        font = wx.Font(12, wx.SWISS, wx.NORMAL, wx.BOLD, True, 'Arial')
        self.pie_ctrl.GetLegend().SetLabelFont(font)
        self.pie_ctrl.SetAngle(math.pi)
    
        self.pie_part_dict = {}
        for player_type in prisoner.players.player_types_list:
            part = piectrl.PiePart()
            part.SetLabel(player_type.__name__)
            part.SetValue(1)
            part.SetColour(player_type.wx_color)
            self.pie_ctrl._series.append(part)
            self.pie_part_dict[player_type] = part
            
        self.gui_project.active_node_changed_or_modified_emitter.add_output(
            lambda: self.show_state(self.gui_project.get_active_state())
        )
            
    def show_state(self, state):
        '''Show a state onscreen.'''
        if state is None:
            return
        for player_type in prisoner.players.player_types_list:
            part = self.pie_part_dict[player_type]
            value = state.get_n_players_of_given_type(player_type)
            part.SetValue(value)
        self.Refresh()

########NEW FILE########
__FILENAME__ = _test_garlicsim_lib
#!/usr/bin/env python

# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Script for launching `garlicsim_lib` tests when installed in local Python.
'''

import test_garlicsim_lib


if __name__ == '__main__':
    test_garlicsim_lib.invoke_nose()
########NEW FILE########
__FILENAME__ = test_import
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Testing module for `garlicsim_lib`.'''


def test_import():
    '''
    Test that `garlicsim_lib` can be imported.
    
    This is mostly a dummy test used for testing the test mechanism itself.
    '''
    import garlicsim_lib
    
    import garlicsim_lib.simpacks
    assert 'simpacks' in vars(garlicsim_lib)
    assert garlicsim_lib.simpacks.__name__ == 'garlicsim_lib.simpacks'
    
    
########NEW FILE########
__FILENAME__ = app
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `App` class.

See its documentation for more information.
'''

import functools
import sys

import wx

from garlicsim.general_misc import import_tools

import garlicsim_wx


class App(wx.PySimpleApp):
    '''
    A `garlicsim_wx` application.
    
    The `App` is responsible for spawning a `Frame`.
    '''
    # todo: need to think if i allow frames with no app. on one hand good idea,
    # to allow people to start a garlicsim_wx frame in their own app. on other
    # hand frames will need to know how to start another frame.
    def __init__(self, new_gui_project_simpack_name=None,
                 load_gui_project_file_path=None):
        '''
        Constructor.
        
        In order to start a new simulation on startup, pass the name of the
        simpack as `new_gui_project_simpack_name`.
        
        In order to load a simulation from file on startup, pass the path to
        the file as `load_gui_project_file_path`.
        
        (At most one of these can be done.)
        '''
        self.frame = None
        assert not (new_gui_project_simpack_name and
                    load_gui_project_file_path)
        self.new_gui_project_simpack_name = new_gui_project_simpack_name
        self.load_gui_project_file_path = load_gui_project_file_path
        super(App, self).__init__()
        
        if '--wx-debug=on' not in sys.argv:
            self.SetAssertMode(wx.PYAPP_ASSERT_SUPPRESS)
        
    
    def OnInit(self):
        
        frame = garlicsim_wx.Frame(
            parent=None,
            title='GarlicSim',
            size=(1140, 850)
        )
        
        self.frame = frame
        
        self.SetTopWindow(frame)
        
        if self.new_gui_project_simpack_name is not None:
            simpack = \
                import_tools.normal_import(self.new_gui_project_simpack_name)
            
            wx.CallAfter(
                functools.partial(
                    self.frame._new_gui_project_from_simpack,
                    simpack
                )
            )
            
        if self.load_gui_project_file_path is not None:
            
            wx.CallAfter(
                functools.partial(
                    self.frame._open_gui_project_from_path,
                    self.load_gui_project_file_path
                )
            )
            
        return True
    
########NEW FILE########
__FILENAME__ = bootstrap
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Bootstrap module for `garlicsim_wx`.

It checks all prerequisites are installed.
'''

import warnings
import sys


### Confirming correct Python version: ########################################
#                                                                             #
if sys.version_info[0] >= 3:
    raise Exception('This package is not compatible with Python 3.x.')
if sys.version_info[1] <= 4:
    raise Exception('This package requires Python 2.5 and upwards. (Not '
                    'including 3.x).')
#                                                                             #
### Finished confirming correct Python version. ###############################


def __check_prerequisites():
    '''
    Check that all modules required for `garlicsim_wx` are installed.
    
    Returns a list of some imported modules: A reference to this list should be
    kept alive so to prevent the imported modules from being garbage-collected,
    which would cause Python to load them twice, which would needlessly
    increase startup time.
    '''
    
    modules = []
    
    class MissingModule(Exception):
        '''A required module is not found.'''
    
    def check_garlicsim():
        try:
            import garlicsim
        except ImportError:
            raise MissingModule("`garlicsim` is required, but it's not "
                                "currently installed on your system. Go to "
                                "http://garlicsim.org and follow the "
                                "instructions for installation.")
        else:
            if garlicsim.__version_info__ < (0, 6, 3):
                raise MissingModule("You have `garlicsim` version %s, while "
                                    "version 0.6.3 is required. Go to "
                                    "http://garlicsim.org and follow the "
                                    "instructions for installation." %
                                    (garlicsim.__version_info__,))
            return [garlicsim]
    
    def check_wx():
        try:
            import wx
            
        except ImportError:
            raise MissingModule("wxPython (version 2.8.10.1 and upwards, but "
                                "lower than 2.9) is required, but it's not "
                                "currently installed on your system. Please "
                                "go download it at http://wxpython.org, "
                                "install it, then try again.")
        
        else:
            wx_version = tuple(int(x) for x in wx.__version__.split('.'))
            if not ((2, 8, 10, 1) <= wx_version < (2, 9, 1, 1)):
                warnings.warn("You have wxPython version %s installed, while "
                              "version 2.8.10.1 or higher (but lower than "
                              "2.9) is needed. This program will try to run "
                              "now, and if you're lucky it will work alright, "
                              "but if any problem comes up, try upgrading "
                              "wxPython. To do that, download and install the "
                              "latest version from "
                              "http://wxpython.org" % (wx.__version__,))
            return [wx]
    

    checkers = [check_garlicsim, check_wx]
    
    for checker in checkers:
        modules += checker()
    
    return modules

__modules_list = __check_prerequisites()
########NEW FILE########
__FILENAME__ = bootstrap_wx
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Monkeypatches `wx` to politely tell us that `wx` objects are non-pickleable.
'''

import wx
if not hasattr(wx.Object, '_is_atomically_pickleable'):
    wx.Object._is_atomically_pickleable = False
########NEW FILE########
__FILENAME__ = frame
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `Frame` class.

See its documentation for more information.
'''

from __future__ import with_statement

import os.path
import sys
import subprocess
import warnings
import traceback

import wx
from garlicsim_wx.general_misc.third_party import aui
import pkg_resources

from garlicsim.general_misc.temp_value_setters import TempRecursionLimitSetter
from garlicsim_wx.general_misc import thread_timer
from garlicsim_wx.general_misc import misc_tools
from garlicsim_wx.general_misc import wx_tools

import garlicsim
from garlicsim_wx.gui_project import GuiProject
import garlicsim_wx.widgets
import garlicsim_wx.misc
from garlicsim_wx.widgets import workspace_widgets
from garlicsim_wx import misc

from . import images as __images_package
images_package = __images_package.__name__


wildcard_text = ('GarlicSim Simulation Pickle (*.gssp)|*.gssp|'
                 'All files (*)|*')


class Frame(wx.Frame):
    '''
    The main window of `garlicsim_wx`.
    
    This window allows the user to create and manipulate gui projects.
    '''
    def __init__(self, *args, **kwargs):
        wx.Frame.__init__(self, *args, **kwargs)
        
        self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM)
        self.SetBackgroundColour(wx_tools.get_background_color())
        
        self.SetDoubleBuffered(True)
        self.SetIcons(garlicsim_wx.misc.icon_bundle.get_icon_bundle())
        
        self.Bind(wx.EVT_CLOSE, self.on_close)
        
        self.app = wx.GetApp()
        '''The GarlicSim `App` that created this frame.'''
        
        assert isinstance(self.app, garlicsim_wx.App)
        
        if hasattr(garlicsim_wx, '_active_frame'):
            warnings.warn('`garlicsim_wx` already had an `_active_frame` '
                          'attribute before we created this frame! It should '
                          'not have one.')
        garlicsim_wx._active_frame = self
        
        self.tree_browser = None
        self.seek_bar = None
        self.shell = None
        self.state_repr_viewer = None
        self.crunching_controls = None
        
        self.aui_manager = garlicsim_wx.misc.aui.AuiManager(self)
        '''The aui manager, which manages the workspace widgets.'''
                
        self.gui_project = None
        '''The current gui project.'''
        
        self.CreateStatusBar()
        
        self.__init_menus()
        self.__init_key_handlers()
        
        self.Bind(wx.EVT_CONTEXT_MENU, self.on_context_menu, self)
        
        self.background_timer = thread_timer.ThreadTimer(self)
        
        self.background_timer.start(150)
        
        self.Bind(
            thread_timer.EVT_THREAD_TIMER,
            lambda event: self.sync_crunchers(),
            self.background_timer
        )
        
        self.aui_manager.Update()
        
        self.Show()
        
        self.Maximize()

        
    def __init_menus(self):
        '''Initialize the menu bar and the context menu.'''
        menu_bar = self.menu_bar = garlicsim_wx.misc.MenuBar(self)
        self.SetMenuBar(menu_bar)
        self._recalculate_all_menus()
        self.context_menu = \
            garlicsim_wx.general_misc.cute_menu.CuteMenu.add_menus([
                garlicsim_wx.misc.menu_bar.node_menu.NodeMenu(self),
                garlicsim_wx.misc.menu_bar.block_menu.BlockMenu(self)
            ])
        
        
    def _recalculate_all_menus(self):
        '''Recalculate all the menus, determining in which state they'll be.'''
        try_recalculate = lambda thing: \
            thing._recalculate() if hasattr(thing, '_recalculate') else None
        
        menus_to_recalculate = \
            [menu for (menu, label) in self.menu_bar.GetMenus()]
        # todo: Should be calculating context menu too?
        
        while menus_to_recalculate:
            menu = menus_to_recalculate.pop()
            for item in menu.GetMenuItems():
                if item.IsSubMenu():
                    menus_to_recalculate.append(item.GetSubMenu())
                else:
                    try_recalculate(item)
            try_recalculate(menu)
        try_recalculate(self.menu_bar)

        
    def __init_key_handlers(self):
        '''Initialize key shortcuts.'''
        
        self.Bind(wx.EVT_KEY_DOWN, self.on_key_down)
        
        def on_home():
            '''Go to root node.'''
            if self.gui_project is not None and \
               self.gui_project.path is not None:
                
                try:
                    self.gui_project.set_active_node(self.gui_project.path[0])
                except LookupError:
                    pass

                
        def on_end():
            '''Go to leaf node.'''
            if self.gui_project is not None and \
               self.gui_project.path is not None:
                
                try:
                    self.gui_project.set_active_node(self.gui_project.path[-1])
                except LookupError:
                    pass

                
        def on_up():
            '''Go one path upwards.'''
            if self.gui_project and self.gui_project.path and \
               self.gui_project.active_node:
                try:
                    new_path = self.gui_project.path._get_lower_path(
                        self.gui_project.active_node
                    )
                except LookupError:
                    return
                pseudoclock = self.gui_project.pseudoclock
                self.gui_project.path = new_path
                self.gui_project.path_changed_emitter.emit()
                self.gui_project.set_pseudoclock(pseudoclock)

                
        def on_down():
            '''Go one path downwards.'''
            if self.gui_project and self.gui_project.path and \
               self.gui_project.active_node:
                try:
                    new_path = self.gui_project.path._get_higher_path(
                        self.gui_project.active_node
                    )
                except LookupError:
                    return
                pseudoclock = self.gui_project.pseudoclock
                self.gui_project.path = new_path
                self.gui_project.path_changed_emitter.emit()
                self.gui_project.set_pseudoclock(pseudoclock)
                
                
        def on_left():
            '''Go one node backwards.'''
            if self.gui_project is not None and \
               self.gui_project.active_node is not None:
                
                parent = self.gui_project.active_node.parent
                if parent is not None:
                    self.gui_project.set_active_node(parent)
        
                    
        def on_right():
            '''Go one node forward.'''
            if self.gui_project is not None and \
               self.gui_project.path is not None and \
               self.gui_project.active_node is not None:
                
                try:
                    child = self.gui_project.path.next_node\
                          (self.gui_project.active_node)
                    self.gui_project.set_active_node(child)
                except LookupError:
                    pass
            
                
        def on_command_left():
            '''Go five nodes backwards.'''
            if self.gui_project is not None and \
               self.gui_project.active_node is not None:
                
                node = self.gui_project.active_node.get_ancestor(5, round=True)
                if node:
                    self.gui_project.set_active_node(node)
        
                    
        def on_command_right():
            '''Go five nodes forward.'''
            if self.gui_project is not None and \
               self.gui_project.path is not None and \
               self.gui_project.active_node is not None:
                
                current = self.gui_project.active_node
                for i in xrange(5):
                    try:
                        current = self.gui_project.path.next_node(current)
                    except LookupError:
                        pass
                self.gui_project.set_active_node(current)
        
                
        def on_page_up():
            '''Go 20 nodes backwards.'''
            if self.gui_project is not None and \
               self.gui_project.active_node is not None:
                
                node = self.gui_project.active_node.get_ancestor(20,
                                                                 round=True)
                if node:
                    self.gui_project.set_active_node(node)
        
                    
        def on_page_down():
            '''Go 20 nodes forward.'''
            if self.gui_project is not None and \
               self.gui_project.path is not None and \
               self.gui_project.active_node is not None:
                
                current = self.gui_project.active_node
                for i in xrange(20):
                    try:
                        current = self.gui_project.path.next_node(current)
                    except LookupError:
                        pass
                self.gui_project.set_active_node(current)

                
        def on_space():
            '''Toggle onscreen playback.'''
            if self.gui_project:
                self.gui_project.toggle_playing()
        
                
        def on_return():
            '''Finalize the active node, if it's in editing.'''

            if self.gui_project and self.gui_project.active_node \
               and self.gui_project.active_node.still_in_editing:
                
                self.gui_project.finalize_active_node()

        
                
        
        self.key_handlers = {
            wx_tools.Key(wx.WXK_HOME): on_home,
            wx_tools.Key(wx.WXK_END): on_end,
            wx_tools.Key(wx.WXK_UP): on_up,
            wx_tools.Key(wx.WXK_DOWN): on_down,
            wx_tools.Key(wx.WXK_LEFT): on_left,
            wx_tools.Key(wx.WXK_RIGHT): on_right,
            wx_tools.Key(wx.WXK_LEFT, cmd=True): on_command_left,
            wx_tools.Key(wx.WXK_RIGHT, cmd=True): on_command_right,
            wx_tools.Key(wx.WXK_PAGEUP): on_page_up,
            wx_tools.Key(wx.WXK_PAGEDOWN): on_page_down,
            wx_tools.Key(wx.WXK_SPACE): on_space,
            wx_tools.Key(wx.WXK_RETURN): on_return,
        }    
            
        
    def on_close(self, event):
        '''Close the frame.'''
        if self.gui_project:
            self.gui_project.stop_playing()
        self.aui_manager.UnInit()
        self.Destroy()
        garlicsim_wx.general_misc.cute_base_timer.CuteBaseTimer.\
            stop_timers_by_frame(self)
        event.Skip()        
        self.background_timer.stop()

        
    def finalize_active_node(self, e=None):
        '''Finalize editing of the active node in the active gui project.'''
        assert self.gui_project
        return self.gui_project.finalize_active_node()

    
    def on_new(self, event=None):
        '''Create a new gui project.'''        
        
        if self.gui_project is not None:
            
            if hasattr(sys, 'frozen'):
                program_to_run = [sys.executable]
                we_are_main_program = 'GarlicSim' in sys.executable
            else:
                main_script = os.path.abspath(sys.argv[0])
                program_to_run = [sys.executable, main_script]
                we_are_main_program = ('run_gui' in main_script) or \
                                    ('garlicsim_wx' in main_script) or \
                                    ('GarlicSim' in main_script)
            
            if not we_are_main_program:
                warning_dialog = \
                    garlicsim_wx.widgets.misc.NotMainProgramWarningDialog(self)
                try:
                    if warning_dialog.ShowModal() != wx.ID_YES:
                        return
                finally:
                    warning_dialog.Destroy()
        
        dialog = garlicsim_wx.widgets.misc.SimpackSelectionDialog(self)
        
        try:
            if dialog.ShowModal() == wx.ID_OK:
                simpack = dialog.get_simpack_selection()
            else:
                dialog.Destroy()
                return
        finally:
            dialog.Destroy()

        
        if self.gui_project is None:
            self._new_gui_project_from_simpack(simpack)
        else:    
                
            program_to_run.append('__garlicsim_wx_new=%s' % simpack.__name__)
            for simpack_place in garlicsim_wx.simpack_places:
                program_to_run.append('__garlicsim_wx_simpack_place=%s' % \
                                      ','.join(simpack_place))
         
            with wx_tools.CursorChanger(self, wx.CURSOR_WAIT):
                subprocess.Popen(program_to_run)
            
            return
            
    def _new_gui_project_from_simpack(self, simpack):
        '''
        Start a new gui project, given the simpack to start it with.
        
        Internal use.
        '''
        assert self.gui_project is None
        with wx_tools.CursorChanger(self, wx.CURSOR_WAIT):
            gui_project = GuiProject(simpack, self)
            self.__setup_gui_project(gui_project)

        
    def on_exit_menu_button(self, event):
        '''Exit menu button handler.'''
        self._post_close_event()

        
    def _post_close_event(self):
        '''Post a close event to the frame.'''
        event = wx.PyEvent(self.Id)
        event.SetEventType(wx.wxEVT_CLOSE_WINDOW)
        wx.PostEvent(self, event)
        
        
    def sync_crunchers(self):
        '''
        Take work from the crunchers, and give them new instructions if needed.
                
        (This is a wrapper that calls the sync_crunchers method of all the
        gui projects.)
        
        Talks with all the crunchers, takes work from them for implementing
        into the tree, retiring crunchers or recruiting new crunchers as
        necessary.
        
        Returns the total amount of nodes that were added to each gui project's
        tree.
        '''
        nodes_added = self.gui_project.sync_crunchers() \
                    if self.gui_project else 0
        
        if nodes_added > 0:
            pass#self.Refresh()
        
        return nodes_added
    
    
    
    def __setup_gui_project(self, gui_project):
        '''
        Setup a newly-created gui project.
        
        Internal use.
        '''
        
        assert isinstance(gui_project, GuiProject)
        
        self.gui_project = gui_project
        
        # todo: should create StateReprViewer only if the simpack got no
        # workspace widgets
        
        with wx_tools.WindowFreezer(self):
            
            self.tree_browser = workspace_widgets.TreeBrowser(self)
            self.aui_manager.AddPane(
                self.tree_browser,
                aui.AuiPaneInfo()\
                .Bottom().Row(0)\
                .BestSize(1000, 100).MinSize(200, 50).MaxSize(10000, 250)\
                .Caption(self.tree_browser.get_uppercase_name())
                .Floatable(False)\
                .CloseButton(False)
            )
            
            self.playback_controls = workspace_widgets.PlaybackControls(self)
            self.aui_manager.AddPane(
                self.playback_controls,
                aui.AuiPaneInfo()\
                .Bottom()\
                .BestSize(184, 128).MinSize(184, 128).MaxSize(184, 128)\
                .Caption(self.playback_controls.get_uppercase_name())
                .Resizable(False)\
                .CloseButton(False)\
                .Gripper(True)
            )
            
            self.seek_bar = workspace_widgets.SeekBar(self)
            self.aui_manager.AddPane(
                self.seek_bar,
                aui.AuiPaneInfo()\
                .Bottom().Row(1)\
                .BestSize(600, 40).MinSize(200, 40).MaxSize(10000, 100)\
                .Caption(self.seek_bar.get_uppercase_name())
                .Floatable(False)\
                .CloseButton(False)
            )
            
            self.shell = workspace_widgets.Shell(self)
            self.aui_manager.AddPane(
                self.shell,
                aui.AuiPaneInfo()\
                .Right().Row(0)\
                .BestSize(400, 600)\
                .Caption(self.shell.get_uppercase_name())
                .MaximizeButton(True)\
                .CloseButton(False)\
                .Gripper(True)
            )
            
            
            self.crunching_controls = workspace_widgets.CrunchingControls(self)
            self.aui_manager.AddPane(
                self.crunching_controls,
                aui.AuiPaneInfo()\
                .Left().Row(0)\
                .BestSize(280, 600)\
                .Caption(self.crunching_controls.get_uppercase_name())
                .CloseButton(True)\
                .Gripper(True)
            )
            
            """
            self.state_repr_viewer = workspace_widgets.StateReprViewer(self)
            self.aui_manager.AddPane(
                self.state_repr_viewer,
                aui.AuiPaneInfo()\
                .BestSize(300, 300)\
                .MaximizeButton(True)\
                .Center()\
                .Caption(self.state_repr_viewer.get_uppercase_name())
                .Floatable(False)\
                .CloseButton(False)
            )
            """
            settings_wx = self.gui_project.simpack_wx_grokker.settings
            
    
            big_widget_class = settings_wx.BIG_WORKSPACE_WIDGETS[0] if \
                             settings_wx.BIG_WORKSPACE_WIDGETS else \
                             workspace_widgets.StateReprViewer
    
            self.big_widget = big_widget_class(self)
            self.aui_manager.AddPane(
                self.big_widget,
                aui.AuiPaneInfo()\
                .BestSize(300, 300)\
                .MaximizeButton(True)\
                .Center()\
                .Caption(self.big_widget.get_uppercase_name())
                .Floatable(False)\
                .CloseButton(False)
            )
            
            if isinstance(self.big_widget, workspace_widgets.StateReprViewer):
                self.state_repr_viewer = self.big_widget
            
            """
            big_widget_classes = \
                settings_wx.BIG_WORKSPACE_WIDGETS #+ \
            #    [workspace_widgets['StateReprViewer']]
            
            self.big_widgets = []
            # todo: not the right way, should be easy listing of all widget
            
            
            for i, BigWidget in enumerate(big_widget_classes):
                big_widget = BigWidget(self)
                self.aui_manager.AddPane(
                    big_widget,
                    aui.AuiPaneInfo()\
                    .BestSize(300, 300)\
                    .MaximizeButton(True)\
                    .Center()\
                    .Caption(big_widget.get_uppercase_name())\
                    .Floatable(False)\
                    .CloseButton(False),
                    target=self.state_repr_viewer.get_aui_pane_info()
                )
                #.NotebookPage(notebook_id, i)\
                self.big_widgets.append(big_widget)
    
            """
            
            if gui_project._temp_shell_history is not None:
                assert isinstance(gui_project._temp_shell_history, basestring)
                self.shell.SetText('')
                self.shell.write(gui_project._temp_shell_history)
                self.shell.push('')
                gui_project._temp_shell_history = None
                
            if gui_project._temp_shell_command_history is not None:
                assert isinstance(gui_project._temp_shell_command_history,
                                  list)
                self.shell.history = gui_project._temp_shell_command_history[:]
                gui_project._temp_shell_command_history = None
            
                
                
            self.aui_manager.Update()
        
        self.gui_project.emitter_system.top_emitter.emit()
        
    
    def on_open(self, event=None):
        '''Raise a dialog for opening a gui project from file.'''
        
        if self.gui_project is not None:
            
            if hasattr(sys, 'frozen'):
                program_to_run = [sys.executable]
                we_are_main_program = 'GarlicSim' in sys.executable
            else:
                main_script = os.path.abspath(sys.argv[0])
                program_to_run = [sys.executable, main_script]
                we_are_main_program = ('run_gui' in main_script) or \
                                    ('garlicsim_wx' in main_script) or \
                                    ('GarlicSim' in main_script)
            
            if not we_are_main_program:
                dialog = \
                    garlicsim_wx.widgets.misc.NotMainProgramWarningDialog(self)
                try:
                    if dialog.ShowModal() != wx.ID_YES:
                        return
                finally:
                    dialog.Destroy()
        
        # Todo: something more sensible here. Ideally should be last place you
        # saved in, but for starters can be desktop.
        folder = os.getcwd()
        
        gui_project_vars = None

        open_dialog = wx.FileDialog(self, message='Choose a file',
                                    defaultDir=folder, defaultFile='',
                                    wildcard=wildcard_text, style=wx.OPEN)
        try:
            if open_dialog.ShowModal() == wx.ID_OK:
                path = open_dialog.GetPath()
                
                if self.gui_project is None:
                    self._open_gui_project_from_path(path)
                else:
                    if hasattr(sys, 'frozen'):
                        program = [sys.executable]
                    else:
                        program = \
                            [sys.executable, os.path.abspath(sys.argv[0])]
                        
                    program.append(path)
            
                    for simpack_place in garlicsim_wx.simpack_places:
                        program.append('__garlicsim_wx_simpack_place=%s' % \
                                       ','.join(simpack_place))
                    
                    with wx_tools.CursorChanger(self, wx.CURSOR_WAIT):
                        subprocess.Popen(program)
        finally:
            open_dialog.Destroy()
                        
            
    def _open_gui_project_from_path(self, path):
        '''
        Open a gui project saved to a file specified by `path`.
        
        Internal use.
        '''
        
        with TempRecursionLimitSetter(10000):
            try:
                with open(path, 'rb') as my_file:
                    with wx_tools.CursorChanger(self, wx.CURSOR_WAIT):
                        unpickler = misc.pickling.Unpickler(my_file)
                        gui_project = unpickler.load()
                
            except Exception, exception:
                dialog = wx.MessageDialog(
                    self,
                    'Error opening file:\n' + traceback.format_exc(),
                    style=(wx.OK | wx.ICON_ERROR)
                )
                try:
                    dialog.ShowModal()
                finally:
                    dialog.Destroy()
                return
                        
        self.__setup_gui_project(gui_project)

    
    
    def on_save(self, event=None):
        '''Raise a dialog for saving a gui project to file.'''
        
        assert self.gui_project is not None
        
        folder = os.getcwd()
        
        save_dialog = wx.FileDialog(self, message='Save file as...',
                                    defaultDir=folder, defaultFile='',
                                    wildcard=wildcard_text,
                                    style=wx.SAVE | wx.OVERWRITE_PROMPT)
        try:
            if save_dialog.ShowModal() == wx.ID_OK:
                path = save_dialog.GetPath()
                
                # Adding extension if got a plain file because wxPython doesn't
                # give the checkbox that's supposed to do it on Mac:
                path = misc_tools.add_extension_if_plain(path, '.gssp')
                
                
                with TempRecursionLimitSetter(10000):
                    try:
                        with open(path, 'wb') as my_file:
                            with wx_tools.CursorChanger(self, wx.CURSOR_WAIT):
                                with self.gui_project.project.tree.lock.read:
                                    pickler = misc.pickling.Pickler(
                                        my_file,
                                        protocol=2,
                                    )
                                    pickler.dump(self.gui_project)
        
                    except Exception, exception:
                        error_dialog = wx.MessageDialog(
                            self,
                            'Error saving to file:\n' + traceback.format_exc(),
                            style=(wx.OK | wx.ICON_ERROR)
                        )
                        error_dialog.ShowModal()
                        error_dialog.Destroy()
            
        finally:
            save_dialog.Destroy()
    
    """    
    def delete_gui_project(self,gui_project):
        I did this wrong.
        self.gui_projects.remove(gui_project)
        self.notebook.AddPage(gui_project.main_window,"zort!")
        self.notebook.DeletePage(0)
        del gui_project
    """
    
    
    def on_key_down(self, event):
        '''wx.EVT_KEY_DOWN handler.'''
        key = wx_tools.Key.get_from_key_event(event)
        handler = self.key_handlers.get(key, None)
        if handler:
            handler()
        else:
            event.Skip()
            
            
    def on_context_menu(self, event):
        '''wx.EVT_CONTEXT_MENU handler.'''
        abs_position = event.GetPosition()
        if abs_position == wx.DefaultPosition:
            position = (0, 0)
        else:
            position = self.ScreenToClient(abs_position)
            
        self.PopupMenu(self.context_menu, position)
        
    
    

########NEW FILE########
__FILENAME__ = color_tools
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Defines tools for manipulating colors.'''


def mix_rgb(ratio, rgb1, rgb2):
    '''Mix two rgb colors `rgb1` and `rgb2`, according to the given `ratio`.'''
    counter_ratio = 1 - ratio
    return (
        rgb1[0] * ratio + rgb2[0] * counter_ratio,
        rgb1[1] * ratio + rgb2[1] * counter_ratio,
        rgb1[2] * ratio + rgb2[2] * counter_ratio
    )
        
########NEW FILE########
__FILENAME__ = cursor_collection
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''A collection of cursors.'''

# todo: change to use generic caching decorator

import pkg_resources
import wx

from . import images as __images_package
images_package = __images_package.__name__

cached_cursors = {}

def get_open_grab():
    '''Get the "open grab" cursor.'''
    name = 'open_grab'
    file_name = 'open_grab.png'
    hotspot = (8, 8)
    if name in cached_cursors:
        return cached_cursors[name]
    stream = pkg_resources.resource_stream(images_package,
                                           file_name)
    image = wx.ImageFromStream(stream, wx.BITMAP_TYPE_ANY)

    if hotspot is not None:
        image.SetOptionInt(wx.IMAGE_OPTION_CUR_HOTSPOT_X, hotspot[0])
        image.SetOptionInt(wx.IMAGE_OPTION_CUR_HOTSPOT_Y, hotspot[1])
        
    cursor = wx.CursorFromImage(image)
    cached_cursors[name] = cursor
    return cursor


def get_closed_grab():
    '''Get the "closed grab" cursor.'''
    name = 'closed_grab'
    file_name = 'closed_grab.png'
    hotspot = (8, 8)
    if name in cached_cursors:
        return cached_cursors[name]
    stream = pkg_resources.resource_stream(images_package,
                                           file_name)
    image = wx.ImageFromStream(stream, wx.BITMAP_TYPE_ANY)

    if hotspot is not None:
        image.SetOptionInt(wx.IMAGE_OPTION_CUR_HOTSPOT_X, hotspot[0])
        image.SetOptionInt(wx.IMAGE_OPTION_CUR_HOTSPOT_Y, hotspot[1])
        
    cursor = wx.CursorFromImage(image)
    cached_cursors[name] = cursor
    return cursor

########NEW FILE########
__FILENAME__ = cute_base_timer
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `CuteBaseTimer` class.

See its documentation for more information.
'''

class CuteBaseTimer(object):
    '''A base class for timers, allowing easy central stopping.'''    
    __timers = [] # todo: change to weakref list
    
    def __init__(self, parent):
        self.__parent = parent
        CuteBaseTimer.__timers.append(self)
        
        
    @staticmethod # should be classmethod?
    def stop_timers_by_frame(frame):
        '''Stop all the timers that are associated with the given frame.'''
        for timer in CuteBaseTimer.__timers:
            ancestor = timer.__parent
            while ancestor:
                if ancestor == frame:
                    timer.Stop()
                    break
                ancestor = ancestor.GetParent()
    
########NEW FILE########
__FILENAME__ = cute_menu
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `CuteMenu` class.

See its documentation for more information.
'''

import wx
from garlicsim.general_misc.third_party import abc


class CuteMenu(wx.Menu):
    '''Menu class that allows easy adding of menus.'''
    
    __metaclass__ = abc.ABCMeta
        
    @abc.abstractmethod
    def _build(self):
        '''Build the menu, populating it with items and/or submenus.'''
    
    @staticmethod
    def add_menus(menus):
        '''
        Build a menu from a sequence of smaller menus.
        
        A separator will come between the items of one menu to the the items of
        the next.
        '''
        big_menu = UnbuildableCuteMenu()
    
        first_run = True
    
        for menu in menus:

            assert isinstance(menu, CuteMenu)
            
            if not first_run:
                big_menu.AppendSeparator()
                assert big_menu.frame is menu.frame
            else:
                big_menu.frame = menu.frame
                first_run = False
                
            type(menu).__dict__['_build'](big_menu)
                
        return big_menu
    
    
    def enable_in_menu_bar(self, enable=True):
        '''Enable (or disable) this menu in its containing menu bar.'''
        menu_bar = self.GetMenuBar()
        menu_bar.EnableTop(
            self._get_number_in_menu_bar(),
            enable
        )
        
        
    def _get_number_in_menu_bar(self):
        '''Get the index number of this menu in its containing menu bar.'''
        # todo: check if we even have a menu bar, otherwise throw helpful
        # exception.
        menu_bar = self.GetMenuBar()
        for (i, (menu, title)) in enumerate(menu_bar.GetMenus()):
            if menu is self:
                return i
        raise Exception
    
    
class UnbuildableCuteMenu(CuteMenu):
    '''
    CuteMenu that can't be built.
    
    This is useful when creating a Menu with `CuteMenu.add_menus`.
    '''
    def _build(self):
        raise Exception("Can't _build an UnbuildableCuteMenu.")
########NEW FILE########
__FILENAME__ = cute_timer
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `CuteTimer` class.

See its documentation for more information.
'''

import wx

from garlicsim_wx.general_misc import cute_base_timer


__all__ = ['CuteTimer']


class CuteTimer(wx.Timer, cute_base_timer.CuteBaseTimer):
    '''A wx.Timer that allows central stopping.'''
    # todo: Should use PyTimer?
    def __init__(self, parent=None, id=wx.ID_ANY):
        wx.Timer.__init__(self, parent, id)
        cute_base_timer.CuteBaseTimer.__init__(self, parent)
        
########NEW FILE########
__FILENAME__ = emitter
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `Emitter` class.

See its documentation for more info.
'''

# todo: there should probably be some circularity check. Maybe actually
# circularity should be permitted?

# todo: make some way to emit from multiple emitters simulataneously, saving
# redundant calls to shared callable outputs.

import itertools
from garlicsim.general_misc import cute_iter_tools
from garlicsim.general_misc import misc_tools
from garlicsim.general_misc import address_tools
        

class Emitter(object):
    '''
    An emitter you can `emit` from to call all its callable outputs.
    
    The emitter idea is a variation on the publisher-subscriber design pattern.

    Every emitter has a set of inputs and a set of outputs. The inputs, if
    there are any, must be emitters themselves. So when you `emit` on any of
    this emitter's inputs, it's as if you `emit`ted on this emitter as well.
    (Recursively, of course.)
    
    The outputs are a bit different. An emitter can have as outputs both (a)
    other emitters and (b) callable objects. (Which means, functions or
    function-like objects.)
    
    There's no need to explain (a): If `emitter_1` has as an output
    `emitter_2`, then `emitter_2` has as an input `emitter_1`, which works like
    how we explained above about inputs.
    
    But now (b): An emitter can have callables as outputs. (Without these, the
    emitter idea won't have much use.) These callables simply get called
    whenever the emitter or one of its inputs get `emit`ted.
    
    The callables that you register as outputs are functions that need to be
    called when the original event that caused the `emit` action happens.
    '''
    # todo: Let user put a single input/output
    
    
    _is_atomically_pickleable = False

    
    def __init__(self, inputs=(), outputs=(), name=None):
        '''
        Construct the emitter.
        
        `inputs` is a list of inputs, all of them must be emitters.
        
        `outputs` is a list of outputs, they must be either emitters or
        callables.
        
        `name` is a string name for the emitter.
        '''

        assert cute_iter_tools.is_iterable(inputs) and \
               cute_iter_tools.is_iterable(outputs)
        
        self._inputs = set()
        '''The emitter's inputs.'''
        
        self._outputs = set()
        '''The emitter's inputs.'''
        
        for output in outputs:
            self.add_output(output)
                        
        self.__total_callable_outputs_cache = None
        '''
        A cache of total callable outputs.
        
        This means the callable outputs of this emitter and any output
        emitters.
        '''
        
        self._recalculate_total_callable_outputs()        

        # We made sure to create the callable outputs cache before we add
        # inputs, so when we update their cache, it could use ours.
        for input in inputs:
            self.add_input(input)

        self.name = name
        '''The emitter's name.'''

    def get_inputs(self):
        '''Get the emitter's inputs.'''
        return self._inputs
    
    def get_outputs(self):
        '''Get the emitter's outputs.'''
        return self._outputs
                
    def _get_input_layers(self):
        '''
        Get the emitter's inputs as a list of layers.
        
        Every item in the list will be a list of emitters on that layer. For
        example, the first item will be a list of direct inputs of our emitter.
        The second item will be a list of *their* inputs. Etc.
        
        Every emitter can appear only once in this scheme: It would appear on
        the closest layer that it's on.
        '''

        input_layers = [self._inputs]
        current_layer = self._inputs
        while current_layer:
            
            next_layer = reduce(
                set.union,
                (input._inputs for input in current_layer),
                set()
            )
            
            for ancestor_layer in input_layers:
                assert isinstance(next_layer, set)
                next_layer -= ancestor_layer

            input_layers.append(next_layer)
            
            current_layer = next_layer        

        
        # assert sum(len(layer) for layer in input_layers) == \
        #        len(reduce(set.union, input_layers, set()))
            
        return input_layers
                
        
    def _recalculate_total_callable_outputs_recursively(self):
        '''
        Recalculate `__total_callable_outputs_cache` recursively.
        
        This will to do the recalculation for this emitter and all its inputs.
        '''
        
        # todo: I suspect this wouldn't work for the following case. `self` has
        # inputs `A` and `B`. `A` has input `B`. A callable output `func` was
        # just removed from `self`, so this function got called. We update the
        # cache here, then take the first input layer, which is `A` and `B` in
        # some order. Say `B` is first. Now, we do `recalculate` on `B`, but `A`
        # still got the cache with `func`, and `B` will take that. I need to
        # test this.
        # 
        # I have an idea how to solve it: In the getter of the cache, check the
        # cache exists, otherwise rebuild. The reason we didn't do it up to now
        # was to optimize for speed, but only `emit` needs to be fast and it
        # doesn't use the getter. We'll clear the caches of all inputs, and
        # they'll rebuild as they call each other.
        
        self._recalculate_total_callable_outputs()
        input_layers = self._get_input_layers()
        for input_layer in input_layers:
            for input in input_layer:
                input._recalculate_total_callable_outputs()
        
        
    def _recalculate_total_callable_outputs(self):
        '''
        Recalculate `__total_callable_outputs_cache` for this emitter.
        
        This will to do the recalculation for this emitter and all its inputs.
        '''
        children_callable_outputs = reduce(
            set.union,
            (emitter.get_total_callable_outputs() for emitter
             in self._get_emitter_outputs() if emitter is not self),
            set()
        )
        
        self.__total_callable_outputs_cache = \
            children_callable_outputs.union(self._get_callable_outputs())

    def add_input(self, emitter):
        '''
        Add an emitter as an input to this emitter.

        Every time that emitter will emit, it will cause this emitter to emit
        as well.
        '''
        assert isinstance(emitter, Emitter)
        self._inputs.add(emitter)
        emitter._outputs.add(self)
        emitter._recalculate_total_callable_outputs_recursively()
        
    def remove_input(self, emitter):
        '''Remove an input from this emitter.'''
        assert isinstance(emitter, Emitter)
        self._inputs.remove(emitter)
        emitter._outputs.remove(self)
        emitter._recalculate_total_callable_outputs_recursively()
    
    def add_output(self, thing):
        '''
        Add an emitter or a callable as an output to this emitter.
        
        If adding a callable, every time this emitter will emit the callable
        will be called.
        
        If adding an emitter, every time this emitter will emit the output
        emitter will emit as well.
        '''
        assert isinstance(thing, Emitter) or callable(thing)
        self._outputs.add(thing)
        if isinstance(thing, Emitter):
            thing._inputs.add(self)
        self._recalculate_total_callable_outputs_recursively()
        
    def remove_output(self, thing):
        '''Remove an output from this emitter.'''
        assert isinstance(thing, Emitter) or callable(thing)
        self._outputs.remove(thing)
        if isinstance(thing, Emitter):
            thing._inputs.remove(self)
        self._recalculate_total_callable_outputs_recursively()
        
    def disconnect_from_all(self): # todo: use the freeze here
        '''Disconnect the emitter from all its inputs and outputs.'''
        for input in self._inputs: 
            self.remove_input(input)
        for output in self._outputs:
            self.remove_output(output)
        
    def _get_callable_outputs(self):
        '''Get the direct callable outputs of this emitter.'''
        return set((
            output for output in self._outputs if callable(output)
        ))
    
    def _get_emitter_outputs(self):
        '''Get the direct emitter outputs of this emitter.'''
        return set((
            output for output in self._outputs if isinstance(output, Emitter)
        ))
        
    def get_total_callable_outputs(self):
        '''
        Get the total of callable outputs of this emitter.
        
        This means the direct callable outputs, and the callable outputs of
        emitter outputs.
        '''
        return self.__total_callable_outputs_cache
    
    def emit(self):
        '''
        Call all of the (direct or indirect) callable outputs of this emitter.
        
        This is the most important method of the emitter. When you `emit`, all
        the callable outputs get called in succession.
        '''
        # Note that this function gets called many times, so it should be
        # optimized for speed.
        for callable_output in self.__total_callable_outputs_cache:
            # We are using the cache directly instead of calling the getter,
            # for speed.
            callable_output()
    
    def __repr__(self):
        '''
        Get a string representation of the emitter.
        
        Example output:        
        <garlicsim_wx.general_misc.emitters.emitter.Emitter 'tree_modified' at
        0x1c013d0>
        '''
        return '<%s %sat %s>' % (
            address_tools.describe(type(self), shorten=True),
            ''.join(("'", self.name, "' ")) if self.name else '',
            hex(id(self))
        )
    """
    Unused:
    
    def _get_total_inputs(self):
        
        total_inputs_of_inputs = reduce(
            set.union,
            (emitter._get_total_inputs() for emitter
             in self._inputs if emitter is not self),
            set()
        )
        
        return total_inputs_of_inputs.union(self._inputs)
    """
########NEW FILE########
__FILENAME__ = emitter
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines an Emitter, which is used in EmitterSystem.

See documentation of these classes for more info.
'''
from ..emitter import Emitter as OriginalEmitter

class Emitter(OriginalEmitter):
    '''
    An emitter you can `emit` from to call all its callable outputs.
    
    This is an extension of the original `Emitter`, see its documentation for
    more info.
    
    What this adds is that it keeps track of which emitter system this emitter
    belongs to, and it allows freezing the cache rebuilding for better speed
    when adding many emitters to the system.
    
    See documentation of `EmitterSystem` for more info.
    '''

    def __init__(self, emitter_system, inputs=(), outputs=(), name=None):
        '''
        Construct the emitter.
        
        `emitter_system` is the emitter system to which this emitter belongs.
        
        `inputs` is a list of inputs, all of them must be emitters.
        
        `outputs` is a list of outputs, they must be either emitters or
        callables.
        
        `name` is a string name for the emitter.
        '''
        
        self.emitter_system = emitter_system
        '''The emitter system to which this emitter belongs.'''
        OriginalEmitter.__init__(self, inputs=inputs,
                                 outputs=outputs, name=name)
                        
    def _recalculate_total_callable_outputs_recursively(self):
        '''
        Recalculate `__total_callable_outputs_cache` recursively.
        
        This will to do the recalculation for this emitter and all its inputs.
        
        Will not do anything if `_cache_rebuilding_frozen` is positive.
        '''
        if self.emitter_system._cache_rebuilding_frozen == 0:
            OriginalEmitter._recalculate_total_callable_outputs_recursively(
                self
            )
        
    def add_input(self, emitter): # todo: ability to add plural in same method
        '''
        Add an emitter as an input to this emitter.

        Every time that emitter will emit, it will cause this emitter to emit
        as well.
        
        Emitter must be member of this emitter's emitter system.
        '''
        assert emitter in self.emitter_system.emitters
        OriginalEmitter.add_input(self, emitter)
    
    def add_output(self, thing): # todo: ability to add plural in same method
        '''
        Add an emitter or a callable as an output to this emitter.
        
        If adding a callable, every time this emitter will emit the callable
        will be called.
        
        If adding an emitter, every time this emitter will emit the output
        emitter will emit as well. Note that the output emitter must be a
        member of this emitter's emitter system.
        '''
        if isinstance(thing, Emitter):
            assert thing in self.emitter_system.emitters
        OriginalEmitter.add_output(self, thing)

########NEW FILE########
__FILENAME__ = emitter_system
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines an EmitterSystem, which offers some benefits over Emitter.

See documentation of EmitterSystem for more info.
'''

from __future__ import with_statement

import itertools
from garlicsim.general_misc import cute_iter_tools
from garlicsim.general_misc.context_manager import ContextManager

from .emitter import Emitter


class FreezeCacheRebuildingContextManager(ContextManager):
    '''
    Context manager for freezing the cache rebuilding in an emitter system.
    
    When you do actions using this context manager, the emitters will not
    rebuild their cache when changing their inputs/outputs. When the outermost
    context manager has exited, all the caches for these emitters will get
    rebuilt.
    '''    
    def __init__(self, emitter_system):
        self.emitter_system = emitter_system
        
    def __enter__(self):
        assert self.emitter_system._cache_rebuilding_frozen >= 0
        self.emitter_system._cache_rebuilding_frozen += 1
        
    def __exit__(self, *args, **kwargs):
        self.emitter_system._cache_rebuilding_frozen -= 1
        if self.emitter_system._cache_rebuilding_frozen == 0:
            self.emitter_system._recalculate_all_cache()

            
class EmitterSystem(object):
    '''
    A system of emitters, representing a set of possible events in a program.
    
    `EmitterSystem` offers a few advantages over using plain emitters.
    
    There are the `bottom_emitter` and `top_emitter`, which allow, respectively,
    to keep track of each `emit`ting that goes on, and to generate an `emit`ting
    that affects all emitters in the system.
    
    The `EmitterSystem` also offers a context manager,
    `.freeze_cache_rebuilding`. When you do actions using this context manager,
    the emitters will not rebuild their cache when changing their
    inputs/outputs. When the outermost context manager has exited, all the
    caches for these emitters will get rebuilt.
    '''
    # possible future idea: there is the idea of optimizing by cutting redundant
    # links between boxes. I'm a bit suspicious of it. The next logical step is
    # to make inputs and outputs abstract.
    def __init__(self):
        
        self._cache_rebuilding_frozen = 0
        self.freeze_cache_rebuilding = \
            FreezeCacheRebuildingContextManager(self)
        
        self.emitters = set()
        
        self.bottom_emitter = Emitter(self, name='bottom')
        self.emitters.add(self.bottom_emitter)
        
        self.top_emitter = Emitter(
            self,
            outputs=(self.bottom_emitter,),
            name='top',
        )
        self.emitters.add(self.top_emitter)
        
            
    def make_emitter(self, inputs=(), outputs=(), name=None):
        '''Create an emitter in this emitter system. Returns the emitter.'''

        # todo: allow one value in inputs and outputs. do in all emitter
        # constructors.
        
        inputs = set(inputs)
        inputs.add(self.top_emitter)
        outputs = set(outputs)
        outputs.add(self.bottom_emitter)
        emitter = Emitter(self, inputs, outputs, name)
        self.emitters.add(emitter)
        return emitter

    
    def remove_emitter(self, emitter):
        '''
        Remove an emitter from this system, disconnecting it from everything.
        '''
        with self.freeze_cache_rebuilding:
            emitter.disconnect_from_all()
        self.emitters.remove(emitter)
        
        
    def _recalculate_all_cache(self):
        '''Recalculate the cache for all the emitters.'''
        self.bottom_emitter._recalculate_total_callable_outputs_recursively()
    


########NEW FILE########
__FILENAME__ = emitting_ordered_set
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `EmittingOrderedSet` class.

See its documentation for more details.
'''

from garlicsim.general_misc.nifty_collections.ordered_set import (
    OrderedSet, KEY, PREV, NEXT
)
from garlicsim_wx.general_misc.emitters import Emitter


class EmittingOrderedSet(OrderedSet):
    '''An ordered set that emits to `.emitter` every time it's modified.'''
    
    def __init__(self, emitter, items=()):
        if emitter:
            assert isinstance(emitter, Emitter)
        self.emitter = emitter
        OrderedSet.__init__(self, items)

        
    def add(self, key):
        """ Add an element to a set.
    
        This has no effect if the element is already present. """
        if key not in self.map:
            end = self.end
            curr = end[PREV]
            curr[NEXT] = end[PREV] = self.map[key] = [key, curr, end]
            if self.emitter:
                self.emitter.emit()

                
    def discard(self, key):
        """ Remove an element from a set if it is a member.
        
        If the element is not a member, do nothing. """
        if key in self.map:        
            key, prev, next = self.map.pop(key)
            prev[NEXT] = next
            next[PREV] = prev
            if self.emitter:
                self.emitter.emit()

                
    def set_emitter(self, emitter):
        '''Set `emitter` to be emitted with on every modification.'''
        self.emitter = emitter
########NEW FILE########
__FILENAME__ = emitting_weak_key_default_dict
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `EmittingWeakKeyDefaultDict` class.

See its documentation for more details.
'''

from garlicsim.general_misc.nifty_collections import WeakKeyDefaultDict


class EmittingWeakKeyDefaultDict(WeakKeyDefaultDict):
    '''
    A key that references keys weakly, has a default factory, and emits.
    
    This is a combination of `weakref.WeakKeyDictionary` and
    `collections.defaultdict`, which emits every time it's modified.
    
    The keys are referenced weakly, so if there are no more references to the
    key, it gets removed from this dict.
    
    If a "default factory" is supplied, when a key is attempted that doesn't
    exist the default factory will be called to create its new value.
    
    Every time that a change is made, like a key is added or removed or gets
    its value changed, we do `.emitter.emit()`.
    '''
    
    def __init__(self, emitter, *args, **kwargs):
        super(EmittingWeakKeyDefaultDict, self).__init__(*args, **kwargs)
        self.emitter = emitter

        
    def set_emitter(self, emitter):
        '''Set the emitter that will be emitted every time a change is made.'''
        self.emitter = emitter

        
    def __setitem__(self, key, value):
        result = \
            super(EmittingWeakKeyDefaultDict, self).__setitem__(key, value)
        if self.emitter:
            self.emitter.emit()
        return result

    
    def __delitem__(self, key):
        result = super(EmittingWeakKeyDefaultDict, self).__delitem__(key)
        if self.emitter:
            self.emitter.emit()
        return result

    
    def pop(self, key, *args):
        """ D.pop(k[,d]) -> v, remove specified key and return the 
        corresponding value. If key is not found, d is returned if given,
        otherwise KeyError is raised """
        result = super(EmittingWeakKeyDefaultDict, self).pop(key, *args)
        if self.emitter:
            self.emitter.emit()
        return result

    
    def popitem(self):
        """ D.popitem() -> (k, v), remove and return some (key, value) 
        pair as a 2-tuple; but raise KeyError if D is empty """
        result = super(EmittingWeakKeyDefaultDict, self).popitem()
        if self.emitter:
            self.emitter.emit()
        return result

    
    def clear(self):
        """ D.clear() -> None.  Remove all items from D. """
        result = super(EmittingWeakKeyDefaultDict, self).clear()
        if self.emitter:
            self.emitter.emit()
        return result

    
    def __repr__(self):
        return '%s(%s, %s, %s)' % (
            type(self).__name__,
            self.emitter,
            self.default_factory,
            dict(self)
        )

    
    def __reduce__(self):
        """
        __reduce__ must return a 5-tuple as follows:

           - factory function
           - tuple of args for the factory function
           - additional state (here None)
           - sequence iterator (here None)
           - dictionary iterator (yielding successive (key, value) pairs

           This API is used by pickle.py and copy.py.
        """
        if self.default_factory:
            parameters = (self.emitter, self.default_factory)
        else: # not self.default_factory
            parameters = (self.emitter)
            
        return (type(self), parameters, None, None, self.iteritems())
########NEW FILE########
__FILENAME__ = flag_raiser
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `FlagRaiser` class.

See its documentation for more info.
'''

import wx

from garlicsim_wx.general_misc import cute_timer


class FlagRaiser(object): # todo: rename?
    '''When called, raises a flag of a window and then calls some function.'''
    def __init__(self, window, attribute_name=None, function=None, delay=None):
        '''
        Construct the flag raiser.
        
        `window` is the window we're acting on. `attribute_name` is the name of
        the flag that we set to True. `function` is the function we call after
        we set the flag. Default for `function` is `window.Refresh`.
        
        If we get a `delay` argument, then we don't call the function
        immediately, but wait for `delay` time, specified as seconds, then call
        it. If this flag raiser will be called again while the timer's on, it
        will not cause another function calling.
        '''
        assert isinstance(window, wx.Window)

        self.window = window
        '''The window that the flag raiser is acting on.'''
        
        self.attribute_name = attribute_name
        '''The name of the flag that this flag raiser raises.'''
        
        self.function = function or window.Refresh
        '''The function that this flag raiser calls after raising the flag.'''
        
        self.delay = delay
        '''The delay, in seconds, that we wait before calling the function.'''
        
        if delay is not None:
            
            self._delay_in_ms = delay * 1000
            '''The delay in milliseconds.'''
            
            self.timer = cute_timer.CuteTimer(self.window)
            '''The timer we use to call the function.'''
            
            self.window.Bind(wx.EVT_TIMER, self.on_timer, self.timer)

            
    def __call__(self):
        '''Raise the flag and call the function. (With delay if we set one.)'''
        if self.attribute_name:
            setattr(self.window, self.attribute_name, True)
        if self.delay is None:
            self.function()
        else: # self.delay is a positive number
            if not self.timer.IsRunning():
                self.timer.Start(self._delay_in_ms, oneShot=True)
                
    def on_timer(self, event):
        '''EVT_TIMER event handler.'''
        if getattr(self.window, self.attribute_name) is True:
            self.function()
########NEW FILE########
__FILENAME__ = get_lines
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `get_lines` function. See its documentation for more
info.
'''

def get_lines(start, end, thing):
    '''
    Get a list of all "round" numbers between start and end.
    
    with thing=0, round numbers = 1, 2, 3...
    with thing=1, round numbers = 10, 20, 30...
    with thing=-1, round numbers = 0.1, 0.2, 0.3...
    etc.
    '''
    mything = int(round(thing))
    mystart = round(start,mything)
    if mystart < start:
        mystart += 10 ** mything
    '''
    myend=round(end,-thing)
    if myend>end:
        myend-=10**thing
    '''

    result = []
    current = mystart
    while current < end:
        result.append(round(current, -mything))
        current += 10 ** mything
    return result

########NEW FILE########
__FILENAME__ = misc_tools
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Defines miscellaneous tools.'''

from __future__ import division

import os.path

from garlicsim.general_misc import cute_iter_tools


def find_clear_place_on_circle(circle_points, circle_size=1):
    '''
    Find the point on a circle that's the farthest away from other points.
    
    Given an interval `(0, circle_size)` and a bunch of points in it, find a
    place for a new point that is as far away from the other points as
    possible. (Since this is a circle, there's wraparound, e.g. the end of the
    interval connects to the start.)
    '''

    # Before starting, taking care of two edge cases:
    if not circle_points:
        # Edge case: No points at all
        return circle_size / 2
    if len(circle_points) == 1:
        # Edge case: Only one point
        return (circle_points[0] + circle_size / 2) % circle_size
    
    sorted_circle_points = sorted(circle_points)
    last_point = sorted_circle_points[-1]
    if last_point >= circle_size:
        raise Exception("One of the points (%s) is bigger than the circle "
                        "size %s." % (last_point, circle_size))
    clear_space = {}
    
    for first_point, second_point in cute_iter_tools.consecutive_pairs(
        sorted_circle_points, wrap_around=True
        ):
        
        clear_space[first_point] = second_point - first_point
        
    # That's the only one that might be negative, so we ensure it's positive:
    clear_space[last_point] %= circle_size
    
    maximum_clear_space = max(clear_space.itervalues())
    
    winners = [key for (key, value) in clear_space.iteritems()
               if value == maximum_clear_space]
    
    winner = winners[0]
    
    result = (winner + (maximum_clear_space / 2)) % circle_size
    
    return result
        
    
def add_extension_if_plain(path, extension):
    '''Add `extenstion` to a file path if it doesn't have an extenstion.'''
    
    if extension:
        assert extension.startswith('.')
    
    (without_extension, existing_extension) = os.path.splitext(path)
    if existing_extension:
        return path
    else: # not existing_extension
        return without_extension + extension
    
########NEW FILE########
__FILENAME__ = stringsaver
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
A little module for cataloging strings.
'''

stringsaver_catalog = []

def s2i(string):
    '''
    If the string isn't cataloged already, catalog it.
    
    In any case, returns the number associated with the string.
    '''
    global stringsaver_catalog
    if string in stringsaver_catalog:
        return stringsaver_catalog.index(string) + 1
    else:
        stringsaver_catalog.append(string)
        return stringsaver_catalog.index(string) + 1


def i2s(integer):
    '''
    Return the string cataloged under the given integer.
    '''
    return stringsaver_catalog[integer - 1]

########NEW FILE########
__FILENAME__ = auibar
"""
auibar contains an implementation of L{AuiToolBar}, which is a completely owner-drawn
toolbar perfectly integrated with the AUI layout system. This allows drag and drop of
toolbars, docking/floating behaviour and the possibility to define "overflow" items
in the toolbar itself.

The default theme that is used is L{AuiDefaultToolBarArt}, which provides a modern,
glossy look and feel. The theme can be changed by calling L{AuiToolBar.SetArtProvider}.
"""

__author__ = "Andrea Gavana <andrea.gavana@gmail.com>"
__date__ = "31 March 2009"


import wx
import types

from aui_utilities import BitmapFromBits, StepColour, GetLabelSize
from aui_utilities import GetBaseColour, MakeDisabledBitmap

import framemanager
from aui_constants import *

# wxPython version string
_VERSION_STRING = wx.VERSION_STRING

# AuiToolBar events
wxEVT_COMMAND_AUITOOLBAR_TOOL_DROPDOWN = wx.NewEventType()
wxEVT_COMMAND_AUITOOLBAR_OVERFLOW_CLICK = wx.NewEventType()
wxEVT_COMMAND_AUITOOLBAR_RIGHT_CLICK = wx.NewEventType()
wxEVT_COMMAND_AUITOOLBAR_MIDDLE_CLICK = wx.NewEventType()
wxEVT_COMMAND_AUITOOLBAR_BEGIN_DRAG = wx.NewEventType()

EVT_AUITOOLBAR_TOOL_DROPDOWN = wx.PyEventBinder(wxEVT_COMMAND_AUITOOLBAR_TOOL_DROPDOWN, 1)
""" A dropdown `AuiToolBarItem` is being shown. """
EVT_AUITOOLBAR_OVERFLOW_CLICK = wx.PyEventBinder(wxEVT_COMMAND_AUITOOLBAR_OVERFLOW_CLICK, 1)
""" The user left-clicked on the overflow button in `AuiToolBar`. """
EVT_AUITOOLBAR_RIGHT_CLICK = wx.PyEventBinder(wxEVT_COMMAND_AUITOOLBAR_RIGHT_CLICK, 1)
""" Fires an event when the user right-clicks on a `AuiToolBarItem`. """
EVT_AUITOOLBAR_MIDDLE_CLICK = wx.PyEventBinder(wxEVT_COMMAND_AUITOOLBAR_MIDDLE_CLICK, 1)
""" Fires an event when the user middle-clicks on a `AuiToolBarItem`. """
EVT_AUITOOLBAR_BEGIN_DRAG = wx.PyEventBinder(wxEVT_COMMAND_AUITOOLBAR_BEGIN_DRAG, 1)
""" A drag operation involving a toolbar item has started. """

# ----------------------------------------------------------------------

class CommandToolBarEvent(wx.PyCommandEvent):
    """ A specialized command event class for events sent by L{AuiToolBar}. """
    
    def __init__(self, command_type, win_id):
        """
        Default class constructor.

        :param `command_type`: the event kind or an instance of `wx.PyCommandEvent`.
        :param `win_id`: the window identification number.
        """
        
        if type(command_type) == types.IntType:    
            wx.PyCommandEvent.__init__(self, command_type, win_id)
        else:
            wx.PyCommandEvent.__init__(self, command_type.GetEventType(), command_type.GetId())
            
        self.is_dropdown_clicked = False
        self.click_pt = wx.Point(-1, -1)
        self.rect = wx.Rect(-1, -1, 0, 0)
        self.tool_id = -1


    def IsDropDownClicked(self):
        """ Returns whether the drop down menu has been clicked. """

        return self.is_dropdown_clicked
    

    def SetDropDownClicked(self, c):
        """
        Sets whether the drop down menu has been clicked.

        :param `c`: ``True`` to set the drop down as clicked, ``False`` otherwise.
        """

        self.is_dropdown_clicked = c    


    def GetClickPoint(self):
        """ Returns the point where the user clicked with the mouse. """

        return self.click_pt

    
    def SetClickPoint(self, p):
        """
        Sets the clicking point.

        :param `p`: a `wx.Point` object.
        """
        
        self.click_pt = p    


    def GetItemRect(self):
        """ Returns the L{AuiToolBarItem} rectangle. """

        return self.rect

    
    def SetItemRect(self, r):
        """
        Sets the L{AuiToolBarItem} rectangle.

        :param `r`: an instance of `wx.Rect`.
        """

        self.rect = r    


    def GetToolId(self):
        """ Returns the L{AuiToolBarItem} identifier. """

        return self.tool_id

    
    def SetToolId(self, id):
        """
        Sets the L{AuiToolBarItem} identifier.

        :param `id`: the toolbar item identifier.
        """

        self.tool_id = id   


# ----------------------------------------------------------------------

class AuiToolBarEvent(CommandToolBarEvent):
    """ A specialized command event class for events sent by L{AuiToolBar}. """
    
    def __init__(self, command_type=None, win_id=0):
        """
        Default class constructor.

        :param `command_type`: the event kind or an instance of `wx.PyCommandEvent`.
        :param `win_id`: the window identification number.
        """

        CommandToolBarEvent.__init__(self, command_type, win_id)

        if type(command_type) == types.IntType:
            self.notify = wx.NotifyEvent(command_type, win_id)
        else:
            self.notify = wx.NotifyEvent(command_type.GetEventType(), command_type.GetId())

        
    def GetNotifyEvent(self):
        """ Returns the actual `wx.NotifyEvent`. """
        
        return self.notify


    def IsAllowed(self):
        """ Returns whether the event is allowed or not. """

        return self.notify.IsAllowed()


    def Veto(self):
        """
        Prevents the change announced by this event from happening.

        It is in general a good idea to notify the user about the reasons for
        vetoing the change because otherwise the applications behaviour (which
        just refuses to do what the user wants) might be quite surprising.
        """

        self.notify.Veto()


    def Allow(self):
        """
        This is the opposite of L{Veto}: it explicitly allows the event to be
        processed. For most events it is not necessary to call this method as the
        events are allowed anyhow but some are forbidden by default (this will
        be mentioned in the corresponding event description).
        """

        self.notify.Allow()


# ----------------------------------------------------------------------

class ToolbarCommandCapture(wx.PyEvtHandler):
    """ A class to handle the dropdown window menu. """
    
    def __init__(self):
        """ Default class constructor. """
        
        wx.PyEvtHandler.__init__(self)
        self._last_id = 0


    def GetCommandId(self):
        """ Returns the event command identifier. """
        
        return self._last_id 


    def ProcessEvent(self, event):
        """
        Processes an event, searching event tables and calling zero or more suitable
        event handler function(s).

        :param `event`: the event to process.

        :note: Normally, your application would not call this function: it is called
         in the wxPython implementation to dispatch incoming user interface events
         to the framework (and application).
         However, you might need to call it if implementing new functionality (such as
         a new control) where you define new event types, as opposed to allowing the
         user to override functions.

         An instance where you might actually override the L{ProcessEvent} function is where
         you want to direct event processing to event handlers not normally noticed by
         wxPython. For example, in the document/view architecture, documents and views
         are potential event handlers. When an event reaches a frame, L{ProcessEvent} will
         need to be called on the associated document and view in case event handler
         functions are associated with these objects. 

         The normal order of event table searching is as follows:

         1. If the object is disabled (via a call to `SetEvtHandlerEnabled`) the function
            skips to step (6).
         2. If the object is a `wx.Window`, L{ProcessEvent} is recursively called on the window's 
            `wx.Validator`. If this returns ``True``, the function exits.
         3. wxWidgets `SearchEventTable` is called for this event handler. If this fails, the
            base class table is tried, and so on until no more tables exist or an appropriate
            function was found, in which case the function exits.
         4. The search is applied down the entire chain of event handlers (usually the chain
            has a length of one). If this succeeds, the function exits.
         5. If the object is a `wx.Window` and the event is a `wx.CommandEvent`, L{ProcessEvent} is
            recursively applied to the parent window's event handler. If this returns ``True``,
            the function exits.
         6. Finally, L{ProcessEvent} is called on the `wx.App` object.
        """
        
        if event.GetEventType() == wx.wxEVT_COMMAND_MENU_SELECTED:
            self._last_id = event.GetId()
            return True
        
        if self.GetNextHandler():
            return self.GetNextHandler().ProcessEvent(event)

        return False


# ----------------------------------------------------------------------

class AuiToolBarItem(object):
    """
    AuiToolBarItem is a toolbar element.
    
    It has a unique id (except for the separators which always have id = -1), the
    style (telling whether it is a normal button, separator or a control), the
    state (toggled or not, enabled or not) and short and long help strings. The
    default implementations use the short help string for the tooltip text which
    is popped up when the mouse pointer enters the tool and the long help string
    for the applications status bar.
    """

    def __init__(self, item=None):
        """
        Default class constructor.

        :param `item`: another instance of L{AuiToolBarItem}.
        """

        if item:
            self.Assign(item)
            return
        
        self.window = None
        self.clockwisebmp = wx.NullBitmap
        self.counterclockwisebmp = wx.NullBitmap
        self.clockwisedisbmp = wx.NullBitmap
        self.counterclockwisedisbmp = wx.NullBitmap
        self.sizer_item = None
        self.spacer_pixels = 0
        self.id = 0
        self.kind = ITEM_NORMAL
        self.state = 0   # normal, enabled
        self.proportion = 0
        self.active = True
        self.dropdown = True
        self.sticky = True
        self.user_data = 0

        self.label = ""
        self.bitmap = wx.NullBitmap
        self.disabled_bitmap = wx.NullBitmap
        self.hover_bitmap = wx.NullBitmap
        self.short_help = ""
        self.long_help = ""
        self.min_size = wx.Size(-1, -1)
        self.alignment = wx.ALIGN_CENTER
        self.orientation = AUI_TBTOOL_HORIZONTAL
        

    def Assign(self, c):
        """
        Assigns the properties of the L{AuiToolBarItem} `c` to `self`.

        :param `c`: another instance of L{AuiToolBarItem}.
        """

        self.window = c.window
        self.label = c.label
        self.bitmap = c.bitmap
        self.disabled_bitmap = c.disabled_bitmap
        self.hover_bitmap = c.hover_bitmap
        self.short_help = c.short_help
        self.long_help = c.long_help
        self.sizer_item = c.sizer_item
        self.min_size = c.min_size
        self.spacer_pixels = c.spacer_pixels
        self.id = c.id
        self.kind = c.kind
        self.state = c.state
        self.proportion = c.proportion
        self.active = c.active
        self.dropdown = c.dropdown
        self.sticky = c.sticky
        self.user_data = c.user_data
        self.alignment = c.alignment
        self.orientation = c.orientation


    def SetWindow(self, w):
        """
        Assigns a window to the toolbar item.

        :param `w`: an instance of `wx.Window`.
        """

        self.window = w

        
    def GetWindow(self):
        """ Returns window associated to the toolbar item. """

        return self.window        


    def SetId(self, new_id):
        """
        Sets the toolbar item identifier.

        :param `new_id`: the new tool id.
        """

        self.id = new_id

        
    def GetId(self):
        """ Returns the toolbar item identifier. """

        return self.id 


    def SetKind(self, new_kind):
        """
        Sets the L{AuiToolBarItem} kind.

        :param `new_kind`: can be one of the following items:

         ========================  =============================
         Item Kind                 Description
         ========================  =============================
         ``ITEM_CONTROL``          The item in the `AuiToolBar` is a control
         ``ITEM_LABEL``            The item in the `AuiToolBar` is a text label
         ``ITEM_SPACER``           The item in the `AuiToolBar` is a spacer
         ``ITEM_SEPARATOR``        The item in the `AuiToolBar` is a separator
         ``ITEM_CHECK``            The item in the `AuiToolBar` is a toolbar check item
         ``ITEM_NORMAL``           The item in the `AuiToolBar` is a standard toolbar item
         ``ITEM_RADIO``            The item in the `AuiToolBar` is a toolbar radio item
         ========================  =============================
        """

        self.kind = new_kind


    def GetKind(self):
        """ Returns the toolbar item kind. See L{SetKind} for more details. """

        return self.kind
        

    def SetState(self, new_state):
        """
        Sets the toolbar item state.

        :param `new_state`: can be one of the following states:

         ============================================  ======================================
         Button State Constant                         Description     
         ============================================  ======================================
         ``AUI_BUTTON_STATE_NORMAL``                   Normal button state
         ``AUI_BUTTON_STATE_HOVER``                    Hovered button state
         ``AUI_BUTTON_STATE_PRESSED``                  Pressed button state
         ``AUI_BUTTON_STATE_DISABLED``                 Disabled button state
         ``AUI_BUTTON_STATE_HIDDEN``                   Hidden button state
         ``AUI_BUTTON_STATE_CHECKED``                  Checked button state
         ============================================  ======================================
    
        """

        self.state = new_state

        
    def GetState(self):
        """
        Returns the toolbar item state. See L{SetState} for more details.

        :see: L{SetState}
        """
        
        return self.state 


    def SetSizerItem(self, s):
        """
        Associates a sizer item to this toolbar item.

        :param `s`: an instance of `wx.SizerItem`.
        """

        self.sizer_item = s

        
    def GetSizerItem(self):
        """ Returns the associated sizer item. """

        return self.sizer_item 


    def SetLabel(self, s):
        """
        Sets the toolbar item label.

        :param `s`: a string specifying the toolbar item label.
        """

        self.label = s

        
    def GetLabel(self):
        """ Returns the toolbar item label. """

        return self.label 


    def SetBitmap(self, bmp):
        """
        Sets the toolbar item bitmap.

        :param `bmp`: an instance of `wx.Bitmap`.
        """
        
        self.bitmap = bmp

        
    def GetBitmap(self):
        """ Returns the toolbar item bitmap. """

        return self.GetRotatedBitmap(False)


    def SetDisabledBitmap(self, bmp):
        """
        Sets the toolbar item disabled bitmap.

        :param `bmp`: an instance of `wx.Bitmap`.
        """
        
        self.disabled_bitmap = bmp

        
    def GetDisabledBitmap(self):
        """ Returns the toolbar item disabled bitmap. """
        
        return self.GetRotatedBitmap(True)


    def SetHoverBitmap(self, bmp):
        """
        Sets the toolbar item hover bitmap.

        :param `bmp`: an instance of `wx.Bitmap`.
        """
        
        self.hover_bitmap = bmp


    def SetOrientation(self, a):
        """
        Sets the toolbar tool orientation.

        :param `a`: one of ``AUI_TBTOOL_HORIZONTAL``, ``AUI_TBTOOL_VERT_CLOCKWISE`` or
         ``AUI_TBTOOL_VERT_COUNTERCLOCKWISE``.
        """

        self.orientation = a


    def GetOrientation(self):
        """ Returns the toolbar tool orientation. """

        return self.orientation
    
        
    def GetHoverBitmap(self):
        """ Returns the toolbar item hover bitmap. """
        
        return self.hover_bitmap 


    def GetRotatedBitmap(self, disabled):
        """
        Returns the correct bitmap depending on the tool orientation.

        :param `disabled`: whether to return the disabled bitmap or not.
        """
        
        bitmap_to_rotate = (disabled and [self.disabled_bitmap] or [self.bitmap])[0]
        if not bitmap_to_rotate.IsOk() or self.orientation == AUI_TBTOOL_HORIZONTAL:
            return bitmap_to_rotate

        rotated_bitmap = wx.NullBitmap
        clockwise = True
        if self.orientation == AUI_TBTOOL_VERT_CLOCKWISE:
            rotated_bitmap = (disabled and [self.clockwisedisbmp] or [self.clockwisebmp])[0]

        elif self.orientation == AUI_TBTOOL_VERT_COUNTERCLOCKWISE:
            rotated_bitmap = (disabled and [self.counterclockwisedisbmp] or [self.counterclockwisebmp])[0]
            clockwise = False

        if not rotated_bitmap.IsOk():
            rotated_bitmap = wx.BitmapFromImage(bitmap_to_rotate.ConvertToImage().Rotate90(clockwise))

        return rotated_bitmap


    def SetShortHelp(self, s):
        """
        Sets the short help string for the L{AuiToolBarItem}, to be displayed in a
        `wx.ToolTip` when the mouse hover over the toolbar item.

        :param `s`: the tool short help string.
        """

        self.short_help = s

        
    def GetShortHelp(self):
        """ Returns the short help string for the L{AuiToolBarItem}. """

        return self.short_help 


    def SetLongHelp(self, s):
        """
        Sets the long help string for the toolbar item. This string is shown in the
        statusbar (if any) of the parent frame when the mouse pointer is inside the
        tool.

        :param `s`: the tool long help string.
        """

        self.long_help = s

        
    def GetLongHelp(self):
        """ Returns the long help string for the L{AuiToolBarItem}. """

        return self.long_help 


    def SetMinSize(self, s):
        """
        Sets the toolbar item minimum size.

        :param `s`: an instance of `wx.Size`.
        """

        self.min_size = wx.Size(*s)

        
    def GetMinSize(self):
        """ Returns the toolbar item minimum size. """

        return self.min_size 


    def SetSpacerPixels(self, s):
        """
        Sets the number of pixels for a toolbar item with kind = ``ITEM_SEPARATOR``.

        :param `s`: number of pixels.
        """

        self.spacer_pixels = s

        
    def GetSpacerPixels(self):
        """ Returns the number of pixels for a toolbar item with kind = ``ITEM_SEPARATOR``. """

        return self.spacer_pixels 


    def SetProportion(self, p):
        """
        Sets the L{AuiToolBarItem} proportion in the toolbar.

        :param `p`: the item proportion.
        """

        self.proportion = p

        
    def GetProportion(self):
        """ Returns the L{AuiToolBarItem} proportion in the toolbar. """

        return self.proportion 


    def SetActive(self, b):
        """
        Activates/deactivates the toolbar item.

        :param `b`: ``True`` to activate the item, ``False`` to deactivate it.
        """

        self.active = b

        
    def IsActive(self):
        """ Returns whether the toolbar item is active or not. """

        return self.active
    

    def SetHasDropDown(self, b):
        """
        Sets whether the toolbar item has an associated dropdown menu.

        :param `b`: ``True`` to set a dropdown menu, ``False`` otherwise.
        """

        self.dropdown = b

        
    def HasDropDown(self):
        """ Returns whether the toolbar item has an associated dropdown menu or not. """

        return self.dropdown 


    def SetSticky(self, b):
        """
        Sets whether the toolbar item is sticky (permanent highlight after mouse enter)
        or not.

        :param `b`: ``True`` to set the item as sticky, ``False`` otherwise.
        """

        self.sticky = b

        
    def IsSticky(self):
        """ Returns whether the toolbar item has a sticky behaviour or not. """

        return self.sticky 


    def SetUserData(self, l):
        """
        Associates some kind of user data to the toolbar item.
        
        :param `l`: a Python object.

        :note: The user data can be any Python object.
        """

        self.user_data = l

        
    def GetUserData(self):
        """ Returns the associated user data. """

        return self.user_data
    

    def SetAlignment(self, l):
        """
        Sets the toolbar item alignment.

        :param `l`: the item alignment, which can be one of the available `wx.Sizer`
         alignments.
        """

        self.alignment = l

        
    def GetAlignment(self):
        """ Returns the toolbar item alignment. """

        return self.alignment        


# ----------------------------------------------------------------------

class AuiDefaultToolBarArt(object):
    """
    Toolbar art provider code - a tab provider provides all drawing functionality to
    the L{AuiToolBar}. This allows the L{AuiToolBar} to have a plugable look-and-feel.

    By default, a L{AuiToolBar} uses an instance of this class called L{AuiDefaultToolBarArt}
    which provides bitmap art and a colour scheme that is adapted to the major platforms'
    look. You can either derive from that class to alter its behaviour or write a
    completely new tab art class. Call L{AuiToolBar.SetArtProvider} to make use this
    new tab art.
    """

    def __init__(self):
        """ Default class constructor. """
        
        self._base_colour = GetBaseColour()

        self._agwFlags = 0
        self._text_orientation = AUI_TBTOOL_TEXT_BOTTOM
        self._highlight_colour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_HIGHLIGHT)

        self._separator_size = 7
        self._orientation = AUI_TBTOOL_HORIZONTAL
        self._gripper_size = 7
        self._overflow_size = 16

        darker1_colour = StepColour(self._base_colour, 85)
        darker2_colour = StepColour(self._base_colour, 75)
        darker3_colour = StepColour(self._base_colour, 60)
        darker4_colour = StepColour(self._base_colour, 50)
        darker5_colour = StepColour(self._base_colour, 40)

        self._gripper_pen1 = wx.Pen(darker5_colour)
        self._gripper_pen2 = wx.Pen(darker3_colour)
        self._gripper_pen3 = wx.WHITE_PEN

        button_dropdown_bits = "\xe0\xf1\xfb"
        overflow_bits = "\x80\xff\x80\xc1\xe3\xf7"

        self._button_dropdown_bmp = BitmapFromBits(button_dropdown_bits, 5, 3, wx.BLACK)
        self._disabled_button_dropdown_bmp = BitmapFromBits(button_dropdown_bits, 5, 3,
                                                            wx.Colour(128, 128, 128))
        self._overflow_bmp = BitmapFromBits(overflow_bits, 7, 6, wx.BLACK)
        self._disabled_overflow_bmp = BitmapFromBits(overflow_bits, 7, 6, wx.Colour(128, 128, 128))

        self._font = wx.SystemSettings.GetFont(wx.SYS_DEFAULT_GUI_FONT)


    def Clone(self):
        """ Clones the L{AuiToolBar} art. """

        return AuiDefaultToolBarArt()


    def SetAGWFlags(self, agwFlags):
        """
        Sets the toolbar art flags.

        :param `agwFlags`: a combination of the following values:

         ==================================== ==================================
         Flag name                            Description
         ==================================== ==================================
         ``AUI_TB_TEXT``                      Shows the text in the toolbar buttons; by default only icons are shown
         ``AUI_TB_NO_TOOLTIPS``               Don't show tooltips on `AuiToolBar` items
         ``AUI_TB_NO_AUTORESIZE``             Do not auto-resize the `AuiToolBar`
         ``AUI_TB_GRIPPER``                   Shows a gripper on the `AuiToolBar`
         ``AUI_TB_OVERFLOW``                  The `AuiToolBar` can contain overflow items
         ``AUI_TB_VERTICAL``                  The `AuiToolBar` is vertical
         ``AUI_TB_HORZ_LAYOUT``               Shows the text and the icons alongside, not vertically stacked. This style must be used with ``AUI_TB_TEXT``
         ``AUI_TB_PLAIN_BACKGROUND``          Don't draw a gradient background on the toolbar
         ``AUI_TB_HORZ_TEXT``                 Combination of ``AUI_TB_HORZ_LAYOUT`` and ``AUI_TB_TEXT``
         ==================================== ==================================
        
        """
        
        self._agwFlags = agwFlags


    def GetAGWFlags(self):
        """
        Returns the L{AuiDefaultToolBarArt} flags. See L{SetAGWFlags} for more
        details.

        :see: L{SetAGWFlags}
        """

        return self._agwFlags


    def SetFont(self, font):
        """
        Sets the L{AuiDefaultToolBarArt} font.

        :param `font`: a `wx.Font` object.
        """

        self._font = font


    def SetTextOrientation(self, orientation):
        """
        Sets the text orientation.

        :param `orientation`: can be one of the following constants:

         ==================================== ==================================
         Orientation Switches                 Description
         ==================================== ==================================
         ``AUI_TBTOOL_TEXT_LEFT``             Text in `AuiToolBar` items is aligned left
         ``AUI_TBTOOL_TEXT_RIGHT``            Text in `AuiToolBar` items is aligned right
         ``AUI_TBTOOL_TEXT_TOP``              Text in `AuiToolBar` items is aligned top
         ``AUI_TBTOOL_TEXT_BOTTOM``           Text in `AuiToolBar` items is aligned bottom
         ==================================== ==================================
        
        """

        self._text_orientation = orientation


    def GetFont(self):
        """ Returns the L{AuiDefaultToolBarArt} font. """

        return self._font


    def GetTextOrientation(self):
        """
        Returns the L{AuiDefaultToolBarArt} text orientation. See
        L{SetTextOrientation} for more details.

        :see: L{SetTextOrientation}
        """

        return self._text_orientation


    def SetOrientation(self, orientation):
        """
        Sets the toolbar tool orientation.

        :param `orientation`: one of ``AUI_TBTOOL_HORIZONTAL``, ``AUI_TBTOOL_VERT_CLOCKWISE`` or
         ``AUI_TBTOOL_VERT_COUNTERCLOCKWISE``.
        """

        self._orientation = orientation


    def GetOrientation(self):
        """ Returns the toolbar orientation. """

        return self._orientation        


    def DrawBackground(self, dc, wnd, _rect, horizontal=True):
        """
        Draws a toolbar background with a gradient shading.

        :param `dc`: a `wx.DC` device context;
        :param `wnd`: a `wx.Window` derived window;
        :param `_rect`: the L{AuiToolBar} rectangle;
        :param `horizontal`: ``True`` if the toolbar is horizontal, ``False`` if it is vertical.
        """

        rect = wx.Rect(*_rect)

        start_colour = StepColour(self._base_colour, 180)
        end_colour = StepColour(self._base_colour, 85)
        reflex_colour = StepColour(self._base_colour, 95)
        
        dc.GradientFillLinear(rect, start_colour, end_colour,
                              (horizontal and [wx.SOUTH] or [wx.EAST])[0])

        left = rect.GetLeft()
        right = rect.GetRight()
        top = rect.GetTop()
        bottom = rect.GetBottom()

        dc.SetPen(wx.Pen(reflex_colour))
        if horizontal:
            dc.DrawLine(left, bottom, right+1, bottom)
        else:
            dc.DrawLine(right, top, right, bottom+1)
            

    def DrawPlainBackground(self, dc, wnd, _rect):
        """
        Draws a toolbar background with a plain colour.

        This method contrasts with the default behaviour of the L{AuiToolBar} that
        draws a background gradient and this break the window design when putting
        it within a control that has margin between the borders and the toolbar
        (example: put L{AuiToolBar} within a `wx.StaticBoxSizer` that has a plain background).
      
        :param `dc`: a `wx.DC` device context;
        :param `wnd`: a `wx.Window` derived window;
        :param `_rect`: the L{AuiToolBar} rectangle.
        """
        
        rect = wx.Rect(*_rect)
        rect.height += 1

        dc.SetBrush(wx.Brush(wx.SystemSettings.GetColour(wx.SYS_COLOUR_3DFACE)))
        dc.DrawRectangle(rect.x - 1, rect.y - 1, rect.width + 2, rect.height + 1)


    def DrawLabel(self, dc, wnd, item, rect):
        """
        Draws a toolbar item label.
        
        :param `dc`: a `wx.DC` device context;
        :param `wnd`: a `wx.Window` derived window;
        :param `item`: an instance of L{AuiToolBarItem};
        :param `rect`: the L{AuiToolBarItem} rectangle.
        """
        
        dc.SetFont(self._font)
        dc.SetTextForeground(wx.BLACK)
        orient = item.GetOrientation()

        horizontal = orient == AUI_TBTOOL_HORIZONTAL
        # we only care about the text height here since the text
        # will get cropped based on the width of the item
        label_size = GetLabelSize(dc, item.GetLabel(), not horizontal)
        text_width = label_size.GetWidth()
        text_height = label_size.GetHeight()

        if orient == AUI_TBTOOL_HORIZONTAL:
            text_x = rect.x
            text_y = rect.y + (rect.height-text_height)/2
            dc.DrawText(item.GetLabel(), text_x, text_y)

        elif orient == AUI_TBTOOL_VERT_CLOCKWISE:
            text_x = rect.x + (rect.width+text_width)/2
            text_y = rect.y
            dc.DrawRotatedText(item.GetLabel(), text_x, text_y, 270)

        elif AUI_TBTOOL_VERT_COUNTERCLOCKWISE:
            text_x = rect.x + (rect.width-text_width)/2
            text_y = rect.y + text_height
            dc.DrawRotatedText(item.GetLabel(), text_x, text_y, 90)


    def DrawButton(self, dc, wnd, item, rect):
        """
        Draws a toolbar item button.
        
        :param `dc`: a `wx.DC` device context;
        :param `wnd`: a `wx.Window` derived window;
        :param `item`: an instance of L{AuiToolBarItem};
        :param `rect`: the L{AuiToolBarItem} rectangle.
        """

        bmp_rect, text_rect = self.GetToolsPosition(dc, item, rect)
        
        if not item.GetState() & AUI_BUTTON_STATE_DISABLED:
        
            if item.GetState() & AUI_BUTTON_STATE_PRESSED:
            
                dc.SetPen(wx.Pen(self._highlight_colour))
                dc.SetBrush(wx.Brush(StepColour(self._highlight_colour, 150)))
                dc.DrawRectangleRect(rect)
            
            elif item.GetState() & AUI_BUTTON_STATE_HOVER or item.IsSticky():
            
                dc.SetPen(wx.Pen(self._highlight_colour))
                dc.SetBrush(wx.Brush(StepColour(self._highlight_colour, 170)))

                # draw an even lighter background for checked item hovers (since
                # the hover background is the same colour as the check background)
                if item.GetState() & AUI_BUTTON_STATE_CHECKED:
                    dc.SetBrush(wx.Brush(StepColour(self._highlight_colour, 180)))

                dc.DrawRectangleRect(rect)
            
            elif item.GetState() & AUI_BUTTON_STATE_CHECKED:
            
                # it's important to put this code in an else statment after the
                # hover, otherwise hovers won't draw properly for checked items
                dc.SetPen(wx.Pen(self._highlight_colour))
                dc.SetBrush(wx.Brush(StepColour(self._highlight_colour, 170)))
                dc.DrawRectangleRect(rect)
            
        if item.GetState() & AUI_BUTTON_STATE_DISABLED:
            bmp = item.GetDisabledBitmap()
        else:
            bmp = item.GetBitmap()

        if bmp.IsOk():
            dc.DrawBitmap(bmp, bmp_rect.x, bmp_rect.y, True)

        # set the item's text colour based on if it is disabled
        dc.SetTextForeground(wx.BLACK)
        if item.GetState() & AUI_BUTTON_STATE_DISABLED:
            dc.SetTextForeground(DISABLED_TEXT_COLOUR)

        if self._agwFlags & AUI_TB_TEXT and item.GetLabel() != "":
            self.DrawLabel(dc, wnd, item, text_rect)
        

    def DrawDropDownButton(self, dc, wnd, item, rect):
        """
        Draws a toolbar dropdown button.
        
        :param `dc`: a `wx.DC` device context;
        :param `wnd`: a `wx.Window` derived window;
        :param `item`: an instance of L{AuiToolBarItem};
        :param `rect`: the L{AuiToolBarItem} rectangle.
        """
        
        dropbmp_x = dropbmp_y = 0

        button_rect = wx.Rect(rect.x, rect.y, rect.width-BUTTON_DROPDOWN_WIDTH, rect.height)
        dropdown_rect = wx.Rect(rect.x+rect.width-BUTTON_DROPDOWN_WIDTH-1, rect.y, BUTTON_DROPDOWN_WIDTH+1, rect.height)

        horizontal = item.GetOrientation() == AUI_TBTOOL_HORIZONTAL
        
        if horizontal:
            button_rect = wx.Rect(rect.x, rect.y, rect.width-BUTTON_DROPDOWN_WIDTH, rect.height)
            dropdown_rect = wx.Rect(rect.x+rect.width-BUTTON_DROPDOWN_WIDTH-1, rect.y, BUTTON_DROPDOWN_WIDTH+1, rect.height)
        else:
            button_rect = wx.Rect(rect.x, rect.y, rect.width, rect.height-BUTTON_DROPDOWN_WIDTH)
            dropdown_rect = wx.Rect(rect.x, rect.y+rect.height-BUTTON_DROPDOWN_WIDTH-1, rect.width, BUTTON_DROPDOWN_WIDTH+1)

        dropbmp_width = self._button_dropdown_bmp.GetWidth()
        dropbmp_height = self._button_dropdown_bmp.GetHeight()
        if not horizontal:
            tmp = dropbmp_width
            dropbmp_width = dropbmp_height
            dropbmp_height = tmp

        dropbmp_x = dropdown_rect.x + (dropdown_rect.width/2) - dropbmp_width/2
        dropbmp_y = dropdown_rect.y + (dropdown_rect.height/2) - dropbmp_height/2

        bmp_rect, text_rect = self.GetToolsPosition(dc, item, button_rect)
        
        if item.GetState() & AUI_BUTTON_STATE_PRESSED:
        
            dc.SetPen(wx.Pen(self._highlight_colour))
            dc.SetBrush(wx.Brush(StepColour(self._highlight_colour, 140)))
            dc.DrawRectangleRect(button_rect)
            dc.DrawRectangleRect(dropdown_rect)
        
        elif item.GetState() & AUI_BUTTON_STATE_HOVER or item.IsSticky():
        
            dc.SetPen(wx.Pen(self._highlight_colour))
            dc.SetBrush(wx.Brush(StepColour(self._highlight_colour, 170)))
            dc.DrawRectangleRect(button_rect)
            dc.DrawRectangleRect(dropdown_rect)

        elif item.GetState() & AUI_BUTTON_STATE_CHECKED:
            # it's important to put this code in an else statment after the 
            # hover, otherwise hovers won't draw properly for checked items 
            dc.SetPen(wx.Pen(self._highlight_colour))
            dc.SetBrush(wx.Brush(StepColour(self._highlight_colour, 170)))
            dc.DrawRectangle(button_rect)
            dc.DrawRectangle(dropdown_rect)
            
        if item.GetState() & AUI_BUTTON_STATE_DISABLED:
        
            bmp = item.GetDisabledBitmap()
            dropbmp = self._disabled_button_dropdown_bmp
        
        else:
        
            bmp = item.GetBitmap()
            dropbmp = self._button_dropdown_bmp
        
        if not bmp.IsOk():
            return

        dc.DrawBitmap(bmp, bmp_rect.x, bmp_rect.y, True)
        if horizontal:
            dc.DrawBitmap(dropbmp, dropbmp_x, dropbmp_y, True)
        else:
            dc.DrawBitmap(wx.BitmapFromImage(dropbmp.ConvertToImage().Rotate90(item.GetOrientation() == AUI_TBTOOL_VERT_CLOCKWISE)),
                          dropbmp_x, dropbmp_y, True)
            
        # set the item's text colour based on if it is disabled
        dc.SetTextForeground(wx.BLACK)
        if item.GetState() & AUI_BUTTON_STATE_DISABLED:
            dc.SetTextForeground(DISABLED_TEXT_COLOUR)

        if self._agwFlags & AUI_TB_TEXT and item.GetLabel() != "":  
            self.DrawLabel(dc, wnd, item, text_rect)
        

    def DrawControlLabel(self, dc, wnd, item, rect):
        """
        Draws a label for a toolbar control.
        
        :param `dc`: a `wx.DC` device context;
        :param `wnd`: a `wx.Window` derived window;
        :param `item`: an instance of L{AuiToolBarItem};
        :param `rect`: the L{AuiToolBarItem} rectangle.
        """

        label_size = GetLabelSize(dc, item.GetLabel(), item.GetOrientation() != AUI_TBTOOL_HORIZONTAL)
        text_height = label_size.GetHeight()
        text_width = label_size.GetWidth()

        dc.SetFont(self._font)

        if self._agwFlags & AUI_TB_TEXT:
        
            tx, text_height = dc.GetTextExtent("ABCDHgj")        

        text_width, ty = dc.GetTextExtent(item.GetLabel())

        # don't draw the label if it is wider than the item width
        if text_width > rect.width:
            return

        # set the label's text colour
        dc.SetTextForeground(wx.BLACK)

        text_x = rect.x + (rect.width/2) - (text_width/2) + 1
        text_y = rect.y + rect.height - text_height - 1

        if self._agwFlags & AUI_TB_TEXT and item.GetLabel() != "": 
            dc.DrawText(item.GetLabel(), text_x, text_y)
    

    def GetLabelSize(self, dc, wnd, item):
        """
        Returns the label size for a toolbar item.
        
        :param `dc`: a `wx.DC` device context;
        :param `wnd`: a `wx.Window` derived window;
        :param `item`: an instance of L{AuiToolBarItem}.
        """

        dc.SetFont(self._font)
        label_size = GetLabelSize(dc, item.GetLabel(), self._orientation != AUI_TBTOOL_HORIZONTAL)

        return wx.Size(item.GetMinSize().GetWidth(), label_size.GetHeight())


    def GetToolSize(self, dc, wnd, item):
        """
        Returns the toolbar item size.
        
        :param `dc`: a `wx.DC` device context;
        :param `wnd`: a `wx.Window` derived window;
        :param `item`: an instance of L{AuiToolBarItem}.
        """
        
        if not item.GetBitmap().IsOk() and not self._agwFlags & AUI_TB_TEXT:
            return wx.Size(16, 16)

        width = item.GetBitmap().GetWidth()
        height = item.GetBitmap().GetHeight()

        if self._agwFlags & AUI_TB_TEXT:
        
            dc.SetFont(self._font)
            label_size = GetLabelSize(dc, item.GetLabel(), self.GetOrientation() != AUI_TBTOOL_HORIZONTAL)
            padding = 6
            
            if self._text_orientation == AUI_TBTOOL_TEXT_BOTTOM:
            
                if self.GetOrientation() != AUI_TBTOOL_HORIZONTAL:
                    height += 3   # space between top border and bitmap
                    height += 3   # space between bitmap and text
                    padding = 0

                height += label_size.GetHeight()
            
                if item.GetLabel() != "":
                    width = max(width, label_size.GetWidth()+padding)
                
            elif self._text_orientation == AUI_TBTOOL_TEXT_RIGHT and item.GetLabel() != "":
            
                if self.GetOrientation() == AUI_TBTOOL_HORIZONTAL:
                    
                    width += 3  # space between left border and bitmap
                    width += 3  # space between bitmap and text
                    padding = 0

                width += label_size.GetWidth()
                height = max(height, label_size.GetHeight()+padding)
                
        # if the tool has a dropdown button, add it to the width
        if item.HasDropDown():
            if item.GetOrientation() == AUI_TBTOOL_HORIZONTAL:
                width += BUTTON_DROPDOWN_WIDTH+4
            else:
                height += BUTTON_DROPDOWN_WIDTH+4

        return wx.Size(width, height)


    def DrawSeparator(self, dc, wnd, _rect):
        """
        Draws a toolbar separator.
        
        :param `dc`: a `wx.DC` device context;
        :param `wnd`: a `wx.Window` derived window;
        :param `_rect`: the L{AuiToolBarItem} rectangle.
        """
        
        horizontal = True
        if self._agwFlags & AUI_TB_VERTICAL:
            horizontal = False

        rect = wx.Rect(*_rect)

        if horizontal:
        
            rect.x += (rect.width/2)
            rect.width = 1
            new_height = (rect.height*3)/4
            rect.y += (rect.height/2) - (new_height/2)
            rect.height = new_height
        
        else:
        
            rect.y += (rect.height/2)
            rect.height = 1
            new_width = (rect.width*3)/4
            rect.x += (rect.width/2) - (new_width/2)
            rect.width = new_width
        
        start_colour = StepColour(self._base_colour, 80)
        end_colour = StepColour(self._base_colour, 80)
        dc.GradientFillLinear(rect, start_colour, end_colour, (horizontal and [wx.SOUTH] or [wx.EAST])[0])


    def DrawGripper(self, dc, wnd, rect):
        """
        Draws the toolbar gripper.
        
        :param `dc`: a `wx.DC` device context;
        :param `wnd`: a `wx.Window` derived window;
        :param `rect`: the L{AuiToolBar} rectangle.
        """
        
        i = 0
        while 1:
        
            if self._agwFlags & AUI_TB_VERTICAL:
            
                x = rect.x + (i*4) + 4
                y = rect.y + 3
                if x > rect.GetWidth() - 4:
                    break
            
            else:
            
                x = rect.x + 3
                y = rect.y + (i*4) + 4
                if y > rect.GetHeight() - 4:
                    break
            
            dc.SetPen(self._gripper_pen1)
            dc.DrawPoint(x, y)
            dc.SetPen(self._gripper_pen2)
            dc.DrawPoint(x, y+1)
            dc.DrawPoint(x+1, y)
            dc.SetPen(self._gripper_pen3)
            dc.DrawPoint(x+2, y+1)
            dc.DrawPoint(x+2, y+2)
            dc.DrawPoint(x+1, y+2)

            i += 1


    def DrawOverflowButton(self, dc, wnd, rect, state):
        """
        Draws the overflow button for the L{AuiToolBar}.
        
        :param `dc`: a `wx.DC` device context;
        :param `wnd`: a `wx.Window` derived window;
        :param `rect`: the L{AuiToolBar} rectangle;
        :param `state`: the overflow button state.
        """
        
        if state & AUI_BUTTON_STATE_HOVER or  state & AUI_BUTTON_STATE_PRESSED:
        
            cli_rect = wnd.GetClientRect()
            light_gray_bg = StepColour(self._highlight_colour, 170)

            if self._agwFlags & AUI_TB_VERTICAL:
            
                dc.SetPen(wx.Pen(self._highlight_colour))
                dc.DrawLine(rect.x, rect.y, rect.x+rect.width, rect.y)
                dc.SetPen(wx.Pen(light_gray_bg))
                dc.SetBrush(wx.Brush(light_gray_bg))
                dc.DrawRectangle(rect.x, rect.y+1, rect.width, rect.height)
            
            else:
            
                dc.SetPen(wx.Pen(self._highlight_colour))
                dc.DrawLine(rect.x, rect.y, rect.x, rect.y+rect.height)
                dc.SetPen(wx.Pen(light_gray_bg))
                dc.SetBrush(wx.Brush(light_gray_bg))
                dc.DrawRectangle(rect.x+1, rect.y, rect.width, rect.height)
            
        x = rect.x + 1 + (rect.width-self._overflow_bmp.GetWidth())/2
        y = rect.y + 1 + (rect.height-self._overflow_bmp.GetHeight())/2
        dc.DrawBitmap(self._overflow_bmp, x, y, True)


    def GetElementSize(self, element_id):
        """
        Returns the size of a UI element in the L{AuiToolBar}.

        :param `element_id`: can be one of the following:

         ==================================== ==================================
         Element Identifier                   Description
         ==================================== ==================================
         ``AUI_TBART_SEPARATOR_SIZE``         Separator size in `AuiToolBar`
         ``AUI_TBART_GRIPPER_SIZE``           Gripper size in `AuiToolBar`
         ``AUI_TBART_OVERFLOW_SIZE``          Overflow button size in `AuiToolBar`
         ==================================== ==================================        
        """
        
        if element_id == AUI_TBART_SEPARATOR_SIZE:
            return self._separator_size
        elif element_id == AUI_TBART_GRIPPER_SIZE:
            return self._gripper_size
        elif element_id == AUI_TBART_OVERFLOW_SIZE:
            return self._overflow_size

        return 0


    def SetElementSize(self, element_id, size):
        """
        Sets the size of a UI element in the L{AuiToolBar}.

        :param `element_id`: can be one of the following:

         ==================================== ==================================
         Element Identifier                   Description
         ==================================== ==================================
         ``AUI_TBART_SEPARATOR_SIZE``         Separator size in `AuiToolBar`
         ``AUI_TBART_GRIPPER_SIZE``           Gripper size in `AuiToolBar`
         ``AUI_TBART_OVERFLOW_SIZE``          Overflow button size in `AuiToolBar`
         ==================================== ==================================

        :param `size`: the new size of the UI element.        
        """
        
        if element_id == AUI_TBART_SEPARATOR_SIZE:
            self._separator_size = size
        elif element_id == AUI_TBART_GRIPPER_SIZE:
            self._gripper_size = size
        elif element_id == AUI_TBART_OVERFLOW_SIZE:
            self._overflow_size = size


    def ShowDropDown(self, wnd, items):
        """
        Shows the drop down window menu for overflow items.

        :param `wnd`: an instance of `wx.Window`;
        :param `items`: the overflow toolbar items (a Python list).
        """

        menuPopup = wx.Menu()
        items_added = 0

        for item in items:

            if item.GetKind() not in [ITEM_SEPARATOR, ITEM_SPACER, ITEM_CONTROL]:
            
                text = item.GetShortHelp()
                if text == "":
                    text = item.GetLabel()
                if text == "":
                    text = " "

                kind = item.GetKind()
                m = wx.MenuItem(menuPopup, item.GetId(), text, item.GetShortHelp(), kind)
                orientation = item.GetOrientation()
                item.SetOrientation(AUI_TBTOOL_HORIZONTAL)
                
                if kind not in [ITEM_CHECK, ITEM_RADIO]:
                    m.SetBitmap(item.GetBitmap())

                item.SetOrientation(orientation)                    
                    
                menuPopup.AppendItem(m)
                if kind in [ITEM_CHECK, ITEM_RADIO]:            
                    state = (item.state & AUI_BUTTON_STATE_CHECKED and [True] or [False])[0]
                    m.Check(state)

                items_added += 1
            
            else:
            
                if items_added > 0 and item.GetKind() == ITEM_SEPARATOR:
                    menuPopup.AppendSeparator()
            
        # find out where to put the popup menu of window items
        pt = wx.GetMousePosition()
        pt = wnd.ScreenToClient(pt)

        # find out the screen coordinate at the bottom of the tab ctrl
        cli_rect = wnd.GetClientRect()
        pt.y = cli_rect.y + cli_rect.height

        cc = ToolbarCommandCapture()
        wnd.PushEventHandler(cc)

        # Adjustments to get slightly better menu placement
        if wx.Platform == "__WXMAC__":
            pt.y += 5
            pt.x -= 5

        wnd.PopupMenu(menuPopup, pt)
        command = cc.GetCommandId()
        wnd.PopEventHandler(True)

        return command


    def GetToolsPosition(self, dc, item, rect):
        """
        Returns the bitmap and text rectangles for a toolbar item.
        
        :param `dc`: a `wx.DC` device context;
        :param `item`: an instance of L{AuiToolBarItem};
        :param `rect`: the tool rect.
        """
        
        text_width = text_height = 0
        horizontal = self._orientation == AUI_TBTOOL_HORIZONTAL
        text_bottom = self._text_orientation == AUI_TBTOOL_TEXT_BOTTOM
        text_right = self._text_orientation == AUI_TBTOOL_TEXT_RIGHT
        bmp_width = item.GetBitmap().GetWidth()
        bmp_height = item.GetBitmap().GetHeight()
     
        if self._agwFlags & AUI_TB_TEXT:        
            dc.SetFont(self._font)
            label_size = GetLabelSize(dc, item.GetLabel(), not horizontal)
            text_height = label_size.GetHeight()
            text_width = label_size.GetWidth()
        
        bmp_x = bmp_y = text_x = text_y = 0

        if horizontal and text_bottom:
            bmp_x = rect.x + (rect.width/2) - (bmp_width/2)
            bmp_y = rect.y + 3
            text_x = rect.x + (rect.width/2) - (text_width/2)
            text_y = rect.y + ((bmp_y - rect.y) * 2) + bmp_height
        
        elif horizontal and text_right:
            bmp_x = rect.x + 3
            bmp_y = rect.y + (rect.height/2) - (bmp_height / 2)
            text_x = rect.x + ((bmp_x - rect.x) * 2) + bmp_width
            text_y = rect.y + (rect.height/2) - (text_height/2)
        
        elif not horizontal and text_bottom:
            bmp_x = rect.x + (rect.width / 2) - (bmp_width / 2)
            bmp_y = rect.y + 3
            text_x = rect.x + (rect.width / 2) - (text_width / 2)
            text_y = rect.y + ((bmp_y - rect.y) * 2) + bmp_height
        
        bmp_rect = wx.Rect(bmp_x, bmp_y, bmp_width, bmp_height)
        text_rect = wx.Rect(text_x, text_y, text_width, text_height)

        return bmp_rect, text_rect

    
class AuiToolBar(wx.PyControl):
    """
    AuiToolBar is a completely owner-drawn toolbar perfectly integrated with the
    AUI layout system. This allows drag and drop of toolbars, docking/floating
    behaviour and the possibility to define "overflow" items in the toolbar itself.

    The default theme that is used is L{AuiDefaultToolBarArt}, which provides a modern,
    glossy look and feel. The theme can be changed by calling L{AuiToolBar.SetArtProvider}.
    """

    def __init__(self, parent, id=wx.ID_ANY, pos=wx.DefaultPosition,
                 size=wx.DefaultSize, style=0, agwStyle=AUI_TB_DEFAULT_STYLE):
        """
        Default class constructor.

        :param `parent`: the L{AuiToolBar} parent;
        :param `id`: an identifier for the control: a value of -1 is taken to mean a default;
        :param `pos`: the control position. A value of (-1, -1) indicates a default position,
         chosen by either the windowing system or wxPython, depending on platform;
        :param `size`: the control size. A value of (-1, -1) indicates a default size,
         chosen by either the windowing system or wxPython, depending on platform;
        :param `style`: the control window style;
        :param `agwStyle`: the AGW-specific window style. This can be a combination of the
         following bits:
        
         ==================================== ==================================
         Flag name                            Description
         ==================================== ==================================
         ``AUI_TB_TEXT``                      Shows the text in the toolbar buttons; by default only icons are shown
         ``AUI_TB_NO_TOOLTIPS``               Don't show tooltips on `AuiToolBar` items
         ``AUI_TB_NO_AUTORESIZE``             Do not auto-resize the `AuiToolBar`
         ``AUI_TB_GRIPPER``                   Shows a gripper on the `AuiToolBar`
         ``AUI_TB_OVERFLOW``                  The `AuiToolBar` can contain overflow items
         ``AUI_TB_VERTICAL``                  The `AuiToolBar` is vertical
         ``AUI_TB_HORZ_LAYOUT``               Shows the text and the icons alongside, not vertically stacked. This style must be used with ``AUI_TB_TEXT``
         ``AUI_TB_PLAIN_BACKGROUND``          Don't draw a gradient background on the toolbar
         ``AUI_TB_HORZ_TEXT``                 Combination of ``AUI_TB_HORZ_LAYOUT`` and ``AUI_TB_TEXT``
         ==================================== ==================================

         The default value for `agwStyle` is: ``AUI_TB_DEFAULT_STYLE`` = 0

        """
        
        wx.PyControl.__init__(self, parent, id, pos, size, style|wx.BORDER_NONE)

        self._sizer = wx.BoxSizer(wx.HORIZONTAL)
        self.SetSizer(self._sizer)
        self._button_width = -1
        self._button_height = -1
        self._sizer_element_count = 0
        self._action_pos = wx.Point(-1, -1)
        self._action_item = None
        self._tip_item = None
        self._art = AuiDefaultToolBarArt()
        self._tool_packing = 2
        self._tool_border_padding = 3
        self._tool_text_orientation = AUI_TBTOOL_TEXT_BOTTOM
        self._tool_orientation = AUI_TBTOOL_HORIZONTAL
        self._tool_alignment = wx.EXPAND
        self._gripper_sizer_item = None
        self._overflow_sizer_item = None
        self._dragging = False

        self._agwStyle = self._originalStyle = agwStyle

        self._gripper_visible = (self._agwStyle & AUI_TB_GRIPPER and [True] or [False])[0]
        self._overflow_visible = (self._agwStyle & AUI_TB_OVERFLOW and [True] or [False])[0]
        self._overflow_state = 0
        self._custom_overflow_prepend = []
        self._custom_overflow_append = []

        self._items = []
        
        self.SetMargins(5, 5, 2, 2)
        self.SetFont(wx.NORMAL_FONT)
        self._art.SetAGWFlags(self._agwStyle)
        self.SetExtraStyle(wx.WS_EX_PROCESS_IDLE)
        
        if agwStyle & AUI_TB_HORZ_LAYOUT:
            self.SetToolTextOrientation(AUI_TBTOOL_TEXT_RIGHT)
        elif agwStyle & AUI_TB_VERTICAL:
            if agwStyle & AUI_TB_CLOCKWISE:
                self.SetToolOrientation(AUI_TBTOOL_VERT_CLOCKWISE)
            elif agwStyle & AUI_TB_COUNTERCLOCKWISE:
                self.SetToolOrientation(AUI_TBTOOL_VERT_COUNTERCLOCKWISE)
 
        self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM)
        
        self.Bind(wx.EVT_SIZE, self.OnSize)
        self.Bind(wx.EVT_IDLE, self.OnIdle)
        self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnEraseBackground)
        self.Bind(wx.EVT_PAINT, self.OnPaint)
        self.Bind(wx.EVT_LEFT_DOWN, self.OnLeftDown)
        self.Bind(wx.EVT_LEFT_DCLICK, self.OnLeftDown)
        self.Bind(wx.EVT_LEFT_UP, self.OnLeftUp)
        self.Bind(wx.EVT_RIGHT_DOWN, self.OnRightDown)
        self.Bind(wx.EVT_RIGHT_DCLICK, self.OnRightDown)
        self.Bind(wx.EVT_RIGHT_UP, self.OnRightUp)
        self.Bind(wx.EVT_MIDDLE_DOWN, self.OnMiddleDown)
        self.Bind(wx.EVT_MIDDLE_DCLICK, self.OnMiddleDown)
        self.Bind(wx.EVT_MIDDLE_UP, self.OnMiddleUp)
        self.Bind(wx.EVT_MOTION, self.OnMotion)
        self.Bind(wx.EVT_LEAVE_WINDOW, self.OnLeaveWindow)
        self.Bind(wx.EVT_SET_CURSOR, self.OnSetCursor)


    def SetWindowStyleFlag(self, style):
        """
        Sets the style of the window.
        
        :param `style`: the new window style. 

        :note: Please note that some styles cannot be changed after the window
         creation and that `Refresh` might need to be be called after changing the
         others for the change to take place immediately.

        :note: Overridden from `wx.PyControl`.
        """

        wx.PyControl.SetWindowStyleFlag(self, style|wx.BORDER_NONE)
        

    def SetAGWWindowStyleFlag(self, agwStyle):
        """
        Sets the AGW-specific style of the window.
        
        :param `agwStyle`: the new window style. This can be a combination of the
         following bits:
        
         ==================================== ==================================
         Flag name                            Description
         ==================================== ==================================
         ``AUI_TB_TEXT``                      Shows the text in the toolbar buttons; by default only icons are shown
         ``AUI_TB_NO_TOOLTIPS``               Don't show tooltips on `AuiToolBar` items
         ``AUI_TB_NO_AUTORESIZE``             Do not auto-resize the `AuiToolBar`
         ``AUI_TB_GRIPPER``                   Shows a gripper on the `AuiToolBar`
         ``AUI_TB_OVERFLOW``                  The `AuiToolBar` can contain overflow items
         ``AUI_TB_VERTICAL``                  The `AuiToolBar` is vertical
         ``AUI_TB_HORZ_LAYOUT``               Shows the text and the icons alongside, not vertically stacked. This style must be used with ``AUI_TB_TEXT``
         ``AUI_TB_PLAIN_BACKGROUND``          Don't draw a gradient background on the toolbar
         ``AUI_TB_HORZ_TEXT``                 Combination of ``AUI_TB_HORZ_LAYOUT`` and ``AUI_TB_TEXT``
         ==================================== ==================================

        :note: Please note that some styles cannot be changed after the window
         creation and that `Refresh` might need to be be called after changing the
         others for the change to take place immediately.
        """
        
        self._agwStyle = self._originalStyle = agwStyle

        if self._art:
            self._art.SetAGWFlags(self._agwStyle)
        
        if agwStyle & AUI_TB_GRIPPER:
            self._gripper_visible = True
        else:
            self._gripper_visible = False

        if agwStyle & AUI_TB_OVERFLOW:
            self._overflow_visible = True
        else:
            self._overflow_visible = False

        if agwStyle & AUI_TB_HORZ_LAYOUT:
            self.SetToolTextOrientation(AUI_TBTOOL_TEXT_RIGHT)
        else:
            self.SetToolTextOrientation(AUI_TBTOOL_TEXT_BOTTOM)

        if agwStyle & AUI_TB_VERTICAL:
            if agwStyle & AUI_TB_CLOCKWISE:
                self.SetToolOrientation(AUI_TBTOOL_VERT_CLOCKWISE)
            elif agwStyle & AUI_TB_COUNTERCLOCKWISE:
                self.SetToolOrientation(AUI_TBTOOL_VERT_COUNTERCLOCKWISE)

                
    def GetAGWWindowStyleFlag(self):
        """
        Returns the AGW-specific window style flag.

        :see: L{SetAGWWindowStyleFlag} for an explanation of various AGW-specific style.
        """

        return self._agwStyle
    

    def SetArtProvider(self, art):
        """
        Instructs L{AuiToolBar} to use art provider specified by parameter `art`
        for all drawing calls. This allows plugable look-and-feel features. 

        :param `art`: an art provider.

        :note: The previous art provider object, if any, will be deleted by L{AuiToolBar}.
        """
        
        del self._art
        self._art = art

        if self._art:
            self._art.SetAGWFlags(self._agwStyle)
            self._art.SetTextOrientation(self._tool_text_orientation)
            self._art.SetOrientation(self._tool_orientation)
        

    def GetArtProvider(self):
        """ Returns the current art provider being used. """

        return self._art


    def AddSimpleTool(self, tool_id, label, bitmap, short_help_string="", kind=ITEM_NORMAL):
        """
        Adds a tool to the toolbar. This is the simplest method you can use to
        ass an item to the L{AuiToolBar}.

        :param `tool_id`: an integer by which the tool may be identified in subsequent operations;
        :param `label`: the toolbar tool label;
        :param `bitmap`: the primary tool bitmap;
        :param `short_help_string`: this string is used for the tools tooltip;
        :param `kind`: the item kind. Can be one of the following:

         ========================  =============================
         Item Kind                 Description
         ========================  =============================
         ``ITEM_CONTROL``          The item in the `AuiToolBar` is a control
         ``ITEM_LABEL``            The item in the `AuiToolBar` is a text label
         ``ITEM_SPACER``           The item in the `AuiToolBar` is a spacer
         ``ITEM_SEPARATOR``        The item in the `AuiToolBar` is a separator
         ``ITEM_CHECK``            The item in the `AuiToolBar` is a toolbar check item
         ``ITEM_NORMAL``           The item in the `AuiToolBar` is a standard toolbar item
         ``ITEM_RADIO``            The item in the `AuiToolBar` is a toolbar radio item
         ========================  =============================
        """
        
        return self.AddTool(tool_id, label, bitmap, wx.NullBitmap, kind, short_help_string, "", None)


    def AddToggleTool(self, tool_id, bitmap, disabled_bitmap, toggle=False, client_data=None, short_help_string="", long_help_string=""):
        """
        Adds a toggle tool to the toolbar. 

        :param `tool_id`: an integer by which the tool may be identified in subsequent operations;
        :param `bitmap`: the primary tool bitmap;
        :param `disabled_bitmap`: the bitmap to use when the tool is disabled. If it is equal to
         `wx.NullBitmap`, the disabled bitmap is automatically generated by greing the normal one;
        :param `client_data`: whatever Python object to associate with the toolbar item;
        :param `short_help_string`: this string is used for the tools tooltip;
        :param `long_help_string`: this string is shown in the statusbar (if any) of the parent
         frame when the mouse pointer is inside the tool.
        """

        kind = (toggle and [ITEM_CHECK] or [ITEM_NORMAL])[0]
        return self.AddTool(tool_id, "", bitmap, disabled_bitmap, kind, short_help_string, long_help_string, client_data)


    def AddTool(self, tool_id, label, bitmap, disabled_bitmap, kind, short_help_string, long_help_string, client_data):
        """
        Adds a tool to the toolbar. This is the full feature version of L{AddTool}.

        :param `tool_id`: an integer by which the tool may be identified in subsequent operations;
        :param `label`: the toolbar tool label;
        :param `bitmap`: the primary tool bitmap;
        :param `disabled_bitmap`: the bitmap to use when the tool is disabled. If it is equal to
         `wx.NullBitmap`, the disabled bitmap is automatically generated by greing the normal one;
        :param `kind`: the item kind. Can be one of the following:

         ========================  =============================
         Item Kind                 Description
         ========================  =============================
         ``ITEM_CONTROL``          The item in the `AuiToolBar` is a control
         ``ITEM_LABEL``            The item in the `AuiToolBar` is a text label
         ``ITEM_SPACER``           The item in the `AuiToolBar` is a spacer
         ``ITEM_SEPARATOR``        The item in the `AuiToolBar` is a separator
         ``ITEM_CHECK``            The item in the `AuiToolBar` is a toolbar check item
         ``ITEM_NORMAL``           The item in the `AuiToolBar` is a standard toolbar item
         ``ITEM_RADIO``            The item in the `AuiToolBar` is a toolbar radio item
         ========================  =============================

        :param `short_help_string`: this string is used for the tools tooltip;
        :param `long_help_string`: this string is shown in the statusbar (if any) of the parent
         frame when the mouse pointer is inside the tool.
        :param `client_data`: whatever Python object to associate with the toolbar item.
        """
        
        item = AuiToolBarItem()
        item.window = None
        item.label = label
        item.bitmap = bitmap
        item.disabled_bitmap = disabled_bitmap
        item.short_help = short_help_string
        item.long_help = long_help_string
        item.active = True
        item.dropdown = False
        item.spacer_pixels = 0

        if tool_id == wx.ID_ANY:
            tool_id = wx.NewId()
            
        item.id = tool_id
        item.state = 0
        item.proportion = 0
        item.kind = kind
        item.sizer_item = None
        item.min_size = wx.Size(-1, -1)
        item.user_data = 0
        item.sticky = False
        item.orientation = self._tool_orientation

        if not item.disabled_bitmap.IsOk():
            # no disabled bitmap specified, we need to make one
            if item.bitmap.IsOk():
                item.disabled_bitmap = MakeDisabledBitmap(item.bitmap)
        
        self._items.append(item)
        return self._items[-1]


    def AddCheckTool(self, tool_id, label, bitmap, disabled_bitmap, short_help_string="", long_help_string="", client_data=None):
        """
        Adds a new check (or toggle) tool to the L{AuiToolBar}.
        
        :see: L{AddTool}.
        """

        return self.AddTool(tool_id, label, bitmap, disabled_bitmap, ITEM_CHECK, short_help_string, long_help_string, client_data) 


    def AddRadioTool(self, tool_id, label, bitmap, disabled_bitmap, short_help_string="", long_help_string="", client_data=None):
        """
        Adds a new radio tool to the toolbar.

        Consecutive radio tools form a radio group such that exactly one button
        in the group is pressed at any moment, in other words whenever a button
        in the group is pressed the previously pressed button is automatically
        released. You should avoid having the radio groups of only one element
        as it would be impossible for the user to use such button.

        :note: By default, the first button in the radio group is initially pressed,
         the others are not.

        :see: L{AddTool}.
        """

        return self.AddTool(tool_id, label, bitmap, disabled_bitmap, ITEM_RADIO, short_help_string, long_help_string, client_data)

    
    def AddControl(self, control, label=""):
        """
        Adds any control to the toolbar, typically e.g. a combobox.

        :param `control`: the control to be added;
        :param `label`: the label which appears if the control goes into the
         overflow items in the toolbar.
        """

        item = AuiToolBarItem()
        item.window = control
        item.label = label
        item.bitmap = wx.NullBitmap
        item.disabled_bitmap = wx.NullBitmap
        item.active = True
        item.dropdown = False
        item.spacer_pixels = 0
        item.id = control.GetId()
        item.state = 0
        item.proportion = 0
        item.kind = ITEM_CONTROL
        item.sizer_item = None
        item.min_size = control.GetEffectiveMinSize()
        item.user_data = 0
        item.sticky = False
        item.orientation = self._tool_orientation

        self._items.append(item)
        return self._items[-1]


    def AddLabel(self, tool_id, label="", width=0):
        """
        Adds a label tool to the L{AuiToolBar}.

        :param `tool_id`: an integer by which the tool may be identified in subsequent operations;
        :param `label`: the toolbar tool label;
        :param `width`: the tool width.
        """

        min_size = wx.Size(-1, -1)
        
        if width != -1:
            min_size.x = width

        item = AuiToolBarItem()
        item.window = None
        item.label = label
        item.bitmap = wx.NullBitmap
        item.disabled_bitmap = wx.NullBitmap
        item.active = True
        item.dropdown = False
        item.spacer_pixels = 0

        if tool_id == wx.ID_ANY:
            tool_id = wx.NewId()
        
        item.id = tool_id
        item.state = 0
        item.proportion = 0
        item.kind = ITEM_LABEL
        item.sizer_item = None
        item.min_size = min_size
        item.user_data = 0
        item.sticky = False
        item.orientation = self._tool_orientation

        self._items.append(item)
        return self._items[-1]


    def AddSeparator(self):
        """ Adds a separator for spacing groups of tools. """
        
        item = AuiToolBarItem()
        item.window = None
        item.label = ""
        item.bitmap = wx.NullBitmap
        item.disabled_bitmap = wx.NullBitmap
        item.active = True
        item.dropdown = False
        item.id = -1
        item.state = 0
        item.proportion = 0
        item.kind = ITEM_SEPARATOR
        item.sizer_item = None
        item.min_size = wx.Size(-1, -1)
        item.user_data = 0
        item.sticky = False
        item.orientation = self._tool_orientation

        self._items.append(item)
        return self._items[-1]


    def AddSpacer(self, pixels):
        """
        Adds a spacer for spacing groups of tools.

        :param `pixels`: the width of the spacer.
        """

        item = AuiToolBarItem()
        item.window = None
        item.label = ""
        item.bitmap = wx.NullBitmap
        item.disabled_bitmap = wx.NullBitmap
        item.active = True
        item.dropdown = False
        item.spacer_pixels = pixels
        item.id = -1
        item.state = 0
        item.proportion = 0
        item.kind = ITEM_SPACER
        item.sizer_item = None
        item.min_size = wx.Size(-1, -1)
        item.user_data = 0
        item.sticky = False
        item.orientation = self._tool_orientation

        self._items.append(item)
        return self._items[-1]


    def AddStretchSpacer(self, proportion=1):
        """
        Adds a stretchable spacer for spacing groups of tools.

        :param `proportion`: the stretchable spacer proportion.
        """
        
        item = AuiToolBarItem()
        item.window = None
        item.label = ""
        item.bitmap = wx.NullBitmap
        item.disabled_bitmap = wx.NullBitmap
        item.active = True
        item.dropdown = False
        item.spacer_pixels = 0
        item.id = -1
        item.state = 0
        item.proportion = proportion
        item.kind = ITEM_SPACER
        item.sizer_item = None
        item.min_size = wx.Size(-1, -1)
        item.user_data = 0
        item.sticky = False
        item.orientation = self._tool_orientation

        self._items.append(item)
        return self._items[-1]


    def Clear(self):
        """ Deletes all the tools in the L{AuiToolBar}. """

        self._items = []
        self._sizer_element_count = 0


    def ClearTools(self):
        """ Deletes all the tools in the L{AuiToolBar}. """

        self.Clear()
        

    def DeleteTool(self, tool_id):
        """
        Removes the specified tool from the toolbar and deletes it.

        :param `tool_id`: the L{AuiToolBarItem} identifier.

        :returns: ``True`` if the tool was deleted, ``False`` otherwise.
        
        :note: Note that it is unnecessary to call L{Realize} for the change to
         take place, it will happen immediately.
        """

        idx = self.GetToolIndex(tool_id)
        
        if idx >= 0 and idx < len(self._items):
            self._items.pop(idx)
            self.Realize()
            return True
        
        return False


    def DeleteToolByPos(self, pos):
        """
        This function behaves like L{DeleteTool} but it deletes the tool at the
        specified position and not the one with the given id.

        :param `pos`: the tool position.

        :see: L{DeleteTool}        
        """
        
        if pos >= 0 and pos < len(self._items):
            
            self._items.pop(pos)
            self.Realize()
            return True

        return False


    def FindControl(self, id):
        """
        Returns a pointer to the control identified by `id` or ``None`` if no corresponding
        control is found.

        :param `id`: the control identifier.        
        """
        
        wnd = self.FindWindow(id)
        return wnd


    def FindTool(self, tool_id):
        """
        Finds a tool for the given tool id.

        :param `tool_id`: the L{AuiToolBarItem} identifier.
        """
        
        for item in self._items:
            if item.id == tool_id:
                return item
    
        return None


    def FindToolForPosition(self, x, y):
        """
        Finds a tool for the given mouse position.

        :param `x`: mouse `x` position;
        :param `y`: mouse `y` position.

        :returns: a pointer to a L{AuiToolBarItem} if a tool is found, or ``None`` otherwise.
        """

        for i, item in enumerate(self._items):
            if not item.sizer_item:
                continue

            rect = item.sizer_item.GetRect()
            if rect.Contains((x,y)):
            
                # if the item doesn't fit on the toolbar, return None
                if not self.GetToolFitsByIndex(i):
                    return None

                return item
            
        return None


    def FindToolForPositionWithPacking(self, x, y):
        """
        Finds a tool for the given mouse position, taking into account also the
        tool packing.

        :param `x`: mouse `x` position;
        :param `y`: mouse `y` position.

        :returns: a pointer to a L{AuiToolBarItem} if a tool is found, or ``None`` otherwise.
        """
        
        count = len(self._items)
        
        for i, item in enumerate(self._items):
            if not item.sizer_item:
                continue

            rect = item.sizer_item.GetRect()

            # apply tool packing
            if i+1 < count:
                rect.width += self._tool_packing

            if rect.Contains((x,y)):
            
                # if the item doesn't fit on the toolbar, return None
                if not self.GetToolFitsByIndex(i):
                    return None

                return item

        return None


    def FindToolByIndex(self, pos):
        """
        Finds a tool for the given tool position in the L{AuiToolBar}.

        :param `pos`: the tool position in the toolbar.

        :returns: a pointer to a L{AuiToolBarItem} if a tool is found, or ``None`` otherwise.        
        """
        
        if pos < 0 or pos >= len(self._items):
            return None

        return self._items[pos]


    def SetToolBitmapSize(self, size):
        """
        Sets the default size of each tool bitmap. The default bitmap size is
        16 by 15 pixels.

        :param `size`: the size of the bitmaps in the toolbar.

        :note: This should be called to tell the toolbar what the tool bitmap
         size is. Call it before you add tools.

        :note: Note that this is the size of the bitmap you pass to L{AddTool},
         and not the eventual size of the tool button.

        :todo: Add `wx.ToolBar` compatibility, actually implementing this method.
        """

        # TODO: wx.ToolBar compatibility
        pass


    def GetToolBitmapSize(self):
        """
        Returns the size of bitmap that the toolbar expects to have. The default
        bitmap size is 16 by 15 pixels.

        :note: Note that this is the size of the bitmap you pass to L{AddTool},
         and not the eventual size of the tool button.

        :todo: Add `wx.ToolBar` compatibility, actually implementing this method.
        """
        
        # TODO: wx.ToolBar compatibility
        return wx.Size(16, 15)


    def SetToolProportion(self, tool_id, proportion):
        """
        Sets the tool proportion in the toolbar.

        :param `tool_id`: the L{AuiToolBarItem} identifier;
        :param `proportion`: the tool proportion in the toolbar.
        """

        item = self.FindTool(tool_id)
        if not item:
            return

        item.proportion = proportion


    def GetToolProportion(self, tool_id):
        """
        Returns the tool proportion in the toolbar.

        :param `tool_id`: the L{AuiToolBarItem} identifier.
        """

        item = self.FindTool(tool_id)
        if not item:
            return

        return item.proportion


    def SetToolSeparation(self, separation):
        """
        Sets the separator size for the toolbar.

        :param `separation`: the separator size in pixels.
        """

        if self._art:
            self._art.SetElementSize(AUI_TBART_SEPARATOR_SIZE, separation)


    def GetToolSeparation(self):
        """ Returns the separator size for the toolbar, in pixels. """
        
        if self._art:
            return self._art.GetElementSize(AUI_TBART_SEPARATOR_SIZE)

        return 5


    def SetToolDropDown(self, tool_id, dropdown):
        """
        Assigns a drop down window menu to the toolbar item.

        :param `tool_id`: the L{AuiToolBarItem} identifier;
        :param `dropdown`: whether to assign a drop down menu or not.
        """

        item = self.FindTool(tool_id)
        if not item:
            return

        item.dropdown = dropdown


    def GetToolDropDown(self, tool_id):
        """
        Returns whether the toolbar item identified by `tool_id` has an associated
        drop down window menu or not.

        :param `tool_id`: the L{AuiToolBarItem} identifier.
        """

        item = self.FindTool(tool_id)
        if not item:
            return

        return item.dropdown


    def SetToolSticky(self, tool_id, sticky):
        """
        Sets the toolbar item as sticky or non-sticky.

        :param `tool_id`: the L{AuiToolBarItem} identifier;
        :param `sticky`: whether the tool should be sticky or not.
        """

        # ignore separators
        if tool_id == -1:
            return

        item = self.FindTool(tool_id)
        if not item:
            return

        if item.sticky == sticky:
            return

        item.sticky = sticky

        self.Refresh(False)
        self.Update()


    def GetToolSticky(self, tool_id):
        """
        Returns whether the toolbar item identified by `tool_id` has a sticky
        behaviour or not.

        :param `tool_id`: the L{AuiToolBarItem} identifier.
        """

        item = self.FindTool(tool_id)
        if not item:
            return

        return item.sticky


    def SetToolBorderPadding(self, padding):
        """
        Sets the padding between the tool border and the label.

        :param `padding`: the padding in pixels.
        """

        self._tool_border_padding = padding


    def GetToolBorderPadding(self):
        """ Returns the padding between the tool border and the label, in pixels. """

        return self._tool_border_padding


    def SetToolTextOrientation(self, orientation):
        """
        Sets the label orientation for the toolbar items.

        :param `orientation`: the L{AuiToolBarItem} label orientation.
        """

        self._tool_text_orientation = orientation

        if self._art:
            self._art.SetTextOrientation(orientation)
    

    def GetToolTextOrientation(self):
        """ Returns the label orientation for the toolbar items. """

        return self._tool_text_orientation


    def SetToolOrientation(self, orientation):
        """
        Sets the tool orientation for the toolbar items.

        :param `orientation`: the L{AuiToolBarItem} orientation.
        """

        self._tool_orientation = orientation
        if self._art:
            self._art.SetOrientation(orientation)


    def GetToolOrientation(self):
        """ Returns the orientation for the toolbar items. """

        return self._tool_orientation        


    def SetToolPacking(self, packing):
        """
        Sets the value used for spacing tools. The default value is 1 pixel.

        :param `packing`: the value for packing.
        """

        self._tool_packing = packing


    def GetToolPacking(self):
        """ Returns the value used for spacing tools. The default value is 1 pixel. """

        return self._tool_packing


    def SetOrientation(self, orientation):
        """
        Sets the toolbar orientation.

        :param `orientation`: either ``wx.VERTICAL`` or ``wx.HORIZONTAL``.

        :note: This can be temporarily overridden by L{AuiManager} when floating and
         docking a L{AuiToolBar}.
        """

        pass
    

    def SetMargins(self, left=-1, right=-1, top=-1, bottom=-1):
        """
        Set the values to be used as margins for the toolbar.

        :param `left`: the left toolbar margin;
        :param `right`: the right toolbar margin;
        :param `top`: the top toolbar margin;
        :param `bottom`: the bottom toolbar margin.
        """

        if left != -1:
            self._left_padding = left
        if right != -1:
            self._right_padding = right
        if top != -1:
            self._top_padding = top
        if bottom != -1:
            self._bottom_padding = bottom


    def SetMarginsSize(self, size):
        """
        Set the values to be used as margins for the toolbar.

        :param `size`: the margin size (an instance of `wx.Size`).
        """
        
        self.SetMargins(size.x, size.x, size.y, size.y)


    def SetMarginsXY(self, x, y):
        """
        Set the values to be used as margins for the toolbar.
        
        :param `x`: left margin, right margin and inter-tool separation value;
        :param `y`: top margin, bottom margin and inter-tool separation value.
        """
        
        self.SetMargins(x, x, y, y)        

            
    def GetGripperVisible(self):
        """ Returns whether the toolbar gripper is visible or not. """

        return self._gripper_visible


    def SetGripperVisible(self, visible):
        """
        Sets whether the toolbar gripper is visible or not.

        :param `visible`: ``True`` for a visible gripper, ``False`` otherwise.
        """

        self._gripper_visible = visible
        if visible:
            self._agwStyle |= AUI_TB_GRIPPER
        else:
            self._agwStyle &= ~AUI_TB_GRIPPER
            
        self.Realize()
        self.Refresh(False)


    def GetOverflowVisible(self):
        """ Returns whether the overflow button is visible or not. """

        return self._overflow_visible


    def SetOverflowVisible(self, visible):
        """
        Sets whether the overflow button is visible or not.

        :param `visible`: ``True`` for a visible overflow button, ``False`` otherwise.
        """

        self._overflow_visible = visible
        if visible:
            self._agwStyle |= AUI_TB_OVERFLOW
        else:
            self._agwStyle &= ~AUI_TB_OVERFLOW

        self.Refresh(False)


    def SetFont(self, font):
        """
        Sets the L{AuiToolBar} font.

        :param `font`: a `wx.Font` object.

        :note: Overridden from `wx.PyControl`.
        """        

        res = wx.PyControl.SetFont(self, font)

        if self._art:
            self._art.SetFont(font)
    
        return res


    def SetHoverItem(self, pitem):
        """
        Sets a toolbar item to be currently hovered by the mouse.

        :param `pitem`: an instance of L{AuiToolBarItem}.
        """

        former_hover = None

        for item in self._items:
        
            if item.state & AUI_BUTTON_STATE_HOVER:
                former_hover = item
                
            item.state &= ~AUI_BUTTON_STATE_HOVER

        if pitem:
            pitem.state |= AUI_BUTTON_STATE_HOVER
        
        if former_hover != pitem:
            self.Refresh(False)
            self.Update()
        

    def SetPressedItem(self, pitem):
        """
        Sets a toolbar item to be currently in a "pressed" state.

        :param `pitem`: an instance of L{AuiToolBarItem}.
        """

        former_item = None

        for item in self._items:
        
            if item.state & AUI_BUTTON_STATE_PRESSED:
                former_item = item
                
            item.state &= ~AUI_BUTTON_STATE_PRESSED
        
        if pitem:
            pitem.state &= ~AUI_BUTTON_STATE_HOVER
            pitem.state |= AUI_BUTTON_STATE_PRESSED
        
        if former_item != pitem:
            self.Refresh(False)
            self.Update()
    

    def RefreshOverflowState(self):
        """ Refreshes the overflow button. """

        if not self._overflow_sizer_item:
            self._overflow_state = 0
            return
        
        overflow_state = 0
        overflow_rect = self.GetOverflowRect()

        # find out the mouse's current position
        pt = wx.GetMousePosition()
        pt = self.ScreenToClient(pt)

        # find out if the mouse cursor is inside the dropdown rectangle
        if overflow_rect.Contains((pt.x, pt.y)):

            if _VERSION_STRING < "2.9":
                leftDown = wx.GetMouseState().LeftDown()
            else:
                leftDown = wx.GetMouseState().LeftIsDown()
        
            if leftDown:
                overflow_state = AUI_BUTTON_STATE_PRESSED
            else:
                overflow_state = AUI_BUTTON_STATE_HOVER
        
        if overflow_state != self._overflow_state:
            self._overflow_state = overflow_state
            self.Refresh(False)
            self.Update()
        
        self._overflow_state = overflow_state


    def ToggleTool(self, tool_id, state):
        """
        Toggles a tool on or off. This does not cause any event to get emitted.

        :param `tool_id`: tool in question.
        :param `state`: if ``True``, toggles the tool on, otherwise toggles it off.

        :note: This only applies to a tool that has been specified as a toggle tool.
        """
        
        tool = self.FindTool(tool_id)

        if tool:
            if tool.kind not in [ITEM_CHECK, ITEM_RADIO]:
                return

            if tool.kind == ITEM_RADIO:
                idx = self.GetToolIndex(tool_id)
                if idx >= 0 and idx < len(self._items):
                    for i in xrange(idx, len(self._items)):
                        tool = self.FindToolByIndex(i)
                        if tool.kind != ITEM_RADIO:
                            break
                        tool.state &= ~AUI_BUTTON_STATE_CHECKED

                    for i in xrange(idx, -1, -1):
                        tool = self.FindToolByIndex(i)
                        if tool.kind != ITEM_RADIO:
                            break
                        tool.state &= ~AUI_BUTTON_STATE_CHECKED 

                    tool = self.FindTool(tool_id)
                    tool.state |= AUI_BUTTON_STATE_CHECKED
            else:
                if state == True:
                    tool.state |= AUI_BUTTON_STATE_CHECKED
                else:
                    tool.state &= ~AUI_BUTTON_STATE_CHECKED 


    def GetToolToggled(self, tool_id):
        """
        Returns whether a tool is toggled or not.

        :param `tool_id`: the toolbar item identifier.

        :note: This only applies to a tool that has been specified as a toggle tool.
        """        

        tool = self.FindTool(tool_id)

        if tool:
            if tool.kind not in [ITEM_CHECK, ITEM_RADIO]:
                return False

            return (tool.state & AUI_BUTTON_STATE_CHECKED and [True] or [False])[0]
        
        return False


    def EnableTool(self, tool_id, state):
        """
        Enables or disables the tool.

        :param `tool_id`: identifier for the tool to enable or disable.
        :param `state`: if ``True``, enables the tool, otherwise disables it.
        """

        tool = self.FindTool(tool_id)

        if tool:
        
            if state == True:
                tool.state &= ~AUI_BUTTON_STATE_DISABLED
            else:
                tool.state |= AUI_BUTTON_STATE_DISABLED
        

    def GetToolEnabled(self, tool_id):
        """
        Returns whether the tool identified by `tool_id` is enabled or not.

        :param `tool_id`: the tool identifier.
        """

        tool = self.FindTool(tool_id)

        if tool:
            return (tool.state & AUI_BUTTON_STATE_DISABLED and [False] or [True])[0]

        return False


    def GetToolLabel(self, tool_id):
        """
        Returns the tool label for the tool identified by `tool_id`.

        :param `tool_id`: the tool identifier.
        """

        tool = self.FindTool(tool_id)
        if not tool:
            return ""
        
        return tool.label


    def SetToolLabel(self, tool_id, label):
        """
        Sets the tool label for the tool identified by `tool_id`.

        :param `tool_id`: the tool identifier;
        :param `label`: the new toolbar item label.
        """
        
        tool = self.FindTool(tool_id)
        if tool:    
            tool.label = label
    

    def GetToolBitmap(self, tool_id):
        """
        Returns the tool bitmap for the tool identified by `tool_id`.

        :param `tool_id`: the tool identifier.
        """
        
        tool = self.FindTool(tool_id)
        if not tool:
            return wx.NullBitmap

        return tool.bitmap


    def SetToolBitmap(self, tool_id, bitmap):
        """
        Sets the tool bitmap for the tool identified by `tool_id`.

        :param `tool_id`: the tool identifier;
        :param `bitmap`: the new bitmap for the toolbar item (an instance of `wx.Bitmap`).
        """
        
        tool = self.FindTool(tool_id)
        if tool:
            tool.bitmap = bitmap


    def SetToolNormalBitmap(self, tool_id, bitmap):
        """
        Sets the tool bitmap for the tool identified by `tool_id`.

        :param `tool_id`: the tool identifier;
        :param `bitmap`: the new bitmap for the toolbar item (an instance of `wx.Bitmap`).
        """
        
        self.SetToolBitmap(tool_id, bitmap)


    def SetToolDisabledBitmap(self, tool_id, bitmap):
        """
        Sets the tool disabled bitmap for the tool identified by `tool_id`.

        :param `tool_id`: the tool identifier;
        :param `bitmap`: the new disabled bitmap for the toolbar item (an instance of `wx.Bitmap`).
        """
        
        tool = self.FindTool(tool_id)
        if tool:
            tool.disabled_bitmap = bitmap


    def GetToolShortHelp(self, tool_id):
        """
        Returns the short help for the given tool.

        :param `tool_id`: the tool identifier.
        """

        tool = self.FindTool(tool_id)
        if not tool:
            return ""

        return tool.short_help


    def SetToolShortHelp(self, tool_id, help_string):
        """
        Sets the short help for the given tool.

        :param `tool_id`: the tool identifier;
        :param `help_string`: the string for the short help.
        """
        
        tool = self.FindTool(tool_id)
        if tool:
            tool.short_help = help_string


    def GetToolLongHelp(self, tool_id):
        """
        Returns the long help for the given tool.

        :param `tool_id`: the tool identifier.
        """

        tool = self.FindTool(tool_id)
        if not tool:
            return ""

        return tool.long_help


    def SetToolAlignment(self, alignment=wx.EXPAND):
        """
        This sets the alignment for all of the tools within the
        toolbar (only has an effect when the toolbar is expanded).

        :param `alignment`: `wx.Sizer` alignment value
         (``wx.ALIGN_CENTER_HORIZONTAL`` or ``wx.ALIGN_CENTER_VERTICAL``).
        """

        self._tool_alignment = alignment



    def SetToolLongHelp(self, tool_id, help_string):
        """
        Sets the long help for the given tool.

        :param `tool_id`: the tool identifier;
        :param `help_string`: the string for the long help.
        """
        
        tool = self.FindTool(tool_id)
        if tool:
            tool.long_help = help_string
    

    def SetCustomOverflowItems(self, prepend, append):
        """
        Sets the two lists `prepend` and `append` as custom overflow items.

        :param `prepend`: a list of L{AuiToolBarItem} to be prepended;
        :param `append`: a list of L{AuiToolBarItem} to be appended.
        """

        self._custom_overflow_prepend = prepend
        self._custom_overflow_append = append


    def GetToolCount(self):
        """ Returns the number of tools in the L{AuiToolBar}. """

        return len(self._items)


    def GetToolIndex(self, tool_id):
        """
        Returns the position of the tool in the toolbar given its identifier.

        :param `tool_id`: the toolbar item identifier.
        """

        # this will prevent us from returning the index of the
        # first separator in the toolbar since its id is equal to -1
        if tool_id == -1:
            return wx.NOT_FOUND

        for i, item in enumerate(self._items):
            if item.id == tool_id:
                return i
        
        return wx.NOT_FOUND


    def GetToolPos(self, tool_id):
        """
        Returns the position of the tool in the toolbar given its identifier.

        :param `tool_id`: the toolbar item identifier.
        """
        
        return self.GetToolIndex(tool_id)
                                

    def GetToolFitsByIndex(self, tool_id):
        """
        Returns whether the tool identified by `tool_id` fits into the toolbar or not.

        :param `tool_id`: the toolbar item identifier.
        """
        
        if tool_id < 0 or tool_id >= len(self._items):
            return False

        if not self._items[tool_id].sizer_item:
            return False

        cli_w, cli_h = self.GetClientSize()
        rect = self._items[tool_id].sizer_item.GetRect()

        if self._agwStyle & AUI_TB_VERTICAL:
            # take the dropdown size into account
            if self._overflow_visible:
                cli_h -= self._overflow_sizer_item.GetSize().y

            if rect.y+rect.height < cli_h:
                return True
        
        else:
        
            # take the dropdown size into account
            if self._overflow_visible:
                cli_w -= self._overflow_sizer_item.GetSize().x

            if rect.x+rect.width < cli_w:
                return True
        
        return False


    def GetToolFits(self, tool_id):
        """
        Returns whether the tool identified by `tool_id` fits into the toolbar or not.

        :param `tool_id`: the toolbar item identifier.
        """
        
        return self.GetToolFitsByIndex(self.GetToolIndex(tool_id))


    def GetToolRect(self, tool_id):
        """
        Returns the toolbar item rectangle

        :param `tool_id`: the toolbar item identifier.
        """

        tool = self.FindTool(tool_id)
        if tool and tool.sizer_item:
            return tool.sizer_item.GetRect()

        return wx.Rect()


    def GetToolBarFits(self):
        """ Returns whether the L{AuiToolBar} size fits in a specified size. """

        if len(self._items) == 0:
            # empty toolbar always 'fits'
            return True
        
        # entire toolbar content fits if the last tool fits
        return self.GetToolFitsByIndex(len(self._items) - 1)


    def Realize(self):
        """ Realizes the toolbar. This function should be called after you have added tools. """

        dc = wx.ClientDC(self)
        
        if not dc.IsOk():
            return False

        horizontal = True
        if self._agwStyle & AUI_TB_VERTICAL:
            horizontal = False

        # create the new sizer to add toolbar elements to
        sizer = wx.BoxSizer((horizontal and [wx.HORIZONTAL] or [wx.VERTICAL])[0])

        # add gripper area
        separator_size = self._art.GetElementSize(AUI_TBART_SEPARATOR_SIZE)
        gripper_size = self._art.GetElementSize(AUI_TBART_GRIPPER_SIZE)
        
        if gripper_size > 0 and self._gripper_visible:        
            if horizontal:
                self._gripper_sizer_item = sizer.Add((gripper_size, 1), 0, wx.EXPAND)
            else:
                self._gripper_sizer_item = sizer.Add((1, gripper_size), 0, wx.EXPAND)
        else:
            self._gripper_sizer_item = None
        
        # add "left" padding
        if self._left_padding > 0:
            if horizontal:
                sizer.Add((self._left_padding, 1))
            else:
                sizer.Add((1, self._left_padding))
        
        count = len(self._items)
        for i, item in enumerate(self._items):
        
            sizer_item = None
            kind = item.kind

            if kind == ITEM_LABEL:
                
                size = self._art.GetLabelSize(dc, self, item)
                sizer_item = sizer.Add((size.x + (self._tool_border_padding*2),
                                        size.y + (self._tool_border_padding*2)),
                                       item.proportion,
                                       item.alignment)
                if i+1 < count:
                    sizer.AddSpacer(self._tool_packing)
                

            elif kind in [ITEM_CHECK, ITEM_NORMAL, ITEM_RADIO]:
                
                size = self._art.GetToolSize(dc, self, item)
                sizer_item = sizer.Add((size.x + (self._tool_border_padding*2),
                                        size.y + (self._tool_border_padding*2)),
                                       0,
                                       item.alignment)
                # add tool packing
                if i+1 < count:
                    sizer.AddSpacer(self._tool_packing)

            elif kind == ITEM_SEPARATOR:
                
                if horizontal:
                    sizer_item = sizer.Add((separator_size, 1), 0, wx.EXPAND)
                else:
                    sizer_item = sizer.Add((1, separator_size), 0, wx.EXPAND)

                # add tool packing
                if i+1 < count:
                    sizer.AddSpacer(self._tool_packing)

            elif kind == ITEM_SPACER:
                
                if item.proportion > 0:
                    sizer_item = sizer.AddStretchSpacer(item.proportion)
                else:
                    sizer_item = sizer.Add((item.spacer_pixels, 1))
                    
            elif kind == ITEM_CONTROL:
                
                vert_sizer = wx.BoxSizer(wx.VERTICAL)
                vert_sizer.AddStretchSpacer(1)
                ctrl_sizer_item = vert_sizer.Add(item.window, 0, wx.EXPAND)
                vert_sizer.AddStretchSpacer(1)
                
                if self._agwStyle & AUI_TB_TEXT and \
                    self._tool_text_orientation == AUI_TBTOOL_TEXT_BOTTOM and \
                    item.GetLabel() != "":
                
                    s = self.GetLabelSize(item.GetLabel())
                    vert_sizer.Add((1, s.y))

                sizer_item = sizer.Add(vert_sizer, item.proportion, wx.EXPAND)
                min_size = item.min_size

                # proportional items will disappear from the toolbar if
                # their min width is not set to something really small
                if item.proportion != 0:
                    min_size.x = 1
                
                if min_size.IsFullySpecified():
                    sizer.SetItemMinSize(vert_sizer, min_size)
                    vert_sizer.SetItemMinSize(item.window, min_size)
                
                # add tool packing
                if i+1 < count:
                    sizer.AddSpacer(self._tool_packing)
                
            item.sizer_item = sizer_item
        

        # add "right" padding
        if self._right_padding > 0:
            if horizontal:
                sizer.Add((self._right_padding, 1))
            else:
                sizer.Add((1, self._right_padding))
        
        # add drop down area
        self._overflow_sizer_item = None

        if self._agwStyle & AUI_TB_OVERFLOW:
        
            overflow_size = self._art.GetElementSize(AUI_TBART_OVERFLOW_SIZE)
            if overflow_size > 0 and self._overflow_visible:
            
                if horizontal:
                    self._overflow_sizer_item = sizer.Add((overflow_size, 1), 0, wx.EXPAND)
                else:
                    self._overflow_sizer_item = sizer.Add((1, overflow_size), 0, wx.EXPAND)
            
            else:
            
                self._overflow_sizer_item = None
            
        # the outside sizer helps us apply the "top" and "bottom" padding
        outside_sizer = wx.BoxSizer((horizontal and [wx.VERTICAL] or [wx.HORIZONTAL])[0])

        # add "top" padding
        if self._top_padding > 0:
        
            if horizontal:
                outside_sizer.Add((1, self._top_padding))
            else:
                outside_sizer.Add((self._top_padding, 1))
        
        # add the sizer that contains all of the toolbar elements
        outside_sizer.Add(sizer, 1, self._tool_alignment)

        # add "bottom" padding
        if self._bottom_padding > 0:
        
            if horizontal:
                outside_sizer.Add((1, self._bottom_padding))
            else:
                outside_sizer.Add((self._bottom_padding, 1))

        del self._sizer # remove old sizer
        self._sizer = outside_sizer
        self.SetSizer(outside_sizer)

        # calculate the rock-bottom minimum size
        for item in self._items:
        
            if item.sizer_item and item.proportion > 0 and item.min_size.IsFullySpecified():
                item.sizer_item.SetMinSize((0, 0))
        
        self._absolute_min_size = self._sizer.GetMinSize()

        # reset the min sizes to what they were
        for item in self._items:
        
            if item.sizer_item and item.proportion > 0 and item.min_size.IsFullySpecified():
                item.sizer_item.SetMinSize(item.min_size)
        
        # set control size
        size = self._sizer.GetMinSize()
        self.SetMinSize(size)
        self._minWidth = size.x
        self._minHeight = size.y

        if self._agwStyle & AUI_TB_NO_AUTORESIZE == 0:
        
            cur_size = self.GetClientSize()
            new_size = self.GetMinSize()

            if new_size != cur_size:
            
                self.SetClientSize(new_size)
            
            else:
            
                self._sizer.SetDimension(0, 0, cur_size.x, cur_size.y)
            
        else:
        
            cur_size = self.GetClientSize()
            self._sizer.SetDimension(0, 0, cur_size.x, cur_size.y)
                    
        self.Refresh(False)
        return True


    def GetOverflowState(self):
        """ Returns the state of the overflow button. """

        return self._overflow_state


    def GetOverflowRect(self):
        """ Returns the rectangle of the overflow button. """

        cli_rect = wx.RectPS(wx.Point(0, 0), self.GetClientSize())
        overflow_rect = wx.Rect(*self._overflow_sizer_item.GetRect())
        overflow_size = self._art.GetElementSize(AUI_TBART_OVERFLOW_SIZE)

        if self._agwStyle & AUI_TB_VERTICAL:
        
            overflow_rect.y = cli_rect.height - overflow_size
            overflow_rect.x = 0
            overflow_rect.width = cli_rect.width
            overflow_rect.height = overflow_size
        
        else:
        
            overflow_rect.x = cli_rect.width - overflow_size
            overflow_rect.y = 0
            overflow_rect.width = overflow_size
            overflow_rect.height = cli_rect.height
        
        return overflow_rect


    def GetLabelSize(self, label):
        """
        Returns the standard size of a toolbar item.

        :param `label`: a test label.
        """

        dc = wx.ClientDC(self)
        dc.SetFont(self._font)

        return GetLabelSize(dc, label, self._tool_orientation != AUI_TBTOOL_HORIZONTAL)


    def GetAuiManager(self):
        """ Returns the L{AuiManager} which manages the toolbar. """

        try:
            return self._auiManager
        except AttributeError:
            return False


    def SetAuiManager(self, auiManager):
        """ Sets the L{AuiManager} which manages the toolbar. """
        
        self._auiManager = auiManager        

        
    def DoIdleUpdate(self):
        """ Updates the toolbar during idle times. """

        handler = self.GetEventHandler()
        if not handler:
            return
        
        need_refresh = False

        for item in self._items:
                
            if item.id == -1:
                continue

            evt = wx.UpdateUIEvent(item.id)
            evt.SetEventObject(self)

            if handler.ProcessEvent(evt):
            
                if evt.GetSetEnabled():
                
                    if item.window:
                        is_enabled = item.window.IsEnabled()
                    else:
                        is_enabled = (item.state & AUI_BUTTON_STATE_DISABLED and [False] or [True])[0]

                    new_enabled = evt.GetEnabled()
                    if new_enabled != is_enabled:
                    
                        if item.window:
                            item.window.Enable(new_enabled)
                        else:
                            if new_enabled:
                                item.state &= ~AUI_BUTTON_STATE_DISABLED
                            else:
                                item.state |= AUI_BUTTON_STATE_DISABLED
                        
                        need_refresh = True
                    
                if evt.GetSetChecked():
                
                    # make sure we aren't checking an item that can't be
                    if item.kind != ITEM_CHECK and item.kind != ITEM_RADIO:
                        continue

                    is_checked = (item.state & AUI_BUTTON_STATE_CHECKED and [True] or [False])[0]
                    new_checked = evt.GetChecked()

                    if new_checked != is_checked:
                    
                        if new_checked:
                            item.state |= AUI_BUTTON_STATE_CHECKED
                        else:
                            item.state &= ~AUI_BUTTON_STATE_CHECKED

                        need_refresh = True
                    
        if need_refresh:
            self.Refresh(False)

        
    def OnSize(self, event):
        """
        Handles the ``wx.EVT_SIZE`` event for L{AuiToolBar}.

        :param `event`: a `wx.SizeEvent` event to be processed.        
        """
        
        x, y = self.GetClientSize()
        realize = False

        if x > y:
            self.SetOrientation(wx.HORIZONTAL)
        else:
            self.SetOrientation(wx.VERTICAL)

        if (x >= y and self._absolute_min_size.x > x) or (y > x and self._absolute_min_size.y > y):
        
            # hide all flexible items
            for item in self._items:
                if item.sizer_item and item.proportion > 0 and item.sizer_item.IsShown():
                    item.sizer_item.Show(False)
                    item.sizer_item.SetProportion(0)

            if self._originalStyle & AUI_TB_OVERFLOW:
                if not self.GetOverflowVisible():
                    self.SetOverflowVisible(True)
                    realize = True
                       
        else:

            if self._originalStyle & AUI_TB_OVERFLOW and not self._custom_overflow_append and \
               not self._custom_overflow_prepend:
                if self.GetOverflowVisible():
                    self.SetOverflowVisible(False)
                    realize = True

            # show all flexible items
            for item in self._items:
                if item.sizer_item and item.proportion > 0 and not item.sizer_item.IsShown():
                    item.sizer_item.Show(True)
                    item.sizer_item.SetProportion(item.proportion)
                
        self._sizer.SetDimension(0, 0, x, y)

        if realize:
            self.Realize()
        else:
            self.Refresh(False)
            
        self.Update()

        
    def DoSetSize(self, x, y, width, height, sizeFlags=wx.SIZE_AUTO):
        """        
        Sets the position and size of the window in pixels. The `sizeFlags`
        parameter indicates the interpretation of the other params if they are
        equal to -1.

        :param `x`: the window `x` position;
        :param `y`: the window `y` position;
        :param `width`: the window width;
        :param `height`: the window height;
        :param `sizeFlags`: may have one of this bit set:
   
         ===================================  ======================================
         Size Flags                           Description
         ===================================  ======================================
         ``wx.SIZE_AUTO``                     A -1 indicates that a class-specific default should be used.
         ``wx.SIZE_AUTO_WIDTH``               A -1 indicates that a class-specific default should be used for the width.
         ``wx.SIZE_AUTO_HEIGHT``              A -1 indicates that a class-specific default should be used for the height.
         ``wx.SIZE_USE_EXISTING``             Existing dimensions should be used if -1 values are supplied.
         ``wx.SIZE_ALLOW_MINUS_ONE``          Allow dimensions of -1 and less to be interpreted as real dimensions, not default values.
         ``wx.SIZE_FORCE``                    Normally, if the position and the size of the window are already the same as the parameters of this function, nothing is done. but with this flag a window resize may be forced even in this case (supported in wx 2.6.2 and later and only implemented for MSW and ignored elsewhere currently) 
         ===================================  ======================================

        :note: Overridden from `wx.PyControl`.
        """
        
        parent_size = self.GetParent().GetClientSize()
        if x + width > parent_size.x:
            width = max(0, parent_size.x - x)
        if y + height > parent_size.y:
            height = max(0, parent_size.y - y)

        wx.PyControl.DoSetSize(self, x, y, width, height, sizeFlags)


    def OnIdle(self, event):
        """
        Handles the ``wx.EVT_IDLE`` event for L{AuiToolBar}.

        :param `event`: a `wx.IdleEvent` event to be processed.        
        """
        
        self.DoIdleUpdate()
        event.Skip()


    def DoGetBestSize(self):
        """
        Gets the size which best suits the window: for a control, it would be the
        minimal size which doesn't truncate the control, for a panel - the same
        size as it would have after a call to `Fit()`.
        
        :note: Overridden from `wx.PyControl`.
        """

        return self._absolute_min_size
    

    def OnPaint(self, event):
        """
        Handles the ``wx.EVT_PAINT`` event for L{AuiToolBar}.

        :param `event`: a `wx.PaintEvent` event to be processed.        
        """

        dc = wx.AutoBufferedPaintDC(self)
        cli_rect = wx.RectPS(wx.Point(0, 0), self.GetClientSize())

        horizontal = True
        if self._agwStyle & AUI_TB_VERTICAL:
            horizontal = False

        if self._agwStyle & AUI_TB_PLAIN_BACKGROUND:
            self._art.DrawPlainBackground(dc, self, cli_rect)
        else:
            self._art.DrawBackground(dc, self, cli_rect, horizontal)

        gripper_size = self._art.GetElementSize(AUI_TBART_GRIPPER_SIZE)
        dropdown_size = self._art.GetElementSize(AUI_TBART_OVERFLOW_SIZE)

        # paint the gripper
        if gripper_size > 0 and self._gripper_sizer_item:
            gripper_rect = wx.Rect(*self._gripper_sizer_item.GetRect())
            if horizontal:
                gripper_rect.width = gripper_size
            else:
                gripper_rect.height = gripper_size
                
            self._art.DrawGripper(dc, self, gripper_rect)
        
        # calculated how far we can draw items
        if horizontal:
            last_extent = cli_rect.width
        else:
            last_extent = cli_rect.height
            
        if self._overflow_visible:
            last_extent -= dropdown_size

        # paint each individual tool
        for item in self._items:

            if not item.sizer_item:
                continue

            item_rect = wx.Rect(*item.sizer_item.GetRect())

            if (horizontal and item_rect.x + item_rect.width >= last_extent) or \
               (not horizontal and item_rect.y + item_rect.height >= last_extent):

                break
            
            if item.kind == ITEM_SEPARATOR:
                # draw a separator
                self._art.DrawSeparator(dc, self, item_rect)
            
            elif item.kind == ITEM_LABEL:
                # draw a text label only
                self._art.DrawLabel(dc, self, item, item_rect)
            
            elif item.kind == ITEM_NORMAL:
                # draw a regular button or dropdown button
                if not item.dropdown:
                    self._art.DrawButton(dc, self, item, item_rect)
                else:
                    self._art.DrawDropDownButton(dc, self, item, item_rect)
            
            elif item.kind == ITEM_CHECK:
                # draw a regular toggle button or a dropdown one
                if not item.dropdown:
                    self._art.DrawButton(dc, self, item, item_rect)
                else:
                    self._art.DrawDropDownButton(dc, self, item, item_rect)

            elif item.kind == ITEM_RADIO:
                # draw a toggle button
                self._art.DrawButton(dc, self, item, item_rect)
            
            elif item.kind == ITEM_CONTROL:
                # draw the control's label
                self._art.DrawControlLabel(dc, self, item, item_rect)
            
            # fire a signal to see if the item wants to be custom-rendered
            self.OnCustomRender(dc, item, item_rect)
        
        # paint the overflow button
        if dropdown_size > 0 and self._overflow_sizer_item:
            dropdown_rect = self.GetOverflowRect()
            self._art.DrawOverflowButton(dc, self, dropdown_rect, self._overflow_state)

        
    def OnEraseBackground(self, event):
        """
        Handles the ``wx.EVT_ERASE_BACKGROUND`` event for L{AuiToolBar}.

        :param `event`: a `wx.EraseEvent` event to be processed.

        :note: This is intentionally empty, to reduce flicker.
        """

        pass
    

    def OnLeftDown(self, event):
        """
        Handles the ``wx.EVT_LEFT_DOWN`` event for L{AuiToolBar}.

        :param `event`: a `wx.MouseEvent` event to be processed.        
        """
        
        cli_rect = wx.RectPS(wx.Point(0, 0), self.GetClientSize())
        self.StopPreviewTimer()

        if self._gripper_sizer_item:
        
            gripper_rect = wx.Rect(*self._gripper_sizer_item.GetRect())
            if gripper_rect.Contains(event.GetPosition()):
            
                # find aui manager
                manager = self.GetAuiManager()
                if not manager:
                    return

                x_drag_offset = event.GetX() - gripper_rect.GetX()
                y_drag_offset = event.GetY() - gripper_rect.GetY()

                clientPt = wx.Point(*event.GetPosition())
                screenPt = self.ClientToScreen(clientPt)
                managedWindow = manager.GetManagedWindow()
                managerClientPt = managedWindow.ScreenToClient(screenPt)

                # gripper was clicked
                manager.OnGripperClicked(self, managerClientPt, wx.Point(x_drag_offset, y_drag_offset))            
                return

        if self._overflow_sizer_item:
            overflow_rect = self.GetOverflowRect()

            if self._art and self._overflow_visible and overflow_rect.Contains(event.GetPosition()):
            
                e = AuiToolBarEvent(wxEVT_COMMAND_AUITOOLBAR_OVERFLOW_CLICK, -1)
                e.SetEventObject(self)
                e.SetToolId(-1)
                e.SetClickPoint(event.GetPosition())
                processed = self.ProcessEvent(e)

                if processed:
                    self.DoIdleUpdate()
                else:                
                    overflow_items = []

                    # add custom overflow prepend items, if any
                    count = len(self._custom_overflow_prepend)
                    for i in xrange(count):
                        overflow_items.append(self._custom_overflow_prepend[i])

                    # only show items that don't fit in the dropdown
                    count = len(self._items)
                    for i in xrange(count):
                    
                        if not self.GetToolFitsByIndex(i):
                            overflow_items.append(self._items[i])
                    
                    # add custom overflow append items, if any
                    count = len(self._custom_overflow_append)
                    for i in xrange(count):
                        overflow_items.append(self._custom_overflow_append[i])

                    res = self._art.ShowDropDown(self, overflow_items)
                    self._overflow_state = 0
                    self.Refresh(False)
                    if res != -1:
                        e = wx.CommandEvent(wx.wxEVT_COMMAND_MENU_SELECTED, res)
                        e.SetEventObject(self)
                        if not self.GetParent().ProcessEvent(e):
                            tool = self.FindTool(res)
                            if tool:
                                state = (tool.state & AUI_BUTTON_STATE_CHECKED and [True] or [False])[0]
                                self.ToggleTool(res, not state)
                    
                return
            
        self._dragging = False
        self._action_pos = wx.Point(*event.GetPosition())
        self._action_item = self.FindToolForPosition(*event.GetPosition())

        if self._action_item:
        
            if self._action_item.state & AUI_BUTTON_STATE_DISABLED:
            
                self._action_pos = wx.Point(-1, -1)
                self._action_item = None
                return
            
            self.SetPressedItem(self._action_item)

            # fire the tool dropdown event
            e = AuiToolBarEvent(wxEVT_COMMAND_AUITOOLBAR_TOOL_DROPDOWN, self._action_item.id)
            e.SetEventObject(self)
            e.SetToolId(self._action_item.id)
            e.SetDropDownClicked(False)

            mouse_x, mouse_y = event.GetX(), event.GetY()
            rect = wx.Rect(*self._action_item.sizer_item.GetRect())

            if self._action_item.dropdown:
                if (self._action_item.orientation == AUI_TBTOOL_HORIZONTAL and \
                    mouse_x >= (rect.x+rect.width-BUTTON_DROPDOWN_WIDTH-1) and \
                    mouse_x < (rect.x+rect.width)) or \
                    (self._action_item.orientation != AUI_TBTOOL_HORIZONTAL and \
                     mouse_y >= (rect.y+rect.height-BUTTON_DROPDOWN_WIDTH-1) and \
                     mouse_y < (rect.y+rect.height)):
                    
                    e.SetDropDownClicked(True)            
            
            e.SetClickPoint(event.GetPosition())
            e.SetItemRect(rect)
            self.ProcessEvent(e)
            self.DoIdleUpdate()
        

    def OnLeftUp(self, event):
        """
        Handles the ``wx.EVT_LEFT_UP`` event for L{AuiToolBar}.

        :param `event`: a `wx.MouseEvent` event to be processed.        
        """
        
        self.SetPressedItem(None)

        hit_item = self.FindToolForPosition(*event.GetPosition())
        
        if hit_item and not hit_item.state & AUI_BUTTON_STATE_DISABLED:
            self.SetHoverItem(hit_item)

        if self._dragging:
            # reset drag and drop member variables
            self._dragging = False
            self._action_pos = wx.Point(-1, -1)
            self._action_item = None
        
        else:

            if self._action_item and hit_item == self._action_item:
                self.SetToolTipString("")

                if hit_item.kind in [ITEM_CHECK, ITEM_RADIO]:
                    toggle = not (self._action_item.state & AUI_BUTTON_STATE_CHECKED)
                    self.ToggleTool(self._action_item.id, toggle)

                    # repaint immediately
                    self.Refresh(False)
                    self.Update()
                    
                    e = wx.CommandEvent(wx.wxEVT_COMMAND_MENU_SELECTED, self._action_item.id)
                    e.SetEventObject(self)
                    e.SetInt(toggle)
                    self._action_pos = wx.Point(-1, -1)
                    self._action_item = None
                    
                    self.ProcessEvent(e)
                    self.DoIdleUpdate()
                    
                else:

                    if self._action_item.id == ID_RESTORE_FRAME:
                        # find aui manager
                        manager = self.GetAuiManager()

                        if not manager:
                            return

                        pane = manager.GetPane(self)
                        e = framemanager.AuiManagerEvent(framemanager.wxEVT_AUI_PANE_MIN_RESTORE)

                        e.SetManager(manager)
                        e.SetPane(pane)

                        manager.ProcessEvent(e)
                        self.DoIdleUpdate()

                    else:

                        e = wx.CommandEvent(wx.wxEVT_COMMAND_MENU_SELECTED, self._action_item.id)
                        e.SetEventObject(self)
                        self.ProcessEvent(e)
                        self.DoIdleUpdate()
                
        # reset drag and drop member variables
        self._dragging = False
        self._action_pos = wx.Point(-1, -1)
        self._action_item = None


    def OnRightDown(self, event):
        """
        Handles the ``wx.EVT_RIGHT_DOWN`` event for L{AuiToolBar}.

        :param `event`: a `wx.MouseEvent` event to be processed.        
        """
        
        cli_rect = wx.RectPS(wx.Point(0, 0), self.GetClientSize())

        if self._gripper_sizer_item:
            gripper_rect = self._gripper_sizer_item.GetRect()
            if gripper_rect.Contains(event.GetPosition()):
                return
        
        if self._overflow_sizer_item:
        
            dropdown_size = self._art.GetElementSize(AUI_TBART_OVERFLOW_SIZE)
            if dropdown_size > 0 and event.m_x > cli_rect.width - dropdown_size and \
               event.m_y >= 0 and event.m_y < cli_rect.height and self._art:
                return
            
        self._action_pos = wx.Point(*event.GetPosition())
        self._action_item = self.FindToolForPosition(*event.GetPosition())

        if self._action_item:
            if self._action_item.state & AUI_BUTTON_STATE_DISABLED:
            
                self._action_pos = wx.Point(-1, -1)
                self._action_item = None
                return


    def OnRightUp(self, event):
        """
        Handles the ``wx.EVT_RIGHT_UP`` event for L{AuiToolBar}.

        :param `event`: a `wx.MouseEvent` event to be processed.        
        """
        
        hit_item = self.FindToolForPosition(*event.GetPosition())

        if self._action_item and hit_item == self._action_item:
            
            e = AuiToolBarEvent(wxEVT_COMMAND_AUITOOLBAR_RIGHT_CLICK, self._action_item.id)
            e.SetEventObject(self)
            e.SetToolId(self._action_item.id)
            e.SetClickPoint(self._action_pos)
            self.ProcessEvent(e)
            self.DoIdleUpdate()
            
        else:
        
            # right-clicked on the invalid area of the toolbar
            e = AuiToolBarEvent(wxEVT_COMMAND_AUITOOLBAR_RIGHT_CLICK, -1)
            e.SetEventObject(self)
            e.SetToolId(-1)
            e.SetClickPoint(self._action_pos)
            self.ProcessEvent(e)
            self.DoIdleUpdate()
        
        # reset member variables
        self._action_pos = wx.Point(-1, -1)
        self._action_item = None


    def OnMiddleDown(self, event):
        """
        Handles the ``wx.EVT_MIDDLE_DOWN`` event for L{AuiToolBar}.

        :param `event`: a `wx.MouseEvent` event to be processed.        
        """
        
        cli_rect = wx.RectPS(wx.Point(0, 0), self.GetClientSize())

        if self._gripper_sizer_item:
        
            gripper_rect = self._gripper_sizer_item.GetRect()
            if gripper_rect.Contains(event.GetPosition()):
                return
        
        if self._overflow_sizer_item:
        
            dropdown_size = self._art.GetElementSize(AUI_TBART_OVERFLOW_SIZE)
            if dropdown_size > 0 and event.m_x > cli_rect.width - dropdown_size and \
               event.m_y >= 0 and event.m_y < cli_rect.height and self._art:            
                return
            
        self._action_pos = wx.Point(*event.GetPosition())
        self._action_item = self.FindToolForPosition(*event.GetPosition())

        if self._action_item:
            if self._action_item.state & AUI_BUTTON_STATE_DISABLED:
            
                self._action_pos = wx.Point(-1, -1)
                self._action_item = None
                return


    def OnMiddleUp(self, event):
        """
        Handles the ``wx.EVT_MIDDLE_UP`` event for L{AuiToolBar}.

        :param `event`: a `wx.MouseEvent` event to be processed.        
        """
        
        hit_item = self.FindToolForPosition(*event.GetPosition())

        if self._action_item and hit_item == self._action_item:        
            if hit_item.kind == ITEM_NORMAL:
            
                e = AuiToolBarEvent(wxEVT_COMMAND_AUITOOLBAR_MIDDLE_CLICK, self._action_item.id)
                e.SetEventObject(self)
                e.SetToolId(self._action_item.id)
                e.SetClickPoint(self._action_pos)
                self.ProcessEvent(e)
                self.DoIdleUpdate()
            
        # reset member variables
        self._action_pos = wx.Point(-1, -1)
        self._action_item = None


    def OnMotion(self, event):
        """
        Handles the ``wx.EVT_MOTION`` event for L{AuiToolBar}.

        :param `event`: a `wx.MouseEvent` event to be processed.        
        """
        
        # start a drag event
        if not self._dragging and self._action_item != None and self._action_pos != wx.Point(-1, -1) and \
           abs(event.m_x - self._action_pos.x) + abs(event.m_y - self._action_pos.y) > 5:
        
            self.SetToolTipString("")
            self._dragging = True

            e = AuiToolBarEvent(wxEVT_COMMAND_AUITOOLBAR_BEGIN_DRAG, self.GetId())
            e.SetEventObject(self)
            e.SetToolId(self._action_item.id)
            self.ProcessEvent(e)
            self.DoIdleUpdate()
            return
        
        hit_item = self.FindToolForPosition(*event.GetPosition())
        
        if hit_item:        
            if not hit_item.state & AUI_BUTTON_STATE_DISABLED:
                self.SetHoverItem(hit_item)
            else:
                self.SetHoverItem(None)
        
        else:        
            # no hit item, remove any hit item
            self.SetHoverItem(hit_item)
        
        # figure out tooltips
        packing_hit_item = self.FindToolForPositionWithPacking(*event.GetPosition())
        
        if packing_hit_item:
        
            if packing_hit_item != self._tip_item:
                self._tip_item = packing_hit_item

                if packing_hit_item.short_help != "":
                    self.StartPreviewTimer()
                    self.SetToolTipString(packing_hit_item.short_help)
                else:
                    self.SetToolTipString("")
                    self.StopPreviewTimer()
            
        else:
        
            self.SetToolTipString("")
            self._tip_item = None
            self.StopPreviewTimer()
        
        # if we've pressed down an item and we're hovering
        # over it, make sure it's state is set to pressed
        if self._action_item:
        
            if self._action_item == hit_item:
                self.SetPressedItem(self._action_item)
            else:
                self.SetPressedItem(None)
        
        # figure out the dropdown button state (are we hovering or pressing it?)
        self.RefreshOverflowState()


    def OnLeaveWindow(self, event):
        """
        Handles the ``wx.EVT_LEAVE_WINDOW`` event for L{AuiToolBar}.

        :param `event`: a `wx.MouseEvent` event to be processed.        
        """

        self.RefreshOverflowState()
        self.SetHoverItem(None)
        self.SetPressedItem(None)

        self._tip_item = None
        self.StopPreviewTimer()


    def OnSetCursor(self, event):
        """
        Handles the ``wx.EVT_SET_CURSOR`` event for L{AuiToolBar}.

        :param `event`: a `wx.SetCursorEvent` event to be processed.        
        """
        
        cursor = wx.NullCursor

        if self._gripper_sizer_item:
        
            gripper_rect = self._gripper_sizer_item.GetRect()
            if gripper_rect.Contains((event.GetX(), event.GetY())):
                cursor = wx.StockCursor(wx.CURSOR_SIZING)
            
        event.SetCursor(cursor)


    def OnCustomRender(self, dc, item, rect):
        """
        Handles custom render for single L{AuiToolBar} items.
        
        :param `dc`: a `wx.DC` device context;
        :param `item`: an instance of L{AuiToolBarItem};
        :param `rect`: the toolbar item rect.

        :note: This method must be overridden to provide custom rendering of items.
        """
        
        pass


    def IsPaneMinimized(self):
        """ Returns whether this L{AuiToolBar} contains a minimized pane tool. """
        
        manager = self.GetAuiManager()
        if not manager:
            return False
        
        if manager.GetAGWFlags() & AUI_MGR_PREVIEW_MINIMIZED_PANES == 0:
            # No previews here
            return False

        self_name = manager.GetPane(self).name
        
        if not self_name.endswith("_min"):
            # Wrong tool name
            return False

        return self_name[0:-4]
    
        
    def StartPreviewTimer(self):
        """ Starts a timer in L{AuiManager} to slide-in/slide-out the minimized pane. """

        self_name = self.IsPaneMinimized()
        if not self_name:
            return

        manager = self.GetAuiManager()        
        manager.StartPreviewTimer(self)


    def StopPreviewTimer(self):
        """ Stops a timer in L{AuiManager} to slide-in/slide-out the minimized pane. """

        self_name = self.IsPaneMinimized()
        if not self_name:
            return

        manager = self.GetAuiManager()        
        manager.StopPreviewTimer()
            

########NEW FILE########
__FILENAME__ = auibook
"""
auibook contains a notebook control which implements many features common in
applications with dockable panes. Specifically, L{AuiNotebook} implements functionality
which allows the user to rearrange tab order via drag-and-drop, split the tab window
into many different splitter configurations, and toggle through different themes to
customize the control's look and feel.

An effort has been made to try to maintain an API as similar to that of `wx.Notebook`.

The default theme that is used is L{AuiDefaultTabArt}, which provides a modern, glossy
look and feel. The theme can be changed by calling L{AuiNotebook.SetArtProvider}.
"""

__author__ = "Andrea Gavana <andrea.gavana@gmail.com>"
__date__ = "31 March 2009"


import wx
import types
import datetime

from wx.lib.expando import ExpandoTextCtrl

import framemanager
import tabart as TA

from aui_utilities import LightColour, MakeDisabledBitmap, TabDragImage
from aui_utilities import TakeScreenShot, RescaleScreenShot

from aui_constants import *

# AuiNotebook events
wxEVT_COMMAND_AUINOTEBOOK_PAGE_CLOSE = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_PAGE_CLOSED = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_PAGE_CHANGED = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_PAGE_CHANGING = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_BUTTON = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_BEGIN_DRAG = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_END_DRAG = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_DRAG_MOTION = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_ALLOW_DND = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_DRAG_DONE = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_TAB_MIDDLE_DOWN = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_TAB_MIDDLE_UP = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_TAB_RIGHT_DOWN = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_TAB_RIGHT_UP = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_TAB_DCLICK = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_BG_MIDDLE_DOWN = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_BG_MIDDLE_UP = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_BG_RIGHT_DOWN = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_BG_RIGHT_UP = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_BG_DCLICK = wx.NewEventType()

# Define a new event for a drag cancelled
wxEVT_COMMAND_AUINOTEBOOK_CANCEL_DRAG = wx.NewEventType()

# Define events for editing a tab label
wxEVT_COMMAND_AUINOTEBOOK_BEGIN_LABEL_EDIT = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_END_LABEL_EDIT = wx.NewEventType()

# Create event binders
EVT_AUINOTEBOOK_PAGE_CLOSE = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_PAGE_CLOSE, 1)
""" A tab in `AuiNotebook` is being closed. Can be vetoed by calling `Veto()`. """
EVT_AUINOTEBOOK_PAGE_CLOSED = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_PAGE_CLOSED, 1)
""" A tab in `AuiNotebook` has been closed. """
EVT_AUINOTEBOOK_PAGE_CHANGED = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_PAGE_CHANGED, 1)
""" The page selection was changed. """
EVT_AUINOTEBOOK_PAGE_CHANGING = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_PAGE_CHANGING, 1)
""" The page selection is being changed. """
EVT_AUINOTEBOOK_BUTTON = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_BUTTON, 1)
""" The user clicked on a button in the `AuiNotebook` tab area. """
EVT_AUINOTEBOOK_BEGIN_DRAG = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_BEGIN_DRAG, 1)
""" A drag-and-drop operation on a notebook tab has started. """
EVT_AUINOTEBOOK_END_DRAG = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_END_DRAG, 1)
""" A drag-and-drop operation on a notebook tab has finished. """
EVT_AUINOTEBOOK_DRAG_MOTION = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_DRAG_MOTION, 1)
""" A drag-and-drop operation on a notebook tab is ongoing. """
EVT_AUINOTEBOOK_ALLOW_DND = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_ALLOW_DND, 1)
""" Fires an event asking if it is OK to drag and drop a tab. """
EVT_AUINOTEBOOK_DRAG_DONE = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_DRAG_DONE, 1)
""" A drag-and-drop operation on a notebook tab has finished. """
EVT_AUINOTEBOOK_TAB_MIDDLE_DOWN = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_TAB_MIDDLE_DOWN, 1)
""" The user clicked with the middle mouse button on a tab. """
EVT_AUINOTEBOOK_TAB_MIDDLE_UP = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_TAB_MIDDLE_UP, 1)
""" The user clicked with the middle mouse button on a tab. """
EVT_AUINOTEBOOK_TAB_RIGHT_DOWN = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_TAB_RIGHT_DOWN, 1)
""" The user clicked with the right mouse button on a tab. """
EVT_AUINOTEBOOK_TAB_RIGHT_UP = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_TAB_RIGHT_UP, 1)
""" The user clicked with the right mouse button on a tab. """
EVT_AUINOTEBOOK_BG_MIDDLE_DOWN = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_BG_MIDDLE_DOWN, 1)
""" The user middle-clicked in the tab area but not over a tab or a button. """
EVT_AUINOTEBOOK_BG_MIDDLE_UP = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_BG_MIDDLE_UP, 1)
""" The user middle-clicked in the tab area but not over a tab or a button. """
EVT_AUINOTEBOOK_BG_RIGHT_DOWN = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_BG_RIGHT_DOWN, 1)
""" The user right-clicked in the tab area but not over a tab or a button. """
EVT_AUINOTEBOOK_BG_RIGHT_UP = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_BG_RIGHT_UP, 1)
""" The user right-clicked in the tab area but not over a tab or a button. """
EVT_AUINOTEBOOK_BG_DCLICK = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_BG_DCLICK, 1)
""" The user left-clicked on the tab area not occupied by `AuiNotebook` tabs. """
EVT_AUINOTEBOOK_CANCEL_DRAG = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_CANCEL_DRAG, 1)
""" A drag and drop operation has been cancelled. """
EVT_AUINOTEBOOK_TAB_DCLICK = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_TAB_DCLICK, 1)
""" The user double-clicked with the left mouse button on a tab. """
EVT_AUINOTEBOOK_BEGIN_LABEL_EDIT = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_BEGIN_LABEL_EDIT, 1)
""" The user double-clicked with the left mouse button on a tab which text is editable. """
EVT_AUINOTEBOOK_END_LABEL_EDIT = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_END_LABEL_EDIT, 1)
""" The user finished editing a tab label. """


# -----------------------------------------------------------------------------
# Auxiliary class: TabTextCtrl
# This is the temporary ExpandoTextCtrl created when you edit the text of a tab
# -----------------------------------------------------------------------------

class TabTextCtrl(ExpandoTextCtrl):
    """ Control used for in-place edit. """

    def __init__(self, owner, tab, page_index):
        """
        Default class constructor.
        For internal use: do not call it in your code!

        :param `owner`: the L{AuiTabCtrl} owning the tab;
        :param `tab`: the actual L{AuiNotebookPage} tab;
        :param `page_index`: the L{AuiNotebook} page index for the tab.
        """
        
        self._owner = owner
        self._tabEdited = tab
        self._pageIndex = page_index
        self._startValue = tab.caption
        self._finished = False
        self._aboutToFinish = False
        self._currentValue = self._startValue

        x, y, w, h = self._tabEdited.rect

        wnd = self._tabEdited.control
        if wnd:
            x += wnd.GetSize()[0] + 2
            h = 0

        image_h = 0
        image_w = 0

        image = tab.bitmap

        if image.IsOk():
            image_w, image_h = image.GetWidth(), image.GetHeight()
            image_w += 6
        
        dc = wx.ClientDC(self._owner)
        h = max(image_h, dc.GetMultiLineTextExtent(tab.caption)[1])
        h = h + 2
            
        # FIXME: what are all these hardcoded 4, 8 and 11s really?
        x += image_w
        w -= image_w + 4

        y = (self._tabEdited.rect.height - h)/2 + 1   

        expandoStyle = wx.WANTS_CHARS
        if wx.Platform in ["__WXGTK__", "__WXMAC__"]:
            expandoStyle |= wx.SIMPLE_BORDER
            xSize, ySize = w + 2, h
        else:
            expandoStyle |= wx.SUNKEN_BORDER
            xSize, ySize = w + 2, h+2
            
        ExpandoTextCtrl.__init__(self, self._owner, wx.ID_ANY, self._startValue,
                                 wx.Point(x, y), wx.Size(xSize, ySize),
                                 expandoStyle)

        if wx.Platform == "__WXMAC__":
            self.SetFont(owner.GetFont())
            bs = self.GetBestSize()
            self.SetSize((-1, bs.height))
        
        self.Bind(wx.EVT_CHAR, self.OnChar)
        self.Bind(wx.EVT_KEY_UP, self.OnKeyUp)
        self.Bind(wx.EVT_KILL_FOCUS, self.OnKillFocus)
    

    def AcceptChanges(self):
        """ Accepts/refuses the changes made by the user. """

        value = self.GetValue()
        notebook = self._owner.GetParent()

        if value == self._startValue:
            # nothing changed, always accept
            # when an item remains unchanged, the owner
            # needs to be notified that the user decided
            # not to change the tree item label, and that
            # the edit has been cancelled
            notebook.OnRenameCancelled(self._pageIndex)
            return True

        if not notebook.OnRenameAccept(self._pageIndex, value):
            # vetoed by the user
            return False

        # accepted, do rename the item
        notebook.SetPageText(self._pageIndex, value)
        
        return True


    def Finish(self):
        """ Finish editing. """

        if not self._finished:

            notebook = self._owner.GetParent()
        
            self._finished = True
            self._owner.SetFocus()
            notebook.ResetTextControl()
        

    def OnChar(self, event):
        """
        Handles the ``wx.EVT_CHAR`` event for L{TabTextCtrl}.

        :param `event`: a `wx.KeyEvent` event to be processed.
        """

        keycode = event.GetKeyCode()
        shiftDown = event.ShiftDown()

        if keycode == wx.WXK_RETURN:
            if shiftDown and self._tabEdited.IsMultiline():
                event.Skip()
            else:
                self._aboutToFinish = True
                self.SetValue(self._currentValue)
                # Notify the owner about the changes
                self.AcceptChanges()
                # Even if vetoed, close the control (consistent with MSW)
                wx.CallAfter(self.Finish)

        elif keycode == wx.WXK_ESCAPE:
            self.StopEditing()

        else:
            event.Skip()
    

    def OnKeyUp(self, event):
        """
        Handles the ``wx.EVT_KEY_UP`` event for L{TabTextCtrl}.

        :param `event`: a `wx.KeyEvent` event to be processed.
        """

        if not self._finished:

            # auto-grow the textctrl:
            mySize = self.GetSize()

            dc = wx.ClientDC(self)
            sx, sy, dummy = dc.GetMultiLineTextExtent(self.GetValue() + "M")

            self.SetSize((sx, -1))
            self._currentValue = self.GetValue()

        event.Skip()


    def OnKillFocus(self, event):
        """
        Handles the ``wx.EVT_KILL_FOCUS`` event for L{TabTextCtrl}.

        :param `event`: a `wx.FocusEvent` event to be processed.
        """

        if not self._finished and not self._aboutToFinish:
        
            # We must finish regardless of success, otherwise we'll get
            # focus problems:
            if not self.AcceptChanges():
                self._owner.GetParent().OnRenameCancelled(self._pageIndex)

        # We must let the native text control handle focus, too, otherwise
        # it could have problems with the cursor (e.g., in wxGTK).
        event.Skip()
        wx.CallAfter(self._owner.GetParent().ResetTextControl)


    def StopEditing(self):
        """ Suddenly stops the editing. """

        self._owner.GetParent().OnRenameCancelled(self._pageIndex)
        self.Finish()
        
    
    def item(self):
        """ Returns the item currently edited. """

        return self._tabEdited


# ----------------------------------------------------------------------

class AuiNotebookPage(object):
    """
    A simple class which holds information about tab captions, bitmaps and
    colours.
    """

    def __init__(self):
        """
        Default class constructor.
        Used internally, do not call it in your code!
        """

        self.window = None              # page's associated window
        self.caption = ""               # caption displayed on the tab
        self.bitmap = wx.NullBitmap     # tab's bitmap
        self.dis_bitmap = wx.NullBitmap # tab's disabled bitmap
        self.rect = wx.Rect()           # tab's hit rectangle
        self.active = False             # True if the page is currently active
        self.enabled = True             # True if the page is currently enabled
        self.hasCloseButton = True      # True if the page has a close button using the style
                                        # AUI_NB_CLOSE_ON_ALL_TABS
        self.control = None             # A control can now be inside a tab
        self.renamable = False          # If True, a tab can be renamed by a left double-click
        
        self.text_colour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_BTNTEXT)
        
        self.access_time = datetime.datetime.now() # Last time this page was selected

    def IsMultiline(self):
        """ Returns whether the tab contains multiline text. """

        return "\n" in self.caption
    
        
# ----------------------------------------------------------------------

class AuiTabContainerButton(object):
    """
    A simple class which holds information about tab buttons and their state.
    """

    def __init__(self):
        """
        Default class constructor.
        Used internally, do not call it in your code!
        """

        self.id = -1                                      # button's id
        self.cur_state = AUI_BUTTON_STATE_NORMAL          # current state (normal, hover, pressed, etc.)
        self.location = wx.LEFT                           # buttons location (wxLEFT, wxRIGHT, or wxCENTER)
        self.bitmap = wx.NullBitmap                       # button's hover bitmap
        self.dis_bitmap = wx.NullBitmap                   # button's disabled bitmap
        self.rect = wx.Rect()                             # button's hit rectangle


# ----------------------------------------------------------------------

class CommandNotebookEvent(wx.PyCommandEvent):
    """ A specialized command event class for events sent by L{AuiNotebook} . """
    
    def __init__(self, command_type=None, win_id=0):
        """
        Default class constructor.

        :param `command_type`: the event kind or an instance of `wx.PyCommandEvent`.
        :param `win_id`: the window identification number.
        """

        if type(command_type) == types.IntType:    
            wx.PyCommandEvent.__init__(self, command_type, win_id)
        else:
            wx.PyCommandEvent.__init__(self, command_type.GetEventType(), command_type.GetId())
            
        self.old_selection = -1
        self.selection = -1
        self.drag_source = None
        self.dispatched = 0
        self.label = ""
        self.editCancelled = False


    def SetSelection(self, s):
        """
        Sets the selection member variable.

        :param `s`: the new selection.
        """

        self.selection = s
        self._commandInt = s

        
    def GetSelection(self):
        """ Returns the currently selected page, or -1 if none was selected. """

        return self.selection


    def SetOldSelection(self, s):
        """
        Sets the id of the page selected before the change.

        :param `s`: the old selection.
        """
        
        self.old_selection = s

        
    def GetOldSelection(self):
        """
        Returns the page that was selected before the change, or -1 if none was
        selected.
        """

        return self.old_selection
    

    def SetDragSource(self, s):
        """
        Sets the drag and drop source.

        :param `s`: the drag source.
        """

        self.drag_source = s

        
    def GetDragSource(self):
        """ Returns the drag and drop source. """

        return self.drag_source


    def SetDispatched(self, b):
        """
        Sets the event as dispatched (used for automatic L{AuiNotebook} ).

        :param `b`: whether the event was dispatched or not.
        """

        self.dispatched = b

        
    def GetDispatched(self):
        """ Returns whether the event was dispatched (used for automatic L{AuiNotebook} ). """

        return self.dispatched


    def IsEditCancelled(self):
        """ Returns the edit cancel flag (for ``EVT_AUINOTEBOOK_BEGIN`` | ``END_LABEL_EDIT`` only)."""

        return self.editCancelled


    def SetEditCanceled(self, editCancelled):
        """
        Sets the edit cancel flag (for ``EVT_AUINOTEBOOK_BEGIN`` | ``END_LABEL_EDIT`` only).

        :param `editCancelled`: whether the editing action has been cancelled or not.
        """

        self.editCancelled = editCancelled


    def GetLabel(self):
        """Returns the label-itemtext (for ``EVT_AUINOTEBOOK_BEGIN`` | ``END_LABEL_EDIT`` only)."""

        return self.label

    
    def SetLabel(self, label):
        """
        Sets the label. Useful only for ``EVT_AUINOTEBOOK_END_LABEL_EDIT``.

        :param `label`: the new label.
        """

        self.label = label
    

# ----------------------------------------------------------------------

class AuiNotebookEvent(CommandNotebookEvent):
    """ A specialized command event class for events sent by L{AuiNotebook}. """
    
    def __init__(self, command_type=None, win_id=0):
        """
        Default class constructor.

        :param `command_type`: the event kind or an instance of `wx.PyCommandEvent`.
        :param `win_id`: the window identification number.
        """

        CommandNotebookEvent.__init__(self, command_type, win_id)

        if type(command_type) == types.IntType:
            self.notify = wx.NotifyEvent(command_type, win_id)
        else:
            self.notify = wx.NotifyEvent(command_type.GetEventType(), command_type.GetId())

        
    def GetNotifyEvent(self):
        """ Returns the actual `wx.NotifyEvent`. """
        
        return self.notify


    def IsAllowed(self):
        """ Returns whether the event is allowed or not. """

        return self.notify.IsAllowed()


    def Veto(self):
        """
        Prevents the change announced by this event from happening.

        It is in general a good idea to notify the user about the reasons for
        vetoing the change because otherwise the applications behaviour (which
        just refuses to do what the user wants) might be quite surprising.
        """

        self.notify.Veto()


    def Allow(self):
        """
        This is the opposite of L{Veto}: it explicitly allows the event to be
        processed. For most events it is not necessary to call this method as the
        events are allowed anyhow but some are forbidden by default (this will
        be mentioned in the corresponding event description).
        """

        self.notify.Allow()
        

# ---------------------------------------------------------------------------- #
# Class TabNavigatorWindow
# ---------------------------------------------------------------------------- #

class TabNavigatorWindow(wx.Dialog):
    """
    This class is used to create a modal dialog that enables "Smart Tabbing",
    similar to what you would get by hitting ``Alt`` + ``Tab`` on Windows.
    """

    def __init__(self, parent=None, icon=None):
        """
        Default class constructor. Used internally.

        :param `parent`: the L{TabNavigatorWindow} parent;
        :param `icon`: the L{TabNavigatorWindow} icon.
        """

        wx.Dialog.__init__(self, parent, wx.ID_ANY, "", style=0)

        self._selectedItem = -1
        self._indexMap = []
        
        if icon is None:
            self._bmp = Mondrian.GetBitmap()
        else:
            self._bmp = icon

        if self._bmp.GetSize() != (16, 16):
            img = self._bmp.ConvertToImage()
            img.Rescale(16, 16, wx.IMAGE_QUALITY_HIGH)
            self._bmp = wx.BitmapFromImage(img)
            
        sz = wx.BoxSizer(wx.VERTICAL)
        
        self._listBox = wx.ListBox(self, wx.ID_ANY, wx.DefaultPosition, wx.Size(200, 150), [], wx.LB_SINGLE | wx.NO_BORDER)
        
        mem_dc = wx.MemoryDC()
        mem_dc.SelectObject(wx.EmptyBitmap(1,1))
        font = wx.SystemSettings_GetFont(wx.SYS_DEFAULT_GUI_FONT)
        font.SetWeight(wx.BOLD)
        mem_dc.SetFont(font)

        panelHeight = mem_dc.GetCharHeight()
        panelHeight += 4 # Place a spacer of 2 pixels

        # Out signpost bitmap is 24 pixels
        if panelHeight < 24:
            panelHeight = 24
        
        self._panel = wx.Panel(self, wx.ID_ANY, wx.DefaultPosition, wx.Size(200, panelHeight))

        sz.Add(self._panel)
        sz.Add(self._listBox, 1, wx.EXPAND)
        
        self.SetSizer(sz)

        # Connect events to the list box
        self._listBox.Bind(wx.EVT_KEY_UP, self.OnKeyUp)
        self._listBox.Bind(wx.EVT_NAVIGATION_KEY, self.OnNavigationKey)
        self._listBox.Bind(wx.EVT_LISTBOX_DCLICK, self.OnItemSelected)
        
        # Connect paint event to the panel
        self._panel.Bind(wx.EVT_PAINT, self.OnPanelPaint)
        self._panel.Bind(wx.EVT_ERASE_BACKGROUND, self.OnPanelEraseBg)

        self.SetBackgroundColour(wx.SystemSettings_GetColour(wx.SYS_COLOUR_3DFACE))
        self._listBox.SetBackgroundColour(wx.SystemSettings_GetColour(wx.SYS_COLOUR_3DFACE))
        self.PopulateListControl(parent)
        
        self.GetSizer().Fit(self)
        self.GetSizer().SetSizeHints(self)
        self.GetSizer().Layout()
        self.Centre()

        # Set focus on the list box to avoid having to click on it to change
        # the tab selection under GTK.
        self._listBox.SetFocus()


    def OnKeyUp(self, event):
        """
        Handles the ``wx.EVT_KEY_UP`` for the L{TabNavigatorWindow}.

        :param `event`: a `wx.KeyEvent` event to be processed.
        """
        
        if event.GetKeyCode() == wx.WXK_CONTROL:
            self.CloseDialog()


    def OnNavigationKey(self, event):
        """
        Handles the ``wx.EVT_NAVIGATION_KEY`` for the L{TabNavigatorWindow}.

        :param `event`: a `wx.NavigationKeyEvent` event to be processed.
        """

        selected = self._listBox.GetSelection()
        bk = self.GetParent()
        maxItems = bk.GetPageCount()
            
        if event.GetDirection():
        
            # Select next page
            if selected == maxItems - 1:
                itemToSelect = 0
            else:
                itemToSelect = selected + 1
        
        else:
        
            # Previous page
            if selected == 0:
                itemToSelect = maxItems - 1
            else:
                itemToSelect = selected - 1
        
        self._listBox.SetSelection(itemToSelect)


    def PopulateListControl(self, book):
        """
        Populates the L{TabNavigatorWindow} listbox with a list of tabs.

        :param `book`: the actual L{AuiNotebook}.
        """
        # Index of currently selected page
        selection = book.GetSelection()
        # Total number of pages
        count = book.GetPageCount()
        # List of (index, AuiNotebookPage)
        pages = list(enumerate(book.GetTabContainer().GetPages()))
        if book.GetAGWWindowStyleFlag() & AUI_NB_ORDER_BY_ACCESS:
            # Sort pages using last access time. Most recently used is the 
            # first in line
            pages.sort(
                key = lambda element: element[1].access_time, 
                reverse = True
            )
        else:
            # Manually add the current selection as first item
            # Remaining ones are added in the next loop
            del pages[selection]
            self._listBox.Append(book.GetPageText(selection))
            self._indexMap.append(selection)
        
        for (index, page) in pages:
            self._listBox.Append(book.GetPageText(index))
            self._indexMap.append(index)
        
        # Select the next entry after the current selection
        self._listBox.SetSelection(0)
        dummy = wx.NavigationKeyEvent()
        dummy.SetDirection(True)
        self.OnNavigationKey(dummy)


    def OnItemSelected(self, event):
        """
        Handles the ``wx.EVT_LISTBOX_DCLICK`` event for the wx.ListBox inside L{TabNavigatorWindow}.

        :param `event`: a `wx.ListEvent` event to be processed.
        """

        self.CloseDialog()


    def CloseDialog(self):
        """ Closes the L{TabNavigatorWindow} dialog, setting selection in L{AuiNotebook}. """

        bk = self.GetParent()
        self._selectedItem = self._listBox.GetSelection()
        self.EndModal(wx.ID_OK)
        
    def GetSelectedPage(self):
        """ Gets the page index that was selected when the dialog was closed """
        return self._indexMap[self._selectedItem]

    def OnPanelPaint(self, event):
        """
        Handles the ``wx.EVT_PAINT`` event for L{TabNavigatorWindow} top panel.

        :param `event`: a `wx.PaintEvent` event to be processed.
        """

        dc = wx.PaintDC(self._panel)
        rect = self._panel.GetClientRect()

        bmp = wx.EmptyBitmap(rect.width, rect.height)

        mem_dc = wx.MemoryDC()
        mem_dc.SelectObject(bmp)

        endColour = wx.SystemSettings_GetColour(wx.SYS_COLOUR_BTNSHADOW)
        startColour = LightColour(endColour, 50)
        mem_dc.GradientFillLinear(rect, startColour, endColour, wx.SOUTH)

        # Draw the caption title and place the bitmap
        # get the bitmap optimal position, and draw it
        bmpPt, txtPt = wx.Point(), wx.Point()
        bmpPt.y = (rect.height - self._bmp.GetHeight())/2
        bmpPt.x = 3
        mem_dc.DrawBitmap(self._bmp, bmpPt.x, bmpPt.y, True)

        # get the text position, and draw it
        font = wx.SystemSettings_GetFont(wx.SYS_DEFAULT_GUI_FONT)
        font.SetWeight(wx.BOLD)
        mem_dc.SetFont(font)
        fontHeight = mem_dc.GetCharHeight()
        
        txtPt.x = bmpPt.x + self._bmp.GetWidth() + 4
        txtPt.y = (rect.height - fontHeight)/2
        mem_dc.SetTextForeground(wx.WHITE)
        mem_dc.DrawText("Opened tabs:", txtPt.x, txtPt.y)
        mem_dc.SelectObject(wx.NullBitmap)
        
        dc.DrawBitmap(bmp, 0, 0)


    def OnPanelEraseBg(self, event):
        """
        Handles the ``wx.EVT_ERASE_BACKGROUND`` event for L{TabNavigatorWindow} top panel.

        :param `event`: a `wx.EraseEvent` event to be processed.

        :note: This is intentionally empty, to reduce flicker.
        """

        pass


# ----------------------------------------------------------------------
# -- AuiTabContainer class implementation --

class AuiTabContainer(object):
    """
    AuiTabContainer is a class which contains information about each
    tab. It also can render an entire tab control to a specified DC.
    It's not a window class itself, because this code will be used by
    the L{AuiManager}, where it is disadvantageous to have separate
    windows for each tab control in the case of "docked tabs".

    A derived class, L{AuiTabCtrl}, is an actual `wx.Window`-derived window
    which can be used as a tab control in the normal sense.
    """

    def __init__(self, auiNotebook):
        """
        Default class constructor.
        Used internally, do not call it in your code!
        """

        self._tab_offset = 0
        self._agwFlags = 0
        self._art = TA.AuiDefaultTabArt()

        self._buttons = []
        self._pages = []
        self._tab_close_buttons = []
        
        self._rect = wx.Rect()
        self._auiNotebook = auiNotebook
        
        self.AddButton(AUI_BUTTON_LEFT, wx.LEFT)
        self.AddButton(AUI_BUTTON_RIGHT, wx.RIGHT)
        self.AddButton(AUI_BUTTON_WINDOWLIST, wx.RIGHT)
        self.AddButton(AUI_BUTTON_CLOSE, wx.RIGHT)


    def SetArtProvider(self, art):
        """
        Instructs L{AuiTabContainer} to use art provider specified by parameter `art`
        for all drawing calls. This allows plugable look-and-feel features. 

        :param `art`: an art provider.

        :note: The previous art provider object, if any, will be deleted by L{AuiTabContainer}.        
        """

        del self._art
        self._art = art

        if self._art:
            self._art.SetAGWFlags(self._agwFlags)
    

    def GetArtProvider(self):
        """ Returns the current art provider being used. """

        return self._art


    def SetAGWFlags(self, agwFlags):
        """
        Sets the tab art flags.

        :param `agwFlags`: a combination of the following values:

         ==================================== ==================================
         Flag name                            Description
         ==================================== ==================================
         ``AUI_NB_TOP``                       With this style, tabs are drawn along the top of the notebook
         ``AUI_NB_LEFT``                      With this style, tabs are drawn along the left of the notebook. Not implemented yet
         ``AUI_NB_RIGHT``                     With this style, tabs are drawn along the right of the notebook. Not implemented yet
         ``AUI_NB_BOTTOM``                    With this style, tabs are drawn along the bottom of the notebook
         ``AUI_NB_TAB_SPLIT``                 Allows the tab control to be split by dragging a tab
         ``AUI_NB_TAB_MOVE``                  Allows a tab to be moved horizontally by dragging
         ``AUI_NB_TAB_EXTERNAL_MOVE``         Allows a tab to be moved to another tab control
         ``AUI_NB_TAB_FIXED_WIDTH``           With this style, all tabs have the same width
         ``AUI_NB_SCROLL_BUTTONS``            With this style, left and right scroll buttons are displayed
         ``AUI_NB_WINDOWLIST_BUTTON``         With this style, a drop-down list of windows is available
         ``AUI_NB_CLOSE_BUTTON``              With this style, a close button is available on the tab bar
         ``AUI_NB_CLOSE_ON_ACTIVE_TAB``       With this style, a close button is available on the active tab
         ``AUI_NB_CLOSE_ON_ALL_TABS``         With this style, a close button is available on all tabs
         ``AUI_NB_MIDDLE_CLICK_CLOSE``        Allows to close L{AuiNotebook} tabs by mouse middle button click
         ``AUI_NB_SUB_NOTEBOOK``              This style is used by L{AuiManager} to create automatic AuiNotebooks
         ``AUI_NB_HIDE_ON_SINGLE_TAB``        Hides the tab window if only one tab is present
         ``AUI_NB_SMART_TABS``                Use Smart Tabbing, like ``Alt`` + ``Tab`` on Windows
         ``AUI_NB_USE_IMAGES_DROPDOWN``       Uses images on dropdown window list menu instead of check items
         ``AUI_NB_CLOSE_ON_TAB_LEFT``         Draws the tab close button on the left instead of on the right (a la Camino browser)
         ``AUI_NB_TAB_FLOAT``                 Allows the floating of single tabs. Known limitation: when the notebook is more or less full screen, tabs cannot be dragged far enough outside of the notebook to become floating pages
         ``AUI_NB_DRAW_DND_TAB``              Draws an image representation of a tab while dragging (on by default)
         ==================================== ==================================

        :todo: Implementation of flags ``AUI_NB_RIGHT`` and ``AUI_NB_LEFT``.
        
        """
        
        self._agwFlags = agwFlags

        # check for new close button settings
        self.RemoveButton(AUI_BUTTON_LEFT)
        self.RemoveButton(AUI_BUTTON_RIGHT)
        self.RemoveButton(AUI_BUTTON_WINDOWLIST)
        self.RemoveButton(AUI_BUTTON_CLOSE)

        if agwFlags & AUI_NB_SCROLL_BUTTONS:
            self.AddButton(AUI_BUTTON_LEFT, wx.LEFT)
            self.AddButton(AUI_BUTTON_RIGHT, wx.RIGHT)
        
        if agwFlags & AUI_NB_WINDOWLIST_BUTTON:
            self.AddButton(AUI_BUTTON_WINDOWLIST, wx.RIGHT)
        
        if agwFlags & AUI_NB_CLOSE_BUTTON:
            self.AddButton(AUI_BUTTON_CLOSE, wx.RIGHT)

        if self._art:
            self._art.SetAGWFlags(self._agwFlags)
        

    def GetAGWFlags(self):
        """
        Returns the tab art flags.

        See L{SetAGWFlags} for a list of possible return values.

        :see: L{SetAGWFlags}
        """

        return self._agwFlags


    def SetNormalFont(self, font):
        """
        Sets the normal font for drawing tab labels.

        :param `font`: a `wx.Font` object.
        """

        self._art.SetNormalFont(font)


    def SetSelectedFont(self, font):
        """
        Sets the selected tab font for drawing tab labels.

        :param `font`: a `wx.Font` object.
        """

        self._art.SetSelectedFont(font)


    def SetMeasuringFont(self, font):
        """
        Sets the font for calculating text measurements.

        :param `font`: a `wx.Font` object.
        """

        self._art.SetMeasuringFont(font)


    def SetTabRect(self, rect):
        """
        Sets the tab area rectangle.

        :param `rect`: an instance of `wx.Rect`, specifying the available area for L{AuiTabContainer}.
        """

        self._rect = rect

        if self._art:
            minMaxTabWidth = self._auiNotebook.GetMinMaxTabWidth()
            self._art.SetSizingInfo(rect.GetSize(), len(self._pages), minMaxTabWidth)


    def AddPage(self, page, info):
        """
        Adds a page to the tab control.

        :param `page`: the window associated with this tab;
        :param `info`: an instance of L{AuiNotebookPage}.
        """

        page_info = info
        page_info.window = page

        self._pages.append(page_info)

        # let the art provider know how many pages we have
        if self._art:
            minMaxTabWidth = self._auiNotebook.GetMinMaxTabWidth()
            self._art.SetSizingInfo(self._rect.GetSize(), len(self._pages), minMaxTabWidth)
        
        return True


    def InsertPage(self, page, info, idx):
        """
        Inserts a page in the tab control in the position specified by `idx`.

        :param `page`: the window associated with this tab;
        :param `info`: an instance of L{AuiNotebookPage};
        :param `idx`: the page insertion index.
        """
        
        page_info = info
        page_info.window = page

        if idx >= len(self._pages):
            self._pages.append(page_info)
        else:
            self._pages.insert(idx, page_info)

        # let the art provider know how many pages we have
        if self._art:
            minMaxTabWidth = self._auiNotebook.GetMinMaxTabWidth()
            self._art.SetSizingInfo(self._rect.GetSize(), len(self._pages), minMaxTabWidth)
        
        return True
    

    def MovePage(self, page, new_idx):
        """
        Moves a page in a new position specified by `new_idx`.

        :param `page`: the window associated with this tab;
        :param `new_idx`: the new page position.
        """
        
        idx = self.GetIdxFromWindow(page)
        if idx == -1:
            return False

        # get page entry, make a copy of it
        p = self.GetPage(idx)

        # remove old page entry
        self.RemovePage(page)

        # insert page where it should be
        self.InsertPage(page, p, new_idx)

        return True


    def RemovePage(self, wnd):
        """
        Removes a page from the tab control.

        :param `wnd`: an instance of `wx.Window`, a window associated with this tab.
        """

        minMaxTabWidth = self._auiNotebook.GetMinMaxTabWidth()

        for page in self._pages:
            if page.window == wnd:
                self._pages.remove(page)
                
                # let the art provider know how many pages we have
                if self._art:
                    self._art.SetSizingInfo(self._rect.GetSize(), len(self._pages), minMaxTabWidth)

                return True
            
        return False


    def SetActivePage(self, wndOrInt):
        """
        Sets the L{AuiTabContainer} active page.

        :param `wndOrInt`: an instance of `wx.Window` or an integer specifying a tab index.
        """

        if type(wndOrInt) == types.IntType:

            if wndOrInt >= len(self._pages):
                return False

            wnd = self._pages[wndOrInt].window

        else:
            wnd = wndOrInt
            
        found = False

        for indx, page in enumerate(self._pages):
            if page.window == wnd:
                page.active = True
                found = True
            else:
                page.active = False

        return found


    def SetNoneActive(self):
        """ Sets all the tabs as incative (non-selected). """

        for page in self._pages:        
            page.active = False
    

    def GetActivePage(self):
        """ Returns the current selected tab or ``wx.NOT_FOUND`` if none is selected. """

        for indx, page in enumerate(self._pages):
            if page.active:
                return indx
    
        return wx.NOT_FOUND


    def GetWindowFromIdx(self, idx):
        """
        Returns the window associated with the tab with index `idx`.

        :param `idx`: the tab index.
        """

        if idx >= len(self._pages):
            return None

        return self._pages[idx].window


    def GetIdxFromWindow(self, wnd):
        """
        Returns the tab index based on the window `wnd` associated with it.

        :param `wnd`: an instance of `wx.Window`.
        """
        
        for indx, page in enumerate(self._pages):
            if page.window == wnd:
                return indx

        return wx.NOT_FOUND


    def GetPage(self, idx):
        """
        Returns the page specified by the given index.

        :param `idx`: the tab index.
        """

        if idx < 0 or idx >= len(self._pages):
            raise Exception("Invalid Page index")

        return self._pages[idx]


    def GetPages(self):
        """ Returns a list of all the pages in this L{AuiTabContainer}. """

        return self._pages


    def GetPageCount(self):
        """ Returns the number of pages in the L{AuiTabContainer}. """

        return len(self._pages)


    def GetEnabled(self, idx):
        """
        Returns whether a tab is enabled or not.

        :param `idx`: the tab index.
        """
        
        if idx < 0 or idx >= len(self._pages):
            return False

        return self._pages[idx].enabled


    def EnableTab(self, idx, enable=True):
        """
        Enables/disables a tab in the L{AuiTabContainer}.

        :param `idx`: the tab index;
        :param `enable`: ``True`` to enable a tab, ``False`` to disable it.
        """
        
        if idx < 0 or idx >= len(self._pages):
            raise Exception("Invalid Page index")

        self._pages[idx].enabled = enable
        wnd = self.GetWindowFromIdx(idx)
        wnd.Enable(enable)

                
    def AddButton(self, id, location, normal_bitmap=wx.NullBitmap, disabled_bitmap=wx.NullBitmap):
        """
        Adds a button in the tab area.

        :param `id`: the button identifier. This can be one of the following:

         ==============================  =================================
         Button Identifier               Description
         ==============================  =================================
         ``AUI_BUTTON_CLOSE``            Shows a close button on the tab area
         ``AUI_BUTTON_WINDOWLIST``       Shows a window list button on the tab area
         ``AUI_BUTTON_LEFT``             Shows a left button on the tab area
         ``AUI_BUTTON_RIGHT``            Shows a right button on the tab area
         ==============================  =================================        

        :param `location`: the button location. Can be ``wx.LEFT`` or ``wx.RIGHT``;
        :param `normal_bitmap`: the bitmap for an enabled tab;
        :param `disabled_bitmap`: the bitmap for a disabled tab.
        """

        button = AuiTabContainerButton()
        button.id = id
        button.bitmap = normal_bitmap
        button.dis_bitmap = disabled_bitmap
        button.location = location
        button.cur_state = AUI_BUTTON_STATE_NORMAL

        self._buttons.append(button)


    def RemoveButton(self, id):
        """
        Removes a button from the tab area.

        :param `id`: the button identifier. See L{AddButton} for a list of button identifiers.

        :see: L{AddButton}        
        """
        
        for button in self._buttons:
            if button.id == id:
                self._buttons.remove(button)
                return


    def GetTabOffset(self):
        """ Returns the tab offset. """

        return self._tab_offset


    def SetTabOffset(self, offset):
        """
        Sets the tab offset.

        :param `offset`: the tab offset.
        """
        
        self._tab_offset = offset


    def Render(self, raw_dc, wnd):
        """
        Renders the tab catalog to the specified `wx.DC`.
        
        It is a virtual function and can be overridden to provide custom drawing
        capabilities.

        :param `raw_dc`: a `wx.DC` device context;
        :param `wnd`: an instance of `wx.Window`.
        """

        if not raw_dc or not raw_dc.IsOk():
            return

        dc = wx.MemoryDC()

        # use the same layout direction as the window DC uses to ensure that the
        # text is rendered correctly
        dc.SetLayoutDirection(raw_dc.GetLayoutDirection())

        page_count = len(self._pages)
        button_count = len(self._buttons)

        # create off-screen bitmap
        bmp = wx.EmptyBitmap(self._rect.GetWidth(), self._rect.GetHeight())
        dc.SelectObject(bmp)

        if not dc.IsOk():
            return
            
        # find out if size of tabs is larger than can be
        # afforded on screen
        total_width = visible_width = 0
        
        for i in xrange(page_count):
            page = self._pages[i]
                
            # determine if a close button is on this tab
            close_button = False
            if (self._agwFlags & AUI_NB_CLOSE_ON_ALL_TABS and page.hasCloseButton) or \
               (self._agwFlags & AUI_NB_CLOSE_ON_ACTIVE_TAB and page.active and page.hasCloseButton):
            
                close_button = True

            control = page.control
            if control:
                try:
                    control.GetSize()
                except wx.PyDeadObjectError:
                    page.control = None
                
            size, x_extent = self._art.GetTabSize(dc, wnd, page.caption, page.bitmap, page.active,
                                                  (close_button and [AUI_BUTTON_STATE_NORMAL] or \
                                                   [AUI_BUTTON_STATE_HIDDEN])[0], page.control)

            if i+1 < page_count:
                total_width += x_extent
            else:
                total_width += size[0]

            if i >= self._tab_offset:            
                if i+1 < page_count:
                    visible_width += x_extent
                else:
                    visible_width += size[0]

        if total_width > self._rect.GetWidth() or self._tab_offset != 0:
        
            # show left/right buttons
            for button in self._buttons:
                if button.id == AUI_BUTTON_LEFT or \
                   button.id == AUI_BUTTON_RIGHT:
                
                    button.cur_state &= ~AUI_BUTTON_STATE_HIDDEN
                
        else:
        
            # hide left/right buttons
            for button in self._buttons:
                if button.id == AUI_BUTTON_LEFT or \
                   button.id == AUI_BUTTON_RIGHT:
                    
                    button.cur_state |= AUI_BUTTON_STATE_HIDDEN

        # determine whether left button should be enabled
        for button in self._buttons:
            if button.id == AUI_BUTTON_LEFT:
                if self._tab_offset == 0:
                    button.cur_state |= AUI_BUTTON_STATE_DISABLED
                else:
                    button.cur_state &= ~AUI_BUTTON_STATE_DISABLED
            
            if button.id == AUI_BUTTON_RIGHT:
                if visible_width < self._rect.GetWidth() - 16*button_count:
                    button.cur_state |= AUI_BUTTON_STATE_DISABLED
                else:
                    button.cur_state &= ~AUI_BUTTON_STATE_DISABLED
            
        # draw background
        self._art.DrawBackground(dc, wnd, self._rect)

        # draw buttons
        left_buttons_width = 0
        right_buttons_width = 0

        # draw the buttons on the right side
        offset = self._rect.x + self._rect.width
        
        for i in xrange(button_count):        
            button = self._buttons[button_count - i - 1]

            if button.location != wx.RIGHT:
                continue
            if button.cur_state & AUI_BUTTON_STATE_HIDDEN:
                continue

            button_rect = wx.Rect(*self._rect)
            button_rect.SetY(1)
            button_rect.SetWidth(offset)

            button.rect = self._art.DrawButton(dc, wnd, button_rect, button, wx.RIGHT)

            offset -= button.rect.GetWidth()
            right_buttons_width += button.rect.GetWidth()
        
        offset = 0

        # draw the buttons on the left side
        for i in xrange(button_count):        
            button = self._buttons[button_count - i - 1]

            if button.location != wx.LEFT:
                continue
            if button.cur_state & AUI_BUTTON_STATE_HIDDEN:
                continue

            button_rect = wx.Rect(offset, 1, 1000, self._rect.height)

            button.rect = self._art.DrawButton(dc, wnd, button_rect, button, wx.LEFT)

            offset += button.rect.GetWidth()
            left_buttons_width += button.rect.GetWidth()
        
        offset = left_buttons_width

        if offset == 0:
            offset += self._art.GetIndentSize()

        # prepare the tab-close-button array
        # make sure tab button entries which aren't used are marked as hidden
        for i in xrange(page_count, len(self._tab_close_buttons)):
            self._tab_close_buttons[i].cur_state = AUI_BUTTON_STATE_HIDDEN

        # make sure there are enough tab button entries to accommodate all tabs
        while len(self._tab_close_buttons) < page_count:
            tempbtn = AuiTabContainerButton()
            tempbtn.id = AUI_BUTTON_CLOSE
            tempbtn.location = wx.CENTER
            tempbtn.cur_state = AUI_BUTTON_STATE_HIDDEN
            self._tab_close_buttons.append(tempbtn)

        # buttons before the tab offset must be set to hidden
        for i in xrange(self._tab_offset):
            self._tab_close_buttons[i].cur_state = AUI_BUTTON_STATE_HIDDEN
            if self._pages[i].control:
                if self._pages[i].control.IsShown():
                    self._pages[i].control.Hide()

        # draw the tabs
        active = 999
        active_offset = 0
        
        rect = wx.Rect(*self._rect)
        rect.y = 0
        rect.height = self._rect.height

        for i in xrange(self._tab_offset, page_count):
        
            page = self._pages[i]
            tab_button = self._tab_close_buttons[i]

            # determine if a close button is on this tab
            if (self._agwFlags & AUI_NB_CLOSE_ON_ALL_TABS and page.hasCloseButton) or \
               (self._agwFlags & AUI_NB_CLOSE_ON_ACTIVE_TAB and page.active and page.hasCloseButton):
            
                if tab_button.cur_state == AUI_BUTTON_STATE_HIDDEN:
                
                    tab_button.id = AUI_BUTTON_CLOSE
                    tab_button.cur_state = AUI_BUTTON_STATE_NORMAL
                    tab_button.location = wx.CENTER
                
            else:
            
                tab_button.cur_state = AUI_BUTTON_STATE_HIDDEN
            
            rect.x = offset
            rect.width = self._rect.width - right_buttons_width - offset - 2

            if rect.width <= 0:
                break

            page.rect, tab_button.rect, x_extent = self._art.DrawTab(dc, wnd, page, rect, tab_button.cur_state)

            if page.active:
                active = i
                active_offset = offset
                active_rect = wx.Rect(*rect)

            offset += x_extent

        lenPages = len(self._pages)        
        # make sure to deactivate buttons which are off the screen to the right
        for j in xrange(i+1, len(self._tab_close_buttons)):
            self._tab_close_buttons[j].cur_state = AUI_BUTTON_STATE_HIDDEN
            if j > 0 and j <= lenPages:
                if self._pages[j-1].control:
                    if self._pages[j-1].control.IsShown():
                        self._pages[j-1].control.Hide()
        
        # draw the active tab again so it stands in the foreground
        if active >= self._tab_offset and active < len(self._pages):
        
            page = self._pages[active]
            tab_button = self._tab_close_buttons[active]

            rect.x = active_offset
            dummy = self._art.DrawTab(dc, wnd, page, active_rect, tab_button.cur_state)

        raw_dc.Blit(self._rect.x, self._rect.y, self._rect.GetWidth(), self._rect.GetHeight(), dc, 0, 0)


    def IsTabVisible(self, tabPage, tabOffset, dc, wnd):
        """
        Returns whether a tab is visible or not.

        :param `tabPage`: the tab index;
        :param `tabOffset`: the tab offset;
        :param `dc`: a `wx.DC` device context;
        :param `wnd`: an instance of `wx.Window` derived window.
        """
        
        if not dc or not dc.IsOk():
            return False

        page_count = len(self._pages)
        button_count = len(self._buttons)
        self.Render(dc, wnd)

        # Hasn't been rendered yet assume it's visible
        if len(self._tab_close_buttons) < page_count:
            return True

        if self._agwFlags & AUI_NB_SCROLL_BUTTONS:
            # First check if both buttons are disabled - if so, there's no need to
            # check further for visibility.
            arrowButtonVisibleCount = 0
            for i in xrange(button_count):
            
                button = self._buttons[i]
                if button.id == AUI_BUTTON_LEFT or \
                   button.id == AUI_BUTTON_RIGHT:
                
                    if button.cur_state & AUI_BUTTON_STATE_HIDDEN == 0:
                        arrowButtonVisibleCount += 1
                
            # Tab must be visible
            if arrowButtonVisibleCount == 0:
                return True

        # If tab is less than the given offset, it must be invisible by definition
        if tabPage < tabOffset:
            return False

        # draw buttons
        left_buttons_width = 0
        right_buttons_width = 0

        offset = 0

        # calculate size of the buttons on the right side
        offset = self._rect.x + self._rect.width
        
        for i in xrange(button_count):
            button = self._buttons[button_count - i - 1]

            if button.location != wx.RIGHT:
                continue
            if button.cur_state & AUI_BUTTON_STATE_HIDDEN:
                continue

            offset -= button.rect.GetWidth()
            right_buttons_width += button.rect.GetWidth()
        
        offset = 0

        # calculate size of the buttons on the left side
        for i in xrange(button_count):
            button = self._buttons[button_count - i - 1]

            if button.location != wx.LEFT:
                continue
            if button.cur_state & AUI_BUTTON_STATE_HIDDEN:
                continue

            offset += button.rect.GetWidth()
            left_buttons_width += button.rect.GetWidth()
        
        offset = left_buttons_width

        if offset == 0:
            offset += self._art.GetIndentSize()

        rect = wx.Rect(*self._rect)
        rect.y = 0
        rect.height = self._rect.height

        # See if the given page is visible at the given tab offset (effectively scroll position)
        for i in xrange(tabOffset, page_count):
        
            page = self._pages[i]
            tab_button = self._tab_close_buttons[i]

            rect.x = offset
            rect.width = self._rect.width - right_buttons_width - offset - 2

            if rect.width <= 0:
                return False # haven't found the tab, and we've run out of space, so return False

            size, x_extent = self._art.GetTabSize(dc, wnd, page.caption, page.bitmap, page.active, tab_button.cur_state, page.control)
            offset += x_extent

            if i == tabPage:
            
                # If not all of the tab is visible, and supposing there's space to display it all,
                # we could do better so we return False.
                if (self._rect.width - right_buttons_width - offset - 2) <= 0 and (self._rect.width - right_buttons_width - left_buttons_width) > x_extent:
                    return False
                else:
                    return True
            
        # Shouldn't really get here, but if it does, assume the tab is visible to prevent
        # further looping in calling code.
        return True


    def MakeTabVisible(self, tabPage, win):
        """
        Make the tab visible if it wasn't already.

        :param `tabPage`: the tab index;
        :param `win`: an instance of `wx.Window` derived window.
        """                

        dc = wx.ClientDC(win)
        
        if not self.IsTabVisible(tabPage, self.GetTabOffset(), dc, win):
            for i in xrange(len(self._pages)):
                if self.IsTabVisible(tabPage, i, dc, win):
                    self.SetTabOffset(i)
                    win.Refresh()
                    return


    def TabHitTest(self, x, y):
        """
        TabHitTest() tests if a tab was hit, passing the window pointer
        back if that condition was fulfilled.

        :param `x`: the mouse `x` position;
        :param `y`: the mouse `y` position.
        """

        if not self._rect.Contains((x,y)):
            return None

        btn = self.ButtonHitTest(x, y)
        if btn:
            if btn in self._buttons:
                return None

        for i in xrange(self._tab_offset, len(self._pages)):
            page = self._pages[i]
            if page.rect.Contains((x,y)):
                return page.window

        return None
    

    def ButtonHitTest(self, x, y):
        """
        Tests if a button was hit.

        :param `x`: the mouse `x` position;
        :param `y`: the mouse `y` position.

        :returns: and instance of L{AuiTabContainerButton} if a button was hit, ``None`` otherwise.
        """

        if not self._rect.Contains((x,y)):
            return None

        for button in self._buttons:
            if button.rect.Contains((x,y)) and \
               (button.cur_state not in [AUI_BUTTON_STATE_HIDDEN, AUI_BUTTON_STATE_DISABLED]):
                return button
            
        for button in self._tab_close_buttons:
            if button.rect.Contains((x,y)) and \
               (button.cur_state not in [AUI_BUTTON_STATE_HIDDEN, AUI_BUTTON_STATE_DISABLED]):
                return button            
            
        return None


    def DoShowHide(self):
        """
        This function shows the active window, then hides all of the other windows
        (in that order).
        """

        pages = self.GetPages()

        # show new active page first
        for page in pages:
            if page.active:
                page.window.Show(True)
                break
            
        # hide all other pages
        for page in pages:
            if not page.active:
                page.window.Show(False)


# ----------------------------------------------------------------------
# -- AuiTabCtrl class implementation --

class AuiTabCtrl(wx.PyControl, AuiTabContainer):
    """
    This is an actual `wx.Window`-derived window which can be used as a tab
    control in the normal sense.
    """

    def __init__(self, parent, id=wx.ID_ANY, pos=wx.DefaultPosition, size=wx.DefaultSize,
                 style=wx.NO_BORDER|wx.WANTS_CHARS|wx.TAB_TRAVERSAL):
        """
        Default class constructor.
        Used internally, do not call it in your code!

        :param `parent`: the L{AuiTabCtrl} parent;
        :param `id`: an identifier for the control: a value of -1 is taken to mean a default;
        :param `pos`: the control position. A value of (-1, -1) indicates a default position,
         chosen by either the windowing system or wxPython, depending on platform;
        :param `size`: the control size. A value of (-1, -1) indicates a default size,
         chosen by either the windowing system or wxPython, depending on platform;
        :param `style`: the window style.
        """

        wx.PyControl.__init__(self, parent, id, pos, size, style, name="AuiTabCtrl")
        AuiTabContainer.__init__(self, parent)

        self._click_pt = wx.Point(-1, -1)
        self._is_dragging = False
        self._hover_button = None
        self._pressed_button = None
        self._drag_image = None
        self._drag_img_offset = (0, 0)
        self._on_button = False
        
        self.Bind(wx.EVT_PAINT, self.OnPaint)
        self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnEraseBackground)
        self.Bind(wx.EVT_SIZE, self.OnSize)
        self.Bind(wx.EVT_LEFT_DOWN, self.OnLeftDown)
        self.Bind(wx.EVT_LEFT_DCLICK, self.OnLeftDClick)
        self.Bind(wx.EVT_LEFT_UP, self.OnLeftUp)
        self.Bind(wx.EVT_MIDDLE_DOWN, self.OnMiddleDown)
        self.Bind(wx.EVT_MIDDLE_UP, self.OnMiddleUp)
        self.Bind(wx.EVT_RIGHT_DOWN, self.OnRightDown)
        self.Bind(wx.EVT_RIGHT_UP, self.OnRightUp)
        self.Bind(wx.EVT_SET_FOCUS, self.OnSetFocus)
        self.Bind(wx.EVT_KILL_FOCUS, self.OnKillFocus)
        self.Bind(wx.EVT_KEY_DOWN, self.OnKeyDown)
        self.Bind(wx.EVT_MOUSE_CAPTURE_LOST, self.OnCaptureLost)
        self.Bind(wx.EVT_MOTION, self.OnMotion)
        self.Bind(wx.EVT_LEAVE_WINDOW, self.OnLeaveWindow)
        self.Bind(EVT_AUINOTEBOOK_BUTTON, self.OnButton)


    def IsDragging(self):
        """ Returns whether the user is dragging a tab with the mouse or not. """

        return self._is_dragging


    def GetDefaultBorder(self):
        """ Returns the default border style for L{AuiTabCtrl}. """

        return wx.BORDER_NONE

    
    def OnPaint(self, event):
        """
        Handles the ``wx.EVT_PAINT`` event for L{AuiTabCtrl}.

        :param `event`: a `wx.PaintEvent` event to be processed.
        """
        
        dc = wx.PaintDC(self)
        dc.SetFont(self.GetFont())

        if self.GetPageCount() > 0:
            self.Render(dc, self)


    def OnEraseBackground(self, event):
        """
        Handles the ``wx.EVT_ERASE_BACKGROUND`` event for L{AuiTabCtrl}.

        :param `event`: a `wx.EraseEvent` event to be processed.        

        :note: This is intentionally empty, to reduce flicker.
        """
        
        pass        


    def DoGetBestSize(self):
        """
        Gets the size which best suits the window: for a control, it would be the
        minimal size which doesn't truncate the control, for a panel - the same
        size as it would have after a call to `Fit()`.
        
        :note: Overridden from `wx.PyControl`.
        """

        return wx.Size(self._rect.width, self._rect.height)
    

    def OnSize(self, event):
        """
        Handles the ``wx.EVT_SIZE`` event for L{AuiTabCtrl}.

        :param `event`: a `wx.SizeEvent` event to be processed.        
        """

        s = event.GetSize()
        self.SetTabRect(wx.Rect(0, 0, s.GetWidth(), s.GetHeight()))
                

    def OnLeftDown(self, event):
        """
        Handles the ``wx.EVT_LEFT_DOWN`` event for L{AuiTabCtrl}.

        :param `event`: a `wx.MouseEvent` event to be processed.        
        """
        
        self.CaptureMouse()
        self._click_pt = wx.Point(-1, -1)
        self._is_dragging = False
        self._click_tab = None
        self._pressed_button = None
        
        wnd = self.TabHitTest(event.GetX(), event.GetY())
        
        if wnd is not None:
            new_selection = self.GetIdxFromWindow(wnd)

            # AuiNotebooks always want to receive this event
            # even if the tab is already active, because they may
            # have multiple tab controls
            if new_selection != self.GetActivePage() or isinstance(self.GetParent(), AuiNotebook):
            
                e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_PAGE_CHANGING, self.GetId())
                e.SetSelection(new_selection)
                e.SetOldSelection(self.GetActivePage())
                e.SetEventObject(self)
                self.GetEventHandler().ProcessEvent(e)
            
            self._click_pt.x = event.GetX()
            self._click_pt.y = event.GetY()
            self._click_tab = wnd
        
        if self._hover_button:
            self._pressed_button = self._hover_button
            self._pressed_button.cur_state = AUI_BUTTON_STATE_PRESSED
            self._on_button = True
            self.Refresh()
            self.Update()


    def OnCaptureLost(self, event):
        """
        Handles the ``wx.EVT_MOUSE_CAPTURE_LOST`` event for L{AuiTabCtrl}.

        :param `event`: a `wx.MouseCaptureLostEvent` event to be processed.        
        """

        if self._is_dragging:
            self._is_dragging = False
            self._on_button = False

            if self._drag_image:
                self._drag_image.EndDrag()
                del self._drag_image
                self._drag_image = None
                
            event = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_CANCEL_DRAG, self.GetId())
            event.SetSelection(self.GetIdxFromWindow(self._click_tab))
            event.SetOldSelection(event.GetSelection())
            event.SetEventObject(self)
            self.GetEventHandler().ProcessEvent(event) 


    def OnLeftUp(self, event):
        """
        Handles the ``wx.EVT_LEFT_UP`` event for L{AuiTabCtrl}.

        :param `event`: a `wx.MouseEvent` event to be processed.        
        """

        self._on_button = False
        
        if self._is_dragging:

            if self.HasCapture():
                self.ReleaseMouse()
            
            self._is_dragging = False
            if self._drag_image:
                self._drag_image.EndDrag()
                del self._drag_image
                self._drag_image = None
                self.GetParent().Refresh()

            evt = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_END_DRAG, self.GetId())
            evt.SetSelection(self.GetIdxFromWindow(self._click_tab))
            evt.SetOldSelection(evt.GetSelection())
            evt.SetEventObject(self)
            self.GetEventHandler().ProcessEvent(evt)

            return

        if self.HasCapture():
            self.ReleaseMouse()
    
        if self._pressed_button:
        
            # make sure we're still clicking the button
            button = self.ButtonHitTest(event.GetX(), event.GetY())
            
            if button is None:
                return

            if button != self._pressed_button:
                self._pressed_button = None
                return
            
            self.Refresh()
            self.Update()

            if self._pressed_button.cur_state & AUI_BUTTON_STATE_DISABLED == 0:
            
                evt = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_BUTTON, self.GetId())
                evt.SetSelection(self.GetIdxFromWindow(self._click_tab))
                evt.SetInt(self._pressed_button.id)
                evt.SetEventObject(self)
                self.GetEventHandler().ProcessEvent(evt)
            
            self._pressed_button = None
        
        self._click_pt = wx.Point(-1, -1)
        self._is_dragging = False
        self._click_tab = None


    def OnMiddleUp(self, event):
        """
        Handles the ``wx.EVT_MIDDLE_UP`` event for L{AuiTabCtrl}.

        :param `event`: a `wx.MouseEvent` event to be processed.        
        """

        x, y = event.GetX(), event.GetY()
        wnd = self.TabHitTest(x, y)

        if wnd:
            e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_TAB_MIDDLE_UP, self.GetId())
            e.SetEventObject(self)
            e.SetSelection(self.GetIdxFromWindow(wnd))
            self.GetEventHandler().ProcessEvent(e)
        elif not self.ButtonHitTest(x, y):
            e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_BG_MIDDLE_UP, self.GetId())
            e.SetEventObject(self)
            self.GetEventHandler().ProcessEvent(e)


    def OnMiddleDown(self, event):
        """
        Handles the ``wx.EVT_MIDDLE_DOWN`` event for L{AuiTabCtrl}.

        :param `event`: a `wx.MouseEvent` event to be processed.        
        """
        
        x, y = event.GetX(), event.GetY()
        wnd = self.TabHitTest(x, y)

        if wnd:
            e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_TAB_MIDDLE_DOWN, self.GetId())
            e.SetEventObject(self)
            e.SetSelection(self.GetIdxFromWindow(wnd))
            self.GetEventHandler().ProcessEvent(e)
        elif not self.ButtonHitTest(x, y):
            e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_BG_MIDDLE_DOWN, self.GetId())
            e.SetEventObject(self)
            self.GetEventHandler().ProcessEvent(e)


    def OnRightUp(self, event):
        """
        Handles the ``wx.EVT_RIGHT_UP`` event for L{AuiTabCtrl}.

        :param `event`: a `wx.MouseEvent` event to be processed.        
        """

        x, y = event.GetX(), event.GetY()
        wnd = self.TabHitTest(x, y)

        if wnd:
            e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_TAB_RIGHT_UP, self.GetId())
            e.SetEventObject(self)
            e.SetSelection(self.GetIdxFromWindow(wnd))
            self.GetEventHandler().ProcessEvent(e)
        elif not self.ButtonHitTest(x, y):
            e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_BG_RIGHT_UP, self.GetId())
            e.SetEventObject(self)
            self.GetEventHandler().ProcessEvent(e)


    def OnRightDown(self, event):
        """
        Handles the ``wx.EVT_RIGHT_DOWN`` event for L{AuiTabCtrl}.

        :param `event`: a `wx.MouseEvent` event to be processed.        
        """
        
        x, y = event.GetX(), event.GetY()
        wnd = self.TabHitTest(x, y)

        if wnd:
            e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_TAB_RIGHT_DOWN, self.GetId())
            e.SetEventObject(self)
            e.SetSelection(self.GetIdxFromWindow(wnd))
            self.GetEventHandler().ProcessEvent(e)
        elif not self.ButtonHitTest(x, y):
            e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_BG_RIGHT_DOWN, self.GetId())
            e.SetEventObject(self)
            self.GetEventHandler().ProcessEvent(e)


    def OnLeftDClick(self, event):
        """
        Handles the ``wx.EVT_LEFT_DCLICK`` event for L{AuiTabCtrl}.

        :param `event`: a `wx.MouseEvent` event to be processed.        
        """
        
        x, y = event.GetX(), event.GetY()
        wnd = self.TabHitTest(x, y)

        if wnd:
            e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_TAB_DCLICK, self.GetId())
            e.SetEventObject(self)
            e.SetSelection(self.GetIdxFromWindow(wnd))
            self.GetEventHandler().ProcessEvent(e)
        elif not self.ButtonHitTest(x, y):
            e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_BG_DCLICK, self.GetId())
            e.SetEventObject(self)
            self.GetEventHandler().ProcessEvent(e)

    
    def OnMotion(self, event):
        """
        Handles the ``wx.EVT_MOTION`` event for L{AuiTabCtrl}.

        :param `event`: a `wx.MouseEvent` event to be processed.        
        """

        pos = event.GetPosition()

        # check if the mouse is hovering above a button

        button = self.ButtonHitTest(pos.x, pos.y)
        wnd = self.TabHitTest(pos.x, pos.y)

        if wnd is not None:
            mouse_tab = self.GetIdxFromWindow(wnd)
            if not self._pages[mouse_tab].enabled:
                self._hover_button = None
                return

        if self._on_button:
            return
        
        if button:
            
            if self._hover_button and button != self._hover_button:
                self._hover_button.cur_state = AUI_BUTTON_STATE_NORMAL
                self._hover_button = None
                self.Refresh()
                self.Update()
            
            if button.cur_state != AUI_BUTTON_STATE_HOVER:
                button.cur_state = AUI_BUTTON_STATE_HOVER
                self.Refresh()
                self.Update()
                self._hover_button = button
                return
                    
        else:
        
            if self._hover_button:
                self._hover_button.cur_state = AUI_BUTTON_STATE_NORMAL
                self._hover_button = None
                self.Refresh()
                self.Update()

        if not event.LeftIsDown() or self._click_pt == wx.Point(-1, -1):
            return

        if not self.HasCapture():
            return
        
        wnd = self.TabHitTest(pos.x, pos.y)

        if not self._is_dragging:

            drag_x_threshold = wx.SystemSettings.GetMetric(wx.SYS_DRAG_X)
            drag_y_threshold = wx.SystemSettings.GetMetric(wx.SYS_DRAG_Y)

            if abs(pos.x - self._click_pt.x) > drag_x_threshold or \
               abs(pos.y - self._click_pt.y) > drag_y_threshold:

                self._is_dragging = True

                if self._drag_image:
                    self._drag_image.EndDrag()
                    del self._drag_image
                    self._drag_image = None

                if self._agwFlags & AUI_NB_DRAW_DND_TAB:
                    # Create the custom draw image from the icons and the text of the item
                    mouse_tab = self.GetIdxFromWindow(wnd)
                    page = self._pages[mouse_tab]
                    tab_button = self._tab_close_buttons[mouse_tab]
                    self._drag_image = TabDragImage(self, page, tab_button.cur_state, self._art)

                    if self._agwFlags & AUI_NB_TAB_FLOAT:
                        self._drag_image.BeginDrag(wx.Point(0,0), self, fullScreen=True)
                    else:
                        self._drag_image.BeginDragBounded(wx.Point(0,0), self, self.GetParent())

                    # Capture the mouse cursor position offset relative to
                    # The tab image location
                    self._drag_img_offset = (pos[0] - page.rect.x,
                                             pos[1] - page.rect.y)

                    self._drag_image.Show()

        if not wnd:
            evt2 = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_BEGIN_DRAG, self.GetId())
            evt2.SetSelection(self.GetIdxFromWindow(self._click_tab))
            evt2.SetOldSelection(evt2.GetSelection())
            evt2.SetEventObject(self)
            self.GetEventHandler().ProcessEvent(evt2)
            if evt2.GetDispatched():
                return
            
        evt3 = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_DRAG_MOTION, self.GetId())
        evt3.SetSelection(self.GetIdxFromWindow(self._click_tab))
        evt3.SetOldSelection(evt3.GetSelection())
        evt3.SetEventObject(self)
        self.GetEventHandler().ProcessEvent(evt3)

        if self._drag_image:
            # Apply the drag images offset
            pos -= self._drag_img_offset
            self._drag_image.Move(pos)
            

    def OnLeaveWindow(self, event):
        """
        Handles the ``wx.EVT_LEAVE_WINDOW`` event for L{AuiTabCtrl}.

        :param `event`: a `wx.MouseEvent` event to be processed.        
        """
        
        if self._hover_button:
            self._hover_button.cur_state = AUI_BUTTON_STATE_NORMAL
            self._hover_button = None
            self.Refresh()
            self.Update()
    

    def OnButton(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_BUTTON`` event for L{AuiTabCtrl}.

        :param `event`: a L{AuiNotebookEvent} event to be processed.        
        """
        
        button = event.GetInt()

        if button == AUI_BUTTON_LEFT or button == AUI_BUTTON_RIGHT:
            if button == AUI_BUTTON_LEFT:
                if self.GetTabOffset() > 0:
                
                    self.SetTabOffset(self.GetTabOffset()-1)
                    self.Refresh()
                    self.Update()
            else:
                self.SetTabOffset(self.GetTabOffset()+1)
                self.Refresh()
                self.Update()
            
        elif button == AUI_BUTTON_WINDOWLIST:
            idx = self.GetArtProvider().ShowDropDown(self, self._pages, self.GetActivePage())
            
            if idx != -1:
            
                e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_PAGE_CHANGING, self.GetId())
                e.SetSelection(idx)
                e.SetOldSelection(self.GetActivePage())
                e.SetEventObject(self)
                self.GetEventHandler().ProcessEvent(e)
            
        else:
            event.Skip()
        

    def OnSetFocus(self, event):
        """
        Handles the ``wx.EVT_SET_FOCUS`` event for L{AuiTabCtrl}.

        :param `event`: a `wx.FocusEvent` event to be processed.        
        """

        self.Refresh()


    def OnKillFocus(self, event):
        """
        Handles the ``wx.EVT_KILL_FOCUS`` event for L{AuiTabCtrl}.

        :param `event`: a `wx.FocusEvent` event to be processed.        
        """

        self.Refresh()


    def OnKeyDown(self, event):
        """
        Handles the ``wx.EVT_KEY_DOWN`` event for L{AuiTabCtrl}.

        :param `event`: a `wx.KeyEvent` event to be processed.        
        """

        key = event.GetKeyCode()
        nb = self.GetParent()

        if key == wx.WXK_LEFT:
            nb.AdvanceSelection(False)
            self.SetFocus()

        elif key == wx.WXK_RIGHT:
            nb.AdvanceSelection(True)
            self.SetFocus()

        elif key == wx.WXK_HOME:
            newPage = 0
            nb.SetSelection(newPage)
            self.SetFocus()
        
        elif key == wx.WXK_END:
            newPage = nb.GetPageCount() - 1
            nb.SetSelection(newPage)
            self.SetFocus()
            
        elif key == wx.WXK_TAB:
            if not event.ControlDown():
                flags = 0
                if not event.ShiftDown(): flags |= wx.NavigationKeyEvent.IsForward
                if event.CmdDown():       flags |= wx.NavigationKeyEvent.WinChange
                self.Navigate(flags)
            else:

                if not nb or not isinstance(nb, AuiNotebook):
                    event.Skip()
                    return

                bForward = bWindowChange = 0
                if not event.ShiftDown(): bForward |= wx.NavigationKeyEvent.IsForward
                if event.CmdDown():       bWindowChange |= wx.NavigationKeyEvent.WinChange
                
                keyEvent = wx.NavigationKeyEvent()
                keyEvent.SetDirection(bForward)
                keyEvent.SetWindowChange(bWindowChange)
                keyEvent.SetFromTab(True)
                keyEvent.SetEventObject(nb)

                if not nb.GetEventHandler().ProcessEvent(keyEvent):
                
                    # Not processed? Do an explicit tab into the page.
                    win = self.GetWindowFromIdx(self.GetActivePage())
                    if win:
                        win.SetFocus()

                self.SetFocus()
                
                return

        else:
            event.Skip()


    def OnKeyDown2(self, event):
        """
        Deprecated.
        
        Handles the ``wx.EVT_KEY_DOWN`` event for L{AuiTabCtrl}.

        :param `event`: a `wx.KeyEvent` event to be processed.

        :warning: This method implementation is now deprecated. Refer to L{OnKeyDown}
         for the correct one.
        """

        if self.GetActivePage() == -1:
            event.Skip()
            return
    
        # We can't leave tab processing to the system on Windows, tabs and keys
        # get eaten by the system and not processed properly if we specify both
        # wxTAB_TRAVERSAL and wxWANTS_CHARS. And if we specify just wxTAB_TRAVERSAL,
        # we don't key arrow key events.

        key = event.GetKeyCode()

        if key == wx.WXK_NUMPAD_PAGEUP:
            key = wx.WXK_PAGEUP
        if key == wx.WXK_NUMPAD_PAGEDOWN:
            key = wx.WXK_PAGEDOWN
        if key == wx.WXK_NUMPAD_HOME:
            key = wx.WXK_HOME
        if key == wx.WXK_NUMPAD_END:
            key = wx.WXK_END
        if key == wx.WXK_NUMPAD_LEFT:
            key = wx.WXK_LEFT
        if key == wx.WXK_NUMPAD_RIGHT:
            key = wx.WXK_RIGHT

        if key == wx.WXK_TAB or key == wx.WXK_PAGEUP or key == wx.WXK_PAGEDOWN:
        
            bCtrlDown = event.ControlDown()
            bShiftDown = event.ShiftDown()

            bForward = (key == wx.WXK_TAB and not bShiftDown) or (key == wx.WXK_PAGEDOWN)
            bWindowChange = (key == wx.WXK_PAGEUP) or (key == wx.WXK_PAGEDOWN) or bCtrlDown
            bFromTab = (key == wx.WXK_TAB)

            nb = self.GetParent()
            if not nb or not isinstance(nb, AuiNotebook):
                event.Skip()
                return
            
            keyEvent = wx.NavigationKeyEvent()
            keyEvent.SetDirection(bForward)
            keyEvent.SetWindowChange(bWindowChange)
            keyEvent.SetFromTab(bFromTab)
            keyEvent.SetEventObject(nb)

            if not nb.GetEventHandler().ProcessEvent(keyEvent):
            
                # Not processed? Do an explicit tab into the page.
                win = self.GetWindowFromIdx(self.GetActivePage())
                if win:
                    win.SetFocus()
            
            return
        
        if len(self._pages) < 2:
            event.Skip()
            return
        
        newPage = -1

        if self.GetLayoutDirection() == wx.Layout_RightToLeft:
            forwardKey = wx.WXK_LEFT
            backwardKey = wx.WXK_RIGHT
        else:
            forwardKey = wx.WXK_RIGHT
            backwardKey = wx.WXK_LEFT
        
        if key == forwardKey:
            if self.GetActivePage() == -1:
                newPage = 0
            elif self.GetActivePage() < len(self._pages) - 1:
                newPage = self.GetActivePage() + 1
            
        elif key == backwardKey:        
            if self.GetActivePage() == -1:
                newPage = len(self._pages) - 1
            elif self.GetActivePage() > 0:
                newPage = self.GetActivePage() - 1
            
        elif key == wx.WXK_HOME:
            newPage = 0
        
        elif key == wx.WXK_END:
            newPage = len(self._pages) - 1
        
        else:
            event.Skip()

        if newPage != -1:
            e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_PAGE_CHANGING, self.GetId())
            e.SetSelection(newPage)
            e.SetOldSelection(newPage)
            e.SetEventObject(self)
            self.GetEventHandler().ProcessEvent(e)
        
        else:
            event.Skip()


# ----------------------------------------------------------------------

class TabFrame(wx.PyWindow):
    """
    TabFrame is an interesting case. It's important that all child pages
    of the multi-notebook control are all actually children of that control
    (and not grandchildren). TabFrame facilitates this. There is one
    instance of TabFrame for each tab control inside the multi-notebook.
    
    It's important to know that TabFrame is not a real window, but it merely
    used to capture the dimensions/positioning of the internal tab control and
    it's managed page windows.
    """

    def __init__(self, parent):
        """
        Default class constructor.
        Used internally, do not call it in your code!
        """

        pre = wx.PrePyWindow()
        
        self._tabs = None
        self._rect = wx.Rect(0, 0, 200, 200)
        self._tab_ctrl_height = 20
        self._tab_rect = wx.Rect()        
        self._parent = parent
        
        self.PostCreate(pre)
        

    def SetTabCtrlHeight(self, h):
        """
        Sets the tab control height.

        :param `h`: the tab area height.
        """
    
        self._tab_ctrl_height = h


    def DoSetSize(self, x, y, width, height, flags=wx.SIZE_AUTO):
        """        
        Sets the position and size of the window in pixels. The `flags`
        parameter indicates the interpretation of the other params if they are
        equal to -1.

        :param `x`: the window `x` position;
        :param `y`: the window `y` position;
        :param `width`: the window width;
        :param `height`: the window height;
        :param `flags`: may have one of this bit set:
   
         ===================================  ======================================
         Size Flags                           Description
         ===================================  ======================================
         ``wx.SIZE_AUTO``                     A -1 indicates that a class-specific default should be used.
         ``wx.SIZE_AUTO_WIDTH``               A -1 indicates that a class-specific default should be used for the width.
         ``wx.SIZE_AUTO_HEIGHT``              A -1 indicates that a class-specific default should be used for the height.
         ``wx.SIZE_USE_EXISTING``             Existing dimensions should be used if -1 values are supplied.
         ``wx.SIZE_ALLOW_MINUS_ONE``          Allow dimensions of -1 and less to be interpreted as real dimensions, not default values.
         ``wx.SIZE_FORCE``                    Normally, if the position and the size of the window are already the same as the parameters of this function, nothing is done. but with this flag a window resize may be forced even in this case (supported in wx 2.6.2 and later and only implemented for MSW and ignored elsewhere currently) 
         ===================================  ======================================

        :note: Overridden from `wx.PyControl`.
        """

        self._rect = wx.Rect(x, y, max(1, width), max(1, height))
        self.DoSizing()


    def DoGetSize(self):
        """
        Returns the window size.

        :note: Overridden from `wx.PyControl`.        
        """

        return self._rect.width, self._rect.height


    def DoGetClientSize(self):
        """
        Returns the window client size.

        :note: Overridden from `wx.PyControl`.
        """
        
        return self._rect.width, self._rect.height
    

    def Show(self, show=True):
        """
        Shows/hides the window.

        :param `show`: ``True`` to show the window, ``False`` otherwise.        

        :note: Overridden from `wx.PyControl`, this method always returns ``False`` as
         L{TabFrame} should never be phisically shown on screen.
        """
        
        return False


    def DoSizing(self):
        """ Does the actual sizing of the tab control. """
    
        if not self._tabs:
            return

        hideOnSingle = ((self._tabs.GetAGWFlags() & AUI_NB_HIDE_ON_SINGLE_TAB) and \
                        self._tabs.GetPageCount() <= 1)
        
        if not hideOnSingle and not self._parent._hide_tabs:
            tab_height = self._tab_ctrl_height
            
            self._tab_rect = wx.Rect(self._rect.x, self._rect.y, self._rect.width, self._tab_ctrl_height)
            
            if self._tabs.GetAGWFlags() & AUI_NB_BOTTOM:        
                self._tab_rect = wx.Rect(self._rect.x, self._rect.y + self._rect.height - tab_height,
                                         self._rect.width, tab_height)
                self._tabs.SetDimensions(self._rect.x, self._rect.y + self._rect.height - tab_height,
                                         self._rect.width, tab_height)
                self._tabs.SetTabRect(wx.Rect(0, 0, self._rect.width, tab_height))
                
            else:

                self._tab_rect = wx.Rect(self._rect.x, self._rect.y, self._rect.width, tab_height)
                self._tabs.SetDimensions(self._rect.x, self._rect.y, self._rect.width, tab_height)
                self._tabs.SetTabRect(wx.Rect(0, 0, self._rect.width, tab_height))
            
            # TODO: elif (GetAGWFlags() & AUI_NB_LEFT)
            # TODO: elif (GetAGWFlags() & AUI_NB_RIGHT)

            self._tabs.Refresh()
            self._tabs.Update()
            
        else:
            
            tab_height = 0
            self._tabs.SetDimensions(self._rect.x, self._rect.y, self._rect.width, tab_height)
            self._tabs.SetTabRect(wx.Rect(0, 0, self._rect.width, tab_height))
            
        pages = self._tabs.GetPages()

        for page in pages:
        
            height = self._rect.height - tab_height
            
            if height < 0:            
                # avoid passing negative height to wx.Window.SetSize(), this
                # results in assert failures/GTK+ warnings
                height = 0
            
            if self._tabs.GetAGWFlags() & AUI_NB_BOTTOM:
                page.window.SetDimensions(self._rect.x, self._rect.y, self._rect.width, height)
            
            else:
                page.window.SetDimensions(self._rect.x, self._rect.y + tab_height,
                                          self._rect.width, height)
            
            # TODO: elif (GetAGWFlags() & AUI_NB_LEFT)
            # TODO: elif (GetAGWFlags() & AUI_NB_RIGHT)
            
            if repr(page.window.__class__).find("AuiMDIChildFrame") >= 0:
                page.window.ApplyMDIChildFrameRect()            


    def Update(self):
        """
        Calling this method immediately repaints the invalidated area of the window
        and all of its children recursively while this would usually only happen when
        the flow of control returns to the event loop.  

        :note: Notice that this function doesn't invalidate any area of the window so
         nothing happens if nothing has been invalidated (i.e. marked as requiring a redraw).
         Use `Refresh` first if you want to immediately redraw the window unconditionally.   

        :note: Overridden from `wx.PyControl`.
        """

        # does nothing
        pass


# ----------------------------------------------------------------------
# -- AuiNotebook class implementation --

class AuiNotebook(wx.PyPanel):
    """
    AuiNotebook is a notebook control which implements many features common in
    applications with dockable panes. Specifically, AuiNotebook implements functionality
    which allows the user to rearrange tab order via drag-and-drop, split the tab window
    into many different splitter configurations, and toggle through different themes to
    customize the control's look and feel.

    An effort has been made to try to maintain an API as similar to that of `wx.Notebook`.

    The default theme that is used is L{AuiDefaultTabArt}, which provides a modern, glossy
    look and feel. The theme can be changed by calling L{AuiNotebook.SetArtProvider}.
    """

    def __init__(self, parent, id=wx.ID_ANY, pos=wx.DefaultPosition, size=wx.DefaultSize,
                 style=0, agwStyle=AUI_NB_DEFAULT_STYLE):
        """
        Default class constructor.

        :param `parent`: the L{AuiNotebook} parent;
        :param `id`: an identifier for the control: a value of -1 is taken to mean a default;
        :param `pos`: the control position. A value of (-1, -1) indicates a default position,
         chosen by either the windowing system or wxPython, depending on platform;
        :param `size`: the control size. A value of (-1, -1) indicates a default size,
         chosen by either the windowing system or wxPython, depending on platform;
        :param `style`: the underlying `wx.PyPanel` window style;
        :param `agwStyle`: the AGW-specific window style. This can be a combination of the following bits:
        
         ==================================== ==================================
         Flag name                            Description
         ==================================== ==================================
         ``AUI_NB_TOP``                       With this style, tabs are drawn along the top of the notebook
         ``AUI_NB_LEFT``                      With this style, tabs are drawn along the left of the notebook. Not implemented yet.
         ``AUI_NB_RIGHT``                     With this style, tabs are drawn along the right of the notebook. Not implemented yet.
         ``AUI_NB_BOTTOM``                    With this style, tabs are drawn along the bottom of the notebook
         ``AUI_NB_TAB_SPLIT``                 Allows the tab control to be split by dragging a tab
         ``AUI_NB_TAB_MOVE``                  Allows a tab to be moved horizontally by dragging
         ``AUI_NB_TAB_EXTERNAL_MOVE``         Allows a tab to be moved to another tab control
         ``AUI_NB_TAB_FIXED_WIDTH``           With this style, all tabs have the same width
         ``AUI_NB_SCROLL_BUTTONS``            With this style, left and right scroll buttons are displayed
         ``AUI_NB_WINDOWLIST_BUTTON``         With this style, a drop-down list of windows is available
         ``AUI_NB_CLOSE_BUTTON``              With this style, a close button is available on the tab bar
         ``AUI_NB_CLOSE_ON_ACTIVE_TAB``       With this style, a close button is available on the active tab
         ``AUI_NB_CLOSE_ON_ALL_TABS``         With this style, a close button is available on all tabs
         ``AUI_NB_MIDDLE_CLICK_CLOSE``        Allows to close L{AuiNotebook} tabs by mouse middle button click
         ``AUI_NB_SUB_NOTEBOOK``              This style is used by L{AuiManager} to create automatic AuiNotebooks
         ``AUI_NB_HIDE_ON_SINGLE_TAB``        Hides the tab window if only one tab is present
         ``AUI_NB_SMART_TABS``                Use Smart Tabbing, like ``Alt`` + ``Tab`` on Windows
         ``AUI_NB_USE_IMAGES_DROPDOWN``       Uses images on dropdown window list menu instead of check items
         ``AUI_NB_CLOSE_ON_TAB_LEFT``         Draws the tab close button on the left instead of on the right (a la Camino browser)
         ``AUI_NB_TAB_FLOAT``                 Allows the floating of single tabs. Known limitation: when the notebook is more or less full screen, tabs cannot be dragged far enough outside of the notebook to become floating pages
         ``AUI_NB_DRAW_DND_TAB``              Draws an image representation of a tab while dragging (on by default)
         ==================================== ==================================

         Default value for `agwStyle` is:
         ``AUI_NB_DEFAULT_STYLE`` = ``AUI_NB_TOP`` | ``AUI_NB_TAB_SPLIT`` | ``AUI_NB_TAB_MOVE`` | ``AUI_NB_SCROLL_BUTTONS`` | ``AUI_NB_CLOSE_ON_ACTIVE_TAB`` | ``AUI_NB_MIDDLE_CLICK_CLOSE`` | ``AUI_NB_DRAW_DND_TAB``

        """

        self._curpage = -1
        self._tab_id_counter = AuiBaseTabCtrlId
        self._dummy_wnd = None
        self._hide_tabs = False
        self._sash_dclick_unsplit = False
        self._tab_ctrl_height = 20
        self._requested_bmp_size = wx.Size(-1, -1)
        self._requested_tabctrl_height = -1
        self._textCtrl = None
        self._tabBounds = (-1, -1)

        wx.PyPanel.__init__(self, parent, id, pos, size, style|wx.BORDER_NONE|wx.TAB_TRAVERSAL)
        self._mgr = framemanager.AuiManager()
        self._tabs = AuiTabContainer(self)

        self.InitNotebook(agwStyle)


    def GetTabContainer(self):
        """ Returns the instance of L{AuiTabContainer}. """

        return self._tabs

    
    def InitNotebook(self, agwStyle):
        """
        Contains common initialization code called by all constructors.

        :param `agwStyle`: the notebook style.

        :see: L{__init__}
        """

        self.SetName("AuiNotebook")
        self._agwFlags = agwStyle

        self._popupWin = None
        self._naviIcon = None
        self._imageList = None
        self._last_drag_x = 0
        
        self._normal_font = wx.SystemSettings.GetFont(wx.SYS_DEFAULT_GUI_FONT)
        self._selected_font = wx.SystemSettings.GetFont(wx.SYS_DEFAULT_GUI_FONT)
        self._selected_font.SetWeight(wx.BOLD)

        self.SetArtProvider(TA.AuiDefaultTabArt())

        self._dummy_wnd = wx.Window(self, wx.ID_ANY, wx.Point(0, 0), wx.Size(0, 0))
        self._dummy_wnd.SetSize((200, 200))
        self._dummy_wnd.Show(False)

        self._mgr.SetManagedWindow(self)
        self._mgr.SetAGWFlags(AUI_MGR_DEFAULT)
        self._mgr.SetDockSizeConstraint(1.0, 1.0) # no dock size constraint

        self._mgr.AddPane(self._dummy_wnd, framemanager.AuiPaneInfo().Name("dummy").Bottom().CaptionVisible(False).Show(False))
        self._mgr.Update()

        self.Bind(wx.EVT_SIZE, self.OnSize)
        self.Bind(wx.EVT_CHILD_FOCUS, self.OnChildFocusNotebook)
        self.Bind(EVT_AUINOTEBOOK_PAGE_CHANGING, self.OnTabClicked,
                  id=AuiBaseTabCtrlId, id2=AuiBaseTabCtrlId+500)
        self.Bind(EVT_AUINOTEBOOK_BEGIN_DRAG, self.OnTabBeginDrag,
                  id=AuiBaseTabCtrlId, id2=AuiBaseTabCtrlId+500)
        self.Bind(EVT_AUINOTEBOOK_END_DRAG, self.OnTabEndDrag,
                  id=AuiBaseTabCtrlId, id2=AuiBaseTabCtrlId+500)
        self.Bind(EVT_AUINOTEBOOK_DRAG_MOTION, self.OnTabDragMotion,
                  id=AuiBaseTabCtrlId, id2=AuiBaseTabCtrlId+500)
        self.Bind(EVT_AUINOTEBOOK_CANCEL_DRAG, self.OnTabCancelDrag,
                  id=AuiBaseTabCtrlId, id2=AuiBaseTabCtrlId+500)        
        self.Bind(EVT_AUINOTEBOOK_BUTTON, self.OnTabButton,
                  id=AuiBaseTabCtrlId, id2=AuiBaseTabCtrlId+500)
        self.Bind(EVT_AUINOTEBOOK_TAB_MIDDLE_DOWN, self.OnTabMiddleDown,
                  id=AuiBaseTabCtrlId, id2=AuiBaseTabCtrlId+500)
        self.Bind(EVT_AUINOTEBOOK_TAB_MIDDLE_UP, self.OnTabMiddleUp,
                  id=AuiBaseTabCtrlId, id2=AuiBaseTabCtrlId+500)
        self.Bind(EVT_AUINOTEBOOK_TAB_RIGHT_DOWN, self.OnTabRightDown,
                  id=AuiBaseTabCtrlId, id2=AuiBaseTabCtrlId+500)
        self.Bind(EVT_AUINOTEBOOK_TAB_RIGHT_UP, self.OnTabRightUp,
                  id=AuiBaseTabCtrlId, id2=AuiBaseTabCtrlId+500)
        self.Bind(EVT_AUINOTEBOOK_BG_DCLICK, self.OnTabBgDClick,
                  id=AuiBaseTabCtrlId, id2=AuiBaseTabCtrlId+500)
        self.Bind(EVT_AUINOTEBOOK_TAB_DCLICK, self.OnTabDClick,
                  id=AuiBaseTabCtrlId, id2=AuiBaseTabCtrlId+500)

        self.Bind(wx.EVT_NAVIGATION_KEY, self.OnNavigationKeyNotebook)


    def SetArtProvider(self, art):
        """
        Sets the art provider to be used by the notebook.

        :param `art`: an art provider.
        """

        self._tabs.SetArtProvider(art)
        self.UpdateTabCtrlHeight(force=True)


    def SavePerspective(self):
        """
        Saves the entire user interface layout into an encoded string, which can then
        be stored by the application (probably using `wx.Config`). When a perspective
        is restored using L{LoadPerspective}, the entire user interface will return
        to the state it was when the perspective was saved.
        """
        
        # Build list of panes/tabs
        tabs = ""
        all_panes = self._mgr.GetAllPanes()
        
        for pane in all_panes:

            if pane.name == "dummy":
                continue

            tabframe = pane.window
          
            if tabs:
                tabs += "|"
              
            tabs += pane.name + "="
          
            # add tab id's
            page_count = tabframe._tabs.GetPageCount()
          
            for p in xrange(page_count):
          
                page = tabframe._tabs.GetPage(p)
                page_idx = self._tabs.GetIdxFromWindow(page.window)
             
                if p:
                    tabs += ","

                if p == tabframe._tabs.GetActivePage():
                    tabs += "+"
                elif page_idx == self._curpage:
                    tabs += "*"
                    
                tabs += "%u"%page_idx
          
        tabs += "@"

        # Add frame perspective
        tabs += self._mgr.SavePerspective()

        return tabs


    def LoadPerspective(self, layout):
        """
        Loads a layout which was saved with L{SavePerspective}.

        :param `layout`: a string which contains a saved L{AuiNotebook} layout.
        """
        
        # Remove all tab ctrls (but still keep them in main index)
        tab_count = self._tabs.GetPageCount()
        for i in xrange(tab_count):
            wnd = self._tabs.GetWindowFromIdx(i)

            # find out which onscreen tab ctrl owns this tab
            ctrl, ctrl_idx = self.FindTab(wnd)
            if not ctrl:
                return False

            # remove the tab from ctrl
            if not ctrl.RemovePage(wnd):
                return False

        self.RemoveEmptyTabFrames()

        sel_page = 0
        tabs = layout[0:layout.index("@")]
        to_break1 = False
        
        while 1:

            if "|" not in tabs:
                to_break1 = True
                tab_part = tabs
            else:
                tab_part = tabs[0:tabs.index('|')]
          
            if "=" not in tab_part:
                # No pages in this perspective...
                return False

            # Get pane name
            pane_name = tab_part[0:tab_part.index("=")]

            # create a new tab frame
            new_tabs = TabFrame(self)
            self._tab_id_counter += 1
            new_tabs._tabs = AuiTabCtrl(self, self._tab_id_counter)
            new_tabs._tabs.SetArtProvider(self._tabs.GetArtProvider().Clone())
            new_tabs.SetTabCtrlHeight(self._tab_ctrl_height)
            new_tabs._tabs.SetAGWFlags(self._agwFlags)
            dest_tabs = new_tabs._tabs

            # create a pane info structure with the information
            # about where the pane should be added
            pane_info = framemanager.AuiPaneInfo().Name(pane_name).Bottom().CaptionVisible(False)
            self._mgr.AddPane(new_tabs, pane_info)

            # Get list of tab id's and move them to pane
            tab_list = tab_part[tab_part.index("=")+1:]
            to_break2, active_found = False, False
            
            while 1:
                if "," not in tab_list:
                    to_break2 = True
                    tab = tab_list
                else:
                    tab = tab_list[0:tab_list.index(",")]                
                    tab_list = tab_list[tab_list.index(",")+1:]

                # Check if this page has an 'active' marker
                c = tab[0]
                if c in ['+', '*']:
                    tab = tab[1:]

                tab_idx = int(tab)
                if tab_idx >= self.GetPageCount():
                    continue

                # Move tab to pane
                page = self._tabs.GetPage(tab_idx)
                newpage_idx = dest_tabs.GetPageCount()
                dest_tabs.InsertPage(page.window, page, newpage_idx)

                if c == '+':
                    dest_tabs.SetActivePage(newpage_idx)
                    active_found = True
                elif c == '*':
                    sel_page = tab_idx

                if to_break2:
                    break

            if not active_found:
                dest_tabs.SetActivePage(0)

            new_tabs.DoSizing()
            dest_tabs.DoShowHide()
            dest_tabs.Refresh()
        
            if to_break1:
                break
            
            tabs = tabs[tabs.index('|')+1:]

        # Load the frame perspective
        frames = layout[layout.index('@')+1:]
        self._mgr.LoadPerspective(frames)

        # Force refresh of selection
        self._curpage = -1
        self.SetSelection(sel_page)

        return True


    def SetTabCtrlHeight(self, height):
        """
        Sets the tab height.

        By default, the tab control height is calculated by measuring the text
        height and bitmap sizes on the tab captions.
        
        Calling this method will override that calculation and set the tab control
        to the specified height parameter. A call to this method will override
        any call to L{SetUniformBitmapSize}. Specifying -1 as the height will
        return the control to its default auto-sizing behaviour.

        :param `height`: the tab control area height.
        """
        
        self._requested_tabctrl_height = height

        # if window is already initialized, recalculate the tab height
        if self._dummy_wnd:
            self.UpdateTabCtrlHeight()
        

    def SetUniformBitmapSize(self, size):
        """
        Ensures that all tabs will have the same height, even if some tabs
        don't have bitmaps. Passing ``wx.DefaultSize`` to this
        function will instruct the control to use dynamic tab height, which is
        the default behaviour. Under the default behaviour, when a tab with a
        large bitmap is added, the tab control's height will automatically
        increase to accommodate the larger bitmap.

        :param `size`: an instance of `wx.Size` specifying the tab bitmap size.        
        """

        self._requested_bmp_size = wx.Size(*size)

        # if window is already initialized, recalculate the tab height
        if self._dummy_wnd:
            self.UpdateTabCtrlHeight()
    

    def UpdateTabCtrlHeight(self, force=False):
        """
        UpdateTabCtrlHeight() does the actual tab resizing. It's meant
        to be used interally.

        :param `force`: ``True`` to force the tab art to repaint.
        """

        # get the tab ctrl height we will use
        height = self.CalculateTabCtrlHeight()

        # if the tab control height needs to change, update
        # all of our tab controls with the new height
        if self._tab_ctrl_height != height or force:
            art = self._tabs.GetArtProvider()

            self._tab_ctrl_height = height

            all_panes = self._mgr.GetAllPanes()
            for pane in all_panes:
    
                if pane.name == "dummy":
                    continue
                
                tab_frame = pane.window
                tabctrl = tab_frame._tabs
                tab_frame.SetTabCtrlHeight(self._tab_ctrl_height)
                tabctrl.SetArtProvider(art.Clone())
                tab_frame.DoSizing()
            

    def UpdateHintWindowSize(self):
        """ Updates the L{AuiManager} hint window size. """

        size = self.CalculateNewSplitSize()

        # the placeholder hint window should be set to this size
        info = self._mgr.GetPane("dummy")
        
        if info.IsOk():        
            info.MinSize(size)
            info.BestSize(size)
            self._dummy_wnd.SetSize(size)
        

    def CalculateNewSplitSize(self):
        """ Calculates the size of the new split. """

        # count number of tab controls
        tab_ctrl_count = 0
        all_panes = self._mgr.GetAllPanes()

        for pane in all_panes:                
            if pane.name == "dummy":
                continue
            
            tab_ctrl_count += 1
        
        # if there is only one tab control, the first split
        # should happen around the middle
        if tab_ctrl_count < 2:
            new_split_size = self.GetClientSize()
            new_split_size.x /= 2
            new_split_size.y /= 2
        
        else:
        
            # this is in place of a more complicated calculation
            # that needs to be implemented
            new_split_size = wx.Size(180, 180)
        
        return new_split_size


    def CalculateTabCtrlHeight(self):
        """ Calculates the tab control area height. """

        # if a fixed tab ctrl height is specified,
        # just return that instead of calculating a
        # tab height
        if self._requested_tabctrl_height != -1:
            return self._requested_tabctrl_height

        # find out new best tab height
        art = self._tabs.GetArtProvider()

        return art.GetBestTabCtrlSize(self, self._tabs.GetPages(), self._requested_bmp_size)


    def GetArtProvider(self):
        """ Returns the associated art provider. """

        return self._tabs.GetArtProvider()


    def SetAGWWindowStyleFlag(self, agwStyle):
        """
        Sets the AGW-specific style of the window.
        
        :param `agwStyle`: the new window style. This can be a combination of the following bits:
        
         ==================================== ==================================
         Flag name                            Description
         ==================================== ==================================
         ``AUI_NB_TOP``                       With this style, tabs are drawn along the top of the notebook
         ``AUI_NB_LEFT``                      With this style, tabs are drawn along the left of the notebook. Not implemented yet.
         ``AUI_NB_RIGHT``                     With this style, tabs are drawn along the right of the notebook. Not implemented yet.
         ``AUI_NB_BOTTOM``                    With this style, tabs are drawn along the bottom of the notebook
         ``AUI_NB_TAB_SPLIT``                 Allows the tab control to be split by dragging a tab
         ``AUI_NB_TAB_MOVE``                  Allows a tab to be moved horizontally by dragging
         ``AUI_NB_TAB_EXTERNAL_MOVE``         Allows a tab to be moved to another tab control
         ``AUI_NB_TAB_FIXED_WIDTH``           With this style, all tabs have the same width
         ``AUI_NB_SCROLL_BUTTONS``            With this style, left and right scroll buttons are displayed
         ``AUI_NB_WINDOWLIST_BUTTON``         With this style, a drop-down list of windows is available
         ``AUI_NB_CLOSE_BUTTON``              With this style, a close button is available on the tab bar
         ``AUI_NB_CLOSE_ON_ACTIVE_TAB``       With this style, a close button is available on the active tab
         ``AUI_NB_CLOSE_ON_ALL_TABS``         With this style, a close button is available on all tabs
         ``AUI_NB_MIDDLE_CLICK_CLOSE``        Allows to close L{AuiNotebook} tabs by mouse middle button click
         ``AUI_NB_SUB_NOTEBOOK``              This style is used by L{AuiManager} to create automatic AuiNotebooks
         ``AUI_NB_HIDE_ON_SINGLE_TAB``        Hides the tab window if only one tab is present
         ``AUI_NB_SMART_TABS``                Use Smart Tabbing, like ``Alt`` + ``Tab`` on Windows
         ``AUI_NB_USE_IMAGES_DROPDOWN``       Uses images on dropdown window list menu instead of check items
         ``AUI_NB_CLOSE_ON_TAB_LEFT``         Draws the tab close button on the left instead of on the right (a la Camino browser)
         ``AUI_NB_TAB_FLOAT``                 Allows the floating of single tabs. Known limitation: when the notebook is more or less full screen, tabs cannot be dragged far enough outside of the notebook to become floating pages
         ``AUI_NB_DRAW_DND_TAB``              Draws an image representation of a tab while dragging (on by default)
         ==================================== ==================================

        :note: Please note that some styles cannot be changed after the window
         creation and that `Refresh` might need to be be called after changing the
         others for the change to take place immediately.

        :todo: Implementation of flags ``AUI_NB_RIGHT`` and ``AUI_NB_LEFT``.
        """

        self._agwFlags = agwStyle

        # if the control is already initialized
        if self._mgr.GetManagedWindow() == self:
        
            # let all of the tab children know about the new style

            all_panes = self._mgr.GetAllPanes()
            for pane in all_panes:
                if pane.name == "dummy":
                    continue

                tabframe = pane.window
                tabctrl = tabframe._tabs
                tabctrl.SetAGWFlags(self._agwFlags)
                tabframe.DoSizing()
                tabctrl.Refresh()
                tabctrl.Update()


    def GetAGWWindowStyleFlag(self):
        """
        Returns the AGW-specific style of the window.

        :see: L{SetAGWWindowStyleFlag} for a list of possible AGW-specific window styles.
        """

        return self._agwFlags
        

    def AddPage(self, page, caption, select=False, bitmap=wx.NullBitmap, disabled_bitmap=wx.NullBitmap, control=None):
        """
        Adds a page. If the `select` parameter is ``True``, calling this will generate a
        page change event.

        :param `page`: the page to be added;
        :param `caption`: specifies the text for the new page;
        :param `select`: specifies whether the page should be selected;
        :param `bitmap`: the `wx.Bitmap` to display in the enabled tab;
        :param `disabled_bitmap`: the `wx.Bitmap` to display in the disabled tab;
        :param `control`: a `wx.Window` instance inside a tab (or ``None``).
        """

        return self.InsertPage(self.GetPageCount(), page, caption, select, bitmap, disabled_bitmap, control)


    def InsertPage(self, page_idx, page, caption, select=False, bitmap=wx.NullBitmap, disabled_bitmap=wx.NullBitmap,
                   control=None):
        """
        This is similar to L{AddPage}, but allows the ability to specify the insert location.

        :param `page_idx`: specifies the position for the new page;
        :param `page`: the page to be added;
        :param `caption`: specifies the text for the new page;
        :param `select`: specifies whether the page should be selected;
        :param `bitmap`: the `wx.Bitmap` to display in the enabled tab;
        :param `disabled_bitmap`: the `wx.Bitmap` to display in the disabled tab;
        :param `control`: a `wx.Window` instance inside a tab (or ``None``).
        """
        
        if not page:
            return False

        page.Reparent(self)
        info = AuiNotebookPage()
        info.window = page
        info.caption = caption
        info.bitmap = bitmap
        info.active = False
        info.control = control

        originalPaneMgr = framemanager.GetManager(page)
        if originalPaneMgr:
            originalPane = originalPaneMgr.GetPane(page)
            
            if originalPane:
                info.hasCloseButton = originalPane.HasCloseButton()
        
        if bitmap.IsOk() and not disabled_bitmap.IsOk():
            disabled_bitmap = MakeDisabledBitmap(bitmap)
            info.dis_bitmap = disabled_bitmap

        # if there are currently no tabs, the first added
        # tab must be active
        if self._tabs.GetPageCount() == 0:
            info.active = True
            
        self._tabs.InsertPage(page, info, page_idx)

        # if that was the first page added, even if
        # select is False, it must become the "current page"
        # (though no select events will be fired)
        if not select and self._tabs.GetPageCount() == 1:
            select = True

        active_tabctrl = self.GetActiveTabCtrl()
        if page_idx >= active_tabctrl.GetPageCount():
            active_tabctrl.AddPage(page, info)
        else:
            active_tabctrl.InsertPage(page, info, page_idx)

        force = False
        if control:
            force = True
            control.Reparent(active_tabctrl)
            control.Show()
            
        self.UpdateTabCtrlHeight(force=force)
        self.DoSizing()
        active_tabctrl.DoShowHide()

        # adjust selected index
        if self._curpage >= page_idx:
            self._curpage += 1

        if select:
            self.SetSelectionToWindow(page)

        return True


    def DeletePage(self, page_idx):
        """
        Deletes a page at the given index. Calling this method will generate a page
        change event.

        :param `page_idx`: the page index to be deleted.

        :note: L{DeletePage} removes a tab from the multi-notebook, and destroys the window as well.

        :see: L{RemovePage}
        """
        
        if page_idx >= self._tabs.GetPageCount():
            return False

        wnd = self._tabs.GetWindowFromIdx(page_idx)
        # hide the window in advance, as this will
        # prevent flicker
        wnd.Show(False)

        self.RemoveControlFromPage(page_idx)

        if not self.RemovePage(page_idx):
            return False

        wnd.Destroy()
        
        return True


    def RemovePage(self, page_idx):
        """
        Removes a page, without deleting the window pointer.

        :param `page_idx`: the page index to be removed.

        :note: L{RemovePage} removes a tab from the multi-notebook, but does not destroy the window.
        
        :see: L{DeletePage}
        """
        
        # save active window pointer
        active_wnd = None
        if self._curpage >= 0:
            active_wnd = self._tabs.GetWindowFromIdx(self._curpage)

        # save pointer of window being deleted
        wnd = self._tabs.GetWindowFromIdx(page_idx)
        new_active = None

        # make sure we found the page
        if not wnd:
            return False

        # find out which onscreen tab ctrl owns this tab
        ctrl, ctrl_idx = self.FindTab(wnd)
        if not ctrl:
            return False

        currentPage = ctrl.GetPage(ctrl_idx)
        is_curpage = (self._curpage == page_idx)
        is_active_in_split = currentPage.active
        
        # remove the tab from main catalog
        if not self._tabs.RemovePage(wnd):
            return False

        # remove the tab from the onscreen tab ctrl
        ctrl.RemovePage(wnd)

        if is_active_in_split:
        
            ctrl_new_page_count = ctrl.GetPageCount()

            if ctrl_idx >= ctrl_new_page_count:
                ctrl_idx = ctrl_new_page_count - 1

            if ctrl_idx >= 0 and ctrl_idx < ctrl.GetPageCount():

                ctrl_idx = self.FindNextActiveTab(ctrl_idx, ctrl)
                
                # set new page as active in the tab split
                ctrl.SetActivePage(ctrl_idx)

                # if the page deleted was the current page for the
                # entire tab control, then record the window
                # pointer of the new active page for activation
                if is_curpage:
                    new_active = ctrl.GetWindowFromIdx(ctrl_idx)
                
        else:
        
            # we are not deleting the active page, so keep it the same
            new_active = active_wnd
        
        if not new_active:
        
            # we haven't yet found a new page to active,
            # so select the next page from the main tab
            # catalogue

            if 0 <= page_idx < self._tabs.GetPageCount():
                new_active = self._tabs.GetPage(page_idx).window
            if not new_active and self._tabs.GetPageCount() > 0:
                new_active = self._tabs.GetPage(0).window
            
        self.RemoveEmptyTabFrames()

        # set new active pane
        if new_active:
            if not self.IsBeingDeleted():
                self._curpage = -1
                self.SetSelectionToWindow(new_active)
        else:
            self._curpage = -1
            self._tabs.SetNoneActive()

        return True


    def FindNextActiveTab(self, ctrl_idx, ctrl):
        """
        Finds the next active tab (used mainly when L{AuiNotebook} has inactive/disabled
        tabs in it).

        :param `ctrl_idx`: the index of the first (most obvious) tab to check for active status;
        :param `ctrl`: an instance of L{AuiTabCtrl}.
        """

        if self.GetEnabled(ctrl_idx):
            return ctrl_idx

        for indx in xrange(ctrl_idx, ctrl.GetPageCount()):
            if self.GetEnabled(indx):
                return indx

        for indx in xrange(ctrl_idx, -1, -1):
            if self.GetEnabled(indx):
                return indx

        return 0
    

    def HideAllTabs(self, hidden=True):
        """
        Hides all tabs on the L{AuiNotebook} control.
        
        :param `hidden`: if ``True`` hides all tabs.
        """

        self._hide_tabs = hidden


    def SetSashDClickUnsplit(self, unsplit=True):
        """
        Sets whether to unsplit a splitted L{AuiNotebook} when double-clicking on a sash.

        :param `unsplit`: ``True`` to unsplit on sash double-clicking, ``False`` otherwise.
        """

        self._sash_dclick_unsplit = unsplit


    def GetSashDClickUnsplit(self):
        """
        Returns whether a splitted L{AuiNotebook} can be unsplitted by double-clicking
        on the splitter sash.
        """

        return self._sash_dclick_unsplit
    

    def SetMinMaxTabWidth(self, minTabWidth, maxTabWidth):
        """
        Sets the minimum and/or the maximum tab widths for L{AuiNotebook} when the
        ``AUI_NB_TAB_FIXED_WIDTH`` style is defined.

        Pass -1 to either `minTabWidth` or `maxTabWidth` to reset to the default tab
        width behaviour for L{AuiNotebook}.

        :param `minTabWidth`: the minimum allowed tab width, in pixels;
        :param `maxTabWidth`: the maximum allowed tab width, in pixels.

        :note: Minimum and maximum tabs widths are used only when the ``AUI_NB_TAB_FIXED_WIDTH``
         style is present.
        """

        if minTabWidth > maxTabWidth:
            raise Exception("Minimum tab width must be less or equal than maximum tab width")

        self._tabBounds = (minTabWidth, maxTabWidth)
        self.SetAGWWindowStyleFlag(self._agwFlags)


    def GetMinMaxTabWidth(self):
        """
        Returns the minimum and the maximum tab widths for L{AuiNotebook} when the
        ``AUI_NB_TAB_FIXED_WIDTH`` style is defined.

        :note: Minimum and maximum tabs widths are used only when the ``AUI_NB_TAB_FIXED_WIDTH``
         style is present.

        :see: L{SetMinMaxTabWidth} for more information.         
        """

        return self._tabBounds
    

    def GetPageIndex(self, page_wnd):
        """
        Returns the page index for the specified window. If the window is not
        found in the notebook, ``wx.NOT_FOUND`` is returned.
        """

        return self._tabs.GetIdxFromWindow(page_wnd)


    def SetPageText(self, page_idx, text):
        """
        Sets the tab label for the page.

        :param `page_idx`: the page index;
        :param `text`: the new tab label.
        """

        if page_idx >= self._tabs.GetPageCount():
            return False

        # update our own tab catalog
        page_info = self._tabs.GetPage(page_idx)
        page_info.caption = text

        # update what's on screen
        ctrl, ctrl_idx = self.FindTab(page_info.window)
        if not ctrl:
            return False
        
        info = ctrl.GetPage(ctrl_idx)
        info.caption = text
        ctrl.Refresh()
        ctrl.Update()

        self.UpdateTabCtrlHeight(force=True)
    
        return True


    def GetPageText(self, page_idx):
        """
        Returns the tab label for the page.

        :param `page_idx`: the page index.
        """
        
        if page_idx >= self._tabs.GetPageCount():
            return ""

        # update our own tab catalog
        page_info = self._tabs.GetPage(page_idx)
        return page_info.caption


    def SetPageBitmap(self, page_idx, bitmap):
        """
        Sets the tab bitmap for the page.

        :param `page_idx`: the page index;
        :param `bitmap`: an instance of `wx.Bitmap`.
        """
        
        if page_idx >= self._tabs.GetPageCount():
            return False

        # update our own tab catalog
        page_info = self._tabs.GetPage(page_idx)
        page_info.bitmap = bitmap
        if bitmap.IsOk() and not page_info.dis_bitmap.IsOk():
            page_info.dis_bitmap = MakeDisabledBitmap(bitmap)

        # tab height might have changed
        self.UpdateTabCtrlHeight()

        # update what's on screen
        ctrl, ctrl_idx = self.FindTab(page_info.window)
        if not ctrl:
            return False
        
        info = ctrl.GetPage(ctrl_idx)
        info.bitmap = bitmap
        info.dis_bitmap = page_info.dis_bitmap
        ctrl.Refresh()
        ctrl.Update()
        
        return True


    def GetPageBitmap(self, page_idx):
        """
        Returns the tab bitmap for the page.

        :param `page_idx`: the page index.
        """
        
        if page_idx >= self._tabs.GetPageCount():
            return wx.NullBitmap

        # update our own tab catalog
        page_info = self._tabs.GetPage(page_idx)
        return page_info.bitmap


    def SetImageList(self, imageList):
        """
        Sets the image list for the L{AuiNotebook} control.

        :param `imageList`: an instance of `wx.ImageList`.
        """

        self._imageList = imageList        
                

    def AssignImageList(self, imageList):
        """
        Sets the image list for the L{AuiNotebook} control.

        :param `imageList`: an instance of `wx.ImageList`.
        """

        self.SetImageList(imageList)


    def GetImageList(self):
        """ Returns the associated image list (if any). """

        return self._imageList        


    def SetPageImage(self, page, image):
        """
        Sets the image index for the given page.

        :param `page`: the page index;
        :param `image`: an index into the image list which was set with L{SetImageList}.
        """
        
        if page >= self._tabs.GetPageCount():
            return False

        if not isinstance(image, types.IntType):
            raise Exception("The image parameter must be an integer, you passed " \
                            "%s"%repr(image))
        
        if not self._imageList:
            raise Exception("To use SetPageImage you need to associate an image list " \
                            "Using SetImageList or AssignImageList")

        if image >= self._imageList.GetImageCount():
            raise Exception("Invalid image index (%d), the image list contains only" \
                            " (%d) bitmaps"%(image, self._imageList.GetImageCount()))

        if image == -1:
            self.SetPageBitmap(page, wx.NullBitmap)
            return
        
        bitmap = self._imageList.GetBitmap(image)
        self.SetPageBitmap(page, bitmap)


    def GetPageImage(self, page):
        """
        Returns the image index for the given page.

        :param `page`: the given page for which to retrieve the image index.
        """

        if page >= self._tabs.GetPageCount():
            return False

        bitmap = self.GetPageBitmap(page)
        for indx in xrange(self._imageList.GetImageCount()):
            imgListBmp = self._imageList.GetBitmap(indx)
            if imgListBmp == bitmap:
                return indx

        return wx.NOT_FOUND


    def SetPageTextColour(self, page_idx, colour):
        """
        Sets the tab text colour for the page.

        :param `page_idx`: the page index;
        :param `colour`: an instance of `wx.Colour`.
        """
        
        if page_idx >= self._tabs.GetPageCount():
            return False

        # update our own tab catalog
        page_info = self._tabs.GetPage(page_idx)
        page_info.text_colour = colour

        # update what's on screen
        ctrl, ctrl_idx = self.FindTab(page_info.window)
        if not ctrl:
            return False
        
        info = ctrl.GetPage(ctrl_idx)
        info.text_colour = page_info.text_colour
        ctrl.Refresh()
        ctrl.Update()
        
        return True


    def GetPageTextColour(self, page_idx):
        """
        Returns the tab text colour for the page.

        :param `page_idx`: the page index.
        """
        
        if page_idx >= self._tabs.GetPageCount():
            return wx.NullColour

        # update our own tab catalog
        page_info = self._tabs.GetPage(page_idx)
        return page_info.text_colour


    def AddControlToPage(self, page_idx, control):
        """
        Adds a control inside a tab (not in the tab area).

        :param `page_idx`: the page index;
        :param `control`: an instance of `wx.Window`.
        """

        if page_idx >= self._tabs.GetPageCount():
            return False

        # update our own tab catalog
        page_info = self._tabs.GetPage(page_idx)
        page_info.control = control

        # tab height might have changed
        self.UpdateTabCtrlHeight(force=True)

        # update what's on screen
        ctrl, ctrl_idx = self.FindTab(page_info.window)
        if not ctrl:
            return False

        control.Reparent(ctrl)
        
        info = ctrl.GetPage(ctrl_idx)
        info.control = control
        ctrl.Refresh()
        ctrl.Update()
        
        return True
        

    def RemoveControlFromPage(self, page_idx):
        """
        Removes a control from a tab (not from the tab area).

        :param `page_idx`: the page index.
        """

        if page_idx >= self._tabs.GetPageCount():
            return False

        page_info = self._tabs.GetPage(page_idx)
        if page_info.control is None:
            return False

        page_info.control.Destroy()        
        page_info.control = None

        # tab height might have changed
        self.UpdateTabCtrlHeight(force=True)

        # update what's on screen
        ctrl, ctrl_idx = self.FindTab(page_info.window)
        if not ctrl:
            return False
        
        info = ctrl.GetPage(ctrl_idx)
        info.control = None
        ctrl.Refresh()
        ctrl.Update()
        
        return True
        

    def SetCloseButton(self, page_idx, hasCloseButton):
        """
        Sets whether a tab should display a close button or not.
        
        :param `page_idx`: the page index;
        :param `hasCloseButton`: ``True`` if the page displays a close button.

        :note: This can only be called if ``AUI_NB_CLOSE_ON_ALL_TABS`` is specified.
        """

        if page_idx >= self._tabs.GetPageCount():
            return False

        if self._agwFlags & AUI_NB_CLOSE_ON_ALL_TABS == 0:
            raise Exception("SetCloseButton can only be used with AUI_NB_CLOSE_ON_ALL_TABS style.")
        
        # update our own tab catalog
        page_info = self._tabs.GetPage(page_idx)
        page_info.hasCloseButton = hasCloseButton

        # update what's on screen
        ctrl, ctrl_idx = self.FindTab(page_info.window)
        if not ctrl:
            return False
        
        info = ctrl.GetPage(ctrl_idx)
        info.hasCloseButton = page_info.hasCloseButton
        ctrl.Refresh()
        ctrl.Update()
        
        return True
        

    def HasCloseButton(self, page_idx):
        """
        Returns whether a tab displays a close button or not.
        
        :param `page_idx`: the page index.

        :note: This can only be called if ``AUI_NB_CLOSE_ON_ALL_TABS`` is specified.
        """

        if page_idx >= self._tabs.GetPageCount():
            return False

        page_info = self._tabs.GetPage(page_idx)
        return page_info.hasCloseButton

        
    def GetSelection(self):
        """ Returns the index of the currently active page, or -1 if none was selected. """
        
        return self._curpage


    def GetCurrentPage(self):
        """ Returns the currently active page (not the index), or ``None`` if none was selected. """

        if self._curpage >= 0 and self._curpage < self._tabs.GetPageCount():
            return self.GetPage(self._curpage)

        return None
    

    def EnsureVisible(self, indx):
        """
        Ensures the input page index `indx` is visible.
        
        :param `indx`: the page index.
        """

        self._tabs.MakeTabVisible(indx, self)
        

    def SetSelection(self, new_page, force=False):
        """
        Sets the page selection. Calling this method will generate a page change event.

        :param `new_page`: the index of the new selection;
        :param `force`: whether to force the selection or not.
        """
        wnd = self._tabs.GetWindowFromIdx(new_page)
        
        #Update page access time
        self._tabs.GetPages()[new_page].access_time = datetime.datetime.now()
        
        if not wnd or not self.GetEnabled(new_page):
            return self._curpage

        # don't change the page unless necessary
        # however, clicking again on a tab should give it the focus.
        if new_page == self._curpage and not force:
        
            ctrl, ctrl_idx = self.FindTab(wnd)
            if wx.Window.FindFocus() != ctrl:
                ctrl.SetFocus()
            
            return self._curpage
        
        evt = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_PAGE_CHANGING, self.GetId())
        evt.SetSelection(new_page)
        evt.SetOldSelection(self._curpage)
        evt.SetEventObject(self)

        if not self.GetEventHandler().ProcessEvent(evt) or evt.IsAllowed():
        
            old_curpage = self._curpage
            self._curpage = new_page

            # program allows the page change
            evt.SetEventType(wxEVT_COMMAND_AUINOTEBOOK_PAGE_CHANGED)
            self.GetEventHandler().ProcessEvent(evt)

            if not evt.IsAllowed(): # event is no longer allowed after handler
                return self._curpage
        
            ctrl, ctrl_idx = self.FindTab(wnd)
            
            if ctrl:
                self._tabs.SetActivePage(wnd)
                ctrl.SetActivePage(ctrl_idx)
                self.DoSizing()
                ctrl.DoShowHide()
                ctrl.MakeTabVisible(ctrl_idx, ctrl)

                # set fonts
                all_panes = self._mgr.GetAllPanes()
                for pane in all_panes:
                    if pane.name == "dummy":
                        continue
                    
                    tabctrl = pane.window._tabs
                    if tabctrl != ctrl:
                        tabctrl.SetSelectedFont(self._normal_font)
                    else:
                        tabctrl.SetSelectedFont(self._selected_font)
                        
                    tabctrl.Refresh()
                    tabctrl.Update()
                
                # Set the focus to the page if we're not currently focused on the tab.
                # This is Firefox-like behaviour.
                if wnd.IsShownOnScreen() and wx.Window.FindFocus() != ctrl:
                    wnd.SetFocus()

                return old_curpage
            
        return self._curpage


    def SetSelectionToWindow(self, win):
        """
        Sets the selection based on the input window `win`.

        :param `win`: a `wx.Window` derived window.
        """

        idx = self._tabs.GetIdxFromWindow(win)
        
        if idx == wx.NOT_FOUND:
            raise Exception("invalid notebook page")

        if not self.GetEnabled(idx):
            return
        
        # since a tab was clicked, let the parent know that we received
        # the focus, even if we will assign that focus immediately
        # to the child tab in the SetSelection call below
        # (the child focus event will also let AuiManager, if any,
        # know that the notebook control has been activated)

        parent = self.GetParent()
        if parent:
            eventFocus = wx.ChildFocusEvent(self)
            parent.GetEventHandler().ProcessEvent(eventFocus)

        self.SetSelection(idx)


    def SetSelectionToPage(self, page):
        """
        Sets the selection based on the input page.

        :param `page`: an instance of L{AuiNotebookPage}.
        """
        
        self.SetSelectionToWindow(page.window)


    def GetPageCount(self):
        """ Returns the number of pages in the notebook. """

        return self._tabs.GetPageCount()


    def GetPage(self, page_idx):
        """
        Returns the page specified by the given index.

        :param `page_idx`: the page index.
        """

        if page_idx >= self._tabs.GetPageCount():
            raise Exception("invalid notebook page")

        return self._tabs.GetWindowFromIdx(page_idx)


    def GetPageInfo(self, page_idx):
        """
        Returns the L{AuiNotebookPage} info structure specified by the given index.

        :param `page_idx`: the page index.
        """

        if page_idx >= self._tabs.GetPageCount():
            raise Exception("invalid notebook page")

        return self._tabs.GetPage(page_idx)
        

    def GetEnabled(self, page_idx):
        """
        Returns whether the page specified by the index `page_idx` is enabled.

        :param `page_idx`: the page index.
        """
        
        return self._tabs.GetEnabled(page_idx)


    def EnableTab(self, page_idx, enable=True):
        """
        Enables/disables a page in the notebook.

        :param `page_idx`: the page index;
        :param `enable`: ``True`` to enable the page, ``False`` to disable it.
        """

        self._tabs.EnableTab(page_idx, enable)
        self.Refresh()

    
    def DoSizing(self):
        """ Performs all sizing operations in each tab control. """

        all_panes = self._mgr.GetAllPanes()
        for pane in all_panes:
            if pane.name == "dummy":
                continue

            tabframe = pane.window
            tabframe.DoSizing()
        

    def GetAuiManager(self):
        """ Returns the associated L{AuiManager}. """

        return self._mgr
    

    def GetActiveTabCtrl(self):
        """
        Returns the active tab control. It is called to determine which control
        gets new windows being added.
        """

        if self._curpage >= 0 and self._curpage < self._tabs.GetPageCount():

            # find the tab ctrl with the current page
            ctrl, idx = self.FindTab(self._tabs.GetPage(self._curpage).window)
            if ctrl:            
                return ctrl
        
        # no current page, just find the first tab ctrl
        all_panes = self._mgr.GetAllPanes()
        for pane in all_panes:
            if pane.name == "dummy":
                continue

            tabframe = pane.window
            return tabframe._tabs
        
        # If there is no tabframe at all, create one
        tabframe = TabFrame(self)
        tabframe.SetTabCtrlHeight(self._tab_ctrl_height)
        self._tab_id_counter += 1
        tabframe._tabs = AuiTabCtrl(self, self._tab_id_counter)
        
        tabframe._tabs.SetAGWFlags(self._agwFlags)
        tabframe._tabs.SetArtProvider(self._tabs.GetArtProvider().Clone())
        self._mgr.AddPane(tabframe, framemanager.AuiPaneInfo().Center().CaptionVisible(False).
                          PaneBorder((self._agwFlags & AUI_NB_SUB_NOTEBOOK) == 0))

        self._mgr.Update()

        return tabframe._tabs


    def FindTab(self, page):
        """
        Finds the tab control that currently contains the window as well
        as the index of the window in the tab control. It returns ``True`` if the
        window was found, otherwise ``False``.

        :param `page`: an instance of L{AuiNotebookPage}.        
        """

        all_panes = self._mgr.GetAllPanes()
        for pane in all_panes:
            if pane.name == "dummy":
                continue

            tabframe = pane.window

            page_idx = tabframe._tabs.GetIdxFromWindow(page)
            
            if page_idx != -1:
            
                ctrl = tabframe._tabs
                idx = page_idx
                return ctrl, idx
            
        return None, wx.NOT_FOUND


    def Split(self, page, direction):
        """
        Performs a split operation programmatically.

        :param `page`: indicates the page that will be split off. This page will also become
         the active page after the split.
        :param `direction`: specifies where the pane should go, it should be one of the
         following: ``wx.TOP``, ``wx.BOTTOM``, ``wx.LEFT``, or ``wx.RIGHT``.
        """
        
        cli_size = self.GetClientSize()

        # get the page's window pointer
        wnd = self.GetPage(page)
        if not wnd:
            return

        # notebooks with 1 or less pages can't be split
        if self.GetPageCount() < 2:
            return

        # find out which tab control the page currently belongs to

        src_tabs, src_idx = self.FindTab(wnd)
        if not src_tabs:
            return
        
        # choose a split size
        if self.GetPageCount() > 2:
            split_size = self.CalculateNewSplitSize()
        else:        
            # because there are two panes, always split them
            # equally
            split_size = self.GetClientSize()
            split_size.x /= 2
            split_size.y /= 2

        # create a new tab frame
        new_tabs = TabFrame(self)
        new_tabs._rect = wx.RectPS(wx.Point(0, 0), split_size)
        new_tabs.SetTabCtrlHeight(self._tab_ctrl_height)
        self._tab_id_counter += 1
        new_tabs._tabs = AuiTabCtrl(self, self._tab_id_counter)
        
        new_tabs._tabs.SetArtProvider(self._tabs.GetArtProvider().Clone())
        new_tabs._tabs.SetAGWFlags(self._agwFlags)
        dest_tabs = new_tabs._tabs

        page_info = src_tabs.GetPage(src_idx)
        if page_info.control:
            self.ReparentControl(page_info.control, dest_tabs)
        
        # create a pane info structure with the information
        # about where the pane should be added
        pane_info = framemanager.AuiPaneInfo().Bottom().CaptionVisible(False)

        if direction == wx.LEFT:
        
            pane_info.Left()
            mouse_pt = wx.Point(0, cli_size.y/2)
        
        elif direction == wx.RIGHT:
        
            pane_info.Right()
            mouse_pt = wx.Point(cli_size.x, cli_size.y/2)
        
        elif direction == wx.TOP:
        
            pane_info.Top()
            mouse_pt = wx.Point(cli_size.x/2, 0)
        
        elif direction == wx.BOTTOM:
        
            pane_info.Bottom()
            mouse_pt = wx.Point(cli_size.x/2, cli_size.y)
        
        self._mgr.AddPane(new_tabs, pane_info, mouse_pt)
        self._mgr.Update()

        # remove the page from the source tabs
        page_info.active = False
        
        src_tabs.RemovePage(page_info.window)
        
        if src_tabs.GetPageCount() > 0:
            src_tabs.SetActivePage(0)
            src_tabs.DoShowHide()
            src_tabs.Refresh()
        
        # add the page to the destination tabs
        dest_tabs.InsertPage(page_info.window, page_info, 0)

        if src_tabs.GetPageCount() == 0:
            self.RemoveEmptyTabFrames()
        
        self.DoSizing()
        dest_tabs.DoShowHide()
        dest_tabs.Refresh()

        # force the set selection function reset the selection
        self._curpage = -1

        # set the active page to the one we just split off
        self.SetSelectionToPage(page_info)

        self.UpdateHintWindowSize()


    def UnSplit(self):
        """ Restores original view after a tab split. """

        self.Freeze()
        
        # remember the tab now selected
        nowSelected = self.GetSelection()
        # select first tab as destination
        self.SetSelection(0)
        # iterate all other tabs
        for idx in xrange(1, self.GetPageCount()):
            # get win reference
            win = self.GetPage(idx)
            # get tab title
            title = self.GetPageText(idx)
            # get page bitmap
            bmp = self.GetPageBitmap(idx)
            # remove from notebook
            self.RemovePage(idx)
            # re-add in the same position so it will tab
            self.InsertPage(idx, win, title, False, bmp)
        # restore orignial selected tab
        self.SetSelection(nowSelected)

        self.Thaw()


    def ReparentControl(self, control, dest_tabs):
        """
        Reparents a control added inside a tab.

        :param `control`: an instance of `wx.Window`;
        :param `dest_tabs`: the destination L{AuiTabCtrl}.
        """
        
        control.Hide()
        control.Reparent(dest_tabs)
        

    def UnsplitDClick(self, part, sash_size, pos):
        """
        Unsplit the L{AuiNotebook} on sash double-click.

        :param `part`: an UI part representing the sash;
        :param `sash_size`: the sash size;
        :param `pos`: the double-click mouse position.

        :warning: Due to a bug on MSW, for disabled pages `wx.FindWindowAtPoint`
         returns the wrong window. See http://trac.wxwidgets.org/ticket/2942
        """

        if not self._sash_dclick_unsplit:
            # Unsplit not allowed
            return

        pos1 = wx.Point(*pos)
        pos2 = wx.Point(*pos)
        if part.orientation == wx.HORIZONTAL:
            pos1.y -= 2*sash_size
            pos2.y += 2*sash_size + self.GetTabCtrlHeight()
        elif part.orientation == wx.VERTICAL:
            pos1.x -= 2*sash_size
            pos2.x += 2*sash_size
        else:
            raise Exception("Invalid UI part orientation")

        pos1, pos2 = self.ClientToScreen(pos1), self.ClientToScreen(pos2)
        win1, win2 = wx.FindWindowAtPoint(pos1), wx.FindWindowAtPoint(pos2)

        if isinstance(win1, wx.ScrollBar):
            # Hopefully it will work
            pos1 = wx.Point(*pos)
            shift = wx.SystemSettings.GetMetric(wx.SYS_VSCROLL_X) + 2*(sash_size+1)
            if part.orientation == wx.HORIZONTAL:
                pos1.y -= shift
            else:
                pos1.x -= shift
                
            pos1 = self.ClientToScreen(pos1)
            win1 = wx.FindWindowAtPoint(pos1)

        if isinstance(win2, wx.ScrollBar):
            pos2 = wx.Point(*pos)
            shift = wx.SystemSettings.GetMetric(wx.SYS_VSCROLL_X) + 2*(sash_size+1)
            if part.orientation == wx.HORIZONTAL:
                pos2.y += shift
            else:
                pos2.x += shift

            pos2 = self.ClientToScreen(pos2)
            win2 = wx.FindWindowAtPoint(pos2)

        if not win1 or not win2:
            # How did we get here?
            return

        if isinstance(win1, AuiNotebook) or isinstance(win2, AuiNotebook):
            # This is a bug on MSW, for disabled pages wx.FindWindowAtPoint
            # returns the wrong window.
            # See http://trac.wxwidgets.org/ticket/2942
            return

        tab_frame1, tab_frame2 = self.GetTabFrameFromWindow(win1), self.GetTabFrameFromWindow(win2)

        if not tab_frame1 or not tab_frame2:
            return

        tab_ctrl_1, tab_ctrl_2 = tab_frame1._tabs, tab_frame2._tabs

        if tab_ctrl_1.GetPageCount() > tab_ctrl_2.GetPageCount():
            src_tabs = tab_ctrl_2
            dest_tabs = tab_ctrl_1
        else:
            src_tabs = tab_ctrl_1
            dest_tabs = tab_ctrl_2

        selection = -1
        page_count = dest_tabs.GetPageCount()
        
        for page in xrange(src_tabs.GetPageCount()-1, -1, -1):
            # remove the page from the source tabs
            page_info = src_tabs.GetPage(page)
            if page_info.active:
                selection = page_count + page
            src_tabs.RemovePage(page_info.window)

            # add the page to the destination tabs
            dest_tabs.AddPage(page_info.window, page_info)
            if page_info.control:
                self.ReparentControl(page_info.control, dest_tabs)
        
        self.RemoveEmptyTabFrames()

        dest_tabs.DoShowHide()
        self.DoSizing()
        dest_tabs.Refresh()
        self._mgr.Update()
        if selection > 0:
            wx.CallAfter(dest_tabs.MakeTabVisible, selection, self)
        
    
    def OnSize(self, event):
        """
        Handles the ``wx.EVT_SIZE`` event for L{AuiNotebook}.

        :param `event`: a `wx.SizeEvent` event to be processed.        
        """
        
        self.UpdateHintWindowSize()
        event.Skip()


    def OnTabClicked(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_PAGE_CHANGING`` event for L{AuiNotebook}.

        :param `event`: a L{AuiNotebookEvent} event to be processed.        
        """

        if self._textCtrl is not None:
            self._textCtrl.StopEditing()
        
        ctrl = event.GetEventObject()
        assert ctrl != None

        wnd = ctrl.GetWindowFromIdx(event.GetSelection())
        assert wnd != None

        self.SetSelectionToWindow(wnd)


    def OnTabBgDClick(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_BG_DCLICK`` event for L{AuiNotebook}.

        :param `event`: a L{AuiNotebookEvent} event to be processed.        
        """

        if self._textCtrl is not None:
            self._textCtrl.StopEditing()
        
        # notify owner that the tabbar background has been double-clicked
        e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_BG_DCLICK, self.GetId())
        e.SetEventObject(self)
        self.GetEventHandler().ProcessEvent(e)


    def OnTabDClick(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_TAB_DCLICK`` event for L{AuiNotebook}.

        :param `event`: a L{AuiNotebookEvent} event to be processed.        
        """

        # notify owner that the tabbar background has been double-clicked
        e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_TAB_DCLICK, self.GetId())
        e.SetEventObject(self)
        self.GetEventHandler().ProcessEvent(e)

        tabs = event.GetEventObject()
        if not tabs.GetEnabled(event.GetSelection()):
            return

        if not self.IsRenamable(event.GetSelection()):
            return

        self.EditTab(event.GetSelection())
        

    def OnTabBeginDrag(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_BEGIN_DRAG`` event for L{AuiNotebook}.

        :param `event`: a L{AuiNotebookEvent} event to be processed.        
        """

        tabs = event.GetEventObject()
        if not tabs.GetEnabled(event.GetSelection()):
            return

        self._last_drag_x = 0


    def OnTabDragMotion(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_DRAG_MOTION`` event for L{AuiNotebook}.

        :param `event`: a L{AuiNotebookEvent} event to be processed.        
        """

        tabs = event.GetEventObject()
        if not tabs.GetEnabled(event.GetSelection()):
            return

        if self._textCtrl is not None:
            self._textCtrl.StopEditing()

        screen_pt = wx.GetMousePosition()
        client_pt = self.ScreenToClient(screen_pt)
        zero = wx.Point(0, 0)

        src_tabs = event.GetEventObject()
        dest_tabs = self.GetTabCtrlFromPoint(client_pt)
        
        if dest_tabs == src_tabs:
            if src_tabs:
                src_tabs.SetCursor(wx.StockCursor(wx.CURSOR_ARROW))
            
            # always hide the hint for inner-tabctrl drag
            self._mgr.HideHint()

            # if tab moving is not allowed, leave
            if not self._agwFlags & AUI_NB_TAB_MOVE:
                return
            
            pt = dest_tabs.ScreenToClient(screen_pt)

            # this is an inner-tab drag/reposition
            dest_location_tab = dest_tabs.TabHitTest(pt.x, pt.y)
            
            if dest_location_tab:
            
                src_idx = event.GetSelection()
                dest_idx = dest_tabs.GetIdxFromWindow(dest_location_tab)

                # prevent jumpy drag
                if (src_idx == dest_idx) or dest_idx == -1 or \
                   (src_idx > dest_idx and self._last_drag_x <= pt.x) or \
                   (src_idx < dest_idx and self._last_drag_x >= pt.x):
                
                    self._last_drag_x = pt.x
                    return
                
                src_tab = dest_tabs.GetWindowFromIdx(src_idx)
                dest_tabs.MovePage(src_tab, dest_idx)
                self._tabs.MovePage(self._tabs.GetPage(src_idx).window, dest_idx)
                dest_tabs.SetActivePage(dest_idx)
                dest_tabs.DoShowHide()
                dest_tabs.Refresh()
                self._last_drag_x = pt.x

            return

        # if external drag is allowed, check if the tab is being dragged
        # over a different AuiNotebook control
        if self._agwFlags & AUI_NB_TAB_EXTERNAL_MOVE:
        
            tab_ctrl = wx.FindWindowAtPoint(screen_pt)

            # if we aren't over any window, stop here
            if not tab_ctrl:
                if self._agwFlags & AUI_NB_TAB_FLOAT:
                    if self.IsMouseWellOutsideWindow():
                        hintRect = wx.RectPS(screen_pt, (400, 300))
                        # Use CallAfter so we overwrite the hint that might be 
                        # shown by our superclass: 
                        wx.CallAfter(self._mgr.ShowHint, hintRect) 
                return

            # make sure we are not over the hint window
            if not isinstance(tab_ctrl, wx.Frame):
                while tab_ctrl:
                    if isinstance(tab_ctrl, AuiTabCtrl):
                        break
                    
                    tab_ctrl = tab_ctrl.GetParent()
                
                if tab_ctrl:
                    nb = tab_ctrl.GetParent()

                    if nb != self:
                    
                        hint_rect = tab_ctrl.GetClientRect()
                        hint_rect.x, hint_rect.y = tab_ctrl.ClientToScreenXY(hint_rect.x, hint_rect.y)
                        self._mgr.ShowHint(hint_rect)
                        return
                    
            else:
            
                if not dest_tabs:
                    # we are either over a hint window, or not over a tab
                    # window, and there is no where to drag to, so exit
                    return

        if self._agwFlags & AUI_NB_TAB_FLOAT:
            if self.IsMouseWellOutsideWindow():
                hintRect = wx.RectPS(screen_pt, (400, 300))
                # Use CallAfter so we overwrite the hint that might be 
                # shown by our superclass: 
                wx.CallAfter(self._mgr.ShowHint, hintRect)
                return
                        
        # if there are less than two panes, split can't happen, so leave
        if self._tabs.GetPageCount() < 2:
            return

        # if tab moving is not allowed, leave
        if not self._agwFlags & AUI_NB_TAB_SPLIT:
            return

        if src_tabs:
            src_tabs.SetCursor(wx.StockCursor(wx.CURSOR_SIZING))
        
        if dest_tabs:
            
            hint_rect = dest_tabs.GetRect()
            hint_rect.x, hint_rect.y = self.ClientToScreenXY(hint_rect.x, hint_rect.y)
            self._mgr.ShowHint(hint_rect)
        
        else:
            rect = self._mgr.CalculateHintRect(self._dummy_wnd, client_pt, zero)
            if rect.IsEmpty():
                self._mgr.HideHint()
                return
            
            hit_wnd = wx.FindWindowAtPoint(screen_pt)
            if hit_wnd and not isinstance(hit_wnd, AuiNotebook):
                tab_frame = self.GetTabFrameFromWindow(hit_wnd)
                if tab_frame:
                    hint_rect = wx.Rect(*tab_frame._rect)
                    hint_rect.x, hint_rect.y = self.ClientToScreenXY(hint_rect.x, hint_rect.y)
                    rect.Intersect(hint_rect)
                    self._mgr.ShowHint(rect)
                else:
                    self._mgr.DrawHintRect(self._dummy_wnd, client_pt, zero)
            else:
                self._mgr.DrawHintRect(self._dummy_wnd, client_pt, zero)
        

    def OnTabEndDrag(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_END_DRAG`` event for L{AuiNotebook}.

        :param `event`: a L{AuiNotebookEvent} event to be processed.        
        """

        tabs = event.GetEventObject()
        if not tabs.GetEnabled(event.GetSelection()):
            return

        self._mgr.HideHint()

        src_tabs = event.GetEventObject()
        if not src_tabs:
            raise Exception("no source object?")

        src_tabs.SetCursor(wx.StockCursor(wx.CURSOR_ARROW))

        # get the mouse position, which will be used to determine the drop point
        mouse_screen_pt = wx.GetMousePosition()
        mouse_client_pt = self.ScreenToClient(mouse_screen_pt)

        # check for an external move
        if self._agwFlags & AUI_NB_TAB_EXTERNAL_MOVE:
            tab_ctrl = wx.FindWindowAtPoint(mouse_screen_pt)

            while tab_ctrl:
            
                if isinstance(tab_ctrl, AuiTabCtrl):
                    break
                
                tab_ctrl = tab_ctrl.GetParent()
            
            if tab_ctrl:
            
                nb = tab_ctrl.GetParent()

                if nb != self:
                
                    # find out from the destination control
                    # if it's ok to drop this tab here
                    e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_ALLOW_DND, self.GetId())
                    e.SetSelection(event.GetSelection())
                    e.SetOldSelection(event.GetSelection())
                    e.SetEventObject(self)
                    e.SetDragSource(self)
                    e.Veto() # dropping must be explicitly approved by control owner

                    nb.GetEventHandler().ProcessEvent(e)

                    if not e.IsAllowed():
                    
                        # no answer or negative answer
                        self._mgr.HideHint()
                        return
                    
                    # drop was allowed
                    src_idx = event.GetSelection()
                    src_page = src_tabs.GetWindowFromIdx(src_idx)

                    # Check that it's not an impossible parent relationship
                    p = nb
                    while p and not p.IsTopLevel():
                        if p == src_page:
                            return
                        
                        p = p.GetParent()

                    # get main index of the page
                    main_idx = self._tabs.GetIdxFromWindow(src_page)
                    if main_idx == wx.NOT_FOUND:
                        raise Exception("no source page?")

                    # make a copy of the page info
                    page_info = self._tabs.GetPage(main_idx)

                    # remove the page from the source notebook
                    self.RemovePage(main_idx)

                    # reparent the page
                    src_page.Reparent(nb)

                    # Reparent the control in a tab (if any)
                    if page_info.control:
                        self.ReparentControl(page_info.control, tab_ctrl)

                    # find out the insert idx
                    dest_tabs = tab_ctrl
                    pt = dest_tabs.ScreenToClient(mouse_screen_pt)

                    target = dest_tabs.TabHitTest(pt.x, pt.y)
                    insert_idx = -1
                    if target:
                        insert_idx = dest_tabs.GetIdxFromWindow(target)

                    # add the page to the new notebook
                    if insert_idx == -1:
                        insert_idx = dest_tabs.GetPageCount()
                        
                    dest_tabs.InsertPage(page_info.window, page_info, insert_idx)
                    nb._tabs.AddPage(page_info.window, page_info)

                    nb.DoSizing()
                    dest_tabs.DoShowHide()
                    dest_tabs.Refresh()

                    # set the selection in the destination tab control
                    nb.SetSelectionToPage(page_info)

                    # notify owner that the tab has been dragged
                    e2 = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_DRAG_DONE, self.GetId())
                    e2.SetSelection(event.GetSelection())
                    e2.SetOldSelection(event.GetSelection())
                    e2.SetEventObject(self)
                    self.GetEventHandler().ProcessEvent(e2)

                    return

        if self._agwFlags & AUI_NB_TAB_FLOAT:
            self._mgr.HideHint() 
            if self.IsMouseWellOutsideWindow(): 
                # Use CallAfter so we our superclass can deal with the event first
                wx.CallAfter(self.FloatPage, self.GetSelection())
                event.Skip()
                return
        
        # only perform a tab split if it's allowed
        dest_tabs = None

        if self._agwFlags & AUI_NB_TAB_SPLIT and self._tabs.GetPageCount() >= 2:
        
            # If the pointer is in an existing tab frame, do a tab insert
            hit_wnd = wx.FindWindowAtPoint(mouse_screen_pt)
            tab_frame = self.GetTabFrameFromTabCtrl(hit_wnd)
            insert_idx = -1
            
            if tab_frame:
            
                dest_tabs = tab_frame._tabs

                if dest_tabs == src_tabs:
                    return

                pt = dest_tabs.ScreenToClient(mouse_screen_pt)
                target = dest_tabs.TabHitTest(pt.x, pt.y)
                
                if target:                
                    insert_idx = dest_tabs.GetIdxFromWindow(target)
                
            else:
            
                zero = wx.Point(0, 0)
                rect = self._mgr.CalculateHintRect(self._dummy_wnd, mouse_client_pt, zero)
                
                if rect.IsEmpty():
                    # there is no suitable drop location here, exit out
                    return
                
                # If there is no tabframe at all, create one
                new_tabs = TabFrame(self)
                new_tabs._rect = wx.RectPS(wx.Point(0, 0), self.CalculateNewSplitSize())
                new_tabs.SetTabCtrlHeight(self._tab_ctrl_height)
                self._tab_id_counter += 1
                new_tabs._tabs = AuiTabCtrl(self, self._tab_id_counter)
                new_tabs._tabs.SetArtProvider(self._tabs.GetArtProvider().Clone())
                new_tabs._tabs.SetAGWFlags(self._agwFlags)

                self._mgr.AddPane(new_tabs, framemanager.AuiPaneInfo().Bottom().CaptionVisible(False), mouse_client_pt)
                self._mgr.Update()
                dest_tabs = new_tabs._tabs
                
            # remove the page from the source tabs
            page_info = src_tabs.GetPage(event.GetSelection())

            if page_info.control:
                self.ReparentControl(page_info.control, dest_tabs)

            page_info.active = False
            src_tabs.RemovePage(page_info.window)

            if src_tabs.GetPageCount() > 0:            
                src_tabs.SetActivePage(0)
                src_tabs.DoShowHide()
                src_tabs.Refresh()

            # add the page to the destination tabs
            if insert_idx == -1:
                insert_idx = dest_tabs.GetPageCount()

            dest_tabs.InsertPage(page_info.window, page_info, insert_idx)
            
            if src_tabs.GetPageCount() == 0:
                self.RemoveEmptyTabFrames()

            self.DoSizing()
            dest_tabs.DoShowHide()
            dest_tabs.Refresh()

            # force the set selection function reset the selection
            self._curpage = -1

            # set the active page to the one we just split off
            self.SetSelectionToPage(page_info)

            self.UpdateHintWindowSize()
        
        # notify owner that the tab has been dragged
        e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_DRAG_DONE, self.GetId())
        e.SetSelection(event.GetSelection())
        e.SetOldSelection(event.GetSelection())
        e.SetEventObject(self)
        self.GetEventHandler().ProcessEvent(e)


    def OnTabCancelDrag(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_CANCEL_DRAG`` event for L{AuiNotebook}.

        :param `event`: a L{AuiNotebookEvent} event to be processed.        
        """

        tabs = event.GetEventObject()
        if not tabs.GetEnabled(event.GetSelection()):
            return

        self._mgr.HideHint()

        src_tabs = event.GetEventObject()
        if not src_tabs:
            raise Exception("no source object?")

        src_tabs.SetCursor(wx.StockCursor(wx.CURSOR_ARROW))


    def IsMouseWellOutsideWindow(self):
        """ Returns whether the mouse is well outside the L{AuiNotebook} screen rectangle. """
        
        screen_rect = self.GetScreenRect() 
        screen_rect.Inflate(50, 50)
        
        return not screen_rect.Contains(wx.GetMousePosition())


    def FloatPage(self, page_index):
        """
        Float the page in `page_index` by reparenting it to a floating frame.

        :param `page_index`: the index of the page to be floated.

        :warning: When the notebook is more or less full screen, tabs cannot be dragged far
         enough outside of the notebook to become floating pages.   
        """

        root_manager = framemanager.GetManager(self)
        page_title = self.GetPageText(page_index) 
        page_contents = self.GetPage(page_index)
        page_bitmap = self.GetPageBitmap(page_index)
        text_colour = self.GetPageTextColour(page_index)
        info = self.GetPageInfo(page_index)
                
        if root_manager and root_manager != self._mgr:
            root_manager = framemanager.GetManager(self)

            if hasattr(page_contents, "__floating_size__"):
                floating_size = wx.Size(*page_contents.__floating_size__)
            else:
                floating_size = page_contents.GetBestSize()
                if floating_size == wx.DefaultSize:
                    floating_size = wx.Size(300, 200)

            page_contents.__page_index__ = page_index
            page_contents.__aui_notebook__ = self
            page_contents.__text_colour__ = text_colour
            page_contents.__control__ = info.control

            if info.control:
                info.control.Reparent(page_contents)
                info.control.Hide()
                info.control = None

            self.RemovePage(page_index)
            self.RemoveEmptyTabFrames()
                            
            pane_info = framemanager.AuiPaneInfo().Float().FloatingPosition(wx.GetMousePosition()). \
                        FloatingSize(floating_size).BestSize(floating_size).Name("__floating__%s"%page_title). \
                        Caption(page_title).Icon(page_bitmap)
            root_manager.AddPane(page_contents, pane_info)
            root_manager.Bind(framemanager.EVT_AUI_PANE_CLOSE, self.OnCloseFloatingPage)
            self.GetActiveTabCtrl().DoShowHide()
            self.DoSizing()
            root_manager.Update()
            
        else:
            frame = wx.Frame(self, title=page_title,
                             style=wx.DEFAULT_FRAME_STYLE|wx.FRAME_TOOL_WINDOW|
                                   wx.FRAME_FLOAT_ON_PARENT | wx.FRAME_NO_TASKBAR) 

            if info.control:
                info.control.Reparent(frame)
                info.control.Hide()
                
            frame.bitmap = page_bitmap            
            frame.page_index = page_index
            frame.text_colour = text_colour
            frame.control = info.control
            page_contents.Reparent(frame) 
            frame.Bind(wx.EVT_CLOSE, self.OnCloseFloatingPage) 
            frame.Move(wx.GetMousePosition()) 
            frame.Show()
            self.RemovePage(page_index)

            self.RemoveEmptyTabFrames()

        wx.CallAfter(self.RemoveEmptyTabFrames)
        

    def OnCloseFloatingPage(self, event):
        """
        Handles the ``wx.EVT_CLOSE`` event for a floating page in L{AuiNotebook}.

        :param `event`: a `wx.CloseEvent` event to be processed.        
        """

        root_manager = framemanager.GetManager(self)
        if root_manager and root_manager != self._mgr:
            pane = event.pane
            if pane.name.startswith("__floating__"):
                self.ReDockPage(pane)
                return
                
            event.Skip()
        else:
            event.Skip()
            frame = event.GetEventObject() 
            page_title = frame.GetTitle() 
            page_contents = frame.GetChildren()[-1] 
            page_contents.Reparent(self)
            self.InsertPage(frame.page_index, page_contents, page_title, select=True, bitmap=frame.bitmap, control=frame.control)

            if frame.control:
                src_tabs, idx = self.FindTab(page_contents)
                frame.control.Reparent(src_tabs)
                frame.control.Hide()
                frame.control = None

            self.SetPageTextColour(frame.page_index, frame.text_colour)


    def ReDockPage(self, pane):
        """
        Re-docks a floating L{AuiNotebook} tab in the original position, when possible.

        :param `pane`: an instance of L{framemanager.AuiPaneInfo}.
        """

        root_manager = framemanager.GetManager(self)        

        pane.window.__floating_size__ = wx.Size(*pane.floating_size)
        page_index = pane.window.__page_index__
        text_colour = pane.window.__text_colour__
        control = pane.window.__control__
        
        root_manager.DetachPane(pane.window)
        self.InsertPage(page_index, pane.window, pane.caption, True, pane.icon, control=control)

        self.SetPageTextColour(page_index, text_colour)
        self.GetActiveTabCtrl().DoShowHide()
        self.DoSizing()
        if control:
            self.UpdateTabCtrlHeight(force=True)
            
        self._mgr.Update()
        root_manager.Update()
        
        
    def GetTabCtrlFromPoint(self, pt):
        """
        Returns the tab control at the specified point.

        :param `pt`: a `wx.Point` object.
        """

        # if we've just removed the last tab from the source
        # tab set, the remove the tab control completely
        all_panes = self._mgr.GetAllPanes()
        for pane in all_panes:
            if pane.name == "dummy":
                continue

            tabframe = pane.window
            if tabframe._tab_rect.Contains(pt):
                return tabframe._tabs
        
        return None


    def GetTabFrameFromTabCtrl(self, tab_ctrl):
        """
        Returns the tab frame associated with a tab control.

        :param `tab_ctrl`: an instance of L{AuiTabCtrl}.
        """

        # if we've just removed the last tab from the source
        # tab set, the remove the tab control completely
        all_panes = self._mgr.GetAllPanes()
        for pane in all_panes:
            if pane.name == "dummy":
                continue

            tabframe = pane.window
            if tabframe._tabs == tab_ctrl:            
                return tabframe
            
        return None


    def GetTabFrameFromWindow(self, wnd):
        """
        Returns the tab frame associated with a window.

        :param `wnd`: an instance of `wx.Window`.
        """

        all_panes = self._mgr.GetAllPanes()
        for pane in all_panes:
            if pane.name == "dummy":
                continue

            tabframe = pane.window
            for page in tabframe._tabs.GetPages():
                if wnd == page.window:
                    return tabframe
            
        return None
    
        
    def RemoveEmptyTabFrames(self):
        """ Removes all the empty tab frames. """

        # if we've just removed the last tab from the source
        # tab set, the remove the tab control completely
        all_panes = self._mgr.GetAllPanes()

        for indx in xrange(len(all_panes)-1, -1, -1):
            pane = all_panes[indx]
            if pane.name == "dummy":
                continue

            tab_frame = pane.window
            if tab_frame._tabs.GetPageCount() == 0:
                self._mgr.DetachPane(tab_frame)
                tab_frame._tabs.Destroy()
                tab_frame._tabs = None
                del tab_frame

        # check to see if there is still a center pane
        # if there isn't, make a frame the center pane
        first_good = None
        center_found = False

        all_panes = self._mgr.GetAllPanes()
        for pane in all_panes:
            if pane.name == "dummy":
                continue
       
            if pane.dock_direction == AUI_DOCK_CENTRE:
                center_found = True
            if not first_good:
                first_good = pane.window
        
        if not center_found and first_good:
            self._mgr.GetPane(first_good).Centre()

        if not self.IsBeingDeleted():
            self._mgr.Update()


    def OnChildFocusNotebook(self, event):
        """
        Handles the ``wx.EVT_CHILD_FOCUS`` event for L{AuiNotebook}.

        :param `event`: a `wx.ChildFocusEvent` event to be processed.        
        """
        
        # if we're dragging a tab, don't change the current selection.
        # This code prevents a bug that used to happen when the hint window
        # was hidden.  In the bug, the focus would return to the notebook
        # child, which would then enter this handler and call
        # SetSelection, which is not desired turn tab dragging.

        event.Skip()
        
        all_panes = self._mgr.GetAllPanes()
        for pane in all_panes:
            if pane.name == "dummy":
                continue
            tabframe = pane.window
            if tabframe._tabs.IsDragging():
                return

##        # change the tab selection to the child
##        # which was focused
##        idx = self._tabs.GetIdxFromWindow(event.GetWindow())
##        if idx != -1 and idx != self._curpage:
##            self.SetSelection(idx)
        

    def SetNavigatorIcon(self, bmp):
        """
        Sets the icon used by the L{TabNavigatorWindow}.

        :param `bmp`: an instance of `wx.Bitmap`.
        """
        
        if isinstance(bmp, wx.Bitmap) and bmp.IsOk():
            # Make sure image is proper size
            if bmp.GetSize() != (16, 16):
                img = bmp.ConvertToImage()
                img.Rescale(16, 16, wx.IMAGE_QUALITY_HIGH)
                bmp = wx.BitmapFromImage(img)
            self._naviIcon = bmp
        else:
            raise TypeError, "SetNavigatorIcon requires a valid bitmap"

        
    def OnNavigationKeyNotebook(self, event):
        """
        Handles the ``wx.EVT_NAVIGATION_KEY`` event for L{AuiNotebook}.

        :param `event`: a `wx.NavigationKeyEvent` event to be processed.        
        """

        if event.IsWindowChange():
            if self._agwFlags & AUI_NB_SMART_TABS:
                if not self._popupWin:
                    self._popupWin = TabNavigatorWindow(self, self._naviIcon)
                    self._popupWin.SetReturnCode(wx.ID_OK)
                    self._popupWin.ShowModal()
                    idx = self._popupWin.GetSelectedPage()
                    self._popupWin.Destroy()
                    self._popupWin = None
                    # Need to do CallAfter so that the selection and its
                    # associated events get processed outside the context of
                    # this key event. Not doing so causes odd issues with the
                    # window focus under certain use cases on Windows.
                    wx.CallAfter(self.SetSelection, idx, True)
                else:
                    # a dialog is already opened
                    self._popupWin.OnNavigationKey(event)
                    return
            else:
                # change pages
                # FIXME: the problem with this is that if we have a split notebook,
                # we selection may go all over the place.
                self.AdvanceSelection(event.GetDirection())
        
        else:
            # we get this event in 3 cases
            #
            # a) one of our pages might have generated it because the user TABbed
            # out from it in which case we should propagate the event upwards and
            # our parent will take care of setting the focus to prev/next sibling
            #
            # or
            #
            # b) the parent panel wants to give the focus to us so that we
            # forward it to our selected page. We can't deal with this in
            # OnSetFocus() because we don't know which direction the focus came
            # from in this case and so can't choose between setting the focus to
            # first or last panel child
            #
            # or
            #
            # c) we ourselves (see MSWTranslateMessage) generated the event
            #
            parent = self.GetParent()

            # the wxObject* casts are required to avoid MinGW GCC 2.95.3 ICE
            isFromParent = event.GetEventObject() == parent
            isFromSelf = event.GetEventObject() == self

            if isFromParent or isFromSelf:
            
                # no, it doesn't come from child, case (b) or (c): forward to a
                # page but only if direction is backwards (TAB) or from ourselves,
                if self.GetSelection() != wx.NOT_FOUND and (not event.GetDirection() or isFromSelf):
                
                    # so that the page knows that the event comes from it's parent
                    # and is being propagated downwards
                    event.SetEventObject(self)

                    page = self.GetPage(self.GetSelection())
                    if not page.GetEventHandler().ProcessEvent(event):                    
                        page.SetFocus()
                    
                    #else: page manages focus inside it itself
                
                else: # otherwise set the focus to the notebook itself
                
                    self.SetFocus()
                
            else:
            
                # send this event back for the 'wraparound' focus.
                winFocus = event.GetCurrentFocus()

                if winFocus:
                    event.SetEventObject(self)
                    winFocus.GetEventHandler().ProcessEvent(event)


    def OnTabButton(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_BUTTON`` event for L{AuiNotebook}.

        :param `event`: a L{AuiNotebookEvent} event to be processed.        
        """

        tabs = event.GetEventObject()
        button_id = event.GetInt()

        if button_id == AUI_BUTTON_CLOSE:

            selection = event.GetSelection()

            if selection == -1:
            
                # if the close button is to the right, use the active
                # page selection to determine which page to close
                selection = tabs.GetActivePage()

            if selection == -1 or not tabs.GetEnabled(selection):
                return
            
            if selection != -1:
            
                close_wnd = tabs.GetWindowFromIdx(selection)

                if close_wnd.GetName() == "__fake__page__":
                    # This is a notebook preview
                    previous_active, page_status = close_wnd.__previousStatus
                    for page, status in zip(tabs.GetPages(), page_status):
                        page.enabled = status
                    
                    main_idx = self._tabs.GetIdxFromWindow(close_wnd)
                    self.DeletePage(main_idx)

                    if previous_active >= 0:
                        tabs.SetActivePage(previous_active)
                        page_count = tabs.GetPageCount()
                        selection = -1
                        
                        for page in xrange(page_count):
                            # remove the page from the source tabs
                            page_info = tabs.GetPage(page)
                            if page_info.active:
                                selection = page
                                break
        
                        tabs.DoShowHide()
                        self.DoSizing()
                        tabs.Refresh()
                        
                        if selection >= 0:
                            wx.CallAfter(tabs.MakeTabVisible, selection, self)
                                                
                    # Don't fire the event
                    return                        

                # ask owner if it's ok to close the tab
                e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_PAGE_CLOSE, self.GetId())
                idx = self._tabs.GetIdxFromWindow(close_wnd)
                e.SetSelection(idx)
                e.SetOldSelection(event.GetSelection())
                e.SetEventObject(self)
                self.GetEventHandler().ProcessEvent(e)
                if not e.IsAllowed():
                    return

                if repr(close_wnd.__class__).find("AuiMDIChildFrame") >= 0:
                    close_wnd.Close()
                
                else:
                    main_idx = self._tabs.GetIdxFromWindow(close_wnd)
                    self.DeletePage(main_idx)
                
                # notify owner that the tab has been closed
                e2 = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_PAGE_CLOSED, self.GetId())
                e2.SetSelection(idx)
                e2.SetEventObject(self)
                self.GetEventHandler().ProcessEvent(e2)

                if self.GetPageCount() == 0:
                    mgr = self.GetAuiManager()
                    win = mgr.GetManagedWindow()
                    win.SendSizeEvent()
            

    def OnTabMiddleDown(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_TAB_MIDDLE_DOWN`` event for L{AuiNotebook}.

        :param `event`: a L{AuiNotebookEvent} event to be processed.        
        """
        
        tabs = event.GetEventObject()
        if not tabs.GetEnabled(event.GetSelection()):
            return

        # patch event through to owner
        wnd = tabs.GetWindowFromIdx(event.GetSelection())

        e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_TAB_MIDDLE_DOWN, self.GetId())
        e.SetSelection(self._tabs.GetIdxFromWindow(wnd))
        e.SetEventObject(self)
        self.GetEventHandler().ProcessEvent(e)


    def OnTabMiddleUp(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_TAB_MIDDLE_UP`` event for L{AuiNotebook}.

        :param `event`: a L{AuiNotebookEvent} event to be processed.        
        """
        
        tabs = event.GetEventObject()
        if not tabs.GetEnabled(event.GetSelection()):
            return

        # if the AUI_NB_MIDDLE_CLICK_CLOSE is specified, middle
        # click should act like a tab close action.  However, first
        # give the owner an opportunity to handle the middle up event
        # for custom action

        wnd = tabs.GetWindowFromIdx(event.GetSelection())

        e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_TAB_MIDDLE_UP, self.GetId())
        e.SetSelection(self._tabs.GetIdxFromWindow(wnd))
        e.SetEventObject(self)
        if self.GetEventHandler().ProcessEvent(e):
            return
        if not e.IsAllowed():
            return

        # check if we are supposed to close on middle-up
        if self._agwFlags & AUI_NB_MIDDLE_CLICK_CLOSE == 0:
            return

        # simulate the user pressing the close button on the tab
        event.SetInt(AUI_BUTTON_CLOSE)
        self.OnTabButton(event)


    def OnTabRightDown(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_TAB_RIGHT_DOWN`` event for L{AuiNotebook}.

        :param `event`: a L{AuiNotebookEvent} event to be processed.        
        """
        
        tabs = event.GetEventObject()
        if not tabs.GetEnabled(event.GetSelection()):
            return

        # patch event through to owner
        wnd = tabs.GetWindowFromIdx(event.GetSelection())

        e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_TAB_RIGHT_DOWN, self.GetId())
        e.SetSelection(self._tabs.GetIdxFromWindow(wnd))
        e.SetEventObject(self)
        self.GetEventHandler().ProcessEvent(e)


    def OnTabRightUp(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_TAB_RIGHT_UP`` event for L{AuiNotebook}.

        :param `event`: a L{AuiNotebookEvent} event to be processed.        
        """

        tabs = event.GetEventObject()
        if not tabs.GetEnabled(event.GetSelection()):
            return

        # patch event through to owner
        wnd = tabs.GetWindowFromIdx(event.GetSelection())

        e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_TAB_RIGHT_UP, self.GetId())
        e.SetSelection(self._tabs.GetIdxFromWindow(wnd))
        e.SetEventObject(self)
        self.GetEventHandler().ProcessEvent(e)


    def SetNormalFont(self, font):
        """
        Sets the normal font for drawing tab labels.

        :param `font`: a `wx.Font` object.
        """

        self._normal_font = font
        self.GetArtProvider().SetNormalFont(font)


    def SetSelectedFont(self, font):
        """
        Sets the selected tab font for drawing tab labels.

        :param `font`: a `wx.Font` object.
        """

        self._selected_font = font
        self.GetArtProvider().SetSelectedFont(font)


    def SetMeasuringFont(self, font):
        """
        Sets the font for calculating text measurements.

        :param `font`: a `wx.Font` object.
        """

        self.GetArtProvider().SetMeasuringFont(font)


    def SetFont(self, font):
        """
        Sets the tab font.

        :param `font`: a `wx.Font` object.

        :note: Overridden from `wx.PyPanel`.
        """
    
        wx.PyPanel.SetFont(self, font)

        selectedFont = wx.Font(font.GetPointSize(), font.GetFamily(),
                               font.GetStyle(), wx.BOLD, font.GetUnderlined(),
                               font.GetFaceName(), font.GetEncoding())

        self.SetNormalFont(font)
        self.SetSelectedFont(selectedFont)
        self.SetMeasuringFont(selectedFont)

        return True


    def GetTabCtrlHeight(self):
        """ Returns the tab control height. """

        return self._tab_ctrl_height

    
    def GetHeightForPageHeight(self, pageHeight):
        """
        Gets the height of the notebook for a given page height.

        :param `pageHeight`: the given page height.
        """

        self.UpdateTabCtrlHeight()

        tabCtrlHeight = self.GetTabCtrlHeight()
        decorHeight = 2
        return tabCtrlHeight + pageHeight + decorHeight


    def AdvanceSelection(self, forward=True, wrap=True):
        """
        Cycles through the tabs.

        :param `forward`: whether to advance forward or backward;
        :param `wrap`: ``True`` to return to the first tab if we reach the last tab.

        :note: The call to this function generates the page changing events.
        """

        tabCtrl = self.GetActiveTabCtrl()
        newPage = -1

        focusWin = tabCtrl.FindFocus()
        activePage = tabCtrl.GetActivePage()
        lenPages = len(tabCtrl.GetPages())
        
        if lenPages == 1:
            return False
        
        if forward:
            if lenPages > 1:
            
                if activePage == -1 or activePage == lenPages - 1:
                    if not wrap:
                        return False

                    newPage = 0
                    
                elif activePage < lenPages - 1:
                    newPage = activePage + 1
            
        else:
        
            if lenPages > 1:
                if activePage == -1 or activePage == 0:
                    if not wrap:
                        return False

                    newPage = lenPages - 1
                
                elif activePage > 0:
                    newPage = activePage - 1

        
        if newPage != -1:
            if not self.GetEnabled(newPage):
                return False

            e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_PAGE_CHANGING, tabCtrl.GetId())
            e.SetSelection(newPage)
            e.SetOldSelection(activePage)
            e.SetEventObject(tabCtrl)
            self.GetEventHandler().ProcessEvent(e)
        
##        if focusWin:
##            focusWin.SetFocus()

        return True


    def ShowWindowMenu(self):
        """
        Shows the window menu for the active tab control associated with this
        notebook, and returns ``True`` if a selection was made.
        """
        
        tabCtrl = self.GetActiveTabCtrl()
        idx = tabCtrl.GetArtProvider().ShowDropDown(tabCtrl, tabCtrl.GetPages(), tabCtrl.GetActivePage())

        if not self.GetEnabled(idx):
            return False

        if idx != -1:
            e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_PAGE_CHANGING, tabCtrl.GetId())
            e.SetSelection(idx)
            e.SetOldSelection(tabCtrl.GetActivePage())
            e.SetEventObject(tabCtrl)
            self.GetEventHandler().ProcessEvent(e)

            return True
        
        else:
            
            return False


    def AddTabAreaButton(self, id, location, normal_bitmap=wx.NullBitmap, disabled_bitmap=wx.NullBitmap):
        """
        Adds a button in the tab area.

        :param `id`: the button identifier. This can be one of the following:

         ==============================  =================================
         Button Identifier               Description
         ==============================  =================================
         ``AUI_BUTTON_CLOSE``            Shows a close button on the tab area
         ``AUI_BUTTON_WINDOWLIST``       Shows a window list button on the tab area
         ``AUI_BUTTON_LEFT``             Shows a left button on the tab area
         ``AUI_BUTTON_RIGHT``            Shows a right button on the tab area
         ==============================  =================================        

        :param `location`: the button location. Can be ``wx.LEFT`` or ``wx.RIGHT``;
        :param `normal_bitmap`: the bitmap for an enabled tab;
        :param `disabled_bitmap`: the bitmap for a disabled tab.
        """

        active_tabctrl = self.GetActiveTabCtrl()
        active_tabctrl.AddButton(id, location, normal_bitmap, disabled_bitmap)


    def RemoveTabAreaButton(self, id):
        """
        Removes a button from the tab area.

        :param `id`: the button identifier. See L{AddTabAreaButton} for a list of button identifiers.

        :see: L{AddTabAreaButton}        
        """

        active_tabctrl = self.GetActiveTabCtrl()
        active_tabctrl.RemoveButton(id)
        
        
    def HasMultiplePages(self):
        """
        This method should be overridden to return ``True`` if this window has multiple pages. All
        standard class with multiple pages such as `wx.Notebook`, `wx.Listbook` and `wx.Treebook`
        already override it to return ``True`` and user-defined classes with similar behaviour
        should do it as well to allow the library to handle such windows appropriately.

        :note: Overridden from `wx.PyPanel`.
        """

        return True


    def GetDefaultBorder(self):
        """ Returns the default border style for L{AuiNotebook}. """

        return wx.BORDER_NONE


    def NotebookPreview(self, thumbnail_size=200):
        """
        Generates a preview of all the pages in the notebook (MSW and GTK only).

        :param `thumbnail_size`: the maximum size of every page thumbnail.

        :note: this functionality is currently unavailable on wxMac.        
        """

        if wx.Platform == "__WXMAC__":
            return False

        tabCtrl = self.GetActiveTabCtrl()
        activePage = tabCtrl.GetActivePage()
        pages = tabCtrl.GetPages()

        pageStatus, pageText = [], []

        for indx, page in enumerate(pages):

            pageStatus.append(page.enabled)

            if not page.enabled:
                continue
            
            self.SetSelectionToPage(page)            
            pageText.append(page.caption)

            rect = page.window.GetScreenRect()
            bmp = RescaleScreenShot(TakeScreenShot(rect), thumbnail_size)

            page.enabled = False
            if indx == 0:
                il = wx.ImageList(bmp.GetWidth(), bmp.GetHeight(), True)

            il.Add(bmp)  

        # create the list control
        listCtrl = wx.ListCtrl(self, style=wx.LC_ICON|wx.LC_AUTOARRANGE|wx.LC_HRULES|wx.LC_VRULES,
                               name="__fake__page__")

        # assign the image list to it
        listCtrl.AssignImageList(il, wx.IMAGE_LIST_NORMAL)
        listCtrl.__previousStatus = [activePage, pageStatus]

        # create some items for the list
        for indx, text in enumerate(pageText):
            listCtrl.InsertImageStringItem(10000, text, indx)
        
        self.AddPage(listCtrl, "AuiNotebook Preview", True, bitmap=auinotebook_preview.GetBitmap(), disabled_bitmap=wx.NullBitmap)
        return True


    def SetRenamable(self, page_idx, renamable):
        """
        Sets whether a tab can be renamed via a left double-click or not.

        :param `page_idx`: the page index;
        :param `renamable`: ``True`` if the page can be renamed.
        """

        if page_idx >= self._tabs.GetPageCount():
            return False
        
        # update our own tab catalog
        page_info = self._tabs.GetPage(page_idx)
        page_info.renamable = renamable

        # update what's on screen
        ctrl, ctrl_idx = self.FindTab(page_info.window)
        if not ctrl:
            return False
        
        info = ctrl.GetPage(ctrl_idx)
        info.renamable = page_info.renamable
        
        return True
        

    def IsRenamable(self, page_idx):
        """
        Returns whether a tab can be renamed or not.
        
        :param `page_idx`: the page index.

        :returns: ``True`` is a page can be renamed, ``False`` otherwise.        
        """

        if page_idx >= self._tabs.GetPageCount():
            return False

        page_info = self._tabs.GetPage(page_idx)
        return page_info.renamable


    def OnRenameCancelled(self, page_index):
        """
        Called by L{TabTextCtrl}, to cancel the changes and to send the
        `EVT_AUINOTEBOOK_END_LABEL_EDIT` event.

        :param `page_index`: the page index in the notebook.
        """

        # let owner know that the edit was cancelled
        evt = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_END_LABEL_EDIT, self.GetId())

        evt.SetSelection(page_index)
        evt.SetEventObject(self)
        evt.SetLabel("")
        evt.SetEditCanceled(True)
        self.GetEventHandler().ProcessEvent(evt)
                

    def OnRenameAccept(self, page_index, value):
        """
        Called by L{TabTextCtrl}, to accept the changes and to send the
        `EVT_AUINOTEBOOK_END_LABEL_EDIT` event.
        """

        evt = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_END_LABEL_EDIT, self.GetId())
        evt.SetSelection(page_index)
        evt.SetEventObject(self)
        evt.SetLabel(value)
        evt.SetEditCanceled(False)

        return not self.GetEventHandler().ProcessEvent(evt) or evt.IsAllowed()

                
    def ResetTextControl(self):
        """ Called by L{TabTextCtrl} when it marks itself for deletion. """

        if not self._textCtrl:
            return
        
        self._textCtrl.Destroy()
        self._textCtrl = None

        # tab height might have changed
        self.UpdateTabCtrlHeight(force=True)
        

    def EditTab(self, page_index):
        """
        Starts the editing of an item label, sending a `EVT_AUINOTEBOOK_BEGIN_LABEL_EDIT` event.

        :param `page_index`: the page index we want to edit.        
        """

        if page_index >= self._tabs.GetPageCount():
            return False

        if not self.IsRenamable(page_index):
            return False
        
        page_info = self._tabs.GetPage(page_index)        
        ctrl, ctrl_idx = self.FindTab(page_info.window)
        if not ctrl:
            return False

        evt = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_BEGIN_LABEL_EDIT, self.GetId())
        evt.SetSelection(page_index)
        evt.SetEventObject(self)
        if self.GetEventHandler().ProcessEvent(evt) and not evt.IsAllowed():
            # vetoed by user
            return False
    
        if self._textCtrl is not None and page_info != self._textCtrl.item():
            self._textCtrl.StopEditing()

        self._textCtrl = TabTextCtrl(ctrl, page_info, page_index)
        self._textCtrl.SetFocus()

        return True

########NEW FILE########
__FILENAME__ = aui_constants
"""
This module contains all the constants used by wxPython-AUI.

Especially important and meaningful are constants for AuiManager, AuiDockArt and
AuiNotebook.
"""

__author__ = "Andrea Gavana <andrea.gavana@gmail.com>"
__date__ = "31 March 2009"


import wx
from wx.lib.embeddedimage import PyEmbeddedImage

# ------------------------- #
# - AuiNotebook Constants - #
# ------------------------- #

# For tabart
# --------------

vertical_border_padding = 4
""" Border padding used in drawing tabs. """

if wx.Platform == "__WXMAC__":
    nb_close_bits = "\xFF\xFF\xFF\xFF\x0F\xFE\x03\xF8\x01\xF0\x19\xF3" \
                    "\xB8\xE3\xF0\xE1\xE0\xE0\xF0\xE1\xB8\xE3\x19\xF3" \
                    "\x01\xF0\x03\xF8\x0F\xFE\xFF\xFF"
    """ AuiNotebook close button image on wxMAC. """
    
elif wx.Platform == "__WXGTK__":
    nb_close_bits = "\xff\xff\xff\xff\x07\xf0\xfb\xef\xdb\xed\x8b\xe8" \
                    "\x1b\xec\x3b\xee\x1b\xec\x8b\xe8\xdb\xed\xfb\xef" \
                    "\x07\xf0\xff\xff\xff\xff\xff\xff"
    """ AuiNotebook close button image on wxGTK. """
    
else:
    nb_close_bits = "\xff\xff\xff\xff\xff\xff\xff\xff\xe7\xf3\xcf\xf9" \
                    "\x9f\xfc\x3f\xfe\x3f\xfe\x9f\xfc\xcf\xf9\xe7\xf3" \
                    "\xff\xff\xff\xff\xff\xff\xff\xff"
    """ AuiNotebook close button image on wxMSW. """

nb_left_bits = "\xff\xff\xff\xff\xff\xff\xff\xfe\x7f\xfe\x3f\xfe\x1f" \
               "\xfe\x0f\xfe\x1f\xfe\x3f\xfe\x7f\xfe\xff\xfe\xff\xff" \
               "\xff\xff\xff\xff\xff\xff"
""" AuiNotebook left button image. """

nb_right_bits = "\xff\xff\xff\xff\xff\xff\xdf\xff\x9f\xff\x1f\xff\x1f" \
                "\xfe\x1f\xfc\x1f\xfe\x1f\xff\x9f\xff\xdf\xff\xff\xff" \
                "\xff\xff\xff\xff\xff\xff"
""" AuiNotebook right button image. """

nb_list_bits = "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x0f" \
               "\xf8\xff\xff\x0f\xf8\x1f\xfc\x3f\xfe\x7f\xff\xff\xff" \
               "\xff\xff\xff\xff\xff\xff"
""" AuiNotebook windows list button image. """


#----------------------------------------------------------------------
tab_active_center = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAAEAAAAbCAYAAAC9WOV0AAAABHNCSVQICAgIfAhkiAAAADNJ"
    "REFUCJltzMEJwDAUw9DHX6OLdP/Bop4KDc3F2EIYrsFtrZow8GnH6OD1zvRTajvY2QMHIhNx"
    "jUhuAgAAAABJRU5ErkJggg==")
""" Center active tab image for the Chrome tab art. """

#----------------------------------------------------------------------
tab_active_left = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAA8AAAAbCAYAAACjkdXHAAAABHNCSVQICAgIfAhkiAAAAglJ"
    "REFUOI2Nkk9rE0EYh5/J7mpW06xE2iSmeFHxEoqIAc/FQ5CKgn4DP4KlIQG/QVsQbBEKgop+"
    "Anvy4rV4bLT2JCGJPVXqwaZJd+f1kN26WTfJDrzszDLPPL/5o0jeFGAC54A0YKmEYAo4DzjA"
    "LHAZmElqtIGrhmEsvtzcfPNtb6/V6524SWALKBiGsfhxe/uzFhGth5XEmgVubWxsvA1Az68k"
    "1nngYbPZ7ASg69c06wxwe3V9/b3reVqHwGmwCZRs2370fX//wIuA0+CLwEKj0XilZTSu602G"
    "FcP7vLe7+7XlRaCgPw62gGv5fP6p63raiwFdLWKOgdNArl6vV1UqpQgcYdcYbwooAPfb7c7h"
    "mTWmUjGwCWTL5fL1K6VSLiqQyMTYyLVa/UEwe9IC0chFYKnb/XnkeiIDV+Q0UsG/qNkCnEql"
    "crNQLDpaxpskJnYayD1bXl4S/xrDoPLHKjQOmsHwlCuHv44+ZJ2sLTrGGqzg7zEc+VK1Wl1w"
    "HMcG0DFxw6sFsRVwAZhdWak9FoRJ+w2HCKzzwN3jXv+daVmGDkdWoMKb9fumHz0DFFfX1p5Y"
    "lmXo6N0G48jzVEDOt97pdA9ezOXzGU+PzBmN6VuDqyoDN3Z2vjyfKxQynhYkJuJ/L02Ara3X"
    "n3602r8HrpaTUy3HAy1/+hNq8O+r+q4WETirmFMNBwm3v+gdmytKNIUpAAAAAElFTkSuQmCC")
""" Left active tab image for the Chrome tab art. """

#----------------------------------------------------------------------
tab_active_right = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAA8AAAAbCAYAAACjkdXHAAAABHNCSVQICAgIfAhkiAAAAkpJ"
    "REFUOI2NlM1rU0EUxX9zZ5KaWq3GKKnGutC0FEWCWAWLRUOxBetK/wdp6Re6F6TFXXGhuFdw"
    "b7dCQUUpiFt1XbB2q7Uf1iTvunjzkpe0afNgmLnDnHvOPe/OWCALtAFC+Cktfha4CRwBDnhg"
    "BQhaSrK19bf89dv35WfPX7y01haBbiAFmH3BlUA1Gm8WFt75BFkg0TK4VAl0Y3NL5+efvgIK"
    "wOH92EVjxRljGBi4VgTOeLDbk7kcqEZju1TWX7/Xgtm5J6+BS8ChvdilLhAhkUya4eFbxVQq"
    "1e3ZbUtgg8GKJd/Tk70/NjYCHCPsgX1kV8K5VA70z8amfvy0tAwMAcebSRfijikY8ez5/OlM"
    "JrOncbIjp4K1lmRb0sw8eDgCpAm7rwlz46YIzjpGb48WveyDNPhDfCOuHmNwzpHL5dK9fX3n"
    "mkmvaxJiayOCWMvM1PSdZtJrhiloLJMYIeESDFwf7Acyu0mXGLYmX0PpYi3ZbFdnoVDoBTpp"
    "uCxCjFob1tYKzlnGJyZHd5Mu6uVGkqvMCmCwzjE4eOMqcALoINauUic37hjhLXPWcTSdThWL"
    "QxcJX5yqdGk4H/cP9a4755iYnLpL+M/b8e0qjafrekb9TUskuNx/5TzQ5Y1zO9yOZEd1R7OI"
    "JdXebh/Pzt3zCToAMZv/AjU1orDWWKAGVJVSqcTqysp6X+/ZaeAL8KNac9wsVQ8yNeOsdZw8"
    "let4/2HpEdAPXDAb20HLj7xqeHT158ra4uLbz2bdg03krmetxrH9KDAmHP8Bn0j1t/01UV0A"
    "AAAASUVORK5CYII=")
""" Right active tab image for the Chrome tab art. """

#----------------------------------------------------------------------
tab_close = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAABHNCSVQICAgIfAhkiAAAAI9J"
    "REFUKJG90MEKAWEUxfEfM4rxAFIommzZzNb7v4BsLJTsiGQlYjHfME3flrO75/xvnXv5p/qY"
    "R/wcWTUktWCKFbrYB6/AAhecmwunAI/RwQAjbLGpoFakwjLATxzqMLQjC68A3/FohkljLkKN"
    "Ha4YKg8+VkBag3Pll9a1GikmuPk+4qMMs0jFMXoR/0d6A9JRFV/jxY+iAAAAAElFTkSuQmCC")
""" Normal close button image for the Chrome tab art. """

#----------------------------------------------------------------------
tab_close_h = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAABHNCSVQICAgIfAhkiAAAAOlJ"
    "REFUKJGVkiFuw0AQRd849hUS7iPUwGEllhyjYJ+gaK9Q4CsY9QTFIY4shQQucI8Q7l6h3Z0S"
    "r7UgjdrPZvVm52k0wpJLWe4y51qgVpECQFQnYPzabN4ra2cAAbgWxZMmyavAkTtROIn33fM0"
    "fcilLHep92+/wXHTd5K8JJlzbYD3w8C2aVZo2zTsh4FF5Zg516ZAHYBb35MbszbkxnDr+3hQ"
    "napIIUv1eT6vYPggvAGoSJE88r6XVFQnRA7BOdYIk8IUUZ1SYAQOsXOskRsT1+P/11pZO4v3"
    "ncLpESzed5W1c1jQn0/jBzPfck1qdmfjAAAAAElFTkSuQmCC")
""" Hover close button image for the Chrome tab art. """

#----------------------------------------------------------------------
tab_close_p = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAABHNCSVQICAgIfAhkiAAAASxJ"
    "REFUKJF9kbFLQlEYxX/nvbs55OAkiJAE7k7Nibo9xf+hrTlyr3Boipb+BCGq0bApJEQcG0Ms"
    "aQ0Lmq5+Dc+nDtbZ7uHce37fd8VSlWwh50PfRKqClWJXI8y6bu5uHj5e3wEEcJDP75txLBSx"
    "RYbdS7QfJ5PnsJIt5BbB4hQjkrQtjxlFILOXyvQDH/qmUCSJznDAYetkFTxsndAZDggkhCIf"
    "+qaLmWP1bu8oN+qrC+VGnd7t3bpKqrp4wBjl+ux8FUweSLwlXCnYCv2PHGgE1BLmTYykad2i"
    "kcOsi1TbZN7EKDfq67NZV5VsIeedvzQjCv5YK8R/4bw7Cl+/P7920+kJkBEq/hWWaPem45cQ"
    "YDybTfdSmf5CizckwHaAH9ATZldu7i560/ELwC+6RXdU6KzezAAAAABJRU5ErkJggg==")
""" Pressed close button image for the Chrome tab art. """

#----------------------------------------------------------------------
tab_inactive_center = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAAEAAAAbCAYAAAC9WOV0AAAABHNCSVQICAgIfAhkiAAAAElJ"
    "REFUCJlVyiEOgDAUBNHp3qmX5iYkyMpqBAaFILRdDGn4qybZB98yy3ZZrRu1PpABAQiDSLN+"
    "h4NLEU8CBAfoPHZUywr3M/wCTz8c3/qQrUcAAAAASUVORK5CYII=")
""" Center inactive tab image for the Chrome tab art. """

#----------------------------------------------------------------------
tab_inactive_left = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAA8AAAAbCAYAAACjkdXHAAAABHNCSVQICAgIfAhkiAAAAf5J"
    "REFUOI2llE1rE1EUhp8bZwyhaZomk5DaD40hSWPQVkTd6KIIEUWlLqTEhTaLulBQ6sfKjeBC"
    "ECULXQku/Alx7d6/U1EQae45LjJpJ5NOnOKBgYG5z33Px3sG/iPMIc87QAmYBZKHgdOu69a2"
    "3/W2yrVGK5vPLTlxFV3Xrb3+8v1Ntd5oiSpWBmnEidKT972tar3R6ovSt4qoxoIdoFipNlpW"
    "B6AVRYFEHNWn3a8dz/PK1rIHEgN2UpnMseVTK7fUGBME48CFe88+3sh5+SXr1xmMSbABvJXz"
    "l9siYAVGWJ0Mu/OVZr5Q8CpWfFWzD2Imj2qu/fhtG4wRVUIZg0bDBsgtn15dt6qIKKBDQZ81"
    "kWmnzly6OZ+ZzhSt7jfK6CBjFMwEk5TWOy82AVQGhzVUb5RJEkC2fLK6JgIiPhioeZJJUhev"
    "3j2RTqdzooqge2ojCxwxqrnrG4/uq4Ida3HgAjMOJ4CZSq1+RVBUzCgQinDDstfa282jyeTU"
    "rhUGF4CJgMPKhbXbmw9VFfG7fBA4LCao7AAzi8cXz1kF0dENMqH38KgWnnd7nSMJxxE5wI4+"
    "MHyCaeeAYvPshQ0RJby3wVSDHxxgAVh99elb9/evndmfP3boW2FsqGNhMMCdBy8/fJ5KZ6at"
    "qL+3Q1dEzFkNGMX82ZWh18e0/vVT/wuFmdYVv/ruKgAAAABJRU5ErkJggg==")
""" Left inactive tab image for the Chrome tab art. """

#----------------------------------------------------------------------
tab_inactive_right = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAA8AAAAbCAYAAACjkdXHAAAABHNCSVQICAgIfAhkiAAAAhBJ"
    "REFUOI2llM9rE1EQxz8zb1dSTKNuYtW01kQDRoKFWi9FEEq1IooUUWoPokWCtVqkR69KsSBU"
    "8OJRPOhBxZNe/At6FBER/HFUPEq1IGn3ecgm2ZjdJODCHPY9vvP9fufNDPzHZ4DDQBrYBKwB"
    "ftfoJys/Kw9ef/1y8/6rh67rHgKS3WLl6cqqtcCGD58+vn+zdPXorUql8g5Y7wTWdd+y4Vus"
    "teQK+yfKi8/KwM5umBXAAgioCIP54gTQBzgdwTbsQZR0JpOfXXw+0w27hn9EBGMcyRcPnulJ"
    "pbKd2JvACKgKnpcePH99+TSwvT3YEphusKsqB4ZHp4FMNWUn5loSEVSFbZ63b8eeUhpwu5Md"
    "JBFRjHHk7LXb08CuNuAaZTgEEaFQHJoEvDjpakOYmnURUFWSvam+0ujJfqAnmlnABhG2jlTZ"
    "j19YuEzMm7dUu34hihrDQG7vGLCViPq0VruuvdquyWSvN3xsKhclvbXaoUQiihFlfLJ8iYiq"
    "O/EtUC2xGGF3vjAObAnI6stCsZbYCLwnEonNY+dulALvHWSH2YN2PXLq4hz/9HpjnmOs18DZ"
    "bP9IIL0+afV5juqzRgLFcV1n9u6LGWAgWnaMBFHBOIbi0MgU1S3jAcjyyw9xqpvzWou1Pj++"
    "f/t8b/7EAvBW5u48agU37abWs99rv1YfL81fkT8V34YxbZ696d4CfwEszZSZx6Z26wAAAABJ"
    "RU5ErkJggg==")
""" Right inactive tab image for the Chrome tab art. """

# For auibook
# -----------

AuiBaseTabCtrlId = 5380
""" Base window identifier for AuiTabCtrl. """

AUI_NB_TOP                 = 1 << 0
""" With this style, tabs are drawn along the top of the notebook. """
AUI_NB_LEFT                = 1 << 1  # not implemented yet
""" With this style, tabs are drawn along the left of the notebook.
Not implemented yet. """
AUI_NB_RIGHT               = 1 << 2  # not implemented yet
""" With this style, tabs are drawn along the right of the notebook.
Not implemented yet. """
AUI_NB_BOTTOM              = 1 << 3
""" With this style, tabs are drawn along the bottom of the notebook. """
AUI_NB_TAB_SPLIT           = 1 << 4
""" Allows the tab control to be split by dragging a tab. """
AUI_NB_TAB_MOVE            = 1 << 5
""" Allows a tab to be moved horizontally by dragging. """
AUI_NB_TAB_EXTERNAL_MOVE   = 1 << 6
""" Allows a tab to be moved to another tab control. """
AUI_NB_TAB_FIXED_WIDTH     = 1 << 7
""" With this style, all tabs have the same width. """
AUI_NB_SCROLL_BUTTONS      = 1 << 8
""" With this style, left and right scroll buttons are displayed. """
AUI_NB_WINDOWLIST_BUTTON   = 1 << 9
""" With this style, a drop-down list of windows is available. """
AUI_NB_CLOSE_BUTTON        = 1 << 10
""" With this style, a close button is available on the tab bar. """
AUI_NB_CLOSE_ON_ACTIVE_TAB = 1 << 11
""" With this style, a close button is available on the active tab. """
AUI_NB_CLOSE_ON_ALL_TABS   = 1 << 12
""" With this style, a close button is available on all tabs. """
AUI_NB_MIDDLE_CLICK_CLOSE  = 1 << 13
""" Allows to close `AuiNotebook` tabs by mouse middle button click. """
AUI_NB_SUB_NOTEBOOK        = 1 << 14
""" This style is used by `AuiManager` to create automatic `AuiNotebooks`. """
AUI_NB_HIDE_ON_SINGLE_TAB  = 1 << 15
""" Hides the tab window if only one tab is present. """
AUI_NB_SMART_TABS          = 1 << 16
""" Use `Smart Tabbing`, like ``Alt`` + ``Tab`` on Windows. """
AUI_NB_USE_IMAGES_DROPDOWN = 1 << 17
""" Uses images on dropdown window list menu instead of check items. """
AUI_NB_CLOSE_ON_TAB_LEFT   = 1 << 18
""" Draws the tab close button on the left instead of on the right
(a la Camino browser). """
AUI_NB_TAB_FLOAT           = 1 << 19
""" Allows the floating of single tabs.
Known limitation: when the notebook is more or less full screen, tabs 
cannot be dragged far enough outside of the notebook to become 
floating pages. """
AUI_NB_DRAW_DND_TAB        = 1 << 20
""" Draws an image representation of a tab while dragging. """
AUI_NB_ORDER_BY_ACCESS     = 1 << 21
""" Tab navigation order by last access time. """

AUI_NB_DEFAULT_STYLE = AUI_NB_TOP | AUI_NB_TAB_SPLIT | AUI_NB_TAB_MOVE | \
                       AUI_NB_SCROLL_BUTTONS | AUI_NB_CLOSE_ON_ACTIVE_TAB | \
                       AUI_NB_MIDDLE_CLICK_CLOSE | AUI_NB_DRAW_DND_TAB
""" Default `AuiNotebook` style. """

#----------------------------------------------------------------------
Mondrian = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAHFJ"
    "REFUWIXt1jsKgDAQRdF7xY25cpcWC60kioI6Fm/ahHBCMh+BRmGMnAgEWnvPpzK8dvrFCCCA"
    "coD8og4c5Lr6WB3Q3l1TBwLYPuF3YS1gn1HphgEEEABcKERrGy0E3B0HFJg7C1N/f/kTBBBA"
    "+Vi+AMkgFEvBPD17AAAAAElFTkSuQmCC")
""" Default icon for the Smart Tabbing dialog. """

# -------------------------- #
# - FrameManager Constants - #
# -------------------------- #

# Docking Styles
AUI_DOCK_NONE = 0
""" No docking direction. """
AUI_DOCK_TOP = 1
""" Top docking direction. """
AUI_DOCK_RIGHT = 2
""" Right docking direction. """
AUI_DOCK_BOTTOM = 3
""" Bottom docking direction. """
AUI_DOCK_LEFT = 4
""" Left docking direction. """
AUI_DOCK_CENTER = 5
""" Center docking direction. """
AUI_DOCK_CENTRE = AUI_DOCK_CENTER
""" Centre docking direction. """
AUI_DOCK_NOTEBOOK_PAGE = 6
""" Automatic AuiNotebooks docking style. """

# Floating/Dragging Styles
AUI_MGR_ALLOW_FLOATING           = 1 << 0
""" Allow floating of panes. """
AUI_MGR_ALLOW_ACTIVE_PANE        = 1 << 1
""" If a pane becomes active, "highlight" it in the interface. """
AUI_MGR_TRANSPARENT_DRAG         = 1 << 2
""" If the platform supports it, set transparency on a floating pane
while it is dragged by the user. """
AUI_MGR_TRANSPARENT_HINT         = 1 << 3
""" If the platform supports it, show a transparent hint window when
the user is about to dock a floating pane. """
AUI_MGR_VENETIAN_BLINDS_HINT     = 1 << 4
""" Show a "venetian blind" effect when the user is about to dock a
floating pane. """
AUI_MGR_RECTANGLE_HINT           = 1 << 5
""" Show a rectangle hint effect when the user is about to dock a
floating pane. """
AUI_MGR_HINT_FADE                = 1 << 6
""" If the platform supports it, the hint window will fade in and out. """
AUI_MGR_NO_VENETIAN_BLINDS_FADE  = 1 << 7
""" Disables the "venetian blind" fade in and out. """
AUI_MGR_LIVE_RESIZE              = 1 << 8
""" Live resize when the user drag a sash. """
AUI_MGR_ANIMATE_FRAMES           = 1 << 9
""" Fade-out floating panes when they are closed (all platforms which support
frames transparency) and show a moving rectangle when they are docked
(Windows < Vista and GTK only). """
AUI_MGR_AERO_DOCKING_GUIDES      = 1 << 10
""" Use the new Aero-style bitmaps as docking guides. """
AUI_MGR_PREVIEW_MINIMIZED_PANES  = 1 << 11
""" Slide in and out minimized panes to preview them. """
AUI_MGR_WHIDBEY_DOCKING_GUIDES   = 1 << 12
""" Use the new Whidbey-style bitmaps as docking guides. """
AUI_MGR_SMOOTH_DOCKING           = 1 << 13
""" Performs a "smooth" docking of panes (a la PyQT). """
AUI_MGR_USE_NATIVE_MINIFRAMES    = 1 << 14
""" Use miniframes with native caption bar as floating panes instead or custom
drawn caption bars (forced on wxMac). """
AUI_MGR_AUTONB_NO_CAPTION        = 1 << 15
""" Panes that merge into an automatic notebook will not have the pane
caption visible. """


AUI_MGR_DEFAULT = AUI_MGR_ALLOW_FLOATING | AUI_MGR_TRANSPARENT_HINT | \
                  AUI_MGR_HINT_FADE | AUI_MGR_NO_VENETIAN_BLINDS_FADE
""" Default `AuiManager` style. """

# Panes Customization
AUI_DOCKART_SASH_SIZE = 0
""" Customizes the sash size. """
AUI_DOCKART_CAPTION_SIZE = 1
""" Customizes the caption size. """
AUI_DOCKART_GRIPPER_SIZE = 2
""" Customizes the gripper size. """
AUI_DOCKART_PANE_BORDER_SIZE = 3
""" Customizes the pane border size. """
AUI_DOCKART_PANE_BUTTON_SIZE = 4
""" Customizes the pane button size. """
AUI_DOCKART_BACKGROUND_COLOUR = 5
""" Customizes the background colour. """
AUI_DOCKART_BACKGROUND_GRADIENT_COLOUR = 6
""" Customizes the background gradient colour. """
AUI_DOCKART_SASH_COLOUR = 7
""" Customizes the sash colour. """
AUI_DOCKART_ACTIVE_CAPTION_COLOUR = 8
""" Customizes the active caption colour. """
AUI_DOCKART_ACTIVE_CAPTION_GRADIENT_COLOUR = 9
""" Customizes the active caption gradient colour. """
AUI_DOCKART_INACTIVE_CAPTION_COLOUR = 10
""" Customizes the inactive caption colour. """
AUI_DOCKART_INACTIVE_CAPTION_GRADIENT_COLOUR = 11
""" Customizes the inactive gradient caption colour. """
AUI_DOCKART_ACTIVE_CAPTION_TEXT_COLOUR = 12
""" Customizes the active caption text colour. """
AUI_DOCKART_INACTIVE_CAPTION_TEXT_COLOUR = 13
""" Customizes the inactive caption text colour. """
AUI_DOCKART_BORDER_COLOUR = 14
""" Customizes the border colour. """
AUI_DOCKART_GRIPPER_COLOUR = 15
""" Customizes the gripper colour. """
AUI_DOCKART_CAPTION_FONT = 16
""" Customizes the caption font. """
AUI_DOCKART_GRADIENT_TYPE = 17
""" Customizes the gradient type (no gradient, vertical or horizontal). """
AUI_DOCKART_DRAW_SASH_GRIP = 18
""" Draw a sash grip on the sash. """

# Caption Gradient Type
AUI_GRADIENT_NONE = 0
""" No gradient on the captions. """
AUI_GRADIENT_VERTICAL = 1
""" Vertical gradient on the captions. """
AUI_GRADIENT_HORIZONTAL = 2
""" Horizontal gradient on the captions. """

# Pane Button State
AUI_BUTTON_STATE_NORMAL = 0
""" Normal button state. """
AUI_BUTTON_STATE_HOVER = 1 << 1
""" Hovered button state. """
AUI_BUTTON_STATE_PRESSED = 1 << 2
""" Pressed button state. """
AUI_BUTTON_STATE_DISABLED = 1 << 3
""" Disabled button state. """
AUI_BUTTON_STATE_HIDDEN   = 1 << 4
""" Hidden button state. """
AUI_BUTTON_STATE_CHECKED  = 1 << 5
""" Checked button state. """

# Pane minimize mode
AUI_MINIMIZE_POS_SMART    = 0x01
""" Minimizes the pane on the closest tool bar. """
AUI_MINIMIZE_POS_TOP      = 0x02
""" Minimizes the pane on the top tool bar. """
AUI_MINIMIZE_POS_LEFT     = 0x03
""" Minimizes the pane on its left tool bar. """
AUI_MINIMIZE_POS_RIGHT    = 0x04
""" Minimizes the pane on its right tool bar. """
AUI_MINIMIZE_POS_BOTTOM   = 0x05
""" Minimizes the pane on its bottom tool bar. """
AUI_MINIMIZE_POS_MASK     = 0x07
""" Mask to filter the position flags. """
AUI_MINIMIZE_CAPT_HIDE    = 0
""" Hides the caption of the minimized pane. """
AUI_MINIMIZE_CAPT_SMART   = 0x08
""" Displays the caption in the best rotation (horz or clockwise). """
AUI_MINIMIZE_CAPT_HORZ    = 0x10
""" Displays the caption horizontally. """
AUI_MINIMIZE_CAPT_MASK    = 0x18
""" Mask to filter the caption flags. """

# Button kind
AUI_BUTTON_CLOSE = 101
""" Shows a close button on the pane. """
AUI_BUTTON_MAXIMIZE_RESTORE = 102
""" Shows a maximize/restore button on the pane. """
AUI_BUTTON_MINIMIZE = 103
""" Shows a minimize button on the pane. """
AUI_BUTTON_PIN = 104
""" Shows a pin button on the pane. """
AUI_BUTTON_OPTIONS = 105
""" Shows an option button on the pane (not implemented). """
AUI_BUTTON_WINDOWLIST = 106
""" Shows a window list button on the pane (for AuiNotebook). """
AUI_BUTTON_LEFT = 107
""" Shows a left button on the pane (for AuiNotebook). """
AUI_BUTTON_RIGHT = 108
""" Shows a right button on the pane (for AuiNotebook). """
AUI_BUTTON_UP = 109
""" Shows an up button on the pane (not implemented). """
AUI_BUTTON_DOWN = 110
""" Shows a down button on the pane (not implemented). """
AUI_BUTTON_CUSTOM1 = 201
""" Shows a custom button on the pane. """
AUI_BUTTON_CUSTOM2 = 202
""" Shows a custom button on the pane. """
AUI_BUTTON_CUSTOM3 = 203
""" Shows a custom button on the pane. """
AUI_BUTTON_CUSTOM4 = 204
""" Shows a custom button on the pane. """
AUI_BUTTON_CUSTOM5 = 205
""" Shows a custom button on the pane. """
AUI_BUTTON_CUSTOM6 = 206
""" Shows a custom button on the pane. """
AUI_BUTTON_CUSTOM7 = 207
""" Shows a custom button on the pane. """
AUI_BUTTON_CUSTOM8 = 208
""" Shows a custom button on the pane. """
AUI_BUTTON_CUSTOM9 = 209
""" Shows a custom button on the pane. """

# Pane Insert Level
AUI_INSERT_PANE = 0
""" Level for inserting a pane. """
AUI_INSERT_ROW = 1
""" Level for inserting a row. """
AUI_INSERT_DOCK = 2
""" Level for inserting a dock. """

# Action constants
actionNone = 0
""" No current action. """
actionResize = 1
""" Resize action. """
actionClickButton = 2
""" Click on a pane button action. """
actionClickCaption = 3
""" Click on a pane caption action. """
actionDragToolbarPane = 4
""" Drag a floating toolbar action. """
actionDragFloatingPane = 5
""" Drag a floating pane action. """

# Drop/Float constants
auiInsertRowPixels = 10
""" Number of pixels between rows. """
auiNewRowPixels = 40
""" Number of pixels for a new inserted row. """
auiLayerInsertPixels = 40
""" Number of pixels between layers. """
auiLayerInsertOffset = 5
""" Number of offset pixels between layers. """
auiToolBarLayer = 10
""" AUI layer for a toolbar. """

# some built in bitmaps

if wx.Platform == "__WXMAC__":

    close_bits = "\xFF\xFF\xFF\xFF\x0F\xFE\x03\xF8\x01\xF0\x19\xF3\xB8\xE3\xF0" \
                 "\xE1\xE0\xE0\xF0\xE1\xB8\xE3\x19\xF3\x01\xF0\x03\xF8\x0F\xFE\xFF\xFF"
    """ Close button bitmap for a pane on wxMAC. """

elif wx.Platform == "__WXGTK__":

    close_bits = "\xff\xff\xff\xff\x07\xf0\xfb\xef\xdb\xed\x8b\xe8\x1b\xec\x3b\xee" \
                 "\x1b\xec\x8b\xe8\xdb\xed\xfb\xef\x07\xf0\xff\xff\xff\xff\xff\xff"
    """ Close button bitmap for a pane on wxGTK. """

else:

    close_bits = "\xff\xff\xff\xff\xff\xff\xff\xff\xcf\xf3\x9f\xf9\x3f\xfc\x7f\xfe" \
                 "\x3f\xfc\x9f\xf9\xcf\xf3\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
    """ Close button bitmap for a pane on wxMSW. """

pin_bits     = '\xff\xff\xff\xff\xff\xff\x1f\xfc\xdf\xfc\xdf\xfc\xdf\xfc\xdf\xfc' \
               '\xdf\xfc\x0f\xf8\x7f\xff\x7f\xff\x7f\xff\xff\xff\xff\xff\xff\xff'
""" Pin button bitmap for a pane. """

max_bits     = '\xff\xff\xff\xff\xff\xff\x07\xf0\xf7\xf7\x07\xf0\xf7\xf7\xf7\xf7' \
               '\xf7\xf7\xf7\xf7\xf7\xf7\x07\xf0\xff\xff\xff\xff\xff\xff\xff\xff'
""" Maximize button bitmap for a pane. """

restore_bits = '\xff\xff\xff\xff\xff\xff\x1f\xf0\x1f\xf0\xdf\xf7\x07\xf4\x07\xf4' \
               '\xf7\xf5\xf7\xf1\xf7\xfd\xf7\xfd\x07\xfc\xff\xff\xff\xff\xff\xff'
""" Restore/maximize button bitmap for a pane. """

minimize_bits = '\xff\xff\xff\xff\xff\xff\x07\xf0\xf7\xf7\x07\xf0\xff\xff\xff\xff' \
                '\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff'
""" Minimize button bitmap for a pane. """

restore_xpm = ["16 15 3 1",
               "       c None",
               ".      c #000000",
               "+      c #FFFFFF",
               "                ",
               "     .......... ",
               "     .++++++++. ",
               "     .......... ",
               "     .++++++++. ",
               " ..........+++. ",
               " .++++++++.+++. ",
               " ..........+++. ",
               " .++++++++..... ",
               " .++++++++.     ",
               " .++++++++.     ",
               " .++++++++.     ",
               " .++++++++.     ",
               " ..........     ",
               "                "]
""" Restore/minimize button bitmap for a pane. """

#----------------------------------------------------------------------

down_focus_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB0AAAAgCAIAAABhFeQrAAAAA3NCSVQICAjb4U/gAAACaUlE"
    "QVRIib2WvWsUQRjGn5mdnWxyTaqz9q+QlLnGToSgWAYDNjbpNCAGDGIvaRPbNJGQyiAEbK+w"
    "sAo2qexyEhbxsvt+jMXc3u3liPfhmWeXnWVm9vc+vO/M7prVzTb+gxyA7Ye/nXPWWmvtXKBb"
    "B9YBcM5lWZam6by4QNcBsNamaeq9d87NmWutdc59+NgGoKIizCwsxMTMFI8oZmZilzomZiFm"
    "FWERaXbv7eyueO+TJEHM79LSkvfeWnv2qftgex2ASGDmkrUkKUspiIuCy5IL4qKQgnghdQVx"
    "ScKsxCKiaH8lIu99NOwAEFGsG4Dv5xeiQYOKBBYVUWJlFhIVVmIlEZGQJKVIYBbWoKqqwQN5"
    "nqdpuri42OMys6rGOG/X78yW0bXWNyLqcyyAEEIIYcYK3aB5Lazb4o5fsPc3ToFaloxBwMle"
    "6+9Pjfd7stda6HR85+dCPC86Y6ETcQEcHz32eZ7meZrnx0ePJnlk0vwenm70r/PkTgWdjjuV"
    "rnPPfvxaa+3NcL3GMaub7XdPtNFoZFn24tmX1/trAOLuM6aaFQwQYExAMPWNaUw1FW+eHj5/"
    "dbfZbDYajY33F7e1L4gUA5uo3fd8AWbQH70bjGqEyxLq3LoMYhKCgakCIWZoLLdkMRE43Iy0"
    "tWi9QOP8xoIFAyBUjF7dgOizb9iMhLmByxIAHbAGKYigUPX3hqog47hSvfCHfYRaDcNg3IzO"
    "7GmydRaGi37zMujrut/9l58nijROQ9yd3ZXLy8urq6vZWFmW9f+Yhrje++XlZR2keDpZa4f+"
    "H/pKkiR+/f9dDsDWgQW6QHcuxKg/ZbVtCjjzINkAAAAASUVORK5CYII=")
""" VS2005 focused docking guide window down bitmap. """

#----------------------------------------------------------------------
down_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB0AAAAgCAIAAABhFeQrAAAAA3NCSVQICAjb4U/gAAACY0lE"
    "QVRIib2WwWrUUBSG/3tzc5s2m0JhXPsU0u1s3Lkpui4W3PgAuhAFi2/QbesTVEphwCIU3Hbh"
    "wk2LG1fujJQgtMk55x4Xd2aS6VAzM479JyQhufnOz3/uzcQMBgP8BzkAeZ4756y11tqlQIui"
    "cACcc1mWpWm6ZK61Nk1T771zbilcxBxiAs659x/OAAQJIswsLMTEzBR/UczMxC51TMxCzEGE"
    "RaR39WB3b9N7nyTJkLu2tua9t9ZefLx69GYbgIgyc82hJqlrqYiriuuaK+Kqkop4JXUVcU3C"
    "HIhFJODsCxF57xu/RBT7BuDb958SNGgQUZYgEogDs5AE4UAcSEREk6QWUWbhoCGEENQDZVmm"
    "abq6ujrkMnMIIdZ5t31vsUC3+l+JaMyxAFRVVRds0C1azsS6O273hH24cwq0UjIGipP9/t+f"
    "6vZ7st9fKQpf/FqJ28+iEzoTF8Dx0RNflmlZpmV5fPR4lkdmzffwdGe8XyZ3Luh83Ll0k3vx"
    "4/dWf3+B/Q2OGQwGGxsbeZ5nWfbi2efXB1sA4uozZjRKDaAwRqGmvTCNGQ3F26eHz1/d7/V6"
    "eZ6fn5/f1bogCmhsonU+9AWY5nr0bjCtKS6LtrltGcQQ1MCMCiEm1MmtWUwETh6mjq1qw0Jd"
    "fmPD1ADQEWPYNyD6HBs2U2Vu4bIoEBpWE0EE6ej68NaoSBdXRi/8SR/a6qE29830yKFmm2c6"
    "2fTbp8FYN/0evPw0U6UuTXB39zYvLy+vr68XY2VZNv5imuB679fX10MT8Xyy1k58P4yVJEn8"
    "9/93OQBFURRFsRTcWH8An5lwqISXsWUAAAAASUVORK5CYII=")
""" VS2005 unfocused docking guide window down bitmap. """

#----------------------------------------------------------------------
left_focus_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAdCAIAAABE/PnQAAAAA3NCSVQICAjb4U/gAAACVElE"
    "QVRIibWWvW8TQRDF3+7Ors8ShSsaSpo0dEgoFcINVChSBFRUkajpIKKgiPgP0pqGJiAhITqE"
    "FIk2BQUVHT2VK+y7ndmhWN/5Ixcbh8tYWvtO8vvdm5mdPXPv+RmuMgjA670/RGSttdZ2q354"
    "YgkAERVF4b3vHABMCIC11nsfQiCiqwJYa4noxbNvOw/6AJIk62ySJMLMwhI5MnPMnxzMzJHJ"
    "E0dmicxJhEXk+uTO0fFuCME5h1yDxbh5+zEz93q+LGOv50WUmStOVZSqkjJyWXJVcRm5LKWM"
    "3PNURq6iMKfIIpJw9n08Hg8Gg36/3wL4+eu3iHpykcWTS5pElCWJpMiJWaIk4RQ5RRERda4S"
    "UWbhpCmllDQA0+k0pZQFVwF3bzEAZ5N3jgje+0COnPVknbUAdm5cW5/1/eGPxcuL2saoAczC"
    "DQWAV0/fr1c/HxcBFNC8QGEMMu3NuyddAfIjG9QLjKJTB3NIHV050EZuoQI6+93q4P7B6TYA"
    "A2gW1xlC61K0OXi492HZ6EbAnGFqEmBmhlYc7A9HutRq/wgA5plSwDT9tORgfzgCNsmv2QfQ"
    "OvEwps7BooOPpwebxFsB83wazdWdl321BjOGWWejrciZ0+wBMwef76LPnx6trXFrivIfVOsl"
    "P2V7FwH4MhpuCTBLX7mjckU628naTImlrdDdLDJ59OT+XDDU8SwyTX+Y2bC7hIPVA+fty6/b"
    "SmwBODreHY/H0+n0P0WLomjegJYAIYTBYNAcp5cOa20IoQXgnMuvAh0GATg8scAEmHQrneMv"
    "3LAo6X/e0vAAAAAASUVORK5CYII=")
""" VS2005 focused docking guide window left bitmap. """

#----------------------------------------------------------------------
left_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAdCAIAAABE/PnQAAAAA3NCSVQICAjb4U/gAAACTklE"
    "QVRIibWWPWsUURSG3/u5u8RiKxtLmzR2gqQSttFKhKBWqQL+BQXL4D9IGxsrBUGEFCIEbC0s"
    "rOzshYHt3Jl7PizuzsduJhs3Ts7C3Z2BfZ95zzn33DGnp6e4zvAAdnZ2vPfWWmvtsOpFUXgA"
    "3vvxeBxCuC6AtTaEEGP03g8LQE5RTo73/sXzr7sPJwCExTorLMxExMSJEhGl/MlBRJTIB0+J"
    "iBORMBMz3/xz7+h4L8bonFsCunH77lMiGo1CWabRKDArEVUkVeKq4jJRWVJVUZmoLLlMNAq+"
    "TFQlJpJEzCz49n0+n0+n08lk0gP4+es3swbvEnHwTlSYlViYJZEQcWJhkkSSmJnVuYpZiZhE"
    "RUREI7BYLESkTVE37t8hAM5KcM57hBCid97Z4K2zFsDurRubk74/+9G9vKhtjBrAdG4oALw6"
    "eLdZ/XxcBFBA8wKFMci012+fDQXIj2xQLzCKQR20kDqGcqCNXKcCuvzd6+DB4dk2AANoFtcl"
    "QutS9Dl49Pj9qtFLAS3D1CTALA2tOdifnehKq/0jAGgzpYBp+mnFwf7sBLhMfsM+gNaJhzF1"
    "DroOPpwdXibeC2jzaTRXty37eg2WDLPJRl+RM6fZA6YFn++iTx+fbKxxb4ryH1TrJT9lfxcB"
    "+Hwy2xJgVr5yR+WKDLaTtZkSK1thuFlk8ujJ/dkxNPAsMk1/mOWwu4KD9QPnzcsv20psATg6"
    "3pvP54vF4j9Fx+Nx8wa0AogxTqfT5ji9clhrY4w9AOdcfhUYMDyAoiiKohhWt4m/9Qss43IB"
    "CBMAAAAASUVORK5CYII=")
""" VS2005 unfocused docking guide window left bitmap. """

#----------------------------------------------------------------------
right_focus_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAdCAIAAABE/PnQAAAAA3NCSVQICAjb4U/gAAACWElE"
    "QVRIibWWv2/TQBTHv3e+uyRbJwZWFv4AJNSRLjChSkhlYqrEzFZVDAwVC3PXsrAUISTExlKJ"
    "tQMSWzcmFqaqQqT2+8VwtuMkbiBp+mzF0pPz/dzX7z373IMXp7jJCABebf8JIXjvvffrVd8/"
    "9gFACGE4HMYY1w4AxgGA9z7GmFIKIdwUwHsfQth7/vXuoxEAFfWFV1ERZhYWYmJmykcOZmbi"
    "EAMTsxCzirCI3BrfPzjcTCkVRYFcg27cubfDzINBLEsaDKKIMXPFWpFUlZTEZclVxSVxWUpJ"
    "PIihJK5ImJVYRBSn387Pzzc2NkajUQ/g7McvEYuhIJYYCjUVMRYVUWJlFhIVVmIlERErikrE"
    "mIXVVFXVEnB5eamqWXAW8Gb39uKHevbzNwARZVFirUSIlFkqEVUD8Pb71P1Lt83LZ+8BAA7O"
    "AYABMAPcFfcvDXj97ikA5wxmHVVrf64LyA7Mau1so770uVjRQa1lzaKtSc2ZWAR4uHsyn2xq"
    "YBnjbFp4zsRCBw6Ptz/M5GoHgLla15AfUV8F/gEwA/Bk66jPgXNwMNhkyf199F816DIaB5bx"
    "yB2aO2qFLsp/+Xiy22YmczA1Cq4hLQlwsK56xwHgumLWln0pgPv8aWcmNdVF7TKujkWAL0db"
    "88nagXWb0xYgVn4XWf0CymdzWQNgapJzWC7HCnPQF5M5aBhXzthqgMkcoF57Zxx6YvaDMzO3"
    "148pwMHhJhFdXFwQ0XVEh8NhuwOaAqSUUkoxxvaLulp471NKPYC80ci7gXVFALB/7IExMF6j"
    "bht/AXIQRaTUgkiHAAAAAElFTkSuQmCC")
""" VS2005 focused docking guide window right bitmap. """

#----------------------------------------------------------------------
right_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAdCAIAAABE/PnQAAAAA3NCSVQICAjb4U/gAAACVElE"
    "QVRIibWWv2sUQRTHvzM7M3dHmlQWtjb+AYKkTaOVCEKsrAL+CxaWwcY6bWysRAQRUtgEbC0E"
    "u3RWNsJCCILZfb8sZvdu925zej/yveMWHnvvM9837+2OOz09xU0qANjZ2QkheO+999vNXpZl"
    "ABBCGI/HMcabAnjvY4wppRDCdgHIJcrFCSG8eP7l7sMJABX1hVdREWYWFmJiZsqfLGZm4hAD"
    "E7MQs4qwiNz6c//oeC+lVBRFA+jqzr0DZh6NYlXRaBRFjJlr1pqkrqUiriqua66Iq0oq4lEM"
    "FXFNwqzEIqL4+u3i4mJ3d3cymQwAzn/8ErEYCmKJoVBTEWNRESVWZiFRYSVWEhGxoqhFjFlY"
    "TVVVLQFXV1eqOitRV68Pby+v6fnP3wBElEWJtRYhUmapRVQNwJvvvftXbpuXz94BABycAwAD"
    "YAa4a+5fGfDq7VMAzhnMOllt+rMpIDswa3JnG81lyMWaDppc1i7a2tCCiWWAB4dni8F2Dyxj"
    "nPUTL5hY6sDh0eP3c7HGAWCuyWvIJRragX8AzAA82T8ZcuAcHAw2W/JwH/3XHnQZrQPLeOQO"
    "zR21Rhflv3w4O5xGZnPQGwXXklYEOFg3e8cB4LrJbLrtKwHcp48Hc6FeF02Xcb2WAT6f7C8G"
    "GwfWbU5bglj7WWTNAyh/28sWAL1JzrK8HWvMwZBmc9Ayrp2x9QCzOUCz9s44DGj+hTM3t5ur"
    "Bzg63iOiy8tLItok6Xg8np6AeoCUUkopxjh9o64n731KaQCQDxr5NLAtBQBlWZZlucWkXf0F"
    "imtJnvbT2psAAAAASUVORK5CYII=")
""" VS2005 unfocused docking guide window right bitmap. """

#----------------------------------------------------------------------
tab_focus_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB0AAAAdCAIAAADZ8fBYAAAAA3NCSVQICAjb4U/gAAAC10lE"
    "QVRIidWWT0gUcRTH387+ZveXZgzsbmvSsmqEfzBJSYz+gUsHCYJgISPytCQKFhJdpIN0qIUO"
    "ezIUaU/roQ5eEzp46ZT/DhG4haCXdSUPK+Wuzvze+02HgdFmFqMtD76Bx8yb3/v8vr/3Zn4z"
    "np6ReTgCYwAwdqfEGFMURVGU/wIdfaswAGCMcc5VVf1fXIBdBgCKoqiq+nxkobn3BABIkgBA"
    "hIiEJFAgorAOyxARBTKVoUAkgSiJkIhO73a/nLjGOd/nWkrPXbqLiH6/CgBEJiIaKA1BhkG6"
    "QF1Hw0BdoK6TLtCvMl2gIQhRCiQiCfPLm5ubtbW1YNXXtuzadyJTZV4AkKYkMpEkkRQoEUmQ"
    "JJQCpSAiMr1eg8hEJJSmlFJK0wdQLBYR0cl9laj7l6LGY5/tc2ejsrmdgeGJbG5nYHgym9uJ"
    "x9KHeGuMNd7B8fSMzCfvyerq6rHHn2bmEgPDE09G+/9WaSqZmRofisfSiadnotHoozclp94K"
    "oGWznNxn/e8q4LqznNwXmb4KuO6s4643lZyugOvOcj8PDyrgurOOe30r05tKZv7ALavXmszt"
    "rXZZL7EjhTmuU8lpRxNSyemZuUEAmJlLOPzU+CAAuKFluO7OWpF4LO1OPsTcejOOTcRepqXR"
    "tngs7Y6U4bbcqNrIF6bGh6yt0prAgm7kC6E2fSNfWF9b2d7e1jStvqGlbMSmeRsuP7zZZvp8"
    "PvCoW1s/a2qq7vddD57y3b7VZfmNfGFxadUQBgqztbWps7Pdy04uLq0WSyVJnoMRgUY45NM0"
    "bXZZ7OvtaA8vLOdeT85mP+4eXN35K/6W5nBjxFz5tv7+w8LWF3+oTW+IBpsavStf1+xIfTTY"
    "cNbknDPGfqsD5/xCa6AuDFe791xtEJyHIhHedTGw17tnj49EeFdH8GAkEAhwzgF+7HMZY5qm"
    "cc6tD6rDGGOMMUS075aN2Ho9R/R/9gsXZ7dKHM+ODQAAAABJRU5ErkJggg==")
""" VS2005 focused docking guide window center bitmap. """

#----------------------------------------------------------------------
tab_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB0AAAAdCAIAAADZ8fBYAAAAA3NCSVQICAjb4U/gAAAC1klE"
    "QVRIidWVTWgTQRTHJ5vZZEyMLKSx1RbSImJbioeiCKIechLBU8CCtadAaaGIFC/iQTxowENO"
    "hUohp/Tiocdce/Gk/TiIpTm0JCnmA+OaFJs2u/PerIcp27IbKsZ66Ft47P5n3m/evLc768lm"
    "s+Q/GCWEBINBSqmiKIqinApU13VKCKGUMsZUVT1lrqIoqqq+frYyeP8cIUSgIIQgAgACcuAA"
    "wOUlDQCAA1UpcADkAAIREPHiwa2383cYY0TWwa7AlRuPAMDvVwkhiBYAmCBMjqaJBgfDANME"
    "g4NhoMHBr1KDg8kRQHBAREE+r1er1Z6enkOubbn8d0RLpV5CiLAEogUoEAUHAYAcBYLgIDgi"
    "ouX1mogWAIKwhBBCWD5Cms0mADi57xKX/6Ws8dgX+97ZqFxpb3JmPlfam5x5nyvtxWPpE7yc"
    "I+c7OJ5sNhsOh4PB4Kunn5aWE5Mz87MvJv4201QyszA3HY+lE88vRaPRYrHozLcDaNsoJ/fl"
    "xIcOuO4oJ/dNZqwDrjvqrOebSi52wHVHud+HJx1w3VFnvb6d5ZtKZv7AbZuvXMztZbvkR+wI"
    "oY7nVHLR0YRUcnFpeYoQsrSccPiFuSlCiBvahuvurFTisbQ7+ARz55txHCL2NmWOtsVjabfS"
    "hjt0L1Cu1BfmpuVRKReQ0HKlHhkxypV6Ib/ZaDQ0TesfGGqr2DTv+Ph4IBDw+XzEo9Zqv0Kh"
    "wOOxu10XfA8f3JS+XKmvrm2Z3ARuDQ9fGx297qXnV9e2mvv7Aj3HFQ5md8Snadru7u7Rua6q"
    "6sp6aTNXzX08OL67q7f9Q4PdTP1ZKCn5Qq321R8ZMQaiXf19VuGbJ1/8IZX+aNdAnxWJRHp7"
    "e7e3t4+4oVCo0Wjout5qtdx9YIwxxlqtlj3aVgmHw5qmbWxsHNWXUqppGmNM/lCd/aWUUgoA"
    "9mhbhTFGKT3sm67ruq7v7Oy4cR3bb5uW079be13FAAAAAElFTkSuQmCC")
""" VS2005 unfocused docking guide window center bitmap. """

#----------------------------------------------------------------------
up_focus_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB0AAAAgCAIAAABhFeQrAAAAA3NCSVQICAjb4U/gAAACTUlE"
    "QVRIic2WP28TMRjGH/85c1miqEF8CnbUgSFdukVRmZGQ+gW6Vgwd+hW60Yq1gMQMQzpHGZAg"
    "C6JS+QIMmUju/L5+Ge6ulzoRTcMh5TmdZfv8/vT4Pcu26h2N8R9kAZwMfltrtdZa60agx5fa"
    "ArDWpmmaJElTXGBmAWitkyRxzllrG+Zqra21bz+OAQQOzETExJ48EfniKURE5MkmljwRe6LA"
    "TMz8ZPbs9GzXOWeMQZHfW33/NOufvALALESUU8g95zlnnrKM8pwyT1nGmadHic085Z6Jgidm"
    "Dhh/mU6nnU6n1WrFXAA/fv7iIEECsxAH5uApELHnwBQ8Bc/MLMbkzELEFCSEEII4YD6fhxAK"
    "Tsx9/tQDEIgqOzRggAQQQEEBguIFgKoNqDdfvy1yYq41emG4QKkSpDQAiNQfFQClpBoZcaK2"
    "s0awEHzXVVyri1gxN7FaFuILu6qwtAyokqWWwEvcxNTTKsIK95Cqs4JJzV02vMJvHS/1cFFQ"
    "UGV+K3tSzWlZq/5bOWGllIio0mzpX+pZSJXdVRmOuabcItRC+ZfKcn+pFRvN65fvNihj9Y7G"
    "o9FoMplcX18f9M5lUx30zofD4WQyubm56R2Nm9oYY20B98XeRfPcAro+ei1uf/DBt9u+3c7b"
    "7f7gfTPc/cOr7HE36+5k3Z28u5N1u/uHV/dG3X+gfb7YW8dgpC1YD1vBjfP7oEW6Lvf0bHc6"
    "nc7n881YaZre3pjucJ1znU7n9qx+qLTWzrkVXGNMcav4d1kAx5camAGzRoiF/gCKPmudbgYP"
    "HQAAAABJRU5ErkJggg==")
""" VS2005 focused docking guide window up bitmap. """

#----------------------------------------------------------------------
up_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB0AAAAgCAIAAABhFeQrAAAAA3NCSVQICAjb4U/gAAACTklE"
    "QVRIic2WP4vUQBjGn/mTMUtgWS6yvb29XGGzzXXHwdWCcGBzH8BCweK+wnWyWKtot6DNge0V"
    "gjYnNn4BA9vdJvO+81ok2ewmi7d3RtgnZEgm8/545skwiZrNZvgPsgCSJLHWaq211r1Asyyz"
    "AKy1cRxHUdQzV2sdRZFzzlrbCxdlDmUC1to3Hy8BBA7MRMTEnjwR+fIoRUTkyUaWPBF7osBM"
    "zDy+fnR2vu+cM8ZU3KV+fLo+fPUUALMQUUGh8FwUnHvKcyoKyj3lOeee7kU291R4JgqemDng"
    "8ut8Ph+NRoPBoM0F8PPXbw4SJDALcWAOngIRew5MwVPwzMxiTMEsRExBQgghiAMWi0UIoclh"
    "VY8fegACUVWHBgwQAQIoKEBQngBQ3wPq9bfv7XzX7o1eGS5QqgIpDQAizUMFQCmpR3bf26qc"
    "NYKV4nVX7aumaavNjayWlfrSriotdQF1WKoD7nAj00yrLCvdQ+rOGiYNt2t4g9+mXprhoqCg"
    "qnxre1LPqatN762asFJKRFRltvIvzSykTndTwm2uqbYItdL+5aLbX2nDRvPiyds7tC2p2WyW"
    "pmmSJHEcP3/25cPFSXfQNjqeTE9fPhiPx0mSXF1d9bMxdrUD3OPJtH9uCd0evRX38Oi9Hw79"
    "cFgMh4dH7/rhHpxc5PfTPN3L070i3cvT9ODk4saqmz9on6eTbQy2tAPrYSe47XxvtUi35Z6d"
    "78/n88VicTdWHMfLP6Y1rnNuNBotv9W3ldbaObeBa4wp/yr+XRZAlmVZlvWCW+oP2FUt8NYb"
    "g5wAAAAASUVORK5CYII=")
""" VS2005 unfocused docking guide window up bitmap. """

#----------------------------------------------------------------------
down = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB0AAAAgCAIAAABhFeQrAAAAA3NCSVQICAjb4U/gAAACFUlE"
    "QVRIidWVPWvbUBSG3+tv8KKpnYtH/4DuJtCti2nntBm7depQWih0zT9w/AtSQsDQ0JIfkKFD"
    "wRC61Iu3uBgRiKXz1eFalizb8QfxkFdCurofz3l1zhVyg8EAe1BhH9BHyC3NWkTU/XYFQEVF"
    "mFlYiImZyR9ezMzEpXKJiVmIWUVYRJ7cPT/uHizhFgqF6+93Lz8fAhAxZo5ZY5I4log4ijiO"
    "OSKOIomIq+VSRByTMCuxiCiufo3H4yAI8txisQjgz98bUVNTEWNRESVWZiFRYSVWEhGxYjEW"
    "MWZhNVVVtQoQhuESrtfXw6e7JbTd+k1E6dv3+/3dQPeo3+8/3n22Si+OLgFLn52D4aLTun/V"
    "er8XnVZ1NKqM/lX9eTNaC92IC+D87HUlDMthWA7D87NXmyzZNL+nl0ez60Nyt4Jux91Kee71"
    "8Lbd6uxwzXFcr9drNpv+4f2bn59O2gDMAMC5ZJY5wOCcwZxlV7tkKr68PX338Vmj0cBev7f8"
    "d0GkSG0i0576Alza7707LGqBy2JZblYOPgnm4JJA8Blay41ZnAfO3xbumWjTQOv8+oKZA2AJ"
    "Y1o3wPucGXYLYVZwWQzQlJWmwIMs6Z8OJUHWcUU1aWZ9WKaGlo67xZlTbbbPbL7oq7fBTHm/"
    "Jx9+bBRpnea4x92D4XA4mUx2Y9VqteVcAEEQ1Ov13bhZ5fP7IFB4v/v41f8HFQ1ap0nfm7YA"
    "AAAASUVORK5CYII=")
""" VS2005 unfocused docking guide window down bitmap. """

#----------------------------------------------------------------------
down_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB0AAAAgCAIAAABhFeQrAAAAA3NCSVQICAjb4U/gAAACaUlE"
    "QVRIib2WvWsUQRjGn5mdnWxyTaqz9q+QlLnGToSgWAYDNjbpNCAGDGIvaRPbNJGQyiAEbK+w"
    "sAo2qexyEhbxsvt+jMXc3u3liPfhmWeXnWVm9vc+vO/M7prVzTb+gxyA7Ye/nXPWWmvtXKBb"
    "B9YBcM5lWZam6by4QNcBsNamaeq9d87NmWutdc59+NgGoKIizCwsxMTMFI8oZmZilzomZiFm"
    "FWERaXbv7eyueO+TJEHM79LSkvfeWnv2qftgex2ASGDmkrUkKUspiIuCy5IL4qKQgnghdQVx"
    "ScKsxCKiaH8lIu99NOwAEFGsG4Dv5xeiQYOKBBYVUWJlFhIVVmIlEZGQJKVIYBbWoKqqwQN5"
    "nqdpuri42OMys6rGOG/X78yW0bXWNyLqcyyAEEIIYcYK3aB5Lazb4o5fsPc3ToFaloxBwMle"
    "6+9Pjfd7stda6HR85+dCPC86Y6ETcQEcHz32eZ7meZrnx0ePJnlk0vwenm70r/PkTgWdjjuV"
    "rnPPfvxaa+3NcL3GMaub7XdPtNFoZFn24tmX1/trAOLuM6aaFQwQYExAMPWNaUw1FW+eHj5/"
    "dbfZbDYajY33F7e1L4gUA5uo3fd8AWbQH70bjGqEyxLq3LoMYhKCgakCIWZoLLdkMRE43Iy0"
    "tWi9QOP8xoIFAyBUjF7dgOizb9iMhLmByxIAHbAGKYigUPX3hqog47hSvfCHfYRaDcNg3IzO"
    "7GmydRaGi37zMujrut/9l58nijROQ9yd3ZXLy8urq6vZWFmW9f+Yhrje++XlZR2keDpZa4f+"
    "H/pKkiR+/f9dDsDWgQW6QHcuxKg/ZbVtCjjzINkAAAAASUVORK5CYII=")
""" VS2005 focused docking guide window down bitmap. """

#----------------------------------------------------------------------
left = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAdCAIAAABE/PnQAAAAA3NCSVQICAjb4U/gAAACMElE"
    "QVRIib2WPYsTURSG3zv3ThKJRSqblDYLwU6wFMKCViIEtbKQ/QdWgrXt/oO4hZWCIEIKUfYH"
    "WFgIATuraewHM3PPh8XNZCaTSWI2oydwMx/kfeY959wzMbPZDC3FaDTavOi23Wgron8n/Z8A"
    "rnry/NmXk/vXAAhLZCNhYSYiJvbkiciHTwgiIk8uduSJ2BMJMzHzjd93zi9OmwEAbt5+TETd"
    "bpxlvtuNmZWIcpLcc55z5inLKM8p85RlnHnqxi7zlHsmEk/MLPj6LUmS4XDYDPjx8xezxs56"
    "4thZUWFWYmEWT0LEnoVJPIlnZlZrc2YlYhIVERHtAIvFYquDu7cIgI0kttY5xHHccdbZKHaR"
    "jSIAJ8Pru5M+GX+vnm4rslEDmMoFBYCXT9/uVt+MbQAFNCxQGINAe/XmSVuA8MgGxQKjaNVB"
    "CSmiLQe6kqtUQJfHjQ7unV0eAjCABnFdIrQoRZODBw/frRvdCygZpiABZmmo5mAynupaq/0l"
    "ACgzpYBZ9dOag8l4CuyT37EPoEXiYUyRg6qD95dn+8QbAWU+jYbqlmWv12DJMLtsNBU5cFZ7"
    "wJTgzS76+OHRzho3pij8QLVYwlM2dxGAT9PxgQCz9hU6KlSktZ2sqymxthXam0UmjJ7QnxVD"
    "Lc8is+oPsxx2V3BQf+G8fvH5UIkDAOcXp0mSVF94V4ter5emab/frwMADAaDcOOYSNO00+mE"
    "4zrgePWaiAMwn8+PF932//MPv0Uk8OspzrYAAAAASUVORK5CYII=")
""" VS2005 unfocused docking guide window left bitmap. """

#----------------------------------------------------------------------
left_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAdCAIAAABE/PnQAAAAA3NCSVQICAjb4U/gAAACVElE"
    "QVRIibWWvW8TQRDF3+7Ors8ShSsaSpo0dEgoFcINVChSBFRUkajpIKKgiPgP0pqGJiAhITqE"
    "FIk2BQUVHT2VK+y7ndmhWN/5Ixcbh8tYWvtO8vvdm5mdPXPv+RmuMgjA670/RGSttdZ2q354"
    "YgkAERVF4b3vHABMCIC11nsfQiCiqwJYa4noxbNvOw/6AJIk62ySJMLMwhI5MnPMnxzMzJHJ"
    "E0dmicxJhEXk+uTO0fFuCME5h1yDxbh5+zEz93q+LGOv50WUmStOVZSqkjJyWXJVcRm5LKWM"
    "3PNURq6iMKfIIpJw9n08Hg8Gg36/3wL4+eu3iHpykcWTS5pElCWJpMiJWaIk4RQ5RRERda4S"
    "UWbhpCmllDQA0+k0pZQFVwF3bzEAZ5N3jgje+0COnPVknbUAdm5cW5/1/eGPxcuL2saoAczC"
    "DQWAV0/fr1c/HxcBFNC8QGEMMu3NuyddAfIjG9QLjKJTB3NIHV050EZuoQI6+93q4P7B6TYA"
    "A2gW1xlC61K0OXi492HZ6EbAnGFqEmBmhlYc7A9HutRq/wgA5plSwDT9tORgfzgCNsmv2QfQ"
    "OvEwps7BooOPpwebxFsB83wazdWdl321BjOGWWejrciZ0+wBMwef76LPnx6trXFrivIfVOsl"
    "P2V7FwH4MhpuCTBLX7mjckU628naTImlrdDdLDJ59OT+XDDU8SwyTX+Y2bC7hIPVA+fty6/b"
    "SmwBODreHY/H0+n0P0WLomjegJYAIYTBYNAcp5cOa20IoQXgnMuvAh0GATg8scAEmHQrneMv"
    "3LAo6X/e0vAAAAAASUVORK5CYII=")
""" VS2005 focused docking guide window left bitmap. """

#----------------------------------------------------------------------
right = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAdCAIAAABE/PnQAAAAA3NCSVQICAjb4U/gAAACMklE"
    "QVRIibWWvY7TUBCFz83vojSuKNiShgdAol8hQYWQkJaKAuUNtqWmoeANFgoqhJAQHRLaB6BA"
    "orC0HWnSUEURK2LPmRmKayeO4wTysydWbI+c+e7xzDgOo9EIK0rTdDW4m0Ij4FBK07R1fdmj"
    "rh3QqZ6cPf965+ENAKbWardMTZWkUoVCUuIniiSFnW6HQqqQpkpVvfnn3uu395sBAG7fPSXZ"
    "73ezTPr9rqqTzGm5aJ5rJswy5jkzYZZpJux3O5kwFyVNqKqGb9/H4/Hx8XEz4PLnL1XvdtpC"
    "7Xba5qbqVFM1oZEqakoTmqiqerudqzqpNDczM+8Bs9lsrYNXw1ub7+nl+DcAVaOa0HJVESM1"
    "VzVzAG9+LF2/dZFfPHsPAAgIAQAcgDsQ1ly/NeDlu6cAQnC4V7L6/GtfQHTgXuSONopdk4sd"
    "HRS5vFy0l6EVE5sAD4YXq8GyBh4xwZcTr5jY6CDg0eMPtVjhAPBQ5HXEW9RUgX8A3AE8OTlv"
    "chACAhy+WHJzH/1XDaqM0oFHPGKHxo7aoYviTz5eDOeRxRwsjUIoSVsCAryaveIACNVkPi/7"
    "VoDw+dNpLbTURfNlrNcmwJfzk9Vg4cCrzekbEDs/i7x4AMWt3B0AsDTJUR7LscMcNGkxByVj"
    "7YztBljMAYq1V8ahQfU/nNrc7q/6e9FkMplOpyKyT9Kjo6MkSQaDQZqmdQdJkiRJsk92AFdX"
    "V71eLx7XAQfRYDCYH68FHOr19C8Ad0k9S0aHzwAAAABJRU5ErkJggg==")
""" VS2005 unfocused docking guide window right bitmap. """

#----------------------------------------------------------------------
right_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAdCAIAAABE/PnQAAAAA3NCSVQICAjb4U/gAAACWElE"
    "QVRIibWWv2/TQBTHv3e+uyRbJwZWFv4AJNSRLjChSkhlYqrEzFZVDAwVC3PXsrAUISTExlKJ"
    "tQMSWzcmFqaqQqT2+8VwtuMkbiBp+mzF0pPz/dzX7z373IMXp7jJCABebf8JIXjvvffrVd8/"
    "9gFACGE4HMYY1w4AxgGA9z7GmFIKIdwUwHsfQth7/vXuoxEAFfWFV1ERZhYWYmJmykcOZmbi"
    "EAMTsxCzirCI3BrfPzjcTCkVRYFcg27cubfDzINBLEsaDKKIMXPFWpFUlZTEZclVxSVxWUpJ"
    "PIihJK5ImJVYRBSn387Pzzc2NkajUQ/g7McvEYuhIJYYCjUVMRYVUWJlFhIVVmIlERErikrE"
    "mIXVVFXVEnB5eamqWXAW8Gb39uKHevbzNwARZVFirUSIlFkqEVUD8Pb71P1Lt83LZ+8BAA7O"
    "AYABMAPcFfcvDXj97ikA5wxmHVVrf64LyA7Mau1so770uVjRQa1lzaKtSc2ZWAR4uHsyn2xq"
    "YBnjbFp4zsRCBw6Ptz/M5GoHgLla15AfUV8F/gEwA/Bk66jPgXNwMNhkyf199F816DIaB5bx"
    "yB2aO2qFLsp/+Xiy22YmczA1Cq4hLQlwsK56xwHgumLWln0pgPv8aWcmNdVF7TKujkWAL0db"
    "88nagXWb0xYgVn4XWf0CymdzWQNgapJzWC7HCnPQF5M5aBhXzthqgMkcoF57Zxx6YvaDMzO3"
    "148pwMHhJhFdXFwQ0XVEh8NhuwOaAqSUUkoxxvaLulp471NKPYC80ci7gXVFALB/7IExMF6j"
    "bht/AXIQRaTUgkiHAAAAAElFTkSuQmCC")
""" VS2005 focused docking guide window right bitmap. """

#----------------------------------------------------------------------
tab = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB0AAAAdCAIAAADZ8fBYAAAAA3NCSVQICAjb4U/gAAACq0lE"
    "QVRIidWWTWgTQRTHJ+3ETEugERrtF6QhFhKsIlgQRITm5LkBvdiDhBZKc5DiRXryoAEPPRUi"
    "pTnVi4cee5NePAitFtFoVxSyheYDa02KCd3deW/Gw2Cy7MZaIz307TK7/Gfeb9587Nvx6LpO"
    "TsA6TgJ6glyqHgcHB4/ub0ZvdRFCBApCCCIAICAHDgBcXcoAADhQLwUOgBxAIAIinju89iRz"
    "gzHW5Pb09BBCImO3AcDn8xJCECUAWCAsjpaFJgfTBMsCk4NposnB56UmB4sjgOCAiIJsbJXL"
    "5b6+PsYYtQev5b8hSi/tJIQIKRAloEAUHAQAchQIgoPgiIiys9NClAAIQgohhJBnCKnX6wDQ"
    "jFfZ0+TA/8xpIv6+8e5cN61Qm05ltEJtOvVMK9QS8ewRpWqj2js4nsb+nbv3cnU9OZ3KzD2c"
    "/NdIF9IrS4sziXg2+aA/FAr5/X5nvG1AW3o5ufOTL9rgur2c3Mcrd9rgur1Oe7wL6edtcN1e"
    "7v1wtw2u2+u0z2978S6kV/7CbRmv6sxdquVSH7HTR/9tE+PLUsqp2cz27k/7PTWbkcezifHl"
    "tbW1XC6n6zp1dONeWaUk4tnjTwtx5F81KEcSaQxzdT1p1xPxrFtpwY3d7C6WKkuLMypVqg4U"
    "tFiqBEfNYqmi57er1WogEBgOx1oqDVoz/77e2Onu6hq7emGg/6w9imKp8ubt149a/mI0rGqV"
    "8u7DlyuXRuzKp8/5yzG/yr9NrmEYm1uFba2svTq0c0eu+2LR88z7Qy905PW9vZwvOGqGQ73D"
    "Q1Lf9eR3vitlONQbHpLBYHBwcJAx5rGfd6rV6v7+vmEY7nVgjDHGDMNo1LZUIpGIc34ppYFA"
    "gDGmfqgOo5RSSgGgUdtSUSUANLmqWp0q/mTK82hFcX4Bm24GMv+uL+EAAAAASUVORK5CYII=")
""" VS2005 unfocused docking guide window center bitmap. """

#----------------------------------------------------------------------
tab_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB0AAAAdCAIAAADZ8fBYAAAAA3NCSVQICAjb4U/gAAAC10lE"
    "QVRIidWWT0gUcRTH387+ZveXZgzsbmvSsmqEfzBJSYz+gUsHCYJgISPytCQKFhJdpIN0qIUO"
    "ezIUaU/roQ5eEzp46ZT/DhG4haCXdSUPK+Wuzvze+02HgdFmFqMtD76Bx8yb3/v8vr/3Zn4z"
    "np6ReTgCYwAwdqfEGFMURVGU/wIdfaswAGCMcc5VVf1fXIBdBgCKoqiq+nxkobn3BABIkgBA"
    "hIiEJFAgorAOyxARBTKVoUAkgSiJkIhO73a/nLjGOd/nWkrPXbqLiH6/CgBEJiIaKA1BhkG6"
    "QF1Hw0BdoK6TLtCvMl2gIQhRCiQiCfPLm5ubtbW1YNXXtuzadyJTZV4AkKYkMpEkkRQoEUmQ"
    "JJQCpSAiMr1eg8hEJJSmlFJK0wdQLBYR0cl9laj7l6LGY5/tc2ejsrmdgeGJbG5nYHgym9uJ"
    "x9KHeGuMNd7B8fSMzCfvyerq6rHHn2bmEgPDE09G+/9WaSqZmRofisfSiadnotHoozclp94K"
    "oGWznNxn/e8q4LqznNwXmb4KuO6s4643lZyugOvOcj8PDyrgurOOe30r05tKZv7ALavXmszt"
    "rXZZL7EjhTmuU8lpRxNSyemZuUEAmJlLOPzU+CAAuKFluO7OWpF4LO1OPsTcejOOTcRepqXR"
    "tngs7Y6U4bbcqNrIF6bGh6yt0prAgm7kC6E2fSNfWF9b2d7e1jStvqGlbMSmeRsuP7zZZvp8"
    "PvCoW1s/a2qq7vddD57y3b7VZfmNfGFxadUQBgqztbWps7Pdy04uLq0WSyVJnoMRgUY45NM0"
    "bXZZ7OvtaA8vLOdeT85mP+4eXN35K/6W5nBjxFz5tv7+w8LWF3+oTW+IBpsavStf1+xIfTTY"
    "cNbknDPGfqsD5/xCa6AuDFe791xtEJyHIhHedTGw17tnj49EeFdH8GAkEAhwzgF+7HMZY5qm"
    "cc6tD6rDGGOMMUS075aN2Ho9R/R/9gsXZ7dKHM+ODQAAAABJRU5ErkJggg==")
""" VS2005 focused docking guide window center bitmap. """

#----------------------------------------------------------------------
up = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB0AAAAgCAIAAABhFeQrAAAAA3NCSVQICAjb4U/gAAACHUlE"
    "QVRIidWWP4vUQBjGn8mfcyGQYiM2W8mWsRcLm22uWw6uFpQt7WwVLPwKVsp+gFMsAwqynY2F"
    "oLAgNu4HsEiz3E7mfee1yN9Lcueu7oo+IcPMZN4fz7yZzEQlSYIDyAMQx/F+ocvl0tkvsdKh"
    "uF6z8eLsAwDLlpmImNiQISKTX7mIiAx5vkeGiA2RZSZmvnF++9nzO0EQ9HC/vj2fPr0PgFmI"
    "KCObGc4y1oa0piwjbUhr1oau+Z42lBkmsoaY2eLjpzRN+7kAvn3/wVasWGYhtszWkCViw5bJ"
    "GrKGmVlcN2MWIiYr1lpr5QjYbDb9eQBw95YBIBBVdDiAC/iAAAoKEOQ3AJRtQL38/OXS/ALw"
    "XKcxXKBUAVIOAIjUDxUApaQcecV7A3DkuYJG8EVX7VpdtNXm+p4jjfjcrsotdQFlslQH3OH6"
    "bj2tPCx3Dyk7S5jU3K7hHr91vNTDRUFBFfkt7Uk5p6763lsxYaWUiKjCbOFf6llImd2+DLe5"
    "ruM0UlA5uazS7S/Usz88vnf2G2VLKkmSap989OD9m8WsO2gbnU7mD5/cHI/H+C/3yR24p5P5"
    "/rk5dHv0VtzpyWsThiYMszCcnrzaD/d4ttDXIx0NdTTMoqGOouPZ4pdR7e+iq3fzyTYGWzrY"
    "etj7zwOAOI7/yjmPHRfpFVKr1apqrNfrNE2bx+pOGgwGo9Eor1/wGwRB9QPwh/oH9oed9BPW"
    "YyQlBOJt4AAAAABJRU5ErkJggg==")
""" VS2005 unfocused docking guide window up bitmap. """
#----------------------------------------------------------------------
up_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB0AAAAgCAIAAABhFeQrAAAAA3NCSVQICAjb4U/gAAACTUlE"
    "QVRIic2WP28TMRjGH/85c1miqEF8CnbUgSFdukVRmZGQ+gW6Vgwd+hW60Yq1gMQMQzpHGZAg"
    "C6JS+QIMmUju/L5+Ge6ulzoRTcMh5TmdZfv8/vT4Pcu26h2N8R9kAZwMfltrtdZa60agx5fa"
    "ArDWpmmaJElTXGBmAWitkyRxzllrG+Zqra21bz+OAQQOzETExJ48EfniKURE5MkmljwRe6LA"
    "TMz8ZPbs9GzXOWeMQZHfW33/NOufvALALESUU8g95zlnnrKM8pwyT1nGmadHic085Z6Jgidm"
    "Dhh/mU6nnU6n1WrFXAA/fv7iIEECsxAH5uApELHnwBQ8Bc/MLMbkzELEFCSEEII4YD6fhxAK"
    "Tsx9/tQDEIgqOzRggAQQQEEBguIFgKoNqDdfvy1yYq41emG4QKkSpDQAiNQfFQClpBoZcaK2"
    "s0awEHzXVVyri1gxN7FaFuILu6qwtAyokqWWwEvcxNTTKsIK95Cqs4JJzV02vMJvHS/1cFFQ"
    "UGV+K3tSzWlZq/5bOWGllIio0mzpX+pZSJXdVRmOuabcItRC+ZfKcn+pFRvN65fvNihj9Y7G"
    "o9FoMplcX18f9M5lUx30zofD4WQyubm56R2Nm9oYY20B98XeRfPcAro+ei1uf/DBt9u+3c7b"
    "7f7gfTPc/cOr7HE36+5k3Z28u5N1u/uHV/dG3X+gfb7YW8dgpC1YD1vBjfP7oEW6Lvf0bHc6"
    "nc7n881YaZre3pjucJ1znU7n9qx+qLTWzrkVXGNMcav4d1kAx5camAGzRoiF/gCKPmudbgYP"
    "HQAAAABJRU5ErkJggg==")
""" VS2005 focused docking guide window up bitmap. """

#----------------------------------------------------------------------
aero_dock_pane = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAGcAAABlCAMAAABnVw3AAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAb3WKdHqPdnyRd3+deYGge4OifISifoallZaWgIy1g463hZC5hZG6iJO8o6Sk"
    "pKSkpKWlpaampqenqKmpqaqqqqurq6ysrKysra6urq+vr7CwsLGxsbKysrOzs7S0tLS0tLW1"
    "tba2tre3t7i4uLm5uru7vLy8vL29vr6+iZfLjJrNjpzPjpzQkZ7PkJ/SlKHSkaHek6Pgk6Th"
    "labjmKjlnqzhnqzjoa/npbPov8DAwMDAwMHBwsLCwsPDw8TExMXFxsbGycnJycrKysvLzMzM"
    "zM3Nzc7Ozs/Pz9DQ0NDQ0NHR0dLS0tPT09TU1NTU1tbW1tfX0tTY19jY1tjd2NjY2dnZ2dra"
    "2tvb29zc29zf3Nzc3N3d3d7e3t/fxs7szNPt0NXo0dfu1djk09js2tzk3d/k3d/m2Nzv3N/r"
    "1Nr02N713OH13OL23+X43+X54ODg4eHh4eLi4+Pj4uPm4uPn4+Tk5OTk5OXl5ubm5+fn4eLo"
    "4uTs5eXp5efv5+jo6Ojo6enp6urq6+vr6Onv7Ozs7O3t7e7u7u/v4Ob55Oj16Ov37e/26+/9"
    "7/D28PDw8fHx8vLy8/Pz8/P09PT09fX19vb29vf38vT89ff9+Pj4+Pj5+vr6+vr7+/v8/Pz8"
    "/f39/v7+////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAsPpcmgAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAf+SURBVGhD7Zr7d9tEGoa9UKBZCiapneBQN3bUQlgo13DbhXBrnRQnS0LJNhDbUO7s"
    "ErCtZWWZm2Rj2YHdbWQsCSQL2/yjZkaypBlpdKH14XA4vL8kkuebx3PR6HtnHBtHkfxyZoGs"
    "zMtR4sfjWJRi0mJRHZGlFhej1BCNs1XyocDbpa0ooEjtSfcDOHp6apyFAMzop4XfF2f0K7Vn"
    "qpyhr0bT5AwHvhpOkzPQ/TVNjt73lT6c4jzQNV/1p8npq77SBlNsj6b4Sr1Ozmtr99xpvQpm"
    "6LKvquyMVezOe9Ze81uDfNbRHLUtiPaqNi8KvrqqztvlRGGbypFJRM7mMoOtnPNHDV8JisOB"
    "QczyJolE4qy/MMAX6Pl23VdNGeeMBi+sE0AEzsYl92tgXqj5ipNcnNHo0oYX5OVsnfe8beab"
    "VVQcelHveTij895XrJdD6SGc4b+HCIglcHTK0yAPJ4dPAYOJtUd/78b3dAdE4owYz6zzcM4Q"
    "3tEop/v18ePHv+7aICJndMbdIDdn93Iwp/vh7VAf2iAy5/KuC+TmPN0J5HQ+eNDUB51Ji8ic"
    "zjMhnAwpIbT7TfjXU4+ZeuqfbRNE5miZEE5qGNSe2g//s/RDLYgzSoVwiKlammMmvVTjLE0w"
    "NH+UJmV37peFe3yInM3NZp0liz/azk+NM0ptt3tkdXZSxGQ1vD3EDOpiep6s9EVSeW+y5e03"
    "/1Qt+ie/Fseb1HnaE5AS+ieL7k+IHMwTzqDDcDofkB+6P8qfRkPtpAEkD9Bbxsa4J+RHyCgo"
    "hZRRm/xi9sxZH61smMBUQUEiRzwyC6G3jLk8IY8PdvElWMdf/6745om9DQP0UhELxDjQW8Zc"
    "ntDF6Z8CdXSoID/XuxtyTmlBHD0dcy0ALs4oCRLrdiBHpmDuncT7wdWenxZ+I5xhEgxMWHvg"
    "2AW3Z+RpD4c/ChMO6WVhjZlMmRwscMjhQwo5WM9+hT8WgyQwCgIVtOLIFPQSSdyKDb7CpwXg"
    "DLGa2b49g/W+1jc4LSrgcR1IJgdYpL5tk/o6i4YMYL/hX6TmYD76XtN0k9MPAE044Pt9/5ED"
    "qmERQ8DBPWHNMlT6O08eaqqeBManRWn+vrEvUdAbJTVVO3zyHX0SrtXQCOAtAQd71BnVdFQ/"
    "fvnQ6qGq9BOyLDcp1d83aj0KFJETqqIerj705Y9muMqgEcBbxhZwT1iVJSjt/dvOrR4q8oQj"
    "+/tGtWtyFEk5XD132/saDJeVKhYxABwNFrNVMV7P2he3nDi3+oksaQkQxVMSVga7ABxYc0Lu"
    "yZ+snjtxyxcarECqoIVUHXBUowGWSl1RFKVXbrj5xP2rH0tdNQGCeKqLlcEuZJGCFSckUfp4"
    "9f4TN9/wigRq6JXQQjLkiC1U2xx0VOKnN91636MHQqN7EnxIL7exMthFm1+G1yeFunDw6H23"
    "3vSpCOK5xjZaqKMCTodHtVVjgGryu5DT5ETIqWabWBnsojnhNJkm5Lwrwwpq9S20UEsBnDaW"
    "mOWrhrOuaJ8/8MgBx1ydA8a0nOV9sjdwm6tnoXed48vcwSMPfK5VjHAmj0bwEuC0aFTrpaIp"
    "4coTB2y1Mwe+VznLYmWwC5bNwq8+xxbZgyeuCGZwqbKOFuIgB/eEueL+RI03vq2U27Ogt4vZ"
    "SZKLuUcrE65l4YjO1vYr377RmMQWyjm0LNsL4BQblf2yMAvaXwjhwC4CnP1Kw/qSETiFPUSA"
    "A4x2IRPcHujFZxk0br8U2h43B8ye/RAOnKHXxykJd4Dx3AvmZOCQ33Fd7Zlwlpx+oxnXjgX3"
    "Hyoap4XNohzWb6VWHHx62eHQbMt2WuY/teeegxXEw9qT5i2vZvAwzn6VT0CO02+McDpt6PSp"
    "U+bf9N+MuEQF/YL4PICeL7a12UK9Wr5SclTlN1YMjv2cgqfSeHHIWm4H/lX0s/8wOCvnmbIT"
    "WMbWA+D5NmNj3KuVOsgCyF2cMyq5i7NutjfOmtsyytkj46+wWDb7fW6DdSKFoxJi/zqXUvBc"
    "Jr+EHCHNzMUdJWBrgJ5fNDsL6O61lFF6MWsGUevW8K4knMDZBOoXlvLecybXMmRVUrBEWnq8"
    "98BCE+br8eUuWrWeUr95zr1JZNjQf5P3kpp8re05uXPks4F9tHOSALpGzsqu/z65sjuZlCju"
    "GjkJMYDThUuGS+GcVIP2hsVtzP+/sfRf654Kl0CX6t2w/SqwxARx3nr8YVOPvxnAofl22P7b"
    "0wXCu9Npj3LlL6auOD3pbQ/dpMP2E3fXsd1ps21xxc5ilbf/DPU2csfLqXXyYfuj42zL23Fx"
    "M7k3pHx27NixzxT7WlY8HJqXlsP2e8e5Hd4DiqPJ8nev/unV75AbHg7NdvbC96/HSy3PVIhL"
    "6Caf/LqMXbrbwzRF9ywg/S5gc80DiveABXAELYWtroRzaIbvPus9miGcl6xfEOp417k4GFTE"
    "OTTb7G4QDmaI5z9rnQbL0A4rLl71Fcqh6RrfEZ+NeP4zHm8uXT4SeM5O+We7ARwZpsaG6nzr"
    "qrSXiXyeBebkhcyFCmuPdkLq+qpnWD5DEkfnMhd+wfkcLArOG+20Yaaw66s92kkFfvl5I/6l"
    "FgLPAad4TtsJOgecIifgHBB4wun9PgT3lphvrHtSKCI20u9qfJI6Yy33vjr/4Fg98Ee/hZ8H"
    "k2bLAu4tsYRomvPN5S1RDvSEU3tOXd4S2yICnnBqHJe3RLMD6AmjKNJ64PKW6C8VoSeMop8B"
    "XFekjMjBOHUAAAAASUVORK5CYII=")

#----------------------------------------------------------------------
aero_dock_pane_denied = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAGcAAABlCAYAAABQif3yAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "ABh0RVh0U29mdHdhcmUAUGFpbnQuTkVUIHYzLjM2qefiJQAAELhJREFUeF7tnfmPHNURx81v"
    "hEsCIQQCxCnu60d+AH5BCCGBAAkEP/AHABKKkEhCCErCHcA4WGAIYJwYbOMrGHzgE9vYxvje"
    "9drYa+99etd7zHov766PSn3avFFvu3v6dU9Pz2Q9K5Vmtt9VVd9X76zqOWtSCf4NDw9LfX39"
    "pMbGxklHR0YKxuHvzj570tVXXz3ptttuO6tgjUykioeGhuTbRYukrr5eRkZG5OTJkwUj6qcd"
    "2ptIOiyYLFV79khDQ0PBAPEDm/Zot2BCTZSKFy9eLGNjY6mCc+zYMaHdiaLDgsmxYOHCVIHB"
    "kvij3YIJNVEqLoNTwkgWAxysp2w5Fp2iDI6FkoqVxYBz4sQJSYPM6q1sORaIoyRAOX78eCpE"
    "W+VhzQIYsgAOwLC8TYvK4EQAB1DY66RBtIX1lIc1C4BQEgobHR1NhegAZXAsgDHDGgrj3CsN"
    "ohMwjJYtxwIglITCjh49mgrRAc5YcGpqa2Xjxo2yZs0aWaiKR/m5aNonn0hLS4vodUEq1NTc"
    "LO3t7UK7YbzBP3IgD3JZ9LXSzLJj505Zvny57Nu3T7p7eqS/v9/qzGzBggVO3h4tkwb19fU5"
    "wyft2lxPGN6QC/mQszQR8OGqqqpKlv3wg7S2tloJ61UISjpy5IgcPnw4FaIDMITaguPlFzmR"
    "F7lLGqRdu3bJ1q1bnTHcphf65UFJvb29cujQoVSoq6tLuHmNCw4yIC9yI39JAlRRUSH7q6tj"
    "g5I9RlFw6M1tbW2pUEdHh3D7mg84hnfkRw8lBRC3iNu3b88bGGenruDQm5t1oo5KKDpqGSx0"
    "cHAwEXDgHz2U1K0qEyMbx7hDmbtcXHDYSDa3tDsbyigAsVJLEhz0gD5KwnpYrcSd/IPmnKiW"
    "MzZ2TOoaWuWPr051PvnfFqCkwUEm9FESq7jlK1YkYjHuOScKOAMDA9LRmZG/vj07S/zPcxuA"
    "CgEOsqCXolpPtU6ABw8eLBo4AFDb0CX/+GjNacRzG4AKBQ56QT9FA2j9Tz9JJpMpCji0W12b"
    "kQ//XRVIpJMvlwUVCpxebXfDhg3FA2fp0qWJO/7ZLAhYalfXD8nsJR3yr7ltgUT63oODzr4p"
    "CKBCgcP5IPopmuX899tvndVREqu0KHMOe6DhoyekKxNOg5qP/GmDgzzop2jgFMIZ43t17mO/"
    "woon13CEwskXRrmA4YC1s7PTOS6i3SQ7WdFvVwsBDmdUu5VYsbFBZNgpFBlgOMTcvXt3GRyb"
    "3slwgMKYK9ggFopYLOzfv98Zfmz4ipqnqBd4hXRjqqisdPyX5+txTqGI+mknaResknC3KiQ4"
    "SSsszfrK4KTkdBgX1JJYEKTpAJiWo2G+7STuqLh3715n0xR2j+5O59496nyweMkSZ2WUlsNg"
    "Eu3AL3xHkZXNtI1fgluf6B8cxu2N4ob5sRTFfKOYPlfCtXV1zgrJT3HcSm7dtk2WLlvmHB6u"
    "WLmyoLTmxx+dC7IgEOETfuE7ipzoxejHdpV3WhhkPmF+NB6FYXdeDciVSl0peZWybv162aO9"
    "B2Wk4VjIMh1w/ACCP/iMI2MccAyI2TDIfML88gEHx8Hvvv9+HDjsO37QiyrbnpZUPgBatXr1"
    "aR0F/uggaYOTDYPMZ5efDzgodv78+eP8odl0couYlNJt62EopV2vbzb8xQHGLAiiDmuG32wY"
    "ZBmck473TRkcz95knvZM97zSE9FyRvTgs2X6dNn3zDNSdd99DvGdZ6RFtRzvHAd/xbCc7B4p"
    "H8vhRDjungChg8AJu4Y4zssd3nxTKq64QpruvVd6nn9eMq+9Jn36rOfFF6Xp/vul4sornTzk"
    "DQPJWE4QOHFkRAb0E9Z2ULpzLpfPEcwhbTzuPgKBAccdScAlGsNLrt46qouG3Q89JLU33yyZ"
    "d9+VgVmzfCkzebLU3Xqrk5cyueo04HijGuAvbiAX5dBPHMsbZzlUEEfJHOUzidoseU1AFHkp"
    "4wdOd3e3A04QL2O6vK56/HGpv/126fv4YznyxRdyZOZM6Z87Vwa0p0F85xlp5Km/4w6nDGX9"
    "6oUPnApp1w8cd6wQfNvEDpl86CeqXo23bNZy4vYOLrJsgaltGpL+wePZ/DDttRzAYSlthPMK"
    "1qIK//XSS6Xr9del7/PPpV979oC+t2bQQzwjjTzkpQxlgxQFOLTrB46788E/ctgChH6igjMu"
    "0s5EksUJ8WvVxsMCnGhsT3W3zFx0SBrbT0WrUcaA447DMeAY63LzNKoK3HXTTdLy5JPS9+mn"
    "MvjVV1ZE3tannnLKUoefnAYcb0yQmRPhF57gHzmQB/5zyU5+9BNVr77g2FiANw9XyTAYFOh0"
    "7NhxaTuUkY9nVsknczTmRoUz+WF63rx5zjLWELefpgd72+pWT5bKSy6RHp3kB6dNi0S9b78t"
    "lZddJtThJyebUNp188J3+DP88gn/yIE8yIV8QbKTH/1E1eu4MEgsJ26YH3f8CEHP89LIyKh6"
    "X7bLW1NXyZQvK7PgIAxlcoFDurdXNrz3ntTcfbcMqKI7dXXWpRbRrcNWr1JGqY/5R6lfaRDS"
    "ZwOap++555wytffcI9Th19vxbwsCB36RjU8DDvIgF/Ihp1d2+Cc/+gkbWfzSs5F2JszP22ts"
    "/m9qavK9Qqa3tLV1yqtvfiVvfbhSpkw/BU5D22gWTPLM1Z7pFowdNUrimbf9mpdektZHHpHB"
    "l1+WtqeflhNaPuzvpObpffhhp0zro48KdXjrRTkGHK+S4Y/8WBaf8I8cyINcyIecyOK9Sqcu"
    "9GOjR3ceM+RnFwQ88Ov9Yc84oEMwor0MUaZqb7W89Mo/5S9vGHAqZJoDzql2KEObCO8WyoBD"
    "urftuldekfYHHpChZ5+VVlW4LTg9N94oA7paa3/wQaEOv14O73QKr4JN5yGdcvCPHFOmVzjg"
    "IB9yIi/pbj1QF/oJ06EfP8w7WXColMk4KuGEwUbLG+hEfc0th+TPr/1H3piyXCZ/vlM+mtUk"
    "dS3DTuwNUWsAMOebb8a1iasSUWKcsXl5adBhqvGaa2ToscekQ0Fqf/996fjgA+nUvc5hHba6"
    "lLqVmF8ySn3vvCNHdH7KXH+9DN51lzRee61Qh7de2qJT0K43Df7gF/n4hH/kQB7kQj7kRF63"
    "DtAJMjohlxH1yuGvEwZpNqE8gMGotEfjclguMvG5yXH602HgYG3raeAw6cM8AnnBYYzmHoc8"
    "Xl7ata09uiAYUksY1n3O8J13yvAtt8jwDTeE0pDmoSx1eOs1bQWBQzqy8ekFB/mQ06sD/gcs"
    "9BNVp4DphEEacOg9cXzDKvWGEIX6RT4z3jJZNrd2y9QZFfLR142OcMZhkEDZ2XPmjIv7pB7A"
    "QSA/fvY+8YS06Z5l5KqrIhFlKOtXp7F82vXGocIfvMAX+RxwVA7kQS7kQ06v/DwDUPQTVa+0"
    "50TaGXBAiyElKhEDybjKhVQQMRxU/tohMxa2SG3zsMMsgGKtRnjTuww45PHjpWHTJtmhFtB5"
    "8cUypgq3IfJShrJ+dRrlmU7h7unwRzqy8Qn/yIE8yBUkMzoBIPQTVafZMEgDTpR4GLeL7E4N"
    "nILBWo3Jz0X0yM27uqWj62i2p2Gts2fPHjdWUxdKyuVCWztjhmw5/3ypvuACGbrwQjl+0UW+"
    "RBp5yEuZINdeE3tKu965E/5IRzaUDf/IgTy55K3Ta206GvqxiRFy58k61qcFDkpHIAREKBin"
    "581S4d1mj1Bh4CBInZbbfvnlsv6cc2THuedKzXnnSdNvxHeekUYe8ob5XAMA7XqHIPgz4BiA"
    "kCOsQ5YMODBSU1MTidzguKOmcaTAAyWX5RhFN+p4Xv3CC7L9uutkkwLx02/Ed57t1zTyhPVc"
    "t+V4I7gBh7kjqnwAydBWdMvJFxz3Kg+h/MABTNLwa8bRfceOHbJlyxbnNSfr9HUna/REYLXe"
    "5zj02WeyVv0BCFz65ZdfnOhmXJtY1qJklOYGzA2Od9V5RoKDgpxhTe9i3BMmygsChzQUjEfM"
    "NnWd+vnnn2W9euqsViBWqAvVMh2WKMvR/6pVq2TdunUOeOblDfiDEQpoJmsDUBYcLeudvOHv"
    "jLOcXOAssRjWmLsMoWSUapTtVrCxhFwvnGB11KJDF6CWJDgspcPGZr90xtQ4wxrg0ObX2jPd"
    "9dKzbcAxgDCBU09YAFWudI71N6kVQl4Z4a+oloPfGmv7sEiypMBh7qAu2uTsyguO7YIAfhka"
    "cZNFBl/SNHzPoKB0ItoYHv3kgz8sNGoHjLsgcEfaOa/vx+OTSZYeGDWSjIkW5rEEWzLA4GH5"
    "o7rC+oETtAl1DzvuzaPftQXPOC3GullIeA8YOSLhgBF33wMHDviCA3/bdEFBR2BRYisjeSmD"
    "fqKcELgj7bJvoYobSVavoLDTj3K4xxBDwNIc3X379dZF333nDFNhdbKJ3aUAo9ygV7sMKwAr"
    "NZ2YTz8vFywPP3GUGTSswycdyQyhYXyRTr20iX6iROU5kXb67oLTAn1BmfE+apQBzDM22xK3"
    "iziPBylj8+bNjsIChyrXEIYL7QZdkSGMH9+LtB42l0EysQjYqUcsYfMt/MK3rYwswRkSo0YZ"
    "oH9wSCQCG6HjHv2EKYQNaRiF1VGs9HFHMIloOkYlhQSnWIpNot0yODHex5aE4m3qmPDgrF27"
    "1vFrsx3n4+SjftqxUXiUPBMaHG5I9+nylxVPId8vTf20Q3tRlB+Wd8KCw96CV2EVEhRv3bTn"
    "3XOFAZArfcKCwxIU/4I0wcHZxHta8X8PDvsLLp/cB4/5CEVZ5g4bYDJ9w9LaMRRKPZlTDn65"
    "CG8X7zlfPnJw0gLgRX1rFOdg5qglH2HcZW3B2b2/V+/zm2TqzPpAIn3HnlMv9U4LHHM+xglG"
    "Ud+3xpsKORS0ubm0Bc8WHJS9Wx0t3v10eyCRHgaMSU/KcgCHjTmfRX1TIRMpxx9x3uccBJYB"
    "x8aNFcX+Wt0qf5+87DTiufHLDquLfEmBQ0fljAy3qKK+45NDBW4gjWuVrXXkyoeSgpzj/Vxb"
    "UWxTc4f86W9fZon/jQN6mDuscTpPAhwzpNEmTooxDl2SLcL7k9krcNydxMIAJYUp1Js+MDAo"
    "+6rr5Pd/eM/55P8odSRhOcjO/IvVHNQr9ZJ4rzRQc5qK9SSxODDgRDlqN1EANbUN2aiAKOWx"
    "nnwtx7jssg0o6kLAa3tcDOFMkQRAKAnFuj32bb97Ix5sypmIhrjgYDEAw8hBXRvVs7Tkfq4F"
    "11NcloxXftwhLh9wbMDwy8MQGAccM5SxOgMYLv9K9mdaYAwLYtxlc8owR68y18s2CwaUhAJx"
    "dE+DTOyNLThGFlZlWAuyUgcWU7LAmKEOk2YOOqCeNBwsYkkIwXLb5j6dW0R6YRrA0AaKZc7x"
    "ugb78crOH1kYvimLxRlfu5IbynKt+xjimBj5xAnEHAaGTdQmmgyA0iD48Yuy8+MTMBw/N51n"
    "cBwx8iW7/k2xNvevHdr4J3DvzqkDG7g0iJ6Psm3v+yfErx3GxR8Ai/KDeoRclP9yawBwmGRT"
    "/0G9MjjhXRNw0vxBvXFhfuHsndk5ACduGGTUED/yZ39Qr2w54R0vbXerkrhSDldLaeQog1Ma"
    "OPhyUQanDE7WFao8rEXoDGXLiaCstLOWwUlb4xHaM0tpmxPsJPKUh7UI4OQTBhkVrNPC/CLw"
    "eUZmzScM0uZKwp3HN8zvjNR6BKHjhkGGXUd40wPD/CLwekZmjRMGaXMl4c6TaJhfAVD6HyAO"
    "VvwtWIicAAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
aero_dock_pane_bottom = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAGcAAABlCAYAAABQif3yAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzoyMTozMiArMDEwMExUiZ4AAAAHdElNRQfZAxkQJgE7q5VA"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAEFtJREFUeNrtXVtsHFcZ"
    "/me8a+9617Ed3x3HcXNxnDhxmsShQQqEolKq0pLeVakSqA8g8YIEQvDAC0g8IB6okEAoPEBB"
    "QEvbJKWFJqBSWpSUosYpdpzaiXN1Yju+xJfYXtu73hnOd3bPerz3uezMoPqTRrM7u3PO///f"
    "ufz/ucxI5EKEQiH16tWrdP36dVpYXCxYPn6fj1paWmjdunVHmpub33Bab9djfn5ePX7ihHrl"
    "6lV1cXFRVRSlYAfSRz7Ib3Bw8FmndU+G5LQAyeg5f14tCwZp06ZNtuV548YNmp2bo47du11l"
    "D9lpAZJx/do12rBhg615NjU18XzdBteRsxQOk8fjsTVP5Id83QbXkbOGFayRw6CqqtMipMUa"
    "OS6GvY27DthVmiXJVQ7aKriSHBBjZ1PjVoI+8eQgn6KiIqdVTotPPDmoNW51CFxJDuBWg9kJ"
    "V5Jjd5/j1oKwRo6LUXByBi5fVm+PjNDS0hJNT09TLpOPjY3xIxqN2mIASZbJ6/HwPF997bWs"
    "4sGnq6iooJKSEqpvaKBtW7cW1M0rCDlHjx5t29/Z2TfOFI6Ew7Rj504q9nopGAzmvPfYsWNU"
    "Xl5OkUikkHonAE/N5/NRbU0NPfnEEzn/Pzc3x2UbHR2lkydPqjW1tdS5f39BSLKcnJ6eHvXm"
    "rVtUX1dH+/buNZQGmjS7ao7IL1+IAlZZWUltbW00PDxMf33rLXVjUxN1dHRYSpKl5Jw7d05d"
    "WFigLz74IMmy8ZEhEGNbs2bSlW5sbKT6+nrq6uri+u/bt88ygiwbW/voo49Uf2kpHThwwBQx"
    "AIylKIotBwqBWecD+kJv6A87WGVTS8jB7OXy8jJtb221RChhNL0H+g+991jpGUJ/2AH2sCI9"
    "S8gZYn3Mvffea4mCRoHZ03BE0T2LarXLDjvAHlbANDlnu7rU3bt3Ozo+VV/fQNcHR+jnR1/l"
    "Z3x3CrAD7AG7mE3LNDnj4+O8U3QK8Jomp+boty+9R77San7Gd1x3CrAH7GIWpsjp7+9Xt2ze"
    "7JgRQMDoxCK9+EoXlZbVJQ58x3UnCYJdYB8zaZgi5zYLxGpY8OYEysrKaGh0mf7y7gj5grUp"
    "B67jd/zPCVQzu2DUwQxMxTlzs7Pk9/ttVzwQCNDoVDF19c2Sz1+V8X9dfUu0Z3uQGquDPLK3"
    "VUbmVt+9e9dUGqbIwXIir9drq9LA4uIiNTdUUFWlL+d//ewvM5MztssIu5hdbmWKHMQjVk/x"
    "FpeU8PgDgR3STwf8PjV5Oy8PcSaUebQBsovYCPlajUzy5wvXTRnc09JCo6ytbmxo4AFdtjgk"
    "H+VBQKZFimLQc2hoiFpsXP6bL1xHzq5du+jE66/zYXyMWRUXFxcsL4wuY+Cyr7+fHn/sMadV"
    "T4El5FgdZT925AiGQOj06dO0uLRUMOV9rCnb2NzM87NSB6uaetfVHIEOFmXj+CRjbcVnAWBV"
    "LTRdc9bm+1NhVbOWSKW3t1fVu80PEbDeEQJ4R5tYO79z506bTGUeH3/8Md0YHOTxVb6AYcfG"
    "x6m2tjbve8Q2SOYUSSINwra7PXv20IbGRl3eEQb3QI6emhNmgdkQ85C6u7vpy48+mvI7PKjz"
    "vb08bbi6hV4qCze7av167iWmwxtvvklGbAO5hX2M2OaJxx+XJDPb/JB5dXW1IaNgqx+GN9rb"
    "21ddP33mDE9z65YtpmdU8wEKw8DAAP+cTNCFCxewmdeQbYyQo7UNtkHKTmzzA/hWPyaEFhj/"
    "whqEdtbkYfkRhkAKfZSWltK2bdtofGIiRUbI55htGC8eJ7b5AcgzzGIYbZOIz06s90cNjaYZ"
    "jYB8TtkGvKy50i6GY0Eod8FpdUzgtEOeXHOckkfIYYocMzFONi+MN28u2tBkVEez8V+CHCMJ"
    "qQbvy6hAUv9jN9LlaaYAGrWPKJgeIYCRuQeV3ZOv8Oh0xX+RebqaIdIxOw+i1xDZ5NfaRsid"
    "Sz6hmxpfuKhXHnG/rDWKXugh5sZwmBbDcs77rKiNenUQ+Wb7HYD80CNX/CX0M9Qaae7zJF/Q"
    "lRDlNiSi/P4rM3SuL0KH71tPDVWU4j5nM4idyNasoTRP3o3SmXN3WSzmpbYt5TnXcxspaNoW"
    "xVSfI/qITPd6PF4am5il9/4zTLK3cpWy/J6kQqHmSK9QyJhvSg2QaH5hmekzTuvLi6i2uoyW"
    "lyPZEjalS6JZM3JkWyAuSTIN3hqjF1/5kMLLikbe3AIrmr7MriMbcUIeAegDvaAf9EzWXWsf"
    "IzYVeclaAfQemQRAhHvnzjT95g9vx2qXmihIq/+bVDBE52nnLoNkIrLJl+An9gPXD3pC33SF"
    "1oge2hpsuuYkC4A28+LANXrhF3/UeMYqiW43uXSkK7121pxMsmivrfxnRQ9R2KAn9BVeXK6C"
    "m488ArzPwVB12MAaKwxSzs/PpzQLLc2N9M1vPEu//PXfUkoG5kRERyq+J5oLJgPSwkixXe40"
    "PC/kh3yT52uEfJAL0wWK4k/RB3pWlAdWLSAEUUgX9sGhB3CghDfIyTG6k0y7x0WL2dlZqq6q"
    "pOefe4D+9Mb5FIWT23ABUXqQpl3k5NP/ZZIH+lVXldPU1NSqdETsZNSuKa60IXKyCI65jOam"
    "evrqMwfoxN9vJjw7/B/r0bRVX2sIrUHsQKYmRfyGa5A3MTrNrnk9Mj3D9IK3Njp6O4XgxGJF"
    "g3oIOTxmjKFkqDkCw8NDfGf04fsaeJyDvyXXnHT32rknVItMsqzITBTwF9G+fQ3sLHH90kHE"
    "KooBPbQBrrkgNEOJ0wJVvrFmHYWW/BRkCi2FIqvinHQ1x85FI8mOSNKPCf3QLwVLJWrb7Gf6"
    "KFyvTBBDMEb0SHGlCw3McG5tUhgxY4nnC6R3VZ2dNEjnSgtAbsgPPezasWDL0ihU7ZmZmYz3"
    "Jz7HLtiieC5Z0umnx6u1oqA5vuIz05SB47K4AI6QkzBChrE1R5CuBXCYLMdrTjL0mEN0vGZm"
    "TeHyRpir7ManFXqEknZD6xBor+ULEUsgckccYhTLrD/EOrGydetS8ne6kfOUMOVy7SSzEtrd"
    "ZOm2LOZbTJAO1radef/9zM2PZtZSTlcA4+5uOSNmc5pd4ZDPKduAF0/LPffwx1Nh77wYY8oX"
    "iJpx6BEcmcOo2LRUk2G1aD5NFQyGZ7jh/Pn7788Ypff29vKFg83NzSn3Q/Z/vPMONTSkf6gE"
    "5Mt3l11y3sI2eta9rdpp19JCHrz54tjx46rHwE4ybGzCclU9UTCUHB4Zob6+Pjp06NCq3yAY"
    "2n8YLpcc+A9WZEJulPB0fQbkm5iYoIMHD6bd9Y1AMhQK8cKSDlgJig1c2GVXV1eXt20EOWFW"
    "2GGffMF32sE2/f149ttK8ezu7lYHb97UtZIeuwwqKyr4GFK+wEPxqliJbGWKp8OtW7f48w08"
    "eXTQPmZwEIpxvHS1F2l4mUEzjQwHAwGqZUavybHe+9LAAN1hJIfzfECfIOfOnTu6dhlAl+aN"
    "G7FwfmWXgVHgsYufO3xY97B4PsjHEMUObLPPByAGNebkqVP09FNPGbax61xpAbca3k6srZV2"
    "MVxXcyZCsfONSz3051ulNLZYuPJT61PoSFOINrV28O/VpU5rvxquIwf4/qmbpO74Ej3wnEqb"
    "/RLBzypmLTd8JQ87w1XIlzI4v/Alo+wDQtUldobLg3HlgZBKR/8lkXzqffrRQxudVjsFriPn"
    "2sVukrY8TD/+dJQCKotVmDU9MshgnyUeN3IvRk8vC4LgyymY7GOxyjKIYhcOSCo9eb9M3104"
    "yPJ9i6r37nFa/VVwXZ9z/GaAWg5JVBzNPnwiM3ZAWq5DzsIiSPJGFap8KJav22Cq5ojF6Va+"
    "SWMqLFOrTyIlS7gFgxezdurufO48MXupsrZQyfBX1KhGv0wXwtaVU2EPs3taTZFTYnLQ0SiK"
    "mc79A/P09r+naHImc/7ryz302c4K6thVRss2LUkQy6IQ7ZeYfG6PKXKCZWU8AEVka+WCDJRm"
    "NcMBLLKsdrQFCdXrxWMXM6bzzIPbacfOMprX8KddtCnGFKwe0wQ5WM+nZ+gmHUyRg0fiT8/M"
    "0IZAwFpy1JVVvPwM48mxz+hCmJ9AIWbw9vYa+lpRhF741bspaXzr65+j1rYamouoq9NSNekX"
    "YE5ADKjemZzUNXSTNi0zN7e1tUl4wweEsXJOCGRE4h4VXGDhCic8LiV2vhtWqXV7I/3wO1+g"
    "2akbiQPfcR2/KyoljmjSZ6QfUVZqkFmIMTUMkGJkGfYxk57pXrCuvp4/RgQCWUWQwpcjqbFz"
    "/FAZY/wzxY/49ZmwQg11FfSD7z1NodlhfsZ3XE/cS0lpaNPla9KsIUZM/uEpHBjFNgvT5OD1"
    "JFeuXOGCWfU4FBiLxyKa0q4t9YqoRRSrVRPLRdS+YzP97Cff5md8j9LKfxK1heI1UV1JP6Ja"
    "M+MJvcXUxaWLFy15bYsl/iMeNIT5GZQaKwgSzZmS4VCTDlwbXiCqaNrEz+n+I/qcVWQJYkzU"
    "HOGdgRg4Rt09PSkTe46Sg/fG4HHCeOoUJq7M9kFKvERHNCVc2+9oa4D2WIimvw5nTdTCaLxW"
    "RuL9TTievlFixMwuZlsHLl/mjyy26j06lkVeeG8MShAef4USJEjCNb0rZBCTRKLxGqQ5lLhx"
    "hUOQ96HEak1UWSFIOARwMvX0OUIX0b9ghhW6/re7m2di5ftzLB1bg2B48xSe/NTa2spdbQSp"
    "Yv4937UGsT5BZWcczBCqFO9n4kUc42s6SrtKq709ni5qUHzYQEiVa75fNGEgRkyPYy3ERdbH"
    "oClz9ZunACHg2bNn1YFLl/i6BDzWCorkG5Rh0GFZiZdsOWZYGUaVKNF7yzrMkOxOC/cczZmk"
    "rtScXPKBHOw9QuCNKfqRkRGu3yOPPPL/8c42gc7OTi4w3nY4ODjIV8pMTU/ncWc1vTypUh1r"
    "19aXSFTmlShQJJGvKDZs45Vjo9NFOswhRqHDjJ0ldp5nF2YjGMdTWCWU6CWW1mH2P0wr50Kl"
    "5m2H+wv0Ij2Bgk8Z6H1d48M/fVddZDVnjhmuRJK5gEXc3ZJILYr1HXrIEU0ayFli5GDoZ4GR"
    "E2Lexnw4FutEIrHRDTPz/YWA6+ZzgKVIbHimlElXwuzGKg9vxkRThgk3RSc53DNjaS3FD3h2"
    "yIM7Cvbv08oLriQHrto8K+oBZjQf62iK0ZRFV1xLVSc5fJiGsRBG7Ymi9sSO0HJsSfAaOXrA"
    "SjSatiV2hFlThqkWT7wp45zIMYLygSBHjKMlalA8D441cvRB0RzZpg9yIdO9Im03w3XT1GtY"
    "wRo5LsYaOS7GGjkuxho5LoY7yZHtE8ydBojBda50tV+iAPNxg8VywQ3nY9oHvDKVxfN1G1xH"
    "zvO7vfTPniLa8Jko+VlwGGTRZ9BL5GcRaElRbODTY2BsLaJI5FNUKmH3e2WViotUquHPspGo"
    "6qREX9nrod85rXwSXEfO/o5d1P7hB/T7Cwdpx6dU2lYqUwUjJcjI8LOqVMLO2Lnj0TNCoMZm"
    "PBfYMc9q5TQ7JhljlxaJhk4TtSkfUOeeXfklaCNcV5dVhunpafqw5wK93K/Q7fnCxfH1AZme"
    "bZPpQEc7VVRUYL7GVfb4H1Voiukj7VWUAAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
aero_dock_pane_center = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAGcAAABlCAYAAABQif3yAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzoyMTozMiArMDEwMExUiZ4AAAAHdElNRQfZAxkQKidFE1+x"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAEAxJREFUeNrtXdtvHNUZ"
    "/2Zv3l2vb7HjWxzbcRzjJCQOcSKQiBSQEBclFAgX0VYt4qnq9blP/Qeqqi+t2gi1BaQCJYQg"
    "oAQQD6VKHhBxwCGJc784dhzbcRzHt73O9Pxm96xnd2e9c9uZqdifdLT27syc832/c77zfec2"
    "ArkQS0tL0pUrV+jatWu0HI2WLZ9QMEjd3d1UW1v7TGdn54dOy+16LC4uSu8fOSJdvnJFikaj"
    "kiiKZUt4PvJBfqOjoy87LXs+BKcLkI9T330n1UQi1NXVZVue169fp/mFBdq+bZur9OFxugD5"
    "uHb1Kq1bt87WPDs6OuR83QbXkROLx8nn89maJ/JDvm6D68ipYAUVchgkSXK6CKqokONi2Gvc"
    "dcCu2iwIrnLQcuBKckCMnabGrQR978lBPl6v12mRVfG9Jwetxq0OgSvJAdyqMDvhSnLs7nPc"
    "WhEq5LgYZSfn4qVL0q2JCYrFYnT37l0qpfKpqSk5pVIpWxQgeDzk9/nkPA+9996qxYNPV19f"
    "T1VVVdTa1kabenvL6uaVhZyDBw/2D+7aNTLNBE7E47R5yxYK+P0UiURK3nv48GGqq6ujRCJR"
    "TrmzgKcWDAapee1aev7AgZLXLywsyGWbnJyko0ePSmubm2nX4GBZSLKcnFOnTkk3xsaotaWF"
    "dj7wgKFnwKTZ1XJ4flrBK1hDQwP19/fTzZs36d+ffCKt7+ig7du3W0qSpeScPHlSWl5epice"
    "f5w8HuMjQyDGNrNm0pVub2+n1tZWGhoakuXfuXOnZQRZNrb2zTffSKFwmHbv3m2KGADKEkXR"
    "loRKYNb5gLyQG/JDD1bp1BJyMHuZTCbpvr4+SwrFlaY3of/Qe4+VniHkhx6gDyueZwk546yP"
    "2bFjhyUCGgVmT+MJUfcsqtUuO/QAfVgB0+ScGBqStm3b5uj4VGtrG10bnaA/HTwkf+J/pwA9"
    "QB/Qi9lnmSZnenpa7hSdArymO7ML9MbbX1Iw3CR/4n987xSgD+jFLEyRc+7cOWljT49jSgAB"
    "k7ej9Pq7QxSuackm/I/vnSQIeoF+zDzDFDm3WCC2lgVvTqCmpobGJ5P08X8mKBhpLkj4Hr/j"
    "OifQxPSCUQczMBXnLMzPUygUsl3w6upqmpwN0NDIPAVDjUWvGxqJ0cB9EWpvisiRva1lZG71"
    "vXv3TD3DFDlYTuT3+20VGohGo9TZVk+NDcGS14bYJXN35mwvI/RidrmVKXIQj1g9xRuoqpLj"
    "DwR2eL4a8PvsnVuaPMS5peKjDSg7j42Qr9UoVn6tcN2UwYbubppktrq9rU0O6FaLQ7QIDwKK"
    "LVLkg57j4+PUbePyX61wHTn3338/HfngA3kYH2NWgUCgbHlhdBkDlyPnztFzzz7rtOgFsIQc"
    "q6PsZ595BkMgdOzYMYrGYmUTPshM2frOTjk/K2WwytS7ruVwbGdRNtL3GZUVn2WAVa3QdMup"
    "zPcXwiqzln3K6dOnJb3b/BAB6x0hgHfUxez8li1bil7zuze/oKszMQoG/GVfjenziNRZH6Df"
    "vvxo0WvOnj1L10dH5fhKK1Dqqelpam5u1nwP3wbJnCKBP4Ow7W5gYIDWtbfr8o4wuAdy9LSc"
    "OAvMxpmHNDw8TD94+umC33/9189ocGsvdXa0UjjooZDPQ1U+gQIs7vEyI+xFbOKBPRZID28o"
    "okgSpZj3nZLSnzHmit9ZiNHvX/uCHtpSr0rQhx99REZ0g0rF9WNENweee07wmd3mp9ekQUDE"
    "Mh5W+DNnztDWrVtzfl9IEj390Ca6siBRiMWYQZb8HharMEIYR/J9HiHdWeppUygloiIRJLEy"
    "J9mnl30RYh7bL3+ylw59/lXBPSjfAzt22LYFUqkb8OJxYpsfIG/1u3495zuMf3kzzcHOXizC"
    "lJJIFeaI8jmmG8aLz4ltfgDyjLMYRtnynHYs8vNH+ZzSjcyLo9pYBTBBkuKTKLc16aVR7V7+"
    "fLfCMXJkF5xya6uUSegX5I6bWTjRw/uJdB/D+xk5QNPtEKw8S5kkRZly7nFQN4ApcszEOKu5"
    "yFBiEuR40iSJQlqJnsxvQuZTTwTNSZA/FcSkpNKtx6iMZs10lhwjD5IM3ldUgMzf8KbizM1N"
    "sH99EnOdQYzEGwquSXtseqq20lNLZUiBxyayL8UMPWqymKmARvXDK66PF8DI3IPE7tFaeMzP"
    "8GuRuVrL4aYua9bEXLMmtxp2m8BbgU6zpmraKNe0qZWJ64aXu5SuuGxSZuGiXmL4/R5eACPQ"
    "Q8z1m3GKxj2a7oOy4kymRKZ2pxTmhys0Jan3H8WS2v3Z1lNCRg6UH3KUWtHK5TNkjRT3+fK/"
    "0PUgKk0sJrTOXZ6jkyMJ2vvgGmprpJLuM5QWZcFokOkgIGBUQBF0ZrwCj85RHSVJIAR9WkJc"
    "+b5YWZSt/c69FB0/eY+Wl/3Uv7Gu5HpuI2ZNaVFM9Tm8jyh2r8/np6nb8/TlVzfJ42/IEVbK"
    "2Bk1oqCshCQyJQo5LcfL/k+bNkm3KyXmmbQU73vE9FCOqhwFLUCgxeUkk2ea1tR5qbmphpLJ"
    "VbaqmBwUzpo1I2m1BeKC4KHRsSl6/d2vKZ4UFeUtXeAcsyZmPDdOEuWZKK2Jcu9P8WdrMGti"
    "pm/lgDyQC/JBznzZlfoxolOel0dZAL2pWAEQ4c7M3KV//POLTE+crUi51+ZVDPlZlFYaq6AU"
    "Q8qYn4SoIIonSUfK3MOfwZ+ZYGwlU7kVp1j5svykf5Dlg5yQV63SGtGrsgWb6nNEFW8Nfcz5"
    "i1fpzbeOUlV2TZmU4aewdhSaEqJ7rMl8PBqjDREvtYY91FAlUK1foGqfIA+EBjIDoeiLtHQ9"
    "Eq20lDhrRlFGxiJrMsgnzr6fn1yULyrW56ysMlqRg1e2P/75Lfrpj56ijRvW5/RBfPWQXr3i"
    "Hr6qSCYHQ9VxA2ussFFqcXGxoADdne30m5+/TH/5+2cFNQNzIlwI/j+HXAYpXaNn2Z9rWMuJ"
    "sFTlw8h0mgywwYdd9JKTENMtEeQss7SUSpvPWMau5c/X8PKhXBgxFsVQgTyQs76uOmcBIYgE"
    "OdAPkh6AGO4NyuQY3Umm3OOixPz8PDU1NtCrP36M/vXhdwUCF6tR3JRAiXOsn11kaYmREwZB"
    "njRBntTKyIBogJx4SkFQcsVMSkU8DL5XSC1egXxNjXU0OzubIw/fLWdUrwVmzRA5qxQcE02Y"
    "MHvlpd105PMbWc8O12M9mtImKxUBNSXZ9/dYlV5ICDI5yymBQilBNmdeeT4H5jFt2rSSI/cz"
    "8sgDI4cxhbTMUoI9N5GTf66S8B3Kmx2dZt/5WcYvMbngrU1O3iqoaNnFihn96AUvh4//Y+gh"
    "RVoOx82b4/LO6L0Ptslxjhyh57UctXuz3prSAVB6XoqRA63kZO9TxDvcQRAVDkE+eOVLl5mo"
    "OuSlnTvb2Kcgy6cGHquIBlqOMsA1F4QqvJNiQJNvX1tLS7EQRZhAsaVETpxT2HKcQ0H+Cvmw"
    "ADESFqi/J8TkEWW5ioEPwRjRa4ErXW5ghrO3Q2TETGXPF1B3VZ2fbMt3pTlQbpQfcti1Y8GW"
    "pVFo2nNzc0Xvz/5ti8iry7KafHq8WisqmuMzoWpTBnYjHYk7P02eD0fIySpBZWxN1KEfDH76"
    "MytyVs2P0hN3PuZ7C6n0fJC8AgdzOX6JZlJRCvhUDotwmCzHW45RgJgwU2hjFXMyoqVNjTy2"
    "5mGEsM84oyvKUrOXfS4t0emh07S1w/5NYKUgk+PEGZeqawjY31qnAtBimoIC/eGNo6u6q/zx"
    "xUSs8hJtbvPQU1vWuGYNAYevKhAouZPMSih3k6ltWYR+sHiwjv0U8aN1EIV8aSUGPOnk95K8"
    "CnRpYYnVLole+8VjqoEgAsfjx4/Lm3Y3b96c8zvkRf5vv/MO9WzYQJ3r1xeUBb87pRvw4utm"
    "BcPxVNg7D3dRT6cI4ZH0FByZ47wybFpa29RU8PtyLE5hIUX71geoiZkstI5axkgEJHkFCmRW"
    "gGIQ9OvhcVpTlZKfp7a+bJGZLOxa27dvn+pxYpAbY2JNKuUAUD6tu+zylcx1o2fdW85Ou+7u"
    "dIB9+P33pc39/bp3kmGhdkN9va4oGEJO3LpFI2fP0p49ewp+/9vn39K3k0kKBkrv96xj5D3a"
    "lqSpiTHVMqDmQ1iM9amhvq6OOru6qHfjxqJTz9jAhVbX0tKiWTecnJk7d+Rz3LQCjQPHB2Dh"
    "/PMHDqxY4uHhYWn0xg1dK+mxy0AmR0fLwaF4jaxG9m3apPr72NiYXECfhs24wVBIVj7G8dRa"
    "L57hZwotNjIcqa6mZqb0tUVaDseFixdp5vZtims8oC9LzsyMrl0GkAXmdWBgYGWXgVHg2MVH"
    "9u7VPSyuBVoUEXBgm70WgJja2lo6+umn9OILLxjWsWtdabcq3k5Uth26GK5tOZcuXaJp2Pky"
    "vnQIHTz6m97eXqfFVYUryTnGYhMcKjc4OFjWcwj4TjLkt+fhh50WuwCuI+ci84xwqq4du8mU"
    "O8mQ76YiHqRTcF2fA1Nm9+F62L2GfN0GUy2HL0638k0aCMS0nEQVjUm0GC2dZ4gFquHg6t4s"
    "8rPykHGuD7OnBJsiB+M/iPidwOhElIbOzNP8YvHRiZpqL22/L0Jbe8O2lYsviwLZVSb7S1Pk"
    "RGpq5AAUka2dJ6gDfd0hIjFOn/73RtFrHtm1nvp6ShNj9SQbyMF6PgSiZmCKHByJf3dujtZV"
    "V1tOjhaF9fXUkc+bpEMfDxf89uL+AerpqtP0HCunTEBMdlxNx9CN6rPM3Nzf3y/gDR8ojJUC"
    "6ln03dPVSK++NEjL87eyCf/jey0Lya0EH1ODF4iRZejHzPNMe2stra3y6DQKZBVBepQGAtY0"
    "ROiVHz5C0aUZ+RP/a53GsIogPhcjE8NiJ4xim4VpcvB6ksuXL8sFQ7KSIK0JWXZ3ttGvfvai"
    "/In/9W69sIIceH3QwYXz5y15bYslQSgOGhoZGZHnPRB1m315g5E9qri+taVJt/doNgzgCwj5"
    "3NG3w8PUyfRhBSwJQvHeGBwnjFOn+KykU+sS7LiHg5syyBwOh/GWLfnIYqveo2PZCAHeGwNP"
    "BbN4qEGcJHxXbPd0Mdj1ehYj6wK4LLx/wbnakBUtBgsgrHx/jqVjaygY3jyFgcS+vj7Z1YaZ"
    "4fPvWk+ztbvV8TxLzffzABPE4FqYMqyFOM/6GJgyV795CuAFPHHihHTxwgV5XQLOHIMgWoIy"
    "3trsAlc4n70sdS3WIyDwxhT9xMSELN/+/fvLUpvKXkWVbzucvXu35PUQ+sknnrD9hXo49E5L"
    "0Njw//62QyX0CoB1CViqFCvjkcVKgBx05iDGzHx/OeC6+RzA6GYuI6i8m1onjHpSRvOqkKMD"
    "Rg9KMoIKOTph5y43txIDuG6auoIVVMhxMSrkuBgVclyMCjkuhivJcWK6wY1wHTnKbZDlRv42"
    "P7fBdXGOmW2QepG/zc9tcKX9MLoNUi/yt/k5LXc+XFcgDiPbIPUif5uf2/A/9n+1U7cLqMYA"
    "AAAASUVORK5CYII=")

#----------------------------------------------------------------------
aero_dock_pane_left = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAGcAAABlCAYAAABQif3yAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzoyMTozMiArMDEwMExUiZ4AAAAHdElNRQfZAxkQKBW/8myz"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAD+tJREFUeNrtXWlsVNcV"
    "Pm8Wz9iewTYYbxhjjDFmM4SloKwkipI0QiIhIU2VSlV+VVGrqlX6p5XaRpXa/kilVmqriD/N"
    "IqWtQkjSJA2ozdJUQJMGEwwYAwZjDLaxjbHB23iW93q/O3PtWT1vmzevynzS9fO8eXOX893l"
    "nHOXJ5ENMT09rfT09FBvby/NBAI5S6fY66XGxkZatGjRnoaGhnfzXW7bY2pqSnnr7beVSz09"
    "SiAQUGRZzllA/EgH6fX19T2d77InQ8p3BpJx6vRpxe/z0YoVKyxL88qVKzQxOUltGzfaSh6O"
    "fGcgGb2XL9OyZcssTbO+vp6nazfYjpzZYJBcLpelaSI9pGs32I6cAuZRIIdBUZR8ZyEtCuTY"
    "GNZ27hpgVW2WJFspaAmwJTkgxsquxq4EfeXJQTpOpzPfRU6Lrzw5aDV2VQhsSQ5gV4FZCVuS"
    "Y/WYY9eKUCDHxsg5Od0XLyrXBwdpdnaWxsfHKZvIh4eHeYhEIpYIQHI4yO1y8TQPvPnmgtmD"
    "TldeXk4ej4dqamtpdXNzTtW8nJCzf//+1q3btnWNsAKHgkFau24dFbnd5PP5sv724MGDVFZW"
    "RqFQKJflngM0Na/XS1VLl9ITe/dmfX5ycpLnbWhoiA4dOqQsraqibVu35oQk08k5deqUcvXa"
    "NaqprqYtd9yhKw50aVa1HJGeWogKVlFRQa2trTQwMEB//+ADZXl9PbW1tZlKkqnknDhxQpmZ"
    "maGHH3qIHA79niEQY1m3ZlCVrquro5qaGmpvb+fl37Jli2kEmeZb+/LLL5XikhLavn27IWIA"
    "CEuWZUsCKoFR5QPlRblRfsjBLJmaQg5mL8PhMK1paTElU0JoWgPGD62/MVMzRPkhB8jDjPhM"
    "IaefjTGbN282pYB6gdnTYEjWPItqtsoOOUAeZsAwOcfb25WNGzfm1T9VU1NLvX2D9If9B/gV"
    "n/MFyAHygFyMxmWYnJGRET4o5gvQmm6OTdKrf/mUvCWV/IrPuJ8vQB6Qi1EYIufcuXPKqqam"
    "vAkBBAzdCNArb7RTib96LuAz7ueTIMgF8jEShyFyrjNDbCkz3vIBv99P/UNhev9fg+T1VaUE"
    "3Mf3eC4fqGRygdfBCAzZOZMTE1RcXGx5wUtLS2lorIjauybIW7wk43PtXbO0aY2P6ip93LK3"
    "NI9Mrb59+7ahOAyRg+VEbrfb0kIDgUCAGmrLaUmFN+uzxeyRWzdvWZ5HyMXocitD5MAeMXuK"
    "t8jj4fYHDDvEnw74fuzmdVUa4q3pzN4G5F3YRkjXbGTKv1rYbspgZWMjDbG+uq62lht0C9kh"
    "agoPAjItUhROz/7+fmq0cPmvWtiOnA0bNtDb77zD3fjwWRUVFeUsLXiX4bjsOneOHn/ssXwX"
    "PQWmkGO2lf3Ynj1wgdCRI0coMDubs8J7WVe2vKGBp2dmGczq6m3XcgTamJWN8FVGYcVnDmBW"
    "KzTccgrz/akwq1vjsQwODv68u+fyC691hmlg0pj6lw21pRJ9a52T7t65I/dSMglnz56lK319"
    "3L5SCwh2eGSEqqqqVP9GbINkShHnRWJWrPKNP50mpfVOum+nQqtKJILN72VfQ0+CJeGSov2f"
    "lj4QFMO6CLNGBVMsyK4z7Hp5RqF/fiaRo+sY/e27X0v5HTSo02fOcMchVN1cL5WFmr1k8WKu"
    "JabDu++9R5s2baJldXWaNEfkG2XQ4t4KMqO1n2mPHR0dtPfxxyXpkyPHlBdv7qBf3qeQj/Ht"
    "dMTI4EGKXkWCGgqtiMD+RBSQpVBYjt4LsUh/+LFCzy86RvfeuTPhd0eOHqXKykpqXrXK8Iyq"
    "GqAydHd38/+TCers7MRmXl1bIPWQIyC2QTpePh2i+nskKpKjtT3XiLBEXOzP2l0SvXo2MUX4"
    "v7AGYf26dXz5EVwguQ4lJSW0evVqGrlxIyWvvUxIVm+BBMQ2SMcN1s1Usz7MyiEdaVV5JELa"
    "QqEQIR/r/dFCIzFvRHwIMhvL6i2QgNgGWVClbQxeLVCT5bgrQnwNVmKftbYuJUMA5Ng/8Wp4"
    "vhXyZJMgX/kR+eDkwH+IsSDCGHBi7HFElQA5lkMoBYqkQyFQoiQosTTwPzQ4KUupefdmow1N"
    "eu04o/ZflBwlLkhR4c0N1bEmo1VUijLfUuRYfPwai1iZe05J/JFJBTNLmEaMbEVnOUTF5ORE"
    "WAQhFhxytMVIjmgrigor2mQkjQTNdZNKNP5ip0RT7Aq7x0EKpfP2i4IYnQfRKoiFBCgWOIpn"
    "EbLlTwhXiS1c1Jof8XtHVBhxLScmUEWOq+1K4nikJvCWEwtlbqbzX52hSsytSFHDNJM89NY2"
    "vRBpKVm+BwJBB10ZCGa1v+I1Pj35SRhzImHiBqIzNuYgbUloAHo0AZrv1sqLJOrqHKaPPp+l"
    "J79eS0WLnRRgbMtxmVlIIFZioW4Ntfnm7QgdPXGb2WJual1VlnU9t56KFj/Wxro1oqAcHfjh"
    "rpn7OqYI8CtpVAjYDxpKJerrH6MDH/SQ01PN76MShCJxY0+accZqcjKmm9ICWNc8E6ZPPx+h"
    "xWVOqqr0UzgcWihiQ2VxCIGFWW2OsL4sjO0XGBPmujmFjxmyhoAM1Xki1HXhKr3wm8PMoJqv"
    "YTJLI6LMq9LpgH462SDMdViIOJEfgSAT2CtvfEF914ZZTXekLI4XceopR3xanBwIKyRHSYpQ"
    "TLVW5v+PH3vUhMUeBw0MjtDPfvV6quApNubEtZz4jMULxIqQTERCSLknHoy2ipdf/5BGR8e5"
    "RZ9cDiFkPflJIAfdDLo1BJAUUkRrigoyIshSEbxs4Dp78iQ994Nfp62JiB8NKZKGnHy0nPia"
    "mq41JT6jULz6gFu//eOf6Xz35TktLpkYPfkR4GPOayMKLQmEqMIjURkbwH1MpYLq62EDkJt7"
    "qSWuLDhUDjot6zfRS7/7MT3/01dTvuu5LdOVSZneY/WigShhjgQuc2QQnmKr1GloXkgP6SbP"
    "1yAPuId8YbpAlotTavr3n3uaystKExYQgijECycughZgmkRog1GFgI1pE0xjK2Kf3JGo1ibF"
    "lAHepUmkiZyu8QjdW7uUfvGTZ+jFl44kfDfLIpwOzysE8RC1B1qQVeRkG7DFXqF0+Xn2mQep"
    "ckkZjY2NJcQjbCe9O/QSVGli5EwxgRWz4GWkFcXI4FzgOUeUILXkQH/5x3WiR1uW0ws/eoR+"
    "/9r5ue/Qpc3ENDZR+HhBxAvECmTqUsR3uIf1c3PeaXbP7XLQU09t59ra0ND1FILnFivqLIfI"
    "R4ycCCNHptKIgwIsriIn7B2FT7YJPlwayAEw/rxxOUQbFpfRvkebuJ3DyWHxTrO0QmlU6bnf"
    "WrgnNJmMdHmZH0eISoudtGVLLbtKNDDQnzYeYavIOsoRb+BGyZFTFQA55gCN9xxogRxTEL4Y"
    "CdP6+iW0IzBB5T4HjYxH5hyt/Lk0Lcfqg4mS04/7cq71YFzylUjU2lRMdUtl3pVlgnDB6ClH"
    "iiqda3SOyVTc5KcDw2EamF5Yfc0n0qnSAiBndnqYmutly3YsWDLNN8Oa0H8YMbdCC7tqlOgN"
    "SwqeDtm80tDagip3DphR0fK+4jPTlEHe82ID2IqcvAonXbeaZ7LyTk4ytIhDDLxGZk2h8oaY"
    "qmzH0wqj5DisXTSNtIQo9LYcYUvAcocdohdhpupinZh/0SLbrCEQcFUyfb2UKVD+IoclBHlY"
    "dfC7HTTBSl5RlKqgq20DIAdr244eO5a5+4mbtXSka10xdbeMEdOUZlc41rVl22VnJuJ32nlY"
    "pXM9u9FNn5x0Uv097AYzTvyuqG+thAVvzLfm1uhbA2DjhGPebm+EeFweV3R9nJ9VCP8nRHvq"
    "pzJmMltXBYHhDDdcH7j//oxW+pkzZ/jCwYaGhpTfw+r/6OOPqbY2/aESSysrVe+yS04bcYug"
    "Fgk77RobydW2ds2H67/47MG/du6klTsUWsMMrXLGhJ+Rwv4ljxR157glbV0fJ4ZdZ5Wou2aS"
    "XW8zknrYjdP/JWq99Rltf6At4TfIGPp/CC7bumQ8gxWZKDxqeLoxAxuvbty4QTt37ky76xuG"
    "5PT0NG+B6YCVoNjAhV121dXVqtdKC3KCzDbCcl614DvtBgf5Trsn9u6NVs+bDMdPn6346zmZ"
    "rk/ltvlWemR6dNk0rd+8kcrSNMVr167x8w1cKgZoLxM4CMWa5HTdDuJwM4Fm8gz7Skupigkd"
    "LWQhXOjuplFGclDlAX2CnNHRUU27DFCWhuXLsXA+usvAiKBx7OKu++7T7BZXAzWCKMrDNns1"
    "ADFoMYcOH6Z9Tz6pW8a2U6UF7Cp4K1FYK21j2LblXLx4kW/LUOvL0gMM8Bhvmpub813ctLAl"
    "OdhAhUPltm7dmtNzCMROMqR391135bvYKbAdOdhlhlN1rXihHojHiSEwUJEuVGc7wXZjDroy"
    "qw/Xw+61dDvb8g1DLQeGoFiqapZHGYaYmpOoAsyYnQpkT7OYWdEl3oW1WaRn5iHjQh5G97Qa"
    "Isdj0OloBH2DAWrvnKCJqcxz9P5SJ7Wt8dH65hLL8iWWRYFsj8Hx0hA5Pr+fG6CwbK1ekNHS"
    "WEwkB+nwv69mfGbXtuXU0pSdGLPnkUDO1NSUJtdNOhgiB0fij9+6RctKS00nR43AWprKyOUM"
    "04H3O1K+27d7EzWtKFMVj5m76IRDdfTmTU2um7RxGflxa2urhDd8IDNmFlDL0tWmFUvo2ae2"
    "0szE9bmAz7ivZjmsmRA+NWiB8CxDPkbiM6ytVdfU8GNEkCGzCNIiNBCwuMJH3/7mLgpMj/Ir"
    "PqudfzGLoPjJP9hO8GIbhWFy8HqSS5cu8YyZeRyKlsXfSLKxoZa+9519/MqXEpu0BUQLOWLq"
    "4sL586a8tsUUI3RFQwN1dXXR2rVrudVt9OUN6ZbGZgOer6mu1Kw9GjUDxMQgiIFidLKjI2Vi"
    "Ty9MMULx3hgcJ9zb28snrsweg9RC7x5MvRBdGcqM2dbuixf5kcVmvUfHNA8B3hsDTQXHX6EG"
    "CZJwT+sKGas2TulZFyDKIsYXzLCirGgxWMtg5vtzTPWtIWN48xQciS0tLVzVRjcj5t/VnmZr"
    "dasTaWab7xcGJogR0+M4wPU8G2PQldn6zVOAyODx48eV7gsX+Am3ONYKBVFjlInWZhWEwMXs"
    "ZbZnJyYmuOGNo/AHBwd5+Xbv3p2T2pTzKhr/tsOx8fGsz6PQjzz8sOUv1MOhd2qMxor/97cd"
    "xkNrAbAuAYfhzebwyOJ4gBwM5iDGyHx/LmC7+RzAyp1thXdTa4ReTUpvWgVyNECPEaoXBXI0"
    "Il/bDu0G201TFzCPAjk2RoEcG6NAjo1RIMfGsCU5djoZN5+wHTlYTiS2+uUaydv87Abb2TmN"
    "K1fS0NAQX/UpjtrKFZK3+dkNtuw/Dr71lrK2tdWSF+phFx0mCLHNL9/lTobtMiTQ0dGh9F29"
    "qumFQlqRvM3PbvgfnhklmOdyrPoAAAAASUVORK5CYII=")

#----------------------------------------------------------------------
aero_dock_pane_right = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAGcAAABlCAYAAABQif3yAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzoyMTozMiArMDEwMExUiZ4AAAAHdElNRQfZAxkQJBxqm5sb"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAD6VJREFUeNrtXVlsVNcZ"
    "/mc89oztGWyDd8xgjDEGgx02BSVEkKRK8kCWkkWpIjVKX6pIbdVK6UP7UFWV2r60ah8aRbw0"
    "SdUsDSFEJAW60SQCSlIMMXYwqwEb23gBY7zNfnu+O3PG1zN3PHebe2+V+dBhPHfuPcv/nfOf"
    "/z/bdZANMTs7K/T19dG1a9doLhDIWTrFHg81NjbSkiVLnvT7/QetLrftMTMzI3xw4IBwpa9P"
    "CAQCQiwWy1lA/EgH6fX39z9vddlT4bA6A6k4290t+LxeWrlypWlpXr9+naamp6l940ZbycNp"
    "dQZSce3qVVq+fLmpaTY0NIjp2g22IycYCpHL5TI1TaSHdO0G25GTxzzy5DAIgmB1FmSRJ8fG"
    "MFe5q4BZtdnhsJWBtgC2JAfEmKlq7ErQ154cpFNQUGB1kWXxtScHrcauBoEtyQHsKjAzYUty"
    "zO5z7FoR8uTYGDkn59Lly8LN4WEKBoN0584dyiby0dFRMUSjUVME4HA6qdDlEtPc9/77i2YP"
    "Nl15eTm53W6qraujNc3NOTXzckLO3r17W7ds3do7xgocDoVo3fr1VFRYSF6vN+uz+/fvp7Ky"
    "MgqHw7ksdxKw1DweD1VXVdHTe/ZkvX96elrM28jICB0+fFioqq6mrVu25IQkw8k5e/asMHDj"
    "BtXW1NDmTZs0xQGVZlbL4ekpBa9gFRUV1NraSkNDQ/TXQ4eEFQ0N1N7ebihJhpJz+vRpYW5u"
    "jh595BFyOrWPDIEY09SaTlO6vr6eamtrqbOzUyz/5s2bDSPIsLG1M2fOCMUlJbRt2zZdxAAQ"
    "ViwWMyWgEug1PlBelBvlhxyMkqkh5GD2MhKJ0NqWFkMyxYWmNqD/UPuMkZYhyg85QB5GxGcI"
    "OYOsj7nnnnsMKaBWYPY0FI6pnkU12mSHHCAPI6CbnFOdncLGjRstHZ+qra2ja/3D9Ie9+8RP"
    "fLcKkAPkAbnojUs3OWNjY2KnaBVgNd2emKY33/mUPCWV4ie+47pVgDwgF73QRc758+eF1U1N"
    "lgkBBIyMB+iN9zqpxFeTDPiO61YSBLlAPnri0EXOTeaIVTHnzQr4fD4aHInQx58Mk8dbnRZw"
    "Hb/jPitQyeSCUQc90OXnTE9NUXFxsekFLy0tpZGJIursnSJP8bKM93X2BqljrZfqK72iZ29q"
    "HplZfffuXV1x6CIHy4kKCwtNLTQQCATIX1dOyyo8We8tZrdM3p40PY+Qi97lVrrIgT9i9BRv"
    "kdst+h9w7BC/HPD7xO2biizEydnMow3IO/eNkK7RyJR/pbDdlMGqxkYaYbq6vq5OdOgW80OU"
    "FB4EZFqkyAc9BwcHqdHE5b9KYTtyNmzYQAc+/FAcxseYVVFRUc7SwugyBi57z5+nbz71lNVF"
    "T4Mh5BjtZT/15JMYAqFjx45RIBjMWeE9TJWt8PvF9Iwsg1Gq3nYth6OdedkIX2fkV3zmAEa1"
    "Qt0tJz/fnw6j1Foylp6eHkHtNj94wGpHCGAdrWR6fv369SaJSj+Onfyc/nwuSsMzua2E9V4n"
    "fbvNRZvaN4ozriI52HbX0dFBy+vrVVlHGNwDOWpaTog5ZoPMQurq6qInHn887XdYUN09PWLc"
    "MHVzvVQWZvaypUtFK1EOT7z6BQmt99HO7QKtLnEQxkM8LEuQErwslyPeN6jpH+AAwPOKMLHB"
    "TQ2xzzn2eXVOoH+cdJCz9wS9+52N5NCzzQ8CrKys1CQUbPXD8EZbW9uC68eOHxfjbF69WveM"
    "qhKgMly6dEn8O5Wgz06cpN9O3ke/3CkQ6nGBM0GGGBzxz8S9aqqQwAP7LyqALIEisfi1MIv0"
    "R0cF+nHF5+S0YpsfIG71YwRJgfEvrEFoYyoPy48wBJLrUFJSQmvWrKGx8fG0PL55LkYNDzio"
    "KBav7blGlCXiYv+t2+Wg17vD5LRimx+ANEPMh+EGBQ9WrPdHC40mRiOkYZypmRqmw8w0d5BW"
    "tdshpp03pW0My5xQsXbSQp/AaoNczrDBlZjkE8GR8rtDQ96FDAGIJf7QRY4eH2cxK0xUbzbZ"
    "0ISxVfQFUZadAvQ9zrgRIPZBQtw4EBwaDAIhToKQSAN/w4JzSMSZJEeLkAWNzy2IQ/q8tBVZ"
    "4NjKpRkTJMERF17SOEg0GbXVSBDmW0osEZ/4mYiY58LFM6Vl7kFgzyhtPeh0k50+axVyLYPH"
    "o3ceRA2yrfiMst/CLDhZltysyZQwW3oO9q+QUGgJwtQQlFSTQjz+aMKkht/DpJQkySkVilqo"
    "Ieb6UIgCIWfW54xojWrLwNOVFWRC5cC/qWY6bHxgjsoLHfO1XVjYHykJgpAeeFwRYV6BJMnR"
    "FBQ8C2LOX5mk46fv0u270QUCSU1b7poZIVO6QDRCooNYVOCgm7eidPDoLbp4bowqipwLCNIT"
    "opLACQR09Tmc4kzPulyFNDo+RZ9+PkTOwop0MmSEozkvOrBYuhBYKBYnCMM1k9MR2ndokL5f"
    "WUgrl1dQ/4wQ78hVpCdtcYgXrQWf4Vg8njS1piUstkDc4XBS/41ReuO9/1IoMt+HKFGFMUlf"
    "ZnbrSYUoPCbJmGSMIBiK0s9/c4R6Lw5QvTu+3jqmMuAf+hve+vB3RIjFW0+qWtOyQp8/l1pQ"
    "eP+3bt2h19/657xpQly/ZlaL3BAwc5dBagtKU2tCvEZHZWyUn/3qLRoaHqOlzFJQo8aSVlqK"
    "SuNGgWBUy0kVJKyfC5eu0u9efVtiGQvEu13pc6lpW9FyMuWFXwtHE2otQ+N6+Ye/pt4vvyQP"
    "65OiMsKWC0lVxtVZQnWGovHAK4LY52AYP6RhjRUGKWdmZtLUQqO/nn7w8vP02h//llZTseaM"
    "L1Xi3zmQB8SFkWKzzGkYLEgP6QZk5rL+NCbQskCYCdFFHc70nuW13/+EXJW1dHFS+WYvTlKY"
    "NZ0gK2aAfZlhhsdkSCDGMX3E2oyfk6N1J5l0j4sUU1NTVLmsgl564Rv0l4PdC36TqsRU8BqL"
    "OM0iJ1v/Fw2z8jDBBZCdlJHIX/z0Baqvq6JPRqOqhm+4+gqLxMTDLEtjJhonJCZtOVr3YEYT"
    "m5zkBIm5Hn9DLb343DY68PeBpGWH+7EeTaoSOfjffPOUGZDr8xaAkYNaHYxS0rZ1FxXQK688"
    "Rn5mrX08EBGvOVWYa5wcUZXF4nGLJLGoMGcUjkrI0SqMWIaWwzE0NCjujN55bx2d7g3Hna2U"
    "liNrvpq4J1QK2XIwSc2wjiEUi48IlHld9PDDTTTlLaN3+kLkYqzwCTil4EYG4kQfE2QXoNow"
    "8uBMmNRAsuVoGltbrMYlMDExQfVVS2g2WEzeYgcFZ8ML/By5lmPmopFUQyQNCR9nbE6g8ion"
    "3dvhI1ruo5OjEXE4xykda1OITA4o0gHRUam1lmtghrO5IcaIGU2eL5BphMFKLJaXG7Mxevtm"
    "hIpW+ah7wpxWbcrSKKioycnJjM8n/45fMKXg2fIih5tzMTo2IhDTbFTsyv2UhuUrPjNNGVie"
    "FxvAEnKSQsgwtmYJbKBWU2F5y0mFGvHweSE9s6ZYGxdmpr0dTyt08UKaDdk1BCpqLt/4hEWQ"
    "8Ju0IsL6Q6yh8y1ZIp++09wF5UiLVxOXmxUu204yIyHdTSa3ZVFpNUE8WNt2/MSJzH0Vu4eX"
    "ySlXAROzoGWMmCaZXeEVRTEqZY/7ipymEORmTcVX6KQpVpxK5na4GletEo+nwt55PsakFBh9"
    "RlBDKoiBULFpqSrDalElqgqVCWe44fOhBx9MyzevBD09PeLCQb/fn/Y88v6vo0eprk7+UIk9"
    "K2bos54CanggSm7mlPiYheZlAVPVHla9mRypEOlocEL58I2HWeWIy+2Kr4/zMVJ8/yZxzbQL"
    "b77Y/8EHgkvDTjJsbFrCap0abx4qaGh4mHp7e2nHjh0LfsMid+h/CC5bPnAPVowi32iBcn0G"
    "8jc+Pk7bt2+X3fUNB3l2dlasLHLYtqmD2vpO0rtfbadV9wq0tsRB5YwJH9YSMDLcWDPtAEHq"
    "VJ9IDPsMYo00I2iafWKSuI9d6P6CqHXyJG3t2DCvRbq6uoT+gQHZkdlMwC6DivJycYxNKXAo"
    "3jLWYlrWrJH9/caNG+L5Bi4FHbSHCRyEYhxPrvUijkJGMkbP5eAtLaXqmpqMLRhAi/zPmW46"
    "NFhC48HcKrfaUic93+qkbe1t4omIuiwBHLu4a+fOjIXXg5CCkwqLLNhmrwRozdAoh48coWef"
    "eUazjG1nSnPYVfBmIr9W2sawbcu5fPmyuC1DywytUsDoQH/T3NxsdXFlYUtysIEKh8pt2bIl"
    "p+cQ8F12SG/H/fdbXew02I4c7DLDqbpmvFAPxOPEEDioSHdNBgvSKtiuz4EqM/twPezsk9vZ"
    "ZjV0tRy+ON3IN2lglELJSVQB5rDNBLKnWcw8xRLP4tYs0jPykHEuD717WnWR49Y56KgH/cMB"
    "6vxqiqZmMo9O+EoLqH2tl9qaS0zLF4jhy63cOvtLXeR4fT7RAYWXbvaCjJbGYqJYiI58NpDx"
    "nl1bV1BLU3ZijJ7HATlYzwdHVA90kYMj8e9MTtLy0lLDyVEisJamMnIVRGjfx11pvz27u4Oa"
    "VpYpisfIKRM+oHrr9m2qrq7WF5eeh1tbWx14wwcyY2QB1SylbVq5jF56bgvNTd1MBnzHdSXL"
    "eo0EP9sNViDOcIN89MSn21qrqa2l0bExMUNGEaRGaCBgaYWXXvzWLgrM3hI/8V3pNIZRBEkn"
    "/+A71TCtohe6ycHrSa5cuSJmzMjjUNQsRkeSjf46+t53nxU/8d2oLSBqyOFTFxcvXDDktS2G"
    "OKE4aAjzM+vWrRO9br0vb8i2UFEOuL+2plK19ajXDeATgyAGhtGXXV1pE3taYYgTivfG4Dhh"
    "nDqFiSuj+yCl0LpqVSu4KkOZMdt66fJl8chio96jY9gIAd4bA0vl3LlzYg3iJOGa2hUyZm2c"
    "0rJmgpeF9y+YYUVZ0WKwlsHI9+cYOraGjOHNUxhIbGlpEU1tqBl+yq3S02zNbnU8zWxnAHEH"
    "E8Tw6XGshbjA+hioMlu/eQrgGTx16pRw6eJFcV0CzmRDQZQ4Zby1mQUucD57me1e7D2C440p"
    "+uHhYbF8u3fvzkltynkVlb7tcOLOnaz3o9CPPfqo6S/UO/jRR4qcxor/97cdSqG2AFiXgMPw"
    "gjk8slgKkIPOHMTome/PBWw3nwOYubMt/25qldBqSWlNK0+OCmhxQrUiT45KWLXt0G6w3TR1"
    "HvPIk2Nj5MmxMfLk2Bh5cmwMW5Jjl5NxrYbtyJFug8w1pFsg9S5jygVs5+fo2QapFgteqNfY"
    "aHXR02BL/YFtkOtaW015oR520WGC8Ok9e2wnC9tliEPLNki1QKvxr1hBHR0dtpTD/wDriTgZ"
    "SBhbDwAAAABJRU5ErkJggg==")

#----------------------------------------------------------------------
aero_dock_pane_top = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAGcAAABlCAYAAABQif3yAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzoyMTozMiArMDEwMExUiZ4AAAAHdElNRQfZAxkQKSNpU8hr"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAEFhJREFUeNrtXWlsXNUV"
    "Pm8W22OPYzu24yXxEscxzk621kDaAGVTFVqxCoRaxJ9WlSr6j1+V2p+tVLX9U1URUlNVXdgK"
    "EhRCgYKgSShtFpw4qx3I6iReEie2x57tvZ7vzVz7eebNzNtm3kPyJ109+828e885313Oucsb"
    "iTyISCSiHDzyOf3peIKGp+SildMa9tH31wVoZXvbi21tbT9wW+9MSG4LkInp6Wnl8Rc/J2XN"
    "nXRfn0JdIYlCfL+MJS3ja4Cvfr76DOancEoi8R8Jvkb5OsvXKU6DEYU+/UQi3xcHaPdj7S8x"
    "QU+7rb8WAbcFyMR/j/STtKqPfnFHkqoUifxszYAPZPDfTIwkpWqUmVoFgtD+ZAVJoQSI4hvb"
    "JYUeu8dHL8z00dD5z57ir3iKHKMVsGTYcyxOnTskKkumjFpMgKRgUqa6h1Lleg2eI2dsRqGm"
    "ComKN9IsBMppDfnUcr0Gz5GziHl4bswBUJuVHAmQyFyXp+j8LcYhtbxSNVOT8GTLwcCtKGlC"
    "cE0bT0kzZLYDUpSFSc7436vwZMsBGXE2mo+vki/loamMpK+Skr5nEHKa0KQiPLa0ay0vbEFe"
    "gyfJgbsrswVlad6YPjajTCk/WnWlTdR4lQC1lShz+Qm3mtSy/G6rrAtvkiOn3Fw/SEmnpOZz"
    "lRwTLUd0ZSIYVVtNOikWuslSwZPkoLtJLqjhCwNPswOldvyaD0ZTZah5erRf8yQ5MFxc03Ik"
    "zXiDq3oxUd0XEJJulXE5lZBfwqNNx5PkJLj/iSdT82gQEC1lriuT0/9bcQjSLVJc0ULVLBdb"
    "jnGkxgSFr0gStyApVfPF6CCZdwiSmi5NzRctSE5l4lFuik/O4NCQcvXKFYpGozQxMVFw8N1z"
    "gY2WSNVqdezxpQyrOgWa6NNnsuVox5lk2jlIpLtM0XJefe21vOKhyNraWiovL6fmlhZa3d1d"
    "1Fn9opCze/fu3q3btp0cHRmheCxGa9aupbJgkMLhcMFn9/z2E3rpukJN3K8tLZeoOihRlV+i"
    "CvZ2y5iooC81O+03YRYxCx1jdqJ8neYbk3GiGzE45xL9jfPayd977NFHC+Y1NTVF8Xicrl27"
    "Rnv37lUaly2jbVu3FoUkx8k5evSocvHSJWpuaqItmzdbymOWW84UG66cI1AI6FfdLYkUf8rj"
    "MkOO6NJATpTJmeUmM8PkRNjjmI4paqwTjyeNZcYQFayuro56e3tpeHiY3n7nHaVtxQrauHGj"
    "oyQ5Ss7hw4eVmZkZevCBB8jnsz4zFOVaHWGCKlm6crYbNx61GxNdGRwF2SQ58MxinFc0nWaS"
    "qTJAdtI4N1lobW2l5uZmOnTokKr/li1bHCPIsbm1I0eOKKHKStq+fbstYlRwTZ7mqj7Do/Ys"
    "J9T4WDKV4rL5pD7LA4varaXzRIpwGRG+2iFHNSLrC72hP+zglE0dIefosWNKgkfx23p6nJEq"
    "keraoolUbVdTOi5BDyScBW2C9xXmJpaU9T9X3XNZ04I0ZZBNcgSgP+wAeziRnyPkXOYx5vbb"
    "b3dGwzRkTVIKJHR33+0I0IrpS+rVJxV+Rpu/k4AdYA8nYJucg4cOKRs2bCC/353JQzgG326V"
    "6PjJL+gnL/xaveJ/M96co/KwHWAP2MVuXrbJGR0dVQdFt7BxaYCuXJugn//yVaqsblWv+B/3"
    "3QLsAbvYhS1yTp06pazq6nLNCJvrAzR58Sr97FfvU3Vdx1zC/7iPz90C7AL72MnDFjlXORBr"
    "bGx0RfmeGj9dPzdOL77yBYVr27MS7uPz2/h7bvRwDWyXEQ7C7cBW1ZqanKRQKFRyxTurfRQd"
    "jtAHn82oXVku4PNvJqepu62KTtxIlFTGKnarb926ZSsPW+REYzEKBoPOa+bL36SvRhS6t6uK"
    "WpsqC2YVrpToo7HcvnKxNlHALrCPHdgiR+bATjIzd28ADSGJqhCzlPlyGm6Wg8qP2eAhA9LP"
    "jKema/RQwc9XBX1UnS7Xacg21yI8t2Tw3PoAfXTMT8u/wcbnCh8OSBxcEoXYNy73pyY+A+m5"
    "tYQB3bGVd0mZxMGnRBWyQuX8fNCnUJlfoUbmrIpJqd8r0fc2e84U3iNn51130LqDn9Kfj/fR"
    "mq8ptLrSR7VMSpjJCLGhy/mKjjRgYm4NDSfGCZs6p5nQCU7XufWdmeUAeh9Rr/wf+taOO9xW"
    "PQuOkKM4vPnr7ef76P1/H6CX35NpKFK8NeTVPB79tNdH9z9zp6M6ONXVe67lCNz/jTs5uS2F"
    "u/Dkjs+vOpxqhbZbDgRxulv7qsOpbm0ul4GBAeXcuXM0Mztr+GFEwGZnCCoqKqijvZ3Wrl1b"
    "IlPZx4kTJ+j8hQs0a8I2MOzI6CgtW7bM8DMhtk1nZyetX79eEnnQ62+8oWzatImWt7ZSWVmZ"
    "4cwwuQdyzLScGAdml4eHqb+/n77z8MNZn2N9/tjAgJo3ZnidjqMyEQgEqH7pUhhE9/M333qL"
    "rNgGcgv7WLHNo488IklYGKoOh6mjo8O0Yii8oaHBklHOnz+vTm+sW7duwf19+/ereXavWmV/"
    "RdUAUBkGBwfVvzMJOn78OC1ZssSSbayQo7XN5NQU+c59+SUtX7686EbIxIoVK+gcC6EFdrZg"
    "D8I67vKw/QhTIMVOlZWVtHr1ahodG8uSEfK5ZhvmJYD5HzTtUgNlxqLRBV0i/nZjBhktNJlI"
    "ZHXPkM8t24CXRVfaw3AtCFVdcFoYE7jtkGe2HLfkEXLYIsdOjJPPC1O7tyJ7aWb1LOVzAnPk"
    "WMlIsfhcTgUyxp9SQ69MOxXQqn1ExQwIAaysPSj8jFHhMeiK76JwvZYh8rG7DmLWEPnk19pG"
    "yF1IPqEb7GNWF61tfFqjmIUZYs4Px2g25iv4nBOt0awOotx8nwOQH3oUir+EfpZ6I81zgcwb"
    "pjKiwoZElH/q7E06fDJOO7++lFrqKct9zmeQUiJft4bafP1WkvYfvsWxWJB6V9VQssA+XisV"
    "Tduj2BpzxBiR69lAIEgjY5P08WfD5AvWLVBWSZ9k1iOq1OTkLDerBUg0PZNgfUZpaY2fljVU"
    "UyIRz5exLV3mujUrSU73qXpJknx04dII/fGV/1FMs55spJXKmrGsVCkfcUIeAegDvaAf9MzU"
    "XWsfKzYVZfm0AphNuQRAhDs+PkF7/vLBgrPkipJRETIqhhg8rcpjJWUSkU++OX7SR7OhH/SE"
    "vnqV1ooe2hZsu+VkCoA+8/Tgl/Sb3/1V4xkrJIbdzNqhV3tL2XJyyaK9N/+deT1EZYOe0Fd4"
    "cYUqrhF5BNQxB1PVMQt7rDBJOT09ndUtdLa30vM/eop+/4d/ZtUMrImIgVT8P9ddsAyKetIs"
    "XjJ3Gp4XykO5mes1Qj7IheUCWQ5l6QM9a2uqFmwgBFHIF/ZBMgM4UMIbVMmBsQp5HnoQz2WS"
    "Mzk5SQ31dfTcM/fRy28ey1I4sw8XELUHeZaKHCPjXy55oF9DfQ3duHFjQT4idrJq1yxX2hI5"
    "eQTHWkb7imZ69snt9MZ7F+c8O3wfB4y0TV9rCK1BSoFcXYr4DPcg79zsNN8LBnz0JOsFb+3a"
    "tatZBIMctICkRT2EHAE7xpBztByB4eHLVFNTw/FNixrnKEp2y9F71mqNs4tcsszLjE2Iftqy"
    "pUXdjAj99CBiFdmCHtoA114QmqPGaYEm39q4hCLREIVZoWgkviDO0Ws5pdw0kumIZHw4px/G"
    "Jey77u0KsT6yqlcuiCkYK3pkudLFBlY4u1fITMyIqqQwSrar6u6igZ4rLQC5IT/0gD6lQEm2"
    "RqFp37x5M+fzc3+nbpRE8UKy6Olnxqt1oqK5vuMz15KB67J4AK6QM2eEHHNrrkCvB3CZLNdb"
    "TibMmEMMvHZWTeHyxtlVdus0eD4EhJKlhtYh0N4zChFLIHJHHGIVCR4PsU+sesmSrPLd7uQC"
    "5awcBmz416WIyucCNC5T78ii0WqCfLC3bf+BA7m7H82qpU+vAqbd3RompkvnVDjkc8s24CXQ"
    "uXKl+noqnJ0Xc0xGgagZyYzgKBxGxduWGnPsFjXSVcFgeIcbrvfec0/OKH1gYEDdONje3p71"
    "PGT/14cfUktLi24ZkO/ayAi18ucJnX1t+YwsbGNm3xvkxV7yy5cvq3umAxs3bJD+/vrrCjLB"
    "24/M7AeeZeNgu6qZKBhKDl+5QidPnqQdO3Ys+AyCof+H4QrJge9gRybkRg3XGzMg39jYGPX1"
    "9eme+kYgGYlE1MqiB+wE3bdvHwW5jKamJsO2EeTEuLLDPkaBxqHa5tQpvPttvnr29/crFy5e"
    "NLWTHqcM6mpr1Tkko8BL8eq5Rvaw4nq4dOmS+n6DgIEBuoINDkIxj6fXepFHkA2aa2Y4XFVF"
    "y9jojQX2e58ZHKRxJjkWN/ZLIYKc8fFxU6cMoEt7Wxs2zs+fMrAKvHbx7p07TU+LG4ERQ5QV"
    "45i9AwAxaDF7332Xnnj8ccs29pwrLeBVw5cSi3ulPQzPtpyhoSH1WIaVFVqjwACP8aa7u9tt"
    "dXXhSXJwgAovldu6dasp79EsxEkylLfjrrvcVjsLniMHp8zwVl0rp8nMAsSv5HgCASrKXZ3D"
    "g3QLnhtz0JWV+uV6OL2md7LNbdhqOWJzeqHN4GaAQMzIm6hmowpNzxYuM1QuUWVFfm8W5cUN"
    "xjBGIOxh90yrLXLKbU462sGFK7N06PgkTU7nnp2orvLTxtvCtK678Ku/nILYFgWyy22Ol7bI"
    "CVdXqwEoIttSb8jo6QwRyTF695OLOb9z97Y26ukqTIzT60ggB/v5zEzd6MEWOXgl/sTNm7S8"
    "qspxcowYrKerhgL+BL36j/6sz57YtYm6OmoM5ePkkomYUB2/ft3U1I1uXnYe7u3tlfALHxDG"
    "SQXNbF3t6qin557cSjOTV+cS/sd9I9thnYSYU4MXiJll2MdOfra9tabmZvU1IhDIKYLMGA0E"
    "LK0L07NP302zkXH1iv+NLmM4RZB28Q+xE2ax7cI2Ofh5krNnz6qCOfk6FDObv1FkZ3sL/fiH"
    "T6hX/O/UERAz5IilizOnTzvysy2OBKF40RDWZ9asWaNG3fl2gRolxuzKI77f3NRg2nu0GwaI"
    "hUEQA8fo8/7+rIU9q3AkCMXvxlSxU4C3TmHhyukxyCis7lq1CtGVQWestg4ODamvLHbqd3Qc"
    "myHA78bAU8Hrr1CDBEm4Z3aHTKkOTlnZFyB0EeMLVlihK1oM9jI4+fs5js6tQTD88hQmEnt6"
    "elRXG92MWH83Ygy7W52sQJRZaL1fBJggRiyPYy/EaR5j0JV5+penACHgwYMHlcEzZ9R9CXit"
    "FRQxEpSJ1lYqCIOL1ctC38XZIwTeWKK/wmEE9Nu1a1dRalPRq6j21w5vTEwU/D6UfujBBx2d"
    "68oHseMFL70zEjTWfdV/7VALswpgXwJehgcySwGQg8EcxNhZ7y8GPLeeA5TyZJuTM+pOw7Pk"
    "lOpMaK7zqV6AJ8mxEoRaxSI5JuHWsUOvwXPL1IuYxyI5HsYiOR7GIjkexiI5HoYnyfHSm3Hd"
    "hOfI0R6DLDYyj/l5DZ6Lc+wcgzSLzGN+XoMn+w8cg1zT22v6GKRZgHycosMCIY75ua13Jjwn"
    "kICVY5BmkXnMz2v4P+EM9joepX/9AAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
aero_down = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB8AAAAgCAYAAADqgqNBAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzo1MTo0MyArMDEwMMndnrAAAAAHdElNRQfZAxkQNALaVrQp"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAAhJJREFUeNrtl01v2kAQ"
    "ht81FgECjUQUyeKjBrfi0EOJktxzg0uOSaWe0lNP/Wk99lBy7A+oSiO1ORE+BChSTjGfBuPs"
    "rATCNSkmyHtpX2ll2czOs+OdWTMMXIPBwKnVaqjX6xiORghK0UgEuVwOhmEgFosx1u/3ncrV"
    "FYrFItKpFMLhcGBwy7LQ7nRQrVZRLpXAfl5fO4l4HLquBwb9U41GA2avB6V+e4t0Oi0NTMpk"
    "MiCuOuavQlXVtRNGFs+NobPWLhphiO783YZ4gut3tc3OEN9/9fDQt5+0ebEbwttCHG9eR335"
    "9A0v5LhDx0LlW+tJm6OTLAr59WDHcTaDiwXk96AqNj5/+eH57fzsEIa+t4k7KMur8TMMPYkP"
    "744xMO8Wg+7puZ/5HrhfMI3ZbIb9ZByX708xHt6LK93Tc78+XHu+alXrlNdT+PTxgpepBtu2"
    "fc8nu1AotB18Op1C0w7EdRMxxrwJtyn8uXOW9ezIt5ErctlwT+SUrTKkKIo7cvrUTSYTKXDK"
    "dEo6V+RULrLkipxeuSy4p9QILmvP5yfhAi4z4VbCZZXaMkfZws/W+g//R+Hz4046fIe3R3S6"
    "0YEftChIOtuJR1zRLvHiQ4r3afRxCbLeCRzhzWK73Rb/gNRXvGP8WqmILkLTtEAbRQqu0+3i"
    "980NyuUyxGabpila5GarhVGALTJF/TKbFS1yIpFgj6VqglrJraorAAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
aero_down_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB8AAAAgCAYAAADqgqNBAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzo1NDo1OSArMDEwMEcuCiQAAAAHdElNRQfZAxkQNxVyqGIt"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAABENJREFUeNrtV02IHEUU"
    "/qq6529nFnezLtGNEEk0O5NZI4GoQaLxoCJ4NgjBgAe9K/5c9SToQbx6UaJgQLyJXgIRDUkk"
    "t+iS1YDgwSWHMGOyO7Mz0z/l97qqZ3vGnd0ZYb1oDY9XXT39vve+eu9VtwJHo9H4+ufrK8+f"
    "XQ6xuh5jt8ZCReNM3Ue9uvjl3NzcKUXgH06fvX7C1B7H08cNDpQUSvxjXlGofWqPWo8JYCiR"
    "CCchdZe6Q71OudE2uPy9gv7tEj57qXpeXbh4yXzQfAzvnTQoGwWPKL4WMM4JrERgZdwhDgh/"
    "sRExCMURLhjOu1rjrW8M3tz3I/QnPwW4/4RCPrIPjRpaWad2Er2Nl+JELoox+xwguP6tDYOD"
    "RYW4sz1wnjzeaW3nnh2VKQXDvYpH/FUYWShpLBPXH4fGPCNaudHC+ctNNG6HI/+35y4fTx6b"
    "wZGlaYTRznb91BszQmR0aKhWrUDo+fSrX0YaO/XsImqHp9HK+GcyOq2jOM6CG0kGByhabmo7"
    "ly1kHqJNg/X6PF7xAnz48Xd/A37t1adwqDqP9cAM2jIZ+0NbkVSQgAUuI6VE0lLpZ2xs9Z2e"
    "waHFBbz7xjNYa/7eF7mWdbkfG/QlGpqL/SDeZEDbyPlQbKx2YuhRMocTt367F+PevTN45+0X"
    "0F5bTbRcy3r/WQzZyNplJIO0x7YMPIp2ks2XpM4zJXQr9FCvHcBH77+OBw7ux83OYJmmVKcM"
    "JlE7SbekD57SnaUs21iGu5s8vLoBzNy3P9HDI7vnm83GYqg0w7MJF2QiV8YhO52oLep2Y0Q5"
    "DQA6VgO332IvNNnIaSSIbB/3XaR9qmN3PUF/jV3kUZrA8WbCqeFSs3tiqEXY043tUHG6O2rr"
    "yEcNM1QtiV1hwLW9NNtt5KH1Ktl7bR9Mki6lHtv37K0iz+5zWr6h29KByM81DPaS9z0Fhemc"
    "QpnHWdGzbTWn7enmTQCenmI9onepW1xYC4Amy1Hx9wVtnUzBO4x8nTcKSicLXpKuPCA8m7GT"
    "gKeUC3iX4NKaNwjeZka3erbWgyDajLwb2PY5xasC1xl8QnNKtSRiPCG4ZHaPtrpOpDIEQ4KJ"
    "ogztkuotulrmYpEbnReqo836NhOCJ22UKD2JPpLorbRDY50bAA8t9V1Kj1T3tHt9cm8xySEz"
    "IXjax/sMOIxkDIDDlQV2Pl7HAd9KUtvZMe574a6M/8H/q+D63/Mii+Pfzc+jMmugwka+2w4U"
    "WdjlnMY054Lrv/xQDheuedj3RIQSi7/C7lLJASV2mIJnDxb/H/T2gC2xyN5e4PM5HpF5vqnM"
    "c71M0LlvFc4c9eEfXTq8Ur96pfr58nHUHjV4cEpjhqAVgvHDgocNHYDteOOCy6nGMwT8KEGL"
    "rP5JadCjX/mu98dFoBpfwbGHl2z3bDab5uq1ZZxbiXGztXufyPeUNV6sajxypI7Z2Vn1F7X+"
    "m7ZM/KBNAAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
aero_down_focus_single = aero_down_focus

#----------------------------------------------------------------------
aero_down_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB8AAAAgCAYAAADqgqNBAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzo1MTo0MyArMDEwMMndnrAAAAAHdElNRQfZAxkQNALaVrQp"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAAhJJREFUeNrtl01v2kAQ"
    "ht81FgECjUQUyeKjBrfi0EOJktxzg0uOSaWe0lNP/Wk99lBy7A+oSiO1ORE+BChSTjGfBuPs"
    "rATCNSkmyHtpX2ll2czOs+OdWTMMXIPBwKnVaqjX6xiORghK0UgEuVwOhmEgFosx1u/3ncrV"
    "FYrFItKpFMLhcGBwy7LQ7nRQrVZRLpXAfl5fO4l4HLquBwb9U41GA2avB6V+e4t0Oi0NTMpk"
    "MiCuOuavQlXVtRNGFs+NobPWLhphiO783YZ4gut3tc3OEN9/9fDQt5+0ebEbwttCHG9eR335"
    "9A0v5LhDx0LlW+tJm6OTLAr59WDHcTaDiwXk96AqNj5/+eH57fzsEIa+t4k7KMur8TMMPYkP"
    "744xMO8Wg+7puZ/5HrhfMI3ZbIb9ZByX708xHt6LK93Tc78+XHu+alXrlNdT+PTxgpepBtu2"
    "fc8nu1AotB18Op1C0w7EdRMxxrwJtyn8uXOW9ezIt5ErctlwT+SUrTKkKIo7cvrUTSYTKXDK"
    "dEo6V+RULrLkipxeuSy4p9QILmvP5yfhAi4z4VbCZZXaMkfZws/W+g//R+Hz4046fIe3R3S6"
    "0YEftChIOtuJR1zRLvHiQ4r3afRxCbLeCRzhzWK73Rb/gNRXvGP8WqmILkLTtEAbRQqu0+3i"
    "980NyuUyxGabpila5GarhVGALTJF/TKbFS1yIpFgj6VqglrJraorAAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
aero_left = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAfCAYAAACGVs+MAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzo0NDo0MCArMDEwMN+SkKkAAAAHdElNRQfZAxkQMBKjjWFJ"
    "AAAACXBIWXMAAAsRAAALEQF/ZF+RAAAABGdBTUEAALGPC/xhBQAAAkJJREFUeNrtV02P0lAU"
    "PS2lUEIlkxlHpCAEZ89Ol27M8A/czMK4duO/caeJiSZu3SgTN25M3DhBFkMmDhQJEK0apnwM"
    "0wK1t+Z1YOqyr2w8yWuT95qcc9+97/UeAS6m06nTarWg6zrOZzPwhJJMolQqoVwuI5VKCcJk"
    "MnFqh4eoVCrQcjnIssxVgGVZ6PX7qNfrqO7vQ/jSaDhqOo1isciV+Co6nQ5G4zFEvd2GpmmR"
    "khPy+TyIW7xwt0SSpMgFECdxi5EzX8HGBDiOs1kBDH7ymaKoIAjCpQAiXy6XXAlFUfR4aBA5"
    "EyBGET2R630LM+tvxpmQNQG8BpE3T8/w8cjEb3MREMe1BuLxOL4bY3z4NIAob/nzq1x+DYQt"
    "IBaLodM18PpNA0p6Fwn5kpzqjXZmTUCYRUiR//x1hucv3yOl3lhbY4Gyd+g7QJGffG3jxau3"
    "SCg7gXUWLH3nC6BfJI2wUC4V8OTxAZ4+qwXWiGexWPgp8J40EeYwTRM72xk8OrgfEMC+CRzD"
    "sEUYhoFi4ToePriDuBTzBdD20zqrOWl1Mmz0ej1kMhncu3sTn5u2XwORHEOG4XAIbfcazm0F"
    "aUXExdQO3oS8MXZbrz1t6ZL/gG3ba2uRtEKUYirMf2Hj/cB/AZ4A1hxsREDCdUKrVyNvULD0"
    "HyBO4vackXsokXNtGR0R3t0RkSddf0iX1Hw+h3TbNYnvajXPKGSzWe7ekILsDwY4bjZRrVbh"
    "JX80Gnnu+Fu3ixlnd0zR3yoUPHesqqrwB18A5ik1mQXQAAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
aero_left_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAfCAYAAACGVs+MAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzo0NjozNCArMDEwMCXtbZ4AAAAHdElNRQfZAxkQLw561jOY"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAABAVJREFUeNrtV02IHEUY"
    "fVXTO70/M+yOExNd4oIRkgljDIiyQZR4FD0rQlDw6E1RDwkoIqiHXLzlKK4Iwb2peFDJHgxx"
    "dS+LcTMhhw0qJkvG7Jjsz8xOd1f5qqu6p9eNMB2Y9WLBm6+nf+p79X2vvqoSYFtdXf3ql8bl"
    "52aWQlxbVxhkmyxJvFz3UK8dmq1Wqy8IOv/+xEzjSV17AsePaTw0KjDCF4cFUKQtEB6vJSz6"
    "bWYYERFqoEvbpW3TXm1rfDsvIBsX8OlLte/E3PkL+vTqNN4/rlGCQEE6hzGEta5TkYOATsCf"
    "SBtCGqGy9wJ2+vo5jbcqP0J+fDHA/qcEisqyHnSL6MTjz+GnBYxv+SdDso/x1rvgPBudvb6A"
    "8Z0nrQNpXsJIZaxBNt/a/c8bJf0vME3pDAGlbG4ieikYLUgrPOV6MULU4i5EqK0j7XyYazMz"
    "RGYkXsImhbAvpIJ0Q8/jHM55MmLl+out6hFMCUR8OyCksiMX0kYj7gV26CInCZVxbvofKQhs"
    "0Jq6IPkkISKTFKQRcB9plWGtt+ujH8QRcBgfEmj+3sYe1hVTY0J3PyUQhYiLhHkQa8Hlalvo"
    "7hITRYErl5r44txNrNyMUGQkEpKZFLBUKiu2AjKhduKLLXKKkB9MjQn89kcLs18vo+Dvi++b"
    "gQZRTwtecjMk3UiaHAlb97VlGidfO2306dy8N+krNK5cx+kz51GamMKo77TB3Ea6Nw1lEoFA"
    "WSKR00SaBpU/Dff4EteuN/HOB5/dUZyh01hKwITEpMDAEAl0EpV/6KIPDDPHlxYX8eprH94x"
    "Oqb/bmT7TFMw09SodgJUWJ/HKZoSpWqmjU9BDMWrI1dJt0L20w7Wj+LMRyfxxtuf7Hi2fFvh"
    "V+45vuTYp9IUBMAaZ8IGmW0SbaKjLLZULzr9ovFXhMn778V7p07sIGD62wyxvQ6ABDZC+6BD"
    "bEUWXYdA5UOH33yzAhw++ADeffMZ+MVCSsD013YzIUMgIgHFkWt+TFBJW6TYpQ2IxOaB6efz"
    "qwHWS+N4/tkDGC95lgCfbdJXkNUA1E7RKbcoZStknqacKBeaIer7q5jurGGC+8Em05Msfr0I"
    "DLgttRRGDpQxe4Ob3s3tQ/F2g4BJ7Q90fivYuaP4z3dE/xOQye9uMjG+ksrg7RkRGKMwy0W5"
    "KyR8yr7M+r5GPRrf3itHhjC3WODhJILPyVv27FowSgy7tWAo51pgmqkBoVtlhyPEffmePX+U"
    "6bg8h/iM6D16pH6jvjC/9+zSMTw4rXGIZ8MJeivTMS/hmzOiMCTypSl2Trulbeldp71NIsu8"
    "cfEnoHZrHo8dfdjuMVqtll74eQlnLyusbAz2gHbfmMSLNYnHH6mjUqmIvwGdqbciWIcx6wAA"
    "AABJRU5ErkJggg==")

#----------------------------------------------------------------------
aero_left_focus_single = aero_left_focus

#----------------------------------------------------------------------
aero_left_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAfCAYAAACGVs+MAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzo0NDo0MCArMDEwMN+SkKkAAAAHdElNRQfZAxkQMBKjjWFJ"
    "AAAACXBIWXMAAAsRAAALEQF/ZF+RAAAABGdBTUEAALGPC/xhBQAAAkJJREFUeNrtV02P0lAU"
    "PS2lUEIlkxlHpCAEZ89Ol27M8A/czMK4duO/caeJiSZu3SgTN25M3DhBFkMmDhQJEK0apnwM"
    "0wK1t+Z1YOqyr2w8yWuT95qcc9+97/UeAS6m06nTarWg6zrOZzPwhJJMolQqoVwuI5VKCcJk"
    "MnFqh4eoVCrQcjnIssxVgGVZ6PX7qNfrqO7vQ/jSaDhqOo1isciV+Co6nQ5G4zFEvd2GpmmR"
    "khPy+TyIW7xwt0SSpMgFECdxi5EzX8HGBDiOs1kBDH7ymaKoIAjCpQAiXy6XXAlFUfR4aBA5"
    "EyBGET2R630LM+tvxpmQNQG8BpE3T8/w8cjEb3MREMe1BuLxOL4bY3z4NIAob/nzq1x+DYQt"
    "IBaLodM18PpNA0p6Fwn5kpzqjXZmTUCYRUiR//x1hucv3yOl3lhbY4Gyd+g7QJGffG3jxau3"
    "SCg7gXUWLH3nC6BfJI2wUC4V8OTxAZ4+qwXWiGexWPgp8J40EeYwTRM72xk8OrgfEMC+CRzD"
    "sEUYhoFi4ToePriDuBTzBdD20zqrOWl1Mmz0ej1kMhncu3sTn5u2XwORHEOG4XAIbfcazm0F"
    "aUXExdQO3oS8MXZbrz1t6ZL/gG3ba2uRtEKUYirMf2Hj/cB/AZ4A1hxsREDCdUKrVyNvULD0"
    "HyBO4vackXsokXNtGR0R3t0RkSddf0iX1Hw+h3TbNYnvajXPKGSzWe7ekILsDwY4bjZRrVbh"
    "JX80Gnnu+Fu3ixlnd0zR3yoUPHesqqrwB18A5ik1mQXQAAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
aero_right = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAfCAYAAACGVs+MAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzo0NToxOCArMDEwMEtfu5QAAAAHdElNRQfZAxkQLyM/CW/t"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAAkpJREFUeNrtVz2PEkEY"
    "fnbZQ+AgGD+R5YSAxVkRLfwF5vgH11xlbeNPsbE2Ftf4C+RiY2OijeGu8GIusEjgiJ4Ej689"
    "YHedd8zgsBgt3Fkan+TNZnY3eZ55v2ZeDQzj8dir1+uwLAsT24ZKxGMxFAoFFItFJBIJTRuN"
    "Rl714ADlchlmNotoNKpUwHQ6RbvTQa1WQ2VnB9rh0ZGXSiaRz+eVEvvRbDYxGA6hW40GTNMM"
    "lZyQy+VA3PoFc4lhGKELIE7i1kNn9mFtAjzPW68AgUXwhaKwoGnaLwFE7rru4gOZWKsiFwJ0"
    "/+7tqQ6rw7JTVxcd4hOchvyCVPXOHbz9cA57soHtUhqO4yjxgMBSDogPo4mDN+/OcCVt4Ob1"
    "JGazmTJvLEIgu4Uwmzt48fI9mq2vPBzyP/9qlF9LZeh/KeP5/mucffuOSCTC/wnCBOcfPSDj"
    "6bN9fDppBOYJucJ4DtARSfbzKI6vCHjyeA+X05sYstMrCJA3RZVxAZTpwvx4tPcQ166m0ev1"
    "Ak2+lTIkctk1G0YEu7sPeBV0u91AyQmCyxALEiBUbcYjuH/vFnsC7XY7cHK5yS01Iqr3ZELH"
    "3VIc5g0X/X4/cHKx4d+ehiTgYvwFd0w3sIT7G1auQiRCZefzY+33gf8CuAD5eAxdwCXWfqkH"
    "qLyAyKDNUismTuLmkxErSmTZWEbZr/puSOQxNh9Sg5vP5zBKbEh8Va3yQSGTySifDWmTndNT"
    "fDw+RqVSAQ/+YDDg0/HnVgu24umYdn97a4tPx6lUSvsBjEDOU65zEi4AAAAASUVORK5CYII=")

#----------------------------------------------------------------------
aero_right_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAfCAYAAACGVs+MAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzo0ODo0NiArMDEwMKZ+RR0AAAAHdElNRQfZAxkQMQU5RdXP"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAA/ZJREFUeNrtV09oVEcY"
    "/83sy27UfZhtNLWxKNaDK6sNlJZIabHgpdB7KYiCR28W7EEPIkLbgz1481hIaSt4a6UUWkyh"
    "Imm9hKbpSg7pIUVjotnGJG5235uZft+bmc1bk8A+NTn1W743b98bvt9vvn9vRoBkbm7uxp/V"
    "ux8Mjce4t6ixkdJflDhZCVApH7je29v7oSDwX48PVd8x5bdx9IjB/q0CW2hitwDyNOZIA7qX"
    "sNqp8DIUaWyAJo1NGus0/l03+GlEQFZv46sT5Z/F8K3b5vLcID49alCEQE46wESFHZ1RkYGA"
    "8UoXZZiQQazts4iMfnzT4JPSb5BfjkV49V2BvLasN1oUgQR0OfieAGPLh+SSl8nfZhPA097p"
    "KwgwdpawbogEnpFOjazpeBv3P6uXzDrKok2KgNY2NopQcpwL0iaedlY4EY14hiQ0Fsg4DL7n"
    "yhCplQSeTUuFndBKSLf0LOBw4H7F2tlLRr1CsEVA0eyIVNLLAi19K9VhnWvHOOc7UllI6BQ4"
    "21euHLkvSHrjiUgfAp7I9d9H/n44VUdPl1hhbdrzoxM1ZrV6W7FfmyegYiRNIp8TmH6k8N3N"
    "R5j4axalvGwj8TyqUupJrhDgdqktCZb5xRjXf5jEvw9q2EutudXNMgKyPT96jVgV2kNgX1Jc"
    "Ur2w0VS4+MWPqE5Mob+giAS9z6j84/jrVC7ERrcW0+aByJXi03Lhs69x7/4sXqLszOIBg7Xd"
    "7xPRpD3ALklCsE6nOX3mc1RHR9FNOaLWMLiWxs5e7O4jF+amsuoXm5Th0KxB73JEEwMMyNXF"
    "dvXKOQQ7dmFiXnVchp5IRC5oENgy/VmiZJ+n7zKtA9/T2ve0+kAELNDLZY1VH/1L54+j/5Wd"
    "+GVGZWrF3tVRAm71CWEsKQuq0x4AEWB2DdV6gkI+h7Nn38ee3SXcmIptvDJ0Ik8gcbu2thMi"
    "ZIr3HJFqI6CIgKaJtvNtLwY4duw1LBS349vJJgJC9puULASiBNwkMW/QAw4Dd1jpynGFgKvR"
    "Wfo+9+yUGBwIgd0hRmbipDXL9LehQ1mvCTEOL0alq8DLP080vpmOkd8XYqzWecI9j6zakEzX"
    "NW49iFGPs6TcCySw2fI/Aemvm8mEsXLuPtixRWAblURI3/7NIFGgwg+7JBYoxxk7OHW4C8Oj"
    "OTqcKBSoaEMq0iIpb8u6iSbNRRedkHLP0Ih8K+6mimZbhcCeP0ICDoeRnBGDNw5XZip3Rvqu"
    "jR/BvkGDA7QB6SG0kPeGBFjgM6JgEtnClIDT2OAzIZFYpPExEZmkB2O/A+X5Ebw5cMjuM2u1"
    "mrnzxziu3dWYXtrYA9qubRIflSXeer2CUqkk/gNN/sDRnOMoBAAAAABJRU5ErkJggg==")

#----------------------------------------------------------------------
aero_right_focus_single = aero_right_focus

#----------------------------------------------------------------------
aero_right_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAfCAYAAACGVs+MAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzo0NToxOCArMDEwMEtfu5QAAAAHdElNRQfZAxkQLyM/CW/t"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAAkpJREFUeNrtVz2PEkEY"
    "fnbZQ+AgGD+R5YSAxVkRLfwF5vgH11xlbeNPsbE2Ftf4C+RiY2OijeGu8GIusEjgiJ4Ej689"
    "YHedd8zgsBgt3Fkan+TNZnY3eZ55v2ZeDQzj8dir1+uwLAsT24ZKxGMxFAoFFItFJBIJTRuN"
    "Rl714ADlchlmNotoNKpUwHQ6RbvTQa1WQ2VnB9rh0ZGXSiaRz+eVEvvRbDYxGA6hW40GTNMM"
    "lZyQy+VA3PoFc4lhGKELIE7i1kNn9mFtAjzPW68AgUXwhaKwoGnaLwFE7rru4gOZWKsiFwJ0"
    "/+7tqQ6rw7JTVxcd4hOchvyCVPXOHbz9cA57soHtUhqO4yjxgMBSDogPo4mDN+/OcCVt4Ob1"
    "JGazmTJvLEIgu4Uwmzt48fI9mq2vPBzyP/9qlF9LZeh/KeP5/mucffuOSCTC/wnCBOcfPSDj"
    "6bN9fDppBOYJucJ4DtARSfbzKI6vCHjyeA+X05sYstMrCJA3RZVxAZTpwvx4tPcQ166m0ev1"
    "Ak2+lTIkctk1G0YEu7sPeBV0u91AyQmCyxALEiBUbcYjuH/vFnsC7XY7cHK5yS01Iqr3ZELH"
    "3VIc5g0X/X4/cHKx4d+ehiTgYvwFd0w3sIT7G1auQiRCZefzY+33gf8CuAD5eAxdwCXWfqkH"
    "qLyAyKDNUismTuLmkxErSmTZWEbZr/puSOQxNh9Sg5vP5zBKbEh8Va3yQSGTySifDWmTndNT"
    "fDw+RqVSAQ/+YDDg0/HnVgu24umYdn97a4tPx6lUSvsBjEDOU65zEi4AAAAASUVORK5CYII=")

#----------------------------------------------------------------------
aero_tab = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAfCAMAAACxiD++AAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFq6ysra6urq+vr7CwsLGxsbKysrOzs7S0tLS0tLW1tba2tre3t7i4uLm5uru7vL29"
    "v8DAwMDAwsPDxMXFxsbGycrKzc3Nzc7Ozs/P09TU19fX2dnZ2tra29vb3Nzc3N3d3t7e4ODg"
    "4uLi4+Pj4+Tk5OTk5OXl5ubm5+fn6Ojo6enp6+vr7Ozs7e3t7e7u7+/v8fHx8vLy8/Pz9PT0"
    "9fX19vb29vf3+Pj4+fn5+vr6+/v7/Pz8/f39/v7+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAA0PbvAwAAABh0RVh0U29mdHdhcmUAUGFpbnQuTkVUIHYzLjM2"
    "qefiJQAAAP9JREFUOE+t0tlSwjAUgOFjZQuxuOBSFURSSOyq0qYNEd//tUzCaIeLk9743Zyb"
    "f5LOSUH3AC3vyEWIuIw06KvHRmGqKIJ3+u1RzaD0BpL+S3DwfIO5oqAHDxPk1LOpr9oGe0/h"
    "ArXHmSCjLbpIpSobyBa3o5DSWqJaF+xqlPykEE/LHFWmU2AkS1GZCdYkFajkjZhAxCghCLwS"
    "zlCcE1j1BpOeE176gqU/mMBy3F0Rb/mpZENh0QWxyJNTfD6HRXfFthgNndFgcJzDa2aCv0WZ"
    "tUj7blLdP9nZ6PCZATtPft+qjELt/vAm/HCzCNYmuA2O5xqzmzOwAuIG0AfGfgDFvqY+8bKe"
    "lgAAAABJRU5ErkJggg==")

#----------------------------------------------------------------------
aero_tab_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAfCAIAAAAJNFjbAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "ABh0RVh0U29mdHdhcmUAUGFpbnQuTkVUIHYzLjM2qefiJQAABPtJREFUSEu9ldtPI2UYxovR"
    "jZd65Z3xxv/AO2/0wnihiZpodgV21cSsiyYbs8ZkiQQSDUaynBaIB0ACLOsegJaWlkNpObSW"
    "XQ5dlgUqPQ3DtPRIW9pO5/DNtPGZFjeVte2F4uTtxcz3e96n7/t+802VJEkqlapx2LQXE589"
    "80xVVRVu//319FO5F587c/Xc6yoYXOrW983vzrqOrExqPcBuRTLOQ94T5/cSApMU/EnxIFUh"
    "wIAEDxW0jyKZRSr+Vv3d724YFYPaDn2Iyy5H5I2Y/MeR7EllaTbrz2QDXC7E5yJ8LlopwIAE"
    "DxW0yOBOylOO8CedOlUikfio0wAD239tYPEkatu0qng8/j8ZWCPyg5i8cyS78y3y/dWicL5L"
    "5QNMoUVQQYsMzqR8XEEsHr/QaQhksosheS0qbyVkZzJLpbP7yhgUTYjLQV8+wOQHkIMKWmTA"
    "LJcKLSoYYDimgHw/Ij9U5qxMiU5nGTZ3AI+M4lE+wIAEDxW0yLCdkBeODWIxGDCsPOUn1jBZ"
    "P5TyRcjelEynZaawnSoFGJDgoYIWGTZjktkTUyo4PDw832nA2iRDFoNkNSptxpXNin1GpeX9"
    "dNaX9ygfYECChwpaZNiISXPuWM1jAyolj9NkLkCWIxJGjQLxRzwpeS9d6FWFAAMSPFTQIsPa"
    "oTRbbADnmx5iYMhSUFqJKpPYgQdeOgw8P4/yAQYkeKigRYZ7EWnala8gGo2iRVgbdAvafdGc"
    "L8KOSaBRCdmFOtCrVIUAAxI8VNAigzVE9LtFBljrdQpjtDjrJ5aQhEngj6BYNLTgUT6U7EcK"
    "DxW0yLAQJLqCQTgcru00bMXk6zvCTY+oY4g5INnC0nq+Udv5OlBf+QADEjxU0CKD0U/UO48N"
    "Ogy2kPTGdPKilW20cx3b/K9O4bZXnKDFKYYANR+Q+dKBVTAgwUMFLTK0bPENJqamVavy+Xy1"
    "7YbFgPSKNnl2gb2ywjVv8j0OYdAl3qZEDU30DJn2kZnSgVUwIMFDBS0yNG3wXxvzBgzD1LQb"
    "5vzSy2PJt43sJRvXYOdbt4RfdsVht3iXUpS6fTJZOrAKBiR4qKBFhqtr/JUZprp1QkXTdE27"
    "Hv/ihd8SrxlSF5bYr1YzzQ+5rh2+3ymMeIQ7XnF8T1SXDqyCAQkeKmiR4fI9rq7YAG/A8yOJ"
    "VydT1Qvsl/cz325wndt8764w7BJuecRRShwrHVgFAxI8VNAiw+c27jNDvgKKolDBKRp4vd7T"
    "NfCcuoHHc0oV1GEG1yZUbrf7w7YKM8A+0dGifp/8Y2AHT9BklCI33GLvrti+JTTa+QY7V6dz"
    "fdyhrWyALYhNvIrzi8mUiqX9zDzNGilW706P7aZGHMn+9eC7Tepv+iZVLperfIvUlLgWlc61"
    "6j5o0TwZ7/+gQTz5vLZVU//zxO82m2JQ3aaf9ZGX7iTenEl9amXr1zMtj7gfHfwgXgKvoHwk"
    "9pK1rdp0Op0qunDL87zJZFpZWSl+zrKsKIqDQ0MWiwXHhGLw3vdqq5//YjnTZOe6d/ght/Lq"
    "4vAyHSjfHxyQP5kcl7vVhJDc3680yw4NDeGje+J5MBjs6u52OByKAX5N/bp3mtVnr2lLxcUu"
    "3a1R9fWurvaOjuLo7unp6+8/8RC3AwMDJrMZh9CxwfLyslqj0ZW+jHNzFqt1XK0eHRsrDo1G"
    "ozcYTjzE7fT0tP3BA2TH9Sf2aVnapn4zWAAAAABJRU5ErkJggg==")

#----------------------------------------------------------------------
aero_tab_focus_single = aero_tab_focus

#----------------------------------------------------------------------
aero_tab_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAfCAMAAACxiD++AAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFq6ysra6urq+vr7CwsLGxsbKysrOzs7S0tLS0tLW1tba2tre3t7i4uLm5uru7vL29"
    "v8DAwMDAwsPDxMXFxsbGycrKzc3Nzc7Ozs/P09TU19fX2dnZ2tra29vb3Nzc3N3d3t7e4ODg"
    "4uLi4+Pj4+Tk5OTk5OXl5ubm5+fn6Ojo6enp6+vr7Ozs7e3t7e7u7+/v8fHx8vLy8/Pz9PT0"
    "9fX19vb29vf3+Pj4+fn5+vr6+/v7/Pz8/f39/v7+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAA0PbvAwAAABh0RVh0U29mdHdhcmUAUGFpbnQuTkVUIHYzLjM2"
    "qefiJQAAAP9JREFUOE+t0tlSwjAUgOFjZQuxuOBSFURSSOyq0qYNEd//tUzCaIeLk9743Zyb"
    "f5LOSUH3AC3vyEWIuIw06KvHRmGqKIJ3+u1RzaD0BpL+S3DwfIO5oqAHDxPk1LOpr9oGe0/h"
    "ArXHmSCjLbpIpSobyBa3o5DSWqJaF+xqlPykEE/LHFWmU2AkS1GZCdYkFajkjZhAxCghCLwS"
    "zlCcE1j1BpOeE176gqU/mMBy3F0Rb/mpZENh0QWxyJNTfD6HRXfFthgNndFgcJzDa2aCv0WZ"
    "tUj7blLdP9nZ6PCZATtPft+qjELt/vAm/HCzCNYmuA2O5xqzmzOwAuIG0AfGfgDFvqY+8bKe"
    "lgAAAABJRU5ErkJggg==")

#----------------------------------------------------------------------
aero_up = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB8AAAAgCAYAAADqgqNBAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzo1MToxNCArMDEwMESarloAAAAHdElNRQfZAxkQMyBAd2MK"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAAh9JREFUeNrFl0tv2kAU"
    "hY+NBXbAElS0QTwColKX4Q+gbvmDXXXVriq160olq7b7Rk2zICsejWyUqkmQgEIMxvWxZAti"
    "0eCoHo40ssZj+5vrO3fmXgmuut2u4zb0+33MZjPEJU3TUKvVUK/X2SRlOp067ZMTNBoNNJtN"
    "JJPJ2OCWZcEwTXw/OwO50o/zc0fPZFCtVmOD3tdgMMB4MoHc7/VQKpWEgalyuQxy5Tv3VyiK"
    "IhROHrmyUOo97QXuOM7+4L4CZ/uziVuSJG3CCRYFX5+AcDg5iURiP3Ba7bOE+3xde/H5huWi"
    "4SHLV6uVEKAsy5uW86hbLBZC4FzpoVCzbVsI3OcFcP5yUfBQqBEuyufkhFb7Y+BMubheHguX"
    "fXiURjH7sSw7yIKivh/Ao4g+KxQK6A1MvHr9wbuyv35a7arI8Gw2i+ubCd6++4KUlveu7PN+"
    "rPBcLoer33d48/4bDvTDoLHP+xyPop0zR13XYfxaov3VhJZ5Fhr/+NlE62UFh090jMfj/wdP"
    "p9O4uk3itDNB6iC/9bnTjoXjFxmUnu42AQ/+0GKZz+c4KuaQz6kPflBTJYxuRrtZnnJjlbsb"
    "N/xtsc7x2+thkIH8S6M/9tbdkkbyGxwn1yuX3OBDsVj0Dpc4j1aCVVWFYRhYLpdQnrsV46d2"
    "26siGK9xFoo0zhwO0bm4QKvVgudsd3F4JfLPy0vPv3GJVh9VKl6J7EaP9Be4+2JJRD7+lAAA"
    "AABJRU5ErkJggg==")

#----------------------------------------------------------------------
aero_up_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB8AAAAgCAYAAADqgqNBAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzo1NTo1MyArMDEwMAycPlQAAAAHdElNRQfZAxkQOBMcU9vX"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAABFhJREFUeNq1V82LHEUU"
    "/1VNz863yWyUyCSaEPzYuGtkwY8QYwLiQfTgwYsgBPMXeDJXvYmo+Qc8KEFIULyJHhQWNcSE"
    "3KLrLgqLoMYVkplIdmZ2PrrL36uqnulOsu50YB68ed3V3fV771fvvZpSoDSbzS9/Xll9+czy"
    "EFc3IkxLGlWNE/MBjj17RBljPlQE/uH1MytHzcEjeOGwwYGSQokvzigqbUCbo9UTAhhqKMqL"
    "IW2PdpN2g/pbx+DH7xX02gWcPblwWi2dv2Debz2Dd48bVIxCjiiBFjBeE1iJwumkIg4If5ER"
    "NRiKIxxgtOhpjVNfGby15xL0xz8NsP+owkzoPpqmiBP5MEL9RUBw9bWuwe6iwvRWOi2C0yhp"
    "CO6kSzkVCWJvzBYqopBtScwdruM8sHj+wkYuiWGMBxTrHxrvQdZcMCat0S33qcgFbMBBTau0"
    "y3CL6K0yfmxCibzDoYkz3pdelGbA0U53Ir4RqfHLmq9FcHVmSy1D+GbEphnNF5cdLFYuAR65"
    "MsgJqNcwMZkFzxB5THXcbGzUXk1iGS240BGmPEw3lqwlkcyfcbNxGHbOKEW7W/M4cpVYb7Em"
    "I+0pQM/qIHIq8w1NMnLyMwhdHw98pCOqI39/NwnnGY2tMKwwLjUL7tbE0Iqyp1Ot5/HqqOwJ"
    "FyYot/MKA5EZMTOOfOi8smuv3Yc26RLdRWeMPLnOoU++oV/SVOTnmuzv5H22oFDLK1S4nRVZ"
    "DTN0JK/d7pbLAB7vYn2i92jbHLg5AFp9KV6Fs5zreAy+ycg3+KDADiMDOZuuCibnMjYLeEy5"
    "gPcIvsmQuwTvMKPbfWNrfTAIx5H36FWHDpR5V+A4g7c0x1RLIkYZwSWz+5yr57UbOgwJJgwT"
    "tEuqt+lqhYNFLvSMUB2O69tkBB/adm1IuwBL9E47ZMA6lwIfOup71D6p7mv/98m3VvHC3AIu"
    "tzuYI//2zG27WJy8cW1bBjyGFQ8+al5RQs02Ksvxyr4Ae9t/WqvV9t8k548l858JYeOlhsLy"
    "yhrePHXaWrnPUg13DX5oNsDf/9zAO+99jnKtYa3cy/hUwRd3Bbj5xzre/uAb1Or7Rir3Mi7P"
    "s8jEbz+yI4fm79fxyRdrqO588LbnH322hjdezePRvbP4pRVONOdE4PtrGr2rHXx7qWup3krk"
    "+bGwjYceqNCB4bbzOnD9//yv86Tx/IEKGrvL205YLSssXds68iROcC+PRxXmf5WNfCsHpEF8"
    "xwlLE/DUve7a6Z2kyO8reY0arwU3OPl4HktXctjzHCenw1V2l2oeKLF2Cjm3scQNZzjByUKO"
    "WvfwoDdgSyyytxf4fZ5b5Az/qdxHnyoE3fW1wonFAMHiwmOr85cvzn26fBgHnzZ4uKyxk6BV"
    "gvFgwc2GDsB1vEnEdjj+cA8BDyVo0+Eb1CbZ+5Unxr/OA3PRRTz5xILrnq1Wy1y+soxzqxHW"
    "29M7ON1f0XhtTuOpQ/Oo1+vqPxxtdiUOpmR7AAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
aero_up_focus_single = aero_up_focus

#----------------------------------------------------------------------
aero_up_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB8AAAAgCAYAAADqgqNBAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzo1MToxNCArMDEwMESarloAAAAHdElNRQfZAxkQMyBAd2MK"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAAh9JREFUeNrFl0tv2kAU"
    "hY+NBXbAElS0QTwColKX4Q+gbvmDXXXVriq160olq7b7Rk2zICsejWyUqkmQgEIMxvWxZAti"
    "0eCoHo40ssZj+5vrO3fmXgmuut2u4zb0+33MZjPEJU3TUKvVUK/X2SRlOp067ZMTNBoNNJtN"
    "JJPJ2OCWZcEwTXw/OwO50o/zc0fPZFCtVmOD3tdgMMB4MoHc7/VQKpWEgalyuQxy5Tv3VyiK"
    "IhROHrmyUOo97QXuOM7+4L4CZ/uziVuSJG3CCRYFX5+AcDg5iURiP3Ba7bOE+3xde/H5huWi"
    "4SHLV6uVEKAsy5uW86hbLBZC4FzpoVCzbVsI3OcFcP5yUfBQqBEuyufkhFb7Y+BMubheHguX"
    "fXiURjH7sSw7yIKivh/Ao4g+KxQK6A1MvHr9wbuyv35a7arI8Gw2i+ubCd6++4KUlveu7PN+"
    "rPBcLoer33d48/4bDvTDoLHP+xyPop0zR13XYfxaov3VhJZ5Fhr/+NlE62UFh090jMfj/wdP"
    "p9O4uk3itDNB6iC/9bnTjoXjFxmUnu42AQ/+0GKZz+c4KuaQz6kPflBTJYxuRrtZnnJjlbsb"
    "N/xtsc7x2+thkIH8S6M/9tbdkkbyGxwn1yuX3OBDsVj0Dpc4j1aCVVWFYRhYLpdQnrsV46d2"
    "26siGK9xFoo0zhwO0bm4QKvVgudsd3F4JfLPy0vPv3GJVh9VKl6J7EaP9Be4+2JJRD7+lAAA"
    "AABJRU5ErkJggg==")

#----------------------------------------------------------------------
aero_denied = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAYAAADEtGw7AAADxklEQVQ4jbWUzWuUVxTGn3Pe"
    "+955k8nMJE5m0vqRZCaUYomG0uJGjDR0UXBRUj+6Kqg7kSy6SBf5A7ropiB07aK4qIsWIYsu"
    "ioXBQoRKqWhJ1eq0sWqSmWQyk8y8H/e+p4t8oJ2YuPHA2dzD+fHwnHMuiQheR/BroQJQOxWv"
    "Z7N9cRB8nAA+dIEBAIiAvwPgJ04kro1Vq/Mv66XtrCgVi9osLEx1K/V57+HD6a5Dh8B9fSDH"
    "ga1WsXr7Niq3btVrUfS1yue/HH34MNwV/HM+n1HN5vd7+/vHsmfPQu3bt60i8+wZli5fxr/l"
    "8nXT2fnJBwsLK8/XX/B4ZnhYqWbzyv5icaz34kXwnj2IrYUoBXge4HkQpRBbC85kkL1wAfuH"
    "hsZUs3llZnhYvRQclMvnsqnUidTp04DWoEwGnE6DEwmQ44AcB5xIgNNpUCYDaI3UqVPIplIn"
    "gnL53LbgmULB9YCp9LFjcHM5KM8D+z6o0QD+l9RogH0fyvPg5nLIHD8OD5iaKRTcTd6W/KhS"
    "OZJOJgc7R0ag4ngd8gqhAHSOjMArlQbrlcoRAL+8oJhFjiaLRWhmrN29ixYzfNdF6LqIXBdG"
    "a1itEWsNaA24LoQZ5s4duAC6hobAIkfbFDOQ78jlQPU6zNIS3jh/Hqz1jmolDFE7eRIqk4GX"
    "zYKBfDtYJGDfB9VqkNXVV7IBAOT+fYjrrs9DJGgDE/Ns+OABkExCBQHmL10CM4OMAVkLAkAb"
    "3hEAIgJZC7YW9OgRwnodzDy7xds8kF97et70iMrFfF6T1gAzEEWAMburBvBwcTH0RQbfX15+"
    "Cjw3vIOl0tMgiq7VVlbA9Tq4VgOvrYGDYNes1esIoujawVLpaZtiAPitu/sta8yt/o6OVI/a"
    "8X/aimVj8E+r1XCUeu/dWu3+tmAA+D2dHvetvdqtlDrgOEgQbQsMRDBnLWrGGM9xzozU6z88"
    "X28D29VV/LF370d+HH/bFOntIkKGCJuLFwJYEcGqCDqJKh7zZ+88efKj09WFHcFbtuTzOW61"
    "vghEPo1EDtiNdweASzSnib6Tjo6vum/eXCwUCm39dO/ePUxMTDizs7Oq0WjoMAy1tVbHceyK"
    "iJsFOs4wv32AqF8AzMXx3FWRP5cAn4hCZo6YOdRah8lkMhwYGDCTk5NGzc/PY21tDcYYiuOY"
    "RIQ30gGgKiL4xpi/AJSxvsIWAIjIAaBEJBYRx1rLxhhqtVqoVqu0rRXT09N048YNPH78mKrV"
    "KjWbTfi+TwDgeZ4kEgn09vZKX1+fjI6OYnx8vA3yHxWIwp50Lj49AAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
auinotebook_preview = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0"
    "RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAJXSURBVHjahFJRSBNxGP/d/+52"
    "W66ildPKJB9EMSwjFSNoUkS+GYg9pi9R9tJeopcgC3yKYvRUMHA+VBJUmpQPQSySKINqEGSB"
    "Np3aNjs3N8+7285d/7sxa9yw3/G777v/932/+76PP6PrOgw8D876dYImWJAEZPpW8l89nYea"
    "i8KGgMHRYPitvgkCw0G9qaNXD4x80Qs1BknRnzaBEfX1e+G758PQaEgvnP8VULA5lCS8/T7T"
    "NUQK4ApO4j/1l3s6N/zA8MiGTxiGgUGowGwkhqkfc5Bl1SKwlM6i90y75dzsoKX9fNPLF2Mt"
    "sZVGuMt3YPDpK7jsDnj7uiEIfH6ClAjF5rAKHD1xcW99a927C5e6hP3luwCGwONpRjwm4tqA"
    "H7du9pmJDG9HrsSeSE3dvmdnz512tFZVQaGjaCyBjedRubscxzva8PrNJzNR0xmsKsQq4KzY"
    "fqDW7UY8o4KjxRzLmpYlBLUNNZj48BVRMQlWA7I5yTqCvcyuq+s0qmkQiC1/QeiTo1ajNpWS"
    "oMoMVJVyXbZ2sDj9S5sMh2l7CjJUJGswq0HNZBCNLmEhPA0xsQpJUSHJJUZILCbuxuZF7fv8"
    "ApbTaaysrSEpSVgURdy//RDJxAp2RvzgMgkQzbpEziVEbgQfBeuXPY1dqcMS4W08cnIWY0Pj"
    "iIXjuNI2A0dsDmXyT3yUTtESZ5EAU3CuDvhD7ydDB1mWg6zQWelSj2ydwbE9v1Fd4TQZmHLj"
    "yTfBzP88PsgUCZTCne4qFycID7Zt4TuqK50TFaTmZMP1x5l/c/4IMABbKBvEcRELXgAAAABJ"
    "RU5ErkJggg==")

#----------------------------------------------------------------------
whidbey_down = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACsAAAAeCAMAAACCNBfsAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAaHWVZ3egZ3e1cYCncYa0dpC4cYXGcpDBc5fWd6Dld6Pwi5OzgJbUkJjQkqHC"
    "hafggqfwh7Dwk6Xgl7fwoKjWp7fXsbbWoLfnoLjwpMLwscHnsMfxtdD0wMHg5eTo5/D49/f3"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAverH2wAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAF4SURBVDhPbZTpYoIwEITRGqAQ1ChqOFrx/R8y3SObq8yvsHwZhglaOdH7HZbJIp1W"
    "YW7t7w68LOcwDaxd5+lhC3q18zwOMhTWIjtZ+3wGfFmWFYZjgJl9vWC/1x30AI2zzExzIcqz"
    "a2RxC2Ak2n4zJmEx1TgaY8R7AtHsdgMS1IivJRZHyN5lA6PMEgwZ2JVYs23bxwuWG3PGdF3X"
    "ImvtBO/KqAl38ytgO+WqMz1SDDz7KXaCbatU5YYARt+SbUHg61zT9/iMHsQZKHBI9A1S6njk"
    "fpuCRTjmJVQBymfxlfuCc5IX0cMhnhvCMYO8KCdCV0L9GbMz8Fhqous1ugbWw/32k2oDtFUn"
    "do2sz1ywqWvCElz6pq4pS3CRVxooMvjqsI2+v5LwXCVrljfrGclhqH2v5e+Nr6VnYltgBct7"
    "iDDExm+grvm0ouL/QwrjN1CHXvczYAz0xF5Pp9w168zfAhjeH9gSle8hnWutldL6H7rHOq2P"
    "agd1f/M7VhKuYPh3AAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
whidbey_down_single = whidbey_down

#----------------------------------------------------------------------
whidbey_down_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACsAAAAeCAMAAACCNBfsAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAECBXFC9vECiQBS2oIDKMIDigC0CVJUqQIkewJFKlJlayMEiwMlSiK2G0JFTR"
    "LmnSKGHmKHDoInDwMGjgNnDgNXLwSFeKQFizR2OkUGagcHiYZ3egcHilUHjRQXLwR4DwU4Pw"
    "YIfTcYXGcIjVc5fWZpHxcJj3d6PwgJbUkJjAkJjQkqHChafggqfwh7Dgh7Dwl7fwoKjAqLDI"
    "sLDIl8D4pMLw4Of35/D4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAQS37pgAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAGeSURBVDhPfdOLUsIwEAVQCCixFSggVfBFQWpVjKJo+f8fi3ezSZq2jDsDhHB62Wyh"
    "o319Vctg9V2tO34p5H0bHw5D4Xe9FULK5bKhb6UcDs/cprNdMYiprhee30khaStx2NpudwCb"
    "JHG8WAhbEkU0cZgtUge0iYrjCEUuilheOWysS2U9GpluGJJ1mKyg1LHZn6NYNNYUCWuozSjr"
    "FVxnLGQUjZPJlLJKCk7piar0Nk2zS90RAhINVDZN5yUeNZuhbjq6BzmZomYoICr/Yr5mtcry"
    "fL2mfnvjSd2anvkSsqBZUazN2XS/YVNLrc2Qut3yHAj/10OWFwVRtrpPvZo5cL+28A7fnxfv"
    "G6Ps74GwsfXCsXKkMnWWko39DKukAbjUygKfskFqYLnnKvcHdQT9sA0EPdgD1ts9Vr2G/fpp"
    "pDMeAg3gWe2fgn9V9d+0yW5edCylQurnwJejZ/7VPJpZ7V+C1PBsFrPFXAul6rSRi2S2uFmq"
    "kdrK1frcWOq1kXrC6osHulnq963Wa3Nm9kOySrVpq1/yr5vNbtdK1foPGIxy6qmqIg0AAAAA"
    "SUVORK5CYII=")

#----------------------------------------------------------------------
whidbey_down_focus_single = whidbey_down_focus

#----------------------------------------------------------------------
whidbey_dock_pane = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAF0AAABdCAMAAADwr5rxAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAaHWVcHiYZ3egZ3e1cHilcYCncYa0dpC4ZobHcYXGcpDBc5fWcZjgd6Dld6Pw"
    "i5Ozl6e3q62xgIjQgpXEgJbUkJjAkJjQgJjggKDXkqHCk6TWhafggqfwh7Dwk6Xgk7Tkl7fw"
    "oKjAoKjWqLDIp7fXsLDIsbbWoLfnoLjwsLjjl8D4pMLwscHnsMfxtdD0wMHg6tTN4Njk5eTo"
    "4Of35/D48Ofh9/f3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAA1jVbdgAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAdFSURBVGhDtZpxe6I4EMbtbQVXrHJuaY8KWq/XW3Sr196u8v0/GTfzThICRIh9nssf"
    "u4rw42UyM5kJHVVXjDQah/EV51ejK05+SKMwjK/BX0Gfzu9ms2kY3PgL8qd/nc/vCB+GN/54"
    "b/p0sVjMaRA+9Mb70hku9GvUe9IBV3TC+9rejy5wTfdX70VneJ7LHRaLu7uIPNPL9j50hp+a"
    "w9NzPOhQfvrHHqeZn/phOmzeofvZfpA+zTFa2rNsFk2GPWeIruB5y+5En00mg1E7QNfw/CSP"
    "oEaZ51kWDavvpxu4phOWB+hJMqi+l17DFb0sBa+eJB3KOX30xLIFeAQXvKYTvtf2PfTVbrtd"
    "6xsonrKMoafhJAwu5/vL9NWO6Rp/iZ5OJsFlfI/2onh7oxvQYKOsaeALjTV944fK2DFn489o"
    "ryqmA69NDrtjWPSwZyHs9RlWr+h5Qzt9UdqzPvhATTBMn/Uu4QOxut9r24vFdzSUvUh+lk37"
    "6wMXfVNf8sF0mdrt9nGF8YbB3ppNl/WpK8eNHPTNxuCXHx/a9q+vZz3exZvW6+m5NPhi58B3"
    "6Yfj2zYRHcuSgOI5Bi0fDgeiT/nT8oxTi2K3U1dZz9ChH5gu+GXJ9HNRvP/dgoOfyEGox/Tn"
    "nVlo04kNm34DHPRfv7psxuujywqm4rBo41t0Vs4uvl4/PXHUNLj7/f6VRvte5RJTjxBo4Zv0"
    "A3sDxw2d+EeTcnzd4qnIdR43zZ/EbSUjNfEN+oHppFsiEZOmxn5/ZJOBvt1uNivrNyvk2nib"
    "fmA6W0W0Z6FGkL0sNvLYt0L/aKeLtnqLTvCD2FzRNR53VelSZ8l1IfhfdqqDbRaWcWo6nWZs"
    "zrk1SZLVvww40oBeZTG9oDwbOm6pDy8svKHzA9Y2Z3oUgU5WOSIXdOjAv/Nv1hLJ5aZRr+lQ"
    "XhNYevSEZye6ZJo2PZNpd9ANXtFFuYtOM0p50UnP4Dm2VeQZavVCZ6cqudziCOL/szSKYkh7"
    "hReu62UJv/MyS8+HM2AZuUwNgwcdTlVSkasrrppOgSL0Rg2ME9l6uD8/cqmWd643T0Y90xEO"
    "azku48RzCu0vau1z0lNEhJu++Epkoks4dOhjPPaL+Hl+gf4upmlplzaIPGdUIbewXls7OTvo"
    "xktbdK6auNyAWz266fOHaoQ4ZKNpOl940vRXHQN99BU9XMkzqylo3+7u0nTEdkHkKzoKRUNH"
    "tccxeoEOwxs6XQqK0GdRNFoVKkqEDo+8lk4Syq2UsDWd2ubxKHtm5dzVid1Fe5bOjCx4kUt7"
    "mohf8QPCMg3ttGERjp4z1Yk27O5HV15r6MbuVF1S2xbHo+pRNblNf88SaN9sVIpyaSfDYhnU"
    "dEQK7A54ELO/f6VJqC2joknF4bmfPgadw4UtY+hmo4Vj9ZanWNtd07PsRfmDuYqTgc43nAei"
    "e8TEu4OuWh7kGcb70kViKfR7phdvVA808gw34thHkBzJ+EZHSquH5NfzN5p1ZU+S/kM3fZxE"
    "owBnCF2lWFAivcWi8jvUYydDBujAZ0JX7XD5Q0yTMT0EnVf6emHh9FC3anptgu3nc5ueppC2"
    "0nfT//OdqRcOA5HeoVsbFGZdFbxFJ3/7C3ShyTPoz/C4PwHnhau+rLmxVdcEwNunRdEYNcFK"
    "8Wv6jO4cBL8DfuC1xbqssbVi1TOMN6chHoSu1Ws6ByLZBfDzObEX8yRqNvd2LaZsLzt3k8lY"
    "1g8aDw+Ukc3gfatAzMJjapTnOdEb2yqNOtLgSdwkMHBWGEIxxmQS/iYTqvAyGSmN9rZEswZW"
    "eJkaC0Af4/ieBrPHY6kWWniCh+0NoVb9DjzbPLhZNhH07f4+CIK4heYbT0V7d0ui3XvcSvLk"
    "QEbXROPnz859zFGOLGptZhRDru2UTt9EeB3ISj31TQ784fBIRwVeVTQtrq2gbs93G0Vfvtg9"
    "3/Ft92KqdXWfI1cpVCspOOMnjg3QLr0aRwpOxuGOj+i7orD6JarnqVugEE2sfnXs2khx0CsD"
    "r6rv33U3w/3MZvNCQ/dP3EI+1c2pa5fGRbfa2e/SApohXbw6RmFk0a2rzMd+ujRclAI0XnYh"
    "pBRH1ujfhuil6yZX6LTEmlEnl158H91uFVVtr+t7ne0o9iKXSdSxHjpvLJieqLmXar5xaPfs"
    "Ll2mP8IMWqRzTy/PSTplzIvqe7Qndit3gc4581Paq4p23lHpYP+dH6K5lyoZSce1U3+vz0xb"
    "dMZLgcD/AB5aode9Qb+/S5VmtEsDUNMH334MxKqpcxw+4/HWbIAuNSbXgc3RLIo+4zNyjeBR"
    "ZdbjRKuFKec+F03qqrpCtuieb/uGLGNXyDbdR7mugXsezlUhn06D3iJED+2qvkcDpCpUvzdl"
    "nnTVnSg6vavxfT/spb1Wz9qpnPN7Q+mrXTsmF1I+78j0PHpq13jOLR7v966mV6jS0BX0vAJq"
    "OZ+3dlLP8UnDH+7nkUpRHMf/399CVFUcf7nu7zj+A8yummsi9EdGAAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
whidbey_dock_pane_bottom = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAF0AAABdCAMAAADwr5rxAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAECBXFC9vECiQBS2oIDKMIDigC0CVJUqQIkewJFKlJlayMEiwMlSiK2G0JFTR"
    "LmnSKGHmKHDoInDwMGjgNnDgNXLwSFeKQFizR2OkUGagaHWVcHiYZ3egZ3e1cHilUHjRQXLw"
    "cYCncYa0dpC4R4DwU4PwZobHYIfTcYXGcIjVcpDBc5fWZpHxcZjgcJj3d6Dld6Pwi5Ozl6e3"
    "q62xgIjQgpXEgJbUkJjAkJjQgJjggKDXkqHCk6TWhafggqfwh7Dgh7Dwk6Xgk7Tkl7fwoKjA"
    "oKjWqLDIp7fXsLDIsbbWoLfnoLjwsLjjl8D4pMLwscHnsMfxtdD0wMHg6tTN4Njk5eTo4Of3"
    "5/D48Ofh9/f3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAaHenigAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAejSURBVGhDpZkLe9o2FIYpTVeWrG3Srmy9stk0LTPJMKMhmYM9KOuSERqydAX8//+H"
    "dy6SLF+QRXeepwtg+9XnT+fotlqyRQRey+1vcX9S2+Lm08Bz3f42+C3ond5xt9txnRf2guzp"
    "b3u9Y8C77gt7vDW94/t+DwLwrjXelo5wpm+j3pJOcEEHvK33dnSGS7q9eis6wqOIW/D942MP"
    "MtPKexs6wlfZsMwcCzopX/2jx6prp76aTp4X6HbeV9I7EUVOexh2vXZ15lTRBTzK+Q70brtd"
    "WbUVdAmPVvwKIuIoCkOvWr2ZruCSDlgMog+HleqN9BQu6HHMePEmQdWYY6IPNS+IB3DGSzrg"
    "jd4b6KOr6XQsGxA84YyiB27bdTaP95vpoyukS/wmetBuO5vxBu2z2fU1NACBpowh6AvEGL7h"
    "S4WYmN3W12hPEqQTXlpOvlNodNcwERpzBtULepTRDl+E9tAEr1gTVNO7xim8olbnc+k9O34F"
    "IfwC+WHYMa8PyuiT9JHPSOeunU7PRhTXFJitYWeQ3joqaaiEPpko/ODzZ+n9xcVaxi1n03jc"
    "WccKP7sqwRfpi5vr6ZB1DGIAcuYoNH9YLIDewU+DNd06m11diae0dyjQF0hn/CBG+no2u73M"
    "wYk/5B9JPXV/VOiFPB3Y5Ol7ghN9uSyyES9/HSRkFZZFHp+jo3JM8fH4/ByrJsOdz+cXEPm2"
    "4gF1PZVADp+lLzAbsG7gxt+zlJuLKb0VpM7ZJHuJ05ZHpCw+Q18gHXRzJVKniZjPb9Ayok+n"
    "k8lIu6aVXB6v0xdIR1dYe+hKBPilsWkcez+TF/XhIq9eowN8wZ4LusRTq2K4lKPkeMb4pT7U"
    "kTe+Zk5Kh9uU5zi2DofD0b8IuIEgvcIxOaF8UHRqUv7sa3hFxxdMPUe65xEdXLmhsaBAJ/wt"
    "XtOmSFxuKvWSTspTAkr3zundgc4jTZ4ecreX0BVe0Fl5GR16FMbFUnpImaO7wu+Qqmc6JlWM"
    "yy2sIPwbBp7XJ2kXlIXjdFqi6zjNwvvRHeQMPyZC4YlOSRXDIleuuFI6FArTM2tguhHdo/bx"
    "lWMxveN6c6XUI53KYcy/c6ywT0n7RzH3ldIDqohyuv8WyEDncijQW/TaHznPow30W7Ymp523"
    "QZA5tYTGFtSra4dkJ7rK0hwdV0243KC0Oiun906TGtUhmibp+OBK0i9kDZjoI3i5GHtWUmj7"
    "dnwcBDX0hSpf0GmhqOi02sMa3UAn4xUdHiUK07ueVxvNRJUwnTJyWzpIiKe8hE3psG1u1cIP"
    "qBx3dew7aw+DrpJFWVSmPRhyXuELkjMZ7XBg4dY+hGInmvHdji6yVtGV77C6hG1bv19LzsQm"
    "N5vv4ZC0TyZiiCrTDsbSNCjpVCnkO8GdPub7W+iE1BlRTaIO12Z6i+hYLuiMoquDFqzV19jF"
    "0ndJD8OPIh/UUzgYyPEGxwHvhGritoQutjw0ziDels4SY6afIH12DeuBzDiDG3E6R+AxEvGZ"
    "HSnMHjy+rt9Drws/QfonuenDQdRz6A6miyGWKJ48YhHjO6mnkwwOohM+ZLrYDsef2JoQ6S7R"
    "caZPJxYcHtKtmpybyPteT6cHAUkbydbkX2wZ9sKuw9ILdO2AQs2rjNfokG9/EZ1p/A7yM2Xc"
    "nwTHiSt9LHuwla4JCK/f5nktWhOMBD+ld6Flx/mN4AucW7THMkcr2noG8eo2qgemS/WSjoUI"
    "vhB8vR7qk/nQy27u9bWY8J5P7trtFs8fEKenMCKrwHMrh23B6CjlUQT0zLFKZh2p8CCu7Sg4"
    "KnRJMUW77b7kDhV47owAIn8skV0DCzx3jQaAj/3+CQSyWy1eLeTwAHfzB0K59Tvh0XPnxSCL"
    "gG8nJ47j9HNobLjD2otHEvm9x2sePLGQadcE8UVZrLf3hdIVKwu2Nl2oobLjlMK+CfCykIX6"
    "ekPvAdHC5eWDOtNp3wTdUnYUVNzzvfa8V6+0PV+93mg8f56z6WWj8eDBPaSLLaXbbZccgBbp"
    "ScsTcDBnvb5Tv7+H8cMz1cCrRr2BP+3f0/arrbKDlBJ6ouBJ8vedO/eBvr+/t/fsWV1EAwLh"
    "+/v3ztPNadkpTRld286C8vuIgdjb24VA8u4us78HvHZvyUczXSpn/sOH5BGjkV6JN9LrqPwR"
    "kZ5CMDP32XjKYaITXOhcZkNryTOYY6ADe3f30f7BY9S7RPFN/A/GUtGbzcPvNuM30+t1YIMt"
    "Kb3ZfLqEfxn6IcSPG/EG7XeBffAY4gkEYDHUH3qVN28Oj47evfsa7Uly99FBlk7ecyNIB/ih"
    "7xvg5lO3nRy9KeCCfgjKu8ZjN3O+7xidOTzy/f91preDnlPOsO8i4Bu4cuR/zZme3kuIJ3o2"
    "oEOPQHnFgWH1/wEFPNFx6lexxGSpVC7XkaaxaKeUbqPchp6Q96n2TxArgP9RZYtaA5vHUcRn"
    "bV9ZeJ6usM10Vt98wgmDyfJrNP2l4hm6XDF7CATiZTZih0aRFdySjup5/PqZMlEe5Vbpt9Oe"
    "AJ7pkOewhSie+Ja3Y0tPdpgOBRrZKrf1HZV9Q3T03Fb5NvTk25+wQKPrsyq30+vWzsAjSI+i"
    "LeC2OcNyTjudc219VP0O/wGW4JFYg7jH7QAAAABJRU5ErkJggg==")

#----------------------------------------------------------------------
whidbey_dock_pane_center = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAF0AAABdCAMAAADwr5rxAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAGDeAJUqQIEOkIkewJFKlJlayMlSiMle1K2G0LmnSNnDgR2OkQ2O1UGagUHCo"
    "VXSzaHWVZ3egZ3e1cHilQ2TAQHDAQnLSVnfFQXfgcYCncYa0dpC4VYTTRIDjVYbgZobHYIfT"
    "ZpPXcYXGcpDBc5fWYIjgYZHgcZjgd6Dld6Pwi5Ozq62xgIjQgJbUkJjAkJjQgJjggKDXkqHC"
    "k6TWlrDXhafggqfwh7Dwk6Xgk7Tkl7fwoKjWqLDIp7fXsLDIsbbWoLfnoLjwsLjjpMLwscHn"
    "sMfxtdD0wMHg6tTN4Njk5eTo4Of35/D48Ofh9/f3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAXehG6QAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAdqSURBVGhDtZoNW9pIEMc5emrB651VUDRUpEkqb5d6SBOUXq9Q8dprke//aXLzsrvZ"
    "hGWz+NzN87RCzP74M5mZzGyspDvYOGh4wx3OTys7nPx+HHjecBf8DnS/3wtD37t47S7InX7V"
    "7/cA73mv3fHOdH8wGPTBAO85413pCGf6Luod6QQXdMC7+t6NznBJd1fvREd4kvAnDAa9XgCR"
    "6eR7FzrCV3lzjBwHOilf/a3bKnRTX04nn2/Q3XxfSvcTsoL2OA6DdnnklNEFPCn4Hehhu12a"
    "tSV0CU9W/BWErZMkjoNy9Xa6gks6YNGIHkWl6q30DC7o6zXjxTcZl9UcGz3SfEE8gDNe0gFv"
    "9b2FPlnMZlP5AYInPKPoY6/tXWyv99vpkwXSJX4bfdxuX2zHW7TP5w8P8AFg6JQpGL0Bm8I7"
    "/FIxBmbYeI72NEU64aXLye9kGt2z3AitMYPqBT3JaYc3Qntsg5f0BOX00HoLL8nVL1+k79nj"
    "CzDhL5Afx769PzDR77Il35DOl3Y2u5mQPZBhtMb+KDt1YvggA/3uTuFH375J33/69CTtK0fT"
    "dOo/rRV+vjDgN+nLx4dZxDpGawBy5Cg0v1guge7jq9ETnTqfLxZilfYdNuhLpDN+tEb603z+"
    "9a8CnPgRHyT1dPmTjatQpAObfPo7wYn+48cmG/Hy6CglV2FaFPEFOirHEJ9Ob28xazRuFIYt"
    "sjjOf9p6RJeeUqCAz9OXGA2YN3DiHzrjw4du66zT6VyCNZvNdzk+hy1XpDw+R18iHXRzJtJF"
    "Y4uvrrpdgBP98vJds9vNfqmlXBGv05dIR6+w9tiThLet62tkn50h+xzs8GVL/lIvF0X1Gh3g"
    "S/a5oEt8+PYtws/AFP2wxfgfeqkj3ww052R0OE35HGtrFEWTfxBwDUZ6NauDnSq6LNNM1/CK"
    "jl8w8znSg4DoEcDZG0U64b9indBukdhuKvWSTsqVV+iOH9zSBe0C3Eiv/3yFJxjoCi/orNxE"
    "73YBbqbXiS5vAJn+TD3TMajW2G5hBuHPeBwEQ1wbtjrklfuCoePrtVDgsV3QujWFJzoF1Rqa"
    "XNlxafSOoOO1zeye6TWkf8KvvBa3d+w3V8r3SKd0mPJxthVeU9Q+adno9Rco3kwfXAEZ6JwO"
    "G/QG6nKhg+cL2nkMgsippFRbUK+uHYKd6G/edDoUiPcmz9TrB3jSjZnef59WqLag0yQd262V"
    "pLfedC5L6RMImzXEPK1EjTS+9XrjcQX9Qpkv6NQoKnqzc8lZZNOu6LBUo4dBUJnMRV1hOkXk"
    "rnRIqPWMW9iMDmNzoxLfo3Kc6tjvrD0eh1Qhm5BI27XX9qt06YnOSzW673mV+1hMojm/P4+u"
    "/A7dJYxtw2ElvRFDbj7e44i0d09F9TL5vba/f6Rrp0yhq0rwiyHG+xVc4swzIpugijnQq0TH"
    "dEHPKLraaMFcPcEAkn6X9Dj+CAs/NM/PMedVzMhyg3Vg/6A6xhpsoIuRh+oM4rfSD/P0Q3qP"
    "dQbolEzzB+gHcnUGB3HaR+AaifjcRAp3j3iCS3svqV5J7Z37jL63R9IFXZRYogRyi0XUd1JP"
    "OxlsRCc8weuQTmwd/gGH9gUd7/SyjcCF+vaQvDeR7/t9nT4mZZNXzC8asKsBnrBB1zYo1H2V"
    "8RodEvnPrfRaDei/ERwb8GxZfmMr6wkIr58WBA3qCU5Pi7qJXf2V4Eu8X2rLclsrWj+DeHUa"
    "5QPTnwr0GhjQCQ4tQ+bzJImC/HCv92LC97xz1243qMKjvXpVq0n9NchQpRx/6SvlRM9tq+T6"
    "SIUPcfdFwZ8mk9oLVMxksJ+OKEnZfAywOB6DFbcl8j2wwPOlydbDq/DgYG8P/6Funa3wAPeK"
    "G0KF/p3w6POL16McHfQfHR1Uq9W9XwIKRM2GpB7gG1sSxdnjhIsnJjJNTWDfvxdo2lG8Y8Bo"
    "E0IOmbZTNuYmwMtEFuphbjLgl8sbOMrwNPXMG1mbM99JEBwf6zPf48Pi47zAf8QuJUK6GCm9"
    "sG3YAN2kp41AwME5OPEBfTGfa/Mq9PmPcBAmQ21ebZg2Ugz0VMHT9PNn3odAgyn57iPYjBta"
    "bKz922w4Ne3SmOjaOPuZR0BlPMWLY5BGGl1bpV7a6TxwQXmQeN6F4FacqoZ9G8JKl0Mu0++0"
    "75AVFyveRtdHRdHby/5eVjvIvcDkEnHMQseNBTUT5fdS1TtMbcvu0nb6TW6SM+7pJQlIh4K+"
    "Vb1Fe6SPclvoAdiztKcp7LxTp0P77+jp/F4qVySZ10b91pjxC3TEczeF/xHc01Jv8wPs8c5d"
    "mtLOA0BGL336UZKrqs8xxIzDU7MSOveY2AfmLd8UPSdmeA3jqcvMbAV3C9XOPS+bxKqsQ9bo"
    "jk/7yjyjd8g63UW57IEtX87UIa9WpdHCRAftor+nAYhbl//0OZ+cTgQdntW4Ph920p6pR+XQ"
    "zrk9oXT0jApMbKRcnpHJ6+ioXcY91haH53s701Pq0mgOtTwCKgSfs3ZQj/kJ5g53i0ihaDgc"
    "/n9/C5Gmw+Hxbn/H8S+cD8xcYY4GnAAAAABJRU5ErkJggg==")

#----------------------------------------------------------------------
whidbey_dock_pane_left = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAF0AAABdCAMAAADwr5rxAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAECBXFC9vECiQBS2oIDKMIDigC0CVJUqQIkewJFKlJlayMEiwMlSiK2G0JFTR"
    "LmnSKGHmKHDoInDwMGjgNnDgNXLwSFeKQFizR2OkUGagaHWVcHiYZ3egZ3e1cHilUHjRQXLw"
    "cYCncYa0dpC4R4DwU4PwZobHYIfTcYXGcIjVcpDBc5fWZpHxcZjgcJj3d6Dld6Pwi5Ozl6e3"
    "q62xgIjQgpXEgJbUkJjAkJjQgKDXkqHCk6TWhafggqfwh7Dgh7Dwk6Xgk7Tkl7fwoKjAoKjW"
    "qLDIp7fXsLDIsbbWoLfnoLjwsLjjl8D4pMLwscHnsMfxtdD0wMHg6tTN4Njk5eTo4Of35/D4"
    "8Ofh9/f3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAA+wCLtAAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAeDSURBVGhDtZr/f9JGGMdprZPJnHSKm9OKI4DG0K5kWAptGIw5FGqpdQL5//+Q7Ply"
    "d7kkR3L4ms8PWmjyzifP3T33PM+1FO1gQ6/u+DtcH5V2uPh86DmOvwt+B7p7etLpuE7jmb0g"
    "e/qr09MTwDvOM3u8Nd3tdrunYIB3rPG2dIQzfRf1lnSCCzrgbX1vR2e4pNurt6IjfDTiJ3S7"
    "JycezEwr39vQEb5OmuXMsaCT8vUn3dYdO/XFdPJ5hm7n+0K6OyJLaQ+CjtcsnjlFdAEfpfwO"
    "9E6zWbhqC+gSPlrzKwgLR6Mg8IrV59MVXNIBi0b0fr9QfS49hgt6GDJevMmwKObk0fuaL4gH"
    "cMZLOuBzfZ9Dv1xMp2P5AMETnlH0odN0Gtvj/Xb65QLpEr+NPmw2G9vxOdrn8+treAAYOmUM"
    "Rh/AxvAJXyrAidmpf432KEI64aXLye9kGt3J2Qhz5wyqF/RRQjt8ENqDPHhBTlBM7+Ru4QVr"
    "9epK+p49vgAT/gL5QeDm5wcm+n58y2ek89BOp4NLsmsynK2B24svvTQ8yEC/s6/wvc+fpe9n"
    "s420W55N47G7CRV+vjDgs/Q7D+/fE/heCECeOQrNPyyXQHfxp96GNM/ni0U/oz5DP3iIdML3"
    "QqRv5vPb9yk48fv8Jamn4R9lRiFNPzg8rCJ+j+BEX62ybMTLb3sRuQqXRRqfogP88BDo9/b2"
    "LnDVJLhXV1czsPSzwh4NPS2BFD5JP3j0E1j1YeUeqE9SbmZTmikwdQaT5K942nJESuIT9INH"
    "TK9WAL+n46+ubm54HqJNJpcaX1tyabxOBzjR0fWofl8ilkudTXHs7Vz+Ug8XafUaHeFEl+ol"
    "frlcgmy5pjhKjueMX+mhjnzT1ZwT0w8eVcHwCfg/eqdc/hsBN2BMVNGeMH8pOj1Q7jNdDa/o"
    "oDxDr/+LMw/gpDtDJ/wt/k7bIjHdVOolHd2SpFcrv9K7A50jTZoe0FrdGOgKL+jkcyMdRhTi"
    "opEe0MzRvcLvEKtnOsJXutXQ7yRtRrNwHG9LIaVltO9xLCDPhPw1m8ITnZSv4M1XT9BqtRXS"
    "f8ZbYaEwPZEDfxJ0ws/QaaHY3jHfXCv1SP+OmCl65elTvPWd2PuM9KGznd59BWSgf0/wtPYK"
    "wYHO+/YW+i27JqWdyyCYOaXo5csamK79SW1V/fE+rVRc/DRXUnTMmjDduMCLBmb66XlUOm+3"
    "k3T0vaLPbOiX8HIhjizmgOh3Kt9OTobDknt8nKCvVjiq1Qprp2wvRzs5XtEBr9E7npem07Tc"
    "lQ4SwimnsDEdyuZ66WLUPW63flN+B+3o90qZtctlbvL7sO/58gXJMwnt0LBwgD46Pm614lHd"
    "ge6l6MrvkF1C2eb7pWhwDeqBv/qorSapfTIRIcqkHRxL2yAODmqnzJ5GleANH+f7ACLDcbtt"
    "pG/y6XWi44JL0FWjBddqf4r4BL1WuV8+Eo5XmjAYyHiDUcY7q+Mltwa6KHkozvTRNxl62Uhn"
    "B4RMP8NL5teQDyTiDBbi1EfgGAnqf1+vtSBZk47fvA107R9l0RcMPc9rULBgOsVIESk92WIR"
    "8R0KMJ45HCNrSC8/x3sDpotyOPzIrgmQ7hAd9lxtY8HwEJdqcm96MwXntFtM5m21Un5PvkE2"
    "1DD0FPyfDdgsPUPXGhRqX33TpXmp6LhrM13ydDrNONrTl7hxyX01qVz6HX3v/onqdfqDB/8Q"
    "XvBjegdmeqPxB8GXuLdo9ERrRctnoFWi06uVB/uYEyj1ko4LEfxC8M2mr2/mfS9Z3Ou5mBvg"
    "qmo9Qbc/flyt3uX7N5vz875m2LdqsFvQXKV8NAJ6oq2SyCNJfatFdA2OCh1STNZsOs95QAWe"
    "B2YIlm5LJHNgUk/0JBwwvn8Ghux6nSJjGg9wJ90QSuXvLvqG4b0kAj6dnTUaDT+Fxge7rD3b"
    "kkjXHp0O8GHW38Xag/lfvmSeo77FlQWlTQfWkKmdkqmbmE5RQqiHusmAXy4H8C3DowiGxdQK"
    "ytZ8r1+320dcvXHNd3O9eKeydfGcGywJIFcScMQ3DQ1QQ736uv2DLA1B/Rzpi/lcq5cgn4dq"
    "AZZoX6tX66ZGioEe/RLXnR8+yGoG65nJ5B2YrJ+whLyILzV1aUz0+I7oA1RLXCuxcRUvvoNl"
    "pNG1u9SP+XQuuCAESDp3ITiZp+CS34bIpcsil+mwxSqLg0suPo+ul4q08bCJ9J2kQ0bnmVwi"
    "vsuhY2NBJkupXqrqrGLCmNNd2k4fkBtk5Db29FA7Rsyt6nO0w1Ye2xY6xsyv0g67FZ90cP+d"
    "8oxEL5XTuSOxro36c+eMm6IjnhME/IfgTh68oKf3IqmdC4CYXnj6UbBWER97Rg0Day/qYOs5"
    "gXngST08wXB2UKi8mB4xvps+96C0oPDMqcAz8ELs+/SJ0P90ZsP4DN1GuYVnhPpvdlYm1FMB"
    "LTJUu5MyO+3S94IOZzW258PFo0ozVc571A7pnN0Jpa12oR5Phq3OyOTasdQu8RhbLM73dqZH"
    "L1A3VQU5R0CpBW+tHdTj+gSzh+/0txC+73+7v4WIIt8/2u3vOP4D32mBB1S/lsMAAAAASUVO"
    "RK5CYII=")

#----------------------------------------------------------------------
whidbey_dock_pane_right = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAF0AAABdCAMAAADwr5rxAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAECBXFC9vECiQBS2oIDKMIDigC0CVJUqQIkewJFKlJlayMEiwMlSiK2G0JFTR"
    "LmnSKGHmKHDoInDwMGjgNnDgNXLwSFeKQFizR2OkUGagaHWVcHiYZ3egZ3e1cHilUHjRQXLw"
    "cYCncYa0dpC4R4DwU4PwZobHYIfTcYXGcIjVcpDBc5fWZpHxcZjgcJj3d6Dld6Pwi5Ozl6e3"
    "q62xgIjQgpXEgJbUkJjAkJjQgJjggKDXkqHCk6TWhafggqfwh7Dgh7Dwk6Xgk7Tkl7fwoKjA"
    "oKjWqLDIp7fXsLDIsbbWoLfnoLjwsLjjl8D4pMLwscHnsMfxtdD0wMHg6tTN4Njk5eTo4Of3"
    "5/D48Ofh9/f3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAaHenigAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAe+SURBVGhDtZr/W9pWFMYtW1en67RzunWdpUvQlgWdMCoyJFkotbaRCrMryP//f2Tn"
    "yz25N19ILn2enV8Qkn7y5s2555570414jRh4dbezxvnxxhonXww81+2sg1+D3jw7bbWarvPM"
    "XpA9/eXZ2SngXfeZPd6a3my322cQgHet8bZ0hDN9HfWWdIIrOuBtvbejM1zo9uqt6AgPAr5C"
    "u3166kFmWnlvQ0f4Ih2WmWNBJ+WLf8xYtOzUV9PJ8xzdzvtKejOgyGj3/ZbXqM6cKrqCBxnf"
    "gd5qNCpHbQVd4MGCb0HFMgh836tWX05P4EIHLAbRe71K9aV0DVf05ZLx6k4GVTWnjN4zvCAe"
    "wBkvdMCXel9CH96Mx6FcQPGUMwl94DZcZ3W9X00f3iBd8Kvog0bDWY0v0R5Ft7dwAQg0JYSg"
    "LxAhfMOb8jExW/Uv0R7HSCe8WE6+Uxh0t2QiLM0ZVK/oQUo7fFHa/TJ4RU9QTW+VTuEVY3Uy"
    "Ee/Z8RsI5RfI9/1meX9QRB/pf/IJ6fxox+P+kOKWArPVb3b1qT8XXKiAPhol+O6nT+L99fW9"
    "xB1nUxg275cJ/rvjV3l8nj6d3Y57fGJ3CUDOnATNf0ynQG/iX917OjU6Pn6Vx+foU6QzvrtE"
    "+n0U3b3PwInf4x9JfbR/cHzSzj3iLB3Y5OlrghN9Ps+zES+/duO7h/tMz+IzdFSOKR6Gl5c4"
    "alLcyWRyDZG91rL7cBfjGPiZHErTp5gNOG5grPyVpsyux3RXkDr9UfoQw3ePgJ5J0RR9inTQ"
    "zSORHpqKyWSGlhF9PB6NhsYxgP9IdMSn1Zv0KdLRFdbuu4IAvww21bHXkRxEONEPjtCblHqD"
    "DvApe67ogqerqnIpVTKMGD+vPd5mY3b3ITLqNR3yOvEca2uv1xv+i4AZBOlVjsmE8gYPvnv8"
    "eFvhmX7S/ls/2oSO4097jnTPIzq4MqNakKMT/v2mST86Anz7dxm1QiflmoDSvUu6d6BzpcnS"
    "fXrsSGfxqB28B/xY8IrOyovo8EShLhbSfcqcXzc3t5lMgeqDQJUSpmMdX2K7hSMIP/2B53VI"
    "+jVlYainJTqO0yzcH51RQ/pcx2LxR6AqFdGpDi6hyZWOS9OhAjM91QPTiege0jc3t7b350r7"
    "PAw/zsEcVo90moFC7EM1HZ4pab9Sc18hfUAj4jBHh7xk9UDnCp6j1+m2rzjPgxX0O7EmpR1H"
    "VRD0kU61BfsrUzskO9GTLM3QsWvCdoPSCo1P0Skvg9t+vEHjEEe+0PEfLoR+LWOgmn5wMIeU"
    "Ad9D+OTMudxAX2jkKzo1igmduj0coyvoZDxrBzJgFf03rGhAH0ZqlDCdMnJd+hbSKSWFjvl/"
    "ctLc8N+gclzVse+s3R+0SNYQnyi1v+mMJN8HPc6rGtH3Te1Cf+OrlWjKdzu6ytra1ve75Ln2"
    "nSra8cVG3FeL3HS++z3SPhqVaG95Hk2DRFeFQPmO9BcvMN9fwgpdO0M+LGQc3pfT60R/ipVA"
    "j9VwvkcV51seq89x70J8F7rvXynj+Rflu9QbrAPeOY2Jpzk6wb9RlYDwtnSeO5ZMP0f6T1CA"
    "M9r39va+ljrD6lMrUpg9uL7ev4anrrV/lEUfFlHPoTOwvJs1cj4XuHTYpJ52MjiITnif6Wo5"
    "vPzI1vhId4n+i8yrwNzDWQQ/STn7jkHen52Z9MGApA3lavKJV4a1sOuw9CK6guvVAeMNOuTb"
    "O6Izje9B/sb9K+ctHq4n86rWLnBj7UF4TW8BvU49wVDxNR2POc6fePAtzHvKmoSewM2VDeIT"
    "OqzlXJfpol7ocAi2ZxgOQ6n26BHyf6AwPDd9N7znnbtGo87zB8TFBVTkJHDfymFbEvzO7pMn"
    "iq6V66dqPlqEw/5FAgdGzyXFFI2G+ys/UI4HD7T6JFvSOZPKHN5zNADwZ6dzDoHsep27BY1H"
    "c3bIG0lFlYmZ/p0eLXruPOumEfDt/NxxnE4GjRdG9Vs7TyBMW4x8l97sOTrAOxe0aoL4/Dl3"
    "neRXHFmwtHlQAzpYn4HnV8OAh4Sg3UalHtZNBfjptA+/MjyOIXO2dnay8IK19nPPOzzkW+E1"
    "3+z25irp1tV1ZtilQK+k4IAH+ldiQPJZsF6tewpO6iOk30SRsV6Cfh5WCzCf94z1aq2Whxfu"
    "EyTwOP7wQVYzuJ4Zja4gZP0Es1bzUsut5ZRn8j1//AMvAZPgVbz6DWZ7g14At9rjgBIgeN6F"
    "4Facqkb5NoTF/gxCaKVn3INeKZTiy+jG7gxOHjKlqvadpMPY84osKR6r5plRRGsONTVJ9eSJ"
    "Sr7h0C7ZXVqtvU9GCKZwTw+1Y8Vcqb7EmV6C1mrT+5FBgDXzi7THMey8U6dD++94E+m9VK5I"
    "Mq4L9ZfmTDNDR7z2neCuMfTyFyjfdeMuLdFOm9fJU7V481Sxp5f0Oen9d/pm8dasgi59Tvad"
    "Da6ZLN7bVNEVnrpMHQuAyyxQMpgs3q/qDtmgWymvrJHSiGS1Wym3ouc75MXCwvNst7TSQcmc"
    "dlt1qHZvyuy0y+oE8h7p8K7G9v1wZc7oNgpHFdE9oJdlij5mSZe8x9pS+ZZpfbrCY22xeL8n"
    "fFvt4D3qplVBySugjGH2dMRDrgDdznPrjFS4Tqfz//1fiDjudA7X+38c/wE5II6oZulXWgAA"
    "AABJRU5ErkJggg==")

#----------------------------------------------------------------------
whidbey_dock_pane_top = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAF0AAABdCAMAAADwr5rxAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAECBXFC9vECiQBS2oIDKMIDigC0CVJUqQIkewJFKlJlayMEiwMlSiK2G0JFTR"
    "LmnSKGHmKHDoInDwMGjgNnDgNXLwSFeKQFizR2OkUGagaHWVcHiYZ3egZ3e1cHilUHjRQXLw"
    "cYCncYa0dpC4R4DwU4PwZobHYIfTcYXGcIjVcpDBc5fWZpHxcZjgcJj3d6Dld6Pwi5Ozl6e3"
    "q62xgIjQgpXEgJbUkJjAkJjQgJjggKDXkqHCk6TWhafggqfwh7Dgh7Dwk6Xgk7Tkl7fwoKjA"
    "oKjWqLDIp7fXsLDIsbbWoLfnoLjwsLjjl8D4pMLwscHnsMfxtdD0wMHg6tTN4Njk5eTo4Of3"
    "5/D48Ofh9/f3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAaHenigAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAe1SURBVGhDpZkNexJHEMcxrTVNao3G0PoSaXmJ4l1soBhCCUdBmkaPCDFWCN//e1z/"
    "M7O7t/fC3aHzPMqFu/3t/2ZnZmeTUrCBnZ83m2cbPB+UNni4NxweHx/9tsGIDei92bBF9B+L"
    "44vTu6T8AFb+oTC+ML07gfIjppe/L4ovSofy1nGjIfT9oviC9O6kBZ83flf0ovhi9NccLY2y"
    "sv39gvhC9NeT4R/HR5q+Xwa9GL4IvQmvLBcRK4gvQG/+DZcvP8JG2hYF1efTSflxY2HIdLHY"
    "gxVwTi696VGCptLz8Xl0Ud4oR90u2vOXNodOyjlYFjoa+VPT89Rn010ol+xXdP1Bq/oI9jA7"
    "azPprguX23T4R7QbejY+i/6q1YJXpLYwlZ0foz/4LqOkZdBfvaJgaZQzPbP3IAu/nv7rEYxi"
    "g+xgIfVrgX+44FV99HAP7J2dra216jO0/3RULkfpPAP9p+lg37u3Hp65r/oHByE9GvDy/e4u"
    "2Bnw7F3bD+kQbGbS1w/y4Dk9wd29vcePtc5dtp9/1rOQ8jt3MjfBnFwlPLtgd2dnG7YD291V"
    "88Et2fBU7eNQz2fgiU3kLWVPnhBflHfCRwcpb5GifTw2+M5n4Mkf21vbh7fanvzCPoLy25XB"
    "+9MUfJI+v55NuqKjswLw7v3729vPDVounj6ld6Grzi0/6vvTqRplvUOCPie64Dsrot9u3X//"
    "PgbHj5VthgPP8BkGDZtx58TpYNODo7cMZ/ri3yQb3/yjv+0EN77QE/gYnZTjuclodH4OONON"
    "XV1dXcLic606V7PZdDoaDRP4KH0O4TPaOPHgX1HK9eWE32oy6fXG0VtXRJ/QmDg+Qp8THbqZ"
    "PmxGZF+Ty5g+mYzHA+see4X8ksTb9DnRySui3atpBPxlsQk1euvrm+JzQ4/43qIDPhefK7rG"
    "86x4d8tGI1/wC7CnfEtpH7asyAnpeMz4fOh5XrfbHfxHgGsY61Ue05h3hs7TGrqFN3R6wdDn"
    "RHccpsMr1ywuQWf8Dd3TZPpstUK8prPykEDSnXN+d9Dl1eN0T5Y9hW7wii7K0+hY0ekauseR"
    "Y3tF3iFUL3Ra9tUSRhlEn17fcdos7ZIDYkQ3lNH9JSB4P36CPSPDlBk80zmoVp8+faJBZCEd"
    "iSJ03LVM0Rl/Sa+8kmQaLpmi8UTngB3J95qONWXtFyqYU+l9zoh0euslyKBLOiToFX7tC4nz"
    "4Rr6jbgmph3SW60TxH0p4Npi3klpR7Az3URpjL5iv7suh1UvnX5yFpQ4D8lp2jM0cKnplzoH"
    "sugDvNyKVlZTWiewN2/6/RL5hTNf0VcR+gB+4ThfQ2fHGzqGMkXoruOUBr7KEqFzRIbai9Eh"
    "YTXheLXorlurlLx3pByrENHu9V0ji5ciTXu/K3FFEtgzEe1us1YrvfOYbejivWJ0FbWGbvzu"
    "wmq1drsU9Jgd0iWbvC5rH49ViUrTDsfyNqjpJptaDK+2Kd5fYhFS6JLm2fQK0yldyDOG/obg"
    "z55xNgUvaIm131UlQAm+UPFgRlEl0MWGqoxzyjlxk0KvgS65KviidJG4Evop0f0Z+oFInXFE"
    "uaIz3qpxqJEw2ZnfYtXVakH6R1pzolMRdar8hNBViWWKU6syXHeprB4mYynLQWe8J/ShTL76"
    "KK7xiF5jOu304cZC5UErN3Tx/cmJTe/3WdpAz6Y/aWbPA1ukJ+jkF9XymX1V8BYd8cYt3kBo"
    "8g76miOOe705bVzhMFt5qF1Fjv2Y41S4Jxgofkh3MXO1+ifD57S3WMMs5TadnWMe43wQulav"
    "6ZSI8AvDb2+79mbedep1iRYxuxdTvicPuW69XpH9A3Z2hopsDMsJn5sWuGmUD4egq2hJ0vXS"
    "EhyPGTgprLFitnq99lwWVKwpi9GHRZVHtSvfE5yCygLgst0+hRG7UpFuIYYHvBZVHqeLevJ5"
    "9VknisBPp6fVarUdQ9PErB5wlaHpfueiIMWTloZPTbAvXxLzmG8ps3C0cZFDgJs4T1tV/g54"
    "nchKve/zzh+z+byHbwQeBFiWuM/jMSMzvnCcw0O5ZPX+9Wx6Ybp1Ncc1dSmo0QpO+HpCecLv"
    "xKw4Cg484ESf+r51XkI/j9MCUrRrnVcr1Wro77WewQ0DD4IPH/Rphs4z4/EFTJ+f6Ah5HhJT"
    "4Hl/mfggR0Bj1FmZ8xPSyKInlad6xnpMjkQoARqPZnuqW3GuGokDcGSSzN9x6EOu0LHFGguL"
    "SyY+i24f5lRvr/t7Xe2Qe06aS9R3GXT6xYI5E+neW21UFv2kth6/nt6LnOQUXW2rZi5IR8Vc"
    "i8/Qjr/ShLaGTjXzq7QHAX5/zZ0O7eZMl0aUtnD6TyqSzutU/Zkx04zRCS8NgqKjcFmpVyxX"
    "w6ekSzPa5QAQ0pMlNzZBzu/0TJ+TEjNwS0rhKp5NVDGlz2lFOjXq1aKtxZqoydGu8dxlhrYE"
    "3LRzX5dNalTYIVv0QsrzqphsJ7pDtulFlBeiJzvk5TI3WuTFc/1u1PPxR3WokXbum/yu8Rz3"
    "RO92sYVa7dw308X3mu6kbdCbVwJrhIp7qi1prcXXxrseJ3gqXPF27ts9Q4FJuvlUkLb7p09R"
    "KGZkKHdpsOLwYhGphLXbbTqeZ3gifmsD7UHQbh/WNoEH/wMcYo64Ex2PFwAAAABJRU5ErkJg"
    "gg==")

#----------------------------------------------------------------------
whidbey_left = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB4AAAArCAMAAABYWciOAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAaHWVZ3egZ3e1cHilcYCncYa0dpC4ZobHcYXGcpDBc5fWd6Dld6Pwi5OzgIjQ"
    "gJbUkJjQgJjggKDXkqHCk6TWhafggqfwh7Dwk6Xgk7Tkl7fwoKjWqLDIoLfnpMLwscHnsMfx"
    "tdD04Njk5/D49/f3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAQ3JLMwAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAF4SURBVDhPfdTbdoIwEAVQL6htAi0tElBaoVb+/xPTM5M7wc6LLvc6GTIJbnRel/DT"
    "ZkUvwXOefsahdqGMJ2LvSwaO4P7d5BdMWejQ9+dzzhOiY4/quu4z44kYSebudbH4REwLm7Q6"
    "Jr2hk+lrGR4e7Rb17ZRSdV23v55vxL4vsRCBOesXRrquBbZm0yb7jIHD/EDNKPpUjRBvbmOU"
    "Heb7/f6g/aISJhz6R8J4MJvmbM6FGSrPmRaM09i0YZ4zDdHxTN8909I8RMtzyu3NztgwbyxK"
    "qytlq6pK0qqROC/0vipGzx0v7ll/MAY2Y1G1SWv9UpXlCvNlpiPZlyjX2w4VJ/rlZk7+D3Oe"
    "DsoXwqoNV5HzKHtidJlUC3eXifuXZcxNE91U4xFLIb6jm8oeWIKLcFPN/jxLKY/HhM3+TUl5"
    "OhU48eQN9Y6VTwe6D+kLbJ0W3m5X3m926ntgXb7+eg/z2ZzJhcuusN4Lsds9/WfSuhBes94U"
    "C6r/AM3yZVcU56/qAAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
whidbey_left_single = whidbey_left

#----------------------------------------------------------------------
whidbey_left_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB4AAAArCAMAAABYWciOAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAECBXFC9vECiQBS2oIDKMIDigC0CVJUqQIkewJFKlJlayMEiwMlSiK2G0JFTR"
    "LmnSKGHmKHDoInDwMGjgNnDgNXLwSFeKQFizR2OkUGagcHiYZ3egcHilUHjRQXLwR4DwU4Pw"
    "YIfTcYXGcIjVc5fWZpHxcJj3d6PwgJbUkJjAkJjQkqHChafggqfwh7Dgh7Dwl7fwoKjAqLDI"
    "sLDIl8D4pMLw4Of35/D4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAQS37pgAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAGNSURBVDhPfdRrW8IgFAdwLyuXZLIUy67D6dK0pd3w+38xOuewAYOMN3ue/fbnwHZG"
    "R8ej5251Yu33nMfcHw8H1iNOxsiNh5xkGUfvmqIBg2YZ8KBrvM3J5BoGH7NBnW9xMjHMGTjl"
    "fQYlxvKYh/V5jErc5MEdJxMOAx/BKxZI0w/LkI340aZx5jZzdmdrU92TjKr8IbB2szHKqv1+"
    "r2Y4hFDINzWf082A2Xxu+II0TDNU4KcnAcNPz4TiV0P6pp1XKduM9R0XZdlipXBpnNXpgGl3"
    "Hu+qdSnzZ1sb0libpab2rqrKMs/d0tqstz+QhwfUt/dabFrrbYXzy1OsNwf0Fgs2TB+ad77B"
    "6SNOba9B/uV49D6ZqIvX3bJp1m++mEBO710rLg8wv8wNmVZj6ZdrxeWatmcZW9FjXbxj3ufR"
    "6NPr8wLyHnM28vtc6+INX08+w9LTKednwS9I+TwnJg3+UMoTGw3/7wKndxqyXq3gAdg9ZaO0"
    "1oab8yo+mRYLKe1p9se5tpCX/7G+dUfhL8vucupsrDz0AAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
whidbey_left_focus_single = whidbey_left_focus

#----------------------------------------------------------------------
whidbey_right = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB4AAAArCAMAAABYWciOAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAaHWVcHilcYCncYa0dpC4ZobHcYXGcpDBc5fWcZjgd6Dld6Pwi5OzgJbUkJjA"
    "kJjQgKDXk6TWhafggqfwh7Dwl7fwp7fXoLfnoLjwsLjjpMLwscHntdD0wMHg4Of35/D49/f3"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAWZqHkAAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAFySURBVDhPddPbeoIwDABglDqoFDcVGBVw8P4PyXJoQ0sxN+L3m0NDzVaJx/YoT5k8"
    "9fbAhfve2luS77kfhq5rir077pkTZ34Ng7Vt2yRO/ELuUPeOTIWxdOrA3Fc46p/9AVobsgnm"
    "Z0b1xRsTeLa+EV1f+jCBQ+8DlnzgsDBX2fLxYFR8WeYtxJF/u65tF95KM0/TNEv+ZzZfkElL"
    "TbKhuDEVnJ/4Z1+cufpmfsBwC47newNV1fV6v8cMTqMx67Jkhs0s3YIRsNbqHDCePczWhVIx"
    "S28NoVRdRyxrMaR5zZPjdcDJha+opxOf+33ACthtrR/glkY7LzmXs5npjbn3VqqcFHmE2i0E"
    "934+fd9PjKXdvylbR7yn/q7FuVB8HOF9uMJUOsjF3retb9PcysuFZ+aA0QrJJXYzC6/Fk+IO"
    "Eee628IOquJcx5wP6nYV9cYvGpYBKucNRqNHpfW+r9+580uS63vjD855vvXcF4fvB7r+A9+i"
    "Xf4K/oDaAAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
whidbey_right_single = whidbey_right

#----------------------------------------------------------------------
whidbey_right_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB4AAAArCAMAAABYWciOAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAECBXFC9vECiQBS2oIDKMIDigC0CVJUqQIkewJFKlJlayMEiwMlSiK2G0JFTR"
    "LmnSKGHmKHDoInDwMGjgNnDgNXLwSFeKQFizR2OkUGagcHiYZ3egcHilUHjRQXLwR4DwU4Pw"
    "YIfTcYXGcIjVc5fWZpHxcJj3d6PwgJbUkJjAkJjQkqHChafggqfwh7Dgh7Dwl7fwoKjAqLDI"
    "sLDIl8D4pMLw4Of35/D4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAQS37pgAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAGXSURBVDhPdZTZVoNADEDpaC2CFSqC1hVaxWoVqdv0/39szDIraF7gcHuTTCankbJx"
    "6V7tW2TfTprVmDvcNKsxt7ismnbzOPQ1npaMh5zxNMdo4Afr0CfMNK8Bv4UcMdBzwshDHzBS"
    "wlWN6QM/UmKecu68hBj40ed8nmrOuN28u/qR+op9XNfANw+mf8asow31ge8Mh9au4zhlRIF+"
    "1z2zjwcTiKWL/f6p2zFHHMdJWkpty77/lpCffcQ3IwzHY5+GitkDG8fTddv/MB2v+9n6dlVJ"
    "aBxq9/Dk/l+95IDgu8b3eD0GJ1ibTmYwzqFt12wTLn07xKc51XW16XqaF20D1jPVtRHf3XHn"
    "Sxyqm1ovC5r+MZ97OcJEj/TULuA+B3ZRFIdm5njd/o1JaSgmvzK7Bh8LXAt8kku1/8KaAr61"
    "u+ZsQ1X0Aauks1tsKdhCzGb4gzMKr66uTTzLFwuNnctjmUycb3t2m6om7JPtu3qZyE+yBURI"
    "+UogvwAM5QfUYOw/ybIhtVghPuBUXrg/LiHG1NmwcSNXqV+4tHLqnJPo+QAAAABJRU5ErkJg"
    "gg==")

#----------------------------------------------------------------------
whidbey_right_focus_single = whidbey_right_focus

#----------------------------------------------------------------------
whidbey_up = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACsAAAAeCAMAAACCNBfsAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAaHWVcHilcYCncYa0dpC4ZobHcYXGcpDBc5fWcZjgd6Dld6Pwi5OzgJbUkJjA"
    "kJjQgKDXk6TWhafggqfwh7Dwl7fwp7fXoLfnoLjwsLjjpMLwscHntdD0wMHg4Of35/D49/f3"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAWZqHkAAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAFmSURBVDhPhdTtdoMgDAZgW3GKWjsL2i/X2vu/SJaEBBXcWf6Jz3l5i9bMpdNXR3Xa"
    "Wc/StXNfKXXawaktm1rrUuWHJCWxX01TA1bqkODYlm3bNjCAVYwji9TbneStJcoWcNR5Yz0V"
    "mySvLVJrvW/buq7g7NadVxbpvJ3taSyWUuef9cx6kxwsdU3sprPY0tJEucboqginwZapjfqC"
    "1UUhT9BboXb28Twfa42pQjLZQMUCwiHbdZKMdqFsPx+PeZee3w2w3WpXugvUY7GAsXPmLvdx"
    "HITzXe4QbK8Klbvsckcr+C/bF0WeZ+52ez6Bw+D2AwxdwAxwhRsaPDp9hA4OLWGpSn1pVlZh"
    "X8Cg2dpNLlxwrgFKFpP/sRqZf26Ph3T2Te8w3AyijSlJ8fuA1v/Acfy+0Dxp8DyZig2dr9fw"
    "WXj5ExoGnxpy5TSi78c0gRUacvE0XjvfsGnqwuryH3q/d6hz07L6CxOEXf5LAPv7AAAAAElF"
    "TkSuQmCC")

#----------------------------------------------------------------------
whidbey_up_single = whidbey_up

#----------------------------------------------------------------------
whidbey_up_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACsAAAAeCAMAAACCNBfsAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAECBXFC9vECiQBS2oIDKMIDigC0CVJUqQIkewJFKlJlayMEiwMlSiK2G0JFTR"
    "LmnSKGHmKHDoInDwMGjgNnDgNXLwSFeKQFizR2OkUGagcHiYZ3egcHilUHjRQXLwR4DwU4Pw"
    "YIfTcYXGcIjVc5fWZpHxcJj3d6PwgJbUkJjAkJjQkqHChafggqfwh7Dgh7Dwl7fwoKjAqLDI"
    "sLDIl8D4pMLw4Of35/D4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAQS37pgAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAGTSURBVDhPfdQNV4IwFAZgpEyCVBRZaR8OUcI0yrLw//8xuvfuy22e7jkKZz68uxtg"
    "0Pm135fl24XxwB/bNU1VFS/+D77d/TY12lsPe3aLqTkUu3Gxa7cHSC3IsmsHOxZS64pzYTMH"
    "23Z7qKFXvpTWwZZd0w5wJivLbHxu14fmtSqUzRhYC5/ZEuY/tVbZ2NjyA1o9/UB9qmrtZG0x"
    "teKtdnjSplCmDWXLd7xZF63G0opUzux2Ra5eoLCYShvQqv2io7IymewGUsV9lVYdcG1TqAnd"
    "QbSbDbR6bqETkastYbCruob5xTNAhpp27PgK7WqFG8DZvz2kY8DBQwGF68XKW/HUtPCBE1rb"
    "dJKCjOMwDLq7gjHbkscvZUEOBiGtLc+NtTdYjCcJyFDsQ2cshOnr1PlYUmH7aTqbqYyEajRS"
    "12Bqr6f2V2CaLInjCCqGShJ5NTRAVOQSRokulDWfozap2gLGmaMwetIv7/yeulGpxnb94TCK"
    "Hp23fLHAedSgeS/C4fHo/y89R5qqfhF9+xJGvszoH5Xccuo6pVT3AAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
whidbey_up_focus_single = whidbey_up_focus

#----------------------------------------------------------------------

whidbey_denied = aero_denied

#----------------------------------------------------------------------

# ------------------------ #
# - AuiToolBar Constants - #
# ------------------------ #

ITEM_CONTROL = wx.ITEM_MAX
""" The item in the AuiToolBar is a control. """
ITEM_LABEL = ITEM_CONTROL + 1
""" The item in the AuiToolBar is a text label. """
ITEM_SPACER = ITEM_CONTROL + 2
""" The item in the AuiToolBar is a spacer. """
ITEM_SEPARATOR = wx.ITEM_SEPARATOR
""" The item in the AuiToolBar is a separator. """
ITEM_CHECK = wx.ITEM_CHECK
""" The item in the AuiToolBar is a toolbar check item. """
ITEM_NORMAL = wx.ITEM_NORMAL
""" The item in the AuiToolBar is a standard toolbar item. """
ITEM_RADIO = wx.ITEM_RADIO
""" The item in the AuiToolBar is a toolbar radio item. """
ID_RESTORE_FRAME = wx.ID_HIGHEST + 10000
""" Identifier for restoring a minimized pane. """

BUTTON_DROPDOWN_WIDTH = 10
""" Width of the drop-down button in AuiToolBar. """

DISABLED_TEXT_GREY_HUE = 153.0
""" Hue text colour for the disabled text in AuiToolBar. """
DISABLED_TEXT_COLOUR = wx.Colour(DISABLED_TEXT_GREY_HUE,
                                 DISABLED_TEXT_GREY_HUE,
                                 DISABLED_TEXT_GREY_HUE)
""" Text colour for the disabled text in AuiToolBar. """

AUI_TB_TEXT             = 1 << 0
""" Shows the text in the toolbar buttons; by default only icons are shown. """
AUI_TB_NO_TOOLTIPS      = 1 << 1
""" Don't show tooltips on `AuiToolBar` items. """
AUI_TB_NO_AUTORESIZE    = 1 << 2
""" Do not auto-resize the `AuiToolBar`. """
AUI_TB_GRIPPER          = 1 << 3
""" Shows a gripper on the `AuiToolBar`. """
AUI_TB_OVERFLOW         = 1 << 4
""" The `AuiToolBar` can contain overflow items. """
AUI_TB_VERTICAL         = 1 << 5
""" The `AuiToolBar` is vertical. """
AUI_TB_HORZ_LAYOUT      = 1 << 6
""" Shows the text and the icons alongside, not vertically stacked.
This style must be used with ``AUI_TB_TEXT``. """
AUI_TB_PLAIN_BACKGROUND = 1 << 7
""" Don't draw a gradient background on the toolbar. """
AUI_TB_CLOCKWISE        = 1 << 8
AUI_TB_COUNTERCLOCKWISE = 1 << 9

AUI_TB_HORZ_TEXT        = AUI_TB_HORZ_LAYOUT | AUI_TB_TEXT
""" Combination of ``AUI_TB_HORZ_LAYOUT`` and ``AUI_TB_TEXT``. """
AUI_TB_VERT_TEXT        = AUI_TB_VERTICAL | AUI_TB_CLOCKWISE | AUI_TB_TEXT

AUI_TB_DEFAULT_STYLE    = 0
""" `AuiToolBar` default style. """

# AuiToolBar settings
AUI_TBART_SEPARATOR_SIZE = 0
""" Separator size in AuiToolBar. """
AUI_TBART_GRIPPER_SIZE = 1
""" Gripper size in AuiToolBar. """
AUI_TBART_OVERFLOW_SIZE = 2
""" Overflow button size in AuiToolBar. """

# AuiToolBar text orientation
AUI_TBTOOL_TEXT_LEFT = 0     # unused/unimplemented
""" Text in AuiToolBar items is aligned left. """
AUI_TBTOOL_TEXT_RIGHT = 1
""" Text in AuiToolBar items is aligned right. """
AUI_TBTOOL_TEXT_TOP = 2      # unused/unimplemented
""" Text in AuiToolBar items is aligned top. """
AUI_TBTOOL_TEXT_BOTTOM = 3
""" Text in AuiToolBar items is aligned bottom. """

# AuiToolBar tool orientation
AUI_TBTOOL_HORIZONTAL = 0             # standard
AUI_TBTOOL_VERT_CLOCKWISE = 1         # rotation of 90 on the right
AUI_TBTOOL_VERT_COUNTERCLOCKWISE = 2  # rotation of 90 on the left


# --------------------- #
# - AuiMDI* Constants - #
# --------------------- #

wxWINDOWCLOSE = 4001
""" Identifier for the AuiMDI "close window" menu. """
wxWINDOWCLOSEALL = 4002
""" Identifier for the AuiMDI "close all windows" menu. """
wxWINDOWNEXT = 4003
""" Identifier for the AuiMDI "next window" menu. """
wxWINDOWPREV = 4004
""" Identifier for the AuiMDI "previous window" menu. """

# ----------------------------- #
# - AuiDockingGuide Constants - #
# ----------------------------- #

colourTargetBorder = wx.Colour(180, 180, 180)
colourTargetShade = wx.Colour(206, 206, 206)
colourTargetBackground = wx.Colour(224, 224, 224)
colourIconBorder = wx.Colour(82, 65, 156)
colourIconBackground = wx.Colour(255, 255, 255)
colourIconDockingPart1 = wx.Colour(215, 228, 243)
colourIconDockingPart2 = wx.Colour(180, 201, 225)
colourIconShadow = wx.Colour(198, 198, 198)
colourIconArrow = wx.Colour(77, 79, 170)
colourHintBackground = wx.Colour(0, 64, 255)
guideSizeX, guideSizeY = 29, 32
aeroguideSizeX, aeroguideSizeY = 31, 32
whidbeySizeX, whidbeySizeY = 43, 30

# ------------------------------- #
# - AuiSwitcherDialog Constants - #
# ------------------------------- #

SWITCHER_TEXT_MARGIN_X = 4
SWITCHER_TEXT_MARGIN_Y = 1

########NEW FILE########
__FILENAME__ = aui_switcherdialog
"""
Description
===========

The idea of `SwitcherDialog` is to make it easier to implement keyboard
navigation in AUI and other applications that have multiple panes and
tabs.

A key combination with a modifier (such as ``Ctrl`` + ``Tab``) shows the
dialog, and the user holds down the modifier whilst navigating with
``Tab`` and arrow keys before releasing the modifier to dismiss the dialog
and activate the selected pane.

The switcher dialog is a multi-column menu with no scrolling, implemented
by the `MultiColumnListCtrl` class. You can have headings for your items
for logical grouping, and you can force a column break if you need to.

The modifier used for invoking and dismissing the dialog can be customised,
as can the colours, number of rows, and the key used for cycling through
the items. So you can use different keys on different platforms if
required (especially since ``Ctrl`` + ``Tab`` is reserved on some platforms).

Items are shown as names and optional 16x16 images.


Base Functionalities
====================

To use the dialog, you set up the items in a `SwitcherItems` object,
before passing this to the `SwitcherDialog` instance.

Call L{SwitcherItems.AddItem} and optionally L{SwitcherItems.AddGroup} to add items and headings. These
functions take a label (to be displayed to the user), an identifying name,
an integer id, and a bitmap. The name and id are purely for application-defined
identification. You may also set a description to be displayed when each
item is selected; and you can set a window pointer for convenience when
activating the desired window after the dialog returns.

Have created the dialog, you call `ShowModal()`, and if the return value is
``wx.ID_OK``, retrieve the selection from the dialog and activate the pane.

The sample code below shows a generic method of finding panes and notebook
tabs within the current L{AuiManager}, and using the pane name or notebook
tab position to display the pane.

The only other code to add is a menu item with the desired accelerator,
whose modifier matches the one you pass to L{SwitcherDialog.SetModifierKey} 
(the default being ``wx.WXK_CONTROL``).


Usage
=====

Menu item::

    if wx.Platform == "__WXMAC__":
        switcherAccel = "Alt+Tab"
    elif wx.Platform == "__WXGTK__":
        switcherAccel = "Ctrl+/"
    else:
        switcherAccel = "Ctrl+Tab"

    view_menu.Append(ID_SwitchPane, _("S&witch Window...") + "\t" + switcherAccel)


Event handler::

    def OnSwitchPane(self, event):

        items = SwitcherItems()
        items.SetRowCount(12)

        # Add the main windows and toolbars, in two separate columns
        # We'll use the item 'id' to store the notebook selection, or -1 if not a page

        for k in xrange(2):
            if k == 0:
                items.AddGroup(_("Main Windows"), "mainwindows")
            else:
                items.AddGroup(_("Toolbars"), "toolbars").BreakColumn()

            for pane in self._mgr.GetAllPanes():
                name = pane.name
                caption = pane.caption

                toolbar = isinstance(info.window, wx.ToolBar) or isinstance(info.window, aui.AuiToolBar)
                if caption and (toolBar  and k == 1) or (not toolBar and k == 0):
                    items.AddItem(caption, name, -1).SetWindow(pane.window)

        # Now add the wxAuiNotebook pages

        items.AddGroup(_("Notebook Pages"), "pages").BreakColumn()

        for pane in self._mgr.GetAllPanes():
            nb = pane.window
            if isinstance(nb, aui.AuiNotebook):
                for j in xrange(nb.GetPageCount()):

                    name = nb.GetPageText(j)
                    win = nb.GetPage(j)

                    items.AddItem(name, name, j, nb.GetPageBitmap(j)).SetWindow(win)

        # Select the focused window

        idx = items.GetIndexForFocus()
        if idx != wx.NOT_FOUND:
            items.SetSelection(idx)

        if wx.Platform == "__WXMAC__":
            items.SetBackgroundColour(wx.WHITE)
        
        # Show the switcher dialog

        dlg = SwitcherDialog(items, wx.GetApp().GetTopWindow())

        # In GTK+ we can't use Ctrl+Tab; we use Ctrl+/ instead and tell the switcher
        # to treat / in the same was as tab (i.e. cycle through the names)

        if wx.Platform == "__WXGTK__":
            dlg.SetExtraNavigationKey(wxT('/'))

        if wx.Platform == "__WXMAC__":
            dlg.SetBackgroundColour(wx.WHITE)
            dlg.SetModifierKey(wx.WXK_ALT)

        ans = dlg.ShowModal()

        if ans == wx.ID_OK and dlg.GetSelection() != -1:
            item = items.GetItem(dlg.GetSelection())

            if item.GetId() == -1:
                info = self._mgr.GetPane(item.GetName())
                info.Show()
                self._mgr.Update()
                info.window.SetFocus()

            else:
                nb = item.GetWindow().GetParent()
                win = item.GetWindow();
                if isinstance(nb, aui.AuiNotebook):
                    nb.SetSelection(item.GetId())
                    win.SetFocus()


"""

import wx

import auibook
from aui_utilities import FindFocusDescendant
from aui_constants import SWITCHER_TEXT_MARGIN_X, SWITCHER_TEXT_MARGIN_Y


# Define a translation function
_ = wx.GetTranslation

    
class SwitcherItem(object):
    """ An object containing information about one item. """
    
    def __init__(self, item=None):
        """ Default class constructor. """

        self._id = 0
        self._isGroup = False
        self._breakColumn = False
        self._rowPos = 0
        self._colPos = 0
        self._window = None
        self._description = ""

        self._textColour = wx.NullColour
        self._bitmap = wx.NullBitmap
        self._font = wx.NullFont
        
        if item:
            self.Copy(item)


    def Copy(self, item):
        """
        Copy operator between 2 L{SwitcherItem} instances.

        :param `item`: another instance of L{SwitcherItem}.
        """

        self._id = item._id
        self._name = item._name
        self._title = item._title
        self._isGroup = item._isGroup
        self._breakColumn = item._breakColumn
        self._rect = item._rect
        self._font = item._font
        self._textColour = item._textColour
        self._bitmap = item._bitmap
        self._description = item._description
        self._rowPos = item._rowPos
        self._colPos = item._colPos
        self._window = item._window


    def SetTitle(self, title):

        self._title = title
        return self
    

    def GetTitle(self):
        
        return self._title


    def SetName(self, name):

        self._name = name
        return self

    
    def GetName(self):

        return self._name


    def SetDescription(self, descr):

        self._description = descr
        return self


    def GetDescription(self):

        return self._description
    

    def SetId(self, id):

        self._id = id
        return self

    
    def GetId(self):

        return self._id


    def SetIsGroup(self, isGroup):

        self._isGroup = isGroup
        return self

    
    def GetIsGroup(self):

        return self._isGroup
    

    def BreakColumn(self, breakCol=True):

        self._breakColumn = breakCol
        return self

    
    def GetBreakColumn(self):

        return self._breakColumn


    def SetRect(self, rect):

        self._rect = rect
        return self

    
    def GetRect(self):
        
        return self._rect


    def SetTextColour(self, colour):

        self._textColour = colour
        return self

    
    def GetTextColour(self):

        return self._textColour
    

    def SetFont(self, font):

        self._font = font
        return self

    
    def GetFont(self):

        return self._font
    

    def SetBitmap(self, bitmap):

        self._bitmap = bitmap
        return self

    
    def GetBitmap(self):

        return self._bitmap


    def SetRowPos(self, pos):

        self._rowPos = pos
        return self

    
    def GetRowPos(self):

        return self._rowPos
    

    def SetColPos(self, pos):

        self._colPos = pos
        return self

    
    def GetColPos(self):

        return self._colPos
    

    def SetWindow(self, win):

        self._window = win
        return self
    

    def GetWindow(self):

        return self._window

    
class SwitcherItems(object):
    """ An object containing switcher items. """

    def __init__(self, items=None):
        """ Default class constructor. """

        self._selection = -1
        self._rowCount = 10
        self._columnCount = 0

        self._backgroundColour = wx.NullColour
        self._textColour = wx.NullColour
        self._selectionColour = wx.NullColour
        self._selectionOutlineColour = wx.NullColour
        self._itemFont = wx.NullFont

        self._items = []        
        
        if wx.Platform == "__WXMSW__":
            # If on Windows XP/Vista, use more appropriate colours
            self.SetSelectionOutlineColour(wx.Colour(49, 106, 197))
            self.SetSelectionColour(wx.Colour(193, 210, 238))

        if items:
            self.Copy(items)
            

    def Copy(self, items):
        """
        Copy operator between 2 L{SwitcherItems}.

        :param `items`: another instance of L{SwitcherItems}.
        """
        
        self.Clear()

        for item in items._items:
            self._items.append(item)
        
        self._selection = items._selection
        self._rowCount = items._rowCount
        self._columnCount = items._columnCount

        self._backgroundColour = items._backgroundColour
        self._textColour = items._textColour
        self._selectionColour = items._selectionColour
        self._selectionOutlineColour = items._selectionOutlineColour
        self._itemFont = items._itemFont


    def AddItem(self, titleOrItem, name=None, id=0, bitmap=wx.NullBitmap):

        if isinstance(titleOrItem, SwitcherItem):
            self._items.append(titleOrItem)
            return self._items[-1]
        
        item = SwitcherItem()
        item.SetTitle(titleOrItem)
        item.SetName(name)
        item.SetId(id)
        item.SetBitmap(bitmap)

        self._items.append(item)
        return self._items[-1]


    def AddGroup(self, title, name, id=0, bitmap=wx.NullBitmap):

        item = self.AddItem(title, name, id, bitmap)
        item.SetIsGroup(True)

        return item


    def Clear(self):

        self._items = []


    def FindItemByName(self, name):

        for i in xrange(len(self._items)):
            if self._items[i].GetName() == name:
                return i
        
        return wx.NOT_FOUND


    def FindItemById(self, id):

        for i in xrange(len(self._items)):
            if self._items[i].GetId() == id:
                return i
        
        return wx.NOT_FOUND


    def SetSelection(self, sel):

        self._selection = sel


    def SetSelectionByName(self, name):

        idx = self.FindItemByName(name)
        if idx != wx.NOT_FOUND:
            self.SetSelection(idx)


    def GetSelection(self):

        return self._selection
    

    def GetItem(self, i):

        return self._items[i]


    def GetItemCount(self):

        return len(self._items)
    

    def SetRowCount(self, rows):

        self._rowCount = rows

        
    def GetRowCount(self):

        return self._rowCount


    def SetColumnCount(self, cols):

        self._columnCount = cols

        
    def GetColumnCount(self):

        return self._columnCount
    

    def SetBackgroundColour(self, colour):

        self._backgroundColour = colour

        
    def GetBackgroundColour(self):

        return self._backgroundColour
    

    def SetTextColour(self, colour):

        self._textColour = colour

        
    def GetTextColour(self):

        return self._textColour
    

    def SetSelectionColour(self, colour):

        self._selectionColour = colour

        
    def GetSelectionColour(self):

        return self._selectionColour
    

    def SetSelectionOutlineColour(self, colour):

        self._selectionOutlineColour = colour

        
    def GetSelectionOutlineColour(self):

        return self._selectionOutlineColour
    

    def SetItemFont(self, font):

        self._itemFont = font

        
    def GetItemFont(self):

        return self._itemFont 
    

    def PaintItems(self, dc, win):

        backgroundColour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_3DFACE)
        standardTextColour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_WINDOWTEXT)
        selectionColour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_HIGHLIGHT)
        selectionOutlineColour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_WINDOWTEXT)
        standardFont = wx.SystemSettings.GetFont(wx.SYS_DEFAULT_GUI_FONT)
        groupFont = wx.SystemSettings.GetFont(wx.SYS_DEFAULT_GUI_FONT)
        groupFont.SetWeight(wx.BOLD)

        if self.GetBackgroundColour().IsOk():
            backgroundColour = self.GetBackgroundColour()

        if self.GetTextColour().IsOk():
            standardTextColour = self.GetTextColour()

        if self.GetSelectionColour().IsOk():
            selectionColour = self.GetSelectionColour()

        if self.GetSelectionOutlineColour().IsOk():
            selectionOutlineColour = self.GetSelectionOutlineColour()

        if self.GetItemFont().IsOk():
        
            standardFont = self.GetItemFont()   
            groupFont = wx.Font(standardFont.GetPointSize(), standardFont.GetFamily(), standardFont.GetStyle(),
                                wx.BOLD, standardFont.GetUnderlined(), standardFont.GetFaceName())
        
        textMarginX = SWITCHER_TEXT_MARGIN_X

        dc.SetLogicalFunction(wx.COPY)
        dc.SetBrush(wx.Brush(backgroundColour))
        dc.SetPen(wx.TRANSPARENT_PEN)
        dc.DrawRectangleRect(win.GetClientRect())
        dc.SetBackgroundMode(wx.TRANSPARENT)

        for i in xrange(len(self._items)):
            item = self._items[i]
            if i == self._selection:
                dc.SetPen(wx.Pen(selectionOutlineColour))
                dc.SetBrush(wx.Brush(selectionColour))
                dc.DrawRectangleRect(item.GetRect())
            
            clippingRect = wx.Rect(*item.GetRect())
            clippingRect.Deflate(1, 1)

            dc.SetClippingRect(clippingRect)

            if item.GetTextColour().IsOk():
                dc.SetTextForeground(item.GetTextColour())
            else:
                dc.SetTextForeground(standardTextColour)
            
            if item.GetFont().IsOk():
                dc.SetFont(item.GetFont())
            else:
                if item.GetIsGroup():
                    dc.SetFont(groupFont)
                else:
                    dc.SetFont(standardFont)
            
            w, h = dc.GetTextExtent(item.GetTitle())
            x = item.GetRect().x

            x += textMarginX

            if not item.GetIsGroup():
                if item.GetBitmap().IsOk() and item.GetBitmap().GetWidth() <= 16 \
                   and item.GetBitmap().GetHeight() <= 16:
                    x -= textMarginX
                    dc.DrawBitmap(item.GetBitmap(), x, item.GetRect().y + \
                                  (item.GetRect().height - item.GetBitmap().GetHeight())/2,
                                  True)
                    x += 16 + textMarginX
                #x += textMarginX
            
            y = item.GetRect().y + (item.GetRect().height - h)/2
            dc.DrawText(item.GetTitle(), x, y)
            dc.DestroyClippingRegion()
    

    def CalculateItemSize(self, dc):

        # Start off allowing for an icon
        sz = wx.Size(150, 16)
        standardFont = wx.SystemSettings.GetFont(wx.SYS_DEFAULT_GUI_FONT)
        groupFont = wx.SystemSettings.GetFont(wx.SYS_DEFAULT_GUI_FONT)
        groupFont.SetWeight(wx.BOLD)

        textMarginX = SWITCHER_TEXT_MARGIN_X
        textMarginY = SWITCHER_TEXT_MARGIN_Y
        maxWidth = 300
        maxHeight = 40

        if self.GetItemFont().IsOk():
            standardFont = self.GetItemFont()   

        for item in self._items:
            if item.GetFont().IsOk():
                dc.SetFont(item.GetFont())
            else:
                if item.GetIsGroup():
                    dc.SetFont(groupFont)
                else:
                    dc.SetFont(standardFont)

            w, h = dc.GetTextExtent(item.GetTitle())
            w += 16 + 2*textMarginX

            if w > sz.x:
                sz.x = min(w, maxWidth)
            if h > sz.y:
                sz.y = min(h, maxHeight)
        
        if sz == wx.Size(16, 16):
            sz = wx.Size(100, 25)
        else:
            sz.x += textMarginX*2
            sz.y += textMarginY*2
        
        return sz


    def GetIndexForFocus(self):

        for i, item in enumerate(self._items):        
            if item.GetWindow():
            
                if FindFocusDescendant(item.GetWindow()):
                    return i
            
        return wx.NOT_FOUND


class MultiColumnListCtrl(wx.PyControl):
    """ A control for displaying several columns (not scrollable). """

    def __init__(self, parent, aui_manager, id=wx.ID_ANY, pos=wx.DefaultPosition, size=wx.DefaultSize,
                 style=0, validator=wx.DefaultValidator, name="MultiColumnListCtrl"):

        wx.PyControl.__init__(self, parent, id, pos, size, style, validator, name)

        self._overallSize = wx.Size(200, 100)
        self._modifierKey = wx.WXK_CONTROL
        self._extraNavigationKey = 0
        self._aui_manager = aui_manager
        
        self.SetInitialSize(size)
        self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM)

        self.Bind(wx.EVT_PAINT, self.OnPaint)
        self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnEraseBackground)
        self.Bind(wx.EVT_MOUSE_EVENTS, self.OnMouseEvent)
        self.Bind(wx.EVT_CHAR, self.OnChar)
        self.Bind(wx.EVT_KEY_DOWN, self.OnKey)
        self.Bind(wx.EVT_KEY_UP, self.OnKey)


    def __del__(self):

        self._aui_manager.HideHint()

        
    def DoGetBestSize(self):

        return self._overallSize


    def OnEraseBackground(self, event):
        
        pass


    def OnPaint(self, event):

        dc = wx.AutoBufferedPaintDC(self)
        rect = self.GetClientRect()

        if self._items.GetColumnCount() == 0:
            self.CalculateLayout(dc)

        if self._items.GetColumnCount() == 0:
            return

        self._items.PaintItems(dc, self)


    def OnMouseEvent(self, event):

        if event.LeftDown():
            self.SetFocus()
    

    def OnChar(self, event):

        event.Skip()        


    def OnKey(self, event):

        if event.GetEventType() == wx.wxEVT_KEY_UP:
            if event.GetKeyCode() == self.GetModifierKey():
                topLevel = wx.GetTopLevelParent(self)
                closeEvent = wx.CloseEvent(wx.wxEVT_CLOSE_WINDOW, topLevel.GetId())
                closeEvent.SetEventObject(topLevel)
                closeEvent.SetCanVeto(False)
                
                topLevel.GetEventHandler().ProcessEvent(closeEvent)
                return
                
            event.Skip()
            return

        keyCode = event.GetKeyCode()
        
        if keyCode in [wx.WXK_ESCAPE, wx.WXK_RETURN]:
            if keyCode == wx.WXK_ESCAPE:
                self._items.SetSelection(-1)

            topLevel = wx.GetTopLevelParent(self)
            closeEvent = wx.CloseEvent(wx.wxEVT_CLOSE_WINDOW, topLevel.GetId())
            closeEvent.SetEventObject(topLevel)
            closeEvent.SetCanVeto(False)
            
            topLevel.GetEventHandler().ProcessEvent(closeEvent)
            return
        
        elif keyCode in [wx.WXK_TAB, self.GetExtraNavigationKey()]:
            if event.ShiftDown():
            
                self._items.SetSelection(self._items.GetSelection() - 1)
                if self._items.GetSelection() < 0:
                    self._items.SetSelection(self._items.GetItemCount() - 1)

                self.AdvanceToNextSelectableItem(-1)
            
            else:
            
                self._items.SetSelection(self._items.GetSelection() + 1)
                if self._items.GetSelection() >= self._items.GetItemCount():
                    self._items.SetSelection(0)

                self.AdvanceToNextSelectableItem(1)
            
            self.GenerateSelectionEvent()
            self.Refresh()
        
        elif keyCode in [wx.WXK_DOWN, wx.WXK_NUMPAD_DOWN]:
            self._items.SetSelection(self._items.GetSelection() + 1)
            if self._items.GetSelection() >= self._items.GetItemCount():
                self._items.SetSelection(0)
            
            self.AdvanceToNextSelectableItem(1)
            self.GenerateSelectionEvent()
            self.Refresh()
        
        elif keyCode in [wx.WXK_UP, wx.WXK_NUMPAD_UP]:
            self._items.SetSelection(self._items.GetSelection() - 1)
            if self._items.GetSelection() < 0:
                self._items.SetSelection(self._items.GetItemCount() - 1)
            
            self.AdvanceToNextSelectableItem(-1)
            self.GenerateSelectionEvent()
            self.Refresh()
        
        elif keyCode in [wx.WXK_HOME, wx.WXK_NUMPAD_HOME]:
            self._items.SetSelection(0)
            self.AdvanceToNextSelectableItem(1)
            self.GenerateSelectionEvent()
            self.Refresh()
        
        elif keyCode in [wx.WXK_END, wx.WXK_NUMPAD_END]:
            self._items.SetSelection(self._items.GetItemCount() - 1)
            self.AdvanceToNextSelectableItem(-1)
            self.GenerateSelectionEvent()
            self.Refresh()
        
        elif keyCode in [wx.WXK_LEFT, wx.WXK_NUMPAD_LEFT]:
            item = self._items.GetItem(self._items.GetSelection())

            row = item.GetRowPos()
            newCol = item.GetColPos() - 1
            if newCol < 0:
                newCol = self._items.GetColumnCount() - 1

            # Find the first item from the end whose row matches and whose column is equal or lower
            for i in xrange(self._items.GetItemCount()-1, -1, -1):
                item2 = self._items.GetItem(i)
                if item2.GetColPos() == newCol and item2.GetRowPos() <= row:
                    self._items.SetSelection(i)
                    break

            self.AdvanceToNextSelectableItem(-1)
            self.GenerateSelectionEvent()
            self.Refresh()
        
        elif keyCode in [wx.WXK_RIGHT, wx.WXK_NUMPAD_RIGHT]:
            item = self._items.GetItem(self._items.GetSelection())

            row = item.GetRowPos()
            newCol = item.GetColPos() + 1
            if newCol >= self._items.GetColumnCount():
                newCol = 0

            # Find the first item from the end whose row matches and whose column is equal or lower
            for i in xrange(self._items.GetItemCount()-1, -1, -1):
                item2 = self._items.GetItem(i)
                if item2.GetColPos() == newCol and item2.GetRowPos() <= row:
                    self._items.SetSelection(i)
                    break

            self.AdvanceToNextSelectableItem(1)
            self.GenerateSelectionEvent()
            self.Refresh()
        
        else:
            event.Skip()


    def AdvanceToNextSelectableItem(self, direction):

        if self._items.GetItemCount() < 2:
            return

        if self._items.GetSelection() == -1:
            self._items.SetSelection(0)

        oldSel = self._items.GetSelection()

        while 1:
        
            if self._items.GetItem(self._items.GetSelection()).GetIsGroup():
            
                self._items.SetSelection(self._items.GetSelection() + direction)
                if self._items.GetSelection() == -1:
                    self._items.SetSelection(self._items.GetItemCount()-1)
                elif self._items.GetSelection() == self._items.GetItemCount():
                    self._items.SetSelection(0)
                if self._items.GetSelection() == oldSel:
                    break
            
            else:
                break

        self.SetTransparency()
        selection = self._items.GetItem(self._items.GetSelection()).GetWindow()
        pane = self._aui_manager.GetPane(selection)

        if not pane.IsOk():
            if isinstance(selection.GetParent(), auibook.AuiNotebook):
                self.SetTransparency(selection)
                self._aui_manager.ShowHint(selection.GetScreenRect())
                wx.CallAfter(self.SetFocus)
                self.SetFocus()
                return
            else:
                self._aui_manager.HideHint()
                return
        if not pane.IsShown():
            self._aui_manager.HideHint()
            return

        self.SetTransparency(selection)
        self._aui_manager.ShowHint(selection.GetScreenRect())
        # NOTE: this is odd but it is the only way for the focus to
        #       work correctly on wxMac...
        wx.CallAfter(self.SetFocus)
        self.SetFocus()        
    

    def SetTransparency(self, selection=None):

        if not self.GetParent().CanSetTransparent():
            return
        
        if selection is not None:
            intersects = False
            if selection.GetScreenRect().Intersects(self.GetParent().GetScreenRect()):
                intersects = True
                self.GetParent().SetTransparent(200)
                return

        self.GetParent().SetTransparent(255)


    def GenerateSelectionEvent(self):

        event = wx.CommandEvent(wx.wxEVT_COMMAND_LISTBOX_SELECTED, self.GetId())
        event.SetEventObject(self)
        event.SetInt(self._items.GetSelection())
        self.GetEventHandler().ProcessEvent(event)


    def CalculateLayout(self, dc=None):

        if dc is None:
            dc = wx.ClientDC(self)

        if self._items.GetSelection() == -1:
            self._items.SetSelection(0)

        columnCount = 1

        # Spacing between edge of window or between columns
        xMargin = 4
        yMargin = 4

        # Inter-row spacing
        rowSpacing = 2

        itemSize = self._items.CalculateItemSize(dc)
        self._overallSize = wx.Size(350, 200)

        currentRow = 0
        x = xMargin
        y = yMargin

        breaking = False
        i = 0
        
        while 1:
        
            oldOverallSize = self._overallSize
            item = self._items.GetItem(i)
            
            item.SetRect(wx.Rect(x, y, itemSize.x, itemSize.y))
            item.SetColPos(columnCount-1)
            item.SetRowPos(currentRow)

            if item.GetRect().GetBottom() > self._overallSize.y:
                self._overallSize.y = item.GetRect().GetBottom() + yMargin

            if item.GetRect().GetRight() > self._overallSize.x:
                self._overallSize.x = item.GetRect().GetRight() + xMargin

            currentRow += 1

            y += rowSpacing + itemSize.y
            stopBreaking = breaking

            if currentRow > self._items.GetRowCount() or (item.GetBreakColumn() and not breaking and currentRow != 1):
                currentRow = 0
                columnCount += 1
                x += xMargin + itemSize.x
                y = yMargin

                # Make sure we don't orphan a group
                if item.GetIsGroup() or (item.GetBreakColumn() and not breaking):
                    self._overallSize = oldOverallSize

                    if item.GetBreakColumn():
                        breaking = True

                    # Repeat the last item, in the next column
                    i -= 1
                
            if stopBreaking:
                breaking = False

            i += 1
            
            if i >= self._items.GetItemCount():
                break
            
        self._items.SetColumnCount(columnCount)
        self.InvalidateBestSize()


    def SetItems(self, items):
        
        self._items = items

        
    def GetItems(self):

        return self._items

 
    def SetExtraNavigationKey(self, keyCode):
        """
        Set an extra key that can be used to cycle through items,
        in case not using the ``Ctrl`` + ``Tab`` combination.
        """

        self._extraNavigationKey = keyCode


    def GetExtraNavigationKey(self):

        return self._extraNavigationKey


    def SetModifierKey(self, modifierKey):
        """
        Set the modifier used to invoke the dialog, and therefore to test for
        release.
        """

        self._modifierKey = modifierKey

        
    def GetModifierKey(self):

        return self._modifierKey

    

class SwitcherDialog(wx.Dialog):
    """
    SwitcherDialog shows a L{MultiColumnListCtrl} with a list of panes
    and tabs for the user to choose. ``Ctrl`` + ``Tab`` cycles through them.
    """

    def __init__(self, items, parent, aui_manager, id=wx.ID_ANY, title=_("Pane Switcher"), pos=wx.DefaultPosition,
                 size=wx.DefaultSize, style=wx.STAY_ON_TOP|wx.DIALOG_NO_PARENT|wx.BORDER_SIMPLE):
        """ Default class constructor. """
        
        self._switcherBorderStyle = (style & wx.BORDER_MASK)
        if self._switcherBorderStyle == wx.BORDER_NONE:
            self._switcherBorderStyle = wx.BORDER_SIMPLE

        style &= wx.BORDER_MASK
        style |= wx.BORDER_NONE

        wx.Dialog.__init__(self, parent, id, title, pos, size, style)

        self._listCtrl = MultiColumnListCtrl(self, aui_manager,
                                             style=wx.WANTS_CHARS|wx.NO_BORDER)
        self._listCtrl.SetItems(items)
        self._listCtrl.CalculateLayout()

        self._descriptionCtrl = wx.html.HtmlWindow(self, size=(-1, 100), style=wx.BORDER_NONE)
        self._descriptionCtrl.SetBackgroundColour(self.GetBackgroundColour())

        if wx.Platform == "__WXGTK__":
            fontSize = 11
            self._descriptionCtrl.SetStandardFonts(fontSize)

        sizer = wx.BoxSizer(wx.VERTICAL)
        self.SetSizer(sizer)
        sizer.Add(self._listCtrl, 1, wx.ALL|wx.EXPAND, 10)
        sizer.Add(self._descriptionCtrl, 0, wx.ALL|wx.EXPAND, 10)
        sizer.SetSizeHints(self)

        self._listCtrl.SetFocus()

        self.Centre(wx.BOTH)

        if self._listCtrl.GetItems().GetSelection() == -1:
            self._listCtrl.GetItems().SetSelection(0)

        self._listCtrl.AdvanceToNextSelectableItem(1)

        self.ShowDescription(self._listCtrl.GetItems().GetSelection())

        self.Bind(wx.EVT_CLOSE, self.OnCloseWindow)
        self.Bind(wx.EVT_ACTIVATE, self.OnActivate)
        self.Bind(wx.EVT_LISTBOX, self.OnSelectItem)
        self.Bind(wx.EVT_PAINT, self.OnPaint)

        # Attributes
        self._closing = False
        if wx.Platform == "__WXMSW__":
            self._borderColour = wx.Colour(49, 106, 197)
        else:
            self._borderColour = wx.BLACK

        self._aui_manager = aui_manager
        

    def OnCloseWindow(self, event):

        if self._closing:
            return

        if self.IsModal():
            self._closing = True

            if self.GetSelection() == -1:
                self.EndModal(wx.ID_CANCEL)
            else:
                self.EndModal(wx.ID_OK)
    
        self._aui_manager.HideHint()


    def GetSelection(self):

        return self._listCtrl.GetItems().GetSelection()


    def OnActivate(self, event):

        if not event.GetActive():
            if not self._closing:
                self._closing = True
                self.EndModal(wx.ID_CANCEL)
            

    def OnPaint(self, event):

        dc = wx.PaintDC(self)

        if self._switcherBorderStyle == wx.BORDER_SIMPLE:
        
            dc.SetPen(wx.Pen(self._borderColour))
            dc.SetBrush(wx.TRANSPARENT_BRUSH)

            rect = self.GetClientRect()
            dc.DrawRectangleRect(rect)

            # Draw border around the HTML control
            rect = wx.Rect(*self._descriptionCtrl.GetRect())
            rect.Inflate(1, 1)
            dc.DrawRectangleRect(rect)

    
    def OnSelectItem(self, event):

        self.ShowDescription(event.GetSelection())


# Convert a colour to a 6-digit hex string
    def ColourToHexString(self, col):

        hx = '%02x%02x%02x' % tuple([int(c) for c in col])
        return hx


    def ShowDescription(self, i):

        item = self._listCtrl.GetItems().GetItem(i)
        colour = self._listCtrl.GetItems().GetBackgroundColour()
        
        if not colour.IsOk():
            colour = self.GetBackgroundColour()

        backgroundColourHex = self.ColourToHexString(colour)
        html = _("<body bgcolor=\"#") + backgroundColourHex + _("\"><b>") + item.GetTitle() + _("</b>")

        if item.GetDescription():
            html += _("<p>")
            html += item.GetDescription()
        
        html += _("</body>")
        self._descriptionCtrl.SetPage(html)


    def SetExtraNavigationKey(self, keyCode):

        self._extraNavigationKey = keyCode
        if self._listCtrl:
            self._listCtrl.SetExtraNavigationKey(keyCode)


    def GetExtraNavigationKey(self):

        return self._extraNavigationKey
    
        
    def SetModifierKey(self, modifierKey):

        self._modifierKey = modifierKey
        if self._listCtrl:
            self._listCtrl.SetModifierKey(modifierKey)


    def GetModifierKey(self):

        return self._modifierKey        


    def SetBorderColour(self, colour):

        self._borderColour = colour

        
########NEW FILE########
__FILENAME__ = aui_utilities
"""
This module contains some common functions used by wxPython-AUI to
manipulate colours, bitmaps, text, gradient shadings and custom
dragging images for AuiNotebook tabs.
"""

__author__ = "Andrea Gavana <andrea.gavana@gmail.com>"
__date__ = "31 March 2009"


import wx

from aui_constants import *


if wx.Platform == "__WXMAC__":
    import Carbon.Appearance
    
    
def BlendColour(fg, bg, alpha):
    """
    Blends the two colour component `fg` and `bg` into one colour component, adding
    an optional alpha channel.

    :param `fg`: the first colour component;
    :param `bg`: the second colour component;
    :param `alpha`: an optional transparency value.
    """
    
    result = bg + (alpha*(fg - bg))
    
    if result < 0.0:
        result = 0.0
    if result > 255:
        result = 255
        
    return result


def StepColour(c, ialpha):
    """
    Darken/lighten the input colour `c`.

    :param `c`: a colour to darken/lighten;
    :param `ialpha`: a transparency value.
    """
    
    if ialpha == 100:
        return c
        
    r, g, b = c.Red(), c.Green(), c.Blue()

    # ialpha is 0..200 where 0 is completely black
    # and 200 is completely white and 100 is the same
    # convert that to normal alpha 0.0 - 1.0
    ialpha = min(ialpha, 200)
    ialpha = max(ialpha, 0)
    alpha = (ialpha - 100.0)/100.0

    if ialpha > 100:
    
        # blend with white
        bg = 255
        alpha = 1.0 - alpha  # 0 = transparent fg 1 = opaque fg
    
    else:
    
        # blend with black
        bg = 0
        alpha = 1.0 + alpha  # 0 = transparent fg 1 = opaque fg
    
    r = BlendColour(r, bg, alpha)
    g = BlendColour(g, bg, alpha)
    b = BlendColour(b, bg, alpha)

    return wx.Colour(r, g, b)


def LightContrastColour(c):
    """
    Creates a new, lighter colour based on the input colour `c`.

    :param `c`: the input colour to analyze.
    """

    amount = 120

    # if the colour is especially dark, then
    # make the contrast even lighter
    if c.Red() < 128 and c.Green() < 128 and c.Blue() < 128:
        amount = 160

    return StepColour(c, amount)


def ChopText(dc, text, max_size):
    """
    Chops the input `text` if its size does not fit in `max_size`, by cutting the
    text and adding ellipsis at the end.

    :param `dc`: a `wx.DC` device context;
    :param `text`: the text to chop;
    :param `max_size`: the maximum size in which the text should fit.
    """
    
    # first check if the text fits with no problems
    x, y, dummy = dc.GetMultiLineTextExtent(text)
    
    if x <= max_size:
        return text

    textLen = len(text)
    last_good_length = 0
    
    for i in xrange(textLen, -1, -1):
        s = text[0:i]
        s += "..."

        x, y = dc.GetTextExtent(s)
        last_good_length = i
        
        if x < max_size:
            break

    ret = text[0:last_good_length] + "..."    
    return ret


def BitmapFromBits(bits, w, h, colour):
    """
    BitmapFromBits() is a utility function that creates a
    masked bitmap from raw bits (XBM format).

    :param `bits`: a string containing the raw bits of the bitmap;
    :param `w`: the bitmap width;
    :param `h`: the bitmap height;
    :param `colour`: the colour which will replace all white pixels in the
     raw bitmap.
    """

    img = wx.BitmapFromBits(bits, w, h).ConvertToImage()
    img.Replace(0, 0, 0, 123, 123, 123)
    img.Replace(255, 255, 255, colour.Red(), colour.Green(), colour.Blue())
    img.SetMaskColour(123, 123, 123)
    return wx.BitmapFromImage(img)


def IndentPressedBitmap(rect, button_state):
    """
    Indents the input rectangle `rect` based on the value of `button_state`.

    :param `rect`: an instance of wx.Rect;
    :param `button_state`: an L{AuiNotebook} button state.
    """

    if button_state == AUI_BUTTON_STATE_PRESSED:
        rect.x += 1
        rect.y += 1

    return rect


def GetBaseColour():
    """
    Returns the face shading colour on push buttons/backgrounds, mimicking as closely
    as possible the platform UI colours.
    """

    if wx.Platform == "__WXMAC__":

        if hasattr(wx, 'MacThemeColour'):
            base_colour = wx.MacThemeColour(Carbon.Appearance.kThemeBrushToolbarBackground)
        else:
            brush = wx.Brush(wx.BLACK)
            brush.MacSetTheme(Carbon.Appearance.kThemeBrushToolbarBackground)
            base_colour = brush.GetColour()

    else:
        
        base_colour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_3DFACE)

    # the base_colour is too pale to use as our base colour,
    # so darken it a bit
    if ((255-base_colour.Red()) +
        (255-base_colour.Green()) +
        (255-base_colour.Blue()) < 60):
    
        base_colour = StepColour(base_colour, 92)
    
    return base_colour


def MakeDisabledBitmap(bitmap):
    """
    Convert the given image (in place) to a grayed-out version,
    appropriate for a 'disabled' appearance.

    :param `bitmap`: the bitmap to gray-out.
    """

    anImage = bitmap.ConvertToImage()    
    factor = 0.7        # 0 < f < 1.  Higher Is Grayer
    
    if anImage.HasMask():
        maskColour = (anImage.GetMaskRed(), anImage.GetMaskGreen(), anImage.GetMaskBlue())
    else:
        maskColour = None
        
    data = map(ord, list(anImage.GetData()))

    for i in range(0, len(data), 3):
        
        pixel = (data[i], data[i+1], data[i+2])
        pixel = MakeGray(pixel, factor, maskColour)

        for x in range(3):
            data[i+x] = pixel[x]

    anImage.SetData(''.join(map(chr, data)))
    
    return anImage.ConvertToBitmap()


def MakeGray(rgbTuple, factor, maskColour):
    """
    Make a pixel grayed-out. If the pixel matches the `maskColour`, it won't be
    changed.

    :param `rgbTuple`: a tuple representing a pixel colour;
    :param `factor`: a graying-out factor;
    :param `maskColour`: a colour mask.
    """

    if rgbTuple != maskColour:
        r, g, b = rgbTuple
        return map(lambda x: int((230 - x) * factor) + x, (r, g, b))
    else:
        return rgbTuple


def Clip(a, b, c):
    """
    Clips the value in `a` based on the extremes `b` and `c`.

    :param `a`: the value to analyze;
    :param `b`: a minimum value;
    :param `c`: a maximum value.
    """

    return ((a < b and [b]) or [(a > c and [c] or [a])[0]])[0]


def LightColour(colour, percent):
    """
    Brighten input `colour` by `percent`.

    :param `colour`: the colour to be brightened;
    :param `percent`: brightening percentage.
    """
    
    end_colour = wx.WHITE
    
    rd = end_colour.Red() - colour.Red()
    gd = end_colour.Green() - colour.Green()
    bd = end_colour.Blue() - colour.Blue()

    high = 100

    # We take the percent way of the colour from colour -. white
    i = percent
    r = colour.Red() + ((i*rd*100)/high)/100
    g = colour.Green() + ((i*gd*100)/high)/100
    b = colour.Blue() + ((i*bd*100)/high)/100
    return wx.Colour(r, g, b)


def PaneCreateStippleBitmap():
    """
    Creates a stipple bitmap to be used in a `wx.Brush`.
    This is used to draw sash resize hints.
    """

    data = [0, 0, 0, 192, 192, 192, 192, 192, 192, 0, 0, 0]
    img = wx.EmptyImage(2, 2)
    counter = 0
    
    for ii in xrange(2):
        for jj in xrange(2):
            img.SetRGB(ii, jj, data[counter], data[counter+1], data[counter+2])
            counter = counter + 3
    
    return img.ConvertToBitmap()


def DrawMACCloseButton(colour, backColour=None):
    """
    Draws the wxMAC tab close button using `wx.GraphicsContext`.

    :param `colour`: the colour to use to draw the circle;
    :param `backColour`: the optional background colour for the circle.
    """

    bmp = wx.EmptyBitmapRGBA(16, 16)
    dc = wx.MemoryDC()
    dc.SelectObject(bmp)

    gc = wx.GraphicsContext.Create(dc)    
    gc.SetBrush(wx.Brush(colour))
    path = gc.CreatePath()
    path.AddCircle(6.5, 7, 6.5)
    path.CloseSubpath()
    gc.FillPath(path)
    
    path = gc.CreatePath()
    if backColour is not None:
        pen = wx.Pen(backColour, 2)
    else:
        pen = wx.Pen("white", 2)
        
    pen.SetCap(wx.CAP_BUTT)
    pen.SetJoin(wx.JOIN_BEVEL)
    gc.SetPen(pen)
    path.MoveToPoint(3.5, 4)
    path.AddLineToPoint(9.5, 10)
    path.MoveToPoint(3.5, 10)
    path.AddLineToPoint(9.5, 4)
    path.CloseSubpath()
    gc.DrawPath(path)

    dc.SelectObject(wx.NullBitmap)
    return bmp


def DarkenBitmap(bmp, caption_colour, new_colour):
    """
    Darkens the input bitmap on wxMAC using the input colour.
    
    :param `bmp`: the bitmap to be manipulated;
    :param `caption_colour`: the colour of the pane caption;
    :param `new_colour`: the colour used to darken the bitmap.
    """

    image = bmp.ConvertToImage()
    red = caption_colour.Red()/float(new_colour.Red())
    green = caption_colour.Green()/float(new_colour.Green())
    blue = caption_colour.Blue()/float(new_colour.Blue())
    image = image.AdjustChannels(red, green, blue)
    return image.ConvertToBitmap()

    
def DrawGradientRectangle(dc, rect, start_colour, end_colour, direction, offset=0, length=0):
    """
    Draws a gradient-shaded rectangle.

    :param `dc`: a `wx.DC` device context;
    :param `rect`: the rectangle in which to draw the gradient;
    :param `start_colour`: the first colour of the gradient;
    :param `end_colour`: the second colour of the gradient;
    :param `direction`: the gradient direction (horizontal or vertical).
    """
    
    if direction == AUI_GRADIENT_VERTICAL:
        dc.GradientFillLinear(rect, start_colour, end_colour, wx.SOUTH)
    else:
        dc.GradientFillLinear(rect, start_colour, end_colour, wx.EAST)
        

def FindFocusDescendant(ancestor):
    """
    Find a window with the focus, that is also a descendant of the given window.
    This is used to determine the window to initially send commands to.

    :param `ancestor`: the window to check for ancestry.    
    """

    # Process events starting with the window with the focus, if any.
    focusWin = wx.Window.FindFocus()
    win = focusWin

    # Check if this is a descendant of this frame.
    # If not, win will be set to NULL.
    while win:
        if win == ancestor:
            break
        else:
            win = win.GetParent()

    if win is None:
        focusWin = None

    return focusWin


def GetLabelSize(dc, label, vertical):
    """
    Returns the L{AuiToolBar} item label size.

    :param `label`: the toolbar tool label;
    :param `vertical`: whether the toolbar tool orientation is vertical or not.
    """

    text_width = text_height = 0

    # get the text height
    dummy, text_height = dc.GetTextExtent("ABCDHgj")
    # get the text width
    if label.strip():
        text_width, dummy = dc.GetTextExtent(label)

    if vertical:
        tmp = text_height
        text_height = text_width
        text_width = tmp

    return wx.Size(text_width, text_height)


#---------------------------------------------------------------------------
# TabDragImage implementation
# This class handles the creation of a custom image when dragging
# AuiNotebook tabs
#---------------------------------------------------------------------------

class TabDragImage(wx.DragImage):
    """
    This class handles the creation of a custom image in case of drag and
    drop of a notebook tab.
    """

    def __init__(self, notebook, page, button_state, tabArt):
        """
        Default class constructor.
        
        For internal use: do not call it in your code!

        :param `notebook`: an instance of L{AuiNotebook};
        :param `page`: the dragged L{AuiNotebook} page;
        :param `button_state`: the state of the close button on the tab;
        :param `tabArt`: an instance of L{AuiDefaultTabArt} or one of its derivations.
        """

        self._backgroundColour = wx.NamedColour("pink")        
        self._bitmap = self.CreateBitmap(notebook, page, button_state, tabArt)
        wx.DragImage.__init__(self, self._bitmap)


    def CreateBitmap(self, notebook, page, button_state, tabArt):
        """
        Actually creates the drag and drop bitmap.

        :param `notebook`: an instance of L{AuiNotebook};
        :param `page`: the dragged L{AuiNotebook} page;
        :param `button_state`: the state of the close button on the tab;
        :param `tabArt`: an instance of L{AuiDefaultTabArt} or one of its derivations.
        """

        control = page.control
        memory = wx.MemoryDC(wx.EmptyBitmap(1, 1))

        tab_size, x_extent = tabArt.GetTabSize(memory, notebook, page.caption, page.bitmap, page.active,
                                               button_state, control)
            
        tab_width, tab_height = tab_size
        rect = wx.Rect(0, 0, tab_width, tab_height)

        bitmap = wx.EmptyBitmap(tab_width+1, tab_height+1)
        memory.SelectObject(bitmap)

        if wx.Platform == "__WXMAC__":
            memory.SetBackground(wx.TRANSPARENT_BRUSH)
        else:
            memory.SetBackground(wx.Brush(self._backgroundColour))
            
        memory.SetBackgroundMode(wx.TRANSPARENT)
        memory.Clear()

        paint_control = wx.Platform != "__WXMAC__"
        tabArt.DrawTab(memory, notebook, page, rect, button_state, paint_control=paint_control)
        
        memory.SetBrush(wx.TRANSPARENT_BRUSH)
        memory.SetPen(wx.BLACK_PEN)
        memory.DrawRoundedRectangle(0, 0, tab_width+1, tab_height+1, 2)

        memory.SelectObject(wx.NullBitmap)
        
        # Gtk and Windows unfortunatly don't do so well with transparent
        # drawing so this hack corrects the image to have a transparent
        # background.
        if wx.Platform != '__WXMAC__':
            timg = bitmap.ConvertToImage()
            if not timg.HasAlpha():
                timg.InitAlpha()
            for y in xrange(timg.GetHeight()):
                for x in xrange(timg.GetWidth()):
                    pix = wx.Colour(timg.GetRed(x, y),
                                    timg.GetGreen(x, y),
                                    timg.GetBlue(x, y))
                    if pix == self._backgroundColour:
                        timg.SetAlpha(x, y, 0)
            bitmap = timg.ConvertToBitmap()
        return bitmap        


def GetDockingImage(direction, useAero, center):
    """
    Returns the correct name of the docking bitmap depending on the input parameters.

    :param `useAero`: whether L{AuiManager} is using Aero-style or Whidbey-style docking
     images or not;
    :param `center`: whether we are looking for the center diamond-shaped bitmap or not. 
    """

    suffix = (center and [""] or ["_single"])[0]
    prefix = ""
    if useAero == 2:
        # Whidbey docking guides
        prefix = "whidbey_"
    elif useAero == 1:
        # Aero docking style
        prefix = "aero_"
        
    if direction == wx.TOP:
        bmp_unfocus = eval("%sup%s"%(prefix, suffix)).GetBitmap()
        bmp_focus = eval("%sup_focus%s"%(prefix, suffix)).GetBitmap()
    elif direction == wx.BOTTOM:
        bmp_unfocus = eval("%sdown%s"%(prefix, suffix)).GetBitmap()
        bmp_focus = eval("%sdown_focus%s"%(prefix, suffix)).GetBitmap()
    elif direction == wx.LEFT:
        bmp_unfocus = eval("%sleft%s"%(prefix, suffix)).GetBitmap()
        bmp_focus = eval("%sleft_focus%s"%(prefix, suffix)).GetBitmap()
    elif direction == wx.RIGHT:
        bmp_unfocus = eval("%sright%s"%(prefix, suffix)).GetBitmap()
        bmp_focus = eval("%sright_focus%s"%(prefix, suffix)).GetBitmap()
    else:
        bmp_unfocus = eval("%stab%s"%(prefix, suffix)).GetBitmap()
        bmp_focus = eval("%stab_focus%s"%(prefix, suffix)).GetBitmap()

    return bmp_unfocus, bmp_focus


def TakeScreenShot(rect):
    """
    Takes a screenshot of the screen at given position and size (rect).

    :param `rect`: the screen rectangle for which we want to take a screenshot.
    """

    # Create a DC for the whole screen area
    dcScreen = wx.ScreenDC()

    # Create a Bitmap that will later on hold the screenshot image
    # Note that the Bitmap must have a size big enough to hold the screenshot
    # -1 means using the current default colour depth
    bmp = wx.EmptyBitmap(rect.width, rect.height)

    # Create a memory DC that will be used for actually taking the screenshot
    memDC = wx.MemoryDC()

    # Tell the memory DC to use our Bitmap
    # all drawing action on the memory DC will go to the Bitmap now
    memDC.SelectObject(bmp)

    # Blit (in this case copy) the actual screen on the memory DC
    # and thus the Bitmap
    memDC.Blit( 0,            # Copy to this X coordinate
                0,            # Copy to this Y coordinate
                rect.width,   # Copy this width
                rect.height,  # Copy this height
                dcScreen,     # From where do we copy?
                rect.x,       # What's the X offset in the original DC?
                rect.y        # What's the Y offset in the original DC?
                )

    # Select the Bitmap out of the memory DC by selecting a new
    # uninitialized Bitmap
    memDC.SelectObject(wx.NullBitmap)

    return bmp


def RescaleScreenShot(bmp, thumbnail_size=200):
    """
    Rescales a bitmap to be 300 pixels wide (or tall) at maximum.

    :param `bmp`: the bitmap to rescale;
    :param `thumbnail_size`: the maximum size of every page thumbnail.
    """

    bmpW, bmpH = bmp.GetWidth(), bmp.GetHeight()
    img = bmp.ConvertToImage()

    newW, newH = bmpW, bmpH
    
    if bmpW > bmpH:
        if bmpW > thumbnail_size:
            ratio = bmpW/float(thumbnail_size)
            newW, newH = int(bmpW/ratio), int(bmpH/ratio)
            img.Rescale(newW, newH, wx.IMAGE_QUALITY_HIGH)
    else:
        if bmpH > thumbnail_size:
            ratio = bmpH/float(thumbnail_size)
            newW, newH = int(bmpW/ratio), int(bmpH/ratio)
            img.Rescale(newW, newH, wx.IMAGE_QUALITY_HIGH)

    newBmp = img.ConvertToBitmap()
    otherBmp = wx.EmptyBitmap(newW+5, newH+5)    

    memDC = wx.MemoryDC()
    memDC.SelectObject(otherBmp)
    memDC.SetBackground(wx.WHITE_BRUSH)
    memDC.Clear()
    
    memDC.SetPen(wx.TRANSPARENT_PEN)

    pos = 0
    for i in xrange(5, 0, -1):
        brush = wx.Brush(wx.Colour(50*i, 50*i, 50*i))
        memDC.SetBrush(brush)
        memDC.DrawRoundedRectangle(0, 0, newW+5-pos, newH+5-pos, 2)
        pos += 1

    memDC.DrawBitmap(newBmp, 0, 0, True)
     
    # Select the Bitmap out of the memory DC by selecting a new
    # uninitialized Bitmap
    memDC.SelectObject(wx.NullBitmap)

    return otherBmp


def GetSlidingPoints(rect, size, direction):
    """
    Returns the point at which the sliding in and out of a minimized pane begins.

    :param `rect`: the L{AuiToolBar} tool screen rectangle;
    :param `size`: the pane window size;
    :param `direction`: the pane docking direction.
    """

    if direction == AUI_DOCK_LEFT:
        startX, startY = rect.x + rect.width + 2, rect.y
    elif direction == AUI_DOCK_TOP:
        startX, startY = rect.x, rect.y + rect.height + 2
    elif direction == AUI_DOCK_RIGHT:
        startX, startY = rect.x - size.x - 2, rect.y
    elif direction == AUI_DOCK_BOTTOM:
        startX, startY = rect.x, rect.y - size.y - 2
    else:
        raise Exception("How did we get here?")

    caption_height = wx.SystemSettings.GetMetric(wx.SYS_CAPTION_Y)
    frame_border_x = wx.SystemSettings.GetMetric(wx.SYS_FRAMESIZE_X)
    frame_border_y = wx.SystemSettings.GetMetric(wx.SYS_FRAMESIZE_Y)
    
    stopX = size.x + caption_height + frame_border_x
    stopY = size.x + frame_border_y
    
    return startX, startY, stopX, stopY


def CopyAttributes(newArt, oldArt):
    """
    Copies pens, brushes, colours and fonts from the old tab art to the new one.

    :param `newArt`: the new instance of L{AuiDefaultTabArt};
    :param `oldArt`: the old instance of L{AuiDefaultTabArt}.
    """    
    
    attrs = dir(oldArt)

    for attr in attrs:
        if attr.startswith("_") and (attr.endswith("_colour") or attr.endswith("_font") or \
                                     attr.endswith("_font") or attr.endswith("_brush") or \
                                     attr.endswith("Pen") or attr.endswith("_pen")):
            setattr(newArt, attr, getattr(oldArt, attr))

    return newArt            


########NEW FILE########
__FILENAME__ = dockart
"""
Dock art provider code - a dock provider provides all drawing functionality to
the AUI dock manager. This allows the dock manager to have a plugable look-and-feel.

By default, a L{AuiManager} uses an instance of this class called L{AuiDefaultDockArt}
which provides bitmap art and a colour scheme that is adapted to the major platforms'
look. You can either derive from that class to alter its behaviour or write a
completely new dock art class. Call L{AuiManager.SetArtProvider} to make use this
new dock art.
"""

__author__ = "Andrea Gavana <andrea.gavana@gmail.com>"
__date__ = "31 March 2009"


import wx
import types

from aui_utilities import BitmapFromBits, StepColour, ChopText, GetBaseColour
from aui_utilities import DrawGradientRectangle, DrawMACCloseButton
from aui_utilities import DarkenBitmap, LightContrastColour
from aui_constants import *

optionActive = 2**14

_ctypes = False

# Try to import winxptheme for ModernDockArt
if wx.Platform == "__WXMSW__":
    try:
        import ctypes
        import winxptheme
        _ctypes = True
    except ImportError:
        pass

# -- AuiDefaultDockArt class implementation --

class AuiDefaultDockArt(object):
    """
    Dock art provider code - a dock provider provides all drawing functionality
    to the AUI dock manager. This allows the dock manager to have a plugable
    look-and-feel.

    By default, a L{AuiManager} uses an instance of this class called L{AuiDefaultDockArt}
    which provides bitmap art and a colour scheme that is adapted to the major
    platforms' look. You can either derive from that class to alter its behaviour or
    write a completely new dock art class.
    
    Call L{AuiManager.SetArtProvider} to make use this new dock art.


    **Metric Ordinals**

    These are the possible pane dock art settings for L{AuiManager}:

    ================================================  ======================================
    Metric Ordinal Constant                           Description
    ================================================  ======================================
    ``AUI_DOCKART_SASH_SIZE``                         Customizes the sash size
    ``AUI_DOCKART_CAPTION_SIZE``                      Customizes the caption size
    ``AUI_DOCKART_GRIPPER_SIZE``                      Customizes the gripper size
    ``AUI_DOCKART_PANE_BORDER_SIZE``                  Customizes the pane border size
    ``AUI_DOCKART_PANE_BUTTON_SIZE``                  Customizes the pane button size
    ``AUI_DOCKART_BACKGROUND_COLOUR``                 Customizes the background colour
    ``AUI_DOCKART_BACKGROUND_GRADIENT_COLOUR``        Customizes the background gradient colour
    ``AUI_DOCKART_SASH_COLOUR``                       Customizes the sash colour
    ``AUI_DOCKART_ACTIVE_CAPTION_COLOUR``             Customizes the active caption colour
    ``AUI_DOCKART_ACTIVE_CAPTION_GRADIENT_COLOUR``    Customizes the active caption gradient colour
    ``AUI_DOCKART_INACTIVE_CAPTION_COLOUR``           Customizes the inactive caption colour
    ``AUI_DOCKART_INACTIVE_CAPTION_GRADIENT_COLOUR``  Customizes the inactive gradient caption colour
    ``AUI_DOCKART_ACTIVE_CAPTION_TEXT_COLOUR``        Customizes the active caption text colour
    ``AUI_DOCKART_INACTIVE_CAPTION_TEXT_COLOUR``      Customizes the inactive caption text colour
    ``AUI_DOCKART_BORDER_COLOUR``                     Customizes the border colour
    ``AUI_DOCKART_GRIPPER_COLOUR``                    Customizes the gripper colour
    ``AUI_DOCKART_CAPTION_FONT``                      Customizes the caption font
    ``AUI_DOCKART_GRADIENT_TYPE``                     Customizes the gradient type (no gradient, vertical or horizontal)
    ``AUI_DOCKART_DRAW_SASH_GRIP``                    Draw a sash grip on the sash
    ================================================  ======================================


    **Gradient Types**

    These are the possible gradient dock art settings for L{AuiManager}:

    ============================================  ======================================
    Gradient Constant                             Description 
    ============================================  ======================================
    ``AUI_GRADIENT_NONE``                         No gradient on the captions
    ``AUI_GRADIENT_VERTICAL``                     Vertical gradient on the captions
    ``AUI_GRADIENT_HORIZONTAL``                   Horizontal gradient on the captions
    ============================================  ======================================


    **Button States**

    These are the possible pane button / L{AuiNotebook} button / L{AuiToolBar} button states:

    ============================================  ======================================
    Button State Constant                         Description     
    ============================================  ======================================
    ``AUI_BUTTON_STATE_NORMAL``                   Normal button state
    ``AUI_BUTTON_STATE_HOVER``                    Hovered button state
    ``AUI_BUTTON_STATE_PRESSED``                  Pressed button state
    ``AUI_BUTTON_STATE_DISABLED``                 Disabled button state
    ``AUI_BUTTON_STATE_HIDDEN``                   Hidden button state
    ``AUI_BUTTON_STATE_CHECKED``                  Checked button state
    ============================================  ======================================


    **Button Identifiers**

    These are the possible pane button / L{AuiNotebook} button / L{AuiToolBar} button identifiers:

    ============================================  ======================================
    Button Identifier                             Description     
    ============================================  ======================================
    ``AUI_BUTTON_CLOSE``                          Shows a close button on the pane
    ``AUI_BUTTON_MAXIMIZE_RESTORE``               Shows a maximize/restore button on the pane
    ``AUI_BUTTON_MINIMIZE``                       Shows a minimize button on the pane
    ``AUI_BUTTON_PIN``                            Shows a pin button on the pane
    ``AUI_BUTTON_OPTIONS``                        Shows an option button on the pane (not implemented)
    ``AUI_BUTTON_WINDOWLIST``                     Shows a window list button on the pane (for L{AuiNotebook})
    ``AUI_BUTTON_LEFT``                           Shows a left button on the pane (for L{AuiNotebook})
    ``AUI_BUTTON_RIGHT``                          Shows a right button on the pane (for L{AuiNotebook})
    ``AUI_BUTTON_UP``                             Shows an up button on the pane (not implemented)
    ``AUI_BUTTON_DOWN``                           Shows a down button on the pane (not implemented)
    ``AUI_BUTTON_CUSTOM1``                        Shows a custom button on the pane (not implemented)
    ``AUI_BUTTON_CUSTOM2``                        Shows a custom button on the pane (not implemented)
    ``AUI_BUTTON_CUSTOM3``                        Shows a custom button on the pane (not implemented)
    ============================================  ======================================
    
    """

    def __init__(self):
        """ Default class constructor. """

        self.Init()

        isMac = wx.Platform == "__WXMAC__"
        
        if isMac:
            self._caption_font = wx.SMALL_FONT
        else:
            self._caption_font = wx.Font(8, wx.DEFAULT, wx.NORMAL, wx.NORMAL, False)

        self.SetDefaultPaneBitmaps(isMac)
        self._restore_bitmap = wx.BitmapFromXPMData(restore_xpm)
        
        # default metric values
        self._sash_size = 4

        if isMac:
            # This really should be implemented in wx.SystemSettings
            # There is no way to do this that I am aware outside of using
            # the cocoa python bindings. 8 pixels looks correct on my system
            # so hard coding it for now.

            # How do I translate this?!? Not sure of the below implementation...
            # SInt32 height;
            # GetThemeMetric( kThemeMetricSmallPaneSplitterHeight , &height );
            # self._sash_size = height;

            self._sash_size = 8 # Carbon.Appearance.kThemeMetricPaneSplitterHeight            
            
        elif wx.Platform == "__WXGTK__":
            self._sash_size = wx.RendererNative.Get().GetSplitterParams(wx.GetTopLevelWindows()[0]).widthSash

        else:
            self._sash_size = 4
        
        self._caption_size = 19
        self._border_size = 1
        self._button_size = 14
        self._gripper_size = 9
        self._gradient_type = AUI_GRADIENT_VERTICAL
        self._draw_sash = False
        

    def Init(self):
        """ Initializes the dock art. """

        base_colour = GetBaseColour()
        darker1_colour = StepColour(base_colour, 85)
        darker2_colour = StepColour(base_colour, 75)
        darker3_colour = StepColour(base_colour, 60)
        darker4_colour = StepColour(base_colour, 40)

        self._background_colour = base_colour
        self._background_gradient_colour = StepColour(base_colour, 180)

        isMac = wx.Platform == "__WXMAC__"

        if isMac:
            self._active_caption_colour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_HIGHLIGHT)
        else:
            self._active_caption_colour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_ACTIVECAPTION)

        self._active_caption_gradient_colour = LightContrastColour(wx.SystemSettings.GetColour(wx.SYS_COLOUR_HIGHLIGHT))
        self._active_caption_text_colour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_HIGHLIGHTTEXT)
        self._inactive_caption_colour = darker1_colour
        self._inactive_caption_gradient_colour = StepColour(base_colour, 97)
        self._inactive_caption_text_colour = wx.BLACK
    
        self._sash_brush = wx.Brush(base_colour)
        self._background_brush = wx.Brush(base_colour)
        self._border_pen = wx.Pen(darker2_colour)
        self._gripper_brush = wx.Brush(base_colour)
        self._gripper_pen1 = wx.Pen(darker4_colour)
        self._gripper_pen2 = wx.Pen(darker3_colour)
        self._gripper_pen3 = wx.WHITE_PEN

        
    def GetMetric(self, id):
        """
        Gets the value of a certain setting.

        :param `id`: can be one of the size values in `Metric Ordinals`.
        """


        if id == AUI_DOCKART_SASH_SIZE:
            return self._sash_size
        elif id == AUI_DOCKART_CAPTION_SIZE:
            return self._caption_size
        elif id == AUI_DOCKART_GRIPPER_SIZE:
            return self._gripper_size
        elif id == AUI_DOCKART_PANE_BORDER_SIZE:
            return self._border_size
        elif id == AUI_DOCKART_PANE_BUTTON_SIZE:
            return self._button_size
        elif id == AUI_DOCKART_GRADIENT_TYPE:
            return self._gradient_type
        elif id == AUI_DOCKART_DRAW_SASH_GRIP:
            return self._draw_sash
        else:
            raise Exception("Invalid Metric Ordinal.")


    def SetMetric(self, id, new_val):
        """
        Sets the value of a certain setting using `new_val`

        :param `id`: can be one of the size values in `Metric Ordinals`;
        :param `new_val`: the new value of the setting.
        """

        if id == AUI_DOCKART_SASH_SIZE:
            self._sash_size = new_val
        elif id == AUI_DOCKART_CAPTION_SIZE:
            self._caption_size = new_val
        elif id == AUI_DOCKART_GRIPPER_SIZE:
            self._gripper_size = new_val
        elif id == AUI_DOCKART_PANE_BORDER_SIZE:
            self._border_size = new_val
        elif id == AUI_DOCKART_PANE_BUTTON_SIZE:
            self._button_size = new_val
        elif id == AUI_DOCKART_GRADIENT_TYPE:
            self._gradient_type = new_val
        elif id == AUI_DOCKART_DRAW_SASH_GRIP:
            self._draw_sash = new_val
        else:
            raise Exception("Invalid Metric Ordinal.")


    def GetColor(self, id):
        """
        Gets the colour of a certain setting.

        :param `id`: can be one of the colour values in `Metric Ordinals`.
        """

        if id == AUI_DOCKART_BACKGROUND_COLOUR:
            return self._background_brush.GetColour()
        elif id == AUI_DOCKART_BACKGROUND_GRADIENT_COLOUR:
            return self._background_gradient_colour
        elif id == AUI_DOCKART_SASH_COLOUR:
            return self._sash_brush.GetColour()
        elif id == AUI_DOCKART_INACTIVE_CAPTION_COLOUR:
            return self._inactive_caption_colour
        elif id == AUI_DOCKART_INACTIVE_CAPTION_GRADIENT_COLOUR:
            return self._inactive_caption_gradient_colour
        elif id == AUI_DOCKART_INACTIVE_CAPTION_TEXT_COLOUR:
            return self._inactive_caption_text_colour
        elif id == AUI_DOCKART_ACTIVE_CAPTION_COLOUR:
            return self._active_caption_colour
        elif id == AUI_DOCKART_ACTIVE_CAPTION_GRADIENT_COLOUR:
            return self._active_caption_gradient_colour
        elif id == AUI_DOCKART_ACTIVE_CAPTION_TEXT_COLOUR:
            return self._active_caption_text_colour        
        elif id == AUI_DOCKART_BORDER_COLOUR:
            return self._border_pen.GetColour()
        elif id == AUI_DOCKART_GRIPPER_COLOUR:
            return self._gripper_brush.GetColour()
        else:
            raise Exception("Invalid Colour Ordinal.")


    def SetColor(self, id, colour):
        """
        Sets the colour of a certain setting.

        :param `id`: can be one of the colour values in `Metric Ordinals`;
        :param `colour`: the new value of the setting.
        """

        if isinstance(colour, basestring):
            colour = wx.NamedColour(colour)
        elif isinstance(colour, types.TupleType):
            colour = wx.Colour(*colour)
        elif isinstance(colour, types.IntType):
            colour = wx.ColourRGB(colour)
        
        if id == AUI_DOCKART_BACKGROUND_COLOUR:
            self._background_brush.SetColour(colour)
        elif id == AUI_DOCKART_BACKGROUND_GRADIENT_COLOUR:
            self._background_gradient_colour = colour
        elif id == AUI_DOCKART_SASH_COLOUR:
            self._sash_brush.SetColour(colour)
        elif id == AUI_DOCKART_INACTIVE_CAPTION_COLOUR:
            self._inactive_caption_colour = colour
            if not self._custom_pane_bitmaps and wx.Platform == "__WXMAC__":
                # No custom bitmaps for the pane close button
                # Change the MAC close bitmap colour
                self._inactive_close_bitmap = DrawMACCloseButton(wx.WHITE, colour)

        elif id == AUI_DOCKART_INACTIVE_CAPTION_GRADIENT_COLOUR:
            self._inactive_caption_gradient_colour = colour
        elif id == AUI_DOCKART_INACTIVE_CAPTION_TEXT_COLOUR:
            self._inactive_caption_text_colour = colour
        elif id == AUI_DOCKART_ACTIVE_CAPTION_COLOUR:
            self._active_caption_colour = colour
            if not self._custom_pane_bitmaps and wx.Platform == "__WXMAC__":
                # No custom bitmaps for the pane close button
                # Change the MAC close bitmap colour
                self._active_close_bitmap = DrawMACCloseButton(wx.WHITE, colour)
                
        elif id == AUI_DOCKART_ACTIVE_CAPTION_GRADIENT_COLOUR:
            self._active_caption_gradient_colour = colour
        elif id == AUI_DOCKART_ACTIVE_CAPTION_TEXT_COLOUR:
            self._active_caption_text_colour = colour
        elif id == AUI_DOCKART_BORDER_COLOUR:
            self._border_pen.SetColour(colour)
        elif id == AUI_DOCKART_GRIPPER_COLOUR:
            self._gripper_brush.SetColour(colour)
            self._gripper_pen1.SetColour(StepColour(colour, 40))
            self._gripper_pen2.SetColour(StepColour(colour, 60))
        else:
            raise Exception("Invalid Colour Ordinal.")
        

    GetColour = GetColor
    SetColour = SetColor

    def SetFont(self, id, font):
        """
        Sets a font setting.
        
        :param `id`: must be ``AUI_DOCKART_CAPTION_FONT``;
        :param `font`: an instance of `wx.Font`.
        """
        
        if id == AUI_DOCKART_CAPTION_FONT:
            self._caption_font = font


    def GetFont(self, id):
        """
        Gets a font setting.
        
        :param `id`: must be ``AUI_DOCKART_CAPTION_FONT``, otherwise `wx.NullFont` is returned.
        """
        
        if id == AUI_DOCKART_CAPTION_FONT:
            return self._caption_font
        
        return wx.NullFont


    def DrawSash(self, dc, window, orient, rect):
        """
        Draws a sash between two windows.

        :param `dc`: a `wx.DC` device context;
        :param `window`: an instance of `wx.Window`;
        :param `orient`: the sash orientation;
        :param `rect`: the sash rectangle.
        """                

        # AG: How do we make this work?!?
        # RendererNative does not use the sash_brush chosen by the user
        # and the rect.GetSize() is ignored as the sash is always drawn
        # 3 pixel wide
        # wx.RendererNative.Get().DrawSplitterSash(window, dc, rect.GetSize(), pos, orient)

        dc.SetPen(wx.TRANSPARENT_PEN)
        dc.SetBrush(self._sash_brush)
        dc.DrawRectangle(rect.x, rect.y, rect.width, rect.height)        

        draw_sash = self.GetMetric(AUI_DOCKART_DRAW_SASH_GRIP)
        if draw_sash:
            self.DrawSashGripper(dc, orient, rect)


    def DrawBackground(self, dc, window, orient, rect):
        """
        Draws a background.

        :param `dc`: a `wx.DC` device context;
        :param `window`: an instance of `wx.Window`;
        :param `orient`: the gradient (if any) orientation;
        :param `rect`: the background rectangle.
        """

        dc.SetPen(wx.TRANSPARENT_PEN)
        if wx.Platform == "__WXMAC__":
            # we have to clear first, otherwise we are drawing a light striped pattern
            # over an already darker striped background
            dc.SetBrush(wx.WHITE_BRUSH)
            dc.DrawRectangle(rect.x, rect.y, rect.width, rect.height)

        DrawGradientRectangle(dc, rect, self._background_brush.GetColour(),
                              self._background_gradient_colour,
                              AUI_GRADIENT_HORIZONTAL, rect.x, 700)


    def DrawBorder(self, dc, window, rect, pane):
        """
        Draws the pane border.

        :param `dc`: a `wx.DC` device context;
        :param `window`: an instance of `wx.Window`;
        :param `rect`: the border rectangle;
        :param `pane`: the pane for which the border is drawn.
        """        

        drect = wx.Rect(*rect)
        
        dc.SetPen(self._border_pen)
        dc.SetBrush(wx.TRANSPARENT_BRUSH)

        border_width = self.GetMetric(AUI_DOCKART_PANE_BORDER_SIZE)

        if pane.IsToolbar():
        
            for ii in xrange(0, border_width):
            
                dc.SetPen(wx.WHITE_PEN)
                dc.DrawLine(drect.x, drect.y, drect.x+drect.width, drect.y)
                dc.DrawLine(drect.x, drect.y, drect.x, drect.y+drect.height)
                dc.SetPen(self._border_pen)       
                dc.DrawLine(drect.x, drect.y+drect.height-1,
                            drect.x+drect.width, drect.y+drect.height-1)
                dc.DrawLine(drect.x+drect.width-1, drect.y,
                            drect.x+drect.width-1, drect.y+drect.height)
                drect.Deflate(1, 1)
        
        else:
        
            for ii in xrange(0, border_width):
            
                dc.DrawRectangle(drect.x, drect.y, drect.width, drect.height)
                drect.Deflate(1, 1)
            

    def DrawCaptionBackground(self, dc, rect, pane):
        """
        Draws the text caption background in the pane.

        :param `dc`: a `wx.DC` device context;
        :param `rect`: the text caption rectangle;
        :param `pane`: the pane for which the text background is drawn.
        """        

        active = pane.state & optionActive
 
        if self._gradient_type == AUI_GRADIENT_NONE:
            if active:
                dc.SetBrush(wx.Brush(self._active_caption_colour))
            else:
                dc.SetBrush(wx.Brush(self._inactive_caption_colour))

            dc.DrawRectangle(rect.x, rect.y, rect.width, rect.height)        

        else:

            switch_gradient = pane.HasCaptionLeft()
            gradient_type = self._gradient_type
            if switch_gradient:
                gradient_type = (self._gradient_type == AUI_GRADIENT_HORIZONTAL and [AUI_GRADIENT_VERTICAL] or \
                                 [AUI_GRADIENT_HORIZONTAL])[0]
            
            if active:
                if wx.Platform == "__WXMAC__":
                    DrawGradientRectangle(dc, rect, self._active_caption_colour,
                                          self._active_caption_gradient_colour,
                                          gradient_type)                    
                else:
                    DrawGradientRectangle(dc, rect, self._active_caption_gradient_colour,
                                          self._active_caption_colour,
                                          gradient_type)
            else:
                if wx.Platform == "__WXMAC__":
                    DrawGradientRectangle(dc, rect, self._inactive_caption_gradient_colour,
                                          self._inactive_caption_colour,
                                          gradient_type)
                else:
                    DrawGradientRectangle(dc, rect, self._inactive_caption_colour,
                                          self._inactive_caption_gradient_colour,
                                          gradient_type)


    def DrawIcon(self, dc, rect, pane):
        """
        Draws the icon in the pane caption area.

        :param `dc`: a `wx.DC` device context;
        :param `rect`: the pane caption rectangle;
        :param `pane`: the pane for which the icon is drawn.
        """        
        
        # Draw the icon centered vertically 
        if pane.icon.Ok():
            if pane.HasCaptionLeft():
                bmp = wx.ImageFromBitmap(pane.icon).Rotate90(clockwise=False)
                dc.DrawBitmap(bmp.ConvertToBitmap(), rect.x+(rect.width-pane.icon.GetWidth())/2, rect.y+rect.height-2-pane.icon.GetHeight(), True)
            else:
                dc.DrawBitmap(pane.icon, rect.x+2, rect.y+(rect.height-pane.icon.GetHeight())/2, True)


    def DrawCaption(self, dc, window, text, rect, pane):
        """
        Draws the text in the pane caption.

        :param `dc`: a `wx.DC` device context;
        :param `window`: an instance of `wx.Window`;
        :param `text`: the text to be displayed;
        :param `rect`: the pane caption rectangle;
        :param `pane`: the pane for which the text is drawn.
        """        

        dc.SetPen(wx.TRANSPARENT_PEN)
        dc.SetFont(self._caption_font)
        
        self.DrawCaptionBackground(dc, rect, pane)

        if pane.state & optionActive:
            dc.SetTextForeground(self._active_caption_text_colour)
        else:
            dc.SetTextForeground(self._inactive_caption_text_colour)

        w, h = dc.GetTextExtent("ABCDEFHXfgkj")

        clip_rect = wx.Rect(*rect)
        btns = pane.CountButtons()

        captionLeft = pane.HasCaptionLeft()
        variable = (captionLeft and [rect.height] or [rect.width])[0]

        variable -= 3      # text offset
        variable -= 2      # button padding

        caption_offset = 0
        if pane.icon:
            if captionLeft:
                caption_offset += pane.icon.GetHeight() + 3
            else:
                caption_offset += pane.icon.GetWidth() + 3
                
            self.DrawIcon(dc, rect, pane)

        variable -= caption_offset
        variable -= btns*(self._button_size + self._border_size)
        draw_text = ChopText(dc, text, variable)

        if captionLeft:
            dc.DrawRotatedText(draw_text, rect.x+(rect.width/2)-(h/2)-1, rect.y+rect.height-3-caption_offset, 90)
        else:
            dc.DrawText(draw_text, rect.x+3+caption_offset, rect.y+(rect.height/2)-(h/2)-1)


    def RequestUserAttention(self, dc, window, text, rect, pane):
        """
        Requests the user attention by intermittently highlighting the pane caption.

        :param `dc`: a `wx.DC` device context;
        :param `window`: an instance of `wx.Window`;
        :param `text`: the text to be displayed;
        :param `rect`: the pane caption rectangle;
        :param `pane`: the pane for which the text is drawn.
        """        

        state = pane.state
        pane.state &= ~optionActive
        
        for indx in xrange(6):
            active = (indx%2 == 0 and [True] or [False])[0]
            if active:
                pane.state |= optionActive
            else:
                pane.state &= ~optionActive
                
            self.DrawCaptionBackground(dc, rect, pane)
            self.DrawCaption(dc, window, text, rect, pane)
            wx.SafeYield()
            wx.MilliSleep(350)

        pane.state = state
        

    def DrawGripper(self, dc, window, rect, pane):
        """
        Draws a gripper on the pane.

        :param `dc`: a `wx.DC` device context;
        :param `window`: an instance of `wx.Window`;
        :param `rect`: the pane caption rectangle;
        :param `pane`: the pane for which the gripper is drawn.
        """        

        dc.SetPen(wx.TRANSPARENT_PEN)
        dc.SetBrush(self._gripper_brush)

        dc.DrawRectangle(rect.x, rect.y, rect.width, rect.height)

        if not pane.HasGripperTop():
            y = 4
            while 1:
                dc.SetPen(self._gripper_pen1)
                dc.DrawPoint(rect.x+3, rect.y+y) 
                dc.SetPen(self._gripper_pen2) 
                dc.DrawPoint(rect.x+3, rect.y+y+1) 
                dc.DrawPoint(rect.x+4, rect.y+y) 
                dc.SetPen(self._gripper_pen3) 
                dc.DrawPoint(rect.x+5, rect.y+y+1) 
                dc.DrawPoint(rect.x+5, rect.y+y+2) 
                dc.DrawPoint(rect.x+4, rect.y+y+2) 
                y = y + 4 
                if y > rect.GetHeight() - 4:
                    break
        else:
            x = 4
            while 1:
                dc.SetPen(self._gripper_pen1) 
                dc.DrawPoint(rect.x+x, rect.y+3) 
                dc.SetPen(self._gripper_pen2) 
                dc.DrawPoint(rect.x+x+1, rect.y+3) 
                dc.DrawPoint(rect.x+x, rect.y+4) 
                dc.SetPen(self._gripper_pen3) 
                dc.DrawPoint(rect.x+x+1, rect.y+5) 
                dc.DrawPoint(rect.x+x+2, rect.y+5) 
                dc.DrawPoint(rect.x+x+2, rect.y+4) 
                x = x + 4 
                if x > rect.GetWidth() - 4:
                    break 
        

    def DrawPaneButton(self, dc, window, button, button_state, _rect, pane):
        """
        Draws a pane button in the pane caption area.

        :param `dc`: a `wx.DC` device context;
        :param `window`: an instance of `wx.Window`;
        :param `button`: the button to be drawn;
        :param `button_state`: the pane button state;
        :param `_rect`: the pane caption rectangle;
        :param `pane`: the pane for which the button is drawn.
        """        
        
        if not pane:
            return
        
        if button == AUI_BUTTON_CLOSE:
            if pane.state & optionActive:
                bmp = self._active_close_bitmap
            else:
                bmp = self._inactive_close_bitmap

        elif button == AUI_BUTTON_PIN:
            if pane.state & optionActive:
                bmp = self._active_pin_bitmap
            else:
                bmp = self._inactive_pin_bitmap

        elif button == AUI_BUTTON_MAXIMIZE_RESTORE:
            if pane.IsMaximized():
                if pane.state & optionActive:
                    bmp = self._active_restore_bitmap
                else:
                    bmp = self._inactive_restore_bitmap
            else:
                if pane.state & optionActive:
                    bmp = self._active_maximize_bitmap
                else:
                    bmp = self._inactive_maximize_bitmap

        elif button == AUI_BUTTON_MINIMIZE:
            if pane.state & optionActive:
                bmp = self._active_minimize_bitmap
            else:
                bmp = self._inactive_minimize_bitmap

        isVertical = pane.HasCaptionLeft()
        
        rect = wx.Rect(*_rect)

        if isVertical:
            old_x = rect.x
            rect.x = rect.x + (rect.width/2) - (bmp.GetWidth()/2)
            rect.width = old_x + rect.width - rect.x - 1
        else:
            old_y = rect.y
            rect.y = rect.y + (rect.height/2) - (bmp.GetHeight()/2)
            rect.height = old_y + rect.height - rect.y - 1

        if button_state == AUI_BUTTON_STATE_PRESSED:
            rect.x += 1
            rect.y += 1

        if button_state in [AUI_BUTTON_STATE_HOVER, AUI_BUTTON_STATE_PRESSED]:

            if pane.state & optionActive:

                dc.SetBrush(wx.Brush(StepColour(self._active_caption_colour, 120)))
                dc.SetPen(wx.Pen(StepColour(self._active_caption_colour, 70)))

            else:

                dc.SetBrush(wx.Brush(StepColour(self._inactive_caption_colour, 120)))
                dc.SetPen(wx.Pen(StepColour(self._inactive_caption_colour, 70)))

            if wx.Platform != "__WXMAC__":
                # draw the background behind the button
                dc.DrawRectangle(rect.x, rect.y, 15, 15)
            else:
                # Darker the bitmap a bit
                bmp = DarkenBitmap(bmp, self._active_caption_colour, StepColour(self._active_caption_colour, 110))

        if isVertical:
            bmp = wx.ImageFromBitmap(bmp).Rotate90(clockwise=False).ConvertToBitmap()
            
        # draw the button itself
        dc.DrawBitmap(bmp, rect.x, rect.y, True)


    def DrawSashGripper(self, dc, orient, rect):
        """
        Draws a sash gripper on a sash between two windows.

        :param `dc`: a `wx.DC` device context;
        :param `orient`: the sash orientation;
        :param `rect`: the sash rectangle.
        """
        
        dc.SetBrush(self._gripper_brush)

        if orient == wx.HORIZONTAL:  # horizontal sash
            
            x = rect.x + int((1.0/4.0)*rect.width)
            xend = rect.x + int((3.0/4.0)*rect.width)
            y = rect.y + (rect.height/2) - 1

            while 1:
                dc.SetPen(self._gripper_pen3)
                dc.DrawRectangle(x, y, 2, 2)
                dc.SetPen(self._gripper_pen2) 
                dc.DrawPoint(x+1, y+1)
                x = x + 5

                if x >= xend:
                    break

        else:

            y = rect.y + int((1.0/4.0)*rect.height)
            yend = rect.y + int((3.0/4.0)*rect.height)
            x = rect.x + (rect.width/2) - 1

            while 1:
                dc.SetPen(self._gripper_pen3)
                dc.DrawRectangle(x, y, 2, 2)
                dc.SetPen(self._gripper_pen2) 
                dc.DrawPoint(x+1, y+1)
                y = y + 5

                if y >= yend:
                    break


    def SetDefaultPaneBitmaps(self, isMac):
        """
        Assigns the default pane bitmaps.

        :param `isMac`: whether we are on wxMAC or not.
        """

        if isMac:
            self._inactive_close_bitmap = DrawMACCloseButton(wx.WHITE, self._inactive_caption_colour)
            self._active_close_bitmap = DrawMACCloseButton(wx.WHITE, self._active_caption_colour)
        else:
            self._inactive_close_bitmap = BitmapFromBits(close_bits, 16, 16, self._inactive_caption_text_colour)
            self._active_close_bitmap = BitmapFromBits(close_bits, 16, 16, self._active_caption_text_colour)
            
        if isMac:
            self._inactive_maximize_bitmap = BitmapFromBits(max_bits, 16, 16, wx.WHITE)
            self._active_maximize_bitmap = BitmapFromBits(max_bits, 16, 16, wx.WHITE)
        else:
            self._inactive_maximize_bitmap = BitmapFromBits(max_bits, 16, 16, self._inactive_caption_text_colour)
            self._active_maximize_bitmap = BitmapFromBits(max_bits, 16, 16, self._active_caption_text_colour)

        if isMac:
            self._inactive_restore_bitmap = BitmapFromBits(restore_bits, 16, 16, wx.WHITE)
            self._active_restore_bitmap = BitmapFromBits(restore_bits, 16, 16, wx.WHITE)
        else:
            self._inactive_restore_bitmap = BitmapFromBits(restore_bits, 16, 16, self._inactive_caption_text_colour)
            self._active_restore_bitmap = BitmapFromBits(restore_bits, 16, 16, self._active_caption_text_colour)

        if isMac:
            self._inactive_minimize_bitmap = BitmapFromBits(minimize_bits, 16, 16, wx.WHITE)
            self._active_minimize_bitmap = BitmapFromBits(minimize_bits, 16, 16, wx.WHITE)
        else:
            self._inactive_minimize_bitmap = BitmapFromBits(minimize_bits, 16, 16, self._inactive_caption_text_colour)
            self._active_minimize_bitmap = BitmapFromBits(minimize_bits, 16, 16, self._active_caption_text_colour)

        self._inactive_pin_bitmap = BitmapFromBits(pin_bits, 16, 16, self._inactive_caption_text_colour)
        self._active_pin_bitmap = BitmapFromBits(pin_bits, 16, 16, self._active_caption_text_colour)

        self._custom_pane_bitmaps = False
        
        
    def SetCustomPaneBitmap(self, bmp, button, active, maximize=False):
        """
        Sets a custom button bitmap for the pane button.

        :param `bmp`: the actual bitmap to set;
        :param `button`: the button identifier;
        :param `active`: whether it is the bitmap for the active button or not;
        :param `maximize`: used to distinguish between the maximize and restore bitmaps.
        """

        if bmp.GetWidth() > 16 or bmp.GetHeight() > 16:
            raise Exception("The input bitmap is too big")

        if button == AUI_BUTTON_CLOSE:
            if active:
                self._active_close_bitmap = bmp
            else:
                self._inactive_close_bitmap = bmp

            if wx.Platform == "__WXMAC__":
                self._custom_pane_bitmaps = True                

        elif button == AUI_BUTTON_PIN:
            if active:
                self._active_pin_bitmap = bmp
            else:
                self._inactive_pin_bitmap = bmp

        elif button == AUI_BUTTON_MAXIMIZE_RESTORE:
            if maximize:
                if active:
                    self._active_maximize_bitmap = bmp
                else:
                    self._inactive_maximize_bitmap = bmp
            else:
                if active:
                    self._active_restore_bitmap = bmp
                else:
                    self._inactive_restore_bitmap = bmp

        elif button == AUI_BUTTON_MINIMIZE:
            if active:
                self._active_minimize_bitmap = bmp
            else:
                self._inactive_minimize_bitmap = bmp


if _ctypes:
    class RECT(ctypes.Structure):
        """ Used to handle L{ModernDockArt} on Windows XP/Vista/7. """
        _fields_ = [('left', ctypes.c_ulong),('top', ctypes.c_ulong),('right', ctypes.c_ulong),('bottom', ctypes.c_ulong)]

        def dump(self):
            """ Dumps `self` as a `wx.Rect`. """
            return map(int, (self.left, self.top, self.right, self.bottom))


    class SIZE(ctypes.Structure):
        """ Used to handle L{ModernDockArt} on Windows XP/Vista/7. """
        _fields_ = [('x', ctypes.c_long),('y', ctypes.c_long)]


class ModernDockArt(AuiDefaultDockArt):
    """
    ModernDockArt is a custom `AuiDockArt` class, that implements a look similar to
    Firefox and other recents applications. 

    Is uses the `winxptheme` module and XP themes whenever possible, so it should
    look good even if the user has a custom theme.

    :note: This dock art is Windows only and will only work if you have installed
     Mark Hammond's `pywin32` module (http://sourceforge.net/projects/pywin32/).
    """

    def __init__(self, win):
        """
        Default class constructor. 

        :param `win`: the window managed by L{AuiManager}. 
        """
        
        AuiDefaultDockArt.__init__(self)
        
        self.win = win

        # Get the size of a small close button (themed)
        hwnd = self.win.GetHandle()
        
        self.hTheme1 = winxptheme.OpenThemeData(hwnd, "Window")
        
        self.usingTheme = True
        
        if not self.hTheme1:
            self.usingTheme = False

        self._button_size = 13

        self._button_border_size = 3
        self._caption_text_indent = 6
        self._caption_size = 22
        
        # We only highlight the active pane with the caption text being in bold.
        # So we do not want a special colour for active elements.        
        self._active_close_bitmap = self._inactive_close_bitmap

        self.Init()
        

    def Init(self):
        """ Initializes the dock art. """

        AuiDefaultDockArt.Init(self)
        
        self._active_caption_colour = self._inactive_caption_colour
        self._active_caption_text_colour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_CAPTIONTEXT)
        self._inactive_caption_text_colour = self._active_caption_text_colour


    def DrawCaption(self, dc, window, text, rect, pane):
        """
        Draws the text in the pane caption.

        :param `dc`: a `wx.DC` device context;
        :param `window`: an instance of `wx.Window`;
        :param `text`: the text to be displayed;
        :param `rect`: the pane caption rectangle;
        :param `pane`: the pane for which the text is drawn.
        """        

        dc.SetPen(wx.TRANSPARENT_PEN)
        self.DrawCaptionBackground(dc, rect, pane)

        active = ((pane.state & optionActive) and [True] or [False])[0]

        self._caption_font.SetWeight(wx.FONTWEIGHT_BOLD)
        dc.SetFont(self._caption_font)
        
        if active:
            dc.SetTextForeground(self._active_caption_text_colour)
        else:
            dc.SetTextForeground(self._inactive_caption_text_colour)

        w, h = dc.GetTextExtent("ABCDEFHXfgkj")

        clip_rect = wx.Rect(*rect)
        btns = pane.CountButtons()

        captionLeft = pane.HasCaptionLeft()
        variable = (captionLeft and [rect.height] or [rect.width])[0]

        variable -= 3      # text offset
        variable -= 2      # button padding

        caption_offset = 0
        if pane.icon:
            if captionLeft:
                caption_offset += pane.icon.GetHeight() + 3
            else:
                caption_offset += pane.icon.GetWidth() + 3
                
            self.DrawIcon(dc, rect, pane)

        diff = -2
        if self.usingTheme:
            diff = -1

        variable -= caption_offset
        variable -= btns*(self._button_size + self._button_border_size)
        draw_text = ChopText(dc, text, variable)

        if captionLeft:
            dc.DrawRotatedText(draw_text, rect.x+(rect.width/2)-(h/2)-diff, rect.y+rect.height-3-caption_offset, 90)
        else:
            dc.DrawText(draw_text, rect.x+3+caption_offset, rect.y+(rect.height/2)-(h/2)-diff)


    def DrawCaptionBackground(self, dc, rect, pane):
        """
        Draws the text caption background in the pane.

        :param `dc`: a `wx.DC` device context;
        :param `rect`: the text caption rectangle;
        :param `pane`: the pane for which we are drawing the caption background.
        """        

        dc.SetBrush(self._background_brush)
        dc.DrawRectangle(rect.x, rect.y, rect.width, rect.height)

        active = ((pane.state & optionActive) and [True] or [False])[0]

        if self.usingTheme:
            
            rectangle = wx.Rect()

            rc = RECT(rectangle.x, rectangle.y, rectangle.width, rectangle.height)

            rc.top = rect.x
            rc.left = rect.y
            rc.right = rect.x + rect.width
            rc.bottom = rect.y + rect.height

            if active:
                winxptheme.DrawThemeBackground(self.hTheme1, dc.GetHDC(), 5, 1, (rc.top, rc.left, rc.right, rc.bottom), None)
            else:
                winxptheme.DrawThemeBackground(self.hTheme1, dc.GetHDC(), 5, 2, (rc.top, rc.left, rc.right, rc.bottom), None)
            
        else:

            AuiDefaultDockArt.DrawCaptionBackground(self, dc, rect, pane)


    def RequestUserAttention(self, dc, window, text, rect, pane):
        """
        Requests the user attention by intermittently highlighting the pane caption.

        :param `dc`: a `wx.DC` device context;
        :param `window`: an instance of `wx.Window`;
        :param `text`: the text to be displayed;
        :param `rect`: the pane caption rectangle;
        :param `pane`: the pane for which the text is drawn.
        """        
    
        state = pane.state
        pane.state &= ~optionActive
        
        for indx in xrange(6):
            active = (indx%2 == 0 and [True] or [False])[0]
            if active:
                pane.state |= optionActive
            else:
                pane.state &= ~optionActive
                
            self.DrawCaptionBackground(dc, rect, pane)
            self.DrawCaption(dc, window, text, rect, pane)
            wx.SafeYield()
            wx.MilliSleep(350)

        pane.state = state


    def DrawPaneButton(self, dc, window, button, button_state, rect, pane):
        """
        Draws a pane button in the pane caption area.

        :param `dc`: a `wx.DC` device context;
        :param `window`: an instance of `wx.Window`;
        :param `button`: the button to be drawn;
        :param `button_state`: the pane button state;
        :param `rect`: the pane caption rectangle;
        :param `pane`: the pane for which the button is drawn.
        """        

        if self.usingTheme:

            hTheme = self.hTheme1            
                    
            # Get the real button position (compensating for borders)
            drect = wx.Rect(rect.x, rect.y, self._button_size, self._button_size)
            
            # Draw the themed close button
            rc = RECT(0, 0, 0, 0)
            if pane.HasCaptionLeft():
                rc.top = rect.x + self._button_border_size
                rc.left = int(rect.y + 1.5*self._button_border_size)
                rc.right = rect.x + self._button_size + self._button_border_size
                rc.bottom = int(rect.y + self._button_size + 1.5*self._button_border_size)
            else:
                rc.top = rect.x - self._button_border_size
                rc.left = int(rect.y + 1.5*self._button_border_size)
                rc.right = rect.x + self._button_size- self._button_border_size
                rc.bottom = int(rect.y + self._button_size + 1.5*self._button_border_size)

            if button == AUI_BUTTON_CLOSE:
                btntype = 19
                
            elif button == AUI_BUTTON_PIN:
                btntype = 23

            elif button == AUI_BUTTON_MAXIMIZE_RESTORE:
                if not pane.IsMaximized():
                    btntype = 17
                else:
                    btntype = 21
            else:
                btntype = 15

            state = 4 # CBS_DISABLED
            
            if pane.state & optionActive:

                if button_state == AUI_BUTTON_STATE_NORMAL:
                    state = 1 # CBS_NORMAL

                elif button_state == AUI_BUTTON_STATE_HOVER:
                    state = 2 # CBS_HOT

                elif button_state == AUI_BUTTON_STATE_PRESSED:
                    state = 3 # CBS_PUSHED

                else:
                    raise Exception("ERROR: Unknown State.")

            else: # inactive pane

                if button_state == AUI_BUTTON_STATE_NORMAL:
                    state = 5 # CBS_NORMAL

                elif button_state == AUI_BUTTON_STATE_HOVER:
                    state = 6 # CBS_HOT

                elif button_state == AUI_BUTTON_STATE_PRESSED:
                    state = 7 # CBS_PUSHED

                else:
                    raise Exception("ERROR: Unknown State.")

            try:
                winxptheme.DrawThemeBackground(hTheme, dc.GetHDC(), btntype, state, (rc.top, rc.left, rc.right, rc.bottom), None)
            except TypeError:
                return

        else:

            # Fallback to default closebutton if themes are not enabled
            rect2 = wx.Rect(rect.x-4, rect.y+2, rect.width, rect.height)
            AuiDefaultDockArt.DrawPaneButton(self, dc, window, button, button_state, rect2, pane)


########NEW FILE########
__FILENAME__ = framemanager
# --------------------------------------------------------------------------- #
# AUI Library wxPython IMPLEMENTATION
#
# Original C++ Code From Kirix (wxAUI). You Can Find It At:
#
#    License: wxWidgets license
#
# http:#www.kirix.com/en/community/opensource/wxaui/about_wxaui.html
#
# Current wxAUI Version Tracked: wxWidgets 2.9.0 SVN HEAD
#
#
# Python Code By:
#
# Andrea Gavana, @ 23 Dec 2005
# Latest Revision: 01 Oct 2010, 23.00 GMT
#
# For All Kind Of Problems, Requests Of Enhancements And Bug Reports, Please
# Write To Me At:
#
# andrea.gavana@gmail.com
# gavana@kpo.kz
#
# Or, Obviously, To The wxPython Mailing List!!!
#
# End Of Comments
# --------------------------------------------------------------------------- #

"""
Description
===========

framemanager is the central module of the AUI class framework.

L{AuiManager} manages the panes associated with it for a particular `wx.Frame`, using
a pane's L{AuiPaneInfo} information to determine each pane's docking and floating
behavior. AuiManager uses wxPython' sizer mechanism to plan the layout of each frame.
It uses a replaceable dock art class to do all drawing, so all drawing is localized
in one area, and may be customized depending on an application's specific needs.

AuiManager works as follows: the programmer adds panes to the class, or makes
changes to existing pane properties (dock position, floating state, show state, etc...).
To apply these changes, AuiManager's L{AuiManager.Update} function is called. This batch
processing can be used to avoid flicker, by modifying more than one pane at a time,
and then "committing" all of the changes at once by calling `Update()`.

Panes can be added quite easily::

    text1 = wx.TextCtrl(self, -1)
    text2 = wx.TextCtrl(self, -1)
    self._mgr.AddPane(text1, AuiPaneInfo().Left().Caption("Pane Number One"))
    self._mgr.AddPane(text2, AuiPaneInfo().Bottom().Caption("Pane Number Two"))

    self._mgr.Update()


Later on, the positions can be modified easily. The following will  an
existing pane in a tool window::

    self._mgr.GetPane(text1).Float()


Layers, Rows and Directions, Positions
======================================

Inside AUI, the docking layout is figured out by checking several pane parameters.
Four of these are important for determining where a pane will end up.

**Direction** - Each docked pane has a direction, `Top`, `Bottom`, `Left`, `Right`, or `Center`.
This is fairly self-explanatory. The pane will be placed in the location specified
by this variable.

**Position** - More than one pane can be placed inside of a "dock". Imagine two panes
being docked on the left side of a window. One pane can be placed over another.
In proportionally managed docks, the pane position indicates it's sequential position,
starting with zero. So, in our scenario with two panes docked on the left side, the
top pane in the dock would have position 0, and the second one would occupy position 1. 

**Row** - A row can allow for two docks to be placed next to each other. One of the most
common places for this to happen is in the toolbar. Multiple toolbar rows are allowed,
the first row being in row 0, and the second in row 1. Rows can also be used on
vertically docked panes. 

**Layer** - A layer is akin to an onion. Layer 0 is the very center of the managed pane.
Thus, if a pane is in layer 0, it will be closest to the center window (also sometimes
known as the "content window"). Increasing layers "swallow up" all layers of a lower
value. This can look very similar to multiple rows, but is different because all panes
in a lower level yield to panes in higher levels. The best way to understand layers
is by running the AUI sample (`AUI.py`).
"""

__author__ = "Andrea Gavana <andrea.gavana@gmail.com>"
__date__ = "31 March 2009"


import wx
import time
import types
import warnings

import auibar
import auibook
import tabmdi
import dockart
import tabart

from aui_utilities import Clip, PaneCreateStippleBitmap, GetDockingImage, GetSlidingPoints

from aui_constants import *

# Define this as a translation function
_ = wx.GetTranslation

_winxptheme = False
if wx.Platform == "__WXMSW__":
    try:
        import winxptheme
        _winxptheme = True
    except ImportError:
        pass

# wxPython version string
_VERSION_STRING = wx.VERSION_STRING

# AUI Events
wxEVT_AUI_PANE_BUTTON = wx.NewEventType()
wxEVT_AUI_PANE_CLOSE = wx.NewEventType()
wxEVT_AUI_PANE_MAXIMIZE = wx.NewEventType()
wxEVT_AUI_PANE_RESTORE = wx.NewEventType()
wxEVT_AUI_RENDER = wx.NewEventType()
wxEVT_AUI_FIND_MANAGER = wx.NewEventType()
wxEVT_AUI_PANE_MINIMIZE = wx.NewEventType()
wxEVT_AUI_PANE_MIN_RESTORE = wx.NewEventType()
wxEVT_AUI_PANE_FLOATING = wx.NewEventType()
wxEVT_AUI_PANE_FLOATED = wx.NewEventType()
wxEVT_AUI_PANE_DOCKING = wx.NewEventType()
wxEVT_AUI_PANE_DOCKED = wx.NewEventType()
wxEVT_AUI_PERSPECTIVE_CHANGED = wx.NewEventType()

EVT_AUI_PANE_BUTTON = wx.PyEventBinder(wxEVT_AUI_PANE_BUTTON, 0)
""" Fires an event when the user left-clicks on a pane button. """
EVT_AUI_PANE_CLOSE = wx.PyEventBinder(wxEVT_AUI_PANE_CLOSE, 0)
""" A pane in `AuiManager` has been closed. """
EVT_AUI_PANE_MAXIMIZE = wx.PyEventBinder(wxEVT_AUI_PANE_MAXIMIZE, 0)
""" A pane in `AuiManager` has been maximized. """
EVT_AUI_PANE_RESTORE = wx.PyEventBinder(wxEVT_AUI_PANE_RESTORE, 0)
""" A pane in `AuiManager` has been restored from a maximized state. """
EVT_AUI_RENDER = wx.PyEventBinder(wxEVT_AUI_RENDER, 0)
""" Fires an event every time the AUI frame is being repainted. """
EVT_AUI_FIND_MANAGER = wx.PyEventBinder(wxEVT_AUI_FIND_MANAGER, 0)
""" Used to find which AUI manager is controlling a certain pane. """
EVT_AUI_PANE_MINIMIZE = wx.PyEventBinder(wxEVT_AUI_PANE_MINIMIZE, 0)
""" A pane in `AuiManager` has been minimized. """
EVT_AUI_PANE_MIN_RESTORE = wx.PyEventBinder(wxEVT_AUI_PANE_MIN_RESTORE, 0)
""" A pane in `AuiManager` has been restored from a minimized state. """
EVT_AUI_PANE_FLOATING = wx.PyEventBinder(wxEVT_AUI_PANE_FLOATING, 0)
""" A pane in `AuiManager` is about to be floated. """
EVT_AUI_PANE_FLOATED = wx.PyEventBinder(wxEVT_AUI_PANE_FLOATED, 0)
""" A pane in `AuiManager` has been floated. """
EVT_AUI_PANE_DOCKING = wx.PyEventBinder(wxEVT_AUI_PANE_DOCKING, 0)
""" A pane in `AuiManager` is about to be docked. """
EVT_AUI_PANE_DOCKED = wx.PyEventBinder(wxEVT_AUI_PANE_DOCKED, 0)
""" A pane in `AuiManager` has been docked. """
EVT_AUI_PERSPECTIVE_CHANGED = wx.PyEventBinder(wxEVT_AUI_PERSPECTIVE_CHANGED, 0)
""" The layout in `AuiManager` has been changed. """

# ---------------------------------------------------------------------------- #

class AuiDockInfo(object):
    """ A class to store all properties of a dock. """

    def __init__(self):
        """
        Default class constructor.
        Used internally, do not call it in your code!
        """

        object.__init__(self)
        
        self.dock_direction = 0
        self.dock_layer = 0
        self.dock_row = 0
        self.size = 0
        self.min_size = 0
        self.resizable = True
        self.fixed = False
        self.toolbar = False
        self.rect = wx.Rect()
        self.panes = []


    def IsOk(self):
        """
        Returns whether a dock is valid or not.

        In order to be valid, a dock needs to have a non-zero `dock_direction`.
        """

        return self.dock_direction != 0

    
    def IsHorizontal(self):
        """ Returns whether the dock is horizontal or not. """

        return self.dock_direction in [AUI_DOCK_TOP, AUI_DOCK_BOTTOM]


    def IsVertical(self):
        """ Returns whether the dock is vertical or not. """

        return self.dock_direction in [AUI_DOCK_LEFT, AUI_DOCK_RIGHT, AUI_DOCK_CENTER]
    

# ---------------------------------------------------------------------------- #

class AuiDockingGuideInfo(object):
    """ A class which holds information about VS2005 docking guide windows. """

    def __init__(self, other=None):
        """
        Default class constructor.
        Used internally, do not call it in your code!

        :param `other`: another instance of L{AuiDockingGuideInfo}.
        """

        if other:
            self.Assign(other)
        else:
            # window representing the docking target
            self.host = None
            # dock direction (top, bottom, left, right, center)
            self.dock_direction = AUI_DOCK_NONE


    def Assign(self, other):
        """
        Assigns the properties of the `other` L{AuiDockingGuideInfo} to `self`.

        :param `other`: another instance of L{AuiDockingGuideInfo}.
        """

        self.host = other.host
        self.dock_direction = other.dock_direction


    def Host(self, h):
        """
        Hosts a docking guide window.

        :param `h`: an instance of L{AuiSingleDockingGuide} or L{AuiCenterDockingGuide}.
        """

        self.host = h
        return self
    

    def Left(self):
        """ Sets the guide window to left docking. """

        self.dock_direction = AUI_DOCK_LEFT
        return self

    
    def Right(self):
        """ Sets the guide window to right docking. """

        self.dock_direction = AUI_DOCK_RIGHT
        return self 


    def Top(self):
        """ Sets the guide window to top docking. """

        self.dock_direction = AUI_DOCK_TOP
        return self 


    def Bottom(self):
        """ Sets the guide window to bottom docking. """

        self.dock_direction = AUI_DOCK_BOTTOM
        return self 


    def Center(self):
        """ Sets the guide window to center docking. """

        self.dock_direction = AUI_DOCK_CENTER
        return self 


    def Centre(self):
        """ Sets the guide window to centre docking. """
        
        self.dock_direction = AUI_DOCK_CENTRE
        return self


# ---------------------------------------------------------------------------- #

class AuiDockUIPart(object):
    """ A class which holds attributes for a UI part in the interface. """
    
    typeCaption = 0
    typeGripper = 1
    typeDock = 2
    typeDockSizer = 3
    typePane = 4
    typePaneSizer = 5
    typeBackground = 6
    typePaneBorder = 7
    typePaneButton = 8

    def __init__(self):
        """
        Default class constructor.
        Used internally, do not call it in your code!
        """
        
        self.orientation = wx.VERTICAL
        self.type = 0
        self.rect = wx.Rect()


# ---------------------------------------------------------------------------- #

class AuiPaneButton(object):
    """ A simple class which describes the caption pane button attributes. """

    def __init__(self, button_id):
        """
        Default class constructor.
        Used internally, do not call it in your code!

        :param `button_id`: the pane button identifier.
        """

        self.button_id = button_id


# ---------------------------------------------------------------------------- #

# event declarations/classes

class AuiManagerEvent(wx.PyCommandEvent):
    """ A specialized command event class for events sent by L{AuiManager}. """

    def __init__(self, eventType, id=1):
        """
        Default class constructor.

        :param `eventType`: the event kind;
        :param `id`: the event identification number.
        """

        wx.PyCommandEvent.__init__(self, eventType, id)

        self.manager = None
        self.pane = None
        self.button = 0
        self.veto_flag = False
        self.canveto_flag = True
        self.dc = None


    def SetManager(self, mgr):
        """
        Associates a L{AuiManager} to the current event.

        :param `mgr`: an instance of L{AuiManager}.
        """

        self.manager = mgr


    def SetDC(self, pdc):
        """
        Associates a `wx.DC` device context to this event.

        :param `pdc`: a `wx.DC` device context object. 
        """

        self.dc = pdc


    def SetPane(self, p):
        """
        Associates a L{AuiPaneInfo} instance to this event.

        :param `p`: a L{AuiPaneInfo} instance.
        """
        
        self.pane = p

        
    def SetButton(self, b):
        """
        Associates a L{AuiPaneButton} instance to this event.

        :param `b`: a L{AuiPaneButton} instance.
        """
        
        self.button = b

        
    def GetManager(self):
        """ Returns the associated L{AuiManager} (if any). """

        return self.manager


    def GetDC(self):
        """ Returns the associated `wx.DC` device context (if any). """

        return self.dc
    

    def GetPane(self):
        """ Returns the associated L{AuiPaneInfo} structure (if any). """
        
        return self.pane


    def GetButton(self):
        """ Returns the associated L{AuiPaneButton} instance (if any). """

        return self.button


    def Veto(self, veto=True):
        """
        Prevents the change announced by this event from happening.

        It is in general a good idea to notify the user about the reasons for
        vetoing the change because otherwise the applications behaviour (which
        just refuses to do what the user wants) might be quite surprising.

        :param `veto`: ``True`` to veto the event, ``False`` otherwise.
        """

        self.veto_flag = veto

        
    def GetVeto(self):
        """ Returns whether the event has been vetoed or not. """

        return self.veto_flag

    
    def SetCanVeto(self, can_veto):
        """
        Sets whether the event can be vetoed or not.

        :param `can_veto`: a bool flag. ``True`` if the event can be vetoed, ``False`` otherwise.
        """

        self.canveto_flag = can_veto

        
    def CanVeto(self):
        """ Returns whether the event can be vetoed and has been vetoed. """

        return  self.canveto_flag and self.veto_flag


# ---------------------------------------------------------------------------- #

class AuiPaneInfo(object):
    """
    AuiPaneInfo specifies all the parameters for a pane. These parameters specify where
    the pane is on the screen, whether it is docked or floating, or hidden. In addition,
    these parameters specify the pane's docked position, floating position, preferred
    size, minimum size, caption text among many other parameters.
    """
    
    optionFloating         = 2**0
    optionHidden           = 2**1
    optionLeftDockable     = 2**2
    optionRightDockable    = 2**3
    optionTopDockable      = 2**4
    optionBottomDockable   = 2**5
    optionFloatable        = 2**6
    optionMovable          = 2**7
    optionResizable        = 2**8
    optionPaneBorder       = 2**9
    optionCaption          = 2**10
    optionGripper          = 2**11
    optionDestroyOnClose   = 2**12
    optionToolbar          = 2**13
    optionActive           = 2**14
    optionGripperTop       = 2**15
    optionMaximized        = 2**16
    optionDockFixed        = 2**17
    optionNotebookDockable = 2**18
    optionMinimized        = 2**19
    optionLeftSnapped      = 2**20
    optionRightSnapped     = 2**21
    optionTopSnapped       = 2**22
    optionBottomSnapped    = 2**23
    optionFlyOut           = 2**24
    optionCaptionLeft      = 2**25

    buttonClose            = 2**26
    buttonMaximize         = 2**27
    buttonMinimize         = 2**28
    buttonPin              = 2**29
    
    buttonCustom1          = 2**30
    buttonCustom2          = 2**31
    buttonCustom3          = 2**32

    savedHiddenState       = 2**33    # used internally
    actionPane             = 2**34    # used internally
    wasMaximized           = 2**35    # used internally
    needsRestore           = 2**36    # used internally


    def __init__(self):
        """ Default class constructor. """
        
        self.window = None
        self.frame = None
        self.state = 0
        self.dock_direction = AUI_DOCK_LEFT
        self.dock_layer = 0
        self.dock_row = 0
        self.dock_pos = 0
        self.minimize_mode = AUI_MINIMIZE_POS_SMART
        self.floating_pos = wx.Point(-1, -1)
        self.floating_size = wx.Size(-1, -1)
        self.best_size = wx.Size(-1, -1)
        self.min_size = wx.Size(-1, -1)
        self.max_size = wx.Size(-1, -1)
        self.dock_proportion = 0
        self.caption = ""
        self.buttons = []
        self.name = ""
        self.icon = wx.NullIcon
        self.rect = wx.Rect()
        self.notebook_id = -1
        self.transparent = 255
        self.needsTransparency = False
        self.previousDockPos = None
        self.previousDockSize = 0
        self.snapped = 0
        
        self.DefaultPane()
        
    
    def dock_direction_get(self):
        """
        Getter for the `dock_direction`.

        :see: L{dock_direction_set} for a set of valid docking directions.
        """
        
        if self.IsMaximized():
            return AUI_DOCK_CENTER
        else:
            return self._dock_direction


    def dock_direction_set(self, value):
        """
        Setter for the `dock_direction`.

        :param `value`: the docking direction. This cab ne one of the following bits:

        ============================ ======= =============================================
        Dock Flag                     Value  Description
        ============================ ======= =============================================
        ``AUI_DOCK_NONE``                  0 No docking direction.
        ``AUI_DOCK_TOP``                   1 Top docking direction.
        ``AUI_DOCK_RIGHT``                 2 Right docking direction.
        ``AUI_DOCK_BOTTOM``                3 Bottom docking direction.
        ``AUI_DOCK_LEFT``                  4 Left docking direction.
        ``AUI_DOCK_CENTER``                5 Center docking direction.
        ``AUI_DOCK_CENTRE``                5 Centre docking direction.
        ``AUI_DOCK_NOTEBOOK_PAGE``         6 Automatic AuiNotebooks docking style.
        ============================ ======= =============================================
        
        """
        
        self._dock_direction = value
        
    dock_direction = property(dock_direction_get, dock_direction_set)

    def IsOk(self):
        """
        Returns ``True`` if the L{AuiPaneInfo} structure is valid.

        :note: A pane structure is valid if it has an associated window.
        """
        
        return self.window != None


    def IsMaximized(self):
        """ Returns ``True`` if the pane is maximized. """
        
        return self.HasFlag(self.optionMaximized)


    def IsMinimized(self):
        """ Returns ``True`` if the pane is minimized. """

        return self.HasFlag(self.optionMinimized)


    def IsFixed(self):
        """ Returns ``True`` if the pane cannot be resized. """
        
        return not self.HasFlag(self.optionResizable)

    
    def IsResizeable(self):
        """ Returns ``True`` if the pane can be resized. """
        
        return self.HasFlag(self.optionResizable)

    
    def IsShown(self):
        """ Returns ``True`` if the pane is currently shown. """
        
        return not self.HasFlag(self.optionHidden)

    
    def IsFloating(self):
        """ Returns ``True`` if the pane is floating. """

        return self.HasFlag(self.optionFloating)

    
    def IsDocked(self):
        """ Returns ``True`` if the pane is docked. """
        
        return not self.HasFlag(self.optionFloating)

    
    def IsToolbar(self):
        """ Returns ``True`` if the pane contains a toolbar. """

        return self.HasFlag(self.optionToolbar)

    
    def IsTopDockable(self):
        """
        Returns ``True`` if the pane can be docked at the top
        of the managed frame.
        """
        
        return self.HasFlag(self.optionTopDockable)

    
    def IsBottomDockable(self):
        """
        Returns ``True`` if the pane can be docked at the bottom
        of the managed frame.
        """
        
        return self.HasFlag(self.optionBottomDockable)

    
    def IsLeftDockable(self):
        """
        Returns ``True`` if the pane can be docked at the left
        of the managed frame.
        """
        
        return self.HasFlag(self.optionLeftDockable) 


    def IsRightDockable(self):
        """
        Returns ``True`` if the pane can be docked at the right
        of the managed frame.
        """
        
        return self.HasFlag(self.optionRightDockable)


    def IsDockable(self):
        """ Returns ``True`` if the pane can be docked. """
        
        return self.IsTopDockable() or self.IsBottomDockable() or self.IsLeftDockable() or \
               self.IsRightDockable() or self.IsNotebookDockable()
    
    
    def IsFloatable(self):
        """
        Returns ``True`` if the pane can be undocked and displayed as a
        floating window.
        """

        return self.HasFlag(self.optionFloatable)

    
    def IsMovable(self):
        """
        Returns ``True`` if the docked frame can be undocked or moved to
        another dock position.
        """
        
        return self.HasFlag(self.optionMovable)


    def IsDestroyOnClose(self):
        """
        Returns ``True`` if the pane should be destroyed when it is closed.
        
        Normally a pane is simply hidden when the close button is clicked. Calling L{DestroyOnClose}
        with a ``True`` input parameter will cause the window to be destroyed when the user clicks
        the pane's close button.
        """
        
        return self.HasFlag(self.optionDestroyOnClose)
    

    def IsNotebookDockable(self):
        """
        Returns ``True`` if a pane can be docked on top to another to create a
        L{AuiNotebook}.
        """

        return self.HasFlag(self.optionNotebookDockable)
    

    def IsTopSnappable(self):
        """ Returns ``True`` if the pane can be snapped at the top of the managed frame. """
        
        return self.HasFlag(self.optionTopSnapped)

    
    def IsBottomSnappable(self):
        """ Returns ``True`` if the pane can be snapped at the bottom of the managed frame. """
        
        return self.HasFlag(self.optionBottomSnapped)

    
    def IsLeftSnappable(self):
        """ Returns ``True`` if the pane can be snapped on the left of the managed frame. """
        
        return self.HasFlag(self.optionLeftSnapped) 


    def IsRightSnappable(self):
        """ Returns ``True`` if the pane can be snapped on the right of the managed frame. """
        
        return self.HasFlag(self.optionRightSnapped)


    def IsSnappable(self):
        """ Returns ``True`` if the pane can be snapped. """
        
        return self.IsTopSnappable() or self.IsBottomSnappable() or self.IsLeftSnappable() or \
               self.IsRightSnappable()


    def IsFlyOut(self):
        """ Returns ``True`` if the floating pane has a "fly-out" effect. """

        return self.HasFlag(self.optionFlyOut)        
            

    def HasCaption(self):
        """ Returns ``True`` if the pane displays a caption. """
        
        return self.HasFlag(self.optionCaption)

    
    def HasCaptionLeft(self):
        """ Returns ``True`` if the pane displays a caption on the left (rotated by 90 degrees). """
        
        return self.HasFlag(self.optionCaptionLeft)


    def HasGripper(self):
        """ Returns ``True`` if the pane displays a gripper. """
        
        return self.HasFlag(self.optionGripper) 


    def HasBorder(self):
        """ Returns ``True`` if the pane displays a border. """
        
        return self.HasFlag(self.optionPaneBorder)

    
    def HasCloseButton(self):
        """ Returns ``True`` if the pane displays a button to close the pane. """

        return self.HasFlag(self.buttonClose) 


    def HasMaximizeButton(self):
        """ Returns ``True`` if the pane displays a button to maximize the pane. """
        
        return self.HasFlag(self.buttonMaximize)

    
    def HasMinimizeButton(self):
        """ Returns ``True`` if the pane displays a button to minimize the pane. """
        
        return self.HasFlag(self.buttonMinimize) 


    def GetMinimizeMode(self):
        """
        Returns the minimization style for this pane.

        Possible return values are:

        ============================== ========= ==============================
        Minimize Mode Flag             Hex Value Description
        ============================== ========= ==============================
        ``AUI_MINIMIZE_POS_SMART``          0x01 Minimizes the pane on the closest tool bar
        ``AUI_MINIMIZE_POS_TOP``            0x02 Minimizes the pane on the top tool bar
        ``AUI_MINIMIZE_POS_LEFT``           0x03 Minimizes the pane on its left tool bar
        ``AUI_MINIMIZE_POS_RIGHT``          0x04 Minimizes the pane on its right tool bar
        ``AUI_MINIMIZE_POS_BOTTOM``         0x05 Minimizes the pane on its bottom tool bar
        ``AUI_MINIMIZE_POS_MASK``           0x07 Mask to filter the position flags
        ``AUI_MINIMIZE_CAPT_HIDE``           0x0 Hides the caption of the minimized pane
        ``AUI_MINIMIZE_CAPT_SMART``         0x08 Displays the caption in the best rotation (horizontal or clockwise)
        ``AUI_MINIMIZE_CAPT_HORZ``          0x10 Displays the caption horizontally
        ``AUI_MINIMIZE_CAPT_MASK``          0x18 Mask to filter the caption flags
        ============================== ========= ==============================

        The flags can be filtered with the following masks:

        ============================== ========= ==============================
        Minimize Mask Flag             Hex Value Description
        ============================== ========= ==============================        
        ``AUI_MINIMIZE_POS_MASK``           0x07 Filters the position flags
        ``AUI_MINIMIZE_CAPT_MASK``          0x18 Filters the caption flags
        ============================== ========= ==============================

        """
        
        return self.minimize_mode
    

    def HasPinButton(self):
        """ Returns ``True`` if the pane displays a button to float the pane. """
        
        return self.HasFlag(self.buttonPin) 


    def HasGripperTop(self):
        """ Returns ``True`` if the pane displays a gripper at the top. """

        return self.HasFlag(self.optionGripperTop)


    def Window(self, w):
        """
        Associate a `wx.Window` derived window to this pane.

        This normally does not need to be specified, as the window pointer is
        automatically assigned to the L{AuiPaneInfo} structure as soon as it is
        added to the manager.

        :param `w`: a `wx.Window` derived window.
        """

        self.window = w
        return self

    
    def Name(self, name):
        """
        Sets the name of the pane so it can be referenced in lookup functions.

        If a name is not specified by the user, a random name is assigned to the pane
        when it is added to the manager.

        :param `name`: a string specifying the pane name.

        :warning: If you are using L{AuiManager.SavePerspective} and L{AuiManager.LoadPerspective}, you will have
         to specify a name for your pane using L{Name}, as randomly generated names can
         not be properly restored.
        """

        self.name = name
        return self

    
    def Caption(self, caption):
        """
        Sets the caption of the pane.

        :param `caption`: a string specifying the pane caption.
        """
        
        self.caption = caption
        return self

    
    def Left(self):
        """ 
        Sets the pane dock position to the left side of the frame.

        :note: This is the same thing as calling L{Direction} with ``AUI_DOCK_LEFT`` as
         parameter.
        """
        
        self.dock_direction = AUI_DOCK_LEFT
        return self

    
    def Right(self):
        """
        Sets the pane dock position to the right side of the frame.

        :note: This is the same thing as calling L{Direction} with ``AUI_DOCK_RIGHT`` as
         parameter.
        """
        
        self.dock_direction = AUI_DOCK_RIGHT
        return self

    
    def Top(self):
        """
        Sets the pane dock position to the top of the frame.

        :note: This is the same thing as calling L{Direction} with ``AUI_DOCK_TOP`` as
         parameter.
        """

        self.dock_direction = AUI_DOCK_TOP
        return self

    
    def Bottom(self):
        """
        Sets the pane dock position to the bottom of the frame.

        :note: This is the same thing as calling L{Direction} with ``AUI_DOCK_BOTTOM`` as
         parameter.
        """

        self.dock_direction = AUI_DOCK_BOTTOM
        return self

    
    def Center(self):
        """
        Sets the pane to the center position of the frame.

        The centre pane is the space in the middle after all border panes (left, top,
        right, bottom) are subtracted from the layout.

        :note: This is the same thing as calling L{Direction} with ``AUI_DOCK_CENTER`` as
         parameter.
        """
        
        self.dock_direction = AUI_DOCK_CENTER
        return self

        
    def Centre(self):
        """
        Sets the pane to the center position of the frame.

        The centre pane is the space in the middle after all border panes (left, top,
        right, bottom) are subtracted from the layout.

        :note: This is the same thing as calling L{Direction} with ``AUI_DOCK_CENTRE`` as
         parameter.
        """
        
        self.dock_direction = AUI_DOCK_CENTRE
        return self

    
    def Direction(self, direction):
        """
        Determines the direction of the docked pane. It is functionally the
        same as calling L{Left}, L{Right}, L{Top} or L{Bottom}, except that docking direction
        may be specified programmatically via the parameter `direction`.

        :param `direction`: the direction of the docked pane.

        :see: L{dock_direction_set} for a list of valid docking directions.        
        """
        
        self.dock_direction = direction
        return self

    
    def Layer(self, layer):
        """
        Determines the layer of the docked pane.

        The dock layer is similar to an onion, the inner-most layer being layer 0. Each
        shell moving in the outward direction has a higher layer number. This allows for
        more complex docking layout formation.

        :param `layer`: the layer of the docked pane.
        """
        
        self.dock_layer = layer
        return self

    
    def Row(self, row):
        """
        Determines the row of the docked pane.

        :param `row`: the row of the docked pane.
        """
        
        self.dock_row = row
        return self

    
    def Position(self, pos):
        """
        Determines the position of the docked pane.

        :param `pos`: the position of the docked pane.
        """

        self.dock_pos = pos
        return self


    def MinSize(self, arg1=None, arg2=None):
        """
        Sets the minimum size of the pane.

        This method is split in 2 versions depending on the input type. If `arg1` is
        a `wx.Size` object, then L{MinSize1} is called. Otherwise, L{MinSize2} is called.

        :param `arg1`: a `wx.Size` object, a (x, y) tuple or or a `x` coordinate.
        :param `arg2`: a `y` coordinate (only if `arg1` is a `x` coordinate, otherwise unused).
        """
        
        if isinstance(arg1, wx.Size):
            ret = self.MinSize1(arg1)
        elif isinstance(arg1, types.TupleType):
            ret = self.MinSize1(wx.Size(*arg1))
        else:
            ret = self.MinSize2(arg1, arg2)

        return ret

    
    def MinSize1(self, size):
        """
        Sets the minimum size of the pane.

        :see: L{MinSize} for an explanation of input parameters.
        """
        self.min_size = size
        return self


    def MinSize2(self, x, y):
        """
        Sets the minimum size of the pane.

        :see: L{MinSize} for an explanation of input parameters.
        """

        self.min_size = wx.Size(x, y)
        return self


    def MaxSize(self, arg1=None, arg2=None):
        """
        Sets the maximum size of the pane.

        This method is split in 2 versions depending on the input type. If `arg1` is
        a `wx.Size` object, then L{MaxSize1} is called. Otherwise, L{MaxSize2} is called.

        :param `arg1`: a `wx.Size` object, a (x, y) tuple or a `x` coordinate.
        :param `arg2`: a `y` coordinate (only if `arg1` is a `x` coordinate, otherwise unused).
        """
        
        if isinstance(arg1, wx.Size):
            ret = self.MaxSize1(arg1)
        elif isinstance(arg1, types.TupleType):
            ret = self.MaxSize1(wx.Size(*arg1))
        else:
            ret = self.MaxSize2(arg1, arg2)

        return ret
    
    
    def MaxSize1(self, size):
        """
        Sets the maximum size of the pane.

        :see: L{MaxSize} for an explanation of input parameters.
        """

        self.max_size = size
        return self


    def MaxSize2(self, x, y):
        """
        Sets the maximum size of the pane.

        :see: L{MaxSize} for an explanation of input parameters.
        """

        self.max_size.Set(x,y)
        return self


    def BestSize(self, arg1=None, arg2=None):
        """
        Sets the ideal size for the pane. The docking manager will attempt to use
        this size as much as possible when docking or floating the pane.

        This method is split in 2 versions depending on the input type. If `arg1` is
        a `wx.Size` object, then L{BestSize1} is called. Otherwise, L{BestSize2} is called.

        :param `arg1`: a `wx.Size` object, a (x, y) tuple or a `x` coordinate.
        :param `arg2`: a `y` coordinate (only if `arg1` is a `x` coordinate, otherwise unused).
        """
        
        if isinstance(arg1, wx.Size):
            ret = self.BestSize1(arg1)
        elif isinstance(arg1, types.TupleType):
            ret = self.BestSize1(wx.Size(*arg1))
        else:
            ret = self.BestSize2(arg1, arg2)

        return ret
    
            
    def BestSize1(self, size):
        """
        Sets the best size of the pane.

        :see: L{BestSize} for an explanation of input parameters.
        """

        self.best_size = size
        return self

    
    def BestSize2(self, x, y):
        """
        Sets the best size of the pane.

        :see: L{BestSize} for an explanation of input parameters.
        """

        self.best_size.Set(x,y)
        return self
    
    
    def FloatingPosition(self, pos):
        """
        Sets the position of the floating pane.

        :param `pos`: a `wx.Point` or a tuple indicating the pane floating position.
        """
        
        self.floating_pos = wx.Point(*pos)
        return self

    
    def FloatingSize(self, size):
        """
        Sets the size of the floating pane.

        :param `size`: a `wx.Size` or a tuple indicating the pane floating size.
        """
        
        self.floating_size = wx.Size(*size)
        return self


    def Maximize(self):
        """ Makes the pane take up the full area."""

        return self.SetFlag(self.optionMaximized, True)


    def Minimize(self):
        """
        Makes the pane minimized in a L{AuiToolBar}.

        Clicking on the minimize button causes a new L{AuiToolBar} to be created
        and added to the frame manager, (currently the implementation is such that
        panes at West will have a toolbar at the right, panes at South will have
        toolbars at the bottom etc...) and the pane is hidden in the manager.
        
        Clicking on the restore button on the newly created toolbar will result in the
        toolbar being removed and the original pane being restored.
        """
        
        return self.SetFlag(self.optionMinimized, True)


    def MinimizeMode(self, mode):
        """
        Sets the expected minimized mode if the MinimizeButton() is visible.

        The minimized pane can have a specific position in the work space:

        ============================== ========= ==============================
        Minimize Mode Flag             Hex Value Description
        ============================== ========= ==============================
        ``AUI_MINIMIZE_POS_SMART``          0x01 Minimizes the pane on the closest tool bar
        ``AUI_MINIMIZE_POS_TOP``            0x02 Minimizes the pane on the top tool bar
        ``AUI_MINIMIZE_POS_LEFT``           0x03 Minimizes the pane on its left tool bar
        ``AUI_MINIMIZE_POS_RIGHT``          0x04 Minimizes the pane on its right tool bar
        ``AUI_MINIMIZE_POS_BOTTOM``         0x05 Minimizes the pane on its bottom tool bar
        ============================== ========= ==============================

        The caption of the minimized pane can be displayed in different modes:

        ============================== ========= ==============================
        Caption Mode Flag              Hex Value Description
        ============================== ========= ==============================
        ``AUI_MINIMIZE_CAPT_HIDE``           0x0 Hides the caption of the minimized pane
        ``AUI_MINIMIZE_CAPT_SMART``         0x08 Displays the caption in the best rotation (horizontal in the top and in the bottom tool bar or clockwise in the right and in the left tool bar)
        ``AUI_MINIMIZE_CAPT_HORZ``          0x10 Displays the caption horizontally
        ============================== ========= ==============================
        
        """
        
        self.minimize_mode = mode
        return self
    

    def Restore(self):
        """ Is the reverse of L{Maximize} and L{Minimize}."""
        
        return self.SetFlag(self.optionMaximized or self.optionMinimized, False)

    
    def Fixed(self):
        """
        Forces a pane to be fixed size so that it cannot be resized.
        After calling L{Fixed}, L{IsFixed} will return ``True``.
        """
        
        return self.SetFlag(self.optionResizable, False)

    
    def Resizable(self, resizable=True):
        """
        Allows a pane to be resizable if `resizable` is ``True``, and forces
        it to be a fixed size if `resizeable` is ``False``.

        If `resizable` is ``False``, this is simply an antonym for L{Fixed}.

        :param `resizable`: whether the pane will be resizeable or not.
        """
        
        return self.SetFlag(self.optionResizable, resizable)


    def Transparent(self, alpha):
        """
        Makes the pane transparent when floating.

        :param `alpha`: an integer value between 0 and 255 for pane transparency.
        """

        if alpha < 0 or alpha > 255:
            raise Exception("Invalid transparency value (%s)"%repr(alpha))
                            
        self.transparent = alpha
        self.needsTransparency = True

    
    def Dock(self):
        """
        Indicates that a pane should be docked. It is the opposite of L{Float}.
        """

        if self.IsNotebookPage():
            self.notebook_id = -1
            self.dock_direction = AUI_DOCK_NONE
        
        return self.SetFlag(self.optionFloating, False)

    
    def Float(self):
        """
        Indicates that a pane should be floated. It is the opposite of L{Dock}.
        """

        if self.IsNotebookPage():
            self.notebook_id = -1
            self.dock_direction = AUI_DOCK_NONE

        return self.SetFlag(self.optionFloating, True)

    
    def Hide(self):
        """
        Indicates that a pane should be hidden.

        Calling L{Show} (``False``) achieve the same effect.
        """
        
        return self.SetFlag(self.optionHidden, True)

    
    def Show(self, show=True):
        """
        Indicates that a pane should be shown.

        :param `show`: whether the pane should be shown or not.
        """
        
        return self.SetFlag(self.optionHidden, not show)
    

    # By defaulting to 1000, the tab will get placed at the end
    def NotebookPage(self, id, tab_position=1000):
        """
        Forces a pane to be a notebook page, so that the pane can be
        docked on top to another to create a L{AuiNotebook}.

        :param `id`: the notebook id;
        :param `tab_position`: the tab number of the pane once docked in a notebook.
        """
        
        # Remove any floating frame
        self.Dock()
        self.notebook_id = id
        self.dock_pos = tab_position
        self.dock_row = 0
        self.dock_layer = 0
        self.dock_direction = AUI_DOCK_NOTEBOOK_PAGE

        return self


    def NotebookControl(self, id):
        """
        Forces a pane to be a notebook control (L{AuiNotebook}).

        :param `id`: the notebook id.
        """

        self.notebook_id = id
        self.window = None
        self.buttons = []
        
        if self.dock_direction == AUI_DOCK_NOTEBOOK_PAGE:
            self.dock_direction = AUI_DOCK_NONE
            
        return self
    

    def HasNotebook(self):
        """ Returns whether a pane has a L{AuiNotebook} or not. """

        return self.notebook_id >= 0


    def IsNotebookPage(self):
        """ Returns whether the pane is a notebook page in a L{AuiNotebook}. """

        return self.notebook_id >= 0 and self.dock_direction == AUI_DOCK_NOTEBOOK_PAGE


    def IsNotebookControl(self):
        """ Returns whether the pane is a notebook control (L{AuiNotebook}). """

        return not self.IsNotebookPage() and self.HasNotebook()


    def SetNameFromNotebookId(self):
        """ Sets the pane name once docked in a L{AuiNotebook} using the notebook id. """

        if self.notebook_id >= 0:
            self.name = "__notebook_%d"%self.notebook_id
            
        return self


    def CaptionVisible(self, visible=True, left=False):
        """
        Indicates that a pane caption should be visible. If `visible` is ``False``, no pane
        caption is drawn.

        :param `visible`: whether the caption should be visible or not;
        :param `left`: whether the caption should be drawn on the left (rotated by 90 degrees) or not.
        """

        if left:
            self.SetFlag(self.optionCaption, False)
            return self.SetFlag(self.optionCaptionLeft, visible)

        self.SetFlag(self.optionCaptionLeft, False)
        return self.SetFlag(self.optionCaption, visible)

    
    def PaneBorder(self, visible=True):
        """
        Indicates that a border should be drawn for the pane.

        :param `visible`: whether the pane border should be visible or not.
        """
        
        return self.SetFlag(self.optionPaneBorder, visible)

    
    def Gripper(self, visible=True):
        """
        Indicates that a gripper should be drawn for the pane.

        :param `visible`: whether the gripper should be visible or not.
        """
        
        return self.SetFlag(self.optionGripper, visible)


    def GripperTop(self, attop=True):
        """
        Indicates that a gripper should be drawn at the top of the pane.

        :param `attop`: whether the gripper should be drawn at the top or not.
        """
        
        return self.SetFlag(self.optionGripperTop, attop)

    
    def CloseButton(self, visible=True):
        """
        Indicates that a close button should be drawn for the pane.

        :param `visible`: whether the close button should be visible or not.
        """
        
        return self.SetFlag(self.buttonClose, visible)

    
    def MaximizeButton(self, visible=True):
        """
        Indicates that a maximize button should be drawn for the pane.

        :param `visible`: whether the maximize button should be visible or not.
        """
        
        return self.SetFlag(self.buttonMaximize, visible)

    
    def MinimizeButton(self, visible=True):
        """
        Indicates that a minimize button should be drawn for the pane.

        :param `visible`: whether the minimize button should be visible or not.
        """

        return self.SetFlag(self.buttonMinimize, visible)

    
    def PinButton(self, visible=True):
        """
        Indicates that a pin button should be drawn for the pane.

        :param `visible`: whether the pin button should be visible or not.
        """
        
        return self.SetFlag(self.buttonPin, visible)

    
    def DestroyOnClose(self, b=True):
        """
        Indicates whether a pane should be destroyed when it is closed.

        Normally a pane is simply hidden when the close button is clicked. Setting
        `b` to ``True`` will cause the window to be destroyed when the user clicks
        the pane's close button.

        :param `b`: whether the pane should be destroyed when it is closed or not.
        """
        
        return self.SetFlag(self.optionDestroyOnClose, b)

    
    def TopDockable(self, b=True):
        """
        Indicates whether a pane can be docked at the top of the frame.

        :param `b`: whether the pane can be docked at the top or not.
        """
        
        return self.SetFlag(self.optionTopDockable, b)

    
    def BottomDockable(self, b=True):
        """
        Indicates whether a pane can be docked at the bottom of the frame.

        :param `b`: whether the pane can be docked at the bottom or not.
        """
        
        return self.SetFlag(self.optionBottomDockable, b)

    
    def LeftDockable(self, b=True):
        """
        Indicates whether a pane can be docked on the left of the frame.

        :param `b`: whether the pane can be docked at the left or not.
        """

        return self.SetFlag(self.optionLeftDockable, b)

    
    def RightDockable(self, b=True):
        """
        Indicates whether a pane can be docked on the right of the frame.

        :param `b`: whether the pane can be docked at the right or not.
        """
        
        return self.SetFlag(self.optionRightDockable, b)

    
    def Floatable(self, b=True):
        """
        Sets whether the user will be able to undock a pane and turn it
        into a floating window.

        :param `b`: whether the pane can be floated or not.
        """
        
        return self.SetFlag(self.optionFloatable, b)

    
    def Movable(self, b=True):
        """
        Indicates whether a pane can be moved.

        :param `b`: whether the pane can be moved or not.
        """
        
        return self.SetFlag(self.optionMovable, b)


    def NotebookDockable(self, b=True):
        """
        Indicates whether a pane can be docked in an automatic L{AuiNotebook}.

        :param `b`: whether the pane can be docked in a notebook or not.
        """
        
        return self.SetFlag(self.optionNotebookDockable, b)
                                  

    def DockFixed(self, b=True):
        """
        Causes the containing dock to have no resize sash. This is useful
        for creating panes that span the entire width or height of a dock, but should
        not be resizable in the other direction.

        :param `b`: whether the pane will have a resize sash or not.
        """

        return self.SetFlag(self.optionDockFixed, b)

                                   
    def Dockable(self, b=True):
        """
        Specifies whether a frame can be docked or not. It is the same as specifying
        L{TopDockable} . L{BottomDockable} . L{LeftDockable} . L{RightDockable} .

        :param `b`: whether the frame can be docked or not.
        """

        return self.TopDockable(b).BottomDockable(b).LeftDockable(b).RightDockable(b)
    

    def TopSnappable(self, b=True):
        """
        Indicates whether a pane can be snapped at the top of the main frame.

        :param `b`: whether the pane can be snapped at the top of the main frame or not.
        """
        
        return self.SetFlag(self.optionTopSnapped, b)

    
    def BottomSnappable(self, b=True):
        """
        Indicates whether a pane can be snapped at the bottom of the main frame.

        :param `b`: whether the pane can be snapped at the bottom of the main frame or not.
        """
        
        return self.SetFlag(self.optionBottomSnapped, b)

    
    def LeftSnappable(self, b=True):
        """
        Indicates whether a pane can be snapped on the left of the main frame.

        :param `b`: whether the pane can be snapped at the left of the main frame or not.
        """

        return self.SetFlag(self.optionLeftSnapped, b)

    
    def RightSnappable(self, b=True):
        """
        Indicates whether a pane can be snapped on the right of the main frame.

        :param `b`: whether the pane can be snapped at the right of the main frame or not.
        """
        
        return self.SetFlag(self.optionRightSnapped, b)


    def Snappable(self, b=True):
        """
        Indicates whether a pane can be snapped on the main frame. This is
        equivalent as calling L{TopSnappable} . L{BottomSnappable} . L{LeftSnappable} . L{RightSnappable} .

        :param `b`: whether the pane can be snapped on the main frame or not.
        """
    
        return self.TopSnappable(b).BottomSnappable(b).LeftSnappable(b).RightSnappable(b)


    def FlyOut(self, b=True):
        """
        Indicates whether a pane, when floating, has a "fly-out" effect
        (i.e., floating panes which only show themselves when moused over).

        :param `b`: whether the pane can be snapped on the main frame or not.
        """

        return self.SetFlag(self.optionFlyOut, b)
    
    
    # Copy over the members that pertain to docking position
    def SetDockPos(self, source):
        """
        Copies the `source` pane members that pertain to docking position to `self`.

        :param `source`: the source pane from where to copy the attributes.
        """
        
        self.dock_direction = source.dock_direction
        self.dock_layer = source.dock_layer
        self.dock_row = source.dock_row
        self.dock_pos = source.dock_pos
        self.dock_proportion = source.dock_proportion
        self.floating_pos = wx.Point(*source.floating_pos)
        self.floating_size = wx.Size(*source.floating_size)
        self.rect = wx.Rect(*source.rect)
        
        return self


    def DefaultPane(self):
        """ Specifies that the pane should adopt the default pane settings. """
        
        state = self.state    
        state |= self.optionTopDockable | self.optionBottomDockable | \
                 self.optionLeftDockable | self.optionRightDockable | \
                 self.optionNotebookDockable | \
                 self.optionFloatable | self.optionMovable | self.optionResizable | \
                 self.optionCaption | self.optionPaneBorder | self.buttonClose

        self.state = state
        
        return self
    
    
    def CentrePane(self):
        """
        Specifies that the pane should adopt the default center pane settings.

        Centre panes usually do not have caption bars. This function provides an easy way of
        preparing a pane to be displayed in the center dock position.
        """
        
        return self.CenterPane()

    
    def CenterPane(self):
        """
        Specifies that the pane should adopt the default center pane settings.

        Centre panes usually do not have caption bars. This function provides an easy way of
        preparing a pane to be displayed in the center dock position.
        """
        
        self.state = 0
        return self.Center().PaneBorder().Resizable()
    
     
    def ToolbarPane(self):
        """ Specifies that the pane should adopt the default toolbar pane settings. """
        
        self.DefaultPane()
        state = self.state
        
        state |= (self.optionToolbar | self.optionGripper)
        state &= ~(self.optionResizable | self.optionCaption | self.optionCaptionLeft)
        
        if self.dock_layer == 0:
            self.dock_layer = 10

        self.state = state
        
        return self


    def Icon(self, icon):
        """
        Specifies whether an icon is drawn on the left of the caption text when
        the pane is docked. If `icon` is ``None`` or `wx.NullIcon`, no icon is drawn on
        the caption space.

        :param icon: an icon to draw on the caption space, or ``None``.
        """

        if icon is None:
            icon = wx.NullIcon
            
        self.icon = icon
        return self        
    

    def SetFlag(self, flag, option_state):
        """
        Turns the property given by `flag` on or off with the `option_state`
        parameter.

        :param `flag`: the property to set;
        :param `option_state`: either ``True`` or ``False``.
        """
        
        state = self.state
        
        if option_state:
            state |= flag
        else:
            state &= ~flag

        self.state = state

        if flag in [self.buttonClose, self.buttonMaximize, self.buttonMinimize, self.buttonPin]:
            self.ResetButtons()
            
        return self
    
    
    def HasFlag(self, flag):
        """
        Returns ``True`` if the the property specified by flag is active for the pane.

        :param `flag`: the property to check for activity.
        """
        
        return (self.state & flag and [True] or [False])[0]


    def ResetButtons(self):
        """
        Resets all the buttons and recreates them from scratch depending on the
        L{AuiPaneInfo} flags.
        """

        floating = self.HasFlag(self.optionFloating)
        self.buttons = []

        if not floating and self.HasMinimizeButton():
            button = AuiPaneButton(AUI_BUTTON_MINIMIZE)
            self.buttons.append(button)
    
        if not floating and self.HasMaximizeButton():
            button = AuiPaneButton(AUI_BUTTON_MAXIMIZE_RESTORE)
            self.buttons.append(button)

        if not floating and self.HasPinButton():
            button = AuiPaneButton(AUI_BUTTON_PIN)
            self.buttons.append(button)

        if self.HasCloseButton():
            button = AuiPaneButton(AUI_BUTTON_CLOSE)
            self.buttons.append(button)
        

    def CountButtons(self):
        """ Returns the number of visible buttons in the docked pane. """

        n = 0
        
        if self.HasCaption() or self.HasCaptionLeft():
            if isinstance(wx.GetTopLevelParent(self.window), AuiFloatingFrame):
                return 1
            
            if self.HasCloseButton():
                n += 1
            if self.HasMaximizeButton():
                n += 1
            if self.HasMinimizeButton():
                n += 1
            if self.HasPinButton():
                n += 1

        return n
    

    def IsHorizontal(self):
        """ Returns ``True`` if the pane `dock_direction` is horizontal. """

        return self.dock_direction in [AUI_DOCK_TOP, AUI_DOCK_BOTTOM]

    def IsVertical(self):
        """ Returns ``True`` if the pane `dock_direction` is vertical. """

        return self.dock_direction in [AUI_DOCK_LEFT, AUI_DOCK_RIGHT]


# Null AuiPaneInfo reference
NonePaneInfo = AuiPaneInfo()


# ---------------------------------------------------------------------------- #

class AuiDockingGuide(wx.Frame):
    """ Base class for L{AuiCenterDockingGuide} and L{AuiSingleDockingGuide}."""

    def __init__(self, parent, id=wx.ID_ANY, title="", pos=wx.DefaultPosition,
                 size=wx.DefaultSize, style=wx.FRAME_TOOL_WINDOW | wx.STAY_ON_TOP |
                 wx.FRAME_NO_TASKBAR | wx.NO_BORDER, name="AuiDockingGuide"):
        """
        Default class constructor. Used internally, do not call it in your code!

        :param `parent`: the L{AuiDockingGuide} parent;
        :param `id`: the window identifier. It may take a value of -1 to indicate a default value.
        :param `title`: the caption to be displayed on the frame's title bar.
        :param `pos`: the window position. A value of (-1, -1) indicates a default position,
         chosen by either the windowing system or wxPython, depending on platform.
        :param `size`: the window size. A value of (-1, -1) indicates a default size, chosen by
         either the windowing system or wxPython, depending on platform.
        :param `style`: the window style. 
        :param `name`: the name of the window. This parameter is used to associate a name with the
         item, allowing the application user to set Motif resource values for individual windows.
        """

        wx.Frame.__init__(self, parent, id, title, pos, size, style, name=name)


    def HitTest(self, x, y):
        """
        To be overridden by parent classes.

        :param `x`: the `x` mouse position;
        :param `y`: the `y` mouse position.
        """

        return 0

    
    def ValidateNotebookDocking(self, valid):
        """
        To be overridden by parent classes.

        :param `valid`: whether a pane can be docked on top to another to form an automatic
         L{AuiNotebook}.
        """
        
        return 0

# ============================================================================
# implementation
# ============================================================================

# ---------------------------------------------------------------------------
# AuiDockingGuideWindow
# ---------------------------------------------------------------------------

class AuiDockingGuideWindow(wx.Window):
    """ Target class for L{AuiSingleDockingGuide} and L{AuiCenterDockingGuide}. """

    def __init__(self, parent, rect, direction=0, center=False, useAero=False):
        """
        Default class constructor. Used internally, do not call it in your code!

        :param `parent`: the L{AuiDockingGuideWindow} parent;
        :param `rect`: the window rect;
        :param `direction`: one of ``wx.TOP``, ``wx.BOTTOM``, ``wx.LEFT``, ``wx.RIGHT``,
         ``wx.CENTER``;
        :param `center`: whether the calling class is a L{AuiCenterDockingGuide};
        :param `useAero`: whether to use the new Aero-style bitmaps or Whidbey-style bitmaps
         for the docking guide.
        """

        wx.Window.__init__(self, parent, -1, rect.GetPosition(), rect.GetSize(), wx.NO_BORDER)

        self._direction = direction
        self._center = center
        self._valid = True
        self._useAero = useAero
        
        self._bmp_unfocus, self._bmp_focus = GetDockingImage(direction, useAero, center)
        
        self._currentImage = self._bmp_unfocus
        self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM)
        
        self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnEraseBackground)
        self.Bind(wx.EVT_PAINT, self.OnPaint)


    def SetValid(self, valid):
        """
        Sets the docking direction as valid or invalid.

        :param `valid`: whether the docking direction is allowed or not.
        """

        self._valid = valid


    def IsValid(self):
        """ Returns whether the docking direction is valid. """
        
        return self._valid


    def OnEraseBackground(self, event):
        """
        Handles the ``wx.EVT_ERASE_BACKGROUND`` event for L{AuiDockingGuideWindow}.

        :param `event`: a `wx.EraseEvent` to be processed.

        :note: This is intentionally empty to reduce flickering while drawing.
        """

        pass


    def DrawBackground(self, dc):
        """
        Draws the docking guide background.

        :param `dc`: a `wx.DC` device context object.
        """

        rect = self.GetClientRect()

        dc.SetPen(wx.TRANSPARENT_PEN)
        dc.SetBrush(wx.Brush(colourTargetBackground))
        dc.DrawRectangleRect(rect)

        dc.SetPen(wx.Pen(colourTargetBorder))

        left = rect.GetLeft()
        top = rect.GetTop()
        right = rect.GetRight()
        bottom = rect.GetBottom()

        if self._direction != wx.CENTER:
        
            if not self._center or self._direction != wx.BOTTOM:
                dc.DrawLine(left, top, right+1, top)
            if not self._center or self._direction != wx.RIGHT:
                dc.DrawLine(left, top, left, bottom+1)
            if not self._center or self._direction != wx.LEFT:
                dc.DrawLine(right, top, right, bottom+1)
            if not self._center or self._direction != wx.TOP:
                dc.DrawLine(left, bottom, right+1, bottom)

            dc.SetPen(wx.Pen(colourTargetShade))

            if self._direction != wx.RIGHT:
                dc.DrawLine(left + 1, top + 1, left + 1, bottom)
            if self._direction != wx.BOTTOM:
                dc.DrawLine(left + 1, top + 1, right, top + 1)

        
    def DrawDottedLine(self, dc, point, length, vertical):
        """
        Draws a dotted line (not used if the docking guide images are ok).

        :param `dc`: a `wx.DC` device context object;
        :param `point`: a `wx.Point` where to start drawing the dotted line;
        :param `length`: the length of the dotted line;
        :param `vertical`: whether it is a vertical docking guide window or not.
        """

        for i in xrange(0, length, 2):
            dc.DrawPoint(point.x, point.y)
            if vertical:
                point.y += 2
            else:
                point.x += 2
        

    def DrawIcon(self, dc):
        """
        Draws the docking guide icon (not used if the docking guide images are ok).

        :param `dc`: a `wx.DC` device context object.
        """

        rect = wx.Rect(*self.GetClientRect())
        point = wx.Point()
        length = 0

        rect.Deflate(4, 4)
        dc.SetPen(wx.Pen(colourIconBorder))
        dc.SetBrush(wx.Brush(colourIconBackground))
        dc.DrawRectangleRect(rect)

        right1 = rect.GetRight() + 1
        bottom1 = rect.GetBottom() + 1

        dc.SetPen(wx.Pen(colourIconShadow))
        dc.DrawLine(rect.x + 1, bottom1, right1 + 1, bottom1)
        dc.DrawLine(right1, rect.y + 1, right1, bottom1 + 1)

        rect.Deflate(1, 1)

        if self._direction == wx.TOP:
            rect.height -= rect.height / 2
            point = rect.GetBottomLeft()
            length = rect.width

        elif self._direction == wx.LEFT:
            rect.width -= rect.width / 2
            point = rect.GetTopRight()
            length = rect.height

        elif self._direction == wx.RIGHT:
            rect.x += rect.width / 2
            rect.width -= rect.width / 2
            point = rect.GetTopLeft()
            length = rect.height

        elif self._direction == wx.BOTTOM:
            rect.y += rect.height / 2
            rect.height -= rect.height / 2
            point = rect.GetTopLeft()
            length = rect.width

        elif self._direction == wx.CENTER:
            rect.Deflate(1, 1)
            point = rect.GetTopLeft()
            length = rect.width

        dc.GradientFillLinear(rect, colourIconDockingPart1,
                              colourIconDockingPart2, self._direction)

        dc.SetPen(wx.Pen(colourIconBorder))

        if self._direction == wx.CENTER:        
            self.DrawDottedLine(dc, rect.GetTopLeft(), rect.width, False)
            self.DrawDottedLine(dc, rect.GetTopLeft(), rect.height, True)
            self.DrawDottedLine(dc, rect.GetBottomLeft(), rect.width, False)
            self.DrawDottedLine(dc, rect.GetTopRight(), rect.height, True)
        
        elif self._direction in [wx.TOP, wx.BOTTOM]:
            self.DrawDottedLine(dc, point, length, False)
        
        else:
            self.DrawDottedLine(dc, point, length, True)
        

    def DrawArrow(self, dc):
        """
        Draws the docking guide arrow icon (not used if the docking guide images are ok).

        :param `dc`: a `wx.DC` device context object.
        """

        rect = self.GetClientRect()
        point = wx.Point()

        point.x = (rect.GetLeft() + rect.GetRight()) / 2
        point.y = (rect.GetTop() + rect.GetBottom()) / 2
        rx, ry = wx.Size(), wx.Size()
        
        if self._direction == wx.TOP:
            rx = wx.Size(1, 0)
            ry = wx.Size(0, 1)

        elif self._direction == wx.LEFT:
            rx = wx.Size(0, -1)
            ry = wx.Size(1, 0)

        elif self._direction == wx.RIGHT:
            rx = wx.Size(0, 1)
            ry = wx.Size(-1, 0)

        elif self._direction == wx.BOTTOM:
            rx = wx.Size(-1, 0)
            ry = wx.Size(0, -1)        

        point.x += ry.x*3
        point.y += ry.y*3

        dc.SetPen(wx.Pen(colourIconArrow))

        for i in xrange(4):
            pt1 = wx.Point(point.x - rx.x*i, point.y - rx.y*i)
            pt2 = wx.Point(point.x + rx.x*(i+1), point.y + rx.y*(i+1))
            dc.DrawLinePoint(pt1, pt2)
            point.x += ry.x
            point.y += ry.y

    
    def OnPaint(self, event):
        """
        Handles the ``wx.EVT_PAINT`` event for L{AuiDockingGuideWindow}.

        :param `event`: a `wx.PaintEvent` to be processed.
        """

        dc = wx.AutoBufferedPaintDC(self)
        if self._currentImage.IsOk() and self._valid:
            dc.DrawBitmap(self._currentImage, 0, 0, True)
        else:
            self.Draw(dc)


    def Draw(self, dc):
        """
        Draws the whole docking guide window (not used if the docking guide images are ok).

        :param `dc`: a `wx.DC` device context object.
        """

        self.DrawBackground(dc)

        if self._valid:
            self.DrawIcon(dc)
            self.DrawArrow(dc)


    def UpdateDockGuide(self, pos):
        """
        Updates the docking guide images depending on the mouse position, using focused
        images if the mouse is inside the docking guide or unfocused images if it is
        outside.

        :param `pos`: a `wx.Point` mouse position.
        """

        inside = self.GetScreenRect().Contains(pos)
        
        if inside:
            image = self._bmp_focus
        else:
            image = self._bmp_unfocus

        if image != self._currentImage:
            self._currentImage = image
            self.Refresh()
            self.Update()


# ---------------------------------------------------------------------------
# AuiSingleDockingGuide
# ---------------------------------------------------------------------------

class AuiSingleDockingGuide(AuiDockingGuide):
    """ A docking guide window for single docking hint (not diamond-shaped HUD). """
    
    def __init__(self, parent, direction=0):
        """
        Default class constructor. Used internally, do not call it in your code!

        :param `parent`: the L{AuiSingleDockingGuide} parent;
        :param `direction`: one of ``wx.TOP``, ``wx.BOTTOM``, ``wx.LEFT``, ``wx.RIGHT``.
        """

        self._direction = direction

        style = wx.FRAME_TOOL_WINDOW | wx.STAY_ON_TOP | \
                wx.FRAME_NO_TASKBAR | wx.NO_BORDER

        # Use of FRAME_SHAPED on wxMac causes the frame to be visible
        # breaking the docking hints.
        if wx.Platform != '__WXMAC__':
            style |= wx.FRAME_SHAPED

        AuiDockingGuide.__init__(self, parent, style=style, name="auiSingleDockTarget")
        
        self.Hide()

        useAero = GetManager(self.GetParent()).GetAGWFlags() & AUI_MGR_AERO_DOCKING_GUIDES
        useWhidbey = GetManager(self.GetParent()).GetAGWFlags() & AUI_MGR_WHIDBEY_DOCKING_GUIDES
        
        self._useAero = useAero or useWhidbey
        self._valid = True
        
        if useAero:
            sizeX, sizeY = aeroguideSizeX, aeroguideSizeY
        elif useWhidbey:
            sizeX, sizeY = whidbeySizeX, whidbeySizeY
        else:
            sizeX, sizeY = guideSizeX, guideSizeY

        if direction not in [wx.TOP, wx.BOTTOM]:
            sizeX, sizeY = sizeY, sizeX

        if self._useAero:
            self.CreateShapesWithStyle(useWhidbey)
            
            if wx.Platform == "__WXGTK__":
                self.Bind(wx.EVT_WINDOW_CREATE, self.SetGuideShape)
            else:
                self.SetGuideShape()
            
            self.SetSize(self.region.GetBox().GetSize())
        else:
            self.SetSize((sizeX, sizeY))
            
        self.rect = wx.Rect(0, 0, sizeX, sizeY)

        if self._useAero:
            useAero = (useWhidbey and [2] or [1])[0]
        else:
            useAero = 0
            
        self.target = AuiDockingGuideWindow(self, self.rect, direction, False, useAero)


    def CreateShapesWithStyle(self, useWhidbey):
        """
        Creates the docking guide window shape based on which docking bitmaps are used.

        :param `useWhidbey`: if ``True``, use Whidbey-style bitmaps; if ``False``, use the
         Aero-style bitmaps.
         """

        sizeX, sizeY = aeroguideSizeX, aeroguideSizeY
        if useWhidbey:
            sizeX, sizeY = whidbeySizeX, whidbeySizeY

        if self._direction not in [wx.TOP, wx.BOTTOM]:
            sizeX, sizeY = sizeY, sizeX

        useAero = (useWhidbey and [2] or [1])[0]      
        bmp, dummy = GetDockingImage(self._direction, useAero, False)
        region = wx.RegionFromBitmap(bmp)
            
        self.region = region
        

    def AeroMove(self, pos):
        """
        Moves the docking window to the new position. Overridden in children classes.

        :param `pos`: the new docking guide position.
        """

        pass
    

    def SetGuideShape(self, event=None):
        """
        Sets the correct shape for the docking guide window.

        :param `event`: on wxGTK, a `wx.WindowCreateEvent` event to process.
        """

        self.SetShape(self.region)        
                
        if event is not None:
            # Skip the event on wxGTK
            event.Skip()
            wx.CallAfter(wx.SafeYield, self, True)


    def SetShape(self, region):
        """
        If the platform supports it, sets the shape of the window to that depicted by `region`.
        The system will not display or respond to any mouse event for the pixels that lie
        outside of the region. To reset the window to the normal rectangular shape simply call
        L{SetShape} again with an empty region. 

        :param `region`: the shape of the frame.

        :note: Overridden for wxMac.        
        """
        
        if wx.Platform == '__WXMAC__':
            # HACK so we don't crash when SetShape is called
            return
        else:
            super(AuiSingleDockingGuide, self).SetShape(region)


    def SetValid(self, valid):
        """
        Sets the docking direction as valid or invalid.

        :param `valid`: whether the docking direction is allowed or not.
        """

        self._valid = valid


    def IsValid(self):
        """ Returns whether the docking direction is valid. """
        
        return self._valid


    def UpdateDockGuide(self, pos):
        """
        Updates the docking guide images depending on the mouse position, using focused
        images if the mouse is inside the docking guide or unfocused images if it is
        outside.

        :param `pos`: a `wx.Point` mouse position.
        """

        self.target.UpdateDockGuide(pos)

        
    def HitTest(self, x, y):
        """
        Checks if the mouse position is inside the target window rect.

        :param `x`: the `x` mouse position;
        :param `y`: the `y` mouse position.
        """

        if self.target.GetScreenRect().Contains((x, y)):
            return wx.ALL

        return -1


# ---------------------------------------------------------------------------
# AuiCenterDockingGuide
# ---------------------------------------------------------------------------

class AuiCenterDockingGuide(AuiDockingGuide):
    """ A docking guide window for multiple docking hint (diamond-shaped HUD). """
    
    def __init__(self, parent):
        """
        Default class constructor.
        Used internally, do not call it in your code!

        :param `parent`: the L{AuiCenterDockingGuide} parent.
        """

        AuiDockingGuide.__init__(self, parent, style=wx.FRAME_TOOL_WINDOW | wx.STAY_ON_TOP |
                                 wx.FRAME_NO_TASKBAR | wx.NO_BORDER | wx.FRAME_SHAPED,
                                 name="auiCenterDockTarget")

        self.Hide()

        self.CreateShapesWithStyle()
        self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM)
        
        if wx.Platform == "__WXGTK__":
            self.Bind(wx.EVT_WINDOW_CREATE, self.SetGuideShape)
        else:
            self.SetGuideShape()
            
        self.SetSize(self.region.GetBox().GetSize())

        self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnEraseBackground)
        self.Bind(wx.EVT_PAINT, self.OnPaint)


    def CreateShapesWithStyle(self):
        """ Creates the docking guide window shape based on which docking bitmaps are used. """

        useAero = (GetManager(self.GetParent()).GetAGWFlags() & AUI_MGR_AERO_DOCKING_GUIDES) != 0
        useWhidbey = (GetManager(self.GetParent()).GetAGWFlags() & AUI_MGR_WHIDBEY_DOCKING_GUIDES) != 0

        self._useAero = 0
        if useAero:
            self._useAero = 1
        elif useWhidbey:
            self._useAero = 2
        
        if useAero:
            sizeX, sizeY = aeroguideSizeX, aeroguideSizeY
        elif useWhidbey:
            sizeX, sizeY = whidbeySizeX, whidbeySizeY          
        else:
            sizeX, sizeY = guideSizeX, guideSizeY

        rectLeft = wx.Rect(0, sizeY, sizeY, sizeX)
        rectTop = wx.Rect(sizeY, 0, sizeX, sizeY)
        rectRight = wx.Rect(sizeY+sizeX, sizeY, sizeY, sizeX)
        rectBottom = wx.Rect(sizeY, sizeX + sizeY, sizeX, sizeY)
        rectCenter = wx.Rect(sizeY, sizeY, sizeX, sizeX)
            
        if not self._useAero:

            self.targetLeft = AuiDockingGuideWindow(self, rectLeft, wx.LEFT, True, useAero)
            self.targetTop = AuiDockingGuideWindow(self, rectTop, wx.TOP, True, useAero)
            self.targetRight = AuiDockingGuideWindow(self, rectRight, wx.RIGHT, True, useAero)
            self.targetBottom = AuiDockingGuideWindow(self, rectBottom, wx.BOTTOM, True, useAero)
            self.targetCenter = AuiDockingGuideWindow(self, rectCenter, wx.CENTER, True, useAero)

            
            # top-left diamond
            tld = [wx.Point(rectTop.x, rectTop.y+rectTop.height-8),
                   wx.Point(rectLeft.x+rectLeft.width-8, rectLeft.y),
                   rectTop.GetBottomLeft()]
            # bottom-left diamond
            bld = [wx.Point(rectLeft.x+rectLeft.width-8, rectLeft.y+rectLeft.height),
                   wx.Point(rectBottom.x, rectBottom.y+8),
                   rectBottom.GetTopLeft()]
            # top-right diamond
            trd = [wx.Point(rectTop.x+rectTop.width, rectTop.y+rectTop.height-8),
                   wx.Point(rectRight.x+8, rectRight.y),
                   rectRight.GetTopLeft()]        
            # bottom-right diamond
            brd = [wx.Point(rectRight.x+8, rectRight.y+rectRight.height),
                   wx.Point(rectBottom.x+rectBottom.width, rectBottom.y+8),
                   rectBottom.GetTopRight()]

            self._triangles = [tld[0:2], bld[0:2],
                               [wx.Point(rectTop.x+rectTop.width-1, rectTop.y+rectTop.height-8),
                                wx.Point(rectRight.x+7, rectRight.y)],
                               [wx.Point(rectRight.x+7, rectRight.y+rectRight.height),
                                wx.Point(rectBottom.x+rectBottom.width-1, rectBottom.y+8)]]
            
            region = wx.Region()
            region.UnionRect(rectLeft)
            region.UnionRect(rectTop)
            region.UnionRect(rectRight)
            region.UnionRect(rectBottom)
            region.UnionRect(rectCenter)
            region.UnionRegion(wx.RegionFromPoints(tld))
            region.UnionRegion(wx.RegionFromPoints(bld))
            region.UnionRegion(wx.RegionFromPoints(trd))
            region.UnionRegion(wx.RegionFromPoints(brd))

        elif useAero:

            self._aeroBmp = aero_dock_pane.GetBitmap()
            region = wx.RegionFromBitmap(self._aeroBmp)

            self._allAeroBmps = [aero_dock_pane_left.GetBitmap(), aero_dock_pane_top.GetBitmap(),
                                 aero_dock_pane_right.GetBitmap(), aero_dock_pane_bottom.GetBitmap(),
                                 aero_dock_pane_center.GetBitmap(), aero_dock_pane.GetBitmap()]
            self._deniedBitmap = aero_denied.GetBitmap()
            self._aeroRects = [rectLeft, rectTop, rectRight, rectBottom, rectCenter]
            self._valid = True

        elif useWhidbey:

            self._aeroBmp = whidbey_dock_pane.GetBitmap()
            region = wx.RegionFromBitmap(self._aeroBmp)

            self._allAeroBmps = [whidbey_dock_pane_left.GetBitmap(), whidbey_dock_pane_top.GetBitmap(),
                                 whidbey_dock_pane_right.GetBitmap(), whidbey_dock_pane_bottom.GetBitmap(),
                                 whidbey_dock_pane_center.GetBitmap(), whidbey_dock_pane.GetBitmap()]
            self._deniedBitmap = whidbey_denied.GetBitmap()
            self._aeroRects = [rectLeft, rectTop, rectRight, rectBottom, rectCenter]
            self._valid = True
            
            
        self.region = region
        

    def SetGuideShape(self, event=None):
        """
        Sets the correct shape for the docking guide window.

        :param `event`: on wxGTK, a `wx.WindowCreateEvent` event to process.
        """

        self.SetShape(self.region)        

        if event is not None:
            # Skip the event on wxGTK
            event.Skip()
            wx.CallAfter(wx.SafeYield, self, True)

            
    def UpdateDockGuide(self, pos):
        """
        Updates the docking guides images depending on the mouse position, using focused
        images if the mouse is inside the docking guide or unfocused images if it is
        outside.

        :param `pos`: a `wx.Point` mouse position.
        """

        if not self._useAero:
            for target in self.GetChildren():
                target.UpdateDockGuide(pos)
        else:
            lenRects = len(self._aeroRects)
            for indx, rect in enumerate(self._aeroRects):
                if rect.Contains(pos):
                    if self._allAeroBmps[indx] != self._aeroBmp:
                        if indx < lenRects - 1 or (indx == lenRects - 1 and self._valid):
                            self._aeroBmp = self._allAeroBmps[indx]
                            self.Refresh()
                        else:
                            self._aeroBmp = self._allAeroBmps[-1]
                            self.Refresh()
                            
                    return

            if self._aeroBmp != self._allAeroBmps[-1]:
                self._aeroBmp = self._allAeroBmps[-1]
                self.Refresh()


    def HitTest(self, x, y):
        """
        Checks if the mouse position is inside the target windows rect.

        :param `x`: the `x` mouse position;
        :param `y`: the `y` mouse position.
        """

        if not self._useAero:
            if self.targetLeft.GetScreenRect().Contains((x, y)):
                return wx.LEFT
            if self.targetTop.GetScreenRect().Contains((x, y)):
                return wx.UP
            if self.targetRight.GetScreenRect().Contains((x, y)):
                return wx.RIGHT
            if self.targetBottom.GetScreenRect().Contains((x, y)):
                return wx.DOWN
            if self.targetCenter.IsValid() and self.targetCenter.GetScreenRect().Contains((x, y)):
                return wx.CENTER
        else:
            constants = [wx.LEFT, wx.UP, wx.RIGHT, wx.DOWN, wx.CENTER]
            lenRects = len(self._aeroRects)
            for indx, rect in enumerate(self._aeroRects):
                if rect.Contains((x, y)):
                    if indx < lenRects or (indx == lenRects-1 and self._valid):
                        return constants[indx]

        return -1


    def ValidateNotebookDocking(self, valid):
        """
        Sets whether a pane can be docked on top of another to create an automatic
        L{AuiNotebook}.

        :param `valid`: whether a pane can be docked on top to another to form an automatic
         L{AuiNotebook}.
        """

        if not self._useAero:
            if self.targetCenter.IsValid() != valid:        
                self.targetCenter.SetValid(valid)
                self.targetCenter.Refresh()
        else:
            if self._valid != valid:
                self._valid = valid
                self.Refresh()
    

    def AeroMove(self, pos):
        """
        Moves the docking guide window to the new position.

        :param `pos`: the new docking guide position.
        """

        if not self._useAero:
            return

        useWhidbey = (GetManager(self.GetParent()).GetAGWFlags() & AUI_MGR_WHIDBEY_DOCKING_GUIDES) != 0

        if useWhidbey:
            sizeX, sizeY = whidbeySizeX, whidbeySizeY            
        else:
            sizeX, sizeY = aeroguideSizeX, aeroguideSizeY
            
        size = self.GetSize()
        
        leftRect, topRect, rightRect, bottomRect, centerRect = self._aeroRects
        thePos = pos + wx.Point((size.x-sizeY)/2, (size.y-sizeX)/2)
        
        centerRect.SetPosition(thePos)

        leftRect.SetPosition(thePos + wx.Point(-sizeY, 0))
        topRect.SetPosition(thePos + wx.Point(0, -sizeY))
        rightRect.SetPosition(thePos + wx.Point(sizeX, 0))
        bottomRect.SetPosition(thePos + wx.Point(0, sizeX))
        
        
    def OnEraseBackground(self, event):
        """
        Handles the ``wx.EVT_ERASE_BACKGROUND`` event for L{AuiCenterDockingGuide}.

        :param `event`: `wx.EraseEvent` to be processed.

        :note: This is intentionally empty to reduce flickering while drawing.
        """
        
        pass


    def OnPaint(self, event):
        """
        Handles the ``wx.EVT_PAINT`` event for L{AuiCenterDockingGuide}.

        :param `event`: a `wx.PaintEvent` to be processed.
        """

        dc = wx.AutoBufferedPaintDC(self)

        if self._useAero:
            dc.SetBrush(wx.TRANSPARENT_BRUSH)
            dc.SetPen(wx.TRANSPARENT_PEN)
        else:
            dc.SetBrush(wx.Brush(colourTargetBackground))
            dc.SetPen(wx.Pen(colourTargetBorder))

        rect = self.GetClientRect()
        dc.DrawRectangle(rect.x, rect.y, rect.width, rect.height)

        if self._useAero:
            dc.DrawBitmap(self._aeroBmp, 0, 0, True)
            if not self._valid:
                diff = (self._useAero == 2 and [1] or [0])[0]
                bmpX, bmpY = self._deniedBitmap.GetWidth(), self._deniedBitmap.GetHeight()
                xPos, yPos = (rect.x + (rect.width)/2 - bmpX/2), (rect.y + (rect.height)/2 - bmpY/2)
                dc.DrawBitmap(self._deniedBitmap, xPos+1, yPos+diff, True)
                
            return
        
        dc.SetPen(wx.Pen(colourTargetBorder, 2))
        for pts in self._triangles:
            dc.DrawLinePoint(pts[0], pts[1])
            

# ----------------------------------------------------------------------------
# AuiDockingHintWindow
# ----------------------------------------------------------------------------

class AuiDockingHintWindow(wx.Frame):
    """ The original wxAUI docking window hint. """

    def __init__(self, parent, id=wx.ID_ANY, title="", pos=wx.DefaultPosition,
                 size=wx.Size(1, 1), style=wx.FRAME_TOOL_WINDOW | wx.FRAME_FLOAT_ON_PARENT |
                 wx.FRAME_NO_TASKBAR | wx.NO_BORDER | wx.FRAME_SHAPED,
                 name="auiHintWindow"):
        """
        Default class constructor. Used internally, do not call it in your code!

        :param `parent`: the L{AuiDockingGuide} parent;
        :param `id`: the window identifier. It may take a value of -1 to indicate a default value.
        :param `title`: the caption to be displayed on the frame's title bar;
        :param `pos`: the window position. A value of (-1, -1) indicates a default position,
         chosen by either the windowing system or wxPython, depending on platform;
        :param `size`: the window size. A value of (-1, -1) indicates a default size, chosen by
         either the windowing system or wxPython, depending on platform;
        :param `style`: the window style;
        :param `name`: the name of the window. This parameter is used to associate a name with the
         item, allowing the application user to set Motif resource values for individual windows.
        """
        if wx.Platform == '__WXMAC__' and style & wx.FRAME_SHAPED:
            # Having the shaped frame causes the frame to not be visible
            # with the transparent style hints.
            style -= wx.FRAME_SHAPED

        wx.Frame.__init__(self, parent, id, title, pos, size, style, name=name)
        
        self._blindMode = False
        self.SetBackgroundColour(colourHintBackground)
        
        # Can't set background colour on a frame on wxMac
        # so add a panel to set the colour on.
        if wx.Platform == '__WXMAC__':
            sizer = wx.BoxSizer(wx.HORIZONTAL)
            self.panel = wx.Panel(self)
            sizer.Add(self.panel, 1, wx.EXPAND)
            self.SetSizer(sizer)
            self.panel.SetBackgroundColour(colourHintBackground)

        self.Bind(wx.EVT_SIZE, self.OnSize)
        

    def MakeVenetianBlinds(self):
        """
        Creates the "venetian blind" effect if L{AuiManager} has the ``AUI_MGR_VENETIAN_BLINDS_HINT``
        flag set.
        """

        amount = 128
        size = self.GetClientSize()
        region = wx.Region(0, 0, size.x, 1)

        for y in xrange(size.y):

            # Reverse the order of the bottom 4 bits
            j = (y & 8 and [1] or [0])[0] | (y & 4 and [2] or [0])[0] | \
                (y & 2 and [4] or [0])[0] | (y & 1 and [8] or [0])[0]
            
            if 16*j+8 < amount:
                region.Union(0, y, size.x, 1)
                        
        self.SetShape(region)


    def SetBlindMode(self, agwFlags):
        """
        Sets whether venetian blinds or transparent hints will be shown as docking hint.
        This depends on the L{AuiManager} flags.

        :param `agwFlags`: the L{AuiManager} flags.
        """

        self._blindMode = (agwFlags & AUI_MGR_VENETIAN_BLINDS_HINT) != 0

        if self._blindMode or not self.CanSetTransparent():
            self.MakeVenetianBlinds()
            self.SetTransparent(255)
        
        else:
            self.SetShape(wx.Region())
            if agwFlags & AUI_MGR_HINT_FADE == 0:                
                self.SetTransparent(80)
            else:
                self.SetTransparent(0)


    def SetShape(self, region):
        """
        If the platform supports it, sets the shape of the window to that depicted by `region`.
        The system will not display or respond to any mouse event for the pixels that lie
        outside of the region. To reset the window to the normal rectangular shape simply call
        L{SetShape} again with an empty region. 

        :param `region`: the shape of the frame (an instance of `wx.Region`).

        :note: Overridden for wxMac.        
        """
        
        if wx.Platform == '__WXMAC__':
            # HACK so we don't crash when SetShape is called
            return
        else:
            super(AuiDockingHintWindow, self).SetShape(region)


    def Show(self, show=True):
        """
        Show the hint window.

        :param `show`: whether to show or hide the hint docking window.
        """
        
        super(AuiDockingHintWindow, self).Show(show)
        if wx.Platform == '__WXMAC__':
            # Need to manually do layout since its a borderless frame.
            self.Layout()


    def OnSize(self, event):
        """
        Handles the ``wx.EVT_SIZE`` event for L{AuiDockingHintWindow}.

        :param `event`: a `wx.SizeEvent` to be processed.
        """

        if self._blindMode or not self.CanSetTransparent():
            self.MakeVenetianBlinds()


# ---------------------------------------------------------------------------- #

# -- AuiFloatingFrame class implementation --            

class AuiFloatingFrame(wx.MiniFrame):
    """ AuiFloatingFrame is the frame class that holds floating panes. """

    def __init__(self, parent, owner_mgr, pane=None, id=wx.ID_ANY, title="",
                 style=wx.FRAME_TOOL_WINDOW | wx.FRAME_FLOAT_ON_PARENT |
                 wx.FRAME_NO_TASKBAR | wx.CLIP_CHILDREN):
        """
        Default class constructor. Used internally, do not call it in your code!

        :param `parent`: the L{AuiFloatingFrame} parent;
        :param `owner_mgr`: the L{AuiManager} that manages the floating pane;
        :param `pane`: the L{AuiPaneInfo} pane that is about to float;
        :param `id`: the window identifier. It may take a value of -1 to indicate a default value.
        :param `title`: the caption to be displayed on the frame's title bar.
        :param `style`: the window style.
        """
            
        if pane and pane.IsResizeable():
            style += wx.RESIZE_BORDER
        if pane:
            self._is_toolbar = pane.IsToolbar()

        self._useNativeMiniframes = False
        if AuiManager_UseNativeMiniframes(owner_mgr):
            # On wxMac we always use native miniframes
            self._useNativeMiniframes = True
            style += wx.CAPTION + wx.SYSTEM_MENU
            if pane.HasCloseButton():
                style += wx.CLOSE_BOX
            if pane.HasMaximizeButton():
                style += wx.MAXIMIZE_BOX
            if pane.HasMinimizeButton():
                style += wx.MINIMIZE_BOX
            
        wx.MiniFrame.__init__(self, parent, id, title, pos=pane.floating_pos,
                              size=pane.floating_size, style=style, name="auiFloatingFrame")

        self._fly_timer = wx.Timer(self, wx.ID_ANY)
        self._check_fly_timer = wx.Timer(self, wx.ID_ANY)
        
        self.Bind(wx.EVT_CLOSE, self.OnClose)
        self.Bind(wx.EVT_SIZE, self.OnSize)
        self.Bind(wx.EVT_ACTIVATE, self.OnActivate)
        self.Bind(wx.EVT_TIMER, self.OnCheckFlyTimer, self._check_fly_timer)
        self.Bind(wx.EVT_TIMER, self.OnFlyTimer, self._fly_timer)
        self.Bind(EVT_AUI_FIND_MANAGER, self.OnFindManager)

        if self._useNativeMiniframes:
            self.Bind(wx.EVT_MOVE, self.OnMoveEvent)
            self.Bind(wx.EVT_MOVING, self.OnMoveEvent)
            self.Bind(wx.EVT_IDLE, self.OnIdle)
            self._useNativeMiniframes = True
            self.SetExtraStyle(wx.WS_EX_PROCESS_IDLE)
        else:
            self.Bind(wx.EVT_MOVE, self.OnMove)

        self._fly = False
        self._send_size = True
        self._alpha_amount = 255
        
        self._owner_mgr = owner_mgr
        self._moving = False
        self._lastDirection = None
        self._transparent = 255

        self._last_rect = wx.Rect()
        self._last2_rect = wx.Rect()
        self._last3_rect = wx.Rect()

        self._mgr = AuiManager()
        self._mgr.SetManagedWindow(self)
        self._mgr.SetArtProvider(owner_mgr.GetArtProvider())
        self._mgr.SetAGWFlags(owner_mgr.GetAGWFlags())


    def CopyAttributes(self, pane):
        """
        Copies all the attributes of the input `pane` into another L{AuiPaneInfo}.

        :param `pane`: the source L{AuiPaneInfo} from where to copy attributes.
        """

        contained_pane = AuiPaneInfo()

        contained_pane.name = pane.name
        contained_pane.caption = pane.caption
        contained_pane.window = pane.window
        contained_pane.frame = pane.frame
        contained_pane.state = pane.state
        contained_pane.dock_direction = pane.dock_direction
        contained_pane.dock_layer = pane.dock_layer
        contained_pane.dock_row = pane.dock_row
        contained_pane.dock_pos = pane.dock_pos
        contained_pane.best_size = wx.Size(*pane.best_size)
        contained_pane.min_size = wx.Size(*pane.min_size)
        contained_pane.max_size = wx.Size(*pane.max_size)
        contained_pane.floating_pos = wx.Point(*pane.floating_pos)
        contained_pane.floating_size = wx.Size(*pane.floating_size)
        contained_pane.dock_proportion = pane.dock_proportion
        contained_pane.buttons = pane.buttons
        contained_pane.rect = wx.Rect(*pane.rect)
        contained_pane.icon = pane.icon
        contained_pane.notebook_id = pane.notebook_id
        contained_pane.transparent = pane.transparent
        contained_pane.snapped = pane.snapped
        contained_pane.minimize_mode = pane.minimize_mode

        return contained_pane
    

    def SetPaneWindow(self, pane):
        """
        Sets all the properties of a pane.

        :param `pane`: the L{AuiPaneInfo} to analyze.
        """

        self._is_toolbar = pane.IsToolbar()
        self._pane_window = pane.window

        if isinstance(pane.window, auibar.AuiToolBar):
            pane.window.SetAuiManager(self._mgr)
        
        self._pane_window.Reparent(self)
        
        contained_pane = self.CopyAttributes(pane)
        
        contained_pane.Dock().Center().Show(). \
                       CaptionVisible(False). \
                       PaneBorder(False). \
                       Layer(0).Row(0).Position(0)

        if not contained_pane.HasGripper() and not self._useNativeMiniframes:
            contained_pane.CaptionVisible(True)

        indx = self._owner_mgr._panes.index(pane)

        # Carry over the minimum size
        pane_min_size = pane.window.GetMinSize()

        # if the best size is smaller than the min size
        # then set the min size to the best size as well
        pane_best_size = contained_pane.best_size
        if pane_best_size.IsFullySpecified() and (pane_best_size.x < pane_min_size.x or \
                                                  pane_best_size.y < pane_min_size.y):

            pane_min_size = pane_best_size
            self._pane_window.SetMinSize(pane_min_size)
    
        # if the frame window's max size is greater than the min size
        # then set the max size to the min size as well
        cur_max_size = self.GetMaxSize()
        if cur_max_size.IsFullySpecified() and  (cur_max_size.x < pane_min_size.x or \
                                                 cur_max_size.y < pane_min_size.y):
            self.SetMaxSize(pane_min_size)

        art_provider = self._mgr.GetArtProvider()
        caption_size = art_provider.GetMetric(AUI_DOCKART_CAPTION_SIZE)
        button_size = art_provider.GetMetric(AUI_DOCKART_PANE_BUTTON_SIZE) + \
                      4*art_provider.GetMetric(AUI_DOCKART_PANE_BORDER_SIZE)

        min_size = pane.window.GetMinSize()

        if min_size.y < caption_size or min_size.x < button_size:
            new_x, new_y = min_size.x, min_size.y
            if min_size.y < caption_size:
                new_y = (pane.IsResizeable() and [2*wx.SystemSettings.GetMetric(wx.SYS_EDGE_Y)+caption_size] or [1])[0]
            if min_size.x < button_size:
                new_x = (pane.IsResizeable() and [2*wx.SystemSettings.GetMetric(wx.SYS_EDGE_X)+button_size] or [1])[0]
                
            self.SetMinSize((new_x, new_y))
        else:
            self.SetMinSize(min_size)

        self._mgr.AddPane(self._pane_window, contained_pane)
        self._mgr.Update()           

        if pane.min_size.IsFullySpecified():
            # because SetSizeHints() calls Fit() too (which sets the window
            # size to its minimum allowed), we keep the size before calling
            # SetSizeHints() and reset it afterwards...
            tmp = self.GetSize()
            self.GetSizer().SetSizeHints(self)
            self.SetSize(tmp)
        
        self.SetTitle(pane.caption)

        if pane.floating_size != wx.Size(-1, -1):
            self.SetSize(pane.floating_size)
        else:
            size = pane.best_size
            if size == wx.Size(-1, -1):
                size = pane.min_size
            if size == wx.Size(-1, -1):
                size = self._pane_window.GetSize()
            if self._owner_mgr and pane.HasGripper():
                if pane.HasGripperTop():
                    size.y += self._owner_mgr._art.GetMetric(AUI_DOCKART_GRIPPER_SIZE)
                else:
                    size.x += self._owner_mgr._art.GetMetric(AUI_DOCKART_GRIPPER_SIZE)

            if not self._useNativeMiniframes:
                size.y += self._owner_mgr._art.GetMetric(AUI_DOCKART_CAPTION_SIZE)
                
            pane.floating_size = size
            
            self.SetClientSize(size)

        self._owner_mgr._panes[indx] = pane

        self._fly_step = abs(pane.floating_size.y - \
                             (caption_size + 2*wx.SystemSettings.GetMetric(wx.SYS_EDGE_Y)))/10

        self._floating_size = wx.Size(*self.GetSize())

        if pane.IsFlyOut():
            self._check_fly_timer.Start(50)

        
    def GetOwnerManager(self):
        """ Returns the L{AuiManager} that manages the pane. """

        return self._owner_mgr


    def OnSize(self, event):
        """
        Handles the ``wx.EVT_SIZE`` event for L{AuiFloatingFrame}.

        :param `event`: a `wx.SizeEvent` to be processed.
        """

        if self._owner_mgr and self._send_size:
            self._owner_mgr.OnFloatingPaneResized(self._pane_window, event.GetSize())

    
    def OnClose(self, event):
        """
        Handles the ``wx.EVT_CLOSE`` event for L{AuiFloatingFrame}.

        :param `event`: a `wx.CloseEvent` to be processed.
        """

        if self._owner_mgr:
            self._owner_mgr.OnFloatingPaneClosed(self._pane_window, event)

        if not event.GetVeto():
            self._mgr.DetachPane(self._pane_window)

            if isinstance(self._pane_window, auibar.AuiToolBar):
                self._pane_window.SetAuiManager(self._owner_mgr)

            # if we do not do this, then we can crash...
            if self._owner_mgr and self._owner_mgr._action_window == self:
                self._owner_mgr._action_window = None

            self.Destroy()
    

    def OnActivate(self, event):
        """
        Handles the ``wx.EVT_ACTIVATE`` event for L{AuiFloatingFrame}.

        :param `event`: a `wx.ActivateEvent` to be processed.
        """

        if self._owner_mgr and event.GetActive():
            self._owner_mgr.OnFloatingPaneActivated(self._pane_window)


    def OnMove(self, event):
        """
        Handles the ``wx.EVT_MOVE`` event for L{AuiFloatingFrame}.

        :param `event`: a `wx.MoveEvent` to be processed.

        :note: This event is not processed on wxMAC or if L{AuiManager} is not using the
         ``AUI_MGR_USE_NATIVE_MINIFRAMES`` style.
        """

        if self._owner_mgr:
            self._owner_mgr.OnFloatingPaneMoved(self._pane_window, event)
                

    def OnMoveEvent(self, event):
        """
        Handles the ``wx.EVT_MOVE`` and ``wx.EVT_MOVING`` events for L{AuiFloatingFrame}.

        :param `event`: a `wx.MoveEvent` to be processed.

        :note: This event is only processed on wxMAC or if L{AuiManager} is using the
         ``AUI_MGR_USE_NATIVE_MINIFRAMES`` style.
        """

        win_rect = self.GetRect()

        if win_rect == self._last_rect:
            return

        # skip the first move event
        if self._last_rect.IsEmpty():        
            self._last_rect = wx.Rect(*win_rect)
            return
        
        # skip if moving too fast to avoid massive redraws and
        # jumping hint windows
        if abs(win_rect.x - self._last_rect.x) > 3 or abs(win_rect.y - self._last_rect.y) > 3:
            self._last3_rect = wx.Rect(*self._last2_rect)
            self._last2_rect = wx.Rect(*self._last_rect)
            self._last_rect = wx.Rect(*win_rect)
            return

        # prevent frame redocking during resize
        if self._last_rect.GetSize() != win_rect.GetSize():
            self._last3_rect = wx.Rect(*self._last2_rect)
            self._last2_rect = wx.Rect(*self._last_rect)
            self._last_rect = wx.Rect(*win_rect)
            return

        self._last3_rect = wx.Rect(*self._last2_rect)
        self._last2_rect = wx.Rect(*self._last_rect)
        self._last_rect = wx.Rect(*win_rect)

        if _VERSION_STRING < "2.9":
            leftDown = wx.GetMouseState().LeftDown()
        else:
            leftDown = wx.GetMouseState().LeftIsDown()

        if not leftDown:
            return

        if not self._moving:        
            self.OnMoveStart(event)
            self._moving = True

        if self._last3_rect.IsEmpty():
            return

        self.OnMoving(event)


    def OnIdle(self, event):
        """
        Handles the ``wx.EVT_IDLE`` event for L{AuiFloatingFrame}.

        :param `event`: a `wx.IdleEvent` event to be processed.

        :note: This event is only processed on wxMAC or if L{AuiManager} is using the
         ``AUI_MGR_USE_NATIVE_MINIFRAMES`` style.        
        """

        if self._moving:        
            if _VERSION_STRING < "2.9":
                leftDown = wx.GetMouseState().LeftDown()
            else:
                leftDown = wx.GetMouseState().LeftIsDown()

            if not leftDown:
                self._moving = False
                self.OnMoveFinished()
            else:            
                event.RequestMore()

        
    def OnMoveStart(self, event):
        """
        The user has just started moving the floating pane.

        :param `event`: an instance of `wx.MouseEvent`.
    
        :note: This method is used only on wxMAC or if L{AuiManager} is using the
         ``AUI_MGR_USE_NATIVE_MINIFRAMES`` style.
        """

        # notify the owner manager that the pane has started to move
        if self._owner_mgr:
            if self._owner_mgr._from_move:
                return
            self._owner_mgr._action_window = self._pane_window
            point = wx.GetMousePosition()
            action_offset = point - self.GetPosition()

            if self._is_toolbar:
                self._owner_mgr._toolbar_action_offset = action_offset
                self._owner_mgr.OnMotion_DragToolbarPane(point)
            else:
                self._owner_mgr._action_offset = action_offset
                self._owner_mgr.OnMotion_DragFloatingPane(point)

    
    def OnMoving(self, event):
        """
        The user is moving the floating pane.

        :param `event`: an instance of `wx.MouseEvent`.
        
        :note: This method is used only on wxMAC or if L{AuiManager} is using the
         ``AUI_MGR_USE_NATIVE_MINIFRAMES`` style.
        """

        # notify the owner manager that the pane is moving
        self.OnMoveStart(event)
        

    def OnMoveFinished(self):
        """
        The user has just finished moving the floating pane.

        :note: This method is used only on wxMAC or if L{AuiManager} is using the
         ``AUI_MGR_USE_NATIVE_MINIFRAMES`` style.
        """

        # notify the owner manager that the pane has finished moving
        if self._owner_mgr:
            self._owner_mgr._action_window = self._pane_window
            point = wx.GetMousePosition()
            if self._is_toolbar:
                self._owner_mgr.OnLeftUp_DragToolbarPane(point)
            else:
                self._owner_mgr.OnLeftUp_DragFloatingPane(point)

            self._owner_mgr.OnFloatingPaneMoved(self._pane_window, point)
    

    def OnCheckFlyTimer(self, event):
        """
        Handles the ``wx.EVT_TIMER`` event for L{AuiFloatingFrame}.

        :param `event`: a `wx.TimerEvent` to be processed.

        :note: This is used solely for "fly-out" panes.        
        """
        
        if self._owner_mgr:
            pane = self._mgr.GetPane(self._pane_window)
            if pane.IsFlyOut():
                if self.IsShownOnScreen():
                    self.FlyOut()
                        

    def OnFindManager(self, event):
        """
        Handles the ``EVT_AUI_FIND_MANAGER`` event for L{AuiFloatingFrame}.

        :param `event`: a L{AuiManagerEvent} event to be processed.
        """
        
        event.SetManager(self._owner_mgr)


    def FlyOut(self):
        """ Starts the flying in and out of a floating pane. """

        if self._fly_timer.IsRunning():
            return

        if _VERSION_STRING < "2.9":
            leftDown = wx.GetMouseState().LeftDown()
        else:
            leftDown = wx.GetMouseState().LeftIsDown()

        if leftDown:
            return
        
        rect = wx.Rect(*self.GetScreenRect())
        rect.Inflate(10, 10)

        if rect.Contains(wx.GetMousePosition()):
            if not self._fly:
                return
            self._send_size = False
            self._fly_timer.Start(5)
        else:
            if self._fly:
                return
            self._send_size = False
            self._fly_timer.Start(5)


    def OnFlyTimer(self, event):            
        """
        Handles the ``wx.EVT_TIMER`` event for L{AuiFloatingFrame}.

        :param `event`: a `wx.TimerEvent` to be processed.
        """

        current_size = self.GetClientSize()
        floating_size = wx.Size(*self._owner_mgr.GetPane(self._pane_window).floating_size)

        if floating_size.y == -1:
            floating_size = self._floating_size
        
        if not self._fly:
            min_size = self._mgr.GetArtProvider().GetMetric(AUI_DOCKART_CAPTION_SIZE)

            if wx.Platform != "__WXMSW__":
                min_size += 2*wx.SystemSettings.GetMetric(wx.SYS_EDGE_Y)

            if current_size.y - self._fly_step <= min_size:
                self.SetClientSize((current_size.x, min_size))
                self._fly = True
                self._fly_timer.Stop()
                self._send_size = True
            else:
                self.SetClientSize((current_size.x, current_size.y-self._fly_step))

        else:
            if current_size.y + self._fly_step >= floating_size.y:
                self.SetClientSize((current_size.x, floating_size.y))
                self._fly = False
                self._fly_timer.Stop()
                self._send_size = True
            else:
                self.SetClientSize((current_size.x, current_size.y+self._fly_step))

        self.Update()
        self.Refresh()


    def FadeOut(self):
        """ Actually starts the fading out of the floating pane. """

        while 1:
            self._alpha_amount -= 10
            if self._alpha_amount <= 0:
                self._alpha_amount = 255
                return

            self.SetTransparent(self._alpha_amount)
            wx.SafeYield()
            wx.MilliSleep(15)

    
# -- static utility functions --

def DrawResizeHint(dc, rect):
    """
    Draws a resize hint while a sash is dragged.

    :param `rect`: a `wx.Rect` rectangle which specifies the sash dimensions.
    """
        
    if wx.Platform == "__WXMSW__" and wx.App.GetComCtl32Version() >= 600:
        if wx.GetOsVersion()[1] > 5:
            # Windows Vista
            dc.SetPen(wx.Pen("black", 2, wx.SOLID))
            dc.SetBrush(wx.TRANSPARENT_BRUSH)
        else:
            # Draw the nice XP style splitter
            dc.SetPen(wx.TRANSPARENT_PEN)
            dc.SetBrush(wx.BLACK_BRUSH)
        dc.SetLogicalFunction(wx.INVERT)
        dc.DrawRectangleRect(rect)
        dc.SetLogicalFunction(wx.COPY)
    else:
        stipple = PaneCreateStippleBitmap()
        brush = wx.BrushFromBitmap(stipple)
        dc.SetBrush(brush)
        dc.SetPen(wx.TRANSPARENT_PEN)

        dc.SetLogicalFunction(wx.XOR)
        dc.DrawRectangleRect(rect)    


def CopyDocksAndPanes(src_docks, src_panes):
    """
    This utility function creates shallow copies of
    the dock and pane info. L{AuiDockInfo} usually contain pointers
    to L{AuiPaneInfo} classes, thus this function is necessary to reliably
    reconstruct that relationship in the new dock info and pane info arrays.

    :param `src_docks`: a list of L{AuiDockInfo} classes;
    :param `src_panes`: a list of L{AuiPaneInfo} classes.
    """
    
    dest_docks = src_docks
    dest_panes = src_panes

    for ii in xrange(len(dest_docks)):
        dock = dest_docks[ii]
        for jj in xrange(len(dock.panes)):
            for kk in xrange(len(src_panes)):
                if dock.panes[jj] == src_panes[kk]:
                    dock.panes[jj] = dest_panes[kk]

    return dest_docks, dest_panes


def CopyDocksAndPanes2(src_docks, src_panes):
    """
    This utility function creates full copies of
    the dock and pane info. L{AuiDockInfo} usually contain pointers
    to L{AuiPaneInfo} classes, thus this function is necessary to reliably
    reconstruct that relationship in the new dock info and pane info arrays.

    :param `src_docks`: a list of L{AuiDockInfo} classes;
    :param `src_panes`: a list of L{AuiPaneInfo} classes.
    """
    
    dest_docks = []

    for ii in xrange(len(src_docks)):
        dest_docks.append(AuiDockInfo())
        dest_docks[ii].dock_direction = src_docks[ii].dock_direction
        dest_docks[ii].dock_layer = src_docks[ii].dock_layer
        dest_docks[ii].dock_row = src_docks[ii].dock_row
        dest_docks[ii].size = src_docks[ii].size
        dest_docks[ii].min_size = src_docks[ii].min_size
        dest_docks[ii].resizable = src_docks[ii].resizable
        dest_docks[ii].fixed = src_docks[ii].fixed
        dest_docks[ii].toolbar = src_docks[ii].toolbar
        dest_docks[ii].panes = src_docks[ii].panes
        dest_docks[ii].rect = wx.Rect(*src_docks[ii].rect)

    dest_panes = []

    for ii in xrange(len(src_panes)):
        dest_panes.append(AuiPaneInfo())
        dest_panes[ii].name = src_panes[ii].name
        dest_panes[ii].caption = src_panes[ii].caption
        dest_panes[ii].window = src_panes[ii].window
        dest_panes[ii].frame = src_panes[ii].frame
        dest_panes[ii].state = src_panes[ii].state
        dest_panes[ii].dock_direction = src_panes[ii].dock_direction
        dest_panes[ii].dock_layer = src_panes[ii].dock_layer
        dest_panes[ii].dock_row = src_panes[ii].dock_row
        dest_panes[ii].dock_pos = src_panes[ii].dock_pos
        dest_panes[ii].best_size = wx.Size(*src_panes[ii].best_size)
        dest_panes[ii].min_size = wx.Size(*src_panes[ii].min_size)
        dest_panes[ii].max_size = wx.Size(*src_panes[ii].max_size)
        dest_panes[ii].floating_pos = wx.Point(*src_panes[ii].floating_pos)
        dest_panes[ii].floating_size = wx.Size(*src_panes[ii].floating_size)
        dest_panes[ii].dock_proportion = src_panes[ii].dock_proportion
        dest_panes[ii].buttons = src_panes[ii].buttons
        dest_panes[ii].rect = wx.Rect(*src_panes[ii].rect)
        dest_panes[ii].icon = src_panes[ii].icon
        dest_panes[ii].notebook_id = src_panes[ii].notebook_id
        dest_panes[ii].transparent = src_panes[ii].transparent
        dest_panes[ii].snapped = src_panes[ii].snapped
        dest_panes[ii].minimize_mode = src_panes[ii].minimize_mode

    for ii in xrange(len(dest_docks)):
        dock = dest_docks[ii]
        for jj in xrange(len(dock.panes)):
            for kk in xrange(len(src_panes)):
                if dock.panes[jj] == src_panes[kk]:
                    dock.panes[jj] = dest_panes[kk]

        dest_docks[ii] = dock
        
    return dest_docks, dest_panes


def GetMaxLayer(docks, dock_direction):
    """
    This is an internal function which returns
    the highest layer inside the specified dock.

    :param `docks`: a list of L{AuiDockInfo};
    :param `dock_direction`: the L{AuiDockInfo} docking direction to analyze.
    """
    
    max_layer = 0

    for dock in docks:
        if dock.dock_direction == dock_direction and dock.dock_layer > max_layer and not dock.fixed:
            max_layer = dock.dock_layer
    
    return max_layer


def GetMaxRow(panes, dock_direction, dock_layer):
    """
    This is an internal function which returns
    the highest layer inside the specified dock.

    :param `panes`: a list of L{AuiPaneInfo};
    :param `dock_direction`: the L{AuiPaneInfo} docking direction to analyze;
    :param `dock_layer`: the L{AuiPaneInfo} layer to analyze.
    """
    
    max_row = 0

    for pane in panes:
        if pane.dock_direction == dock_direction and pane.dock_layer == dock_layer and \
           pane.dock_row > max_row:
            max_row = pane.dock_row
    
    return max_row


def DoInsertDockLayer(panes, dock_direction, dock_layer):
    """
    This is an internal function that inserts a new dock
    layer by incrementing all existing dock layer values by one.
    
    :param `panes`: a list of L{AuiPaneInfo};
    :param `dock_direction`: the L{AuiPaneInfo} docking direction to analyze;
    :param `dock_layer`: the L{AuiPaneInfo} layer to analyze.
    """
    
    for ii in xrange(len(panes)):
        pane = panes[ii]
        if not pane.IsFloating() and pane.dock_direction == dock_direction and pane.dock_layer >= dock_layer:
            pane.dock_layer = pane.dock_layer + 1

        panes[ii] = pane

    return panes


def DoInsertDockRow(panes, dock_direction, dock_layer, dock_row):
    """
    This is an internal function that inserts a new dock
    row by incrementing all existing dock row values by one.
    
    :param `panes`: a list of L{AuiPaneInfo};
    :param `dock_direction`: the L{AuiPaneInfo} docking direction to analyze;
    :param `dock_layer`: the L{AuiPaneInfo} layer to analyze;
    :param `dock_row`: the L{AuiPaneInfo} row to analyze.
    """
    
    for pane in panes:
        if not pane.IsFloating() and pane.dock_direction == dock_direction and \
           pane.dock_layer == dock_layer and pane.dock_row >= dock_row:
            pane.dock_row += 1

    return panes

    
def DoInsertPane(panes, dock_direction, dock_layer, dock_row, dock_pos):
    """
    This is an internal function that inserts a new pane
    by incrementing all existing dock position values by one.
    
    :param `panes`: a list of L{AuiPaneInfo};
    :param `dock_direction`: the L{AuiPaneInfo} docking direction to analyze;
    :param `dock_layer`: the L{AuiPaneInfo} layer to analyze;
    :param `dock_row`: the L{AuiPaneInfo} row to analyze;
    :param `dock_pos`: the L{AuiPaneInfo} row to analyze.
    """

    for ii in xrange(len(panes)):
        pane = panes[ii]
        if not pane.IsFloating() and pane.dock_direction == dock_direction and \
           pane.dock_layer == dock_layer and  pane.dock_row == dock_row and \
           pane.dock_pos >= dock_pos:
            pane.dock_pos = pane.dock_pos + 1

        panes[ii] = pane

    return panes


def FindDocks(docks, dock_direction, dock_layer=-1, dock_row=-1, reverse=False):
    """
    This is an internal function that returns a list of docks which meet
    the specified conditions in the parameters and returns a sorted array
    (sorted by layer and then row).
    
    :param `docks`: a list of L{AuiDockInfo};
    :param `dock_direction`: the L{AuiDockInfo} docking direction to analyze;
    :param `dock_layer`: the L{AuiDockInfo} layer to analyze;
    :param `dock_row`: the L{AuiDockInfo} row to analyze;
    """
    
    matchDocks = [(d.dock_layer, d.dock_row, d.dock_direction, d) for d in docks if \
                  (dock_direction == -1 or dock_direction == d.dock_direction) and \
                  ((dock_layer == -1 or dock_layer == d.dock_layer) and \
                  (dock_row == -1 or dock_row == d.dock_row))]
    
    arr = [x[-1] for x in sorted(matchDocks, reverse=reverse)]
    
    return arr


def FindOppositeDocks(docks, dock_direction):
    """
    This is an internal function that returns a list of docks
    which is related to the opposite direction.

    :param `docks`: a list of L{AuiDockInfo};
    :param `dock_direction`: the L{AuiDockInfo} docking direction to analyze;
    """

    if dock_direction == AUI_DOCK_LEFT:
        arr = FindDocks(docks, AUI_DOCK_RIGHT, -1, -1)
    elif dock_direction == AUI_DOCK_TOP:
        arr = FindDocks(docks, AUI_DOCK_BOTTOM, -1, -1)
    elif dock_direction == AUI_DOCK_RIGHT:
        arr = FindDocks(docks, AUI_DOCK_LEFT, -1, -1)
    elif dock_direction == AUI_DOCK_BOTTOM:
        arr = FindDocks(docks, AUI_DOCK_TOP, -1, -1)

    return arr    


def FindPaneInDock(dock, window):
    """
    This method looks up a specified window pointer inside a dock.
    If found, the corresponding L{AuiPaneInfo} pointer is returned, otherwise ``None``.

    :param `dock`: a L{AuiDockInfo} structure;
    :param `window`: a `wx.Window` derived window (associated to a pane).
    """

    for p in dock.panes:
        if p.window == window:
            return p
    
    return None


def GetToolBarDockOffsets(docks):
    """
    Returns the toolbar dock offsets (top-left and bottom-right).

    :param `docks`: a list of L{AuiDockInfo} to analyze.
    """

    top_left = wx.Size(0, 0)
    bottom_right = wx.Size(0, 0)

    for dock in docks:
        if dock.toolbar:
            dock_direction = dock.dock_direction
            if dock_direction == AUI_DOCK_LEFT:
                top_left.x += dock.rect.width
                bottom_right.x += dock.rect.width

            elif dock_direction == AUI_DOCK_TOP:
                top_left.y += dock.rect.height
                bottom_right.y += dock.rect.height

            elif dock_direction == AUI_DOCK_RIGHT:
                bottom_right.x += dock.rect.width
            
            elif dock_direction == AUI_DOCK_BOTTOM:
                bottom_right.y += dock.rect.height

    return top_left, bottom_right        
    

def GetInternalFrameRect(window, docks):
    """
    Returns the window rectangle excluding toolbars.

    :param `window`: a `wx.Window` derived window;
    :param `docks`: a list of L{AuiDockInfo} structures.
    """

    frameRect = wx.Rect()

    frameRect.SetTopLeft(window.ClientToScreen(window.GetClientAreaOrigin()))
    frameRect.SetSize(window.GetClientSize())

    top_left, bottom_right = GetToolBarDockOffsets(docks)

    # make adjustments for toolbars
    frameRect.x += top_left.x
    frameRect.y += top_left.y
    frameRect.width -= bottom_right.x
    frameRect.height -= bottom_right.y

    return frameRect


def CheckOutOfWindow(window, pt):
    """
    Checks if a point is outside the window rectangle.
    
    :param `window`: a `wx.Window` derived window;
    :param `pt`: a `wx.Point` object.
    """

    auiWindowMargin = 30
    marginRect = wx.Rect(*window.GetClientRect())
    marginRect.Inflate(auiWindowMargin, auiWindowMargin)

    return not marginRect.Contains(pt)


def CheckEdgeDrop(window, docks, pt):
    """
    Checks on which edge of a window the drop action has taken place.

    :param `window`: a `wx.Window` derived window;
    :param `docks`: a list of L{AuiDockInfo} structures;
    :param `pt`: a `wx.Point` object.
    """

    screenPt = window.ClientToScreen(pt)
    clientSize = window.GetClientSize()
    frameRect = GetInternalFrameRect(window, docks)

    if screenPt.y >= frameRect.GetTop() and screenPt.y < frameRect.GetBottom():
        if pt.x < auiLayerInsertOffset and pt.x > auiLayerInsertOffset - auiLayerInsertPixels:
            return wx.LEFT
        
        if pt.x >= clientSize.x - auiLayerInsertOffset and \
           pt.x < clientSize.x - auiLayerInsertOffset + auiLayerInsertPixels:
            return wx.RIGHT
        
    if screenPt.x >= frameRect.GetLeft() and screenPt.x < frameRect.GetRight():
        if pt.y < auiLayerInsertOffset and pt.y > auiLayerInsertOffset - auiLayerInsertPixels:
            return wx.TOP
        
        if pt.y >= clientSize.y - auiLayerInsertOffset and \
           pt.y < clientSize.y - auiLayerInsertOffset + auiLayerInsertPixels:
            return wx.BOTTOM

    return -1


def RemovePaneFromDocks(docks, pane, exc=None):
    """
    Removes a pane window from all docks
    with a possible exception specified by parameter `exc`.

    :param `docks`: a list of L{AuiDockInfo} structures;
    :param `pane`: the L{AuiPaneInfo} pane to be removed;
    :param `exc`: the possible pane exception.
    """
    
    for ii in xrange(len(docks)):
        d = docks[ii]
        if d == exc:
            continue
        pi = FindPaneInDock(d, pane.window)
        if pi:
            d.panes.remove(pi)

        docks[ii] = d            

    return docks


def RenumberDockRows(docks):
    """
    Takes a dock and assigns sequential numbers
    to existing rows.  Basically it takes out the gaps so if a
    dock has rows with numbers 0, 2, 5, they will become 0, 1, 2.

    :param `docks`: a list of L{AuiDockInfo} structures.    
    """
    
    for ii in xrange(len(docks)):
        dock = docks[ii]
        dock.dock_row = ii
        for jj in xrange(len(dock.panes)):
            dock.panes[jj].dock_row = ii

        docks[ii] = dock
        
    return docks


def SetActivePane(panes, active_pane):
    """
    Sets the active pane, as well as cycles through
    every other pane and makes sure that all others' active flags
    are turned off.

    :param `panes`: a list of L{AuiPaneInfo} structures;
    :param `active_pane`: the pane to be made active (if found).
    """

    for pane in panes:
        pane.state &= ~AuiPaneInfo.optionActive

    for pane in panes:
        if pane.window == active_pane and not pane.IsNotebookPage():
            pane.state |= AuiPaneInfo.optionActive
            return True, panes
            
    return False, panes
        

def ShowDockingGuides(guides, show):
    """
    Shows or hide the docking guide windows.

    :param `guides`: a list of L{AuiDockingGuideInfo} classes;
    :param `show`: whether to show or hide the docking guide windows.
    """

    for target in guides:
        
        if show and not target.host.IsShown():
            target.host.Show()
            target.host.Update()
        
        elif not show and target.host.IsShown():        
            target.host.Hide()
        

def RefreshDockingGuides(guides):
    """
    Refreshes the docking guide windows.

    :param `guides`: a list of L{AuiDockingGuideInfo} classes;
    """
    
    for target in guides:
        if target.host.IsShown():
            target.host.Refresh()
        
    
def PaneSortFunc(p1, p2):
    """
    This function is used to sort panes by dock position.

    :param `p1`: a L{AuiPaneInfo} instance;
    :param `p2`: another L{AuiPaneInfo} instance.    
    """
    
    return (p1.dock_pos < p2.dock_pos and [-1] or [1])[0]


def GetNotebookRoot(panes, notebook_id):
    """
    Returns the L{AuiPaneInfo} which has the specified `notebook_id`.

    :param `panes`: a list of L{AuiPaneInfo} instances;
    :param `notebook_id`: the target notebook id.
    """    

    for paneInfo in panes:
        if paneInfo.IsNotebookControl() and paneInfo.notebook_id == notebook_id:
            return paneInfo
        
    return None


def EscapeDelimiters(s):
    """
    Changes ``;`` into ``\`` and ``|`` into ``\|`` in the input string.  

    :param `s`: the string to be analyzed.

    :note: This is an internal functions which is used for saving perspectives.    
    """
    
    result = s.replace(";", "\\")
    result = result.replace("|", "|\\")
    
    return result


def IsDifferentDockingPosition(pane1, pane2):
    """
    Returns whether `pane1` and `pane2` are in a different docking position
    based on pane status, docking direction, docking layer and docking row.

    :param `pane1`: a L{AuiPaneInfo} instance;
    :param `pane2`: another L{AuiPaneInfo} instance.
    """

    return pane1.IsFloating() != pane2.IsFloating() or \
           pane1.dock_direction != pane2.dock_direction or \
           pane1.dock_layer != pane2.dock_layer or \
           pane1.dock_row != pane2.dock_row


# Convenience function
def AuiManager_HasLiveResize(manager):
    """
    Static function which returns if the input `manager` should have "live resize"
    behaviour.

    :param `manager`: an instance of L{AuiManager}.

    :note: This method always returns ``True`` on wxMac as this platform doesn't have
     the ability to use `wx.ScreenDC` to draw sashes.
    """

    # With Core Graphics on Mac, it's not possible to show sash feedback,
    # so we'll always use live update instead.
    
    if wx.Platform == "__WXMAC__":
        return True
    else:
        return (manager.GetAGWFlags() & AUI_MGR_LIVE_RESIZE) == AUI_MGR_LIVE_RESIZE


# Convenience function
def AuiManager_UseNativeMiniframes(manager):
    """
    Static function which returns if the input `manager` should use native `wx.MiniFrame` as
    floating panes.

    :param `manager`: an instance of L{AuiManager}.

    :note: This method always returns ``True`` on wxMac as this platform doesn't have
     the ability to use custom drawn miniframes.
    """

    # With Core Graphics on Mac, it's not possible to show sash feedback,
    # so we'll always use live update instead.
    
    if wx.Platform == "__WXMAC__":
        return True
    else:
        return (manager.GetAGWFlags() & AUI_MGR_USE_NATIVE_MINIFRAMES) == AUI_MGR_USE_NATIVE_MINIFRAMES


def GetManager(window):
    """
    This function will return the aui manager for a given window.
    
    :param `window`: this parameter should be any child window or grand-child
     window (and so on) of the frame/window managed by L{AuiManager}. The window
     does not need to be managed by the manager itself, nor does it even need
     to be a child or sub-child of a managed window. It must however be inside
     the window hierarchy underneath the managed window.
    """
    
    if not isinstance(wx.GetTopLevelParent(window), AuiFloatingFrame):
        if isinstance(window, auibar.AuiToolBar):
            return window.GetAuiManager()
    
    evt = AuiManagerEvent(wxEVT_AUI_FIND_MANAGER)
    evt.SetManager(None)
    evt.ResumePropagation(wx.EVENT_PROPAGATE_MAX)

    if not window.GetEventHandler().ProcessEvent(evt):
        return None

    return evt.GetManager()


# ---------------------------------------------------------------------------- #

class AuiManager(wx.EvtHandler):
    """
    AuiManager manages the panes associated with it for a particular `wx.Frame`,
    using a pane's L{AuiPaneInfo} information to determine each pane's docking and
    floating behavior. L{AuiManager} uses wxPython's sizer mechanism to plan the
    layout of each frame. It uses a replaceable dock art class to do all drawing,
    so all drawing is localized in one area, and may be customized depending on an
    applications' specific needs.

    L{AuiManager} works as follows: the programmer adds panes to the class, or makes
    changes to existing pane properties (dock position, floating state, show state, etc...).
    To apply these changes, the L{AuiManager.Update} function is called. This batch
    processing can be used to avoid flicker, by modifying more than one pane at a time,
    and then "committing" all of the changes at once by calling `Update()`.

    Panes can be added quite easily::

        text1 = wx.TextCtrl(self, -1)
        text2 = wx.TextCtrl(self, -1)
        self._mgr.AddPane(text1, AuiPaneInfo().Left().Caption("Pane Number One"))
        self._mgr.AddPane(text2, AuiPaneInfo().Bottom().Caption("Pane Number Two"))

        self._mgr.Update()


    Later on, the positions can be modified easily. The following will float an
    existing pane in a tool window::

        self._mgr.GetPane(text1).Float()


    **Layers, Rows and Directions, Positions:**
    
    Inside AUI, the docking layout is figured out by checking several pane parameters.
    Four of these are important for determining where a pane will end up.

    **Direction** - Each docked pane has a direction, `Top`, `Bottom`, `Left`, `Right`, or `Center`.
    This is fairly self-explanatory. The pane will be placed in the location specified
    by this variable.

    **Position** - More than one pane can be placed inside of a "dock". Imagine two panes
    being docked on the left side of a window. One pane can be placed over another.
    In proportionally managed docks, the pane position indicates it's sequential position,
    starting with zero. So, in our scenario with two panes docked on the left side, the
    top pane in the dock would have position 0, and the second one would occupy position 1. 

    **Row** - A row can allow for two docks to be placed next to each other. One of the most
    common places for this to happen is in the toolbar. Multiple toolbar rows are allowed,
    the first row being in row 0, and the second in row 1. Rows can also be used on
    vertically docked panes. 

    **Layer** - A layer is akin to an onion. Layer 0 is the very center of the managed pane.
    Thus, if a pane is in layer 0, it will be closest to the center window (also sometimes
    known as the "content window"). Increasing layers "swallow up" all layers of a lower
    value. This can look very similar to multiple rows, but is different because all panes
    in a lower level yield to panes in higher levels. The best way to understand layers
    is by running the AUI sample (`AUI.py`).
    """

    def __init__(self, managed_window=None, agwFlags=None):
        """
        Default class constructor.
        
        :param `managed_window`: specifies the window which should be managed;
        :param `agwFlags`: specifies options which allow the frame management behavior to be
         modified. `agwFlags` can be a combination of the following style bits:

         ==================================== ==================================
         Flag name                            Description
         ==================================== ==================================
         ``AUI_MGR_ALLOW_FLOATING``           Allow floating of panes
         ``AUI_MGR_ALLOW_ACTIVE_PANE``        If a pane becomes active, "highlight" it in the interface
         ``AUI_MGR_TRANSPARENT_DRAG``         If the platform supports it, set transparency on a floating pane while it is dragged by the user
         ``AUI_MGR_TRANSPARENT_HINT``         If the platform supports it, show a transparent hint window when the user is about to dock a floating pane
         ``AUI_MGR_VENETIAN_BLINDS_HINT``     Show a "venetian blind" effect when the user is about to dock a floating pane
         ``AUI_MGR_RECTANGLE_HINT``           Show a rectangle hint effect when the user is about to dock a floating pane
         ``AUI_MGR_HINT_FADE``                If the platform supports it, the hint window will fade in and out
         ``AUI_MGR_NO_VENETIAN_BLINDS_FADE``  Disables the "venetian blind" fade in and out
         ``AUI_MGR_LIVE_RESIZE``              Live resize when the user drag a sash
         ``AUI_MGR_ANIMATE_FRAMES``           Fade-out floating panes when they are closed (all platforms which support frames transparency) and show a moving rectangle when they are docked (Windows < Vista and GTK only)
         ``AUI_MGR_AERO_DOCKING_GUIDES``      Use the new Aero-style bitmaps as docking guides
         ``AUI_MGR_PREVIEW_MINIMIZED_PANES``  Slide in and out minimized panes to preview them
         ``AUI_MGR_WHIDBEY_DOCKING_GUIDES``   Use the new Whidbey-style bitmaps as docking guides
         ``AUI_MGR_SMOOTH_DOCKING``           Performs a "smooth" docking of panes (a la PyQT)
         ``AUI_MGR_USE_NATIVE_MINIFRAMES``    Use miniframes with native caption bar as floating panes instead or custom drawn caption bars (forced on wxMac)
         ``AUI_MGR_AUTONB_NO_CAPTION``        Panes that merge into an automatic notebook will not have the pane caption visible
         ==================================== ==================================

         Default value for `agwFlags` is:
         ``AUI_MGR_DEFAULT`` = ``AUI_MGR_ALLOW_FLOATING`` | ``AUI_MGR_TRANSPARENT_HINT`` | ``AUI_MGR_HINT_FADE`` | ``AUI_MGR_NO_VENETIAN_BLINDS_FADE``

         :note: If using the ``AUI_MGR_USE_NATIVE_MINIFRAMES``, double-clicking on a
          floating pane caption will not re-dock the pane, but simply maximize it (if
          L{AuiPaneInfo.MaximizeButton} has been set to ``True``) or do nothing.
        """

        wx.EvtHandler.__init__(self)
        
        self._action = actionNone
        self._action_window = None
        self._hover_button = None
        self._art = dockart.AuiDefaultDockArt()
        self._hint_window = None
        self._active_pane = None
        self._has_maximized = False
        self._has_minimized = False

        self._frame = None
        self._dock_constraint_x = 0.3
        self._dock_constraint_y = 0.3
        self._reserved = None
    
        self._panes = []
        self._docks = []
        self._uiparts = []
        
        self._guides = []
        self._notebooks = []

        self._masterManager = None
        self._currentDragItem = -1
        self._lastknowndocks = {}

        self._hint_fadetimer = wx.Timer(self, wx.ID_ANY)
        self._hint_fademax = 50
        self._last_hint = wx.Rect()

        self._from_move = False
        self._last_rect = wx.Rect()
        
        if agwFlags is None:
            agwFlags = AUI_MGR_DEFAULT
            
        self._agwFlags = agwFlags
        self._is_docked = (False, wx.RIGHT, wx.TOP, 0)
        self._snap_limits = (15, 15)

        if wx.Platform == "__WXMSW__":
            self._animation_step = 30.0
        else:
            self._animation_step = 5.0

        self._hint_rect = wx.Rect()

        self._preview_timer = wx.Timer(self, wx.ID_ANY)
        self._sliding_frame = None

        self._autoNBTabArt = tabart.AuiDefaultTabArt()
        self._autoNBStyle = AUI_NB_DEFAULT_STYLE | AUI_NB_BOTTOM | \
                            AUI_NB_SUB_NOTEBOOK | AUI_NB_TAB_EXTERNAL_MOVE
        self._autoNBStyle -= AUI_NB_DRAW_DND_TAB

        if managed_window:
            self.SetManagedWindow(managed_window)

        self.Bind(wx.EVT_PAINT, self.OnPaint)
        self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnEraseBackground)
        self.Bind(wx.EVT_SIZE, self.OnSize)
        self.Bind(wx.EVT_SET_CURSOR, self.OnSetCursor)
        self.Bind(wx.EVT_LEFT_DOWN, self.OnLeftDown)
        self.Bind(wx.EVT_LEFT_DCLICK, self.OnLeftDClick)
        self.Bind(wx.EVT_LEFT_UP, self.OnLeftUp)
        self.Bind(wx.EVT_MOTION, self.OnMotion)
        self.Bind(wx.EVT_LEAVE_WINDOW, self.OnLeaveWindow)
        self.Bind(wx.EVT_CHILD_FOCUS, self.OnChildFocus)
        self.Bind(wx.EVT_MOUSE_CAPTURE_LOST, self.OnCaptureLost)
        self.Bind(wx.EVT_TIMER, self.OnHintFadeTimer, self._hint_fadetimer)
        self.Bind(wx.EVT_TIMER, self.SlideIn, self._preview_timer)

        self.Bind(wx.EVT_MOVE, self.OnMove)
        self.Bind(wx.EVT_SYS_COLOUR_CHANGED, self.OnSysColourChanged)
        
        self.Bind(EVT_AUI_PANE_BUTTON, self.OnPaneButton)
        self.Bind(EVT_AUI_RENDER, self.OnRender)
        self.Bind(EVT_AUI_FIND_MANAGER, self.OnFindManager)
        self.Bind(EVT_AUI_PANE_MIN_RESTORE, self.OnRestoreMinimizedPane)
        self.Bind(EVT_AUI_PANE_DOCKED, self.OnPaneDocked)

        self.Bind(auibook.EVT_AUINOTEBOOK_BEGIN_DRAG, self.OnTabBeginDrag)
        self.Bind(auibook.EVT_AUINOTEBOOK_PAGE_CLOSE, self.OnTabPageClose)
        self.Bind(auibook.EVT_AUINOTEBOOK_PAGE_CHANGED, self.OnTabSelected)
        

    def CreateFloatingFrame(self, parent, pane_info):
        """
        Creates a floating frame for the windows.

        :param `parent`: the floating frame parent;
        :param `pane_info`: the L{AuiPaneInfo} class with all the pane's information.
        """

        return AuiFloatingFrame(parent, self, pane_info)


    def CanDockPanel(self, p):
        """
        Returns whether a pane can be docked or not.

        :param `p`: the L{AuiPaneInfo} class with all the pane's information.
        """        

        # is the pane dockable?
        if not p.IsDockable():
            return False

        # if a key modifier is pressed while dragging the frame,
        # don't dock the window
        return not (wx.GetKeyState(wx.WXK_CONTROL) or wx.GetKeyState(wx.WXK_ALT))


    def GetPaneByWidget(self, window):
        """
        This version of L{GetPane} looks up a pane based on a
        'pane window'.

        :param `window`: a `wx.Window` derived window.

        :see: L{GetPane}
        """

        for p in self._panes:
            if p.window == window:
                return p

        return NonePaneInfo


    def GetPaneByName(self, name):
        """
        This version of L{GetPane} looks up a pane based on a
        'pane name'.

        :param `name`: the pane name.

        :see: L{GetPane}        
        """
        
        for p in self._panes:
            if p.name == name:
                return p
        
        return NonePaneInfo


    def GetPane(self, item):
        """
        Looks up a L{AuiPaneInfo} structure based
        on the supplied window pointer. Upon failure, L{GetPane}
        returns an empty L{AuiPaneInfo}, a condition which can be checked
        by calling L{AuiPaneInfo.IsOk}.

        The pane info's structure may then be modified. Once a pane's
        info is modified, L{Update} must be called to
        realize the changes in the UI.

        :param `item`: either a pane name or a `wx.Window`.        
        """

        if isinstance(item, basestring):
            return self.GetPaneByName(item)
        else:
            return self.GetPaneByWidget(item)


    def GetAllPanes(self):
        """ Returns a reference to all the pane info structures. """
        
        return self._panes


    def ShowPane(self, window, show):
        """
        Shows or hides a pane based on the window passed as input.

        :param `window`: a `wx.Window` derived window;
        :param `show`: ``True`` to show the pane, ``False`` otherwise.
        """

        p = self.GetPane(window)
        
        if p.IsOk():
            if p.IsNotebookPage():
                if show:
                
                    notebook = self._notebooks[p.notebook_id]
                    id = notebook.GetPageIndex(p.window)
                    if id >= 0:
                        notebook.SetSelection(id)
                    self.ShowPane(notebook, True)
                
            else:
                p.Show(show)
                
            if p.frame:
                p.frame.Raise()
                
            self.Update()

            
    def HitTest(self, x, y):
        """
        This is an internal function which determines
        which UI item the specified coordinates are over.
        
        :param `x`: specifies a x position in client coordinates;
        :param `y`: specifies a y position in client coordinates.
        """

        result = None

        for item in self._uiparts:
            # we are not interested in typeDock, because this space 
            # isn't used to draw anything, just for measurements
            # besides, the entire dock area is covered with other
            # rectangles, which we are interested in.
            if item.type == AuiDockUIPart.typeDock:
                continue

            # if we already have a hit on a more specific item, we are not
            # interested in a pane hit.  If, however, we don't already have
            # a hit, returning a pane hit is necessary for some operations
            if item.type in [AuiDockUIPart.typePane, AuiDockUIPart.typePaneBorder] and result:
                continue
        
            # if the point is inside the rectangle, we have a hit
            if item.rect.Contains((x, y)):
                result = item
        
        return result


    def PaneHitTest(self, panes, pt):
        """
        Similar to L{HitTest}, but it checks in which L{AuiPaneInfo} rectangle the
        input point belongs to.

        :param `panes`: a list of L{AuiPaneInfo} instances;
        :param `pt`: a `wx.Point` object.
        """

        for paneInfo in panes:
            if paneInfo.IsDocked() and paneInfo.IsShown() and paneInfo.rect.Contains(pt):
                return paneInfo

        return NonePaneInfo


    # SetAGWFlags() and GetAGWFlags() allow the owner to set various
    # options which are global to AuiManager

    def SetAGWFlags(self, agwFlags):
        """
        This method is used to specify L{AuiManager}'s settings flags.

        :param `agwFlags`: specifies options which allow the frame management behavior
         to be modified. `agwFlags` can be one of the following style bits:

         ==================================== ==================================
         Flag name                            Description
         ==================================== ==================================
         ``AUI_MGR_ALLOW_FLOATING``           Allow floating of panes
         ``AUI_MGR_ALLOW_ACTIVE_PANE``        If a pane becomes active, "highlight" it in the interface
         ``AUI_MGR_TRANSPARENT_DRAG``         If the platform supports it, set transparency on a floating pane while it is dragged by the user
         ``AUI_MGR_TRANSPARENT_HINT``         If the platform supports it, show a transparent hint window when the user is about to dock a floating pane
         ``AUI_MGR_VENETIAN_BLINDS_HINT``     Show a "venetian blind" effect when the user is about to dock a floating pane
         ``AUI_MGR_RECTANGLE_HINT``           Show a rectangle hint effect when the user is about to dock a floating pane
         ``AUI_MGR_HINT_FADE``                If the platform supports it, the hint window will fade in and out
         ``AUI_MGR_NO_VENETIAN_BLINDS_FADE``  Disables the "venetian blind" fade in and out
         ``AUI_MGR_LIVE_RESIZE``              Live resize when the user drag a sash
         ``AUI_MGR_ANIMATE_FRAMES``           Fade-out floating panes when they are closed (all platforms which support frames transparency) and show a moving rectangle when they are docked (Windows < Vista and GTK only)
         ``AUI_MGR_AERO_DOCKING_GUIDES``      Use the new Aero-style bitmaps as docking guides
         ``AUI_MGR_PREVIEW_MINIMIZED_PANES``  Slide in and out minimized panes to preview them
         ``AUI_MGR_WHIDBEY_DOCKING_GUIDES``   Use the new Whidbey-style bitmaps as docking guides        
         ``AUI_MGR_SMOOTH_DOCKING``           Performs a "smooth" docking of panes (a la PyQT)
         ``AUI_MGR_USE_NATIVE_MINIFRAMES``    Use miniframes with native caption bar as floating panes instead or custom drawn caption bars (forced on wxMac)
         ``AUI_MGR_AUTONB_NO_CAPTION``        Panes that merge into an automatic notebook will not have the pane caption visible
         ==================================== ==================================

         :note: If using the ``AUI_MGR_USE_NATIVE_MINIFRAMES``, double-clicking on a
          floating pane caption will not re-dock the pane, but simply maximize it (if
          L{AuiPaneInfo.MaximizeButton} has been set to ``True``) or do nothing.
        
        """
        
        self._agwFlags = agwFlags

        if len(self._guides) > 0:
            self.CreateGuideWindows()

        if self._hint_window and agwFlags & AUI_MGR_RECTANGLE_HINT == 0:
            self.CreateHintWindow()


    def GetAGWFlags(self):
        """
        Returns the current manager's flags.

        :see: L{SetAGWFlags} for a list of possible L{AuiManager} flags.
        """
        
        return self._agwFlags
        

    def SetManagedWindow(self, managed_window):
        """
        Called to specify the frame or window which is to be managed by L{AuiManager}.
        Frame management is not restricted to just frames. Child windows or custom
        controls are also allowed.

        :param `managed_window`: specifies the window which should be managed by
         the AUI manager.
        """

        if not managed_window:
            raise Exception("Specified managed window must be non-null. ")
        
        self._frame = managed_window
        self._frame.PushEventHandler(self)

        # if the owner is going to manage an MDI parent frame,
        # we need to add the MDI client window as the default
        # center pane

        if isinstance(self._frame, wx.MDIParentFrame):
            mdi_frame = self._frame
            client_window = mdi_frame.GetClientWindow()

            if not client_window:
                raise Exception("Client window is None!")

            self.AddPane(client_window, AuiPaneInfo().Name("mdiclient").
                         CenterPane().PaneBorder(False))

        elif isinstance(self._frame, tabmdi.AuiMDIParentFrame):

            mdi_frame = self._frame
            client_window = mdi_frame.GetClientWindow()

            if not client_window:
                raise Exception("Client window is None!")

            self.AddPane(client_window, AuiPaneInfo().Name("mdiclient").
                         CenterPane().PaneBorder(False))


    def GetManagedWindow(self):
        """ Returns the window being managed by L{AuiManager}. """
        
        return self._frame


    def SetFrame(self, managed_window):
        """
        Called to specify the frame or window which is to be managed by L{AuiManager}.
        Frame management is not restricted to just frames. Child windows or custom
        controls are also allowed.

        :param `managed_window`: specifies the window which should be managed by
         the AUI manager.

        :warning: This method is now deprecated, use L{SetManagedWindow} instead.
        """

        DeprecationWarning("This method is deprecated, use SetManagedWindow instead.")
        return self.SetManagedWindow(managed_window)
    
        
    def GetFrame(self):
        """
        Returns the window being managed by L{AuiManager}.

        :warning: This method is now deprecated, use L{GetManagedWindow} instead.
        """

        DeprecationWarning("This method is deprecated, use GetManagedWindow instead.")        
        return self._frame


    def CreateGuideWindows(self):
        """ Creates the VS2005 HUD guide windows. """

        self.DestroyGuideWindows()

        self._guides.append(AuiDockingGuideInfo().Left().
                            Host(AuiSingleDockingGuide(self._frame, wx.LEFT)))
        self._guides.append(AuiDockingGuideInfo().Top().
                            Host(AuiSingleDockingGuide(self._frame, wx.TOP)))
        self._guides.append(AuiDockingGuideInfo().Right().
                            Host(AuiSingleDockingGuide(self._frame, wx.RIGHT)))
        self._guides.append(AuiDockingGuideInfo().Bottom().
                            Host(AuiSingleDockingGuide(self._frame, wx.BOTTOM)))
        self._guides.append(AuiDockingGuideInfo().Centre().
                            Host(AuiCenterDockingGuide(self._frame)))


    def DestroyGuideWindows(self):
        """ Destroys the VS2005 HUD guide windows. """

        for guide in self._guides:
            if guide.host:
                guide.host.Destroy()
        
        self._guides = []
    

    def CreateHintWindow(self):
        """ Creates the standard wxAUI hint window. """

        self.DestroyHintWindow()

        self._hint_window = AuiDockingHintWindow(self._frame)
        self._hint_window.SetBlindMode(self._agwFlags)


    def DestroyHintWindow(self):
        """ Destroys the standard wxAUI hint window. """

        if self._hint_window:

            self._hint_window.Destroy()
            self._hint_window = None


    def UnInit(self):
        """
        Uninitializes the framework and should be called before a managed frame or
        window is destroyed. L{UnInit} is usually called in the managed `wx.Frame`/`wx.Window`
        destructor.

        It is necessary to call this function before the managed frame or window is
        destroyed, otherwise the manager cannot remove its custom event handlers
        from a window.
        """

        if self._frame:
            self._frame.RemoveEventHandler(self)


    def GetArtProvider(self):
        """ Returns the current art provider being used. """
        
        return self._art


    def ProcessMgrEvent(self, event):
        """
        Process the AUI events sent to the manager.

        :param `event`: the event to process, an instance of L{AuiManagerEvent}.
        """

        # first, give the owner frame a chance to override
        if self._frame:
            if self._frame.GetEventHandler().ProcessEvent(event):
                return
        
        self.ProcessEvent(event)


    def FireEvent(self, evtType, pane, canVeto=False):
        """
        Fires one of the ``EVT_AUI_PANE_FLOATED``/``FLOATING``/``DOCKING``/``DOCKED`` event. 

        :param `evtType`: one of the aforementioned events;
        :param `pane`: the L{AuiPaneInfo} instance associated to this event;
        :param `canVeto`: whether the event can be vetoed or not.
        """        

        event = AuiManagerEvent(evtType)
        event.SetPane(pane)
        event.SetCanVeto(canVeto)
        self.ProcessMgrEvent(event)

        return event

    
    def CanUseModernDockArt(self):
        """
        Returns whether L{ModernDockArt} can be used (Windows XP / Vista / 7 only,
        requires Mark Hammonds's `pywin32` package).
        """

        if not _winxptheme:
            return False

        # Get the size of a small close button (themed)
        hwnd = self._frame.GetHandle()
        hTheme = winxptheme.OpenThemeData(hwnd, "Window")

        if not hTheme:
            return False

        return True
            
    
    def SetArtProvider(self, art_provider):
        """
        Instructs L{AuiManager} to use art provider specified by the parameter
        `art_provider` for all drawing calls. This allows plugable look-and-feel
        features.

        :param `art_provider`: a AUI dock art provider.

        :note: The previous art provider object, if any, will be deleted by L{AuiManager}.
        """

        # delete the last art provider, if any
        del self._art
        
        # assign the new art provider
        self._art = art_provider

        for pane in self.GetAllPanes():
            if pane.IsFloating() and pane.frame:                
                pane.frame._mgr.SetArtProvider(art_provider)
                pane.frame._mgr.Update()


    def AddPane(self, window, arg1=None, arg2=None, target=None):
        """
        Tells the frame manager to start managing a child window. There
        are four versions of this function. The first verison allows the full spectrum
        of pane parameter possibilities (L{AddPane1}). The second version is used for
        simpler user interfaces which do not require as much configuration (L{AddPane2}).
        The L{AddPane3} version allows a drop position to be specified, which will determine
        where the pane will be added. The L{AddPane4} version allows to turn the target
        L{AuiPaneInfo} pane into a notebook and the added pane into a page.

        In wxPython, simply call L{AddPane}.

        :param `window`: the child window to manage;
        :param `arg1`: a L{AuiPaneInfo} or an integer value (direction);
        :param `arg2`: a L{AuiPaneInfo} or a `wx.Point` (drop position);
        :param `target`: a L{AuiPaneInfo} to be turned into a notebook
         and new pane added to it as a page. (additionally, target can be any pane in 
         an existing notebook)
         """
 
        if target in self._panes:
            return self.AddPane4(window, arg1, target)

        if type(arg1) == type(1):
            # This Is Addpane2
            if arg1 is None:
                arg1 = wx.LEFT
            if arg2 is None:
                arg2 = ""
            return self.AddPane2(window, arg1, arg2)
        else:
            if isinstance(arg2, wx.Point):
                return self.AddPane3(window, arg1, arg2)
            else:
                return self.AddPane1(window, arg1)
        

    def AddPane1(self, window, pane_info):
        """ See comments on L{AddPane}. """

        # check if the pane has a valid window
        if not window:
            return False

        # check if the pane already exists
        if self.GetPane(pane_info.window).IsOk():
            return False

        # check if the pane name already exists, this could reveal a
        # bug in the library user's application
        already_exists = False
        if pane_info.name != "" and self.GetPane(pane_info.name).IsOk():
            warnings.warn("A pane with that name already exists in the manager!")
            already_exists = True

        # if the new pane is docked then we should undo maximize
        if pane_info.IsDocked():
            self.RestoreMaximizedPane()

        self._panes.append(pane_info)
        pinfo = self._panes[-1]

        # set the pane window
        pinfo.window = window

        # if the pane's name identifier is blank, create a random string
        if pinfo.name == "" or already_exists:
            pinfo.name = ("%s%08x%08x%08x")%(pinfo.window.GetName(), time.time(),
                                             time.clock(), len(self._panes))

        # set initial proportion (if not already set)
        if pinfo.dock_proportion == 0:
            pinfo.dock_proportion = 100000

        floating = isinstance(self._frame, AuiFloatingFrame)

        pinfo.buttons = []

        if not floating and pinfo.HasMinimizeButton():
            button = AuiPaneButton(AUI_BUTTON_MINIMIZE)
            pinfo.buttons.append(button)
    
        if not floating and pinfo.HasMaximizeButton():
            button = AuiPaneButton(AUI_BUTTON_MAXIMIZE_RESTORE)
            pinfo.buttons.append(button)

        if not floating and pinfo.HasPinButton():
            button = AuiPaneButton(AUI_BUTTON_PIN)
            pinfo.buttons.append(button)

        if pinfo.HasCloseButton():
            button = AuiPaneButton(AUI_BUTTON_CLOSE)
            pinfo.buttons.append(button)

        if pinfo.HasGripper():
            if isinstance(pinfo.window, auibar.AuiToolBar):
                # prevent duplicate gripper -- both AuiManager and AuiToolBar
                # have a gripper control.  The toolbar's built-in gripper
                # meshes better with the look and feel of the control than ours,
                # so turn AuiManager's gripper off, and the toolbar's on.

                tb = pinfo.window
                pinfo.SetFlag(AuiPaneInfo.optionGripper, False)
                tb.SetGripperVisible(True)

        if pinfo.window:
            if pinfo.best_size == wx.Size(-1, -1):
                pinfo.best_size = pinfo.window.GetClientSize()

            if isinstance(pinfo.window, wx.ToolBar):
                # GetClientSize() doesn't get the best size for
                # a toolbar under some newer versions of wxWidgets,
                # so use GetBestSize()
                pinfo.best_size = pinfo.window.GetBestSize()

                # this is needed for Win2000 to correctly fill toolbar backround
                # it should probably be repeated once system colour change happens
                if wx.Platform == "__WXMSW__" and pinfo.window.UseBgCol():
                    pinfo.window.SetBackgroundColour(self.GetArtProvider().GetColour(AUI_DOCKART_BACKGROUND_COLOUR))
                
            if pinfo.min_size != wx.Size(-1, -1):
                if pinfo.best_size.x < pinfo.min_size.x:
                    pinfo.best_size.x = pinfo.min_size.x
                if pinfo.best_size.y < pinfo.min_size.y:
                    pinfo.best_size.y = pinfo.min_size.y

        self._panes[-1] = pinfo
        if isinstance(window, auibar.AuiToolBar):
            window.SetAuiManager(self)

        return True


    def AddPane2(self, window, direction, caption):
        """ See comments on L{AddPane}. """
        
        pinfo = AuiPaneInfo()
        pinfo.Caption(caption)
        
        if direction == wx.TOP:
            pinfo.Top()
        elif direction == wx.BOTTOM:
            pinfo.Bottom()
        elif direction == wx.LEFT:
            pinfo.Left()
        elif direction == wx.RIGHT:
            pinfo.Right()
        elif direction == wx.CENTER:
            pinfo.CenterPane()
        
        return self.AddPane(window, pinfo)


    def AddPane3(self, window, pane_info, drop_pos):
        """ See comments on L{AddPane}. """
        
        if not self.AddPane(window, pane_info):
            return False

        pane = self.GetPane(window)
        indx = self._panes.index(pane)

        ret, pane = self.DoDrop(self._docks, self._panes, pane, drop_pos, wx.Point(0, 0))
        self._panes[indx] = pane

        return True


    def AddPane4(self, window, pane_info, target):
        """ See comments on L{AddPane}. """
        
        if not self.AddPane(window, pane_info):
            return False
               
        paneInfo = self.GetPane(window)
        
        if not paneInfo.IsNotebookDockable():
            return self.AddPane1(window, pane_info)
        if not target.IsNotebookDockable() and not target.IsNotebookControl():
            return self.AddPane1(window, pane_info)

        if not target.HasNotebook():
            self.CreateNotebookBase(self._panes, target)
        
        # Add new item to notebook
        paneInfo.NotebookPage(target.notebook_id)

        # we also want to remove our captions sometimes
        self.RemoveAutoNBCaption(paneInfo)
        self.UpdateNotebook()
        
        return True


    def InsertPane(self, window, pane_info, insert_level=AUI_INSERT_PANE):
        """
        This method is used to insert either a previously unmanaged pane window
        into the frame manager, or to insert a currently managed pane somewhere else.
        L{InsertPane} will push all panes, rows, or docks aside and insert the window
        into the position specified by `pane_info`.

        Because `pane_info` can specify either a pane, dock row, or dock layer, the
        `insert_level` parameter is used to disambiguate this. The parameter `insert_level`
        can take a value of ``AUI_INSERT_PANE``, ``AUI_INSERT_ROW`` or ``AUI_INSERT_DOCK``.

        :param `window`: the window to be inserted and managed;
        :param `pane_info`: the insert location for the new window;
        :param `insert_level`: the insertion level of the new pane.
        """

        if not window:
            raise Exception("Invalid window passed to InsertPane.")
                            
        # shift the panes around, depending on the insert level
        if insert_level == AUI_INSERT_PANE:
            self._panes = DoInsertPane(self._panes, pane_info.dock_direction,
                                       pane_info.dock_layer, pane_info.dock_row,
                                       pane_info.dock_pos)

        elif insert_level == AUI_INSERT_ROW:
            self._panes = DoInsertDockRow(self._panes, pane_info.dock_direction,
                                          pane_info.dock_layer, pane_info.dock_row)

        elif insert_level == AUI_INSERT_DOCK:
            self._panes = DoInsertDockLayer(self._panes, pane_info.dock_direction,
                                            pane_info.dock_layer)
        
        # if the window already exists, we are basically just moving/inserting the
        # existing window.  If it doesn't exist, we need to add it and insert it
        existing_pane = self.GetPane(window)
        indx = self._panes.index(existing_pane)
        
        if not existing_pane.IsOk():
        
            return self.AddPane(window, pane_info)
        
        else:
        
            if pane_info.IsFloating():
                existing_pane.Float()
                if pane_info.floating_pos != wx.Point(-1, -1):
                    existing_pane.FloatingPosition(pane_info.floating_pos)
                if pane_info.floating_size != wx.Size(-1, -1):
                    existing_pane.FloatingSize(pane_info.floating_size)
            else:
                # if the new pane is docked then we should undo maximize
                self.RestoreMaximizedPane()

                existing_pane.Direction(pane_info.dock_direction)
                existing_pane.Layer(pane_info.dock_layer)
                existing_pane.Row(pane_info.dock_row)
                existing_pane.Position(pane_info.dock_pos)

            self._panes[indx] = existing_pane                
            
        return True

    
    def DetachPane(self, window):
        """
        Tells the L{AuiManager} to stop managing the pane specified
        by `window`. The window, if in a floated frame, is reparented to the frame
        managed by L{AuiManager}.

        :param `window`: the window to be un-managed.
        """
        
        for p in self._panes:
            if p.window == window:
                if p.frame:
                    # we have a floating frame which is being detached. We need to
                    # reparent it to self._frame and destroy the floating frame

                    # reduce flicker
                    p.window.SetSize((1, 1))
                    if p.frame.IsShown():
                        p.frame.Show(False)

                    if self._action_window == p.frame:
                        self._action_window = None
                        
                    # reparent to self._frame and destroy the pane
                    p.window.Reparent(self._frame)
                    p.frame.SetSizer(None)
                    p.frame.Destroy()
                    p.frame = None

                elif p.IsNotebookPage():
                    notebook = self._notebooks[p.notebook_id]
                    id = notebook.GetPageIndex(p.window)
                    notebook.RemovePage(id)
                
                # make sure there are no references to this pane in our uiparts,
                # just in case the caller doesn't call Update() immediately after
                # the DetachPane() call.  This prevets obscure crashes which would
                # happen at window repaint if the caller forgets to call Update()
                counter = 0
                for pi in xrange(len(self._uiparts)):
                    part = self._uiparts[counter]
                    if part.pane == p:
                        self._uiparts.pop(counter)
                        counter -= 1

                    counter += 1
            
                self._panes.remove(p)
                return True
        
        return False


    def ClosePane(self, pane_info):
        """
        Destroys or hides the pane depending on its flags.

        :param `pane_info`: a L{AuiPaneInfo} instance.
        """

        # if we were maximized, restore
        if pane_info.IsMaximized():
            self.RestorePane(pane_info)

        if pane_info.frame:
            if self._agwFlags & AUI_MGR_ANIMATE_FRAMES:
                pane_info.frame.FadeOut()

        # first, hide the window
        if pane_info.window and pane_info.window.IsShown():
            pane_info.window.Show(False)

        # make sure that we are the parent of this window
        if pane_info.window and pane_info.window.GetParent() != self._frame:
            pane_info.window.Reparent(self._frame)

        # if we have a frame, destroy it
        if pane_info.frame:
            pane_info.frame.Destroy()
            pane_info.frame = None
            
        elif pane_info.IsNotebookPage():
            # if we are a notebook page, remove ourselves...
            # the  code would index out of bounds 
            # if the last page of a sub-notebook was closed
            # because the notebook would be deleted, before this
            # code is executed.
            # This code just prevents an out-of bounds error.
            if self._notebooks:
                nid = pane_info.notebook_id
                if nid >= 0 and nid < len(self._notebooks):
                    notebook = self._notebooks[nid]
                    page_idx = notebook.GetPageIndex(pane_info.window)
                    if page_idx >= 0:
                        notebook.RemovePage(page_idx)
                                
        # now we need to either destroy or hide the pane
        to_destroy = 0
        if pane_info.IsDestroyOnClose():
            to_destroy = pane_info.window
            self.DetachPane(to_destroy)
        else:
            if isinstance(pane_info.window, auibar.AuiToolBar) and pane_info.IsFloating():
                tb = pane_info.window
                if pane_info.dock_direction in [AUI_DOCK_LEFT, AUI_DOCK_RIGHT]:
                    tb.SetAGWWindowStyleFlag(tb.GetAGWWindowStyleFlag() | AUI_TB_VERTICAL)
                
            pane_info.Dock().Hide()

        if pane_info.IsNotebookControl():

            notebook = self._notebooks[pane_info.notebook_id]
            while notebook.GetPageCount():
                window = notebook.GetPage(0)
                notebook.RemovePage(0)
                info = self.GetPane(window)
                if info.IsOk():
                    info.notebook_id = -1
                    info.dock_direction = AUI_DOCK_NONE
                    # Note: this could change our paneInfo reference ...
                    self.ClosePane(info)

        if to_destroy:
            to_destroy.Destroy()


    def MaximizePane(self, pane_info, savesizes=True):
        """
        Maximizes the input pane.

        :param `pane_info`: a L{AuiPaneInfo} instance.
        :param `savesizes`: whether to save previous dock sizes.
        """

        if savesizes:
            self.SavePreviousDockSizes(pane_info)
                
        for p in self._panes:
            
            # save hidden state
            p.SetFlag(p.savedHiddenState, p.HasFlag(p.optionHidden))

            if not p.IsToolbar() and not p.IsFloating():
                p.Restore()
        
                # hide the pane, because only the newly
                # maximized pane should show
                p.Hide()

        pane_info.previousDockPos = pane_info.dock_pos

        # mark ourselves maximized
        pane_info.Maximize()
        pane_info.Show()
        self._has_maximized = True

        # last, show the window
        if pane_info.window and not pane_info.window.IsShown():
            pane_info.window.Show(True)

            
    def SavePreviousDockSizes(self, pane_info):
        """
        Stores the previous dock sizes, to be used in a "restore" action later.

        :param `pane_info`: a L{AuiPaneInfo} instance.
        """

        for d in self._docks:
            if not d.toolbar:
                for p in d.panes:
                    p.previousDockSize = d.size
                    if pane_info is not p:
                        p.SetFlag(p.needsRestore, True)

        
    def RestorePane(self, pane_info):
        """
        Restores the input pane from a previous maximized or minimized state.

        :param `pane_info`: a L{AuiPaneInfo} instance.
        """
        
        # restore all the panes
        for p in self._panes:
            if not p.IsToolbar():
                p.SetFlag(p.optionHidden, p.HasFlag(p.savedHiddenState))

        pane_info.SetFlag(pane_info.needsRestore, True)

        # mark ourselves non-maximized
        pane_info.Restore()
        self._has_maximized = False
        self._has_minimized = False

        # last, show the window
        if pane_info.window and not pane_info.window.IsShown():
            pane_info.window.Show(True)


    def RestoreMaximizedPane(self):
        """ Restores the current maximized pane (if any). """
        
        # restore all the panes
        for p in self._panes:
            if p.IsMaximized():
                self.RestorePane(p)
                break


    def ActivatePane(self, window):
        """
        Activates the pane to which `window` is associated.

        :param `window`: a `wx.Window` derived window.
        """

        if self.GetAGWFlags() & AUI_MGR_ALLOW_ACTIVE_PANE:
            while window:
                ret, self._panes = SetActivePane(self._panes, window)
                if ret:
                    break

                window = window.GetParent()

            self.RefreshCaptions()
            

    def CreateNotebook(self):
        """
        Creates an automatic L{AuiNotebook} when a pane is docked on
        top of another pane.
        """

        notebook = auibook.AuiNotebook(self._frame, -1, wx.Point(0, 0), wx.Size(0, 0), agwStyle=self._autoNBStyle)

        # This is so we can get the tab-drag event.
        notebook.GetAuiManager().SetMasterManager(self)
        notebook.SetArtProvider(self._autoNBTabArt.Clone())
        self._notebooks.append(notebook)

        return notebook


    def SetAutoNotebookTabArt(self, art):
        """
        Sets the default tab art provider for automatic notebooks.

        :param `art`: a tab art provider.
        """

        for nb in self._notebooks:
            nb.SetArtProvider(art.Clone())
            nb.Refresh()
            nb.Update()

        self._autoNBTabArt = art


    def GetAutoNotebookTabArt(self):
        """ Returns the default tab art provider for automatic notebooks. """

        return self._autoNBTabArt        
        

    def SetAutoNotebookStyle(self, agwStyle):
        """
        Sets the default AGW-specific window style for automatic notebooks.

        :param `agwStyle`: the underlying L{AuiNotebook} window style.
         This can be a combination of the following bits:
        
         ==================================== ==================================
         Flag name                            Description
         ==================================== ==================================
         ``AUI_NB_TOP``                       With this style, tabs are drawn along the top of the notebook
         ``AUI_NB_LEFT``                      With this style, tabs are drawn along the left of the notebook. Not implemented yet.
         ``AUI_NB_RIGHT``                     With this style, tabs are drawn along the right of the notebook. Not implemented yet.
         ``AUI_NB_BOTTOM``                    With this style, tabs are drawn along the bottom of the notebook
         ``AUI_NB_TAB_SPLIT``                 Allows the tab control to be split by dragging a tab
         ``AUI_NB_TAB_MOVE``                  Allows a tab to be moved horizontally by dragging
         ``AUI_NB_TAB_EXTERNAL_MOVE``         Allows a tab to be moved to another tab control
         ``AUI_NB_TAB_FIXED_WIDTH``           With this style, all tabs have the same width
         ``AUI_NB_SCROLL_BUTTONS``            With this style, left and right scroll buttons are displayed
         ``AUI_NB_WINDOWLIST_BUTTON``         With this style, a drop-down list of windows is available
         ``AUI_NB_CLOSE_BUTTON``              With this style, a close button is available on the tab bar
         ``AUI_NB_CLOSE_ON_ACTIVE_TAB``       With this style, a close button is available on the active tab
         ``AUI_NB_CLOSE_ON_ALL_TABS``         With this style, a close button is available on all tabs
         ``AUI_NB_MIDDLE_CLICK_CLOSE``        Allows to close L{AuiNotebook} tabs by mouse middle button click
         ``AUI_NB_SUB_NOTEBOOK``              This style is used by {AuiManager} to create automatic AuiNotebooks
         ``AUI_NB_HIDE_ON_SINGLE_TAB``        Hides the tab window if only one tab is present
         ``AUI_NB_SMART_TABS``                Use Smart Tabbing, like ``Alt`` + ``Tab`` on Windows
         ``AUI_NB_USE_IMAGES_DROPDOWN``       Uses images on dropdown window list menu instead of check items
         ``AUI_NB_CLOSE_ON_TAB_LEFT``         Draws the tab close button on the left instead of on the right (a la Camino browser)
         ``AUI_NB_TAB_FLOAT``                 Allows the floating of single tabs. Known limitation: when the notebook is more or less full screen, tabs cannot be dragged far enough outside of the notebook to become floating pages
         ``AUI_NB_DRAW_DND_TAB``              Draws an image representation of a tab while dragging (on by default)
         ==================================== ==================================

        """

        for nb in self._notebooks:
            nb.SetAGWWindowStyleFlag(agwStyle)
            nb.Refresh()
            nb.Update()

        self._autoNBStyle = agwStyle


    def GetAutoNotebookStyle(self):
        """
        Returns the default AGW-specific window style for automatic notebooks.

        :see: L{SetAutoNotebookStyle} method for a list of possible styles.
        """

        return self._autoNBStyle


    def SavePaneInfo(self, pane):
        """
        This method is similar to L{SavePerspective}, with the exception
        that it only saves information about a single pane. It is used in
        combination with L{LoadPaneInfo}.

        :param `pane`: a L{AuiPaneInfo} instance to save.        
        """

        result = "name=" + EscapeDelimiters(pane.name) + ";"
        result += "caption=" + EscapeDelimiters(pane.caption) + ";"

        result += "state=%u;"%pane.state
        result += "dir=%d;"%pane.dock_direction
        result += "layer=%d;"%pane.dock_layer
        result += "row=%d;"%pane.dock_row
        result += "pos=%d;"%pane.dock_pos
        result += "prop=%d;"%pane.dock_proportion
        result += "bestw=%d;"%pane.best_size.x
        result += "besth=%d;"%pane.best_size.y
        result += "minw=%d;"%pane.min_size.x
        result += "minh=%d;"%pane.min_size.y
        result += "maxw=%d;"%pane.max_size.x
        result += "maxh=%d;"%pane.max_size.y
        result += "floatx=%d;"%pane.floating_pos.x
        result += "floaty=%d;"%pane.floating_pos.y
        result += "floatw=%d;"%pane.floating_size.x
        result += "floath=%d;"%pane.floating_size.y
        result += "notebookid=%d;"%pane.notebook_id
        result += "transparent=%d"%pane.transparent

        return result


    def LoadPaneInfo(self, pane_part, pane):
        """
        This method is similar to to L{LoadPerspective}, with the exception that
        it only loads information about a single pane. It is used in combination
        with L{SavePaneInfo}.

        :param `pane_part`: the string to analyze;
        :param `pane`: the L{AuiPaneInfo} structure in which to load `pane_part`.
        """

        # replace escaped characters so we can
        # split up the string easily
        pane_part = pane_part.replace("\\|", "\a")
        pane_part = pane_part.replace("\\;", "\b")

        options = pane_part.split(";")
        for items in options:

            val_name, value = items.split("=")
            val_name = val_name.strip()

            if val_name == "name":
                pane.name = value
            elif val_name == "caption":
                pane.caption = value
            elif val_name == "state":
                pane.state = int(value)
            elif val_name == "dir":
                pane.dock_direction = int(value)
            elif val_name == "layer":
                pane.dock_layer = int(value)
            elif val_name == "row":
                pane.dock_row = int(value)
            elif val_name == "pos":
                pane.dock_pos = int(value)
            elif val_name == "prop":
                pane.dock_proportion = int(value)
            elif val_name == "bestw":
                pane.best_size.x = int(value)
            elif val_name == "besth":
                pane.best_size.y = int(value)
                pane.best_size = wx.Size(pane.best_size.x, pane.best_size.y)
            elif val_name == "minw":
                pane.min_size.x = int(value)
            elif val_name == "minh":
                pane.min_size.y = int(value)
                pane.min_size = wx.Size(pane.min_size.x, pane.min_size.y)
            elif val_name == "maxw":
                pane.max_size.x = int(value)
            elif val_name == "maxh":
                pane.max_size.y = int(value)
                pane.max_size = wx.Size(pane.max_size.x, pane.max_size.y)
            elif val_name == "floatx":
                pane.floating_pos.x = int(value)
            elif val_name == "floaty":
                pane.floating_pos.y = int(value)
                pane.floating_pos = wx.Point(pane.floating_pos.x, pane.floating_pos.y)
            elif val_name == "floatw":
                pane.floating_size.x = int(value)
            elif val_name == "floath":
                pane.floating_size.y = int(value)
                pane.floating_size = wx.Size(pane.floating_size.x, pane.floating_size.y)
            elif val_name == "notebookid":
                pane.notebook_id = int(value)
            elif val_name == "transparent":
                pane.transparent = int(value)
            else:
                raise Exception("Bad perspective string")

        # replace escaped characters so we can
        # split up the string easily
        pane.name = pane.name.replace("\a", "|")
        pane.name = pane.name.replace("\b", ";")
        pane.caption = pane.caption.replace("\a", "|")
        pane.caption = pane.caption.replace("\b", ";")
        pane_part = pane_part.replace("\a", "|")
        pane_part = pane_part.replace("\b", ";")

        return pane
    

    def SavePerspective(self):
        """
        Saves the entire user interface layout into an encoded string, which can then
        be stored by the application (probably using `wx.Config`).

        When a perspective is restored using L{LoadPerspective}, the entire user
        interface will return to the state it was when the perspective was saved.
        """

        result = "layout2|"

        for pane in self._panes:
            result += self.SavePaneInfo(pane) + "|"
        
        for dock in self._docks:
            result = result + ("dock_size(%d,%d,%d)=%d|")%(dock.dock_direction,
                                                           dock.dock_layer,
                                                           dock.dock_row,
                                                           dock.size)
        return result


    def LoadPerspective(self, layout, update=True):
        """
        Loads a layout which was saved with L{SavePerspective}.
        
        If the `update` flag parameter is ``True``, L{Update} will be
        automatically invoked, thus realizing the saved perspective on screen.

        :param `layout`: a string which contains a saved AUI layout;
        :param `update`: whether to update immediately the window or not.
        """

        input = layout

        # check layout string version
        #    'layout1' = wxAUI 0.9.0 - wxAUI 0.9.2
        #    'layout2' = wxAUI 0.9.2 (wxWidgets 2.8)
        index = input.find("|")
        part = input[0:index].strip()
        input = input[index+1:]
        
        if part != "layout2":
            return False

        # mark all panes currently managed as docked and hidden
        for pane in self._panes:
            pane.Dock().Hide()

        # clear out the dock array; this will be reconstructed
        self._docks = []

        # replace escaped characters so we can
        # split up the string easily
        input = input.replace("\\|", "\a")
        input = input.replace("\\;", "\b")

        while 1:

            pane = AuiPaneInfo()
            index = input.find("|")
            pane_part = input[0:index].strip()
            input = input[index+1:]

            # if the string is empty, we're done parsing
            if pane_part == "":
                break

            if pane_part[0:9] == "dock_size":
                index = pane_part.find("=")
                val_name = pane_part[0:index]
                value = pane_part[index+1:]

                index = val_name.find("(")
                piece = val_name[index+1:]
                index = piece.find(")")
                piece = piece[0:index]

                vals = piece.split(",")
                dir = int(vals[0])
                layer = int(vals[1])
                row = int(vals[2])
                size = int(value)
                
                dock = AuiDockInfo()
                dock.dock_direction = dir
                dock.dock_layer = layer
                dock.dock_row = row
                dock.size = size
                self._docks.append(dock)
                
                continue

            # Undo our escaping as LoadPaneInfo needs to take an unescaped
            # name so it can be called by external callers
            pane_part = pane_part.replace("\a", "|")
            pane_part = pane_part.replace("\b", ";")

            pane = self.LoadPaneInfo(pane_part, pane)

            p = self.GetPane(pane.name)
                
            if not p.IsOk():
                if pane.IsNotebookControl():
                    # notebook controls - auto add...
                    self._panes.append(pane)
                    indx = self._panes.index(pane)
                else:
                    # the pane window couldn't be found
                    # in the existing layout -- skip it
                    continue

            else:
                indx = self._panes.index(p)
            pane.window = p.window
            pane.frame = p.frame
            pane.buttons = p.buttons
            self._panes[indx] = pane

            if isinstance(pane.window, auibar.AuiToolBar) and (pane.IsFloatable() or pane.IsDockable()):
                pane.window.SetGripperVisible(True)
            
        if update:
            self.Update()

        return True


    def GetPanePositionsAndSizes(self, dock):
        """
        Returns all the panes positions and sizes in a dock.

        :param `dock`: a L{AuiDockInfo} instance.
        """
        
        caption_size = self._art.GetMetric(AUI_DOCKART_CAPTION_SIZE)
        pane_border_size = self._art.GetMetric(AUI_DOCKART_PANE_BORDER_SIZE)
        gripper_size = self._art.GetMetric(AUI_DOCKART_GRIPPER_SIZE)

        positions = []
        sizes = []

        action_pane = -1
        pane_count = len(dock.panes)

        # find the pane marked as our action pane
        for pane_i in xrange(pane_count):
            pane = dock.panes[pane_i]
            if pane.HasFlag(AuiPaneInfo.actionPane):
                if action_pane != -1:
                    raise Exception("Too many action panes!")
                action_pane = pane_i
            
        # set up each panes default position, and
        # determine the size (width or height, depending
        # on the dock's orientation) of each pane
        for pane in dock.panes:
            positions.append(pane.dock_pos)
            size = 0
            
            if pane.HasBorder():
                size += pane_border_size*2
                    
            if dock.IsHorizontal():
                if pane.HasGripper() and not pane.HasGripperTop():
                    size += gripper_size

                if pane.HasCaptionLeft():
                    size += caption_size
                    
                size += pane.best_size.x
                 
            else:
                if pane.HasGripper() and pane.HasGripperTop():
                    size += gripper_size

                if pane.HasCaption() and not pane.HasCaptionLeft():
                    size += caption_size
                    
                size += pane.best_size.y
       
            sizes.append(size)

        # if there is no action pane, just return the default
        # positions (as specified in pane.pane_pos)
        if action_pane == -1:
            return positions, sizes

        offset = 0
        for pane_i in xrange(action_pane-1, -1, -1):
            amount = positions[pane_i+1] - (positions[pane_i] + sizes[pane_i])
            if amount >= 0:
                offset += amount
            else:
                positions[pane_i] -= -amount

            offset += sizes[pane_i]
        
        # if the dock mode is fixed, make sure none of the panes
        # overlap we will bump panes that overlap
        offset = 0
        for pane_i in xrange(action_pane, pane_count):
            amount = positions[pane_i] - offset
            if amount >= 0:
                offset += amount
            else:
                positions[pane_i] += -amount

            offset += sizes[pane_i]

        return positions, sizes
    

    def LayoutAddPane(self, cont, dock, pane, uiparts, spacer_only):
        """
        Adds a pane into the existing layout (in an existing dock).

        :param `cont`: a `wx.Sizer` object;
        :param `dock`: the L{AuiDockInfo} structure in which to add the pane;
        :param `pane`: the L{AuiPaneInfo} instance to add to the dock;
        :param `uiparts`: a list of UI parts in the interface;
        :param `spacer_only`: whether to add a simple spacer or a real window.
        """
        
        sizer_item = wx.SizerItem()
        caption_size = self._art.GetMetric(AUI_DOCKART_CAPTION_SIZE)
        gripper_size = self._art.GetMetric(AUI_DOCKART_GRIPPER_SIZE)
        pane_border_size = self._art.GetMetric(AUI_DOCKART_PANE_BORDER_SIZE)
        pane_button_size = self._art.GetMetric(AUI_DOCKART_PANE_BUTTON_SIZE)

        # find out the orientation of the item (orientation for panes
        # is the same as the dock's orientation)

        if dock.IsHorizontal():
            orientation = wx.HORIZONTAL
        else:
            orientation = wx.VERTICAL

        # this variable will store the proportion
        # value that the pane will receive
        pane_proportion = pane.dock_proportion

        horz_pane_sizer = wx.BoxSizer(wx.HORIZONTAL)
        vert_pane_sizer = wx.BoxSizer(wx.VERTICAL)

        if pane.HasGripper():
            
            part = AuiDockUIPart()
            if pane.HasGripperTop():
                sizer_item = vert_pane_sizer.Add((1, gripper_size), 0, wx.EXPAND)
            else:
                sizer_item = horz_pane_sizer.Add((gripper_size, 1), 0, wx.EXPAND)

            part.type = AuiDockUIPart.typeGripper
            part.dock = dock
            part.pane = pane
            part.button = None
            part.orientation = orientation
            part.cont_sizer = horz_pane_sizer
            part.sizer_item = sizer_item
            uiparts.append(part)

        button_count = len(pane.buttons)
        button_width_total = button_count*pane_button_size
        if button_count >= 1:
            button_width_total += 3

        caption, captionLeft = pane.HasCaption(), pane.HasCaptionLeft()
        button_count = len(pane.buttons)

        if captionLeft:
            caption_sizer = wx.BoxSizer(wx.VERTICAL)

            # add pane buttons to the caption
            dummy_parts = []
            for btn_id in xrange(len(pane.buttons)-1, -1, -1):
                sizer_item = caption_sizer.Add((caption_size, pane_button_size), 0, wx.EXPAND)
                part = AuiDockUIPart()
                part.type = AuiDockUIPart.typePaneButton
                part.dock = dock
                part.pane = pane
                part.button = pane.buttons[btn_id]
                part.orientation = orientation
                part.cont_sizer = caption_sizer
                part.sizer_item = sizer_item
                dummy_parts.append(part)
            
            sizer_item = caption_sizer.Add((caption_size, 1), 1, wx.EXPAND)
            vert_pane_sizer = wx.BoxSizer(wx.HORIZONTAL)

            # create the caption sizer
            part = AuiDockUIPart()

            part.type = AuiDockUIPart.typeCaption
            part.dock = dock
            part.pane = pane
            part.button = None
            part.orientation = orientation
            part.cont_sizer = vert_pane_sizer
            part.sizer_item = sizer_item
            caption_part_idx = len(uiparts)
            uiparts.append(part)
            uiparts.extend(dummy_parts)

        elif caption:

            caption_sizer = wx.BoxSizer(wx.HORIZONTAL)
            sizer_item = caption_sizer.Add((1, caption_size), 1, wx.EXPAND)

            # create the caption sizer
            part = AuiDockUIPart()

            part.type = AuiDockUIPart.typeCaption
            part.dock = dock
            part.pane = pane
            part.button = None
            part.orientation = orientation
            part.cont_sizer = vert_pane_sizer
            part.sizer_item = sizer_item
            caption_part_idx = len(uiparts)
            uiparts.append(part)

            # add pane buttons to the caption
            for button in pane.buttons:
                sizer_item = caption_sizer.Add((pane_button_size, caption_size), 0, wx.EXPAND)                        
                part = AuiDockUIPart()
                part.type = AuiDockUIPart.typePaneButton
                part.dock = dock
                part.pane = pane
                part.button = button
                part.orientation = orientation
                part.cont_sizer = caption_sizer
                part.sizer_item = sizer_item
                uiparts.append(part)

        if caption or captionLeft:
            # if we have buttons, add a little space to the right
            # of them to ease visual crowding
            if button_count >= 1:
                if captionLeft:
                    caption_sizer.Add((caption_size, 3), 0, wx.EXPAND)
                else:
                    caption_sizer.Add((3, caption_size), 0, wx.EXPAND)

            # add the caption sizer
            sizer_item = vert_pane_sizer.Add(caption_sizer, 0, wx.EXPAND)
            uiparts[caption_part_idx].sizer_item = sizer_item
                    
        # add the pane window itself
        if spacer_only or not pane.window:
            sizer_item = vert_pane_sizer.Add((1, 1), 1, wx.EXPAND)
        else:
            sizer_item = vert_pane_sizer.Add(pane.window, 1, wx.EXPAND)
            vert_pane_sizer.SetItemMinSize(pane.window, (1, 1))

        part = AuiDockUIPart()        
        part.type = AuiDockUIPart.typePane
        part.dock = dock
        part.pane = pane
        part.button = None
        part.orientation = orientation
        part.cont_sizer = vert_pane_sizer
        part.sizer_item = sizer_item
        uiparts.append(part)

        # determine if the pane should have a minimum size if the pane is
        # non-resizable (fixed) then we must set a minimum size. Alternatively,
        # if the pane.min_size is set, we must use that value as well
        
        min_size = pane.min_size
        if pane.IsFixed():
            if min_size == wx.Size(-1, -1):
                min_size = pane.best_size
                pane_proportion = 0

        if min_size != wx.Size(-1, -1):
            vert_pane_sizer.SetItemMinSize(len(vert_pane_sizer.GetChildren())-1, (min_size.x, min_size.y))
        
        # add the vertical/horizontal sizer (caption, pane window) to the
        # horizontal sizer (gripper, vertical sizer)
        horz_pane_sizer.Add(vert_pane_sizer, 1, wx.EXPAND)

        # finally, add the pane sizer to the dock sizer
        if pane.HasBorder():
            # allowing space for the pane's border
            sizer_item = cont.Add(horz_pane_sizer, pane_proportion,
                                  wx.EXPAND | wx.ALL, pane_border_size)
            part = AuiDockUIPart()
            part.type = AuiDockUIPart.typePaneBorder
            part.dock = dock
            part.pane = pane
            part.button = None
            part.orientation = orientation
            part.cont_sizer = cont
            part.sizer_item = sizer_item
            uiparts.append(part)
        else:
            sizer_item = cont.Add(horz_pane_sizer, pane_proportion, wx.EXPAND)
        
        return uiparts
        
        
    def LayoutAddDock(self, cont, dock, uiparts, spacer_only):
        """
        Adds a dock into the existing layout.

        :param `cont`: a `wx.Sizer` object;
        :param `dock`: the L{AuiDockInfo} structure to add to the layout;
        :param `uiparts`: a list of UI parts in the interface;
        :param `spacer_only`: whether to add a simple spacer or a real window.
        """
        
        sizer_item = wx.SizerItem()
        part = AuiDockUIPart()

        sash_size = self._art.GetMetric(AUI_DOCKART_SASH_SIZE)
        orientation = (dock.IsHorizontal() and [wx.HORIZONTAL] or [wx.VERTICAL])[0]

        # resizable bottom and right docks have a sash before them
        if not self._has_maximized and not dock.fixed and \
           dock.dock_direction in [AUI_DOCK_BOTTOM, AUI_DOCK_RIGHT]:
        
            sizer_item = cont.Add((sash_size, sash_size), 0, wx.EXPAND)

            part.type = AuiDockUIPart.typeDockSizer
            part.orientation = orientation
            part.dock = dock
            part.pane = None
            part.button = None
            part.cont_sizer = cont
            part.sizer_item = sizer_item
            uiparts.append(part)
        
        # create the sizer for the dock
        dock_sizer = wx.BoxSizer(orientation)

        # add each pane to the dock
        has_maximized_pane = False
        pane_count = len(dock.panes)

        if dock.fixed:
        
            # figure out the real pane positions we will
            # use, without modifying the each pane's pane_pos member
            pane_positions, pane_sizes = self.GetPanePositionsAndSizes(dock)

            offset = 0
            for pane_i in xrange(pane_count):
            
                pane = dock.panes[pane_i]
                pane_pos = pane_positions[pane_i]

                if pane.IsMaximized():
                    has_maximized_pane = True

                amount = pane_pos - offset
                if amount > 0:
                
                    if dock.IsVertical():
                        sizer_item = dock_sizer.Add((1, amount), 0, wx.EXPAND)
                    else:
                        sizer_item = dock_sizer.Add((amount, 1), 0, wx.EXPAND)

                    part = AuiDockUIPart()
                    part.type = AuiDockUIPart.typeBackground
                    part.dock = dock
                    part.pane = None
                    part.button = None
                    part.orientation = (orientation==wx.HORIZONTAL and \
                                        [wx.VERTICAL] or [wx.HORIZONTAL])[0]
                    part.cont_sizer = dock_sizer
                    part.sizer_item = sizer_item
                    uiparts.append(part)

                    offset = offset + amount
                
                uiparts = self.LayoutAddPane(dock_sizer, dock, pane, uiparts, spacer_only)

                offset = offset + pane_sizes[pane_i]
            
            # at the end add a very small stretchable background area
            sizer_item = dock_sizer.Add((0, 0), 1, wx.EXPAND)
            part = AuiDockUIPart()
            part.type = AuiDockUIPart.typeBackground
            part.dock = dock
            part.pane = None
            part.button = None
            part.orientation = orientation
            part.cont_sizer = dock_sizer
            part.sizer_item = sizer_item
            uiparts.append(part)
        
        else:
        
            for pane_i in xrange(pane_count):
            
                pane = dock.panes[pane_i]

                if pane.IsMaximized():
                    has_maximized_pane = True

                # if this is not the first pane being added,
                # we need to add a pane sizer
                if not self._has_maximized and pane_i > 0:
                    sizer_item = dock_sizer.Add((sash_size, sash_size), 0, wx.EXPAND)
                    part = AuiDockUIPart()
                    part.type = AuiDockUIPart.typePaneSizer
                    part.dock = dock
                    part.pane = dock.panes[pane_i-1]
                    part.button = None
                    part.orientation = (orientation==wx.HORIZONTAL and \
                                        [wx.VERTICAL] or [wx.HORIZONTAL])[0]
                    part.cont_sizer = dock_sizer
                    part.sizer_item = sizer_item
                    uiparts.append(part)
                
                uiparts = self.LayoutAddPane(dock_sizer, dock, pane, uiparts, spacer_only)
            
        if dock.dock_direction == AUI_DOCK_CENTER or has_maximized_pane:
            sizer_item = cont.Add(dock_sizer, 1, wx.EXPAND)
        else:
            sizer_item = cont.Add(dock_sizer, 0, wx.EXPAND)

        part = AuiDockUIPart()
        part.type = AuiDockUIPart.typeDock
        part.dock = dock
        part.pane = None
        part.button = None
        part.orientation = orientation
        part.cont_sizer = cont
        part.sizer_item = sizer_item
        uiparts.append(part)

        if dock.IsHorizontal():
            cont.SetItemMinSize(dock_sizer, (0, dock.size))
        else:
            cont.SetItemMinSize(dock_sizer, (dock.size, 0))

        #  top and left docks have a sash after them
        if not self._has_maximized and not dock.fixed and \
           dock.dock_direction in [AUI_DOCK_TOP, AUI_DOCK_LEFT]:
        
            sizer_item = cont.Add((sash_size, sash_size), 0, wx.EXPAND)

            part = AuiDockUIPart()
            part.type = AuiDockUIPart.typeDockSizer
            part.dock = dock
            part.pane = None
            part.button = None
            part.orientation = orientation
            part.cont_sizer = cont
            part.sizer_item = sizer_item
            uiparts.append(part)
        
        return uiparts
    

    def LayoutAll(self, panes, docks, uiparts, spacer_only=False, oncheck=True):
        """
        Layouts all the UI structures in the interface.

        :param `panes`: a list of L{AuiPaneInfo} instances;
        :param `docks`: a list of L{AuiDockInfo} classes;
        :param `uiparts`: a list of UI parts in the interface;
        :param `spacer_only`: whether to add a simple spacer or a real window;
        :param `oncheck`: whether to store the results in a class member or not.
        """
        
        container = wx.BoxSizer(wx.VERTICAL)

        pane_border_size = self._art.GetMetric(AUI_DOCKART_PANE_BORDER_SIZE)
        caption_size = self._art.GetMetric(AUI_DOCKART_CAPTION_SIZE)
        cli_size = self._frame.GetClientSize()
        
        # empty all docks out
        for dock in docks:
            dock.panes = []
            if dock.fixed:
                # always reset fixed docks' sizes, because
                # the contained windows may have been resized
                dock.size = 0
            
        dock_count = len(docks)
        
        # iterate through all known panes, filing each
        # of them into the appropriate dock. If the
        # pane does not exist in the dock, add it
        for p in panes:

            # don't layout hidden panes.
            if p.IsShown():
                
                # find any docks with the same dock direction, dock layer, and
                # dock row as the pane we are working on
                arr = FindDocks(docks, p.dock_direction, p.dock_layer, p.dock_row)

                if arr:
                    dock = arr[0]

                else:
                    # dock was not found, so we need to create a new one
                    d = AuiDockInfo()
                    d.dock_direction = p.dock_direction
                    d.dock_layer = p.dock_layer
                    d.dock_row = p.dock_row
                    docks.append(d)
                    dock = docks[-1]

                    if p.HasFlag(p.needsRestore) and not p.HasFlag(p.wasMaximized):
                   
                        isHor = dock.IsHorizontal()
                        sashSize = self._art.GetMetric(AUI_DOCKART_SASH_SIZE)

                        # get the sizes of any docks that might 
                        # overlap with our restored dock

                        # make list of widths or heights from the size in the dock rects
                        sizes = [d.rect[2:][isHor] for \
                                 d in docks if d.IsOk() and \
                                 (d.IsHorizontal() == isHor) and \
                                 not d.toolbar and \
                                 d.dock_direction != AUI_DOCK_CENTER]
                        
                        frameRect = GetInternalFrameRect(self._frame, self._docks)

                        # set max size allowing for sashes and absolute minimum
                        maxsize = frameRect[2:][isHor] - sum(sizes) - (len(sizes)*10) - (sashSize*len(sizes))
                        dock.size = min(p.previousDockSize,maxsize)

                    else:
                        dock.size = 0

                if p.HasFlag(p.wasMaximized):
                    self.MaximizePane(p, savesizes=False)
                    p.SetFlag(p.wasMaximized, False)

                if p.HasFlag(p.needsRestore):
                    if p.previousDockPos is not None:
                        DoInsertPane(dock.panes, dock.dock_direction, dock.dock_layer, dock.dock_row, p.previousDockPos)
                        p.dock_pos = p.previousDockPos
                        p.previousDockPos = None
                    p.SetFlag(p.needsRestore, False)

                if p.IsDocked():
                    # remove the pane from any existing docks except this one
                    docks = RemovePaneFromDocks(docks, p, dock)

                    # pane needs to be added to the dock,
                    # if it doesn't already exist 
                    if not FindPaneInDock(dock, p.window):
                        dock.panes.append(p)
                else:
                    # remove the pane from any existing docks
                    docks = RemovePaneFromDocks(docks, p)
                
        # remove any empty docks
        docks = [dock for dock in docks if dock.panes]

        dock_count = len(docks)
        # configure the docks further
        for ii, dock in enumerate(docks):
            # sort the dock pane array by the pane's
            # dock position (dock_pos), in ascending order
            dock.panes.sort(PaneSortFunc)
            dock_pane_count = len(dock.panes)
            
            # for newly created docks, set up their initial size
            if dock.size == 0:
                size = 0
                for pane in dock.panes:
                    pane_size = pane.best_size
                    if pane_size == wx.Size(-1, -1):
                        pane_size = pane.min_size
                    if pane_size == wx.Size(-1, -1) and pane.window:
                        pane_size = pane.window.GetSize()
                    if dock.IsHorizontal():
                        size = max(pane_size.y, size)
                    else:
                        size = max(pane_size.x, size)
                
                # add space for the border (two times), but only
                # if at least one pane inside the dock has a pane border
                for pane in dock.panes:
                    if pane.HasBorder():
                        size = size + pane_border_size*2
                        break
                    
                # if pane is on the top or bottom, add the caption height,
                # but only if at least one pane inside the dock has a caption
                if dock.IsHorizontal():
                    for pane in dock.panes:
                        if pane.HasCaption() and not pane.HasCaptionLeft():
                            size = size + caption_size
                            break
                else:
                    for pane in dock.panes:
                        if pane.HasCaptionLeft() and not pane.HasCaption():
                            size = size + caption_size
                            break
                    
                # new dock's size may not be more than the dock constraint
                # parameter specifies.  See SetDockSizeConstraint()
                max_dock_x_size = int(self._dock_constraint_x*float(cli_size.x))
                max_dock_y_size = int(self._dock_constraint_y*float(cli_size.y))
                if cli_size <= wx.Size(20, 20):
                    max_dock_x_size = 10000
                    max_dock_y_size = 10000

                if dock.IsHorizontal():
                    size = min(size, max_dock_y_size)
                else:
                    size = min(size, max_dock_x_size)

                # absolute minimum size for a dock is 10 pixels
                if size < 10:
                    size = 10

                dock.size = size

            # determine the dock's minimum size
            plus_border = False
            plus_caption = False
            plus_caption_left = False
            dock_min_size = 0
            for pane in dock.panes:
                if pane.min_size != wx.Size(-1, -1):
                    if pane.HasBorder():
                        plus_border = True
                    if pane.HasCaption():
                        plus_caption = True
                    if pane.HasCaptionLeft():
                        plus_caption_left = True
                    if dock.IsHorizontal():
                        if pane.min_size.y > dock_min_size:
                            dock_min_size = pane.min_size.y
                    else:
                        if pane.min_size.x > dock_min_size:
                            dock_min_size = pane.min_size.x
                    
            if plus_border:
                dock_min_size += pane_border_size*2
            if plus_caption and dock.IsHorizontal():
                dock_min_size += caption_size
            if plus_caption_left and dock.IsVertical():
                dock_min_size += caption_size
               
            dock.min_size = dock_min_size
            
            # if the pane's current size is less than it's
            # minimum, increase the dock's size to it's minimum
            if dock.size < dock.min_size:
                dock.size = dock.min_size

            # determine the dock's mode (fixed or proportional)
            # determine whether the dock has only toolbars
            action_pane_marked = False
            dock.fixed = True
            dock.toolbar = True
            for pane in dock.panes:
                if not pane.IsFixed():
                    dock.fixed = False
                if not pane.IsToolbar():
                    dock.toolbar = False
                if pane.HasFlag(AuiPaneInfo.optionDockFixed):
                    dock.fixed = True
                if pane.HasFlag(AuiPaneInfo.actionPane):
                    action_pane_marked = True

            # if the dock mode is proportional and not fixed-pixel,
            # reassign the dock_pos to the sequential 0, 1, 2, 3
            # e.g. remove gaps like 1, 2, 30, 500
            if not dock.fixed:
                for jj in xrange(dock_pane_count):
                    pane = dock.panes[jj]
                    pane.dock_pos = jj
                
            # if the dock mode is fixed, and none of the panes
            # are being moved right now, make sure the panes
            # do not overlap each other.  If they do, we will
            # adjust the panes' positions
            if dock.fixed and not action_pane_marked:
                pane_positions, pane_sizes = self.GetPanePositionsAndSizes(dock)
                offset = 0
                for jj in xrange(dock_pane_count):
                    pane = dock.panes[jj]
                    pane.dock_pos = pane_positions[jj]
                    amount = pane.dock_pos - offset
                    if amount >= 0:
                        offset += amount
                    else:
                        pane.dock_pos += -amount

                    offset += pane_sizes[jj]
                    dock.panes[jj] = pane

            if oncheck:
                self._docks[ii] = dock                    

        # shrink docks if needed 
##        docks = self.SmartShrink(docks, AUI_DOCK_TOP)
##        docks = self.SmartShrink(docks, AUI_DOCK_LEFT)

        if oncheck:
            self._docks = docks
            
        # discover the maximum dock layer
        max_layer = 0
        dock_count = len(docks)
        
        for ii in xrange(dock_count):
            max_layer = max(max_layer, docks[ii].dock_layer)

        # clear out uiparts
        uiparts = []

        # create a bunch of box sizers,
        # from the innermost level outwards.
        cont = None
        middle = None

        if oncheck:
            docks = self._docks
        
        for layer in xrange(max_layer+1):
            # find any docks in this layer
            arr = FindDocks(docks, -1, layer, -1)
            # if there aren't any, skip to the next layer
            if not arr:
                continue

            old_cont = cont

            # create a container which will hold this layer's
            # docks (top, bottom, left, right)
            cont = wx.BoxSizer(wx.VERTICAL)

            # find any top docks in this layer
            arr = FindDocks(docks, AUI_DOCK_TOP, layer, -1)
            for row in arr:
                uiparts = self.LayoutAddDock(cont, row, uiparts, spacer_only)
            
            # fill out the middle layer (which consists
            # of left docks, content area and right docks)
            
            middle = wx.BoxSizer(wx.HORIZONTAL)

            # find any left docks in this layer
            arr = FindDocks(docks, AUI_DOCK_LEFT, layer, -1)
            for row in arr:
                uiparts = self.LayoutAddDock(middle, row, uiparts, spacer_only)
            
            # add content dock (or previous layer's sizer
            # to the middle
            if not old_cont:
                # find any center docks
                arr = FindDocks(docks, AUI_DOCK_CENTER, -1, -1)
                if arr:
                    for row in arr:
                       uiparts = self.LayoutAddDock(middle, row, uiparts, spacer_only)
                       
                elif not self._has_maximized:
                    # there are no center docks, add a background area
                    sizer_item = middle.Add((1, 1), 1, wx.EXPAND)
                    part = AuiDockUIPart()
                    part.type = AuiDockUIPart.typeBackground
                    part.pane = None
                    part.dock = None
                    part.button = None
                    part.cont_sizer = middle
                    part.sizer_item = sizer_item
                    uiparts.append(part)
            else:
                middle.Add(old_cont, 1, wx.EXPAND)
            
            # find any right docks in this layer
            arr = FindDocks(docks, AUI_DOCK_RIGHT, layer, -1, reverse=True)
            for row in arr:
                uiparts = self.LayoutAddDock(middle, row, uiparts, spacer_only)
                    
            if len(middle.GetChildren()) > 0:
                cont.Add(middle, 1, wx.EXPAND)

            # find any bottom docks in this layer
            arr = FindDocks(docks, AUI_DOCK_BOTTOM, layer, -1, reverse=True)
            for row in arr:
                    uiparts = self.LayoutAddDock(cont, row, uiparts, spacer_only)

        if not cont:
            # no sizer available, because there are no docks,
            # therefore we will create a simple background area
            cont = wx.BoxSizer(wx.VERTICAL)
            sizer_item = cont.Add((1, 1), 1, wx.EXPAND)
            part = AuiDockUIPart()
            part.type = AuiDockUIPart.typeBackground
            part.pane = None
            part.dock = None
            part.button = None
            part.cont_sizer = middle
            part.sizer_item = sizer_item
            uiparts.append(part)

        if oncheck:
            self._uiparts = uiparts
            self._docks = docks

        container.Add(cont, 1, wx.EXPAND)

        if oncheck:
            return container
        else:
            return container, panes, docks, uiparts


    def SetDockSizeConstraint(self, width_pct, height_pct):
        """
        When a user creates a new dock by dragging a window into a docked position,
        often times the large size of the window will create a dock that is unwieldly
        large.

        L{AuiManager} by default limits the size of any new dock to 1/3 of the window
        size. For horizontal docks, this would be 1/3 of the window height. For vertical
        docks, 1/3 of the width. Calling this function will adjust this constraint value.

        The numbers must be between 0.0 and 1.0. For instance, calling L{SetDockSizeConstraint}
        with (0.5, 0.5) will cause new docks to be limited to half of the size of the entire
        managed window.

        :param `width_pct`: a float number representing the x dock size constraint;
        :param `width_pct`: a float number representing the y dock size constraint.
        """

        self._dock_constraint_x = max(0.0, min(1.0, width_pct))
        self._dock_constraint_y = max(0.0, min(1.0, height_pct))


    def GetDockSizeConstraint(self):
        """
        Returns the current dock constraint values.

        :see: L{SetDockSizeConstraint}
        """

        return self._dock_constraint_x, self._dock_constraint_y


    def Update(self):
        """
        This method is called after any number of changes are made to any of the
        managed panes. L{Update} must be invoked after L{AddPane} or L{InsertPane} are
        called in order to "realize" or "commit" the changes.

        In addition, any number of changes may be made to L{AuiPaneInfo} structures
        (retrieved with L{GetPane}), but to realize the changes, L{Update}
        must be called. This construction allows pane flicker to be avoided by updating
        the whole layout at one time.
        """

        self._hover_button = None
        self._action_part = None
        
        # destroy floating panes which have been
        # redocked or are becoming non-floating
        for p in self._panes:
            if p.IsFloating() or not p.frame:
                continue
            
            # because the pane is no longer in a floating, we need to
            # reparent it to self._frame and destroy the floating frame
            # reduce flicker
            p.window.SetSize((1, 1))

            # the following block is a workaround for bug #1531361
            # (see wxWidgets sourceforge page).  On wxGTK (only), when
            # a frame is shown/hidden, a move event unfortunately
            # also gets fired.  Because we may be dragging around
            # a pane, we need to cancel that action here to prevent
            # a spurious crash.
            if self._action_window == p.frame:
                if self._frame.HasCapture():
                    self._frame.ReleaseMouse()
                self._action = actionNone
                self._action_window = None

            # hide the frame
            if p.frame.IsShown():
                p.frame.Show(False)

            if self._action_window == p.frame:
                self._action_window = None
        
            # reparent to self._frame and destroy the pane
            p.window.Reparent(self._frame)
            if isinstance(p.window, auibar.AuiToolBar):
                p.window.SetAuiManager(self)

            if p.frame:
                p.frame.SetSizer(None)
                p.frame.Destroy()
            p.frame = None

        # Only the master manager should create/destroy notebooks...
        if not self._masterManager:
            self.UpdateNotebook()
        
        # delete old sizer first
        self._frame.SetSizer(None)

        # create a layout for all of the panes
        sizer = self.LayoutAll(self._panes, self._docks, self._uiparts, False)

        # hide or show panes as necessary,
        # and float panes as necessary
        
        pane_count = len(self._panes)
        
        for ii in xrange(pane_count):
            p = self._panes[ii]
            pFrame = p.frame

            if p.IsFloating():
                if pFrame is None:
                    # we need to create a frame for this
                    # pane, which has recently been floated
                    frame = self.CreateFloatingFrame(self._frame, p)

                    # on MSW and Mac, if the owner desires transparent dragging, and
                    # the dragging is happening right now, then the floating
                    # window should have this style by default
                    if self._action in [actionDragFloatingPane, actionDragToolbarPane] and \
                       self._agwFlags & AUI_MGR_TRANSPARENT_DRAG:
                        frame.SetTransparent(150)

                    if p.IsToolbar():
                        bar = p.window
                        if isinstance(bar, auibar.AuiToolBar):
                            bar.SetGripperVisible(False)
                            agwStyle = bar.GetAGWWindowStyleFlag()
                            bar.SetAGWWindowStyleFlag(agwStyle & ~AUI_TB_VERTICAL)
                            bar.Realize()

                        s = p.window.GetMinSize()
                        p.BestSize(s)
                        p.FloatingSize(wx.DefaultSize)

                    frame.SetPaneWindow(p)
                    p.needsTransparency = True
                    p.frame = pFrame = frame
                    if p.IsShown() and not frame.IsShown():
                        frame.Show()
                        frame.Update()
                else:

                    # frame already exists, make sure it's position
                    # and size reflect the information in AuiPaneInfo
                    if pFrame.GetPosition() != p.floating_pos or pFrame.GetSize() != p.floating_size:
                        pFrame.SetDimensions(p.floating_pos.x, p.floating_pos.y,
                                             p.floating_size.x, p.floating_size.y, wx.SIZE_USE_EXISTING)

                    # update whether the pane is resizable or not
                    style = p.frame.GetWindowStyleFlag()
                    if p.IsFixed():
                        style &= ~wx.RESIZE_BORDER
                    else:
                        style |= wx.RESIZE_BORDER

                    p.frame.SetWindowStyleFlag(style)

                    if pFrame.IsShown() != p.IsShown():
                        p.needsTransparency = True
                        pFrame.Show(p.IsShown())

                if pFrame.GetTitle() != p.caption:
                    pFrame.SetTitle(p.caption)
                if p.icon.IsOk():
                    pFrame.SetIcon(wx.IconFromBitmap(p.icon))
                    
            else:

                if p.IsToolbar():
#                    self.SwitchToolBarOrientation(p)
                    p.best_size = p.window.GetBestSize()

                if p.window and not p.IsNotebookPage() and p.window.IsShown() != p.IsShown():
                    p.window.Show(p.IsShown())

            if pFrame and p.needsTransparency:
                if pFrame.IsShown() and pFrame._transparent != p.transparent:
                    pFrame.SetTransparent(p.transparent)
                    pFrame._transparent = p.transparent
                    
                p.needsTransparency = False

            # if "active panes" are no longer allowed, clear
            # any optionActive values from the pane states
            if self._agwFlags & AUI_MGR_ALLOW_ACTIVE_PANE == 0:
                p.state &= ~AuiPaneInfo.optionActive

            self._panes[ii] = p

        old_pane_rects = []
        pane_count = len(self._panes)
        
        for p in self._panes:
            r = wx.Rect()
            if p.window and p.IsShown() and p.IsDocked():
                r = p.rect

            old_pane_rects.append(r)    
            
        # apply the new sizer
        self._frame.SetSizer(sizer)
        self._frame.SetAutoLayout(False)
        self.DoFrameLayout()
        
        # now that the frame layout is done, we need to check
        # the new pane rectangles against the old rectangles that
        # we saved a few lines above here.  If the rectangles have
        # changed, the corresponding panes must also be updated
        for ii in xrange(pane_count):
            p = self._panes[ii]
            if p.window and p.IsShown() and p.IsDocked():
                if p.rect != old_pane_rects[ii]:
                    p.window.Refresh()
                    p.window.Update()

        if wx.Platform == "__WXMAC__":
            self._frame.Refresh()
        else:
            self.Repaint()

        if not self._masterManager:
            e = self.FireEvent(wxEVT_AUI_PERSPECTIVE_CHANGED, None, canVeto=False)    


    def UpdateNotebook(self):
        """ Updates the automatic L{AuiNotebook} in the layout (if any exists). """

        # Workout how many notebooks we need.
        max_notebook = -1

        # destroy floating panes which have been
        # redocked or are becoming non-floating
        for paneInfo in self._panes:
            if max_notebook < paneInfo.notebook_id:
                max_notebook = paneInfo.notebook_id
        
        # We are the master of our domain
        extra_notebook = len(self._notebooks)
        max_notebook += 1
        
        for i in xrange(extra_notebook, max_notebook):
            self.CreateNotebook()

        # Remove pages from notebooks that no-longer belong there ...
        for nb, notebook in enumerate(self._notebooks):
            pages = notebook.GetPageCount()
            pageCounter, allPages = 0, pages

            # Check each tab ...
            for page in xrange(pages):

                if page >= allPages:
                    break
                
                window = notebook.GetPage(pageCounter)
                paneInfo = self.GetPane(window)
                if paneInfo.IsOk() and paneInfo.notebook_id != nb:
                    notebook.RemovePage(pageCounter)
                    window.Hide()
                    window.Reparent(self._frame)
                    pageCounter -= 1
                    allPages -= 1

                pageCounter += 1

            notebook.DoSizing()

        # Add notebook pages that aren't there already...
        for paneInfo in self._panes:
            if paneInfo.IsNotebookPage():
            
                title = (paneInfo.caption == "" and [paneInfo.name] or [paneInfo.caption])[0]

                notebook = self._notebooks[paneInfo.notebook_id]
                page_id = notebook.GetPageIndex(paneInfo.window)

                if page_id < 0:
                
                    paneInfo.window.Reparent(notebook)
                    notebook.AddPage(paneInfo.window, title, True, paneInfo.icon)
                
                # Update title and icon ...
                else:
                
                    notebook.SetPageText(page_id, title)
                    notebook.SetPageBitmap(page_id, paneInfo.icon)

                notebook.DoSizing()
                
            # Wire-up newly created notebooks
            elif paneInfo.IsNotebookControl() and not paneInfo.window:
                paneInfo.window = self._notebooks[paneInfo.notebook_id]
            
        # Delete empty notebooks, and convert notebooks with 1 page to
        # normal panes...
        remap_ids = [-1]*len(self._notebooks)
        nb_idx = 0

        for nb, notebook in enumerate(self._notebooks): 
            if notebook.GetPageCount() == 1:
            
                # Convert notebook page to pane...
                window = notebook.GetPage(0)
                child_pane = self.GetPane(window)
                notebook_pane = self.GetPane(notebook)
                if child_pane.IsOk() and notebook_pane.IsOk():
                
                    child_pane.SetDockPos(notebook_pane)
                    child_pane.window.Hide()
                    child_pane.window.Reparent(self._frame)
                    child_pane.frame = None
                    child_pane.notebook_id = -1
                    if notebook_pane.IsFloating():
                        child_pane.Float()

                    self.DetachPane(notebook)

                    notebook.RemovePage(0)
                    notebook.Destroy()
                
                else:
                
                    raise Exception("Odd notebook docking")
                
            elif notebook.GetPageCount() == 0:
            
                self.DetachPane(notebook)
                notebook.Destroy()
            
            else:
            
                # Correct page ordering. The original wxPython code
                # for this did not work properly, and would misplace 
                # windows causing errors.
                notebook.Freeze()
                self._notebooks[nb_idx] = notebook
                pages = notebook.GetPageCount()
                selected = notebook.GetPage(notebook.GetSelection())

                # Take each page out of the notebook, group it with
                # its current pane, and sort the list by pane.dock_pos
                # order
                pages_and_panes = []
                for idx in reversed(range(pages)):
                    page = notebook.GetPage(idx)
                    pane = self.GetPane(page)
                    pages_and_panes.append((page, pane))
                    notebook.RemovePage(idx)
                sorted_pnp = sorted(pages_and_panes, key=lambda tup: tup[1].dock_pos)

                # Grab the attributes from the panes which are ordered
                # correctly, and copy those attributes to the original
                # panes. (This avoids having to change the ordering
                # of self._panes) Then, add the page back into the notebook
                sorted_attributes = [self.GetAttributes(tup[1])
                                     for tup in sorted_pnp]
                for attrs, tup in zip(sorted_attributes, pages_and_panes):
                    pane = tup[1]
                    self.SetAttributes(pane, attrs)
                    notebook.AddPage(pane.window, pane.caption)

                notebook.SetSelection(notebook.GetPageIndex(selected), True)
                notebook.DoSizing()
                notebook.Thaw()

                # It's a keeper.
                remap_ids[nb] = nb_idx
                nb_idx += 1

        # Apply remap...
        nb_count = len(self._notebooks)
        
        if nb_count != nb_idx:
        
            self._notebooks = self._notebooks[0:nb_idx]
            for p in self._panes:
                if p.notebook_id >= 0:                
                    p.notebook_id = remap_ids[p.notebook_id]
                    if p.IsNotebookControl():
                        p.SetNameFromNotebookId()
                
        # Make sure buttons are correct ...
        for notebook in self._notebooks:
            want_max = True
            want_min = True
            want_close = True

            pages = notebook.GetPageCount()
            for page in xrange(pages):
            
                win = notebook.GetPage(page)
                pane = self.GetPane(win)
                if pane.IsOk():
                
                    if not pane.HasCloseButton():
                        want_close = False
                    if not pane.HasMaximizeButton():
                        want_max = False
                    if not pane.HasMinimizeButton():
                        want_min = False
                
            notebook_pane = self.GetPane(notebook)
            if notebook_pane.IsOk():
                if notebook_pane.HasMinimizeButton() != want_min:
                    if want_min:
                        button = AuiPaneButton(AUI_BUTTON_MINIMIZE)
                        notebook_pane.state |= AuiPaneInfo.buttonMinimize
                        notebook_pane.buttons.append(button)

                    # todo: remove min/max
            
                if notebook_pane.HasMaximizeButton() != want_max:
                    if want_max:
                        button = AuiPaneButton(AUI_BUTTON_MAXIMIZE_RESTORE)
                        notebook_pane.state |= AuiPaneInfo.buttonMaximize
                        notebook_pane.buttons.append(button)
                    
                    # todo: remove min/max
                
                if notebook_pane.HasCloseButton() != want_close:
                    if want_close:
                        button = AuiPaneButton(AUI_BUTTON_CLOSE)
                        notebook_pane.state |= AuiPaneInfo.buttonClose
                        notebook_pane.buttons.append(button)
                    
                    # todo: remove close


    def SmartShrink(self, docks, direction):
        """
        Used to intelligently shrink the docks' size (if needed).

        :param `docks`: a list of L{AuiDockInfo} instances;
        :param `direction`: the direction in which to shrink.
        """

        sashSize = self._art.GetMetric(AUI_DOCKART_SASH_SIZE)
        caption_size = self._art.GetMetric(AUI_DOCKART_CAPTION_SIZE)
        clientSize = self._frame.GetClientSize()
        ourDocks = FindDocks(docks, direction, -1, -1)
        oppositeDocks = FindOppositeDocks(docks, direction)
        oppositeSize = self.GetOppositeDockTotalSize(docks, direction)
        ourSize = 0

        for dock in ourDocks:
            ourSize += dock.size

            if not dock.toolbar:
                ourSize += sashSize
        
        shrinkSize = ourSize + oppositeSize

        if direction == AUI_DOCK_TOP or direction == AUI_DOCK_BOTTOM:
            shrinkSize -= clientSize.y
        else:
            shrinkSize -= clientSize.x

        if shrinkSize <= 0:
            return docks

        # Combine arrays
        for dock in oppositeDocks:
            ourDocks.append(dock)
            
        oppositeDocks = []

        for dock in ourDocks:
            if dock.toolbar or not dock.resizable:
                continue

            dockRange = dock.size - dock.min_size

            if dock.min_size == 0:
                dockRange -= sashSize
                if direction == AUI_DOCK_TOP or direction == AUI_DOCK_BOTTOM:
                    dockRange -= caption_size
            
            if dockRange >= shrinkSize:
            
                dock.size -= shrinkSize
                return docks
            
            else:
            
                dock.size -= dockRange
                shrinkSize -= dockRange
            
        return docks
    

    def UpdateDockingGuides(self, paneInfo):
        """
        Updates the docking guide windows positions and appearance.

        :param `paneInfo`: a L{AuiPaneInfo} instance.
        """

        if len(self._guides) == 0:
            self.CreateGuideWindows()

        captionSize = self._art.GetMetric(AUI_DOCKART_CAPTION_SIZE)
        frameRect = GetInternalFrameRect(self._frame, self._docks)
        mousePos = wx.GetMousePosition()

        for indx, guide in enumerate(self._guides):
        
            pt = wx.Point()
            guide_size = guide.host.GetSize()
            if not guide.host:
                raise Exception("Invalid docking host")

            direction = guide.dock_direction

            if direction == AUI_DOCK_LEFT:
                pt.x = frameRect.x + guide_size.x / 2 + 16
                pt.y = frameRect.y + frameRect.height / 2

            elif direction == AUI_DOCK_TOP:
                pt.x = frameRect.x + frameRect.width / 2
                pt.y = frameRect.y + guide_size.y / 2 + 16

            elif direction == AUI_DOCK_RIGHT:
                pt.x = frameRect.x + frameRect.width - guide_size.x / 2 - 16
                pt.y = frameRect.y + frameRect.height / 2

            elif direction == AUI_DOCK_BOTTOM:
                pt.x = frameRect.x + frameRect.width / 2
                pt.y = frameRect.y + frameRect.height - guide_size.y / 2 - 16

            elif direction == AUI_DOCK_CENTER:
                rc = paneInfo.window.GetScreenRect()
                pt.x = rc.x + rc.width / 2
                pt.y = rc.y + rc.height / 2
                if paneInfo.HasCaption():
                    pt.y -= captionSize / 2
                elif paneInfo.HasCaptionLeft():
                    pt.x -= captionSize / 2

            # guide will be centered around point 'pt'
            targetPosition = wx.Point(pt.x - guide_size.x / 2, pt.y - guide_size.y / 2)

            if guide.host.GetPosition() != targetPosition:
                guide.host.Move(targetPosition)
                
            guide.host.AeroMove(targetPosition)

            if guide.dock_direction == AUI_DOCK_CENTER:
                guide.host.ValidateNotebookDocking(paneInfo.IsNotebookDockable())

            guide.host.UpdateDockGuide(mousePos)
        
        paneInfo.window.Lower()

                        
    def DoFrameLayout(self):
        """
        This is an internal function which invokes `wx.Sizer.Layout`
        on the frame's main sizer, then measures all the various UI items
        and updates their internal rectangles.

        :note: This should always be called instead of calling
         `self._managed_window.Layout()` directly.
        """

        self._frame.Layout()
        
        for part in self._uiparts:            
            # get the rectangle of the UI part
            # originally, this code looked like this:
            #    part.rect = wx.Rect(part.sizer_item.GetPosition(),
            #                       part.sizer_item.GetSize())
            # this worked quite well, with one exception: the mdi
            # client window had a "deferred" size variable 
            # that returned the wrong size.  It looks like
            # a bug in wx, because the former size of the window
            # was being returned.  So, we will retrieve the part's
            # rectangle via other means

            part.rect = part.sizer_item.GetRect()
            flag = part.sizer_item.GetFlag()
            border = part.sizer_item.GetBorder()
            
            if flag & wx.TOP:
                part.rect.y -= border
                part.rect.height += border
            if flag & wx.LEFT:
                part.rect.x -= border
                part.rect.width += border
            if flag & wx.BOTTOM:
                part.rect.height += border
            if flag & wx.RIGHT:
                part.rect.width += border

            if part.type == AuiDockUIPart.typeDock:
                part.dock.rect = part.rect
            if part.type == AuiDockUIPart.typePane:
                part.pane.rect = part.rect


    def GetPanePart(self, wnd):
        """
        Looks up the pane border UI part of the
        pane specified. This allows the caller to get the exact rectangle
        of the pane in question, including decorations like caption and border.

        :param `wnd`: the window to which the pane border belongs to.        
        """

        for part in self._uiparts:
            if part.type == AuiDockUIPart.typePaneBorder and \
               part.pane and part.pane.window == wnd:
                return part

        for part in self._uiparts:
            if part.type == AuiDockUIPart.typePane and \
               part.pane and part.pane.window == wnd:
                return part
    
        return None


    def GetDockPixelOffset(self, test):
        """
        This is an internal function which returns
        a dock's offset in pixels from the left side of the window
        (for horizontal docks) or from the top of the window (for
        vertical docks).

        This value is necessary for calculating fixed-pane/toolbar offsets
        when they are dragged.

        :param `test`: a fake L{AuiPaneInfo} for testing purposes.
        """

        # the only way to accurately calculate the dock's
        # offset is to actually run a theoretical layout
        docks, panes = CopyDocksAndPanes2(self._docks, self._panes)
        panes.append(test)

        sizer, panes, docks, uiparts = self.LayoutAll(panes, docks, [], True, False)
        client_size = self._frame.GetClientSize()
        sizer.SetDimension(0, 0, client_size.x, client_size.y)
        sizer.Layout()

        for part in uiparts:
            pos = part.sizer_item.GetPosition()
            size = part.sizer_item.GetSize()
            part.rect = wx.RectPS(pos, size)
            if part.type == AuiDockUIPart.typeDock:
                part.dock.rect = part.rect

        sizer.Destroy()

        for dock in docks:
            if test.dock_direction == dock.dock_direction and \
               test.dock_layer == dock.dock_layer and  \
               test.dock_row == dock.dock_row:
            
                if dock.IsVertical():
                    return dock.rect.y
                else:
                    return dock.rect.x
            
        return 0
    

    def GetPartnerDock(self, dock):
        """
        Returns the partner dock for the input dock.

        :param `dock`: a L{AuiDockInfo} instance.
        """

        for layer in xrange(dock.dock_layer, -1, -1):
        
            bestDock = None

            for tmpDock in self._docks:
            
                if tmpDock.dock_layer != layer:
                    continue
                
                if tmpDock.dock_direction != dock.dock_direction:
                    continue

                if tmpDock.dock_layer < dock.dock_layer:
                
                    if not bestDock or tmpDock.dock_row < bestDock.dock_row:
                        bestDock = tmpDock
                
                elif tmpDock.dock_row > dock.dock_row:
                
                    if not bestDock or tmpDock.dock_row > bestDock.dock_row:
                        bestDock = tmpDock
                
            if bestDock:
                return bestDock
        
        return None


    def GetPartnerPane(self, dock, pane):
        """
        Returns the partner pane for the input pane. They both need to live
        in the same L{AuiDockInfo}.

        :param `dock`: a L{AuiDockInfo} instance;
        :param `pane`: a L{AuiPaneInfo} class.
        """
        
        panePosition = -1

        for i, tmpPane in enumerate(dock.panes):        
            if tmpPane.window == pane.window:
                panePosition = i
            elif not tmpPane.IsFixed() and panePosition != -1:
                return tmpPane
        
        return None


    def GetTotalPixSizeAndProportion(self, dock):
        """
        Returns the dimensions and proportion of the input dock.

        :param `dock`: the L{AuiDockInfo} structure to analyze.
        """

        totalPixsize = 0
        totalProportion = 0

        # determine the total proportion of all resizable panes,
        # and the total size of the dock minus the size of all
        # the fixed panes
        for tmpPane in dock.panes:
        
            if tmpPane.IsFixed():
                continue

            totalProportion += tmpPane.dock_proportion

            if dock.IsHorizontal():
                totalPixsize += tmpPane.rect.width
            else:
                totalPixsize += tmpPane.rect.height

##            if tmpPane.min_size.IsFullySpecified():
##            
##                if dock.IsHorizontal():
##                    totalPixsize -= tmpPane.min_size.x
##                else:
##                    totalPixsize -= tmpPane.min_size.y
            
        return totalPixsize, totalProportion


    def GetOppositeDockTotalSize(self, docks, direction):
        """
        Returns the dimensions of the dock which lives opposite of the input dock.

        :param `docks`: a list of L{AuiDockInfo} structures to analyze;
        :param `direction`: the direction in which to look for the opposite dock.
        """
        
        sash_size = self._art.GetMetric(AUI_DOCKART_SASH_SIZE)
        caption_size = self._art.GetMetric(AUI_DOCKART_CAPTION_SIZE)
        pane_border_size = self._art.GetMetric(AUI_DOCKART_PANE_BORDER_SIZE)
        minSizeMax = 0
        result = sash_size
        vertical = False

        if direction in [AUI_DOCK_TOP, AUI_DOCK_BOTTOM]:
            vertical = True

        # Get minimum size of the most inner area
        for tmpDock in docks:
        
            if tmpDock.dock_layer != 0:
                continue

            if tmpDock.dock_direction != AUI_DOCK_CENTER and tmpDock.IsVertical() != vertical:
                continue

            for tmpPane in tmpDock.panes:
            
                minSize = pane_border_size*2 - sash_size

                if vertical:
                    minSize += tmpPane.min_size.y + caption_size
                else:
                    minSize += tmpPane.min_size.x

                if minSize > minSizeMax:
                    minSizeMax = minSize
            
        result += minSizeMax

        # Get opposite docks
        oppositeDocks = FindOppositeDocks(docks, direction)

        # Sum size of the opposite docks and their sashes
        for dock in oppositeDocks:
            result += dock.size
            # if it's not a toolbar add the sash_size too
            if not dock.toolbar:
                result += sash_size
        
        return result


    def CalculateDockSizerLimits(self, dock):
        """
        Calculates the minimum and maximum sizes allowed for the input dock.

        :param `dock`: the L{AuiDockInfo} structure to analyze.
        """

        docks, panes = CopyDocksAndPanes2(self._docks, self._panes)

        sash_size = self._art.GetMetric(AUI_DOCKART_SASH_SIZE)
        caption_size = self._art.GetMetric(AUI_DOCKART_CAPTION_SIZE)
        opposite_size = self.GetOppositeDockTotalSize(docks, dock.dock_direction)

        for tmpDock in docks:
        
            if tmpDock.dock_direction == dock.dock_direction and \
               tmpDock.dock_layer == dock.dock_layer and \
               tmpDock.dock_row == dock.dock_row:
        
                tmpDock.size = 1
                break
        
        sizer, panes, docks, uiparts = self.LayoutAll(panes, docks, [], True, False)
        client_size = self._frame.GetClientSize()
        sizer.SetDimension(0, 0, client_size.x, client_size.y)
        sizer.Layout()

        for part in uiparts:
        
            part.rect = wx.RectPS(part.sizer_item.GetPosition(), part.sizer_item.GetSize())
            if part.type == AuiDockUIPart.typeDock:
                part.dock.rect = part.rect
        
        sizer.Destroy()
        new_dock = None

        for tmpDock in docks:
            if tmpDock.dock_direction == dock.dock_direction and \
               tmpDock.dock_layer == dock.dock_layer and \
               tmpDock.dock_row == dock.dock_row:
            
                new_dock = tmpDock
                break
            
        partnerDock = self.GetPartnerDock(dock)

        if partnerDock:
            partnerRange = partnerDock.size - partnerDock.min_size
            if partnerDock.min_size == 0:
                partnerRange -= sash_size
                if dock.IsHorizontal():
                    partnerRange -= caption_size
            
            direction = dock.dock_direction
            
            if direction == AUI_DOCK_LEFT:
                minPix = new_dock.rect.x + new_dock.rect.width
                maxPix = dock.rect.x + dock.rect.width
                maxPix += partnerRange

            elif direction == AUI_DOCK_TOP:
                minPix = new_dock.rect.y + new_dock.rect.height
                maxPix = dock.rect.y + dock.rect.height
                maxPix += partnerRange

            elif direction == AUI_DOCK_RIGHT:
                minPix = dock.rect.x - partnerRange - sash_size
                maxPix = new_dock.rect.x - sash_size

            elif direction == AUI_DOCK_BOTTOM:
                minPix = dock.rect.y - partnerRange - sash_size
                maxPix = new_dock.rect.y - sash_size

            return minPix, maxPix
        
        direction = new_dock.dock_direction
        
        if direction == AUI_DOCK_LEFT:
            minPix = new_dock.rect.x + new_dock.rect.width
            maxPix = client_size.x - opposite_size - sash_size

        elif direction == AUI_DOCK_TOP:
            minPix = new_dock.rect.y + new_dock.rect.height
            maxPix = client_size.y - opposite_size - sash_size

        elif direction == AUI_DOCK_RIGHT:
            minPix = opposite_size
            maxPix = new_dock.rect.x - sash_size

        elif direction == AUI_DOCK_BOTTOM:
            minPix = opposite_size
            maxPix = new_dock.rect.y - sash_size

        return minPix, maxPix


    def CalculatePaneSizerLimits(self, dock, pane):
        """
        Calculates the minimum and maximum sizes allowed for the input pane.

        :param `dock`: the L{AuiDockInfo} structure to which `pane` belongs to;
        :param `pane`: a L{AuiPaneInfo} class for which calculation are requested.
        """
        
        if pane.IsFixed():
            if dock.IsHorizontal():
                minPix = maxPix = pane.rect.x + 1 + pane.rect.width
            else:
                minPix = maxPix = pane.rect.y + 1 + pane.rect.height

            return minPix, maxPix
        
        totalPixsize, totalProportion = self.GetTotalPixSizeAndProportion(dock)
        partnerPane = self.GetPartnerPane(dock, pane)

        if dock.IsHorizontal():
        
            minPix = pane.rect.x + 1
            maxPix = pane.rect.x + 1 + pane.rect.width

            if pane.min_size.IsFullySpecified():
                minPix += pane.min_size.x
            else:
                minPix += 1

            if partnerPane:
                maxPix += partnerPane.rect.width

                if partnerPane.min_size.IsFullySpecified():
                    maxPix -= partnerPane.min_size.x - 1
            
            else:
                minPix = maxPix
        
        else:
        
            minPix = pane.rect.y + 1
            maxPix = pane.rect.y + 1 + pane.rect.height

            if pane.min_size.IsFullySpecified():
                minPix += pane.min_size.y
            else:
                minPix += 1

            if partnerPane:            
                maxPix += partnerPane.rect.height

                if partnerPane.min_size.IsFullySpecified():
                    maxPix -= partnerPane.min_size.y - 1
            
            else:            
                minPix = maxPix
            
        return minPix, maxPix


    def CheckMovableSizer(self, part):
        """
        Checks if a UI part can be actually resized.

        :param `part`: a UI part.
        """

        # a dock may not be resized if it has a single
        # pane which is not resizable
        if part.type == AuiDockUIPart.typeDockSizer and part.dock and \
           len(part.dock.panes) == 1 and part.dock.panes[0].IsFixed():
        
            return False
        
        if part.pane:
        
            # panes that may not be resized should be ignored here
            minPix, maxPix = self.CalculatePaneSizerLimits(part.dock, part.pane)

            if minPix == maxPix:
                return False
        
        return True


    def PaneFromTabEvent(self, event):
        """
        Returns a L{AuiPaneInfo} from a L{AuiNotebookEvent} event.

        :param `event`: a L{AuiNotebookEvent} event.
        """

        obj = event.GetEventObject()

        if obj and isinstance(obj, auibook.AuiTabCtrl):
        
            page_idx = obj.GetActivePage()

            if page_idx >= 0:
                page = obj.GetPage(page_idx)
                window = page.window
                if window:
                    return self.GetPane(window)
            
        elif obj and isinstance(obj, auibook.AuiNotebook):
        
            page_idx = event.GetSelection()
            
            if page_idx >= 0:
                window = obj.GetPage(page_idx)
                if window:
                    return self.GetPane(window)
            
        return NonePaneInfo


    def OnTabBeginDrag(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_BEGIN_DRAG`` event.

        :param `event`: a L{AuiNotebookEvent} event to be processed.
        """

        if self._masterManager:
            self._masterManager.OnTabBeginDrag(event)
        
        else:
            paneInfo = self.PaneFromTabEvent(event)
            
            if paneInfo.IsOk():
            
                # It's one of ours!
                self._action = actionDragFloatingPane
                mouse = wx.GetMousePosition()

                # set initial float position - may have to think about this
                # offset a bit more later ...
                self._action_offset = wx.Point(20, 10)
                self._toolbar_action_offset = wx.Point(20, 10)
                
                paneInfo.floating_pos = mouse - self._action_offset
                paneInfo.dock_pos = AUI_DOCK_NONE
                paneInfo.notebook_id = -1

                tab = event.GetEventObject()

                if tab.HasCapture():
                    tab.ReleaseMouse()

                # float the window
                if paneInfo.IsMaximized():
                    self.RestorePane(paneInfo)
                paneInfo.Float()
                self.Update()

                self._action_window = paneInfo.window
                    
                self._frame.CaptureMouse()
                event.SetDispatched(True)
            
            else:
            
                # not our window
                event.Skip()
            

    def OnTabPageClose(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_PAGE_CLOSE`` event.

        :param `event`: a L{AuiNotebookEvent} event to be processed.
        """

        if self._masterManager:
            self._masterManager.OnTabPageClose(event)
        
        else:
        
            p = self.PaneFromTabEvent(event)
            if p.IsOk():
            
                # veto it because we will call "RemovePage" ourselves
                event.Veto()

                # Now ask the app if they really want to close...
                # fire pane close event
                e = AuiManagerEvent(wxEVT_AUI_PANE_CLOSE)
                e.SetPane(p)
                e.SetCanVeto(True)
                self.ProcessMgrEvent(e)

                if e.GetVeto():
                    return

                self.ClosePane(p)
                self.Update()
            else:
                event.Skip()
            

    def OnTabSelected(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_PAGE_CHANGED`` event.

        :param `event`: a L{AuiNotebookEvent} event to be processed.
        """
        
        if self._masterManager:
            self._masterManager.OnTabSelected(event)
            return
        
        obj = event.GetEventObject()

        if obj and isinstance(obj, auibook.AuiNotebook):
        
            notebook = obj
            page = notebook.GetPage(event.GetSelection())
            paneInfo = self.GetPane(page)

            if paneInfo.IsOk():
                notebookRoot = GetNotebookRoot(self._panes, paneInfo.notebook_id)
                if notebookRoot:
                
                    notebookRoot.Caption(paneInfo.caption)
                    self.RefreshCaptions()
                
        event.Skip()


    def GetNotebooks(self):
        """ Returns all the automatic L{AuiNotebook} in the L{AuiManager}. """

        if self._masterManager:
            return self._masterManager.GetNotebooks()
        
        return self._notebooks


    def SetMasterManager(self, manager):
        """
        Sets the master manager for an automatic L{AuiNotebook}.

        :param `manager`: an instance of L{AuiManager}.
        """

        self._masterManager = manager

        
    def ProcessDockResult(self, target, new_pos):
        """
        This is a utility function used by L{DoDrop} - it checks
        if a dock operation is allowed, the new dock position is copied into
        the target info. If the operation was allowed, the function returns ``True``.

        :param `target`: the L{AuiPaneInfo} instance to be docked;
        :param `new_pos`: the new docking position if the docking operation is allowed.
        """

        allowed = False
        direction = new_pos.dock_direction
        
        if direction == AUI_DOCK_TOP:
            allowed = target.IsTopDockable()
        elif direction == AUI_DOCK_BOTTOM:
            allowed = target.IsBottomDockable()
        elif direction == AUI_DOCK_LEFT:
            allowed = target.IsLeftDockable()
        elif direction == AUI_DOCK_RIGHT:
            allowed = target.IsRightDockable()

        if allowed:
            target = new_pos

            if target.IsToolbar():
                self.SwitchToolBarOrientation(target)

        return allowed, target


    def SwitchToolBarOrientation(self, pane):
        """
        Switches the toolbar orientation from vertical to horizontal and vice-versa.
        This is especially useful for vertical docked toolbars once they float.

        :param `pane`: an instance of L{AuiPaneInfo}, which may have a L{AuiToolBar}
         window associated with it.
        """

        if not isinstance(pane.window, auibar.AuiToolBar):
            return pane
        
        if pane.IsFloating():
            return pane

        toolBar = pane.window
        direction = pane.dock_direction
        vertical = direction in [AUI_DOCK_LEFT, AUI_DOCK_RIGHT]

        agwStyle = toolBar.GetAGWWindowStyleFlag()
        new_agwStyle = agwStyle

        if vertical:
            new_agwStyle |= AUI_TB_VERTICAL
        else:
            new_agwStyle &= ~(AUI_TB_VERTICAL)

        if agwStyle != new_agwStyle:
            toolBar.SetAGWWindowStyleFlag(new_agwStyle)
        if not toolBar.GetGripperVisible():
            toolBar.SetGripperVisible(True)

        s = pane.window.GetMinSize()
        pane.BestSize(s)

        if new_agwStyle != agwStyle:
            toolBar.Realize()
        
        return pane


    def DoDrop(self, docks, panes, target, pt, offset=wx.Point(0, 0)):
        """
        This is an important function. It basically takes a mouse position,
        and determines where the panes new position would be. If the pane is to be
        dropped, it performs the drop operation using the specified dock and pane
        arrays. By specifying copy dock and pane arrays when calling, a "what-if"
        scenario can be performed, giving precise coordinates for drop hints.

        :param `docks`: a list of L{AuiDockInfo} classes;
        :param `panes`: a list of L{AuiPaneInfo} instances;
        :param `pt`: a mouse position to check for a drop operation;
        :param `offset`: a possible offset from the input point `pt`.
        """

        if target.IsToolbar():
            return self.DoDropToolbar(docks, panes, target, pt, offset)
        elif target.IsFloating():
            return self.DoDropFloatingPane(docks, panes, target, pt)
        else:
            return self.DoDropNonFloatingPane(docks, panes, target, pt)
    

    def CopyTarget(self, target):
        """
        Copies all the attributes of the input `target` into another L{AuiPaneInfo}.

        :param `target`: the source L{AuiPaneInfo} from where to copy attributes.
        """

        drop = AuiPaneInfo()
        drop.name = target.name
        drop.caption = target.caption
        drop.window = target.window
        drop.frame = target.frame
        drop.state = target.state
        drop.dock_direction = target.dock_direction
        drop.dock_layer = target.dock_layer
        drop.dock_row = target.dock_row
        drop.dock_pos = target.dock_pos
        drop.best_size = wx.Size(*target.best_size)
        drop.min_size = wx.Size(*target.min_size)
        drop.max_size = wx.Size(*target.max_size)
        drop.floating_pos = wx.Point(*target.floating_pos)
        drop.floating_size = wx.Size(*target.floating_size)
        drop.dock_proportion = target.dock_proportion
        drop.buttons = target.buttons
        drop.rect = wx.Rect(*target.rect)
        drop.icon = target.icon
        drop.notebook_id = target.notebook_id
        drop.transparent = target.transparent
        drop.snapped = target.snapped
        drop.minimize_mode = target.minimize_mode

        return drop        


    def DoDropToolbar(self, docks, panes, target, pt, offset):
        """
        Handles the situation in which the dropped pane contains a toolbar.

        :param `docks`: a list of L{AuiDockInfo} classes;
        :param `panes`: a list of L{AuiPaneInfo} instances;
        :param `target`: the target pane containing the toolbar;
        :param `pt`: a mouse position to check for a drop operation;
        :param `offset`: a possible offset from the input point `pt`.        
        """
        
        drop = self.CopyTarget(target)

        # The result should always be shown
        drop.Show()

        # Check to see if the toolbar has been dragged out of the window
        if CheckOutOfWindow(self._frame, pt):
            if self._agwFlags & AUI_MGR_ALLOW_FLOATING and drop.IsFloatable():
                drop.Float()

            return self.ProcessDockResult(target, drop)

        # Allow directional change when the cursor leaves this rect
        safeRect = wx.Rect(*target.rect)
        if target.IsHorizontal():
            safeRect.Inflate(100, 50)
        else:
            safeRect.Inflate(50, 100)
        
        # Check to see if the toolbar has been dragged to edge of the frame
        dropDir = CheckEdgeDrop(self._frame, docks, pt)

        if dropDir != -1:
        
            if dropDir == wx.LEFT:
                drop.Dock().Left().Layer(auiToolBarLayer).Row(0). \
                    Position(pt.y - self.GetDockPixelOffset(drop) - offset.y)

            elif dropDir == wx.RIGHT:
                drop.Dock().Right().Layer(auiToolBarLayer).Row(0). \
                    Position(pt.y - self.GetDockPixelOffset(drop) - offset.y)

            elif dropDir == wx.TOP:
                drop.Dock().Top().Layer(auiToolBarLayer).Row(0). \
                    Position(pt.x - self.GetDockPixelOffset(drop) - offset.x)

            elif dropDir == wx.BOTTOM:
                drop.Dock().Bottom().Layer(auiToolBarLayer).Row(0). \
                    Position(pt.x - self.GetDockPixelOffset(drop) - offset.x)

            if not target.IsFloating() and safeRect.Contains(pt) and \
               target.dock_direction != drop.dock_direction:
                return False, target
        
            return self.ProcessDockResult(target, drop)
    
        # If the windows is floating and out of the client area, do nothing
        if drop.IsFloating() and not self._frame.GetClientRect().Contains(pt):
            return False, target
    
        # Ok, can't drop on edge - check internals ...

        clientSize = self._frame.GetClientSize()
        x = Clip(pt.x, 0, clientSize.x - 1)
        y = Clip(pt.y, 0, clientSize.y - 1)
        part = self.HitTest(x, y)

        if not part or not part.dock:
            return False, target
        
        dock = part.dock
        
        # toolbars may only be moved in and to fixed-pane docks,
        # otherwise we will try to float the pane.  Also, the pane
        # should float if being dragged over center pane windows
        if not dock.fixed or dock.dock_direction == AUI_DOCK_CENTER:
        
            if (self._agwFlags & AUI_MGR_ALLOW_FLOATING and drop.IsFloatable()) or \
               dock.dock_direction not in [AUI_DOCK_CENTER, AUI_DOCK_NONE]:
                if drop.IsFloatable():
                    drop.Float()
            
            return self.ProcessDockResult(target, drop)
        
        # calculate the offset from where the dock begins
        # to the point where the user dropped the pane
        dockDropOffset = 0
        if dock.IsHorizontal():
            dockDropOffset = pt.x - dock.rect.x - offset.x
        else:
            dockDropOffset = pt.y - dock.rect.y - offset.y
        
        drop.Dock().Direction(dock.dock_direction).Layer(dock.dock_layer). \
            Row(dock.dock_row).Position(dockDropOffset)

        if (pt.y <= dock.rect.GetTop() + 2 and dock.IsHorizontal()) or \
           (pt.x <= dock.rect.GetLeft() + 2 and dock.IsVertical()):
        
            if dock.dock_direction in [AUI_DOCK_TOP, AUI_DOCK_LEFT]:
                row = drop.dock_row
                panes = DoInsertDockRow(panes, dock.dock_direction, dock.dock_layer, dock.dock_row)
                drop.dock_row = row
            
            else:
                panes = DoInsertDockRow(panes, dock.dock_direction, dock.dock_layer, dock.dock_row+1)
                drop.dock_row = dock.dock_row + 1
            
        if (pt.y >= dock.rect.GetBottom() - 2 and dock.IsHorizontal()) or \
           (pt.x >= dock.rect.GetRight() - 2 and dock.IsVertical()):
        
            if dock.dock_direction in [AUI_DOCK_TOP, AUI_DOCK_LEFT]:
                panes = DoInsertDockRow(panes, dock.dock_direction, dock.dock_layer, dock.dock_row+1)
                drop.dock_row = dock.dock_row+1
            
            else:
                row = drop.dock_row
                panes = DoInsertDockRow(panes, dock.dock_direction, dock.dock_layer, dock.dock_row)
                drop.dock_row = row

        if not target.IsFloating() and safeRect.Contains(pt) and \
           target.dock_direction != drop.dock_direction:
            return False, target
    
        return self.ProcessDockResult(target, drop)


    def DoDropFloatingPane(self, docks, panes, target, pt):
        """
        Handles the situation in which the dropped pane contains a normal window.

        :param `docks`: a list of L{AuiDockInfo} classes;
        :param `panes`: a list of L{AuiPaneInfo} instances;
        :param `target`: the target pane containing the window;
        :param `pt`: a mouse position to check for a drop operation.
        """
        
        screenPt = self._frame.ClientToScreen(pt)
        paneInfo = self.PaneHitTest(panes, pt)

        if paneInfo.IsMaximized():
            return False, target

        if paneInfo.window is None:
            return False, target

        # search the dock guides.
        # reverse order to handle the center first.
        for i in xrange(len(self._guides)-1, -1, -1):
            guide = self._guides[i]

            # do hit testing on the guide
            dir = guide.host.HitTest(screenPt.x, screenPt.y)

            if dir == -1:  # point was outside of the dock guide
                continue

            if dir == wx.ALL:   # target is a single dock guide
                return self.DoDropLayer(docks, target, guide.dock_direction)
            
            elif dir == wx.CENTER:

                if not target.IsNotebookDockable():
                    continue
                if not paneInfo.IsNotebookDockable() and not paneInfo.IsNotebookControl():
                    continue

                if not paneInfo.HasNotebook():
                
                    # Add a new notebook pane with the original as a tab...
                    self.CreateNotebookBase(panes, paneInfo)
                
                # Add new item to notebook
                target.NotebookPage(paneInfo.notebook_id)
            
            else:
            
                drop_pane = False
                drop_row = False

                insert_dir = paneInfo.dock_direction
                insert_layer = paneInfo.dock_layer
                insert_row = paneInfo.dock_row
                insert_pos = paneInfo.dock_pos

                if insert_dir == AUI_DOCK_CENTER:
                
                    insert_layer = 0
                    if dir == wx.LEFT:
                        insert_dir = AUI_DOCK_LEFT
                    elif dir == wx.UP:
                        insert_dir = AUI_DOCK_TOP
                    elif dir == wx.RIGHT:
                        insert_dir = AUI_DOCK_RIGHT
                    elif dir == wx.DOWN:
                        insert_dir = AUI_DOCK_BOTTOM
                
                if insert_dir == AUI_DOCK_LEFT:
                
                    drop_pane = (dir == wx.UP   or dir == wx.DOWN)
                    drop_row  = (dir == wx.LEFT or dir == wx.RIGHT)
                    if dir == wx.RIGHT:
                        insert_row += 1
                    elif dir == wx.DOWN:
                        insert_pos += 1
                
                elif insert_dir == AUI_DOCK_RIGHT:
                
                    drop_pane = (dir == wx.UP   or dir == wx.DOWN)
                    drop_row  = (dir == wx.LEFT or dir == wx.RIGHT)
                    if dir == wx.LEFT:
                        insert_row += 1
                    elif dir == wx.DOWN:
                        insert_pos += 1
                
                elif insert_dir == AUI_DOCK_TOP:
                
                    drop_pane = (dir == wx.LEFT or dir == wx.RIGHT)
                    drop_row  = (dir == wx.UP   or dir == wx.DOWN)
                    if dir == wx.DOWN:
                        insert_row += 1
                    elif dir == wx.RIGHT:
                        insert_pos += 1
                
                elif insert_dir == AUI_DOCK_BOTTOM:
                
                    drop_pane = (dir == wx.LEFT or dir == wx.RIGHT)
                    drop_row  = (dir == wx.UP   or dir == wx.DOWN)
                    if dir == wx.UP:
                        insert_row += 1
                    elif dir == wx.RIGHT:
                        insert_pos += 1
                
                if paneInfo.dock_direction == AUI_DOCK_CENTER:
                    insert_row = GetMaxRow(panes, insert_dir, insert_layer) + 1

                if drop_pane:
                    return self.DoDropPane(panes, target, insert_dir, insert_layer, insert_row, insert_pos)

                if drop_row:
                    return self.DoDropRow(panes, target, insert_dir, insert_layer, insert_row)
            
            return True, target
        
        return False, target


    def DoDropNonFloatingPane(self, docks, panes, target, pt):
        """
        Handles the situation in which the dropped pane is not floating.

        :param `docks`: a list of L{AuiDockInfo} classes;
        :param `panes`: a list of L{AuiPaneInfo} instances;
        :param `target`: the target pane containing the toolbar;
        :param `pt`: a mouse position to check for a drop operation.
        """
        
        screenPt = self._frame.ClientToScreen(pt)
        clientSize = self._frame.GetClientSize()
        frameRect = GetInternalFrameRect(self._frame, self._docks)

        drop = self.CopyTarget(target)

        # The result should always be shown
        drop.Show()

        part = self.HitTest(pt.x, pt.y)

        if not part:
            return False, target

        if part.type == AuiDockUIPart.typeDockSizer:
        
            if len(part.dock.panes) != 1:
                return False, target
            
            part = self.GetPanePart(part.dock.panes[0].window)
            if not part:
                return False, target
        
        if not part.pane:
            return False, target

        part = self.GetPanePart(part.pane.window)
        if not part:
            return False, target

        insert_dock_row = False
        insert_row = part.pane.dock_row
        insert_dir = part.pane.dock_direction
        insert_layer = part.pane.dock_layer

        direction = part.pane.dock_direction
        
        if direction == AUI_DOCK_TOP:
            if pt.y >= part.rect.y and pt.y < part.rect.y+auiInsertRowPixels:
                insert_dock_row = True

        elif direction == AUI_DOCK_BOTTOM:
            if pt.y > part.rect.y+part.rect.height-auiInsertRowPixels and \
               pt.y <= part.rect.y + part.rect.height:
                insert_dock_row = True

        elif direction == AUI_DOCK_LEFT:
            if pt.x >= part.rect.x and pt.x < part.rect.x+auiInsertRowPixels:
                insert_dock_row = True

        elif direction == AUI_DOCK_RIGHT:
            if pt.x > part.rect.x+part.rect.width-auiInsertRowPixels and \
               pt.x <= part.rect.x+part.rect.width:
                insert_dock_row = True

        elif direction == AUI_DOCK_CENTER:
            
                # "new row pixels" will be set to the default, but
                # must never exceed 20% of the window size
                new_row_pixels_x = auiNewRowPixels
                new_row_pixels_y = auiNewRowPixels

                if new_row_pixels_x > (part.rect.width*20)/100:
                    new_row_pixels_x = (part.rect.width*20)/100

                if new_row_pixels_y > (part.rect.height*20)/100:
                    new_row_pixels_y = (part.rect.height*20)/100

                # determine if the mouse pointer is in a location that
                # will cause a new row to be inserted.  The hot spot positions
                # are along the borders of the center pane

                insert_layer = 0
                insert_dock_row = True
                pr = part.rect
                
                if pt.x >= pr.x and pt.x < pr.x + new_row_pixels_x:
                    insert_dir = AUI_DOCK_LEFT
                elif pt.y >= pr.y and pt.y < pr.y + new_row_pixels_y:
                    insert_dir = AUI_DOCK_TOP
                elif pt.x >= pr.x + pr.width - new_row_pixels_x and pt.x < pr.x + pr.width:
                    insert_dir = AUI_DOCK_RIGHT
                elif pt.y >= pr.y+ pr.height - new_row_pixels_y and pt.y < pr.y + pr.height:
                    insert_dir = AUI_DOCK_BOTTOM
                else:
                    return False, target

                insert_row = GetMaxRow(panes, insert_dir, insert_layer) + 1
            
        if insert_dock_row:
        
            panes = DoInsertDockRow(panes, insert_dir, insert_layer, insert_row)
            drop.Dock().Direction(insert_dir).Layer(insert_layer). \
                Row(insert_row).Position(0)
                
            return self.ProcessDockResult(target, drop)

        # determine the mouse offset and the pane size, both in the
        # direction of the dock itself, and perpendicular to the dock

        if part.orientation == wx.VERTICAL:
        
            offset = pt.y - part.rect.y
            size = part.rect.GetHeight()
        
        else:
        
            offset = pt.x - part.rect.x
            size = part.rect.GetWidth()
        
        drop_position = part.pane.dock_pos

        # if we are in the top/left part of the pane,
        # insert the pane before the pane being hovered over
        if offset <= size/2:
        
            drop_position = part.pane.dock_pos
            panes = DoInsertPane(panes,
                                 part.pane.dock_direction,
                                 part.pane.dock_layer,
                                 part.pane.dock_row,
                                 part.pane.dock_pos)

        # if we are in the bottom/right part of the pane,
        # insert the pane before the pane being hovered over
        if offset > size/2:
        
            drop_position = part.pane.dock_pos+1
            panes = DoInsertPane(panes,
                                 part.pane.dock_direction,
                                 part.pane.dock_layer,
                                 part.pane.dock_row,
                                 part.pane.dock_pos+1)
        

        drop.Dock(). \
                     Direction(part.dock.dock_direction). \
                     Layer(part.dock.dock_layer).Row(part.dock.dock_row). \
                     Position(drop_position)
        
        return self.ProcessDockResult(target, drop)


    def DoDropLayer(self, docks, target, dock_direction):
        """
        Handles the situation in which `target` is a single dock guide.

        :param `docks`: a list of L{AuiDockInfo} classes;
        :param `target`: the target pane;
        :param `dock_direction`: the docking direction.
        """

        drop = self.CopyTarget(target)
        
        if dock_direction == AUI_DOCK_LEFT:
            drop.Dock().Left()
            drop_new_layer = max(max(GetMaxLayer(docks, AUI_DOCK_LEFT),
                                     GetMaxLayer(docks, AUI_DOCK_BOTTOM)),
                                 GetMaxLayer(docks, AUI_DOCK_TOP)) + 1

        elif dock_direction == AUI_DOCK_TOP:
            drop.Dock().Top()
            drop_new_layer = max(max(GetMaxLayer(docks, AUI_DOCK_TOP),
                                     GetMaxLayer(docks, AUI_DOCK_LEFT)),
                                 GetMaxLayer(docks, AUI_DOCK_RIGHT)) + 1

        elif dock_direction == AUI_DOCK_RIGHT:
            drop.Dock().Right()
            drop_new_layer = max(max(GetMaxLayer(docks, AUI_DOCK_RIGHT),
                                     GetMaxLayer(docks, AUI_DOCK_TOP)),
                                 GetMaxLayer(docks, AUI_DOCK_BOTTOM)) + 1

        elif dock_direction == AUI_DOCK_BOTTOM:
            drop.Dock().Bottom()
            drop_new_layer = max(max(GetMaxLayer(docks, AUI_DOCK_BOTTOM),
                                     GetMaxLayer(docks, AUI_DOCK_LEFT)),
                                 GetMaxLayer(docks, AUI_DOCK_RIGHT)) + 1

        else:
            return False, target
        

        drop.Dock().Layer(drop_new_layer)
        return self.ProcessDockResult(target, drop)


    def DoDropPane(self, panes, target, dock_direction, dock_layer, dock_row, dock_pos):
        """
        Drop a pane in the interface.

        :param `panes`: a list of L{AuiPaneInfo} classes;
        :param `target`: the target pane;
        :param `dock_direction`: the docking direction;
        :param `dock_layer`: the docking layer;
        :param `dock_row`: the docking row;
        :param `dock_pos`: the docking position.
        """
        
        drop = self.CopyTarget(target)
        panes = DoInsertPane(panes, dock_direction, dock_layer, dock_row, dock_pos)

        drop.Dock().Direction(dock_direction).Layer(dock_layer).Row(dock_row).Position(dock_pos)
        return self.ProcessDockResult(target, drop)


    def DoDropRow(self, panes, target, dock_direction, dock_layer, dock_row):
        """
        Insert a row in the interface before dropping.

        :param `panes`: a list of L{AuiPaneInfo} classes;
        :param `target`: the target pane;
        :param `dock_direction`: the docking direction;
        :param `dock_layer`: the docking layer;
        :param `dock_row`: the docking row.
        """
        
        drop = self.CopyTarget(target)
        panes = DoInsertDockRow(panes, dock_direction, dock_layer, dock_row)

        drop.Dock().Direction(dock_direction).Layer(dock_layer).Row(dock_row).Position(0)
        return self.ProcessDockResult(target, drop)


    def ShowHint(self, rect):
        """
        Shows the AUI hint window.

        :param `rect`: the hint rect calculated in advance.
        """

        if rect == self._last_hint:
            return

        if self._agwFlags & AUI_MGR_RECTANGLE_HINT and wx.Platform != "__WXMAC__":

            if self._last_hint != rect:
                # remove the last hint rectangle
                self._last_hint = wx.Rect(*rect)
                self._frame.Refresh()
                self._frame.Update()
            
            screendc = wx.ScreenDC()
            clip = wx.Region(1, 1, 10000, 10000)

            # clip all floating windows, so we don't draw over them
            for pane in self._panes:            
                if pane.IsFloating() and pane.frame.IsShown():
                
                    rect2 = wx.Rect(*pane.frame.GetRect())
                    if wx.Platform == "__WXGTK__":
                        # wxGTK returns the client size, not the whole frame size
                        rect2.width += 15
                        rect2.height += 35
                        rect2.Inflate(5, 5)

                    clip.SubtractRect(rect2)
                
            # As we can only hide the hint by redrawing the managed window, we
            # need to clip the region to the managed window too or we get
            # nasty redrawn problems.
            clip.IntersectRect(self._frame.GetRect())
            screendc.SetClippingRegionAsRegion(clip)

            stipple = PaneCreateStippleBitmap()
            brush = wx.BrushFromBitmap(stipple)
            screendc.SetBrush(brush)
            screendc.SetPen(wx.TRANSPARENT_PEN)
            screendc.DrawRectangle(rect.x, rect.y, 5, rect.height)
            screendc.DrawRectangle(rect.x+5, rect.y, rect.width-10, 5)
            screendc.DrawRectangle(rect.x+rect.width-5, rect.y, 5, rect.height)
            screendc.DrawRectangle(rect.x+5, rect.y+rect.height-5, rect.width-10, 5)
            RefreshDockingGuides(self._guides)

            return
            
        if not self._hint_window:
            self.CreateHintWindow()

        if self._hint_window:
            self._hint_window.SetRect(rect)
            self._hint_window.Show()

        self._hint_fadeamt = self._hint_fademax

        if self._agwFlags & AUI_MGR_HINT_FADE:
            self._hint_fadeamt = 0
            self._hint_window.SetTransparent(self._hint_fadeamt)

        if self._action == actionDragFloatingPane and self._action_window:
            self._action_window.SetFocus()

        if self._hint_fadeamt != self._hint_fademax: #  Only fade if we need to
            # start fade in timer
            self._hint_fadetimer.Start(5)

        self._last_hint = wx.Rect(*rect)
        

    def HideHint(self):
        """ Hides a transparent window hint if there is one. """

        # hides a transparent window hint if there is one
        if self._hint_window:
            self._hint_window.Hide()

        self._hint_fadetimer.Stop()
        self._last_hint = wx.Rect()
        

    def IsPaneButtonVisible(self, part):
        """
        Returns whether a pane button in the pane caption is visible.

        :param `part`: the UI part to analyze.
        """

        captionRect = wx.Rect()

        for temp_part in self._uiparts:
            if temp_part.pane == part.pane and \
               temp_part.type == AuiDockUIPart.typeCaption:
                captionRect = temp_part.rect
                break

        return captionRect.ContainsRect(part.rect)


    def DrawPaneButton(self, dc, part, pt):
        """
        Draws a pane button in the caption (convenience function).

        :param `dc`: a `wx.DC` device context object;
        :param `part`: the UI part to analyze;
        :param `pt`: a `wx.Point` object, specifying the mouse location.
        """

        if not self.IsPaneButtonVisible(part):
            return

        state = AUI_BUTTON_STATE_NORMAL

        if part.rect.Contains(pt):

            if _VERSION_STRING < "2.9":
                leftDown = wx.GetMouseState().LeftDown()
            else:
                leftDown = wx.GetMouseState().LeftIsDown()

            if leftDown:
                state = AUI_BUTTON_STATE_PRESSED
            else:
                state = AUI_BUTTON_STATE_HOVER

        self._art.DrawPaneButton(dc, self._frame, part.button.button_id,
                                 state, part.rect, part.pane)

    
    def RefreshButton(self, part):
        """
        Refreshes a pane button in the caption.

        :param `part`: the UI part to analyze.
        """
        
        rect = wx.Rect(*part.rect)
        rect.Inflate(2, 2)
        self._frame.Refresh(True, rect)
        self._frame.Update()


    def RefreshCaptions(self):
        """ Refreshes all pane captions. """

        for part in self._uiparts:
            if part.type == AuiDockUIPart.typeCaption:
                self._frame.Refresh(True, part.rect)
                self._frame.Update()


    def CalculateHintRect(self, pane_window, pt, offset):
        """
        Calculates the drop hint rectangle.

        The method first calls L{DoDrop} to determine the exact position the pane would
        be at were if dropped. If the pane would indeed become docked at the
        specified drop point, the the rectangle hint will be returned in
        screen coordinates. Otherwise, an empty rectangle is returned.

        :param `pane_window`: it is the window pointer of the pane being dragged;
        :param `pt`: is the mouse position, in client coordinates;
        :param `offset`: describes the offset that the mouse is from the upper-left
         corner of the item being dragged.
        """
        
        # we need to paint a hint rectangle to find out the exact hint rectangle,
        # we will create a new temporary layout and then measure the resulting
        # rectangle we will create a copy of the docking structures (self._docks)
        # so that we don't modify the real thing on screen

        rect = wx.Rect()
        pane = self.GetPane(pane_window)
        
        attrs = self.GetAttributes(pane)
        hint = AuiPaneInfo()
        hint = self.SetAttributes(hint, attrs)
        
        if hint.name != "__HINT__":
            self._oldname = hint.name
            
        hint.name = "__HINT__"
        hint.PaneBorder(True)
        hint.Show()

        if not hint.IsOk():
            hint.name = self._oldname
            return rect

        docks, panes = CopyDocksAndPanes2(self._docks, self._panes)

        # remove any pane already there which bears the same window
        # this happens when you are moving a pane around in a dock
        for ii in xrange(len(panes)):
            if panes[ii].window == pane_window:
                docks = RemovePaneFromDocks(docks, panes[ii])
                panes.pop(ii)
                break

        # find out where the new pane would be
        allow, hint = self.DoDrop(docks, panes, hint, pt, offset)

        if not allow:
            return rect
        
        panes.append(hint)

        sizer, panes, docks, uiparts = self.LayoutAll(panes, docks, [], True, False)
        
        client_size = self._frame.GetClientSize()
        sizer.SetDimension(0, 0, client_size.x, client_size.y)
        sizer.Layout()

        sought = "__HINT__"
        
        # For a notebook page, actually look for the noteboot itself.
        if hint.IsNotebookPage():
            id = hint.notebook_id
            for pane in panes:
                if pane.IsNotebookControl() and pane.notebook_id==id:
                    sought = pane.name
                    break

        for part in uiparts:
            if part.pane and part.pane.name == sought:    
                rect.Union(wx.RectPS(part.sizer_item.GetPosition(),
                                     part.sizer_item.GetSize()))

        sizer.Destroy()

        # check for floating frame ...
        if rect.IsEmpty():
            for p in panes:
                if p.name == sought and p.IsFloating():
                    return wx.RectPS(p.floating_pos, p.floating_size)
    
        if rect.IsEmpty():
            return rect

        # actually show the hint rectangle on the screen
        rect.x, rect.y = self._frame.ClientToScreen((rect.x, rect.y))
        if self._frame.GetLayoutDirection() == wx.Layout_RightToLeft:
            # Mirror rectangle in RTL mode
            rect.x -= rect.GetWidth()

        return rect


    def DrawHintRect(self, pane_window, pt, offset):
        """
        Calculates the hint rectangle by calling
        L{CalculateHintRect}. If there is a rectangle, it shows it
        by calling L{ShowHint}, otherwise it hides any hint
        rectangle currently shown.

        :param `pane_window`: it is the window pointer of the pane being dragged;
        :param `pt`: is the mouse position, in client coordinates;
        :param `offset`: describes the offset that the mouse is from the upper-left
         corner of the item being dragged.
        """

        rect = self.CalculateHintRect(pane_window, pt, offset)

        if rect.IsEmpty():
            self.HideHint()
            self._hint_rect = wx.Rect()
        else:
            self.ShowHint(rect)
            self._hint_rect = wx.Rect(*rect)


    def GetPartSizerRect(self, uiparts):
        """
        Returns the rectangle surrounding the specified UI parts.

        :param `uiparts`: UI parts.
        """

        rect = wx.Rect()

        for part in self._uiparts:
            if part.pane and part.pane.name == "__HINT__":
                rect.Union(wx.RectPS(part.sizer_item.GetPosition(),
                                     part.sizer_item.GetSize()))

        return rect


    def GetAttributes(self, pane):
        """
        Returns all the attributes of a L{AuiPaneInfo}.

        :param `pane`: a L{AuiPaneInfo} instance.
        """

        attrs = []
        attrs.extend([pane.window, pane.frame, pane.state, pane.dock_direction,
                      pane.dock_layer, pane.dock_pos, pane.dock_row, pane.dock_proportion,
                      pane.floating_pos, pane.floating_size, pane.best_size,
                      pane.min_size, pane.max_size, pane.caption, pane.name,
                      pane.buttons, pane.rect, pane.icon, pane.notebook_id,
                      pane.transparent, pane.snapped, pane.minimize_mode])

        return attrs
    

    def SetAttributes(self, pane, attrs):
        """
        Sets all the attributes contained in `attrs` to a L{AuiPaneInfo}.

        :param `pane`: a L{AuiPaneInfo} instance;
        :param `attrs`: a list of attributes.
        """
        
        pane.window = attrs[0]
        pane.frame = attrs[1]
        pane.state = attrs[2]
        pane.dock_direction = attrs[3]
        pane.dock_layer = attrs[4]
        pane.dock_pos = attrs[5]
        pane.dock_row = attrs[6]
        pane.dock_proportion = attrs[7]
        pane.floating_pos = attrs[8]
        pane.floating_size = attrs[9]
        pane.best_size = attrs[10]
        pane.min_size = attrs[11]
        pane.max_size = attrs[12]
        pane.caption = attrs[13]
        pane.name = attrs[14]
        pane.buttons = attrs[15]
        pane.rect = attrs[16]
        pane.icon = attrs[17]
        pane.notebook_id = attrs[18]
        pane.transparent = attrs[19]
        pane.snapped = attrs[20]
        pane.minimize_mode = attrs[21]

        return pane

     
    def OnFloatingPaneResized(self, wnd, size):
        """
        Handles the resizing of a floating pane.

        :param `wnd`: a `wx.Window` derived window, managed by the pane;
        :param `size`: a `wx.Size` object, specifying the new pane floating size.
        """

        # try to find the pane
        pane = self.GetPane(wnd)
        if not pane.IsOk():
            raise Exception("Pane window not found")

        if pane.frame:
            indx = self._panes.index(pane)
            pane.floating_pos = pane.frame.GetPosition()
            pane.floating_size = size
            self._panes[indx] = pane
            if pane.IsSnappable():
                self.SnapPane(pane, pane.floating_pos, pane.floating_size, True)
            

    def OnFloatingPaneClosed(self, wnd, event):
        """
        Handles the close event of a floating pane.

        :param `wnd`: a `wx.Window` derived window, managed by the pane;
        :param `event`: a `wx.CloseEvent` to be processed.
        """
        
        # try to find the pane
        pane = self.GetPane(wnd)
        if not pane.IsOk():
            raise Exception("Pane window not found")

        # fire pane close event
        e = AuiManagerEvent(wxEVT_AUI_PANE_CLOSE)
        e.SetPane(pane)
        e.SetCanVeto(event.CanVeto())
        self.ProcessMgrEvent(e)

        if e.GetVeto():
            event.Veto()
            return
        else:
            # close the pane, but check that it
            # still exists in our pane array first
            # (the event handler above might have removed it)

            check = self.GetPane(wnd)
            if check.IsOk():
                self.ClosePane(pane)
        

    def OnFloatingPaneActivated(self, wnd):
        """
        Handles the activation event of a floating pane.

        :param `wnd`: a `wx.Window` derived window, managed by the pane.
        """
        
        pane = self.GetPane(wnd)
        if not pane.IsOk():
            raise Exception("Pane window not found")

        if self.GetAGWFlags() & AUI_MGR_ALLOW_ACTIVE_PANE:
            ret, self._panes = SetActivePane(self._panes, wnd)
            self.RefreshCaptions()


    def OnFloatingPaneMoved(self, wnd, eventOrPt):
        """
        Handles the move event of a floating pane.

        :param `wnd`: a `wx.Window` derived window, managed by the pane;
        :param `eventOrPt`: a `wx.MoveEvent` to be processed or an instance of `wx.Point`.
        """
        
        pane = self.GetPane(wnd)
        if not pane.IsOk():
            raise Exception("Pane window not found")

        if not pane.IsSnappable():
            return

        if isinstance(eventOrPt, wx.Point):
            pane_pos = wx.Point(*eventOrPt)
        else:
            pane_pos = eventOrPt.GetPosition()

        pane_size = pane.floating_size

        self.SnapPane(pane, pane_pos, pane_size, False)


    def SnapPane(self, pane, pane_pos, pane_size, toSnap=False):
        """
        Snaps a floating pane to one of the main frame sides.

        :param `pane`: a L{AuiPaneInfo} instance;
        :param `pane_pos`: the new pane floating position;
        :param `pane_size`: the new pane floating size;
        :param `toSnap`: a bool variable to check if L{SnapPane} was called from
         a move event.
        """

        if self._from_move:
            return
        
        managed_window = self.GetManagedWindow()
        wnd_pos = managed_window.GetPosition()
        wnd_size = managed_window.GetSize()
        snapX, snapY = self._snap_limits

        if not toSnap:
            pane.snapped = 0
            if pane.IsLeftSnappable():
                # Check if we can snap to the left
                diff = wnd_pos.x - (pane_pos.x + pane_size.x)
                if -snapX <= diff <= snapX:
                    pane.snapped = wx.LEFT
                    pane.floating_pos = wx.Point(wnd_pos.x-pane_size.x, pane_pos.y)
            elif pane.IsTopSnappable():
                # Check if we can snap to the top
                diff = wnd_pos.y - (pane_pos.y + pane_size.y)
                if -snapY <= diff <= snapY:
                    pane.snapped = wx.TOP
                    pane.floating_pos = wx.Point(pane_pos.x, wnd_pos.y-pane_size.y)
            elif pane.IsRightSnappable():
                # Check if we can snap to the right
                diff = pane_pos.x - (wnd_pos.x + wnd_size.x)
                if -snapX <= diff <= snapX:
                    pane.snapped = wx.RIGHT
                    pane.floating_pos = wx.Point(wnd_pos.x + wnd_size.x, pane_pos.y)
            elif pane.IsBottomSnappable():
                # Check if we can snap to the bottom
                diff = pane_pos.y - (wnd_pos.y + wnd_size.y)
                if -snapY <= diff <= snapY:
                    pane.snapped = wx.BOTTOM
                    pane.floating_pos = wx.Point(pane_pos.x, wnd_pos.y + wnd_size.y)

        self.RepositionPane(pane, wnd_pos, wnd_size)


    def RepositionPane(self, pane, wnd_pos, wnd_size):
        """
        Repositions a pane after the main frame has been moved/resized.
        
        :param `pane`: a L{AuiPaneInfo} instance;
        :param `wnd_pos`: the main frame position;
        :param `wnd_size`: the main frame size.
        """

        pane_pos = pane.floating_pos
        pane_size = pane.floating_size

        snap = pane.snapped
        if snap == wx.LEFT:
            floating_pos = wx.Point(wnd_pos.x - pane_size.x, pane_pos.y)
        elif snap == wx.TOP:
            floating_pos = wx.Point(pane_pos.x, wnd_pos.y - pane_size.y)
        elif snap == wx.RIGHT:
            floating_pos = wx.Point(wnd_pos.x + wnd_size.x, pane_pos.y)
        elif snap == wx.BOTTOM:
            floating_pos = wx.Point(pane_pos.x, wnd_pos.y + wnd_size.y)

        if snap:
            if pane_pos != floating_pos:
                pane.floating_pos = floating_pos
                self._from_move = True
                pane.frame.SetPosition(pane.floating_pos)
                self._from_move = False

            
    def OnGripperClicked(self, pane_window, start, offset):
        """
        Handles the mouse click on the pane gripper.

        :param `pane_window`: a `wx.Window` derived window, managed by the pane;
        :param `start`: a `wx.Point` object, specifying the clicking position;
        :param `offset`: an offset point from the `start` position.
        """

        # try to find the pane
        paneInfo = self.GetPane(pane_window)

        if not paneInfo.IsOk():
            raise Exception("Pane window not found")

        if self.GetAGWFlags() & AUI_MGR_ALLOW_ACTIVE_PANE:
            # set the caption as active
            ret, self._panes = SetActivePane(self._panes, pane_window)
            self.RefreshCaptions()
        
        self._action_part = None
        self._action_pane = paneInfo
        self._action_window = pane_window
        self._action_start = start
        self._action_offset = offset
        self._toolbar_action_offset = wx.Point(*self._action_offset)
        
        self._frame.CaptureMouse()

        if paneInfo.IsDocked():
            self._action = actionClickCaption
        else:
            if paneInfo.IsToolbar():
                self._action = actionDragToolbarPane
            else:
                self._action = actionDragFloatingPane

            if paneInfo.frame:
            
                windowPt = paneInfo.frame.GetRect().GetTopLeft()
                originPt = paneInfo.frame.ClientToScreen(wx.Point())
                self._action_offset += originPt - windowPt
                self._toolbar_action_offset = wx.Point(*self._action_offset)

                if self._agwFlags & AUI_MGR_TRANSPARENT_DRAG:
                    paneInfo.frame.SetTransparent(150)
            
            if paneInfo.IsToolbar():
                self._frame.SetCursor(wx.StockCursor(wx.CURSOR_SIZING))
        

    def OnRender(self, event):        
        """
        Draws all of the pane captions, sashes,
        backgrounds, captions, grippers, pane borders and buttons.
        It renders the entire user interface. It binds the ``EVT_AUI_RENDER`` event.

        :param `event`: an instance of L{AuiManagerEvent}.
        """

        # if the frame is about to be deleted, don't bother
        if not self._frame or self._frame.IsBeingDeleted():
            return
        
        if not self._frame.GetSizer():
            return

        mouse = wx.GetMouseState()
        mousePos = wx.Point(mouse.GetX(), mouse.GetY())
        point = self._frame.ScreenToClient(mousePos)
        art = self._art

        dc = event.GetDC()
        
        for part in self._uiparts:
        
            # don't draw hidden pane items or items that aren't windows
            if part.sizer_item and ((not part.sizer_item.IsWindow() and \
                                     not part.sizer_item.IsSpacer() and \
                                     not part.sizer_item.IsSizer()) or \
                                    not part.sizer_item.IsShown()):
            
                continue
            
            ptype = part.type
                    
            if ptype in [AuiDockUIPart.typeDockSizer, AuiDockUIPart.typePaneSizer]:
                art.DrawSash(dc, self._frame, part.orientation, part.rect)

            elif ptype == AuiDockUIPart.typeBackground:
                art.DrawBackground(dc, self._frame, part.orientation, part.rect)

            elif ptype == AuiDockUIPart.typeCaption:
                art.DrawCaption(dc, self._frame, part.pane.caption, part.rect, part.pane)

            elif ptype == AuiDockUIPart.typeGripper:
                art.DrawGripper(dc, self._frame, part.rect, part.pane)

            elif ptype == AuiDockUIPart.typePaneBorder:
                art.DrawBorder(dc, self._frame, part.rect, part.pane)

            elif ptype == AuiDockUIPart.typePaneButton:                
                self.DrawPaneButton(dc, part, point)


    def Repaint(self, dc=None):
        """
        Repaints the entire frame decorations (sashes, borders, buttons and so on).
        It renders the entire user interface.

        :param `dc`: if not ``None``, an instance of `wx.PaintDC`.
        """
        
        w, h = self._frame.GetClientSize()

        # Figure out which dc to use; if one
        # has been specified, use it, otherwise
        # make a client dc
        if dc is None:
            client_dc = wx.ClientDC(self._frame)
            dc = client_dc

        # If the frame has a toolbar, the client area
        # origin will not be (0, 0).
        pt = self._frame.GetClientAreaOrigin()
        if pt.x != 0 or pt.y != 0:
            dc.SetDeviceOrigin(pt.x, pt.y)

        # Render all the items
        self.Render(dc)

                
    def Render(self, dc):
        """
        Fires a render event, which is normally handled by
        L{OnRender}. This allows the render function to
        be overridden via the render event.

        This can be useful for painting custom graphics in the main window.
        Default behavior can be invoked in the overridden function by calling
        L{OnRender}.

        :param `dc`: a `wx.DC` device context object.        
        """

        e = AuiManagerEvent(wxEVT_AUI_RENDER)
        e.SetManager(self)
        e.SetDC(dc)
        self.ProcessMgrEvent(e)


    def OnCaptionDoubleClicked(self, pane_window):
        """
        Handles the mouse double click on the pane caption.

        :param `pane_window`: a `wx.Window` derived window, managed by the pane.
        """

        # try to find the pane
        paneInfo = self.GetPane(pane_window)
        if not paneInfo.IsOk():
            raise Exception("Pane window not found")

        if not paneInfo.IsFloatable() or not paneInfo.IsDockable() or \
           self._agwFlags & AUI_MGR_ALLOW_FLOATING == 0:
            return

        indx = self._panes.index(paneInfo)
        win_rect = None
        
        if paneInfo.IsFloating():
            if paneInfo.name.startswith("__floating__"):
                # It's a floating tab from a AuiNotebook
                notebook = paneInfo.window.__aui_notebook__
                notebook.ReDockPage(paneInfo)
                self.Update()
                return
            else:

                e = self.FireEvent(wxEVT_AUI_PANE_DOCKING, paneInfo, canVeto=True)
                if e.GetVeto():
                    self.HideHint()
                    ShowDockingGuides(self._guides, False)
                    return
                
                win_rect = paneInfo.frame.GetRect()
                paneInfo.Dock()
                if paneInfo.IsToolbar():
                    paneInfo = self.SwitchToolBarOrientation(paneInfo)

                e = self.FireEvent(wxEVT_AUI_PANE_DOCKED, paneInfo, canVeto=False)

        else:

            e = self.FireEvent(wxEVT_AUI_PANE_FLOATING, paneInfo, canVeto=True)
            if e.GetVeto():
                return

            # float the window
            if paneInfo.IsMaximized():
                self.RestorePane(paneInfo)
            
            if paneInfo.floating_pos == wx.Point(-1, -1):
                captionSize = self._art.GetMetric(AUI_DOCKART_CAPTION_SIZE)
                paneInfo.floating_pos = pane_window.GetScreenPosition()
                paneInfo.floating_pos.y -= captionSize

            paneInfo.Float()
            e = self.FireEvent(wxEVT_AUI_PANE_FLOATED, paneInfo, canVeto=False)

        self._panes[indx] = paneInfo
        self.Update()

        if win_rect and self._agwFlags & AUI_MGR_ANIMATE_FRAMES:
            paneInfo = self.GetPane(pane_window)
            pane_rect = paneInfo.window.GetScreenRect()
            self.AnimateDocking(win_rect, pane_rect)


    def OnPaint(self, event):
        """
        Handles the ``wx.EVT_PAINT`` event for L{AuiManager}.

        :param `event`: an instance of `wx.PaintEvent` to be processed.
        """
        
        dc = wx.PaintDC(self._frame)
        self.Repaint(dc)
                

    def OnEraseBackground(self, event):
        """
        Handles the ``wx.EVT_ERASE_BACKGROUND`` event for L{AuiManager}.

        :param `event`: `wx.EraseEvent` to be processed.

        :note: This is intentionally empty (excluding wxMAC) to reduce
         flickering while drawing.
        """
        
        if wx.Platform == "__WXMAC__":
            event.Skip()


    def OnSize(self, event):
        """
        Handles the ``wx.EVT_SIZE`` event for L{AuiManager}.

        :param `event`: a `wx.SizeEvent` to be processed.
        """
        
        skipped = False
        if isinstance(self._frame, AuiFloatingFrame) and self._frame.IsShownOnScreen():
            skipped = True
            event.Skip()

        if self._frame:
                
            self.DoFrameLayout()
            if wx.Platform == "__WXMAC__":
                self._frame.Refresh()
            else:
                self.Repaint()
            
            if isinstance(self._frame, wx.MDIParentFrame) or isinstance(self._frame, tabmdi.AuiMDIClientWindow) \
               or isinstance(self._frame, tabmdi.AuiMDIParentFrame):
                # for MDI parent frames, this event must not
                # be "skipped".  In other words, the parent frame
                # must not be allowed to resize the client window
                # after we are finished processing sizing changes
                return

        if not skipped:
            event.Skip()

        # For the snap to screen...
        self.OnMove(None)
        

    def OnFindManager(self, event):
        """
        Handles the ``EVT_AUI_FIND_MANAGER`` event for L{AuiManager}.

        :param `event`: a L{AuiManagerEvent} event to be processed.
        """
        
        # Initialize to None
        event.SetManager(None)
        
        if not self._frame:
            return
        
        # See it this window wants to overwrite
        self._frame.ProcessEvent(event)

        # if no, it must be us
        if not event.GetManager():
           event.SetManager(self)
       

    def OnSetCursor(self, event):
        """
        Handles the ``wx.EVT_SET_CURSOR`` event for L{AuiManager}.

        :param `event`: a `wx.SetCursorEvent` to be processed.
        """
        
        # determine cursor
        part = self.HitTest(event.GetX(), event.GetY())
        cursor = wx.NullCursor

        if part:
            if part.type in [AuiDockUIPart.typeDockSizer, AuiDockUIPart.typePaneSizer]:

                if not self.CheckMovableSizer(part):
                    return
                
                if part.orientation == wx.VERTICAL:
                    cursor = wx.StockCursor(wx.CURSOR_SIZEWE)
                else:
                    cursor = wx.StockCursor(wx.CURSOR_SIZENS)
            
            elif part.type == AuiDockUIPart.typeGripper:
                cursor = wx.StockCursor(wx.CURSOR_SIZING)

        event.SetCursor(cursor)


    def UpdateButtonOnScreen(self, button_ui_part, event):
        """
        Updates/redraws the UI part containing a pane button.

        :param `button_ui_part`: the UI part the button belongs to;
        :param `event`: a `wx.MouseEvent` to be processed.
        """

        hit_test = self.HitTest(*event.GetPosition())

        if not hit_test or not button_ui_part:
            return
    
        state = AUI_BUTTON_STATE_NORMAL
        
        if hit_test == button_ui_part:
            if event.LeftDown():
                state = AUI_BUTTON_STATE_PRESSED
            else:
                state = AUI_BUTTON_STATE_HOVER
        else:
            if event.LeftDown():
                state = AUI_BUTTON_STATE_HOVER
        
        # now repaint the button with hover state
        cdc = wx.ClientDC(self._frame)

        # if the frame has a toolbar, the client area
        # origin will not be (0,0).
        pt = self._frame.GetClientAreaOrigin()
        if pt.x != 0 or pt.y != 0:
            cdc.SetDeviceOrigin(pt.x, pt.y)

        if hit_test.pane:        
            self._art.DrawPaneButton(cdc, self._frame,
                      button_ui_part.button.button_id,
                      state,
                      button_ui_part.rect, hit_test.pane)


    def OnLeftDown(self, event):
        """
        Handles the ``wx.EVT_LEFT_DOWN`` event for L{AuiManager}.

        :param `event`: a `wx.MouseEvent` to be processed.
        """
        
        part = self.HitTest(*event.GetPosition())

        if not part:
            event.Skip()
            return
        
        self._currentDragItem = -1
        
        if part.type in [AuiDockUIPart.typeDockSizer, AuiDockUIPart.typePaneSizer]:
        
            if not self.CheckMovableSizer(part):
                return

            self._action = actionResize
            self._action_part = part
            self._action_pane = None
            self._action_rect = wx.Rect()
            self._action_start = wx.Point(event.GetX(), event.GetY())
            self._action_offset = wx.Point(event.GetX() - part.rect.x,
                                           event.GetY() - part.rect.y)

            # draw the resize hint
            rect = wx.RectPS(self._frame.ClientToScreen(part.rect.GetPosition()),
                             part.rect.GetSize())

            self._action_rect = wx.Rect(*rect)

            if not AuiManager_HasLiveResize(self):
                if wx.Platform == "__WXMAC__":
                    dc = wx.ClientDC(self._frame)
                else:
                    dc = wx.ScreenDC()
                    
                DrawResizeHint(dc, rect)

            self._frame.CaptureMouse()
        
        elif part.type == AuiDockUIPart.typePaneButton:
            if self.IsPaneButtonVisible(part):
                self._action = actionClickButton
                self._action_part = part
                self._action_pane = None
                self._action_start = wx.Point(*event.GetPosition())
                self._frame.CaptureMouse()

                self.RefreshButton(part)
        
        elif part.type in [AuiDockUIPart.typeCaption, AuiDockUIPart.typeGripper]:

            # if we are managing a AuiFloatingFrame window, then
            # we are an embedded AuiManager inside the AuiFloatingFrame.
            # We want to initiate a toolbar drag in our owner manager
            if isinstance(part.pane.window.GetParent(), AuiFloatingFrame):
                rootManager = GetManager(part.pane.window)
            else:
                rootManager = self

            offset = wx.Point(event.GetX() - part.rect.x, event.GetY() - part.rect.y)
            rootManager.OnGripperClicked(part.pane.window, event.GetPosition(), offset)
        
        if wx.Platform != "__WXMAC__":
            event.Skip()


    def OnLeftDClick(self, event):
        """
        Handles the ``wx.EVT_LEFT_DCLICK`` event for L{AuiManager}.

        :param `event`: a `wx.MouseEvent` to be processed.
        """
        
        part = self.HitTest(event.GetX(), event.GetY())

        if part and part.type == AuiDockUIPart.typeCaption:
            if isinstance(part.pane.window.GetParent(), AuiFloatingFrame):
                rootManager = GetManager(part.pane.window)
            else:
                rootManager = self
                
            rootManager.OnCaptionDoubleClicked(part.pane.window)
            
        elif part and part.type in [AuiDockUIPart.typeDockSizer, AuiDockUIPart.typePaneSizer]:
            # Handles double click on AuiNotebook sashes to unsplit
            sash_size = self._art.GetMetric(AUI_DOCKART_SASH_SIZE)
            for child in part.cont_sizer.GetChildren():
                if child.IsSizer():
                    win = child.GetSizer().GetContainingWindow()
                    if isinstance(win, auibook.AuiNotebook):
                        win.UnsplitDClick(part, sash_size, event.GetPosition())
                        break
                
        event.Skip()


    def DoEndResizeAction(self, event):
        """
        Ends a resize action, or for live update, resizes the sash.

        :param `event`: a `wx.MouseEvent` to be processed.
        """

        clientPt = event.GetPosition()
        screenPt = self._frame.ClientToScreen(clientPt)

        return self.RestrictResize(clientPt, screenPt, createDC=False)


    def RestrictResize(self, clientPt, screenPt, createDC):
        """ Common method between L{DoEndResizeAction} and L{OnLeftUp_Resize}. """

        dock = self._action_part.dock
        pane = self._action_part.pane

        if createDC:
            if wx.Platform == "__WXMAC__":
                dc = wx.ClientDC(self._frame)
            else:
                dc = wx.ScreenDC()

            DrawResizeHint(dc, self._action_rect)
            self._action_rect = wx.Rect()
        
        newPos = clientPt - self._action_offset

        if self._action_part.type == AuiDockUIPart.typeDockSizer:
            minPix, maxPix = self.CalculateDockSizerLimits(dock)
        else:
            if not self._action_part.pane:
                return
            minPix, maxPix = self.CalculatePaneSizerLimits(dock, pane)

        if self._action_part.orientation == wx.HORIZONTAL:
            newPos.y = Clip(newPos.y, minPix, maxPix)
        else:
            newPos.x = Clip(newPos.x, minPix, maxPix)

        if self._action_part.type == AuiDockUIPart.typeDockSizer:
        
            partnerDock = self.GetPartnerDock(dock)
            sash_size = self._art.GetMetric(AUI_DOCKART_SASH_SIZE)
            new_dock_size = 0
            direction = dock.dock_direction

            if direction == AUI_DOCK_LEFT:
                new_dock_size = newPos.x - dock.rect.x

            elif direction == AUI_DOCK_TOP:
                new_dock_size = newPos.y - dock.rect.y

            elif direction == AUI_DOCK_RIGHT:
                new_dock_size = dock.rect.x + dock.rect.width - newPos.x - sash_size

            elif direction == AUI_DOCK_BOTTOM:
                new_dock_size = dock.rect.y + dock.rect.height - newPos.y - sash_size

            deltaDockSize = new_dock_size - dock.size

            if partnerDock:
                if deltaDockSize > partnerDock.size - sash_size:
                    deltaDockSize = partnerDock.size - sash_size

                partnerDock.size -= deltaDockSize
            
            dock.size += deltaDockSize
            self.Update()
        
        else:
        
            # determine the new pixel size that the user wants
            # this will help us recalculate the pane's proportion
            if dock.IsHorizontal():
                oldPixsize = pane.rect.width
                newPixsize = oldPixsize + newPos.x - self._action_part.rect.x
                    
            else:            
                oldPixsize = pane.rect.height
                newPixsize = oldPixsize + newPos.y - self._action_part.rect.y
                                
            totalPixsize, totalProportion = self.GetTotalPixSizeAndProportion(dock)
            partnerPane = self.GetPartnerPane(dock, pane)

            # prevent division by zero
            if totalPixsize <= 0 or totalProportion <= 0 or not partnerPane:
                return

            # adjust for the surplus
            while (oldPixsize > 0 and totalPixsize > 10 and \
                  oldPixsize*totalProportion/totalPixsize < pane.dock_proportion):
            
                totalPixsize -= 1

            # calculate the new proportion of the pane
            
            newProportion = newPixsize*totalProportion/totalPixsize
            newProportion = Clip(newProportion, 1, totalProportion)
            deltaProp = newProportion - pane.dock_proportion

            if partnerPane.dock_proportion - deltaProp < 1:
                deltaProp = partnerPane.dock_proportion - 1
                newProportion = pane.dock_proportion + deltaProp
            
            # borrow the space from our neighbor pane to the
            # right or bottom (depending on orientation)
            partnerPane.dock_proportion -= deltaProp
            pane.dock_proportion = newProportion

            self.Update()
        
        return True
    

    def OnLeftUp(self, event):
        """
        Handles the ``wx.EVT_LEFT_UP`` event for L{AuiManager}.

        :param `event`: a `wx.MouseEvent` to be processed.
        """

        if self._action == actionResize:
##            self._frame.Freeze()
            self.OnLeftUp_Resize(event)
##            self._frame.Thaw()
        
        elif self._action == actionClickButton:
            self.OnLeftUp_ClickButton(event)
        
        elif self._action == actionDragFloatingPane:
            self.OnLeftUp_DragFloatingPane(event)
        
        elif self._action == actionDragToolbarPane:
            self.OnLeftUp_DragToolbarPane(event)
            
        else:
            event.Skip()        

        if self._frame.HasCapture():
            self._frame.ReleaseMouse()
            
        self._action = actionNone


    def OnMotion(self, event):
        """
        Handles the ``wx.EVT_MOTION`` event for L{AuiManager}.

        :param `event`: a `wx.MouseEvent` to be processed.
        """

        if self._action == actionResize:
            self.OnMotion_Resize(event)
        
        elif self._action == actionClickCaption:
            self.OnMotion_ClickCaption(event)
        
        elif self._action == actionDragFloatingPane:
            self.OnMotion_DragFloatingPane(event)
        
        elif self._action == actionDragToolbarPane:
            self.OnMotion_DragToolbarPane(event)
        
        else:
            self.OnMotion_Other(event)
                        
    
    def OnLeaveWindow(self, event):
        """
        Handles the ``wx.EVT_LEAVE_WINDOW`` event for L{AuiManager}.

        :param `event`: a `wx.MouseEvent` to be processed.
        """

        if self._hover_button:
            self.RefreshButton(self._hover_button)
            self._hover_button = None


    def OnCaptureLost(self, event):
        """
        Handles the ``wx.EVT_MOUSE_CAPTURE_LOST`` event for L{AuiManager}.

        :param `event`: a `wx.MouseCaptureLostEvent` to be processed.
        """
        
        # cancel the operation in progress, if any
        if self._action != actionNone:
            self._action = actionNone
            self.HideHint()


    def OnHintFadeTimer(self, event):
        """
        Handles the ``wx.EVT_TIMER`` event for L{AuiManager}.

        :param `event`: a `wx.TimerEvent` to be processed.
        """

        if not self._hint_window or self._hint_fadeamt >= self._hint_fademax:
            self._hint_fadetimer.Stop()
            return

        self._hint_fadeamt += 4
        self._hint_window.SetTransparent(self._hint_fadeamt)


    def OnMove(self, event):
        """
        Handles the ``wx.EVT_MOVE`` event for L{AuiManager}.

        :param `event`: a `wx.MoveEvent` to be processed.
        """

        if isinstance(self._frame, AuiFloatingFrame) and self._frame.IsShownOnScreen():
            if event is not None:
                event.Skip()
            return

        docked, hAlign, vAlign, monitor = self._is_docked
        if docked:
            self.Snap()

        for pane in self._panes:
            if pane.IsSnappable():
                if pane.IsFloating() and pane.IsShown():
                    self.SnapPane(pane, pane.floating_pos, pane.floating_size, True)
        

    def OnSysColourChanged(self, event):
        """
        Handles the ``wx.EVT_SYS_COLOUR_CHANGED`` event for L{AuiManager}.

        :param `event`: a `wx.SysColourChangedEvent` to be processed.
        """
        
        # This event is probably triggered by a theme change 
        # so we have to re-init the art provider.
        if self._art:
            self._art.Init()

        if self._frame:
            self.Update()
            self._frame.Refresh()
            

    def OnChildFocus(self, event):
        """
        Handles the ``wx.EVT_CHILD_FOCUS`` event for L{AuiManager}.

        :param `event`: a `wx.ChildFocusEvent` to be processed.
        """

        # when a child pane has it's focus set, we should change the 
        # pane's active state to reflect this. (this is only true if 
        # active panes are allowed by the owner)

        window = event.GetWindow()
        if isinstance(window, wx.Dialog):
            # Ignore EVT_CHILD_FOCUS events originating from dialogs not
            # managed by AUI
            rootManager = None
        elif isinstance(window.GetParent(), AuiFloatingFrame):
            rootManager = GetManager(window)
        else:
            rootManager = self
                
        if rootManager:
            rootManager.ActivatePane(window)
            
        event.Skip()


    def OnMotion_ClickCaption(self, event):
        """
        Sub-handler for the L{OnMotion} event.

        :param `event`: a `wx.MouseEvent` to be processed.
        """
        
        clientPt = event.GetPosition()
        screenPt = self._frame.ClientToScreen(clientPt)

        drag_x_threshold = wx.SystemSettings.GetMetric(wx.SYS_DRAG_X)
        drag_y_threshold = wx.SystemSettings.GetMetric(wx.SYS_DRAG_Y)

        if not self._action_pane:
            return

        # we need to check if the mouse is now being dragged
        if not (abs(clientPt.x - self._action_start.x) > drag_x_threshold or \
                abs(clientPt.y - self._action_start.y) > drag_y_threshold):
        
            return
        
        # dragged -- we need to change the mouse action to 'drag'
        if self._action_pane.IsToolbar():
            self._action = actionDragToolbarPane
            self._action_window = self._action_pane.window
        
        elif self._action_pane.IsFloatable() and self._agwFlags & AUI_MGR_ALLOW_FLOATING:

            e = self.FireEvent(wxEVT_AUI_PANE_FLOATING, self._action_pane, canVeto=True)
            if e.GetVeto():
                return
            
            self._action = actionDragFloatingPane

            # set initial float position
            self._action_pane.floating_pos = screenPt - self._action_offset

            # float the window
            if self._action_pane.IsMaximized():
                self.RestorePane(self._action_pane)
                
            self._action_pane.Hide()
            self._action_pane.Float()
            if wx.Platform == "__WXGTK__":
                self._action_pane.Show()

            e = self.FireEvent(wxEVT_AUI_PANE_FLOATED, self._action_pane, canVeto=False)

            if not self._action_pane.frame:
                self.Update()

            self._action_window = self._action_pane.window

            # adjust action offset for window frame
            windowPt = self._action_pane.frame.GetRect().GetTopLeft()
            originPt = self._action_pane.frame.ClientToScreen(wx.Point())
            self._toolbar_action_offset = originPt - windowPt
            
            if self._agwFlags & AUI_MGR_USE_NATIVE_MINIFRAMES:
                originPt = windowPt + wx.Point(3, 3)
                
            self._action_offset += originPt - windowPt

            # action offset is used here to make it feel "natural" to the user
            # to drag a docked pane and suddenly have it become a floating frame.
            # Sometimes, however, the offset where the user clicked on the docked
            # caption is bigger than the width of the floating frame itself, so
            # in that case we need to set the action offset to a sensible value
            frame_size = self._action_pane.frame.GetSize()
            if self._action_offset.x > frame_size.x * 2 / 3:
                self._action_offset.x = frame_size.x / 2
            if self._action_offset.y > frame_size.y * 2 / 3:
                self._action_offset.y = frame_size.y / 2

            self.OnMotion_DragFloatingPane(event)
            if wx.Platform != "__WXGTK__":
                self._action_pane.Show()
                
            self.Update()


    def OnMotion_Resize(self, event):
        """
        Sub-handler for the L{OnMotion} event.

        :param `event`: a `wx.MouseEvent` to be processed.
        """

        if AuiManager_HasLiveResize(self):
            if self._currentDragItem != -1:
                self._action_part = self._uiparts[self._currentDragItem]
            else:
                self._currentDragItem = self._uiparts.index(self._action_part)

            if self._frame.HasCapture():
                self._frame.ReleaseMouse()
                
            self.DoEndResizeAction(event)
            self._frame.CaptureMouse()
            return

        if not self._action_part or not self._action_part.dock or not self._action_part.orientation:
            return

        clientPt = event.GetPosition()
        screenPt = self._frame.ClientToScreen(clientPt)
                    
        dock = self._action_part.dock
        pos = self._action_part.rect.GetPosition()

        if self._action_part.type == AuiDockUIPart.typeDockSizer:
            minPix, maxPix = self.CalculateDockSizerLimits(dock)
        else:
            if not self._action_part.pane:
                return
            
            pane = self._action_part.pane
            minPix, maxPix = self.CalculatePaneSizerLimits(dock, pane)

        if self._action_part.orientation == wx.HORIZONTAL:
            pos.y = Clip(clientPt.y - self._action_offset.y, minPix, maxPix)
        else:
            pos.x = Clip(clientPt.x - self._action_offset.x, minPix, maxPix)

        hintrect = wx.RectPS(self._frame.ClientToScreen(pos), self._action_part.rect.GetSize())

        if hintrect != self._action_rect:
        
            if wx.Platform == "__WXMAC__":
                dc = wx.ClientDC(self._frame)
            else:
                dc = wx.ScreenDC()

            DrawResizeHint(dc, self._action_rect)
            DrawResizeHint(dc, hintrect)
            self._action_rect = wx.Rect(*hintrect)
                

    def OnLeftUp_Resize(self, event):
        """
        Sub-handler for the L{OnLeftUp} event.

        :param `event`: a `wx.MouseEvent` to be processed.
        """
        
        if self._currentDragItem != -1 and AuiManager_HasLiveResize(self):
            self._action_part = self._uiparts[self._currentDragItem]

            if self._frame.HasCapture():
                self._frame.ReleaseMouse()
                
            self.DoEndResizeAction(event)
            self._currentDragItem = -1
            return
            
        if not self._action_part or not self._action_part.dock:
            return

        clientPt = event.GetPosition()
        screenPt = self._frame.ClientToScreen(clientPt)

        return self.RestrictResize(clientPt, screenPt, createDC=True)
        

    def OnLeftUp_ClickButton(self, event):
        """
        Sub-handler for the L{OnLeftUp} event.

        :param `event`: a `wx.MouseEvent` to be processed.
        """
        
        self._hover_button = None

        if self._action_part:
            self.RefreshButton(self._action_part)

            # make sure we're still over the item that was originally clicked
            if self._action_part == self.HitTest(*event.GetPosition()):
            
                # fire button-click event
                e = AuiManagerEvent(wxEVT_AUI_PANE_BUTTON)
                e.SetManager(self)
                e.SetPane(self._action_part.pane)
                e.SetButton(self._action_part.button.button_id)
                self.ProcessMgrEvent(e)
        

    def CheckPaneMove(self, pane):
        """
        Checks if a pane has moved by a visible amount.

        :param `pane`: an instance of L{AuiPaneInfo}.
        """

        win_rect = pane.frame.GetRect()
        win_rect.x, win_rect.y = pane.floating_pos
        
        if win_rect == self._last_rect:
            return False

        # skip the first move event
        if self._last_rect.IsEmpty():
            self._last_rect = wx.Rect(*win_rect)
            return False

        # skip if moving too fast to avoid massive redraws and
        # jumping hint windows
        if abs(win_rect.x - self._last_rect.x) > 10 or \
           abs(win_rect.y - self._last_rect.y) > 10:
            self._last_rect = wx.Rect(*win_rect)
            return False

        return True        
        

    def OnMotion_DragFloatingPane(self, eventOrPt):
        """
        Sub-handler for the L{OnMotion} event.

        :param `event`: a `wx.MouseEvent` to be processed.
        """

        isPoint = False
        if isinstance(eventOrPt, wx.Point):
            clientPt = self._frame.ScreenToClient(eventOrPt)
            screenPt = wx.Point(*eventOrPt)
            isPoint = True
        else:
            clientPt = eventOrPt.GetPosition()
            screenPt = self._frame.ClientToScreen(clientPt)
        
        framePos = wx.Point()
        
        # try to find the pane
        pane = self.GetPane(self._action_window)
        if not pane.IsOk():
            raise Exception("Pane window not found")

        # update floating position
        if pane.IsFloating():
            diff = pane.floating_pos - (screenPt - self._action_offset)
            pane.floating_pos = screenPt - self._action_offset

        framePos = pane.floating_pos

        # Move the pane window
        if pane.frame:

            if diff.x != 0 or diff.y != 0:
                if wx.Platform == "__WXMSW__" and (self._agwFlags & AUI_MGR_TRANSPARENT_DRAG) == 0: # and not self.CheckPaneMove(pane):
                    # return
                    # HACK: Terrible hack on wxMSW (!)
                    pane.frame.SetTransparent(254)
                            
                self._from_move = True
                pane.frame.Move(pane.floating_pos)
                self._from_move = False

            if self._agwFlags & AUI_MGR_TRANSPARENT_DRAG:
                pane.frame.SetTransparent(150)

        # calculate the offset from the upper left-hand corner
        # of the frame to the mouse pointer
        action_offset = screenPt - framePos

        # is the pane dockable?
        if not self.CanDockPanel(pane):
            self.HideHint()
            ShowDockingGuides(self._guides, False)
            return
        
        for paneInfo in self._panes:
        
            if not paneInfo.IsDocked() or not paneInfo.IsShown():
                continue
            if paneInfo.IsToolbar() or paneInfo.IsNotebookControl():
                continue
            if paneInfo.IsMaximized():
                continue

            if paneInfo.IsNotebookPage():
            
                notebookRoot = GetNotebookRoot(self._panes, paneInfo.notebook_id)

                if not notebookRoot or not notebookRoot.IsDocked():
                    continue
            
            rc = paneInfo.window.GetScreenRect()
            if rc.Contains(screenPt):
                if rc.height < 20 or rc.width < 20:
                    return
                
                self.UpdateDockingGuides(paneInfo)
                ShowDockingGuides(self._guides, True)
                break

        self.DrawHintRect(pane.window, clientPt, action_offset)


    def OnLeftUp_DragFloatingPane(self, eventOrPt):
        """
        Sub-handler for the L{OnLeftUp} event.

        :param `event`: a `wx.MouseEvent` to be processed.
        """

        if isinstance(eventOrPt, wx.Point):
            clientPt = self._frame.ScreenToClient(eventOrPt)
            screenPt = wx.Point(*eventOrPt)
        else:
            clientPt = eventOrPt.GetPosition()
            screenPt = self._frame.ClientToScreen(clientPt)

        # try to find the pane
        paneInfo = self.GetPane(self._action_window)
        if not paneInfo.IsOk():
            raise Exception("Pane window not found")

        ret = False
        
        if paneInfo.frame:
        
            # calculate the offset from the upper left-hand corner
            # of the frame to the mouse pointer
            framePos = paneInfo.frame.GetPosition()
            action_offset = screenPt - framePos

            # is the pane dockable?
            if self.CanDockPanel(paneInfo):
                # do the drop calculation
                indx = self._panes.index(paneInfo)
                ret, paneInfo = self.DoDrop(self._docks, self._panes, paneInfo, clientPt, action_offset)

                if ret:
                    e = self.FireEvent(wxEVT_AUI_PANE_DOCKING, paneInfo, canVeto=True)
                    if e.GetVeto():
                        self.HideHint()
                        ShowDockingGuides(self._guides, False)
                        return

                    e = self.FireEvent(wxEVT_AUI_PANE_DOCKED, paneInfo, canVeto=False)

                    if self._agwFlags & AUI_MGR_SMOOTH_DOCKING:
                        self.SmoothDock(paneInfo)

                self._panes[indx] = paneInfo
            
        # if the pane is still floating, update it's floating
        # position (that we store)
        if paneInfo.IsFloating():
            paneInfo.floating_pos = paneInfo.frame.GetPosition()
            if paneInfo.frame._transparent != paneInfo.transparent or self._agwFlags & AUI_MGR_TRANSPARENT_DRAG:
                paneInfo.frame.SetTransparent(paneInfo.transparent)
                paneInfo.frame._transparent = paneInfo.transparent
        
        elif self._has_maximized:
            self.RestoreMaximizedPane()
        
        # reorder for dropping to a new notebook
        # (caution: this code breaks the reference!)
        tempPaneInfo = self.CopyTarget(paneInfo)
        self._panes.remove(paneInfo)
        self._panes.append(tempPaneInfo)

        if ret:
            self.Update()

        self.HideHint()
        ShowDockingGuides(self._guides, False)


    def OnMotion_DragToolbarPane(self, eventOrPt):
        """
        Sub-handler for the L{OnMotion} event.

        :param `event`: a `wx.MouseEvent` to be processed.
        """
        
        isPoint = False
        if isinstance(eventOrPt, wx.Point):
            clientPt = self._frame.ScreenToClient(eventOrPt)
            screenPt = wx.Point(*eventOrPt)
            isPoint = True
        else:
            clientPt = eventOrPt.GetPosition()
            screenPt = self._frame.ClientToScreen(clientPt)

        pane = self.GetPane(self._action_window)
        if not pane.IsOk():
            raise Exception("Pane window not found")

        pane.state |= AuiPaneInfo.actionPane
        indx = self._panes.index(pane)

        ret = False
        wasFloating = pane.IsFloating()
        # is the pane dockable?
        if self.CanDockPanel(pane):
            # do the drop calculation
            ret, pane = self.DoDrop(self._docks, self._panes, pane, clientPt, self._action_offset)
        
        # update floating position
        if pane.IsFloating():
            pane.floating_pos = screenPt - self._toolbar_action_offset

        # move the pane window
        if pane.frame:
            if wx.Platform == "__WXMSW__" and (self._agwFlags & AUI_MGR_TRANSPARENT_DRAG) == 0: # and not self.CheckPaneMove(pane):
                # return
                # HACK: Terrible hack on wxMSW (!)
                pane.frame.SetTransparent(254)

            self._from_move = True
            pane.frame.Move(pane.floating_pos)
            self._from_move = False
                
            if self._agwFlags & AUI_MGR_TRANSPARENT_DRAG:
                pane.frame.SetTransparent(150)

        self._panes[indx] = pane
        if ret and wasFloating != pane.IsFloating() or (ret and not wasFloating):
            wx.CallAfter(self.Update)

        # when release the button out of the window.
        # TODO: a better fix is needed.

        if _VERSION_STRING < "2.9":
            leftDown = wx.GetMouseState().LeftDown()
        else:
            leftDown = wx.GetMouseState().LeftIsDown()
        
        if not leftDown:
            self._action = actionNone
            self.OnLeftUp_DragToolbarPane(eventOrPt)


    def OnMotion_Other(self, event):
        """
        Sub-handler for the L{OnMotion} event.

        :param `event`: a `wx.MouseEvent` to be processed.
        """
        
        part = self.HitTest(*event.GetPosition())

        if part and part.type == AuiDockUIPart.typePaneButton \
           and self.IsPaneButtonVisible(part):
            if part != self._hover_button:
            
                if self._hover_button:
                    self.RefreshButton(self._hover_button)

                self._hover_button = part
                self.RefreshButton(part)
            
        else:
        
            if self._hover_button:
                self.RefreshButton(self._hover_button)
            else:
                event.Skip()

            self._hover_button = None
        
        
    def OnLeftUp_DragToolbarPane(self, eventOrPt):
        """
        Sub-handler for the L{OnLeftUp} event.

        :param `event`: a `wx.MouseEvent` to be processed.
        """
        
        isPoint = False
        if isinstance(eventOrPt, wx.Point):
            clientPt = self._frame.ScreenToClient(eventOrPt)
            screenPt = wx.Point(*eventOrPt)
            isPoint = True
        else:
            clientPt = eventOrPt.GetPosition()
            screenPt = self._frame.ClientToScreen(clientPt)

        # try to find the pane
        pane = self.GetPane(self._action_window)
        if not pane.IsOk():
            raise Exception("Pane window not found")

        if pane.IsFloating():
            pane.floating_pos = pane.frame.GetPosition()
            if pane.frame._transparent != pane.transparent or self._agwFlags & AUI_MGR_TRANSPARENT_DRAG:
                pane.frame.SetTransparent(pane.transparent)
                pane.frame._transparent = pane.transparent
        
        # save the new positions
        docks = FindDocks(self._docks, pane.dock_direction, pane.dock_layer, pane.dock_row)
        if len(docks) == 1:
            dock = docks[0]
            pane_positions, pane_sizes = self.GetPanePositionsAndSizes(dock)

            for i in xrange(len(dock.panes)):
                dock.panes[i].dock_pos = pane_positions[i]
        
        pane.state &= ~AuiPaneInfo.actionPane
        self.Update()


    def OnPaneButton(self, event):
        """
        Handles the ``EVT_AUI_PANE_BUTTON`` event for L{AuiManager}.

        :param `event`: a L{AuiManagerEvent} event to be processed.
        """

        if not event.pane:
            raise Exception("Pane Info passed to AuiManager.OnPaneButton must be non-null")

        pane = event.pane

        if event.button == AUI_BUTTON_CLOSE:

            if isinstance(pane.window.GetParent(), AuiFloatingFrame):
                rootManager = GetManager(pane.window)
            else:
                rootManager = self
            
            if rootManager != self:
                self._frame.Close()
                return

            # fire pane close event
            e = AuiManagerEvent(wxEVT_AUI_PANE_CLOSE)
            e.SetManager(self)
            e.SetPane(event.pane)
            self.ProcessMgrEvent(e)

            if not e.GetVeto():
            
                # close the pane, but check that it
                # still exists in our pane array first
                # (the event handler above might have removed it)

                check = self.GetPane(pane.window)
                if check.IsOk():                
                    self.ClosePane(pane)
                
                self.Update()

        # mn this performs the minimizing of a pane
        elif event.button == AUI_BUTTON_MINIMIZE:
            e = AuiManagerEvent(wxEVT_AUI_PANE_MINIMIZE)
            e.SetManager(self)
            e.SetPane(event.pane)
            self.ProcessMgrEvent(e)

            if not e.GetVeto():
                self.MinimizePane(pane)
    
        elif event.button == AUI_BUTTON_MAXIMIZE_RESTORE and not pane.IsMaximized():
        
            # fire pane close event
            e = AuiManagerEvent(wxEVT_AUI_PANE_MAXIMIZE)
            e.SetManager(self)
            e.SetPane(event.pane)
            self.ProcessMgrEvent(e)

            if not e.GetVeto():
            
                self.MaximizePane(pane)
                self.Update()
            
        elif event.button == AUI_BUTTON_MAXIMIZE_RESTORE and pane.IsMaximized():
        
            # fire pane close event
            e = AuiManagerEvent(wxEVT_AUI_PANE_RESTORE)
            e.SetManager(self)
            e.SetPane(event.pane)
            self.ProcessMgrEvent(e)

            if not e.GetVeto():
            
                self.RestorePane(pane)
                self.Update()
            
        elif event.button == AUI_BUTTON_PIN:
        
            if self._agwFlags & AUI_MGR_ALLOW_FLOATING and pane.IsFloatable():
                e = self.FireEvent(wxEVT_AUI_PANE_FLOATING, pane, canVeto=True)
                if e.GetVeto():
                    return

                pane.Float()
                e = self.FireEvent(wxEVT_AUI_PANE_FLOATED, pane, canVeto=False)

            self.Update()


    def MinimizePane(self, paneInfo):
        """
        Minimizes a pane in a newly and automatically created L{AuiToolBar}.

        Clicking on the minimize button causes a new L{AuiToolBar} to be created
        and added to the frame manager (currently the implementation is such that
        panes at West will have a toolbar at the right, panes at South will have
        toolbars at the bottom etc...) and the pane is hidden in the manager.
        
        Clicking on the restore button on the newly created toolbar will result in the
        toolbar being removed and the original pane being restored.

        :param `paneInfo`: a L{AuiPaneInfo} instance for the pane to be minimized.
        """
        
        if not paneInfo.IsToolbar():

            if paneInfo.IsMinimized():
                # We are already minimized
                return
            
            # Basically the idea is this.
            #
            # 1) create a toolbar, with a restore button 
            #
            # 2) place the new toolbar in the toolbar area representative of the location of the pane 
            #  (NORTH/SOUTH/EAST/WEST, central area always to the right)
            #
            # 3) Hide the minimizing pane 


            # personalize the toolbar style
            tbStyle = AUI_TB_DEFAULT_STYLE
            posMask = paneInfo.minimize_mode & AUI_MINIMIZE_POS_MASK
            captMask = paneInfo.minimize_mode & AUI_MINIMIZE_CAPT_MASK
            dockDirection = paneInfo.dock_direction
            if captMask != 0:
                tbStyle |= AUI_TB_TEXT
            if posMask == AUI_MINIMIZE_POS_SMART:
                if paneInfo.dock_direction in [AUI_DOCK_TOP, AUI_DOCK_BOTTOM]:
                    tbStyle |= AUI_TB_HORZ_LAYOUT

                elif paneInfo.dock_direction in [AUI_DOCK_LEFT, AUI_DOCK_RIGHT, AUI_DOCK_CENTER]:
                    tbStyle |= AUI_TB_VERTICAL
                    if captMask == AUI_MINIMIZE_CAPT_SMART:
                        tbStyle |= AUI_TB_CLOCKWISE
                    
            elif posMask in [AUI_MINIMIZE_POS_TOP, AUI_MINIMIZE_POS_BOTTOM]:
                tbStyle |= AUI_TB_HORZ_LAYOUT
                if posMask == AUI_MINIMIZE_POS_TOP:
                    dockDirection = AUI_DOCK_TOP
                else:
                    dockDirection = AUI_DOCK_BOTTOM

            else:
                tbStyle |= AUI_TB_VERTICAL
                if captMask == AUI_MINIMIZE_CAPT_SMART:
                    tbStyle |= AUI_TB_CLOCKWISE
                if posMask == AUI_MINIMIZE_POS_LEFT:
                    dockDirection = AUI_DOCK_LEFT
                elif posMask == AUI_MINIMIZE_POS_RIGHT:
                    dockDirection = AUI_DOCK_RIGHT
                elif posMask == AUI_MINIMIZE_POS_BOTTOM:
                    dockDirection = AUI_DOCK_BOTTOM

            # Create a new toolbar
            # give it the same name as the minimized pane with _min appended

            win_rect = paneInfo.window.GetScreenRect()
            
            minimize_toolbar = auibar.AuiToolBar(self.GetManagedWindow(), agwStyle=tbStyle)
            minimize_toolbar.Hide()
            minimize_toolbar.SetToolBitmapSize(wx.Size(16, 16))

            if paneInfo.icon and paneInfo.icon.IsOk():
                restore_bitmap = paneInfo.icon
            else:
                restore_bitmap = self._art._restore_bitmap
                
            minimize_toolbar.AddSimpleTool(ID_RESTORE_FRAME, paneInfo.caption, restore_bitmap, "Restore " + paneInfo.caption)
            minimize_toolbar.SetAuiManager(self)
            minimize_toolbar.Realize()
            toolpanelname = paneInfo.name + "_min"

            if paneInfo.IsMaximized():
                paneInfo.SetFlag(paneInfo.wasMaximized, True)

            if dockDirection == AUI_DOCK_TOP:
                self.AddPane(minimize_toolbar, AuiPaneInfo(). \
                    Name(toolpanelname).Caption(paneInfo.caption). \
                    ToolbarPane().Top().BottomDockable(False). \
                    LeftDockable(False).RightDockable(False).DestroyOnClose())
                
            elif dockDirection == AUI_DOCK_BOTTOM:
                self.AddPane(minimize_toolbar, AuiPaneInfo(). \
                    Name(toolpanelname).Caption(paneInfo.caption). \
                    ToolbarPane().Bottom().TopDockable(False). \
                    LeftDockable(False).RightDockable(False).DestroyOnClose())
                
            elif dockDirection == AUI_DOCK_LEFT:
                self.AddPane(minimize_toolbar, AuiPaneInfo(). \
                    Name(toolpanelname).Caption(paneInfo.caption). \
                    ToolbarPane().Left().TopDockable(False). \
                    BottomDockable(False).RightDockable(False).DestroyOnClose())

            elif dockDirection in [AUI_DOCK_RIGHT, AUI_DOCK_CENTER]:
                self.AddPane(minimize_toolbar, AuiPaneInfo(). \
                    Name(toolpanelname).Caption(paneInfo.caption). \
                    ToolbarPane().Right().TopDockable(False). \
                    LeftDockable(False).BottomDockable(False).DestroyOnClose())

            arr = FindDocks(self._docks, paneInfo.dock_direction, paneInfo.dock_layer, paneInfo.dock_row)

            if arr:
                dock = arr[0]
                paneInfo.previousDockSize = dock.size

            paneInfo.previousDockPos = paneInfo.dock_pos
            
            # mark ourselves minimized
            paneInfo.Minimize()
            paneInfo.Show(False)
            self._has_minimized = True
            # last, hide the window
            if paneInfo.window and paneInfo.window.IsShown():
                paneInfo.window.Show(False)

            minimize_toolbar.Show()
            self.Update()
            if self._agwFlags & AUI_MGR_ANIMATE_FRAMES:
                self.AnimateDocking(win_rect, minimize_toolbar.GetScreenRect())


    def OnRestoreMinimizedPane(self, event):
        """
        Handles the ``EVT_AUI_PANE_MIN_RESTORE`` event for L{AuiManager}.

        :param `event`: an instance of L{AuiManagerEvent} to be processed.
        """

        self.RestoreMinimizedPane(event.pane)


    def OnPaneDocked(self, event):
        """
        Handles the ``EVT_AUI_PANE_DOCKED`` event for L{AuiManager}.

        :param `event`: an instance of L{AuiManagerEvent} to be processed.
        """

        event.Skip()
        self.RemoveAutoNBCaption(event.GetPane())        
    

    def CreateNotebookBase(self, panes, paneInfo):
        """
        Creates an auto-notebook base from a pane, and then add that pane as a page.

        :param `panes`: Set of panes to append new notebook base pane to
        :param `paneInfo`: L{AuiPaneInfo} instance to convert to new notebook.
        """

        # Create base notebook pane ...
        nbid = len(self._notebooks)

        baseInfo = AuiPaneInfo()
        baseInfo.SetDockPos(paneInfo).NotebookControl(nbid). \
            CloseButton(False).SetNameFromNotebookId(). \
            NotebookDockable(False).Floatable(paneInfo.IsFloatable())
        baseInfo.best_size = paneInfo.best_size
        panes.append(baseInfo)

        # add original pane as tab ...
        paneInfo.NotebookPage(nbid)

    def RemoveAutoNBCaption(self, pane):
        """
        Removes the caption on newly created automatic notebooks.

        :param `pane`: an instance of L{AuiPaneInfo} (the target notebook).
        """

        if self._agwFlags & AUI_MGR_AUTONB_NO_CAPTION == 0:
            return False

        def RemoveCaption():
            """ Sub-function used to remove the pane caption on automatic notebooks. """
            
            if pane.HasNotebook(): 
                notebook = self._notebooks[pane.notebook_id] 
                self.GetPane(notebook).CaptionVisible(False).PaneBorder(False)                
                self.Update() 

        # it seems the notebook isnt created by this stage, so remove 
        # the caption a moment later 
        wx.CallAfter(RemoveCaption)
        return True
        
        
    def RestoreMinimizedPane(self, paneInfo):
        """
        Restores a previously minimized pane.

        :param `paneInfo`: a L{AuiPaneInfo} instance for the pane to be restored.
        """

        panename = paneInfo.name
        panename = panename[0:-4]
        pane = self.GetPane(panename)

        pane.SetFlag(pane.needsRestore, True)

        if not pane.IsOk():
            panename = paneInfo.name
            pane = self.GetPane(panename)
            paneInfo = self.GetPane(panename + "_min")
            if not paneInfo.IsOk():
                # Already minimized
                return
        
        if pane.IsOk():
            if not pane.IsMinimized():
                return
            

            if pane.HasFlag(pane.wasMaximized):

                self.SavePreviousDockSizes(pane)
                

            self.ShowPane(pane.window, True)
            pane.Show(True)
            self._has_minimized = False
            pane.SetFlag(pane.optionMinimized, False)
            paneInfo.window.Show(False)
            self.DetachPane(paneInfo.window)
            paneInfo.Show(False)
            paneInfo.Hide()

            self.Update()


    def AnimateDocking(self, win_rect, pane_rect):
        """
        Animates the minimization/docking of a pane a la Eclipse, using a `wx.ScreenDC`
        to draw a "moving docking rectangle" on the screen.

        :param `win_rect`: the original pane screen rectangle;
        :param `pane_rect`: the newly created toolbar/pane screen rectangle.

        :note: This functionality is not available on wxMAC as this platform doesn't have
         the ability to use `wx.ScreenDC` to draw on-screen and on Windows > Vista.
        """

        if wx.Platform == "__WXMAC__":
            # No wx.ScreenDC on the Mac...
            return
        if wx.Platform == "__WXMSW__" and wx.GetOsVersion()[1] > 5:
            # No easy way to handle this on Vista...
            return

        xstart, ystart = win_rect.x, win_rect.y
        xend, yend = pane_rect.x, pane_rect.y

        step = self.GetAnimationStep()
        
        wstep = int(abs(win_rect.width - pane_rect.width)/step)
        hstep = int(abs(win_rect.height - pane_rect.height)/step)
        xstep = int(win_rect.x - pane_rect.x)/step
        ystep = int(win_rect.y - pane_rect.y)/step
        
        dc = wx.ScreenDC()
        dc.SetLogicalFunction(wx.INVERT)
        dc.SetBrush(wx.TRANSPARENT_BRUSH)
        dc.SetPen(wx.LIGHT_GREY_PEN)
        
        for i in xrange(int(step)):
            width, height = win_rect.width - i*wstep, win_rect.height - i*hstep
            x, y = xstart - i*xstep, ystart - i*ystep
            new_rect = wx.Rect(x, y, width, height)
            dc.DrawRoundedRectangleRect(new_rect, 3)
            wx.SafeYield()
            wx.MilliSleep(10)
            dc.DrawRoundedRectangleRect(new_rect, 3)
            

    def SmoothDock(self, paneInfo):
        """
        This method implements a smooth docking effect for floating panes, similar to
        what the PyQT library does with its floating windows.

        :param `paneInfo`: an instance of L{AuiPaneInfo}.

        :note: The smooth docking effect can only be used if you set the ``AUI_MGR_SMOOTH_DOCKING``
         style to L{AuiManager}.
        """

        if paneInfo.IsToolbar():
            return

        if not paneInfo.frame or self._hint_rect.IsEmpty():
            return

        hint_rect = self._hint_rect
        win_rect = paneInfo.frame.GetScreenRect()

        xstart, ystart = win_rect.x, win_rect.y
        xend, yend = hint_rect.x, hint_rect.y

        step = self.GetAnimationStep()/3

        wstep = int((win_rect.width - hint_rect.width)/step)
        hstep = int((win_rect.height - hint_rect.height)/step)
        xstep = int((win_rect.x - hint_rect.x))/step
        ystep = int((win_rect.y - hint_rect.y))/step

        for i in xrange(int(step)):
            width, height = win_rect.width - i*wstep, win_rect.height - i*hstep
            x, y = xstart - i*xstep, ystart - i*ystep
            new_rect = wx.Rect(x, y, width, height)
            paneInfo.frame.SetRect(new_rect)
            wx.MilliSleep(10)            
        
            
    def SetSnapLimits(self, x, y):
        """
        Modifies the snap limits used when snapping the `managed_window` to the screen
        (using L{SnapToScreen}) or when snapping the floating panes to one side of the
        `managed_window` (using L{SnapPane}).

        To change the limit after which the `managed_window` or the floating panes are
        automatically stickled to the screen border (or to the `managed_window` side),
        set these two variables. Default values are 15 pixels.
    
        :param `x`: the minimum horizontal distance below which the snap occurs;
        :param `y`: the minimum vertical distance below which the snap occurs.
        """

        self._snap_limits = (x, y)
        self.Snap()


    def Snap(self):
        """
        Snaps the main frame to specified position on the screen.

        :see: L{SnapToScreen}
        """
        
        snap, hAlign, vAlign, monitor = self._is_docked
        if not snap:
            return

        managed_window = self.GetManagedWindow()
        snap_pos = self.GetSnapPosition()
        wnd_pos = managed_window.GetPosition()
        snapX, snapY = self._snap_limits
        
        if abs(snap_pos.x - wnd_pos.x) < snapX and abs(snap_pos.y - wnd_pos.y) < snapY:
            managed_window.SetPosition(snap_pos)
        

    def SnapToScreen(self, snap=True, monitor=0, hAlign=wx.RIGHT, vAlign=wx.TOP):
        """
        Snaps the main frame to specified position on the screen.

        :param `snap`: whether to snap the main frame or not;
        :param `monitor`: the monitor display in which snapping the window;
        :param `hAlign`: the horizontal alignment of the snapping position;
        :param `vAlign`: the vertical alignment of the snapping position.
        """
        
        if not snap:
            self._is_docked = (False, wx.RIGHT, wx.TOP, 0)
            return

        displayCount = wx.Display.GetCount()
        if monitor > displayCount:
            raise Exception("Invalid monitor selected: you only have %d monitors"%displayCount)

        self._is_docked = (True, hAlign, vAlign, monitor)
        self.GetManagedWindow().SetPosition(self.GetSnapPosition())
        

    def GetSnapPosition(self):
        """ Returns the main frame snapping position. """

        snap, hAlign, vAlign, monitor = self._is_docked
        
        display = wx.Display(monitor)
        area = display.GetClientArea()
        size = self.GetManagedWindow().GetSize()
        
        pos = wx.Point()
        if hAlign == wx.LEFT:
            pos.x = area.x
        elif hAlign == wx.CENTER:
            pos.x = area.x + (area.width - size.x)/2
        else:
            pos.x = area.x + area.width - size.x

        if vAlign == wx.TOP:
            pos.y = area.y
        elif vAlign == wx.CENTER:
            pos.y = area.y + (area.height - size.y)/2
        else:
            pos.y = area.y + area.height - size.y

        return pos            


    def GetAnimationStep(self):
        """ Returns the animation step speed (a float) to use in L{AnimateDocking}. """

        return self._animation_step


    def SetAnimationStep(self, step):
        """
        Sets the animation step speed (a float) to use in L{AnimateDocking}.

        :param `step`: a floating point value for the animation speed.
        """

        self._animation_step = float(step)        

        
    def RequestUserAttention(self, pane_window):
        """
        Requests the user attention by intermittently highlighting the pane caption.

        :param `pane_window`: a `wx.Window` derived window, managed by the pane.
        """
                
        # try to find the pane
        paneInfo = self.GetPane(pane_window)
        if not paneInfo.IsOk():
            raise Exception("Pane window not found")

        dc = wx.ClientDC(self._frame)

        # if the frame is about to be deleted, don't bother
        if not self._frame or self._frame.IsBeingDeleted():
            return
        
        if not self._frame.GetSizer():
            return

        for part in self._uiparts:
            if part.pane == paneInfo:
                self._art.RequestUserAttention(dc, self._frame, part.pane.caption, part.rect, part.pane)
                self._frame.RefreshRect(part.rect, True)
                break


    def StartPreviewTimer(self, toolbar):
        """
        Starts a timer for sliding in and out a minimized pane.

        :param `toolbar`: the L{AuiToolBar} containing the minimized pane tool.
        """

        toolbar_pane = self.GetPane(toolbar)
        toolbar_name = toolbar_pane.name
        
        pane_name = toolbar_name[0:-4]
        
        self._sliding_pane = self.GetPane(pane_name)
        self._sliding_rect = toolbar.GetScreenRect()
        self._sliding_direction = toolbar_pane.dock_direction
        self._sliding_frame = None
        
        self._preview_timer.Start(1000, wx.TIMER_ONE_SHOT)


    def StopPreviewTimer(self):
        """ Stops a timer for sliding in and out a minimized pane. """

        if self._preview_timer.IsRunning():
            self._preview_timer.Stop()

        self.SlideOut()
        self._sliding_pane = None


    def SlideIn(self, event):
        """
        Handles the ``wx.EVT_TIMER`` event for L{AuiManager}.

        :param `event`: a `wx.TimerEvent` to be processed.

        :note: This is used solely for sliding in and out minimized panes.
        """

        window = self._sliding_pane.window
        self._sliding_frame = wx.MiniFrame(None, -1, title=_("Pane Preview"),
                                           style=wx.FRAME_TOOL_WINDOW | wx.STAY_ON_TOP |
                                           wx.FRAME_NO_TASKBAR | wx.CAPTION)
        window.Reparent(self._sliding_frame)
        self._sliding_frame.SetSize((0, 0))
        window.Show()
        self._sliding_frame.Show()
        
        size = window.GetBestSize()

        startX, startY, stopX, stopY = GetSlidingPoints(self._sliding_rect, size, self._sliding_direction)
        
        step = stopX/10
        window_size = 0
        
        for i in xrange(0, stopX, step):
            window_size = i
            self._sliding_frame.SetDimensions(startX, startY, window_size, stopY)
            self._sliding_frame.Refresh()
            self._sliding_frame.Update()
            wx.MilliSleep(10)

        self._sliding_frame.SetDimensions(startX, startY, stopX, stopY)
        self._sliding_frame.Refresh()
        self._sliding_frame.Update()
        

    def SlideOut(self):
        """
        Slides out a preview of a minimized pane.

        :note: This is used solely for sliding in and out minimized panes.
        """

        if not self._sliding_frame:
            return

        window = self._sliding_frame.GetChildren()[0]
        size = window.GetBestSize()
        
        startX, startY, stopX, stopY = GetSlidingPoints(self._sliding_rect, size, self._sliding_direction)

        step = stopX/10
        window_size = 0
        
        for i in xrange(stopX, 0, -step):
            window_size = i
            self._sliding_frame.SetDimensions(startX, startY, window_size, stopY)
            self._sliding_frame.Refresh()
            self._sliding_frame.Update()
            self._frame.RefreshRect(wx.Rect(startX+window_size, startY, step, stopY))
            self._frame.Update()
            wx.MilliSleep(10)

        self._sliding_frame.SetDimensions(startX, startY, 0, stopY)

        window.Hide()
        window.Reparent(self._frame)

        self._sliding_frame.Hide()
        self._sliding_frame.Destroy()
        self._sliding_frame = None
        self._sliding_pane = None
        

class AuiManager_DCP(AuiManager):
    """
    A class similar to L{AuiManager} but with a Dummy Center Pane (**DCP**).
    The code for this class is still flickery due to the call to `wx.CallAfter`
    and the double-update call.
    """
    
    def __init__(self, *args, **keys):

        aui.AuiManager.__init__(self, *args, **keys)
        self.hasDummyPane = False
        

    def _createDummyPane(self):
        """ Creates a Dummy Center Pane (**DCP**). """

        if self.hasDummyPane:
            return

        self.hasDummyPane = True
        dummy = wx.Panel(self.GetManagedWindow())
        info = aui.AuiPaneInfo().CenterPane().NotebookDockable(True).Name('dummyCenterPane').DestroyOnClose(True)
        self.AddPane(dummy, info)


    def _destroyDummyPane(self):
        """ Destroys the Dummy Center Pane (**DCP**). """

        if not self.hasDummyPane:
            return
        
        self.hasDummyPane = False
        self.ClosePane(self.GetPane('dummyCenterPane'))

        
    def Update(self):
        """
        This method is called after any number of changes are made to any of the
        managed panes. L{Update} must be invoked after L{AuiManager.AddPane} or L{AuiManager.InsertPane} are
        called in order to "realize" or "commit" the changes.

        In addition, any number of changes may be made to L{AuiPaneInfo} structures
        (retrieved with L{AuiManager.GetPane}), but to realize the changes, L{Update}
        must be called. This construction allows pane flicker to be avoided by updating
        the whole layout at one time.
        """
        
        aui.AuiManager.Update(self)

        # check if there's already a center pane (except our dummy pane)
        dummyCenterPane = self.GetPane('dummyCenterPane')
        haveCenterPane = any((pane != dummyCenterPane) and (pane.dock_direction == aui.AUI_DOCK_CENTER) and
                             not pane.IsFloating() and pane.IsShown() for pane in self.GetAllPanes())
        if haveCenterPane:
            if self.hasDummyPane:
                # there's our dummy pane and also another center pane, therefor let's remove our dummy
                def do():
                    self._destroyDummyPane()
                    self.Update()
                wx.CallAfter(do)
        else:
            # if we get here, there's no center pane, create our dummy
            if not self.hasDummyPane:
                self._createDummyPane()

                

########NEW FILE########
__FILENAME__ = tabart
"""
Tab art provider code - a tab provider provides all drawing functionality to
the L{AuiNotebook}. This allows the L{AuiNotebook} to have a plugable look-and-feel.

By default, a L{AuiNotebook} uses an instance of this class called L{AuiDefaultTabArt}
which provides bitmap art and a colour scheme that is adapted to the major platforms'
look. You can either derive from that class to alter its behaviour or write a
completely new tab art class. Call L{AuiNotebook.SetArtProvider} to make use this
new tab art.
"""

__author__ = "Andrea Gavana <andrea.gavana@gmail.com>"
__date__ = "31 March 2009"


import wx

if wx.Platform == '__WXMAC__':
    import Carbon.Appearance

from aui_utilities import BitmapFromBits, StepColour, IndentPressedBitmap, ChopText
from aui_utilities import GetBaseColour, DrawMACCloseButton, LightColour, TakeScreenShot
from aui_utilities import CopyAttributes

from aui_constants import *


# -- GUI helper classes and functions --
class AuiCommandCapture(wx.PyEvtHandler):
    """ A class to handle the dropdown window menu. """

    def __init__(self):
        """ Default class constructor. """

        wx.PyEvtHandler.__init__(self)        
        self._last_id = 0


    def GetCommandId(self):
        """ Returns the event command identifier. """

        return self._last_id 


    def ProcessEvent(self, event):
        """
        Processes an event, searching event tables and calling zero or more suitable
        event handler function(s).

        :param `event`: the event to process.

        :note: Normally, your application would not call this function: it is called
         in the wxPython implementation to dispatch incoming user interface events
         to the framework (and application).
         However, you might need to call it if implementing new functionality (such as
         a new control) where you define new event types, as opposed to allowing the
         user to override functions.

         An instance where you might actually override the L{ProcessEvent} function is where
         you want to direct event processing to event handlers not normally noticed by
         wxPython. For example, in the document/view architecture, documents and views
         are potential event handlers. When an event reaches a frame, L{ProcessEvent} will
         need to be called on the associated document and view in case event handler
         functions are associated with these objects. 

         The normal order of event table searching is as follows:

         1. If the object is disabled (via a call to `SetEvtHandlerEnabled`) the function
            skips to step (6).
         2. If the object is a `wx.Window`, L{ProcessEvent} is recursively called on the window's 
            `wx.Validator`. If this returns ``True``, the function exits.
         3. wxWidgets `SearchEventTable` is called for this event handler. If this fails, the
            base class table is tried, and so on until no more tables exist or an appropriate
            function was found, in which case the function exits.
         4. The search is applied down the entire chain of event handlers (usually the chain
            has a length of one). If this succeeds, the function exits.
         5. If the object is a `wx.Window` and the event is a `wx.CommandEvent`, L{ProcessEvent} is
            recursively applied to the parent window's event handler. If this returns ``True``,
            the function exits.
         6. Finally, L{ProcessEvent} is called on the `wx.App` object.
        """
        
        if event.GetEventType() == wx.wxEVT_COMMAND_MENU_SELECTED:
            self._last_id = event.GetId()
            return True
        
        if self.GetNextHandler():
            return self.GetNextHandler().ProcessEvent(event)

        return False
    

class AuiDefaultTabArt(object):
    """
    Tab art provider code - a tab provider provides all drawing functionality to
    the L{AuiNotebook}. This allows the L{AuiNotebook} to have a plugable look-and-feel.

    By default, a L{AuiNotebook} uses an instance of this class called L{AuiDefaultTabArt}
    which provides bitmap art and a colour scheme that is adapted to the major platforms'
    look. You can either derive from that class to alter its behaviour or write a
    completely new tab art class. Call L{AuiNotebook.SetArtProvider} to make use this
    new tab art.
    """
    
    def __init__(self):
        """ Default class constructor. """

        self._normal_font = wx.SystemSettings_GetFont(wx.SYS_DEFAULT_GUI_FONT)
        self._selected_font = wx.SystemSettings_GetFont(wx.SYS_DEFAULT_GUI_FONT)
        self._selected_font.SetWeight(wx.BOLD)
        self._measuring_font = self._selected_font

        self._fixed_tab_width = 100
        self._tab_ctrl_height = 0
        self._buttonRect = wx.Rect()

        self.SetDefaultColours()

        if wx.Platform == "__WXMAC__":
            bmp_colour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_3DDKSHADOW)
            self._active_close_bmp = DrawMACCloseButton(bmp_colour)
            self._disabled_close_bmp = DrawMACCloseButton(wx.Colour(128, 128, 128))
        else:
            self._active_close_bmp = BitmapFromBits(nb_close_bits, 16, 16, wx.BLACK)
            self._disabled_close_bmp = BitmapFromBits(nb_close_bits, 16, 16, wx.Colour(128, 128, 128))

        self._hover_close_bmp = self._active_close_bmp
        self._pressed_close_bmp = self._active_close_bmp

        self._active_left_bmp = BitmapFromBits(nb_left_bits, 16, 16, wx.BLACK)
        self._disabled_left_bmp = BitmapFromBits(nb_left_bits, 16, 16, wx.Colour(128, 128, 128))

        self._active_right_bmp = BitmapFromBits(nb_right_bits, 16, 16, wx.BLACK)
        self._disabled_right_bmp = BitmapFromBits(nb_right_bits, 16, 16, wx.Colour(128, 128, 128))

        self._active_windowlist_bmp = BitmapFromBits(nb_list_bits, 16, 16, wx.BLACK)
        self._disabled_windowlist_bmp = BitmapFromBits(nb_list_bits, 16, 16, wx.Colour(128, 128, 128))

        if wx.Platform == "__WXMAC__":
            # Get proper highlight colour for focus rectangle from the
            # current Mac theme.  kThemeBrushFocusHighlight is
            # available on Mac OS 8.5 and higher
            if hasattr(wx, 'MacThemeColour'):
                c = wx.MacThemeColour(Carbon.Appearance.kThemeBrushFocusHighlight)
            else:
                brush = wx.Brush(wx.BLACK)
                brush.MacSetTheme(Carbon.Appearance.kThemeBrushFocusHighlight)
                c = brush.GetColour()
            self._focusPen = wx.Pen(c, 2, wx.SOLID)
        else:
            self._focusPen = wx.Pen(wx.BLACK, 1, wx.USER_DASH)
            self._focusPen.SetDashes([1, 1])
            self._focusPen.SetCap(wx.CAP_BUTT)
            
            
    def SetBaseColour(self, base_colour):
        """ Sets a new base colour. """
        self._base_colour = base_colour
        self._base_colour_pen = wx.Pen(self._base_colour)
        self._base_colour_brush = wx.Brush(self._base_colour)


    def SetDefaultColours(self, base_colour = None):
        """ Sets the default colours, which are calculated from the given base colour. """
        if base_colour is None:
            base_colour = GetBaseColour()
        self.SetBaseColour( base_colour )
        self._border_colour = StepColour(base_colour, 75)
        self._border_pen = wx.Pen(self._border_colour)

        self._background_top_colour = StepColour(self._base_colour, 90)
        self._background_bottom_colour = StepColour(self._base_colour, 170)
        
        self._tab_top_colour = self._base_colour
        self._tab_bottom_colour = wx.WHITE
        self._tab_gradient_highlight_colour = wx.WHITE

        self._tab_inactive_top_colour = self._base_colour
        self._tab_inactive_bottom_colour = StepColour(self._tab_inactive_top_colour, 160)
        
        self._tab_text_colour = lambda page: page.text_colour
        self._tab_disabled_text_colour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_GRAYTEXT)


    def Clone(self):
        """ Clones the art object. """

        art = type(self)()
        art.SetNormalFont(self.GetNormalFont())
        art.SetSelectedFont(self.GetSelectedFont())
        art.SetMeasuringFont(self.GetMeasuringFont())

        art = CopyAttributes(art, self)
        return art


    def SetAGWFlags(self, agwFlags):
        """
        Sets the tab art flags.

        :param `agwFlags`: a combination of the following values:

         ==================================== ==================================
         Flag name                            Description
         ==================================== ==================================
         ``AUI_NB_TOP``                       With this style, tabs are drawn along the top of the notebook
         ``AUI_NB_LEFT``                      With this style, tabs are drawn along the left of the notebook. Not implemented yet.
         ``AUI_NB_RIGHT``                     With this style, tabs are drawn along the right of the notebook. Not implemented yet.
         ``AUI_NB_BOTTOM``                    With this style, tabs are drawn along the bottom of the notebook
         ``AUI_NB_TAB_SPLIT``                 Allows the tab control to be split by dragging a tab
         ``AUI_NB_TAB_MOVE``                  Allows a tab to be moved horizontally by dragging
         ``AUI_NB_TAB_EXTERNAL_MOVE``         Allows a tab to be moved to another tab control
         ``AUI_NB_TAB_FIXED_WIDTH``           With this style, all tabs have the same width
         ``AUI_NB_SCROLL_BUTTONS``            With this style, left and right scroll buttons are displayed
         ``AUI_NB_WINDOWLIST_BUTTON``         With this style, a drop-down list of windows is available
         ``AUI_NB_CLOSE_BUTTON``              With this style, a close button is available on the tab bar
         ``AUI_NB_CLOSE_ON_ACTIVE_TAB``       With this style, a close button is available on the active tab
         ``AUI_NB_CLOSE_ON_ALL_TABS``         With this style, a close button is available on all tabs
         ``AUI_NB_MIDDLE_CLICK_CLOSE``        Allows to close L{AuiNotebook} tabs by mouse middle button click
         ``AUI_NB_SUB_NOTEBOOK``              This style is used by L{AuiManager} to create automatic AuiNotebooks
         ``AUI_NB_HIDE_ON_SINGLE_TAB``        Hides the tab window if only one tab is present
         ``AUI_NB_SMART_TABS``                Use Smart Tabbing, like ``Alt`` + ``Tab`` on Windows
         ``AUI_NB_USE_IMAGES_DROPDOWN``       Uses images on dropdown window list menu instead of check items
         ``AUI_NB_CLOSE_ON_TAB_LEFT``         Draws the tab close button on the left instead of on the right (a la Camino browser)
         ``AUI_NB_TAB_FLOAT``                 Allows the floating of single tabs. Known limitation: when the notebook is more or less full screen, tabs cannot be dragged far enough outside of the notebook to become floating pages
         ``AUI_NB_DRAW_DND_TAB``              Draws an image representation of a tab while dragging (on by default)
         ==================================== ==================================
        
        """

        self._agwFlags = agwFlags


    def GetAGWFlags(self):
        """
        Returns the tab art flags.

        :see: L{SetAGWFlags} for a list of possible return values.
        """

        return self._agwFlags
    
            
    def SetSizingInfo(self, tab_ctrl_size, tab_count, minMaxTabWidth):
        """
        Sets the tab sizing information.
        
        :param `tab_ctrl_size`: the size of the tab control area;
        :param `tab_count`: the number of tabs;
        :param `minMaxTabWidth`: a tuple containing the minimum and maximum tab widths
         to be used when the ``AUI_NB_TAB_FIXED_WIDTH`` style is active.
        """
        
        self._fixed_tab_width = 100
        minTabWidth, maxTabWidth = minMaxTabWidth

        tot_width = tab_ctrl_size.x - self.GetIndentSize() - 4
        agwFlags = self.GetAGWFlags()
        
        if agwFlags & AUI_NB_CLOSE_BUTTON:
            tot_width -= self._active_close_bmp.GetWidth()
        if agwFlags & AUI_NB_WINDOWLIST_BUTTON:
            tot_width -= self._active_windowlist_bmp.GetWidth()

        if tab_count > 0:
            self._fixed_tab_width = tot_width/tab_count

        if self._fixed_tab_width < 100:
            self._fixed_tab_width = 100

        if self._fixed_tab_width > tot_width/2:
            self._fixed_tab_width = tot_width/2

        if self._fixed_tab_width > 220:
            self._fixed_tab_width = 220

        if minTabWidth > -1:
            self._fixed_tab_width = max(self._fixed_tab_width, minTabWidth)
        if maxTabWidth > -1:
            self._fixed_tab_width = min(self._fixed_tab_width, maxTabWidth)

        self._tab_ctrl_height = tab_ctrl_size.y
    

    def DrawBackground(self, dc, wnd, rect):
        """
        Draws the tab area background.

        :param `dc`: a `wx.DC` device context;
        :param `wnd`: a `wx.Window` instance object;
        :param `rect`: the tab control rectangle.
        """

        self._buttonRect = wx.Rect()

        # draw background
        agwFlags = self.GetAGWFlags()
        if agwFlags & AUI_NB_BOTTOM:
            r = wx.Rect(rect.x, rect.y, rect.width+2, rect.height)

        # TODO: else if (agwFlags & AUI_NB_LEFT) 
        # TODO: else if (agwFlags & AUI_NB_RIGHT) 
        else: #for AUI_NB_TOP
            r = wx.Rect(rect.x, rect.y, rect.width+2, rect.height-3)

        dc.GradientFillLinear(r, self._background_top_colour, self._background_bottom_colour, wx.SOUTH)

        # draw base lines

        dc.SetPen(self._border_pen)
        y = rect.GetHeight()
        w = rect.GetWidth()

        if agwFlags & AUI_NB_BOTTOM:
            dc.SetBrush(wx.Brush(self._background_bottom_colour))
            dc.DrawRectangle(-1, 0, w+2, 4)

        # TODO: else if (agwFlags & AUI_NB_LEFT) 
        # TODO: else if (agwFlags & AUI_NB_RIGHT)
        
        else: # for AUI_NB_TOP
            dc.SetBrush(self._base_colour_brush)
            dc.DrawRectangle(-1, y-4, w+2, 4)


    def DrawTab(self, dc, wnd, page, in_rect, close_button_state, paint_control=False):
        """
        Draws a single tab.

        :param `dc`: a `wx.DC` device context;
        :param `wnd`: a `wx.Window` instance object;
        :param `page`: the tab control page associated with the tab;
        :param `in_rect`: rectangle the tab should be confined to;
        :param `close_button_state`: the state of the close button on the tab;
        :param `paint_control`: whether to draw the control inside a tab (if any) on a `wx.MemoryDC`.
        """

        # if the caption is empty, measure some temporary text
        caption = page.caption
        if not caption:
            caption = "Xj"

        dc.SetFont(self._selected_font)
        selected_textx, selected_texty, dummy = dc.GetMultiLineTextExtent(caption)

        dc.SetFont(self._normal_font)
        normal_textx, normal_texty, dummy = dc.GetMultiLineTextExtent(caption)

        control = page.control

        # figure out the size of the tab
        tab_size, x_extent = self.GetTabSize(dc, wnd, page.caption, page.bitmap,
                                             page.active, close_button_state, control)

        tab_height = self._tab_ctrl_height - 3
        tab_width = tab_size[0]
        tab_x = in_rect.x
        tab_y = in_rect.y + in_rect.height - tab_height

        caption = page.caption

        # select pen, brush and font for the tab to be drawn

        if page.active:
        
            dc.SetFont(self._selected_font)
            textx, texty = selected_textx, selected_texty
        
        else:
        
            dc.SetFont(self._normal_font)
            textx, texty = normal_textx, normal_texty

        if not page.enabled:
            dc.SetTextForeground(self._tab_disabled_text_colour)
            pagebitmap = page.dis_bitmap
        else:
            dc.SetTextForeground(self._tab_text_colour(page))
            pagebitmap = page.bitmap
            
        # create points that will make the tab outline

        clip_width = tab_width
        if tab_x + clip_width > in_rect.x + in_rect.width:
            clip_width = in_rect.x + in_rect.width - tab_x

        # since the above code above doesn't play well with WXDFB or WXCOCOA,
        # we'll just use a rectangle for the clipping region for now --
        dc.SetClippingRegion(tab_x, tab_y, clip_width+1, tab_height-3)

        border_points = [wx.Point() for i in xrange(6)]
        agwFlags = self.GetAGWFlags()
        
        if agwFlags & AUI_NB_BOTTOM:
        
            border_points[0] = wx.Point(tab_x,             tab_y)
            border_points[1] = wx.Point(tab_x,             tab_y+tab_height-6)
            border_points[2] = wx.Point(tab_x+2,           tab_y+tab_height-4)
            border_points[3] = wx.Point(tab_x+tab_width-2, tab_y+tab_height-4)
            border_points[4] = wx.Point(tab_x+tab_width,   tab_y+tab_height-6)
            border_points[5] = wx.Point(tab_x+tab_width,   tab_y)
        
        else: #if (agwFlags & AUI_NB_TOP) 
        
            border_points[0] = wx.Point(tab_x,             tab_y+tab_height-4)
            border_points[1] = wx.Point(tab_x,             tab_y+2)
            border_points[2] = wx.Point(tab_x+2,           tab_y)
            border_points[3] = wx.Point(tab_x+tab_width-2, tab_y)
            border_points[4] = wx.Point(tab_x+tab_width,   tab_y+2)
            border_points[5] = wx.Point(tab_x+tab_width,   tab_y+tab_height-4)
        
        # TODO: else if (agwFlags & AUI_NB_LEFT) 
        # TODO: else if (agwFlags & AUI_NB_RIGHT) 

        drawn_tab_yoff = border_points[1].y
        drawn_tab_height = border_points[0].y - border_points[1].y

        if page.active:
        
            # draw active tab

            # draw base background colour
            r = wx.Rect(tab_x, tab_y, tab_width, tab_height)
            dc.SetPen(self._base_colour_pen)
            dc.SetBrush(self._base_colour_brush)
            dc.DrawRectangle(r.x+1, r.y+1, r.width-1, r.height-4)

            # this white helps fill out the gradient at the top of the tab
            dc.SetPen( wx.Pen(self._tab_gradient_highlight_colour) )
            dc.SetBrush( wx.Brush(self._tab_gradient_highlight_colour) )
            dc.DrawRectangle(r.x+2, r.y+1, r.width-3, r.height-4)

            # these two points help the rounded corners appear more antialiased
            dc.SetPen(self._base_colour_pen)
            dc.DrawPoint(r.x+2, r.y+1)
            dc.DrawPoint(r.x+r.width-2, r.y+1)

            # set rectangle down a bit for gradient drawing
            r.SetHeight(r.GetHeight()/2)
            r.x += 2
            r.width -= 2
            r.y += r.height
            r.y -= 2

            # draw gradient background
            top_colour = self._tab_bottom_colour
            bottom_colour = self._tab_top_colour
            dc.GradientFillLinear(r, bottom_colour, top_colour, wx.NORTH)
        
        else:
        
            # draw inactive tab

            r = wx.Rect(tab_x, tab_y+1, tab_width, tab_height-3)

            # start the gradent up a bit and leave the inside border inset
            # by a pixel for a 3D look.  Only the top half of the inactive
            # tab will have a slight gradient
            r.x += 3
            r.y += 1
            r.width -= 4
            r.height /= 2
            r.height -= 1

            # -- draw top gradient fill for glossy look
            top_colour = self._tab_inactive_top_colour
            bottom_colour = self._tab_inactive_bottom_colour
            dc.GradientFillLinear(r, bottom_colour, top_colour, wx.NORTH)

            r.y += r.height
            r.y -= 1

            # -- draw bottom fill for glossy look
            top_colour = self._tab_inactive_bottom_colour
            bottom_colour = self._tab_inactive_bottom_colour
            dc.GradientFillLinear(r, top_colour, bottom_colour, wx.SOUTH)
        
        # draw tab outline
        dc.SetPen(self._border_pen)
        dc.SetBrush(wx.TRANSPARENT_BRUSH)
        dc.DrawPolygon(border_points)

        # there are two horizontal grey lines at the bottom of the tab control,
        # this gets rid of the top one of those lines in the tab control
        if page.active:
        
            if agwFlags & AUI_NB_BOTTOM:
                dc.SetPen(wx.Pen(self._background_bottom_colour))
                
            # TODO: else if (agwFlags & AUI_NB_LEFT) 
            # TODO: else if (agwFlags & AUI_NB_RIGHT) 
            else: # for AUI_NB_TOP
                dc.SetPen(self._base_colour_pen)
                
            dc.DrawLine(border_points[0].x+1,
                        border_points[0].y,
                        border_points[5].x,
                        border_points[5].y)
        
        text_offset = tab_x + 8
        close_button_width = 0

        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
            close_button_width = self._active_close_bmp.GetWidth()

            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
                text_offset += close_button_width - 5
                
        bitmap_offset = 0
        
        if pagebitmap.IsOk():
        
            bitmap_offset = tab_x + 8
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT and close_button_width:
                bitmap_offset += close_button_width - 5

            # draw bitmap
            dc.DrawBitmap(pagebitmap,
                          bitmap_offset,
                          drawn_tab_yoff + (drawn_tab_height/2) - (pagebitmap.GetHeight()/2),
                          True)

            text_offset = bitmap_offset + pagebitmap.GetWidth()
            text_offset += 3 # bitmap padding

        else:

            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT == 0 or not close_button_width:
                text_offset = tab_x + 8
        
        draw_text = ChopText(dc, caption, tab_width - (text_offset-tab_x) - close_button_width)

        ypos = drawn_tab_yoff + (drawn_tab_height)/2 - (texty/2) - 1

        offset_focus = text_offset     
        if control is not None:
            if control.GetPosition() != wx.Point(text_offset+1, ypos):
                control.SetPosition(wx.Point(text_offset+1, ypos))

            if not control.IsShown():
                control.Show()

            if paint_control:
                bmp = TakeScreenShot(control.GetScreenRect())
                dc.DrawBitmap(bmp, text_offset+1, ypos, True)
                
            controlW, controlH = control.GetSize()
            text_offset += controlW + 4
            textx += controlW + 4
            
        # draw tab text
        rectx, recty, dummy = dc.GetMultiLineTextExtent(draw_text)
        dc.DrawLabel(draw_text, wx.Rect(text_offset, ypos, rectx, recty))

        # draw focus rectangle
        self.DrawFocusRectangle(dc, page, wnd, draw_text, offset_focus, bitmap_offset, drawn_tab_yoff, drawn_tab_height, textx, texty)
        
        out_button_rect = wx.Rect()
        
        # draw close button if necessary
        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
        
            bmp = self._disabled_close_bmp

            if close_button_state == AUI_BUTTON_STATE_HOVER:
                bmp = self._hover_close_bmp
            elif close_button_state == AUI_BUTTON_STATE_PRESSED:
                bmp = self._pressed_close_bmp

            shift = (agwFlags & AUI_NB_BOTTOM and [1] or [0])[0]

            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
                rect = wx.Rect(tab_x + 4, tab_y + (tab_height - bmp.GetHeight())/2 - shift,
                               close_button_width, tab_height)
            else:
                rect = wx.Rect(tab_x + tab_width - close_button_width - 1,
                               tab_y + (tab_height - bmp.GetHeight())/2 - shift,
                               close_button_width, tab_height)

            rect = IndentPressedBitmap(rect, close_button_state)
            dc.DrawBitmap(bmp, rect.x, rect.y, True)

            out_button_rect = rect
        
        out_tab_rect = wx.Rect(tab_x, tab_y, tab_width, tab_height)

        dc.DestroyClippingRegion()

        return out_tab_rect, out_button_rect, x_extent
    

    def SetCustomButton(self, bitmap_id, button_state, bmp):
        """
        Sets a custom bitmap for the close, left, right and window list
        buttons.
        
        :param `bitmap_id`: the button identifier;
        :param `button_state`: the button state;
        :param `bmp`: the custom bitmap to use for the button.
        """

        if bitmap_id == AUI_BUTTON_CLOSE:
            if button_state == AUI_BUTTON_STATE_NORMAL:
                self._active_close_bmp = bmp
                self._hover_close_bmp = self._active_close_bmp
                self._pressed_close_bmp = self._active_close_bmp
                self._disabled_close_bmp = self._active_close_bmp
                    
            elif button_state == AUI_BUTTON_STATE_HOVER:
                self._hover_close_bmp = bmp
            elif button_state == AUI_BUTTON_STATE_PRESSED:
                self._pressed_close_bmp = bmp
            else:
                self._disabled_close_bmp = bmp

        elif bitmap_id == AUI_BUTTON_LEFT:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                self._disabled_left_bmp = bmp
            else:
                self._active_left_bmp = bmp

        elif bitmap_id == AUI_BUTTON_RIGHT:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                self._disabled_right_bmp = bmp
            else:
                self._active_right_bmp = bmp

        elif bitmap_id == AUI_BUTTON_WINDOWLIST:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                self._disabled_windowlist_bmp = bmp
            else:
                self._active_windowlist_bmp = bmp
        

    def GetIndentSize(self):
        """ Returns the tabs indent size. """

        return 5


    def GetTabSize(self, dc, wnd, caption, bitmap, active, close_button_state, control=None):
        """
        Returns the tab size for the given caption, bitmap and button state.

        :param `dc`: a `wx.DC` device context;
        :param `wnd`: a `wx.Window` instance object;
        :param `caption`: the tab text caption;
        :param `bitmap`: the bitmap displayed on the tab;
        :param `active`: whether the tab is selected or not;
        :param `close_button_state`: the state of the close button on the tab;
        :param `control`: a `wx.Window` instance inside a tab (or ``None``).
        """

        dc.SetFont(self._measuring_font)
        measured_textx, measured_texty, dummy = dc.GetMultiLineTextExtent(caption)

        # add padding around the text
        tab_width = measured_textx
        tab_height = measured_texty

        # if the close button is showing, add space for it
        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
            tab_width += self._active_close_bmp.GetWidth() + 3

        # if there's a bitmap, add space for it
        if bitmap.IsOk():
            tab_width += bitmap.GetWidth()
            tab_width += 3 # right side bitmap padding
            tab_height = max(tab_height, bitmap.GetHeight())
        
        # add padding
        tab_width += 16
        tab_height += 10

        agwFlags = self.GetAGWFlags()
        if agwFlags & AUI_NB_TAB_FIXED_WIDTH:
            tab_width = self._fixed_tab_width

        if control is not None:
            tab_width += control.GetSize().GetWidth() + 4
            
        x_extent = tab_width

        return (tab_width, tab_height), x_extent


    def DrawButton(self, dc, wnd, in_rect, button, orientation):
        """
        Draws a button on the tab or on the tab area, depending on the button identifier. 

        :param `dc`: a `wx.DC` device context;
        :param `wnd`: a `wx.Window` instance object;
        :param `in_rect`: rectangle the tab should be confined to;
        :param `button`: an instance of the button class;
        :param `orientation`: the tab orientation.
        """

        bitmap_id, button_state = button.id, button.cur_state
        
        if bitmap_id == AUI_BUTTON_CLOSE:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                bmp = self._disabled_close_bmp
            elif button_state & AUI_BUTTON_STATE_HOVER:
                bmp = self._hover_close_bmp
            elif button_state & AUI_BUTTON_STATE_PRESSED:
                bmp = self._pressed_close_bmp
            else:
                bmp = self._active_close_bmp

        elif bitmap_id == AUI_BUTTON_LEFT:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                bmp = self._disabled_left_bmp
            else:
                bmp = self._active_left_bmp

        elif bitmap_id == AUI_BUTTON_RIGHT:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                bmp = self._disabled_right_bmp
            else:
                bmp = self._active_right_bmp

        elif bitmap_id == AUI_BUTTON_WINDOWLIST:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                bmp = self._disabled_windowlist_bmp
            else:
                bmp = self._active_windowlist_bmp

        else:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                bmp = button.dis_bitmap
            else:
                bmp = button.bitmap
                
        if not bmp.IsOk():
            return

        rect = wx.Rect(*in_rect)

        if orientation == wx.LEFT:
        
            rect.SetX(in_rect.x)
            rect.SetY(((in_rect.y + in_rect.height)/2) - (bmp.GetHeight()/2))
            rect.SetWidth(bmp.GetWidth())
            rect.SetHeight(bmp.GetHeight())
        
        else:
        
            rect = wx.Rect(in_rect.x + in_rect.width - bmp.GetWidth(),
                           ((in_rect.y + in_rect.height)/2) - (bmp.GetHeight()/2),
                           bmp.GetWidth(), bmp.GetHeight())
        
        rect = IndentPressedBitmap(rect, button_state)
        dc.DrawBitmap(bmp, rect.x, rect.y, True)

        out_rect = rect

        if bitmap_id == AUI_BUTTON_RIGHT:
            self._buttonRect = wx.Rect(rect.x, rect.y, 30, rect.height)
        
        return out_rect


    def DrawFocusRectangle(self, dc, page, wnd, draw_text, text_offset, bitmap_offset, drawn_tab_yoff, drawn_tab_height, textx, texty):
        """
        Draws the focus rectangle on a tab.

        :param `dc`: a `wx.DC` device context;
        :param `page`: the page associated with the tab;
        :param `wnd`: a `wx.Window` instance object;
        :param `draw_text`: the text that has been drawn on the tab;
        :param `text_offset`: the text offset on the tab;
        :param `bitmap_offset`: the bitmap offset on the tab;
        :param `drawn_tab_yoff`: the y offset of the tab text;
        :param `drawn_tab_height`: the height of the tab;
        :param `textx`: the x text extent;
        :param `texty`: the y text extent.
        """

        if page.active and wx.Window.FindFocus() == wnd:
        
            focusRectText = wx.Rect(text_offset, (drawn_tab_yoff + (drawn_tab_height)/2 - (texty/2)),
                                    textx, texty)

            if page.bitmap.IsOk():
                focusRectBitmap = wx.Rect(bitmap_offset, drawn_tab_yoff + (drawn_tab_height/2) - (page.bitmap.GetHeight()/2),
                                          page.bitmap.GetWidth(), page.bitmap.GetHeight())

            if page.bitmap.IsOk() and draw_text == "":
                focusRect = wx.Rect(*focusRectBitmap)
            elif not page.bitmap.IsOk() and draw_text != "":
                focusRect = wx.Rect(*focusRectText)
            elif page.bitmap.IsOk() and draw_text != "":
                focusRect = focusRectText.Union(focusRectBitmap)

            focusRect.Inflate(2, 2)

            dc.SetBrush(wx.TRANSPARENT_BRUSH)
            dc.SetPen(self._focusPen)
            dc.DrawRoundedRectangleRect(focusRect, 2)
        

    def GetBestTabCtrlSize(self, wnd, pages, required_bmp_size):
        """
        Returns the best tab control size.

        :param `wnd`: a `wx.Window` instance object;
        :param `pages`: the pages associated with the tabs;
        :param `required_bmp_size`: the size of the bitmap on the tabs.
        """

        dc = wx.ClientDC(wnd)
        dc.SetFont(self._measuring_font)

        # sometimes a standard bitmap size needs to be enforced, especially
        # if some tabs have bitmaps and others don't.  This is important because
        # it prevents the tab control from resizing when tabs are added.

        measure_bmp = wx.NullBitmap
        
        if required_bmp_size.IsFullySpecified():
            measure_bmp = wx.EmptyBitmap(required_bmp_size.x,
                                         required_bmp_size.y)
        
        max_y = 0
        
        for page in pages:
        
            if measure_bmp.IsOk():
                bmp = measure_bmp
            else:
                bmp = page.bitmap

            # we don't use the caption text because we don't
            # want tab heights to be different in the case
            # of a very short piece of text on one tab and a very
            # tall piece of text on another tab
            s, x_ext = self.GetTabSize(dc, wnd, page.caption, bmp, True, AUI_BUTTON_STATE_HIDDEN, None)
            max_y = max(max_y, s[1])

            if page.control:
                controlW, controlH = page.control.GetSize()
                max_y = max(max_y, controlH+4)

        return max_y + 2


    def SetNormalFont(self, font):
        """
        Sets the normal font for drawing tab labels.

        :param `font`: a `wx.Font` object.
        """

        self._normal_font = font


    def SetSelectedFont(self, font):
        """
        Sets the selected tab font for drawing tab labels.

        :param `font`: a `wx.Font` object.
        """

        self._selected_font = font


    def SetMeasuringFont(self, font):
        """
        Sets the font for calculating text measurements.

        :param `font`: a `wx.Font` object.
        """

        self._measuring_font = font


    def GetNormalFont(self):
        """ Returns the normal font for drawing tab labels. """

        return self._normal_font


    def GetSelectedFont(self):
        """ Returns the selected tab font for drawing tab labels. """

        return self._selected_font


    def GetMeasuringFont(self):
        """ Returns the font for calculating text measurements. """

        return self._measuring_font
    

    def ShowDropDown(self, wnd, pages, active_idx):
        """
        Shows the drop-down window menu on the tab area.

        :param `wnd`: a `wx.Window` derived window instance;
        :param `pages`: the pages associated with the tabs;
        :param `active_idx`: the active tab index.
        """
        
        useImages = self.GetAGWFlags() & AUI_NB_USE_IMAGES_DROPDOWN
        menuPopup = wx.Menu()

        longest = 0
        for i, page in enumerate(pages):
        
            caption = page.caption

            # if there is no caption, make it a space.  This will prevent
            # an assert in the menu code.
            if caption == "":
                caption = " "

            # Save longest caption width for calculating menu width with
            width = wnd.GetTextExtent(caption)[0]
            if width > longest:
                longest = width

            if useImages:
                menuItem = wx.MenuItem(menuPopup, 1000+i, caption)
                if page.bitmap:
                    menuItem.SetBitmap(page.bitmap)

                menuPopup.AppendItem(menuItem)
                
            else:
                
                menuPopup.AppendCheckItem(1000+i, caption)
                
            menuPopup.Enable(1000+i, page.enabled)

        if active_idx != -1 and not useImages:
        
            menuPopup.Check(1000+active_idx, True)
        
        # find out the screen coordinate at the bottom of the tab ctrl
        cli_rect = wnd.GetClientRect()

        # Calculate the approximate size of the popupmenu for setting the
        # position of the menu when its shown.
        # Account for extra padding on left/right of text on mac menus
        if wx.Platform in ['__WXMAC__', '__WXMSW__']:
            longest += 32

        # Bitmap/Checkmark width + padding
        longest += 20

        if self.GetAGWFlags() & AUI_NB_CLOSE_BUTTON:
            longest += 16

        pt = wx.Point(cli_rect.x + cli_rect.GetWidth() - longest,
                     cli_rect.y + cli_rect.height)

        cc = AuiCommandCapture()
        wnd.PushEventHandler(cc)
        wnd.PopupMenu(menuPopup, pt)
        command = cc.GetCommandId()
        wnd.PopEventHandler(True)

        if command >= 1000:
            return command - 1000

        return -1


class AuiSimpleTabArt(object):
    """ A simple-looking implementation of a tab art. """

    def __init__(self):
        """ Default class constructor. """

        self._normal_font = wx.SystemSettings.GetFont(wx.SYS_DEFAULT_GUI_FONT)
        self._selected_font = wx.SystemSettings.GetFont(wx.SYS_DEFAULT_GUI_FONT)
        self._selected_font.SetWeight(wx.BOLD)
        self._measuring_font = self._selected_font

        self._agwFlags = 0
        self._fixed_tab_width = 100

        base_colour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_3DFACE)

        background_colour = base_colour
        normaltab_colour = base_colour
        selectedtab_colour = wx.WHITE

        self._bkbrush = wx.Brush(background_colour)
        self._normal_bkbrush = wx.Brush(normaltab_colour)
        self._normal_bkpen = wx.Pen(normaltab_colour)
        self._selected_bkbrush = wx.Brush(selectedtab_colour)
        self._selected_bkpen = wx.Pen(selectedtab_colour)

        self._active_close_bmp = BitmapFromBits(nb_close_bits, 16, 16, wx.BLACK)
        self._disabled_close_bmp = BitmapFromBits(nb_close_bits, 16, 16, wx.Colour(128, 128, 128))

        self._active_left_bmp = BitmapFromBits(nb_left_bits, 16, 16, wx.BLACK)
        self._disabled_left_bmp = BitmapFromBits(nb_left_bits, 16, 16, wx.Colour(128, 128, 128))

        self._active_right_bmp = BitmapFromBits(nb_right_bits, 16, 16, wx.BLACK)
        self._disabled_right_bmp = BitmapFromBits(nb_right_bits, 16, 16, wx.Colour(128, 128, 128))

        self._active_windowlist_bmp = BitmapFromBits(nb_list_bits, 16, 16, wx.BLACK)
        self._disabled_windowlist_bmp = BitmapFromBits(nb_list_bits, 16, 16, wx.Colour(128, 128, 128))


    def Clone(self):
        """ Clones the art object. """

        art = type(self)()
        art.SetNormalFont(self.GetNormalFont())
        art.SetSelectedFont(self.GetSelectedFont())
        art.SetMeasuringFont(self.GetMeasuringFont())

        art = CopyAttributes(art, self)
        return art


    def SetAGWFlags(self, agwFlags):
        """
        Sets the tab art flags.

        :param `agwFlags`: a combination of the following values:

         ==================================== ==================================
         Flag name                            Description
         ==================================== ==================================
         ``AUI_NB_TOP``                       With this style, tabs are drawn along the top of the notebook
         ``AUI_NB_LEFT``                      With this style, tabs are drawn along the left of the notebook. Not implemented yet.
         ``AUI_NB_RIGHT``                     With this style, tabs are drawn along the right of the notebook. Not implemented yet.
         ``AUI_NB_BOTTOM``                    With this style, tabs are drawn along the bottom of the notebook
         ``AUI_NB_TAB_SPLIT``                 Allows the tab control to be split by dragging a tab
         ``AUI_NB_TAB_MOVE``                  Allows a tab to be moved horizontally by dragging
         ``AUI_NB_TAB_EXTERNAL_MOVE``         Allows a tab to be moved to another tab control
         ``AUI_NB_TAB_FIXED_WIDTH``           With this style, all tabs have the same width
         ``AUI_NB_SCROLL_BUTTONS``            With this style, left and right scroll buttons are displayed
         ``AUI_NB_WINDOWLIST_BUTTON``         With this style, a drop-down list of windows is available
         ``AUI_NB_CLOSE_BUTTON``              With this style, a close button is available on the tab bar
         ``AUI_NB_CLOSE_ON_ACTIVE_TAB``       With this style, a close button is available on the active tab
         ``AUI_NB_CLOSE_ON_ALL_TABS``         With this style, a close button is available on all tabs
         ``AUI_NB_MIDDLE_CLICK_CLOSE``        Allows to close L{AuiNotebook} tabs by mouse middle button click
         ``AUI_NB_SUB_NOTEBOOK``              This style is used by L{AuiManager} to create automatic AuiNotebooks
         ``AUI_NB_HIDE_ON_SINGLE_TAB``        Hides the tab window if only one tab is present
         ``AUI_NB_SMART_TABS``                Use Smart Tabbing, like ``Alt`` + ``Tab`` on Windows
         ``AUI_NB_USE_IMAGES_DROPDOWN``       Uses images on dropdown window list menu instead of check items
         ``AUI_NB_CLOSE_ON_TAB_LEFT``         Draws the tab close button on the left instead of on the right (a la Camino browser)
         ``AUI_NB_TAB_FLOAT``                 Allows the floating of single tabs. Known limitation: when the notebook is more or less full screen, tabs cannot be dragged far enough outside of the notebook to become floating pages
         ``AUI_NB_DRAW_DND_TAB``              Draws an image representation of a tab while dragging (on by default)
         ==================================== ==================================
        
        """

        self._agwFlags = agwFlags


    def GetAGWFlags(self):
        """
        Returns the tab art flags.

        :see: L{SetAGWFlags} for a list of possible return values.
        """

        return self._agwFlags
    

    def SetSizingInfo(self, tab_ctrl_size, tab_count, minMaxTabWidth):
        """
        Sets the tab sizing information.
        
        :param `tab_ctrl_size`: the size of the tab control area;
        :param `tab_count`: the number of tabs;
        :param `minMaxTabWidth`: a tuple containing the minimum and maximum tab widths
         to be used when the ``AUI_NB_TAB_FIXED_WIDTH`` style is active.
        """
        
        self._fixed_tab_width = 100
        minTabWidth, maxTabWidth = minMaxTabWidth

        tot_width = tab_ctrl_size.x - self.GetIndentSize() - 4

        if self._agwFlags & AUI_NB_CLOSE_BUTTON:
            tot_width -= self._active_close_bmp.GetWidth()
        if self._agwFlags & AUI_NB_WINDOWLIST_BUTTON:
            tot_width -= self._active_windowlist_bmp.GetWidth()

        if tab_count > 0:
            self._fixed_tab_width = tot_width/tab_count
        
        if self._fixed_tab_width < 100:
            self._fixed_tab_width = 100

        if self._fixed_tab_width > tot_width/2:
            self._fixed_tab_width = tot_width/2

        if self._fixed_tab_width > 220:
            self._fixed_tab_width = 220

        if minTabWidth > -1:
            self._fixed_tab_width = max(self._fixed_tab_width, minTabWidth)
        if maxTabWidth > -1:
            self._fixed_tab_width = min(self._fixed_tab_width, maxTabWidth)

        self._tab_ctrl_height = tab_ctrl_size.y
        

    def DrawBackground(self, dc, wnd, rect):
        """
        Draws the tab area background.

        :param `dc`: a `wx.DC` device context;
        :param `wnd`: a `wx.Window` instance object;
        :param `rect`: the tab control rectangle.
        """
        
        # draw background
        dc.SetBrush(self._bkbrush)
        dc.SetPen(wx.TRANSPARENT_PEN)
        dc.DrawRectangle(-1, -1, rect.GetWidth()+2, rect.GetHeight()+2)

        # draw base line
        dc.SetPen(wx.GREY_PEN)
        dc.DrawLine(0, rect.GetHeight()-1, rect.GetWidth(), rect.GetHeight()-1)


    def DrawTab(self, dc, wnd, page, in_rect, close_button_state, paint_control=False):
        """
        Draws a single tab.

        :param `dc`: a `wx.DC` device context;
        :param `wnd`: a `wx.Window` instance object;
        :param `page`: the tab control page associated with the tab;
        :param `in_rect`: rectangle the tab should be confined to;
        :param `close_button_state`: the state of the close button on the tab;
        :param `paint_control`: whether to draw the control inside a tab (if any) on a `wx.MemoryDC`.
        """
        
        # if the caption is empty, measure some temporary text
        caption = page.caption
        if caption == "":
            caption = "Xj"

        agwFlags = self.GetAGWFlags()
        
        dc.SetFont(self._selected_font)
        selected_textx, selected_texty, dummy = dc.GetMultiLineTextExtent(caption)

        dc.SetFont(self._normal_font)
        normal_textx, normal_texty, dummy = dc.GetMultiLineTextExtent(caption)

        control = page.control

        # figure out the size of the tab
        tab_size, x_extent = self.GetTabSize(dc, wnd, page.caption, page.bitmap,
                                             page.active, close_button_state, control)

        tab_height = tab_size[1]
        tab_width = tab_size[0]
        tab_x = in_rect.x
        tab_y = in_rect.y + in_rect.height - tab_height

        caption = page.caption
        # select pen, brush and font for the tab to be drawn

        if page.active:
        
            dc.SetPen(self._selected_bkpen)
            dc.SetBrush(self._selected_bkbrush)
            dc.SetFont(self._selected_font)
            textx = selected_textx
            texty = selected_texty
        
        else:
        
            dc.SetPen(self._normal_bkpen)
            dc.SetBrush(self._normal_bkbrush)
            dc.SetFont(self._normal_font)
            textx = normal_textx
            texty = normal_texty

        if not page.enabled:
            dc.SetTextForeground(wx.SystemSettings.GetColour(wx.SYS_COLOUR_GRAYTEXT))
        else:
            dc.SetTextForeground(page.text_colour)
        
        # -- draw line --

        points = [wx.Point() for i in xrange(7)]
        points[0].x = tab_x
        points[0].y = tab_y + tab_height - 1
        points[1].x = tab_x + tab_height - 3
        points[1].y = tab_y + 2
        points[2].x = tab_x + tab_height + 3
        points[2].y = tab_y
        points[3].x = tab_x + tab_width - 2
        points[3].y = tab_y
        points[4].x = tab_x + tab_width
        points[4].y = tab_y + 2
        points[5].x = tab_x + tab_width
        points[5].y = tab_y + tab_height - 1
        points[6] = points[0]

        dc.SetClippingRect(in_rect)
        dc.DrawPolygon(points)

        dc.SetPen(wx.GREY_PEN)
        dc.DrawLines(points)

        close_button_width = 0
        
        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
        
            close_button_width = self._active_close_bmp.GetWidth()
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
                if control:
                    text_offset = tab_x + (tab_height/2) + close_button_width - (textx/2) - 2
                else:
                    text_offset = tab_x + (tab_height/2) + ((tab_width+close_button_width)/2) - (textx/2) - 2
            else:
                if control:
                    text_offset = tab_x + (tab_height/2) + close_button_width - (textx/2)
                else:
                    text_offset = tab_x + (tab_height/2) + ((tab_width-close_button_width)/2) - (textx/2)
        
        else:
        
            text_offset = tab_x + (tab_height/3) + (tab_width/2) - (textx/2)
            if control:
                if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
                    text_offset = tab_x + (tab_height/3) - (textx/2) + close_button_width + 2
                else:
                    text_offset = tab_x + (tab_height/3) - (textx/2)
        
        # set minimum text offset
        if text_offset < tab_x + tab_height:
            text_offset = tab_x + tab_height

        # chop text if necessary
        if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
            draw_text = ChopText(dc, caption, tab_width - (text_offset-tab_x))
        else:
            draw_text = ChopText(dc, caption,
                                 tab_width - (text_offset-tab_x) - close_button_width)


        ypos = (tab_y + tab_height)/2 - (texty/2) + 1

        if control is not None:
            if control.GetPosition() != wx.Point(text_offset+1, ypos):
                control.SetPosition(wx.Point(text_offset+1, ypos))

            if not control.IsShown():
                control.Show()

            if paint_control:
                bmp = TakeScreenShot(control.GetScreenRect())
                dc.DrawBitmap(bmp, text_offset+1, ypos, True)
                
            controlW, controlH = control.GetSize()
            text_offset += controlW + 4

        # draw tab text
        rectx, recty, dummy = dc.GetMultiLineTextExtent(draw_text)
        dc.DrawLabel(draw_text, wx.Rect(text_offset, ypos, rectx, recty))

        # draw focus rectangle
        if page.active and wx.Window.FindFocus() == wnd:
        
            focusRect = wx.Rect(text_offset, ((tab_y + tab_height)/2 - (texty/2) + 1),
                                selected_textx, selected_texty)

            focusRect.Inflate(2, 2)
            # TODO:
            # This should be uncommented when DrawFocusRect will become
            # available in wxPython
            # wx.RendererNative.Get().DrawFocusRect(wnd, dc, focusRect, 0)

        out_button_rect = wx.Rect()        
        # draw close button if necessary
        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
        
            if page.active:
                bmp = self._active_close_bmp
            else:
                bmp = self._disabled_close_bmp

            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
                rect = wx.Rect(tab_x + tab_height - 2,
                               tab_y + (tab_height/2) - (bmp.GetHeight()/2) + 1,
                               close_button_width, tab_height - 1)
            else:                
                rect = wx.Rect(tab_x + tab_width - close_button_width - 1,
                               tab_y + (tab_height/2) - (bmp.GetHeight()/2) + 1,
                               close_button_width, tab_height - 1)
            
            self.DrawButtons(dc, rect, bmp, wx.WHITE, close_button_state)
            out_button_rect = wx.Rect(*rect)
        
        out_tab_rect = wx.Rect(tab_x, tab_y, tab_width, tab_height)
        dc.DestroyClippingRegion()

        return out_tab_rect, out_button_rect, x_extent  


    def DrawButtons(self, dc, _rect, bmp, bkcolour, button_state):
        """
        Convenience method to draw tab buttons.

        :param `dc`: a `wx.DC` device context;
        :param `_rect`: the tab rectangle;
        :param `bmp`: the tab bitmap;
        :param `bkcolour`: the tab background colour;
        :param `button_state`: the state of the tab button.
        """

        rect = wx.Rect(*_rect)

        if button_state == AUI_BUTTON_STATE_PRESSED:
            rect.x += 1
            rect.y += 1

        if button_state in [AUI_BUTTON_STATE_HOVER, AUI_BUTTON_STATE_PRESSED]:
            dc.SetBrush(wx.Brush(StepColour(bkcolour, 120)))
            dc.SetPen(wx.Pen(StepColour(bkcolour, 75)))

            # draw the background behind the button
            dc.DrawRectangle(rect.x, rect.y, 15, 15)

        # draw the button itself
        dc.DrawBitmap(bmp, rect.x, rect.y, True)

    
    def GetIndentSize(self):
        """ Returns the tabs indent size. """
        
        return 0


    def GetTabSize(self, dc, wnd, caption, bitmap, active, close_button_state, control=None):
        """
        Returns the tab size for the given caption, bitmap and button state.

        :param `dc`: a `wx.DC` device context;
        :param `wnd`: a `wx.Window` instance object;
        :param `caption`: the tab text caption;
        :param `bitmap`: the bitmap displayed on the tab;
        :param `active`: whether the tab is selected or not;
        :param `close_button_state`: the state of the close button on the tab;
        :param `control`: a `wx.Window` instance inside a tab (or ``None``).
        """
        
        dc.SetFont(self._measuring_font)
        measured_textx, measured_texty, dummy = dc.GetMultiLineTextExtent(caption)

        tab_height = measured_texty + 4
        tab_width = measured_textx + tab_height + 5

        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
            tab_width += self._active_close_bmp.GetWidth()

        if self._agwFlags & AUI_NB_TAB_FIXED_WIDTH:
            tab_width = self._fixed_tab_width

        if control is not None:
            controlW, controlH = control.GetSize()
            tab_width += controlW + 4

        x_extent = tab_width - (tab_height/2) - 1

        return (tab_width, tab_height), x_extent


    def DrawButton(self, dc, wnd, in_rect, button, orientation):
        """
        Draws a button on the tab or on the tab area, depending on the button identifier. 

        :param `dc`: a `wx.DC` device context;
        :param `wnd`: a `wx.Window` instance object;
        :param `in_rect`: rectangle the tab should be confined to;
        :param `button`: an instance of the button class;
        :param `orientation`: the tab orientation.
        """

        bitmap_id, button_state = button.id, button.cur_state
        
        if bitmap_id == AUI_BUTTON_CLOSE:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                bmp = self._disabled_close_bmp
            else:
                bmp = self._active_close_bmp

        elif bitmap_id == AUI_BUTTON_LEFT:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                bmp = self._disabled_left_bmp
            else:
                bmp = self._active_left_bmp

        elif bitmap_id == AUI_BUTTON_RIGHT:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                bmp = self._disabled_right_bmp
            else:
                bmp = self._active_right_bmp

        elif bitmap_id == AUI_BUTTON_WINDOWLIST:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                bmp = self._disabled_windowlist_bmp
            else:
                bmp = self._active_windowlist_bmp

        else:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                bmp = button.dis_bitmap
            else:
                bmp = button.bitmap
            
        if not bmp.IsOk():
            return

        rect = wx.Rect(*in_rect)

        if orientation == wx.LEFT:
        
            rect.SetX(in_rect.x)
            rect.SetY(((in_rect.y + in_rect.height)/2) - (bmp.GetHeight()/2))
            rect.SetWidth(bmp.GetWidth())
            rect.SetHeight(bmp.GetHeight())
        
        else:
        
            rect = wx.Rect(in_rect.x + in_rect.width - bmp.GetWidth(),
                           ((in_rect.y + in_rect.height)/2) - (bmp.GetHeight()/2),
                           bmp.GetWidth(), bmp.GetHeight())

        self.DrawButtons(dc, rect, bmp, wx.WHITE, button_state)

        out_rect = wx.Rect(*rect)
        return out_rect


    def ShowDropDown(self, wnd, pages, active_idx):
        """
        Shows the drop-down window menu on the tab area.

        :param `wnd`: a `wx.Window` derived window instance;
        :param `pages`: the pages associated with the tabs;
        :param `active_idx`: the active tab index.
        """
        
        menuPopup = wx.Menu()
        useImages = self.GetAGWFlags() & AUI_NB_USE_IMAGES_DROPDOWN
        
        for i, page in enumerate(pages):

            if useImages:
                menuItem = wx.MenuItem(menuPopup, 1000+i, page.caption)
                if page.bitmap:
                    menuItem.SetBitmap(page.bitmap)

                menuPopup.AppendItem(menuItem)
                
            else:
                
                menuPopup.AppendCheckItem(1000+i, page.caption)
                
            menuPopup.Enable(1000+i, page.enabled)
        
        if active_idx != -1 and not useImages:
            menuPopup.Check(1000+active_idx, True)
        
        # find out where to put the popup menu of window
        # items.  Subtract 100 for now to center the menu
        # a bit, until a better mechanism can be implemented
        pt = wx.GetMousePosition()
        pt = wnd.ScreenToClient(pt)
        
        if pt.x < 100:
            pt.x = 0
        else:
            pt.x -= 100

        # find out the screen coordinate at the bottom of the tab ctrl
        cli_rect = wnd.GetClientRect()
        pt.y = cli_rect.y + cli_rect.height

        cc = AuiCommandCapture()
        wnd.PushEventHandler(cc)
        wnd.PopupMenu(menuPopup, pt)
        command = cc.GetCommandId()
        wnd.PopEventHandler(True)

        if command >= 1000:
            return command-1000

        return -1


    def GetBestTabCtrlSize(self, wnd, pages, required_bmp_size):
        """
        Returns the best tab control size.

        :param `wnd`: a `wx.Window` instance object;
        :param `pages`: the pages associated with the tabs;
        :param `required_bmp_size`: the size of the bitmap on the tabs.
        """
        
        dc = wx.ClientDC(wnd)
        dc.SetFont(self._measuring_font)
        s, x_extent = self.GetTabSize(dc, wnd, "ABCDEFGHIj", wx.NullBitmap, True,
                                      AUI_BUTTON_STATE_HIDDEN, None)

        max_y = s[1]

        for page in pages:
            if page.control:
                controlW, controlH = page.control.GetSize()
                max_y = max(max_y, controlH+4)
                
            textx, texty, dummy = dc.GetMultiLineTextExtent(page.caption)
            max_y = max(max_y, texty)
        
        return max_y + 3


    def SetNormalFont(self, font):
        """
        Sets the normal font for drawing tab labels.

        :param `font`: a `wx.Font` object.
        """
        
        self._normal_font = font


    def SetSelectedFont(self, font):
        """
        Sets the selected tab font for drawing tab labels.

        :param `font`: a `wx.Font` object.
        """
        
        self._selected_font = font


    def SetMeasuringFont(self, font):
        """
        Sets the font for calculating text measurements.

        :param `font`: a `wx.Font` object.
        """
        
        self._measuring_font = font


    def GetNormalFont(self):
        """ Returns the normal font for drawing tab labels. """

        return self._normal_font


    def GetSelectedFont(self):
        """ Returns the selected tab font for drawing tab labels. """

        return self._selected_font


    def GetMeasuringFont(self):
        """ Returns the font for calculating text measurements. """

        return self._measuring_font


    def SetCustomButton(self, bitmap_id, button_state, bmp):
        """
        Sets a custom bitmap for the close, left, right and window list
        buttons.
        
        :param `bitmap_id`: the button identifier;
        :param `button_state`: the button state;
        :param `bmp`: the custom bitmap to use for the button.
        """
        
        if bitmap_id == AUI_BUTTON_CLOSE:
            if button_state == AUI_BUTTON_STATE_NORMAL:
                self._active_close_bmp = bmp
                self._hover_close_bmp = self._active_close_bmp
                self._pressed_close_bmp = self._active_close_bmp
                self._disabled_close_bmp = self._active_close_bmp
                    
            elif button_state == AUI_BUTTON_STATE_HOVER:
                self._hover_close_bmp = bmp
            elif button_state == AUI_BUTTON_STATE_PRESSED:
                self._pressed_close_bmp = bmp
            else:
                self._disabled_close_bmp = bmp

        elif bitmap_id == AUI_BUTTON_LEFT:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                self._disabled_left_bmp = bmp
            else:
                self._active_left_bmp = bmp

        elif bitmap_id == AUI_BUTTON_RIGHT:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                self._disabled_right_bmp = bmp
            else:
                self._active_right_bmp = bmp

        elif bitmap_id == AUI_BUTTON_WINDOWLIST:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                self._disabled_windowlist_bmp = bmp
            else:
                self._active_windowlist_bmp = bmp
    

class VC71TabArt(AuiDefaultTabArt):
    """ A class to draw tabs using the Visual Studio 2003 (VC71) style. """

    def __init__(self):
        """ Default class constructor. """

        AuiDefaultTabArt.__init__(self)


    def Clone(self):
        """ Clones the art object. """

        art = type(self)()
        art.SetNormalFont(self.GetNormalFont())
        art.SetSelectedFont(self.GetSelectedFont())
        art.SetMeasuringFont(self.GetMeasuringFont())

        art = CopyAttributes(art, self)
        return art


    def DrawTab(self, dc, wnd, page, in_rect, close_button_state, paint_control=False):
        """
        Draws a single tab.

        :param `dc`: a `wx.DC` device context;
        :param `wnd`: a `wx.Window` instance object;
        :param `page`: the tab control page associated with the tab;
        :param `in_rect`: rectangle the tab should be confined to;
        :param `close_button_state`: the state of the close button on the tab;
        :param `paint_control`: whether to draw the control inside a tab (if any) on a `wx.MemoryDC`.
        """
        
        # Visual studio 7.1 style
        # This code is based on the renderer included in FlatNotebook

        # figure out the size of the tab

        control = page.control
        tab_size, x_extent = self.GetTabSize(dc, wnd, page.caption, page.bitmap, page.active,
                                             close_button_state, control)

        tab_height = self._tab_ctrl_height - 3
        tab_width = tab_size[0]
        tab_x = in_rect.x
        tab_y = in_rect.y + in_rect.height - tab_height
        clip_width = tab_width

        if tab_x + clip_width > in_rect.x + in_rect.width - 4:
            clip_width = (in_rect.x + in_rect.width) - tab_x - 4
            
        dc.SetClippingRegion(tab_x, tab_y, clip_width + 1, tab_height - 3)
        agwFlags = self.GetAGWFlags()

        if agwFlags & AUI_NB_BOTTOM:
            tab_y -= 1

        dc.SetPen((page.active and [wx.Pen(wx.SystemSettings.GetColour(wx.SYS_COLOUR_3DHIGHLIGHT))] or \
                   [wx.Pen(wx.SystemSettings.GetColour(wx.SYS_COLOUR_3DSHADOW))])[0])
        dc.SetBrush((page.active and [wx.Brush(wx.SystemSettings.GetColour(wx.SYS_COLOUR_3DFACE))] or \
                     [wx.TRANSPARENT_BRUSH])[0])

        if page.active:

            tabH = tab_height - 2
            dc.DrawRectangle(tab_x, tab_y, tab_width, tabH)

            rightLineY1 = (agwFlags & AUI_NB_BOTTOM and [vertical_border_padding - 2] or \
                           [vertical_border_padding - 1])[0]
            rightLineY2 = tabH + 3
            dc.SetPen(wx.Pen(wx.SystemSettings.GetColour(wx.SYS_COLOUR_3DSHADOW)))
            dc.DrawLine(tab_x + tab_width - 1, rightLineY1 + 1, tab_x + tab_width - 1, rightLineY2)
            
            if agwFlags & AUI_NB_BOTTOM:
                dc.DrawLine(tab_x + 1, rightLineY2 - 3 , tab_x + tab_width - 1, rightLineY2 - 3)
                
            dc.SetPen(wx.Pen(wx.SystemSettings.GetColour(wx.SYS_COLOUR_3DDKSHADOW)))
            dc.DrawLine(tab_x + tab_width, rightLineY1, tab_x + tab_width, rightLineY2)
            
            if agwFlags & AUI_NB_BOTTOM:
                dc.DrawLine(tab_x, rightLineY2 - 2, tab_x + tab_width, rightLineY2 - 2)

        else:
        
            # We dont draw a rectangle for non selected tabs, but only
            # vertical line on the right
            blackLineY1 = (agwFlags & AUI_NB_BOTTOM and [vertical_border_padding + 2] or \
                           [vertical_border_padding + 1])[0]
            blackLineY2 = tab_height - 5
            dc.DrawLine(tab_x + tab_width, blackLineY1, tab_x + tab_width, blackLineY2)
        
        border_points = [0, 0]
        
        if agwFlags & AUI_NB_BOTTOM:
        
            border_points[0] = wx.Point(tab_x, tab_y)
            border_points[1] = wx.Point(tab_x, tab_y + tab_height - 6)
        
        else: # if (agwFlags & AUI_NB_TOP)
        
            border_points[0] = wx.Point(tab_x, tab_y + tab_height - 4)
            border_points[1] = wx.Point(tab_x, tab_y + 2)

        drawn_tab_yoff = border_points[1].y
        drawn_tab_height = border_points[0].y - border_points[1].y

        text_offset = tab_x + 8
        close_button_width = 0

        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
            close_button_width = self._active_close_bmp.GetWidth()
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
                text_offset += close_button_width - 5

        if not page.enabled:
            dc.SetTextForeground(wx.SystemSettings.GetColour(wx.SYS_COLOUR_GRAYTEXT))
            pagebitmap = page.dis_bitmap
        else:
            dc.SetTextForeground(page.text_colour)
            pagebitmap = page.bitmap

        shift = 0
        if agwFlags & AUI_NB_BOTTOM:
            shift = (page.active and [1] or [2])[0]
            
        bitmap_offset = 0
        if pagebitmap.IsOk():
            bitmap_offset = tab_x + 8
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT and close_button_width:
                bitmap_offset += close_button_width - 5

            # draw bitmap
            dc.DrawBitmap(pagebitmap, bitmap_offset,
                          drawn_tab_yoff + (drawn_tab_height/2) - (pagebitmap.GetHeight()/2) + shift,
                          True)

            text_offset = bitmap_offset + pagebitmap.GetWidth()
            text_offset += 3 # bitmap padding
        
        else:
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT == 0 or not close_button_width:
                text_offset = tab_x + 8
        
        # if the caption is empty, measure some temporary text
        caption = page.caption

        if caption == "":
            caption = "Xj"

        if page.active:
            dc.SetFont(self._selected_font)
            textx, texty, dummy = dc.GetMultiLineTextExtent(caption)
        else:
            dc.SetFont(self._normal_font)
            textx, texty, dummy = dc.GetMultiLineTextExtent(caption)

        draw_text = ChopText(dc, caption, tab_width - (text_offset-tab_x) - close_button_width)

        ypos = drawn_tab_yoff + (drawn_tab_height)/2 - (texty/2) - 1 + shift

        offset_focus = text_offset
        
        if control is not None:
            if control.GetPosition() != wx.Point(text_offset+1, ypos):
                control.SetPosition(wx.Point(text_offset+1, ypos))

            if not control.IsShown():
                control.Show()

            if paint_control:
                bmp = TakeScreenShot(control.GetScreenRect())
                dc.DrawBitmap(bmp, text_offset+1, ypos, True)
                
            controlW, controlH = control.GetSize()
            text_offset += controlW + 4
            textx += controlW + 4

        # draw tab text
        rectx, recty, dummy = dc.GetMultiLineTextExtent(draw_text)
        dc.DrawLabel(draw_text, wx.Rect(text_offset, ypos, rectx, recty))

        out_button_rect = wx.Rect()

        # draw focus rectangle
        self.DrawFocusRectangle(dc, page, wnd, draw_text, offset_focus, bitmap_offset, drawn_tab_yoff+shift,
                                drawn_tab_height+shift, textx, texty)
                
        # draw 'x' on tab (if enabled)
        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
            close_button_width = self._active_close_bmp.GetWidth()

            bmp = self._disabled_close_bmp

            if close_button_state == AUI_BUTTON_STATE_HOVER:
                bmp = self._hover_close_bmp
            elif close_button_state == AUI_BUTTON_STATE_PRESSED:
                bmp = self._pressed_close_bmp

            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
                rect = wx.Rect(tab_x + 4,
                               drawn_tab_yoff + (drawn_tab_height / 2) - (bmp.GetHeight() / 2) + shift,
                               close_button_width, tab_height)
            else:
                rect = wx.Rect(tab_x + tab_width - close_button_width - 3,
                               drawn_tab_yoff + (drawn_tab_height / 2) - (bmp.GetHeight() / 2) + shift,
                               close_button_width, tab_height)

            # Indent the button if it is pressed down:
            rect = IndentPressedBitmap(rect, close_button_state)
            dc.DrawBitmap(bmp, rect.x, rect.y, True)

            out_button_rect = rect        

        out_tab_rect = wx.Rect(tab_x, tab_y, tab_width, tab_height)
        dc.DestroyClippingRegion()

        return out_tab_rect, out_button_rect, x_extent


class FF2TabArt(AuiDefaultTabArt):
    """ A class to draw tabs using the Firefox 2 (FF2) style. """

    def __init__(self):
        """ Default class constructor. """

        AuiDefaultTabArt.__init__(self)


    def Clone(self):
        """ Clones the art object. """

        art = type(self)()
        art.SetNormalFont(self.GetNormalFont())
        art.SetSelectedFont(self.GetSelectedFont())
        art.SetMeasuringFont(self.GetMeasuringFont())

        art = CopyAttributes(art, self)
        return art


    def GetTabSize(self, dc, wnd, caption, bitmap, active, close_button_state, control):
        """
        Returns the tab size for the given caption, bitmap and button state.

        :param `dc`: a `wx.DC` device context;
        :param `wnd`: a `wx.Window` instance object;
        :param `caption`: the tab text caption;
        :param `bitmap`: the bitmap displayed on the tab;
        :param `active`: whether the tab is selected or not;
        :param `close_button_state`: the state of the close button on the tab;
        :param `control`: a `wx.Window` instance inside a tab (or ``None``).
        """
        
        tab_size, x_extent = AuiDefaultTabArt.GetTabSize(self, dc, wnd, caption, bitmap,
                                                         active, close_button_state, control)

        tab_width, tab_height = tab_size        

        # add some vertical padding
        tab_height += 2
        
        return (tab_width, tab_height), x_extent


    def DrawTab(self, dc, wnd, page, in_rect, close_button_state, paint_control=False):
        """
        Draws a single tab.

        :param `dc`: a `wx.DC` device context;
        :param `wnd`: a `wx.Window` instance object;
        :param `page`: the tab control page associated with the tab;
        :param `in_rect`: rectangle the tab should be confined to;
        :param `close_button_state`: the state of the close button on the tab;
        :param `paint_control`: whether to draw the control inside a tab (if any) on a `wx.MemoryDC`.
        """
        
        # Firefox 2 style

        control = page.control

        # figure out the size of the tab
        tab_size, x_extent = self.GetTabSize(dc, wnd, page.caption, page.bitmap,
                                             page.active, close_button_state, control)

        tab_height = self._tab_ctrl_height - 2
        tab_width = tab_size[0]
        tab_x = in_rect.x
        tab_y = in_rect.y + in_rect.height - tab_height

        clip_width = tab_width
        if tab_x + clip_width > in_rect.x + in_rect.width - 4:
            clip_width = (in_rect.x + in_rect.width) - tab_x - 4
            
        dc.SetClippingRegion(tab_x, tab_y, clip_width + 1, tab_height - 3)

        tabPoints = [wx.Point() for i in xrange(7)]
        
        adjust = 0
        if not page.active:
            adjust = 1

        agwFlags = self.GetAGWFlags()
        
        tabPoints[0].x = tab_x + 3
        tabPoints[0].y = (agwFlags & AUI_NB_BOTTOM and [3] or [tab_height - 2])[0]

        tabPoints[1].x = tabPoints[0].x
        tabPoints[1].y = (agwFlags & AUI_NB_BOTTOM and [tab_height - (vertical_border_padding + 2) - adjust] or \
                          [(vertical_border_padding + 2) + adjust])[0]

        tabPoints[2].x = tabPoints[1].x+2
        tabPoints[2].y = (agwFlags & AUI_NB_BOTTOM and [tab_height - vertical_border_padding - adjust] or \
                          [vertical_border_padding + adjust])[0]

        tabPoints[3].x = tab_x + tab_width - 2
        tabPoints[3].y = tabPoints[2].y

        tabPoints[4].x = tabPoints[3].x + 2
        tabPoints[4].y = tabPoints[1].y

        tabPoints[5].x = tabPoints[4].x
        tabPoints[5].y = tabPoints[0].y

        tabPoints[6].x = tabPoints[0].x
        tabPoints[6].y = tabPoints[0].y

        rr = wx.RectPP(tabPoints[2], tabPoints[5])
        self.DrawTabBackground(dc, rr, page.active, (agwFlags & AUI_NB_BOTTOM) == 0)

        dc.SetBrush(wx.TRANSPARENT_BRUSH)
        dc.SetPen(wx.Pen(wx.SystemSettings_GetColour(wx.SYS_COLOUR_BTNSHADOW)))

        # Draw the tab as rounded rectangle
        dc.DrawPolygon(tabPoints)

        if page.active:
            dc.DrawLine(tabPoints[0].x + 1, tabPoints[0].y, tabPoints[5].x , tabPoints[0].y)
        
        drawn_tab_yoff = tabPoints[1].y
        drawn_tab_height = tabPoints[0].y - tabPoints[2].y

        text_offset = tab_x + 8
        close_button_width = 0
        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
            close_button_width = self._active_close_bmp.GetWidth()
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
                text_offset += close_button_width - 4

        if not page.enabled:
            dc.SetTextForeground(wx.SystemSettings.GetColour(wx.SYS_COLOUR_GRAYTEXT))
            pagebitmap = page.dis_bitmap
        else:
            dc.SetTextForeground(page.text_colour)
            pagebitmap = page.bitmap

        shift = -1
        if agwFlags & AUI_NB_BOTTOM:
            shift = 2
        
        bitmap_offset = 0
        if pagebitmap.IsOk():
            bitmap_offset = tab_x + 8
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT and close_button_width:
                bitmap_offset += close_button_width - 4

            # draw bitmap
            dc.DrawBitmap(pagebitmap, bitmap_offset,
                          drawn_tab_yoff + (drawn_tab_height/2) - (pagebitmap.GetHeight()/2) + shift,
                          True)

            text_offset = bitmap_offset + pagebitmap.GetWidth()
            text_offset += 3 # bitmap padding
        
        else:
        
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT == 0 or not close_button_width:
                text_offset = tab_x + 8
        
        # if the caption is empty, measure some temporary text
        caption = page.caption
        if caption == "":
            caption = "Xj"

        if page.active:
            dc.SetFont(self._selected_font)
            textx, texty, dummy = dc.GetMultiLineTextExtent(caption)
        else:
            dc.SetFont(self._normal_font)
            textx, texty, dummy = dc.GetMultiLineTextExtent(caption)

        if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
            draw_text = ChopText(dc, caption, tab_width - (text_offset-tab_x) - close_button_width + 1)
        else:
            draw_text = ChopText(dc, caption, tab_width - (text_offset-tab_x) - close_button_width)

        ypos = drawn_tab_yoff + drawn_tab_height/2 - texty/2 - 1 + shift

        offset_focus = text_offset
        
        if control is not None:
            if control.GetPosition() != wx.Point(text_offset+1, ypos):
                control.SetPosition(wx.Point(text_offset+1, ypos))

            if not control.IsShown():
                control.Show()

            if paint_control:
                bmp = TakeScreenShot(control.GetScreenRect())
                dc.DrawBitmap(bmp, text_offset+1, ypos, True)
                
            controlW, controlH = control.GetSize()
            text_offset += controlW + 4
            textx += controlW + 4
        
        # draw tab text
        rectx, recty, dummy = dc.GetMultiLineTextExtent(draw_text)
        dc.DrawLabel(draw_text, wx.Rect(text_offset, ypos, rectx, recty))

        # draw focus rectangle
        self.DrawFocusRectangle(dc, page, wnd, draw_text, offset_focus, bitmap_offset, drawn_tab_yoff+shift,
                                drawn_tab_height, textx, texty)
        
        out_button_rect = wx.Rect()
        # draw 'x' on tab (if enabled)
        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
        
            close_button_width = self._active_close_bmp.GetWidth()
            bmp = self._disabled_close_bmp

            if close_button_state == AUI_BUTTON_STATE_HOVER:
                bmp = self._hover_close_bmp
            elif close_button_state == AUI_BUTTON_STATE_PRESSED:
                bmp = self._pressed_close_bmp

            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
                rect = wx.Rect(tab_x + 5,
                               drawn_tab_yoff + (drawn_tab_height / 2) - (bmp.GetHeight() / 2) + shift,
                               close_button_width, tab_height)
            else:
                rect = wx.Rect(tab_x + tab_width - close_button_width - 3,
                               drawn_tab_yoff + (drawn_tab_height / 2) - (bmp.GetHeight() / 2) + shift,
                               close_button_width, tab_height)

            # Indent the button if it is pressed down:
            rect = IndentPressedBitmap(rect, close_button_state)
            dc.DrawBitmap(bmp, rect.x, rect.y, True)
            out_button_rect = rect
        
        out_tab_rect = wx.Rect(tab_x, tab_y, tab_width, tab_height)
        dc.DestroyClippingRegion()
    
        return out_tab_rect, out_button_rect, x_extent


    def DrawTabBackground(self, dc, rect, focus, upperTabs):
        """
        Draws the tab background for the Firefox 2 style.
        This is more consistent with L{FlatNotebook} than before.

        :param `dc`: a `wx.DC` device context;
        :param `rect`: rectangle the tab should be confined to;
        :param `focus`: whether the tab has focus or not;
        :param `upperTabs`: whether the style is ``AUI_NB_TOP`` or ``AUI_NB_BOTTOM``.
        """

        # Define the rounded rectangle base on the given rect
        # we need an array of 9 points for it
        regPts = [wx.Point() for indx in xrange(9)]

        if focus:
            if upperTabs:
                leftPt = wx.Point(rect.x, rect.y + (rect.height / 10)*8)
                rightPt = wx.Point(rect.x + rect.width - 2, rect.y + (rect.height / 10)*8)
            else:
                leftPt = wx.Point(rect.x, rect.y + (rect.height / 10)*5)
                rightPt = wx.Point(rect.x + rect.width - 2, rect.y + (rect.height / 10)*5)
        else:
            leftPt = wx.Point(rect.x, rect.y + (rect.height / 2))
            rightPt = wx.Point(rect.x + rect.width - 2, rect.y + (rect.height / 2))

        # Define the top region
        top = wx.RectPP(rect.GetTopLeft(), rightPt)
        bottom = wx.RectPP(leftPt, rect.GetBottomRight())

        topStartColour = wx.WHITE

        if not focus:
            topStartColour = LightColour(wx.SystemSettings_GetColour(wx.SYS_COLOUR_3DFACE), 50)

        topEndColour = wx.SystemSettings_GetColour(wx.SYS_COLOUR_3DFACE)
        bottomStartColour = topEndColour
        bottomEndColour = topEndColour

        # Incase we use bottom tabs, switch the colours
        if upperTabs:
            if focus:
                dc.GradientFillLinear(top, topStartColour, topEndColour, wx.SOUTH)
                dc.GradientFillLinear(bottom, bottomStartColour, bottomEndColour, wx.SOUTH)
            else:
                dc.GradientFillLinear(top, topEndColour , topStartColour, wx.SOUTH)
                dc.GradientFillLinear(bottom, bottomStartColour, bottomEndColour, wx.SOUTH)

        else:
            if focus:
                dc.GradientFillLinear(bottom, topEndColour, bottomEndColour, wx.SOUTH)
                dc.GradientFillLinear(top, topStartColour, topStartColour, wx.SOUTH)
            else:
                dc.GradientFillLinear(bottom, bottomStartColour, bottomEndColour, wx.SOUTH)
                dc.GradientFillLinear(top, topEndColour, topStartColour, wx.SOUTH)
        
        dc.SetBrush(wx.TRANSPARENT_BRUSH)


class VC8TabArt(AuiDefaultTabArt):
    """ A class to draw tabs using the Visual Studio 2005 (VC8) style. """

    def __init__(self):
        """ Default class constructor. """

        AuiDefaultTabArt.__init__(self)


    def Clone(self):
        """ Clones the art object. """

        art = type(self)()
        art.SetNormalFont(self.GetNormalFont())
        art.SetSelectedFont(self.GetSelectedFont())
        art.SetMeasuringFont(self.GetMeasuringFont())

        art = CopyAttributes(art, self)
        return art


    def SetSizingInfo(self, tab_ctrl_size, tab_count, minMaxTabWidth):
        """
        Sets the tab sizing information.
        
        :param `tab_ctrl_size`: the size of the tab control area;
        :param `tab_count`: the number of tabs;
        :param `minMaxTabWidth`: a tuple containing the minimum and maximum tab widths
         to be used when the ``AUI_NB_TAB_FIXED_WIDTH`` style is active.
        """
        
        AuiDefaultTabArt.SetSizingInfo(self, tab_ctrl_size, tab_count, minMaxTabWidth)

        minTabWidth, maxTabWidth = minMaxTabWidth
        if minTabWidth > -1:
            self._fixed_tab_width = max(self._fixed_tab_width, minTabWidth)
        if maxTabWidth > -1:
            self._fixed_tab_width = min(self._fixed_tab_width, maxTabWidth)
        
        self._fixed_tab_width -= 5


    def GetTabSize(self, dc, wnd, caption, bitmap, active, close_button_state, control=None):
        """
        Returns the tab size for the given caption, bitmap and button state.

        :param `dc`: a `wx.DC` device context;
        :param `wnd`: a `wx.Window` instance object;
        :param `caption`: the tab text caption;
        :param `bitmap`: the bitmap displayed on the tab;
        :param `active`: whether the tab is selected or not;
        :param `close_button_state`: the state of the close button on the tab;
        :param `control`: a `wx.Window` instance inside a tab (or ``None``).
        """
        
        tab_size, x_extent = AuiDefaultTabArt.GetTabSize(self, dc, wnd, caption, bitmap,
                                                         active, close_button_state, control)

        tab_width, tab_height = tab_size        

        # add some padding
        tab_width += 10
        tab_height += 2

        return (tab_width, tab_height), x_extent


    def DrawTab(self, dc, wnd, page, in_rect, close_button_state, paint_control=False):
        """
        Draws a single tab.

        :param `dc`: a `wx.DC` device context;
        :param `wnd`: a `wx.Window` instance object;
        :param `page`: the tab control page associated with the tab;
        :param `in_rect`: rectangle the tab should be confined to;
        :param `close_button_state`: the state of the close button on the tab;
        :param `paint_control`: whether to draw the control inside a tab (if any) on a `wx.MemoryDC`.
        """
        
        # Visual Studio 8 style

        control = page.control

        # figure out the size of the tab
        tab_size, x_extent = self.GetTabSize(dc, wnd, page.caption, page.bitmap,
                                             page.active, close_button_state, control)

        tab_height = self._tab_ctrl_height - 1
        tab_width = tab_size[0]
        tab_x = in_rect.x
        tab_y = in_rect.y + in_rect.height - tab_height

        clip_width = tab_width + 3
        if tab_x + clip_width > in_rect.x + in_rect.width - 4:
            clip_width = (in_rect.x + in_rect.width) - tab_x - 4
        
        tabPoints = [wx.Point() for i in xrange(8)]

        # If we draw the first tab or the active tab, 
        # we draw a full tab, else we draw a truncated tab
        #
        #             X(2)                  X(3)
        #        X(1)                            X(4)
        #                                          
        #                                           X(5)
        #                                           
        # X(0),(7)                                  X(6)
        #
        #

        adjust = 0
        if not page.active:
            adjust = 1

        agwFlags = self.GetAGWFlags()
        tabPoints[0].x = (agwFlags & AUI_NB_BOTTOM and [tab_x] or [tab_x + adjust])[0]
        tabPoints[0].y = (agwFlags & AUI_NB_BOTTOM and [2] or [tab_height - 3])[0]

        tabPoints[1].x = tabPoints[0].x + tab_height - vertical_border_padding - 3 - adjust
        tabPoints[1].y = (agwFlags & AUI_NB_BOTTOM and [tab_height - (vertical_border_padding+2)] or \
                          [(vertical_border_padding+2)])[0]

        tabPoints[2].x = tabPoints[1].x + 4
        tabPoints[2].y = (agwFlags & AUI_NB_BOTTOM and [tab_height - vertical_border_padding] or \
                          [vertical_border_padding])[0]

        tabPoints[3].x = tabPoints[2].x + tab_width - tab_height + vertical_border_padding
        tabPoints[3].y = (agwFlags & AUI_NB_BOTTOM and [tab_height - vertical_border_padding] or \
                          [vertical_border_padding])[0]

        tabPoints[4].x = tabPoints[3].x + 1
        tabPoints[4].y = (agwFlags & AUI_NB_BOTTOM and [tabPoints[3].y - 1] or [tabPoints[3].y + 1])[0]

        tabPoints[5].x = tabPoints[4].x + 1
        tabPoints[5].y = (agwFlags & AUI_NB_BOTTOM and [(tabPoints[4].y - 1)] or [tabPoints[4].y + 1])[0]

        tabPoints[6].x = tabPoints[2].x + tab_width - tab_height + 2 + vertical_border_padding
        tabPoints[6].y = tabPoints[0].y

        tabPoints[7].x = tabPoints[0].x
        tabPoints[7].y = tabPoints[0].y

        self.FillVC8GradientColour(dc, tabPoints, page.active)        

        dc.SetBrush(wx.TRANSPARENT_BRUSH)

        dc.SetPen(wx.Pen(wx.SystemSettings.GetColour(wx.SYS_COLOUR_BTNSHADOW)))
        dc.DrawPolygon(tabPoints)

        if page.active:
            # Delete the bottom line (or the upper one, incase we use wxBOTTOM) 
            dc.SetPen(wx.WHITE_PEN)
            dc.DrawLine(tabPoints[0].x, tabPoints[0].y, tabPoints[6].x, tabPoints[6].y)

        dc.SetClippingRegion(tab_x, tab_y, clip_width + 2, tab_height - 3)            

        drawn_tab_yoff = tabPoints[1].y
        drawn_tab_height = tabPoints[0].y - tabPoints[2].y

        text_offset = tab_x + 20
        close_button_width = 0
        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
            close_button_width = self._active_close_bmp.GetWidth()
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
                text_offset += close_button_width

        if not page.enabled:
            dc.SetTextForeground(wx.SystemSettings.GetColour(wx.SYS_COLOUR_GRAYTEXT))
            pagebitmap = page.dis_bitmap
        else:
            dc.SetTextForeground(page.text_colour)
            pagebitmap = page.bitmap

        shift = 0
        if agwFlags & AUI_NB_BOTTOM:
            shift = (page.active and [1] or [2])[0]
        
        bitmap_offset = 0
        if pagebitmap.IsOk():
            bitmap_offset = tab_x + 20
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT and close_button_width:
                bitmap_offset += close_button_width

            # draw bitmap
            dc.DrawBitmap(pagebitmap, bitmap_offset,
                          drawn_tab_yoff + (drawn_tab_height/2) - (pagebitmap.GetHeight()/2) + shift,
                          True)

            text_offset = bitmap_offset + pagebitmap.GetWidth()
            text_offset += 3 # bitmap padding
        
        else:
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT == 0 or not close_button_width:
                text_offset = tab_x + tab_height
        
        # if the caption is empty, measure some temporary text
        caption = page.caption
        if caption == "":
            caption = "Xj"

        if page.active:
            dc.SetFont(self._selected_font)
            textx, texty, dummy = dc.GetMultiLineTextExtent(caption)
        else:
            dc.SetFont(self._normal_font)
            textx, texty, dummy = dc.GetMultiLineTextExtent(caption)

        if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
            draw_text = ChopText(dc, caption, tab_width - (text_offset-tab_x))
        else:
            draw_text = ChopText(dc, caption, tab_width - (text_offset-tab_x) - close_button_width)

        ypos = drawn_tab_yoff + drawn_tab_height/2 - texty/2 - 1 + shift

        offset_focus = text_offset
        
        if control is not None:
            if control.GetPosition() != wx.Point(text_offset+1, ypos):
                control.SetPosition(wx.Point(text_offset+1, ypos))

            if not control.IsShown():
                control.Show()

            if paint_control:
                bmp = TakeScreenShot(control.GetScreenRect())
                dc.DrawBitmap(bmp, text_offset+1, ypos, True)
                
            controlW, controlH = control.GetSize()
            text_offset += controlW + 4
            textx += controlW + 4

        # draw tab text
        rectx, recty, dummy = dc.GetMultiLineTextExtent(draw_text)
        dc.DrawLabel(draw_text, wx.Rect(text_offset, ypos, rectx, recty))
        
        # draw focus rectangle
        self.DrawFocusRectangle(dc, page, wnd, draw_text, offset_focus, bitmap_offset, drawn_tab_yoff+shift,
                                drawn_tab_height+shift, textx, texty)
        
        out_button_rect = wx.Rect()
        # draw 'x' on tab (if enabled)
        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
        
            close_button_width = self._active_close_bmp.GetWidth()
            bmp = self._disabled_close_bmp

            if close_button_state == AUI_BUTTON_STATE_HOVER:
                bmp = self._hover_close_bmp
            elif close_button_state == AUI_BUTTON_STATE_PRESSED:
                bmp = self._pressed_close_bmp
                
            if page.active:
                xpos = tab_x + tab_width - close_button_width + 3
            else:
                xpos = tab_x + tab_width - close_button_width - 5

            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
                rect = wx.Rect(tab_x + 20,
                               drawn_tab_yoff + (drawn_tab_height / 2) - (bmp.GetHeight() / 2) + shift,
                               close_button_width, tab_height)
            else:
                rect = wx.Rect(xpos,
                               drawn_tab_yoff + (drawn_tab_height / 2) - (bmp.GetHeight() / 2) + shift,
                               close_button_width, tab_height)

            # Indent the button if it is pressed down:
            rect = IndentPressedBitmap(rect, close_button_state)
            dc.DrawBitmap(bmp, rect.x, rect.y, True)
            out_button_rect = rect
        
        out_tab_rect = wx.Rect(tab_x, tab_y, x_extent, tab_height)
        dc.DestroyClippingRegion()

        return out_tab_rect, out_button_rect, x_extent
        

    def FillVC8GradientColour(self, dc, tabPoints, active):
        """
        Fills the tab with the Visual Studio 2005 gradient background.

        :param `dc`: a `wx.DC` device context;
        :param `tabPoints`: a list of `wx.Point` objects describing the tab shape;
        :param `active`: whether the tab is selected or not.
        """

        xList = [pt.x for pt in tabPoints]
        yList = [pt.y for pt in tabPoints]
        
        minx, maxx = min(xList), max(xList)
        miny, maxy = min(yList), max(yList)

        rect = wx.Rect(minx, maxy, maxx-minx, miny-maxy+1)        
        region = wx.RegionFromPoints(tabPoints)

        if self._buttonRect.width > 0:
            buttonRegion = wx.Region(*self._buttonRect)
            region.XorRegion(buttonRegion)
        
        dc.SetClippingRegionAsRegion(region)

        if active:
            bottom_colour = top_colour = wx.WHITE
        else:
            bottom_colour = StepColour(self._base_colour, 90)
            top_colour = StepColour(self._base_colour, 170)

        dc.GradientFillLinear(rect, top_colour, bottom_colour, wx.SOUTH)
        dc.DestroyClippingRegion()
        

class ChromeTabArt(AuiDefaultTabArt):
    """
    A class to draw tabs using the Google Chrome browser style.
    It uses custom bitmap to render the tabs, so that the look and feel is as close
    as possible to the Chrome style.
    """

    def __init__(self):
        """ Default class constructor. """

        AuiDefaultTabArt.__init__(self)

        self.SetBitmaps(mirror=False)
        
        closeBmp = tab_close.GetBitmap()
        closeHBmp = tab_close_h.GetBitmap()
        closePBmp = tab_close_p.GetBitmap()

        self.SetCustomButton(AUI_BUTTON_CLOSE, AUI_BUTTON_STATE_NORMAL, closeBmp)
        self.SetCustomButton(AUI_BUTTON_CLOSE, AUI_BUTTON_STATE_HOVER, closeHBmp)
        self.SetCustomButton(AUI_BUTTON_CLOSE, AUI_BUTTON_STATE_PRESSED, closePBmp)
        

    def SetAGWFlags(self, agwFlags):
        """
        Sets the tab art flags.

        :param `agwFlags`: a combination of the following values:

         ==================================== ==================================
         Flag name                            Description
         ==================================== ==================================
         ``AUI_NB_TOP``                       With this style, tabs are drawn along the top of the notebook
         ``AUI_NB_LEFT``                      With this style, tabs are drawn along the left of the notebook. Not implemented yet.
         ``AUI_NB_RIGHT``                     With this style, tabs are drawn along the right of the notebook. Not implemented yet.
         ``AUI_NB_BOTTOM``                    With this style, tabs are drawn along the bottom of the notebook
         ``AUI_NB_TAB_SPLIT``                 Allows the tab control to be split by dragging a tab
         ``AUI_NB_TAB_MOVE``                  Allows a tab to be moved horizontally by dragging
         ``AUI_NB_TAB_EXTERNAL_MOVE``         Allows a tab to be moved to another tab control
         ``AUI_NB_TAB_FIXED_WIDTH``           With this style, all tabs have the same width
         ``AUI_NB_SCROLL_BUTTONS``            With this style, left and right scroll buttons are displayed
         ``AUI_NB_WINDOWLIST_BUTTON``         With this style, a drop-down list of windows is available
         ``AUI_NB_CLOSE_BUTTON``              With this style, a close button is available on the tab bar
         ``AUI_NB_CLOSE_ON_ACTIVE_TAB``       With this style, a close button is available on the active tab
         ``AUI_NB_CLOSE_ON_ALL_TABS``         With this style, a close button is available on all tabs
         ``AUI_NB_MIDDLE_CLICK_CLOSE``        Allows to close L{AuiNotebook} tabs by mouse middle button click
         ``AUI_NB_SUB_NOTEBOOK``              This style is used by L{AuiManager} to create automatic AuiNotebooks
         ``AUI_NB_HIDE_ON_SINGLE_TAB``        Hides the tab window if only one tab is present
         ``AUI_NB_SMART_TABS``                Use Smart Tabbing, like ``Alt`` + ``Tab`` on Windows
         ``AUI_NB_USE_IMAGES_DROPDOWN``       Uses images on dropdown window list menu instead of check items
         ``AUI_NB_CLOSE_ON_TAB_LEFT``         Draws the tab close button on the left instead of on the right (a la Camino browser)
         ``AUI_NB_TAB_FLOAT``                 Allows the floating of single tabs. Known limitation: when the notebook is more or less full screen, tabs cannot be dragged far enough outside of the notebook to become floating pages
         ``AUI_NB_DRAW_DND_TAB``              Draws an image representation of a tab while dragging (on by default)
         ==================================== ==================================

        :note: Overridden from L{AuiDefaultTabArt}.
        """

        if agwFlags & AUI_NB_TOP:
            self.SetBitmaps(mirror=False)
        elif agwFlags & AUI_NB_BOTTOM:
            self.SetBitmaps(mirror=True)

        AuiDefaultTabArt.SetAGWFlags(self, agwFlags)            


    def SetBitmaps(self, mirror):
        """
        Assigns the tab custom bitmaps

        :param `mirror`: whether to vertically mirror the bitmap or not.
        """

        bmps = [tab_active_left.GetBitmap(), tab_active_center.GetBitmap(),
                tab_active_right.GetBitmap(), tab_inactive_left.GetBitmap(),
                tab_inactive_center.GetBitmap(), tab_inactive_right.GetBitmap()]

        if mirror:
            for indx, bmp in enumerate(bmps):
                img = bmp.ConvertToImage()
                img = img.Mirror(horizontally=False)
                bmps[indx] = img.ConvertToBitmap()
                
        self._leftActiveBmp = bmps[0]
        self._centerActiveBmp = bmps[1]
        self._rightActiveBmp = bmps[2]
        self._leftInactiveBmp = bmps[3]
        self._centerInactiveBmp = bmps[4]
        self._rightInactiveBmp = bmps[5]
            

    def Clone(self):
        """ Clones the art object. """

        art = type(self)()
        art.SetNormalFont(self.GetNormalFont())
        art.SetSelectedFont(self.GetSelectedFont())
        art.SetMeasuringFont(self.GetMeasuringFont())

        art = CopyAttributes(art, self)
        return art


    def SetSizingInfo(self, tab_ctrl_size, tab_count, minMaxTabWidth):
        """
        Sets the tab sizing information.
        
        :param `tab_ctrl_size`: the size of the tab control area;
        :param `tab_count`: the number of tabs;
        :param `minMaxTabWidth`: a tuple containing the minimum and maximum tab widths
         to be used when the ``AUI_NB_TAB_FIXED_WIDTH`` style is active.
        """
        
        AuiDefaultTabArt.SetSizingInfo(self, tab_ctrl_size, tab_count, minMaxTabWidth)

        minTabWidth, maxTabWidth = minMaxTabWidth
        if minTabWidth > -1:
            self._fixed_tab_width = max(self._fixed_tab_width, minTabWidth)
        if maxTabWidth > -1:
            self._fixed_tab_width = min(self._fixed_tab_width, maxTabWidth)

        self._fixed_tab_width -= 5


    def GetTabSize(self, dc, wnd, caption, bitmap, active, close_button_state, control=None):
        """
        Returns the tab size for the given caption, bitmap and button state.

        :param `dc`: a `wx.DC` device context;
        :param `wnd`: a `wx.Window` instance object;
        :param `caption`: the tab text caption;
        :param `bitmap`: the bitmap displayed on the tab;
        :param `active`: whether the tab is selected or not;
        :param `close_button_state`: the state of the close button on the tab;
        :param `control`: a `wx.Window` instance inside a tab (or ``None``).
        """
        
        tab_size, x_extent = AuiDefaultTabArt.GetTabSize(self, dc, wnd, caption, bitmap,
                                                         active, close_button_state, control)

        tab_width, tab_height = tab_size        

        # add some padding
        tab_width += self._leftActiveBmp.GetWidth()
        tab_height += 2

        tab_height = max(tab_height, self._centerActiveBmp.GetHeight())        

        return (tab_width, tab_height), x_extent


    def DrawTab(self, dc, wnd, page, in_rect, close_button_state, paint_control=False):
        """
        Draws a single tab.

        :param `dc`: a `wx.DC` device context;
        :param `wnd`: a `wx.Window` instance object;
        :param `page`: the tab control page associated with the tab;
        :param `in_rect`: rectangle the tab should be confined to;
        :param `close_button_state`: the state of the close button on the tab;
        :param `paint_control`: whether to draw the control inside a tab (if any) on a `wx.MemoryDC`.
        """
        
        # Chrome tab style

        control = page.control
        # figure out the size of the tab
        tab_size, x_extent = self.GetTabSize(dc, wnd, page.caption, page.bitmap, page.active,
                                             close_button_state, control)

        agwFlags = self.GetAGWFlags()
        
        tab_height = self._tab_ctrl_height - 1
        tab_width = tab_size[0]
        tab_x = in_rect.x
        tab_y = in_rect.y + in_rect.height - tab_height
        clip_width = tab_width

        if tab_x + clip_width > in_rect.x + in_rect.width - 4:
            clip_width = (in_rect.x + in_rect.width) - tab_x - 4
            
        dc.SetClippingRegion(tab_x, tab_y, clip_width + 1, tab_height - 3)
        drawn_tab_yoff = 1

        if page.active:
            left = self._leftActiveBmp
            center = self._centerActiveBmp
            right = self._rightActiveBmp
        else:
            left = self._leftInactiveBmp
            center = self._centerInactiveBmp
            right = self._rightInactiveBmp

        dc.DrawBitmap(left, tab_x, tab_y)
        leftw = left.GetWidth()
        centerw = center.GetWidth()
        rightw = right.GetWidth()

        available = tab_x + tab_width - rightw
        posx = tab_x + leftw
        
        while 1:
            if posx >= available:
                break
            dc.DrawBitmap(center, posx, tab_y)
            posx += centerw

        dc.DrawBitmap(right, posx, tab_y)

        drawn_tab_height = center.GetHeight()
        text_offset = tab_x + leftw
        
        close_button_width = 0
        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
            close_button_width = self._active_close_bmp.GetWidth()
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
                text_offset += close_button_width

        if not page.enabled:
            dc.SetTextForeground(wx.SystemSettings.GetColour(wx.SYS_COLOUR_GRAYTEXT))
            pagebitmap = page.dis_bitmap
        else:
            dc.SetTextForeground(page.text_colour)
            pagebitmap = page.bitmap
        
        bitmap_offset = 0
        if pagebitmap.IsOk():
            bitmap_offset = tab_x + leftw
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT and close_button_width:
                bitmap_offset += close_button_width

            # draw bitmap
            dc.DrawBitmap(pagebitmap, bitmap_offset,
                          drawn_tab_yoff + (drawn_tab_height/2) - (pagebitmap.GetHeight()/2),
                          True)

            text_offset = bitmap_offset + pagebitmap.GetWidth()
            text_offset += 3 # bitmap padding
        
        else:
        
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT == 0 or not close_button_width:
                text_offset = tab_x + leftw
        
        # if the caption is empty, measure some temporary text
        caption = page.caption
        if caption == "":
            caption = "Xj"

        if page.active:
            dc.SetFont(self._selected_font)
            textx, texty, dummy = dc.GetMultiLineTextExtent(caption)
        else:
            dc.SetFont(self._normal_font)
            textx, texty, dummy = dc.GetMultiLineTextExtent(caption)

        if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
            draw_text = ChopText(dc, caption, tab_width - (text_offset-tab_x) - leftw)
        else:
            draw_text = ChopText(dc, caption, tab_width - (text_offset-tab_x) - close_button_width - leftw)

        ypos = drawn_tab_yoff + drawn_tab_height/2 - texty/2 - 1

        if control is not None:
            if control.GetPosition() != wx.Point(text_offset+1, ypos):
                control.SetPosition(wx.Point(text_offset+1, ypos))

            if not control.IsShown():
                control.Show()

            if paint_control:
                bmp = TakeScreenShot(control.GetScreenRect())
                dc.DrawBitmap(bmp, text_offset+1, ypos, True)
                
            controlW, controlH = control.GetSize()
            text_offset += controlW + 4

        # draw tab text
        rectx, recty, dummy = dc.GetMultiLineTextExtent(draw_text)
        dc.DrawLabel(draw_text, wx.Rect(text_offset, ypos, rectx, recty))
                
        out_button_rect = wx.Rect()
        # draw 'x' on tab (if enabled)
        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
        
            close_button_width = self._active_close_bmp.GetWidth()
            bmp = self._disabled_close_bmp

            if close_button_state == AUI_BUTTON_STATE_HOVER:
                bmp = self._hover_close_bmp
            elif close_button_state == AUI_BUTTON_STATE_PRESSED:
                bmp = self._pressed_close_bmp

            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
                rect = wx.Rect(tab_x + leftw - 2,
                               drawn_tab_yoff + (drawn_tab_height / 2) - (bmp.GetHeight() / 2) + 1,
                               close_button_width, tab_height)
            else:
                rect = wx.Rect(tab_x + tab_width - close_button_width - rightw + 2,
                               drawn_tab_yoff + (drawn_tab_height / 2) - (bmp.GetHeight() / 2) + 1,
                               close_button_width, tab_height)

            if agwFlags & AUI_NB_BOTTOM:
                rect.y -= 1
                
            # Indent the button if it is pressed down:
            rect = IndentPressedBitmap(rect, close_button_state)
            dc.DrawBitmap(bmp, rect.x, rect.y, True)
            out_button_rect = rect
            
        out_tab_rect = wx.Rect(tab_x, tab_y, tab_width, tab_height)
        dc.DestroyClippingRegion()

        return out_tab_rect, out_button_rect, x_extent        



########NEW FILE########
__FILENAME__ = tabmdi
__author__ = "Andrea Gavana <andrea.gavana@gmail.com>"
__date__ = "31 March 2009"


import wx

import auibook
from aui_constants import *

_ = wx.GetTranslation

#-----------------------------------------------------------------------------
# AuiMDIParentFrame
#-----------------------------------------------------------------------------

class AuiMDIParentFrame(wx.Frame):

    def __init__(self, parent, id=wx.ID_ANY, title="", pos=wx.DefaultPosition,
                 size=wx.DefaultSize, style=wx.DEFAULT_FRAME_STYLE|wx.VSCROLL|wx.HSCROLL,
                 name="AuiMDIParentFrame"):

        wx.Frame.__init__(self, parent, id, title, pos, size, style, name=name)
        self.Init()

        self.Bind(wx.EVT_MENU, self.DoHandleMenu, id=wx.ID_ANY)

        # this style can be used to prevent a window from having the standard MDI
        # "Window" menu
        if not style & wx.FRAME_NO_WINDOW_MENU:
        
            self._pWindowMenu = wx.Menu()
            self._pWindowMenu.Append(wxWINDOWCLOSE,    _("Cl&ose"))
            self._pWindowMenu.Append(wxWINDOWCLOSEALL, _("Close All"))
            self._pWindowMenu.AppendSeparator()
            self._pWindowMenu.Append(wxWINDOWNEXT,     _("&Next"))
            self._pWindowMenu.Append(wxWINDOWPREV,     _("&Previous"))
    
        self._pClientWindow = self.OnCreateClient()


    def SetArtProvider(self, provider):

        if self._pClientWindow:
            self._pClientWindow.SetArtProvider(provider)
    

    def GetArtProvider(self):

        if not self._pClientWindow:
            return None

        return self._pClientWindow.GetArtProvider()


    def GetNotebook(self):

        return self._pClientWindow


    def SetWindowMenu(self, pMenu):

        # Replace the window menu from the currently loaded menu bar.
        pMenuBar = self.GetMenuBar()

        if self._pWindowMenu:
            self.RemoveWindowMenu(pMenuBar)
            del self._pWindowMenu
            self._pWindowMenu = None

        if pMenu:
            self._pWindowMenu = pMenu
            self.AddWindowMenu(pMenuBar)
        

    def GetWindowMenu(self):

        return self._pWindowMenu
    

    def SetMenuBar(self, pMenuBar):

        # Remove the Window menu from the old menu bar
        self.RemoveWindowMenu(self.GetMenuBar())

        # Add the Window menu to the new menu bar.
        self.AddWindowMenu(pMenuBar)

        wx.Frame.SetMenuBar(self, pMenuBar)


    def SetChildMenuBar(self, pChild):

        if not pChild:
        
            # No Child, set Our menu bar back.
            if self._pMyMenuBar:
                self.SetMenuBar(self._pMyMenuBar)
            else:
                self.SetMenuBar(self.GetMenuBar())

            # Make sure we know our menu bar is in use
            self._pMyMenuBar = None
        
        else:
        
            if pChild.GetMenuBar() == None:
                return

            # Do we need to save the current bar?
            if self._pMyMenuBar == None:
                self._pMyMenuBar = self.GetMenuBar()

            self.SetMenuBar(pChild.GetMenuBar())
    

    def ProcessEvent(self, event):

        # stops the same event being processed repeatedly
        if self._pLastEvt == event:
            return False
        
        self._pLastEvt = event

        # let the active child (if any) process the event first.
        res = False
        if self._pActiveChild and event.IsCommandEvent() and \
           event.GetEventObject() != self._pClientWindow and \
           event.GetEventType() not in [wx.wxEVT_ACTIVATE, wx.wxEVT_SET_FOCUS,
                                        wx.wxEVT_KILL_FOCUS, wx.wxEVT_CHILD_FOCUS,
                                        wx.wxEVT_COMMAND_SET_FOCUS, wx.wxEVT_COMMAND_KILL_FOCUS]:
        
            res = self._pActiveChild.GetEventHandler().ProcessEvent(event)
        
        if not res:
        
            # if the event was not handled this frame will handle it,
            # which is why we need the protection code at the beginning
            # of this method
            res = self.GetEventHandler().ProcessEvent(event)
        
        self._pLastEvt = None

        return res


    def GetActiveChild(self):

        return self._pActiveChild


    def SetActiveChild(self, pChildFrame):

        self._pActiveChild = pChildFrame


    def GetClientWindow(self):

        return self._pClientWindow


    def OnCreateClient(self):

        return AuiMDIClientWindow(self)


    def ActivateNext(self):

        if self._pClientWindow and self._pClientWindow.GetSelection() != wx.NOT_FOUND:
        
            active = self._pClientWindow.GetSelection() + 1
            if active >= self._pClientWindow.GetPageCount():
                active = 0

            self._pClientWindow.SetSelection(active)
        

    def ActivatePrevious(self):

        if self._pClientWindow and self._pClientWindow.GetSelection() != wx.NOT_FOUND:
        
            active = self._pClientWindow.GetSelection() - 1
            if active < 0:
                active = self._pClientWindow.GetPageCount() - 1

            self._pClientWindow.SetSelection(active)
    

    def Init(self):

        self._pLastEvt = None

        self._pClientWindow = None
        self._pActiveChild = None
        self._pWindowMenu = None
        self._pMyMenuBar = None


    def RemoveWindowMenu(self, pMenuBar):

        if pMenuBar and self._pWindowMenu:
        
            # Remove old window menu
            pos = pMenuBar.FindMenu(_("&Window"))
            if pos != wx.NOT_FOUND:            
                pMenuBar.Remove(pos)
            

    def AddWindowMenu(self, pMenuBar):

        if pMenuBar and self._pWindowMenu:
        
            pos = pMenuBar.FindMenu(wx.GetStockLabel(wx.ID_HELP, wx.STOCK_NOFLAGS))
            if pos == wx.NOT_FOUND:
                pMenuBar.Append(self._pWindowMenu, _("&Window"))
            else:
                pMenuBar.Insert(pos, self._pWindowMenu, _("&Window"))
    

    def DoHandleMenu(self, event):

        evId = event.GetId()
        
        if evId == wxWINDOWCLOSE:
            if self._pActiveChild:
                self._pActiveChild.Close()

        elif evId == wxWINDOWCLOSEALL:
            
            while self._pActiveChild:            
                if not self._pActiveChild.Close():
                    return # failure
                
        elif evId == wxWINDOWNEXT:
            self.ActivateNext()

        elif evId == wxWINDOWPREV:
            self.ActivatePrevious()

        else:
            event.Skip()

    
    def Tile(self, orient=wx.HORIZONTAL):

        client_window = self.GetClientWindow()
        if not client_window:
            raise Exception("Missing MDI Client Window")

        cur_idx = client_window.GetSelection()
        if cur_idx == -1:
            return

        if orient == wx.VERTICAL:
        
            client_window.Split(cur_idx, wx.LEFT)
        
        elif orient == wx.HORIZONTAL:
        
            client_window.Split(cur_idx, wx.TOP)
    

#-----------------------------------------------------------------------------
# AuiMDIChildFrame
#-----------------------------------------------------------------------------

class AuiMDIChildFrame(wx.PyPanel):

    def __init__(self, parent, id=wx.ID_ANY, title="", pos=wx.DefaultPosition,
                 size=wx.DefaultSize, style=wx.DEFAULT_FRAME_STYLE, name="AuiMDIChildFrame"):

        pClientWindow = parent.GetClientWindow()
        if pClientWindow is None:
            raise Exception("Missing MDI client window.")

        self.Init()
        
        # see comment in constructor
        if style & wx.MINIMIZE:
            self._activate_on_create = False

        cli_size = pClientWindow.GetClientSize()

        # create the window off-screen to prevent flicker
        wx.PyPanel.__init__(self, pClientWindow, id, wx.Point(cli_size.x+1, cli_size.y+1),
                            size, wx.NO_BORDER, name=name)

        self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM)
        self.Show(False)
        self.SetMDIParentFrame(parent)

        # this is the currently active child
        parent.SetActiveChild(self)
        self._title = title

        pClientWindow.AddPage(self, title, self._activate_on_create)
        pClientWindow.Refresh()

        self.Bind(wx.EVT_MENU_HIGHLIGHT_ALL, self.OnMenuHighlight)
        self.Bind(wx.EVT_ACTIVATE, self.OnActivate)
        self.Bind(wx.EVT_CLOSE, self.OnCloseWindow)


    def Init(self):

        # There are two ways to create an tabbed mdi child fram without
        # making it the active document.  Either Show(False) can be called
        # before Create() (as is customary on some ports with wxFrame-type
        # windows), or wx.MINIMIZE can be passed in the style flags.  Note that
        # AuiMDIChildFrame is not really derived from wxFrame, as MDIChildFrame
        # is, but those are the expected symantics.  No style flag is passed
        # onto the panel underneath.

        self._activate_on_create = True

        self._pMDIParentFrame = None
        self._pMenuBar = None
        
        self._mdi_currect = None
        self._mdi_newrect = wx.Rect()
        self._icon = None
        self._icon_bundle = None


    def Destroy(self):

        pParentFrame = self.GetMDIParentFrame()
        if not pParentFrame:
            raise Exception("Missing MDI Parent Frame")

        pClientWindow = pParentFrame.GetClientWindow()
        if not pClientWindow:
            raise Exception("Missing MDI Client Window")

        if pParentFrame.GetActiveChild() == self:
        
            # deactivate ourself
            event = wx.ActivateEvent(wx.wxEVT_ACTIVATE, False, self.GetId())
            event.SetEventObject(self)
            self.GetEventHandler().ProcessEvent(event)

            pParentFrame.SetActiveChild(None)
            pParentFrame.SetChildMenuBar(None)
        
        for pos in xrange(pClientWindow.GetPageCount()):
            if pClientWindow.GetPage(pos) == self:
                return pClientWindow.DeletePage(pos)

        return False


    def SetMenuBar(self, menu_bar):

        pOldMenuBar = self._pMenuBar
        self._pMenuBar = menu_bar

        if self._pMenuBar:
        
            pParentFrame = self.GetMDIParentFrame()
            if not pParentFrame:
                raise Exception("Missing MDI Parent Frame")

            self._pMenuBar.Reparent(pParentFrame)
            if pParentFrame.GetActiveChild() == self:
            
                # replace current menu bars
                if pOldMenuBar:
                    pParentFrame.SetChildMenuBar(None)
                    
                pParentFrame.SetChildMenuBar(self)
            

    def GetMenuBar(self):

        return self._pMenuBar


    def SetTitle(self, title):

        self._title = title

        pParentFrame = self.GetMDIParentFrame()
        if not pParentFrame:
            raise Exception("Missing MDI Parent Frame")
        
        pClientWindow = pParentFrame.GetClientWindow()
        if pClientWindow is not None:
        
            for pos in xrange(pClientWindow.GetPageCount()):
                if pClientWindow.GetPage(pos) == self:
                    pClientWindow.SetPageText(pos, self._title)
                    break


    def GetTitle(self):

        return self._title


    def SetIcons(self, icons):

        # get icon with the system icon size
        self.SetIcon(icons.GetIcon(-1))
        self._icon_bundle = icons


    def GetIcons(self):

        return self._icon_bundle


    def SetIcon(self, icon):

        pParentFrame = self.GetMDIParentFrame()
        if not pParentFrame:
            raise Exception("Missing MDI Parent Frame")

        self._icon = icon

        bmp = wx.BitmapFromIcon(self._icon)

        pClientWindow = pParentFrame.GetClientWindow()
        if pClientWindow is not None:
            idx = pClientWindow.GetPageIndex(self)
            if idx != -1:
                pClientWindow.SetPageBitmap(idx, bmp)
        

    def GetIcon(self):

        return self._icon


    def Activate(self):

        pParentFrame = self.GetMDIParentFrame()
        if not pParentFrame:
            raise Exception("Missing MDI Parent Frame")
        
        pClientWindow = pParentFrame.GetClientWindow()
        if pClientWindow is not None:
        
            for pos in xrange(pClientWindow.GetPageCount()):
                if pClientWindow.GetPage(pos) == self:
                    pClientWindow.SetSelection(pos)
                    break
            

    def OnMenuHighlight(self, event):

        if self._pMDIParentFrame:
    
            # we don't have any help text for this item,
            # but may be the MDI frame does?
            self._pMDIParentFrame.OnMenuHighlight(event)


    def OnActivate(self, event):

        # do nothing
        pass


    def OnCloseWindow(self, event):

        pParentFrame = self.GetMDIParentFrame()
        if pParentFrame:
            if pParentFrame.GetActiveChild() == self:
            
                pParentFrame.SetActiveChild(None)
                pParentFrame.SetChildMenuBar(None)
            
            pClientWindow = pParentFrame.GetClientWindow()
            idx = pClientWindow.GetPageIndex(self)
            
            if idx != wx.NOT_FOUND:
                pClientWindow.RemovePage(idx)

        self.Destroy()


    def SetMDIParentFrame(self, parentFrame):

        self._pMDIParentFrame = parentFrame


    def GetMDIParentFrame(self):

        return self._pMDIParentFrame


    def CreateStatusBar(self, number=1, style=1, winid=1, name=""):
        
        return None


    def GetStatusBar(self):

        return None
    

    def SetStatusText(self, text, number=0):

        pass

    
    def SetStatusWidths(self, widths_field):

        pass
    

    # no toolbar bars
    def CreateToolBar(self, style=1, winid=-1, name=""):
        
        return None

    
    def GetToolBar(self):

        return None
    

    # no maximize etc
    def Maximize(self, maximize=True):

        pass


    def Restore(self):
    
        pass

    
    def Iconize(self, iconize=True):

        pass

    
    def IsMaximized(self):

        return True

    
    def IsIconized(self):

        return False

    
    def ShowFullScreen(self, show=True, style=0):

        return False

    
    def IsFullScreen(self):

        return False        


    def IsTopLevel(self):

        return False


    # renamed from Show().
    def ActivateOnCreate(self, activate_on_create):

        self._activate_on_create = activate_on_create
        return True

    
    def Show(self, show=True):

        wx.PyPanel.Show(self, show)


    def ApplyMDIChildFrameRect(self):

        if self._mdi_currect != self._mdi_newrect:
            self.SetDimensions(*self._mdi_newrect)
            self._mdi_currect = wx.Rect(*self._mdi_newrect)


#-----------------------------------------------------------------------------
# AuiMDIClientWindow
#-----------------------------------------------------------------------------

class AuiMDIClientWindow(auibook.AuiNotebook):

    def __init__(self, parent, agwStyle=0):

        auibook.AuiNotebook.__init__(self, parent, wx.ID_ANY, wx.Point(0, 0), wx.Size(100, 100),
                                     agwStyle=AUI_NB_DEFAULT_STYLE|wx.NO_BORDER)

        caption_icon_size = wx.Size(wx.SystemSettings.GetMetric(wx.SYS_SMALLICON_X),
                                    wx.SystemSettings.GetMetric(wx.SYS_SMALLICON_Y))
        self.SetUniformBitmapSize(caption_icon_size)

        bkcolour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_APPWORKSPACE)
        self.SetOwnBackgroundColour(bkcolour)

        self._mgr.GetArtProvider().SetColour(AUI_DOCKART_BACKGROUND_COLOUR, bkcolour)

        self.Bind(auibook.EVT_AUINOTEBOOK_PAGE_CHANGED, self.OnPageChanged)
        self.Bind(auibook.EVT_AUINOTEBOOK_PAGE_CLOSE, self.OnPageClose)
        self.Bind(wx.EVT_SIZE, self.OnSize)


    def SetSelection(self, nPage):

        return auibook.AuiNotebook.SetSelection(self, nPage)


    def PageChanged(self, old_selection, new_selection):

        # don't do anything if the page doesn't actually change
        if old_selection == new_selection:
            return

        # notify old active child that it has been deactivated
        if old_selection != -1 and old_selection < self.GetPageCount():
        
            old_child = self.GetPage(old_selection)
            if not old_child:
                raise Exception("AuiMDIClientWindow.PageChanged - null page pointer")

            event = wx.ActivateEvent(wx.wxEVT_ACTIVATE, False, old_child.GetId())
            event.SetEventObject(old_child)
            old_child.GetEventHandler().ProcessEvent(event)
        
        # notify new active child that it has been activated
        if new_selection != -1:
        
            active_child = self.GetPage(new_selection)
            if not active_child:
                raise Exception("AuiMDIClientWindow.PageChanged - null page pointer")

            event = wx.ActivateEvent(wx.wxEVT_ACTIVATE, True, active_child.GetId())
            event.SetEventObject(active_child)
            active_child.GetEventHandler().ProcessEvent(event)

            if active_child.GetMDIParentFrame():
                active_child.GetMDIParentFrame().SetActiveChild(active_child)
                active_child.GetMDIParentFrame().SetChildMenuBar(active_child)


    def OnPageClose(self, event):

        wnd = self.GetPage(event.GetSelection())
        wnd.Close()

        # regardless of the result of wnd.Close(), we've
        # already taken care of the close operations, so
        # suppress further processing
        event.Veto()


    def OnPageChanged(self, event):

        self.PageChanged(event.GetOldSelection(), event.GetSelection())


    def OnSize(self, event):

        auibook.AuiNotebook.OnSize(self, event)

        for pos in xrange(self.GetPageCount()):
            self.GetPage(pos).ApplyMDIChildFrameRect()

########NEW FILE########
__FILENAME__ = thread_timer
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `ThreadTimer` class.

See its documentation for more info.
'''
# todo: daemonize?
# todo: kickass idea: make all timers use one thread that will sleep smartly
# to send all events correctly.

import threading
import time

import wx

from garlicsim_wx.general_misc import cute_base_timer


wxEVT_THREAD_TIMER = wx.NewEventType()
EVT_THREAD_TIMER = wx.PyEventBinder(wxEVT_THREAD_TIMER, 1)
'''Event saying that a `ThreadTimer` has fired.'''


class ThreadTimer(cute_base_timer.CuteBaseTimer):
   '''
   A timer for a wxPython app which runs on a different thread.
   
   This solved a problem of wxPython timers being late when the program is
   busy.
   '''
   
   n = 0
   '''The number of created thread timers.'''
   
   
   def __init__(self, parent):
      '''
      Construct the ThreadTimer.
      
      `parent` is the parent window.
      '''
      
      cute_base_timer.CuteBaseTimer.__init__(self, parent)
      
      self.parent = parent
      '''The parent window.'''
      
      ThreadTimer.n += 1
      self.wx_id = wx.NewId()
      '''The ID of this timer, given by wxPython.'''
      
      self.__init_thread()
      self.alive = False
      '''Flag saying whether this timer is running.'''

   def __init_thread(self):
      '''Create the thread.'''
      thread_name = ''.join(('Thread used by ThreadTimer no. ', str(self.n)))
      self.thread = Thread(self, name=thread_name)
      # Overwriting previous thread, so it'll get garbage-collected, hopefully
   
   def start(self, interval):
      '''Start the timer.'''
      if self.alive:
         self.stop()
      self.interval = interval
      self.alive = True
      self.thread.start()

   def stop(self):
      '''Stop the timer.'''
      self.alive = False
      self.thread.retired = True
      self.__init_thread()
   
   # Crutch for compatibilty with wx.Timer:
   Start = start
   Stop = stop
      
   def GetId(self):
      '''Get the wx ID of this timer.'''
      return self.wx_id

      
class Thread(threading.Thread):
   '''Thread used as a timer for wxPython programs.'''
   def __init__(self, parent, name):
      threading.Thread.__init__(self, name=name)
      self.parent = parent
      self.retired = False
      
   def run(self):
      '''Run the thread. Internal function.'''
      interval_in_seconds = self.parent.interval / 1000.0
      def sleep():
            time.sleep(interval_in_seconds)

      sleep()
      try:
         while self.parent.alive is True and self.retired is False:
            event = wx.PyEvent(self.parent.wx_id)
            event.SetEventType(wxEVT_THREAD_TIMER)
            wx.PostEvent(self.parent.parent, event)
            sleep()
      except:
         return # Just so it wouldn't raise an error when wx is shutting down
########NEW FILE########
__FILENAME__ = vectorish
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This is a terrible little module for manipulating tuples of two items as 2d
vectors.
'''

import math

def add(vec1, vec2):
    return tuple((vec1[i] + vec2[i]) for i in xrange(len(vec1)))

def mult(scal, vec1):
    return tuple(vec1[i] * scal for i in xrange(len(vec1)))

def average(vec1, vec2):
    return mult(0.5, add(vec1, vec2))

########NEW FILE########
__FILENAME__ = wx_tools
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Defines various tools for wxPython.'''

from __future__ import division

import warnings
import colorsys

import wx

from garlicsim.general_misc import caching
from garlicsim.general_misc.context_manager import ContextManager
from garlicsim_wx.general_misc import color_tools


@caching.cache()
def get_background_color():
    '''Get the default `garlicsim_wx` background color'''
    
    if wx.Platform == '__WXMSW__':
        # return wx.Colour(212, 208, 200)
        return wx.SystemSettings.GetColour(wx.SYS_COLOUR_MENUBAR)
    elif wx.Platform == '__WXMAC__':
        return wx.Colour(232, 232, 232)
    elif wx.Platform == '__WXGTK__':
        # Until `SYS_COLOUR_*` get their act togother, we're using Windows
        # colors for Linux.
        return wx.Colour(212, 208, 200)
    
    else:
        warnings.warn("Unidentified platform! It's neither '__WXGTK__', "
                      "'__WXMAC__' nor '__WXMSW__'. Things might not work "
                      "properly.")
        return wx.Colour(212, 208, 200)


@caching.cache()
def get_background_brush():
    '''Get the default garlicsim_wx background brush.'''
    return wx.Brush(get_background_color())


def wx_color_to_html_color(wx_color):
    '''Convert a wxPython color to an HTML color string.'''
    rgb = wx_color.GetRGB()
    (green_blue, red) = divmod(rgb, 256)
    (blue, green) = divmod(green_blue, 256)
    return '#%02x%02x%02x' % (red, green, blue)


def hls_to_wx_color(hls, alpha=255):
    '''Convert an HLS color to a wxPython color.'''
    return rgb_to_wx_color(colorsys.hls_to_rgb(*hls), alpha=alpha)


def wx_color_to_hls(wx_color):
    '''Convert a wxPython color to an HLS color.'''
    return colorsys.rgb_to_hls(wx_color.red, wx_color.blue, wx_color.green)


def rgb_to_wx_color(rgb, alpha=255):
    '''Convert an RGB color to a wxPython color.'''
    r, g, b = rgb
    return wx.Colour(r * 255, g * 255, b * 255, alpha)


def wx_color_to_rgb(wx_color):
    '''Convert a wxPython color to an RGB color.'''
    return (
        wx_color.red / 255,
        wx_color.blue / 255,
        wx_color.green / 255
    )


def wx_color_to_big_rgb(wx_color):
    '''Convert a wxPython color to a big (i.e. `int`) RGB color.'''
    return (
        wx_color.red,
        wx_color.green,
        wx_color.blue
    )


def mix_wx_color(ratio, color1, color2):
    '''Mix two wxPython colors according to the given `ratio`.'''
    rgb = color_tools.mix_rgb(
        ratio,
        wx_color_to_rgb(color1),
        wx_color_to_rgb(color2)
    )
    return rgb_to_wx_color(rgb)


def post_event(evt_handler, event_binder, source=None, **kwargs):
    '''Post an event to an evt_handler.'''
    # todo: Use wherever I post events    
    # todo: possibly it's a problem that I'm using PyEvent here for any type of
    # event, because every event has its own type. but i don't know how to get
    # the event type from `event_binder`. problem.
    event = wx.PyCommandEvent(event_binder.evtType[0],
                              source.GetId() if source else 0)
    for key, value in kwargs.iteritems():
        setattr(event, key, value)
    event.SetEventType(event_binder.evtType[0])
    wx.PostEvent(evt_handler, event)
    
    
class Key(object):    
    '''A key combination.'''

    def __init__(self, key_code, cmd=False, alt=False, shift=False):

        self.key_code = key_code        
        '''The numerical code of the pressed key.'''
        
        self.cmd = cmd
        '''Flag saying whether the ctrl/cmd key was pressed.'''
        
        self.alt = alt
        '''Flag saying whether the alt key was pressed.'''
        
        self.shift = shift
        '''Flag saying whether the shift key was pressed.'''
        
        
    @staticmethod
    def get_from_key_event(event):
        '''Construct a Key from a wx.EVT_KEY_DOWN event.'''
        return Key(event.GetKeyCode(), event.CmdDown(),
                   event.AltDown(), event.ShiftDown())
    
    def __hash__(self):
        return hash(tuple(sorted(tuple(vars(self)))))
    
    def __eq__(self, other):
        if not isinstance(other, Key):
            return NotImplemented
        return self.key_code == other.key_code and \
               self.cmd == other.cmd and \
               self.shift == other.shift and \
               self.alt == other.alt
        
menu_keys = [Key(wx.WXK_MENU), Key(wx.WXK_WINDOWS_MENU),
             Key(wx.WXK_F10, shift=True)]
'''Keys used for raising a context menu.'''


def navigate_from_key_event(key_event):
    '''
    Figure out if `key_event` is a navigation button press, if so navigate.
    
    Returns whether there was navigation action or not.
    '''
    key = Key.get_from_key_event(key_event)
    
    if key in [Key(wx.WXK_TAB), Key(wx.WXK_TAB, shift=True),
               Key(wx.WXK_TAB, cmd=True),
               Key(wx.WXK_TAB, cmd=True, shift=True)]:
        
        window = key_event.GetEventObject()
        
        flags = 0
        
        if key.shift:
            flags |= wx.NavigationKeyEvent.IsBackward
        else: # not key.shift
            flags |= wx.NavigationKeyEvent.IsForward
        
        if key.cmd:
            flags |= wx.NavigationKeyEvent.WinChange
        
        
        current_window = window
        while not current_window.Parent.HasFlag(wx.TAB_TRAVERSAL):
            current_window = current_window.Parent
        current_window.Navigate(flags)
        return True
    
    else:
        return False
            

    
def iter_rects_of_region(region):
    '''Iterate over the rects of a region.'''
    i = wx.RegionIterator(region)
    while i.HaveRects():
        yield i.GetRect()
        i.Next()
        


def color_replaced_bitmap(bitmap, old_rgb, new_rgb):
    '''Replace all appearances of `old_rgb` with `new_rgb` in `bitmap`.'''
    old_r, old_g, old_b = old_rgb
    new_r, new_g, new_b = new_rgb
    image = wx.ImageFromBitmap(bitmap)
    assert isinstance(image, wx.Image)
    image.Replace(old_r, old_g, old_b, new_r, new_g, new_b)
    return wx.BitmapFromImage(image)
    

class WindowFreezer(ContextManager):
    '''Context manager for having `window` frozen while the suite executes.'''
    def __init__(self, window):
        assert isinstance(window, wx.Window)
        self.window = window
    def __enter__(self):
        self.window.Freeze()
    def __exit__(self, *args, **kwargs):
        self.window.Thaw()
        
        
class CursorChanger(ContextManager):
    '''Context manager for showing specified cursor while suite executes.'''
    def __init__(self, window, cursor):
        '''
        Construct the `CursorChanger`.
        
        `cursor` may be either a `wx.Cursor` object or a constant like
        `wx.CURSOR_BULLSEYE`.
        '''
        assert isinstance(window, wx.Window)
        self.window = window
        self.cursor = cursor if isinstance(cursor, wx.Cursor) \
            else wx.StockCursor(cursor)
        self.old_cursor = window.GetCursor()
    def __enter__(self):
        self.window.SetCursor(self.cursor)
    def __exit__(self, *args, **kwargs):
        self.window.SetCursor(self.old_cursor)
        
########NEW FILE########
__FILENAME__ = gui_project
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `GuiProject` class.

See its documentation for more info.
'''

from __future__ import with_statement

import time

import wx

from .general_misc.stringsaver import s2i, i2s
from garlicsim.general_misc.infinity import infinity
from garlicsim.general_misc import binary_search
from garlicsim.general_misc import import_tools
from garlicsim_wx.general_misc.emitting_ordered_set import EmittingOrderedSet
from garlicsim_wx.general_misc.emitting_weak_key_default_dict import \
     EmittingWeakKeyDefaultDict
from garlicsim_wx.misc.step_profile_hue_default_factory import \
     StepProfileHueDefaultFactory
from garlicsim_wx.general_misc import thread_timer

import garlicsim
from garlicsim.asynchronous_crunching import crunchers
import garlicsim_wx
from garlicsim_wx.general_misc import emitters
        

class GuiProject(object):
    '''Encapsulates a project for use with a wxPython interface.'''
    
    def __init__(self, simpack, frame, project=None):
        '''
        Construct the gui project.
        
        `simpack` is the simpack (or grokker) to use. `frame` is the frame in
        which this gui project will live.
        '''
        # This is broken down into a few parts.
        self.__init_general(simpack, frame, project)
        self.__init_gui()
        if not self.project.tree.roots:
            wx.CallAfter(self.make_state_creation_dialog)

            
    def __init_general(self, simpack, frame, project=None):
        '''General initialization.'''
        
        self.frame = frame
        '''The frame that this gui project lives in.'''
        
        assert isinstance(self.frame, garlicsim_wx.Frame)
        
        if isinstance(simpack, garlicsim.misc.SimpackGrokker):
            simpack_grokker = simpack            
            simpack = simpack_grokker.simpack
        else:
            simpack_grokker = garlicsim.misc.SimpackGrokker(simpack)
            
            
        self.simpack = simpack
        '''The simpack used for this gui project.'''
        
        self.simpack_grokker = simpack_grokker
        '''The simpack grokker used for this gui project.'''
        
        self.simpack_wx_grokker = garlicsim_wx.misc.SimpackWxGrokker(simpack)
        '''The simpack_wx used for this gui project.'''
        
        self.project = project or garlicsim.Project(simpack_grokker)
        '''The project encapsulated in this gui project.'''
        
        assert isinstance(self.project, garlicsim.Project)
        

        ### If it's a new project, use `ProcessCruncher` if available: ########
        #                                                                     #
        
        if (not project): # Note this is the project given as an argument
            if (crunchers.ProcessCruncher in 
                simpack_grokker.available_cruncher_types):
                
                self.project.crunching_manager.cruncher_type = \
                    crunchers.ProcessCruncher
        #                                                                     #
        #######################################################################
            
        self.path = None
        '''The active path.'''

        self.active_node = None
        '''The node that is currently displayed onscreen.'''

        self.is_playing = False
        '''Says whether the simulation is currently playing.'''
        
        self.infinity_job = None
        '''
        The job of the playing leaf, which should be crunched to infinity.
        '''
        
        self.default_buffer = 100
        '''
        The default clock buffer to crunch from an active node.

        For the user it is called "Autocrunch".
        '''
        
        self._default_buffer_before_cancellation = None
        '''
        The value of the default buffer before buffering was cancelled.

        When buffering will be enabled again, it will be set to this value.
        '''

        self.timer_for_playing = thread_timer.ThreadTimer(self.frame)
        '''Contains the timer object used when playing the simulation.'''
        
        self.frame.Bind(thread_timer.EVT_THREAD_TIMER, self.__play_next,
                        self.timer_for_playing)

        self.defacto_playing_speed = 4
        '''The playing speed that we are actually playing in.'''
        
        self.official_playing_speed = 4
        '''
        The playing speed that we're "officially" playing in.
        
        The defacto playing speed may deviate from this.
        '''
        
        self.standard_playing_speed = 4
        '''The reference playing speed. This speed is considered "normal".'''
        
        self.last_tracked_real_time = None
        '''
        The last tracked time point (real time, not simulation), for playback.
        '''
        
        self.pseudoclock = 0
        '''
        The current pseudoclock.
        
        The pseudoclock is *something like* the clock of the current active
        node. But not exactly. We're letting the pseudoclock slide more
        smoothly from one node to its neighbor, instead of jumping. This is in
        order to make some things smoother in the program. This is also why
        it's called "pseudo".
        '''
        
        self.default_step_profile = garlicsim.misc.StepProfile(
            self.simpack_grokker.default_step_function
        )
        '''The step profile that will be used be default.'''
        
        self.step_profiles = EmittingOrderedSet(
            emitter=None,
            items=(self.default_step_profile,)
        )
        '''An ordered set of step profiles that the user may use.'''
        
        self.step_profiles_to_hues = EmittingWeakKeyDefaultDict(
            emitter=None,
            default_factory=StepProfileHueDefaultFactory(self),
        )
        '''Mapping from step profile to hue that represents it in GUI.'''
        
        self._tracked_step_profile = None
        self._temp_shell_history = None
        self._temp_shell_command_history = None
        self._job_and_node_of_recent_fork_by_crunching = None
        
        ### Setting up namespace: #############################################
        #                                                                     #
        
        self.namespace = {
            
            '__name__': '__garlicsim_shell__',
            # This will become `.__module__` of classes and functions.
            
            'f': frame, 'frame': frame,
            'gp': self, 'gui_project': self,
            'p': self.project, 'project': self.project,
            't': self.project.tree, 'tree': self.project.tree,
            'gs': garlicsim, 'garlicsim': garlicsim,
            'gs_wx': garlicsim_wx, 'garlicsim_wx': garlicsim_wx,
            'wx': wx,
            'simpack': self.simpack,
            self.simpack.__name__.rsplit('.', 1)[-1]: self.simpack,
        }
        '''Namespace that will be used in shell and other places.'''
        
        garlicsim_lib = import_tools.import_if_exists('garlicsim_lib',
                                                      silent_fail=True)
        if garlicsim_lib:
            self.namespace.update({
                'gs_lib': garlicsim_lib,
                'garlicsim_lib': garlicsim_lib,
            })
        
        #                                                                     #
        ### Finished setting up namespace. ####################################
        
            
        self.__init_emitters()
        self.__init_menu_enablings()
        
        self.emitter_system.top_emitter.emit()
        # Just for good measure, jiggle all the widgets up.
        
        
    def __init_emitters(self):
        '''Create an emitter system and a bunch of emitters.'''
        
        # todo: not clear that `tree_modified_emitter` means that only data
        # changed and not structure.
        
        self.emitter_system = emitters.EmitterSystem()
                
        with self.emitter_system.freeze_cache_rebuilding:
        
            es = self.emitter_system
            
            self.tree_modified_emitter = es.make_emitter(
                name='tree_modified',
            )
            self.tree_modified_on_path_emitter = es.make_emitter(
                outputs=(self.tree_modified_emitter,),
                name='tree_modified_on_path',
            )
    
            self.tree_modified_not_on_path = es.make_emitter(
                outputs=(self.tree_modified_emitter,),
                name='tree_modified_not_on_path',
            )
            
            self.tree_modified_at_unknown_location_emitter = es.make_emitter(
                outputs=(
                    self.tree_modified_on_path_emitter,
                    self.tree_modified_not_on_path,
                ),
                name='tree_modified_at_unknown_location',
            )
            
            self.tree_structure_modified_emitter = es.make_emitter(
                outputs=(
                    self.tree_modified_emitter,
                    self._update_step_profiles_set,
                    self._if_forked_by_crunching_recently_switch_to_new_path,
                    ),
                name='tree_structure_modified',
            )
            
            self.tree_structure_modified_on_path_emitter = es.make_emitter(
                outputs=(
                    self.tree_modified_on_path_emitter,
                    self.tree_structure_modified_emitter
                ),
                name='tree_structure_modified_on_path',
            )
            self.tree_structure_modified_not_on_path_emitter = es.make_emitter(
                outputs=(
                    self.tree_modified_not_on_path,
                    self.tree_structure_modified_emitter
                ),
                name='tree_structure_modified_not_on_path',
            )
            self.tree_structure_modified_at_unknown_location_emitter = \
                es.make_emitter(
                outputs=(
                    self.tree_structure_modified_on_path_emitter,
                    self.tree_structure_modified_not_on_path_emitter,
                    self.tree_modified_at_unknown_location_emitter
                ),
                name='tree_structure_modified_at_unknown_location',
            )
            
    
            self.pseudoclock_modified_emitter = es.make_emitter(
                name='pseudoclock_modified'
            )
    
            self.active_node_changed_emitter = es.make_emitter(
                name='active_node_changed'
            )
            # todo: should possibly take input from
            # `pseudoclock_modified_emitter`
            
            self.active_node_modified_emitter = es.make_emitter(
                name='active_node_modified'
            )
            
            self.active_node_changed_or_modified_emitter = es.make_emitter(
                inputs=(
                    self.active_node_changed_emitter,
                    self.active_node_modified_emitter,
                ),
                outputs=(self.__check_if_step_profile_changed,),
                name='active_node_changed_or_modified'
            )
            
            self.active_step_profile_changed_emitter = es.make_emitter(
                name='active_step_profile_changed'
            )
            
            self.path_changed_emitter = es.make_emitter(
                name='path_changed'
            )
            
            self.path_contents_changed_emitter = es.make_emitter(
                inputs=(
                    self.path_changed_emitter,
                    self.tree_modified_on_path_emitter
                ),
                name='path_contents_changed',
            )
            
            self.playing_toggled_emitter = es.make_emitter(
                name='playing_toggled',
            )
            self.playing_started_emitter = es.make_emitter(
                outputs=(self.playing_toggled_emitter,),
                name='playing_started',
            )
            self.playing_stopped_emitter = es.make_emitter(
                outputs=(self.playing_toggled_emitter,),
                name='playing_stopped',
            )
    
            self.official_playing_speed_modified_emitter = es.make_emitter(
                outputs=(self.update_defacto_playing_speed,),
                name='official_playing_speed_modified',
            )
            
            self.active_node_finalized_emitter = es.make_emitter(
                inputs=(self.active_node_modified_emitter,),
                outputs=(self.tree_modified_on_path_emitter,), # todo: correct?
                name='active_node_finalized',
            )
            
            #todo: maybe need an emitter for when editing a state?
            
            ###################################################################
            
            self.default_buffer_modified_emitter = es.make_emitter(
                name='default_buffer_modified',
            )
            
            self.step_profiles_set_modified_emitter = es.make_emitter(
                outputs=(
                    self.frame.menu_bar.node_menu.\
                    fork_by_crunching_using_menu._recalculate,
                    self.frame.context_menu.\
                    fork_by_crunching_using_menu._recalculate
                ),
                name='step_profiles_set_modified'
            )
            self.step_profiles.set_emitter(
                self.step_profiles_set_modified_emitter
            )
            
            self.step_profiles_to_hues_modified_emitter = es.make_emitter(
                name='step_profiles_to_hues_modified',
            )
            self.step_profiles_to_hues.set_emitter(
                self.step_profiles_to_hues_modified_emitter
            )
            
            self.all_menus_need_recalculation_emitter = es.make_emitter(
                outputs=(self.frame._recalculate_all_menus,),
                name='all_menus_need_recalculation_emitter'
            )
            
            self.cruncher_type_changed_emitter = es.make_emitter(
                name='cruncher_type_changed_emitter'
            )
            
            

    def __init_menu_enablings(self):
        '''Connect the functions that (en/dis)able menus to the emitters.'''
        for menu in [self.frame.menu_bar.node_menu,
                     self.frame.menu_bar.block_menu]:
            
            self.active_node_changed_or_modified_emitter.add_output(
                menu._recalculate
            )
        
            
    def __init_gui(self):
        '''
        Initialization related to the widgets which make up the gui project.
        '''
        
        self.frame.Bind(wx.EVT_MENU, self.on_fork_by_editing_menu_item,
                         id=s2i("Fork by editing"))
        self.frame.Bind(wx.EVT_MENU, self.on_fork_by_crunching_menu_item,
                         id=s2i("Fork by crunching"))
        
        

    def on_fork_by_crunching_menu_item(self, event):
        '''Event handler for "Fork by crunching" menu item.'''
        self.fork_by_crunching()
        
        
    def on_fork_by_editing_menu_item(self, event):
        '''Event handler for "Fork by editing" menu item.'''
        self.fork_by_editing()

        
    def set_path(self, path):
        '''Set the path to `path`.'''
        self.path = path
        self.path_changed_emitter.emit()
        
        
    def set_official_playing_speed(self, value):
        '''Set the official playing speed.'''
        self.official_playing_speed = value
        self.official_playing_speed_modified_emitter.emit()

        
    def _set_pseudoclock(self, value):
        '''Set the pseudoclock. Internal use.'''
        if self.pseudoclock != value:
            self.pseudoclock = value
            self.pseudoclock_modified_emitter.emit()

            
    def set_pseudoclock(self, desired_pseudoclock,
                        rounding=binary_search.LOW_OTHERWISE_HIGH):
        '''
        Attempt to set the pseudoclock to a desired value.
        
        If value is outside the range of the current path, you'll get the clock
        of the closest edge node.
        
        The active node will be changed to one which is close to the
        `desired_pseudoclock`. In `rounding` use
        `binary_search.LOW_OTHERWISE_HIGH` to get the node just below, or
        `binary_search.HIGH_OTHERWISE_LOW` to get the node just above.
        
        See documentation for these two options for more details.
        '''
        # todo: check that everything that should use this does use this

        assert rounding in (binary_search.LOW_OTHERWISE_HIGH,
                            binary_search.HIGH_OTHERWISE_LOW)
        
        both_nodes = self.path.get_node_by_clock(desired_pseudoclock,
                                                 rounding=binary_search.BOTH)
        
        binary_search_profile = binary_search.BinarySearchProfile(
            self.path, 
            lambda node: node.state.clock,
            desired_pseudoclock,
            both_nodes
        )
        
        node = binary_search_profile.results[rounding]
        
        if node is None:
            return # todo: Not sure if I should raise something
        
        self._set_active_node(node)
        
        if binary_search_profile.is_surrounded:
            self._set_pseudoclock(desired_pseudoclock)
        else:
            self._set_pseudoclock(node.state.clock)
        
        self.project.ensure_buffer(node, clock_buffer=self.default_buffer)

        
    def set_default_buffer(self, default_buffer):
        '''Set the default buffer, saying how far we should crunch ahead.'''
        self.default_buffer = default_buffer
        if self.active_node:
            self.project.ensure_buffer(self.active_node,
                                       clock_buffer=self.default_buffer)
        self.default_buffer_modified_emitter.emit()
    
        
    def round_pseudoclock_to_active_node(self):
        '''Set the value of the pseudoclock to the clock of the active node.'''
        self._set_pseudoclock(self.active_node.state.clock)

        
    def update_defacto_playing_speed(self):
        '''Update the defacto playing speed to the official playing speed.'''
        # In the future this will check if someone's temporarily tweaking the
        # defacto speed, and let that override.
        self.defacto_playing_speed = self.official_playing_speed
        
    
    def make_state_creation_dialog(self):
        '''Create a dialog for creating a root state.'''
        Dialog = self.simpack_wx_grokker.settings.STATE_CREATION_DIALOG
        dialog = Dialog(self.frame)
        try:
            state = dialog.start()
        finally:
            dialog.Destroy()
        if state:
            root = self.project.root_this_state(state)
            self.tree_structure_modified_not_on_path_emitter.emit()
            self.set_active_node(root)
        self.frame.SetFocus()
        

    def get_active_state(self):
        '''Get the active state, i.e. the state of the active node.'''
        return self.active_node.state if self.active_node else None

    
    def get_active_step_profile(self):
        '''Get the active step profile, i.e. step profile of active node.'''
        return self.active_node.step_profile if self.active_node else None
                
    
    def _set_active_node(self, node):
        '''Set the active node, displaying it onscreen. Internal use.'''
        if self.active_node is not node:
            self.active_node = node
            self.active_node_changed_emitter.emit()

     
    def set_active_node(self, node, modify_path=True):
        '''
        Set the active node, displaying it onscreen.
        
        This will change the pseudoclock to the clock of the node.
        
        if `modify_path` is True, the method will modify the path to go through
        the node, if it doesn't already.        
        '''
        self.project.ensure_buffer(node, clock_buffer=self.default_buffer)
        
        if self.active_node is node:
            return
        
        was_playing = self.is_playing # todo: consider cancelling this
        if self.is_playing: self.stop_playing()
        
        self._set_active_node(node)

        self._set_pseudoclock(node.state.clock)
        
        if was_playing:
            self.start_playing()
        if modify_path:
            self.__modify_path_to_include_active_node()
            
        if modify_path and was_playing:
            if self.infinity_job:
                self.infinity_job.crunching_profile.clock_target = \
                    self.infinity_job.node.state.clock + self.default_buffer
                self.infinity_job = \
                    self.project.ensure_buffer_on_path(node,
                                                       self.path,
                                                       infinity)   
        
        
    def __modify_path_to_include_active_node(self):
        '''Ensure that `.path` includes the active node.'''
        if self.path is None:
            self.set_path(self.active_node.make_containing_path())
        else:
            self.path.modify_to_include_node(self.active_node)
            
        self.path_changed_emitter.emit()


    def start_playing(self):
        '''Start playback of the simulation.'''
        if self.is_playing:
            return
        if self.active_node is None:
            return

        self.is_playing = True
        
        
        self.infinity_job = \
            self.project.ensure_buffer_on_path(self.active_node, self.path,
                                               infinity)
        
        self.timer_for_playing.Start(1000//25)
        
        assert self.last_tracked_real_time == None
        self.round_pseudoclock_to_active_node()
        self.last_tracked_real_time = time.time()        
        self.playing_started_emitter.emit()
        
        # todo: maybe should start a call of __play_next right here, to save
        # 25ms delay on the first frame?
        


    def stop_playing(self):
        '''Stop playback of the simulation.'''
        
        if self.is_playing is False:
            return

        try:
            self.timer_for_playing.Stop()
        except Exception: # todo: Find out the type
            pass
        
        self.is_playing = False
        
        if self.infinity_job:
            self.infinity_job.crunching_profile.clock_target = \
                self.infinity_job.node.state.clock + self.default_buffer
        
        self.last_tracked_real_time = None
        self.round_pseudoclock_to_active_node()
        self.project.ensure_buffer(self.active_node, self.default_buffer)
        
        self.playing_stopped_emitter.emit()


    def editing_state(self):
        '''
        Get a state suitable for editing.
        
        If the current active node is "still in editing", returns its state. If
        not, forks the tree with the active node as a template and returns the
        newly created state.
        '''
        node = self.active_node
        state = node.state
        if (node.touched is False) or (node.still_in_editing is False):
            new_node = self.fork_by_editing()
            return new_node.state
        else:
            return state

        
    def toggle_playing(self):
        '''Toggle the onscreen playback of the simulation.'''
        return self.stop_playing() if self.is_playing else self.start_playing()
    
        
    def __play_next(self, event=None):
        '''
        Show the next node onscreen.
        
        This method is called repeatedly when playing the simulation.
        '''
        if self.is_playing is False: return

        current_real_time = time.time()
        real_time_elapsed = (current_real_time - self.last_tracked_real_time)
        desired_pseudoclock = \
            self.pseudoclock + \
            (real_time_elapsed * self.defacto_playing_speed)
        

        rounding = binary_search.LOW_OTHERWISE_HIGH \
                 if self.defacto_playing_speed > 0 \
                 else binary_search.HIGH_OTHERWISE_LOW
        
        self.set_pseudoclock(desired_pseudoclock, rounding)

        self.last_tracked_real_time = current_real_time
        

    def fork_by_crunching(self, *args, **kwargs):
        '''
        Fork the simulation from the active node.
        
        Used for forking the simulation without modifying any states. Creates
        a new node from the active node via natural simulation.

        Any `*args` or `**kwargs` will be packed in a `StepProfile` object and
        passed to the step function. You may pass a `StepProfile` yourself, as
        the only argument, and it will be noticed and used. If nothing is
        passed in `*args` or `**kwargs`, the step profile of the active node
        will be used, unless it doesn't have a step profile, in which case the
        default step profile will be used.
        
        Returns the job.
        '''
        #todo: maybe not let to do it from unfinalized touched node?
        
        if not args and not kwargs and self.active_node.step_profile:
            step_profile = self.active_node.step_profile
        elif args or kwargs:
            parse_arguments_to_step_profile = \
                garlicsim.misc.StepProfile.build_parser(
                    self.active_node.step_profile.step_function if
                    self.active_node.step_profile else
                    self.simpack_grokker.default_step_function
                )
            step_profile = parse_arguments_to_step_profile(*args, **kwargs)
        else:
            assert not self.active_node.step_profile
            step_profile = self.default_step_profile
            
        job = self.project.begin_crunching(self.active_node,
                                           self.default_buffer or 1,
                                           step_profile)
        
        self._job_and_node_of_recent_fork_by_crunching = (job,
                                                          self.active_node)
        
        return job


    def fork_by_editing(self):
        '''
        Fork the simulation from the active node by editing.
        
        Returns the new node.
        '''
        # todo: event argument is bad, in other places too
        # todo: maybe not restrict it to "from_active_node"?
        new_node = \
            self.project.tree.fork_to_edit(template_node=self.active_node)
        self.tree_structure_modified_on_path_emitter.emit()
        self.set_active_node(new_node)
        return new_node


    def sync_crunchers(self):
        '''
        Take work from the crunchers, and give them new instructions if needed.
        
        (This is a wrapper for `Project.sync_crunchers()` with some gui-related
        additions.)
        
        Talks with all the crunchers, takes work from them for implementing
        into the tree, retiring crunchers or recruiting new crunchers as
        necessary.

        Returns the total amount of nodes that were added to the tree in the
        process.
        '''
        
        # This method basically has two tasks. The first one is to take work
        # from the crunchers and retire/recruit/redirect them as necessary.
        # This is done by `Project.sync_crunchers`, which we call here, so
        # that's not the tricky part here.
        #
        # The second task is the tricky part. We want to know just how much the
        # tree was modified during this action. And the tricky thing is that
        # `Project.sync_crunchers` won't do that for us, so we're going to have
        # to try to deduce how much the tree modified ourselves, just by
        # looking at the `jobs` list before and after calling
        # `Project.sync_crunchers`.
        #
        # And when I say "to know how much the tree modified", I mean mainly to
        # know if the modification is a structural modification, or just some
        # blocks getting fatter. And the reason we want to know this is so
        # we'll know whether to update various workspace widgets.
        
        jobs = self.project.crunching_manager.jobs
        
        jobs_to_nodes = dict((job, job.node) for job in jobs)

                
        added_nodes = self.project.sync_crunchers()        
        # This is the heavy line here, which actually executes the Project's
        # `sync_crunchers` function.
        
        
        if any(
            (job not in jobs) or \
            (job.node.soft_get_block() is not old_node.soft_get_block())
            for job, old_node in jobs_to_nodes.iteritems()
               ):

            # What does this codition mean?
            # 
            # It means that there is at least one job that either:
            # (a) Was removed from the jobs list, or
            # (b) Changed the soft block it's pointing to.            
            #
            # The thing is, if there was a structural modification in the tree,
            # this condition must be `True`. So we report a structure
            # modification:
            
            self.tree_structure_modified_at_unknown_location_emitter.emit()
            
            # Even though we are not sure that the tree structure was modified.
            # We have to play it safe. And since this condition doesn't happen
            # most of the time when crunching, we're not wasting too much
            # rendering time by assuming this is a structural modification.
            
            # Note that we didn't check if `added_nodes > 0`: This is because
            # if an `End` was added to the tree, it wouldn't have been counted
            # in `added_nodes`.
            
        elif added_nodes > 0:
            
            # If this condition is `True`, we know as a fact that there was no
            # structural modification, and we know as a fact that some blocks
            # have gotten fatter.
            
            self.tree_modified_at_unknown_location_emitter.emit()
            
        # todo: It would be hard but nice to know whether the tree changes were
        # on the path. This could save some rendering on `SeekBar`.
            
        return added_nodes

    
    def finalize_active_node(self):
        '''Finalize the changes made to the active node.'''
        self.active_node.finalize()
        
        self.active_node_finalized_emitter.emit()
        
        self.project.ensure_buffer(self.active_node, self.default_buffer)
        
    
    def _update_step_profiles_set(self):
        '''Update the step profiles set to include ones used in the tree.'''
        self.step_profiles |= self.project.tree.get_step_profiles()
    
    
    def __check_if_step_profile_changed(self):
        '''Check if the active step profile has changed.'''
        active_step_profile = self.get_active_step_profile()
        if active_step_profile != self._tracked_step_profile:
            self._tracked_step_profile = active_step_profile
            self.active_step_profile_changed_emitter.emit()
        
        
    def _if_forked_by_crunching_recently_switch_to_new_path(self):
        '''If user did "fork by crunching" and new path is ready, switch to.'''
        if self._job_and_node_of_recent_fork_by_crunching:
            job, old_node = self._job_and_node_of_recent_fork_by_crunching
            new_node = job.node
            
            if new_node is not old_node:
                new_path = new_node.make_containing_path()
                
                assert old_node in new_path
                # Cause `new_node` was born out of `old_node`.
                
                self.set_path(new_path)
                self._job_and_node_of_recent_fork_by_crunching = None
            
        
    def __reduce__(self):
        my_dict = dict(self.__dict__)
        
        del my_dict['frame']
        del my_dict['timer_for_playing']
        del my_dict['simpack_grokker']
        del my_dict['simpack_wx_grokker']
        
        # Getting rid of emitter:
        del my_dict['step_profiles']
        my_dict['step_profiles'] = list(self.step_profiles)
        
        # Getting rid of emitter and default factory:
        del my_dict['step_profiles_to_hues']
        my_dict['step_profiles_to_hues'] = dict(self.step_profiles_to_hues)
        
        if self.frame.shell:
            my_dict['_temp_shell_history'] = self.frame.shell.GetText()
            my_dict['_temp_shell_command_history'] = \
                self.frame.shell.history[:]
        
        my_namespace = my_dict['namespace'] = my_dict['namespace'].copy()
        try:
            del my_namespace['__builtins__']
        except KeyError:
            pass
        

        for (key, value) in my_dict.items():
            
            if isinstance(value, emitters.Emitter) or \
               isinstance(value, emitters.EmitterSystem):
                
                del my_dict[key]
            
        return (
            GuiProject._reconstruct,
            (self.simpack, self.project),
            my_dict
        )

    
    def __setstate__(self, my_dict):
        isinstance(my_dict, dict)
        
        if 'step_profiles' in my_dict:
            self.step_profiles.clear()
            self.step_profiles |= my_dict.pop('step_profiles')
            # todo: Last line not idiomatic
            
        if 'step_profiles_to_hues' in my_dict:
            self.step_profiles_to_hues.clear()
            self.step_profiles_to_hues.update(
                my_dict.pop('step_profiles_to_hues')
            )
            
        if 'namespace' in my_dict:
            pickled_namespace = my_dict.pop('namespace')
            pickled_namespace.update(self.namespace)
            self.namespace.update(pickled_namespace)
        
        for (key, value) in my_dict.iteritems():
            setattr(self, key, value)
    
    
    @staticmethod
    def _reconstruct(simpack, project):
        '''Reconstruct a pickled gui project.'''

        frame = garlicsim_wx._active_frame
        # todo: Make Frame inherit from some "InstanceHolder" instead
        
        gui_project = GuiProject(simpack, frame, project)
        
        return gui_project
    
    
_reconstruct = GuiProject._reconstruct
# Anchored because static methods cannot be pickled, because they are
# desciptors which return a function and (c)pickle sucks at functions defined
# in classes.


########NEW FILE########
__FILENAME__ = aui_dock_art
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `AuiDockArt` class.

See its documentation for more info.
'''

import wx

from garlicsim_wx.general_misc.third_party import aui
from garlicsim_wx.general_misc import wx_tools

# Imports for my copy-paste-modify overriding of some methods:
# # # #
import types
from garlicsim_wx.general_misc.third_party.aui.aui_utilities import (
    BitmapFromBits, StepColour, ChopText, GetBaseColour, DrawGradientRectangle,
    DrawMACCloseButton, DarkenBitmap, LightContrastColour)
from garlicsim_wx.general_misc.third_party.aui.aui_constants import *

optionActive = 2**14
# # # #



class AuiDockArt(aui.AuiDefaultDockArt):
    '''A dock art provider.'''
    def __init__(self):
        aui.AuiDefaultDockArt.__init__(self)
 
        self.SetColor(
            aui.AUI_DOCKART_BACKGROUND_GRADIENT_COLOUR,
            self.GetColor(
                aui.AUI_DOCKART_BACKGROUND_COLOUR
            )
        )
        
        self.SetMetric(aui.AUI_DOCKART_SASH_SIZE, 2)
        
        font_size = 9 if wx.Platform == '__WXMAC__' else 7
        
        self.SetMetric(aui.AUI_DOCKART_CAPTION_SIZE, 11)
        self.SetFont(
            aui.AUI_DOCKART_CAPTION_FONT,
            wx.Font(font_size, wx.FONTFAMILY_DEFAULT, wx.NORMAL, wx.NORMAL, False)
        )
        
        #self.SetMetric(aui.AUI_DOCKART_GRADIENT_TYPE,
        #               aui.AUI_GRADIENT_NONE)
        
        self.SetColor(aui.AUI_DOCKART_INACTIVE_CAPTION_COLOUR,
                      wx_tools.get_background_color())

        
    def DrawCaption(self, dc, window, text, rect, pane):
        # A copy-paste-modify override. Changes not marked, you can diff.
        """
        Draws the text in the pane caption.

        :param `dc`: a `wx.DC` device context;
        :param `window`: an instance of `wx.Window`;
        :param `text`: the text to be displayed;
        :param `rect`: the pane caption rectangle;
        :param `pane`: the pane for which the text is drawn.
        """

        dc.SetPen(wx.TRANSPARENT_PEN)
        dc.SetFont(self._caption_font)
        
        self.DrawCaptionBackground(dc, rect, pane)

        if pane.state & optionActive:
            dc.SetTextForeground(self._active_caption_text_colour)
        else:
            dc.SetTextForeground(self._inactive_caption_text_colour)

        w, h = dc.GetTextExtent("ABCDEFHXfgkj")

        clip_rect = wx.Rect(*rect)
        btns = pane.CountButtons()

        captionLeft = pane.HasCaptionLeft()
        variable = (captionLeft and [rect.height] or [rect.width])[0]

        variable -= 3      # text offset
        variable -= 2      # button padding

        caption_offset = 0
        if pane.icon:
            if captionLeft:
                caption_offset += pane.icon.GetHeight() + 3
            else:
                caption_offset += pane.icon.GetWidth() + 3
                
            self.DrawIcon(dc, rect, pane)

        variable -= caption_offset
        variable -= btns*(self._button_size + self._border_size)
        draw_text = ChopText(dc, text, variable)

        if captionLeft:
            dc.DrawRotatedText(draw_text, rect.x+(rect.width/2)-(h/2)-1, rect.y+rect.height-3-caption_offset, 90)
        else:
            dc.DrawText(draw_text, rect.x+3+caption_offset, rect.y+(rect.height/2)-(h/2))
            
    


    def SetColor(self, id, colour):
        # A copy-paste-modify override. Changes marked with "# IS A CHANGE"
        """
        Sets the colour of a certain setting.

        :param `id`: can be one of the colour values in `Metric Ordinals`;
        :param `colour`: the new value of the setting.
        """

        if isinstance(colour, basestring):
            colour = wx.NamedColour(colour)
        elif isinstance(colour, types.TupleType):
            colour = wx.Colour(*colour)
        elif isinstance(colour, types.IntType):
            colour = wx.ColourRGB(colour)
        
        if id == AUI_DOCKART_BACKGROUND_COLOUR:
            self._background_brush.SetColour(colour)
        elif id == AUI_DOCKART_BACKGROUND_GRADIENT_COLOUR:
            self._background_gradient_colour = colour
        elif id == AUI_DOCKART_SASH_COLOUR:
            self._sash_brush.SetColour(colour)
        elif id == AUI_DOCKART_INACTIVE_CAPTION_COLOUR:
            self._inactive_caption_colour = colour
            if not self._custom_pane_bitmaps and wx.Platform == "__WXMAC__":
                # No custom bitmaps for the pane close button
                # Change the MAC close bitmap colour
                pass # # self._inactive_close_bitmap = DrawMACCloseButton(wx.WHITE, colour)
                # IS A CHANGE

        elif id == AUI_DOCKART_INACTIVE_CAPTION_GRADIENT_COLOUR:
            self._inactive_caption_gradient_colour = colour
        elif id == AUI_DOCKART_INACTIVE_CAPTION_TEXT_COLOUR:
            self._inactive_caption_text_colour = colour
        elif id == AUI_DOCKART_ACTIVE_CAPTION_COLOUR:
            self._active_caption_colour = colour
            if not self._custom_pane_bitmaps and wx.Platform == "__WXMAC__":
                # No custom bitmaps for the pane close button
                # Change the MAC close bitmap colour
                pass # self._active_close_bitmap = DrawMACCloseButton(wx.WHITE, colour)
                # IS A CHANGE
                
        elif id == AUI_DOCKART_ACTIVE_CAPTION_GRADIENT_COLOUR:
            self._active_caption_gradient_colour = colour
        elif id == AUI_DOCKART_ACTIVE_CAPTION_TEXT_COLOUR:
            self._active_caption_text_colour = colour
        elif id == AUI_DOCKART_BORDER_COLOUR:
            self._border_pen.SetColour(colour)
        elif id == AUI_DOCKART_GRIPPER_COLOUR:
            self._gripper_brush.SetColour(colour)
            self._gripper_pen1.SetColour(StepColour(colour, 40))
            self._gripper_pen2.SetColour(StepColour(colour, 60))
        else:
            raise Exception("Invalid Colour Ordinal.")

########NEW FILE########
__FILENAME__ = aui_manager
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `AuiManager` class.

See its documentation for more info.
'''

import wx
from garlicsim_wx.general_misc.third_party import aui

from .aui_dock_art import AuiDockArt
from .aui_tab_art import AuiTabArt


class AuiManager(aui.AuiManager):
    '''An AUI manager. See documentation of base class.'''
    def __init__(self, managed_window=None):
        aui.AuiManager.__init__(self, managed_window)
 
        self.SetArtProvider(AuiDockArt())
        
        self.tab_art_provider = AuiTabArt()
        
        self.SetAutoNotebookTabArt(self.tab_art_provider)
        
        
        
    def CreateNotebook(self):
        
        notebook = aui.AuiManager.CreateNotebook(self)

        notebook.SetNormalFont(self.tab_art_provider.GetNormalFont())
        notebook.SetSelectedFont(self.tab_art_provider.GetSelectedFont())
        notebook.SetMeasuringFont(self.tab_art_provider.GetMeasuringFont())
                
        
        return notebook

########NEW FILE########
__FILENAME__ = aui_tab_art
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `AuiTabArt` class.

See its documentation for more info.
'''

import wx
from garlicsim_wx.general_misc.third_party import aui

# Imports for my copy-paste-modify overriding of some methods:
# # # #
from garlicsim_wx.general_misc.third_party.aui.aui_utilities import (
    BitmapFromBits, StepColour, IndentPressedBitmap, ChopText, GetBaseColour,
    DrawMACCloseButton, LightColour, TakeScreenShot, CopyAttributes)
from garlicsim_wx.general_misc.third_party.aui.aui_constants import *
# # # #


class AuiTabArt(aui.AuiDefaultTabArt):
    '''A tab art provider.'''
    def __init__(self):
        aui.AuiDefaultTabArt.__init__(self)
        
        font_size = 9 if wx.Platform == '__WXMAC__' else 7
        
        self.SetNormalFont(wx.Font(font_size, wx.FONTFAMILY_DEFAULT, wx.NORMAL, wx.NORMAL))
        self.SetSelectedFont(wx.Font(font_size, wx.FONTFAMILY_DEFAULT, wx.NORMAL, wx.NORMAL))
        self.SetMeasuringFont(wx.Font(font_size, wx.FONTFAMILY_DEFAULT, wx.NORMAL, wx.NORMAL))
 
        
    def Clone(self):

        art = type(self)()
        art.SetNormalFont(self.GetNormalFont())
        art.SetSelectedFont(self.GetSelectedFont())
        art.SetMeasuringFont(self.GetMeasuringFont())

        art = aui.aui_utilities.CopyAttributes(art, self)
        return art

    
    def DrawTab(self, dc, wnd, page, in_rect, close_button_state, paint_control=False):
        # A copy-paste-modify override. Changes marked with "# IS A CHANGE"
        """
        Draws a single tab.

        :param `dc`: a `wx.DC` device context;
        :param `wnd`: a `wx.Window` instance object;
        :param `page`: the tab control page associated with the tab;
        :param `in_rect`: rectangle the tab should be confined to;
        :param `close_button_state`: the state of the close button on the tab;
        :param `paint_control`: whether to draw the control inside a tab (if any) on a `wx.MemoryDC`.
        """

        # if the caption is empty, measure some temporary text
        caption = page.caption
        if not caption:
            caption = "Xj"

        dc.SetFont(self._selected_font)
        selected_textx, selected_texty, dummy = dc.GetMultiLineTextExtent(caption)

        dc.SetFont(self._normal_font)
        normal_textx, normal_texty, dummy = dc.GetMultiLineTextExtent(caption)

        control = page.control

        # figure out the size of the tab
        tab_size, x_extent = self.GetTabSize(dc, wnd, page.caption, page.bitmap,
                                             page.active, close_button_state, control)

        tab_height = self._tab_ctrl_height - 3
        tab_width = tab_size[0]
        tab_x = in_rect.x
        tab_y = in_rect.y + in_rect.height - tab_height

        caption = page.caption

        # select pen, brush and font for the tab to be drawn

        if page.active:
        
            dc.SetFont(self._selected_font)
            textx, texty = selected_textx, selected_texty
        
        else:
        
            dc.SetFont(self._normal_font)
            textx, texty = normal_textx, normal_texty

        if not page.enabled:
            dc.SetTextForeground(wx.SystemSettings.GetColour(wx.SYS_COLOUR_GRAYTEXT))
            pagebitmap = page.dis_bitmap
        else:
            dc.SetTextForeground(page.text_colour)
            pagebitmap = page.bitmap
            
        # create points that will make the tab outline

        clip_width = tab_width
        if tab_x + clip_width > in_rect.x + in_rect.width:
            clip_width = in_rect.x + in_rect.width - tab_x

        # since the above code above doesn't play well with WXDFB or WXCOCOA,
        # we'll just use a rectangle for the clipping region for now --
        dc.SetClippingRegion(tab_x, tab_y, clip_width+1, tab_height-3)

        border_points = [wx.Point() for i in xrange(6)]
        agwFlags = self.GetAGWFlags()
        
        if agwFlags & AUI_NB_BOTTOM:
        
            border_points[0] = wx.Point(tab_x,             tab_y)
            border_points[1] = wx.Point(tab_x,             tab_y+tab_height-6)
            border_points[2] = wx.Point(tab_x+2,           tab_y+tab_height-4)
            border_points[3] = wx.Point(tab_x+tab_width-2, tab_y+tab_height-4)
            border_points[4] = wx.Point(tab_x+tab_width,   tab_y+tab_height-6)
            border_points[5] = wx.Point(tab_x+tab_width,   tab_y)
        
        else: #if (agwFlags & AUI_NB_TOP) 
        
            border_points[0] = wx.Point(tab_x,             tab_y+tab_height-4)
            border_points[1] = wx.Point(tab_x,             tab_y+2)
            border_points[2] = wx.Point(tab_x+2,           tab_y)
            border_points[3] = wx.Point(tab_x+tab_width-2, tab_y)
            border_points[4] = wx.Point(tab_x+tab_width,   tab_y+2)
            border_points[5] = wx.Point(tab_x+tab_width,   tab_y+tab_height-4)
        
        # TODO: else if (agwFlags & AUI_NB_LEFT) 
        # TODO: else if (agwFlags & AUI_NB_RIGHT) 

        drawn_tab_yoff = border_points[1].y
        drawn_tab_height = border_points[0].y - border_points[1].y

        if page.active:
        
            # draw active tab

            # draw base background colour
            r = wx.Rect(tab_x, tab_y, tab_width, tab_height)
            dc.SetPen(self._base_colour_pen)
            dc.SetBrush(self._base_colour_brush)
            dc.DrawRectangle(r.x+1, r.y+1, r.width-1, r.height-4)

            # this white helps fill out the gradient at the top of the tab
            dc.SetPen(wx.WHITE_PEN)
            dc.SetBrush(wx.WHITE_BRUSH)
            dc.DrawRectangle(r.x+2, r.y+1, r.width-3, r.height-4)

            # these two points help the rounded corners appear more antialiased
            dc.SetPen(self._base_colour_pen)
            dc.DrawPoint(r.x+2, r.y+1)
            dc.DrawPoint(r.x+r.width-2, r.y+1)

            # set rectangle down a bit for gradient drawing
            r.SetHeight(r.GetHeight()/2)
            r.x += 2
            r.width -= 2
            r.y += r.height
            r.y -= 2

            # draw gradient background
            top_colour = wx.WHITE
            bottom_colour = self._base_colour
            dc.GradientFillLinear(r, bottom_colour, top_colour, wx.NORTH)
        
        else:
        
            # draw inactive tab

            r = wx.Rect(tab_x, tab_y+1, tab_width, tab_height-3)

            # start the gradent up a bit and leave the inside border inset
            # by a pixel for a 3D look.  Only the top half of the inactive
            # tab will have a slight gradient
            r.x += 3
            r.y += 1
            r.width -= 4
            r.height /= 2
            r.height -= 1

            # -- draw top gradient fill for glossy look
            top_colour = self._base_colour
            bottom_colour = StepColour(top_colour, 160)
            dc.GradientFillLinear(r, bottom_colour, top_colour, wx.NORTH)

            r.y += r.height
            r.y -= 1

            # -- draw bottom fill for glossy look
            top_colour = self._base_colour
            bottom_colour = self._base_colour
            dc.GradientFillLinear(r, top_colour, bottom_colour, wx.SOUTH)
        
        # draw tab outline
        dc.SetPen(self._border_pen)
        dc.SetBrush(wx.TRANSPARENT_BRUSH)
        dc.DrawPolygon(border_points)

        # there are two horizontal grey lines at the bottom of the tab control,
        # this gets rid of the top one of those lines in the tab control
        if page.active:
        
            if agwFlags & AUI_NB_BOTTOM:
                dc.SetPen(wx.Pen(StepColour(self._base_colour, 170)))
                
            # TODO: else if (agwFlags & AUI_NB_LEFT) 
            # TODO: else if (agwFlags & AUI_NB_RIGHT) 
            else: # for AUI_NB_TOP
                dc.SetPen(self._base_colour_pen)
                
            dc.DrawLine(border_points[0].x+1,
                        border_points[0].y,
                        border_points[5].x,
                        border_points[5].y)
        
        text_offset = tab_x + 8
        close_button_width = 0

        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
            close_button_width = self._active_close_bmp.GetWidth()

            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
                text_offset += close_button_width - 5
                
        bitmap_offset = 0
        
        if pagebitmap.IsOk():
        
            bitmap_offset = tab_x + 8
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT and close_button_width:
                bitmap_offset += close_button_width - 5

            # draw bitmap
            dc.DrawBitmap(pagebitmap,
                          bitmap_offset,
                          drawn_tab_yoff + (drawn_tab_height/2) - (pagebitmap.GetHeight()/2),
                          True)

            text_offset = bitmap_offset + pagebitmap.GetWidth()
            text_offset += 3 # bitmap padding

        else:

            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT == 0 or not close_button_width:
                text_offset = tab_x + 8
        
        draw_text = ChopText(dc, caption, tab_width - (text_offset-tab_x) - close_button_width)

        ypos = drawn_tab_yoff + (drawn_tab_height)/2 - (texty/2) + 1 # IS A CHANGE

        offset_focus = text_offset     
        if control is not None:
            if control.GetPosition() != wx.Point(text_offset+1, ypos):
                control.SetPosition(wx.Point(text_offset+1, ypos))

            if not control.IsShown():
                control.Show()

            if paint_control:
                bmp = TakeScreenShot(control.GetScreenRect())
                dc.DrawBitmap(bmp, text_offset+1, ypos, True)
                
            controlW, controlH = control.GetSize()
            text_offset += controlW + 4
            textx += controlW + 4
            
        # draw tab text
        rectx, recty, dummy = dc.GetMultiLineTextExtent(draw_text)
        dc.DrawLabel(draw_text, wx.Rect(text_offset, ypos, rectx, recty))

        # draw focus rectangle
        self.DrawFocusRectangle(dc, page, wnd, draw_text, offset_focus, bitmap_offset, drawn_tab_yoff, drawn_tab_height, textx, texty)
        
        out_button_rect = wx.Rect()
        
        # draw close button if necessary
        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
        
            bmp = self._disabled_close_bmp

            if close_button_state == AUI_BUTTON_STATE_HOVER:
                bmp = self._hover_close_bmp
            elif close_button_state == AUI_BUTTON_STATE_PRESSED:
                bmp = self._pressed_close_bmp

            shift = (agwFlags & AUI_NB_BOTTOM and [1] or [0])[0]

            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
                rect = wx.Rect(tab_x + 4, tab_y + (tab_height - bmp.GetHeight())/2 - shift,
                               close_button_width, tab_height)
            else:
                rect = wx.Rect(tab_x + tab_width - close_button_width - 1,
                               tab_y + (tab_height - bmp.GetHeight())/2 - shift,
                               close_button_width, tab_height)

            rect = IndentPressedBitmap(rect, close_button_state)
            dc.DrawBitmap(bmp, rect.x, rect.y, True)

            out_button_rect = rect
        
        out_tab_rect = wx.Rect(tab_x, tab_y, tab_width, tab_height)

        dc.DestroyClippingRegion()

        return out_tab_rect, out_button_rect, x_extent
########NEW FILE########
__FILENAME__ = colors
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Defines colors and color-related tools used in `garlicsim_wx`.'''

import colorsys

import wx


def make_wx_color(rgb):
    '''Convert an RGB float tuple (like `(0.1, 0.7, 0.3)`) to a `wx.Colour`.'''
    r, g, b = rgb
    return wx.Colour(255*r, 255*g, 255*b)

def hue_to_light_color(hue):
    '''Covert a float hue to a corresponding light `wx.Colour`.'''
    return make_wx_color(
        colorsys.hls_to_rgb(hue, 0.8, 1)
    )
########NEW FILE########
__FILENAME__ = block_menu
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `BlockMenu` class.

See its documentation for more info.
'''

import wx

from garlicsim_wx.general_misc.cute_menu import CuteMenu

class BlockMenu(CuteMenu):
    '''A menu for manipulating the active block.'''
    def __init__(self, frame):
        super(BlockMenu, self).__init__()
        self.frame = frame
        self._build()
    
    def _build(self):
        
        frame = self.frame
        
       
        self.split_button = self.Append(
            -1,
            '&Split active block...',
            " Split the active block into two separate blocks"
        )
        self.split_button.Enable(False)
        
        
        self.scatter_button = self.Append( # todo: rename
            -1,
            'S&catter active block...',
            ' Scatter the active block, leaving all its nodes blockless'
        )
        self.scatter_button.Enable(False)
        
        
    def _recalculate(self):
        gui_project = self.frame.gui_project
        self.enable_in_menu_bar(
            gui_project is not None and \
            gui_project.active_node is not None and \
            gui_project.active_node.block is not None
        )
########NEW FILE########
__FILENAME__ = create_menu
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `CreateMenu` class.

See its documentation for more info.
'''

import wx

from garlicsim_wx.general_misc.cute_menu import CuteMenu


class CreateMenu(CuteMenu):
    '''Menu for creating new objects.'''
    def __init__(self, frame):
        super(CreateMenu, self).__init__()
        self.frame = frame
        self._build()
    
    def _build(self):
        
        frame = self.frame
        
        self.create_state_button = self.Append(
            -1, 
            'Create &state...',
            ' Create a new state, which will become a root node in the tree'
        )
        frame.Bind(
            wx.EVT_MENU,
            lambda event: frame.gui_project.make_state_creation_dialog(),
            self.create_state_button
        )
        
    
        self.AppendSeparator()
        
        
        self.create_step_profile_button = self.Append(
            -1, 
            'Create step &profile...',
            ' Create a new step profile, which can modify the world rules '
            'under which the simulation crunches'
        )
        frame.Bind(
            wx.EVT_MENU,
            lambda event: frame.crunching_controls.step_profiles_controls.\
                          show_step_profile_editing_dialog(),
            self.create_step_profile_button
        )
        
        
    def _recalculate(self):
        self.enable_in_menu_bar(
            self.frame.gui_project is not None
        )
########NEW FILE########
__FILENAME__ = edit_menu
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `EditMenu` class.

See its documentation for more info.
'''

import wx

from garlicsim_wx.general_misc.cute_menu import CuteMenu


class EditMenu(CuteMenu):
    '''Menu for editing: Undo, cut, copy, paste etc.'''
    def __init__(self, frame):
        super(EditMenu, self).__init__()
        self.frame = frame
        self._build()
    
    def _build(self):
        
        frame = self.frame
        
        
        self.undo_button = self.Append(
            wx.ID_UNDO,
            '&Undo', # todo: Add '\tCtrl+Z' after solved bug
            ' Undo the last operation'
        )
        self.undo_button.Enable(False)
        
        
        self.redo_button = self.Append(
            wx.ID_REDO,
            '&Redo', # todo: Add '\tCtrl+Y' after solved bug
            ' Redo the last operation that was undone'
        )
        self.redo_button.Enable(False)
        
        
        self.AppendSeparator()
        
                
        self.cut_button = self.Append(
            -1, # todo: Make it `wx.ID_CUT` after solved 11.04 bugs
            'Cu&t', # todo: Add '\tCtrl+X' after solved bug
            ' Cut the current selection, copying to the clipboard and '
            'deleting it from the simulation'
        )
        self.cut_button.Enable(False)
        
                
        self.copy_button = self.Append(
            -1, # todo: Make it `wx.ID_COPY` after solved 11.04 bugs
            '&Copy', # todo: Add '\tCtrl+C' after solved bug
            ' Copy the current selection to the clipboard'
        )
        self.copy_button.Enable(False)
        
                
        self.paste_button = self.Append(
            -1, # todo: Make it `wx.ID_PASTE` after solved 11.04 bugs
            '&Paste', # todo: Add '\tCtrl+V' after solved bug
            ' Paste the content of the clipboard into the simulation'
        )
        self.paste_button.Enable(False)
        
                
        self.clear_button = self.Append(
            wx.ID_CLEAR,
            'Cl&ear', # todo: Add '\tDel' after solved bug
            ' Delete the current selection'
        )
        self.clear_button.Enable(False)
        
        
        self.AppendSeparator()


        self.select_all_button = self.Append(
            wx.ID_SELECTALL,
            'Select &All', # todo: Add '\tCtrl+A' after solved bug
            ' Select all the nodes'
        )
        self.select_all_button.Enable(False)
        
        
        self.deselect_button = self.Append(
            -1,
            '&Deselect\tCtrl+D',
            ' Deselect all the selected nodes'
        )
        self.deselect_button.Enable(False)
        
        
        self.invert_selection_button = self.Append(
            -1,
            'Invert selection\tCtrl+Shift+I',
            " Select all the nodes that aren't selected, and deselect those "
            "that are selected"
        )
        self.invert_selection_button.Enable(False)
        
        
        self.AppendSeparator()
        
        
        self.merge_to_blocks_button = self.Append(
            -1,
            'Merge to blocks where possible',
            ' Merge adjacant nodes to blocks, where possible'
        )
        self.merge_to_blocks_button.Enable(False)
        
        
        self.AppendSeparator()
        
        
        self.preferences_button = self.Append(
            wx.ID_PREFERENCES,
            'Prefere&nces',
            " View and modify GarlicSim's program-wide preferences"
        )
        self.preferences_button.Enable(False)
        
                

########NEW FILE########
__FILENAME__ = export_menu
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `ExportMenu` class.

See its documentation for more info.
'''

import wx

from garlicsim_wx.general_misc.cute_menu import CuteMenu

class ExportMenu(CuteMenu):
    '''Menu for exporting simulation data to non-GarlicSim formats.'''
    def __init__(self, frame):
        super(ExportMenu, self).__init__()
        self.frame = frame
        self._build()
    
    def _build(self):
        
        frame = self.frame
        
        
        self.video_button = self.Append(
            -1,
            '&Video',
            ' Export a video sequence showing playback of the simulation'
        )
        self.video_button.Enable(False)
        
        
        self.image_button = self.Append(
            -1,
            '&Image',
            ' Export an image showing a single state in the simulation'
        )
        self.image_button.Enable(False)
                

########NEW FILE########
__FILENAME__ = file_menu
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `FileMenu` class.

See its documentation for more info.
'''

import wx

from garlicsim_wx.general_misc.cute_menu import CuteMenu

from .export_menu import ExportMenu


class FileMenu(CuteMenu):
    '''Menu for file actions: New, open, save...'''
    def __init__(self, frame):
        super(FileMenu, self).__init__()
        self.frame = frame
        self._build()
    
    def _build(self):
        
        frame = self.frame

        
        self.new_button = self.Append(
            wx.ID_NEW, 
            '&New...\tCtrl+N',
            ' Create a new simulation'
        )
        frame.Bind(wx.EVT_MENU, frame.on_new, self.new_button)
        

        self.open_button = self.Append(
            wx.ID_OPEN,
            '&Open...\tCtrl+O',
            ' Open a saved simulation'
        )
        frame.Bind(wx.EVT_MENU, frame.on_open, self.open_button)        
        
        
        # todo: put open recent here

        
        self.AppendSeparator()

        
        self.close_button = self.Append(
            wx.ID_CLOSE,
            '&Close\tCtrl+W',
            ' Close the currently open simulation'
        )
        self.close_button.Enable(False)

        
        self.save_button = self.Append(
            wx.ID_SAVE,
            '&Save\tCtrl+S',
            ' Save the currently open simulation'
        )
        frame.Bind(wx.EVT_MENU, frame.on_save, self.save_button)
        
        
        self.save_as_button = self.Append(
            wx.ID_SAVEAS,
            'Save &as...\tShift+Ctrl+S',
            ' Save the currently open simulation under a different name'
        )
        self.save_as_button.Enable(False)
                
        
        self.AppendSeparator()
        
        
        self.new_simpack_button = self.Append(
            -1,
            'New simpack...',
            ' Create a new simulation package'
        )
        self.new_simpack_button.Enable(False)
                
        
        self.AppendSeparator()

        
        self.export_menu = ExportMenu(frame)
        self.export_menu_button = self.AppendMenu(
            -1,
            '&Export',
            self.export_menu,
            ' Export simulation data'
        )
        self.export_menu_button.Enable(False)
        
        
        self.AppendSeparator()
        
        
        self.print_button = self.Append(
            wx.ID_PRINT,
            '&Print...\tCtrl+P',
            ' Print the current state of the simulation'
        )
        self.print_button.Enable(False)
        
        
        self.AppendSeparator()
        

        self.exit_button = self.Append(
            wx.ID_EXIT,
            'E&xit',
            ' Close GarlicSim')              
        
        frame.Bind(wx.EVT_MENU, frame.on_exit_menu_button, self.exit_button)

        
    def _recalculate(self):
        self.save_button.Enable(
            bool(self.frame.gui_project)
        )
########NEW FILE########
__FILENAME__ = help_menu
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `HelpMenu` class.

See its documentation for more info.
'''

import wx

from garlicsim_wx.general_misc.cute_menu import CuteMenu

import garlicsim_wx

from .online_resources_menu import OnlineResourcesMenu


class HelpMenu(CuteMenu):
    '''Menu for getting help on GarlicSim.'''
    def __init__(self, frame):
        super(HelpMenu, self).__init__()
        self.frame = frame
        self._build()
    
    def _build(self):
        
        frame = self.frame                
        
        
        self.garlicsim_help_button = self.Append(
            wx.ID_HELP_CONTENTS,
            'GarlicSim &Help...\tF1',
            ' Display the help documents for GarlicSim'
        )
        self.garlicsim_help_button.Enable(False)
        
        
        self.welcome_screen_button = self.Append(
            -1,
            '&Welcome screen...',
            ' Show the welcome screen'
        )
        self.welcome_screen_button.Enable(False)
        
                
        self.garlicsim_book_button = self.Append(
            -1,
            'Read the &book, "Introduction to GarlicSim"...',
            ' Open the GarlicSim book, a PDF document'
        )
        self.garlicsim_book_button.Enable(False)
        
        
        self.AppendSeparator()
                
 
        self.online_resources_menu = OnlineResourcesMenu(frame)
        self.online_resources_menu_button = self.AppendMenu(
            -1,
            '&Online resources',
            self.online_resources_menu,
            ' Use resources that require an internet connection'
        )       
        
        
        self.AppendSeparator()
        
                
        self.about_button = self.Append(
            wx.ID_ABOUT,
            '&About GarlicSim...',
            ' Tell me a little bit about the GarlicSim software'
        )
        frame.Bind(
            wx.EVT_MENU,
            lambda event: garlicsim_wx.widgets.misc.AboutDialog.\
                          create_show_modal_and_destroy(frame),
            self.about_button
        )
 
########NEW FILE########
__FILENAME__ = online_resources_menu
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `OnlineResourcesMenu` class.

See its documentation for more info.
'''


import webbrowser

import wx

from garlicsim_wx.general_misc.cute_menu import CuteMenu


class OnlineResourcesMenu(CuteMenu):
    '''Menu for accessing online resources in the web browser.'''
    def __init__(self, frame):
        super(OnlineResourcesMenu, self).__init__()
        self.frame = frame
        self._build()
    
    def _build(self):
        
        frame = self.frame
        
        
        self.website_button = self.Append(
            -1,
            'Official &website...',
            ' Open the official GarlicSim website in your browser'
        )
        frame.Bind(
            wx.EVT_MENU,
            lambda event: webbrowser.open_new_tab('http://garlicsim.org'),
            self.website_button
        )
        
        
        self.online_documentation_button = self.Append(
            -1,
            'Online &documentation...',
            " Open the online version of GarlicSim's documentation in your "
            "browser"
        )
        frame.Bind(
            wx.EVT_MENU,
            lambda event: webbrowser.open_new_tab('http://docs.garlicsim.org'),
            self.online_documentation_button
        )
        
        
        self.mailing_lists_button = self.Append(
            -1,
            '&Mailing lists...',
            ''' Open the page with info about GarlicSim mailing lists\
in your browser'''
        )
        frame.Bind(
            wx.EVT_MENU,
            lambda event: webbrowser.open_new_tab(
                'http://garlicsim.org/#mailing_lists'
                ),
            self.mailing_lists_button
        )
        
        
        self.blog_button = self.Append(
            -1,
            '&Blog...',
            ' Open the GarlicSim blog in your browser'
        )
        frame.Bind(
            wx.EVT_MENU,
            lambda event: webbrowser.open_new_tab(
                'http://blog.garlicsim.org'
                ),
            self.blog_button
        )
        

        self.github_button = self.Append(
            -1,
            'Code &repository...',
            ' Open the GitHub code repository for GarlicSim in your browser'
        )
        frame.Bind(
            wx.EVT_MENU,
            lambda event: webbrowser.open_new_tab(
                'http://github.com/cool-RR/GarlicSim'
                ),
            self.github_button
        )
                

########NEW FILE########
__FILENAME__ = menu_bar
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `MenuBar` class.

See its documentation for more info.
'''

import wx

from .file_menu import FileMenu
from .edit_menu import EditMenu
from .create_menu import CreateMenu
from .node_menu import NodeMenu
from .block_menu import BlockMenu
from .window_menu import WindowMenu
from .help_menu import HelpMenu


class MenuBar(wx.MenuBar):
    '''The main menubar of garlicsim_wx.'''
    def __init__(self, frame):
        super(MenuBar, self).__init__()
        self.frame = frame
        
        is_mac = (wx.Platform == '__WXMAC__')
        
        self.file_menu = FileMenu(frame)
        self.Append(self.file_menu, '&File')
        
        self.edit_menu = EditMenu(frame)
        self.Append(self.edit_menu, '&Edit')
        # This disables a menu from the bar:
        # self.EnableTop(self.FindMenu('Edit'), False)
        # Logically it makes sense, but it makes it hard to see all the options
        # in the menu, so at least for now I'm not doing it.
        
        self.create_menu = CreateMenu(frame)
        self.Append(self.create_menu, '&Create')
        
        self.node_menu = NodeMenu(frame)
        self.Append(self.node_menu, '&Node')
        
        self.block_menu = BlockMenu(frame)
        self.Append(self.block_menu, '&Block')
        
        self.window_menu = WindowMenu(frame)
        title_of_window_menu = '&Workspace' if is_mac else '&Window'
        self.Append(self.window_menu, title_of_window_menu)
        
        self.help_menu = HelpMenu(frame)
        title_of_help_menu = 'GarlicSim &Help' if is_mac else '&Help'
        self.Append(self.help_menu, title_of_help_menu)
########NEW FILE########
__FILENAME__ = fork_by_crunching_using_menu
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `ForkByCrunchingUsingMenu` class.

See its documentation for more details.
'''

from itertools import izip

from garlicsim.general_misc.nifty_collections import OrderedDict
from garlicsim.general_misc.sleek_refs import CuteSleekValueDict
import wx

from garlicsim_wx.general_misc.cute_menu import CuteMenu


class ForkByCrunchingUsingMenu(CuteMenu):
    def __init__(self, frame):
        super(ForkByCrunchingUsingMenu, self).__init__()
        self.frame = frame
        self.item_ids_to_step_profiles = CuteSleekValueDict(lambda: None)
        self._build()
    
    def _build(self):
        
        frame = self.frame
        

        self.AppendSeparator()
        
        
        self.new_step_profile_button = self.Append(
            -1,
            '&New step profile...',
            ' Create a new step profile and fork with it'
        )
        frame.Bind(wx.EVT_MENU, self.on_new_step_profile_button,
                   self.new_step_profile_button)
        
        
    def on_new_step_profile_button(self, event):
        self.frame.crunching_controls.show()
        self.frame.crunching_controls.step_profiles_controls.\
            show_step_profile_editing_dialog(and_fork=True)
        

    def _get_step_profile_items(self):
        '''Get the menu items which correspond to step profiles.'''
        # Getting the existing menu items, while slicing out the separator and
        # "New step profile..." button:
        return list(self.GetMenuItems())[:-2]
    
        
    def _recalculate(self):
        gui_project = self.frame.gui_project
        if not gui_project:
            return
        step_profiles = gui_project.step_profiles
            
        items = self._get_step_profile_items()
        
        def find_item_of_step_profile(step_profile):
            '''Find the menu item corresponding to `step_profile`.'''
            matching_items = \
                [item for item in items if 
                self.item_ids_to_step_profiles[item.Id] == step_profile]
            assert len(matching_items) in [0, 1]
            if matching_items:
                (matching_item,) = matching_items
                return matching_item
            else:
                return None
        
        step_profiles_to_items = OrderedDict(
            ((step_profile, find_item_of_step_profile(step_profile))
             for step_profile in step_profiles)
        )
        
        needed_items = filter(None, step_profiles_to_items.values())
        unneeded_items = [item for item in items if (item not in needed_items)]
        
        for unneeded_item in unneeded_items:
            self.frame.Unbind(wx.EVT_MENU, unneeded_item)
        
        for item in items:
            self.RemoveItem(item)
            
        itemless_step_profiles = [
            step_profile for step_profile in step_profiles if
            (step_profiles_to_items[step_profile] is None)
        ]
        
        for step_profile in itemless_step_profiles:
            step_profile_text = step_profile.__repr__(
                short_form=True,
                root=gui_project.simpack,
                namespace=gui_project.namespace
            )
            new_item = wx.MenuItem(
                self,
                -1,
                step_profile_text,
                'Fork by crunching using %s' % step_profile_text
            )
            self.item_ids_to_step_profiles[new_item.Id] = step_profile
            step_profiles_to_items[step_profile] = new_item
            self.frame.Bind(
                wx.EVT_MENU,
                lambda event:
                    gui_project.fork_by_crunching(step_profile=step_profile),
                new_item
            )
            
        for i, item in enumerate(step_profiles_to_items.itervalues()):
            self.InsertItem(i, item)
            
        
        updated_items = self._get_step_profile_items()
        for item, step_profile in izip(updated_items, step_profiles):
            assert self.item_ids_to_step_profiles[item.Id] == step_profile
            
        
                
            
########NEW FILE########
__FILENAME__ = node_menu
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `NodeMenu` class.

See its documentation for more info.
'''

import wx

from garlicsim_wx.general_misc.cute_menu import CuteMenu

from .fork_by_crunching_using_menu import ForkByCrunchingUsingMenu


class NodeMenu(CuteMenu):
    '''Menu for manipulating the active node.'''
    def __init__(self, frame):
        super(NodeMenu, self).__init__()
        self.frame = frame
        self._build()
    
    def _build(self):
        
        frame = self.frame
       
        self.fork_by_editing_button = self.Append(
            -1,
            'Fork by &editing',
            " Fork the simulation by making a copy of the active node and "
            "editing it"
        )
        
        frame.Bind(
            wx.EVT_MENU,
            lambda event: frame.gui_project.fork_by_editing(),
            self.fork_by_editing_button
        )

        
        self.fork_by_crunching_button = self.Append(
            -1,
            'Fork by &crunching',
            ' Fork the simulation by crunching from the active node'
        )
        frame.Bind(
            wx.EVT_MENU,
            lambda event: frame.gui_project.fork_by_crunching(),
            self.fork_by_crunching_button
        )

        self.fork_by_crunching_using_menu = ForkByCrunchingUsingMenu(frame)
        self.fork_by_crunching_using_menu_button = self.AppendMenu(
            -1,
            'Fork by crunching &using',
            self.fork_by_crunching_using_menu,
            ' Fork by crunching from the active node using specified step '
            'profile'
        )

        
        self.AppendSeparator()
        
        
        self.properties_button = self.Append(
            -1,
            'Node &properties...',
            " See the active node's properties"
        )
        self.properties_button.Enable(False)        
        
        
        self.AppendSeparator()
        
        
        self.delete_button = self.Append(
            -1,
            '&Delete active node...',
            ' Delete the active node'
        )
        self.delete_button.Enable(False)
                
        
    def _recalculate(self):
        self.enable_in_menu_bar(
            self.frame.gui_project is not None and \
            self.frame.gui_project.active_node is not None
        )
########NEW FILE########
__FILENAME__ = window_menu
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `WindowMenu` class.

See its documentation for more info.
'''

import wx

from garlicsim_wx.general_misc.cute_menu import CuteMenu
from garlicsim_wx.general_misc import wx_tools

from garlicsim_wx.widgets.workspace_widget import \
     EVT_WORKSPACE_WIDGET_MENU_SELECT
from .workspace_menu import WorkspaceMenu


class WindowMenu(CuteMenu):
    '''Menu for controlling workspace widgets.'''
    def __init__(self, frame):
        super(WindowMenu, self).__init__()
        self.frame = frame
        self._build()
    
    def _build(self):
        
        frame = self.frame


        self.workspace_menu = WorkspaceMenu(frame)
        self.workspace_menu_button = self.AppendMenu(
            -1,
            '&Workspace',
            self.workspace_menu,
            ' Manipulate the workspace, i.e. the arrangement of widgets on '
            'the screen'
        )
        self.workspace_menu_button.Enable(False)
        
        
        self.AppendSeparator()
        
        
        self.crunching_controls_button = self.Append(
            -1,
            '&Crunching',
            ' Go to the crunching tool, which lets you control how your '
            'simulation is crunched'
        )       
        
        frame.Bind(
            wx.EVT_MENU,
            lambda event: wx_tools.post_event(
                frame.crunching_controls,
                EVT_WORKSPACE_WIDGET_MENU_SELECT
            ),
            source=self.crunching_controls_button
        )
        
        
        self.local_nodes_examiner_button = self.Append(
            -1,
            '&Local nodes examiner',
            ' Go to the local nodes examiner, which lets you manipulate '
            'tree nodes one-by-one'
        )       
        self.local_nodes_examiner_button.Enable(False)
        
        #frame.Bind(
            #wx.EVT_MENU,
            #lambda event: wx_tools.post_event(
                #frame.local_nodes_examiner,
                #EVT_WORKSPACE_WIDGET_MENU_SELECT
            #),
            #source=self.local_nodes_examiner_button
        #)
        
        
        self.playback_controls_button = self.Append(
            -1,
            '&Playback',
            ' Go to the playback controls, which let you control the onscreen '
            'playback of the simulation'
        )       
        
        frame.Bind(
            wx.EVT_MENU,
            lambda event: wx_tools.post_event(
                frame.playback_controls,
                EVT_WORKSPACE_WIDGET_MENU_SELECT
            ),
            source=self.playback_controls_button
        )
        
        
        self.seek_bar_button = self.Append(
            -1,
            'Seek-&bar',
            ' Go to the seek-bar, which lets you navigate the active timeline'
        )       
        
        frame.Bind(
            wx.EVT_MENU,
            lambda event: wx_tools.post_event(
                frame.seek_bar,
                EVT_WORKSPACE_WIDGET_MENU_SELECT
            ),
            source=self.seek_bar_button
        )
        
        
        self.shell_button = self.Append(
            -1,
            '&Shell',
            ' Go to the shell, which lets you analyze your simulation using '
            'arbitrary Python code'
        )               
        
        frame.Bind(
            wx.EVT_MENU,
            lambda event: wx_tools.post_event(
                frame.shell,
                EVT_WORKSPACE_WIDGET_MENU_SELECT
            ),
            source=self.shell_button
        )
        
        
        self.toolbox_button = self.Append(
            -1,
            'Toolbo&x',
            ' Go to the toolbox, in which you can choose between '
            'different tools to use in the other widgets'
        )       
        self.toolbox_button.Enable(False)
        
        #frame.Bind(
            #wx.EVT_MENU,
            #lambda event: wx_tools.post_event(
                #frame.toolbox,
                #EVT_WORKSPACE_WIDGET_MENU_SELECT
            #),
            #source=self.toolbox_button
        #)
        
        
        self.tree_browser_button = self.Append(
            -1,
            '&Tree browser',
            ' Go to the tree browser, which lets you navigate the time tree'
        )       
        
        frame.Bind(
            wx.EVT_MENU,
            lambda event: wx_tools.post_event(
                frame.tree_browser,
                EVT_WORKSPACE_WIDGET_MENU_SELECT
            ),
            source=self.tree_browser_button
        )
        
        
        self.workspace_widgets_buttons = [
            self.crunching_controls_button,
            #self.local_nodes_examiner_button,
            self.playback_controls_button,
            self.seek_bar_button,
            self.shell_button,
            #self.toolbox_button
            self.tree_browser_button
        ]
        
    def _recalculate(self):
        gui_project = self.frame.gui_project
        for workspace_widget_button in self.workspace_widgets_buttons:
            workspace_widget_button.Enable(gui_project is not None)
        
########NEW FILE########
__FILENAME__ = workspace_menu
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `WorkspaceMenu` class.

See its documentation for more info.
'''

import wx

from garlicsim_wx.general_misc.cute_menu import CuteMenu

class WorkspaceMenu(CuteMenu):
    '''Menu for manipulating the workspace.'''
    def __init__(self, frame):
        super(WorkspaceMenu, self).__init__()
        self.frame = frame
        self._build()
        
        
    def _build(self):

        frame = self.frame
        
        self.save_workspace_button = self.Append(
            -1,
            '&Save workspace...',
            ''' Save the current workspace configuration, so that it may be \
recalled in the future'''
        )
        self.save_workspace_button.Enable(False)
        
        
        self.delete_workspace_button = self.Append(
            -1,
            '&Delete workspace...',
            ' Delete one of the saved workspace configurations'
        )
        self.delete_workspace_button.Enable(False)
        
        
        self.AppendSeparator()
        
                
        self.delete_workspace_button = self.Append(
            -1,
            'De&fault workspace',
            ' Use the factory-default workspace configuration'
        )
        self.delete_workspace_button.Enable(False)
                

########NEW FILE########
__FILENAME__ = pickling
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `Pickler` and `Unpickler` classes.

See their documentation for more details.
'''

from garlicsim.general_misc import pickle_tools


class Pickler(pickle_tools.CutePickler):
    '''Pickler for pickling a `GuiProject`.'''
    def __init__(self, file_, protocol=2): 
        pickle_tools.CutePickler.__init__(self, file_, protocol)

    def pre_filter(self, thing):
        return (getattr(thing, '__module__', None) != '__garlicsim_shell__')

    
class Unpickler(pickle_tools.CuteUnpickler):
    '''Unpickler for unpickling a `GuiProject`.'''


########NEW FILE########
__FILENAME__ = settings
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `Settings` class.

See its documentation for more info.
'''

import garlicsim_wx

class Settings(object):
    '''A set of settings for a simpack_wx.'''
    #todo: subclass from a pretty vars-shower
    def __init__(self):
        
        self.BIG_WORKSPACE_WIDGETS = []
        '''Widgets to show in the middle of the frame.'''
        
        self.SMALL_WORKSPACE_WIDGETS = []
        '''Small widgets to show.'''
        
        self.SEEK_BAR_GRAPHS = []
        '''
        List of scalar functions that should be shown as graphs in the seek bar.
        
        These may be either scalar state functions or scalar history functions.
        '''
        
        self.STATE_CREATION_DIALOG = \
            garlicsim_wx.widgets.misc.StateCreationDialog
        '''Dialog for creating a root state.'''

########NEW FILE########
__FILENAME__ = simpack_wx_grokker
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `SimpackWxGrokker` class.

See its documentation for more info.
'''

import types

from garlicsim.general_misc import import_tools
import garlicsim.general_misc.caching

import garlicsim_wx
from garlicsim.asynchronous_crunching import crunchers

from .settings import Settings


class SimpackWxGrokker(object):
    '''Encapsulates a simpack_wx and gives useful information and tools.'''
    
    
    __metaclass__ = garlicsim.general_misc.caching.CachedType

    
    def __init__(self, simpack):
        self.simpack = simpack
        
        if isinstance(simpack, types.ModuleType):
            simpack_wx_module_name = ''.join((
                self.simpack.__name__,
                '.wx'
            ))
        
        import_tools.import_if_exists(simpack_wx_module_name, silent_fail=True)
        # This imports the `wx` submodule, if it exists, but it does *not* keep
        # a reference to it. We'll access `wx` as an attribute of the simpack
        # below.
            
        try:
            self.simpack_wx = self.simpack.wx
        except AttributeError:
            self.simpack_wx = None
            #raise Exception("Simpack has no wx") # todo: edit this
        
        self.__init_analysis_settings()
    
    
    def __init_analysis_settings(self):
        '''Analyze the simpack_wx to produce a Settings object.'''
        # todo: consider doing this in Settings.__init__
        
        # We want to access the `.settings` of our simpack_wx, but we don't
        # know if our simpack_wx is a module or some other kind of object. So
        # if it's a module, we'll try to import `settings`.
        
        self.settings = Settings()        
        
        if isinstance(self.simpack_wx, types.ModuleType) and \
           not hasattr(self.simpack_wx, 'settings'):
            
            # The `if` that we did here means: "If there's reason to suspect
            # that self.simpack_wx.settings is a module that exists but hasn't
            # been imported yet."
                
            settings_module_name = ''.join((
                self.simpack_wx.__name__,
                '.settings'
            ))
            
            import_tools.import_if_exists(settings_module_name,
                                          silent_fail=True)
            # This imports the `settings` submodule, if it exists, but it does
            # *not* keep a reference to it. We'll access `settings` as an
            # attribute of the simpack_wx below.
            
        # Checking if there are original settings at all. If there aren't,
        # we're done.
        if self.simpack_wx and hasattr(self.simpack_wx, 'settings'):
            
            original_settings = getattr(self.simpack_wx, 'settings')
        
            for setting_name in vars(self.settings).keys():
                if hasattr(original_settings, setting_name):
                    value = getattr(original_settings, setting_name)
                    setattr(self.settings, setting_name, value)
            # todo: currently throws away unrecognized attributes from the
            # simpack's settings.
        
########NEW FILE########
__FILENAME__ = step_profile_hue_default_factory
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `StepProfileHueDefaultFactory` class.

See its documentation for more details.
'''

import garlicsim_wx
from garlicsim_wx.general_misc import misc_tools
from garlicsim.general_misc import dict_tools


class StepProfileHueDefaultFactory(object):
    '''
    Default factory for making hues for representing step profiles.
    
    The goal is to have hues which are as diverse as possible. So every call to
    this default factory picks the hue that is the farthest away from all the
    other hues.
    '''
    def __init__(self, gui_project):
        self.gui_project = gui_project
        assert isinstance(self.gui_project, garlicsim_wx.GuiProject)
        
    def __call__(self):
        hues = dict_tools.get_contained(
            self.gui_project.step_profiles_to_hues,
            self.gui_project.step_profiles
        )
        return misc_tools.find_clear_place_on_circle(hues, circle_size=1)
########NEW FILE########
__FILENAME__ = GarlicSim
#!/usr/bin/env python

# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Script that starts the `garlicsim_wx` GUI.'''

import sys 
import os.path


use_psyco = False
if not ('--psyco=off' in sys.argv):
    try:
        import psyco
        use_psyco = True
    except ImportError:
        pass
    
    
def start():
    '''Start the GUI.'''
    
    import garlicsim
    import garlicsim_wx
    
    if use_psyco:
        psyco.full()
    garlicsim_wx.start()
    

if __name__ == '__main__':
    start()
########NEW FILE########
__FILENAME__ = cute_dialog
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `CuteDialog` class.

See its documentation for more info.
'''

import wx

from garlicsim_wx.general_misc import wx_tools


class CuteDialog(wx.Dialog):
    '''Improved dialog.'''
    def __init__(self, *args, **kwargs):
        if not kwargs.pop('skip_dialog_init', False):
            wx.Dialog.__init__(self, *args, **kwargs)
        self.SetBackgroundColour(wx_tools.get_background_color())

        
    def ShowModal(self):
        self.Centre(wx.BOTH)
        return super(CuteDialog, self).ShowModal()
    
    
    @classmethod
    def create_show_modal_and_destroy(cls, *args, **kwargs):
        dialog = cls(*args, **kwargs)
        try:
            result = dialog.ShowModal()
        finally:
            dialog.Destroy()
        return result
########NEW FILE########
__FILENAME__ = cute_hyper_tree_list
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `CuteHyperTreeList` class.

See its documentation for more details.
'''

from garlicsim_wx.widgets.general_misc.third_party import hypertreelist
from garlicsim_wx.widgets.general_misc.third_party import customtreectrl
from garlicsim_wx.widgets.general_misc.third_party.hypertreelist import *

from garlicsim_wx.general_misc import wx_tools


EVT_COMMAND_TREE_ITEM_RIGHT_CLICK = \
    wx.PyEventBinder(wx.wxEVT_COMMAND_TREE_ITEM_RIGHT_CLICK, 1)
'''Event saying that a tree item was right clicked.'''


class CuteHyperTreeList(HyperTreeList):
    '''An improved `HyperTreeList`.'''
    
    def __init__(self, parent, id=wx.ID_ANY, pos=wx.DefaultPosition,
                 size=wx.DefaultSize, style=0, agwStyle=wx.TR_DEFAULT_STYLE,
                 validator=wx.DefaultValidator, name='HyperTreeList'):
        
        # todo: when scrolling with scrollwheel and reaching top, should
        # probably scroll up parent window.
        
        style |= wx.WANTS_CHARS
        HyperTreeList.__init__(self, parent, id, pos, size, style, agwStyle,
                               validator, name)
        
        # Hackishly generating context menu event and tree item menu event from
        # these events:
        self.GetMainWindow().Bind(EVT_COMMAND_TREE_ITEM_RIGHT_CLICK,
                                  self.__on_command_tree_item_right_click)
        self.GetMainWindow().Bind(wx.EVT_KEY_DOWN, self.__on_key_down)
        self.GetMainWindow().Bind(wx.EVT_RIGHT_UP, self.__on_right_up)
        self.GetMainWindow().Bind(wx.EVT_CONTEXT_MENU, self.__on_context_menu)

        
    def __on_command_tree_item_right_click(self, event):
        
        new_event = hypertreelist.TreeEvent(
            customtreectrl.wxEVT_TREE_ITEM_MENU,
            self.GetId(),
            item=event.GetItem(),
            point=self.ClientToScreen(event.GetPoint())
        )
        new_event.SetEventObject(self)
        wx.PostEvent(self, new_event)
        
        
    def _point_to_item(self, point):
        return self._main_win._anchor.HitTest(
            wx.Point(*point),
            self._main_win,
            0,
            self._main_win._curColumn,
            0
        )[0]

    
    def __on_right_up(self, event):
        item = self._point_to_item(
            self._main_win.CalcUnscrolledPosition(
                event.GetPosition()
            )
        )
        if item:
            assert item is self.GetSelection()
            
            new_event = hypertreelist.TreeEvent(
                customtreectrl.wxEVT_TREE_ITEM_MENU,
                self.GetId(),
                item=item,
                point=self.ClientToScreen(event.GetPosition())
            )
            new_event.SetEventObject(self)
            wx.PostEvent(self, new_event)
            
        else:
            new_event = wx.ContextMenuEvent(
                wx.wxEVT_CONTEXT_MENU,
                self.GetId(),
                self.ClientToScreen(event.GetPosition())
            )
            new_event.SetEventObject(self)
            wx.PostEvent(self, new_event)
        
            
    def __on_key_down(self, event):
        if wx_tools.navigate_from_key_event(event):
            return
        # Hacky, either the OS or wxPython should be doing this:
        key = wx_tools.Key.get_from_key_event(event)
        if key in wx_tools.menu_keys:
            selection = self.GetSelection()
            if selection is not None:
                
                new_event = hypertreelist.TreeEvent(
                    customtreectrl.wxEVT_TREE_ITEM_MENU,
                    self.GetId(),
                    item=selection,
                )
                new_event.SetEventObject(self)
                self.GetEventHandler().ProcessEvent(new_event)
                
            else:
                wx_tools.post_event(self, wx.EVT_CONTEXT_MENU, self)
        else:
            event.Skip()


    def __on_context_menu(self, event):
        abs_position = event.GetPosition()
        position = abs_position - self.ScreenPosition
        selected_item = self.GetSelection()
        hit_item = self._point_to_item(position)
        
        if hit_item and (hit_item != selected_item):
            self._main_win.SelectItem(hit_item)
            selected_item = self.GetSelection()
            assert hit_item == selected_item
            
        if selected_item:
            new_event = hypertreelist.TreeEvent(
                customtreectrl.wxEVT_TREE_ITEM_MENU,
                self.GetId(),
                item=selected_item,
                point=(position + self.ScreenPosition)
            )
            new_event.SetEventObject(self)
            wx.PostEvent(self, new_event)
            return
        else:
            event.Skip()
########NEW FILE########
__FILENAME__ = error_dialog
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `ErrorDialog` class.

See its documentation for more details.
'''

import wx

from garlicsim_wx.widgets.general_misc.cute_dialog import CuteDialog


class ErrorDialog(wx.MessageDialog, CuteDialog):
    '''Dialog showing error message with an error icon.'''
    def __init__(self, parent, message, caption='Error'):
        wx.MessageDialog.__init__(self, parent, message, caption,
                                  wx.OK | wx.ICON_ERROR)
        CuteDialog.__init__(self, skip_dialog_init=True)
        
########NEW FILE########
__FILENAME__ = hue_control
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `HueControl` class.

See its documentation for more details.
'''

from __future__ import with_statement

import colorsys

import wx

from garlicsim_wx.widgets.general_misc.hue_selection_dialog \
     import HueSelectionDialog
from garlicsim_wx.general_misc import wx_tools
from garlicsim_wx.general_misc.emitters import Emitter


class HueControl(wx.Window):
    '''
    Widget for displaying (and possibly modifying) a hue.
    
    Clicking on the hue will open a dialog for changing it.
    '''
    def __init__(self, parent, getter, setter, emitter=None, lightness=1,
                 saturation=1, dialog_title='Select hue', size=(25, 10)):
        
        wx.Window.__init__(self, parent, size=size, style=wx.SIMPLE_BORDER)
        
        self.getter = getter
        
        self.setter = setter
                
        
        
        self.lightness = lightness
        
        self.saturation = saturation
        
        self.dialog_title = dialog_title
        
        
        self._pen = wx.Pen(wx.Colour(0, 0, 0), width=0, style=wx.TRANSPARENT)
        
        self.Bind(wx.EVT_PAINT, self.on_paint)
        self.Bind(wx.EVT_LEFT_DOWN, self.on_mouse_left_down)
        
        if emitter:
            assert isinstance(emitter, Emitter)
            self.emitter = emitter
            self.emitter.add_output(self.update)
        else:
            assert emitter is None
            self.emitter = Emitter(
                outputs=(self.update,),
                name='hue_modified'
            )
            old_setter = self.setter
            def new_setter(value):
                old_setter(value)
                self.emitter.emit()
            self.setter = new_setter
            
        
    
    def on_paint(self, event):
        dc = wx.PaintDC(self)
        color = wx_tools.hls_to_wx_color(
            (
                self.getter(),
                self.lightness,
                self.saturation
            )
        )
        dc.SetBrush(wx.Brush(color))
        dc.SetPen(self._pen)
        width, height = self.GetSize()
        dc.DrawRectangle(-5, -5, width+10, height+10)
                
    
    def on_mouse_left_down(self, event):
        self.open_editing_dialog()
      
        
    def open_editing_dialog(self):
        '''Open a dialog to edit the hue.'''
        old_hue = self.getter()
        
        with wx_tools.CursorChanger(self, wx.CURSOR_WAIT):
            hue_selection_dialog = HueSelectionDialog(
                self.GetTopLevelParent(), self.getter, self.setter,
                self.emitter,
                lightness=self.lightness, saturation=self.saturation,
                title=self.dialog_title
            )
        
        try:
            hue_selection_dialog.ShowModal()
        finally:
            hue_selection_dialog.Destroy()

            
    def update(self):
        if self: # Protecting from dead object
            self.Refresh()

        
    def Destroy(self):
        self.emitter.remove_output(self.update)
        super(HueControl, self).Destroy()
########NEW FILE########
__FILENAME__ = comparer
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `Comparer` class.

See its documentation for more details.
'''

import wx

from garlicsim_wx.general_misc import wx_tools


class Comparer(wx.Panel):
    '''Shows the new hue compared to the old hue before dialog was started.'''
    def __init__(self, hue_selection_dialog):
        style = wx.SIMPLE_BORDER if wx.Platform == '__WXGTK__' else \
                wx.SUNKEN_BORDER
        wx.Panel.__init__(self, parent=hue_selection_dialog, size=(75, 90),
                          style=style)
        self.SetDoubleBuffered(True)
        self.hue_selection_dialog = hue_selection_dialog
        self.hue = hue_selection_dialog.hue
        self.old_hls = hue_selection_dialog.old_hls
        self.old_hue = hue_selection_dialog.old_hue
        self.old_color = wx_tools.hls_to_wx_color(self.old_hls)
        self.old_brush = wx.Brush(self.old_color)
        self._pen = wx.Pen(wx.Colour(0, 0, 0), width=0, style=wx.TRANSPARENT)
        self._calculate()
        
        self.SetCursor(wx.StockCursor(wx.CURSOR_BULLSEYE))
        
        self.Bind(wx.EVT_PAINT, self.on_paint)
        self.Bind(wx.EVT_LEFT_DOWN, self.on_mouse_left_down)
        
        
    def _calculate(self):
        '''Create a brush for showing the new hue.'''
        self.color = wx_tools.hls_to_wx_color(
            (self.hue,
             self.hue_selection_dialog.lightness,
             self.hue_selection_dialog.saturation)
        )
        self.brush = wx.Brush(self.color)
        
        
    def update(self):
        '''If hue changed, show new hue.'''
        if self.hue != self.hue_selection_dialog.hue:
            self.hue = self.hue_selection_dialog.hue
            self._calculate()
            self.Refresh()

            
    def on_paint(self, event):
        w, h = self.GetClientSize()
        dc = wx.PaintDC(self)

        dc.SetPen(self._pen)
        
        dc.SetBrush(self.brush)
        dc.DrawRectangle(0, 0, w, (h // 2))
        
        dc.SetBrush(self.old_brush)
        dc.DrawRectangle(0, (h // 2), w, (h // 2) + 1)
        
                
    
    def on_mouse_left_down(self, event):
        x, y = event.GetPosition()
        w, h = self.GetClientSize()
        if y >= h // 2:
            self.hue_selection_dialog.setter(self.old_hue)
########NEW FILE########
__FILENAME__ = hue_selection_dialog
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `HueSelectionDialog` class.

See its documentation for more details.
'''

import wx

from garlicsim_wx.widgets.general_misc.cute_dialog import CuteDialog
from garlicsim_wx.general_misc.emitters import Emitter

from .wheel import Wheel
from .comparer import Comparer
from .textual import Textual


class HueSelectionDialog(CuteDialog):
    '''Dialog for changing a hue.'''
    
    def __init__(self, parent, getter, setter, emitter, lightness=1,
                 saturation=1, id=-1, title='Select hue',
                 pos=wx.DefaultPosition, size=wx.DefaultSize,
                 style=wx.DEFAULT_DIALOG_STYLE, name=wx.DialogNameStr):

        
        CuteDialog.__init__(self, parent, id, title, pos, size, style, name)
        
        self.getter = getter
        
        self.setter = setter
        
        assert isinstance(emitter, Emitter)
        self.emitter = emitter
        
        self.lightness = lightness

        self.saturation = saturation
        
        self.hue = getter()
        
        self.old_hue = self.hue
        
        self.old_hls = (self.old_hue, lightness, saturation)
        
        
        
        
        self.main_v_sizer = wx.BoxSizer(wx.VERTICAL)
        
        self.h_sizer = wx.BoxSizer(wx.HORIZONTAL)
        
        self.main_v_sizer.Add(self.h_sizer, 0)
        
        self.wheel = Wheel(self)
        
        self.h_sizer.Add(self.wheel, 0)
        
        self.v_sizer = wx.BoxSizer(wx.VERTICAL)
        
        self.h_sizer.Add(self.v_sizer, 0, wx.ALIGN_CENTER)
        
        self.comparer = Comparer(self)
        
        self.v_sizer.Add(self.comparer, 0, wx.RIGHT | wx.TOP | wx.BOTTOM,
                         border=10)
        
        self.textual = Textual(self)
        
        self.v_sizer.Add(self.textual, 0, wx.RIGHT | wx.TOP | wx.BOTTOM,
                         border=10)
                
        self.dialog_button_sizer = wx.StdDialogButtonSizer()
        
        self.main_v_sizer.Add(self.dialog_button_sizer, 0,
                              wx.ALIGN_CENTER | wx.ALL, border=10)
        
        self.ok_button = wx.Button(self, wx.ID_OK, 'Okay')
        self.dialog_button_sizer.AddButton(self.ok_button)
        self.ok_button.SetDefault()
        self.dialog_button_sizer.SetAffirmativeButton(self.ok_button)
        self.Bind(wx.EVT_BUTTON, self.on_ok, source=self.ok_button)
        
        self.cancel_button = wx.Button(self, wx.ID_CANCEL, 'Cancel')
        self.dialog_button_sizer.AddButton(self.cancel_button)
        self.Bind(wx.EVT_BUTTON, self.on_cancel, source=self.cancel_button)
        self.dialog_button_sizer.Realize()

        
        self.SetSizer(self.main_v_sizer)
        self.main_v_sizer.Fit(self)
        
        
        self.emitter.add_output(self.update)
        
        
    def on_ok(self, event):
        self.EndModal(wx.ID_OK)
        
    
    def on_cancel(self, event):
        self.setter(self.old_hue)
        self.EndModal(wx.ID_CANCEL)
        
        
    def update(self):
        '''If hue changed, update all widgets to show the new hue.'''
        self.hue = self.getter()
        self.wheel.update()
        self.comparer.update()
        self.textual.update()
        
        
    def Destroy(self):
        self.emitter.remove_output(self.update)
        super(HueSelectionDialog, self).Destroy()
########NEW FILE########
__FILENAME__ = textual
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `Textual` class.

See its documentation for more details.
'''

from __future__ import division
from __future__ import with_statement

import wx

from garlicsim_wx.general_misc import wx_tools
from garlicsim.general_misc.context_manager import ContextManager


def ratio_to_round_degrees(ratio):
    return int(ratio * 360)


def degrees_to_ratio(degrees):
    return degrees / 360


class Freezer(ContextManager):
    '''
    Freezer for not changing the `Textual`'s text value.

    Used as a context manager. Anything that happens inside the `with` suite
    will not cause the `Textual` to update its text value.
    
    This is useful because when the `Textual`'s value changes, some platforms
    automatically select all the text in the `Textual`, which is really
    annoying if you're just typing in it.
    '''
    def __init__(self, textual):
        self.textual = textual
    def __enter__(self):
        self.textual.frozen += 1
    def __exit__(self, *args, **kwargs):
        self.textual.frozen -= 1


class Textual(wx.Panel):
    '''Display (and allow modifying) the hue as a number 0-359.'''
    def __init__(self, hue_selection_dialog):
        wx.Panel.__init__(self, parent=hue_selection_dialog, size=(75, 100))
        self.SetBackgroundColour(wx_tools.get_background_color())
        
        self.hue_selection_dialog = hue_selection_dialog
        self.hue = hue_selection_dialog.hue
        
        self.frozen = 0
        self.freezer = Freezer(self)
        
        self.main_v_sizer = wx.BoxSizer(wx.VERTICAL)
        
        self.hue_static_text = wx.StaticText(self, label='Hue:')
        
        self.main_v_sizer.Add(self.hue_static_text, 0,
                              wx.ALIGN_LEFT | wx.BOTTOM, border=5)
        
        self.h_sizer = wx.BoxSizer(wx.HORIZONTAL)
        
        self.main_v_sizer.Add(self.h_sizer, 0)
        
        self.spin_ctrl = wx.SpinCtrl(self, min=0, max=359,
                                     initial=ratio_to_round_degrees(self.hue),
                                     size=(70, -1), style=wx.SP_WRAP)
        if wx.Platform == '__WXMAC__':
            self.spin_ctrl.SetValue(ratio_to_round_degrees(self.hue))
        
        self.h_sizer.Add(self.spin_ctrl, 0)
        
        self.degree_static_text = wx.StaticText(self, label=unichr(176))
        
        self.h_sizer.Add(self.degree_static_text, 0)
        
        self.SetSizerAndFit(self.main_v_sizer)
        
        self.Bind(wx.EVT_SPINCTRL, self.on_spin, source=self.spin_ctrl)
        self.Bind(wx.EVT_TEXT, self.on_text, source=self.spin_ctrl)
                    
        
    def update(self):
        '''Update to show the new hue.'''
        if not self.frozen and self.hue != self.hue_selection_dialog.hue:
            self.hue = self.hue_selection_dialog.hue
            self.spin_ctrl.SetValue(ratio_to_round_degrees(self.hue))
    
            
    def on_spin(self, event):
        self.hue_selection_dialog.setter(
            degrees_to_ratio(
                self.spin_ctrl.GetValue()
            )
        )
            
    def on_text(self, event):
        with self.freezer:
            self.hue_selection_dialog.setter(
                degrees_to_ratio(
                    self.spin_ctrl.GetValue()
                )
            )

########NEW FILE########
__FILENAME__ = wheel
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `Wheel` class.

See its documentation for more details.
'''

from __future__ import division

import itertools
import math
import colorsys

import wx

from garlicsim.general_misc import caching
from garlicsim.general_misc import cute_iter_tools
from garlicsim_wx.general_misc import wx_tools
from garlicsim_wx.general_misc import color_tools

BIG_LENGTH = 221
THICKNESS = 21
HALF_THICKNESS = THICKNESS / 2
AA_THICKNESS = 1.5 # Thickness of the anti-aliasing circle.
RADIUS = int((BIG_LENGTH / 2) - THICKNESS - 5)
SMALL_RADIUS = RADIUS - HALF_THICKNESS
BIG_RADIUS = RADIUS + HALF_THICKNESS

two_pi = math.pi * 2


@caching.cache()
def make_bitmap(lightness=1, saturation=1):
    '''Make the bitmap of the color wheel.'''
    bitmap = wx.EmptyBitmap(BIG_LENGTH, BIG_LENGTH)
    assert isinstance(bitmap, wx.Bitmap)
    dc = wx.MemoryDC(bitmap)
    
    dc.SetBrush(wx_tools.get_background_brush())
    dc.SetPen(wx.TRANSPARENT_PEN)
    dc.DrawRectangle(-5, -5, BIG_LENGTH + 10, BIG_LENGTH + 10)
    
    center_x = center_y = BIG_LENGTH // 2 
    background_color_rgb = wx_tools.wx_color_to_rgb(
        wx_tools.get_background_color()
    )
    
    for x, y in cute_iter_tools.product(xrange(BIG_LENGTH),
                                        xrange(BIG_LENGTH)):
        
        # This is a big loop so the code is optimized to keep it fast.
        
        rx, ry = (x - center_x), (y - center_y)
        distance = (rx ** 2 + ry ** 2) ** 0.5
        
        if (SMALL_RADIUS - AA_THICKNESS) <= distance <= \
           (BIG_RADIUS + AA_THICKNESS):
            
            angle = -math.atan2(rx, ry)
            hue = (angle + math.pi) / two_pi
            rgb = colorsys.hls_to_rgb(hue, lightness, saturation)
            
            if abs(distance - RADIUS) > HALF_THICKNESS:
                
                # This pixel requires some anti-aliasing.
                
                if distance < RADIUS:
                    aa_distance = SMALL_RADIUS - distance
                else: # distance > RADIUS
                    aa_distance = distance - BIG_RADIUS
                
                aa_ratio = aa_distance / AA_THICKNESS
                
                rgb = color_tools.mix_rgb(
                    aa_ratio,
                    background_color_rgb,
                    rgb
                )
                
            color = wx_tools.rgb_to_wx_color(rgb)
            pen = wx.Pen(color)
            dc.SetPen(pen)
            
            dc.DrawPoint(x, y)
        
    return bitmap


class Wheel(wx.Panel):
    '''
    Color wheel displaying current hue and allows moving to different hue.
    '''
    def __init__(self, hue_selection_dialog):
        wx.Panel.__init__(self, parent=hue_selection_dialog,
                          size=(BIG_LENGTH, BIG_LENGTH))
        self.SetDoubleBuffered(True)
        self.hue_selection_dialog = hue_selection_dialog
        self.hue = hue_selection_dialog.hue
        self.bitmap = make_bitmap(hue_selection_dialog.lightness,
                                  hue_selection_dialog.saturation)
        self._calculate_angle()
        self._pen = wx.Pen(
            wx.Colour(255, 255, 255) if hue_selection_dialog.lightness < 0.5
            else wx.Colour(0, 0, 0),
            width=2,
            style=wx.DOT
        )
        self._cursor_set_to_bullseye = False
        
        self.Bind(wx.EVT_PAINT, self.on_paint)
        self.Bind(wx.EVT_MOUSE_EVENTS, self.on_mouse)
        
    
    def on_paint(self, event):
        dc = wx.BufferedPaintDC(self)
                    
        dc.DrawBitmap(self.bitmap, 0, 0)

        
        #######################################################################
        # Drawing dashed line which marks the selected color:
        
        gc = wx.GraphicsContext.Create(dc)
        assert isinstance(gc, wx.GraphicsContext)
        gc.SetPen(self._pen)
        cx, cy = BIG_LENGTH // 2, BIG_LENGTH // 2
        start_x, start_y = cx + SMALL_RADIUS * math.sin(self.angle), \
                           cy + SMALL_RADIUS * math.cos(self.angle)
        end_x, end_y = cx + BIG_RADIUS * math.sin(self.angle), \
                       cy + BIG_RADIUS * math.cos(self.angle)
        gc.StrokeLine(start_x, start_y, end_x, end_y)

        #dc.SetPen(self._pen)
        #dc.DrawLine(start_x, start_y, end_x, end_y)
                
        
                
        
    def on_mouse(self, event):
        
        center_x = center_y = BIG_LENGTH // 2 
        x, y = event.GetPosition()
        distance = ((x - center_x) ** 2 + (y - center_y) ** 2) ** 0.5
        inside_wheel = (SMALL_RADIUS <= distance <= BIG_RADIUS)

        
        if inside_wheel and not self._cursor_set_to_bullseye:
            
            self.SetCursor(wx.StockCursor(wx.CURSOR_BULLSEYE))
            self._cursor_set_to_bullseye = True
            
        elif not inside_wheel and not self.HasCapture() and \
             self._cursor_set_to_bullseye:
            
            self.SetCursor(wx.StockCursor(wx.CURSOR_DEFAULT))
            self._cursor_set_to_bullseye = False

            
        if event.LeftIsDown():
            
            if inside_wheel and not self.HasCapture():
                self.CaptureMouse()
                
            if self.HasCapture():
                angle = -math.atan2((x - center_x), (y - center_y))
                hue = (angle + math.pi) / (math.pi * 2)
                self.hue_selection_dialog.setter(hue)
                
            
        else: # Left mouse button is up
            if self.HasCapture():
                self.ReleaseMouse()
            
                
        
    def _calculate_angle(self):
        '''Calculate the angle to represent current hue and put in `.angle`.'''
        self.angle = - (2 * self.hue - 1) * math.pi
        
        
    def update(self):
        '''If hue changed, show new hue.'''
        if self.hue != self.hue_selection_dialog.hue:
            self.hue = self.hue_selection_dialog.hue
            self._calculate_angle()
            self.Refresh()
            
        
        
    
########NEW FILE########
__FILENAME__ = knob
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `Knob` class.

See its documentation for more info.
'''

from __future__ import division

import math

import wx
import pkg_resources

from garlicsim.general_misc import math_tools
from garlicsim_wx.general_misc import wx_tools
from garlicsim_wx.general_misc import cursor_collection
from garlicsim.general_misc import binary_search
from garlicsim.general_misc import cute_iter_tools

from .snap_map import SnapMap

from . import images as __images_package
images_package = __images_package.__name__


class Knob(wx.Panel):
    '''
    A knob that sets a real value between `-infinity` and `infinity`.
    
    (Not really touching infinity.)
    
    By turning the knob with the mouse, the user changes a floating point
    variable.


    There are three "scales" that one should keep in mind when working with
    Knob:
    
    1. The "value" scale, which is the value that the actual final variable
       gets. It spans from `-infinity` to `infinity`.
    
    2. The "angle" scale, which is the angle in which the knob appears on
        the screen. It spans from `(-(5/6) * pi)` to `((5/6) * pi)`.
    
    3. As a more convenient mediator between them there's the "ratio" scale,
       which spans from `-1` to `1`, and is mapped linearly to "angle".
    
    
    The knob has snap points that can be modified with `.set_snap_point` and
    `.remove_snap_point`. These are specified by value.
    '''
    # todo future: make key that disables snapping while dragging
    # todo: consider letting the knob turn just a bit slower near the edges.
    # todo: currently forcing size to be constant, in future allow changing
    def __init__(self, parent, getter, setter, *args, **kwargs):
        '''
        Construct the knob.
        
        `getter` is the getter function used to get the value of the variable.
        `setter` is the setter function used to set the value of the variable.
        
        Note that you can't give a size argument to knob, it is always created
        with a size of (29, 29).
        '''
        
        assert 'size' not in kwargs
        kwargs['size'] = (29, 29)
        
        assert callable(setter) and callable(getter)
        self.value_getter, self.value_setter = getter, setter
        
        wx.Panel.__init__(self, parent, *args, **kwargs)
        
        self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM)
        
        self.original_bitmap = wx.BitmapFromImage(
            wx.ImageFromStream(
                pkg_resources.resource_stream(images_package, 'knob.png'),
                wx.BITMAP_TYPE_ANY
            )
        )
        
        self.Bind(wx.EVT_PAINT, self.on_paint)
        self.Bind(wx.EVT_SIZE, self.on_size)
        self.Bind(wx.EVT_MOUSE_EVENTS, self.on_mouse)
        # self.Bind(wx.EVT_ERASE_BACKGROUND, self.on_erase)
        
        self.SetCursor(cursor_collection.get_open_grab())
        
        
        self._knob_house_brush = wx.Brush(wx.Colour(0, 0, 0))
        '''Brush used to paint the circle around the knob.'''
        
        self.current_angle = 0
        '''The current angle of the knob.'''
        
        self.current_ratio = 0
        '''The current ratio of the knob.'''
        
        self.sensitivity = 25
        '''
        The knob's sensitivity.
        
        Higher values will cause faster changes in value when turning the knob.
        '''
        
        self.angle_resolution = math.pi / 180
        '''The minimal change in angle that will warrant a repaint.'''
        
        self.snap_points = []
        '''An ordered list of snap points, specified by value.'''
        
        self.base_drag_radius = 50
        '''
        The base drag radius, in pixels.
        
        This number is the basis for calculating the height of the area in which
        the user can play with the mouse to turn the knob. Beyond that area the
        knob will be turned all the way to one side, and any movement farther
        will have no effect.
        
        If there are no snap points, the total height of that area will be `2 *
        self.base_drag_radius`.
        '''
        
        self.snap_point_drag_well = 20
        '''
        The height of a snap point's drag well, in pixels.
        
        This is the height of the area on the screen in which, when the user
        drags to it, the knob will have the value of the snap point.
        
        The bigger this is, the harder the snap point "traps" the mouse.
        '''
            
        self.being_dragged = False
        '''Flag saying whether the knob is currently being dragged.'''
        
        self.snap_map = None
        '''
        The current snap map used by the knob.
        
        See documentation of SnapMap for more info.
        '''
        
        self.needs_recalculation_flag = True
        '''Flag saying whether the knob needs to be recalculated.'''
        
        self._recalculate()

    
    def _angle_to_ratio(self, angle):
        '''Convert from angle to ratio.'''
        return angle / (math.pi * 5 / 6)

    def _ratio_to_value(self, ratio):
        '''Convert from ratio to value.'''
        return self.sensitivity * \
               math_tools.sign(ratio) * \
               (4 / math.pi**2) * \
               math.log(math.cos(ratio * math.pi / 2))**2
        
    def _value_to_ratio(self, value):
        '''Convert from value to ratio.'''
        return math_tools.sign(value) * \
               (2 / math.pi) * \
               math.acos(
                   math.exp(
                       - (math.pi * math.sqrt(abs(value))) / \
                       (2 * math.sqrt(self.sensitivity))
                   )
               )

    def _ratio_to_angle(self, ratio):
        '''Convert from ratio to angle.'''
        return ratio * (math.pi * 5 / 6)
    
    def _get_snap_points_as_ratios(self):
        '''Get the list of snap points, but as ratios instead of as values.'''
        return [self._value_to_ratio(value) for value in self.snap_points]
    
    def set_snap_point(self, value):
        '''Set a snap point. Specified as value.'''
        # Not optimizing with the sorting for now
        self.snap_points.append(value)
        self.snap_points.sort()
    
    def remove_snap_point(self, value):
        '''Remove a snap point. Specified as value.'''
        self.snap_points.remove(value)
        
    def _recalculate(self):
        '''
        Recalculate the knob, changing its angle and refreshing if necessary.
        '''
        value = self.value_getter()
        self.current_ratio = self._value_to_ratio(value)
        angle = self._ratio_to_angle(self.current_ratio)
        d_angle = angle - self.current_angle
        if abs(d_angle) > self.angle_resolution:
            self.current_angle = angle
            self.Refresh()
        self.needs_recalculation_flag = False
    
    def on_paint(self, event):
        '''EVT_PAINT handler.'''
        
        # Not checking for recalculation flag, this widget is not real-time
        # enough to care about the delay.
        
        dc = wx.BufferedPaintDC(self)
        
        dc.SetBackground(wx_tools.get_background_brush())
        dc.Clear()
        
        w, h = self.GetClientSize()
        
        gc = wx.GraphicsContext.Create(dc)

        gc.SetPen(wx.TRANSPARENT_PEN)
        gc.SetBrush(self._knob_house_brush)
        
        assert isinstance(gc, wx.GraphicsContext)
        gc.Translate(w/2, h/2)
        gc.Rotate(self.current_angle)
        gc.DrawEllipse(-13.5, -13.5, 27, 27)
        gc.DrawBitmap(self.original_bitmap, -13, -13, 26, 26)
        
        #gc.DrawEllipse(5,5,2,2)
        #gc.DrawEllipse(100,200,500,500)
        
    def on_size(self, event):
        '''EVT_SIZE handler.'''
        event.Skip()
        self.Refresh()
      
    def on_mouse(self, event):
        '''EVT_MOUSE_EVENTS handler.'''
        # todo: maybe right click should give context menu with
        # 'Sensitivity...'        
        # todo: make check: if left up and has capture, release capture

        self.Refresh()
        
        (w, h) = self.GetClientSize()
        (x, y) = event.GetPositionTuple()
        
        
        if event.LeftDown():
            self.being_dragged = True
            self.snap_map = SnapMap(
                snap_point_ratios=self._get_snap_points_as_ratios(),
                base_drag_radius=self.base_drag_radius,
                snap_point_drag_well=self.snap_point_drag_well,
                initial_y=y,
                initial_ratio=self.current_ratio
            )
            
            self.SetCursor(cursor_collection.get_closed_grab())
            # SetCursor must be before CaptureMouse because of wxPython/GTK
            # weirdness
            self.CaptureMouse()
            
            return
        
        if event.LeftIsDown() and self.HasCapture():
            ratio = self.snap_map.y_to_ratio(y)
            value = self._ratio_to_value(ratio)
            self.value_setter(value)
            
                
        if event.LeftUp():
            # todo: make sure that when leaving
            # entire app, things don't get fucked
            if self.HasCapture():
                self.ReleaseMouse()
            # SetCursor must be after ReleaseMouse because of wxPython/GTK
            # weirdness
            self.SetCursor(cursor_collection.get_open_grab())
            self.being_dragged = False
            self.snap_map = None
            
            
        return
    
    """
    def on_erase(self, event):
        pass
    """
        

        
        
        
########NEW FILE########
__FILENAME__ = snap_map
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `SnapMap` class.

See its documentation for more info.
'''

from __future__ import division
from garlicsim.general_misc import misc_tools


FUZZ = 0.001
'''
The fuzziness of floating point numbers.

If two floats have a distance of less than FUZZ, we may treat them as identical.
'''


class SnapMap(object):
    '''
    Map for deciding which angle the knob will have when mouse-dragging.
    
    
    Here we have three "scales" we are playing in:
    
    1. The "ratio" scale. See documenation on Knob for that one. This controls
       the angle of the knob and the actual value of the final variable.
    
    2. The "y" scale. This is the `y` reading of the mouse on the screen.
    
    3. The "pos" scale. This is a convenient mediator between the first two. It
       is reversed from "y", because on the screen a higher number of y means
       "down", and that's just wrong. Also, it has some translation.
       
    '''
    def __init__(self, snap_point_ratios, base_drag_radius,
                 snap_point_drag_well, initial_y, initial_ratio):
        
        assert snap_point_ratios == sorted(snap_point_ratios)
        
        self.snap_point_ratios = snap_point_ratios
        '''Ordered list of snap points, as ratios.'''
        
        self.base_drag_radius = base_drag_radius
        '''
        The base drag radius, in pixels.
        
        This number is the basis for calculating the height of the area in which
        the user can play with the mouse to turn the knob. Beyond that area the
        knob will be turned all the way to one side, and any movement farther
        will have no effect.
        
        If there are no snap points, the total height of that area will be `2 *
        self.base_drag_radius`.
        '''
        
        self.snap_point_drag_well = snap_point_drag_well
        '''
        The height of a snap point's drag well, in pixels.
        
        This is the height of the area on the screen in which, when the user
        drags to it, the knob will have the value of the snap point.
        
        The bigger this is, the harder the snap point "traps" the mouse.
        '''
        
        self.initial_y = initial_y
        '''The y that was recorded when the user started dragging.'''
        
        self.initial_ratio = initial_ratio
        '''The ratio that was recorded when the user started dragging.'''
        
        self.initial_pos = self.ratio_to_pos(initial_ratio)
        '''The pos that was recorded when the user started dragging.'''
        
        self.max_pos = base_drag_radius * 2 + \
            len(snap_point_ratios) * snap_point_drag_well
        '''The maximum that a pos number can reach before it gets truncated.'''
        
        self._make_snap_point_pos_starts()
            
    
    ###########################################################################
    # # # # Converters:
    ############
    
    def ratio_to_pos(self, ratio):
        '''Convert from ratio to pos.'''
        assert (- 1 - FUZZ) <= ratio <= 1 + FUZZ
        n_snap_points_from_bottom = self._get_n_snap_points_from_bottom(ratio)
        padding = n_snap_points_from_bottom * self.snap_point_drag_well
        distance_from_bottom = ratio - (-1)
        result = padding + distance_from_bottom * self.base_drag_radius
        return result

    def pos_to_y(self, pos):
        '''Convert from pos to y.'''
        assert 0 - FUZZ <= pos <= self.max_pos + FUZZ
        relative_pos = (pos - self.initial_pos)
        return self.initial_y - relative_pos
        # doing minus because y is upside down
    
    def y_to_pos(self, y):
        '''Convert from y to pos.'''
        relative_y = (y - self.initial_y)

        # doing minus because y is upside down
        pos = self.initial_pos - relative_y
        
        if pos < 0:
            pos = 0
        if pos > self.max_pos:
            pos = self.max_pos
        
        return pos
        
        
    def pos_to_ratio(self, pos):
        '''Convert from pos to ratio.'''
        assert 0 - FUZZ <= pos <= self.max_pos + FUZZ
        
        snap_point_pos_starts_from_bottom = [
            p for p in self.snap_point_pos_starts if p <= pos
        ]
        
        padding = 0
        
        if snap_point_pos_starts_from_bottom:

            candidate_for_current_snap_point = \
                snap_point_pos_starts_from_bottom[-1]
        
            distance_from_candidate = (pos - candidate_for_current_snap_point)
            
            if distance_from_candidate < self.snap_point_drag_well:
                
                # It IS the current snap point!
                
                snap_point_pos_starts_from_bottom.remove(
                    candidate_for_current_snap_point
                )
                
                padding += distance_from_candidate
        
        padding += \
            len(snap_point_pos_starts_from_bottom) * self.snap_point_drag_well
        
        
        ratio = ((pos - padding) / self.base_drag_radius) - 1
        
        assert (- 1 - FUZZ) <= ratio <= 1 + FUZZ
        
        return ratio
        
    
    def ratio_to_y(self, ratio):
        '''Convert from ratio to y.'''
        return self.pos_to_y(self.ratio_to_pos(ratio))
    
    def y_to_ratio(self, y):
        '''Convert from y to ratio.'''
        return self.pos_to_ratio(self.y_to_pos(y))
    
    ###########################################################################
    
    def _get_n_snap_points_from_bottom(self, ratio):
        '''Get the number of snap points whose ratio is lower than `ratio`.'''
        raw_list = [s for s in self.snap_point_ratios
                    if -1 <= s <= (ratio + FUZZ)]
        
        if not raw_list:            
            return 0
        else: # len(raw_list) >= 1
            counter = 0
            counter += len(raw_list[:-1])
            last_snap_point = raw_list[-1]
            ratio_in_last_snap_point = (abs(last_snap_point - ratio) < FUZZ)
            if ratio_in_last_snap_point:
                counter += 0.5
            else:
                counter += 1
            return counter    
    
    
    def _make_snap_point_pos_starts(self):
        '''
        Make a list with a "pos start" for each snap point.
        
        A "pos start" is the lowest point, in pos scale, of a snap point's drag
        well.

        The list is not returned, but is stored as the attribute
        `.snap_point_pos_starts`.
        '''
        
        self.snap_point_pos_starts = []
        
        for i, ratio in enumerate(self.snap_point_ratios):
            self.snap_point_pos_starts.append(
                (1 + ratio) * self.base_drag_radius + \
                i * self.snap_point_drag_well
            )
            
    
    """
    def _debug_ratio_to_pos(self, step=0.1):
        if step is None: step = 10
        
        return [(i, self.ratio_to_pos(i)) for i in
                misc_tools.frange(-1, 1, step)]
    """
        

########NEW FILE########
__FILENAME__ = customtreectrl
# --------------------------------------------------------------------------------- #
# CUSTOMTREECTRL wxPython IMPLEMENTATION
# Inspired By And Heavily Based On wxGenericTreeCtrl.
#
# Andrea Gavana, @ 17 May 2006
# Latest Revision: 28 Nov 2010, 16.00 GMT
#
#
# TODO List
#
# Almost All The Features Of wx.TreeCtrl Are Available, And There Is Practically
# No Limit In What Could Be Added To This Class. The First Things That Comes
# To My Mind Are:
#
# 1. Try To Implement A More Flicker-Free Background Image In Cases Like
#    Centered Or Stretched Image (Now CustomTreeCtrl Supports Only Tiled
#    Background Images).
#
# 2. Try To Mimic Windows wx.TreeCtrl Expanding/Collapsing behaviour: CustomTreeCtrl
#    Suddenly Expands/Collapses The Nodes On Mouse Click While The Native Control
#    Has Some Kind Of "Smooth" Expanding/Collapsing, Like A Wave. I Don't Even
#    Know Where To Start To Do That.
#
# 3. Speed Up General OnPaint Things? I Have No Idea, Here CustomTreeCtrl Is Quite
#    Fast, But We Should See On Slower Machines.
#
#
# For All Kind Of Problems, Requests Of Enhancements And Bug Reports, Please
# Write To Me At:
#
# gavana@kpo.kz
# andrea.gavana@gmail.com
#
# Or, Obviously, To The wxPython Mailing List!!!
#
#
# End Of Comments
# --------------------------------------------------------------------------------- #


"""
CustomTreeCtrl is a class that mimics the behaviour of `wx.TreeCtrl`, with some more
enhancements.


Description
===========

CustomTreeCtrl is a class that mimics the behaviour of `wx.TreeCtrl`, with almost the
same base functionalities plus some more enhancements. This class does not rely on
the native control, as it is a full owner-drawn tree control.
Apart of the base functionalities of CustomTreeCtrl (described below), in addition
to the standard `wx.TreeCtrl` behaviour this class supports:

* CheckBox-type items: checkboxes are easy to handle, just selected or unselected
  state with no particular issues in handling the item's children;
* Added support for 3-state value checkbox items;
* RadioButton-type items: since I elected to put radiobuttons in CustomTreeCtrl, I
  needed some way to handle them, that made sense. So, I used the following approach:
  
  - All peer-nodes that are radiobuttons will be mutually exclusive. In other words,
    only one of a set of radiobuttons that share a common parent can be checked at
    once. If a radiobutton node becomes checked, then all of its peer radiobuttons
    must be unchecked.
  - If a radiobutton node becomes unchecked, then all of its child nodes will become
    inactive.

* Hyperlink-type items: they look like an hyperlink, with the proper mouse cursor on
  hovering;
* Multiline text items (**note**: to add a newline character in a multiline item, press
  ``Shift`` + ``Enter`` as the ``Enter`` key alone is consumed by CustomTreeCtrl to finish
  the editing and ``Ctrl`` + ``Enter`` is consumed by the platform for tab navigation);
* Enabling/disabling items (together with their plain or grayed out icons);
* Whatever non-toplevel widget can be attached next to an item;
* Possibility to horizontally align the widgets attached to tree items on the
  same tree level.
* Default selection style, gradient (horizontal/vertical) selection style and Windows
  Vista selection style;
* Customized drag and drop images built on the fly;
* Setting the CustomTreeCtrl item buttons to a personalized imagelist;
* Setting the CustomTreeCtrl check/radio item icons to a personalized imagelist;
* Changing the style of the lines that connect the items (in terms of `wx.Pen` styles);
* Using an image as a CustomTreeCtrl background (currently only in "tile" mode);
* Adding images to any item in the leftmost area of the CustomTreeCtrl client window.

And a lot more. Check the demo for an almost complete review of the functionalities.


Base Functionalities
====================

CustomTreeCtrl supports all the wx.TreeCtrl styles, except:

- ``TR_EXTENDED``: supports for this style is on the todo list (am I sure of this?).

Plus it has 3 more styles to handle checkbox-type items:

- ``TR_AUTO_CHECK_CHILD``: automatically checks/unchecks the item children;
- ``TR_AUTO_CHECK_PARENT``: automatically checks/unchecks the item parent;
- ``TR_AUTO_TOGGLE_CHILD``: automatically toggles the item children.

And a style you can use to force the horizontal alignment of all the widgets
attached to the tree items:

- ``TR_ALIGN_WINDOWS``: aligns horizontally the windows belongiing to the item on the
  same tree level.

    
All the methods available in `wx.TreeCtrl` are also available in CustomTreeCtrl.


Events
======

All the events supported by `wx.TreeCtrl` are also available in CustomTreeCtrl, with
a few exceptions:

- ``EVT_TREE_GET_INFO`` (don't know what this means);
- ``EVT_TREE_SET_INFO`` (don't know what this means);
- ``EVT_TREE_ITEM_MIDDLE_CLICK`` (not implemented, but easy to add);
- ``EVT_TREE_STATE_IMAGE_CLICK`` (no need for that, look at the checking events below).

Plus, CustomTreeCtrl supports the events related to the checkbutton-type items:

- ``EVT_TREE_ITEM_CHECKING``: an item is being checked;
- ``EVT_TREE_ITEM_CHECKED``: an item has been checked.

And to hyperlink-type items:

- ``EVT_TREE_ITEM_HYPERLINK``: an hyperlink item has been clicked (this event is sent
  after the ``EVT_TREE_SEL_CHANGED`` event).


Supported Platforms
===================

CustomTreeCtrl has been tested on the following platforms:
  * Windows (Windows XP);
  * GTK (Thanks to Michele Petrazzo);
  * Mac OS (Thanks to John Jackson).


Window Styles
=============

This class supports the following window styles:

============================== =========== ==================================================
Window Styles                  Hex Value   Description
============================== =========== ==================================================
``TR_NO_BUTTONS``                      0x0 For convenience to document that no buttons are to be drawn.
``TR_SINGLE``                          0x0 For convenience to document that only one item may be selected at a time. Selecting another item causes the current selection, if any, to be deselected. This is the default.
``TR_HAS_BUTTONS``                     0x1 Use this style to show + and - buttons to the left of parent items.
``TR_NO_LINES``                        0x4 Use this style to hide vertical level connectors.
``TR_LINES_AT_ROOT``                   0x8 Use this style to show lines between root nodes. Only applicable if ``TR_HIDE_ROOT`` is set and ``TR_NO_LINES`` is not set.
``TR_DEFAULT_STYLE``                   0x9 The set of flags that are closest to the defaults for the native control for a particular toolkit.
``TR_TWIST_BUTTONS``                  0x10 Use old Mac-twist style buttons.
``TR_MULTIPLE``                       0x20 Use this style to allow a range of items to be selected. If a second range is selected, the current range, if any, is deselected.
``TR_EXTENDED``                       0x40 Use this style to allow disjoint items to be selected. (Only partially implemented; may not work in all cases).
``TR_HAS_VARIABLE_ROW_HEIGHT``        0x80 Use this style to cause row heights to be just big enough to fit the content. If not set, all rows use the largest row height. The default is that this flag is unset.
``TR_EDIT_LABELS``                   0x200 Use this style if you wish the user to be able to edit labels in the tree control.
``TR_ROW_LINES``                     0x400 Use this style to draw a contrasting border between displayed rows.
``TR_HIDE_ROOT``                     0x800 Use this style to suppress the display of the root node, effectively causing the first-level nodes to appear as a series of root nodes.
``TR_FULL_ROW_HIGHLIGHT``           0x2000 Use this style to have the background colour and the selection highlight extend  over the entire horizontal row of the tree control window.
``TR_AUTO_CHECK_CHILD``             0x4000 Only meaningful foe checkbox-type items: when a parent item is checked/unchecked its children are checked/unchecked as well.
``TR_AUTO_TOGGLE_CHILD``            0x8000 Only meaningful foe checkbox-type items: when a parent item is checked/unchecked its children are toggled accordingly.
``TR_AUTO_CHECK_PARENT``           0x10000 Only meaningful foe checkbox-type items: when a child item is checked/unchecked its parent item is checked/unchecked as well.
``TR_ALIGN_WINDOWS``               0x20000 Flag used to align windows (in items with windows) at the same horizontal position.
============================== =========== ==================================================


Events Processing
=================

This class processes the following events:

============================== ==================================================
Event Name                     Description
============================== ==================================================
``EVT_TREE_BEGIN_DRAG``        Begin dragging with the left mouse button.
``EVT_TREE_BEGIN_LABEL_EDIT``  Begin editing a label. This can be prevented by calling `Veto()`.
``EVT_TREE_BEGIN_RDRAG``       Begin dragging with the right mouse button.
``EVT_TREE_DELETE_ITEM``       Delete an item.
``EVT_TREE_END_DRAG``          End dragging with the left or right mouse button.
``EVT_TREE_END_LABEL_EDIT``    End editing a label. This can be prevented by calling `Veto()`.
``EVT_TREE_GET_INFO``          Request information from the application (not implemented in `CustomTreeCtrl`).
``EVT_TREE_ITEM_ACTIVATED``    The item has been activated, i.e. chosen by double clicking it with mouse or from keyboard.
``EVT_TREE_ITEM_CHECKED``      A checkbox or radiobox type item has been checked.
``EVT_TREE_ITEM_CHECKING``     A checkbox or radiobox type item is being checked.
``EVT_TREE_ITEM_COLLAPSED``    The item has been collapsed.
``EVT_TREE_ITEM_COLLAPSING``   The item is being collapsed. This can be prevented by calling `Veto()`.
``EVT_TREE_ITEM_EXPANDED``     The item has been expanded.
``EVT_TREE_ITEM_EXPANDING``    The item is being expanded. This can be prevented by calling `Veto()`.
``EVT_TREE_ITEM_GETTOOLTIP``   The opportunity to set the item tooltip is being given to the application (call `TreeEvent.SetToolTip`).
``EVT_TREE_ITEM_HYPERLINK``    An hyperlink type item has been clicked.
``EVT_TREE_ITEM_MENU``         The context menu for the selected item has been requested, either by a right click or by using the menu key.
``EVT_TREE_ITEM_MIDDLE_CLICK`` The user has clicked the item with the middle mouse button (not implemented in `CustomTreeCtrl`).
``EVT_TREE_ITEM_RIGHT_CLICK``  The user has clicked the item with the right mouse button.
``EVT_TREE_KEY_DOWN``          A key has been pressed.
``EVT_TREE_SEL_CHANGED``       Selection has changed.
``EVT_TREE_SEL_CHANGING``      Selection is changing. This can be prevented by calling `Veto()`.
``EVT_TREE_SET_INFO``          Information is being supplied to the application (not implemented in `CustomTreeCtrl`).
``EVT_TREE_STATE_IMAGE_CLICK`` The state image has been clicked (not implemented in `CustomTreeCtrl`).
============================== ==================================================


License And Version
===================

CustomTreeCtrl is distributed under the wxPython license. 

Latest Revision: Andrea Gavana @ 28 Nov 2010, 16.00 GMT

Version 2.3

"""

# Version Info
__version__ = "2.3"

import wx
from wx.lib.expando import ExpandoTextCtrl

# ----------------------------------------------------------------------------
# Constants
# ----------------------------------------------------------------------------

_NO_IMAGE = -1
_PIXELS_PER_UNIT = 10

# Start editing the current item after half a second (if the mouse hasn't
# been clicked/moved)
_DELAY = 500

# wxPython version string
_VERSION_STRING = wx.VERSION_STRING

# ----------------------------------------------------------------------------
# Constants
# ----------------------------------------------------------------------------

# Enum for different images associated with a treectrl item
TreeItemIcon_Normal = 0              # not selected, not expanded
TreeItemIcon_Selected = 1            #     selected, not expanded
TreeItemIcon_Expanded = 2            # not selected,     expanded
TreeItemIcon_SelectedExpanded = 3    #     selected,     expanded

TreeItemIcon_Checked = 0             # check button,     checked
TreeItemIcon_NotChecked = 1          # check button, not checked
TreeItemIcon_Undetermined = 2        # check button, undetermined
TreeItemIcon_Flagged = 3             # radio button,     selected
TreeItemIcon_NotFlagged = 4          # radio button, not selected

# ----------------------------------------------------------------------------
# CustomTreeCtrl flags
# ----------------------------------------------------------------------------

TR_NO_BUTTONS = wx.TR_NO_BUTTONS                               # for convenience
""" For convenience to document that no buttons are to be drawn. """
TR_HAS_BUTTONS = wx.TR_HAS_BUTTONS                             # draw collapsed/expanded btns
""" Use this style to show + and - buttons to the left of parent items. """
TR_NO_LINES = wx.TR_NO_LINES                                   # don't draw lines at all
""" Use this style to hide vertical level connectors. """
TR_LINES_AT_ROOT = wx.TR_LINES_AT_ROOT                         # connect top-level nodes
""" Use this style to show lines between root nodes. Only applicable if ``TR_HIDE_ROOT`` is""" \
""" set and ``TR_NO_LINES`` is not set. """
TR_TWIST_BUTTONS = wx.TR_TWIST_BUTTONS                         # still used by wxTreeListCtrl
""" Use old Mac-twist style buttons. """
TR_SINGLE = wx.TR_SINGLE                                       # for convenience
""" For convenience to document that only one item may be selected at a time. Selecting another""" \
""" item causes the current selection, if any, to be deselected. This is the default. """
TR_MULTIPLE = wx.TR_MULTIPLE                                   # can select multiple items
""" Use this style to allow a range of items to be selected. If a second range is selected,""" \
""" the current range, if any, is deselected. """
TR_EXTENDED = wx.TR_EXTENDED                                   # TODO: allow extended selection
""" Use this style to allow disjoint items to be selected. (Only partially implemented;""" \
""" may not work in all cases). """
TR_HAS_VARIABLE_ROW_HEIGHT = wx.TR_HAS_VARIABLE_ROW_HEIGHT     # what it says
""" Use this style to cause row heights to be just big enough to fit the content.""" \
""" If not set, all rows use the largest row height. The default is that this flag is unset. """
TR_EDIT_LABELS = wx.TR_EDIT_LABELS                             # can edit item labels
""" Use this style if you wish the user to be able to edit labels in the tree control. """
TR_ROW_LINES = wx.TR_ROW_LINES                                 # put border around items
""" Use this style to draw a contrasting border between displayed rows. """
TR_HIDE_ROOT = wx.TR_HIDE_ROOT                                 # don't display root node
""" Use this style to suppress the display of the root node, effectively causing the""" \
""" first-level nodes to appear as a series of root nodes. """
TR_FULL_ROW_HIGHLIGHT = wx.TR_FULL_ROW_HIGHLIGHT               # highlight full horz space
""" Use this style to have the background colour and the selection highlight extend """ \
""" over the entire horizontal row of the tree control window. """

TR_AUTO_CHECK_CHILD = 0x04000                                  # only meaningful for checkboxes
""" Only meaningful foe checkbox-type items: when a parent item is checked/unchecked""" \
""" its children are checked/unchecked as well. """
TR_AUTO_TOGGLE_CHILD = 0x08000                                 # only meaningful for checkboxes
""" Only meaningful foe checkbox-type items: when a parent item is checked/unchecked""" \
""" its children are toggled accordingly. """
TR_AUTO_CHECK_PARENT = 0x10000                                 # only meaningful for checkboxes
""" Only meaningful foe checkbox-type items: when a child item is checked/unchecked""" \
""" its parent item is checked/unchecked as well. """
TR_ALIGN_WINDOWS = 0x20000                                     # to align windows horizontally for items at the same level
""" Flag used to align windows (in items with windows) at the same horizontal position. """

TR_DEFAULT_STYLE = wx.TR_DEFAULT_STYLE                         # default style for the tree control
""" The set of flags that are closest to the defaults for the native control for a""" \
""" particular toolkit. """

# Values for the `flags` parameter of CustomTreeCtrl.HitTest() which determine
# where exactly the specified point is situated:

TREE_HITTEST_ABOVE            = wx.TREE_HITTEST_ABOVE
TREE_HITTEST_BELOW            = wx.TREE_HITTEST_BELOW
TREE_HITTEST_NOWHERE          = wx.TREE_HITTEST_NOWHERE
# on the button associated with an item.
TREE_HITTEST_ONITEMBUTTON     = wx.TREE_HITTEST_ONITEMBUTTON
# on the bitmap associated with an item.
TREE_HITTEST_ONITEMICON       = wx.TREE_HITTEST_ONITEMICON
# on the indent associated with an item.
TREE_HITTEST_ONITEMINDENT     = wx.TREE_HITTEST_ONITEMINDENT
# on the label (string) associated with an item.
TREE_HITTEST_ONITEMLABEL      = wx.TREE_HITTEST_ONITEMLABEL
# on the right of the label associated with an item.
TREE_HITTEST_ONITEMRIGHT      = wx.TREE_HITTEST_ONITEMRIGHT
# on the label (string) associated with an item.
TREE_HITTEST_ONITEMSTATEICON  = wx.TREE_HITTEST_ONITEMSTATEICON
# on the left of the CustomTreeCtrl.
TREE_HITTEST_TOLEFT           = wx.TREE_HITTEST_TOLEFT
# on the right of the CustomTreeCtrl.
TREE_HITTEST_TORIGHT          = wx.TREE_HITTEST_TORIGHT
# on the upper part (first half) of the item.
TREE_HITTEST_ONITEMUPPERPART  = wx.TREE_HITTEST_ONITEMUPPERPART
# on the lower part (second half) of the item.
TREE_HITTEST_ONITEMLOWERPART  = wx.TREE_HITTEST_ONITEMLOWERPART
# on the check icon, if present
TREE_HITTEST_ONITEMCHECKICON  = 0x4000
# anywhere on the item
TREE_HITTEST_ONITEM  = TREE_HITTEST_ONITEMICON | TREE_HITTEST_ONITEMLABEL | TREE_HITTEST_ONITEMCHECKICON

TREE_ITEMTYPE_NORMAL = 0
TREE_ITEMTYPE_CHECK = 1
TREE_ITEMTYPE_RADIO = 2

# Background Image Style
_StyleTile = 0
_StyleStretch = 1

# Windows Vista Colours
_rgbSelectOuter = wx.Colour(170, 200, 245)
_rgbSelectInner = wx.Colour(230, 250, 250)
_rgbSelectTop = wx.Colour(210, 240, 250)
_rgbSelectBottom = wx.Colour(185, 215, 250)
_rgbNoFocusTop = wx.Colour(250, 250, 250)
_rgbNoFocusBottom = wx.Colour(235, 235, 235)
_rgbNoFocusOuter = wx.Colour(220, 220, 220)
_rgbNoFocusInner = wx.Colour(245, 245, 245)

# Flags for wx.RendererNative
_CONTROL_EXPANDED = 8
_CONTROL_CURRENT = 16
            

# ----------------------------------------------------------------------------
# CustomTreeCtrl events and binding for handling them
# ----------------------------------------------------------------------------

wxEVT_TREE_BEGIN_DRAG = wx.wxEVT_COMMAND_TREE_BEGIN_DRAG
wxEVT_TREE_BEGIN_RDRAG = wx.wxEVT_COMMAND_TREE_BEGIN_RDRAG
wxEVT_TREE_BEGIN_LABEL_EDIT = wx.wxEVT_COMMAND_TREE_BEGIN_LABEL_EDIT
wxEVT_TREE_END_LABEL_EDIT = wx.wxEVT_COMMAND_TREE_END_LABEL_EDIT
wxEVT_TREE_DELETE_ITEM = wx.wxEVT_COMMAND_TREE_DELETE_ITEM
wxEVT_TREE_GET_INFO = wx.wxEVT_COMMAND_TREE_GET_INFO
wxEVT_TREE_SET_INFO = wx.wxEVT_COMMAND_TREE_SET_INFO
wxEVT_TREE_ITEM_EXPANDED = wx.wxEVT_COMMAND_TREE_ITEM_EXPANDED
wxEVT_TREE_ITEM_EXPANDING = wx.wxEVT_COMMAND_TREE_ITEM_EXPANDING
wxEVT_TREE_ITEM_COLLAPSED = wx.wxEVT_COMMAND_TREE_ITEM_COLLAPSED
wxEVT_TREE_ITEM_COLLAPSING = wx.wxEVT_COMMAND_TREE_ITEM_COLLAPSING
wxEVT_TREE_SEL_CHANGED = wx.wxEVT_COMMAND_TREE_SEL_CHANGED
wxEVT_TREE_SEL_CHANGING = wx.wxEVT_COMMAND_TREE_SEL_CHANGING
wxEVT_TREE_KEY_DOWN = wx.wxEVT_COMMAND_TREE_KEY_DOWN
wxEVT_TREE_ITEM_ACTIVATED = wx.wxEVT_COMMAND_TREE_ITEM_ACTIVATED
wxEVT_TREE_ITEM_RIGHT_CLICK = wx.wxEVT_COMMAND_TREE_ITEM_RIGHT_CLICK
wxEVT_TREE_ITEM_MIDDLE_CLICK = wx.wxEVT_COMMAND_TREE_ITEM_MIDDLE_CLICK
wxEVT_TREE_END_DRAG = wx.wxEVT_COMMAND_TREE_END_DRAG
wxEVT_TREE_STATE_IMAGE_CLICK = wx.wxEVT_COMMAND_TREE_STATE_IMAGE_CLICK
wxEVT_TREE_ITEM_GETTOOLTIP = wx.wxEVT_COMMAND_TREE_ITEM_GETTOOLTIP
wxEVT_TREE_ITEM_MENU = wx.wxEVT_COMMAND_TREE_ITEM_MENU
wxEVT_TREE_ITEM_CHECKING = wx.NewEventType()
wxEVT_TREE_ITEM_CHECKED = wx.NewEventType()
wxEVT_TREE_ITEM_HYPERLINK = wx.NewEventType()

EVT_TREE_BEGIN_DRAG = wx.EVT_TREE_BEGIN_DRAG
""" Begin dragging with the left mouse button. """
EVT_TREE_BEGIN_RDRAG = wx.EVT_TREE_BEGIN_RDRAG
""" Begin dragging with the right mouse button. """
EVT_TREE_BEGIN_LABEL_EDIT = wx.EVT_TREE_BEGIN_LABEL_EDIT
""" Begin editing a label. This can be prevented by calling `Veto()`. """
EVT_TREE_END_LABEL_EDIT = wx.EVT_TREE_END_LABEL_EDIT
""" End editing a label. This can be prevented by calling `Veto()`. """
EVT_TREE_DELETE_ITEM = wx.EVT_TREE_DELETE_ITEM
""" Delete an item. """
EVT_TREE_GET_INFO = wx.EVT_TREE_GET_INFO
""" Request information from the application (not implemented in `CustomTreeCtrl`). """
EVT_TREE_SET_INFO = wx.EVT_TREE_SET_INFO
""" Information is being supplied to the application (not implemented in `CustomTreeCtrl`). """
EVT_TREE_ITEM_EXPANDED = wx.EVT_TREE_ITEM_EXPANDED
""" The item has been expanded. """
EVT_TREE_ITEM_EXPANDING = wx.EVT_TREE_ITEM_EXPANDING
""" The item is being expanded. This can be prevented by calling `Veto()`. """
EVT_TREE_ITEM_COLLAPSED = wx.EVT_TREE_ITEM_COLLAPSED
""" The item has been collapsed. """
EVT_TREE_ITEM_COLLAPSING = wx.EVT_TREE_ITEM_COLLAPSING
""" The item is being collapsed. This can be prevented by calling `Veto()`. """
EVT_TREE_SEL_CHANGED = wx.EVT_TREE_SEL_CHANGED
""" Selection has changed. """
EVT_TREE_SEL_CHANGING = wx.EVT_TREE_SEL_CHANGING
""" Selection is changing. This can be prevented by calling `Veto()`. """
EVT_TREE_KEY_DOWN = wx.EVT_TREE_KEY_DOWN
""" A key has been pressed. """
EVT_TREE_ITEM_ACTIVATED = wx.EVT_TREE_ITEM_ACTIVATED
""" The item has been activated, i.e. chosen by double clicking it with mouse or from keyboard. """
EVT_TREE_ITEM_RIGHT_CLICK = wx.EVT_TREE_ITEM_RIGHT_CLICK
""" The user has clicked the item with the right mouse button. """
EVT_TREE_ITEM_MIDDLE_CLICK = wx.EVT_TREE_ITEM_MIDDLE_CLICK
""" The user has clicked the item with the middle mouse button (not implemented in `CustomTreeCtrl`). """
EVT_TREE_END_DRAG = wx.EVT_TREE_END_DRAG
""" End dragging with the left or right mouse button. """
EVT_TREE_STATE_IMAGE_CLICK = wx.EVT_TREE_STATE_IMAGE_CLICK
""" The state image has been clicked (not implemented in `CustomTreeCtrl`). """
EVT_TREE_ITEM_GETTOOLTIP = wx.EVT_TREE_ITEM_GETTOOLTIP
""" The opportunity to set the item tooltip is being given to the application (call `TreeEvent.SetToolTip`). """
EVT_TREE_ITEM_MENU = wx.EVT_TREE_ITEM_MENU
""" The context menu for the selected item has been requested, either by a right click or by using the menu key. """
EVT_TREE_ITEM_CHECKING = wx.PyEventBinder(wxEVT_TREE_ITEM_CHECKING, 1)
""" A checkbox or radiobox type item is being checked. """
EVT_TREE_ITEM_CHECKED = wx.PyEventBinder(wxEVT_TREE_ITEM_CHECKED, 1)
""" A checkbox or radiobox type item has been checked. """
EVT_TREE_ITEM_HYPERLINK = wx.PyEventBinder(wxEVT_TREE_ITEM_HYPERLINK, 1)
""" An hyperlink type item has been clicked. """


# ----------------------------------------------------------------------------

def MakeDisabledBitmap(original):
    """
    Creates a disabled-looking bitmap starting from the input one.

    :param `original`: an instance of `wx.Bitmap` to be greyed-out.
    """
    
    img = original.ConvertToImage()
    return wx.BitmapFromImage(img.ConvertToGreyscale())

# ----------------------------------------------------------------------------

def DrawTreeItemButton(win, dc, rect, flags):
    """
    Draw the expanded/collapsed icon for a tree control item.

    :param `win`: an instance of `wx.Window`;
    :param `dc`: an instance of `wx.DC`;
    :param `rect`: the client rectangle where to draw the tree item button;
    :param `flags`: contains ``wx.CONTROL_EXPANDED`` bit for expanded tree items.

    :note: This is a simple replacement of `wx.RendererNative.DrawTreeItemButton`.

    :note: This method is never used in wxPython versions newer than 2.6.2.1.    
    """

    # white background
    dc.SetPen(wx.GREY_PEN)
    dc.SetBrush(wx.WHITE_BRUSH)
    dc.DrawRectangleRect(rect)

    # black lines
    xMiddle = rect.x + rect.width/2
    yMiddle = rect.y + rect.height/2

    # half of the length of the horz lines in "-" and "+"
    halfWidth = rect.width/2 - 2
    dc.SetPen(wx.BLACK_PEN)
    dc.DrawLine(xMiddle - halfWidth, yMiddle,
                xMiddle + halfWidth + 1, yMiddle)

    if not flags & _CONTROL_EXPANDED:
    
        # turn "-" into "+"
        halfHeight = rect.height/2 - 2
        dc.DrawLine(xMiddle, yMiddle - halfHeight,
                    xMiddle, yMiddle + halfHeight + 1)


def EventFlagsToSelType(style, shiftDown=False, ctrlDown=False):
    """
    Translate the key or mouse event flag to the type of selection we
    are dealing with.

    :param `style`: the main L{CustomTreeCtrl} window style flag;
    :param `shiftDown`: ``True`` if the ``Shift`` key is pressed, ``False`` otherwise;
    :param `ctrlDown`: ``True`` if the ``Ctrl`` key is pressed, ``False`` otherwise;
    """

    is_multiple = (style & TR_MULTIPLE) != 0
    extended_select = shiftDown and is_multiple
    unselect_others = not (extended_select or (ctrlDown and is_multiple))

    return is_multiple, extended_select, unselect_others

    
#---------------------------------------------------------------------------
# DragImage Implementation
# This Class Handles The Creation Of A Custom Image In Case Of Item Drag
# And Drop.
#---------------------------------------------------------------------------

class DragImage(wx.DragImage):
    """
    This class handles the creation of a custom image in case of item drag
    and drop.
    """

    def __init__(self, treeCtrl, item):
        """
        Default class constructor.
        For internal use: do not call it in your code!

        :param `treeCtrl`: the parent L{CustomTreeCtrl};
        :param `item`: one of the tree control item (an instance of L{GenericTreeItem}).
        """
        
        text = item.GetText()
        font = item.Attr().GetFont()
        colour = item.Attr().GetTextColour()
        if not colour:
            colour = wx.BLACK
        if not font:
            font = treeCtrl._normalFont
    
        backcolour = treeCtrl.GetBackgroundColour()
        r, g, b = int(backcolour.Red()), int(backcolour.Green()), int(backcolour.Blue())
        backcolour = ((r >> 1) + 20, (g >> 1) + 20, (b >> 1) + 20)
        backcolour = wx.Colour(backcolour[0], backcolour[1], backcolour[2])
        self._backgroundColour = backcolour

        tempdc = wx.ClientDC(treeCtrl)
        tempdc.SetFont(font)
        width, height, dummy = tempdc.GetMultiLineTextExtent(text + "M")
        
        image = item.GetCurrentImage()

        image_w, image_h = 0, 0
        wcheck, hcheck = 0, 0
        itemcheck = None
        itemimage = None
        ximagepos = 0
        yimagepos = 0
        xcheckpos = 0
        ycheckpos = 0
        
        if image != _NO_IMAGE:    
            if treeCtrl._imageListNormal:
                image_w, image_h = treeCtrl._imageListNormal.GetSize(image)
                image_w += 4
                itemimage = treeCtrl._imageListNormal.GetBitmap(image)
            
        checkimage = item.GetCurrentCheckedImage()

        if checkimage is not None:
            if treeCtrl._imageListCheck:
                wcheck, hcheck = treeCtrl._imageListCheck.GetSize(checkimage)
                wcheck += 4
                itemcheck = treeCtrl._imageListCheck.GetBitmap(checkimage)

        total_h = max(hcheck, height)
        total_h = max(image_h, total_h)
                
        if image_w:
            ximagepos = wcheck
            yimagepos = ((total_h > image_h) and [(total_h-image_h)/2] or [0])[0]

        if checkimage is not None:
            xcheckpos = 2
            ycheckpos = ((total_h > image_h) and [(total_h-image_h)/2] or [0])[0] + 2

        extraH = ((total_h > height) and [(total_h - height)/2] or [0])[0]
        
        xtextpos = wcheck + image_w
        ytextpos = extraH

        total_h = max(image_h, hcheck)
        total_h = max(total_h, height)
        
        if total_h < 30:
            total_h += 2            # at least 2 pixels
        else:
            total_h += total_h/10   # otherwise 10% extra spacing

        total_w = image_w + wcheck + width

        self._total_w = total_w
        self._total_h = total_h
        self._itemimage = itemimage
        self._itemcheck = itemcheck
        self._text = text
        self._colour = colour
        self._font = font
        self._xtextpos = xtextpos
        self._ytextpos = ytextpos
        self._ximagepos = ximagepos
        self._yimagepos = yimagepos
        self._xcheckpos = xcheckpos
        self._ycheckpos = ycheckpos
        self._textwidth = width
        self._textheight = height
        self._extraH = extraH
        
        self._bitmap = self.CreateBitmap()

        wx.DragImage.__init__(self, self._bitmap)


    def CreateBitmap(self):
        """ Actually creates the drag and drop bitmap for L{DragImage}. """

        memory = wx.MemoryDC()

        bitmap = wx.EmptyBitmap(self._total_w, self._total_h)
        memory.SelectObject(bitmap)

        if wx.Platform == '__WXMAC__':
            memory.SetBackground(wx.TRANSPARENT_BRUSH)
        else:
            memory.SetBackground(wx.Brush(self._backgroundColour))
        memory.SetBackgroundMode(wx.TRANSPARENT)
        memory.SetFont(self._font)
        memory.SetTextForeground(self._colour)
        memory.Clear()

        if self._itemimage:
            memory.DrawBitmap(self._itemimage, self._ximagepos, self._yimagepos, True)

        if self._itemcheck:
            memory.DrawBitmap(self._itemcheck, self._xcheckpos, self._ycheckpos, True)

        textrect = wx.Rect(self._xtextpos, self._ytextpos+self._extraH, self._textwidth, self._textheight)
        memory.DrawLabel(self._text, textrect)

        memory.SelectObject(wx.NullBitmap)
        
        # Gtk and Windows unfortunatly don't do so well with transparent
        # drawing so this hack corrects the image to have a transparent
        # background.
        if wx.Platform != '__WXMAC__':
            timg = bitmap.ConvertToImage()
            if not timg.HasAlpha():
                timg.InitAlpha()
            for y in xrange(timg.GetHeight()):
                for x in xrange(timg.GetWidth()):
                    pix = wx.Colour(timg.GetRed(x, y),
                                    timg.GetGreen(x, y),
                                    timg.GetBlue(x, y))
                    if pix == self._backgroundColour:
                        timg.SetAlpha(x, y, 0)
            bitmap = timg.ConvertToBitmap()
        return bitmap        

    
# ----------------------------------------------------------------------------
# TreeItemAttr: a structure containing the visual attributes of an item
# ----------------------------------------------------------------------------

class TreeItemAttr(object):
    """ Creates the item attributes (text colour, background colour and font). """
    
    def __init__(self, colText=wx.NullColour, colBack=wx.NullColour, font=wx.NullFont):
        """
        Default class constructor.
        For internal use: do not call it in your code!

        :param `colText`: the text colour;
        :param `colBack`: the tree item background colour;
        :param `font`: the tree item font.
        """
        
        self._colText = colText
        self._colBack = colBack
        self._font = font

    # setters
    def SetTextColour(self, colText):
        """
        Sets the text colour attribute.

        :param `colText`: an instance of `wx.Colour`.
        """
        
        self._colText = colText


    def SetBackgroundColour(self, colBack):
        """
        Sets the item background colour attribute.

        :param `colBack`: an instance of `wx.Colour`.
        """
        
        self._colBack = colBack

        
    def SetFont(self, font):
        """
        Sets the item font attribute.

        :param `font`: an instance of `wx.Font`.
        """
        
        self._font = font

        
    # accessors
    def HasTextColour(self):
        """Returns whether the attribute has text colour."""
        
        return self._colText != wx.NullColour


    def HasBackgroundColour(self):
        """Returns whether the attribute has background colour."""
        
        return self._colBack != wx.NullColour


    def HasFont(self):
        """Returns whether the attribute has font."""

        return self._font != wx.NullFont


    # getters
    def GetTextColour(self):
        """Returns the attribute text colour."""
        
        return self._colText

    
    def GetBackgroundColour(self):
        """Returns the attribute background colour."""

        return self._colBack

    
    def GetFont(self):
        """Returns the attribute font."""

        return self._font


# ----------------------------------------------------------------------------
# CommandTreeEvent Is A Special Subclassing Of wx.PyCommandEvent
#
# NB: Note That Not All The Accessors Make Sense For All The Events, See The
# Event Description Below. 
# ----------------------------------------------------------------------------

class CommandTreeEvent(wx.PyCommandEvent):
    """
    CommandTreeEvent is a special subclassing of `wx.PyCommandEvent`.

    :note: Not all the accessors make sense for all the events, see the event description for every method in this class. 
    """
    
    def __init__(self, evtType, evtId, item=None, evtKey=None, point=None,
                 label=None, **kwargs):
        """
        Default class constructor.
        For internal use: do not call it in your code!

        :param `evtType`: the event type;
        :param `evtId`: the event identifier;
        :param `item`: an instance of L{GenericTreeItem};
        :param `evtKey`: a character ordinal;
        :param `point`: an instance of `wx.Point`;
        :param `label`: a L{GenericTreeItem} text label.
        """

        wx.PyCommandEvent.__init__(self, evtType, evtId, **kwargs)
        self._item = item
        self._evtKey = evtKey
        self._pointDrag = point
        self._label = label
        

    def GetItem(self):
        """
        Gets the item on which the operation was performed or the newly selected
        item for ``EVT_TREE_SEL_CHANGED`` and ``EVT_TREE_SEL_CHANGING`` events.
        """
        
        return self._item

    
    def SetItem(self, item):
        """
        Sets the item on which the operation was performed or the newly selected
        item for ``EVT_TREE_SEL_CHANGED`` and ``EVT_TREE_SEL_CHANGING`` events.

        :param `item`: an instance of L{GenericTreeItem}.        
        """

        self._item = item


    def GetOldItem(self):
        """
        Returns the previously selected item for ``EVT_TREE_SEL_CHANGED`` and
        ``EVT_TREE_SEL_CHANGING`` events.
        """

        return self._itemOld
    

    def SetOldItem(self, item):
        """
        Returns the previously selected item for ``EVT_TREE_SEL_CHANGED`` and
        ``EVT_TREE_SEL_CHANGING`` events.

        :param `item`: an instance of L{GenericTreeItem}.        
        """
        
        self._itemOld = item


    def GetPoint(self):
        """
        Returns the point where the mouse was when the drag operation started
        (for ``EVT_TREE_BEGIN_DRAG`` and ``EVT_TREE_BEGIN_RDRAG`` events only)
        or the click position.
        """

        return self._pointDrag

    
    def SetPoint(self, pt):
        """
        Sets the point where the mouse was when the drag operation started
        (for ``EVT_TREE_BEGIN_DRAG`` and ``EVT_TREE_BEGIN_RDRAG`` events only)
        or the click position.

        :param `pt`: an instance of `wx.Point`.        
        """
        
        self._pointDrag = pt


    def GetKeyEvent(self):
        """ Returns the keyboard data (for ``EVT_TREE_KEY_DOWN`` event only)."""
        
        return self._evtKey


    def GetKeyCode(self):
        """ Returns the integer key code (for ``EVT_TREE_KEY_DOWN`` event only)."""

        return self._evtKey.GetKeyCode()

    
    def SetKeyEvent(self, event):
        """
        Sets the keyboard data (for ``EVT_TREE_KEY_DOWN`` event only).

        :param `event`: a L{TreeEvent} event to be processed.
        """

        self._evtKey = event
        

    def GetLabel(self):
        """
        Returns the item text (for ``EVT_TREE_BEGIN_LABEL_EDIT`` and
        ``EVT_TREE_END_LABEL_EDIT`` events only).
        """

        return self._label

    
    def SetLabel(self, label):
        """
        Sets the item text (for ``EVT_TREE_BEGIN_LABEL_EDIT`` and
        ``EVT_TREE_END_LABEL_EDIT`` events only).

        :param `label`: a string containing the new item text.        
        """

        self._label = label


    def IsEditCancelled(self):
        """
        Returns the edit cancel flag (for ``EVT_TREE_BEGIN_LABEL_EDIT`` and
        ``EVT_TREE_END_LABEL_EDIT`` events only).
        """

        return self._editCancelled


    def SetEditCanceled(self, editCancelled):
        """
        Sets the edit cancel flag (for ``EVT_TREE_BEGIN_LABEL_EDIT`` and
        ``EVT_TREE_END_LABEL_EDIT`` events only).

        :param `editCancelled`: ``True`` to cancel the editing, ``False`` otherwise.        
        """

        self._editCancelled = editCancelled


    def SetToolTip(self, toolTip):
        """
        Sets the tooltip for the item (for ``EVT_TREE_ITEM_GETTOOLTIP`` events).

        :param `tooltip`: a string representing the item tooltip.
        """

        self._label = toolTip

        
    def GetToolTip(self):
        """Returns the tooltip for the item (for ``EVT_TREE_ITEM_GETTOOLTIP`` events)."""

        return self._label
    

# ----------------------------------------------------------------------------
# TreeEvent is a special class for all events associated with tree controls
#
# NB: note that not all accessors make sense for all events, see the event
#     descriptions below
# ----------------------------------------------------------------------------

class TreeEvent(CommandTreeEvent):
    """
    `TreeEvent` is a special class for all events associated with tree controls.
    
    :note: Not all accessors make sense for all events, see the event descriptions below.
    """
    def __init__(self, evtType, evtId, item=None, evtKey=None, point=None,
                 label=None, **kwargs):
        """
        Default class constructor.
        For internal use: do not call it in your code!

        :param `evtType`: the event type;
        :param `evtId`: the event identifier;
        :param `item`: an instance of L{GenericTreeItem};
        :param `evtKey`: a character ordinal;
        :param `point`: an instance of `wx.Point`;
        :param `label`: a L{GenericTreeItem} text label.
        """

        CommandTreeEvent.__init__(self, evtType, evtId, item, evtKey, point, label, **kwargs)
        self.notify = wx.NotifyEvent(evtType, evtId)


    def GetNotifyEvent(self):
        """Returns the actual `wx.NotifyEvent`."""
        
        return self.notify


    def IsAllowed(self):
        """
        Returns ``True`` if the change is allowed (L{Veto} hasn't been called) or
        ``False`` otherwise (if it was).
        """

        return self.notify.IsAllowed()


    def Veto(self):
        """
        Prevents the change announced by this event from happening.

        :note: It is in general a good idea to notify the user about the reasons
         for vetoing the change because otherwise the applications behaviour (which
         just refuses to do what the user wants) might be quite surprising.
        """

        self.notify.Veto()


    def Allow(self):
        """
        This is the opposite of L{Veto}: it explicitly allows the event to be processed.
        For most events it is not necessary to call this method as the events are
        allowed anyhow but some are forbidden by default (this will be mentioned
        in the corresponding event description).
        """

        self.notify.Allow()
        
    
# -----------------------------------------------------------------------------
# Auxiliary Classes: TreeRenameTimer
# -----------------------------------------------------------------------------

class TreeRenameTimer(wx.Timer):
    """ Timer used for enabling in-place edit."""

    def __init__(self, owner):
        """
        Default class constructor.
        For internal use: do not call it in your code!

        :param `owner`: the `wx.Timer` owner (an instance of L{CustomTreeCtrl}).
        """
        
        wx.Timer.__init__(self)
        self._owner = owner        


    def Notify(self):
        """ The timer has expired. """

        self._owner.OnRenameTimer()


# -----------------------------------------------------------------------------
# Auxiliary Classes: TreeTextCtrl
# This Is The Temporary ExpandoTextCtrl Created When You Edit The Text Of An Item
# -----------------------------------------------------------------------------

class TreeTextCtrl(ExpandoTextCtrl):
    """
    Control used for in-place edit.

    This is a subclass of `ExpandoTextCtrl` as L{CustomTreeCtrl} supports multiline
    text items.

    :note: To add a newline character in a multiline item, press ``Shift`` + ``Enter`` as the ``Enter`` key alone is consumed by L{CustomTreeCtrl} to finish the editing and ``Ctrl`` + ``Enter`` is consumed by the platform for tab navigation.
    """

    def __init__(self, owner, item=None):
        """
        Default class constructor.
        For internal use: do not call it in your code!

        :param `owner`: the control parent (an instance of L{CustomTreeCtrl});
        :param `item`: an instance of L{GenericTreeItem}.
        """
        
        self._owner = owner
        self._itemEdited = item
        self._startValue = item.GetText()
        self._finished = False
        self._aboutToFinish = False
        self._currentValue = self._startValue

        w = self._itemEdited.GetWidth()
        h = self._itemEdited.GetHeight()

        wnd = self._itemEdited.GetWindow()
        if wnd:
            w = w - self._itemEdited.GetWindowSize()[0]
            h = 0

        x, y = self._owner.CalcScrolledPosition(item.GetX(), item.GetY())

        image_h = 0
        image_w = 0

        image = item.GetCurrentImage()

        if image != _NO_IMAGE:
    
            if self._owner._imageListNormal:
                image_w, image_h = self._owner._imageListNormal.GetSize(image)
                image_w += 4
        
            else:
        
                raise Exception("\n ERROR: You Must Create An Image List To Use Images!")

        checkimage = item.GetCurrentCheckedImage()

        if checkimage is not None:
            wcheck, hcheck = self._owner._imageListCheck.GetSize(checkimage)
            wcheck += 4
        else:
            wcheck = hcheck = 0

        if wnd:
            h = max(hcheck, image_h)
            dc = wx.ClientDC(self._owner)
            h = max(h, dc.GetTextExtent("Aq")[1])
            h = h + 2
            
        # FIXME: what are all these hardcoded 4, 8 and 11s really?
        x += image_w + wcheck
        w -= image_w + 4 + wcheck

        expandoStyle = wx.WANTS_CHARS
        if wx.Platform in ["__WXGTK__", "__WXMAC__"]:
            expandoStyle |= wx.SIMPLE_BORDER
            xSize, ySize = w + 25, h
        else:
            expandoStyle |= wx.SUNKEN_BORDER
            xSize, ySize = w + 25, h+2
            
        ExpandoTextCtrl.__init__(self, self._owner, wx.ID_ANY, self._startValue,
                                 wx.Point(x - 4, y), wx.Size(xSize, ySize),
                                 expandoStyle)

        if wx.Platform == "__WXMAC__":
            self.SetFont(owner.GetFont())
            bs = self.GetBestSize()
            self.SetSize((-1, bs.height))
        
        self.Bind(wx.EVT_CHAR, self.OnChar)
        self.Bind(wx.EVT_KEY_UP, self.OnKeyUp)
        self.Bind(wx.EVT_KILL_FOCUS, self.OnKillFocus)
    

    def AcceptChanges(self):
        """Accepts/refuses the changes made by the user."""

        value = self.GetValue()

        if value == self._startValue:
            # nothing changed, always accept
            # when an item remains unchanged, the owner
            # needs to be notified that the user decided
            # not to change the tree item label, and that
            # the edit has been cancelled
            self._owner.OnRenameCancelled(self._itemEdited)
            return True

        if not self._owner.OnRenameAccept(self._itemEdited, value):
            # vetoed by the user
            return False

        # accepted, do rename the item
        self._owner.SetItemText(self._itemEdited, value)
        
        return True


    def Finish(self):
        """Finish editing."""

        if not self._finished:        
            self._finished = True
            self._owner.SetFocusIgnoringChildren()
            self._owner.ResetTextControl()
        

    def OnChar(self, event):
        """
        Handles the ``wx.EVT_CHAR`` event for L{TreeTextCtrl}.

        :param `event`: a `wx.KeyEvent` event to be processed.
        """

        keycode = event.GetKeyCode()
        shiftDown = event.ShiftDown()

        if keycode in [wx.WXK_RETURN, wx.WXK_NUMPAD_ENTER]:
            if shiftDown:
                event.Skip()
            else:
                self._aboutToFinish = True
                self.SetValue(self._currentValue)
                # Notify the owner about the changes
                self.AcceptChanges()
                # Even if vetoed, close the control (consistent with MSW)
                wx.CallAfter(self.Finish)

        elif keycode == wx.WXK_ESCAPE:
            self.StopEditing()

        else:
            event.Skip()
    

    def OnKeyUp(self, event):
        """
        Handles the ``wx.EVT_KEY_UP`` event for L{TreeTextCtrl}.

        :param `event`: a `wx.KeyEvent` event to be processed.
        """

        if not self._finished:

            # auto-grow the textctrl:
            parentSize = self._owner.GetSize()
            myPos = self.GetPosition()
            mySize = self.GetSize()

            dc = wx.ClientDC(self)
            sx, sy, dummy = dc.GetMultiLineTextExtent(self.GetValue() + "M")

            if myPos.x + sx > parentSize.x:
                sx = parentSize.x - myPos.x
            if mySize.x > sx:
                sx = mySize.x
                
            self.SetSize((sx, -1))
            self._currentValue = self.GetValue()

        event.Skip()


    def OnKillFocus(self, event):
        """
        Handles the ``wx.EVT_KILL_FOCUS`` event for L{TreeTextCtrl}.

        :param `event`: a `wx.FocusEvent` event to be processed.
        """
        
        if not self._finished and not self._aboutToFinish:
        
            # We must finish regardless of success, otherwise we'll get
            # focus problems:
            
            if not self.AcceptChanges():
                self._owner.OnRenameCancelled(self._itemEdited)
        
        # We must let the native text control handle focus, too, otherwise
        # it could have problems with the cursor (e.g., in wxGTK).
        event.Skip()


    def StopEditing(self):
        """Suddenly stops the editing."""

        self._owner.OnRenameCancelled(self._itemEdited)
        self.Finish()
        
    
    def item(self):
        """Returns the item currently edited."""

        return self._itemEdited 


# -----------------------------------------------------------------------------
# Auxiliary Classes: TreeFindTimer
# Timer Used To Clear CustomTreeCtrl._findPrefix If No Key Was Pressed For A
# Sufficiently Long Time.
# -----------------------------------------------------------------------------

class TreeFindTimer(wx.Timer):
    """
    Timer used to clear the L{CustomTreeCtrl} `_findPrefix` attribute if no
    key was pressed for a sufficiently long time.
    """

    def __init__(self, owner):
        """
        Default class constructor.
        For internal use: do not call it in your code!

        :param `owner`: the `wx.Timer` owner (an instance of L{CustomTreeCtrl}).        
        """

        wx.Timer.__init__(self)
        self._owner = owner


    def Notify(self):
        """The timer has expired."""

        self._owner._findPrefix = ""


# -----------------------------------------------------------------------------
# GenericTreeItem Implementation.
# This Class Holds All The Information And Methods For Every Single Item In
# CustomTreeCtrl.
# -----------------------------------------------------------------------------

class GenericTreeItem(object):
    """
    This class holds all the information and methods for every single item in
    L{CustomTreeCtrl}. This is a generic implementation of `wx.TreeItem`.
    """
    
    def __init__(self, parent, text="", ct_type=0, wnd=None, image=-1, selImage=-1, data=None):
        """
        Default class constructor.
        For internal use: do not call it in your code!

        :param `parent`: the tree item parent (may be ``None`` for root items);
        :param `text`: the tree item text;
        :param `ct_type`: the tree item kind. May be one of the following integers:

         =============== =========================================
         `ct_type` Value Description
         =============== =========================================
                0        A normal item
                1        A checkbox-like item
                2        A radiobutton-type item
         =============== =========================================

        :param `wnd`: if not ``None``, a non-toplevel window to be displayed next to
         the item;
        :param `image`: an index within the normal image list specifying the image to
         use for the item in unselected state;
        :param `selImage`: an index within the normal image list specifying the image to
         use for the item in selected state; if `image` > -1 and `selImage` is -1, the
         same image is used for both selected and unselected items;
        :param `data`: associate the given Python object `data` with the item.

        :note: Regarding radiobutton-type items (with `ct_type` = 2), the following
         approach is used:
         
         - All peer-nodes that are radiobuttons will be mutually exclusive. In other words,
           only one of a set of radiobuttons that share a common parent can be checked at
           once. If a radiobutton node becomes checked, then all of its peer radiobuttons
           must be unchecked.
         - If a radiobutton node becomes unchecked, then all of its child nodes will become
           inactive.
        
        """
        
        # since there can be very many of these, we save size by chosing
        # the smallest representation for the elements and by ordering
        # the members to avoid padding.
        self._text = text       # label to be rendered for item
        self._data = data       # user-provided data

        self._children  = []    # list of children
        self._parent = parent   # parent of this item

        self._attr = None       # attributes???

        # tree ctrl images for the normal, selected, expanded and
        # expanded+selected states
        self._images = [-1, -1, -1, -1]
        self._images[TreeItemIcon_Normal] = image
        self._images[TreeItemIcon_Selected] = selImage
        self._images[TreeItemIcon_Expanded] = _NO_IMAGE
        self._images[TreeItemIcon_SelectedExpanded] = _NO_IMAGE

        self._checkedimages = [None, None, None, None, None]
        self._leftimage = _NO_IMAGE

        self._x = 0             # (virtual) offset from top
        self._y = 0             # (virtual) offset from left
        self._width = 0         # width of this item
        self._height = 0        # height of this item

        self._isCollapsed = True
        self._hasHilight = False    # same as focused
        self._hasPlus = False       # used for item which doesn't have
                                    # children but has a [+] button
        self._isBold = False        # render the label in bold font
        self._isItalic = False      # render the label in italic font
        self._ownsAttr = False      # delete attribute when done
        self._type = ct_type        # item type: 0=normal, 1=check, 2=radio
        self._is3State = False      # true for 3-state checkbox items
        self._checked = 0           # only meaningful for check and radio items
        self._enabled = True        # flag to enable/disable an item
        self._hypertext = False     # indicates if the item is hypertext
        self._visited = False       # visited state for an hypertext item

        if self._type > 0:
            # do not construct the array for normal items
            self._checkedimages[TreeItemIcon_Checked] = 0
            self._checkedimages[TreeItemIcon_NotChecked] = 1
            self._checkedimages[TreeItemIcon_Undetermined] = 2
            self._checkedimages[TreeItemIcon_Flagged] = 3
            self._checkedimages[TreeItemIcon_NotFlagged] = 4
        
        if parent:
            if parent.GetType() == 2 and not parent.IsChecked():
                # if the node parent is a radio not enabled, we are disabled
                self._enabled = False

        self._wnd = wnd             # are we holding a window?

        if wnd:
            self.SetWindow(wnd)
        

    def IsOk(self):
        """
        Returns whether the item is ok or not.

        :note: This method always returns ``True``, it has been added for
         backward compatibility with the wxWidgets C++ implementation.
        """
        
        return True
    

    def GetChildren(self):
        """Returns the item's children."""

        return self._children 


    def GetText(self):
        """Returns the item text."""

        return self._text 


    def GetImage(self, which=TreeItemIcon_Normal):
        """
        Returns the item image for a particular item state.

        :param `which`: can be one of the following bits:

         ================================= ========================
         Item State                        Description
         ================================= ========================
         ``TreeItemIcon_Normal``           To get the normal item image
         ``TreeItemIcon_Selected``         To get the selected item image (i.e. the image which is shown when the item is currently selected)
         ``TreeItemIcon_Expanded``         To get the expanded image (this only makes sense for items which have children - then this image is shown when the item is expanded and the normal image is shown when it is collapsed)
         ``TreeItemIcon_SelectedExpanded`` To get the selected expanded image (which is shown when an expanded item is currently selected) 
         ================================= ========================

        """
        
        return self._images[which] 


    def GetCheckedImage(self, which=TreeItemIcon_Checked):
        """
        Returns the item check image.

        :param `which`: can be one of the following bits:

         ================================= ========================
         Item State                        Description
         ================================= ========================
         ``TreeItemIcon_Checked``          To get the checkbox checked item image
         ``TreeItemIcon_NotChecked``       To get the checkbox unchecked item image
         ``TreeItemIcon_Undetermined``     To get the checkbox undetermined state item image
         ``TreeItemIcon_Flagged``          To get the radiobutton checked image
         ``TreeItemIcon_NotFlagged``       To get the radiobutton unchecked image
         ================================= ========================

        :note: This method is meaningful only for radio & check items.
        """

        return self._checkedimages[which]


    def GetLeftImage(self):
        """
        Returns the leftmost image associated to this item, i.e. the image on the
        leftmost part of the client area of L{CustomTreeCtrl}.
        """

        return self._leftimage
    

    def GetData(self):
        """Returns the data associated to this item."""
        
        return self._data 


    def SetImage(self, image, which):
        """
        Sets the item image.

        :param `image`: an index within the normal image list specifying the image to use;
        :param `which`: the image kind.
        
        :see: L{GetImage} for a description of the `which` parameter.
        """

        self._images[which] = image


    def SetLeftImage(self, image):
        """
        Sets the item leftmost image, i.e. the image associated to the item on the leftmost
        part of the L{CustomTreeCtrl} client area.

        :param `image`: an index within the left image list specifying the image to
         use for the item in the leftmost part of the client area.
        """

        self._leftimage = image

        
    def SetData(self, data):
        """
        Sets the data associated to this item.

        :param `data`: can be any Python object.
        """

        self._data = data 


    def SetHasPlus(self, has=True):
        """
        Sets whether an item has the 'plus' button.

        :param `has`: ``True`` to set the 'plus' button on the item, ``False`` otherwise.
        """

        self._hasPlus = has 


    def SetBold(self, bold):
        """
        Sets the item font bold.

        :parameter `bold`: ``True`` to have a bold font item, ``False`` otherwise.
        """

        self._isBold = bold 


    def SetItalic(self, italic):
        """
        Sets the item font italic.

        :parameter `italic`: ``True`` to have an italic font item, ``False`` otherwise.
        """

        self._isItalic = italic
        

    def GetX(self):
        """Returns the `x` position on an item, in logical coordinates. """

        return self._x 


    def GetY(self):
        """Returns the `y` position on an item, in logical coordinates. """

        return self._y 


    def SetX(self, x):
        """
        Sets the `x` position on an item, in logical coordinates.

        :param `x`: an integer specifying the x position of the item.
        """

        self._x = x 


    def SetY(self, y):
        """
        Sets the `y` position on an item, in logical coordinates.

        :param `y`: an integer specifying the y position of the item.
        """

        self._y = y 


    def GetHeight(self):
        """Returns the height of the item."""

        return self._height 


    def GetWidth(self):
        """Returns the width of the item."""

        return self._width 


    def SetHeight(self, h):
        """
        Sets the item's height.

        :param `h`: an integer specifying the item's height.
        """

        self._height = h

        
    def SetWidth(self, w):
        """
        Sets the item's width.

        :param `w`: an integer specifying the item's width.
        """

        self._width = w 


    def SetWindow(self, wnd):
        """
        Sets the window associated to the item.

        :param `wnd`: a non-toplevel window to be displayed next to the item.
        """

        self._wnd = wnd

        if wnd.GetSizer():      # the window is a complex one hold by a sizer
            size = wnd.GetBestSize()
        else:                   # simple window, without sizers
            size = wnd.GetSize()

        # We have to bind the wx.EVT_SET_FOCUS for the associated window
        # No other solution to handle the focus changing from an item in
        # CustomTreeCtrl and the window associated to an item
        # Do better strategies exist?
        self._wnd.Bind(wx.EVT_SET_FOCUS, self.OnSetFocus)
        
        self._height = size.GetHeight() + 2
        self._width = size.GetWidth()
        self._windowsize = size
        
        # We don't show the window if the item is collapsed
        if self._isCollapsed:
            self._wnd.Show(False)

        # The window is enabled only if the item is enabled                
        self._wnd.Enable(self._enabled)
        self._windowenabled = self._enabled


    def GetWindow(self):
        """Returns the window associated to the item (if any)."""

        return self._wnd        


    def DeleteWindow(self):
        """Deletes the window associated to the item (if any)."""

        if self._wnd:
            self._wnd.Destroy()
            self._wnd = None
        

    def GetWindowEnabled(self):
        """Returns whether the associated window is enabled or not."""

        if not self._wnd:
            raise Exception("\nERROR: This Item Has No Window Associated")

        return self._windowenabled


    def SetWindowEnabled(self, enable=True):
        """
        Sets whether the associated window is enabled or not.

        :param `enable`: ``True`` to enable the associated window, ``False`` to disable it.
        """

        if not self._wnd:
            raise Exception("\nERROR: This Item Has No Window Associated")

        self._windowenabled = enable
        self._wnd.Enable(enable)


    def GetWindowSize(self):
        """Returns the associated window size."""
        
        return self._windowsize        


    def OnSetFocus(self, event):
        """
        Handles the ``wx.EVT_SET_FOCUS`` event for the window associated with the item.

        :param `event`: a `wx.FocusEvent` event to be processed.        
        """

        treectrl = self._wnd.GetParent()
        select = treectrl.GetSelection()

        # If the window is associated to an item that currently is selected
        # (has focus) we don't kill the focus. Otherwise we do it.
        if select != self:
            treectrl._hasFocus = False
        else:
            treectrl._hasFocus = True
            
        event.Skip()


    def GetType(self):
        """
        Returns the item type.

        :see: L{SetType} and L{__init__} for a description of valid item types.        
        """

        return self._type
    

    def SetType(self, ct_type):
        """
        Sets the item type.

        :param `ct_type`: May be one of the following integers:

         =============== =========================================
         `ct_type` Value Description
         =============== =========================================
                0        A normal item
                1        A checkbox-like item
                2        A radiobutton-type item
         =============== =========================================

        :note: Regarding radiobutton-type items (with `ct_type` = 2), the following
         approach is used:
         
         - All peer-nodes that are radiobuttons will be mutually exclusive. In other words,
           only one of a set of radiobuttons that share a common parent can be checked at
           once. If a radiobutton node becomes checked, then all of its peer radiobuttons
           must be unchecked.
         - If a radiobutton node becomes unchecked, then all of its child nodes will become
           inactive.
        """

        self._type = ct_type


    def SetHyperText(self, hyper=True):
        """
        Sets whether the item is hypertext or not.

        :param `hyper`: ``True`` to set hypertext behaviour, ``False`` otherwise.
        """
        
        self._hypertext = hyper


    def SetVisited(self, visited=True):
        """
        Sets whether an hypertext item was visited or not.

        :param `visited`: ``True`` to set a hypertext item as visited, ``False`` otherwise.
        """

        self._visited = visited


    def GetVisited(self):
        """Returns whether an hypertext item was visited or not."""

        return self._visited        


    def IsHyperText(self):
        """Returns whether the item is hypetext or not."""

        return self._hypertext
    

    def GetParent(self):
        """
        Gets the item parent (another instance of L{GenericTreeItem} or ``None`` for
        root items.
        """

        return self._parent 


    def Insert(self, child, index):
        """
        Inserts an item in the item children.

        :param `child`: an instance of L{GenericTreeItem};
        :param `index`: the index at which we should insert the new child.
        """
        
        self._children.insert(index, child) 


    def Expand(self):
        """Expands the item."""

        self._isCollapsed = False 
        

    def Collapse(self):
        """Collapses the item."""

        self._isCollapsed = True
            

    def SetHilight(self, set=True):
        """
        Sets the item focus/unfocus.

        :param `set`: ``True`` to set the focus to the item, ``False`` otherwise.    
        """

        self._hasHilight = set 


    def HasChildren(self):
        """Returns whether the item has children or not."""

        return len(self._children) > 0


    def IsSelected(self):
        """Returns whether the item is selected or not."""

        return self._hasHilight != 0 


    def IsExpanded(self):
        """Returns whether the item is expanded or not."""

        return not self._isCollapsed 


    def GetValue(self):
        """
        Returns whether the item is checked or not.

        :note: This is meaningful only for checkbox-like and radiobutton-like items.
        """

        if self.Is3State():
            return self.Get3StateValue()
        
        return self._checked        


    def Get3StateValue(self):
        """
        Gets the state of a 3-state checkbox item.

        :return: ``wx.CHK_UNCHECKED`` when the checkbox is unchecked, ``wx.CHK_CHECKED``
         when it is checked and ``wx.CHK_UNDETERMINED`` when it's in the undetermined
         state. 

        :note: This method raises an exception when the function is used with a 2-state
         checkbox item.

        :note: This method is meaningful only for checkbox-like items.
        """

        if not self.Is3State():
            raise Exception("Get3StateValue can only be used with 3-state checkbox items.")

        return self._checked        


    def Is3State(self):
        """
        Returns whether or not the checkbox item is a 3-state checkbox.

        :return: ``True`` if this checkbox is a 3-state checkbox, ``False`` if it's a
         2-state checkbox item.

        :note: This method is meaningful only for checkbox-like items.
        """

        return self._is3State
    

    def Set3StateValue(self, state):
        """
        Sets the checkbox item to the given `state`.

        :param `state`: can be one of: ``wx.CHK_UNCHECKED`` (check is off), ``wx.CHK_CHECKED``
         (check is on) or ``wx.CHK_UNDETERMINED`` (check is mixed).

        :note: This method raises an exception when the checkbox item is a 2-state checkbox
         and setting the state to ``wx.CHK_UNDETERMINED``.

        :note: This method is meaningful only for checkbox-like items.
        """

        if not self._is3State and state == wx.CHK_UNDETERMINED:
            raise Exception("Set3StateValue can only be used with 3-state checkbox items.")

        self._checked = state


    def Set3State(self, allow):
        """
        Sets whether the item has a 3-state value checkbox assigned to it or not.

        :param `allow`: ``True`` to set an item as a 3-state checkbox, ``False`` to set it
         to a 2-state checkbox.

        :return: ``True`` if the change was successful, ``False`` otherwise.

        :note: This method is meaningful only for checkbox-like items.
        """

        if self._type != 1:
            return False

        self._is3State = allow
        return True
            

    def IsChecked(self):
        """
        This is just a maybe more readable synonym for L{GetValue}.
        Returns whether the item is checked or not.

        :note: This is meaningful only for checkbox-like and radiobutton-like items.
        """

        return self.GetValue()


    def Check(self, checked=True):
        """
        Checks/unchecks an item.

        :param `checked`: ``True`` to check an item, ``False`` to uncheck it.        

        :note: This is meaningful only for checkbox-like and radiobutton-like items.
        """
        
        self._checked = checked        


    def HasPlus(self):
        """Returns whether the item has the plus button or not."""

        return self._hasPlus or self.HasChildren() 


    def IsBold(self):
        """Returns whether the item font is bold or not."""

        return self._isBold != 0 


    def IsItalic(self):
        """Returns whether the item font is italic or not."""

        return self._isItalic != 0 


    def Enable(self, enable=True):
        """
        Enables/disables the item.

        :param `enable`: ``True`` to enable the item, ``False`` to disable it.
        """

        self._enabled = enable


    def IsEnabled(self):
        """Returns whether the item is enabled or not."""

        return self._enabled
    

    def GetAttributes(self):
        """Returns the item attributes (font, colours)."""

        return self._attr 


    def Attr(self):
        """Creates a new attribute (font, colours)."""
    
        if not self._attr:
        
            self._attr = TreeItemAttr()
            self._ownsAttr = True
        
        return self._attr

    
    def SetAttributes(self, attr):
        """
        Sets the item attributes (font, colours).

        :param `attr`: an instance of L{TreeItemAttr}.
        """
    
        if self._ownsAttr:
             del self._attr
             
        self._attr = attr
        self._ownsAttr = False

    
    def AssignAttributes(self, attr):
        """
        Assigns the item attributes (font, colours).

        :param `attr`: an instance of L{TreeItemAttr}.
        """
    
        self.SetAttributes(attr)
        self._ownsAttr = True


    def DeleteChildren(self, tree):
        """
        Deletes the item children.

        :param `tree`: the main L{CustomTreeCtrl} instance.
        """

        for child in self._children:
            if tree:
                tree.SendDeleteEvent(child)

            child.DeleteChildren(tree)
            
            if child == tree._select_me:
                tree._select_me = None

            # We have to destroy the associated window
            wnd = child.GetWindow()
            if wnd:
                wnd.Destroy()
                child._wnd = None

            if child in tree._itemWithWindow:
                tree._itemWithWindow.remove(child)
                
            del child
        
        self._children = []


    def SetText(self, text):
        """
        Sets the item text.

        :param `text`: the new item label.
        """

        self._text = text


    def GetChildrenCount(self, recursively=True):
        """
        Gets the number of children of this item.

        :param `recursively`: if ``True``, returns the total number of descendants,
         otherwise only one level of children is counted.
        """

        count = len(self._children)
        
        if not recursively:
            return count

        total = count

        for n in xrange(count):
            total += self._children[n].GetChildrenCount()
        
        return total


    def GetSize(self, x, y, theButton):
        """
        Returns the item size.

        :param `x`: the current item's x position;
        :param `y`: the current item's y position;
        :param `theButton`: an instance of the main L{CustomTreeCtrl}.
        """

        bottomY = self._y + theButton.GetLineHeight(self)

        if y < bottomY:
            y = bottomY

        width = self._x + self._width
        
        if x < width:
            x = width

        if self.IsExpanded():
            for child in self._children:
                x, y = child.GetSize(x, y, theButton)
            
        return x, y        


    def HitTest(self, point, theCtrl, flags=0, level=0):
        """
        HitTest method for an item. Called from the main window HitTest.

        :param `point`: the point to test for the hit (an instance of `wx.Point`);
        :param `theCtrl`: the main L{CustomTreeCtrl} tree;
        :param `flags`: a bitlist of hit locations;
        :param `level`: the item's level inside the tree hierarchy.
        
        :see: L{CustomTreeCtrl.HitTest} method for the flags explanation.
        """
        
        # for a hidden root node, don't evaluate it, but do evaluate children
        if not (level == 0 and theCtrl.HasAGWFlag(TR_HIDE_ROOT)):
        
            # evaluate the item
            h = theCtrl.GetLineHeight(self)
            
            if point.y > self._y and point.y < self._y + h:
            
                y_mid = self._y + h/2

                if point.y < y_mid:
                    flags |= TREE_HITTEST_ONITEMUPPERPART
                else:
                    flags |= TREE_HITTEST_ONITEMLOWERPART

                xCross = self._x - theCtrl.GetSpacing()

                if wx.Platform == "__WXMAC__":
                    # according to the drawing code the triangels are drawn
                    # at -4 , -4  from the position up to +10/+10 max
                    if point.x > xCross-4 and point.x < xCross+10 and point.y > y_mid-4 and \
                       point.y < y_mid+10 and self.HasPlus() and theCtrl.HasButtons():

                        flags |= TREE_HITTEST_ONITEMBUTTON
                        return self, flags
                else:
                    # 5 is the size of the plus sign
                    if point.x > xCross-6 and point.x < xCross+6 and point.y > y_mid-6 and \
                       point.y < y_mid+6 and self.HasPlus() and theCtrl.HasButtons():

                        flags |= TREE_HITTEST_ONITEMBUTTON
                        return self, flags

                if point.x >= self._x and point.x <= self._x + self._width:

                    image_w = -1
                    wcheck = 0

                    # assuming every image (normal and selected) has the same size!
                    if self.GetImage() != _NO_IMAGE and theCtrl._imageListNormal:
                        image_w, image_h = theCtrl._imageListNormal.GetSize(self.GetImage())

                    if self.GetCheckedImage() is not None:
                        wcheck, hcheck = theCtrl._imageListCheck.GetSize(self.GetCheckedImage())

                    if wcheck and point.x <= self._x + wcheck + 1:
                        flags |= TREE_HITTEST_ONITEMCHECKICON
                        return self, flags

                    if image_w != -1 and point.x <= self._x + wcheck + image_w + 1:
                        flags |= TREE_HITTEST_ONITEMICON
                    else:
                        flags |= TREE_HITTEST_ONITEMLABEL

                    return self, flags

                if point.x < self._x:
                    if theCtrl.HasAGWFlag(TR_FULL_ROW_HIGHLIGHT):
                        flags |= TREE_HITTEST_ONITEM
                    else:
                        flags |= TREE_HITTEST_ONITEMINDENT
                if point.x > self._x + self._width:
                    if theCtrl.HasAGWFlag(TR_FULL_ROW_HIGHLIGHT):
                        flags |= TREE_HITTEST_ONITEM
                    else:
                        flags |= TREE_HITTEST_ONITEMRIGHT
                        
                return self, flags
            
            # if children are expanded, fall through to evaluate them
            if self._isCollapsed:
                return None, 0
        
        # evaluate children
        for child in self._children:
            res, flags = child.HitTest(point, theCtrl, flags, level + 1)
            if res != None:
                return res, flags

        return None, 0


    def GetCurrentImage(self):
        """Returns the current item image."""

        image = _NO_IMAGE
        
        if self.IsExpanded():
        
            if self.IsSelected():
            
                image = self._images[TreeItemIcon_SelectedExpanded]

            if image == _NO_IMAGE:
            
                # we usually fall back to the normal item, but try just the
                # expanded one (and not selected) first in this case
                image = self._images[TreeItemIcon_Expanded]
        
        else: # not expanded
        
            if self.IsSelected():
                image = self._images[TreeItemIcon_Selected]
        
        # maybe it doesn't have the specific image we want,
        # try the default one instead
        if image == _NO_IMAGE:
            image = self._images[TreeItemIcon_Normal]

        return image


    def GetCurrentCheckedImage(self):
        """Returns the current item check image."""

        if self._type == 0:
            return None

        checked = self.IsChecked()
        
        if checked > 0:
            if self._type == 1:     # Checkbox
                if checked == wx.CHK_CHECKED:
                    return self._checkedimages[TreeItemIcon_Checked]
                else:
                    return self._checkedimages[TreeItemIcon_Undetermined]                    
            else:                   # Radiobutton
                return self._checkedimages[TreeItemIcon_Flagged]
        else:
            if self._type == 1:     # Checkbox
                return self._checkedimages[TreeItemIcon_NotChecked]
            else:                   # Radiobutton
                return self._checkedimages[TreeItemIcon_NotFlagged]
            

# -----------------------------------------------------------------------------
# CustomTreeCtrl Main Implementation.
# This Is The Main Class.
# -----------------------------------------------------------------------------

class CustomTreeCtrl(wx.PyScrolledWindow):
    """
    CustomTreeCtrl is a class that mimics the behaviour of `wx.TreeCtrl`, with almost the
    same base functionalities plus some more enhancements. This class does not rely on
    the native control, as it is a full owner-drawn tree control.
    """

    def __init__(self, parent, id=wx.ID_ANY, pos=wx.DefaultPosition, size=wx.DefaultSize,
                 style=0, agwStyle=TR_DEFAULT_STYLE, validator=wx.DefaultValidator,
                 name="CustomTreeCtrl"):
        """
        Default class constructor.
        
        :param `parent`: parent window. Must not be ``None``;
        :param `id`: window identifier. A value of -1 indicates a default value;
        :param `pos`: the control position. A value of (-1, -1) indicates a default position,
         chosen by either the windowing system or wxPython, depending on platform;
        :param `size`: the control size. A value of (-1, -1) indicates a default size,
         chosen by either the windowing system or wxPython, depending on platform;
        :param `style`: the underlying `wx.PyScrolledWindow` style;
        :param `agwStyle`: the AGW-specific window style for L{CustomTreeCtrl}. It can be a
         combination of the following bits:
        
         ============================== =========== ==================================================
         Window Styles                  Hex Value   Description
         ============================== =========== ==================================================
         ``TR_NO_BUTTONS``                      0x0 For convenience to document that no buttons are to be drawn.
         ``TR_SINGLE``                          0x0 For convenience to document that only one item may be selected at a time. Selecting another item causes the current selection, if any, to be deselected. This is the default.
         ``TR_HAS_BUTTONS``                     0x1 Use this style to show + and - buttons to the left of parent items.
         ``TR_NO_LINES``                        0x4 Use this style to hide vertical level connectors.
         ``TR_LINES_AT_ROOT``                   0x8 Use this style to show lines between root nodes. Only applicable if ``TR_HIDE_ROOT`` is set and ``TR_NO_LINES`` is not set.
         ``TR_DEFAULT_STYLE``                   0x9 The set of flags that are closest to the defaults for the native control for a particular toolkit.
         ``TR_TWIST_BUTTONS``                  0x10 Use old Mac-twist style buttons.
         ``TR_MULTIPLE``                       0x20 Use this style to allow a range of items to be selected. If a second range is selected, the current range, if any, is deselected.
         ``TR_EXTENDED``                       0x40 Use this style to allow disjoint items to be selected. (Only partially implemented; may not work in all cases).
         ``TR_HAS_VARIABLE_ROW_HEIGHT``        0x80 Use this style to cause row heights to be just big enough to fit the content. If not set, all rows use the largest row height. The default is that this flag is unset.
         ``TR_EDIT_LABELS``                   0x200 Use this style if you wish the user to be able to edit labels in the tree control.
         ``TR_ROW_LINES``                     0x400 Use this style to draw a contrasting border between displayed rows.
         ``TR_HIDE_ROOT``                     0x800 Use this style to suppress the display of the root node, effectively causing the first-level nodes to appear as a series of root nodes.
         ``TR_FULL_ROW_HIGHLIGHT``           0x2000 Use this style to have the background colour and the selection highlight extend  over the entire horizontal row of the tree control window.
         ``TR_AUTO_CHECK_CHILD``             0x4000 Only meaningful foe checkbox-type items: when a parent item is checked/unchecked its children are checked/unchecked as well.
         ``TR_AUTO_TOGGLE_CHILD``            0x8000 Only meaningful foe checkbox-type items: when a parent item is checked/unchecked its children are toggled accordingly.
         ``TR_AUTO_CHECK_PARENT``           0x10000 Only meaningful foe checkbox-type items: when a child item is checked/unchecked its parent item is checked/unchecked as well.
         ``TR_ALIGN_WINDOWS``               0x20000 Flag used to align windows (in items with windows) at the same horizontal position.
         ============================== =========== ==================================================

        :param `validator`: window validator;
        :param `name`: window name.
        """
        
        self._current = self._key_current = self._anchor = self._select_me = None
        self._hasFocus = False
        self._dirty = False

        # Default line height: it will soon be changed
        self._lineHeight = 10
        # Item indent wrt parent
        self._indent = 15
        # item horizontal spacing between the start and the text
        self._spacing = 18

        # Brushes for focused/unfocused items (also gradient type)
        self._hilightBrush = wx.Brush(wx.SystemSettings_GetColour(wx.SYS_COLOUR_HIGHLIGHT))
        btnshadow = wx.SystemSettings_GetColour(wx.SYS_COLOUR_BTNSHADOW)
        self._hilightUnfocusedBrush = wx.Brush(btnshadow)
        r, g, b = btnshadow.Red(), btnshadow.Green(), btnshadow.Blue()
        backcolour = (max((r >> 1) - 20, 0),
                      max((g >> 1) - 20, 0),
                      max((b >> 1) - 20, 0))
        backcolour = wx.Colour(backcolour[0], backcolour[1], backcolour[2])
        self._hilightUnfocusedBrush2 = wx.Brush(backcolour)

        # image list for icons
        self._imageListNormal = self._imageListButtons = self._imageListState = self._imageListCheck = self._imageListLeft = None
        self._ownsImageListNormal = self._ownsImageListButtons = self._ownsImageListState = self._ownsImageListLeft = False

        # Drag and drop initial settings
        self._dragCount = 0
        self._countDrag = 0
        self._isDragging = False
        self._dropTarget = self._oldSelection = None
        self._dragImage = None
        self._underMouse = None

        # TextCtrl initial settings for editable items        
        self._textCtrl = None
        self._renameTimer = None

        # This one allows us to handle Freeze() and Thaw() calls        
        self._freezeCount = 0

        self._findPrefix = ""
        self._findTimer = None

        self._dropEffectAboveItem = False
        self._lastOnSame = False

        # Default normal and bold fonts for an item
        self._hasFont = True
        self._normalFont = wx.SystemSettings_GetFont(wx.SYS_DEFAULT_GUI_FONT)
        family = self._normalFont.GetFamily()
        if family == wx.FONTFAMILY_UNKNOWN:
            family = wx.FONTFAMILY_SWISS
        self._boldFont = wx.Font(self._normalFont.GetPointSize(), family,
                                 self._normalFont.GetStyle(), wx.BOLD, self._normalFont.GetUnderlined(),
                                 self._normalFont.GetFaceName(), self._normalFont.GetEncoding())
        self._italicFont = wx.Font(self._normalFont.GetPointSize(), family,
                                   wx.FONTSTYLE_ITALIC, wx.NORMAL, self._normalFont.GetUnderlined(),
                                   self._normalFont.GetFaceName(), self._normalFont.GetEncoding())

        # Hyperlinks things
        self._hypertextfont = wx.Font(self._normalFont.GetPointSize(), family,
                                      self._normalFont.GetStyle(), wx.NORMAL, True,
                                      self._normalFont.GetFaceName(), self._normalFont.GetEncoding())
        self._hypertextnewcolour = wx.BLUE
        self._hypertextvisitedcolour = wx.Colour(200, 47, 200)
        self._isonhyperlink = False

        # Default CustomTreeCtrl background colour.    
        self._backgroundColour = wx.WHITE
        
        # Background image settings
        self._backgroundImage = None
        self._imageStretchStyle = _StyleTile

        # Disabled items colour        
        self._disabledColour = wx.Colour(180, 180, 180)

        # Gradient selection colours        
        self._firstcolour = colour = wx.SystemSettings_GetColour(wx.SYS_COLOUR_HIGHLIGHT)
        self._secondcolour = wx.WHITE
        self._usegradients = False
        self._gradientstyle = 0   # Horizontal Gradient

        # Vista Selection Styles
        self._vistaselection = False

        # To speed up ExpandAll and SelectAll
        self._sendEvent = True

        # Connection lines style
        grey = (160,160,160)
        if wx.Platform != "__WXMAC__":
            self._dottedPen = wx.Pen(grey, 1, wx.USER_DASH)
            self._dottedPen.SetDashes([1,1])
            self._dottedPen.SetCap(wx.CAP_BUTT)
        else:
            self._dottedPen = wx.Pen(grey, 1)

        # Pen Used To Draw The Border Around Selected Items
        self._borderPen = wx.BLACK_PEN
        self._cursor = wx.StockCursor(wx.CURSOR_ARROW)
        
        # For Appended Windows
        self._hasWindows = False
        self._itemWithWindow = []
        
        if wx.Platform == "__WXMAC__":
            agwStyle &= ~TR_LINES_AT_ROOT
            agwStyle |= TR_NO_LINES
            
            platform, major, minor = wx.GetOsVersion()
            if major < 10:
                agwStyle |= TR_ROW_LINES

        # A constant to use my translation of RendererNative.DrawTreeItemButton
        # if the wxPython version is less than 2.6.2.1.
        if _VERSION_STRING < "2.6.2.1":
            self._drawingfunction = DrawTreeItemButton
        else:
            self._drawingfunction = wx.RendererNative.Get().DrawTreeItemButton

        # Create our container... at last!    
        wx.PyScrolledWindow.__init__(self, parent, id, pos, size, style|wx.HSCROLL|wx.VSCROLL, name)

        self._agwStyle = agwStyle
        
        # Create the default check image list        
        self.SetImageListCheck(16, 16)

        # If the tree display has no buttons, but does have
        # connecting lines, we can use a narrower layout.
        # It may not be a good idea to force this...
        if not self.HasButtons() and not self.HasAGWFlag(TR_NO_LINES):
            self._indent= 10
            self._spacing = 10
        
        self.SetValidator(validator)

        attr = self.GetDefaultAttributes()
        self.SetOwnForegroundColour(attr.colFg)
        self.SetOwnBackgroundColour(wx.WHITE)
        
        if not self._hasFont:
            self.SetOwnFont(attr.font)

        self.SetSize(size)

        # Bind the events
        self.Bind(wx.EVT_PAINT, self.OnPaint)
        self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnEraseBackground)
        self.Bind(wx.EVT_SIZE, self.OnSize)
        self.Bind(wx.EVT_MOUSE_EVENTS, self.OnMouse)
        self.Bind(wx.EVT_KEY_DOWN, self.OnKeyDown)
        self.Bind(wx.EVT_SET_FOCUS, self.OnSetFocus)
        self.Bind(wx.EVT_KILL_FOCUS, self.OnKillFocus)
        self.Bind(EVT_TREE_ITEM_GETTOOLTIP, self.OnGetToolTip)
        self.Bind(wx.EVT_WINDOW_DESTROY, self.OnDestroy)

        # Sets the focus to ourselves: this is useful if you have items
        # with associated widgets.
        self.SetFocus()


    def AcceptsFocus(self):
        """
        Can this window be given focus by mouse click?

        :note: This method always returns ``True`` as we alsways accept focus from
         mouse click.

        :note: Overridden from `wx.PyScrolledWindow`.
        """

        # overridden base class method, allows this ctrl to
        # participate in the tab-order, etc.  It's overridable because
        # of deriving this class from wx.PyScrolledWindow...
        return True
    

    def OnDestroy(self, event):
        """
        Handles the ``wx.EVT_WINDOW_DESTROY`` event for L{CustomTreeCtrl}.

        :param `event`: a `wx.WindowDestroyEvent` event to be processed.        
        """

        # Here there may be something I miss... do I have to destroy
        # something else?
        if self._renameTimer and self._renameTimer.IsRunning():
            self._renameTimer.Stop()
            del self._renameTimer
            self._renameTimer = None

        if self._findTimer and self._findTimer.IsRunning():
            self._findTimer.Stop()
            del self._findTimer

        event.Skip()


    def GetControlBmp(self, checkbox=True, checked=False, enabled=True, x=16, y=16):
        """
        Returns a native looking checkbox or radio button bitmap.
        
        :param `checkbox`: ``True`` to get a checkbox image, ``False`` for a radiobutton
         one;
        :param `checked`: ``True`` if the control is marked, ``False`` if it is not;
        :param `enabled`: ``True`` if the control is enabled, ``False`` if it is not;
        :param `x`: the width of the bitmap;
        :param `y`: the height of the bitmap.        
        """

        bmp = wx.EmptyBitmap(x, y)
        mdc = wx.MemoryDC(bmp)
        mask = wx.Colour(0xfe, 0xfe, 0xfe)
        mdc.SetBackground(wx.Brush(mask))
        mdc.Clear()
        
        render = wx.RendererNative.Get()

        if checked == wx.CHK_CHECKED:
            flag = wx.CONTROL_CHECKED
        elif checked == wx.CHK_UNDETERMINED:
            flag = wx.CONTROL_UNDETERMINED
        else:
            flag = 0

        if not enabled:
            flag |= wx.CONTROL_DISABLED

        if checkbox:
            render.DrawCheckBox(self, mdc, (0, 0, x, y), flag)
        else:
            if _VERSION_STRING < "2.9":
                render.DrawRadioButton(self, mdc, (0, 0, x, y), flag)
            else:
                render.DrawRadioBitmap(self, mdc, (0, 0, x, y), flag)

        mdc.SelectObject(wx.NullBitmap)
        bmp.SetMaskColour(mask)
        return bmp


    def GetCount(self):
        """ Returns the global number of items in the tree. """

        if not self._anchor:
            # the tree is empty
            return 0

        count = self._anchor.GetChildrenCount()
        
        if not self.HasAGWFlag(TR_HIDE_ROOT):
            # take the root itself into account
            count = count + 1
        
        return count


    def GetIndent(self):
        """ Returns the item indentation. """

        return self._indent

    
    def GetSpacing(self):
        """ Returns the spacing between the start and the text. """

        return self._spacing


    def GetRootItem(self):
        """ Returns the root item. """

        return self._anchor


    def GetSelection(self):
        """
        Returns the current selection.

        :note: This method is valid only with the style ``TR_SINGLE`` set. Use
         L{GetSelections} for multiple-selections trees.
        """

        return self._current


    def ToggleItemSelection(self, item):
        """
        Toggles the item selection.

        :param `item`: an instance of L{GenericTreeItem}.
        """
        
        self.SelectItem(item, not self.IsSelected(item))


    def EnableChildren(self, item, enable=True):
        """
        Enables/disables the item children.

        :param `item`: an instance of L{GenericTreeItem};
        :param `enable`: ``True`` to enable the children, ``False`` otherwise.

        :note: This method is used internally.        
        """

        torefresh = False
        if item.IsExpanded():
            torefresh = True

        if item.GetType() == 2 and enable and not item.IsChecked():
            # We hit a radiobutton item not checked, we don't want to
            # enable the children
            return
        
        child, cookie = self.GetFirstChild(item)
        while child:
            self.EnableItem(child, enable, torefresh=torefresh)
            # Recurse on tree
            if child.GetType != 2 or (child.GetType() == 2 and item.IsChecked()):
                self.EnableChildren(child, enable)
            (child, cookie) = self.GetNextChild(item, cookie)


    def EnableItem(self, item, enable=True, torefresh=True):
        """
        Enables/disables an item.

        :param `item`: an instance of L{GenericTreeItem};
        :param `enable`: ``True`` to enable the item, ``False`` otherwise;
        :param `torefresh`: whether to redraw the item or not.
        """

        if item.IsEnabled() == enable:
            return

        if not enable and item.IsSelected():
            self.SelectItem(item, False)

        item.Enable(enable)
        wnd = item.GetWindow()

        # Handles the eventual window associated to the item        
        if wnd:
            wndenable = item.GetWindowEnabled()
            wnd.Enable(enable)
        
        if torefresh:
            # We have to refresh the item line
            dc = wx.ClientDC(self)
            self.CalculateSize(item, dc)
            self.RefreshLine(item)
                

    def IsItemEnabled(self, item):
        """
        Returns whether an item is enabled or disabled.

        :param `item`: an instance of L{GenericTreeItem}.
        """

        return item.IsEnabled()        


    def SetDisabledColour(self, colour):
        """
        Sets the colour for items in a disabled state.

        :param `colour`: a valid `wx.Colour` instance.
        """
        
        self._disabledColour = colour
        self._dirty = True


    def GetDisabledColour(self):
        """ Returns the colour for items in a disabled state. """

        return self._disabledColour        
        

    def IsItemChecked(self, item):
        """
        Returns whether an item is checked or not.

        :param `item`: an instance of L{GenericTreeItem}.

        :note: This method is meaningful only for checkbox-like and radiobutton-like items.
        """

        return item.IsChecked()


    def GetItem3StateValue(self, item):
        """
        Gets the state of a 3-state checkbox item.

        :param `item`: an instance of L{GenericTreeItem}.

        :return: ``wx.CHK_UNCHECKED`` when the checkbox is unchecked, ``wx.CHK_CHECKED``
         when it is checked and ``wx.CHK_UNDETERMINED`` when it's in the undetermined
         state. 

        :note: This method raises an exception when the function is used with a 2-state
         checkbox item.

        :note: This method is meaningful only for checkbox-like items.
        """

        return item.Get3StateValue()


    def IsItem3State(self, item):
        """
        Returns whether or not the checkbox item is a 3-state checkbox.

        :param `item`: an instance of L{GenericTreeItem}.

        :return: ``True`` if this checkbox is a 3-state checkbox, ``False`` if it's a
         2-state checkbox item.

        :note: This method is meaningful only for checkbox-like items.
        """

        return item.Is3State()
    

    def SetItem3StateValue(self, item, state):
        """
        Sets the checkbox item to the given `state`.

        :param `item`: an instance of L{GenericTreeItem};
        :param `state`: can be one of: ``wx.CHK_UNCHECKED`` (check is off), ``wx.CHK_CHECKED``
         (check is on) or ``wx.CHK_UNDETERMINED`` (check is mixed).

        :note: This method raises an exception when the checkbox item is a 2-state checkbox
         and setting the state to ``wx.CHK_UNDETERMINED``.

        :note: This method is meaningful only for checkbox-like items.
        """

        item.Set3StateValue(state)


    def SetItem3State(self, item, allow):
        """
        Sets whether the item has a 3-state value checkbox assigned to it or not.

        :param `item`: an instance of L{GenericTreeItem};
        :param `allow`: ``True`` to set an item as a 3-state checkbox, ``False`` to set it
         to a 2-state checkbox.

        :return: ``True`` if the change was successful, ``False`` otherwise.

        :note: This method is meaningful only for checkbox-like items.
        """

        return item.Set3State(allow)
    

    def CheckItem2(self, item, checked=True, torefresh=False):
        """
        Used internally to avoid ``EVT_TREE_ITEM_CHECKED`` events.

        :param `item`: an instance of L{GenericTreeItem};
        :param `checked`: ``True`` to check an item, ``False`` to uncheck it;
        :param `torefresh`: whether to redraw the item or not.
        """

        if item.GetType() == 0:
            return
        
        item.Check(checked)

        if torefresh:
            dc = wx.ClientDC(self)
            self.CalculateSize(item, dc)
            self.RefreshLine(item)
        

    def UnCheckRadioParent(self, item, checked=False):
        """
        Used internally to handle radio node parent correctly.

        :param `item`: an instance of L{GenericTreeItem};
        :param `checked`: ``True`` to check an item, ``False`` to uncheck it.
        """

        e = TreeEvent(wxEVT_TREE_ITEM_CHECKING, self.GetId())
        e.SetItem(item)
        e.SetEventObject(self)
        
        if self.GetEventHandler().ProcessEvent(e):
            return False

        item.Check(checked)
        self.RefreshLine(item)
        self.EnableChildren(item, checked)
        e = TreeEvent(wxEVT_TREE_ITEM_CHECKED, self.GetId())
        e.SetItem(item)
        e.SetEventObject(self)
        self.GetEventHandler().ProcessEvent(e)

        return True        
        

    def CheckItem(self, item, checked=True):
        """
        Actually checks/uncheks an item, sending (eventually) the two
        events ``EVT_TREE_ITEM_CHECKING`` and ``EVT_TREE_ITEM_CHECKED``.

        :param `item`: an instance of L{GenericTreeItem};
        :param `checked`: for a radiobutton-type item, ``True`` to check it, ``False``
         to uncheck it. For a checkbox-type item, it can be one of ``wx.CHK_UNCHECKED``
         when the checkbox is unchecked, ``wx.CHK_CHECKED`` when it is checked and
         ``wx.CHK_UNDETERMINED`` when it's in the undetermined state.
        """

        # Should we raise an error here?!?        
        if item.GetType() == 0:
            return

        if item.GetType() == 2:    # it's a radio button
            if not checked and item.IsChecked():  # Try To Unckeck?
                return
            else:
                if not self.UnCheckRadioParent(item, checked):
                    return

                self.CheckSameLevel(item, False)
                return
            
        # Radiobuttons are done, let's handle checkbuttons...
        e = TreeEvent(wxEVT_TREE_ITEM_CHECKING, self.GetId())
        e.SetItem(item)
        e.SetEventObject(self)
        
        if self.GetEventHandler().ProcessEvent(e):
            # Blocked by user
            return 

        if item.Is3State():
            item.Set3StateValue(checked)
        else:
            item.Check(checked)
            
        dc = wx.ClientDC(self)
        self.RefreshLine(item)

        if self.HasAGWFlag(TR_AUTO_CHECK_CHILD):
            ischeck = self.IsItemChecked(item)
            self.AutoCheckChild(item, ischeck)
        if self.HasAGWFlag(TR_AUTO_CHECK_PARENT):
            ischeck = self.IsItemChecked(item)
            self.AutoCheckParent(item, ischeck)
        elif self.HasAGWFlag(TR_AUTO_TOGGLE_CHILD):
            self.AutoToggleChild(item)

        e = TreeEvent(wxEVT_TREE_ITEM_CHECKED, self.GetId())
        e.SetItem(item)
        e.SetEventObject(self)
        self.GetEventHandler().ProcessEvent(e)


    def AutoToggleChild(self, item):
        """
        Transverses the tree and toggles the items.

        :param `item`: an instance of L{GenericTreeItem}.

        :note: This method is meaningful only for checkbox-like and radiobutton-like items.
        """
        
        child, cookie = self.GetFirstChild(item)

        torefresh = False
        if item.IsExpanded():
            torefresh = True

        # Recurse on tree            
        while child:
            if child.GetType() == 1 and child.IsEnabled():
                self.CheckItem2(child, not child.IsChecked(), torefresh=torefresh)
            self.AutoToggleChild(child)
            (child, cookie) = self.GetNextChild(item, cookie)


    def AutoCheckChild(self, item, checked):
        """
        Transverses the tree and checks/unchecks the items.

        :param `item`: an instance of L{GenericTreeItem};
        :param `checked`: ``True`` to check an item, ``False`` to uncheck it.

        :note: This method is meaningful only for checkbox-like and radiobutton-like items.
        """        

        (child, cookie) = self.GetFirstChild(item)

        torefresh = False
        if item.IsExpanded():
            torefresh = True
            
        while child:
            if child.GetType() == 1 and child.IsEnabled():
                self.CheckItem2(child, checked, torefresh=torefresh)
            self.AutoCheckChild(child, checked)
            (child, cookie) = self.GetNextChild(item, cookie)


    def AutoCheckParent(self, item, checked):
        """
        Traverses up the tree and checks/unchecks parent items.

        :param `item`: an instance of L{GenericTreeItem};
        :param `checked`: ``True`` to check an item, ``False`` to uncheck it.

        :note: This method is meaningful only for checkbox-like and radiobutton-like items.
        """

        parent = item.GetParent()
        if not parent or parent.GetType() != 1:
            return

        (child, cookie) = self.GetFirstChild(parent)
        while child:
            if child.GetType() == 1 and child.IsEnabled():
                if checked != child.IsChecked():
                    return
            (child, cookie) = self.GetNextChild(parent, cookie)

        self.CheckItem2(parent, checked, torefresh=True)
        self.AutoCheckParent(parent, checked)


    def CheckChilds(self, item, checked=True):
        """
        Programatically check/uncheck item children.

        :param `item`: an instance of L{GenericTreeItem};
        :param `checked`: ``True`` to check an item, ``False`` to uncheck it.

        :note: This method is meaningful only for checkbox-like and radiobutton-like items.

        :note: This method does not generate ``EVT_TREE_ITEM_CHECKING`` and
         ``EVT_TREE_ITEM_CHECKED`` events.
        """
        
        if checked == None:
            self.AutoToggleChild(item)
        else:
            self.AutoCheckChild(item, checked)


    def CheckSameLevel(self, item, checked=False):
        """
        Uncheck radio items which are on the same level of the checked one.
        Used internally.

        :param `item`: an instance of L{GenericTreeItem};
        :param `checked`: ``True`` to check an item, ``False`` to uncheck it.

        :note: This method is meaningful only for radiobutton-like items.
        """

        parent = item.GetParent()

        if not parent:
            return

        torefresh = False
        if parent.IsExpanded():
            torefresh = True
        
        (child, cookie) = self.GetFirstChild(parent)
        while child:
            if child.GetType() == 2 and child != item:
                self.CheckItem2(child, checked, torefresh=torefresh)
                if child.GetType != 2 or (child.GetType() == 2 and child.IsChecked()):
                    self.EnableChildren(child, checked)
            (child, cookie) = self.GetNextChild(parent, cookie)


    def EditLabel(self, item):
        """
        Starts editing an item label.

        :param `item`: an instance of L{GenericTreeItem}.
        """
        
        self.Edit(item)

        
    def ShouldInheritColours(self):
        """
        Return ``True`` from here to allow the colours of this window to be
        changed by `InheritAttributes`, returning ``False`` forbids inheriting them
        from the parent window.
        
        The base class version returns ``False``, but this method is overridden in
        `wx.Control` where it returns ``True``.

        L{CustomTreeCtrl} does not inherit colours from anyone.
        """

        return False        


    def SetIndent(self, indent):
        """
        Sets the indentation for L{CustomTreeCtrl}.

        :param `indent`: an integer representing the indentation for the items in the tree.
        """

        self._indent = indent
        self._dirty = True


    def SetSpacing(self, spacing):
        """
        Sets the spacing between items in L{CustomTreeCtrl}.

        :param `spacing`: an integer representing the spacing between items in the tree.
        """
        
        self._spacing = spacing
        self._dirty = True


    def HasChildren(self, item):
        """
        Returns whether an item has children or not.

        :param `item`: an instance of L{GenericTreeItem}.
        """

        return len(item.GetChildren()) > 0


    def GetChildrenCount(self, item, recursively=True):
        """
        Returns the item children count.

        :param `item`: an instance of L{GenericTreeItem};
        :param `recursively`: if ``True``, returns the total number of descendants,
         otherwise only one level of children is counted.
        """

        return item.GetChildrenCount(recursively)


    def HasAGWFlag(self, flag):
        """
        Returns ``True`` if L{CustomTreeCtrl} has the `flag` bit set.

        :param `flag`: any possible window style for L{CustomTreeCtrl}.

        :see: The L{__init__} method for the `flag` parameter description.
        """

        return self._agwStyle & flag        
        

    def SetAGWWindowStyleFlag(self, agwStyle):
        """
        Sets the L{CustomTreeCtrl} window style.

        :param `agwStyle`: the new L{CustomTreeCtrl} window style.
        
        :see: The L{__init__} method for the `agwStyle` parameter description.
        """

        # Do not try to expand the root node if it hasn't been created yet
        if self._anchor and not self.HasAGWFlag(TR_HIDE_ROOT) and agwStyle & TR_HIDE_ROOT:
        
            # if we will hide the root, make sure children are visible
            self._anchor.SetHasPlus()
            self._anchor.Expand()
            self.CalculatePositions()
        
        # right now, just sets the styles.  Eventually, we may
        # want to update the inherited styles, but right now
        # none of the parents has updatable styles

        if self.HasAGWFlag(TR_MULTIPLE) and not (agwStyle & TR_MULTIPLE):
            selections = self.GetSelections()
            for select in selections[0:-1]:
                self.SelectItem(select, False)

        self._agwStyle = agwStyle
        self._dirty = True


    def GetAGWWindowStyleFlag(self):
        """
        Returns the L{CustomTreeCtrl} style.

        :see: The L{__init__} method for a list of possible style flags.
        """

        return self._agwStyle
    

    def HasButtons(self):
        """Returns whether L{CustomTreeCtrl} has the ``TR_HAS_BUTTONS`` flag set."""

        return self.HasAGWFlag(TR_HAS_BUTTONS)


# -----------------------------------------------------------------------------
# functions to work with tree items
# -----------------------------------------------------------------------------

    def GetItemText(self, item):
        """
        Returns the item text.

        :param `item`: an instance of L{GenericTreeItem}.
        """

        return item.GetText()
    

    def GetItemImage(self, item, which=TreeItemIcon_Normal):
        """
        Returns the item image.

        :param `item`: an instance of L{GenericTreeItem};
        :param `which`: can be one of the following bits:

         ================================= ========================
         Item State                        Description
         ================================= ========================
         ``TreeItemIcon_Normal``           To get the normal item image
         ``TreeItemIcon_Selected``         To get the selected item image (i.e. the image which is shown when the item is currently selected)
         ``TreeItemIcon_Expanded``         To get the expanded image (this only makes sense for items which have children - then this image is shown when the item is expanded and the normal image is shown when it is collapsed)
         ``TreeItemIcon_SelectedExpanded`` To get the selected expanded image (which is shown when an expanded item is currently selected) 
         ================================= ========================
        """

        return item.GetImage(which)


    def GetItemLeftImage(self, item):
        """
        Returns the item leftmost image, i.e. the image associated to the item on the leftmost
        part of the L{CustomTreeCtrl} client area.

        :param `item`: an instance of L{GenericTreeItem}.
        """

        return item.GetLeftImage()


    def GetPyData(self, item):
        """
        Returns the data associated to an item.

        :param `item`: an instance of L{GenericTreeItem}.
        """

        return item.GetData()

    GetItemPyData = GetPyData 


    def GetItemTextColour(self, item):
        """
        Returns the item text colour.

        :param `item`: an instance of L{GenericTreeItem}.
        """

        return item.Attr().GetTextColour()


    def GetItemBackgroundColour(self, item):
        """
        Returns the item background colour.

        :param `item`: an instance of L{GenericTreeItem}.
        """

        return item.Attr().GetBackgroundColour()


    def GetItemFont(self, item):
        """
        Returns the item font.

        :param `item`: an instance of L{GenericTreeItem}.
        """

        font = item.Attr().GetFont()
        if font.IsOk():
            return font

        return wx.NullFont


    def IsItemHyperText(self, item):
        """
        Returns whether an item is hypertext or not.

        :param `item`: an instance of L{GenericTreeItem}.
        """

        return item.IsHyperText()


    def SetItemText(self, item, text):
        """
        Sets the item text.

        :param `item`: an instance of L{GenericTreeItem};
        :param `text`: the new item label.
        """

        dc = wx.ClientDC(self)
        item.SetText(text)
        self.CalculateSize(item, dc)
        self.RefreshLine(item)


    def SetItemImage(self, item, image, which=TreeItemIcon_Normal):
        """
        Sets the item image, depending on the item state.

        :param `item`: an instance of L{GenericTreeItem};
        :param `image`: an index within the normal image list specifying the image to
         use for the item in the state specified by the `which` parameter;
        :param `which`: the item state.

        :see: L{GetItemImage} for an explanation of the `which` parameter.        
        """

        item.SetImage(image, which)

        dc = wx.ClientDC(self)
        self.CalculateSize(item, dc)
        self.RefreshLine(item)


    def SetItemLeftImage(self, item, image):
        """
        Sets the item leftmost image, i.e. the image associated to the item on the leftmost
        part of the L{CustomTreeCtrl} client area.

        :param `item`: an instance of L{GenericTreeItem};
        :param `image`: an index within the left image list specifying the image to
         use for the item in the leftmost part of the client area.
        """

        item.SetLeftImage(image)

        dc = wx.ClientDC(self)
        self.CalculateSize(item, dc)
        self.RefreshLine(item)


    def SetPyData(self, item, data):
        """
        Sets the data associated to an item.

        :param `item`: an instance of L{GenericTreeItem};
        :param `data`: can be any Python object.
        """

        item.SetData(data)

    SetItemPyData = SetPyData
    

    def SetItemHasChildren(self, item, has=True):
        """
        Forces the appearance/disappearance of the button next to the item.

        :param `item`: an instance of L{GenericTreeItem};
        :param `has`: ``True`` to have a button next to an item, ``False`` otherwise.
        """
        
        item.SetHasPlus(has)
        self.RefreshLine(item)


    def SetItemBold(self, item, bold=True):
        """
        Sets the item font as bold/unbold.

        :param `item`: an instance of L{GenericTreeItem};
        :param `bold`: ``True`` to set the item font as bold, ``False`` otherwise.
        """

        # avoid redrawing the tree if no real change
        if item.IsBold() != bold:
            item.SetBold(bold)
            self._dirty = True
    

    def SetItemItalic(self, item, italic=True):
        """
        Sets the item font as italic/non-italic.

        :param `item`: an instance of L{GenericTreeItem};
        :param `italic`: ``True`` to set the item font as italic, ``False`` otherwise.
        """

        if item.IsItalic() != italic:
            item.SetItalic(italic)
            self._dirty = True


    def SetItemDropHighlight(self, item, highlight=True):
        """
        Gives the item the visual feedback for drag and drop operations.
        This is useful when something is dragged from outside the L{CustomTreeCtrl}.

        :param `item`: an instance of L{GenericTreeItem};
        :param `highlight`: ``True`` to highlight the dragged items, ``False`` otherwise.
        """

        if highlight:
            bg = wx.SystemSettings_GetColour(wx.SYS_COLOUR_HIGHLIGHT)
            fg = wx.SystemSettings_GetColour(wx.SYS_COLOUR_HIGHLIGHTTEXT)

        item.Attr().SetTextColour(fg)
        item.Attr.SetBackgroundColour(bg)
        self.RefreshLine(item)


    def SetItemTextColour(self, item, colour):
        """
        Sets the item text colour.

        :param `item`: an instance of L{GenericTreeItem};
        :param `colour`: a valid `wx.Colour` instance.
        """

        item.Attr().SetTextColour(colour)
        self.RefreshLine(item)


    def SetItemBackgroundColour(self, item, colour):
        """
        Sets the item background colour.

        :param `item`: an instance of L{GenericTreeItem};
        :param `colour`: a valid `wx.Colour` instance.
        """

        item.Attr().SetBackgroundColour(colour)
        self.RefreshLine(item)


    def SetItemHyperText(self, item, hyper=True):
        """
        Sets whether the item is hypertext or not.

        :param `item`: an instance of L{GenericTreeItem};
        :param `hyper`: ``True`` to have an item with hypertext behaviour, ``False`` otherwise.
        """

        item.SetHyperText(hyper)
        self.RefreshLine(item)
        

    def SetItemFont(self, item, font):
        """
        Sets the item font.

        :param `item`: an instance of L{GenericTreeItem};
        :param `font`: a valid `wx.Font` instance.
        """

        item.Attr().SetFont(font)
        self._dirty = True
        

    def SetFont(self, font):
        """
        Sets the L{CustomTreeCtrl} font.

        :param `font`: a valid `wx.Font` instance.

        :note: Overridden from `wx.PyScrolledWindow`.        
        """

        wx.PyScrolledWindow.SetFont(self, font)

        self._normalFont = font 
        family = self._normalFont.GetFamily()
        if family == wx.FONTFAMILY_UNKNOWN:
            family = wx.FONTFAMILY_SWISS
        self._boldFont = wx.Font(self._normalFont.GetPointSize(), family,
                                 self._normalFont.GetStyle(), wx.BOLD, self._normalFont.GetUnderlined(),
                                 self._normalFont.GetFaceName(), self._normalFont.GetEncoding())
        self._italicFont = wx.Font(self._normalFont.GetPointSize(), family,
                                   wx.FONTSTYLE_ITALIC, wx.NORMAL, self._normalFont.GetUnderlined(),
                                   self._normalFont.GetFaceName(), self._normalFont.GetEncoding())

        return True


    def GetHyperTextFont(self):
        """ Returns the font used to render hypertext items. """

        return self._hypertextfont        


    def SetHyperTextFont(self, font):
        """
        Sets the font used to render hypertext items.

        :param `font`: a valid `wx.Font` instance.
        """

        self._hypertextfont = font
        self._dirty = True
        

    def SetHyperTextNewColour(self, colour):
        """
        Sets the colour used to render a non-visited hypertext item.

        :param `colour`: a valid `wx.Colour` instance.
        """

        self._hypertextnewcolour = colour
        self._dirty = True


    def GetHyperTextNewColour(self):
        """ Returns the colour used to render a non-visited hypertext item. """

        return self._hypertextnewcolour


    def SetHyperTextVisitedColour(self, colour):
        """
        Sets the colour used to render a visited hypertext item.

        :param `colour`: a valid `wx.Colour` instance.
        """

        self._hypertextvisitedcolour = colour
        self._dirty = True


    def GetHyperTextVisitedColour(self):
        """ Returns the colour used to render a visited hypertext item. """

        return self._hypertextvisitedcolour


    def SetItemVisited(self, item, visited=True):
        """
        Sets whether an hypertext item was visited.

        :param `item`: an instance of L{GenericTreeItem};
        :param `visited`: ``True`` to mark an hypertext item as visited, ``False`` otherwise.
        """

        item.SetVisited(visited)
        self.RefreshLine(item)


    def GetItemVisited(self, item):
        """
        Returns whether an hypertext item was visited.

        :param `item`: an instance of L{GenericTreeItem}.
        """

        return item.GetVisited()            


    def SetHilightFocusColour(self, colour):
        """
        Sets the colour used to highlight focused selected items.

        :param `colour`: a valid `wx.Colour` instance.
        
        :note: This is applied only if gradient and Windows Vista selection
         styles are disabled.
        """

        self._hilightBrush = wx.Brush(colour)
        self.RefreshSelected()
            

    def SetHilightNonFocusColour(self, colour):
        """
        Sets the colour used to highlight unfocused selected items.

        :param `colour`: a valid `wx.Colour` instance.
        
        :note: This is applied only if gradient and Windows Vista selection
         styles are disabled.
        """

        self._hilightUnfocusedBrush = wx.Brush(colour)
        self.RefreshSelected()


    def GetHilightFocusColour(self):
        """
        Returns the colour used to highlight focused selected items.

        :note: This is used only if gradient and Windows Vista selection
         styles are disabled.
        """

        return self._hilightBrush.GetColour()
            

    def GetHilightNonFocusColour(self):
        """
        Returns the colour used to highlight unfocused selected items.

        :note: This is used only if gradient and Windows Vista selection
         styles are disabled.
        """
        
        return self._hilightUnfocusedBrush.GetColour()

    
    def SetFirstGradientColour(self, colour=None):
        """
        Sets the first gradient colour for gradient-style selections.

        :param `colour`: if not ``None``, a valid `wx.Colour` instance. Otherwise,
         the colour is taken from the system value ``wx.SYS_COLOUR_HIGHLIGHT``.
        """
        
        if colour is None:
            colour = wx.SystemSettings_GetColour(wx.SYS_COLOUR_HIGHLIGHT)

        self._firstcolour = colour
        if self._usegradients:
            self.RefreshSelected()
            

    def SetSecondGradientColour(self, colour=None):
        """
        Sets the second gradient colour for gradient-style selections.

        :param `colour`: if not ``None``, a valid `wx.Colour` instance. Otherwise,
         the colour generated is a slightly darker version of the L{CustomTreeCtrl}
         background colour.
        """

        if colour is None:
            # No colour given, generate a slightly darker from the
            # CustomTreeCtrl background colour
            colour = self.GetBackgroundColour()
            r, g, b = int(colour.Red()), int(colour.Green()), int(colour.Blue())
            colour = ((r >> 1) + 20, (g >> 1) + 20, (b >> 1) + 20)
            colour = wx.Colour(colour[0], colour[1], colour[2])

        self._secondcolour = colour

        if self._usegradients:
            self.RefreshSelected()


    def GetFirstGradientColour(self):
        """ Returns the first gradient colour for gradient-style selections. """
        
        return self._firstcolour


    def GetSecondGradientColour(self):
        """ Returns the second gradient colour for gradient-style selections. """
        
        return self._secondcolour


    def EnableSelectionGradient(self, enable=True):
        """
        Globally enables/disables drawing of gradient selections.

        :param `enable`: ``True`` to enable gradient-style selections, ``False``
         to disable it.

        :note: Calling this method disables any Vista-style selection previously
         enabled.
        """

        self._usegradients = enable
        self._vistaselection = False
        self.RefreshSelected()
        

    def SetGradientStyle(self, vertical=0):
        """
        Sets the gradient style for gradient-style selections.

        :param `vertical`: 0 for horizontal gradient-style selections, 1 for vertical
         gradient-style selections.
        """

        # 0 = Horizontal, 1 = Vertical
        self._gradientstyle = vertical

        if self._usegradients:
            self.RefreshSelected()


    def GetGradientStyle(self):
        """
        Returns the gradient style for gradient-style selections.

        :returns: 0 for horizontal gradient-style selections, 1 for vertical
         gradient-style selections.
        """

        return self._gradientstyle


    def EnableSelectionVista(self, enable=True):
        """
        Globally enables/disables drawing of Windows Vista selections.

        :param `enable`: ``True`` to enable Vista-style selections, ``False`` to
         disable it.

        :note: Calling this method disables any gradient-style selection previously
         enabled.
        """

        self._usegradients = False
        self._vistaselection = enable
        self.RefreshSelected()


    def SetBorderPen(self, pen):
        """
        Sets the pen used to draw the selected item border.

        :param `pen`: an instance of `wx.Pen`.
        
        :note: The border pen is not used if the Windows Vista selection style is applied.
        """

        self._borderPen = pen
        self.RefreshSelected()


    def GetBorderPen(self):
        """
        Returns the pen used to draw the selected item border.

        :note: The border pen is not used if the Windows Vista selection style is applied.
        """

        return self._borderPen


    def SetConnectionPen(self, pen):
        """
        Sets the pen used to draw the connecting lines between items.

        :param `pen`: an instance of `wx.Pen`.
        """

        self._dottedPen = pen
        self._dirty = True


    def GetConnectionPen(self):
        """Returns the pen used to draw the connecting lines between items."""

        return self._dottedPen


    def SetBackgroundImage(self, image):
        """
        Sets the L{CustomTreeCtrl} background image.

        :param `image`: if not ``None``, an instance of `wx.Bitmap`.

        :note: At present, the background image can only be used in "tile" mode.

        :todo: Support background images also in stretch and centered modes.        
        """

        self._backgroundImage = image
        self.Refresh()
        

    def GetBackgroundImage(self):
        """
        Returns the L{CustomTreeCtrl} background image (if any).

        :note: At present, the background image can only be used in "tile" mode.

        :todo: Support background images also in stretch and centered modes.        
        """

        return self._backgroundImage        
    

    def GetItemWindow(self, item):
        """
        Returns the window associated to the item (if any).

        :param `item`: an instance of L{GenericTreeItem}.
        """

        return item.GetWindow()


    def SetItemWindow(self, item, wnd):
        """
        Sets the window for the given item.

        :param `item`: an instance of L{GenericTreeItem};
        :param `wnd`: if not ``None``, a non-toplevel window to be displayed next to
         the item.
        """

        if wnd is not None:
            self._hasWindows = True
            if item not in self._itemWithWindow:
                self._itemWithWindow.append(item)
            else:
                self.DeleteItemWindow(item)
        else:
            self.DeleteItemWindow(item)
                
        item.SetWindow(wnd)
        self.CalculatePositions()
        self.Refresh()
        self.AdjustMyScrollbars()
       

    def DeleteItemWindow(self, item):
        """
        Deletes the window associated to an item (if any).

        :param `item`: an instance of L{GenericTreeItem}.
        """

        if item.GetWindow() is None:
            return

        item.DeleteWindow()
        if item in self._itemWithWindow:
            self._itemWithWindow.remove(item)
        

    def GetItemWindowEnabled(self, item):
        """
        Returns whether the window associated to the item is enabled.

        :param `item`: an instance of L{GenericTreeItem}.
        """

        return item.GetWindowEnabled()


    def SetItemWindowEnabled(self, item, enable=True):
        """
        Enables/disables the window associated to the item.

        :param `item`: an instance of L{GenericTreeItem};
        :param `enable`: ``True`` to enable the associated window, ``False`` to
         disable it.
        """

        item.SetWindowEnabled(enable)


    def GetItemType(self, item):
        """
        Returns the item type.

        :param `item`: an instance of L{GenericTreeItem}.
        
        :see: L{SetItemType} for a description of valid item types.        
        """

        return item.GetType()


    def SetItemType(self, item, ct_type):
        """
        Sets the item type.

        :param `item`: an instance of L{GenericTreeItem};
        :param `ct_type`: May be one of the following integers:

         =============== =========================================
         `ct_type` Value Description
         =============== =========================================
                0        A normal item
                1        A checkbox-like item
                2        A radiobutton-type item
         =============== =========================================

        :note: Regarding radiobutton-type items (with `ct_type` = 2), the following
         approach is used:
         
         - All peer-nodes that are radiobuttons will be mutually exclusive. In other words,
           only one of a set of radiobuttons that share a common parent can be checked at
           once. If a radiobutton node becomes checked, then all of its peer radiobuttons
           must be unchecked.
         - If a radiobutton node becomes unchecked, then all of its child nodes will become
           inactive.

        """

        item.SetType(ct_type)
        self.CalculatePositions()
        self.Refresh()


# -----------------------------------------------------------------------------
# item status inquiries
# -----------------------------------------------------------------------------

    def IsVisible(self, item):
        """
        Returns whether the item is visible or not (i.e., its hierarchy is expanded
        enough to show the item).

        :param `item`: an instance of L{GenericTreeItem}.
        """

        # An item is only visible if it's not a descendant of a collapsed item
        parent = item.GetParent()

        while parent:
        
            if not parent.IsExpanded():
                return False
            
            parent = parent.GetParent()
        
        startX, startY = self.GetViewStart()
        clientSize = self.GetClientSize()

        rect = self.GetBoundingRect(item)
        
        if not rect:
            return False
        if rect.GetWidth() == 0 or rect.GetHeight() == 0:
            return False
        if rect.GetBottom() < 0 or rect.GetTop() > clientSize.y:
            return False
        if rect.GetRight() < 0 or rect.GetLeft() > clientSize.x:
            return False

        return True


    def ItemHasChildren(self, item):
        """
        Returns whether the item has children or not.

        :param `item`: an instance of L{GenericTreeItem}.
        """

        # consider that the item does have children if it has the "+" button: it
        # might not have them (if it had never been expanded yet) but then it
        # could have them as well and it's better to err on this side rather than
        # disabling some operations which are restricted to the items with
        # children for an item which does have them
        return item.HasPlus()


    def IsExpanded(self, item):
        """
        Returns whether the item is expanded or not.

        :param `item`: an instance of L{GenericTreeItem}.
        """

        return item.IsExpanded()


    def IsSelected(self, item):
        """
        Returns whether the item is selected or not.

        :param `item`: an instance of L{GenericTreeItem}.
        """

        return item.IsSelected()


    def IsBold(self, item):
        """
        Returns whether the item font is bold or not.

        :param `item`: an instance of L{GenericTreeItem}.
        """

        return item.IsBold()


    def IsItalic(self, item):
        """
        Returns whether the item font is italic or not.

        :param `item`: an instance of L{GenericTreeItem}.
        """

        return item.IsItalic()


# -----------------------------------------------------------------------------
# navigation
# -----------------------------------------------------------------------------

    def GetItemParent(self, item):
        """
        Returns the item parent (can be ``None`` for root items).

        :param `item`: an instance of L{GenericTreeItem}.
        """

        return item.GetParent()


    def GetFirstChild(self, item):
        """
        Returns the item's first child and an integer value 'cookie'.
        Call L{GetNextChild} for the next child using this very 'cookie' return
        value as an input.

        :param `item`: an instance of L{GenericTreeItem}.

        :note: This method returns ``None`` if there are no further children.
        """

        cookie = 0
        return self.GetNextChild(item, cookie)


    def GetNextChild(self, item, cookie):
        """
        Returns the item's next child.

        :param `item`: an instance of L{GenericTreeItem};
        :param `cookie`: a parameter which is opaque for the application but is necessary
         for the library to make these functions reentrant (i.e. allow more than one
         enumeration on one and the same object simultaneously).

        :note: This method returns ``None`` if there are no further children.
        """

        children = item.GetChildren()

        # it's ok to cast cookie to size_t, we never have indices big enough to
        # overflow "void *"

        if cookie < len(children):
            
            return children[cookie], cookie+1
        
        else:
        
            # there are no more of them
            return None, cookie
    

    def GetLastChild(self, item):
        """
        Returns the item last child.

        :param `item`: an instance of L{GenericTreeItem}.
        """

        children = item.GetChildren()
        return (len(children) == 0 and [None] or [children[-1]])[0]


    def GetNextSibling(self, item):
        """
        Returns the next sibling of an item.

        :param `item`: an instance of L{GenericTreeItem}.

        :note: This method returns ``None`` if there are no further siblings.
        """

        i = item
        parent = i.GetParent()
        
        if parent == None:
        
            # root item doesn't have any siblings
            return None
        
        siblings = parent.GetChildren()
        index = siblings.index(i)
        
        n = index + 1
        return (n == len(siblings) and [None] or [siblings[n]])[0]


    def GetPrevSibling(self, item):
        """
        Returns the previous sibling of an item.

        :param `item`: an instance of L{GenericTreeItem}.

        :note: This method returns ``None`` if there are no further siblings.
        """

        i = item
        parent = i.GetParent()
        
        if parent == None:
        
            # root item doesn't have any siblings
            return None
        
        siblings = parent.GetChildren()
        index = siblings.index(i)

        return (index == 0 and [None] or [siblings[index-1]])[0]


    def GetNext(self, item):
        """
        Returns the next item. Only for internal use right now.

        :param `item`: an instance of L{GenericTreeItem}.
        """

        i = item

        # First see if there are any children.
        children = i.GetChildren()
        if len(children) > 0:
             return children[0]
        else:
             # Try a sibling of this or ancestor instead
             p = item
             toFind = None
             while p and not toFind:
                  toFind = self.GetNextSibling(p)
                  p = self.GetItemParent(p)
                  
             return toFind
        

    def GetFirstVisibleItem(self):
        """ Returns the first visible item. """

        id = self.GetRootItem()
        if not id:
            return id

        while id:
            if self.IsVisible(id):
                return id
            id = self.GetNext(id)

        return None


    def GetNextVisible(self, item):
        """
        Returns the next visible item.

        :param `item`: an instance of L{GenericTreeItem}.
        """

        id = item

        while id:
            id = self.GetNext(id)
            if id and self.IsVisible(id):
                return id
            
        return None


    def GetPrevVisible(self, item):
        """
        Returns the previous visible item.

        :param `item`: an instance of L{GenericTreeItem}.
        """
 
        # find a previous sibling or parent which is visible
        lastGoodItem = self.GetPrevSibling(item)
        if not lastGoodItem or not self.IsVisible(lastGoodItem):
            parent = self.GetItemParent(item)
            rootHidden = self.HasAGWFlag(TR_HIDE_ROOT)
            rootItem = self.GetRootItem()
 
            while parent and not (rootHidden and parent == rootItem):
                if self.IsVisible(parent):
                    lastGoodItem = parent
                    break
                parent = self.GetItemParent(parent)

            if not lastGoodItem:
                return None
            
        # test if found item has visible children, if so and if the found item is not the 
        # parent of the current item traverse the found item to the last visible child
        if not self.HasChildren(lastGoodItem) or not self.IsExpanded(lastGoodItem) or \
           (self.GetItemParent(item) == lastGoodItem):
            return lastGoodItem
        
        lastChild = self.GetLastChild(lastGoodItem)
        while lastChild and self.IsVisible(lastChild):
            lastGoodItem = lastChild
            lastChild = self.GetLastChild(lastGoodItem)
 
        return lastGoodItem


    def ResetTextControl(self):
        """ Called by L{TreeTextCtrl} when it marks itself for deletion. """

        if self._textCtrl is not None:
            self._textCtrl.Destroy()
            self._textCtrl = None

        self.CalculatePositions()
        self.Refresh()
        self.AdjustMyScrollbars()


    def FindItem(self, idParent, prefixOrig):
        """
        Finds the first item starting with the given prefix after the given parent.

        :param `idParent`: an instance of L{GenericTreeItem};
        :param `prefixOrig`: a string containing the item text prefix.
        """

        # match is case insensitive as this is more convenient to the user: having
        # to press Shift-letter to go to the item starting with a capital letter
        # would be too bothersome
        prefix = prefixOrig.lower()

        # determine the starting point: we shouldn't take the current item (this
        # allows to switch between two items starting with the same letter just by
        # pressing it) but we shouldn't jump to the next one if the user is
        # continuing to type as otherwise he might easily skip the item he wanted
        id = idParent

        if len(prefix) == 1:
            id = self.GetNext(id)
        
        # look for the item starting with the given prefix after it
        while id and not self.GetItemText(id).lower().startswith(prefix):
        
            id = self.GetNext(id)
        
        # if we haven't found anything...
        if not id:
        
            # ... wrap to the beginning
            id = self.GetRootItem()
            if self.HasAGWFlag(TR_HIDE_ROOT):
                # can't select virtual root
                id = self.GetNext(id)
                if idParent == self.GetRootItem(): 
                    # no tree item selected and idParent is not reachable 
                    return id 
            
            # and try all the items (stop when we get to the one we started from)
            while id != idParent and not self.GetItemText(id).lower().startswith(prefix):
                id = self.GetNext(id)
            
        return id


# -----------------------------------------------------------------------------
# operations
# -----------------------------------------------------------------------------

    def DoInsertItem(self, parentId, previous, text, ct_type=0, wnd=None, image=-1, selImage=-1, data=None):
        """
        Actually inserts an item in the tree.

        :param `parentId`: an instance of L{GenericTreeItem} representing the
         item's parent;
        :param `previous`: the index at which we should insert the item;
        :param `text`: the item text label;
        :param `ct_type`: the item type (see L{SetItemType} for a list of valid
         item types);
        :param `wnd`: if not ``None``, a non-toplevel window to show next to the item;
        :param `image`: an index within the normal image list specifying the image to
         use for the item in unselected state;
        :param `selImage`: an index within the normal image list specifying the image to
         use for the item in selected state; if `image` > -1 and `selImage` is -1, the
         same image is used for both selected and unselected items;
        :param `data`: associate the given Python object `data` with the item.
        """

        if wnd is not None and not self.HasAGWFlag(TR_HAS_VARIABLE_ROW_HEIGHT):
            raise Exception("\nERROR: In Order To Append/Insert Controls You Have To Use The Style TR_HAS_VARIABLE_ROW_HEIGHT")

        if text.find("\n") >= 0 and not self.HasAGWFlag(TR_HAS_VARIABLE_ROW_HEIGHT):
            raise Exception("\nERROR: In Order To Append/Insert A MultiLine Text You Have To Use The Style TR_HAS_VARIABLE_ROW_HEIGHT")

        if ct_type < 0 or ct_type > 2:
            raise Exception("\nERROR: Item Type Should Be 0 (Normal), 1 (CheckBox) or 2 (RadioButton). ")
        
        parent = parentId
        
        if not parent:
            # should we give a warning here?
            return self.AddRoot(text, ct_type, wnd, image, selImage, data)
        
        self._dirty = True     # do this first so stuff below doesn't cause flicker

        item = GenericTreeItem(parent, text, ct_type, wnd, image, selImage, data)
        
        if wnd is not None:
            self._hasWindows = True
            self._itemWithWindow.append(item)
        
        parent.Insert(item, previous)

        return item


    def AddRoot(self, text, ct_type=0, wnd=None, image=-1, selImage=-1, data=None):
        """
        Adds a root item to the L{CustomTreeCtrl}.

        :param `text`: the item text label;
        :param `ct_type`: the item type (see L{SetItemType} for a list of valid
         item types);
        :param `wnd`: if not ``None``, a non-toplevel window to show next to the item;
        :param `image`: an index within the normal image list specifying the image to
         use for the item in unselected state;
        :param `selImage`: an index within the normal image list specifying the image to
         use for the item in selected state; if `image` > -1 and `selImage` is -1, the
         same image is used for both selected and unselected items;
        :param `data`: associate the given Python object `data` with the item.

        :warning: only one root is allowed to exist in any given instance of L{CustomTreeCtrl}.
        """

        if self._anchor:
            raise Exception("\nERROR: Tree Can Have Only One Root")

        if wnd is not None and not self.HasAGWFlag(TR_HAS_VARIABLE_ROW_HEIGHT):
            raise Exception("\nERROR: In Order To Append/Insert Controls You Have To Use The Style TR_HAS_VARIABLE_ROW_HEIGHT")

        if text.find("\n") >= 0 and not self.HasAGWFlag(TR_HAS_VARIABLE_ROW_HEIGHT):
            raise Exception("\nERROR: In Order To Append/Insert A MultiLine Text You Have To Use The Style TR_HAS_VARIABLE_ROW_HEIGHT")

        if ct_type < 0 or ct_type > 2:
            raise Exception("\nERROR: Item Type Should Be 0 (Normal), 1 (CheckBox) or 2 (RadioButton). ")

        self._dirty = True     # do this first so stuff below doesn't cause flicker

        self._anchor = GenericTreeItem(None, text, ct_type, wnd, image, selImage, data)
        
        if wnd is not None:
            self._hasWindows = True
            self._itemWithWindow.append(self._anchor)            
        
        if self.HasAGWFlag(TR_HIDE_ROOT):
        
            # if root is hidden, make sure we can navigate
            # into children
            self._anchor.SetHasPlus()
            self._anchor.Expand()
            self.CalculatePositions()
        
        if not self.HasAGWFlag(TR_MULTIPLE):
        
            self._current = self._key_current = self._anchor
            self._current.SetHilight(True)
        
        return self._anchor


    def PrependItem(self, parent, text, ct_type=0, wnd=None, image=-1, selImage=-1, data=None):
        """
        Prepends an item as a first child of parent.

        :param `parent`: an instance of L{GenericTreeItem} representing the
         item's parent;
        :param `text`: the item text label;
        :param `ct_type`: the item type (see L{SetItemType} for a list of valid
         item types);
        :param `wnd`: if not ``None``, a non-toplevel window to show next to the item;
        :param `image`: an index within the normal image list specifying the image to
         use for the item in unselected state;
        :param `selImage`: an index within the normal image list specifying the image to
         use for the item in selected state; if `image` > -1 and `selImage` is -1, the
         same image is used for both selected and unselected items;
        :param `data`: associate the given Python object `data` with the item.
        """

        return self.DoInsertItem(parent, 0, text, ct_type, wnd, image, selImage, data)


    def InsertItemByItem(self, parentId, idPrevious, text, ct_type=0, wnd=None, image=-1, selImage=-1, data=None):
        """
        Inserts an item after the given previous.

        :param `parentId`: an instance of L{GenericTreeItem} representing the
         item's parent;
        :param `idPrevious`: an instance of L{GenericTreeItem} representing the
         previous item;
        :param `text`: the item text label;
        :param `ct_type`: the item type (see L{SetItemType} for a list of valid
         item types);
        :param `wnd`: if not ``None``, a non-toplevel window to show next to the item;
        :param `image`: an index within the normal image list specifying the image to
         use for the item in unselected state;
        :param `selImage`: an index within the normal image list specifying the image to
         use for the item in selected state; if `image` > -1 and `selImage` is -1, the
         same image is used for both selected and unselected items;
        :param `data`: associate the given Python object `data` with the item.
        """
                
        parent = parentId
        
        if not parent:
            # should we give a warning here?
            return self.AddRoot(text, ct_type, wnd, image, selImage, data)
        
        index = -1
        if idPrevious:

            try:
                index = parent.GetChildren().index(idPrevious)
            except:
                raise Exception("ERROR: Previous Item In CustomTreeCtrl.InsertItem() Is Not A Sibling")

        return self.DoInsertItem(parentId, index+1, text, ct_type, wnd, image, selImage, data)


    def InsertItemByIndex(self, parentId, idPrevious, text, ct_type=0, wnd=None, image=-1, selImage=-1, data=None):
        """
        Inserts an item after the given previous.

        :param `parentId`: an instance of L{GenericTreeItem} representing the
         item's parent;
        :param `idPrevious`: the index at which we should insert the new item;
        :param `text`: the item text label;
        :param `ct_type`: the item type (see L{SetItemType} for a list of valid
         item types);
        :param `wnd`: if not ``None``, a non-toplevel window to show next to the item;
        :param `image`: an index within the normal image list specifying the image to
         use for the item in unselected state;
        :param `selImage`: an index within the normal image list specifying the image to
         use for the item in selected state; if `image` > -1 and `selImage` is -1, the
         same image is used for both selected and unselected items;
        :param `data`: associate the given Python object `data` with the item.
        """
        
        parent = parentId
        
        if not parent:
            # should we give a warning here?
            return self.AddRoot(text, ct_type, wnd, image, selImage, data)
        
        return self.DoInsertItem(parentId, idPrevious, text, ct_type, wnd, image, selImage, data)


    def InsertItem(self, parentId, input, text, ct_type=0, wnd=None, image=-1, selImage=-1, data=None):
        """
        Inserts an item after the given previous.

        :see: L{InsertItemByIndex} and L{InsertItemByItem} for an explanation of
         the input parameters.
        """

        if type(input) == type(1):
            return self.InsertItemByIndex(parentId, input, text, ct_type, wnd, image, selImage, data)
        else:
            return self.InsertItemByItem(parentId, input, text, ct_type, wnd, image, selImage, data)
            

    def AppendItem(self, parentId, text, ct_type=0, wnd=None, image=-1, selImage=-1, data=None):
        """
        Appends an item as a last child of its parent.

        :param `parentId`: an instance of L{GenericTreeItem} representing the
         item's parent;
        :param `text`: the item text label;
        :param `ct_type`: the item type (see L{SetItemType} for a list of valid
         item types);
        :param `wnd`: if not ``None``, a non-toplevel window to show next to the item;
        :param `image`: an index within the normal image list specifying the image to
         use for the item in unselected state;
        :param `selImage`: an index within the normal image list specifying the image to
         use for the item in selected state; if `image` > -1 and `selImage` is -1, the
         same image is used for both selected and unselected items;
        :param `data`: associate the given Python object `data` with the item.
        """
        
        parent = parentId
        
        if not parent:
            # should we give a warning here?
            return self.AddRoot(text, ct_type, wnd, image, selImage, data)
        
        return self.DoInsertItem(parent, len(parent.GetChildren()), text, ct_type, wnd, image, selImage, data)


    def SendDeleteEvent(self, item):
        """
        Actually sends the ``EVT_TREE_DELETE_ITEM`` event.

        :param `item`: an instance of L{GenericTreeItem}.
        """

        event = TreeEvent(wxEVT_TREE_DELETE_ITEM, self.GetId())
        event._item = item
        event.SetEventObject(self)
        self.GetEventHandler().ProcessEvent(event)


    def IsDescendantOf(self, parent, item):
        """
        Checks if the given item is under another one in the tree hierarchy.

        :param `parent`: an instance of L{GenericTreeItem}, representing the possible
         parent of `item`;
        :param `item`: another instance of L{GenericTreeItem}.
        """

        while item:
        
            if item == parent:
            
                # item is a descendant of parent
                return True
            
            item = item.GetParent()
        
        return False


    # Don't leave edit or selection on a child which is about to disappear
    def ChildrenClosing(self, item):
        """
        We are about to destroy the item children.

        :param `item`: an instance of L{GenericTreeItem}.
        """

        if self._textCtrl != None and item != self._textCtrl.item() and self.IsDescendantOf(item, self._textCtrl.item()):
            self._textCtrl.StopEditing()
        
        if item != self._key_current and self.IsDescendantOf(item, self._key_current):
            self._key_current = None
        
        if self.IsDescendantOf(item, self._select_me):
            self._select_me = item
        
        if item != self._current and self.IsDescendantOf(item, self._current):
            self._current.SetHilight(False)
            self._current = None
            self._select_me = item


    def DeleteChildren(self, item):
        """
        Delete all the item's children.

        :param `item`: an instance of L{GenericTreeItem}.
        """

        self._dirty = True     # do this first so stuff below doesn't cause flicker

        self.ChildrenClosing(item)
        item.DeleteChildren(self)


    def Delete(self, item):
        """
        Deletes an item.

        :param `item`: an instance of L{GenericTreeItem}.
        """

        self._dirty = True     # do this first so stuff below doesn't cause flicker

        if self._textCtrl != None and self.IsDescendantOf(item, self._textCtrl.item()):
            # can't delete the item being edited, cancel editing it first
            self._textCtrl.StopEditing()
        
        parent = item.GetParent()

        # don't keep stale pointers around!
        if self.IsDescendantOf(item, self._key_current):
        
            # Don't silently change the selection:
            # do it properly in idle time, so event
            # handlers get called.

            # self._key_current = parent
            self._key_current = None
        
        # self._select_me records whether we need to select
        # a different item, in idle time.
        if self._select_me and self.IsDescendantOf(item, self._select_me):
            self._select_me = parent
        
        if self.IsDescendantOf(item, self._current):
        
            # Don't silently change the selection:
            # do it properly in idle time, so event
            # handlers get called.

            # self._current = parent
            self._current = None
            self._select_me = parent
        
        # remove the item from the tree
        if parent:
        
            parent.GetChildren().remove(item)  # remove by value
        
        else: # deleting the root
        
            # nothing will be left in the tree
            self._anchor = None
        
        # and delete all of its children and the item itself now
        item.DeleteChildren(self)
        self.SendDeleteEvent(item)

        if item == self._select_me:
            self._select_me = None

        # Remove the item with window
        if item in self._itemWithWindow:
            wnd = item.GetWindow()
            wnd.Hide()
            wnd.Destroy()
            item._wnd = None
            self._itemWithWindow.remove(item)
            
        del item


    def DeleteAllItems(self):
        """ Deletes all items in the L{CustomTreeCtrl}. """

        if self._anchor:
            self.Delete(self._anchor)
        

    def Expand(self, item):
        """
        Expands an item, sending a ``EVT_TREE_ITEM_EXPANDING`` and
        ``EVT_TREE_ITEM_EXPANDED`` events.

        :param `item`: an instance of L{GenericTreeItem}.        
        """
        
        if self.HasAGWFlag(TR_HIDE_ROOT) and item == self.GetRootItem():
             raise Exception("\nERROR: Can't Expand An Hidden Root. ")

        if not item.HasPlus():
            return

        if item.IsExpanded():
            return

        if self._sendEvent:
            event = TreeEvent(wxEVT_TREE_ITEM_EXPANDING, self.GetId())
            event._item = item
            event.SetEventObject(self)

            if self.GetEventHandler().ProcessEvent(event) and not event.IsAllowed():
                # cancelled by program
                return
    
        item.Expand()
        
        if not self._sendEvent:
            # We are in ExpandAll/ExpandAllChildren
            return

        self.CalculatePositions()
        self.RefreshSubtree(item)

        if self._hasWindows:
            # We hide the associated window here, we may show it after
            self.HideWindows()
            
        event.SetEventType(wxEVT_TREE_ITEM_EXPANDED)
        self.GetEventHandler().ProcessEvent(event)


    def ExpandAllChildren(self, item):
        """
        Expands all the items children of the input item.

        :param `item`: an instance of L{GenericTreeItem}.

        :note: This method suppresses the ``EVT_TREE_ITEM_EXPANDING`` and
         ``EVT_TREE_ITEM_EXPANDED`` events because expanding many items int the
         control would be too slow then.
        """

        self._sendEvent = False        
        if not self.HasAGWFlag(TR_HIDE_ROOT) or item != self.GetRootItem():
            self.Expand(item)
            if not self.IsExpanded(item):
                self._sendEvent = True
                return
        
        child, cookie = self.GetFirstChild(item)
        
        while child:
            self.ExpandAllChildren(child)
            child, cookie = self.GetNextChild(item, cookie)

        self._sendEvent = True
        

    def ExpandAll(self):
        """
        Expands all L{CustomTreeCtrl} items.

        :note: This method suppresses the ``EVT_TREE_ITEM_EXPANDING`` and
         ``EVT_TREE_ITEM_EXPANDED`` events because expanding many items int the
         control would be too slow then.
        """

        if self._anchor:
            self.ExpandAllChildren(self._anchor)

        self._sendEvent = True
        self._dirty = True
        

    def Collapse(self, item):
        """
        Collapse an item, sending a ``EVT_TREE_ITEM_COLLAPSING`` and
        ``EVT_TREE_ITEM_COLLAPSED`` events.

        :param `item`: an instance of L{GenericTreeItem}.
        """
        
        if self.HasAGWFlag(TR_HIDE_ROOT) and item == self.GetRootItem():
             raise Exception("\nERROR: Can't Collapse An Hidden Root. ")

        if not item.IsExpanded():
            return

        event = TreeEvent(wxEVT_TREE_ITEM_COLLAPSING, self.GetId())
        event._item = item
        event.SetEventObject(self)
        if self.GetEventHandler().ProcessEvent(event) and not event.IsAllowed():
            # cancelled by program
            return
    
        self.ChildrenClosing(item)
        item.Collapse()

        self.CalculatePositions()
        self.Refresh()

        if self._hasWindows:
            self.HideWindows()
            
        event.SetEventType(wxEVT_TREE_ITEM_COLLAPSED)
        self.GetEventHandler().ProcessEvent(event)


    def CollapseAndReset(self, item):
        """
        Collapse the given item and deletes its children.

        :param `item`: an instance of L{GenericTreeItem}.
        """

        self.Collapse(item)
        self.DeleteChildren(item)


    def Toggle(self, item):
        """
        Toggles the item state (collapsed/expanded).

        :param `item`: an instance of L{GenericTreeItem}.
        """

        if item.IsExpanded():
            self.Collapse(item)
        else:
            self.Expand(item)


    def HideWindows(self):
        """ Hides the windows associated to the items. Used internally. """
        
        for child in self._itemWithWindow:
            if not self.IsVisible(child):
                wnd = child.GetWindow()
                if wnd:
                    wnd.Hide()
            

    def Unselect(self):
        """ Unselects the current selection. """

        if self._current:
            self._current.SetHilight(False)
            self.RefreshLine(self._current)

        self._current = None
        self._select_me = None


    def UnselectAllChildren(self, item):
        """
        Unselects all the children of the given item.

        :param `item`: an instance of L{GenericTreeItem}.
        """

        if item.IsSelected():
            item.SetHilight(False)
            self.RefreshLine(item)
        
        if item.HasChildren():
            for child in item.GetChildren():
                self.UnselectAllChildren(child)


    def SelectAllChildren(self, item):
        """
        Selects all the children of the given item.

        :param `item`: an instance of L{GenericTreeItem}.

        :note: This method can be used only if L{CustomTreeCtrl} has the ``TR_MULTIPLE`` or ``TR_EXTENDED``
         style set.        
        """

        if not self.HasAGWFlag(TR_MULTIPLE) and not self.HasAGWFlag(TR_EXTENDED):
            raise Exception("SelectAllChildren can be used only with multiple selection enabled.")
        
        if not item.IsSelected():
            item.SetHilight(True)
            self.RefreshLine(item)
        
        if item.HasChildren():
            for child in item.GetChildren():
                self.SelectAllChildren(child)            


    def UnselectAll(self):
        """ Unselect all the items. """

        rootItem = self.GetRootItem()

        # the tree might not have the root item at all
        if rootItem:
            self.UnselectAllChildren(rootItem)

        self.Unselect()        


    def SelectAll(self):
        """
        Selects all the item in the tree.

        :note: This method can be used only if L{CustomTreeCtrl} has the ``TR_MULTIPLE`` or ``TR_EXTENDED``
         style set.
        """

        if not self.HasAGWFlag(TR_MULTIPLE) and not self.HasAGWFlag(TR_EXTENDED):
            raise Exception("SelectAll can be used only with multiple selection enabled.")
        
        rootItem = self.GetRootItem()

        # the tree might not have the root item at all
        if rootItem:
            self.SelectAllChildren(rootItem)

                
    # Recursive function !
    # To stop we must have crt_item<last_item
    # Algorithm :
    # Tag all next children, when no more children,
    # Move to parent (not to tag)
    # Keep going... if we found last_item, we stop.

    def TagNextChildren(self, crt_item, last_item, select):
        """ Used internally. """

        parent = crt_item.GetParent()

        if parent == None: # This is root item
            return self.TagAllChildrenUntilLast(crt_item, last_item, select)

        children = parent.GetChildren()
        index = children.index(crt_item)
        
        count = len(children)
        
        for n in xrange(index+1, count):
            if self.TagAllChildrenUntilLast(children[n], last_item, select):
                return True

        return self.TagNextChildren(parent, last_item, select)


    def TagAllChildrenUntilLast(self, crt_item, last_item, select):
        """ Used internally. """

        crt_item.SetHilight(select)
        self.RefreshLine(crt_item)

        if crt_item == last_item:
            return True

        if crt_item.HasChildren():        
            for child in crt_item.GetChildren():
                if self.TagAllChildrenUntilLast(child, last_item, select):
                    return True
            
        return False


    def SelectItemRange(self, item1, item2):
        """
        Selects all the items between `item1` and `item2`.

        :param `item1`: an instance of L{GenericTreeItem}, representing the first
         item in the range to select;
        :param `item2`: an instance of L{GenericTreeItem}, representing the last
         item in the range to select.

        :note: This method can be used only if L{CustomTreeCtrl} has the ``TR_MULTIPLE`` or ``TR_EXTENDED``
         style set.         
        """

        if not self.HasAGWFlag(TR_MULTIPLE) and not self.HasAGWFlag(TR_EXTENDED):
            raise Exception("SelectItemRange can be used only with multiple selection enabled.")
        
        self._select_me = None

        # item2 is not necessary after item1
        # choice first' and 'last' between item1 and item2
        first = (item1.GetY() < item2.GetY() and [item1] or [item2])[0]
        last = (item1.GetY() < item2.GetY() and [item2] or [item1])[0]

        select = self._current.IsSelected()

        if self.TagAllChildrenUntilLast(first, last, select):
            return

        self.TagNextChildren(first, last, select)


    def DoSelectItem(self, item, unselect_others=True, extended_select=False):
        """
        Actually selects/unselects an item, sending ``EVT_TREE_SEL_CHANGING`` and
        ``EVT_TREE_SEL_CHANGED`` events.

        :param `item`: an instance of L{GenericTreeItem};
        :param `unselect_others`: if ``True``, all the other selected items are
         unselected.
        :param `extended_select`: ``True`` if the L{CustomTreeCtrl} is using the
         ``TR_EXTENDED`` style.
        """

        self._select_me = None

        is_single = not (self.GetAGWWindowStyleFlag() & TR_MULTIPLE)

        # to keep going anyhow !!!
        if is_single:
            if item.IsSelected():
                # Handles hypertext items
                self.HandleHyperLink(item)
                return # nothing else to do
            unselect_others = True
            extended_select = False
        
        elif unselect_others and item.IsSelected():
        
            # selection change if there is more than one item currently selected
            if len(self.GetSelections()) == 1:
                # Handles hypertext items
                self.HandleHyperLink(item)
                return

        event = TreeEvent(wxEVT_TREE_SEL_CHANGING, self.GetId())
        event._item = item
        event._itemOld = self._current
        event.SetEventObject(self)
        # TODO : Here we don't send any selection mode yet !

        if self.GetEventHandler().ProcessEvent(event) and not event.IsAllowed():
            return

        parent = self.GetItemParent(item)
        while parent:
            if not self.IsExpanded(parent):
                self.Expand(parent)

            parent = self.GetItemParent(parent)
        
        # ctrl press
        if unselect_others:
            if is_single:
                self.Unselect() # to speed up thing
            else:
                self.UnselectAll()

        # shift press
        if extended_select:
            if not self._current:
                self._current = self._key_current = self.GetRootItem()
            
            # don't change the mark (self._current)
            self.SelectItemRange(self._current, item)
        
        else:
        
            select = True # the default

            # Check if we need to toggle hilight (ctrl mode)
            if not unselect_others:
                select = not item.IsSelected()

            self._current = self._key_current = item
            self._current.SetHilight(select)
            self.RefreshLine(self._current)
        
        # This can cause idle processing to select the root
        # if no item is selected, so it must be after the
        # selection is set
        self.EnsureVisible(item)

        event.SetEventType(wxEVT_TREE_SEL_CHANGED)
        self.GetEventHandler().ProcessEvent(event)

        # Handles hypertext items
        self.HandleHyperLink(item)
        

    def SelectItem(self, item, select=True):
        """
        Selects/deselects an item.

        :param `item`: an instance of L{GenericTreeItem};
        :param `select`: ``True`` to select an item, ``False`` to deselect it.
        """
        
        if select:
        
            self.DoSelectItem(item, not self.HasAGWFlag(TR_MULTIPLE))
        
        else: # deselect
        
            item.SetHilight(False)
            self.RefreshLine(item)

    
    def FillArray(self, item, array=[]):
        """
        Internal function. Used to populate an array of selected items when
        the style ``TR_MULTIPLE`` is used.
        """

        if not array:
            array = []
            
        if item.IsSelected():
            array.append(item)

        if item.HasChildren() and item.IsExpanded():
            for child in item.GetChildren():
                array = self.FillArray(child, array)
        
        return array
    

    def GetSelections(self):
        """
        Returns a list of selected items.

        :note: This method can be used only if L{CustomTreeCtrl} has the ``TR_MULTIPLE`` or ``TR_EXTENDED``
         style set.
        """

        array = []
        idRoot = self.GetRootItem()
        if idRoot:
            array = self.FillArray(idRoot, array)
        
        #else: the tree is empty, so no selections

        return array


    def HandleHyperLink(self, item):
        """
        Handles the hyperlink items, sending the ``EVT_TREE_ITEM_HYPERLINK`` event.

        :param `item`: an instance of L{GenericTreeItem}.        
        """

        if self.IsItemHyperText(item):
            event = TreeEvent(wxEVT_TREE_ITEM_HYPERLINK, self.GetId())
            event._item = item
            self.GetEventHandler().ProcessEvent(event)
        

    def EnsureVisible(self, item):
        """
        Scrolls and/or expands items to ensure that the given item is visible.

        :param `item`: an instance of L{GenericTreeItem}.
        """

        # first expand all parent branches
        parent = item.GetParent()

        if self.HasAGWFlag(TR_HIDE_ROOT):
            while parent and parent != self._anchor:
                self.Expand(parent)
                parent = parent.GetParent()
        else:
            while parent:
                self.Expand(parent)
                parent = parent.GetParent()
            
        self.ScrollTo(item)


    def ScrollTo(self, item):
        """
        Scrolls the specified item into view.

        :param `item`: an instance of L{GenericTreeItem}.
        """

        if not item:
            return

        # We have to call this here because the label in
        # question might just have been added and no screen
        # update taken place.
        if self._dirty:
            if wx.Platform in ["__WXMSW__", "__WXMAC__"]:
                self.Update()
        else:
            wx.YieldIfNeeded()

        # now scroll to the item
        item_y = item.GetY()
        start_x, start_y = self.GetViewStart()
        start_y *= _PIXELS_PER_UNIT

        client_w, client_h = self.GetClientSize()

        x, y = 0, 0

        if item_y < start_y+3:
        
            # going down
            x, y = self._anchor.GetSize(x, y, self)
            y += _PIXELS_PER_UNIT + 2 # one more scrollbar unit + 2 pixels
            x += _PIXELS_PER_UNIT + 2 # one more scrollbar unit + 2 pixels
            x_pos = self.GetScrollPos(wx.HORIZONTAL)
            # Item should appear at top
            self.SetScrollbars(_PIXELS_PER_UNIT, _PIXELS_PER_UNIT, x/_PIXELS_PER_UNIT, y/_PIXELS_PER_UNIT, x_pos, item_y/_PIXELS_PER_UNIT)
        
        elif item_y+self.GetLineHeight(item) > start_y+client_h:
        
            # going up
            x, y = self._anchor.GetSize(x, y, self)
            y += _PIXELS_PER_UNIT + 2 # one more scrollbar unit + 2 pixels
            x += _PIXELS_PER_UNIT + 2 # one more scrollbar unit + 2 pixels
            item_y += _PIXELS_PER_UNIT+2
            x_pos = self.GetScrollPos(wx.HORIZONTAL)
            # Item should appear at bottom
            self.SetScrollbars(_PIXELS_PER_UNIT, _PIXELS_PER_UNIT, x/_PIXELS_PER_UNIT, y/_PIXELS_PER_UNIT, x_pos, (item_y+self.GetLineHeight(item)-client_h)/_PIXELS_PER_UNIT )


    def OnCompareItems(self, item1, item2):
        """
        Returns whether 2 items have the same text.
        
        Override this function in the derived class to change the sort order of the items
        in the L{CustomTreeCtrl}. The function should return a negative, zero or positive
        value if the first item is less than, equal to or greater than the second one.

        :param `item1`: an instance of L{GenericTreeItem};
        :param `item2`: another instance of L{GenericTreeItem}.

        :note: The base class version compares items alphabetically.
        """

        return cmp(self.GetItemText(item1), self.GetItemText(item2))


    def SortChildren(self, item):
        """
        Sorts the children of the given item using the L{OnCompareItems} method of
        L{CustomTreeCtrl}. 

        :param `item`: an instance of L{GenericTreeItem}.
        
        :note: You should override the L{OnCompareItems} method in your derived class to change
         the sort order (the default is ascending case-sensitive alphabetical order).
        """

        children = item.GetChildren()
        
        if len(children) > 1:
            self._dirty = True
            children.sort(self.OnCompareItems)
        

    def GetImageList(self):
        """ Returns the normal image list associated with L{CustomTreeCtrl}. """

        return self._imageListNormal


    def GetButtonsImageList(self):
        """
        Returns the buttons image list associated with L{CustomTreeCtrl} (from
        which application-defined button images are taken).
        """

        return self._imageListButtons


    def GetStateImageList(self):
        """
        Returns the state image list associated with L{CustomTreeCtrl} (from which
        application-defined state images are taken).
        """

        return self._imageListState


    def GetImageListCheck(self):
        """ Returns the image list used to build the check/radio buttons in L{CustomTreeCtrl}. """

        return self._imageListCheck        


    def GetLeftImageList(self):
        """
        Returns the image list for L{CustomTreeCtrl} filled with images to be used on
        the leftmost part of the client area. Any item can have a leftmost image associated
        with it.
        """

        return self._imageListLeft


    def CalculateLineHeight(self):
        """ Calculates the height of a line. """

        dc = wx.ClientDC(self)
        self._lineHeight = dc.GetCharHeight() 

        if self._imageListNormal:
        
            # Calculate a self._lineHeight value from the normal Image sizes.
            # May be toggle off. Then CustomTreeCtrl will spread when
            # necessary (which might look ugly).
            n = self._imageListNormal.GetImageCount()

            for i in xrange(n):
            
                width, height = self._imageListNormal.GetSize(i)

                if height > self._lineHeight:
                    self._lineHeight = height
            
        if self._imageListButtons:
        
            # Calculate a self._lineHeight value from the Button image sizes.
            # May be toggle off. Then CustomTreeCtrl will spread when
            # necessary (which might look ugly).
            n = self._imageListButtons.GetImageCount()

            for i in xrange(n):
            
                width, height = self._imageListButtons.GetSize(i)

                if height > self._lineHeight:
                    self._lineHeight = height

        if self._imageListCheck:
        
            # Calculate a self._lineHeight value from the check/radio image sizes.
            # May be toggle off. Then CustomTreeCtrl will spread when
            # necessary (which might look ugly).
            n = self._imageListCheck.GetImageCount()

            for i in xrange(n):
            
                width, height = self._imageListCheck.GetSize(i)

                if height > self._lineHeight:
                    self._lineHeight = height

        if self._imageListLeft:
        
            # Calculate a self._lineHeight value from the leftmost image sizes.
            # May be toggle off. Then CustomTreeCtrl will spread when
            # necessary (which might look ugly).
            n = self._imageListLeft.GetImageCount()

            for i in xrange(n):
            
                width, height = self._imageListLeft.GetSize(i)

                if height > self._lineHeight:
                    self._lineHeight = height
        
        if self._lineHeight < 30:
            self._lineHeight += 2                 # at least 2 pixels
        else:
            self._lineHeight += self._lineHeight/10   # otherwise 10% extra spacing


    def SetImageList(self, imageList):
        """
        Sets the normal image list for L{CustomTreeCtrl}.

        :param `imageList`: an instance of `wx.ImageList`.
        """

        if self._ownsImageListNormal:
            del self._imageListNormal
            
        self._imageListNormal = imageList
        self._ownsImageListNormal = False
        self._dirty = True
        
        # Don't do any drawing if we're setting the list to NULL,
        # since we may be in the process of deleting the tree control.
        if imageList:
            self.CalculateLineHeight()

            # We gray out the image list to use the grayed icons with disabled items
            sz = imageList.GetSize(0)
            self._grayedImageList = wx.ImageList(sz[0], sz[1], True, 0)

            for ii in xrange(imageList.GetImageCount()):
                bmp = imageList.GetBitmap(ii)
                newbmp = MakeDisabledBitmap(bmp)
                self._grayedImageList.Add(newbmp)


    def SetLeftImageList(self, imageList):
        """
        Sets the image list for L{CustomTreeCtrl} filled with images to be used on
        the leftmost part of the client area. Any item can have a leftmost image associated
        with it.

        :param `imageList`: an instance of `wx.ImageList`.
        """

        self._imageListLeft = imageList
        self._ownsImageListLeft = False
        self._dirty = True
        
        # Don't do any drawing if we're setting the list to NULL,
        # since we may be in the process of deleting the tree control.
        if imageList:
            self.CalculateLineHeight()

            # We gray out the image list to use the grayed icons with disabled items
            sz = imageList.GetSize(0)
            self._grayedImageListLeft = wx.ImageList(sz[0], sz[1], True, 0)

            for ii in xrange(imageList.GetImageCount()):
                bmp = imageList.GetBitmap(ii)
                newbmp = MakeDisabledBitmap(bmp)
                self._grayedImageListLeft.Add(newbmp)
        

    def SetStateImageList(self, imageList):
        """
        Sets the state image list for L{CustomTreeCtrl} (from which application-defined
        state images are taken).

        :param `imageList`: an instance of `wx.ImageList`.
        """
        
        if self._ownsImageListState:
            del self._imageListState

        self._imageListState = imageList
        self._ownsImageListState = False


    def SetButtonsImageList(self, imageList):
        """
        Sets the buttons image list for L{CustomTreeCtrl} (from which application-defined
        button images are taken).

        :param `imageList`: an instance of `wx.ImageList`.
        """

        if self._ownsImageListButtons:
            del self._imageListButtons
            
        self._imageListButtons = imageList
        self._ownsImageListButtons = False
        self._dirty = True
        self.CalculateLineHeight()


    def SetImageListCheck(self, sizex, sizey, imglist=None):
        """
        Sets the checkbox/radiobutton image list.

        :param `sizex`: the width of the bitmaps in the `imglist`;
        :param `sizey`: the height of the bitmaps in the `imglist`;
        :param `imglist`: an instance of `wx.ImageList`.
        """

        # Image list to hold disabled versions of each control
        self._grayedCheckList = wx.ImageList(sizex, sizey, True, 0)

        if imglist is None:
            
            self._imageListCheck = wx.ImageList(sizex, sizey)

            # Get the Checkboxes
            self._imageListCheck.Add(self.GetControlBmp(checkbox=True,
                                                        checked=True,
                                                        enabled=True,
                                                        x=sizex, y=sizey))
            self._grayedCheckList.Add(self.GetControlBmp(checkbox=True,
                                                         checked=True,
                                                         enabled=False,
                                                         x=sizex, y=sizey))

            self._imageListCheck.Add(self.GetControlBmp(checkbox=True,
                                                        checked=False,
                                                        enabled=True,
                                                        x=sizex, y=sizey))
            self._grayedCheckList.Add(self.GetControlBmp(checkbox=True,
                                                         checked=False,
                                                         enabled=False,
                                                         x=sizex, y=sizey))

            self._imageListCheck.Add(self.GetControlBmp(checkbox=True,
                                                        checked=2,
                                                        enabled=True,
                                                        x=sizex, y=sizey))
            self._grayedCheckList.Add(self.GetControlBmp(checkbox=True,
                                                         checked=2,
                                                         enabled=False,
                                                         x=sizex, y=sizey))

            # Get the Radio Buttons
            self._imageListCheck.Add(self.GetControlBmp(checkbox=False,
                                                        checked=True,
                                                        enabled=True,
                                                        x=sizex, y=sizey))
            self._grayedCheckList.Add(self.GetControlBmp(checkbox=False,
                                                         checked=True,
                                                         enabled=False,
                                                         x=sizex, y=sizey))

            self._imageListCheck.Add(self.GetControlBmp(checkbox=False,
                                                        checked=False,
                                                        enabled=True,
                                                        x=sizex, y=sizey))
            self._grayedCheckList.Add(self.GetControlBmp(checkbox=False,
                                                        checked=False,
                                                        enabled=False,
                                                        x=sizex, y=sizey))

        else:

            sizex, sizey = imglist.GetSize(0)
            self._imageListCheck = imglist

            for ii in xrange(self._imageListCheck.GetImageCount()):
                
                bmp = self._imageListCheck.GetBitmap(ii)
                newbmp = MakeDisabledBitmap(bmp)
                self._grayedCheckList.Add(newbmp)

        self._dirty = True

        if imglist:
            self.CalculateLineHeight()


    def AssignImageList(self, imageList):
        """
        Assigns the normal image list.

        :param `imageList`: an instance of `wx.ImageList`.
        """

        self.SetImageList(imageList)
        self._ownsImageListNormal = True


    def AssignStateImageList(self, imageList):
        """
        Assigns the state image list.

        :param `imageList`: an instance of `wx.ImageList`.
        """

        self.SetStateImageList(imageList)
        self._ownsImageListState = True


    def AssignButtonsImageList(self, imageList):
        """
        Assigns the button image list.

        :param `imageList`: an instance of `wx.ImageList`.
        """

        self.SetButtonsImageList(imageList)
        self._ownsImageListButtons = True


    def AssignLeftImageList(self, imageList):
        """
        Assigns the image list for L{CustomTreeCtrl} filled with images to be used on
        the leftmost part of the client area. Any item can have a leftmost image associated
        with it.

        :param `imageList`: an instance of `wx.ImageList`.
        """

        self.SetLeftImageList(imageList)
        self._ownsImageListLeft = True


# -----------------------------------------------------------------------------
# helpers
# -----------------------------------------------------------------------------

    def AdjustMyScrollbars(self):
        """ Internal method used to adjust the `wx.PyScrolledWindow` scrollbars. """

        if self._anchor:
        
            x, y = self._anchor.GetSize(0, 0, self)
            y += _PIXELS_PER_UNIT + 2 # one more scrollbar unit + 2 pixels
            x += _PIXELS_PER_UNIT + 2 # one more scrollbar unit + 2 pixels
            x_pos = self.GetScrollPos(wx.HORIZONTAL)
            y_pos = self.GetScrollPos(wx.VERTICAL)
            self.SetScrollbars(_PIXELS_PER_UNIT, _PIXELS_PER_UNIT, x/_PIXELS_PER_UNIT, y/_PIXELS_PER_UNIT, x_pos, y_pos)
        
        else:
        
            self.SetScrollbars(0, 0, 0, 0)
    

    def GetLineHeight(self, item):
        """
        Returns the line height for the given item.

        :param `item`: an instance of L{GenericTreeItem}.
        """

        if self.GetAGWWindowStyleFlag() & TR_HAS_VARIABLE_ROW_HEIGHT:
            return item.GetHeight()
        else:
            return self._lineHeight


    def DrawVerticalGradient(self, dc, rect, hasfocus):
        """
        Gradient fill from colour 1 to colour 2 from top to bottom.

        :param `dc`: an instance of `wx.DC`;
        :param `rect`: the rectangle to be filled with the gradient shading;
        :param `hasfocus`: ``True`` if the main L{CustomTreeCtrl} has focus, ``False``
         otherwise.
        """

        oldpen = dc.GetPen()
        oldbrush = dc.GetBrush()
        dc.SetPen(wx.TRANSPARENT_PEN)

        # calculate gradient coefficients
        if hasfocus:
            col2 = self._secondcolour
            col1 = self._firstcolour
        else:
            col2 = self._hilightUnfocusedBrush.GetColour()
            col1 = self._hilightUnfocusedBrush2.GetColour()

        r1, g1, b1 = int(col1.Red()), int(col1.Green()), int(col1.Blue())
        r2, g2, b2 = int(col2.Red()), int(col2.Green()), int(col2.Blue())

        flrect = float(rect.height)

        rstep = float((r2 - r1)) / flrect
        gstep = float((g2 - g1)) / flrect
        bstep = float((b2 - b1)) / flrect

        rf, gf, bf = 0, 0, 0
        
        for y in xrange(rect.y, rect.y + rect.height):
            currCol = (r1 + rf, g1 + gf, b1 + bf)                
            dc.SetBrush(wx.Brush(currCol, wx.SOLID))
            dc.DrawRectangle(rect.x, y, rect.width, 1)
            rf = rf + rstep
            gf = gf + gstep
            bf = bf + bstep
        
        dc.SetPen(oldpen)
        dc.SetBrush(wx.TRANSPARENT_BRUSH)
        dc.DrawRectangleRect(rect)
        dc.SetBrush(oldbrush)


    def DrawHorizontalGradient(self, dc, rect, hasfocus):
        """
        Gradient fill from colour 1 to colour 2 from left to right.

        :param `dc`: an instance of `wx.DC`;
        :param `rect`: the rectangle to be filled with the gradient shading;
        :param `hasfocus`: ``True`` if the main L{CustomTreeCtrl} has focus, ``False``
         otherwise.
        """

        oldpen = dc.GetPen()
        oldbrush = dc.GetBrush()
        dc.SetPen(wx.TRANSPARENT_PEN)

        # calculate gradient coefficients

        if hasfocus:
            col2 = self._secondcolour
            col1 = self._firstcolour
        else:
            col2 = self._hilightUnfocusedBrush.GetColour()
            col1 = self._hilightUnfocusedBrush2.GetColour()

        r1, g1, b1 = int(col1.Red()), int(col1.Green()), int(col1.Blue())
        r2, g2, b2 = int(col2.Red()), int(col2.Green()), int(col2.Blue())

        flrect = float(rect.width)

        rstep = float((r2 - r1)) / flrect
        gstep = float((g2 - g1)) / flrect
        bstep = float((b2 - b1)) / flrect

        rf, gf, bf = 0, 0, 0

        for x in xrange(rect.x, rect.x + rect.width):
            currCol = (int(r1 + rf), int(g1 + gf), int(b1 + bf))
            dc.SetBrush(wx.Brush(currCol, wx.SOLID))
            dc.DrawRectangle(x, rect.y, 1, rect.height)
            rf = rf + rstep
            gf = gf + gstep
            bf = bf + bstep

        dc.SetPen(oldpen)
        dc.SetBrush(wx.TRANSPARENT_BRUSH)
        dc.DrawRectangleRect(rect)
        dc.SetBrush(oldbrush)
        

    def DrawVistaRectangle(self, dc, rect, hasfocus):
        """
        Draws the selected item(s) with the Windows Vista style.

        :param `dc`: an instance of `wx.DC`;
        :param `rect`: the rectangle to be filled with the gradient shading;
        :param `hasfocus`: ``True`` if the main L{CustomTreeCtrl} has focus, ``False``
         otherwise.
        """

        if hasfocus:
            
            outer = _rgbSelectOuter
            inner = _rgbSelectInner
            top = _rgbSelectTop
            bottom = _rgbSelectBottom

        else:
            
            outer = _rgbNoFocusOuter
            inner = _rgbNoFocusInner
            top = _rgbNoFocusTop
            bottom = _rgbNoFocusBottom

        oldpen = dc.GetPen()
        oldbrush = dc.GetBrush()

        bdrRect = wx.Rect(*rect.Get())
        filRect = wx.Rect(*rect.Get())
        filRect.Deflate(1,1)
        
        r1, g1, b1 = int(top.Red()), int(top.Green()), int(top.Blue())
        r2, g2, b2 = int(bottom.Red()), int(bottom.Green()), int(bottom.Blue())

        flrect = float(filRect.height)
        if flrect < 1:
            flrect = self._lineHeight

        rstep = float((r2 - r1)) / flrect
        gstep = float((g2 - g1)) / flrect
        bstep = float((b2 - b1)) / flrect

        rf, gf, bf = 0, 0, 0
        dc.SetPen(wx.TRANSPARENT_PEN)
        
        for y in xrange(filRect.y, filRect.y + filRect.height):
            currCol = (r1 + rf, g1 + gf, b1 + bf)
            dc.SetBrush(wx.Brush(currCol, wx.SOLID))
            dc.DrawRectangle(filRect.x, y, filRect.width, 1)
            rf = rf + rstep
            gf = gf + gstep
            bf = bf + bstep
        
        dc.SetBrush(wx.TRANSPARENT_BRUSH)
        dc.SetPen(wx.Pen(outer))
        dc.DrawRoundedRectangleRect(bdrRect, 3)
        bdrRect.Deflate(1, 1)
        dc.SetPen(wx.Pen(inner))
        dc.DrawRoundedRectangleRect(bdrRect, 2)

        dc.SetPen(oldpen)
        dc.SetBrush(oldbrush)


    def PaintItem(self, item, dc, level, align):
        """
        Actually draws an item.

        :param `item`: an instance of L{GenericTreeItem};
        :param `dc`: an instance of `wx.DC`;
        :param `level`: the item level in the tree hierarchy;
        :param `align`: ``True`` if we want to align windows (in items with windows)
         at the same horizontal position.
        """

        attr = item.GetAttributes()
        
        if attr and attr.HasFont():
            dc.SetFont(attr.GetFont())
        else:
            if item.IsBold():
                dc.SetFont(self._boldFont)
            elif item.IsItalic():
                dc.SetFont(self._italicFont)
        if item.IsHyperText():
            dc.SetFont(self.GetHyperTextFont())
            if item.GetVisited():
                dc.SetTextForeground(self.GetHyperTextVisitedColour())
            else:
                dc.SetTextForeground(self.GetHyperTextNewColour())
                    
        text_w, text_h, dummy = dc.GetMultiLineTextExtent(item.GetText())

        image = item.GetCurrentImage()
        checkimage = item.GetCurrentCheckedImage()
        leftimage = _NO_IMAGE
        
        if self._imageListLeft:
            leftimage = item.GetLeftImage()
            
        image_w, image_h = 0, 0

        if image != _NO_IMAGE:
        
            if self._imageListNormal:
            
                image_w, image_h = self._imageListNormal.GetSize(image)
                image_w += 4
            
            else:
            
                image = _NO_IMAGE

        if item.GetType() != 0:
            wcheck, hcheck = self._imageListCheck.GetSize(item.GetType())
            wcheck += 4
        else:
            wcheck, hcheck = 0, 0

        if leftimage != _NO_IMAGE:
            l_image_w, l_image_h = self._imageListLeft.GetSize(leftimage)
            
        total_h = self.GetLineHeight(item)
        drawItemBackground = False
            
        if item.IsSelected():
        
            # under mac selections are only a rectangle in case they don't have the focus
            if wx.Platform == "__WXMAC__":
                if not self._hasFocus:
                    dc.SetBrush(wx.TRANSPARENT_BRUSH) 
                    dc.SetPen(wx.Pen(wx.SystemSettings_GetColour(wx.SYS_COLOUR_HIGHLIGHT), 1, wx.SOLID)) 
                else:
                    dc.SetBrush(self._hilightBrush) 
            else:
                    dc.SetBrush((self._hasFocus and [self._hilightBrush] or [self._hilightUnfocusedBrush])[0])
                    drawItemBackground = True
        else:
            if attr and attr.HasBackgroundColour():
                drawItemBackground = True
                colBg = attr.GetBackgroundColour()
            else:
                colBg = self._backgroundColour
            
            dc.SetBrush(wx.Brush(colBg, wx.SOLID))
            dc.SetPen(wx.TRANSPARENT_PEN)
        
        offset = (self.HasAGWFlag(TR_ROW_LINES) and [1] or [0])[0]
        
        if self.HasAGWFlag(TR_FULL_ROW_HIGHLIGHT):
            x = 0
            w, h = self.GetClientSize()

            itemrect = wx.Rect(x, item.GetY()+offset, w, total_h-offset)
            
            if item.IsSelected():
                if self._usegradients:
                    if self._gradientstyle == 0:   # Horizontal
                        self.DrawHorizontalGradient(dc, itemrect, self._hasFocus)
                    else:                          # Vertical
                        self.DrawVerticalGradient(dc, itemrect, self._hasFocus)
                elif self._vistaselection:
                    self.DrawVistaRectangle(dc, itemrect, self._hasFocus)
                else:
                    if wx.Platform in ["__WXGTK2__", "__WXMAC__"]:
                        flags = wx.CONTROL_SELECTED
                        if self._hasFocus: flags = flags | wx.CONTROL_FOCUSED
                        wx.RendererNative.Get().DrawItemSelectionRect(self, dc, itemrect, flags) 
                    else:
                        dc.DrawRectangleRect(itemrect)
            else:
               if drawItemBackground:
                   minusicon = wcheck + image_w - 2
                   itemrect = wx.Rect(item.GetX()+minusicon,
                                      item.GetY()+offset,
                                      item.GetWidth()-minusicon,
                                      total_h-offset)
                   dc.DrawRectangleRect(itemrect)
                
        else:

            if item.IsSelected():
            
                # If it's selected, and there's an image, then we should
                # take care to leave the area under the image painted in the
                # background colour.

                wnd = item.GetWindow()
                wndx = 0
                if wnd:
                    wndx, wndy = item.GetWindowSize()

                itemrect = wx.Rect(item.GetX() + wcheck + image_w - 2,
                                   item.GetY()+offset,
                                   item.GetWidth() - image_w - wcheck + 2 - wndx,
                                   total_h-offset)

                if self._usegradients:
                    if self._gradientstyle == 0:   # Horizontal
                        self.DrawHorizontalGradient(dc, itemrect, self._hasFocus)
                    else:                          # Vertical
                        self.DrawVerticalGradient(dc, itemrect, self._hasFocus)
                elif self._vistaselection:
                    self.DrawVistaRectangle(dc, itemrect, self._hasFocus)
                else:
                    if wx.Platform in ["__WXGTK2__", "__WXMAC__"]:
                        flags = wx.CONTROL_SELECTED
                        if self._hasFocus: flags = flags | wx.CONTROL_FOCUSED
                        wx.RendererNative.Get().DrawItemSelectionRect(self, dc, itemrect, flags) 
                    else:
                        dc.DrawRectangleRect(itemrect)
                            
            # On GTK+ 2, drawing a 'normal' background is wrong for themes that
            # don't allow backgrounds to be customized. Not drawing the background,
            # except for custom item backgrounds, works for both kinds of theme.
            elif drawItemBackground:

                minusicon = wcheck + image_w - 2
                itemrect = wx.Rect(item.GetX()+minusicon,
                                   item.GetY()+offset,
                                   item.GetWidth()-minusicon,
                                   total_h-offset)
                                
                if self._usegradients and self._hasFocus:
                    if self._gradientstyle == 0:   # Horizontal
                        self.DrawHorizontalGradient(dc, itemrect, self._hasFocus)
                    else:                          # Vertical
                        self.DrawVerticalGradient(dc, itemrect, self._hasFocus)
                else:
                    dc.DrawRectangleRect(itemrect)
                        
        if image != _NO_IMAGE:
        
            dc.SetClippingRegion(item.GetX(), item.GetY(), wcheck+image_w-2, total_h)
            if item.IsEnabled():
                imglist = self._imageListNormal
            else:
                imglist = self._grayedImageList

            imglist.Draw(image, dc,
                         item.GetX() + wcheck,
                         item.GetY() + ((total_h > image_h) and [(total_h-image_h)/2] or [0])[0],
                         wx.IMAGELIST_DRAW_TRANSPARENT)
            
            dc.DestroyClippingRegion()

        if wcheck:
            if item.IsEnabled():
                imglist = self._imageListCheck
            else:
                imglist = self._grayedCheckList
                
            imglist.Draw(checkimage, dc,
                         item.GetX(),
                         item.GetY() + ((total_h > hcheck) and [(total_h-hcheck)/2] or [0])[0],
                         wx.IMAGELIST_DRAW_TRANSPARENT)

        if leftimage != _NO_IMAGE:
            if item.IsEnabled():
                imglist = self._imageListLeft
            else:
                imglist = self._grayedImageListLeft

            imglist.Draw(leftimage, dc,
                         4,
                         item.GetY() + ((total_h > l_image_h) and [(total_h-l_image_h)/2] or [0])[0],
                         wx.IMAGELIST_DRAW_TRANSPARENT)

        dc.SetBackgroundMode(wx.TRANSPARENT)
        extraH = ((total_h > text_h) and [(total_h - text_h)/2] or [0])[0]

        textrect = wx.Rect(wcheck + image_w + item.GetX(), item.GetY() + extraH, text_w, text_h)
        
        if not item.IsEnabled():
            foreground = dc.GetTextForeground()
            dc.SetTextForeground(self._disabledColour)
            dc.DrawLabel(item.GetText(), textrect)
            dc.SetTextForeground(foreground)
        else:
            if wx.Platform == "__WXMAC__" and item.IsSelected() and self._hasFocus:
                dc.SetTextForeground(wx.WHITE)
            dc.DrawLabel(item.GetText(), textrect)

        wnd = item.GetWindow()
        if wnd:
            wndx = wcheck + image_w + item.GetX() + text_w + 4
            xa, ya = self.CalcScrolledPosition((0, item.GetY()))
            wndx += xa
            if item.GetHeight() > item.GetWindowSize()[1]:
                ya += (item.GetHeight() - item.GetWindowSize()[1])/2

            if align and level in self.absoluteWindows:
                wndx = self.absoluteWindows[level] + item.GetX() + 2
                
            if not wnd.IsShown():
                wnd.Show()
            if wnd.GetPosition() != (wndx, ya):
                wnd.SetPosition((wndx, ya))

        # restore normal font
        dc.SetFont(self._normalFont)
        

    # Now y stands for the top of the item, whereas it used to stand for middle !
    def PaintLevel(self, item, dc, level, y, align):
        """
        Paint a level in the hierarchy of L{CustomTreeCtrl}.

        :param `item`: an instance of L{GenericTreeItem};
        :param `dc`: an instance of `wx.DC`;
        :param `level`: the item level in the tree hierarchy;
        :param `y`: the current vertical position in the `wx.PyScrolledWindow`;
        :param `align`: ``True`` if we want to align windows (in items with windows)
         at the same horizontal position.
        """

        x = level*self._indent

        left_image_list = 0
        if self._imageListLeft:
            left_image_list += self._imageListLeft.GetBitmap(0).GetWidth()
            
        x += left_image_list
        
        if not self.HasAGWFlag(TR_HIDE_ROOT):
        
            x += self._indent
        
        elif level == 0:
        
            # always expand hidden root
            origY = y
            children = item.GetChildren()
            count = len(children)
            
            if count > 0:
                n = 0
                while n < count:
                    oldY = y
                    y = self.PaintLevel(children[n], dc, 1, y, align)
                    n = n + 1

                if not self.HasAGWFlag(TR_NO_LINES) and self.HasAGWFlag(TR_LINES_AT_ROOT) and count > 0:
                
                    # draw line down to last child
                    origY += self.GetLineHeight(children[0])>>1
                    oldY += self.GetLineHeight(children[n-1])>>1
                    oldPen = dc.GetPen()
                    dc.SetPen(self._dottedPen)
                    dc.DrawLine(3, origY, 3, oldY)
                    dc.SetPen(oldPen)
                
            return y
        
        item.SetX(x+self._spacing)
        item.SetY(y)

        h = self.GetLineHeight(item)
        y_top = y
        y_mid = y_top + (h>>1)
        y += h

        exposed_x = dc.LogicalToDeviceX(0)
        exposed_y = dc.LogicalToDeviceY(y_top)

        if self.IsExposed(exposed_x, exposed_y, 10000, h):  # 10000 = very much
            if wx.Platform == "__WXMAC__":
                # don't draw rect outline if we already have the
                # background colour under Mac
                pen = ((item.IsSelected() and self._hasFocus) and [self._borderPen] or [wx.TRANSPARENT_PEN])[0]
            else:
                pen = self._borderPen

            if item.IsSelected():
                if (wx.Platform == "__WXMAC__" and self._hasFocus):
                    colText = wx.SystemSettings_GetColour(wx.SYS_COLOUR_HIGHLIGHTTEXT)
                else:
                    colText = wx.SystemSettings_GetColour(wx.SYS_COLOUR_HIGHLIGHTTEXT)
            else:
                attr = item.GetAttributes()
                if attr and attr.HasTextColour():
                    colText = attr.GetTextColour()
                else:
                    colText = self.GetForegroundColour()

            if self._vistaselection:
                colText = wx.BLACK
            
            # prepare to draw
            dc.SetTextForeground(colText)
            dc.SetPen(pen)
            oldpen = pen

            # draw
            self.PaintItem(item, dc, level, align)

            if self.HasAGWFlag(TR_ROW_LINES):
            
                # if the background colour is white, choose a
                # contrasting colour for the lines
                medium_grey = wx.Pen(wx.Colour(200, 200, 200))
                dc.SetPen(((self.GetBackgroundColour() == wx.WHITE) and [medium_grey] or [wx.WHITE_PEN])[0])
                dc.DrawLine(0, y_top, 10000, y_top)
                dc.DrawLine(0, y, 10000, y)
            
            # restore DC objects
            dc.SetBrush(wx.WHITE_BRUSH)
            dc.SetTextForeground(wx.BLACK)

            if not self.HasAGWFlag(TR_NO_LINES):
            
                # draw the horizontal line here
                dc.SetPen(self._dottedPen)
                x_start = x
                if x > self._indent+left_image_list:
                    x_start -= self._indent
                elif self.HasAGWFlag(TR_LINES_AT_ROOT):
                    x_start = 3
                dc.DrawLine(x_start, y_mid, x + self._spacing, y_mid)
                dc.SetPen(oldpen)            

            # should the item show a button?
            if item.HasPlus() and self.HasButtons():
            
                if self._imageListButtons:
                
                    # draw the image button here
                    image_h = 0
                    image_w = 0
                    image = (item.IsExpanded() and [TreeItemIcon_Expanded] or [TreeItemIcon_Normal])[0]
                    if item.IsSelected():
                        image += TreeItemIcon_Selected - TreeItemIcon_Normal

                    image_w, image_h = self._imageListButtons.GetSize(image)
                    xx = x - image_w/2
                    yy = y_mid - image_h/2

                    dc.SetClippingRegion(xx, yy, image_w, image_h)
                    self._imageListButtons.Draw(image, dc, xx, yy,
                                                wx.IMAGELIST_DRAW_TRANSPARENT)
                    dc.DestroyClippingRegion()
                    
                else: # no custom buttons

                    if self.HasAGWFlag(TR_TWIST_BUTTONS):
                        # We draw something like the Mac twist buttons
                        
                        dc.SetPen(wx.BLACK_PEN)
                        dc.SetBrush(self._hilightBrush)
                        button = [wx.Point(), wx.Point(), wx.Point()]
                        
                        if item.IsExpanded():
                            button[0].x = x - 5
                            button[0].y = y_mid - 3
                            button[1].x = x + 5
                            button[1].y = button[0].y
                            button[2].x = x
                            button[2].y = button[0].y + 6
                        else:
                            button[0].x = x - 3
                            button[0].y = y_mid - 5
                            button[1].x = button[0].x
                            button[1].y = y_mid + 5
                            button[2].x = button[0].x + 5
                            button[2].y = y_mid
                        
                        dc.DrawPolygon(button)

                    else:
                        # These are the standard wx.TreeCtrl buttons as wx.RendererNative knows
                        
                        wImage = 9
                        hImage = 9

                        flag = 0

                        if item.IsExpanded():
                            flag |= _CONTROL_EXPANDED
                        if item == self._underMouse:
                            flag |= _CONTROL_CURRENT

                        self._drawingfunction(self, dc, wx.Rect(x - wImage/2, y_mid - hImage/2,wImage, hImage), flag)
                
        if item.IsExpanded():
        
            children = item.GetChildren()
            count = len(children)
            
            if count > 0:
            
                n = 0
                level = level + 1

                while n < count:
                    oldY = y
                    y = self.PaintLevel(children[n], dc, level, y, align)
                    n = n + 1
                    
                if not self.HasAGWFlag(TR_NO_LINES) and count > 0:
                
                    # draw line down to last child
                    oldY += self.GetLineHeight(children[n-1])>>1
                    if self.HasButtons():
                        y_mid += 5

                    # Only draw the portion of the line that is visible, in case it is huge
                    xOrigin, yOrigin = dc.GetDeviceOrigin()
                    yOrigin = abs(yOrigin)
                    width, height = self.GetClientSize()

                    # Move end points to the begining/end of the view?
                    if y_mid < yOrigin:
                        y_mid = yOrigin
                    if oldY > yOrigin + height:
                        oldY = yOrigin + height

                    # after the adjustments if y_mid is larger than oldY then the line
                    # isn't visible at all so don't draw anything
                    if y_mid < oldY:
                        dc.SetPen(self._dottedPen)
                        dc.DrawLine(x, y_mid, x, oldY)
                
        return y


# -----------------------------------------------------------------------------
# wxWidgets callbacks
# -----------------------------------------------------------------------------

    def OnPaint(self, event):
        """
        Handles the ``wx.EVT_PAINT`` event for L{CustomTreeCtrl}.

        :param `event`: a `wx.PaintEvent` event to be processed.
        """

        dc = wx.PaintDC(self)
        self.PrepareDC(dc)

        if not self._anchor:
            return

        dc.SetFont(self._normalFont)
        dc.SetPen(self._dottedPen)

        align = self.HasAGWFlag(TR_ALIGN_WINDOWS)            
        y = 2
        self.PaintLevel(self._anchor, dc, 0, y, align)


    def OnSize(self, event):
        """
        Handles the ``wx.EVT_SIZE`` event for L{CustomTreeCtrl}.

        :param `event`: a `wx.SizeEvent` event to be processed.
        """

        self.RefreshSelected()
        event.Skip()
        

    def OnEraseBackground(self, event):
        """
        Handles the ``wx.EVT_ERASE_BACKGROUND`` event for L{CustomTreeCtrl}.

        :param `event`: a `wx.EraseEvent` event to be processed.
        """

        # Can we actually do something here (or in OnPaint()) To Handle
        # background images that are stretchable or always centered?
        # I tried but I get enormous flickering...
        
        if not self._backgroundImage:
            event.Skip()
            return

        if self._imageStretchStyle == _StyleTile:
            dc = event.GetDC()

            if not dc:
                dc = wx.ClientDC(self)
                rect = self.GetUpdateRegion().GetBox()
                dc.SetClippingRect(rect)

            self.TileBackground(dc)


    def TileBackground(self, dc):
        """
        Tiles the background image to fill all the available area.

        :param `dc`: an instance of `wx.DC`.

        :todo: Support background images also in stretch and centered modes.        
        """

        sz = self.GetClientSize()
        w = self._backgroundImage.GetWidth()
        h = self._backgroundImage.GetHeight()

        x = 0

        while x < sz.width:
            y = 0

            while y < sz.height:
                dc.DrawBitmap(self._backgroundImage, x, y, True)
                y = y + h

            x = x + w        
        

    def OnSetFocus(self, event):
        """
        Handles the ``wx.EVT_SET_FOCUS`` event for L{CustomTreeCtrl}.

        :param `event`: a `wx.FocusEvent` event to be processed.
        """

        self._hasFocus = True
        self.RefreshSelected()
        event.Skip()


    def OnKillFocus(self, event):
        """
        Handles the ``wx.EVT_KILL_FOCUS`` event for L{CustomTreeCtrl}.

        :param `event`: a `wx.FocusEvent` event to be processed.
        """

        self._hasFocus = False
        self.RefreshSelected()
        event.Skip()


    def OnKeyDown(self, event):
        """
        Handles the ``wx.EVT_KEY_DOWN`` event for L{CustomTreeCtrl}, sending a
        ``EVT_TREE_KEY_DOWN`` event.

        :param `event`: a `wx.KeyEvent` event to be processed.
        """

        te = TreeEvent(wxEVT_TREE_KEY_DOWN, self.GetId())
        te._evtKey = event
        te.SetEventObject(self)
        
        if self.GetEventHandler().ProcessEvent(te):
            # intercepted by the user code
            return

        if self._current is None or self._key_current is None:
        
            event.Skip()
            return
        
        # how should the selection work for this event?
        is_multiple, extended_select, unselect_others = EventFlagsToSelType(self.GetAGWWindowStyleFlag(),
                                                                            event.ShiftDown(), event.CmdDown())

        # + : Expand
        # - : Collaspe
        # * : Expand all/Collapse all
        # ' ' | return : activate
        # up    : go up (not last children!)
        # down  : go down
        # left  : go to parent
        # right : open if parent and go next
        # home  : go to root
        # end   : go to last item without opening parents
        # alnum : start or continue searching for the item with this prefix
        
        keyCode = event.GetKeyCode()

        if keyCode in [ord("+"), wx.WXK_ADD]:       # "+"
            if self._current.HasPlus() and not self.IsExpanded(self._current) and self.IsItemEnabled(self._current):
                self.Expand(self._current)
                
        elif keyCode in [ord("*"), wx.WXK_MULTIPLY]:  # "*"
            if not self.IsExpanded(self._current) and self.IsItemEnabled(self._current):
                # expand all
                self.ExpandAll(self._current)

        elif keyCode in [ord("-"), wx.WXK_SUBTRACT]:  # "-"
            if self.IsExpanded(self._current):
                self.Collapse(self._current)
            
        elif keyCode == wx.WXK_MENU:
            # Use the item's bounding rectangle to determine position for the event
            itemRect = self.GetBoundingRect(self._current, True)
            event = TreeEvent(wxEVT_TREE_ITEM_MENU, self.GetId())
            event._item = self._current
            # Use the left edge, vertical middle
            event._pointDrag = wx.Point(itemRect.GetX(), itemRect.GetY() + itemRect.GetHeight()/2)
            event.SetEventObject(self)
            self.GetEventHandler().ProcessEvent(event)
                
        elif keyCode in [wx.WXK_RETURN, wx.WXK_SPACE, wx.WXK_NUMPAD_ENTER]:

            if not self.IsItemEnabled(self._current):
                event.Skip()
                return
            
            if not event.HasModifiers():
                event = TreeEvent(wxEVT_TREE_ITEM_ACTIVATED, self.GetId())
                event._item = self._current
                event.SetEventObject(self)
                self.GetEventHandler().ProcessEvent(event)

                if keyCode == wx.WXK_SPACE and self.GetItemType(self._current) > 0:
                    if self.IsItem3State(self._current):
                        checked = self.GetItem3StateValue(self._current)
                        checked = (checked+1)%3
                    else:
                        checked = not self.IsItemChecked(self._current)
                        
                    self.CheckItem(self._current, checked)
        
            # in any case, also generate the normal key event for this key,
            # even if we generated the ACTIVATED event above: this is what
            # wxMSW does and it makes sense because you might not want to
            # process ACTIVATED event at all and handle Space and Return
            # directly (and differently) which would be impossible otherwise
            event.Skip()

        # up goes to the previous sibling or to the last
        # of its children if it's expanded
        elif keyCode == wx.WXK_UP:
            prev = self.GetPrevSibling(self._key_current)
            if not prev:
                prev = self.GetItemParent(self._key_current)
                if prev == self.GetRootItem() and self.HasAGWFlag(TR_HIDE_ROOT):
                    return
                
                if prev:
                    current = self._key_current
                    # TODO: Huh?  If we get here, we'd better be the first child of our parent.  How else could it be?
                    if current == self.GetFirstChild(prev)[0] and self.IsItemEnabled(prev):
                        # otherwise we return to where we came from
                        self.DoSelectItem(prev, unselect_others, extended_select)
                        self._key_current = prev
                
            else:
                current = self._key_current
                
                # We are going to another parent node
                while self.IsExpanded(prev) and self.HasChildren(prev):
                    child = self.GetLastChild(prev)
                    if child:
                        prev = child
                        current = prev
                
                # Try to get the previous siblings and see if they are active
                while prev and not self.IsItemEnabled(prev):
                    prev = self.GetPrevSibling(prev)

                if not prev:
                    # No previous siblings active: go to the parent and up
                    prev = self.GetItemParent(current)
                    while prev and not self.IsItemEnabled(prev):
                        prev = self.GetItemParent(prev)
                        
                if prev:
                    self.DoSelectItem(prev, unselect_others, extended_select)
                    self._key_current = prev

        # left arrow goes to the parent
        elif keyCode == wx.WXK_LEFT:
            
            prev = self.GetItemParent(self._current)
            if prev == self.GetRootItem() and self.HasAGWFlag(TR_HIDE_ROOT):            
                # don't go to root if it is hidden
                prev = self.GetPrevSibling(self._current)

            if self.IsExpanded(self._current):
                self.Collapse(self._current)
            else:
                if prev and self.IsItemEnabled(prev):
                    self.DoSelectItem(prev, unselect_others, extended_select)
                
        elif keyCode == wx.WXK_RIGHT:
            # this works the same as the down arrow except that we
            # also expand the item if it wasn't expanded yet
            if self.IsExpanded(self._current) and self.HasChildren(self._current):
                child, cookie = self.GetFirstChild(self._key_current)
                if self.IsItemEnabled(child):
                    self.DoSelectItem(child, unselect_others, extended_select)
                    self._key_current = child
            else:
                self.Expand(self._current)
            # fall through

        elif keyCode == wx.WXK_DOWN:
            if self.IsExpanded(self._key_current) and self.HasChildren(self._key_current):

                child = self.GetNextActiveItem(self._key_current)
                
                if child:
                    self.DoSelectItem(child, unselect_others, extended_select)
                    self._key_current = child   
                
            else:
                
                next = self.GetNextSibling(self._key_current)
    
                if not next:
                    current = self._key_current
                    while current and not next:
                        current = self.GetItemParent(current)
                        if current:
                            next = self.GetNextSibling(current)
                            if not next or not self.IsItemEnabled(next):
                                next = None

                else:
                    while next and not self.IsItemEnabled(next):
                        next = self.GetNext(next)
                    
                if next:
                    self.DoSelectItem(next, unselect_others, extended_select)
                    self._key_current = next
                    

        # <End> selects the last visible tree item
        elif keyCode == wx.WXK_END:
            
            last = self.GetRootItem()

            while last and self.IsExpanded(last):
            
                lastChild = self.GetLastChild(last)

                # it may happen if the item was expanded but then all of
                # its children have been deleted - so IsExpanded() returned
                # true, but GetLastChild() returned invalid item
                if not lastChild:
                    break

                last = lastChild
            
            if last and self.IsItemEnabled(last):
            
                self.DoSelectItem(last, unselect_others, extended_select)
                
        # <Home> selects the root item
        elif keyCode == wx.WXK_HOME:
                
            prev = self.GetRootItem()
            
            if not prev:
                return

            if self.HasAGWFlag(TR_HIDE_ROOT):
                prev, cookie = self.GetFirstChild(prev)
                if not prev:
                    return

            if self.IsItemEnabled(prev):
                self.DoSelectItem(prev, unselect_others, extended_select)
        
        else:
            
            if not event.HasModifiers() and ((keyCode >= ord('0') and keyCode <= ord('9')) or \
                                             (keyCode >= ord('a') and keyCode <= ord('z')) or \
                                             (keyCode >= ord('A') and keyCode <= ord('Z'))):
            
                # find the next item starting with the given prefix
                ch = chr(keyCode)
                id = self.FindItem(self._current, self._findPrefix + ch)
                
                if not id:
                    # no such item
                    return

                if self.IsItemEnabled(id):                
                    self.SelectItem(id)
                self._findPrefix += ch

                # also start the timer to reset the current prefix if the user
                # doesn't press any more alnum keys soon -- we wouldn't want
                # to use this prefix for a new item search
                if not self._findTimer:
                    self._findTimer = TreeFindTimer(self)
                
                self._findTimer.Start(_DELAY, wx.TIMER_ONE_SHOT)
            
            else:
            
                event.Skip()


    def GetNextActiveItem(self, item, down=True):
        """
        Returns the next active item. Used Internally at present.

        :param `item`: an instance of L{GenericTreeItem};
        :param `down`: ``True`` to search downwards in the hierarchy for an active item,
         ``False`` to search upwards.
        """
        
        if down:
            sibling = self.GetNextSibling
        else:
            sibling = self.GetPrevSibling
                
        if self.GetItemType(item) == 2 and not self.IsItemChecked(item):
            # Is an unchecked radiobutton... all its children are inactive
            # try to get the next/previous sibling
            found = 0                 

            while 1:
                child = sibling(item)
                if (child and self.IsItemEnabled(child)) or not child:
                    break
                item = child

        else:
            # Tha's not a radiobutton... but some of its children can be
            # inactive
            child, cookie = self.GetFirstChild(item)
            while child and not self.IsItemEnabled(child):
                child, cookie = self.GetNextChild(item, cookie)
                
        if child and self.IsItemEnabled(child):
            return child
            
        return None
    

    def HitTest(self, point, flags=0):
        """
        Calculates which (if any) item is under the given point, returning the tree item
        at this point plus extra information flags.

        :param `point`: an instance of `wx.Point`, a point to test for hits;
        :param `flags`: a bitlist of the following values:

         ================================== =============== =================================
         HitTest Flags                      Hex Value       Description
         ================================== =============== =================================
         ``TREE_HITTEST_ABOVE``                         0x1 Above the client area
         ``TREE_HITTEST_BELOW``                         0x2 Below the client area
         ``TREE_HITTEST_NOWHERE``                       0x4 No item has been hit
         ``TREE_HITTEST_ONITEMBUTTON``                  0x8 On the button associated to an item
         ``TREE_HITTEST_ONITEMICON``                   0x10 On the icon associated to an item
         ``TREE_HITTEST_ONITEMINDENT``                 0x20 On the indent associated to an item
         ``TREE_HITTEST_ONITEMLABEL``                  0x40 On the label (string) associated to an item
         ``TREE_HITTEST_ONITEM``                       0x50 Anywhere on the item
         ``TREE_HITTEST_ONITEMRIGHT``                  0x80 On the right of the label associated to an item
         ``TREE_HITTEST_TOLEFT``                      0x200 On the left of the client area
         ``TREE_HITTEST_TORIGHT``                     0x400 On the right of the client area
         ``TREE_HITTEST_ONITEMUPPERPART``             0x800 On the upper part (first half) of the item
         ``TREE_HITTEST_ONITEMLOWERPART``            0x1000 On the lower part (second half) of the item
         ``TREE_HITTEST_ONITEMCHECKICON``            0x2000 On the check/radio icon, if present
         ================================== =============== =================================

        :note: both the item (if any, ``None`` otherwise) and the `flags` are always returned as a tuple.
        """
        
        w, h = self.GetSize()
        flags = 0
        
        if point.x < 0:
            flags |= TREE_HITTEST_TOLEFT
        if point.x > w:
            flags |= TREE_HITTEST_TORIGHT
        if point.y < 0:
            flags |= TREE_HITTEST_ABOVE
        if point.y > h:
            flags |= TREE_HITTEST_BELOW

        if flags:
            return None, flags
 
        if self._anchor == None:
            flags = TREE_HITTEST_NOWHERE
            return None, flags
        
        hit, flags = self._anchor.HitTest(self.CalcUnscrolledPosition(point), self, flags, 0)

        if hit == None:        
            flags = TREE_HITTEST_NOWHERE
            return None, flags

        if not self.IsItemEnabled(hit):
            return None, flags

        return hit, flags


    def GetBoundingRect(self, item, textOnly=False):
        """
        Retrieves the rectangle bounding the item.

        :param `item`: an instance of L{GenericTreeItem};
        :param `textOnly`: if ``True``, only the rectangle around the item's label will
         be returned, otherwise the item's image is also taken into account.

        :note: The rectangle coordinates are logical, not physical ones. So, for example,
         the x coordinate may be negative if the tree has a horizontal scrollbar and its
         position is not 0.
        """
    
        i = item

        startX, startY = self.GetViewStart()
        rect = wx.Rect()

        rect.x = i.GetX() - startX*_PIXELS_PER_UNIT
        rect.y = i.GetY() - startY*_PIXELS_PER_UNIT
        rect.width = i.GetWidth()
        rect.height = self.GetLineHeight(i)

        return rect


    def Edit(self, item):
        """
        Internal function. Starts the editing of an item label, sending a
        ``EVT_TREE_BEGIN_LABEL_EDIT`` event.

        :param `item`: an instance of L{GenericTreeItem}.        
        """

        te = TreeEvent(wxEVT_TREE_BEGIN_LABEL_EDIT, self.GetId())
        te._item = item
        te.SetEventObject(self)
        if self.GetEventHandler().ProcessEvent(te) and not te.IsAllowed():
            # vetoed by user
            return
    
        # We have to call this here because the label in
        # question might just have been added and no screen
        # update taken place.
        if self._dirty:
            if wx.Platform in ["__WXMSW__", "__WXMAC__"]:
                self.Update()
            else:
                wx.YieldIfNeeded()

        if self._textCtrl != None and item != self._textCtrl.item():
            self._textCtrl.StopEditing()

        self._textCtrl = TreeTextCtrl(self, item=item)
        self._textCtrl.SetFocus()

 
    def GetEditControl(self):
        """
        Returns a pointer to the edit L{TreeTextCtrl} if the item is being edited or
        ``None`` otherwise (it is assumed that no more than one item may be edited
        simultaneously).
        """
        
        return self._textCtrl


    def OnRenameAccept(self, item, value):
        """
        Called by L{TreeTextCtrl}, to accept the changes and to send the
        ``EVT_TREE_END_LABEL_EDIT`` event.

        :param `item`: an instance of L{GenericTreeItem};
        :param `value`: the new value of the item label.        
        """

        le = TreeEvent(wxEVT_TREE_END_LABEL_EDIT, self.GetId())
        le._item = item
        le.SetEventObject(self)
        le._label = value
        le._editCancelled = False

        return not self.GetEventHandler().ProcessEvent(le) or le.IsAllowed()
    

    def OnRenameCancelled(self, item):
        """
        Called by L{TreeTextCtrl}, to cancel the changes and to send the
        ``EVT_TREE_END_LABEL_EDIT`` event.

        :param `item`: an instance of L{GenericTreeItem}.        
        """

        # let owner know that the edit was cancelled
        le = TreeEvent(wxEVT_TREE_END_LABEL_EDIT, self.GetId())
        le._item = item
        le.SetEventObject(self)
        le._label = ""
        le._editCancelled = True

        self.GetEventHandler().ProcessEvent(le)


    def OnRenameTimer(self):
        """ The timer for renaming has expired. Start editing. """
        
        self.Edit(self._current)


    def OnMouse(self, event):
        """
        Handles a bunch of ``wx.EVT_MOUSE_EVENTS`` events for L{CustomTreeCtrl}.

        :param `event`: a `wx.MouseEvent` event to be processed.
        """

        if not self._anchor:
            return

        pt = self.CalcUnscrolledPosition(event.GetPosition())

        # Is the mouse over a tree item button?
        flags = 0
        thisItem, flags = self._anchor.HitTest(pt, self, flags, 0)
        underMouse = thisItem
        underMouseChanged = underMouse != self._underMouse

        if underMouse and (flags & TREE_HITTEST_ONITEM) and not event.LeftIsDown() and \
           not self._isDragging and (not self._renameTimer or not self._renameTimer.IsRunning()):
            underMouse = underMouse
        else:
            underMouse = None

        if underMouse != self._underMouse:
            if self._underMouse:
                # unhighlight old item
                self._underMouse = None
             
            self._underMouse = underMouse

        # Determines what item we are hovering over and need a tooltip for
        hoverItem = thisItem

        # We do not want a tooltip if we are dragging, or if the rename timer is running
        if underMouseChanged and not self._isDragging and (not self._renameTimer or not self._renameTimer.IsRunning()):
            
            if hoverItem is not None:
                # Ask the tree control what tooltip (if any) should be shown
                hevent = TreeEvent(wxEVT_TREE_ITEM_GETTOOLTIP, self.GetId())
                hevent._item = hoverItem
                hevent.SetEventObject(self)

                if self.GetEventHandler().ProcessEvent(hevent) and hevent.IsAllowed():
                    self.SetToolTip(hevent._label)

                if hoverItem.IsHyperText() and (flags & TREE_HITTEST_ONITEMLABEL) and hoverItem.IsEnabled():
                    self.SetCursor(wx.StockCursor(wx.CURSOR_HAND))
                    self._isonhyperlink = True
                else:
                    if self._isonhyperlink:
                        self.SetCursor(wx.StockCursor(wx.CURSOR_ARROW))
                        self._isonhyperlink = False
                
        # we process left mouse up event (enables in-place edit), right down
        # (pass to the user code), left dbl click (activate item) and
        # dragging/moving events for items drag-and-drop

        if not (event.LeftDown() or event.LeftUp() or event.RightDown() or event.LeftDClick() or \
                event.Dragging() or ((event.Moving() or event.RightUp()) and self._isDragging)):
        
            event.Skip()
            return
                    
        flags = 0
        item, flags = self._anchor.HitTest(pt, self, flags, 0)

        if event.Dragging() and not self._isDragging and ((flags & TREE_HITTEST_ONITEMICON) or (flags & TREE_HITTEST_ONITEMLABEL)):
        
            if self._dragCount == 0:
                self._dragStart = pt

            self._countDrag = 0
            self._dragCount = self._dragCount + 1

            if self._dragCount != 3:
                # wait until user drags a bit further...
                return
            
            command = (event.RightIsDown() and [wxEVT_TREE_BEGIN_RDRAG] or [wxEVT_TREE_BEGIN_DRAG])[0]

            nevent = TreeEvent(command, self.GetId())
            nevent._item = self._current
            nevent.SetEventObject(self)
            newpt = self.CalcScrolledPosition(pt)
            nevent.SetPoint(newpt)

            # by default the dragging is not supported, the user code must
            # explicitly allow the event for it to take place
            nevent.Veto()

            if self.GetEventHandler().ProcessEvent(nevent) and nevent.IsAllowed():
                
                # we're going to drag this item
                self._isDragging = True

                # remember the old cursor because we will change it while
                # dragging
                self._oldCursor = self._cursor

                # in a single selection control, hide the selection temporarily
                if not (self.GetAGWWindowStyleFlag() & TR_MULTIPLE):
                    self._oldSelection = self.GetSelection()

                    if self._oldSelection:
                    
                        self._oldSelection.SetHilight(False)
                        self.RefreshLine(self._oldSelection)
                else:
                    selections = self.GetSelections()
                    if len(selections) == 1:
                        self._oldSelection = selections[0]
                        self._oldSelection.SetHilight(False)
                        self.RefreshLine(self._oldSelection)

                if self._dragImage:
                    del self._dragImage

                # Create the custom draw image from the icons and the text of the item                    
                self._dragImage = DragImage(self, self._current)
                self._dragImage.BeginDrag(wx.Point(0,0), self)
                self._dragImage.Show()
                self._dragImage.Move(self.CalcScrolledPosition(pt))
            
        elif event.Dragging() and self._isDragging:

            self._dragImage.Move(self.CalcScrolledPosition(pt))

            if self._countDrag == 0 and item:
                self._oldItem = item

            if item != self._dropTarget:
                    
                # unhighlight the previous drop target
                if self._dropTarget:
                    self._dropTarget.SetHilight(False)
                    self.RefreshLine(self._dropTarget)
                if item:
                    item.SetHilight(True)
                    self.RefreshLine(item)
                    self._countDrag = self._countDrag + 1
                self._dropTarget = item

                self.Update()

            if self._countDrag >= 3:
                # Here I am trying to avoid ugly repainting problems... hope it works
                self.RefreshLine(self._oldItem)
                self._countDrag = 0

        elif (event.LeftUp() or event.RightUp()) and self._isDragging:

            if self._dragImage:
                self._dragImage.EndDrag()

            if self._dropTarget:
                self._dropTarget.SetHilight(False)
                
            if self._oldSelection:
            
                self._oldSelection.SetHilight(True)
                self.RefreshLine(self._oldSelection)
                self._oldSelection = None
            
            # generate the drag end event
            event = TreeEvent(wxEVT_TREE_END_DRAG, self.GetId())
            event._item = item
            event._pointDrag = self.CalcScrolledPosition(pt)
            event.SetEventObject(self)

            self.GetEventHandler().ProcessEvent(event)

            self._isDragging = False
            self._dropTarget = None
            
            self.SetCursor(self._oldCursor)

            if wx.Platform in ["__WXMSW__", "__WXMAC__"]:
                self.Refresh()
            else:
                # Probably this is not enough on GTK. Try a Refresh() if it does not work.
                wx.YieldIfNeeded()
        
        else:

            # If we got to this point, we are not dragging or moving the mouse.
            # Because the code in carbon/toplevel.cpp will only set focus to the tree
            # if we skip for EVT_LEFT_DOWN, we MUST skip this event here for focus to work.
            # We skip even if we didn't hit an item because we still should
            # restore focus to the tree control even if we didn't exactly hit an item.
            if event.LeftDown():
                self._hasFocus = True
                self.SetFocusIgnoringChildren()
                event.Skip()
            
            # here we process only the messages which happen on tree items

            self._dragCount = 0

            if item == None:
                if self._textCtrl != None and item != self._textCtrl.item():
                    self._textCtrl.StopEditing()
                return  # we hit the blank area

            if event.RightDown():
                
                if self._textCtrl != None and item != self._textCtrl.item():
                    self._textCtrl.StopEditing()

                self._hasFocus = True
                self.SetFocusIgnoringChildren()
                    
                # If the item is already selected, do not update the selection.
                # Multi-selections should not be cleared if a selected item is clicked.
                if not self.IsSelected(item):
                
                    self.DoSelectItem(item, True, False)

                nevent = TreeEvent(wxEVT_TREE_ITEM_RIGHT_CLICK, self.GetId())
                nevent._item = item
                nevent._pointDrag = self.CalcScrolledPosition(pt)
                nevent.SetEventObject(self)
                event.Skip(not self.GetEventHandler().ProcessEvent(nevent))

                # Consistent with MSW (for now), send the ITEM_MENU *after*
                # the RIGHT_CLICK event. TODO: This behaviour may change.
                nevent2 = TreeEvent(wxEVT_TREE_ITEM_MENU, self.GetId())
                nevent2._item = item
                nevent2._pointDrag = self.CalcScrolledPosition(pt)
                nevent2.SetEventObject(self)
                self.GetEventHandler().ProcessEvent(nevent2)
            
            elif event.LeftUp():
            
                # this facilitates multiple-item drag-and-drop

                if self.HasAGWFlag(TR_MULTIPLE):
                
                    selections = self.GetSelections()

                    if len(selections) > 1 and not event.CmdDown() and not event.ShiftDown():
                    
                        self.DoSelectItem(item, True, False)
                    
                if self._lastOnSame:
                
                    if item == self._current and (flags & TREE_HITTEST_ONITEMLABEL) and self.HasAGWFlag(TR_EDIT_LABELS):
                    
                        if self._renameTimer:
                        
                            if self._renameTimer.IsRunning():
                                
                                self._renameTimer.Stop()
                        
                        else:
                        
                            self._renameTimer = TreeRenameTimer(self)
                        
                        self._renameTimer.Start(_DELAY, True)
                    
                    self._lastOnSame = False
                
            
            else: # !RightDown() && !LeftUp() ==> LeftDown() || LeftDClick()

                if not item or not item.IsEnabled():
                    if self._textCtrl != None and item != self._textCtrl.item():
                        self._textCtrl.StopEditing()
                    return

                if self._textCtrl != None and item != self._textCtrl.item():
                    self._textCtrl.StopEditing()

                self._hasFocus = True
                self.SetFocusIgnoringChildren()
                
                if event.LeftDown():
                
                    self._lastOnSame = item == self._current
                    
                if flags & TREE_HITTEST_ONITEMBUTTON:
                
                    # only toggle the item for a single click, double click on
                    # the button doesn't do anything (it toggles the item twice)
                    if event.LeftDown():
                    
                        self.Toggle(item)
                    
                    # don't select the item if the button was clicked
                    return

                if item.GetType() > 0 and (flags & TREE_HITTEST_ONITEMCHECKICON):

                    if event.LeftDown():
                        if flags & TREE_HITTEST_ONITEM and self.HasAGWFlag(TR_FULL_ROW_HIGHLIGHT):
                            self.DoSelectItem(item, not self.HasAGWFlag(TR_MULTIPLE))

                        if self.IsItem3State(item):
                            checked = self.GetItem3StateValue(item)
                            checked = (checked+1)%3
                        else:
                            checked = not self.IsItemChecked(item)
                            
                        self.CheckItem(item, checked)
                        
                    return                                            

                # clear the previously selected items, if the
                # user clicked outside of the present selection.
                # otherwise, perform the deselection on mouse-up.
                # this allows multiple drag and drop to work.
                # but if Cmd is down, toggle selection of the clicked item
                if not self.IsSelected(item) or event.CmdDown():

                    if flags & TREE_HITTEST_ONITEM:
                        # how should the selection work for this event?
                        if item.IsHyperText():
                            self.SetItemVisited(item, True)
                        
                        is_multiple, extended_select, unselect_others = EventFlagsToSelType(self.GetAGWWindowStyleFlag(),
                                                                                            event.ShiftDown(),
                                                                                            event.CmdDown())

                        self.DoSelectItem(item, unselect_others, extended_select)

                # Handle hyperlink items... which are a bit odd sometimes
                elif self.IsSelected(item) and item.IsHyperText():
                    self.HandleHyperLink(item)
                    
                # For some reason, Windows isn't recognizing a left double-click,
                # so we need to simulate it here.  Allow 200 milliseconds for now.
                if event.LeftDClick():
                
                    # double clicking should not start editing the item label
                    if self._renameTimer:
                        self._renameTimer.Stop()

                    self._lastOnSame = False

                    # send activate event first
                    nevent = TreeEvent(wxEVT_TREE_ITEM_ACTIVATED, self.GetId())
                    nevent._item = item
                    nevent._pointDrag = self.CalcScrolledPosition(pt)
                    nevent.SetEventObject(self)
                    if not self.GetEventHandler().ProcessEvent(nevent):
                    
                        # if the user code didn't process the activate event,
                        # handle it ourselves by toggling the item when it is
                        # double clicked
##                        if item.HasPlus():
                        self.Toggle(item)
                        

    def OnInternalIdle(self):
        """
        This method is normally only used internally, but sometimes an application
        may need it to implement functionality that should not be disabled by an
        application defining an `OnIdle` handler in a derived class.

        This method may be used to do delayed painting, for example, and most
        implementations call `wx.Window.UpdateWindowUI` in order to send update events
        to the window in idle time.
        """

        # Check if we need to select the root item
        # because nothing else has been selected.
        # Delaying it means that we can invoke event handlers
        # as required, when a first item is selected.
        if not self.HasAGWFlag(TR_MULTIPLE) and not self.GetSelection():
        
            if self._select_me:
                self.SelectItem(self._select_me)
            elif self.GetRootItem():
                self.SelectItem(self.GetRootItem())
        
        # after all changes have been done to the tree control,
        # we actually redraw the tree when everything is over

        if not self._dirty:
            return
        if self._freezeCount:
            return

        self._dirty = False

        self.CalculatePositions()
        self.Refresh()
        self.AdjustMyScrollbars()

#        event.Skip()        


    def CalculateSize(self, item, dc, level=-1, align=False):
        """
        Calculates overall position and size of an item.

        :param `item`: an instance of L{GenericTreeItem};
        :param `dc`: an instance of `wx.DC`;
        :param `level`: the item level in the tree hierarchy;
        :param `align`: ``True`` if we want to align windows (in items with windows)
         at the same horizontal position.
        """

        attr = item.GetAttributes()

        if attr and attr.HasFont():
            dc.SetFont(attr.GetFont())
        else:
            if item.IsBold():
                dc.SetFont(self._boldFont)
            elif item.IsItalic():
                dc.SetFont(self._italicFont)
            else:
                dc.SetFont(self._normalFont)

        text_w, text_h, dummy = dc.GetMultiLineTextExtent(item.GetText())
        text_h+=2

        # restore normal font
        dc.SetFont(self._normalFont)

        image_w, image_h = 0, 0
        image = item.GetCurrentImage()

        if image != _NO_IMAGE:
        
            if self._imageListNormal:
            
                image_w, image_h = self._imageListNormal.GetSize(image)
                image_w += 4

        total_h = ((image_h > text_h) and [image_h] or [text_h])[0]

        checkimage = item.GetCurrentCheckedImage()
        if checkimage is not None:
            wcheck, hcheck = self._imageListCheck.GetSize(checkimage)
            wcheck += 4
        else:
            wcheck = 0           

        if total_h < 30:
            total_h += 2            # at least 2 pixels
        else:
            total_h += total_h/10   # otherwise 10% extra spacing

        if total_h > self._lineHeight:
            self._lineHeight = total_h

        wnd = item.GetWindow()
        if not wnd:
            totalWidth = image_w+text_w+wcheck+2
            totalHeight = total_h
        else:
            totalWidth = item.GetWindowSize()[0]+image_w+text_w+wcheck+2
            totalHeight = max(total_h, item.GetWindowSize()[1])

        if level >= 0 and wnd:
            if not align:
                if level in self.absoluteWindows:
                    self.absoluteWindows[level] = max(self.absoluteWindows[level], image_w+text_w+wcheck+2)
                else:
                    self.absoluteWindows[level] = image_w+text_w+wcheck+2
            else:
                self.absoluteWindows[level] = max(self.absoluteWindows[level], image_w+text_w+wcheck+2)
                                        
        item.SetWidth(totalWidth)
        item.SetHeight(totalHeight)


    def CalculateLevel(self, item, dc, level, y, align=False):
        """
        Calculates the level of an item inside the tree hierarchy.

        :param `item`: an instance of L{GenericTreeItem};
        :param `dc`: an instance of `wx.DC`;
        :param `level`: the item level in the tree hierarchy;
        :param `y`: the current vertical position inside the `wx.PyScrolledWindow`;
        :param `align`: ``True`` if we want to align windows (in items with windows)
         at the same horizontal position.
        """

        x = level*self._indent
        
        if not self.HasAGWFlag(TR_HIDE_ROOT):
        
            x += self._indent
        
        elif level == 0:
        
            # a hidden root is not evaluated, but its
            # children are always calculated
            children = item.GetChildren()
            count = len(children)
            level = level + 1
            for n in xrange(count):
                y = self.CalculateLevel(children[n], dc, level, y, align)  # recurse
                
            return y
        
        self.CalculateSize(item, dc, level, align)

        # set its position
        item.SetX(x+self._spacing)
        item.SetY(y)
        y += self.GetLineHeight(item)

        if not item.IsExpanded():
            # we don't need to calculate collapsed branches
            return y

        children = item.GetChildren()
        count = len(children)
        level = level + 1
        for n in xrange(count):
            y = self.CalculateLevel(children[n], dc, level, y, align)  # recurse
        
        return y
    

    def CalculatePositions(self):
        """ Calculates all the positions of the visible items. """

        if not self._anchor:
            return

        self.absoluteWindows = {}
        
        dc = wx.ClientDC(self)
        self.PrepareDC(dc)

        dc.SetFont(self._normalFont)
        dc.SetPen(self._dottedPen)
        y = 2
        y = self.CalculateLevel(self._anchor, dc, 0, y) # start recursion
        
        if self.HasAGWFlag(TR_ALIGN_WINDOWS):
            y = 2
            y = self.CalculateLevel(self._anchor, dc, 0, y, align=True) # start recursion


    def RefreshSubtree(self, item):
        """
        Refreshes a damaged subtree of an item.
        
        :param `item`: an instance of L{GenericTreeItem}.
        """

        if self._dirty:
            return
        if self._freezeCount:
            return

        client = self.GetClientSize()

        rect = wx.Rect()
        x, rect.y = self.CalcScrolledPosition(0, item.GetY())
        rect.width = client.x
        rect.height = client.y

        self.Refresh(True, rect)
        self.AdjustMyScrollbars()


    def RefreshLine(self, item):
        """
        Refreshes a damaged item line.

        :param `item`: an instance of L{GenericTreeItem}.
        """

        if self._dirty:
            return
        if self._freezeCount:
            return

        rect = wx.Rect()
        x, rect.y = self.CalcScrolledPosition(0, item.GetY())
        rect.width = self.GetClientSize().x
        rect.height = self.GetLineHeight(item)

        self.Refresh(True, rect)


    def RefreshSelected(self):
        """ Refreshes a damaged selected item line. """

        if self._freezeCount:
            return

        # TODO: this is awfully inefficient, we should keep the list of all
        #       selected items internally, should be much faster
        if self._anchor:
            self.RefreshSelectedUnder(self._anchor)


    def RefreshSelectedUnder(self, item):
        """
        Refreshes the selected items under the given item.

        :param `item`: an instance of L{GenericTreeItem}.
        """

        if self._freezeCount:
            return

        if item.IsSelected():
            self.RefreshLine(item)

        children = item.GetChildren()
        for child in children:
            self.RefreshSelectedUnder(child)
    

    def Freeze(self):
        """
        Freeze L{CustomTreeCtrl}.

        Freezes the window or, in other words, prevents any updates from taking place
        on screen, the window is not redrawn at all. L{Thaw} must be called to reenable
        window redrawing. Calls to these two functions may be nested.

        :note: This method is useful for visual appearance optimization (for example,
         it is a good idea to use it before doing many large text insertions in a row
         into a `wx.TextCtrl` under wxGTK) but is not implemented on all platforms nor
         for all controls so it is mostly just a hint to wxWidgets and not a mandatory
         directive.
        """

        self._freezeCount = self._freezeCount + 1


    def Thaw(self):
        """
        Thaw L{CustomTreeCtrl}.

        Reenables window updating after a previous call to L{Freeze}. To really thaw the
        control, it must be called exactly the same number of times as L{Freeze}.
        """

        if self._freezeCount == 0:
            raise Exception("\nERROR: Thawing Unfrozen Tree Control?")

        self._freezeCount = self._freezeCount - 1
        
        if not self._freezeCount:
            self.Refresh()
    

    # ----------------------------------------------------------------------------
    # changing colours: we need to refresh the tree control
    # ----------------------------------------------------------------------------

    def SetBackgroundColour(self, colour):
        """
        Changes the background colour of L{CustomTreeCtrl}.

        :param `colour`: the colour to be used as the background colour, pass
         `wx.NullColour` to reset to the default colour.

        :note: The background colour is usually painted by the default `wx.EraseEvent`
         event handler function under Windows and automatically under GTK.

        :note: Setting the background colour does not cause an immediate refresh, so
         you may wish to call `wx.Window.ClearBackground` or `wx.Window.Refresh` after
         calling this function.

        :note: Overridden from `wx.PyScrolledWindow`.         
        """

        if not wx.PyScrolledWindow.SetBackgroundColour(self, colour):
            return False

        if self._freezeCount:
            return True

        self.Refresh()

        return True


    def SetForegroundColour(self, colour):
        """
        Changes the foreground colour of L{CustomTreeCtrl}.

        :param `colour`: the colour to be used as the foreground colour, pass
         `wx.NullColour` to reset to the default colour.

        :note: Overridden from `wx.PyScrolledWindow`.         
        """

        if not wx.PyScrolledWindow.SetForegroundColour(self, colour):
            return False

        if self._freezeCount:
            return True

        self.Refresh()

        return True

    
    def OnGetToolTip(self, event):
        """
        Process the tooltip event, to speed up event processing. Does not actually
        get a tooltip.

        :param `event`: a L{TreeEvent} event to be processed.        
        """

        event.Veto()


    def DoGetBestSize(self):
        """
        Gets the size which best suits the window: for a control, it would be the
        minimal size which doesn't truncate the control, for a panel - the same size
        as it would have after a call to `Fit()`.
        """
        
        # something is better than nothing...
        # 100x80 is what the MSW version will get from the default
        # wxControl::DoGetBestSize

        return wx.Size(100, 80)

        
    def GetMaxWidth(self, respect_expansion_state=True):
        """
        Returns the maximum width of the L{CustomTreeCtrl}.
        
        :param `respect_expansion_state`: if ``True``, only the expanded items (and their
         children) will be measured. Otherwise all the items are expanded and
         their width measured.
        """

        self.Freeze()
        
        root = self.GetRootItem()
        rect = self.GetBoundingRect(root, True)

        # It looks like the space between the "+" and the node
        # rect occupies 4 pixels approximatively
        maxwidth = rect.x + rect.width + 4
        lastheight = rect.y + rect.height
        
        if not self.IsExpanded(root):
            if respect_expansion_state:
                return maxwidth

        if not respect_expansion_state:
            self.ExpandAll()

        maxwidth, lastheight = self.RecurseOnChildren(root, maxwidth, respect_expansion_state)

        self.Thaw()
        
        return maxwidth
    

    def RecurseOnChildren(self, item, maxwidth, respect_expansion_state):
        """
        Recurses over all the children of the spcified items, calculating their
        maximum width.

        :param `item`: an instance of L{GenericTreeItem};
        :param `maxwidth`: the current maximum width for L{CustomTreeCtrl};
        :param `respect_expansion_state`: if ``True``, only the expanded items (and their
         children) will be measured. Otherwise all the items are expanded and
         their width measured.
        """
        
        child, cookie = self.GetFirstChild(item)

        while child.IsOk():

            rect = self.GetBoundingRect(child, True)
            
            # It looks like the space between the "+" and the node
            # rect occupies 4 pixels approximatively
            maxwidth = max(maxwidth, rect.x + rect.width + 4)
            lastheight = rect.y + rect.height
            
            if self.IsExpanded(child) or not respect_expansion_state:
                maxwidth, lastheight = self.RecurseOnChildren(child, maxwidth, respect_expansion_state)
            
            child, cookie = self.GetNextChild(item, cookie)

        return maxwidth, lastheight

    
    def GetClassDefaultAttributes(self):
        """
        Returns the default font and colours which are used by the control. This is
        useful if you want to use the same font or colour in your own control as in
        a standard control -- which is a much better idea than hard coding specific
        colours or fonts which might look completely out of place on the users system,
        especially if it uses themes.

        This static method is "overridden'' in many derived classes and so calling,
        for example, `wx.Button.GetClassDefaultAttributes()` will typically return the
        values appropriate for a button which will be normally different from those
        returned by, say, `wx.ListCtrl.GetClassDefaultAttributes()`.

        :note: The `wx.VisualAttributes` structure has at least the fields `font`,
         `colFg` and `colBg`. All of them may be invalid if it was not possible to
         determine the default control appearance or, especially for the background
         colour, if the field doesn't make sense as is the case for `colBg` for the
         controls with themed background.

        :note: Overridden from `wx.PyControl`.         
        """

        attr = wx.VisualAttributes()
        attr.colFg = wx.SystemSettings_GetColour(wx.SYS_COLOUR_WINDOWTEXT)
        attr.colBg = wx.SystemSettings_GetColour(wx.SYS_COLOUR_LISTBOX)
        attr.font  = wx.SystemSettings_GetFont(wx.SYS_DEFAULT_GUI_FONT)
        return attr

    GetClassDefaultAttributes = classmethod(GetClassDefaultAttributes)

    

########NEW FILE########
__FILENAME__ = hypertreelist
# --------------------------------------------------------------------------------- #
# HYPERTREELIST wxPython IMPLEMENTATION
# Inspired By And Heavily Based On wx.gizmos.TreeListCtrl.
#
# Andrea Gavana, @ 08 May 2006
# Latest Revision: 28 Nov 2010, 16.00 GMT
#
#
# TODO List
#
# Almost All The Features Of wx.gizmos.TreeListCtrl Are Available, And There Is
# Practically No Limit In What Could Be Added To This Class. The First Things
# That Comes To My Mind Are:
#
# 1. Add Support For 3-State CheckBoxes (Is That Really Useful?).
#
# 2. Try To Implement A More Flicker-Free Background Image In Cases Like
#    Centered Or Stretched Image (Now HyperTreeList Supports Only Tiled
#    Background Images).
#
# 3. Try To Mimic Windows wx.TreeCtrl Expanding/Collapsing behaviour: HyperTreeList
#    Suddenly Expands/Collapses The Nodes On Mouse Click While The Native Control
#    Has Some Kind Of "Smooth" Expanding/Collapsing, Like A Wave. I Don't Even
#    Know Where To Start To Do That.
#
# 4. Speed Up General OnPaint Things? I Have No Idea, Here HyperTreeList Is Quite
#    Fast, But We Should See On Slower Machines.
#
#
# For All Kind Of Problems, Requests Of Enhancements And Bug Reports, Please
# Write To Me At:
#
# andrea.gavana@gmail.com
# gavana@kpo.kz
#
# Or, Obviously, To The wxPython Mailing List!!!
#
#
# End Of Comments
# --------------------------------------------------------------------------------- #


"""
HyperTreeList is a class that mimics the behaviour of `wx.gizmos.TreeListCtrl`, with
some more functionalities.


Description
===========

HyperTreeList is a class that mimics the behaviour of `wx.gizmos.TreeListCtrl`, with
almost the same base functionalities plus some more enhancements. This class does
not rely on the native control, as it is a full owner-drawn tree-list control.

HyperTreeList is somewhat an hybrid between L{CustomTreeCtrl} and `wx.gizmos.TreeListCtrl`.

In addition to the standard `wx.gizmos.TreeListCtrl` behaviour this class supports:

* CheckBox-type items: checkboxes are easy to handle, just selected or unselected
  state with no particular issues in handling the item's children;
* Added support for 3-state value checkbox items;
* RadioButton-type items: since I elected to put radiobuttons in CustomTreeCtrl, I
  needed some way to handle them, that made sense. So, I used the following approach:
  
  - All peer-nodes that are radiobuttons will be mutually exclusive. In other words,
    only one of a set of radiobuttons that share a common parent can be checked at
    once. If a radiobutton node becomes checked, then all of its peer radiobuttons
    must be unchecked.
  - If a radiobutton node becomes unchecked, then all of its child nodes will become
    inactive.

* Hyperlink-type items: they look like an hyperlink, with the proper mouse cursor on
  hovering;
* Multiline text items;
* Enabling/disabling items (together with their plain or grayed out icons);
* Whatever non-toplevel widget can be attached next to a tree item;
* Whatever non-toplevel widget can be attached next to a list item;
* Column headers are fully customizable in terms of icons, colour, font, alignment etc...;
* Default selection style, gradient (horizontal/vertical) selection style and Windows
  Vista selection style;
* Customized drag and drop images built on the fly;
* Setting the HyperTreeList item buttons to a personalized imagelist;
* Setting the HyperTreeList check/radio item icons to a personalized imagelist;
* Changing the style of the lines that connect the items (in terms of `wx.Pen` styles);
* Using an image as a HyperTreeList background (currently only in "tile" mode);

And a lot more. Check the demo for an almost complete review of the functionalities.


Base Functionalities
====================

HyperTreeList supports all the `wx.gizmos.TreeListCtrl` styles, except:

- ``TR_EXTENDED``: supports for this style is on the todo list (Am I sure of this?).

Plus it has 3 more styles to handle checkbox-type items:

- ``TR_AUTO_CHECK_CHILD``: automatically checks/unchecks the item children;
- ``TR_AUTO_CHECK_PARENT``: automatically checks/unchecks the item parent;
- ``TR_AUTO_TOGGLE_CHILD``: automatically toggles the item children.

And a style useful to hide the TreeListCtrl header:

- ``TR_NO_HEADER``: hides the HyperTreeList header.


All the methods available in `wx.gizmos.TreeListCtrl` are also available in HyperTreeList.


Events
======

All the events supported by `wx.gizmos.TreeListCtrl` are also available in HyperTreeList,
with a few exceptions:

- ``EVT_TREE_GET_INFO`` (don't know what this means);
- ``EVT_TREE_SET_INFO`` (don't know what this means);
- ``EVT_TREE_ITEM_MIDDLE_CLICK`` (not implemented, but easy to add);
- ``EVT_TREE_STATE_IMAGE_CLICK`` (no need for that, look at the checking events below).

Plus, HyperTreeList supports the events related to the checkbutton-type items:

- ``EVT_TREE_ITEM_CHECKING``: an item is being checked;
- ``EVT_TREE_ITEM_CHECKED``: an item has been checked.

And to hyperlink-type items:

- ``EVT_TREE_ITEM_HYPERLINK``: an hyperlink item has been clicked (this event is sent
  after the ``EVT_TREE_SEL_CHANGED`` event).


Supported Platforms
===================

HyperTreeList has been tested on the following platforms:
  * Windows (Windows XP);


Window Styles
=============

This class supports the following window styles:

============================== =========== ==================================================
Window Styles                  Hex Value   Description
============================== =========== ==================================================
``TR_NO_BUTTONS``                      0x0 For convenience to document that no buttons are to be drawn.
``TR_SINGLE``                          0x0 For convenience to document that only one item may be selected at a time. Selecting another item causes the current selection, if any, to be deselected. This is the default.
``TR_HAS_BUTTONS``                     0x1 Use this style to show + and - buttons to the left of parent items.
``TR_NO_LINES``                        0x4 Use this style to hide vertical level connectors.
``TR_LINES_AT_ROOT``                   0x8 Use this style to show lines between root nodes. Only applicable if ``TR_HIDE_ROOT`` is set and ``TR_NO_LINES`` is not set.
``TR_DEFAULT_STYLE``                   0x9 No Docs
``TR_TWIST_BUTTONS``                  0x10 Use old Mac-twist style buttons.
``TR_MULTIPLE``                       0x20 Use this style to allow a range of items to be selected. If a second range is selected, the current range, if any, is deselected.
``TR_EXTENDED``                       0x40 Use this style to allow disjoint items to be selected. (Only partially implemented; may not work in all cases).
``TR_HAS_VARIABLE_ROW_HEIGHT``        0x80 Use this style to cause row heights to be just big enough to fit the content. If not set, all rows use the largest row height. The default is that this flag is unset.
``TR_EDIT_LABELS``                   0x200 Use this style if you wish the user to be able to edit labels in the tree control.
``TR_ROW_LINES``                     0x400 Use this style to draw a contrasting border between displayed rows.
``TR_HIDE_ROOT``                     0x800 Use this style to suppress the display of the root node, effectively causing the first-level nodes to appear as a series of root nodes.
``TR_COLUMN_LINES``                 0x1000 No Docs
``TR_FULL_ROW_HIGHLIGHT``           0x2000 Use this style to have the background colour and the selection highlight extend  over the entire horizontal row of the tree control window.
``TR_AUTO_CHECK_CHILD``             0x4000 Only meaningful foe checkbox-type items: when a parent item is checked/unchecked its children are checked/unchecked as well.
``TR_AUTO_TOGGLE_CHILD``            0x8000 Only meaningful foe checkbox-type items: when a parent item is checked/unchecked its children are toggled accordingly.
``TR_AUTO_CHECK_PARENT``           0x10000 Only meaningful foe checkbox-type items: when a child item is checked/unchecked its parent item is checked/unchecked as well.
``TR_ALIGN_WINDOWS``               0x20000 Flag used to align windows (in items with windows) at the same horizontal position.
``TR_NO_HEADER``                   0x40000 Use this style to hide the columns header.
``TR_VIRTUAL``                     0x80000 `HyperTreeList` will have virtual behaviour.
============================== =========== ==================================================


Events Processing
=================

This class processes the following events:

============================== ==================================================
Event Name                     Description
============================== ==================================================
``EVT_LIST_COL_BEGIN_DRAG``    The user started resizing a column - can be vetoed.
``EVT_LIST_COL_CLICK``         A column has been left-clicked.
``EVT_LIST_COL_DRAGGING``      The divider between columns is being dragged.
``EVT_LIST_COL_END_DRAG``      A column has been resized by the user.
``EVT_LIST_COL_RIGHT_CLICK``   A column has been right-clicked.
``EVT_TREE_BEGIN_DRAG``        Begin dragging with the left mouse button.
``EVT_TREE_BEGIN_LABEL_EDIT``  Begin editing a label. This can be prevented by calling `Veto()`.
``EVT_TREE_BEGIN_RDRAG``       Begin dragging with the right mouse button.
``EVT_TREE_DELETE_ITEM``       Delete an item.
``EVT_TREE_END_DRAG``          End dragging with the left or right mouse button.
``EVT_TREE_END_LABEL_EDIT``    End editing a label. This can be prevented by calling `Veto()`.
``EVT_TREE_GET_INFO``          Request information from the application (not implemented in `CustomTreeCtrl`).
``EVT_TREE_ITEM_ACTIVATED``    The item has been activated, i.e. chosen by double clicking it with mouse or from keyboard.
``EVT_TREE_ITEM_CHECKED``      A checkbox or radiobox type item has been checked.
``EVT_TREE_ITEM_CHECKING``     A checkbox or radiobox type item is being checked.
``EVT_TREE_ITEM_COLLAPSED``    The item has been collapsed.
``EVT_TREE_ITEM_COLLAPSING``   The item is being collapsed. This can be prevented by calling `Veto()`.
``EVT_TREE_ITEM_EXPANDED``     The item has been expanded.
``EVT_TREE_ITEM_EXPANDING``    The item is being expanded. This can be prevented by calling `Veto()`.
``EVT_TREE_ITEM_GETTOOLTIP``   The opportunity to set the item tooltip is being given to the application (call `TreeEvent.SetToolTip`).
``EVT_TREE_ITEM_HYPERLINK``    An hyperlink type item has been clicked.
``EVT_TREE_ITEM_MENU``         The context menu for the selected item has been requested, either by a right click or by using the menu key.
``EVT_TREE_ITEM_MIDDLE_CLICK`` The user has clicked the item with the middle mouse button (not implemented in `CustomTreeCtrl`).
``EVT_TREE_ITEM_RIGHT_CLICK``  The user has clicked the item with the right mouse button.
``EVT_TREE_KEY_DOWN``          A key has been pressed.
``EVT_TREE_SEL_CHANGED``       Selection has changed.
``EVT_TREE_SEL_CHANGING``      Selection is changing. This can be prevented by calling `Veto()`.
``EVT_TREE_SET_INFO``          Information is being supplied to the application (not implemented in `CustomTreeCtrl`).
``EVT_TREE_STATE_IMAGE_CLICK`` The state image has been clicked (not implemented in `CustomTreeCtrl`).
============================== ==================================================


License And Version
===================

HyperTreeList is distributed under the wxPython license.

Latest Revision: Andrea Gavana @ 28 Nov 2010, 16.00 GMT

Version 1.2

"""

import wx
import wx.gizmos

from customtreectrl import CustomTreeCtrl
from customtreectrl import DragImage, TreeEvent, GenericTreeItem
from customtreectrl import TreeRenameTimer as TreeListRenameTimer
from customtreectrl import EVT_TREE_ITEM_CHECKING, EVT_TREE_ITEM_CHECKED, EVT_TREE_ITEM_HYPERLINK

# Version Info
__version__ = "1.2"

# --------------------------------------------------------------------------
# Constants
# --------------------------------------------------------------------------

_NO_IMAGE = -1

_DEFAULT_COL_WIDTH = 100
_LINEHEIGHT = 10
_LINEATROOT = 5
_MARGIN = 2
_MININDENT = 16
_BTNWIDTH = 9
_BTNHEIGHT = 9
_EXTRA_WIDTH = 4
_EXTRA_HEIGHT = 4

_MAX_WIDTH = 30000  # pixels; used by OnPaint to redraw only exposed items

_DRAG_TIMER_TICKS = 250   # minimum drag wait time in ms
_FIND_TIMER_TICKS = 500   # minimum find wait time in ms
_RENAME_TIMER_TICKS = 250 # minimum rename wait time in ms

# --------------------------------------------------------------------------
# Additional HitTest style
# --------------------------------------------------------------------------
TREE_HITTEST_ONITEMCHECKICON  = 0x4000

# HyperTreeList styles
TR_NO_BUTTONS = wx.TR_NO_BUTTONS                               # for convenience
""" For convenience to document that no buttons are to be drawn. """
TR_HAS_BUTTONS = wx.TR_HAS_BUTTONS                             # draw collapsed/expanded btns
""" Use this style to show + and - buttons to the left of parent items. """
TR_NO_LINES = wx.TR_NO_LINES                                   # don't draw lines at all
""" Use this style to hide vertical level connectors. """
TR_LINES_AT_ROOT = wx.TR_LINES_AT_ROOT                         # connect top-level nodes
""" Use this style to show lines between root nodes. Only applicable if ``TR_HIDE_ROOT`` is""" \
""" set and ``TR_NO_LINES`` is not set. """
TR_TWIST_BUTTONS = wx.TR_TWIST_BUTTONS                         # still used by wxTreeListCtrl
""" Use old Mac-twist style buttons. """
TR_SINGLE = wx.TR_SINGLE                                       # for convenience
""" For convenience to document that only one item may be selected at a time. Selecting another""" \
""" item causes the current selection, if any, to be deselected. This is the default. """
TR_MULTIPLE = wx.TR_MULTIPLE                                   # can select multiple items
""" Use this style to allow a range of items to be selected. If a second range is selected,""" \
""" the current range, if any, is deselected. """
TR_EXTENDED = wx.TR_EXTENDED                                   # TODO: allow extended selection
""" Use this style to allow disjoint items to be selected. (Only partially implemented;""" \
""" may not work in all cases). """
TR_HAS_VARIABLE_ROW_HEIGHT = wx.TR_HAS_VARIABLE_ROW_HEIGHT     # what it says
""" Use this style to cause row heights to be just big enough to fit the content.""" \
""" If not set, all rows use the largest row height. The default is that this flag is unset. """
TR_EDIT_LABELS = wx.TR_EDIT_LABELS                             # can edit item labels
""" Use this style if you wish the user to be able to edit labels in the tree control. """
TR_ROW_LINES = wx.TR_ROW_LINES                                 # put border around items
""" Use this style to draw a contrasting border between displayed rows. """
TR_HIDE_ROOT = wx.TR_HIDE_ROOT                                 # don't display root node
""" Use this style to suppress the display of the root node, effectively causing the""" \
""" first-level nodes to appear as a series of root nodes. """
TR_FULL_ROW_HIGHLIGHT = wx.TR_FULL_ROW_HIGHLIGHT               # highlight full horz space
""" Use this style to have the background colour and the selection highlight extend """ \
""" over the entire horizontal row of the tree control window. """

TR_AUTO_CHECK_CHILD = 0x04000                                  # only meaningful for checkboxes
""" Only meaningful foe checkbox-type items: when a parent item is checked/unchecked""" \
""" its children are checked/unchecked as well. """
TR_AUTO_TOGGLE_CHILD = 0x08000                                 # only meaningful for checkboxes
""" Only meaningful foe checkbox-type items: when a parent item is checked/unchecked""" \
""" its children are toggled accordingly. """
TR_AUTO_CHECK_PARENT = 0x10000                                 # only meaningful for checkboxes
""" Only meaningful foe checkbox-type items: when a child item is checked/unchecked""" \
""" its parent item is checked/unchecked as well. """
TR_ALIGN_WINDOWS = 0x20000                                     # to align windows horizontally for items at the same level
""" Flag used to align windows (in items with windows) at the same horizontal position. """
TR_VIRTUAL = 0x80000
""" `HyperTreeList` will have virtual behaviour. """

# --------------------------------------------------------------------------
# Additional HyperTreeList style to hide the header
# --------------------------------------------------------------------------
TR_NO_HEADER = 0x40000
""" Use this style to hide the columns header. """
# --------------------------------------------------------------------------


def IsBufferingSupported():
    """
    Utility function which checks if a platform handles correctly double
    buffering for the header. Currently returns ``False`` for all platforms
    except Windows XP.
    """

    if wx.Platform != "__WXMSW__":
        return False

    if wx.App.GetComCtl32Version() >= 600:
        if wx.GetOsVersion()[1] > 5:
            # Windows Vista
            return False

        return True

    return False    
    

class TreeListColumnInfo(object):
    """
    Class used to store information (width, alignment flags, colours, etc...) about a
    L{HyperTreeList} column header.
    """

    def __init__(self, input="", width=_DEFAULT_COL_WIDTH, flag=wx.ALIGN_LEFT,
                 image=-1, shown=True, colour=None, edit=False):
        """
        Default class constructor.

        :param `input`: can be a string (representing the column header text) or
         another instance of L{TreeListColumnInfo}. In the latter case, all the
         other input parameters are not used;
        :param `width`: the column width in pixels;
        :param `flag`: the column alignment flag, one of ``wx.ALIGN_LEFT``,
         ``wx.ALIGN_RIGHT``, ``wx.ALIGN_CENTER``;
        :param `image`: an index within the normal image list assigned to
         L{HyperTreeList} specifying the image to use for the column;
        :param `shown`: ``True`` to show the column, ``False`` to hide it;
        :param `colour`: a valid `wx.Colour`, representing the text foreground colour
         for the column;
        :param `edit`: ``True`` to set the column as editable, ``False`` otherwise.
        """

        if isinstance(input, basestring):
            self._text = input
            self._width = width
            self._flag = flag
            self._image = image
            self._selected_image = -1
            self._shown = shown
            self._edit = edit
            self._font = wx.SystemSettings_GetFont(wx.SYS_DEFAULT_GUI_FONT)
            if colour is None:
                self._colour = wx.SystemSettings_GetColour(wx.SYS_COLOUR_WINDOWTEXT)
            else:
                self._colour = colour
                
        else:
    
            self._text = input._text
            self._width = input._width
            self._flag = input._flag
            self._image = input._image
            self._selected_image = input._selected_image
            self._shown = input._shown
            self._edit = input._edit
            self._colour = input._colour
            self._font = input._font
    

    # get/set
    def GetText(self):
        """ Returns the column header label. """
        
        return self._text

    
    def SetText(self, text):
        """
        Sets the column header label.

        :param `text`: the new column header text.
        """

        self._text = text
        return self


    def GetWidth(self):
        """ Returns the column header width in pixels. """

        return self._width 


    def SetWidth(self, width):
        """
        Sets the column header width.

        :param `width`: the column header width, in pixels.
        """

        self._width = width
        return self


    def GetAlignment(self):
        """ Returns the column text alignment. """

        return self._flag

    
    def SetAlignment(self, flag):
        """
        Sets the column text alignment.

        :param `flag`: the alignment flag, one of ``wx.ALIGN_LEFT``, ``wx.ALIGN_RIGHT``,
         ``wx.ALIGN_CENTER``.
        """

        self._flag = flag
        return self 


    def GetColour(self):
        """ Returns the column text colour. """

        return self._colour


    def SetColour(self, colour):
        """
        Sets the column text colour.

        :param `colour`: a valid `wx.Colour` object.
        """

        self._colour = colour
        return self
        

    def GetImage(self):
        """ Returns the column image index. """

        return self._image 


    def SetImage(self, image):
        """
        Sets the column image index.

        :param `image`: an index within the normal image list assigned to
         L{HyperTreeList} specifying the image to use for the column.
        """

        self._image = image
        return self 


    def GetSelectedImage(self):
        """ Returns the column image index in the selected state. """

        return self._selected_image
    

    def SetSelectedImage(self, image):
        """
        Sets the column image index in the selected state.

        :param `image`: an index within the normal image list assigned to
         L{HyperTreeList} specifying the image to use for the column when in
         selected state.
        """

        self._selected_image = image
        return self
    

    def IsEditable(self):
        """ Returns ``True`` if the column is editable, ``False`` otherwise. """

        return self._edit

    
    def SetEditable(self, edit):
        """
        Sets the column as editable or non-editable.

        :param `edit`: ``True`` if the column should be editable, ``False`` otherwise.
        """
        
        self._edit = edit
        return self 


    def IsShown(self):
        """ Returns ``True`` if the column is shown, ``False`` if it is hidden. """

        return self._shown

    
    def SetShown(self, shown):
        """
        Sets the column as shown or hidden.

        :param `shown`: ``True`` if the column should be shown, ``False`` if it
         should be hidden.
        """

        self._shown = shown
        return self 


    def SetFont(self, font):
        """
        Sets the column text font.

        :param `font`: a valid `wx.Font` object.
        """

        self._font = font
        return self


    def GetFont(self):
        """ Returns the column text font. """

        return self._font        


#-----------------------------------------------------------------------------
#  TreeListHeaderWindow (internal)
#-----------------------------------------------------------------------------

class TreeListHeaderWindow(wx.Window):
    """ A window which holds the header of L{HyperTreeList}. """
    
    def __init__(self, parent, id=wx.ID_ANY, owner=None, pos=wx.DefaultPosition,
                 size=wx.DefaultSize, style=0, name="wxtreelistctrlcolumntitles"):
        """
        Default class constructor.

        :param `parent`: the window parent. Must not be ``None``;
        :param `id`: window identifier. A value of -1 indicates a default value;
        :param `owner`: the window owner, in this case an instance of L{TreeListMainWindow};
        :param `pos`: the control position. A value of (-1, -1) indicates a default position,
         chosen by either the windowing system or wxPython, depending on platform;
        :param `size`: the control size. A value of (-1, -1) indicates a default size,
         chosen by either the windowing system or wxPython, depending on platform;
        :param `style`: the window style;
        :param `name`: the window name.
        """

        wx.Window.__init__(self, parent, id, pos, size, style, name=name)
        
        self._owner = owner
        self._currentCursor = wx.StockCursor(wx.CURSOR_DEFAULT)
        self._resizeCursor = wx.StockCursor(wx.CURSOR_SIZEWE)
        self._isDragging = False
        self._dirty = False
        self._total_col_width = 0
        self._hotTrackCol = -1
        self._columns = []
        self._headerCustomRenderer = None
        
        self.Bind(wx.EVT_PAINT, self.OnPaint)
        self.Bind(wx.EVT_MOUSE_EVENTS, self.OnMouse)
        self.Bind(wx.EVT_SET_FOCUS, self.OnSetFocus)

        self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM)


    def SetBuffered(self, buffered):
        """
        Sets/unsets the double buffering for the header.

        :param `buffered`: ``True`` to use double-buffering, ``False`` otherwise.

        :note: Currently we are using double-buffering only on Windows XP.
        """

        self._buffered = buffered


    # total width of all columns
    def GetWidth(self):
        """ Returns the total width of all columns. """

        return self._total_col_width 


    # column manipulation
    def GetColumnCount(self):
        """ Returns the total number of columns. """

        return len(self._columns)


    # column information manipulation
    def GetColumn(self, column):
        """
        Returns a column item, an instance of L{TreeListItem}.

        :param `column`: an integer specifying the column index.
        """

        if column < 0 or column >= self.GetColumnCount():
            raise Exception("Invalid column")
        
        return self._columns[column]


    def GetColumnText(self, column):
        """
        Returns the column text label.

        :param `column`: an integer specifying the column index.
        """

        if column < 0 or column >= self.GetColumnCount():
            raise Exception("Invalid column")
        
        return self._columns[column].GetText()

    
    def SetColumnText(self, column, text):
        """
        Sets the column text label.

        :param `column`: an integer specifying the column index;
        :param `text`: the new column label.
        """

        if column < 0 or column >= self.GetColumnCount():
            raise Exception("Invalid column")
        
        return self._columns[column].SetText(text)
    

    def GetColumnAlignment(self, column):
        """
        Returns the column text alignment.

        :param `column`: an integer specifying the column index.
        """

        if column < 0 or column >= self.GetColumnCount():
            raise Exception("Invalid column")
        
        return self._columns[column].GetAlignment()
    

    def SetColumnAlignment(self, column, flag):
        """
        Sets the column text alignment.

        :param `column`: an integer specifying the column index;
        :param `flag`: the new text alignment flag.

        :see: L{TreeListColumnInfo.SetAlignment} for a list of valid alignment
         flags.
        """

        if column < 0 or column >= self.GetColumnCount():
            raise Exception("Invalid column")
        
        return self._columns[column].SetAlignment(flag)
    

    def GetColumnWidth(self, column):
        """
        Returns the column width, in pixels.

        :param `column`: an integer specifying the column index.
        """

        if column < 0 or column >= self.GetColumnCount():
            raise Exception("Invalid column")
        
        return self._columns[column].GetWidth()
    

    def GetColumnColour(self, column):
        """
        Returns the column text colour.

        :param `column`: an integer specifying the column index.
        """

        if column < 0 or column >= self.GetColumnCount():
            raise Exception("Invalid column")
        
        return self._columns[column].GetColour()


    def SetColumnColour(self, column, colour):
        """
        Sets the column text colour.

        :param `column`: an integer specifying the column index;
        :param `colour`: a valid `wx.Colour` object.
        """

        if column < 0 or column >= self.GetColumnCount():
            raise Exception("Invalid column")
        
        return self._columns[column].SetColour(colour)


    def IsColumnEditable(self, column):
        """
        Returns ``True`` if the column is editable, ``False`` otherwise.

        :param `column`: an integer specifying the column index.
        """

        if column < 0 or column >= self.GetColumnCount():
            raise Exception("Invalid column")
        
        return self._columns[column].IsEditable()
    

    def IsColumnShown(self, column):
        """
        Returns ``True`` if the column is shown, ``False`` if it is hidden.

        :param `column`: an integer specifying the column index.
        """

        if column < 0 or column >= self.GetColumnCount():
            raise Exception("Invalid column")

        return self._columns[column].IsShown()
    

    # shift the DC origin to match the position of the main window horz
    # scrollbar: this allows us to always use logical coords
    def AdjustDC(self, dc):
        """
        Shifts the `wx.DC` origin to match the position of the main window horizontal
        scrollbar: this allows us to always use logical coordinates.

        :param `dc`: an instance of `wx.DC`.        
        """
        
        xpix, dummy = self._owner.GetScrollPixelsPerUnit()
        x, dummy = self._owner.GetViewStart()

        # account for the horz scrollbar offset
        dc.SetDeviceOrigin(-x * xpix, 0)


    def OnPaint(self, event):
        """
        Handles the ``wx.EVT_PAINT`` event for L{TreeListHeaderWindow}.

        :param `event`: a `wx.PaintEvent` event to be processed.
        """
        
        if self._buffered:
            dc = wx.BufferedPaintDC(self)
        else:
            dc = wx.PaintDC(self)
            
        self.PrepareDC(dc)
        self.AdjustDC(dc)

        x = 0

        # width and height of the entire header window
        w, h = self.GetClientSize()
        w, dummy = self._owner.CalcUnscrolledPosition(w, 0)
        dc.SetBackgroundMode(wx.TRANSPARENT)

        numColumns = self.GetColumnCount()
        
        for i in xrange(numColumns):

            if x >= w:
                break
        
            if not self.IsColumnShown(i):
                continue # do next column if not shown

            params = wx.HeaderButtonParams()

            column = self.GetColumn(i)
            params.m_labelColour = column.GetColour()
            params.m_labelFont = column.GetFont()

            wCol = column.GetWidth()
            flags = 0
            rect = wx.Rect(x, 0, wCol, h)
            x += wCol

            if i == self._hotTrackCol:
                flags |= wx.CONTROL_CURRENT
            
            params.m_labelText = column.GetText()
            params.m_labelAlignment = column.GetAlignment()

            image = column.GetImage()
            imageList = self._owner.GetImageList()

            if image != -1 and imageList:
                params.m_labelBitmap = imageList.GetBitmap(image)

            if self._headerCustomRenderer != None:
               self._headerCustomRenderer.DrawHeaderButton(dc, rect, flags, params)
            else:
                wx.RendererNative.Get().DrawHeaderButton(self, dc, rect, flags,
                                                         wx.HDR_SORT_ICON_NONE, params)
       
        # Fill up any unused space to the right of the columns
        if x < w:
            rect = wx.Rect(x, 0, w-x, h)
            if self._headerCustomRenderer != None:
               self._headerCustomRenderer.DrawHeaderButton(dc, rect)
            else:
                wx.RendererNative.Get().DrawHeaderButton(self, dc, rect)
        

    def DrawCurrent(self):
        """ Draws the column resize line on a `wx.ScreenDC`. """
        
        x1, y1 = self._currentX, 0
        x1, y1 = self.ClientToScreen((x1, y1))
        x2 = self._currentX-1
        if wx.Platform == "__WXMSW__":
            x2 += 1 # but why ????

        y2 = 0
        dummy, y2 = self._owner.GetClientSize()
        x2, y2 = self._owner.ClientToScreen((x2, y2))

        dc = wx.ScreenDC()
        dc.SetLogicalFunction(wx.INVERT)
        dc.SetPen(wx.Pen(wx.BLACK, 2, wx.SOLID))
        dc.SetBrush(wx.TRANSPARENT_BRUSH)

        self.AdjustDC(dc)
        dc.DrawLine (x1, y1, x2, y2)
        dc.SetLogicalFunction(wx.COPY)
        
        
    def SetCustomRenderer(self, renderer=None):
        """
        Associate a custom renderer with the header - all columns will use it

        :param `renderer`: a class able to correctly render header buttons

        :note: the renderer class **must** implement the method `DrawHeaderButton`
        """

        self._headerCustomRenderer = renderer


    def XToCol(self, x):
        """
        Returns the column that corresponds to the logical input `x` coordinate.

        :param `x`: the `x` position to evaluate.

        :return: The column that corresponds to the logical input `x` coordinate,
         or ``wx.NOT_FOUND`` if there is no column at the `x` position.
        """
        
        colLeft = 0
        numColumns = self.GetColumnCount()
        for col in xrange(numColumns):
        
            if not self.IsColumnShown(col):
                continue 

            column = self.GetColumn(col)

            if x < (colLeft + column.GetWidth()):
                 return col
            
            colLeft += column.GetWidth()
        
        return wx.NOT_FOUND


    def RefreshColLabel(self, col):
        """
        Redraws the column.

        :param `col`: the index of the column to redraw.
        """

        if col >= self.GetColumnCount():
            return
        
        x = idx = width = 0
        while idx <= col:
            
            if not self.IsColumnShown(idx):
                continue 

            column = self.GetColumn(idx)
            x += width
            width = column.GetWidth()
            idx += 1

        x, dummy = self._owner.CalcScrolledPosition(x, 0)
        self.RefreshRect(wx.Rect(x, 0, width, self.GetSize().GetHeight()))

        
    def OnMouse(self, event):
        """
        Handles the ``wx.EVT_MOUSE_EVENTS`` event for L{TreeListHeaderWindow}.

        :param `event`: a `wx.MouseEvent` event to be processed.
        """

        # we want to work with logical coords
        x, dummy = self._owner.CalcUnscrolledPosition(event.GetX(), 0)
        y = event.GetY()

        if event.Moving():
        
            col = self.XToCol(x)
            if col != self._hotTrackCol:
            
                # Refresh the col header so it will be painted with hot tracking
                # (if supported by the native renderer.)
                self.RefreshColLabel(col)

                # Also refresh the old hot header
                if self._hotTrackCol >= 0:
                    self.RefreshColLabel(self._hotTrackCol)

                self._hotTrackCol = col
            
        if event.Leaving() and self._hotTrackCol >= 0:
        
            # Leaving the window so clear any hot tracking indicator that may be present
            self.RefreshColLabel(self._hotTrackCol)
            self._hotTrackCol = -1
        
        if self._isDragging:

            self.SendListEvent(wx.wxEVT_COMMAND_LIST_COL_DRAGGING, event.GetPosition())

            # we don't draw the line beyond our window, but we allow dragging it
            # there
            w, dummy = self.GetClientSize()
            w, dummy = self._owner.CalcUnscrolledPosition(w, 0)
            w -= 6

            # erase the line if it was drawn
            if self._currentX < w:
                self.DrawCurrent()

            if event.ButtonUp():
                self._isDragging = False
                if self.HasCapture():
                    self.ReleaseMouse()
                self._dirty = True
                self.SetColumnWidth(self._column, self._currentX - self._minX)
                self.Refresh()
                self.SendListEvent(wx.wxEVT_COMMAND_LIST_COL_END_DRAG, event.GetPosition())
            else:
                self._currentX = max(self._minX + 7, x)

                # draw in the new location
                if self._currentX < w:
                    self.DrawCurrent()
            
        else: # not dragging

            self._minX = 0
            hit_border = False

            # end of the current column
            xpos = 0

            # find the column where this event occured
            countCol = self.GetColumnCount()

            for column in xrange(countCol):

                if not self.IsColumnShown(column):
                    continue # do next if not shown

                xpos += self.GetColumnWidth(column)
                self._column = column
                if abs (x-xpos) < 3 and y < 22:
                    # near the column border
                    hit_border = True
                    break
                
                if x < xpos:
                    # inside the column
                    break
            
                self._minX = xpos
            
            if event.LeftDown() or event.RightUp():
                if hit_border and event.LeftDown():
                    self._isDragging = True
                    self.CaptureMouse()
                    self._currentX = x
                    self.DrawCurrent()
                    self.SendListEvent(wx.wxEVT_COMMAND_LIST_COL_BEGIN_DRAG, event.GetPosition())
                else: # click on a column
                    evt = (event.LeftDown() and [wx.wxEVT_COMMAND_LIST_COL_CLICK] or [wx.wxEVT_COMMAND_LIST_COL_RIGHT_CLICK])[0]
                    self.SendListEvent(evt, event.GetPosition())
                
            elif event.LeftDClick() and hit_border:
                self.SetColumnWidth(self._column, self._owner.GetBestColumnWidth(self._column))
                self.Refresh()

            elif event.Moving():
                
                if hit_border:
                    setCursor = self._currentCursor == wx.STANDARD_CURSOR
                    self._currentCursor = self._resizeCursor
                else:
                    setCursor = self._currentCursor != wx.STANDARD_CURSOR
                    self._currentCursor = wx.STANDARD_CURSOR
                
                if setCursor:
                    self.SetCursor(self._currentCursor)
    

    def OnSetFocus(self, event):
        """
        Handles the ``wx.EVT_SET_FOCUS`` event for L{TreeListHeaderWindow}.

        :param `event`: a `wx.FocusEvent` event to be processed.
        """

        self._owner.SetFocus()


    def SendListEvent(self, evtType, pos):
        """
        Sends a `wx.ListEvent` for the parent window.

        :param `evtType`: the event type;
        :param `pos`: an instance of `wx.Point`.
        """
        
        parent = self.GetParent()
        le = wx.ListEvent(evtType, parent.GetId())
        le.SetEventObject(parent)
        le.m_pointDrag = pos

        # the position should be relative to the parent window, not
        # this one for compatibility with MSW and common sense: the
        # user code doesn't know anything at all about this header
        # window, so why should it get positions relative to it?
        le.m_pointDrag.y -= self.GetSize().y
        le.m_col = self._column
        parent.GetEventHandler().ProcessEvent(le)


    def AddColumnInfo(self, colInfo):
        """
        Appends a column to the L{TreeListHeaderWindow}.

        :param `colInfo`: an instance of L{TreeListColumnInfo}.
        """
        
        self._columns.append(colInfo)
        self._total_col_width += colInfo.GetWidth()
        self._owner.AdjustMyScrollbars()
        self._owner._dirty = True


    def AddColumn(self, text, width=_DEFAULT_COL_WIDTH, flag=wx.ALIGN_LEFT,
                  image=-1, shown=True, colour=None, edit=False):
        """
        Appends a column to the L{TreeListHeaderWindow}.

        :param `text`: the column text label;
        :param `width`: the column width in pixels;
        :param `flag`: the column alignment flag, one of ``wx.ALIGN_LEFT``,
         ``wx.ALIGN_RIGHT``, ``wx.ALIGN_CENTER``;
        :param `image`: an index within the normal image list assigned to
         L{HyperTreeList} specifying the image to use for the column;
        :param `shown`: ``True`` to show the column, ``False`` to hide it;
        :param `colour`: a valid `wx.Colour`, representing the text foreground colour
         for the column;
        :param `edit`: ``True`` to set the column as editable, ``False`` otherwise.
        """

        colInfo = TreeListColumnInfo(text, width, flag, image, shown, colour, edit)
        self.AddColumnInfo(colInfo)


    def SetColumnWidth(self, column, width):
        """
        Sets the column width, in pixels.

        :param `column`: an integer specifying the column index;
        :param `width`: the new width for the column, in pixels.
        """
        
        if column < 0 or column >= self.GetColumnCount():
            raise Exception("Invalid column")

        self._total_col_width -= self._columns[column].GetWidth()
        self._columns[column].SetWidth(width)
        self._total_col_width += width
        self._owner.AdjustMyScrollbars()
        self._owner._dirty = True


    def InsertColumnInfo(self, before, colInfo):
        """
        Inserts a column to the L{TreeListHeaderWindow} at the position specified
        by `before`.

        :param `before`: the index at which we wish to insert the new column;
        :param `colInfo`: an instance of L{TreeListColumnInfo}.
        """

        if before < 0 or before >= self.GetColumnCount():
            raise Exception("Invalid column")
        
        self._columns.insert(before, colInfo)
        self._total_col_width += colInfo.GetWidth()
        self._owner.AdjustMyScrollbars()
        self._owner._dirty = True


    def InsertColumn(self, before, text, width=_DEFAULT_COL_WIDTH,
                     flag=wx.ALIGN_LEFT, image=-1, shown=True, colour=None, 
                     edit=False):
        """
        Inserts a column to the L{TreeListHeaderWindow} at the position specified
        by `before`.

        :param `before`: the index at which we wish to insert the new column;
        :param `text`: the column text label;
        :param `width`: the column width in pixels;
        :param `flag`: the column alignment flag, one of ``wx.ALIGN_LEFT``,
         ``wx.ALIGN_RIGHT``, ``wx.ALIGN_CENTER``;
        :param `image`: an index within the normal image list assigned to
         L{HyperTreeList} specifying the image to use for the column;
        :param `shown`: ``True`` to show the column, ``False`` to hide it;
        :param `colour`: a valid `wx.Colour`, representing the text foreground colour
         for the column;
        :param `edit`: ``True`` to set the column as editable, ``False`` otherwise.        
        """
        
        colInfo = TreeListColumnInfo(text, width, flag, image, shown, colour, 
                                     edit)
        self.InsertColumnInfo(before, colInfo)


    def RemoveColumn(self, column):
        """
        Removes a column from the L{TreeListHeaderWindow}.

        :param `column`: an integer specifying the column index.
        """

        if column < 0 or column >= self.GetColumnCount():
            raise Exception("Invalid column")
        
        self._total_col_width -= self._columns[column].GetWidth()
        self._columns.pop(column)
        self._owner.AdjustMyScrollbars()
        self._owner._dirty = True


    def SetColumn(self, column, info):
        """
        Sets a column using an instance of L{TreeListColumnInfo}.

        :param `column`: an integer specifying the column index;
        :param `info`: an instance of L{TreeListColumnInfo}.        
        """
        
        if column < 0 or column >= self.GetColumnCount():
            raise Exception("Invalid column")
        
        w = self._columns[column].GetWidth()
        self._columns[column] = info
        
        if w != info.GetWidth():
            self._total_col_width += info.GetWidth() - w
            self._owner.AdjustMyScrollbars()
        
        self._owner._dirty = True
        

# ---------------------------------------------------------------------------
# TreeListItem
# ---------------------------------------------------------------------------
class TreeListItem(GenericTreeItem):
    """
    This class holds all the information and methods for every single item in
    L{HyperTreeList}.

    :note: Subclassed from L{customtreectrl.GenericTreeItem}.    
    """
    
    def __init__(self, mainWin, parent, text=[], ct_type=0, wnd=None, image=-1, selImage=-1, data=None):
        """
        Default class constructor.
        For internal use: do not call it in your code!

        :param `mainWin`: the main L{HyperTreeList} window, in this case an instance
         of L{TreeListMainWindow};
        :param `parent`: the tree item parent (may be ``None`` for root items);
        :param `text`: the tree item text;
        :param `ct_type`: the tree item kind. May be one of the following integers:

         =============== ==========================
         `ct_type` Value Description
         =============== ==========================
                0        A normal item
                1        A checkbox-like item
                2        A radiobutton-type item
         =============== ==========================

        :param `wnd`: if not ``None``, a non-toplevel window to be displayed next to
         the item;
        :param `image`: an index within the normal image list specifying the image to
         use for the item in unselected state;
        :param `selImage`: an index within the normal image list specifying the image to
         use for the item in selected state; if `image` > -1 and `selImage` is -1, the
         same image is used for both selected and unselected items;
        :param `data`: associate the given Python object `data` with the item.

        :note: Regarding radiobutton-type items (with `ct_type` = 2), the following
         approach is used:
         
         - All peer-nodes that are radiobuttons will be mutually exclusive. In other words,
           only one of a set of radiobuttons that share a common parent can be checked at
           once. If a radiobutton node becomes checked, then all of its peer radiobuttons
           must be unchecked.
         - If a radiobutton node becomes unchecked, then all of its child nodes will become
           inactive.        
        """

        self._col_images = []
        self._owner = mainWin

        # We don't know the height here yet.
        self._text_x = 0
        
        GenericTreeItem.__init__(self, parent, text, ct_type, wnd, image, selImage, data)        
 
        self._wnd = [None]             # are we holding a window?
        self._hidden = False
        
        if wnd:
            self.SetWindow(wnd)


    def IsHidden(self):
        """ Returns whether the item is hidden or not. """

        return self._hidden


    def Hide(self, hide):
        """
        Hides/shows the L{TreeListItem}.

        :param `hide`: ``True`` to hide the item, ``False`` to show it.
        """

        self._hidden = hide
        
    
    def DeleteChildren(self, tree):
        """
        Deletes the item children.

        :param `tree`: the main L{TreeListMainWindow} instance.
        """

        for child in self._children:
            if tree:
                tree.SendDeleteEvent(child)

            child.DeleteChildren(tree)
            
            if child == tree._selectItem:
                tree._selectItem = None

            # We have to destroy the associated window
            for wnd in child._wnd:
                if wnd:
                    wnd.Hide()
                    wnd.Destroy()
                    
            child._wnd = []

            if child in tree._itemWithWindow:
                tree._itemWithWindow.remove(child)
                
            del child
        
        self._children = []


    def HitTest(self, point, theCtrl, flags, column, level):
        """
        HitTest method for an item. Called from the main window HitTest.

        :param `point`: the point to test for the hit (an instance of `wx.Point`);
        :param `theCtrl`: the main L{TreeListMainWindow} tree;
        :param `flags`: a bitlist of hit locations;
        :param `column`: an integer specifying the column index;
        :param `level`: the item's level inside the tree hierarchy.
        
        :see: L{TreeListMainWindow.HitTest} method for the flags explanation.
        """

        # for a hidden root node, don't evaluate it, but do evaluate children
        if not theCtrl.HasAGWFlag(wx.TR_HIDE_ROOT) or level > 0:

            # reset any previous hit infos
            flags = 0
            column = -1
            header_win = theCtrl._owner.GetHeaderWindow()

            # check for right of all columns (outside)
            if point.x > header_win.GetWidth():
                return None, flags, wx.NOT_FOUND

            # evaluate if y-pos is okay
            h = theCtrl.GetLineHeight(self)
            
            if point.y >= self._y and point.y <= self._y + h:

                maincol = theCtrl.GetMainColumn()

                # check for above/below middle
                y_mid = self._y + h/2
                if point.y < y_mid:
                    flags |= wx.TREE_HITTEST_ONITEMUPPERPART
                else:
                    flags |= wx.TREE_HITTEST_ONITEMLOWERPART
                
                # check for button hit
                if self.HasPlus() and theCtrl.HasButtons():
                    bntX = self._x - theCtrl._btnWidth2
                    bntY = y_mid - theCtrl._btnHeight2
                    if ((point.x >= bntX) and (point.x <= (bntX + theCtrl._btnWidth)) and
                        (point.y >= bntY) and (point.y <= (bntY + theCtrl._btnHeight))):
                        flags |= wx.TREE_HITTEST_ONITEMBUTTON
                        column = maincol
                        return self, flags, column

                # check for hit on the check icons
                if self.GetType() != 0:
                    imageWidth = 0
                    numberOfMargins = 1
                    if self.GetCurrentImage() != _NO_IMAGE:
                        imageWidth = theCtrl._imgWidth
                        numberOfMargins += 1
                    chkX = self._text_x - imageWidth - numberOfMargins*_MARGIN - theCtrl._checkWidth
                    chkY = y_mid - theCtrl._checkHeight2
                    if ((point.x >= chkX) and (point.x <= (chkX + theCtrl._checkWidth)) and
                        (point.y >= chkY) and (point.y <= (chkY + theCtrl._checkHeight))):                    
                        flags |= TREE_HITTEST_ONITEMCHECKICON
                        return self, flags, maincol
                    
                # check for image hit
                if self.GetCurrentImage() != _NO_IMAGE:
                    imgX = self._text_x - theCtrl._imgWidth - _MARGIN                        
                    imgY = y_mid - theCtrl._imgHeight2
                    if ((point.x >= imgX) and (point.x <= (imgX + theCtrl._imgWidth)) and
                        (point.y >= imgY) and (point.y <= (imgY + theCtrl._imgHeight))):
                        flags |= wx.TREE_HITTEST_ONITEMICON
                        column = maincol
                        return self, flags, column
                    
                # check for label hit
                if ((point.x >= self._text_x) and (point.x <= (self._text_x + self._width))):
                    flags |= wx.TREE_HITTEST_ONITEMLABEL
                    column = maincol
                    return self, flags, column
                
                # check for indent hit after button and image hit
                if point.x < self._x:
                    flags |= wx.TREE_HITTEST_ONITEMINDENT
                    column = -1 # considered not belonging to main column
                    return self, flags, column
                
                # check for right of label
                end = 0
                for i in xrange(maincol):
                    end += header_win.GetColumnWidth(i)
                    if ((point.x > (self._text_x + self._width)) and (point.x <= end)):
                        flags |= wx.TREE_HITTEST_ONITEMRIGHT
                        column = -1 # considered not belonging to main column
                        return self, flags, column
                
                # else check for each column except main
                x = 0
                for j in xrange(theCtrl.GetColumnCount()):
                    if not header_win.IsColumnShown(j):
                        continue
                    w = header_win.GetColumnWidth(j)
                    if ((j != maincol) and (point.x >= x and point.x < x+w)):
                        flags |= wx.TREE_HITTEST_ONITEMCOLUMN
                        column = j
                        return self, flags, column
                    
                    x += w
                
                # no special flag or column found
                return self, flags, column

            # if children not expanded, return no item
            if not self.IsExpanded():
                return None, flags, wx.NOT_FOUND
        
        # in any case evaluate children
        for child in self._children:
            hit, flags, column = child.HitTest(point, theCtrl, flags, column, level+1)
            if hit:
                return hit, flags, column
        
        # not found
        return None, flags, wx.NOT_FOUND


    def GetText(self, column=None):
        """
        Returns the item text label.

        :param `column`: if not ``None``, an integer specifying the column index.
         If it is ``None``, the main column index is used.
        """

        column = (column is not None and [column] or [self._owner.GetMainColumn()])[0]
        
        if len(self._text) > 0:
            if self._owner.IsVirtual():
                return self._owner.GetItemText(self._data, column)
            else:
                return self._text[column]
        
        return ""
    

    def GetImage(self, which=wx.TreeItemIcon_Normal, column=None):
        """
        Returns the item image for a particular item state.

        :param `which`: can be one of the following bits:

         ================================= ========================
         Item State                        Description
         ================================= ========================
         ``TreeItemIcon_Normal``           To get the normal item image
         ``TreeItemIcon_Selected``         To get the selected item image (i.e. the image which is shown when the item is currently selected)
         ``TreeItemIcon_Expanded``         To get the expanded image (this only makes sense for items which have children - then this image is shown when the item is expanded and the normal image is shown when it is collapsed)
         ``TreeItemIcon_SelectedExpanded`` To get the selected expanded image (which is shown when an expanded item is currently selected) 
         ================================= ========================

        :param `column`: if not ``None``, an integer specifying the column index.
         If it is ``None``, the main column index is used.
        """

        column = (column is not None and [column] or [self._owner.GetMainColumn()])[0]

        if column == self._owner.GetMainColumn():
            return self._images[which]
        
        if column < len(self._col_images):
            return self._col_images[column]

        return _NO_IMAGE


    def GetCurrentImage(self, column=None):
        """
        Returns the current item image.

        :param `column`: if not ``None``, an integer specifying the column index.
         If it is ``None``, the main column index is used.        
        """

        column = (column is not None and [column] or [self._owner.GetMainColumn()])[0]

        if column != self._owner.GetMainColumn():
            return self.GetImage(column=column)
        
        image = GenericTreeItem.GetCurrentImage(self)
        return image
    

    def SetText(self, column, text):
        """
        Sets the item text label.

        :param `column`: if not ``None``, an integer specifying the column index.
         If it is ``None``, the main column index is used;
        :param `text`: a string specifying the new item label.
        """

        column = (column is not None and [column] or [self._owner.GetMainColumn()])[0]
    
        if column < len(self._text):
            self._text[column] = text
        elif column < self._owner.GetColumnCount():
            self._text.extend([""] * (column - len(self._text) + 1))
            self._text[column] = text
        

    def SetImage(self, column, image, which):
        """
        Sets the item image for a particular item state.

        :param `column`: if not ``None``, an integer specifying the column index.
         If it is ``None``, the main column index is used;
        :param `image`: an index within the normal image list specifying the image to use;
        :param `which`: the item state.

        :see: L{GetImage} for a list of valid item states.
        """

        column = (column is not None and [column] or [self._owner.GetMainColumn()])[0]
    
        if column == self._owner.GetMainColumn():
            self._images[which] = image
        elif column < len(self._col_images):
            self._col_images[column] = image
        elif column < self._owner.GetColumnCount():
            self._col_images.extend([_NO_IMAGE] * (column - len(self._col_images) + 1))
            self._col_images[column] = image
        
    
    def GetTextX(self):
        """ Returns the `x` position of the item text. """

        return self._text_x

    
    def SetTextX(self, text_x):
        """
        Sets the `x` position of the item text.

        :param `text_x`: the `x` position of the item text.
        """

        self._text_x = text_x 


    def SetWindow(self, wnd, column=None):
        """
        Sets the window associated to the item.

        :param `wnd`: a non-toplevel window to be displayed next to the item;
        :param `column`: if not ``None``, an integer specifying the column index.
         If it is ``None``, the main column index is used.
        """

        column = (column is not None and [column] or [self._owner.GetMainColumn()])[0]

        if type(self._wnd) != type([]):
            self._wnd = [self._wnd]

        if column < len(self._wnd):
            self._wnd[column] = wnd
        elif column < self._owner.GetColumnCount():
            self._wnd.extend([None] * (column - len(self._wnd) + 1))
            self._wnd[column] = wnd

        if self not in self._owner._itemWithWindow:
            self._owner._itemWithWindow.append(self)
            
        # We have to bind the wx.EVT_SET_FOCUS for the associated window
        # No other solution to handle the focus changing from an item in
        # HyperTreeList and the window associated to an item
        # Do better strategies exist?
        wnd.Bind(wx.EVT_SET_FOCUS, self.OnSetFocus)
        
        # We don't show the window if the item is collapsed
        if self._isCollapsed:
            wnd.Show(False)

        # The window is enabled only if the item is enabled                
        wnd.Enable(self._enabled)
        

    def OnSetFocus(self, event):
        """
        Handles the ``wx.EVT_SET_FOCUS`` event for a window associated to an item.

        :param `event`: a `wx.FocusEvent` event to be processed.
        """

        treectrl = self._owner
        select = treectrl.GetSelection()

        # If the window is associated to an item that currently is selected
        # (has focus) we don't kill the focus. Otherwise we do it.
        if select != self:
            treectrl._hasFocus = False
        else:
            treectrl._hasFocus = True
            
        event.Skip()

        
    def GetWindow(self, column=None):
        """
        Returns the window associated to the item.

        :param `column`: if not ``None``, an integer specifying the column index.
         If it is ``None``, the main column index is used.        
        """

        column = (column is not None and [column] or [self._owner.GetMainColumn()])[0]
        
        if column >= len(self._wnd):
            return None

        return self._wnd[column]        


    def DeleteWindow(self, column=None):
        """
        Deletes the window associated to the item (if any).

        :param `column`: if not ``None``, an integer specifying the column index.
         If it is ``None``, the main column index is used.
        """

        column = (column is not None and [column] or [self._owner.GetMainColumn()])[0]

        if column >= len(self._wnd):
            return
        
        if self._wnd[column]:
            self._wnd[column].Destroy()
            self._wnd[column] = None
        

    def GetWindowEnabled(self, column=None):
        """
        Returns whether the window associated with an item is enabled or not.

        :param `column`: if not ``None``, an integer specifying the column index.
         If it is ``None``, the main column index is used.
        """

        column = (column is not None and [column] or [self._owner.GetMainColumn()])[0]

        if not self._wnd[column]:
            raise Exception("\nERROR: This Item Has No Window Associated At Column %s"%column)

        return self._wnd[column].IsEnabled()


    def SetWindowEnabled(self, enable=True, column=None):
        """
        Sets whether the window associated with an item is enabled or not.

        :param `enable`: ``True`` to enable the associated window, ``False`` to disable it;
        :param `column`: if not ``None``, an integer specifying the column index.
         If it is ``None``, the main column index is used.
        """

        column = (column is not None and [column] or [self._owner.GetMainColumn()])[0]

        if not self._wnd[column]:
            raise Exception("\nERROR: This Item Has No Window Associated At Column %s"%column)

        self._wnd[column].Enable(enable)


    def GetWindowSize(self, column=None):
        """
        Returns the associated window size.

        :param `column`: if not ``None``, an integer specifying the column index.
         If it is ``None``, the main column index is used.
        """

        column = (column is not None and [column] or [self._owner.GetMainColumn()])[0]
        
        if not self._wnd[column]:
            raise Exception("\nERROR: This Item Has No Window Associated At Column %s"%column)
        
        return self._wnd[column].GetSize()   


#-----------------------------------------------------------------------------
# EditTextCtrl (internal)
#-----------------------------------------------------------------------------

class EditTextCtrl(wx.TextCtrl):
    """
    Control used for in-place edit.
    """
    
    def __init__(self, parent, id=wx.ID_ANY, item=None, column=None, owner=None,
                 value="", pos=wx.DefaultPosition, size=wx.DefaultSize, style=0,
                 validator=wx.DefaultValidator, name="edittextctrl"):
        """
        Default class constructor.
        For internal use: do not call it in your code!

        :param `parent`: the window parent. Must not be ``None``;
        :param `id`: window identifier. A value of -1 indicates a default value;
        :param `item`: an instance of L{TreeListItem};
        :param `column`: if not ``None``, an integer specifying the column index.
         If it is ``None``, the main column index is used;
        :param `owner`: the window owner, in this case an instance of L{TreeListMainWindow};
        :param `value`: the initial value in the text control;
        :param `pos`: the control position. A value of (-1, -1) indicates a default position,
         chosen by either the windowing system or wxPython, depending on platform;
        :param `size`: the control size. A value of (-1, -1) indicates a default size,
         chosen by either the windowing system or wxPython, depending on platform;
        :param `style`: the window style;
        :param `validator`: the window validator;
        :param `name`: the window name.
        """
        
        self._owner = owner
        self._startValue = value
        self._finished = False
        self._itemEdited = item

        column = (column is not None and [column] or [self._owner.GetMainColumn()])[0]
        
        self._column = column

        w = self._itemEdited.GetWidth()
        h = self._itemEdited.GetHeight()

        wnd = self._itemEdited.GetWindow(column)
        if wnd:
            w = w - self._itemEdited.GetWindowSize(column)[0]
            h = 0

        x = item.GetX()

        if column > 0:
            x = 0
            
        for i in xrange(column):
            if not self._owner.GetParent()._header_win.IsColumnShown(i):
                continue # do next column if not shown
            
            col = self._owner.GetParent()._header_win.GetColumn(i)
            wCol = col.GetWidth()
            x += wCol
        
        x, y = self._owner.CalcScrolledPosition(x+2, item.GetY())

        image_w = image_h = wcheck = hcheck = 0
        image = item.GetCurrentImage(column)

        if image != _NO_IMAGE:
    
            if self._owner._imageListNormal:
                image_w, image_h = self._owner._imageListNormal.GetSize(image)
                image_w += 2*_MARGIN
        
            else:
        
                raise Exception("\n ERROR: You Must Create An Image List To Use Images!")

        if column > 0:
            checkimage = item.GetCurrentCheckedImage()
            if checkimage is not None:
                wcheck, hcheck = self._owner._imageListCheck.GetSize(checkimage)
                wcheck += 2*_MARGIN

        if wnd:
            h = max(hcheck, image_h)
            dc = wx.ClientDC(self._owner)
            h = max(h, dc.GetTextExtent("Aq")[1])
            h = h + 2
            
        # FIXME: what are all these hardcoded 4, 8 and 11s really?
        x += image_w + wcheck
        w -= image_w + 2*_MARGIN + wcheck

        wx.TextCtrl.__init__(self, parent, id, value, wx.Point(x, y),
                             wx.Size(w + 15, h), style|wx.SIMPLE_BORDER, validator, name)
        
        if wx.Platform == "__WXMAC__":
            self.SetFont(owner.GetFont())
            bs = self.GetBestSize()
            self.SetSize((-1, bs.height))
                    
        self.Bind(wx.EVT_CHAR, self.OnChar)
        self.Bind(wx.EVT_KEY_UP, self.OnKeyUp)
        self.Bind(wx.EVT_KILL_FOCUS, self.OnKillFocus)


    def AcceptChanges(self):
        """Accepts/refuses the changes made by the user."""

        value = self.GetValue()

        if value == self._startValue:
            # nothing changed, always accept
            # when an item remains unchanged, the owner
            # needs to be notified that the user decided
            # not to change the tree item label, and that
            # the edit has been cancelled
            self._owner.OnRenameCancelled()
            return True

        if not self._owner.OnRenameAccept(value):
            # vetoed by the user
            return False
        
        return True


    def Finish(self):
        """Finish editing."""

        if not self._finished:
        
            self._finished = True
            self._owner.SetFocusIgnoringChildren()
            self._owner.ResetTextControl()
        

    def OnChar(self, event):
        """
        Handles the ``wx.EVT_CHAR`` event for L{EditTextCtrl}.

        :param `event`: a `wx.KeyEvent` event to be processed.
        """

        keycode = event.GetKeyCode()

        if keycode in [wx.WXK_RETURN, wx.WXK_NUMPAD_ENTER]:
            self._aboutToFinish = True
            # Notify the owner about the changes
            self.AcceptChanges()
            # Even if vetoed, close the control (consistent with MSW)
            wx.CallAfter(self.Finish)

        elif keycode == wx.WXK_ESCAPE:
            self.StopEditing()

        else:
            event.Skip()
    

    def OnKeyUp(self, event):
        """
        Handles the ``wx.EVT_KEY_UP`` event for L{EditTextCtrl}.

        :param `event`: a `wx.KeyEvent` event to be processed.
        """

        if not self._finished:

            # auto-grow the textctrl:
            parentSize = self._owner.GetSize()
            myPos = self.GetPosition()
            mySize = self.GetSize()
            
            sx, sy = self.GetTextExtent(self.GetValue() + "M")
            if myPos.x + sx > parentSize.x:
                sx = parentSize.x - myPos.x
            if mySize.x > sx:
                sx = mySize.x
                
            self.SetSize((sx, -1))

        event.Skip()


    def OnKillFocus(self, event):
        """
        Handles the ``wx.EVT_KILL_FOCUS`` event for L{EditTextCtrl}

        :param `event`: a `wx.FocusEvent` event to be processed.
        """

        # We must let the native text control handle focus, too, otherwise
        # it could have problems with the cursor (e.g., in wxGTK).
        event.Skip()


    def StopEditing(self):
        """Suddenly stops the editing."""

        self._owner.OnRenameCancelled()
        self.Finish()
        

    def item(self):
        """Returns the item currently edited."""

        return self._itemEdited


    def column(self): 
        """Returns the column currently edited.""" 

        return self._column


# ---------------------------------------------------------------------------
# TreeListMainWindow implementation
# ---------------------------------------------------------------------------

class TreeListMainWindow(CustomTreeCtrl):
    """
    This class represents the main window (and thus the main column) in L{HyperTreeList}.

    :note: This is a subclass of L{CustomTreeCtrl}.
    """

    def __init__(self, parent, id=wx.ID_ANY, pos=wx.DefaultPosition, size=wx.DefaultSize,
                 style=0, agwStyle=wx.TR_DEFAULT_STYLE, validator=wx.DefaultValidator,
                 name="wxtreelistmainwindow"):
        """
        Default class constructor.
        
        :param `parent`: parent window. Must not be ``None``;
        :param `id`: window identifier. A value of -1 indicates a default value;
        :param `pos`: the control position. A value of (-1, -1) indicates a default position,
         chosen by either the windowing system or wxPython, depending on platform;
        :param `size`: the control size. A value of (-1, -1) indicates a default size,
         chosen by either the windowing system or wxPython, depending on platform;
        :param `style`: the underlying `wx.PyScrolledWindow` style;
        :param `agwStyle`: the AGW-specific L{TreeListMainWindow} window style. This can be a
         combination of the following bits:
        
         ============================== =========== ==================================================
         Window Styles                  Hex Value   Description
         ============================== =========== ==================================================
         ``TR_NO_BUTTONS``                      0x0 For convenience to document that no buttons are to be drawn.
         ``TR_SINGLE``                          0x0 For convenience to document that only one item may be selected at a time. Selecting another item causes the current selection, if any, to be deselected. This is the default.
         ``TR_HAS_BUTTONS``                     0x1 Use this style to show + and - buttons to the left of parent items.
         ``TR_NO_LINES``                        0x4 Use this style to hide vertical level connectors.
         ``TR_LINES_AT_ROOT``                   0x8 Use this style to show lines between root nodes. Only applicable if ``TR_HIDE_ROOT`` is set and ``TR_NO_LINES`` is not set.
         ``TR_DEFAULT_STYLE``                   0x9 The set of flags that are closest to the defaults for the native control for a particular toolkit.
         ``TR_TWIST_BUTTONS``                  0x10 Use old Mac-twist style buttons.
         ``TR_MULTIPLE``                       0x20 Use this style to allow a range of items to be selected. If a second range is selected, the current range, if any, is deselected.
         ``TR_EXTENDED``                       0x40 Use this style to allow disjoint items to be selected. (Only partially implemented; may not work in all cases).
         ``TR_HAS_VARIABLE_ROW_HEIGHT``        0x80 Use this style to cause row heights to be just big enough to fit the content. If not set, all rows use the largest row height. The default is that this flag is unset.
         ``TR_EDIT_LABELS``                   0x200 Use this style if you wish the user to be able to edit labels in the tree control.
         ``TR_ROW_LINES``                     0x400 Use this style to draw a contrasting border between displayed rows.
         ``TR_HIDE_ROOT``                     0x800 Use this style to suppress the display of the root node, effectively causing the first-level nodes to appear as a series of root nodes.
         ``TR_FULL_ROW_HIGHLIGHT``           0x2000 Use this style to have the background colour and the selection highlight extend  over the entire horizontal row of the tree control window.
         ``TR_AUTO_CHECK_CHILD``             0x4000 Only meaningful foe checkbox-type items: when a parent item is checked/unchecked its children are checked/unchecked as well.
         ``TR_AUTO_TOGGLE_CHILD``            0x8000 Only meaningful foe checkbox-type items: when a parent item is checked/unchecked its children are toggled accordingly.
         ``TR_AUTO_CHECK_PARENT``           0x10000 Only meaningful foe checkbox-type items: when a child item is checked/unchecked its parent item is checked/unchecked as well.
         ``TR_ALIGN_WINDOWS``               0x20000 Flag used to align windows (in items with windows) at the same horizontal position.
         ``TR_NO_HEADER``                   0x40000 Use this style to hide the columns header.
         ``TR_VIRTUAL``                     0x80000 L{HyperTreeList} will have virtual behaviour.
         ============================== =========== ==================================================

        :param `validator`: window validator;
        :param `name`: window name.
        """

        CustomTreeCtrl.__init__(self, parent, id, pos, size, style, agwStyle, validator, name)
        
        self._shiftItem = None
        self._editItem = None
        self._selectItem = None

        self._curColumn = -1 # no current column
        self._owner = parent
        self._main_column = 0
        self._dragItem = None

        self._imgWidth = self._imgWidth2 = 0
        self._imgHeight = self._imgHeight2 = 0
        self._btnWidth = self._btnWidth2 = 0
        self._btnHeight = self._btnHeight2 = 0
        self._checkWidth = self._checkWidth2 = 0
        self._checkHeight = self._checkHeight2 = 0
        self._agwStyle = agwStyle
        self._current = None

        # TextCtrl initial settings for editable items
        self._renameTimer = TreeListRenameTimer(self)
        self._left_down_selection = False

        self._dragTimer = wx.Timer(self)
        self._findTimer = wx.Timer(self)
        
        self.Bind(wx.EVT_PAINT, self.OnPaint)
        self.Bind(wx.EVT_MOUSE_EVENTS, self.OnMouse)

        # Listen for EVT_SCROLLWIN in a separate event handler so that the
        # default handler can be called without entering an infinite loop.
        # See OnScroll for why calling the default handler manually is needed.
        # Store the default handler in _default_evt_handler.
        scroll_evt_handler = wx.EvtHandler()
        self.PushEventHandler(scroll_evt_handler)
        scroll_evt_handler.Bind(wx.EVT_SCROLLWIN, self.OnScroll)
        self._default_evt_handler = scroll_evt_handler.GetNextHandler()

        # Sets the focus to ourselves: this is useful if you have items
        # with associated widgets.
        self.SetFocus()
        self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM)


    def SetBuffered(self, buffered):
        """
        Sets/unsets the double buffering for the main window.

        :param `buffered`: ``True`` to use double-buffering, ``False`` otherwise.

        :note: Currently we are using double-buffering only on Windows XP.
        """

        self._buffered = buffered
        if buffered:
            self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM)
        else:
            self.SetBackgroundStyle(wx.BG_STYLE_SYSTEM)


    def IsVirtual(self):
        """ Returns ``True`` if L{TreeListMainWindow} has the ``TR_VIRTUAL`` flag set. """
        
        return self.HasAGWFlag(TR_VIRTUAL)


#-----------------------------------------------------------------------------
# functions to work with tree items
#-----------------------------------------------------------------------------

    def GetItemImage(self, item, column=None, which=wx.TreeItemIcon_Normal):
        """
        Returns the item image.

        :param `item`: an instance of L{TreeListItem};
        :param `column`: if not ``None``, an integer specifying the column index.
         If it is ``None``, the main column index is used;
        :param `which`: can be one of the following bits:

         ================================= ========================
         Item State                        Description
         ================================= ========================
         ``TreeItemIcon_Normal``           To get the normal item image
         ``TreeItemIcon_Selected``         To get the selected item image (i.e. the image which is shown when the item is currently selected)
         ``TreeItemIcon_Expanded``         To get the expanded image (this only makes sense for items which have children - then this image is shown when the item is expanded and the normal image is shown when it is collapsed)
         ``TreeItemIcon_SelectedExpanded`` To get the selected expanded image (which is shown when an expanded item is currently selected) 
         ================================= ========================
        """
        
        column = (column is not None and [column] or [self._main_column])[0]

        if column < 0:
            return _NO_IMAGE

        return item.GetImage(which, column)


    def SetItemImage(self, item, image, column=None, which=wx.TreeItemIcon_Normal):
        """
        Sets the item image for a particular item state.

        :param `item`: an instance of L{TreeListItem};
        :param `image`: an index within the normal image list specifying the image to use;
        :param `column`: if not ``None``, an integer specifying the column index.
         If it is ``None``, the main column index is used;
        :param `which`: the item state.

        :see: L{GetItemImage} for a list of valid item states.
        """
        
        column = (column is not None and [column] or [self._main_column])[0]

        if column < 0:
            return
        
        item.SetImage(column, image, which)
        dc = wx.ClientDC(self)
        self.CalculateSize(item, dc)
        self.RefreshLine(item)


    def GetItemWindowEnabled(self, item, column=None):
        """
        Returns whether the window associated with an item is enabled or not.

        :param `item`: an instance of L{TreeListItem};
        :param `column`: if not ``None``, an integer specifying the column index.
         If it is ``None``, the main column index is used.
        """

        return item.GetWindowEnabled(column)


    def GetItemWindow(self, item, column=None):
        """
        Returns the window associated with an item.

        :param `item`: an instance of L{TreeListItem};
        :param `column`: if not ``None``, an integer specifying the column index.
         If it is ``None``, the main column index is used.
        """
        
        return item.GetWindow(column)


    def SetItemWindow(self, item, window, column=None):
        """
        Sets the window associated to an item.

        :param `item`: an instance of L{TreeListItem};
        :param `wnd`: a non-toplevel window to be displayed next to the item;
        :param `column`: if not ``None``, an integer specifying the column index.
         If it is ``None``, the main column index is used.

        :note: The window parent should not be the L{HyperTreeList} itself, but actually
         an instance of L{TreeListMainWindow}. The current solution here is to reparent
         the window to this class.
        """

        # Reparent the window to ourselves
        if window.GetParent() != self:
            window.Reparent(self)
        
        item.SetWindow(window, column)
        if window:
            self._hasWindows = True
        

    def SetItemWindowEnabled(self, item, enable=True, column=None):
        """
        Sets whether the window associated with an item is enabled or not.

        :param `item`: an instance of L{TreeListItem};
        :param `enable`: ``True`` to enable the associated window, ``False`` to disable it;
        :param `column`: if not ``None``, an integer specifying the column index.
         If it is ``None``, the main column index is used.
        """

        item.SetWindowEnabled(enable, column)


# ----------------------------------------------------------------------------
# navigation
# ----------------------------------------------------------------------------

    def IsItemVisible(self, item):
        """
        Returns whether the item is visible or not.

        :param `item`: an instance of L{TreeListItem};
        """

        # An item is only visible if it's not a descendant of a collapsed item
        parent = item.GetParent()

        while parent:
        
            if not parent.IsExpanded():
                return False
            
            parent = parent.GetParent()
        
        startX, startY = self.GetViewStart()
        clientSize = self.GetClientSize()

        rect = self.GetBoundingRect(item)
        
        if not rect:
            return False
        if rect.GetWidth() == 0 or rect.GetHeight() == 0:
            return False
        if rect.GetBottom() < 0 or rect.GetTop() > clientSize.y:
            return False
        if rect.GetRight() < 0 or rect.GetLeft() > clientSize.x:
            return False

        return True


    def GetPrevChild(self, item, cookie):
        """
        Returns the previous child of an item.

        :param `item`: an instance of L{TreeListItem};
        :param `cookie`: a parameter which is opaque for the application but is necessary
         for the library to make these functions reentrant (i.e. allow more than one
         enumeration on one and the same object simultaneously).

        :note: This method returns ``None`` if there are no further siblings.
        """

        children = item.GetChildren()

        if cookie >= 0:            
            return children[cookie], cookie-1
        else:        
            # there are no more of them
            return None, cookie


    def GetFirstExpandedItem(self):
        """ Returns the first item which is in the expanded state. """

        return self.GetNextExpanded(self.GetRootItem())


    def GetNextExpanded(self, item):
        """
        Returns the next expanded item after the input one.

        :param `item`: an instance of L{TreeListItem}.
        """                

        return self.GetNext(item, False)


    def GetPrevExpanded(self, item):
        """
        Returns the previous expanded item before the input one.

        :param `item`: an instance of L{TreeListItem}.
        """                

        return self.GetPrev(item, False)


    def GetFirstVisibleItem(self):
        """ Returns the first visible item. """

        return self.GetNextVisible(self.GetRootItem())


    def GetPrevVisible(self, item):
        """
        Returns the previous visible item before the input one.

        :param `item`: an instance of L{TreeListItem}.
        """                

        i = self.GetNext(item, False)
        while i:
            if self.IsItemVisible(i):
                return i
            i = self.GetPrev(i, False)
        
        return None


# ----------------------------------------------------------------------------
# operations
# ----------------------------------------------------------------------------

    def DoInsertItem(self, parent, previous, text, ct_type=0, wnd=None, image=-1, selImage=-1, data=None):
        """
        Actually inserts an item in the tree.

        :param `parentId`: an instance of L{TreeListItem} representing the
         item's parent;
        :param `previous`: the index at which we should insert the item;
        :param `text`: the item text label;
        :param `ct_type`: the item type (see L{CustomTreeCtrl.SetItemType} for a list of valid
         item types);
        :param `wnd`: if not ``None``, a non-toplevel window to show next to the item;
        :param `image`: an index within the normal image list specifying the image to
         use for the item in unselected state;
        :param `selImage`: an index within the normal image list specifying the image to
         use for the item in selected state; if `image` > -1 and `selImage` is -1, the
         same image is used for both selected and unselected items;
        :param `data`: associate the given Python object `data` with the item.
        """
        
        self._dirty = True # do this first so stuff below doesn't cause flicker
        arr = [""]*self.GetColumnCount()
        arr[self._main_column] = text
        
        if not parent:
            # should we give a warning here?
            return self.AddRoot(text, ct_type, wnd, image, selImage, data)
        
        self._dirty = True     # do this first so stuff below doesn't cause flicker

        item = TreeListItem(self, parent, arr, ct_type, wnd, image, selImage, data)
        
        if wnd is not None:
            self._hasWindows = True
            self._itemWithWindow.append(item)
        
        parent.Insert(item, previous)

        return item


    def AddRoot(self, text, ct_type=0, wnd=None, image=-1, selImage=-1, data=None):
        """
        Adds a root item to the L{TreeListMainWindow}.

        :param `text`: the item text label;
        :param `ct_type`: the item type (see L{CustomTreeCtrl.SetItemType} for a list of valid
         item types);
        :param `wnd`: if not ``None``, a non-toplevel window to show next to the item;
        :param `image`: an index within the normal image list specifying the image to
         use for the item in unselected state;
        :param `selImage`: an index within the normal image list specifying the image to
         use for the item in selected state; if `image` > -1 and `selImage` is -1, the
         same image is used for both selected and unselected items;
        :param `data`: associate the given Python object `data` with the item.

        :warning: only one root is allowed to exist in any given instance of L{TreeListMainWindow}.
        """        

        if self._anchor:
            raise Exception("\nERROR: Tree Can Have Only One Root")

        if wnd is not None and not (self._agwStyle & wx.TR_HAS_VARIABLE_ROW_HEIGHT):
            raise Exception("\nERROR: In Order To Append/Insert Controls You Have To Use The Style TR_HAS_VARIABLE_ROW_HEIGHT")

        if text.find("\n") >= 0 and not (self._agwStyle & wx.TR_HAS_VARIABLE_ROW_HEIGHT):
            raise Exception("\nERROR: In Order To Append/Insert A MultiLine Text You Have To Use The Style TR_HAS_VARIABLE_ROW_HEIGHT")

        if ct_type < 0 or ct_type > 2:
            raise Exception("\nERROR: Item Type Should Be 0 (Normal), 1 (CheckBox) or 2 (RadioButton). ")

        self._dirty = True     # do this first so stuff below doesn't cause flicker
        arr = [""]*self.GetColumnCount()
        arr[self._main_column] = text
        self._anchor = TreeListItem(self, None, arr, ct_type, wnd, image, selImage, data)
        
        if wnd is not None:
            self._hasWindows = True
            self._itemWithWindow.append(self._anchor)            
        
        if self.HasAGWFlag(wx.TR_HIDE_ROOT):
            # if root is hidden, make sure we can navigate
            # into children
            self._anchor.SetHasPlus()
            self._anchor.Expand()
            self.CalculatePositions()
        
        if not self.HasAGWFlag(wx.TR_MULTIPLE):
            self._current = self._key_current = self._selectItem = self._anchor
            self._current.SetHilight(True)
        
        return self._anchor


    def Delete(self, item):
        """
        Deletes an item.

        :param `item`: an instance of L{TreeListItem}.
        """

        if not item:
            raise Exception("\nERROR: Invalid Tree Item. ")
        
        self._dirty = True     # do this first so stuff below doesn't cause flicker

        if self._textCtrl != None and self.IsDescendantOf(item, self._textCtrl.item()):
            # can't delete the item being edited, cancel editing it first
            self._textCtrl.StopEditing()

        # don't stay with invalid self._shiftItem or we will crash in the next call to OnChar()
        changeKeyCurrent = False
        itemKey = self._shiftItem
        
        while itemKey:
            if itemKey == item:  # self._shiftItem is a descendant of the item being deleted
                changeKeyCurrent = True
                break
            
            itemKey = itemKey.GetParent()
        
        parent = item.GetParent()
        if parent:
            parent.GetChildren().remove(item)  # remove by value
        
        if changeKeyCurrent:
            self._shiftItem = parent

        self.SendDeleteEvent(item)
        if self._selectItem == item:
            self._selectItem = None

        # Remove the item with window
        if item in self._itemWithWindow:
            for wnd in item._wnd:
                if wnd:
                    wnd.Hide()
                    wnd.Destroy()
                
            item._wnd = []
            self._itemWithWindow.remove(item)
            
        item.DeleteChildren(self)
        del item


    # Don't leave edit or selection on a child which is about to disappear
    def ChildrenClosing(self, item):
        """
        We are about to destroy the item's children.

        :param `item`: an instance of L{TreeListItem}.
        """

        if self._textCtrl != None and item != self._textCtrl.item() and self.IsDescendantOf(item, self._textCtrl.item()):
            self._textCtrl.StopEditing()

        if self.IsDescendantOf(item, self._selectItem):
            self._selectItem = item
            
        if item != self._current and self.IsDescendantOf(item, self._current):
            self._current.SetHilight(False)
            self._current = None

            
    def DeleteRoot(self):
        """
        Removes the tree root item (and subsequently all the items in
        L{TreeListMainWindow}.
        """

        if self._anchor:

            self._dirty = True
            self.SendDeleteEvent(self._anchor)
            self._current = None
            self._selectItem = None
            self._anchor.DeleteChildren(self)
            del self._anchor
            self._anchor = None


    def DeleteAllItems(self):
        """ Delete all items in the L{TreeListMainWindow}. """

        self.DeleteRoot()
        

    def HideWindows(self):
        """ Hides the windows associated to the items. Used internally. """
        
        for child in self._itemWithWindow:
            if not self.IsItemVisible(child):
                for column in xrange(self.GetColumnCount()):
                    wnd = child.GetWindow(column)
                    if wnd and wnd.IsShown():
                        wnd.Hide()
                

    def EnableItem(self, item, enable=True, torefresh=True):
        """
        Enables/disables an item.

        :param `item`: an instance of L{TreeListItem};
        :param `enable`: ``True`` to enable the item, ``False`` otherwise;
        :param `torefresh`: whether to redraw the item or not.
        """
        
        if item.IsEnabled() == enable:
            return

        if not enable and item.IsSelected():
            self.DoSelectItem(item, not self.HasAGWFlag(wx.TR_MULTIPLE))

        item.Enable(enable)

        for column in xrange(self.GetColumnCount()):
            wnd = item.GetWindow(column)

            # Handles the eventual window associated to the item        
            if wnd:
                wnd.Enable(enable)
        
        if torefresh:
            # We have to refresh the item line
            dc = wx.ClientDC(self)
            self.CalculateSize(item, dc)
            self.RefreshLine(item)


    def IsItemEnabled(self, item):
        """
        Returns whether an item is enabled or disabled.

        :param `item`: an instance of L{TreeListItem}.
        """

        return item.IsEnabled()
    

    def GetCurrentItem(self):
        """ Returns the current item. """

        return self._current

    
    def GetColumnCount(self):
        """ Returns the total number of columns. """

        return self._owner.GetHeaderWindow().GetColumnCount()


    def SetMainColumn(self, column):
        """
        Sets the L{HyperTreeList} main column (i.e. the position of the underlying
        L{CustomTreeCtrl}.

        :param `column`: if not ``None``, an integer specifying the column index.
         If it is ``None``, the main column index is used.
        """
        
        if column >= 0 and column < self.GetColumnCount():
            self._main_column = column


    def GetMainColumn(self):
        """
        Returns the L{HyperTreeList} main column (i.e. the position of the underlying
        L{CustomTreeCtrl}.
        """
        
        return self._main_column
    

    def ScrollTo(self, item):
        """
        Scrolls the specified item into view.

        :param `item`: an instance of L{TreeListItem}.
        """

        # ensure that the position of the item it calculated in any case
        if self._dirty:
            self.CalculatePositions()

        # now scroll to the item
        xUnit, yUnit = self.GetScrollPixelsPerUnit()
        start_x, start_y = self.GetViewStart()
        start_y *= yUnit
        client_w, client_h = self.GetClientSize ()

        x, y = self._anchor.GetSize (0, 0, self)
        x = self._owner.GetHeaderWindow().GetWidth()
        y += yUnit + 2 # one more scrollbar unit + 2 pixels
        x_pos = self.GetScrollPos(wx.HORIZONTAL)

        if item._y < start_y+3:
            # going down, item should appear at top
            self.SetScrollbars(xUnit, yUnit, (xUnit and [x/xUnit] or [0])[0], (yUnit and [y/yUnit] or [0])[0],
                               x_pos, (yUnit and [item._y/yUnit] or [0])[0])
            
        elif item._y+self.GetLineHeight(item) > start_y+client_h:
            # going up, item should appear at bottom
            item._y += yUnit + 2
            self.SetScrollbars(xUnit, yUnit, (xUnit and [x/xUnit] or [0])[0], (yUnit and [y/yUnit] or [0])[0],
                               x_pos, (yUnit and [(item._y+self.GetLineHeight(item)-client_h)/yUnit] or [0])[0])
        

    def SetDragItem(self, item):
        """
        Sets the specified item as member of a current drag and drop operation.

        :param `item`: an instance of L{TreeListItem}.
        """

        prevItem = self._dragItem
        self._dragItem = item
        if prevItem:
            self.RefreshLine(prevItem)
        if self._dragItem:
            self.RefreshLine(self._dragItem)


# ----------------------------------------------------------------------------
# helpers
# ----------------------------------------------------------------------------

    def AdjustMyScrollbars(self):
        """ Internal method used to adjust the `wx.PyScrolledWindow` scrollbars. """

        if self._anchor:
            xUnit, yUnit = self.GetScrollPixelsPerUnit()
            if xUnit == 0:
                xUnit = self.GetCharWidth()
            if yUnit == 0:
                yUnit = self._lineHeight

            x, y = self._anchor.GetSize(0, 0, self)
            y += yUnit + 2 # one more scrollbar unit + 2 pixels
            x_pos = self.GetScrollPos(wx.HORIZONTAL)
            y_pos = self.GetScrollPos(wx.VERTICAL)
            x = self._owner.GetHeaderWindow().GetWidth() + 2
            if x < self.GetClientSize().GetWidth():
                x_pos = 0

            self.SetScrollbars(xUnit, yUnit, x/xUnit, y/yUnit, x_pos, y_pos)
        else:
            self.SetScrollbars(0, 0, 0, 0)
    

    def PaintItem(self, item, dc):
        """
        Actually draws an item.

        :param `item`: an instance of L{TreeListItem};
        :param `dc`: an instance of `wx.DC`.
        """

        def _paintText(text, textrect, alignment):
            """
            Sub-function to draw multi-lines text label aligned correctly.

            :param `text`: the item text label (possibly multiline);
            :param `textrect`: the label client rectangle;
            :param `alignment`: the alignment for the text label, one of ``wx.ALIGN_LEFT``,
             ``wx.ALIGN_RIGHT``, ``wx.ALIGN_CENTER``.
            """
            
            txt = text.splitlines()
            if alignment != wx.ALIGN_LEFT and len(txt):
                yorigin = textrect.Y
                for t in txt:
                    w, h = dc.GetTextExtent(t)
                    plus = textrect.Width - w
                    if alignment == wx.ALIGN_CENTER:
                        plus /= 2
                    dc.DrawLabel(t, wx.Rect(textrect.X + plus, yorigin, w, yorigin+h))
                    yorigin += h
                return
            dc.DrawLabel(text, textrect)
        
        attr = item.GetAttributes()
        
        if attr and attr.HasFont():
            dc.SetFont(attr.GetFont())
        elif item.IsBold():
            dc.SetFont(self._boldFont)
        if item.IsHyperText():
            dc.SetFont(self.GetHyperTextFont())
            if item.GetVisited():
                dc.SetTextForeground(self.GetHyperTextVisitedColour())
            else:
                dc.SetTextForeground(self.GetHyperTextNewColour())

        colText = wx.Colour(*dc.GetTextForeground())
        
        if item.IsSelected():
            if (wx.Platform == "__WXMAC__" and self._hasFocus):
                colTextHilight = wx.SystemSettings_GetColour(wx.SYS_COLOUR_HIGHLIGHTTEXT)
            else:
                colTextHilight = wx.SystemSettings_GetColour(wx.SYS_COLOUR_HIGHLIGHTTEXT)

        else:
            attr = item.GetAttributes()
            if attr and attr.HasTextColour():
                colText = attr.GetTextColour()
            
        if self._vistaselection:
            colText = colTextHilight = wx.BLACK
                
        total_w = self._owner.GetHeaderWindow().GetWidth()
        total_h = self.GetLineHeight(item)
        off_h = (self.HasAGWFlag(wx.TR_ROW_LINES) and [1] or [0])[0]
        off_w = (self.HasAGWFlag(wx.TR_COLUMN_LINES) and [1] or [0])[0]
##        clipper = wx.DCClipper(dc, 0, item.GetY(), total_w, total_h) # only within line

        text_w, text_h, dummy = dc.GetMultiLineTextExtent(item.GetText(self.GetMainColumn()))

        drawItemBackground = False
        # determine background and show it
        if attr and attr.HasBackgroundColour():
            colBg = attr.GetBackgroundColour()
            drawItemBackground = True
        else:
            colBg = self._backgroundColour
        
        dc.SetBrush(wx.Brush(colBg, wx.SOLID))
        dc.SetPen(wx.TRANSPARENT_PEN)

        if self.HasAGWFlag(wx.TR_FULL_ROW_HIGHLIGHT):

            itemrect = wx.Rect(0, item.GetY() + off_h, total_w-1, total_h - off_h)
            
            if item == self._dragItem:
                dc.SetBrush(self._hilightBrush)
                if wx.Platform == "__WXMAC__":
                    dc.SetPen((item == self._dragItem) and [wx.BLACK_PEN] or [wx.TRANSPARENT_PEN])[0]

                dc.SetTextForeground(colTextHilight)

            elif item.IsSelected():

                wnd = item.GetWindow(self._main_column)
                wndx = 0
                if wnd:
                    wndx, wndy = item.GetWindowSize(self._main_column)

                itemrect = wx.Rect(0, item.GetY() + off_h, total_w-1, total_h - off_h)
                
                if self._usegradients:
                    if self._gradientstyle == 0:   # Horizontal
                        self.DrawHorizontalGradient(dc, itemrect, self._hasFocus)
                    else:                          # Vertical
                        self.DrawVerticalGradient(dc, itemrect, self._hasFocus)
                elif self._vistaselection:
                    self.DrawVistaRectangle(dc, itemrect, self._hasFocus)
                else:
                    if wx.Platform in ["__WXGTK2__", "__WXMAC__"]:
                        flags = wx.CONTROL_SELECTED
                        if self._hasFocus: flags = flags | wx.CONTROL_FOCUSED
                        wx.RendererNative.Get().DrawItemSelectionRect(self._owner, dc, itemrect, flags) 
                    else:
                        dc.SetBrush((self._hasFocus and [self._hilightBrush] or [self._hilightUnfocusedBrush])[0])
                        dc.SetPen((self._hasFocus and [self._borderPen] or [wx.TRANSPARENT_PEN])[0])
                        dc.DrawRectangleRect(itemrect)
                
                dc.SetTextForeground(colTextHilight)

            # On GTK+ 2, drawing a 'normal' background is wrong for themes that
            # don't allow backgrounds to be customized. Not drawing the background,
            # except for custom item backgrounds, works for both kinds of theme.
            elif drawItemBackground:

                itemrect = wx.Rect(0, item.GetY() + off_h, total_w-1, total_h - off_h)
                dc.SetBrush(wx.Brush(colBg, wx.SOLID))
                dc.DrawRectangleRect(itemrect)
                dc.SetTextForeground(colText)
                                                
            else:
                dc.SetTextForeground(colText)

        else:
            
            dc.SetTextForeground(colText)

        text_extraH = (total_h > text_h and [(total_h - text_h)/2] or [0])[0]
        img_extraH = (total_h > self._imgHeight and [(total_h-self._imgHeight)/2] or [0])[0]
        x_colstart = 0
        
        for i in xrange(self.GetColumnCount()):
            if not self._owner.GetHeaderWindow().IsColumnShown(i):
                continue

            col_w = self._owner.GetHeaderWindow().GetColumnWidth(i)
            dc.SetClippingRegion(x_colstart, item.GetY(), col_w, total_h) # only within column

            image = _NO_IMAGE
            x = image_w = wcheck = hcheck = 0

            if i == self.GetMainColumn():
                x = item.GetX() + _MARGIN
                if self.HasButtons():
                    x += (self._btnWidth-self._btnWidth2) + _LINEATROOT
                else:
                    x -= self._indent/2
                
                if self._imageListNormal:
                    image = item.GetCurrentImage(i)
                    
                if item.GetType() != 0 and self._imageListCheck:
                    checkimage = item.GetCurrentCheckedImage()
                    wcheck, hcheck = self._imageListCheck.GetSize(item.GetType())
                else:
                    wcheck, hcheck = 0, 0
            
            else:
                x = x_colstart + _MARGIN
                image = item.GetImage(column=i)
                
            if image != _NO_IMAGE:
                image_w = self._imgWidth + _MARGIN

            # honor text alignment
            text = item.GetText(i)
            alignment = self._owner.GetHeaderWindow().GetColumn(i).GetAlignment()

            text_w, dummy, dummy = dc.GetMultiLineTextExtent(text)

            if alignment == wx.ALIGN_RIGHT:
                w = col_w - (image_w + wcheck + text_w + off_w + _MARGIN + 1)
                x += (w > 0 and [w] or [0])[0]

            elif alignment == wx.ALIGN_CENTER:
                w = (col_w - (image_w + wcheck + text_w + off_w + _MARGIN))/2
                x += (w > 0 and [w] or [0])[0]
            else:
                if not item.HasPlus() and image_w == 0 and wcheck:
                    x += 3*_MARGIN
            
            text_x = x + image_w + wcheck + 1
            
            if i == self.GetMainColumn():
                item.SetTextX(text_x)

            if not self.HasAGWFlag(wx.TR_FULL_ROW_HIGHLIGHT):
                dc.SetBrush((self._hasFocus and [self._hilightBrush] or [self._hilightUnfocusedBrush])[0])
                dc.SetPen((self._hasFocus and [self._borderPen] or [wx.TRANSPARENT_PEN])[0])
                if i == self.GetMainColumn():
                    if item == self._dragItem:
                        if wx.Platform == "__WXMAC__":  # don't draw rect outline if we already have the background colour
                            dc.SetPen((item == self._dragItem and [wx.BLACK_PEN] or [wx.TRANSPARENT_PEN])[0])

                        dc.SetTextForeground(colTextHilight)
                        
                    elif item.IsSelected():

                        itemrect = wx.Rect(text_x-2, item.GetY() + off_h, text_w+2*_MARGIN, total_h - off_h)

                        if self._usegradients:
                            if self._gradientstyle == 0:   # Horizontal
                                self.DrawHorizontalGradient(dc, itemrect, self._hasFocus)
                            else:                          # Vertical
                                self.DrawVerticalGradient(dc, itemrect, self._hasFocus)
                        elif self._vistaselection:
                            self.DrawVistaRectangle(dc, itemrect, self._hasFocus)
                        else:
                            if wx.Platform in ["__WXGTK2__", "__WXMAC__"]:
                                flags = wx.CONTROL_SELECTED
                                if self._hasFocus: flags = flags | wx.CONTROL_FOCUSED
                                wx.RendererNative.Get().DrawItemSelectionRect(self._owner, dc, itemrect, flags) 
                            else:
                                dc.DrawRectangleRect(itemrect)

                        dc.SetTextForeground(colTextHilight)

                    elif item == self._current:
                        dc.SetPen((self._hasFocus and [wx.BLACK_PEN] or [wx.TRANSPARENT_PEN])[0])
                    
                    # On GTK+ 2, drawing a 'normal' background is wrong for themes that
                    # don't allow backgrounds to be customized. Not drawing the background,
                    # except for custom item backgrounds, works for both kinds of theme.
                    elif drawItemBackground:

                        itemrect = wx.Rect(text_x-2, item.GetY() + off_h, text_w+2*_MARGIN, total_h - off_h)
                        dc.SetBrush(wx.Brush(colBg, wx.SOLID))
                        dc.DrawRectangleRect(itemrect)

                    else:
                        dc.SetTextForeground(colText)
    
                else:
                    dc.SetTextForeground(colText)
                
            if self.HasAGWFlag(wx.TR_COLUMN_LINES):  # vertical lines between columns
                pen = wx.Pen(wx.SystemSettings_GetColour(wx.SYS_COLOUR_3DLIGHT), 1, wx.SOLID)
                dc.SetPen((self.GetBackgroundColour() == wx.WHITE and [pen] or [wx.WHITE_PEN])[0])
                dc.DrawLine(x_colstart+col_w-1, item.GetY(), x_colstart+col_w-1, item.GetY()+total_h)
            
            dc.SetBackgroundMode(wx.TRANSPARENT)

            if image != _NO_IMAGE:
                y = item.GetY() + img_extraH
                if wcheck:
                    x += wcheck

                if item.IsEnabled():
                    imglist = self._imageListNormal
                else:
                    imglist = self._grayedImageList
                
                imglist.Draw(image, dc, x, y, wx.IMAGELIST_DRAW_TRANSPARENT)

            if wcheck:
                if item.IsEnabled():
                    imglist = self._imageListCheck
                else:
                    imglist = self._grayedCheckList

                if self.HasButtons():  # should the item show a button?
                    btnWidth = self._btnWidth
                else:
                    btnWidth = -self._btnWidth
                
                imglist.Draw(checkimage, dc,
                             item.GetX() + btnWidth + _MARGIN,
                             item.GetY() + ((total_h > hcheck) and [(total_h-hcheck)/2] or [0])[0]+1,
                             wx.IMAGELIST_DRAW_TRANSPARENT)

            text_w, text_h, dummy = dc.GetMultiLineTextExtent(text)
            text_extraH = (total_h > text_h and [(total_h - text_h)/2] or [0])[0]            
            text_y = item.GetY() + text_extraH
            textrect = wx.Rect(text_x, text_y, text_w, text_h)
        
            if not item.IsEnabled():
                foreground = dc.GetTextForeground()
                dc.SetTextForeground(self._disabledColour)
                _paintText(text, textrect, alignment)
                dc.SetTextForeground(foreground)
            else:
                if wx.Platform == "__WXMAC__" and item.IsSelected() and self._hasFocus:
                    dc.SetTextForeground(wx.WHITE)
                _paintText(text, textrect, alignment)

            wnd = item.GetWindow(i)            
            if wnd:
                if text_w == 0:
                    wndx = text_x
                else:
                    wndx = text_x + text_w + 2*_MARGIN
                xa, ya = self.CalcScrolledPosition((0, item.GetY()))
                wndx += xa
                if item.GetHeight() > item.GetWindowSize(i)[1]:
                    ya += (item.GetHeight() - item.GetWindowSize(i)[1])/2
                    
                if not wnd.IsShown():
                    wnd.Show()
                if wnd.GetPosition() != (wndx, ya):
                    wnd.SetPosition((wndx, ya))                
            
            x_colstart += col_w
            dc.DestroyClippingRegion()
        
        # restore normal font
        dc.SetFont(self._normalFont)


    # Now y stands for the top of the item, whereas it used to stand for middle !
    def PaintLevel(self, item, dc, level, y, x_maincol):
        """
        Paint a level in the hierarchy of L{TreeListMainWindow}.

        :param `item`: an instance of L{TreeListItem};
        :param `dc`: an instance of `wx.DC`;
        :param `level`: the item level in the tree hierarchy;
        :param `y`: the current vertical position in the `wx.PyScrolledWindow`;
        :param `x_maincol`: the horizontal position of the main column.
        """

        if item.IsHidden():
            return y, x_maincol
        
        # Handle hide root (only level 0)
        if self.HasAGWFlag(wx.TR_HIDE_ROOT) and level == 0:
            for child in item.GetChildren():
                y, x_maincol = self.PaintLevel(child, dc, 1, y, x_maincol)
            
            # end after expanding root
            return y, x_maincol
        
        # calculate position of vertical lines
        x = x_maincol + _MARGIN # start of column

        if self.HasAGWFlag(wx.TR_LINES_AT_ROOT):
            x += _LINEATROOT # space for lines at root
            
        if self.HasButtons():
            x += (self._btnWidth-self._btnWidth2) # half button space
        else:
            x += (self._indent-self._indent/2)
        
        if self.HasAGWFlag(wx.TR_HIDE_ROOT):
            x += self._indent*(level-1) # indent but not level 1
        else:
            x += self._indent*level # indent according to level
        
        # set position of vertical line
        item.SetX(x)
        item.SetY(y)

        h = self.GetLineHeight(item)
        y_top = y
        y_mid = y_top + (h/2)
        y += h

        exposed_x = dc.LogicalToDeviceX(0)
        exposed_y = dc.LogicalToDeviceY(y_top)

        # horizontal lines between rows?
        draw_row_lines = self.HasAGWFlag(wx.TR_ROW_LINES)

        if self.IsExposed(exposed_x, exposed_y, _MAX_WIDTH, h + draw_row_lines):
            if draw_row_lines:
                total_width = self._owner.GetHeaderWindow().GetWidth()
                # if the background colour is white, choose a
                # contrasting colour for the lines
                pen = wx.Pen(wx.SystemSettings_GetColour(wx.SYS_COLOUR_3DLIGHT), 1, wx.SOLID)
                dc.SetPen((self.GetBackgroundColour() == wx.WHITE and [pen] or [wx.WHITE_PEN])[0])
                dc.DrawLine(0, y_top, total_width, y_top)
                dc.DrawLine(0, y_top+h, total_width, y_top+h)
            
            # draw item
            self.PaintItem(item, dc)

            # restore DC objects
            dc.SetBrush(wx.WHITE_BRUSH)
            dc.SetPen(self._dottedPen)

            # clip to the column width
            clip_width = self._owner.GetHeaderWindow().GetColumn(self._main_column).GetWidth()
##            clipper = wx.DCClipper(dc, x_maincol, y_top, clip_width, 10000)

            if not self.HasAGWFlag(wx.TR_NO_LINES):  # connection lines

                # draw the horizontal line here
                dc.SetPen(self._dottedPen)
                x2 = x - self._indent
                if x2 < (x_maincol + _MARGIN):
                    x2 = x_maincol + _MARGIN
                x3 = x + (self._btnWidth-self._btnWidth2)
                if self.HasButtons():
                    if item.HasPlus():
                        dc.DrawLine(x2, y_mid, x - self._btnWidth2, y_mid)
                        dc.DrawLine(x3, y_mid, x3 + _LINEATROOT, y_mid)
                    else:
                        dc.DrawLine(x2, y_mid, x3 + _LINEATROOT, y_mid)
                else:
                    dc.DrawLine(x2, y_mid, x - self._indent/2, y_mid)
                
            if item.HasPlus() and self.HasButtons():  # should the item show a button?
                
                if self._imageListButtons:

                    # draw the image button here
                    image = wx.TreeItemIcon_Normal
                    if item.IsExpanded():
                        image = wx.TreeItemIcon_Expanded
                    if item.IsSelected():
                        image += wx.TreeItemIcon_Selected - wx.TreeItemIcon_Normal
                    xx = x - self._btnWidth2 + _MARGIN
                    yy = y_mid - self._btnHeight2
                    dc.SetClippingRegion(xx, yy, self._btnWidth, self._btnHeight)
                    self._imageListButtons.Draw(image, dc, xx, yy, wx.IMAGELIST_DRAW_TRANSPARENT)
                    dc.DestroyClippingRegion()

                elif self.HasAGWFlag(wx.TR_TWIST_BUTTONS):

                    # draw the twisty button here
                    dc.SetPen(wx.BLACK_PEN)
                    dc.SetBrush(self._hilightBrush)
                    button = [wx.Point() for j in xrange(3)]
                    if item.IsExpanded():
                        button[0].x = x - (self._btnWidth2+1)
                        button[0].y = y_mid - (self._btnHeight/3)
                        button[1].x = x + (self._btnWidth2+1)
                        button[1].y = button[0].y
                        button[2].x = x
                        button[2].y = button[0].y + (self._btnHeight2+1)
                    else:
                        button[0].x = x - (self._btnWidth/3)
                        button[0].y = y_mid - (self._btnHeight2+1)
                        button[1].x = button[0].x
                        button[1].y = y_mid + (self._btnHeight2+1)
                        button[2].x = button[0].x + (self._btnWidth2+1)
                        button[2].y = y_mid
                    
                    dc.DrawPolygon(button)

                else: # if (HasAGWFlag(wxTR_HAS_BUTTONS))

                    rect = wx.Rect(x-self._btnWidth2, y_mid-self._btnHeight2, self._btnWidth, self._btnHeight)
                    flag = (item.IsExpanded() and [wx.CONTROL_EXPANDED] or [0])[0]
                    wx.RendererNative.GetDefault().DrawTreeItemButton(self, dc, rect, flag)        

        # restore DC objects
        dc.SetBrush(wx.WHITE_BRUSH)
        dc.SetPen(self._dottedPen)
        dc.SetTextForeground(wx.BLACK)

        if item.IsExpanded():

            # process lower levels
            if self._imgWidth > 0:
                oldY = y_mid + self._imgHeight2
            else:
                oldY = y_mid + h/2
            
            for child in item.GetChildren():

                y, x_maincol = self.PaintLevel(child, dc, level+1, y, x_maincol)

                # draw vertical line
                if not self.HasAGWFlag(wx.TR_NO_LINES):
                    Y1 = child.GetY() + child.GetHeight()/2
                    dc.DrawLine(x, oldY, x, Y1)

        return y, x_maincol        


# ----------------------------------------------------------------------------
# wxWindows callbacks
# ----------------------------------------------------------------------------

    def OnEraseBackground(self, event):
        """
        Handles the ``wx.EVT_ERASE_BACKGROUND`` event for L{TreeListMainWindow}.

        :param `event`: a `wx.EraseEvent` event to be processed.
        """

        # do not paint the background separately in buffered mode.
        if not self._buffered:
            CustomTreeCtrl.OnEraseBackground(self, event)


    def OnPaint(self, event):
        """
        Handles the ``wx.EVT_PAINT`` event for L{TreeListMainWindow}.

        :param `event`: a `wx.PaintEvent` event to be processed.
        """

        if self._buffered:

            # paint the background
            dc = wx.BufferedPaintDC(self)
            rect = self.GetUpdateRegion().GetBox()
            dc.SetClippingRect(rect)
            dc.SetBackground(wx.Brush(self.GetBackgroundColour()))
            if self._backgroundImage:
                self.TileBackground(dc)
            else:
                dc.Clear()

        else:
            dc = wx.PaintDC(self)

        self.PrepareDC(dc)

        if not self._anchor or self.GetColumnCount() <= 0:
            return

        # calculate button size
        if self._imageListButtons:
            self._btnWidth, self._btnHeight = self._imageListButtons.GetSize(0)
        elif self.HasButtons():
            self._btnWidth = _BTNWIDTH
            self._btnHeight = _BTNHEIGHT
        
        self._btnWidth2 = self._btnWidth/2
        self._btnHeight2 = self._btnHeight/2

        # calculate image size
        if self._imageListNormal:
            self._imgWidth, self._imgHeight = self._imageListNormal.GetSize(0)
        
        self._imgWidth2 = self._imgWidth/2
        self._imgHeight2 = self._imgHeight/2

        if self._imageListCheck:
            self._checkWidth, self._checkHeight = self._imageListCheck.GetSize(0)

        self._checkWidth2 = self._checkWidth/2
        self._checkHeight2 = self._checkHeight/2
            
        # calculate indent size
        if self._imageListButtons:
            self._indent = max(_MININDENT, self._btnWidth + _MARGIN)
        elif self.HasButtons():
            self._indent = max(_MININDENT, self._btnWidth + _LINEATROOT)
        
        # set default values
        dc.SetFont(self._normalFont)
        dc.SetPen(self._dottedPen)

        # calculate column start and paint
        x_maincol = 0
        for i in xrange(self.GetMainColumn()):
            if not self._owner.GetHeaderWindow().IsColumnShown(i):
                continue
            x_maincol += self._owner.GetHeaderWindow().GetColumnWidth(i)
        
        y, x_maincol = self.PaintLevel(self._anchor, dc, 0, 0, x_maincol)


    def HitTest(self, point, flags=0):
        """
        Calculates which (if any) item is under the given point, returning the tree item
        at this point plus extra information flags plus the item's column.

        :param `point`: an instance of `wx.Point`, a point to test for hits;
        :param `flags`: a bitlist of the following values:

         ================================== =============== =================================
         HitTest Flags                      Hex Value       Description
         ================================== =============== =================================
         ``TREE_HITTEST_ABOVE``                         0x1 Above the client area
         ``TREE_HITTEST_BELOW``                         0x2 Below the client area
         ``TREE_HITTEST_NOWHERE``                       0x4 No item has been hit
         ``TREE_HITTEST_ONITEMBUTTON``                  0x8 On the button associated to an item
         ``TREE_HITTEST_ONITEMICON``                   0x10 On the icon associated to an item
         ``TREE_HITTEST_ONITEMINDENT``                 0x20 On the indent associated to an item
         ``TREE_HITTEST_ONITEMLABEL``                  0x40 On the label (string) associated to an item
         ``TREE_HITTEST_ONITEM``                       0x50 Anywhere on the item
         ``TREE_HITTEST_ONITEMRIGHT``                  0x80 On the right of the label associated to an item
         ``TREE_HITTEST_TOLEFT``                      0x200 On the left of the client area
         ``TREE_HITTEST_TORIGHT``                     0x400 On the right of the client area
         ``TREE_HITTEST_ONITEMUPPERPART``             0x800 On the upper part (first half) of the item
         ``TREE_HITTEST_ONITEMLOWERPART``            0x1000 On the lower part (second half) of the item
         ``TREE_HITTEST_ONITEMCHECKICON``            0x2000 On the check/radio icon, if present
         ================================== =============== =================================

        :return: the item (if any, ``None`` otherwise), the `flags` and the column are always
         returned as a tuple.
        """

        w, h = self.GetSize()
        column = -1

        if not isinstance(point, wx.Point):
            point = wx.Point(*point)

        if point.x < 0:
            flags |= wx.TREE_HITTEST_TOLEFT
        if point.x > w:
            flags |= wx.TREE_HITTEST_TORIGHT
        if point.y < 0:
            flags |= wx.TREE_HITTEST_ABOVE
        if point.y > h:
            flags |= wx.TREE_HITTEST_BELOW
        if flags:
            return None, flags, column

        if not self._anchor:
            flags = wx.TREE_HITTEST_NOWHERE
            column = -1
            return None, flags, column
        
        hit, flags, column = self._anchor.HitTest(self.CalcUnscrolledPosition(point), self, flags, column, 0)
        if not hit:
            flags = wx.TREE_HITTEST_NOWHERE
            column = -1
            return None, flags, column
        
        return hit, flags, column


    def EditLabel(self, item, column=None):
        """
        Starts editing an item label.

        :param `item`: an instance of L{TreeListItem};
        :param `column`: if not ``None``, an integer specifying the column index.
         If it is ``None``, the main column index is used.        
        """

        if not item:
            return

        column = (column is not None and [column] or [self._main_column])[0]

        if column < 0 or column >= self.GetColumnCount():
            return

        self._editItem = item

        te = TreeEvent(wx.wxEVT_COMMAND_TREE_BEGIN_LABEL_EDIT, self._owner.GetId())
        te.SetItem(self._editItem)
        te.SetInt(column)
        te.SetEventObject(self._owner)
        self._owner.GetEventHandler().ProcessEvent(te)

        if not te.IsAllowed():
            return

        # ensure that the position of the item it calculated in any case
        if self._dirty:
            self.CalculatePositions()

        header_win = self._owner.GetHeaderWindow()
        alignment = header_win.GetColumnAlignment(column)
        if alignment == wx.ALIGN_LEFT:
            style = wx.TE_LEFT
        elif alignment == wx.ALIGN_RIGHT:
            style = wx.TE_RIGHT
        elif alignment == wx.ALIGN_CENTER:
            style = wx.TE_CENTER
            
        if self._textCtrl != None and (item != self._textCtrl.item() or column != self._textCtrl.column()):
            self._textCtrl.StopEditing()
            
        self._textCtrl = EditTextCtrl(self, -1, self._editItem, column,
                                      self, self._editItem.GetText(column),
                                      style=style|wx.TE_PROCESS_ENTER)
        self._textCtrl.SetFocus()


    def OnRenameTimer(self):
        """ The timer for renaming has expired. Start editing. """

        self.EditLabel(self._current, self._curColumn)


    def OnRenameAccept(self, value):
        """
        Called by L{EditTextCtrl}, to accept the changes and to send the
        ``EVT_TREE_END_LABEL_EDIT`` event.

        :param `value`: the new value of the item label.        
        """

        # TODO if the validator fails this causes a crash
        le = TreeEvent(wx.wxEVT_COMMAND_TREE_END_LABEL_EDIT, self._owner.GetId())
        le.SetItem(self._editItem)
        le.SetEventObject(self._owner)
        le.SetLabel(value)
        le._editCancelled = False
        self._owner.GetEventHandler().ProcessEvent(le)

        if not le.IsAllowed():
            return

        if self._curColumn == -1:
            self._curColumn = 0
           
        self.SetItemText(self._editItem, value, self._curColumn)


    def OnRenameCancelled(self):
        """
        Called by L{EditTextCtrl}, to cancel the changes and to send the
        ``EVT_TREE_END_LABEL_EDIT`` event.
        """

        # let owner know that the edit was cancelled
        le = TreeEvent(wx.wxEVT_COMMAND_TREE_END_LABEL_EDIT, self._owner.GetId())
        le.SetItem(self._editItem)
        le.SetEventObject(self._owner)
        le.SetLabel("")
        le._editCancelled = True

        self._owner.GetEventHandler().ProcessEvent(le)

    
    def OnMouse(self, event):
        """
        Handles the ``wx.EVT_MOUSE_EVENTS`` event for L{TreeListMainWindow}.

        :param `event`: a `wx.MouseEvent` event to be processed.
        """

        if not self._anchor:
            return

        # we process left mouse up event (enables in-place edit), right down
        # (pass to the user code), left dbl click (activate item) and
        # dragging/moving events for items drag-and-drop
        if not (event.LeftDown() or event.LeftUp() or event.RightDown() or \
                event.RightUp() or event.LeftDClick() or event.Dragging() or \
                event.GetWheelRotation() != 0 or event.Moving()):
            self._owner.GetEventHandler().ProcessEvent(event)
            return
        

        # set focus if window clicked
        if event.LeftDown() or event.RightDown():
            self._hasFocus = True
            self.SetFocusIgnoringChildren()

        # determine event
        p = wx.Point(event.GetX(), event.GetY())
        flags = 0
        item, flags, column = self._anchor.HitTest(self.CalcUnscrolledPosition(p), self, flags, self._curColumn, 0)

        underMouse = item
        underMouseChanged = underMouse != self._underMouse

        if underMouse and (flags & wx.TREE_HITTEST_ONITEM) and not event.LeftIsDown() and \
           not self._isDragging and (not self._renameTimer or not self._renameTimer.IsRunning()):
            underMouse = underMouse
        else:
            underMouse = None

        if underMouse != self._underMouse:
            if self._underMouse:
                # unhighlight old item
                self._underMouse = None
             
            self._underMouse = underMouse

        # Determines what item we are hovering over and need a tooltip for
        hoverItem = item

        if (event.LeftDown() or event.LeftUp() or event.RightDown() or \
            event.RightUp() or event.LeftDClick() or event.Dragging()):
            if self._textCtrl != None and item != self._textCtrl.item():
                self._textCtrl.StopEditing()

        # We do not want a tooltip if we are dragging, or if the rename timer is running
        if underMouseChanged and not self._isDragging and (not self._renameTimer or not self._renameTimer.IsRunning()):
            
            if hoverItem is not None:
                # Ask the tree control what tooltip (if any) should be shown
                hevent = TreeEvent(wx.wxEVT_COMMAND_TREE_ITEM_GETTOOLTIP, self.GetId())
                hevent.SetItem(hoverItem)
                hevent.SetEventObject(self)

                if self.GetEventHandler().ProcessEvent(hevent) and hevent.IsAllowed():
                    self.SetToolTip(hevent._label)

                if hoverItem.IsHyperText() and (flags & wx.TREE_HITTEST_ONITEMLABEL) and hoverItem.IsEnabled():
                    self.SetCursor(wx.StockCursor(wx.CURSOR_HAND))
                    self._isonhyperlink = True
                else:
                    if self._isonhyperlink:
                        self.SetCursor(wx.StockCursor(wx.CURSOR_ARROW))
                        self._isonhyperlink = False
                        
        # we only process dragging here
        if event.Dragging():
            
            if self._isDragging:
                if not self._dragImage:
                    # Create the custom draw image from the icons and the text of the item                    
                    self._dragImage = DragImage(self, self._current or item)
                    self._dragImage.BeginDrag(wx.Point(0,0), self)
                    self._dragImage.Show()

                self._dragImage.Move(p)

                if self._countDrag == 0 and item:
                    self._oldItem = self._current
                    self._oldSelection = self._current

                if item != self._dropTarget:
                        
                    # unhighlight the previous drop target
                    if self._dropTarget:
                        self._dropTarget.SetHilight(False)
                        self.RefreshLine(self._dropTarget)
                    if item:
                        item.SetHilight(True)
                        self.RefreshLine(item)
                        self._countDrag = self._countDrag + 1
                    self._dropTarget = item

                    self.Update()

                if self._countDrag >= 3 and self._oldItem is not None:
                    # Here I am trying to avoid ugly repainting problems... hope it works
                    self.RefreshLine(self._oldItem)
                    self._countDrag = 0
                    
                return # nothing to do, already done

            if item == None:
                return # we need an item to dragging

            # determine drag start
            if self._dragCount == 0:
                self._dragTimer.Start(_DRAG_TIMER_TICKS, wx.TIMER_ONE_SHOT)
            
            self._dragCount += 1
            if self._dragCount < 3:
                return # minimum drag 3 pixel
            if self._dragTimer.IsRunning():
                return

            # we're going to drag
            self._dragCount = 0

            # send drag start event
            command = (event.LeftIsDown() and [wx.wxEVT_COMMAND_TREE_BEGIN_DRAG] or [wx.wxEVT_COMMAND_TREE_BEGIN_RDRAG])[0]
            nevent = TreeEvent(command, self._owner.GetId())
            nevent.SetEventObject(self._owner)
            nevent.SetItem(self._current) # the dragged item
            nevent.SetPoint(p)
            nevent.Veto()         # dragging must be explicit allowed!
            
            if self.GetEventHandler().ProcessEvent(nevent) and nevent.IsAllowed():
                
                # we're going to drag this item
                self._isDragging = True
                self.CaptureMouse()
                self.RefreshSelected()

                # in a single selection control, hide the selection temporarily
                if not (self._agwStyle & wx.TR_MULTIPLE):
                    if self._oldSelection:
                    
                        self._oldSelection.SetHilight(False)
                        self.RefreshLine(self._oldSelection)
                else:
                    selections = self.GetSelections()
                    if len(selections) == 1:
                        self._oldSelection = selections[0]
                        self._oldSelection.SetHilight(False)
                        self.RefreshLine(self._oldSelection)

        elif self._isDragging:  # any other event but not event.Dragging()

            # end dragging
            self._dragCount = 0
            self._isDragging = False
            if self.HasCapture():
                self.ReleaseMouse()
            self.RefreshSelected()

            # send drag end event event
            nevent = TreeEvent(wx.wxEVT_COMMAND_TREE_END_DRAG, self._owner.GetId())
            nevent.SetEventObject(self._owner)
            nevent.SetItem(item) # the item the drag is started
            nevent.SetPoint(p)
            self._owner.GetEventHandler().ProcessEvent(nevent)
            
            if self._dragImage:
                self._dragImage.EndDrag()

            if self._dropTarget:
                self._dropTarget.SetHilight(False)
                self.RefreshLine(self._dropTarget)
                
            if self._oldSelection:
                self._oldSelection.SetHilight(True)
                self.RefreshLine(self._oldSelection)
                self._oldSelection = None

            self._isDragging = False
            self._dropTarget = None
            if self._dragImage:
                self._dragImage = None
            
            self.Refresh()

        elif self._dragCount > 0:  # just in case dragging is initiated

            # end dragging
            self._dragCount = 0

        # we process only the messages which happen on tree items
        if item == None or not self.IsItemEnabled(item):
            self._owner.GetEventHandler().ProcessEvent(event)
            return
        
        # remember item at shift down
        if event.ShiftDown():
            if not self._shiftItem:
                self._shiftItem = self._current
        else:
            self._shiftItem = None
        
        if event.RightUp():

            self.SetFocus()
            nevent = TreeEvent(wx.wxEVT_COMMAND_TREE_ITEM_RIGHT_CLICK, self._owner.GetId())
            nevent.SetEventObject(self._owner)
            nevent.SetItem(item) # the item clicked
            nevent.SetInt(self._curColumn) # the column clicked
            nevent.SetPoint(p)
            self._owner.GetEventHandler().ProcessEvent(nevent)

        elif event.LeftUp():

            if self._lastOnSame:
                if item == self._current and self._curColumn != -1 and \
                   self._owner.GetHeaderWindow().IsColumnEditable(self._curColumn) and \
                   flags & (wx.TREE_HITTEST_ONITEMLABEL | wx.TREE_HITTEST_ONITEMCOLUMN):
                    self._renameTimer.Start(_RENAME_TIMER_TICKS, wx.TIMER_ONE_SHOT)
                
                self._lastOnSame = False
            
            if (((flags & wx.TREE_HITTEST_ONITEMBUTTON) or (flags & wx.TREE_HITTEST_ONITEMICON)) and \
                self.HasButtons() and item.HasPlus()):

                # only toggle the item for a single click, double click on
                # the button doesn't do anything (it toggles the item twice)
                if event.LeftDown():
                    self.Toggle(item)

                # don't select the item if the button was clicked
                return         
            
            # determine the selection if not done by left down
            if not self._left_down_selection:
                unselect_others = not ((event.ShiftDown() or event.ControlDown()) and self.HasAGWFlag(wx.TR_MULTIPLE))
                self.DoSelectItem(item, unselect_others, event.ShiftDown())
                self.EnsureVisible (item)
                self._current = self._key_current = item # make the new item the current item
            else:
                self._left_down_selection = False
            
        elif event.LeftDown() or event.RightDown() or event.LeftDClick():

            if column >= 0:
                self._curColumn = column
            
            if event.LeftDown() or event.RightDown():
                self.SetFocus()
                self._lastOnSame = item == self._current
            
            if (((flags & wx.TREE_HITTEST_ONITEMBUTTON) or (flags & wx.TREE_HITTEST_ONITEMICON)) and \
                self.HasButtons() and item.HasPlus()):

                # only toggle the item for a single click, double click on
                # the button doesn't do anything (it toggles the item twice)
                if event.LeftDown():
                    self.Toggle(item)

                # don't select the item if the button was clicked
                return

            if flags & TREE_HITTEST_ONITEMCHECKICON and event.LeftDown():
                if item.GetType() > 0:
                    if self.IsItem3State(item):
                        checked = self.GetItem3StateValue(item)
                        checked = (checked+1)%3
                    else:
                        checked = not self.IsItemChecked(item)

                    self.CheckItem(item, checked)
                    return
                
            # determine the selection if the current item is not selected
            if not item.IsSelected():
                unselect_others = not ((event.ShiftDown() or event.ControlDown()) and self.HasAGWFlag(wx.TR_MULTIPLE))
                self.DoSelectItem(item, unselect_others, event.ShiftDown())
                self.EnsureVisible(item)
                self._current = self._key_current = item # make the new item the current item
                self._left_down_selection = True
            
            # For some reason, Windows isn't recognizing a left double-click,
            # so we need to simulate it here.  Allow 200 milliseconds for now.
            if event.LeftDClick():

                # double clicking should not start editing the item label
                self._renameTimer.Stop()
                self._lastOnSame = False

                # send activate event first
                nevent = TreeEvent(wx.wxEVT_COMMAND_TREE_ITEM_ACTIVATED, self._owner.GetId())
                nevent.SetEventObject(self._owner)
                nevent.SetItem(item) # the item clicked
                nevent.SetInt(self._curColumn) # the column clicked
                nevent.SetPoint(p)
                if not self._owner.GetEventHandler().ProcessEvent(nevent):

                    # if the user code didn't process the activate event,
                    # handle it ourselves by toggling the item when it is
                    # double clicked
                    if item.HasPlus():
                        self.Toggle(item)
                
        else: # any other event skip just in case

            event.Skip()

        
    def OnScroll(self, event):
        """
        Handles the ``wx.EVT_SCROLLWIN`` event for L{TreeListMainWindow}.

        :param `event`: a `wx.ScrollEvent` event to be processed.
        """

        # Let wx.PyScrolledWindow compute the new scroll position so that
        # TreeListHeaderWindow is repainted with the same scroll position as
        # TreeListMainWindow.
        #
        # event.Skip() would not work, Update() would call
        # TreeListHeaderWindow.OnPaint() synchronously, before
        # wx.PyScrolledWindow.OnScroll() is called by the event handler. OnPaint()
        # would not use the latest scroll position so the header and the tree
        # scrolling positions would be unsynchronized.
        self._default_evt_handler.ProcessEvent(event)
        
        if event.GetOrientation() == wx.HORIZONTAL:
            self._owner.GetHeaderWindow().Refresh()
            self._owner.GetHeaderWindow().Update()
        

    def CalculateSize(self, item, dc):
        """
        Calculates overall position and size of an item.

        :param `item`: an instance of L{TreeListItem};
        :param `dc`: an instance of `wx.DC`.
        """

        attr = item.GetAttributes()

        if attr and attr.HasFont():
            dc.SetFont(attr.GetFont())
        elif item.IsBold():
            dc.SetFont(self._boldFont)
        else:
            dc.SetFont(self._normalFont)

        text_w = text_h = wnd_w = wnd_h = 0
        for column in xrange(self.GetColumnCount()):
            w, h, dummy = dc.GetMultiLineTextExtent(item.GetText(column))
            text_w, text_h = max(w, text_w), max(h, text_h)
            
            wnd = item.GetWindow(column)
            if wnd:
                wnd_h = max(wnd_h, item.GetWindowSize(column)[1])
                if column == self._main_column:
                    wnd_w = item.GetWindowSize(column)[0]

        text_w, dummy, dummy = dc.GetMultiLineTextExtent(item.GetText(self._main_column))
        text_h+=2

        # restore normal font
        dc.SetFont(self._normalFont)

        image_w, image_h = 0, 0
        image = item.GetCurrentImage()

        if image != _NO_IMAGE:
        
            if self._imageListNormal:
            
                image_w, image_h = self._imageListNormal.GetSize(image)
                image_w += 2*_MARGIN

        total_h = ((image_h > text_h) and [image_h] or [text_h])[0]

        checkimage = item.GetCurrentCheckedImage()
        if checkimage is not None:
            wcheck, hcheck = self._imageListCheck.GetSize(checkimage)
            wcheck += 2*_MARGIN
        else:
            wcheck = 0

        if total_h < 30:
            total_h += 2            # at least 2 pixels
        else:
            total_h += total_h/10   # otherwise 10% extra spacing

        if total_h > self._lineHeight:
            self._lineHeight = max(total_h, wnd_h+2)

        item.SetWidth(image_w+text_w+wcheck+2+wnd_w)
        item.SetHeight(max(total_h, wnd_h+2))

        
    def CalculateLevel(self, item, dc, level, y, x_colstart):
        """
        Calculates the level of an item inside the tree hierarchy.

        :param `item`: an instance of L{TreeListItem};
        :param `dc`: an instance of `wx.DC`;
        :param `level`: the item level in the tree hierarchy;
        :param `y`: the current vertical position inside the `wx.PyScrolledWindow`;
        :param `x_colstart`: the x coordinate at which the item's column starts.
        """

        # calculate position of vertical lines
        x = x_colstart + _MARGIN # start of column
        if self.HasAGWFlag(wx.TR_LINES_AT_ROOT):
            x += _LINEATROOT # space for lines at root
        if self.HasButtons():
            x += (self._btnWidth-self._btnWidth2) # half button space
        else:
            x += (self._indent-self._indent/2)
        
        if self.HasAGWFlag(wx.TR_HIDE_ROOT):
            x += self._indent * (level-1) # indent but not level 1
        else:
            x += self._indent * level # indent according to level
        
        # a hidden root is not evaluated, but its children are always
        if self.HasAGWFlag(wx.TR_HIDE_ROOT) and (level == 0):
            # a hidden root is not evaluated, but its
            # children are always calculated
            children = item.GetChildren()
            count = len(children)
            level = level + 1
            for n in xrange(count):
                y = self.CalculateLevel(children[n], dc, level, y, x_colstart)  # recurse
                
            return y

        self.CalculateSize(item, dc)

        # set its position
        item.SetX(x)
        item.SetY(y)
        y += self.GetLineHeight(item)

        if not item.IsExpanded():
            # we don't need to calculate collapsed branches
            return y

        children = item.GetChildren()
        count = len(children)
        level = level + 1
        for n in xrange(count):
            y = self.CalculateLevel(children[n], dc, level, y, x_colstart)  # recurse
        
        return y
    

    def CalculatePositions(self):
        """ Recalculates all the items positions. """
        
        if not self._anchor:
            return

        dc = wx.ClientDC(self)
        self.PrepareDC(dc)

        dc.SetFont(self._normalFont)
        dc.SetPen(self._dottedPen)

        y, x_colstart = 2, 0
        for i in xrange(self.GetMainColumn()):
            if not self._owner.GetHeaderWindow().IsColumnShown(i):
                continue
            x_colstart += self._owner.GetHeaderWindow().GetColumnWidth(i)
        
        self.CalculateLevel(self._anchor, dc, 0, y, x_colstart) # start recursion


    def SetItemText(self, item, text, column=None):
        """
        Sets the item text label.

        :param `item`: an instance of L{TreeListItem};
        :param `text`: a string specifying the new item label;
        :param `column`: if not ``None``, an integer specifying the column index.
         If it is ``None``, the main column index is used.
        """

        dc = wx.ClientDC(self)
        item.SetText(column, text)
        self.CalculateSize(item, dc)
        self.RefreshLine(item)


    def GetItemText(self, item, column=None):
        """
        Returns the item text label.

        :param `item`: an instance of L{TreeListItem};
        :param `column`: if not ``None``, an integer specifying the column index.
         If it is ``None``, the main column index is used.
        """

        if self.IsVirtual():
            return self._owner.OnGetItemText(item, column)
        else:
            return item.GetText(column)
   

    def GetItemWidth(self, item, column):
        """
        Returns the item width.

        :param `item`: an instance of L{TreeListItem};
        :param `column`: an integer specifying the column index.
        """
        
        if not item:
            return 0

        # determine item width
        font = self.GetItemFont(item)
        if not font.IsOk():
            if item.IsBold():
                font = self._boldFont
            elif item.IsItalic():
                font = self._italicFont
            elif item.IsHyperText():
                font = self.GetHyperTextFont()
            else:
                font = self._normalFont
            
        dc = wx.ClientDC(self)
        dc.SetFont(font)
        w, h, dummy = dc.GetMultiLineTextExtent(item.GetText(column))
        w += 2*_MARGIN

        # calculate width
        width = w + 2*_MARGIN
        if column == self.GetMainColumn():
            width += _MARGIN
            if self.HasAGWFlag(wx.TR_LINES_AT_ROOT):
                width += _LINEATROOT
            if self.HasButtons():
                width += self._btnWidth + _LINEATROOT
            if item.GetCurrentImage() != _NO_IMAGE:
                width += self._imgWidth

            # count indent level
            level = 0
            parent = item.GetParent()
            root = self.GetRootItem()
            while (parent and (not self.HasAGWFlag(wx.TR_HIDE_ROOT) or (parent != root))):
                level += 1
                parent = parent.GetParent()
            
            if level:
                width += level*self.GetIndent()

        wnd = item.GetWindow(column)
        if wnd:
            width += wnd.GetSize()[0] + 2*_MARGIN
            
        return width


    def GetBestColumnWidth(self, column, parent=None):
        """
        Returns the best column's width based on the items width in this column.

        :param `column`: an integer specifying the column index;
        :param `parent`: an instance of L{TreeListItem}.
        """

        maxWidth, h = self.GetClientSize()
        width = 0

        # get root if on item
        if not parent:
            parent = self.GetRootItem()

        # add root width
        if not self.HasAGWFlag(wx.TR_HIDE_ROOT):
            w = self.GetItemWidth(parent, column)
            if width < w:
                width = w
            if width > maxWidth:
                return maxWidth

        item, cookie = self.GetFirstChild(parent)
        while item:
            w = self.GetItemWidth(item, column)
            if width < w:
                width = w
            if width > maxWidth:
                return maxWidth

            # check the children of this item
            if item.IsExpanded():
                w = self.GetBestColumnWidth(column, item)
                if width < w:
                    width = w
                if width > maxWidth:
                    return maxWidth

            # next sibling
            item, cookie = self.GetNextChild(parent, cookie)
        
        return width


    def HideItem(self, item, hide=True):
        """
        Hides/shows an item.

        :param `item`: an instance of L{TreeListItem};
        :param `hide`: ``True`` to hide the item, ``False`` to show it.
        """

        item.Hide(hide)
        self.Refresh()
        

#----------------------------------------------------------------------------
# TreeListCtrl - the multicolumn tree control
#----------------------------------------------------------------------------

_methods = ["GetIndent", "SetIndent", "GetSpacing", "SetSpacing", "GetImageList", "GetStateImageList",
            "GetButtonsImageList", "AssignImageList", "AssignStateImageList", "AssignButtonsImageList",
            "SetImageList", "SetButtonsImageList", "SetStateImageList",
            "GetItemText", "GetItemImage", "GetItemPyData", "GetPyData", "GetItemTextColour",
            "GetItemBackgroundColour", "GetItemFont", "SetItemText", "SetItemImage", "SetItemPyData", "SetPyData",
            "SetItemHasChildren", "SetItemBackgroundColour", "SetItemFont", "IsItemVisible", "HasChildren",
            "IsExpanded", "IsSelected", "IsBold", "GetChildrenCount", "GetRootItem", "GetSelection", "GetSelections",
            "GetItemParent", "GetFirstChild", "GetNextChild", "GetPrevChild", "GetLastChild", "GetNextSibling",
            "GetPrevSibling", "GetNext", "GetFirstExpandedItem", "GetNextExpanded", "GetPrevExpanded",
            "GetFirstVisibleItem", "GetNextVisible", "GetPrevVisible", "AddRoot", "PrependItem", "InsertItem",
            "AppendItem", "Delete", "DeleteChildren", "DeleteRoot", "Expand", "ExpandAll", "ExpandAllChildren",
            "Collapse", "CollapseAndReset", "Toggle", "Unselect", "UnselectAll", "SelectItem", "SelectAll",
            "EnsureVisible", "ScrollTo", "HitTest", "GetBoundingRect", "EditLabel", "FindItem", "SelectAllChildren",
            "SetDragItem", "GetColumnCount", "SetMainColumn", "GetHyperTextFont", "SetHyperTextFont",
            "SetHyperTextVisitedColour", "GetHyperTextVisitedColour", "SetHyperTextNewColour", "GetHyperTextNewColour",
            "SetItemVisited", "GetItemVisited", "SetHilightFocusColour", "GetHilightFocusColour", "SetHilightNonFocusColour",
            "GetHilightNonFocusColour", "SetFirstGradientColour", "GetFirstGradientColour", "SetSecondGradientColour",
            "GetSecondGradientColour", "EnableSelectionGradient", "SetGradientStyle", "GetGradientStyle",
            "EnableSelectionVista", "SetBorderPen", "GetBorderPen", "SetConnectionPen", "GetConnectionPen",
            "SetBackgroundImage", "GetBackgroundImage", "SetImageListCheck", "GetImageListCheck", "EnableChildren",
            "EnableItem", "IsItemEnabled", "GetDisabledColour", "SetDisabledColour", "IsItemChecked",
            "UnCheckRadioParent", "CheckItem", "CheckItem2", "AutoToggleChild", "AutoCheckChild", "AutoCheckParent",
            "CheckChilds", "CheckSameLevel", "GetItemWindowEnabled", "SetItemWindowEnabled", "GetItemType",
            "IsDescendantOf", "SetItemHyperText", "IsItemHyperText", "SetItemBold", "SetItemDropHighlight", "SetItemItalic",
            "GetEditControl", "ShouldInheritColours", "GetItemWindow", "SetItemWindow", "SetItemTextColour", "HideItem",
            "DeleteAllItems", "ItemHasChildren", "ToggleItemSelection", "SetItemType", "GetCurrentItem",
            "SetItem3State", "SetItem3StateValue", "GetItem3StateValue", "IsItem3State"]


class HyperTreeList(wx.PyControl):
    """
    HyperTreeList is a class that mimics the behaviour of `wx.gizmos.TreeListCtrl`, with
    almost the same base functionalities plus some more enhancements. This class does
    not rely on the native control, as it is a full owner-drawn tree-list control.
    """
    
    def __init__(self, parent, id=wx.ID_ANY, pos=wx.DefaultPosition, size=wx.DefaultSize,
                 style=0, agwStyle=wx.TR_DEFAULT_STYLE, validator=wx.DefaultValidator,
                 name="HyperTreeList"):
        """
        Default class constructor.
        
        :param `parent`: parent window. Must not be ``None``;
        :param `id`: window identifier. A value of -1 indicates a default value;
        :param `pos`: the control position. A value of (-1, -1) indicates a default position,
         chosen by either the windowing system or wxPython, depending on platform;
        :param `size`: the control size. A value of (-1, -1) indicates a default size,
         chosen by either the windowing system or wxPython, depending on platform;
        :param `style`: the underlying `wx.PyScrolledWindow` style;
        :param `agwStyle`: the AGW-specific L{HyperTreeList} window style. This can be a combination
         of the following bits:
        
         ============================== =========== ==================================================
         Window Styles                  Hex Value   Description
         ============================== =========== ==================================================
         ``TR_NO_BUTTONS``                      0x0 For convenience to document that no buttons are to be drawn.
         ``TR_SINGLE``                          0x0 For convenience to document that only one item may be selected at a time. Selecting another item causes the current selection, if any, to be deselected. This is the default.
         ``TR_HAS_BUTTONS``                     0x1 Use this style to show + and - buttons to the left of parent items.
         ``TR_NO_LINES``                        0x4 Use this style to hide vertical level connectors.
         ``TR_LINES_AT_ROOT``                   0x8 Use this style to show lines between root nodes. Only applicable if ``TR_HIDE_ROOT`` is set and ``TR_NO_LINES`` is not set.
         ``TR_DEFAULT_STYLE``                   0x9 No Docs
         ``TR_TWIST_BUTTONS``                  0x10 Use old Mac-twist style buttons.
         ``TR_MULTIPLE``                       0x20 Use this style to allow a range of items to be selected. If a second range is selected, the current range, if any, is deselected.
         ``TR_EXTENDED``                       0x40 Use this style to allow disjoint items to be selected. (Only partially implemented; may not work in all cases).
         ``TR_HAS_VARIABLE_ROW_HEIGHT``        0x80 Use this style to cause row heights to be just big enough to fit the content. If not set, all rows use the largest row height. The default is that this flag is unset.
         ``TR_EDIT_LABELS``                   0x200 Use this style if you wish the user to be able to edit labels in the tree control.
         ``TR_ROW_LINES``                     0x400 Use this style to draw a contrasting border between displayed rows.
         ``TR_HIDE_ROOT``                     0x800 Use this style to suppress the display of the root node, effectively causing the first-level nodes to appear as a series of root nodes.
         ``TR_COLUMN_LINES``                 0x1000 No Docs
         ``TR_FULL_ROW_HIGHLIGHT``           0x2000 Use this style to have the background colour and the selection highlight extend  over the entire horizontal row of the tree control window.
         ``TR_AUTO_CHECK_CHILD``             0x4000 Only meaningful foe checkbox-type items: when a parent item is checked/unchecked its children are checked/unchecked as well.
         ``TR_AUTO_TOGGLE_CHILD``            0x8000 Only meaningful foe checkbox-type items: when a parent item is checked/unchecked its children are toggled accordingly.
         ``TR_AUTO_CHECK_PARENT``           0x10000 Only meaningful foe checkbox-type items: when a child item is checked/unchecked its parent item is checked/unchecked as well.
         ``TR_ALIGN_WINDOWS``               0x20000 Flag used to align windows (in items with windows) at the same horizontal position.
         ``TR_NO_HEADER``                   0x40000 Use this style to hide the columns header.
         ``TR_VIRTUAL``                     0x80000 L{HyperTreeList} will have virtual behaviour.
         ============================== =========== ==================================================

        :param `validator`: window validator;
        :param `name`: window name.
        """

        wx.PyControl.__init__(self, parent, id, pos, size, style, validator, name)

        self._header_win = None
        self._main_win = None
        self._headerHeight = 0
        self._attr_set = False
        
        main_style = style & ~(wx.SIMPLE_BORDER|wx.SUNKEN_BORDER|wx.DOUBLE_BORDER|
                               wx.RAISED_BORDER|wx.STATIC_BORDER)

        self._agwStyle = agwStyle
        
        self._main_win = TreeListMainWindow(self, -1, wx.Point(0, 0), size, main_style, agwStyle, validator)
        self._main_win._buffered = False

        self._header_win = TreeListHeaderWindow(self, -1, self._main_win, wx.Point(0, 0),
                                                wx.DefaultSize, wx.TAB_TRAVERSAL)
        self._header_win._buffered = False
        
        self.CalculateAndSetHeaderHeight()
        self.Bind(wx.EVT_SIZE, self.OnSize)

        self.SetBuffered(IsBufferingSupported())
        self._main_win.SetAGWWindowStyleFlag(agwStyle)
        

    def SetBuffered(self, buffered):
        """
        Sets/unsets the double buffering for the header and the main window.

        :param `buffered`: ``True`` to use double-buffering, ``False`` otherwise.

        :note: Currently we are using double-buffering only on Windows XP.
        """

        self._main_win.SetBuffered(buffered)
        self._header_win.SetBuffered(buffered)


    def CalculateAndSetHeaderHeight(self):
        """ Calculates the best header height and stores it. """

        if self._header_win:
            h = wx.RendererNative.Get().GetHeaderButtonHeight(self._header_win)
            # only update if changed
            if h != self._headerHeight:
                self._headerHeight = h
                self.DoHeaderLayout()
            

    def DoHeaderLayout(self):
        """ Layouts the header control. """

        w, h = self.GetClientSize()
        has_header = self._agwStyle & TR_NO_HEADER == 0
        
        if self._header_win and has_header:
            self._header_win.SetDimensions(0, 0, w, self._headerHeight)
            self._header_win.Refresh()
        else:
            self._header_win.SetDimensions(0, 0, 0, 0)
        
        if self._main_win and has_header:
            self._main_win.SetDimensions(0, self._headerHeight + 1, w, h - self._headerHeight - 1)
        else:
            self._main_win.SetDimensions(0, 0, w, h)
    

    def OnSize(self, event):
        """
        Handles the ``wx.EVT_SIZE`` event for L{HyperTreeList}.

        :param `event`: a `wx.SizeEvent` event to be processed.
        """

        self.DoHeaderLayout()


    def SetFont(self, font):
        """
        Sets the default font for the header window and the main window.

        :param `font`: a valid `wx.Font` object.
        """
        
        if self._header_win:
            self._header_win.SetFont(font)
            self.CalculateAndSetHeaderHeight()
            self._header_win.Refresh()
        
        if self._main_win:
            return self._main_win.SetFont(font)
        else:
            return False


    def SetHeaderFont(self, font):
        """
        Sets the default font for the header window..

        :param `font`: a valid `wx.Font` object.
        """

        if not self._header_win:
            return
        
        for column in xrange(self.GetColumnCount()):
            self._header_win.SetColumn(column, self.GetColumn(column).SetFont(font))

        self._header_win.Refresh()

    
    def SetHeaderCustomRenderer(self, renderer=None):
        """
        Associate a custom renderer with the header - all columns will use it

        :param `renderer`: a class able to correctly render header buttons

        :note: the renderer class **must** implement the method `DrawHeaderButton`
        """

        self._header_win.SetCustomRenderer(renderer)
        

    def SetAGWWindowStyleFlag(self, agwStyle):
        """
        Sets the window style for L{HyperTreeList}.

        :param `agwStyle`: can be a combination of the following bits:

         ============================== =========== ==================================================
         Window Styles                  Hex Value   Description
         ============================== =========== ==================================================
         ``TR_NO_BUTTONS``                      0x0 For convenience to document that no buttons are to be drawn.
         ``TR_SINGLE``                          0x0 For convenience to document that only one item may be selected at a time. Selecting another item causes the current selection, if any, to be deselected. This is the default.
         ``TR_HAS_BUTTONS``                     0x1 Use this style to show + and - buttons to the left of parent items.
         ``TR_NO_LINES``                        0x4 Use this style to hide vertical level connectors.
         ``TR_LINES_AT_ROOT``                   0x8 Use this style to show lines between root nodes. Only applicable if ``TR_HIDE_ROOT`` is set and ``TR_NO_LINES`` is not set.
         ``TR_DEFAULT_STYLE``                   0x9 No Docs
         ``TR_TWIST_BUTTONS``                  0x10 Use old Mac-twist style buttons.
         ``TR_MULTIPLE``                       0x20 Use this style to allow a range of items to be selected. If a second range is selected, the current range, if any, is deselected.
         ``TR_EXTENDED``                       0x40 Use this style to allow disjoint items to be selected. (Only partially implemented; may not work in all cases).
         ``TR_HAS_VARIABLE_ROW_HEIGHT``        0x80 Use this style to cause row heights to be just big enough to fit the content. If not set, all rows use the largest row height. The default is that this flag is unset.
         ``TR_EDIT_LABELS``                   0x200 Use this style if you wish the user to be able to edit labels in the tree control.
         ``TR_ROW_LINES``                     0x400 Use this style to draw a contrasting border between displayed rows.
         ``TR_HIDE_ROOT``                     0x800 Use this style to suppress the display of the root node, effectively causing the first-level nodes to appear as a series of root nodes.
         ``TR_COLUMN_LINES``                 0x1000 No Docs
         ``TR_FULL_ROW_HIGHLIGHT``           0x2000 Use this style to have the background colour and the selection highlight extend  over the entire horizontal row of the tree control window.
         ``TR_AUTO_CHECK_CHILD``             0x4000 Only meaningful foe checkbox-type items: when a parent item is checked/unchecked its children are checked/unchecked as well.
         ``TR_AUTO_TOGGLE_CHILD``            0x8000 Only meaningful foe checkbox-type items: when a parent item is checked/unchecked its children are toggled accordingly.
         ``TR_AUTO_CHECK_PARENT``           0x10000 Only meaningful foe checkbox-type items: when a child item is checked/unchecked its parent item is checked/unchecked as well.
         ``TR_ALIGN_WINDOWS``               0x20000 Flag used to align windows (in items with windows) at the same horizontal position.
         ``TR_NO_HEADER``                   0x40000 Use this style to hide the columns header.
         ``TR_VIRTUAL``                     0x80000 L{HyperTreeList} will have virtual behaviour.
         ============================== =========== ==================================================
         
        :note: Please note that some styles cannot be changed after the window creation
         and that `Refresh()` might need to be be called after changing the others for
         the change to take place immediately.
        """
        
        if self._main_win:
            self._main_win.SetAGWWindowStyleFlag(agwStyle)

        tmp = self._agwStyle
        self._agwStyle = agwStyle
        if abs(agwStyle - tmp) & TR_NO_HEADER:
            self.DoHeaderLayout()
            

    def GetAGWWindowStyleFlag(self):
        """
        Returns the L{HyperTreeList} window style flag.

        :see: L{SetAGWWindowStyleFlag} for a list of valid window styles.
        """

        agwStyle = self._agwStyle
        if self._main_win:
            agwStyle |= self._main_win.GetAGWWindowStyleFlag()
            
        return agwStyle


    def HasAGWFlag(self, flag):
        """
        Returns whether a flag is present in the L{HyperTreeList} style.

        :param `flag`: one of the possible L{HyperTreeList} window styles.

        :see: L{SetAGWWindowStyleFlag} for a list of possible window style flags.
        """

        agwStyle = self.GetAGWWindowStyleFlag()
        res = (agwStyle & flag and [True] or [False])[0]
        return res


    def SetBackgroundColour(self, colour):
        """
        Changes the background colour of L{HyperTreeList}.

        :param `colour`: the colour to be used as the background colour, pass
         `wx.NullColour` to reset to the default colour.

        :note: The background colour is usually painted by the default `wx.EraseEvent`
         event handler function under Windows and automatically under GTK.

        :note: Setting the background colour does not cause an immediate refresh, so
         you may wish to call `wx.Window.ClearBackground` or `wx.Window.Refresh` after
         calling this function.

        :note: Overridden from `wx.PyControl`.         
        """

        if not self._main_win:
            return False
        
        return self._main_win.SetBackgroundColour(colour)


    def SetForegroundColour(self, colour):
        """
        Changes the foreground colour of L{HyperTreeList}.

        :param `colour`: the colour to be used as the foreground colour, pass
         `wx.NullColour` to reset to the default colour.

        :note: Overridden from `wx.PyControl`.         
        """

        if not self._main_win:
            return False
        
        return self._main_win.SetForegroundColour(colour)


    def SetColumnWidth(self, column, width):
        """
        Sets the column width, in pixels.

        :param `column`: an integer specifying the column index;
        :param `width`: the new column width, in pixels.
        """

        if width == wx.LIST_AUTOSIZE_USEHEADER:
        
            font = self._header_win.GetFont()
            dc = wx.ClientDC(self._header_win)
            width, dummy, dummy = dc.GetMultiLineTextExtent(self._header_win.GetColumnText(column))
            # Search TreeListHeaderWindow.OnPaint to understand this:
            width += 2*_EXTRA_WIDTH + _MARGIN
        
        elif width == wx.LIST_AUTOSIZE:
        
            width = self._main_win.GetBestColumnWidth(column)
        
        self._header_win.SetColumnWidth(column, width)
        self._header_win.Refresh()


    def GetColumnWidth(self, column):
        """
        Returns the column width, in pixels.

        :param `column`: an integer specifying the column index.
        """

        return self._header_win.GetColumnWidth(column)

        
    def SetColumnText(self, column, text):
        """
        Sets the column text label.

        :param `column`: an integer specifying the column index;
        :param `text`: the new column label.
        """

        self._header_win.SetColumnText(column, text)
        self._header_win.Refresh()


    def GetColumnText(self, column):
        """
        Returns the column text label.

        :param `column`: an integer specifying the column index.
        """

        return self._header_win.GetColumnText(column)


    def AddColumn(self, text, width=_DEFAULT_COL_WIDTH, flag=wx.ALIGN_LEFT,
                  image=-1, shown=True, colour=None, edit=False):
        """
        Appends a column to the L{HyperTreeList}.

        :param `text`: the column text label;
        :param `width`: the column width in pixels;
        :param `flag`: the column alignment flag, one of ``wx.ALIGN_LEFT``,
         ``wx.ALIGN_RIGHT``, ``wx.ALIGN_CENTER``;
        :param `image`: an index within the normal image list assigned to
         L{HyperTreeList} specifying the image to use for the column;
        :param `shown`: ``True`` to show the column, ``False`` to hide it;
        :param `colour`: a valid `wx.Colour`, representing the text foreground colour
         for the column;
        :param `edit`: ``True`` to set the column as editable, ``False`` otherwise.
        """

        self._header_win.AddColumn(text, width, flag, image, shown, colour, edit)
        self.DoHeaderLayout()
        

    def AddColumnInfo(self, colInfo):
        """
        Appends a column to the L{HyperTreeList}.

        :param `colInfo`: an instance of L{TreeListColumnInfo}.
        """

        self._header_win.AddColumnInfo(colInfo)
        self.DoHeaderLayout()


    def InsertColumnInfo(self, before, colInfo):
        """
        Inserts a column to the L{HyperTreeList} at the position specified
        by `before`.

        :param `before`: the index at which we wish to insert the new column;
        :param `colInfo`: an instance of L{TreeListColumnInfo}.
        """

        self._header_win.InsertColumnInfo(before, colInfo)
        self._header_win.Refresh()


    def InsertColumn(self, before, text, width=_DEFAULT_COL_WIDTH,
                     flag=wx.ALIGN_LEFT, image=-1, shown=True, colour=None, 
                     edit=False):
        """
        Inserts a column to the L{HyperTreeList} at the position specified
        by `before`.

        :param `before`: the index at which we wish to insert the new column;
        :param `text`: the column text label;
        :param `width`: the column width in pixels;
        :param `flag`: the column alignment flag, one of ``wx.ALIGN_LEFT``,
         ``wx.ALIGN_RIGHT``, ``wx.ALIGN_CENTER``;
        :param `image`: an index within the normal image list assigned to
         L{HyperTreeList} specifying the image to use for the column;
        :param `shown`: ``True`` to show the column, ``False`` to hide it;
        :param `colour`: a valid `wx.Colour`, representing the text foreground colour
         for the column;
        :param `edit`: ``True`` to set the column as editable, ``False`` otherwise.        
        """

        self._header_win.InsertColumn(before, text, width, flag, image,
                                      shown, colour, edit)
        self._header_win.Refresh()


    def RemoveColumn(self, column):
        """
        Removes a column from the L{HyperTreeList}.

        :param `column`: an integer specifying the column index.
        """

        self._header_win.RemoveColumn(column)
        self._header_win.Refresh()


    def SetColumn(self, column, colInfo):
        """
        Sets a column using an instance of L{TreeListColumnInfo}.

        :param `column`: an integer specifying the column index;
        :param `info`: an instance of L{TreeListColumnInfo}.        
        """

        self._header_win.SetColumn(column, colInfo)
        self._header_win.Refresh()
            

    def GetColumn(self, column):
        """
        Returns an instance of L{TreeListColumnInfo} containing column information.

        :param `column`: an integer specifying the column index.
        """
        
        return self._header_win.GetColumn(column)


    def SetColumnImage(self, column, image):
        """
        Sets an image on the specified column.

        :param `column`: an integer specifying the column index.
        :param `image`: an index within the normal image list assigned to
         L{HyperTreeList} specifying the image to use for the column.
        """                

        self._header_win.SetColumn(column, self.GetColumn(column).SetImage(image))
        self._header_win.Refresh()


    def GetColumnImage(self, column):
        """
        Returns the image assigned to the specified column.

        :param `column`: an integer specifying the column index.
        """

        return self._header_win.GetColumn(column).GetImage()


    def SetColumnEditable(self, column, edit):
        """
        Sets the column as editable or non-editable.

        :param `column`: an integer specifying the column index;
        :param `edit`: ``True`` if the column should be editable, ``False`` otherwise.
        """

        self._header_win.SetColumn(column, self.GetColumn(column).SetEditable(edit))


    def SetColumnShown(self, column, shown):
        """
        Sets the column as shown or hidden.

        :param `column`: an integer specifying the column index;
        :param `shown`: ``True`` if the column should be shown, ``False`` if it
         should be hidden.
        """

        if self._main_win.GetMainColumn() == column:
            shown = True # Main column cannot be hidden
            
        self.SetColumn(column, self.GetColumn(column).SetShown(shown))


    def IsColumnEditable(self, column):
        """
        Returns ``True`` if the column is editable, ``False`` otherwise.

        :param `column`: an integer specifying the column index.
        """

        return self._header_win.GetColumn(column).IsEditable()


    def IsColumnShown(self, column):
        """
        Returns ``True`` if the column is shown, ``False`` otherwise.

        :param `column`: an integer specifying the column index.
        """

        return self._header_win.GetColumn(column).IsShown()


    def SetColumnAlignment(self, column, flag):
        """
        Sets the column text alignment.

        :param `column`: an integer specifying the column index;
        :param `flag`: the alignment flag, one of ``wx.ALIGN_LEFT``, ``wx.ALIGN_RIGHT``,
         ``wx.ALIGN_CENTER``.
        """

        self._header_win.SetColumn(column, self.GetColumn(column).SetAlignment(flag))
        self._header_win.Refresh()


    def GetColumnAlignment(self, column):
        """
        Returns the column text alignment.

        :param `column`: an integer specifying the column index.
        """
        
        return self._header_win.GetColumn(column).GetAlignment()


    def SetColumnColour(self, column, colour):
        """
        Sets the column text colour.

        :param `column`: an integer specifying the column index;
        :param `colour`: a valid `wx.Colour` object.
        """

        self._header_win.SetColumn(column, self.GetColumn(column).SetColour(colour))
        self._header_win.Refresh()


    def GetColumnColour(self, column):
        """
        Returns the column text colour.

        :param `column`: an integer specifying the column index.
        """

        return self._header_win.GetColumn(column).GetColour()
                

    def SetColumnFont(self, column, font):
        """
        Sets the column text font.

        :param `column`: an integer specifying the column index;
        :param `font`: a valid `wx.Font` object.
        """

        self._header_win.SetColumn(column, self.GetColumn(column).SetFont(font))
        self._header_win.Refresh()


    def GetColumnFont(self, column):
        """
        Returns the column text font.

        :param `column`: an integer specifying the column index.
        """

        return self._header_win.GetColumn(column).GetFont()


    def Refresh(self, erase=True, rect=None):
        """
        Causes this window, and all of its children recursively (except under wxGTK1
        where this is not implemented), to be repainted. 

        :param `erase`: If ``True``, the background will be erased;
        :param `rect`: If not ``None``, only the given rectangle will be treated as damaged.

        :note: Note that repainting doesn't happen immediately but only during the next
         event loop iteration, if you need to update the window immediately you should
         use `Update` instead.

        :note: Overridden from `wx.PyControl`.         
        """

        self._main_win.Refresh(erase, rect)
        self._header_win.Refresh(erase, rect)


    def SetFocus(self):
        """ This sets the window to receive keyboard input. """
        
        self._main_win.SetFocus() 


    def GetHeaderWindow(self):
        """ Returns the header window, an instance of L{TreeListHeaderWindow}. """
        
        return self._header_win
    

    def GetMainWindow(self):
        """ Returns the main window, an instance of L{TreeListMainWindow}. """
        
        return self._main_win


    def DoGetBestSize(self):
        """
        Gets the size which best suits the window: for a control, it would be the
        minimal size which doesn't truncate the control, for a panel - the same size
        as it would have after a call to `Fit()`.
        """

        # something is better than nothing...
        return wx.Size(200, 200) # but it should be specified values! FIXME


    def OnGetItemText(self, item, column):
        """
        This function **must** be overloaded in the derived class for a control
        with ``TR_VIRTUAL`` style. It should return the string containing the
        text of the given column for the specified item.

        :param `item`: an instance of L{TreeListItem};
        :param `column`: an integer specifying the column index.
        """
        
        return ""


    def SortChildren(self, item):
        """
        Sorts the children of the given item using L{OnCompareItems} method of L{HyperTreeList}. 
        You should override that method to change the sort order (the default is ascending
        case-sensitive alphabetical order).

        :param `item`: an instance of L{TreeListItem};
        """

        if not self._attr_set:
            setattr(self._main_win, "OnCompareItems", self.OnCompareItems)
            self._attr_set = True
            
        self._main_win.SortChildren(item)
        

    def OnCompareItems(self, item1, item2):
        """
        Returns whether 2 items have the same text.
        
        Override this function in the derived class to change the sort order of the items
        in the L{HyperTreeList}. The function should return a negative, zero or positive
        value if the first item is less than, equal to or greater than the second one.

        :param `item1`: an instance of L{TreeListItem};
        :param `item2`: another instance of L{TreeListItem}.

        :note: The base class version compares items alphabetically.
        """

        # do the comparison here, and not delegate to self._main_win, in order
        # to let the user override it

        return self.GetItemText(item1) == self.GetItemText(item2)

    
    def GetClassDefaultAttributes(self):
        """
        Returns the default font and colours which are used by the control. This is
        useful if you want to use the same font or colour in your own control as in
        a standard control -- which is a much better idea than hard coding specific
        colours or fonts which might look completely out of place on the users system,
        especially if it uses themes.

        This static method is "overridden'' in many derived classes and so calling,
        for example, `wx.Button.GetClassDefaultAttributes()` will typically return the
        values appropriate for a button which will be normally different from those
        returned by, say, `wx.ListCtrl.GetClassDefaultAttributes()`.

        :note: The `wx.VisualAttributes` structure has at least the fields `font`,
         `colFg` and `colBg`. All of them may be invalid if it was not possible to
         determine the default control appearance or, especially for the background
         colour, if the field doesn't make sense as is the case for `colBg` for the
         controls with themed background.
        """

        attr = wx.VisualAttributes()
        attr.colFg = wx.SystemSettings_GetColour(wx.SYS_COLOUR_WINDOWTEXT)
        attr.colBg = wx.SystemSettings_GetColour(wx.SYS_COLOUR_LISTBOX)
        attr.font  = wx.SystemSettings_GetFont(wx.SYS_DEFAULT_GUI_FONT)
        return attr

    GetClassDefaultAttributes = classmethod(GetClassDefaultAttributes)


def create_delegator_for(method):
    """
    Creates a method that forwards calls to `self._main_win` (an instance of L{TreeListMainWindow}).

    :param `method`: one method inside the L{TreeListMainWindow} local scope.
    """
    
    def delegate(self, *args, **kwargs):
        return getattr(self._main_win, method)(*args, **kwargs)
    return delegate

# Create methods that delegate to self._main_win. This approach allows for
# overriding these methods in possible subclasses of HyperTreeList
for method in _methods:
    setattr(HyperTreeList, method, create_delegator_for(method))    


########NEW FILE########
__FILENAME__ = about_dialog
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `AboutDialog` class.

See its documentation for more info.
'''

import time
import webbrowser

import pkg_resources
import wx.html

from garlicsim_wx.general_misc import wx_tools
import garlicsim_wx.general_misc.cute_timer
from garlicsim_wx.widgets.general_misc.cute_dialog import CuteDialog

import garlicsim_wx
from .bitmap_viewer import BitmapViewer

from . import images as __images_package
images_package = __images_package.__name__


class AboutDialog(CuteDialog):
    '''An About dialog for GarlicSim.'''
    def __init__(self, frame):
   
        wx.Dialog.__init__(self, frame, title='About GarlicSim',
                           size=(628, 600))
        CuteDialog.__init__(self, frame, skip_dialog_init=True)
        
        self.SetDoubleBuffered(True)
        
        self.frame = frame

        v_sizer = wx.BoxSizer(wx.VERTICAL)
        

        self._original_image = wx.ImageFromStream(
            pkg_resources.resource_stream(
                images_package,
                'about.png'
            )
        )
        
        self.bitmap_viewer = BitmapViewer(self, size=(627, 271))
        v_sizer.Add(self.bitmap_viewer, 0)
        
        self.html_window = wx.html.HtmlWindow(self, size=(628, 270))
        v_sizer.Add(self.html_window, 0)
        
        foreground_color_in_hex = \
            wx_tools.wx_color_to_html_color(wx_tools.get_background_color())
        background_color_in_hex = \
            wx_tools.wx_color_to_html_color(wx.Colour(0, 0, 0))
        
        
        self.html_window.SetPage(
            '''
            <html>
                <body bgcolor="%s" color="%s">
                    <div align="center"> <font size="1">
                        &copy; 2009-2011 Ram Rachum (a.k.a. cool-RR)
                        <br />                        
                        This program is distributed under the LGPL2.1 license.
                        <br />
                    </font></div>
                    <div> 
                        GarlicSim is a platform for writing, running and
                        analyzing computer simulations. It is general enough to
                        handle any kind of simulation: Physics, game theory,
                        epidemic spread, electronics, etc.<br />
                        <font size="1"><br /></font>
                        <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Version %s</b>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Website:
                        <a href="http://garlicsim.org">http://garlicsim.org</a>
                    </div>
                    <div>
                        <font size="1"><br /></font>
                        I would like to thank the open source community for
                        making this program possible. This includes the
                        developers of Python, Psyco, wxPython, wxWidgets,
                        Mayavi, git, and so many others... And more thanks to
                        the many people who spent many hours helping me out
                        with various issues, on mailing lists such as
                        wxpython-users and on the StackOverflow website.
                    </div>
                </body>
            </html>
            ''' % (
                    foreground_color_in_hex,
                    background_color_in_hex,
                    garlicsim_wx.__version__
                )
        )
        
        self.html_window.Bind(
            wx.html.EVT_HTML_LINK_CLICKED, 
            lambda event: webbrowser.open_new_tab(
                event.GetLinkInfo().GetHref()
                ),
            self.html_window
        )

        
        self.button_sizer = button_sizer = wx.StdDialogButtonSizer()
        self.ok_button = wx.Button(self, wx.ID_OK,
                                   "Let's get back to simulating!")
        self.ok_button.SetDefault()
        button_sizer.SetAffirmativeButton(self.ok_button)
        self.Bind(wx.EVT_BUTTON, self.on_ok, self.ok_button)
        button_sizer.AddButton(self.ok_button)
        button_sizer.Realize()
        button_sizer.SetMinSize((500, -1))
        v_sizer.Add(button_sizer, 0)
        
        
        self.SetSizer(v_sizer)
        self.Layout()

        
        self.timer = garlicsim_wx.general_misc.cute_timer.CuteTimer(self)
        self.timer.Start(40, oneShot=True)
        self.Bind(wx.EVT_TIMER, self.on_timer, self.timer)
        
        self._rotate_image_hue()

        
    def on_ok(self, e=None):
        '''Do 'Okay' on the dialog.'''

        self.EndModal(wx.ID_OK)

        
    def on_timer(self, event):
        '''wx.EVT_TIMER handler.'''
        self._rotate_image_hue()

        
    def _rotate_image_hue(self):
        '''Rotate the image's hue by a tiny bit.'''
        new_image = self._original_image.Copy()
        t = time.time()
        new_image.RotateHue((t / 50.) % 1)
        self.bitmap_viewer.set_bitmap(wx.BitmapFromImage(new_image))
        self.timer.Start(40, oneShot=True)

        
    def EndModal(self, *args, **kwargs):
        self.timer.Stop()
        wx.Dialog.EndModal(self, *args, **kwargs)

        
########NEW FILE########
__FILENAME__ = bitmap_viewer
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `BitmapViewer` class.

See its documentation for more info.
'''

import wx

class BitmapViewer(wx.Panel):
    '''Widget for viewing a bitmap. Similar to `StaticBitmap`.'''
    def __init__(self, *args, **kwargs):
        wx.Panel.__init__(self, *args, **kwargs)
        #self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM)
        self._bitmap = wx.EmptyBitmap(1, 1)
        self.Bind(wx.EVT_PAINT, self.on_paint)
    
    def on_paint(self, event):
        '''EVT_PAINT handler.'''
        dc = wx.PaintDC(self)
        dc.DrawBitmap(self._bitmap, 0, 0)
                
    def set_bitmap(self, bitmap):
        '''Set the bitmap that the viewer will display.'''
        self._bitmap = bitmap
        self.Refresh()
########NEW FILE########
__FILENAME__ = not_main_program_warning_dialog
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `NotMainProgramWarningDialog` class.

See its documentation for more info.
'''


import wx


class NotMainProgramWarningDialog(wx.MessageDialog): 
    '''
    Dialog warning that garlicsim_wx is not the main program.
    
    This is something that can cause problems in several operations, like
    load/save, so we warn the user about it.
    '''
    
    
    def __init__(self, frame):
   
        content = (
            "GarlicSim has detected that it's not being run as the main "
            "program. (Perhaps you have imported it from another script?)\n"
            "\n"
            "\n"
            "If this is the case, it will probably not succeed in starting "
            "another instance of GarlicSim, which is needed for the action "
            "you just tried to do. It can try to continue, but it might not "
            "work. If you want to be safe from this problem, run GarlicSim by "
            "itself, not importing it from another script.\n"
            "\n"
            "\n"
            "Do you want to try to continue?"
        )
        
        wx.MessageDialog.__init__(
            self,
            frame,
            content,
            'Warning',
            wx.YES_NO | wx.ICON_EXCLAMATION
        )
        
########NEW FILE########
__FILENAME__ = simpack_selection_dialog
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `SimpackSelectionDialog` class.

See its documentation for more info.
'''

import os
import sys
import glob
import pkgutil

import wx

from garlicsim.general_misc.cmp_tools import underscore_hating_cmp
from garlicsim.general_misc import address_tools
from garlicsim.general_misc import path_tools
from garlicsim.general_misc import import_tools
from garlicsim.general_misc import package_finder
from garlicsim_wx.widgets.general_misc.cute_dialog import CuteDialog

import garlicsim_wx


class SimpackSelectionDialog(CuteDialog):
    '''Dialog for selecting a simpack when creating a new gui project.'''
    
    def __init__(self, frame):
        CuteDialog.__init__(
            self,
            frame,
            title='Choose simulation package',
            size=(-1, 400)
        )
        
        assert isinstance(frame, garlicsim_wx.Frame)
        self.frame = frame
        
        self.main_v_sizer = wx.BoxSizer(wx.VERTICAL)
        
        self.static_text = wx.StaticText(
            self,
            label='Choose a simulation package for your new simulation:'
        )
        self.main_v_sizer.Add(self.static_text, 0, wx.EXPAND | wx.ALL, 10)
        
        self.list_box = wx.ListBox(self)
        self.main_v_sizer.Add(self.list_box, 1, wx.EXPAND | wx.ALL, 10)
        self.list_box.Bind(wx.EVT_LEFT_DCLICK, self.on_ok, self.list_box)
        
        self.add_folder_containing_simpacks_button = wx.Button(
            self,
            label='&Add folder containing simpacks...'
        )
        self.main_v_sizer.Add(self.add_folder_containing_simpacks_button,
                              0,
                              wx.EXPAND | wx.ALL,
                              border=10)            
        self.Bind(wx.EVT_BUTTON,
                  self.on_add_folder_containing_simpacks_button,
                  self.add_folder_containing_simpacks_button)
        
        self.horizontal_line = wx.StaticLine(self)
        self.main_v_sizer.Add(self.horizontal_line,
                              0,
                              wx.EXPAND | wx.ALL,
                              10)
        
        self.dialog_button_sizer = wx.StdDialogButtonSizer()
        
        self.main_v_sizer.Add(self.dialog_button_sizer,
                              0,
                              wx.ALIGN_CENTER_HORIZONTAL | wx.ALL,
                              border=10)
        
        self.ok_button = wx.Button(self, wx.ID_OK, 'Create &project')
        self.dialog_button_sizer.AddButton(self.ok_button)
        self.ok_button.SetDefault()
        self.dialog_button_sizer.SetAffirmativeButton(self.ok_button)
        self.Bind(wx.EVT_BUTTON, self.on_ok, source=self.ok_button)
        
        self.cancel_button = wx.Button(self, wx.ID_CANCEL, 'Cancel')
        self.dialog_button_sizer.AddButton(self.cancel_button)
        self.Bind(wx.EVT_BUTTON, self.on_cancel, source=self.cancel_button)
        self.dialog_button_sizer.Realize()
        
        self.update_simpack_list()
        if self.list_of_simpacks:
            self.list_box.Select(0)
        
        self.SetSizer(self.main_v_sizer)
        self.Layout()
        
        self.list_box.SetFocus()
        
        
    def on_add_folder_containing_simpacks_button(self, event):
        '''Handler for "Add folders containing simpacks" button.'''
        dir_dialog = wx.DirDialog(
            self,
            'Choose folder containing simpacks. Note that you need to choose '
            'the folder that *contains* your simpack, and not the simpack '
            'folder itself.',
            style=wx.DD_DEFAULT_STYLE | wx.DD_DIR_MUST_EXIST
        )
        try:
            dir_dialog_return_value = dir_dialog.ShowModal()
        finally:
            dir_dialog.Destroy()
            
        if dir_dialog_return_value == wx.ID_OK:
            path = dir_dialog.GetPath()
            if path not in zip(garlicsim_wx.simpack_places)[0]:
                garlicsim_wx.simpack_places.append((path, ''))
                self.update_simpack_list()
            if path not in sys.path:
                sys.path.append(path)
                
        
    def on_ok(self, event):
        '''Handler for "Ok" button.'''
        if self.list_box.GetStringSelection():
            self.EndModal(wx.ID_OK)       
        
        
    def on_cancel(self, event):
        '''Handler for "Cancel" button.'''
        self.EndModal(wx.ID_CANCEL)
        
        
    def update_simpack_list(self):
        '''Update the list of available simpacks.'''
        
        self.list_of_simpacks = []
        
        for path, package_prefix in garlicsim_wx.simpack_places:
            if path not in sys.path:
                sys.path.append(path)
                
            if package_prefix:
                assert package_prefix[-1] == '.'
                package = address_tools.resolve(package_prefix[:-1])
                path_to_search = path_tools.get_path_of_package(package)
            else: # not package_prefix
                path_to_search = path
                
            list_of_simpacks_in_simpack_place = [
                (package_prefix + package_name[1:]) for package_name in
                package_finder.get_packages(path_to_search, self_in_name=False)
            ]
            list_of_simpacks_in_simpack_place.sort(cmp=underscore_hating_cmp)
            
            self.list_of_simpacks += list_of_simpacks_in_simpack_place
            
        self.list_box.SetItems(self.list_of_simpacks)
        

    def get_simpack_selection(self):
        '''Import the selected simpack and return it.'''
        string = self.list_box.GetStringSelection()
        result = import_tools.normal_import(string)
        return result




########NEW FILE########
__FILENAME__ = state_creation_dialog
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `StateCreationDialog` class.

See its documentation for more info.
'''

import wx

from garlicsim_wx.widgets.general_misc.cute_dialog import CuteDialog


class StateCreationDialog(CuteDialog): # make base class
    '''
    An initial dialog to show when creating a root state.
    
    This is a generic one, used if the simpack doesn't define its own.
    '''
    def __init__(self, frame):
   
        CuteDialog.__init__(self, frame, title='Creating a root state')
        
        self.frame = frame
        self.simpack = frame.gui_project.simpack
        State = self.simpack.State

        vbox = wx.BoxSizer(wx.VERTICAL)
        self.messy_check_box = messy_check_box = wx.CheckBox(self, -1, 'Messy')
        tool_tip_string = ('Make a messy chaotic state, useful for '
                           'test-driving the simpack.')
        messy_check_box.SetValue(True)
        if State.create_root is None or State.create_messy_root is None:
            messy_check_box.Disable()
            if State.create_messy_root is None:
                messy_check_box.SetValue(False)
                tool_tip_string += (" Not available because the simpack "
                                    "doesn't define `create_messy_root`.")
            else:
                tool_tip_string += (" Can't be canceled because the simpack "
                                    "doesn't define `create_root`.")
        messy_check_box.SetToolTipString(tool_tip_string)
        
        vbox.Add(messy_check_box, 0, wx.ALL, 10)
        
        # todo: add slick way to add args/kwargs

        last_hbox = wx.StdDialogButtonSizer()
        ok = wx.Button(self, wx.ID_OK, 'Create state')
        ok.SetDefault()
        last_hbox.SetAffirmativeButton(ok)
        self.Bind(wx.EVT_BUTTON, self.on_ok, id=ok.GetId())
        cancel = wx.Button(self, wx.ID_CANCEL, 'Cancel')
        self.Bind(wx.EVT_BUTTON, self.on_cancel, id=cancel.GetId())
        last_hbox.AddButton(ok)
        last_hbox.AddButton(cancel)
        last_hbox.Realize()

        vbox.Add(last_hbox, 0, wx.ALIGN_CENTER | wx.BOTTOM, 10)

        self.SetSizer(vbox)
        vbox.Fit(self)
        ok.SetFocus()

        
    def start(self):
        '''Start the dialog to make a new state.'''
        if self.ShowModal() == wx.ID_OK:
            creator = self.simpack.State.create_messy_root if \
                    self.messy_check_box.GetValue() is True else \
                    self.simpack.State.create_root
            
            state = creator()
        else:
            state = None
        self.Destroy()
        return state

    
    def on_ok(self, event):
        '''Do 'Okay' on the dialog.'''

        self.EndModal(wx.ID_OK)

        
        
    def on_cancel(self, event):
        '''Do 'cancel' on the dialog'''
        
        self.EndModal(wx.ID_CANCEL)

        
        
########NEW FILE########
__FILENAME__ = workspace_widget
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines `WorkspaceWidget` class and `EVT_WORKSPACE_WIDGET_MENU_SELECT` event.

See their documentation for more info.
'''

import wx

import garlicsim_wx
from garlicsim_wx.general_misc import wx_tools
from garlicsim_wx.general_misc.third_party import aui
from garlicsim.general_misc.third_party import abc
from garlicsim.general_misc import string_tools


wxEVT_WORKSPACE_WIDGET_MENU_SELECT = wx.NewEventType()
EVT_WORKSPACE_WIDGET_MENU_SELECT = wx.PyEventBinder(
    wxEVT_WORKSPACE_WIDGET_MENU_SELECT,
    1
)
'''Event for when a workspace widget gets activated from the menu.'''


class WorkspaceWidget(object):
    '''
    Abstract base class for workspace widgets.
    
    A workspace widget is a widget displayed on the `Frame` of `garlicsim_wx`,
    and is connected to a specific gui project.
    '''

    # todo: How do I make it so all subclasses must inherit from `Window`?
    
    __metaclass__ = abc.ABCMeta
    

    _WorkspaceWidget__name = None
    '''The display name of the widget. Default is class name.'''

    
    def __init__(self, frame):
        
        self.Hide()
        
        self.frame = frame
        assert isinstance(self.frame, garlicsim_wx.Frame)
        
        self.gui_project = frame.gui_project
        assert isinstance(self.gui_project, garlicsim_wx.GuiProject)
        
        self.aui_manager = frame.aui_manager
        assert isinstance(self.aui_manager, aui.AuiManager)
        
        
        self.Bind(wx.EVT_KEY_DOWN, self.on_key_down)
        self.__escape_key = wx_tools.Key(wx.WXK_ESCAPE)
        
        self.Bind(EVT_WORKSPACE_WIDGET_MENU_SELECT,
                  self.on_workspace_widget_menu_select)
        
        
    @classmethod
    def get_uppercase_name(cls):
        '''Get the name of the widget's class in uppercase. Used for title.'''
        name = cls._WorkspaceWidget__name or cls.__name__
        return string_tools.camelcase_to_spacecase(name).upper()

    
    def get_aui_pane_info(self):
        '''Get the AuiPaneInfo of this widget in the aui manager.'''
        return self.aui_manager.GetPane(self)
        
    
    def on_key_down(self, event):
        '''Handler for key down event.'''
        
        if wx_tools.Key.get_from_key_event(event) == self.__escape_key and \
           self.frame.FindFocus() is not self.frame:
                
                self.frame.SetFocus()
                
        else:
            event.Skip()


    def show(self):
        '''Show the workspace widget, making sure `aui` doesn't hide it.'''
        aui_pane_info = self.get_aui_pane_info()
        if aui_pane_info.IsShown() is False:
            aui_pane_info.Show()
            self.aui_manager.Update()
        if isinstance(self.Parent, aui.AuiNotebook):
            self.Parent.SetSelectionToWindow(self)
        self.SetFocus()
            
            
    def on_workspace_widget_menu_select(self, event):
        '''Handle the event of a workspace widget being selected in menu.'''
        self.show()
    
########NEW FILE########
__FILENAME__ = autocrunch_controls
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `` class.

See its documentation for more details.
'''

from __future__ import with_statement

import wx

import garlicsim, garlicsim_wx

from garlicsim.general_misc.context_manager import ContextManager
from garlicsim_wx.general_misc import wx_tools


class Freezer(ContextManager):
    '''
    Freezer for not changing the `SpinCtrl`'s text value.

    Used as a context manager. Anything that happens inside the `with` suite
    will not cause the `SpinCtrl` to update its text value.
    
    This is useful because when the `SpinCtrl`'s value changes, some platforms
    automatically select all the text in the `SpinCtrl`, which is really
    annoying if you're just typing in it.
    '''
    
    def __init__(self, autocrunch_controls):
        self.autocrunch_controls = autocrunch_controls
        
    def __enter__(self):
        self.autocrunch_controls.frozen += 1
        
    def __exit__(self, *args, **kwargs):
        self.autocrunch_controls.frozen -= 1
        

class AutocrunchControls(wx.Panel):

    def __init__(self, parent, frame):

        assert isinstance(frame, garlicsim_wx.Frame)
        self.frame = frame
        self.gui_project = frame.gui_project
        assert isinstance(self.gui_project, garlicsim_wx.GuiProject)
        
        wx.Panel.__init__(self, parent, -1)
        
        self.SetBackgroundColour(wx_tools.get_background_color())
        
        tooltip_text = ('Set the clock buffer that will be crunched '
                        'automatically from the active node.')
        
        self.SetToolTipString(tooltip_text)
                
        self.frozen = 0
        self.freezer = Freezer(self)
        
        self.main_h_sizer = wx.BoxSizer(wx.HORIZONTAL)
        
        self.SetSizer(self.main_h_sizer)
        
        self.check_box = wx.CheckBox(self, -1, 'Autocrunch: ')
        
        self.check_box.SetToolTipString(tooltip_text)
        
        self.main_h_sizer.Add(
            self.check_box,
            0,
            wx.EXPAND | wx.ALIGN_CENTER_VERTICAL | wx.RIGHT,
            border=10
        )
        
        self.spin_ctrl = wx.SpinCtrl(self, -1, max=10000000)
        
        self.spin_ctrl.SetToolTipString(tooltip_text)
        
        
        self.main_h_sizer.Add(self.spin_ctrl, 0,
                              wx.ALIGN_CENTER_VERTICAL | wx.ALIGN_RIGHT)
        
        self.check_box.SetValue(
            bool(self.gui_project.default_buffer)
        )
        
        self.spin_ctrl.Enable(
            bool(self.gui_project.default_buffer)
        )
        
        self.spin_ctrl.SetValue(
            self.gui_project.default_buffer or \
            self.gui_project._default_buffer_before_cancellation or \
            0
        )
        
        ### Setting up event handling and emitter connections: ################
        #                                                                     #
        
        self.gui_project.default_buffer_modified_emitter.add_output(
            self.update_check_box
        )
        
        self.Bind(wx.EVT_CHECKBOX, self.on_check_box,
                  source=self.check_box)
        
        self.Bind(wx.EVT_SPINCTRL, self.on_spin, self.spin_ctrl)
        self.Bind(wx.EVT_TEXT, self.on_text, self.spin_ctrl)
        
        self.gui_project.default_buffer_modified_emitter.add_output(
            self.update_spin_ctrl
        )
        
        #                                                                     #
        ### Finished setting up event handling and emitter connections. #######
        
        
    def on_check_box(self, event):
        if event.IsChecked(): # Checkbox got checked
            new_autocrunch = \
                self.gui_project._default_buffer_before_cancellation or 100
            self.gui_project.default_buffer = new_autocrunch
            self.gui_project._default_buffer_before_cancellation = None
            self.spin_ctrl.SetValue(new_autocrunch)
            self.spin_ctrl.Enable()
            if self.gui_project.active_node:
                self.gui_project.project.ensure_buffer(
                    self.gui_project.active_node,
                    clock_buffer=new_autocrunch
                )
        else: # Checkbox got unchecked
            autocrunch_to_store = self.spin_ctrl.GetValue() or 100
            self.gui_project._default_buffer_before_cancellation = \
                autocrunch_to_store
            self.gui_project.default_buffer = 0
            self.spin_ctrl.Disable()
        
    def _update_gui_project(self):
        '''Update the gui project with the autocrunch value that we have.'''
        self.gui_project.set_default_buffer(self.spin_ctrl.GetValue())
        
            
    def on_spin(self, event):
        self._update_gui_project()
        event.Skip()
            
        
    def on_text(self, event):
        with self.freezer:
            self._update_gui_project()
        event.Skip()
        
        
    def update_spin_ctrl(self):
        '''Update the `SpinCtrl` with the gui project's autocrunch value.'''
        if not self.frozen:
            value = self.gui_project.default_buffer or \
                    self.gui_project._default_buffer_before_cancellation or \
                    0
            self.spin_ctrl.SetValue(value)
            self.spin_ctrl.Enable(bool(value))
        
        
    def update_check_box(self):
        '''
        Update the `CheckBox` on whether autocrunch is on in the gui project.
        '''
        self.check_box.SetValue(
            bool(self.gui_project.default_buffer)
        )
        
        
    def on_size(self, event):
        '''EVT_SIZE handler.'''
        self.Refresh()
        event.Skip()
    
        
    def on_paint(self, event):
        '''EVT_PAINT handler.'''
        event.Skip()
        

    
########NEW FILE########
__FILENAME__ = cruncher_controls
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

import pkg_resources
import wx

from garlicsim_wx.general_misc import wx_tools

import garlicsim, garlicsim_wx

from .cruncher_selection_dialog import CruncherSelectionDialog

    
class CruncherControls(wx.Panel):
    '''Widget for viewing/changing the active cruncher type.'''
    
    def __init__(self, parent, frame):
        
        assert isinstance(frame, garlicsim_wx.Frame)
        self.frame = frame
        self.gui_project = frame.gui_project
        
        wx.Panel.__init__(self, parent)
        
        self.SetBackgroundColour(wx_tools.get_background_color())
        
        self.SetToolTipString('Observe or change the cruncher type that is '
                              'used when crunching the simulation.')
        
        self.main_v_sizer = wx.BoxSizer(wx.VERTICAL)
        
        self.SetSizer(self.main_v_sizer)
        
        self.title_text = wx.StaticText(self, -1, 'Cruncher in use:')
        
        self.main_v_sizer.Add(self.title_text, 0)
        
        self.cruncher_in_use_static_text = wx.StaticText(self, -1, '')
        self.cruncher_in_use_static_text.SetFont(
            wx.Font(14, wx.MODERN, wx.NORMAL, wx.NORMAL)
        )
        
        self.main_v_sizer.Add(self.cruncher_in_use_static_text, 0,
                              wx.EXPAND | wx.ALL, 5)
        
        
        self.change_cruncher_button = wx.Button(self, -1, 'Change...')
        self.Bind(wx.EVT_BUTTON, self.on_change_cruncher_button,
                  self.change_cruncher_button)
        
        self.main_v_sizer.Add(self.change_cruncher_button, 0,
                              wx.ALIGN_RIGHT | wx.BOTTOM, 5)
        
        self.gui_project.cruncher_type_changed_emitter.add_output(
            self._recalculate
        )
        
        
    def on_change_cruncher_button(self, event):
        cruncher_selection_dialog = CruncherSelectionDialog(self)
        cruncher_selection_dialog.ShowModal()
        cruncher_selection_dialog.Destroy()
        
    
    def _recalculate(self):
        '''Ensure we display the correct current cruncher type.'''
        self.cruncher_in_use_static_text.SetLabel(
            self.gui_project.project.crunching_manager.cruncher_type.__name__
        )
        


########NEW FILE########
__FILENAME__ = cruncher_selection_dialog
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `CruncherSelectionDialog` class.

See its documentation for more details.
'''

import wx

from garlicsim.general_misc.nifty_collections import OrderedDict
from garlicsim_wx.widgets.general_misc.cute_dialog import CuteDialog
from garlicsim_wx.widgets.general_misc.error_dialog import ErrorDialog

import garlicsim
import garlicsim_wx

from .cruncher_text_scrolled_panel import CruncherTextScrolledPanel


class CruncherSelectionDialog(CuteDialog):
    '''Dialog for changing the cruncher type used in the gui project.'''
    def __init__(self, cruncher_controls):
        CuteDialog.__init__(
            self,
            cruncher_controls.GetTopLevelParent(),
            title='Choose a cruncher type',
            size=(700, 300)
        )
        self.frame = cruncher_controls.frame
        self.gui_project = cruncher_controls.gui_project
        
        self.selected_cruncher_type = None
        
        self.main_v_sizer = wx.BoxSizer(wx.VERTICAL)
        
        self.general_text = wx.StaticText(
            self,
            label=("Choose a cruncher type to be used when crunching the "
                   "simulation. Your simulation will use the same algorithm "
                   "regardless of which cruncher you'll choose; the choice of "
                   "cruncher will affect how and where that algorithm will be "
                   "run.")
        )
        #self.general_text.SetSize((self.ClientSize[0] - 20, -1))
        self.general_text.Wrap(self.ClientSize[0] - 20)
                                  
        self.general_text.Wrap(self.general_text.Size[0])
        
        self.main_v_sizer.Add(self.general_text, 0, wx.EXPAND | wx.ALL,
                              border=10)
        
        self.h_sizer = wx.BoxSizer(wx.HORIZONTAL)
        
        self.main_v_sizer.Add(self.h_sizer, 0, wx.EXPAND)
        
        self.cruncher_types_availability = cruncher_types_availability = \
            self.gui_project.project.simpack_grokker.\
            cruncher_types_availability

        self.cruncher_titles = cruncher_titles = OrderedDict()
        
        for cruncher_type, availability in cruncher_types_availability.items():
            if availability == True:
                title = cruncher_type.__name__
            else:
                assert availability == False
                title = '%s (not available)' % cruncher_type.__name__
            cruncher_titles[title] = cruncher_type
        
        self.cruncher_list_box = wx.ListBox(
            self,
            choices=cruncher_titles.keys()
        )
        self.cruncher_list_box.SetMinSize((250, 100))
        
        self.cruncher_list_box.Select(
            cruncher_titles.values().index(
                self.gui_project.project.crunching_manager.cruncher_type
            )
        )
        
        self.h_sizer.Add(self.cruncher_list_box, 2*0, wx.EXPAND | wx.ALL,
                              border=10)
        
        self.cruncher_text_scrolled_panel = CruncherTextScrolledPanel(self)
        
        self.h_sizer.Add(self.cruncher_text_scrolled_panel, 3*0,
                         wx.EXPAND | wx.ALL, border=10)
        
        self.dialog_button_sizer = wx.StdDialogButtonSizer()
        
        self.main_v_sizer.Add(self.dialog_button_sizer, 0,
                              wx.ALIGN_CENTER | wx.ALL, border=10)
        
        self.ok_button = wx.Button(self, wx.ID_OK, 'Switch cruncher type')
        self.dialog_button_sizer.AddButton(self.ok_button)
        self.ok_button.SetDefault()
        self.dialog_button_sizer.SetAffirmativeButton(self.ok_button)
        self.Bind(wx.EVT_BUTTON, self.on_ok, source=self.ok_button)
        
        self.cancel_button = wx.Button(self, wx.ID_CANCEL, 'Cancel')
        self.dialog_button_sizer.AddButton(self.cancel_button)
        self.Bind(wx.EVT_BUTTON, self.on_cancel, source=self.cancel_button)
        self.dialog_button_sizer.Realize()
        
        
        self.Bind(wx.EVT_LISTBOX, self.on_list_box_change,
                  self.cruncher_list_box)
        self.Bind(wx.EVT_LISTBOX_DCLICK, self.on_list_box_double_click,
                  self.cruncher_list_box)
        
        self.SetSizer(self.main_v_sizer)
        self.Layout()
        self.general_text.Wrap(self.general_text.Size[0])
        self.main_v_sizer.Fit(self)
        
        self.update()

        
    def on_ok(self, event):
        #event.Skip()
        self.try_to_change_cruncher_type_and_end_modal()
        
        
    def on_list_box_double_click(self, event):
        event.Skip()
        self.try_to_change_cruncher_type_and_end_modal()
        

    def try_to_change_cruncher_type_and_end_modal(self):
        if self.cruncher_types_availability[self.selected_cruncher_type]:
            self.gui_project.project.crunching_manager.cruncher_type = \
                self.selected_cruncher_type
            self.gui_project.cruncher_type_changed_emitter.emit()
            self.EndModal(wx.ID_OK)
        else: # Selected cruncher type is unavailable
            error_dialog = ErrorDialog(
                self,
                '`%s` is not available.' % self.selected_cruncher_type.__name__
            )
            error_dialog.ShowModal()
            error_dialog.Destroy()
        
        
    def on_cancel(self, event):
        self.EndModal(wx.ID_CANCEL)

        
    def on_list_box_change(self, event):
        self.update()
        
        
    def update(self):
        '''
        Update the text widget that explains about the current cruncher type.
        '''
        cruncher_types = self.cruncher_titles.values()
        selected_cruncher_type = cruncher_types[
            self.cruncher_list_box.GetSelection()
        ]
        if selected_cruncher_type is not self.selected_cruncher_type:
            self.selected_cruncher_type = selected_cruncher_type
            self.cruncher_text_scrolled_panel.update()
            
            
    def ShowModal(self):
        self.cruncher_list_box.SetFocus()
        return super(CruncherSelectionDialog, self).ShowModal()
########NEW FILE########
__FILENAME__ = cruncher_text_scrolled_panel
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `CruncherTextScrolledPanel` class.

See its documentation for more details.
'''

from __future__ import with_statement

import wx

from garlicsim.general_misc import string_tools
from garlicsim_wx.general_misc import wx_tools

import garlicsim


class CruncherTextScrolledPanel(wx.lib.scrolledpanel.ScrolledPanel):
    '''Widget for showing information about the selected cruncher type.'''
    
    def __init__(self, cruncher_selection_dialog):
        self.cruncher_selection_dialog = cruncher_selection_dialog
        wx.lib.scrolledpanel.ScrolledPanel.__init__(self,
                                                    cruncher_selection_dialog)
        self.SetBackgroundColour(wx_tools.get_background_color())
        self.SetMinSize((530, 300))
        
        self.main_v_sizer = wx.BoxSizer(wx.VERTICAL)
        
        self.cruncher_text = wx.StaticText(
            self,
            label=''
        )
        self.cruncher_text.Wrap(self._get_wrap_width())
        self.main_v_sizer.Add(self.cruncher_text, 0, wx.EXPAND)
        
        self.main_v_sizer.AddSpacer((1, 20))
        
        self.cruncher_unavailability_text = wx.StaticText(
            self,
            label=''
        )
        self.cruncher_unavailability_text.Wrap(self._get_wrap_width())
        self.cruncher_unavailability_text.SetForegroundColour(
            wx.Colour(170, 0, 0)
        )
        self.main_v_sizer.Add(self.cruncher_unavailability_text, 0, wx.EXPAND)
        
        #self.general_text.SetSize((self.ClientSize[0] - 20, -1))
        #self.cruncher_text.Wrap(
            #self.ClientSize[0]# - self.cruncher_list_box.BestSize[0] - 20
        #)
        #self.cruncher_text.SetSize(self.cruncher_text.GetEffectiveMinSize())
        self.SetSizer(self.main_v_sizer)
        self.SetupScrolling()
        
        
    def _get_wrap_width(self):
        return (self.GetClientSize()[0] - 10)

    
    def update(self):
        '''Update to show information about the current cruncher type.'''
        with wx_tools.WindowFreezer(self):
            cruncher_type = \
                self.cruncher_selection_dialog.selected_cruncher_type
            self.cruncher_text.SetLabel(cruncher_type.gui_explanation)
            self.cruncher_text.Wrap(self._get_wrap_width())
            availability = \
                self.cruncher_selection_dialog.cruncher_types_availability[
                    cruncher_type
                ]
            unavailibility_text = getattr(availability, 'reason', '') if \
                                  (availability == False) else ''
            self.cruncher_unavailability_text.SetLabel(unavailibility_text)
            self.cruncher_unavailability_text.Wrap(self._get_wrap_width())
            self.main_v_sizer.Layout()
            self.SetupScrolling()
########NEW FILE########
__FILENAME__ = crunching_controls
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `CrunchingControls` class.

See its documentation for more details.
'''

import wx.lib.scrolledpanel

from garlicsim_wx.general_misc import wx_tools

import garlicsim, garlicsim_wx
from garlicsim_wx.widgets import WorkspaceWidget

from .step_profiles_controls import StepProfilesControls
from .cruncher_controls import CruncherControls
from .autocrunch_controls import AutocrunchControls


class CrunchingControls(wx.lib.scrolledpanel.ScrolledPanel, WorkspaceWidget):
    '''
    Widget for controlling the crunching of the simulations.
    
    Contains three parts:
    
     1. `AutocrunchControls` for setting how far we should automatically
        crunch.
        
     2. `StepProfilesControls` for manipulating step profiles that are used 
        (or will be used) in the tree.
        
     3. `CruncherControls` for displaying which cruncher type is active and 
        switching to a different cruncher type.
    
    '''
    
    _WorkspaceWidget__name = 'Crunching'

    def __init__(self, frame):
        wx.lib.scrolledpanel.ScrolledPanel.__init__(self, frame, -1,
                                                    style=wx.SUNKEN_BORDER)
        WorkspaceWidget.__init__(self, frame)
        
        self.SetBackgroundColour(wx_tools.get_background_color())
        
        self.SetupScrolling()
        
        
        assert isinstance(self.gui_project, garlicsim_wx.GuiProject)
        # I put this assert mainly for better source assistance in Wing.
        # It may be removed.
        
        self.Bind(wx.EVT_SIZE, self.on_size)
        self.Bind(wx.EVT_PAINT, self.on_paint)
        
        self.main_v_sizer = wx.BoxSizer(wx.VERTICAL)
        
        self.SetSizer(self.main_v_sizer)
        
        self.autocrunch_controls = AutocrunchControls(self, frame)
    
        self.main_v_sizer.Add(self.autocrunch_controls, 0, wx.ALL, border=10)
        
        self.step_profiles_controls = StepProfilesControls(self, frame)
        
        self.main_v_sizer.Add(self.step_profiles_controls, 1,
                              wx.EXPAND | wx.ALL, border=10)
        
        self.horizontal_line = wx.StaticLine(self, -1)
        
        self.main_v_sizer.Add(self.horizontal_line, 0,
                              wx.EXPAND | wx.LEFT | wx.RIGHT, border=30)
        
        self.main_v_sizer.AddSpacer((1, 20))
        
        self.cruncher_controls = CruncherControls(self, frame)
        
        self.main_v_sizer.Add(self.cruncher_controls, 0,
                              wx.EXPAND | wx.LEFT | wx.TOP | wx.RIGHT, 10)
        
        self.autocrunch_controls.SetFocus()
        # We do this so when the user switches to this widget for the first
        # time, the focus will be on the autocrunch controls. I'm not sure this
        # is the wisest way to do this, since this sets the global focus and
        # not just the local.

        
    def on_size(self, event):
        '''EVT_SIZE handler.'''
        self.Refresh()
        event.Skip()
    
        
    def on_paint(self, event):
        '''EVT_PAINT handler.'''
        event.Skip()
        

    
########NEW FILE########
__FILENAME__ = step_profiles_controls
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `` class.

See its documentation for more details.
'''

import pkg_resources
import wx

from garlicsim_wx.general_misc import wx_tools
from garlicsim_wx.widgets.general_misc.error_dialog import ErrorDialog

import garlicsim
import garlicsim_wx

from .step_profiles_list import StepProfilesList
from .step_profile_dialog import StepProfileDialog

from . import images as __images_package
images_package = __images_package.__name__

    
class StepProfilesControls(wx.Panel):
    '''Widget for manipulating the step profiles used in the gui project.'''
    
    def __init__(self, parent, frame, *args, **kwargs):
        
        self.frame = frame
        assert isinstance(self.frame, garlicsim_wx.Frame)
        
        self.gui_project = frame.gui_project
        assert isinstance(self.gui_project, garlicsim_wx.GuiProject)
        
        wx.Panel.__init__(self, parent, *args, **kwargs)
        
        self.SetBackgroundColour(wx_tools.get_background_color())
        
        self.SetToolTipString('Add, remove or organize step profiles.')

        
        self.main_v_sizer = wx.BoxSizer(wx.VERTICAL)
        
        self.title_text = wx.StaticText(self, -1, 'Step profiles:')
        
        self.main_v_sizer.Add(self.title_text, 0, wx.ALL, 10)
        
        self.step_profiles_list = StepProfilesList(self, frame)
        
        self.main_v_sizer.Add(self.step_profiles_list, 1,
                              wx.EXPAND | wx.BOTTOM, 8)
        
        self.button_h_sizer = wx.BoxSizer(wx.HORIZONTAL)
        
        self.main_v_sizer.Add(self.button_h_sizer, 0, wx.ALIGN_RIGHT)
        
        new_image = wx.BitmapFromImage(
            wx.ImageFromStream(
                pkg_resources.resource_stream(images_package,
                                              'new.png'),
                wx.BITMAP_TYPE_ANY
            )
        )
        self.new_button = wx.BitmapButton(self, -1, new_image)
        self.new_button.SetToolTipString('Create a new step profile.')
        
        self.button_h_sizer.Add(self.new_button, 0, wx.RIGHT, 8)
        
        delete_image = wx.BitmapFromImage(
            wx.ImageFromStream(
                pkg_resources.resource_stream(images_package,
                                              'trash.png'),
                wx.BITMAP_TYPE_ANY
            )
        )
        self.delete_button = wx.BitmapButton(self, -1, delete_image)
        self.delete_button.SetToolTipString(
            'Delete the selected step profile.'
        )
        self.delete_button.Disable()
        
        self.button_h_sizer.Add(self.delete_button, 0, wx.RIGHT, 8)
        
        self.SetSizer(self.main_v_sizer)
        
        
        self.Bind(wx.EVT_BUTTON, self.on_new_button, source=self.new_button)
        self.Bind(wx.EVT_BUTTON, self.on_delete_button,
                  source=self.delete_button)

        
    def _recalculate(self):
        if self.step_profiles_list.get_selected_step_profile():
            self.delete_button.Enable()
        else: # self.step_profiles_list.get_selected_step_profile() is None
            self.delete_button.Disable()
            
    
    def show_step_profile_editing_dialog(self, step_profile=None,
                                         and_fork=False):
        '''
        Show a dialog for creating a new step profile.
        
        `step_profile` is the step profile that will be used as a template; use
        `None` to start from scratch.
                
        Set `and_fork=True` to fork with the new (or identical existing) step
        profile after the dialog is done.
        '''
        
        # todo: It's a bitch that there's logic here for handling what happens
        # after the dialog is finished. Because there's related logic in the
        # dialog itself. Ideally the logic should be in one of those places
        # only, not spread between them.
        
        step_profile_dialog = StepProfileDialog(self, step_profile,
                                                and_fork=and_fork)
        
        try:
            if step_profile_dialog.ShowModal() == wx.ID_OK:
                new_step_profile = step_profile_dialog.step_profile
                new_hue = step_profile_dialog.hue
            else:
                new_step_profile = new_hue = None
        finally:
            step_profile_dialog.Destroy()
            
        if new_step_profile:
            assert new_step_profile not in self.gui_project.step_profiles
            self.gui_project.step_profiles_to_hues[new_step_profile] = new_hue
            self.gui_project.step_profiles.add(new_step_profile)
            self.step_profiles_list.select_step_profile(new_step_profile)
            
            
        if not and_fork:
            self.step_profiles_list.real_set_focus()
            
        if and_fork and step_profile_dialog.step_profile:
            self.frame.gui_project.fork_by_crunching(
                step_profile_dialog.step_profile
            )
            
            
    def try_delete_step_profile(self, step_profile):
        '''
        Try to delete `step_profile`, raising dialog if it's used in the tree.
        '''
        # todo: in the future, make this dialog offer to delete the nodes with
        # the step profile.
        if step_profile is None:
            return
        tree_step_profiles = self.gui_project.project.tree.get_step_profiles()
        if step_profile in tree_step_profiles:
            ErrorDialog.create_show_modal_and_destroy(
                self,
                "The step profile `%s` is currently used in the tree; it may "
                "not be deleted." % step_profile.__repr__(
                    short_form=True,
                    root=self.gui_project.simpack,
                    namespace=self.gui_project.namespace
                )
            )
            return
        else:
            self.gui_project.step_profiles.remove(step_profile)
            
            
    def on_new_button(self, event):
        self.show_step_profile_editing_dialog(step_profile=None)
    
    
    def on_delete_button(self, event):
        self.try_delete_step_profile(
            self.step_profiles_list.get_selected_step_profile()
        )
########NEW FILE########
__FILENAME__ = active_step_profile_indicator
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `ActiveStepProfileIndicator` class.

See its documentation for more details.
'''

from __future__ import division

import wx


class ActiveStepProfileIndicator(wx.Window):
    '''
    Widget for indicating which step profile is active.
    
    This widget appears next to *every* step profile in the list; but only for
    the active step profile it shows a little black triangle, while for the
    others it shows nothing.
    '''
    def __init__(self, step_profile_item_panel, step_profile, size=(10, 15)):
        self.step_profile_item_panel = step_profile_item_panel
        self.active = False
        wx.Window.__init__(self, step_profile_item_panel, size=size)
        self.SetMinSize(size)
        self.SetBackgroundColour(step_profile_item_panel.GetBackgroundColour())
        self.Bind(wx.EVT_PAINT, self.on_paint)
        
    
    def set_active(self):
        '''Set this `ActiveStepProfileIndicator` to show a marker.'''
        if not self.active:
            self.active = True
            self.Refresh()

            
    def set_inactive(self):
        '''Set this `ActiveStepProfileIndicator` to not show a marker.'''
        if self.active:
            self.active = False
            self.Refresh()
            
        
    def on_paint(self, event):
        dc = wx.BufferedPaintDC(self)
        dc.Clear()
        if self.active:
            gc = wx.GraphicsContext.Create(dc)
            assert isinstance(gc, wx.GraphicsContext)
            w, h = self.GetClientSize()
            path = gc.CreatePath()
            assert isinstance(path, wx.GraphicsPath)
            path.MoveToPoint((1/4) * w, (1/6) * h)
            path.AddLineToPoint((1/4) * w, (5/6) * h)
            path.AddLineToPoint((5/6) * w, (1/2) * h)
            gc.SetPen(wx.Pen(wx.Colour(255, 0, 0)))
            gc.SetBrush(wx.Brush(wx.Colour(0, 0, 0)))
            gc.FillPath(path)
            gc.Destroy()
        
        
        dc.Destroy()
########NEW FILE########
__FILENAME__ = free_context_menu
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `FreeContextMenu` class.

See its documentation for more details.
'''

import wx
from garlicsim_wx.general_misc import cute_menu


class FreeContextMenu(cute_menu.CuteMenu):
    '''
    Context menu shown in `StepProfilesList` when no step profile is selected.
    '''
    def __init__(self, step_profiles_list):
        super(FreeContextMenu, self).__init__()
        self.step_profiles_list = step_profiles_list
        self._build()
        
    def _build(self):
        '''Build the context menu.'''
        
        step_profiles_list = self.step_profiles_list
        
        self.new_step_profile_button = self.Append(
            -1,
            'Create step profile...',
            ' Create a new step profile'
        )
        self.Bind(wx.EVT_MENU,
                  step_profiles_list.on_new_step_profile_button,
                  source=self.new_step_profile_button)
    
########NEW FILE########
__FILENAME__ = hue_control
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `HueControl` class.

See its documentation for more details.
'''

import colorsys

import wx

from garlicsim_wx.widgets.general_misc.hue_control \
     import HueControl as GenericHueControl

import garlicsim_wx


class HueControl(GenericHueControl):
    '''
    Control for viewing and changing the hue associated with a step profile.
    '''
    def __init__(self, step_profile_item_panel, step_profile):
        
        self.step_profile = step_profile
        
        self.step_profile_item_panel = step_profile_item_panel
        self.frame = self.step_profile_item_panel.frame
        self.gui_project = self.frame.gui_project
        
        getter = lambda: \
               self.gui_project.step_profiles_to_hues.__getitem__(
                   self.step_profile
               )
        
        setter = lambda hue: \
               self.gui_project.step_profiles_to_hues.__setitem__(
                   self.step_profile,
                   hue
               )
        
        size = (25, 15)
        
        GenericHueControl.__init__(
            self,
            step_profile_item_panel,
            getter=getter,
            setter=setter,
            emitter=self.gui_project.step_profiles_to_hues_modified_emitter,
            lightness=0.8,
            saturation=1,
            dialog_title='Select hue for step profile',
            size=size
        )
        
        self.SetMinSize(size)

        self.SetBackgroundColour(step_profile_item_panel.GetBackgroundColour())
        
        
            

########NEW FILE########
__FILENAME__ = step_profiles_list
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `StepProfilesList` class.

See its documentation for more details.
'''

import wx
import weakref

from garlicsim_wx.general_misc import wx_tools
from garlicsim_wx.widgets.general_misc import cute_hyper_tree_list

import garlicsim, garlicsim_wx
from garlicsim_wx.widgets import WorkspaceWidget

from .free_context_menu import FreeContextMenu
from .step_profile_context_menu import StepProfileContextMenu
from .step_profile_item_panel import StepProfileItemPanel


class StepProfilesList(cute_hyper_tree_list.CuteHyperTreeList):
    '''
    List of step profiles.
    
    The list has all the step profiles that are used in the tree, and also the
    step profiles that the user created but aren't in the tree yet.
    
    The `StepProfilesList` allows the user to add new step profiles (possibly
    by using existing ones as templates, or by starting from scratch,) to
    delete existing step profiles, and to change the hue used to identify the
    step profile in the GUI.
    
    '''
    # todo: set max size dynamically according to number of profiles
    
    def __init__(self, step_profiles_controls, frame):
        
        self.frame = frame
        assert isinstance(self.frame, garlicsim_wx.Frame)
        self.gui_project = frame.gui_project
        assert isinstance(self.gui_project, garlicsim_wx.GuiProject)
        self.step_profiles_controls = step_profiles_controls
        
        cute_hyper_tree_list.CuteHyperTreeList.__init__(
            self,
            step_profiles_controls,
            style=wx.SIMPLE_BORDER,
            agwStyle=(
                #wx.TR_FULL_ROW_HIGHLIGHT | \
                wx.TR_ROW_LINES | \
                wx.TR_HIDE_ROOT | \
                cute_hyper_tree_list.TR_NO_HEADER
                )
        )        
        
        self.step_profiles_to_items = weakref.WeakKeyDictionary()
        
        self.AddColumn('', width=50)
        self.AddColumn('', width=600)
        self.SetMainColumn(1)
        self.root_item = self.AddRoot('')
        
        self.items = self.root_item._children
        
        self.free_context_menu = FreeContextMenu(self)
        self.step_profile_context_menu = StepProfileContextMenu(self)
        
        self.Bind(wx.EVT_TREE_ITEM_ACTIVATED, self.on_tree_item_activated)
        
        self.Bind(wx.EVT_TREE_ITEM_MENU, self.on_tree_item_menu)
        self.Bind(wx.EVT_CONTEXT_MENU, self.on_context_menu)
        
        self.Bind(wx.EVT_TREE_BEGIN_DRAG, self.on_tree_begin_drag)
        
        self.Bind(wx.EVT_TREE_SEL_CHANGED, self.on_tree_sel_changed)
        
        self.Bind(wx.EVT_SET_FOCUS, self.on_set_focus)
        
        self.GetMainWindow().Bind(wx.EVT_KEY_DOWN, self.on_key_down)
        
        self.gui_project.step_profiles_set_modified_emitter.add_output(
            self.update
        )
        
        self.gui_project.active_step_profile_changed_emitter.add_output(
            self.update_active_step_profile_indicator
        )
        
        self.update_active_step_profile_indicator()
        
  
        
    def update(self):
        '''Ensure we're showing exactly the gui project's step profiles.'''
        
        gui_project = self.gui_project
        
        for step_profile, item in self.step_profiles_to_items.items():
            if item not in self.items:
                del self.step_profiles_to_items[step_profile]
                
        for step_profile in gui_project.step_profiles:
            try:
                item = self.step_profiles_to_items[step_profile]
            except KeyError:
                step_profile_item_panel = StepProfileItemPanel(self,
                                                               step_profile)
                item = self.AppendItem(self.root_item, '',
                                       )#wnd=step_profile_item_panel)
                item.SetWindow(step_profile_item_panel, 0)
                item.step_profile = step_profile
                item.step_profile_item_panel = step_profile_item_panel
                self.step_profiles_to_items[step_profile] = item
                self.SetItemText(
                    item,
                    step_profile.__repr__(short_form=True,
                                          root=gui_project.simpack,
                                          namespace=gui_project.namespace),
                    1
                )
        
        for item in self.items:
            if item.step_profile not in gui_project.step_profiles:
                self.Delete(item)
                # item.step_profile_item_panel.Destroy()
                # Apparently gets destroyed before

        
        if (self.items) and (self.GetSelection() not in self.items):
            self.SelectItem(self.items[-1])
            
            
                
               
    def update_active_step_profile_indicator(self):
        '''
        Ensure we're putting the active step profile marker on the active one.
        '''
        active_step_profile = self.gui_project.get_active_step_profile()
        for item in self.items:
            active_step_profile_indicator = \
                item.step_profile_item_panel.active_step_profile_indicator
            step_profile = item.step_profile
            if step_profile == active_step_profile:
                active_step_profile_indicator.set_active()
            else:
                active_step_profile_indicator.set_inactive()
        
    
    def get_selected_step_profile(self):
        '''Get the step profile that's currently selected.'''
        selection = self.GetSelection()
        if selection and (selection != self.root_item):
            return selection.step_profile
        else:
            return None
        
        
    def select_step_profile(self, step_profile):
        '''Select `step_profile`.'''
        item = self.step_profiles_to_items[step_profile]
        self.SelectItem(item)

        
    def real_set_focus(self):
        '''Set focus on the `StepProfilesList`. Bypasses some cruft.'''
        self.GetMainWindow().SetFocusIgnoringChildren()
        
        
    def on_tree_item_activated(self, event):
        assert event.GetItem() == self.GetSelection()
        self.step_profiles_controls.show_step_profile_editing_dialog(
            self.get_selected_step_profile()
        )
    
    
    def on_tree_item_menu(self, event):
        abs_position = event.GetPoint() or wx.DefaultPosition
        
        if abs_position == wx.DefaultPosition:
            position = (0, 0) # todo: take position smartly
        else:
            position = self.ScreenToClient(abs_position)

        if self.get_selected_step_profile() is not None:
            self.PopupMenu(self.step_profile_context_menu, position)
        else:
            new_event = wx.ContextMenuEvent(
                wx.wxEVT_CONTEXT_MENU,
                self.GetId(),
                abs_position #self.ClientToScreen(abs_position)
            )
            new_event.SetEventObject(self)
            wx.PostEvent(self, new_event)
            
    
            
    def on_context_menu(self, event):

        abs_position = event.GetPosition()
        
        if abs_position == wx.DefaultPosition:
            position = (0, 0)
        else:
            position = self.ScreenToClient(abs_position)
            
        self.PopupMenu(self.free_context_menu, position)
        
        
    def on_new_step_profile_button(self, event):
        self.step_profiles_controls.show_step_profile_editing_dialog()

        
    def on_fork_by_crunching_button(self, event):
        self.gui_project.fork_by_crunching(
            self.get_selected_step_profile()
        )

        
    def on_select_tree_members_button(self, event):
        raise NotImplementedError()

        
    def on_change_color_button(self, event):
        item = self.GetSelection()
        item.step_profile_item_panel.hue_control.open_editing_dialog()

        
    def on_duplicate_and_edit_button(self, event):
        self.step_profiles_controls.show_step_profile_editing_dialog(
            self.get_selected_step_profile()
        )

        
    def on_tree_begin_drag(self, event):
        event.Allow()
        
        
    def on_tree_end_drag(self, event):
        event.Allow()
        
    
    def on_tree_sel_changed(self, event):
        event.Skip()
        self.step_profiles_controls._recalculate()
       
        
    def on_key_down(self, event):
        key = wx_tools.Key.get_from_key_event(event)
        if key == wx_tools.Key(wx.WXK_DELETE):
            self.step_profiles_controls.try_delete_step_profile(
                self.get_selected_step_profile()
            )
        else:
            event.Skip()
            
            
    def on_set_focus(self, event):
        if self.frame.FindFocus() == self:
            self.GetMainWindow().SetFocusIgnoringChildren()
            
########NEW FILE########
__FILENAME__ = step_profile_context_menu
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `StepProfileContextMenu` class.

See its documentation for more details.
'''

import wx
from garlicsim_wx.general_misc import cute_menu


class StepProfileContextMenu(cute_menu.CuteMenu):
    '''Context menu for a step profile in the list.'''
    
    def __init__(self, step_profiles_list):
        super(StepProfileContextMenu, self).__init__()
        self.step_profiles_list = step_profiles_list
        self._build()
        
    def _build(self):
        '''Build the context menu.'''
        
        step_profiles_list = self.step_profiles_list
        
        self.fork_by_crunching_button = self.Append(
            -1,
            'Fork by &crunching...',
            ' Fork the simulation by crunching from the active node using '
            'this step profile'
        )
        self.Bind(wx.EVT_MENU,
                  step_profiles_list.on_fork_by_crunching_button,
                  source=self.fork_by_crunching_button)
        
        
        self.AppendSeparator()
        
        
        self.select_tree_members_button = self.Append(
            -1,
            'Select tree &members',
            ' Select all the nodes and ends that have this step profile'
        )
        self.Bind(wx.EVT_MENU,
                  step_profiles_list.on_select_tree_members_button,
                  source=self.select_tree_members_button)
        self.select_tree_members_button.Enable(False)
        
        
        self.AppendSeparator()
        
        
        self.change_color_button = self.Append(
            -1,
            'Change co&lor...',
            ' Change the color of this step profile'
        )
        self.Bind(wx.EVT_MENU,
                  step_profiles_list.on_change_color_button,
                  source=self.change_color_button)
        
        
        self.duplicate_and_edit_button = self.Append(
            -1,
            '&Duplicate and edit...',
            ' Duplicate this step profile and edit the newly-created step '
            'profile'
        )
        self.Bind(wx.EVT_MENU,
                  step_profiles_list.on_duplicate_and_edit_button,
                  source=self.duplicate_and_edit_button)
        
        
        self.delete_button = self.Append(
            -1,
            'D&elete...\tDel',
            ' Delete this step profile'
        )
        self.Bind(wx.EVT_MENU,
                  step_profiles_list.step_profiles_controls.on_delete_button,
                  source=self.delete_button)
        
        
    
########NEW FILE########
__FILENAME__ = step_profile_item_panel
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `StepProfileItemPanel` class.

See its documentation for more details.
'''

import wx

from .active_step_profile_indicator import ActiveStepProfileIndicator
from .hue_control import HueControl


class StepProfileItemPanel(wx.Panel):
    '''
    Panel to display next to a step profile in the step profiles list.
    
    This panel contains:
    
     1. `ActiveStepProfileIndicator` for indicating which step profile is 
        active.
        
     2. `HueControl` for viewing and changing the hue associated with a step
        profile.
        
    '''
    def __init__(self, step_profiles_list, step_profile):
        self.step_profiles_list = step_profiles_list
        self.frame = step_profiles_list.frame
        self.step_profile = step_profile
        wx.Panel.__init__(
            self,
            step_profiles_list.GetMainWindow(),
            size=(40, 20)
        )
        
        
        self.SetBackgroundColour(
            step_profiles_list.GetMainWindow().GetBackgroundColour()
        )
        
        self.main_h_sizer = wx.BoxSizer(wx.HORIZONTAL)
        
        
        self.active_step_profile_indicator = ActiveStepProfileIndicator(
            self,
            step_profile
        )
        
        self.main_h_sizer.Add(self.active_step_profile_indicator, 0,
                              wx.EXPAND | wx.TOP | wx.BOTTOM, border=3)
        
        self.main_h_sizer.AddSpacer((5, -1))
        
        self.hue_control = HueControl(self, step_profile)
        
        self.main_h_sizer.Add(self.hue_control, 0,
                              wx.EXPAND | wx.BOTTOM | wx.TOP, border=3)
        
        self.SetSizer(self.main_h_sizer)
        self.Layout()
        
        
########NEW FILE########
__FILENAME__ = already_exists_dialog
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `AlreadyExistsDialog` class.

See its documentation for more details.
'''

import wx

from garlicsim_wx.widgets.general_misc.cute_dialog import CuteDialog

import garlicsim_wx


class AlreadyExistsDialog(CuteDialog):
    '''
    Dialog alerting that the step profile you tried to create already exists.
    
    The user may either go to the existing step profile, or keep editing this
    one.
    '''
    def __init__(self, step_profile_dialog, step_profile, and_fork=False):
        '''
        Construct the `AlreadyExistsDialog`.
        
        Set `and_fork=True` if you intend to fork right after getting the step
        profile, though note it will only affect the labels; the actual forking
        is not done here.
        '''
        self.step_profile_dialog = step_profile_dialog
        self.frame = step_profile_dialog.frame
        self.step_profile = step_profile
        self.and_fork = and_fork
        assert isinstance(self.frame, garlicsim_wx.Frame)
        
        CuteDialog.__init__(self, step_profile_dialog,
                            title='Step profile already exists')

        
        self.main_v_sizer = wx.BoxSizer(wx.VERTICAL)
                
        
        self.static_text = wx.StaticText(
            self,
            label='The step profile `%s` already exists.' % \
                step_profile.__repr__(
                    short_form=True,
                    root=self.frame.gui_project.simpack,
                    namespace=self.frame.gui_project.namespace
                )
        )
        
        self.main_v_sizer.Add(self.static_text, 0, wx.EXPAND | wx.ALL,
                              border=10)
        

        self.button_sizer = wx.BoxSizer(wx.HORIZONTAL)
        
        self.main_v_sizer.Add(self.button_sizer, 0, wx.ALIGN_CENTER_HORIZONTAL)
        
        take_me_to_it_label = 'Take me to it' if not and_fork else \
                              'Take me to it and fork with it'
        self.take_me_to_it_button = wx.Button(self, label=take_me_to_it_label)
        
        # Allowing keyboard-navigation and Esc on Ubuntu:
        self.take_me_to_it_button.SetFocus()
        
        self.button_sizer.Add(self.take_me_to_it_button, 0, wx.EXPAND | wx.ALL,
                              border=10)
        
        self.keep_editing_button = wx.Button(self, label='Keep editing')
        
        
        
        self.SetEscapeId(self.keep_editing_button.Id)
        
        self.button_sizer.Add(self.keep_editing_button, 0, wx.EXPAND | wx.ALL,
                              border=10)
        
        self.Bind(wx.EVT_BUTTON, self.on_take_me_to_it_button,
                  source=self.take_me_to_it_button)
        self.Bind(wx.EVT_BUTTON, self.on_keep_editing_button,
                  source=self.keep_editing_button)
        
        self.take_me_to_it_button.SetDefault()
        
        self.SetSizer(self.main_v_sizer)
        self.main_v_sizer.Fit(self)
        
        
        
    def on_take_me_to_it_button(self, event):
        self.EndModal(wx.ID_OK)
        step_profiles_list = self.frame.crunching_controls.\
                             step_profiles_controls.step_profiles_list
        step_profiles_list.select_step_profile(self.step_profile)
        self.frame.crunching_controls.show()

        # Hacky, since `wx.CallAfter` doesn't work for this:
        wx.CallLater(200, step_profiles_list.real_set_focus)
        
    
    
    def on_keep_editing_button(self, event):
        self.EndModal(wx.ID_CANCEL)
        
    
########NEW FILE########
__FILENAME__ = arg
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `Arg` class.

See its documentation for more details.
'''

import wx

from garlicsim_wx.general_misc import wx_tools

from .value_text_ctrl import ValueTextCtrl


class Arg(wx.Panel):
    '''
    Widget for specifying a named argument to the step function.

    The name is static, only the value can be changed by the user.
    '''
    def __init__(self, argument_control, name, value=''):
        wx.Panel.__init__(self, argument_control)
        if wx.Platform == '__WXGTK__':
            self.SetBackgroundColour(wx_tools.get_background_color())
        
        self.argument_control = argument_control
        self.name = name
        
        self.main_h_sizer = wx.BoxSizer(wx.HORIZONTAL)
        
        self.name_static_text = wx.StaticText(self, label=('%s=' % name))
        
        self.main_h_sizer.Add(self.name_static_text, 0,
                              wx.ALIGN_CENTER_VERTICAL)
        
        self.value_text_ctrl = ValueTextCtrl(
            self,
            #size=(100, -1),
            value=value
        )
        
        self.main_h_sizer.Add(self.value_text_ctrl, 1,
                              wx.ALIGN_CENTER_VERTICAL)
        
        self.SetSizer(self.main_h_sizer)
        
        #self.main_h_sizer.Fit(self)
        
        
    def get_value_string(self):
        '''Get the value of the argument, as a string.'''
        return self.value_text_ctrl.GetValue()
    
########NEW FILE########
__FILENAME__ = argument_control
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `ArgumentControl` class.

See its documentation for more details.
'''

import wx

from garlicsim.general_misc import cute_inspect
from garlicsim.general_misc import misc_tools
from garlicsim_wx.general_misc import wx_tools

from .arg_box import ArgBox
from .star_arg_box import StarArgBox
from .star_kwarg_box import StarKwargBox
from .placeholder import Placeholder
from .exceptions import ResolveFailed


class ArgumentControl(wx.Panel):
    '''Widget for specifying arguments to a step function.'''
    def __init__(self, step_profile_dialog, step_function=None):
        self.step_profile_dialog = step_profile_dialog
        self.gui_project = step_profile_dialog.gui_project
        
        wx.Panel.__init__(self, step_profile_dialog)
        
        self.SetBackgroundColour(wx_tools.get_background_color())
        
        self.box_size = wx.Size(200, -1) if wx.Platform == '__WXMSW__' \
                        else wx.Size(250, -1) 
        
        self.step_function = None
        
        self.main_h_sizer = wx.BoxSizer(wx.HORIZONTAL)
        
        self.SetSizer(self.main_h_sizer)
        
        self.set_step_function(step_function)
        
        
    def set_step_function(self, step_function):
        '''Set the step function for which we are specifying arguments.'''
        if self.step_function == step_function:
            return
        
        if self.step_function is not None:
            try:
                self.save()
            except ResolveFailed:
                pass

        self.step_function = step_function

        self.main_h_sizer.Clear(deleteWindows=True)
        
        arg_spec = cute_inspect.getargspec(step_function)
        
        step_profile_dialog = self.step_profile_dialog
        
        arg_dict = step_profile_dialog.\
                 step_functions_to_argument_dicts[step_function]
        
        star_arg_list = step_profile_dialog.\
                      step_functions_to_star_args[step_function]
        
        star_kwarg_dict = step_profile_dialog.\
                        step_functions_to_star_kwargs[step_function]
        
        
        if arg_spec.args[1:]: # Filtering the state which is always present
            self.arg_box = ArgBox(self, step_function)
            self.main_h_sizer.Add(self.arg_box.sizer, 0, wx.ALL, border=10)
        else:
            self.arg_box = None
            self.main_h_sizer.Add(
                Placeholder(self, '(No named arguments)'),
                0,
                wx.ALL,
                border=10
            )
            
        
        if arg_spec.varargs:
            self.star_arg_box = StarArgBox(self, step_function)
            self.main_h_sizer.Add(self.star_arg_box.sizer, 0, wx.ALL,
                                  border=10)
        else:
            self.star_arg_box = None
            self.main_h_sizer.Add(
                Placeholder(self, '(No additional positional arguments)'),
                0,
                wx.ALL,
                border=10
            )
                
            
        if arg_spec.keywords:
            self.star_kwarg_box = StarKwargBox(self, step_function)
            self.main_h_sizer.Add(self.star_kwarg_box.sizer, 0, wx.ALL,
                                  border=10)
        else:
            self.star_kwarg_box = None
            self.main_h_sizer.Add(
                Placeholder(self, '(No additional keyword arguments)'),
                0,
                wx.ALL,
                border=10
            )
            
        
        self.main_h_sizer.Fit(self)
        self.Layout()
        self.step_profile_dialog.main_v_sizer.Fit(self.step_profile_dialog)
        self.step_profile_dialog.Layout()
        
        
        self.step_profile_dialog.Refresh()
        

    def save(self):
        '''
        Save all arguments to the dialog, unless there's an error resolving.
        
        The arguments will be saved to the following attributes of the dialog:
        
         *  `.step_functions_to_argument_dicts[step_function]`
         *  `.step_functions_to_star_args[step_function]`
         *  `.step_functions_to_star_kwargs[step_function]`
        
        '''
        
        step_profile_dialog = self.step_profile_dialog
        step_function = self.step_function

        
        arg_dict = step_profile_dialog.\
            step_functions_to_argument_dicts[step_function]
        
        star_arg_list = step_profile_dialog.\
            step_functions_to_star_args[step_function]
        
        star_kwarg_dict = step_profile_dialog.\
            step_functions_to_star_kwargs[step_function]
        
        resolve_failed = None
        
        
        if self.arg_box:
            arg_dict.clear()
            for arg in self.arg_box.args:
                name = arg.name
                value_string = arg.get_value_string() 
                try:
                    # Not storing, just checking if it'll raise an error:
                    self.step_profile_dialog.resolve(value_string)
                except Exception:
                    if not resolve_failed:
                        resolve_failed = ResolveFailed(
                            "Can't resolve '%s' to a Python "
                            "object." % value_string,
                            arg.value_text_ctrl
                        )
                else:
                    arg_dict[name] = value_string
        
            
        if self.star_arg_box:
            del star_arg_list[:]
            for star_arg in self.star_arg_box.star_args:
                value_string = star_arg.get_value_string()
                try:
                    # Not storing, just checking if it'll raise an error:
                    self.step_profile_dialog.resolve(value_string)
                except Exception:
                    if not resolve_failed:
                        resolve_failed = ResolveFailed(
                            "Can't resolve '%s' to a Python "
                            "object." % value_string,
                            star_arg.value_text_ctrl
                        )
                else:
                    star_arg_list.append(value_string)
                
                    
        if self.star_kwarg_box:
            star_kwarg_dict.clear()
            for star_kwarg in self.star_kwarg_box.star_kwargs:
                name = star_kwarg.get_name_string()
                if not misc_tools.is_legal_ascii_variable_name(name):
                    if not resolve_failed:
                        resolve_failed = ResolveFailed(
                            "'%s' is not a legal name for a variable." % name,
                            star_kwarg.name_text_ctrl
                        )
                    continue
                value_string = star_kwarg.get_value_string()
                try:
                    # Not storing, just checking if it'll raise an error:
                    self.step_profile_dialog.resolve(value_string)
                except Exception:
                    if not resolve_failed:
                        resolve_failed = ResolveFailed(
                            "Can't resolve '%s' to a Python "
                            "object." % value_string,
                            star_kwarg.value_text_ctrl
                        )
                else:
                    star_kwarg_dict[name] = value_string
                
        
        if resolve_failed:
            raise resolve_failed
########NEW FILE########
__FILENAME__ = arg_box
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `ArgBox` class.

See its documentation for more details.
'''

import wx

from garlicsim.general_misc import cute_inspect

from .arg import Arg


class ArgBox(wx.StaticBox):    
    '''
    Static box for specifying arguments to the step function.
    
    Note that this static box is not the parent of the widgets it creates.
    '''
    def __init__(self, argument_control, step_function):
        self.argument_control = argument_control
        
        wx.StaticBox.__init__(self, argument_control, label='Arguments',
                              size=argument_control.box_size)
        
        self.SetMinSize(argument_control.box_size)
        self.SetMaxSize(argument_control.box_size)
        
        self.sizer = wx.StaticBoxSizer(self, wx.VERTICAL)
        
        self.sizer.SetMinSize(argument_control.box_size)
        
        self.step_function = step_function
        
        arg_spec = cute_inspect.getargspec(step_function)
        
        arg_dict = argument_control.step_profile_dialog.\
            step_functions_to_argument_dicts[
                step_function
            ]
        
        self.args = []
        
        for i, arg_name in list(enumerate(arg_spec.args))[1:]:
            value = arg_dict[arg_name]
            if not value and (arg_name in arg_spec.defaults):
                value = arg_dict[arg_name] = repr(arg_spec.defaults[i])
            arg = Arg(argument_control, arg_name, value)
            self.args.append(arg)
            self.sizer.Add(arg, 0, wx.EXPAND | wx.ALL, border=5)
            
########NEW FILE########
__FILENAME__ = close_button
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `CloseButton` class.

See its documentation for more details.
'''

import wx
import pkg_resources

from garlicsim.general_misc import caching

from . import images as __images_package
images_package = __images_package.__name__


@caching.cache()
def get_bitmap():
    '''Get the "X" bitmap used for the close button.'''
    stream = pkg_resources.resource_stream(
        images_package,
        'close.png'
    )
    
    return wx.BitmapFromImage(
        wx.ImageFromStream(
            stream,
            wx.BITMAP_TYPE_ANY
        )
    )


class CloseButton(wx.BitmapButton):
    '''Button for deleting a star-arg or star-kwarg.'''
    def __init__(self, parent):
        self.parent = parent
        wx.BitmapButton.__init__(self, parent, bitmap=get_bitmap())
                
            
        

########NEW FILE########
__FILENAME__ = colors
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Defines colors for use in `ArgumentsControl`.'''

import wx

from garlicsim.general_misc import caching
from garlicsim_wx.general_misc import color_tools
from garlicsim_wx.general_misc import wx_tools


@caching.cache()
def get_error_background_color():
    '''Get the background color of a text control which has invalid input.'''
    red = wx.Colour(255, 0, 0)
    return wx_tools.mix_wx_color(0.2, red, wx.Colour(255, 255, 255))

########NEW FILE########
__FILENAME__ = exceptions
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Defines exceptions for `ArgumentControl`.'''

from garlicsim.misc import exceptions


class ResolveFailed(exceptions.GarlicSimException):
    '''An attempt to resolve a string to a Python object failed.'''
    def __init__(self, message, widget):
        self.widget = widget
        super(ResolveFailed, self).__init__(message)
########NEW FILE########
__FILENAME__ = name_text_ctrl
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `` class.

See its documentation for more details.
'''

import wx

from garlicsim.general_misc import misc_tools

from . import colors


class NameTextCtrl(wx.TextCtrl):
    '''Widget for entering an argument name.'''
    def __init__(self, parent, value=''):
        
        wx.TextCtrl.__init__(self, parent, value=value)
        self._original_background_color = self.GetBackgroundColour()
        
        self.SetMinSize((10, -1))
        
        self.Bind(wx.EVT_KILL_FOCUS, self.on_kill_focus)
        
        self.Bind(wx.EVT_TEXT, self.on_text)
        
        self.error_mode = False
        
    
    def _check_validity_and_color(self):
        '''
        Check whether the value is a valid name, if it isn't show error color.
        '''
        is_valid = misc_tools.is_legal_ascii_variable_name(self.GetValue())
        if is_valid:
            self.SetBackgroundColour(self._original_background_color)
        else: # not is_valid
            self.SetBackgroundColour(colors.get_error_background_color())
        self.Refresh()
        return is_valid
            
        
    def on_text(self, event):
        if self.error_mode:
            self._check_validity_and_color()
            
            
    def on_kill_focus(self, event):
        event.Skip()
        if self.FindFocus() != self:
            if not self._check_validity_and_color() and not self.error_mode:
                self.error_mode = True
########NEW FILE########
__FILENAME__ = placeholder
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `Placeholder` class.

See its documentation for more details.
'''

import wx

from garlicsim_wx.general_misc import wx_tools
from garlicsim_wx.general_misc import color_tools


class Placeholder(wx.StaticText):
    '''Placeholder for functions that don't have extraneous arguments.'''
    def __init__(self, argument_control, label):
        self.argument_control = argument_control
        
        wx.StaticText.__init__(self, argument_control, label=label,
                               size=argument_control.box_size,
                               style=wx.ALIGN_CENTER_HORIZONTAL)
        
        old_foreground_color = self.GetForegroundColour()        
        
        faint_color = wx_tools.mix_wx_color(0.5,
                                            old_foreground_color,
                                            wx_tools.get_background_color())
        self.SetForegroundColour(faint_color)
        
        self.SetMinSize(argument_control.box_size)
        self.SetMaxSize(argument_control.box_size)
            
########NEW FILE########
__FILENAME__ = star_adder
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `StarAdder` class.

See its documentation for more details.
'''

import wx
import pkg_resources

from garlicsim.general_misc import caching
from garlicsim_wx.general_misc import wx_tools

from . import images as __images_package
images_package = __images_package.__name__


@caching.cache()
def get_bitmap():
    '''Get the "+" bitmap used for the star adder button.'''

    stream = pkg_resources.resource_stream(
        images_package,
        'plus.png'
    )
    
    return wx.BitmapFromImage(
        wx.ImageFromStream(
            stream,
            wx.BITMAP_TYPE_ANY
        )
    )


wxEVT_STAR_ADDER_PRESSED = wx.NewEventType()
EVT_STAR_ADDER_PRESSED = wx.PyEventBinder(
    wxEVT_STAR_ADDER_PRESSED,
    1
)
'''Event saying that a star adder button was pressed.'''


class StarAdder(wx.BitmapButton):
    '''Button for adding an entry for another star-arg or star-kwarg.'''
    def __init__(self, argument_control):
        self.argument_control = argument_control
        
        wx.BitmapButton.__init__(self, argument_control, bitmap=get_bitmap())
                
        self.Bind(wx.EVT_BUTTON, self.on_button)
        
    def on_button(self, event):
        wx_tools.post_event(self, EVT_STAR_ADDER_PRESSED, source=self)
        event.Skip()
            
        

########NEW FILE########
__FILENAME__ = star_arg
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `StarArg` class.

See its documentation for more details.
'''

import wx

from garlicsim_wx.general_misc import wx_tools

from .close_button import CloseButton
from .value_text_ctrl import ValueTextCtrl


class StarArg(wx.Panel):
    '''
    Widget for specifying an extraneous positional argument (for `*args`).
    '''
    def __init__(self, argument_control, star_arg_box, value=''):
        wx.Panel.__init__(self, argument_control)
        if wx.Platform == '__WXGTK__':
            self.SetBackgroundColour(wx_tools.get_background_color())
        
        self.argument_control = argument_control
        
        self.star_arg_box = star_arg_box
        
        self.main_h_sizer = wx.BoxSizer(wx.HORIZONTAL)
        
        self.value_text_ctrl = ValueTextCtrl(
            self,
            value=value
        )
        
        self.main_h_sizer.Add(self.value_text_ctrl, 1,
                              wx.ALIGN_CENTER_VERTICAL)
        
        self.close_button = CloseButton(self)
        
        self.main_h_sizer.Add(self.close_button, 0,
                              wx.ALIGN_CENTER_VERTICAL)
        
        self.SetSizer(self.main_h_sizer)
        
        self.Bind(wx.EVT_BUTTON, lambda event: self.remove(),
                  source=self.close_button)
    
        
    def remove(self):
        '''Remove this `StarArg` from the containing `StarArgBox`.'''
        self.star_arg_box.remove(self)
        
        
    def get_value_string(self):
        '''Get the value of the arument as a string.'''
        return self.value_text_ctrl.GetValue()
        
        
        
            
########NEW FILE########
__FILENAME__ = star_arg_box
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `StarArgBox` class.

See its documentation for more details.
'''

from __future__ import with_statement

import wx

from garlicsim.general_misc import cute_inspect
from garlicsim_wx.general_misc import wx_tools

from .star_arg import StarArg
from .star_adder import StarAdder, EVT_STAR_ADDER_PRESSED


class StarArgBox(wx.StaticBox):
    '''
    Static box for specifying extraneous args (`*args`) to the step function.
    
    Note that this static box is not the parent of the widgets it creates.
    '''
    def __init__(self, argument_control, step_function):
        self.argument_control = argument_control
        
        wx.StaticBox.__init__(self, argument_control,
                              label='Additional arguments')
        
        self.SetMinSize(argument_control.box_size)
        self.SetMaxSize(argument_control.box_size)
        
        self.sizer = wx.StaticBoxSizer(self, wx.VERTICAL)
        
        self.sizer.SetMinSize(argument_control.box_size)
        
        self.step_function = step_function
        
        arg_spec = cute_inspect.getargspec(step_function)
        
        star_arg_list = \
            argument_control.step_profile_dialog.step_functions_to_star_args[
                step_function
            ]
        
        
        self.star_args = []
        
        for star_arg_value in star_arg_list:
            star_arg = StarArg(argument_control, self, star_arg_value)
            self.star_args.append(star_arg)
            self.sizer.Add(star_arg, 0, wx.EXPAND | wx.ALL, border=5)
            
        self.star_adder = StarAdder(argument_control)
        self.sizer.Add(self.star_adder, 0, wx.EXPAND | wx.ALL, border=5)
        
        self.Parent.Bind(EVT_STAR_ADDER_PRESSED, self.on_star_adder_pressed,
                         source=self.star_adder)
        
        
    def on_star_adder_pressed(self, event):
        
        with wx_tools.WindowFreezer(self.Parent.Parent):
            star_arg = StarArg(self.argument_control, self)
            star_arg.MoveBeforeInTabOrder(self.star_adder)
            star_arg.SetFocus()
            self.star_args.append(star_arg)
            self.sizer.Insert(len(self.sizer.GetChildren()) - 1, star_arg, 0,
                              wx.EXPAND | wx.ALL, border=5)
            self.layout()

        
    def layout(self):

        with wx_tools.WindowFreezer(self.Parent.Parent):
        
            self.Parent.main_h_sizer.Fit(self.Parent)
            self.Parent.Layout()
            self.Parent.Parent.main_v_sizer.Fit(self.Parent.Parent)
            self.Parent.Parent.Layout()
        
            
    def remove(self, star_arg):
        '''Remove a `StarArg` from this box.'''
        index = self.star_args.index(star_arg)
        
        if index >= 1:
            place_to_put_focus_in = \
                self.star_args[index - 1].value_text_ctrl
        elif len(self.star_args) >= 2:
            place_to_put_focus_in = \
                self.star_args[1].value_text_ctrl
        else:
            place_to_put_focus_in = self.star_adder
            
        with wx_tools.WindowFreezer(self.Parent.Parent):
            self.star_args.remove(star_arg)
            self.sizer.Remove(star_arg)
            star_arg.DestroyChildren()
            star_arg.Destroy()
            self.layout()
        
        place_to_put_focus_in.SetFocus()
########NEW FILE########
__FILENAME__ = star_kwarg
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `StarKwarg` class.

See its documentation for more details.
'''

import wx

from garlicsim.general_misc import misc_tools
from garlicsim_wx.general_misc import wx_tools

from .name_text_ctrl import NameTextCtrl
from .value_text_ctrl import ValueTextCtrl
from .close_button import CloseButton


class StarKwarg(wx.Panel):
    '''
    Widget for specifying an extraneous keyword argument (for `**kwargs`).
    
    Allows used to type both a keyword name and a value to be assigned to it.
    '''
    def __init__(self, argument_control, star_kwarg_box, name='', value=''):
        wx.Panel.__init__(self, argument_control)
        if wx.Platform == '__WXGTK__':
            self.SetBackgroundColour(wx_tools.get_background_color())
        
        self.argument_control = argument_control
        
        self.star_kwarg_box = star_kwarg_box
        
        self.main_h_sizer = wx.BoxSizer(wx.HORIZONTAL)
        
        self.name_text_ctrl = NameTextCtrl(self, value=name)
        self.main_h_sizer.Add(self.name_text_ctrl, 4,
                              wx.ALIGN_CENTER_VERTICAL)
                
        self.static_text = wx.StaticText(self, label=('='))
        
        self.main_h_sizer.Add(self.static_text, 0,
                              wx.ALIGN_CENTER_VERTICAL)
        
        self.value_text_ctrl = ValueTextCtrl(
            self,
            value=value
        )
        self.main_h_sizer.Add(self.value_text_ctrl, 6,
                              wx.ALIGN_CENTER_VERTICAL)
        
        self.close_button = CloseButton(self)
        
        self.main_h_sizer.Add(self.close_button, 0,
                              wx.ALIGN_CENTER_VERTICAL)
        
        self.SetSizer(self.main_h_sizer)
        
        self.Bind(wx.EVT_BUTTON, lambda event: self.remove(),
                  source=self.close_button)
        

        
    def remove(self):
        '''Remove this `StarKwarg` from the containing `StarKwargBox`.'''
        self.star_kwarg_box.remove(self)
        
        
    def get_name_string(self):
        '''Get the name of the kwarg as a string.'''
        return str(self.name_text_ctrl.GetValue())
    
    
    def get_value_string(self):
        '''Get the value of the kwarg as a string.'''
        return self.value_text_ctrl.GetValue()
        
########NEW FILE########
__FILENAME__ = star_kwarg_box
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `StarKwargBox` class.

See its documentation for more details.
'''

from __future__ import with_statement

import wx

from garlicsim.general_misc import cute_inspect
from garlicsim_wx.general_misc import wx_tools

from .star_kwarg import StarKwarg
from .star_adder import StarAdder, EVT_STAR_ADDER_PRESSED


class StarKwargBox(wx.StaticBox):
    '''
    Static box for specifying `**kwargs` to the step function.
    
    Note that this static box is not the parent of the widgets it creates.
    '''
    def __init__(self, argument_control, step_function):
        self.argument_control = argument_control
        
        wx.StaticBox.__init__(self, argument_control,
                              label='Additional keyword arguments')
        
        self.SetMinSize(argument_control.box_size)
        self.SetMaxSize(argument_control.box_size)
        
        self.sizer = wx.StaticBoxSizer(self, wx.VERTICAL)
        
        self.sizer.SetMinSize(argument_control.box_size)
        
        self.step_function = step_function
        
        arg_spec = cute_inspect.getargspec(step_function)
        
        star_kwarg_dict = \
            argument_control.step_profile_dialog.step_functions_to_star_kwargs[
                step_function
            ]
        
        self.star_kwargs = []
        
        for name, value in star_kwarg_dict.iteritems():
            star_kwarg = StarKwarg(argument_control, self, name, value)
            self.star_kwargs.append(star_kwarg)
            self.sizer.Add(star_kwarg, 0, wx.EXPAND | wx.ALL, border=5)
            
        self.star_adder = StarAdder(argument_control)
        self.sizer.Add(self.star_adder, 0, wx.EXPAND | wx.ALL, border=5)
        
        self.Parent.Bind(EVT_STAR_ADDER_PRESSED, self.on_star_adder_pressed,
                         source=self.star_adder)
        
        
    def on_star_adder_pressed(self, event):
        
        with wx_tools.WindowFreezer(self.Parent.Parent):
            star_kwarg = StarKwarg(self.argument_control, self)
            star_kwarg.MoveBeforeInTabOrder(self.star_adder)
            star_kwarg.SetFocus()
            self.star_kwargs.append(star_kwarg)
            self.sizer.Insert(len(self.sizer.GetChildren()) - 1, star_kwarg, 0,
                              wx.EXPAND | wx.ALL, border=5)
            self.layout()

        
    def layout(self):

        with wx_tools.WindowFreezer(self.Parent.Parent):
        
            self.Parent.main_h_sizer.Fit(self.Parent)
            self.Parent.Layout()
            self.Parent.Parent.main_v_sizer.Fit(self.Parent.Parent)
            self.Parent.Parent.Layout()
        
            
    def remove(self, star_kwarg):
        '''Remove a `StarKwarg` from this `StarKwargBox`.'''
        index = self.star_kwargs.index(star_kwarg)
        
        if index >= 1:
            place_to_put_focus_in = \
                self.star_kwargs[index - 1].value_text_ctrl
        elif len(self.star_kwargs) >= 2:
            place_to_put_focus_in = \
                self.star_kwargs[1].value_text_ctrl
        else:
            place_to_put_focus_in = self.star_adder
        
        with wx_tools.WindowFreezer(self.Parent.Parent):
            self.star_kwargs.remove(star_kwarg)
            self.sizer.Remove(star_kwarg)
            star_kwarg.DestroyChildren()
            star_kwarg.Destroy()
            self.layout()
            
        place_to_put_focus_in.SetFocus()
        
        
########NEW FILE########
__FILENAME__ = value_text_ctrl
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `ValueTextCtrl` class.

See its documentation for more details.
'''

import wx

from . import colors


class ValueTextCtrl(wx.TextCtrl):
    '''Widget for inputting a Python expression for an argument value.'''
    
    def __init__(self, parent, value='', root=None):
        
        wx.TextCtrl.__init__(self, parent, value=value)
        
        self._original_background_color = self.GetBackgroundColour()
        
        self.root = root
        
        self.SetMinSize((10, -1))
        
        self.Bind(wx.EVT_KILL_FOCUS, self.on_kill_focus)
        
        self.Bind(wx.EVT_TEXT, self.on_text)
        
        self.error_mode = False
        
    
    def _check_validity_and_color(self):
        '''
        Check whether the expression is valid, if it isn't show error color.
        '''
        try:
            self.Parent.argument_control.step_profile_dialog.resolve(
                str(self.GetValue())
            )
        except Exception:
            is_valid = False
        else:
            is_valid = True
            
        if is_valid:
            self.SetBackgroundColour(self._original_background_color)
        else: # not is_valid
            self.SetBackgroundColour(colors.get_error_background_color())
        self.Refresh()
        return is_valid
            
        
    def on_text(self, event):
        if self.error_mode:
            self._check_validity_and_color()
            
            
    def on_kill_focus(self, event):
        event.Skip()
        if self.FindFocus() != self:
            if not self._check_validity_and_color() and not self.error_mode:
                self.error_mode = True
########NEW FILE########
__FILENAME__ = static_function_text
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `StaticFunctionText` class.

See its documentation for more details.
'''

import wx

from garlicsim_wx.general_misc import wx_tools

import garlicsim


class StaticFunctionText(wx.Panel):
    '''Static text showing information about the current step function.'''
    
    def __init__(self, step_profile_dialog, step_function=None):
        
        self.step_profile_dialog = step_profile_dialog
        
        self.width = 400 if wx.Platform == '__WXMSW__' else 500
        
        self.step_function = None
        
        wx.Panel.__init__(self, step_profile_dialog)
        
        self.SetBackgroundColour(wx_tools.get_background_color())
        
        self.text = wx.StaticText(self, style=wx.ALIGN_CENTER_HORIZONTAL)
        
        self.SetMinSize((self.width, 25))
        
        #self.SetBackgroundColour(wx_tools.get_background_color())
        
        self.text.Wrap(self.width - 10)
        
        self.Bind(wx.EVT_SIZE, self.on_size)
        
        self.main_h_sizer = wx.BoxSizer(wx.HORIZONTAL)
        
        self.v_sizer = wx.BoxSizer(wx.VERTICAL)
        
        self.main_h_sizer.Add(self.v_sizer, 1, wx.ALIGN_CENTER_VERTICAL)
        
        self.v_sizer.Add(self.text, 0, wx.ALIGN_CENTER_HORIZONTAL)
        
        self.SetSizer(self.main_h_sizer)
        
        self._error_color = wx.Colour(255, 200, 200)
        self._success_color = wx.Colour(200, 255, 200)

        self.valid_step_function = True
        
        
        
        
    def set_error_text(self, error_text):
        '''Set the error text to show.'''
        self.text.SetLabel(error_text)
        self.text.Wrap(self.width - 10)
        self.step_function = None
        
        self.Layout()
        
        
    def set_step_function(self, step_function):
        '''Set the step function to show information about.'''
        if step_function != self.step_function:
            self.step_function = step_function
            step_type = garlicsim.misc.simpack_grokker.step_type.BaseStep.\
                      get_step_type(step_function)
            step_function_address = self.step_profile_dialog.\
                                    describe(step_function)
            label = '`%s` is a %s.' % (
                step_function_address,
                step_type.verbose_name
            )
            self.text.SetLabel(label)
            self.text.Wrap(self.width - 10)
            #self.SetBackgroundColour(self._success_color)
            self.Layout()

    
    def on_size(self, event):
        pass
########NEW FILE########
__FILENAME__ = step_functions_to_argument_dicts
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `StepFunctionsToArgumentDicts` class.

See its documentation for more details.
'''

import collections

from garlicsim.general_misc import introspection_tools
from garlicsim.general_misc import address_tools


class StepFunctionsToArgumentDicts(dict):
    '''
    Dictionary mapping from a step function to an argument `dict`.
    
    This acts like a `defaultdict`. The default value for a new step function
    is a `dict` specifying the function's default values for the arguments.
    '''
    def __init__(self, describe_function, *args, **kwargs):
        dict.__init__(self, *args, **kwargs)
        self.describe = describe_function
        
    def __missing__(self, step_function):
        defaults = introspection_tools.get_default_args_dict(step_function)
        result = collections.defaultdict(
            lambda: '',
            dict(
                (key, self.describe(value)) for (key, value) in
                defaults.iteritems()
            )
        )
        self[step_function] = result
        return result
    
    # todo: Make `__repr__`. In the mean time we use this in order to not
    # confuse the user by looking like a `dict`:
    __repr__ = object.__repr__
########NEW FILE########
__FILENAME__ = step_function_input
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `StepFunctionInput` class.

See its documentation for more details.
'''

import types

import wx

import garlicsim_wx
import garlicsim

from .argument_control import colors


class StepFunctionInput(wx.ComboBox):
    '''
    Widget for specifying a step function.
    
    The step function is usually specified with the dropdown menu, but if it
    isn't in the simpack, it can be specified by typing in its address.
    '''
    def __init__(self, step_profile_dialog, value):
        self.step_profile_dialog = step_profile_dialog
        self.simpack_grokker = step_profile_dialog.simpack_grokker
        step_functions_list = [
            step_profile_dialog.describe(step_function) for
            step_function in self.simpack_grokker.all_step_functions
        ]
        
        # If there's an initial value from an existing step profile, make sure
        # it's first on the list:
        if value:
            if value in step_functions_list:
                step_functions_list.remove(value)
            step_functions_list.insert(0, value)
        
        width = 250 if wx.Platform == '__WXMSW__' else 300
            
        wx.ComboBox.__init__(self, step_profile_dialog, value=value,
                             choices=step_functions_list, size=(width, -1))
        
        self._original_background_color = self.GetBackgroundColour()
        
        self.error_mode = False
        
        self.Bind(wx.EVT_TEXT, self.on_text)
        self.Bind(wx.EVT_COMBOBOX, self.on_combo_box)
        
        self.Bind(wx.EVT_KILL_FOCUS, self.on_kill_focus)

        
    def select_step_function(self, step_function, step_function_string):
        '''
        Select `step_function`, with `step_function_string` being its address.
        '''
        if step_function_string not in self.GetItems():
            self.Append(step_function_string)
        self.step_profile_dialog.set_step_function(step_function)
        
        
    def try_to_parse_text_and_set(self):
        text = str(self.GetValue())
        try:
            thing = self.step_profile_dialog.resolve(text)
        except Exception:
            if self.error_mode:
                self._set_error_background()
            return
        else:
            step_type = garlicsim.misc.simpack_grokker.step_type.BaseStep.\
                      get_step_type(thing)
            if step_type:
                self.select_step_function(thing, text)
                if self.error_mode:
                    self._set_normal_background()
            else:
                assert step_type is None
                if self.error_mode:
                    self._set_error_background()
                return
                
                
    
    def parse_text_and_set(self):
        text = str(self.GetValue())
        try:
            thing = self.step_profile_dialog.resolve(text)
        except Exception:
            raise Exception("Error: Unable to resolve '%s' into a step "
                            "function." % text)
        else:
            step_type = garlicsim.misc.simpack_grokker.step_type.BaseStep.\
                      get_step_type(thing)
            if step_type:
                self.select_step_function(thing, text)
            else:
                assert step_type is None
                if callable(thing):
                    type_description = 'function' if \
                                     isinstance(thing, types.FunctionType) \
                                     else 'callable'
                    raise Exception("Error: `%s` is a %s, but it's not a step "
                                    "function." % (text, type_description))
                else:
                    raise Exception("Error `%s` is a not a step function; "
                                    "It's not even a callable." % text)
            
        
    def on_text(self, event):
        self.try_to_parse_text_and_set()
        
        
    def on_combo_box(self, event):
        self.try_to_parse_text_and_set()
        
        
    def on_kill_focus(self, event):
        event.Skip()
        if self.FindFocus() != self:
            try:
                self.parse_text_and_set()
            except Exception, exception:
                self.step_profile_dialog.static_function_text.set_error_text(
                    exception.args[0]
                )
                self.error_mode = True
                self._set_error_background()
            else:
                self._set_normal_background()

                
    def _set_error_background(self):
        '''Set the background of the control to an error color.'''
        self.SetBackgroundColour(colors.get_error_background_color())
        self.Refresh()
            
    
    def _set_normal_background(self):
        '''Set the background of the control to a non-error color.'''
        self.SetBackgroundColour(self._original_background_color)
        self.Refresh()
    

########NEW FILE########
__FILENAME__ = step_profile_dialog
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `StepProfileDialog` class.

See its documentation for more details.
'''

from __future__ import with_statement

import collections

import wx

from garlicsim.general_misc import address_tools
from garlicsim.general_misc import cute_inspect
from garlicsim_wx.widgets.general_misc.cute_dialog import CuteDialog
from garlicsim_wx.general_misc import wx_tools
from garlicsim_wx.widgets.general_misc.error_dialog import ErrorDialog

import garlicsim
import garlicsim_wx
from garlicsim.misc import StepProfile

from .static_function_text import StaticFunctionText
from .step_function_input import StepFunctionInput
from .argument_control import ArgumentControl, ResolveFailed
from .already_exists_dialog import AlreadyExistsDialog
from .step_functions_to_argument_dicts import StepFunctionsToArgumentDicts


class StepProfileDialog(CuteDialog):
    '''Dialog for creating a new step profile, possibly from template.'''
    
    def __init__(self, step_profiles_controls, step_profile=None,
                 and_fork=False):
        '''
        Construct the `StepProfileDialog`.
        
        If given a `step_profile`, use it as a template. If it's `None`, start
        from scratch. Set `and_fork=True` if you intend to fork right after
        getting the step profile, though note it will only affect the labels;
        the actual forking is not done here.
        '''
        
        self.step_profiles_controls = step_profiles_controls
        
        self.gui_project = step_profiles_controls.gui_project
        assert isinstance(self.gui_project, garlicsim_wx.GuiProject)
        
        self.frame = step_profiles_controls.frame
        
        self.and_fork = and_fork
        
        self.simpack = self.gui_project.simpack
        
        self.simpack_grokker = simpack_grokker = \
            self.gui_project.simpack_grokker
        
        title = 'Create a new step profile' if not and_fork else \
                'Create a new step profile and fork with it'
        CuteDialog.__init__(self, step_profiles_controls.GetTopLevelParent(),
                            title=title)
        
        self.SetDoubleBuffered(True)
        
        self.original_step_profile = original_step_profile = step_profile
        
        del step_profile        
        
        
        self.hue = self.gui_project.step_profiles_to_hues.default_factory()
        
        self.step_functions_to_argument_dicts = \
            StepFunctionsToArgumentDicts(self.describe)
        
        self.step_functions_to_star_args = \
            collections.defaultdict(lambda: [])
        
        self.step_functions_to_star_kwargs = \
            collections.defaultdict(lambda: {})

        
        if original_step_profile:
            
            original_step_function = original_step_profile.step_function

            self.step_function = original_step_function
            
            initial_step_function_address = self.describe(
                original_step_function
            )

            original_argument_dict = collections.defaultdict(
                lambda: '',
                original_step_profile.getcallargs_result
            )

            self.step_functions_to_argument_dicts[original_step_function] = \
                dict((key, self.describe(value)) for (key, value) in
                 original_argument_dict.iteritems())
            

            original_arg_spec = cute_inspect.getargspec(original_step_function)
            
            
            if original_arg_spec.varargs:
                star_args_value = original_step_profile.getcallargs_result[
                    original_arg_spec.varargs
                ]
                
                self.step_functions_to_star_args[original_step_function] = \
                    [self.describe(value) for value in
                     star_args_value]
            
            
            if original_arg_spec.keywords:
                star_kwargs_value = original_step_profile.getcallargs_result[
                    original_arg_spec.keywords
                ]
                
                self.step_functions_to_star_kwargs[original_step_function] = \
                    dict((key, self.describe(value)) for (key, value)
                         in star_kwargs_value.iteritems())
                
            
            
            
        else:
            
            self.step_function = None
            
            if len(simpack_grokker.all_step_functions) >= 2:
                initial_step_function_address = ''
            else: # len(simpack_grokker.all_step_functions) == 1
                initial_step_function_address = self.describe(
                    simpack_grokker.default_step_function
                )
        
            
        #######################################################################
        # Setting up widgets and sizers:
        
        self.main_v_sizer = wx.BoxSizer(wx.VERTICAL)

        
        
        self.static_text = wx.StaticText(self, label="Choose a step function:")
        
        self.main_v_sizer.Add(self.static_text,
                              0,
                              wx.EXPAND | wx.TOP | wx.LEFT | wx.RIGHT,
                              border=10)
        
        
        self.h_sizer = wx.BoxSizer(wx.HORIZONTAL)
        
        self.main_v_sizer.Add(
            self.h_sizer,
            0,
            wx.ALIGN_CENTER_HORIZONTAL | wx.ALL,            
            border=10
        )
        
        
        self.hue_control = \
            garlicsim_wx.widgets.general_misc.hue_control.HueControl(
                self,
                lambda: getattr(self, 'hue'),
                lambda hue: setattr(self, 'hue', hue),
                emitter=None,
                lightness=0.8,
                saturation=1,
                dialog_title='Select hue for new step profile',
                size=(25, 20)
            )
        
        self.h_sizer.Add(
            self.hue_control,
            0,
            wx.ALIGN_CENTER_VERTICAL
        )
        
        
        self.h_sizer.AddSpacer(5)
        
        
        self.step_function_input = StepFunctionInput(
            self,
            value=initial_step_function_address
        )
        
        self.h_sizer.Add(
            self.step_function_input,
            0,
            wx.ALIGN_CENTER_VERTICAL,
        )
        
        
        self.static_function_text = StaticFunctionText(
            self,
            step_function=original_step_function if original_step_profile \
                          else None
        )
        
        self.h_sizer.Add(
            self.static_function_text,
            0,
            wx.ALIGN_CENTER_VERTICAL | wx.LEFT,
            border=15
        )
        
        
        self.argument_control = ArgumentControl(
            self,
            original_step_function if original_step_profile else None
        )
        
        self.main_v_sizer.Add(
            self.argument_control,
            1,
            wx.ALIGN_CENTER_HORIZONTAL | wx.TOP,
            border=0
        )
        
        
        self.dialog_button_sizer = wx.StdDialogButtonSizer()
        
        self.main_v_sizer.Add(
            self.dialog_button_sizer,
            0,
            wx.ALIGN_CENTER | wx.ALL,
            border=10
        )
        
        ok_title = 'Create step profile' if not and_fork else \
                   'Create step profile and fork with it'
        self.ok_button = wx.Button(self, wx.ID_OK, title)
        self.dialog_button_sizer.AddButton(self.ok_button)
        self.ok_button.SetDefault()
        self.dialog_button_sizer.SetAffirmativeButton(self.ok_button)
        self.Bind(wx.EVT_BUTTON, self.on_ok, source=self.ok_button)
        
        self.cancel_button = wx.Button(self, wx.ID_CANCEL, 'Cancel')
        self.dialog_button_sizer.AddButton(self.cancel_button)
        self.Bind(wx.EVT_BUTTON, self.on_cancel, source=self.cancel_button)
        self.dialog_button_sizer.Realize()
    
        
        self.SetSizer(self.main_v_sizer)
        self.main_v_sizer.Fit(self)
        
        # Finished setting up sizers and widgets.
        #######################################################################
    
        
    def set_step_function(self, step_function):
        '''Set the step function to be used in our new step profile.'''
        if step_function != self.step_function:
            with wx_tools.WindowFreezer(self): 
                self.step_function = step_function
                self.static_function_text.set_step_function(step_function)
                self.argument_control.set_step_function(step_function)
        elif step_function != self.static_function_text.step_function:
            self.static_function_text.set_step_function(step_function)
        
        
    def describe(self, step_function):
        '''Describe `step_function` as a string.'''
        return address_tools.describe(
            step_function,
            shorten=True,
            root=self.simpack,
            namespace=self.gui_project.namespace
        )
        
    
    def resolve(self, address):
        '''Resolve `address` into a Python object.'''
        return address_tools.resolve(
            address,
            root=self.simpack,
            namespace=self.gui_project.namespace
        )

    
    def ShowModal(self):
        wx.CallAfter(self.step_function_input.try_to_parse_text_and_set)
        self.step_function_input.SetFocus()
        return super(StepProfileDialog, self).ShowModal()
    
    
    def on_ok(self, event):
        try:
            self.step_function_input.parse_text_and_set()
        except Exception, exception:
            error_dialog = ErrorDialog(self, exception.args[0])
            try:
                error_dialog.ShowModal()
            finally:
                error_dialog.Destroy()
            self.step_function_input.SetFocus()
            return
        
        try:
            self.argument_control.save()
        except ResolveFailed, resolve_failed_exception:
            error_dialog = ErrorDialog(self, resolve_failed_exception.message)
            try:
                error_dialog.ShowModal()
            finally:
                error_dialog.Destroy()
            resolve_failed_exception.widget.SetFocus()
            return

        step_function = self.step_function
        
        arg_spec = cute_inspect.getargspec(step_function)
        
        step_profile = StepProfile.create_from_dld_format(
            
            step_function,
            
            dict((key, self.resolve(value_string)) for 
                 (key, value_string) in self.\
                 step_functions_to_argument_dicts[step_function].iteritems()
                 if key in arg_spec.args),
            
            [self.resolve(value_string) for value_string in 
             self.step_functions_to_star_args[step_function]],
            
            dict((key, self.resolve(value_string)) for 
                 (key, value_string) in
                 self.step_functions_to_star_kwargs[step_function].iteritems())
        )
        
        
        if step_profile in self.gui_project.step_profiles:
            result = AlreadyExistsDialog.create_show_modal_and_destroy(
                self,
                step_profile,
                and_fork=self.and_fork
            )
            if result == wx.ID_OK:
                self.step_profile = step_profile
                self.EndModal(wx.ID_CANCEL)
                return
            else:
                assert result == wx.ID_CANCEL
                return
        else: # step_profile not in self.gui_project.step_profiles
            self.step_profile = step_profile
                
        self.EndModal(wx.ID_OK)
    
    
    def on_cancel(self, event):
        # ...
        self.step_profile = None
        self.EndModal(wx.ID_CANCEL)
        
                         
        
########NEW FILE########
__FILENAME__ = playback_controls
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `PlaybackControls` class.

See its documentation for more info.
'''

import pkg_resources
import wx

from garlicsim_wx.general_misc.third_party import aui
from garlicsim_wx.general_misc import thread_timer
from garlicsim_wx.general_misc.flag_raiser import FlagRaiser
from garlicsim_wx.general_misc import emitters
from garlicsim_wx.general_misc import wx_tools
from garlicsim_wx.widgets.general_misc.knob import Knob

import garlicsim, garlicsim_wx
from garlicsim_wx.widgets import WorkspaceWidget
from .scratch_wheel import ScratchWheel

from . import images as __images_package
images_package = __images_package.__name__


class CenterButtonMode(object):
    '''A mode that the center button can be in.'''
    

class PlayMode(CenterButtonMode):
    '''A mode in which pressing will cause playback to start.'''

    @staticmethod
    def action(playback_controls):
        '''Start playback.'''
        playback_controls.gui_project.start_playing()

        
class PauseMode(CenterButtonMode):
    '''A mode in which pressing will cause playback to pause.'''

    @staticmethod
    def action(playback_controls):
        '''Pause playback.'''
        playback_controls.gui_project.stop_playing()

        
class FinalizeMode(CenterButtonMode):
    '''A mode in which pressing will finalize the node being currently edited.'''

    @staticmethod
    def action(playback_controls):
        '''Finalize the node being currently edited.'''
        try:
            playback_controls.gui_project.finalize_active_node()
        except Exception: # todo: should have meaningful exceptions all over
            pass

        

class PlaybackControls(wx.Panel, WorkspaceWidget):
    '''Widget to control playback of the simulation.'''
    
    _WorkspaceWidget__name = 'Playback'

    def __init__(self, frame):
        wx.Panel.__init__(self, frame, -1, size=(184, 128),
                          style=wx.SUNKEN_BORDER)
        WorkspaceWidget.__init__(self, frame)
        
        #self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM)
        self.SetBackgroundColour(wx_tools.get_background_color())
        self.SetDoubleBuffered(True)
        
        
        assert isinstance(self.gui_project, garlicsim_wx.GuiProject)
        # I put this assert mainly for better source assistance in Wing.
        # It may be removed.
        
        self.Bind(wx.EVT_SIZE, self.on_size)
        self.Bind(wx.EVT_PAINT, self.on_paint)
        
        self.inner_panel = wx.Panel(self, -1, size=(184, 124))
        '''The panel that contains all the subwidgets.'''
        
        self.inner_panel.SetBackgroundColour(wx_tools.get_background_color())
        
        self.center_button_mode = PlayMode
        '''The current mode of the center button.'''

        bitmap_list = ['to_start', 'previous_node', 'play',
                                'next_node', 'to_end', 'pause',
                                'finalize']
        
        bitmaps_dict = self.bitmap_dict = {}
        for bitmap_name in bitmap_list:
            stream = pkg_resources.resource_stream(images_package,
                                                 bitmap_name + '.png')
            self.bitmap_dict[bitmap_name] = wx.BitmapFromImage(
                wx.ImageFromStream(
                    stream,
                    wx.BITMAP_TYPE_ANY
                )
            )
            
        
        self.center_button_bitmap_dict = {
            PlayMode: bitmaps_dict['play'],
            PauseMode: bitmaps_dict['pause'],
            FinalizeMode: bitmaps_dict['finalize'],
            }
        

        v_sizer = self.v_sizer = wx.BoxSizer(wx.VERTICAL)


        playing_speed_getter = lambda: \
            self.gui_project.official_playing_speed / \
            self.gui_project.standard_playing_speed
        
        playing_speed_setter = lambda value: \
            self.gui_project.set_official_playing_speed(
                value * self.gui_project.standard_playing_speed
            )
        
        self.playing_speed_knob = Knob(
            self.inner_panel,
            getter = playing_speed_getter,
            setter = playing_speed_setter
        )
        '''Knob which controls the official playback speed.'''
        
        self.playing_speed_knob.set_snap_point(-1)
        self.playing_speed_knob.set_snap_point(1)
        
        
        self.knob_sizer = knob_sizer = wx.BoxSizer(wx.HORIZONTAL)
        knob_sizer.Add(
            self.playing_speed_knob,
            1,
            wx.EXPAND | wx.ALIGN_CENTER_HORIZONTAL |\
            wx.ALIGN_CENTER_VERTICAL | wx.LEFT,
            75
        )
        
        
        v_sizer.Add(
            knob_sizer, #self.playing_speed_knob, # knob_sizer,
            0,
            #wx.ALIGN_CENTER_HORIZONTAL #wx.EXPAND #|
        )


        h_sizer = wx.BoxSizer(wx.HORIZONTAL)
        
                           
        self.button_to_start = wx.BitmapButton(
            self.inner_panel, -1, bitmaps_dict['to_start'], size=(31, 50)
        )
        '''Button for moving to start of path.'''
        
        self.button_previous_node = wx.BitmapButton(
            self.inner_panel, -1, bitmaps_dict['previous_node'], size=(31, 50)
        )
        '''Button for moving to previous node.'''
        
        self.button_center_button = wx.BitmapButton(
            self.inner_panel, -1, bitmaps_dict['play'], size=(60, 50)
        )
        '''Button for playing/pausing playback, and finalizing edited node.'''
        
        self.button_next_node= wx.BitmapButton(
            self.inner_panel, -1, bitmaps_dict['next_node'], size=(31, 50)
        )
        '''Button for moving to next node.'''
        
        self.button_to_end = wx.BitmapButton(
            self.inner_panel, -1, bitmaps_dict['to_end'], size=(31, 50)
        )
        '''Button for moving to end of path.'''
        
        
        self.Bind(wx.EVT_BUTTON, self.on_button_to_start,
                  source=self.button_to_start)
        
        self.Bind(wx.EVT_BUTTON, self.on_button_previous_node,
                  source=self.button_previous_node)
        
        self.Bind(wx.EVT_BUTTON, self.on_button_center_button,
                  source=self.button_center_button)
        
        self.Bind(wx.EVT_BUTTON, self.on_button_next_node,
                  source=self.button_next_node)
        
        self.Bind(wx.EVT_BUTTON, self.on_button_to_end,
                  source=self.button_to_end)
        
        button_line = (
            self.button_to_start,
            self.button_previous_node,
            self.button_center_button,
            self.button_next_node,
            self.button_to_end
        )
        
        for button in button_line:
            h_sizer.Add(button, 0)
        v_sizer.Add(h_sizer, 0)#1, wx.EXPAND)


        self.scratch_wheel = ScratchWheel(self.inner_panel, self.gui_project,
                                          -1, size=(184, 44))
        v_sizer.Add(self.scratch_wheel, 0)


        self.inner_panel.SetSizer(v_sizer)
        knob_sizer.Layout()
        h_sizer.Layout()
        v_sizer.Layout()
        
        
        self.center_button_update_flag = True
        '''Flag saying whether the center button needs update.'''
        
        self.navigation_buttons_update_flag = True
        '''Flag saying whether the navigation buttons need update.'''
        
        self.playing_speed_knob_update_flag = True
        '''Flag saying whether the playing speed knob needs update.'''
        
        self.center_button_needs_update_emitter = \
            self.gui_project.emitter_system.make_emitter(
                inputs=(
                    self.gui_project.playing_toggled_emitter,
                    self.gui_project.active_node_changed_or_modified_emitter,
                    self.gui_project.active_node_finalized_emitter
                ),
                outputs=(
                    FlagRaiser(self, 'center_button_update_flag',
                               function=self._update_center_button, delay=0.03),
                ),
                name='playback_controls_center_button_needs_update',
        )
        

        self.navigation_buttons_need_update_emitter = \
            self.gui_project.emitter_system.make_emitter(
                inputs=(
                    self.gui_project.active_node_changed_emitter,
                    self.gui_project.path_contents_changed_emitter
                ),            
                outputs=(
                    FlagRaiser(
                        self, 'navigation_buttons_update_flag',
                        function=self._update_navigation_buttons, delay=0.03
                        ),
                ),
                name='playback_controls_navigation_buttons_need_update',
        )
        
        
        self.gui_project.official_playing_speed_modified_emitter.add_output(
            FlagRaiser(self.playing_speed_knob, 'recalculation_flag',
                       self.playing_speed_knob._recalculate, delay=0.03)
        )


    def on_size(self, event):
        '''EVT_SIZE handler.'''
        self.Refresh()
        event.Skip()
    
        
    def on_paint(self, event):
        '''EVT_PAINT handler.'''
        
        if self.center_button_update_flag:
            self._update_center_button()
        if self.navigation_buttons_update_flag:
            self._update_navigation_buttons()
        
        event.Skip()
        

    def _update_navigation_buttons(self):
        '''Update the navigation buttons, disabling/enabling them as needed.'''
        
        active_node = self.gui_project.active_node
        
        if self.gui_project.path is None or active_node is None:
            self.button_to_start.Disable()
            self.button_previous_node.Disable()
            self.button_next_node.Disable()
            self.button_to_end.Disable()
    
        else:      
            if active_node.parent is not None:
                self.button_previous_node.Enable()
                self.button_to_start.Enable()
            else:
                self.button_previous_node.Disable()
                self.button_to_start.Disable()
                
            if active_node.children:
                self.button_next_node.Enable()
                self.button_to_end.Enable()
            else:
                self.button_next_node.Disable()
                self.button_to_end.Disable()
        
        self.navigation_buttons_update_flag = False    
        
    def _update_center_button(self):
        '''Update the center button, changing its mode if needed.'''
        gui_project = self.gui_project
        active_node = gui_project.active_node
        
        if gui_project.path is None or active_node is None:
            self.set_center_button_mode(PlayMode)
            self.button_to_start.Disable()
        else:
            self.button_to_start.Enable()
            # todo: find out if it's wasteful to call enable if the button's
            # enbaled
            
            if active_node.still_in_editing:
                self.set_center_button_mode(FinalizeMode)
            elif self.gui_project.is_playing:
                self.set_center_button_mode(PauseMode)
            else: # self.gui_project.is_playing is False
                self.set_center_button_mode(PlayMode)
        
        self.center_button_update_flag = False
    
    def set_center_button_mode(self, center_button_mode): 
        '''Set the mode of the center button.'''
        # Not privatized because it's a setter
        if self.center_button_mode == center_button_mode:
            return
        self.button_center_button.SetBitmapLabel(
            self.center_button_bitmap_dict[center_button_mode]
        )
        self.center_button_mode = center_button_mode
       
        
    def on_button_to_start(self, e=None):
        '''Handler for when the to_start button gets pressed.'''
        try:
            if self.gui_project.path is None: return
            head_node = self.gui_project.path[0]
            self.gui_project.set_active_node(head_node)
        except garlicsim.data_structures.path.PathOutOfRangeError:
            return
        
    def on_button_to_end(self, e=None):
        '''Handler for when the to_end button gets pressed.'''
        try:
            if self.gui_project.path is None: return
            tail_node = self.gui_project.path[-1]
            self.gui_project.set_active_node(tail_node)
        except garlicsim.data_structures.path.PathOutOfRangeError:
            return
    
    def on_button_previous_node(self, e=None):
        '''Handler for when the previous_node button gets pressed.'''
        if self.gui_project.active_node is None: return
        previous_node = self.gui_project.active_node.parent
        if previous_node is not None:
            self.gui_project.set_active_node(previous_node)
        
                
    def on_button_next_node(self, e=None):
        '''Handler for when the next_node button gets pressed.'''
        if self.gui_project.active_node is None: return
        try:
            next_node = \
                self.gui_project.path.next_node(self.gui_project.active_node)
            self.gui_project.set_active_node(next_node)
        except garlicsim.data_structures.path.PathOutOfRangeError:
            return
        
    def on_button_center_button(self, e=None):
        '''Handler for when the center button gets pressed.'''
        self.center_button_mode.action(self)
            
            
            
########NEW FILE########
__FILENAME__ = scratch_wheel
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `ScratchWheel` class.

See its documentation for more info.
'''

# todo: currently has horrible cruft

from __future__ import division

import wx
import math
import time

from garlicsim_wx.widgets import WorkspaceWidget
from garlicsim_wx.general_misc import cursor_collection
from garlicsim_wx.general_misc import cute_timer
from garlicsim.general_misc import math_tools
from garlicsim_wx.general_misc.flag_raiser import FlagRaiser

import garlicsim, garlicsim_wx
from . import images


__all__ = ["ScratchWheel"]


class ScratchWheel(wx.Panel):
    '''Widget for visualizing playback and browsing small time intervals.'''
    def __init__(self, parent, gui_project, *args, **kwargs):
        
        if 'style' in kwargs:
            kwargs['style'] |= wx.SUNKEN_BORDER
        else:
            kwargs['style'] = wx.SUNKEN_BORDER
            
        wx.Panel.__init__(self, parent, *args, **kwargs)
        
        self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM)
        
        self.Bind(wx.EVT_PAINT, self.on_paint)
        self.Bind(wx.EVT_SIZE, self.on_size)
        self.Bind(wx.EVT_MOUSE_EVENTS, self.on_mouse_event)
        self.Unbind(wx.EVT_ERASE_BACKGROUND) # Good or bad?
        
        self.SetCursor(cursor_collection.get_open_grab())
        
        self.gui_project = gui_project
        '''The gui project that this scratch wheel is attached to.'''
        
        assert isinstance(self.gui_project, garlicsim_wx.GuiProject)
        
        self.current_frame_number = -1
        '''Serial number of the frame that is currently drawn.'''
        # Set to -1 to make sure first drawing won't fuck up
        
        self.current_blur_alpha = 0.
        '''The current level of motion blur. Between 0 and 1.'''
        
        self.current_bitmap = None
        '''Current bitmap of the wheel.'''
        
        self.image_size = images.get_image_size()
        '''The size of the gear image.'''
        
        self.clock_factor = 0.05 # todo: maybe rename
        '''
        Factor for converting from simulations seconds to radians in the gear.
        '''
        
        self.being_dragged = False
        '''Flag that says whether the gear is currently being dragged.'''
        
        self.grabbed_angle = None
        '''The angle that the user grabbed when starting to drag.'''
        
        self.grabbed_pseudoclock = None
        '''The pseudoclock that the user grabbed when starting to drag.'''
        
        self.angle_while_dragging = None
        
        self.d_angle_while_dragging = None
        
        self.desired_clock_while_dragging = None
                
        self.last_tracked_time_and_angle = (0, 0)
        '''A tuple of (time, angle) that was recorded for velocity tracking.'''
        
        self.current_velocity_estimate = 0
        '''
        The current estimate of the gear's velocity.
        
        The units are radian per second, and that's a real world second, not in
        the simulation.
        '''
        
        self.velocity_for_maximal_motion_blur = 10
        '''Velocity in which the scratch wheel will get maximal motion blur.'''
        
        self.velocity_time_sampling_minimum = 0.07
        '''Minimum interval over which we can measure the gear's velocity.'''
        
        self.was_playing_before_drag = None
        '''Flag saying if playback was active before user grabbed the gear.'''
            
        self.motion_blur_update_timer = cute_timer.CuteTimer(self)
        '''
        Timer to use for updating the motion blur bitmap.
        
        The motion blur bitmap must get updated periodically as long as its
        last value was non-zero, even if the user doesn't touch anything. This
        is because we don't want to have a situtation where the user dragged
        fast, got a high motion blur, left the scratch wheel, and then the
        wheel is frozen with a high motion blur.
        '''
        
        self.Bind(wx.EVT_TIMER,
                  self.on_motion_blur_update_timer,
                  self.motion_blur_update_timer)
        
        
        self.recalculation_flag = False
        '''Flag saying whether the scratch wheel needs to recalculate.'''
        
        self.needs_recalculation_emitter = \
            self.gui_project.emitter_system.make_emitter(
                inputs=(
                    self.gui_project.pseudoclock_modified_emitter,
                    self.gui_project.active_node_changed_or_modified_emitter
                    # todo: needed?
                ),
                outputs=(
                    FlagRaiser(self, 'recalculation_flag',
                               function=self._recalculate),
                    # todo: There was originally delay=0.03 here, but it made 
                    # things too sluggish so I removed it. Will this cause a
                    # problem?
                ),
                name='needs_recalculation',
            )
        
        
        self.needs_recalculation_emitter.emit()
        
        
    """
    @staticmethod
    def _pos_to_angle(pos):
        return -math.acos(-1 + 2*pos)
    
    @staticmethod
    def _angle_to_pos(angle):
        return (1 + math.cos(-angle)) / 2
    """
    
    @staticmethod
    def _expanded_pos_to_angle(pos):
        '''Convert from pos to angle, expanded.'''
        pos = (pos * 0.8) + 0.1
        return -math.pi * (1 - pos)
    
    
    @staticmethod    
    def _expanded_angle_to_pos(angle):
        '''Convert from angle to pos, expanded.'''
        pos = 1 - (angle / (-math.pi))
        return (pos - 0.1) / 0.8

    
    def get_current_angle(self):
        '''Get the angle that the scratch wheel should be in.'''
        return self.gui_project.pseudoclock * self.clock_factor
                    
    
    def _recalculate(self, possibly_refresh=True):
        '''
        Recalculate the scratch wheel.
        
        If `possibly_refresh` is True, and this function sees that the image on
        the scratch wheel should change, then it will trigger a `Refresh`.
        '''
        angle = self.get_current_angle()
        frame_number = int(
            ((angle % ((2/3) * math.pi)) / (2 * math.pi)) * 3 * images.N_FRAMES
        )
        if frame_number == images.N_FRAMES:
            frame_number =- 1
        
        if self.current_frame_number != frame_number:
            self.current_frame_number = frame_number
            if possibly_refresh:
                self.Refresh()
        
        self.__update_motion_blur_bitmap(possibly_refresh)
        
        self.recalculation_flag = False
    
        
    def __update_motion_blur_bitmap(self, possibly_refresh):
        '''
        Check the speed and update the motion blur bitmap if necessary.
        
        If `possibly_refresh` is True, and this function sees that the image on
        the scratch wheel should change, then it will trigger a `Refresh`.
        '''

        current = (time.time(), self.get_current_angle())
        last = self.last_tracked_time_and_angle

        d_time = current[0] - last[0]
        d_angle = current[1] - last[1]
        
        if d_time < self.velocity_time_sampling_minimum:
            self.motion_blur_update_timer.Start(30)
            return
            # This protects us from two things: Having a grossly inaccurate
            # velocity reading because of tiny sample, and having a division by
            # zero.
        
        self.current_velocity_estimate = velocity = d_angle / d_time

        r_velocity = velocity / self.velocity_for_maximal_motion_blur

        alpha = min(abs(r_velocity), 1)
        
        alpha = min(alpha, 0.8)
        # I'm limiting the alpha, still want to see some animation
        
        self.current_blur_alpha = alpha
        
        new_bitmap = images.get_blurred_gear_image_by_ratio(
            self.current_frame_number,
            alpha
        )
        
        if self.current_bitmap is not new_bitmap:
            # No need to do this:
            # self.current_bitmap = new_bitmap
            # The `on_paint` handler will do it anyway
            if possibly_refresh:
                self.Refresh()
        
        if new_bitmap.blur_raw is not images.get_blur_image_raw(0):
            # We have a non-zero visible motion blur
            self.motion_blur_update_timer.Start(30)
        else:
            self.motion_blur_update_timer.Stop()
            
        self.last_tracked_time_and_angle = current
            
        
    def on_paint(self, event):
        '''EVT_PAINT handler.'''
        # todo: optimization: if motion blur is (rounded to) zero, don't draw
        
        event.Skip()
        
        if self.recalculation_flag:
            self._recalculate(possibly_refresh=False)
            # We make sure `_recalculate` won't refresh, because that would
            # make an infinite loop
            
        bw, bh = self.GetWindowBorderSize()
        
        ox, oy = ((4 - bw) / 2 , (4 - bh) / 2)

        self.current_bitmap = images.get_blurred_gear_image_by_ratio(
            self.current_frame_number,
            self.current_blur_alpha
        )
        
        #print(self.current_frame_number,
            #self.current_blur_alpha)
        
        dc = wx.PaintDC(self)
        dc.DrawBitmap(self.current_bitmap, ox, oy)
        # todo: Is the way I draw the bitmap the fastest way?
            
    def on_mouse_event(self, e):
        '''EVT_MOUSE_EVENTS handler.'''
        # todo: possibly do momentum, like in old shockwave carouselle.
        # todo: right click should give context menu with 'Sensitivity...' and
        # 'Disable'
        # todo: make check: if left up and has capture, release capture

        
        # If the gui project has no active path, we can't navigate on it at
        # all:
        if self.gui_project.path is None:
            return
        
        self.Refresh()
        
        (w, h) = self.GetClientSize()
        (x, y) = e.GetPositionTuple()
        (rx, ry) = (x/w, y/h)
        
        if e.LeftDown():
            self.angle_while_dragging = self.grabbed_angle = \
                self._expanded_pos_to_angle(rx)
            self.d_angle_while_dragging = 0
            self.desired_clock_while_dragging = self.grabbed_pseudoclock = \
                self.gui_project.pseudoclock
            self.was_playing_before_drag = self.gui_project.is_playing
            self.gui_project.stop_playing()
            self.being_dragged = True
            
            self.SetCursor(cursor_collection.get_closed_grab())
            # SetCursor must be before CaptureMouse because of wxPython/GTK
            # weirdness
            self.CaptureMouse()
            
            return
        
        if e.LeftIsDown():
            if not self.HasCapture():
                return
            self.angle_while_dragging = self._expanded_pos_to_angle(rx)
            self.d_angle_while_dragging = \
                (self.angle_while_dragging - self.grabbed_angle)
            
            desired_pseudoclock = self.grabbed_pseudoclock + \
                (self.d_angle_while_dragging / self.clock_factor)
            
            self.gui_project.set_pseudoclock(desired_pseudoclock)
            
            if self.gui_project.pseudoclock != desired_pseudoclock:
                # Means we got an edge node
                
                edge_clock = self.gui_project.active_node.state.clock
                direction = cmp(self.gui_project.pseudoclock,
                                desired_pseudoclock)
                # direction that we bring back the cursor to if it goes too far
                d_clock = (edge_clock - self.grabbed_pseudoclock)
                d_angle = d_clock * self.clock_factor
                edge_angle = self.grabbed_angle + d_angle
                edge_rx = self._expanded_angle_to_pos(edge_angle)
                edge_x = edge_rx * w
                is_going_over = \
                    (edge_x - x > 0) if direction == 1 else (edge_x - x < 0)
                if is_going_over:
                    self.WarpPointer(edge_x, y)
            
                
        if e.LeftUp(): #or e.Leaving():
            # todo: make sure that when leaving entire app, things don't get
            # fucked
            if self.HasCapture():
                self.ReleaseMouse()
            # SetCursor must be after ReleaseMouse because of wxPython/GTK
            # weirdness
            self.SetCursor(cursor_collection.get_open_grab())
            self.being_dragged = False
            self.grabbed_angle = None
            self.grabbed_pseudoclock = None
            self.angle_while_dragging = None
            self.d_angle_while_dragging = None
            self.desired_clock_while_dragging = None
            
            if self.was_playing_before_drag:
                self.gui_project.start_playing()
                
            self.gui_project.round_pseudoclock_to_active_node()
                
            self.was_playing_before_drag = None
            

    def on_size(self, event):
        '''EVT_SIZE handler.'''
        self.Refresh()
        if event is not None:
            event.Skip()
    
    def on_motion_blur_update_timer(self, event):
        '''Handler for when the motion blur timer goes off.'''
        self.recalculation_flag = True
        self.Refresh()
        
        
        

########NEW FILE########
__FILENAME__ = seek_bar
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `SeekBar` class.

See its documentation for more info.
'''

import wx
import math

from garlicsim_wx.general_misc.get_lines import get_lines
from garlicsim_wx.general_misc import emitters
from garlicsim_wx.general_misc import wx_tools
from garlicsim_wx.general_misc.flag_raiser import FlagRaiser

from garlicsim_wx.widgets import WorkspaceWidget
import garlicsim
import garlicsim_wx


class SeekBar(wx.Panel, WorkspaceWidget):
    '''
    Seek-bar widget, allowing navigation and visualization of the active path.
    
    The seek-bar is attached to a path. It shows what time period the path
    spans. It shows which node is currently active. It allows to move to any
    other node on the path just by clicking.
    '''
    #todo: show little breaks on the bar where there's a block start/end
    def __init__(self, frame):
        
        wx.Panel.__init__(self, frame, size=(100, 100), style=wx.SUNKEN_BORDER)
        WorkspaceWidget.__init__(self, frame)
        
        self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM)
        self.SetBackgroundColour(wx_tools.get_background_color())
        
        self.Bind(wx.EVT_PAINT, self.on_paint)
        self.Bind(wx.EVT_SIZE, self.on_size)
        self.Bind(wx.EVT_MOUSE_EVENTS, self.on_mouse_event)
        self.Bind(wx.EVT_KEY_DOWN, self.on_key_down)

        self.zoom = 1.
        self.start = 0.

        self.screenify = lambda x: (x-self.start)*self.zoom
        '''Translate from time point to on-screen coordinate.'''
        
        self.unscreenify = lambda x: (x/self.zoom)+self.start
        '''Translate from on-screen coordinate to time point.'''

        self.was_playing_before_mouse_click = None
        self.was_playing_before_mouse_click_but_then_paused_and_mouse_left = \
            None
        self.active_triangle_width = 13 # Must be odd number

        self.view_changed_flag = False
        self.active_node_changed_or_modified_flag = False
        self.path_contents_changed_flag = False
        
        self.view_change_emitter = emitters.Emitter()
        self.gui_project.active_node_changed_or_modified_emitter.add_output(
            FlagRaiser(self, 'active_node_changed_or_modified_flag')
        )
        self.gui_project.path_contents_changed_emitter.add_output(
            FlagRaiser(self, 'path_contents_changed_flag')
        )


    def on_paint(self, event):
        '''Refresh the seek-bar.'''
        event.Skip()
        

        self.view_changed_flag = False
        self.active_node_changed_or_modified_flag = False
        self.path_contents_changed_flag = False
        # todo: now we just lower these flags retardedly, in future there will
        # be __recalculate
        
        occupied_region = wx.Region()

        if (self.gui_project is None) or (self.gui_project.path is None):
            return
        
        (w, h) = self.GetSize()
        start = self.start
        end = self.start + (w / self.zoom)
        dc = wx.BufferedPaintDC(self)

        dc.SetBackground(wx_tools.get_background_brush())
        dc.Clear()
        
        #dc.DrawRectangle(3,3,50,90)
        if self.gui_project.path is not None: # Draw rect for renedered segment
            seg = self.gui_project.path.get_existing_time_segment(start, end)
            if seg is not None:
                dc.SetPen(wx.Pen('#000000'))
                dc.SetBrush(wx.Brush('#FFFFB8'))
                sseg = [self.screenify(thing) for thing in seg]
                dc.DrawRectangle(sseg[0], 0, sseg[1]-sseg[0], h-4)
                occupied_region = wx.Region(sseg[0] + 1, 1,
                                            sseg[1] - sseg[0] - 2,
                                            h - 6)

        active = self.gui_project.active_node
        if active is not None:
            active_start = active.state.clock
            try:
                after_active = self.gui_project.path.next_node(active)
                active_end = after_active.state.clock
            except garlicsim.data_structures.path.PathOutOfRangeError:
                after_active = None
                active_end = active_start
            active_inside = False
            screen_active_start = start
            screen_active_end = end

            if start <= active_start <= end:
                active_inside = True
                screen_active_start = self.screenify(active_start)

            if start <= active_end <= end:
                active_inside = True
                screen_active_end = self.screenify(active_end)


            dc.SetBrush(wx.Brush('#FF9933'))
            dc.SetPen(wx.Pen('#000000', 1, wx.TRANSPARENT))
            if active_inside is True:
                dc.DrawRectangle(
                    math.floor(screen_active_start),
                    1,
                    math.ceil(screen_active_end-screen_active_start),
                    h-6)
                triangle_half_width = \
                    math.ceil(self.active_triangle_width / 2.0)
                dc.SetClippingRegionAsRegion(occupied_region)
                dc.DrawPolygon(
                        ((screen_active_start - triangle_half_width, h - 5),
                        (screen_active_start + triangle_half_width, h - 5),
                        (screen_active_start, h - 5 - triangle_half_width))
                    )
                dc.DestroyClippingRegion()




        # Draw ruler
        min = 15
        temp = math.ceil(math.log10(min / self.zoom))
        bigliners = get_lines(start, end, temp+1)
        presmallliners = get_lines(start, end, temp)
        smallliners = []
        for thing in presmallliners:
            if bigliners.count(thing) == 0:
                smallliners.append(thing)

        self.draw_small_numbers(dc, smallliners)
        self.draw_big_numbers(dc, bigliners)
        
        

    def draw_small_numbers(self, dc, numbers):
        dc.SetPen(wx.Pen('#000000'))
        dc.SetFont(
            wx.Font(8,
                    wx.FONTFAMILY_DEFAULT,
                    wx.FONTSTYLE_NORMAL,
                    wx.FONTWEIGHT_NORMAL,
                    False)
        )
        
        for number in numbers:
            dc.DrawLine(number, 0, number, 6)
            width, height = dc.GetTextExtent(str(number))
            dc.DrawText(str(number), (number - width / 2), 8)

    def draw_big_numbers(self, dc, numbers):
        dc.SetPen(wx.Pen('#000000'))
        dc.SetFont(
            wx.Font(8,
                    wx.FONTFAMILY_DEFAULT,
                    wx.FONTSTYLE_NORMAL,
                    wx.FONTWEIGHT_BOLD,
                    False)
        )
        
        for number in numbers:
            dc.DrawLine(number, 0, number, 9)
            width, height = dc.GetTextExtent(str(number))
            dc.DrawText(str(number), (number - width / 2), 12)


    def on_mouse_event(self, event):
        #todo: should catch drag to outside of the window        
        # todo: use EVT_CONTEXT_MENU, in tree browser and others too
        if event.RightDown():
            self.gui_project.stop_playing()

            reselect_node = False
            new_thing = event.GetPositionTuple()[0]
            if self.gui_project.active_node is None:
                reselect_node=True
            else:
                thing = \
                    self.screenify(self.gui_project.active_node.state.clock)
                if abs(thing - new_thing) >= 8:
                    reselect_node = True

            if reselect_node is True:
                
                new_node = self.gui_project.path.get_node_occupying_timepoint \
                         (self.unscreenify(new_thing))
                
                if new_node is not None:
                    self.gui_project.set_active_node(new_node,
                                                     modify_path=False)

            if self.gui_project.active_node is not None:
                self.gui_project.frame.Refresh()
                self.PopupMenu(self.frame.context_menu, event.GetPosition())



        if event.LeftDClick():
            self.gui_project.toggle_playing()
            
        if event.LeftDown():# or event.RightDown():
            thing = event.GetPositionTuple()[0]
            node = self.gui_project.path.get_node_occupying_timepoint \
                 (self.unscreenify(thing))

            self.was_playing_before_mouse_click = self.gui_project.is_playing
            if self.was_playing_before_mouse_click:
                self.gui_project.stop_playing()

            if node is not None:
                self.gui_project.set_active_node(node, modify_path=False)


        if event.LeftIsDown():
            thing = event.GetPositionTuple()[0]
            node = self.gui_project.path.get_node_occupying_timepoint \
                 (self.unscreenify(thing))
            if node is not None:
                self.gui_project.set_active_node(node, modify_path=False)
                
        if event.LeftUp():
            if self.was_playing_before_mouse_click:
                self.gui_project.start_playing()
                self.was_playing_before_mouse_click = False
                
        if event.Leaving():
            if self.was_playing_before_mouse_click:
                self.gui_project.start_playing()
                self.was_playing_before_mouse_click = False
                self.was_playing_before_mouse_click_but_then_paused_and_mouse_left = True
                
        if event.Entering():
            if self.was_playing_before_mouse_click_but_then_paused_and_mouse_left:
                self.gui_project.stop_playing()
                self.was_playing_before_mouse_click = True
                self.was_playing_before_mouse_click_but_then_paused_and_mouse_left = False

                
    def on_key_down(self, event):
        self.frame.ProcessEvent(event)

        
    def on_size(self, event):
        self.Refresh()
        if event is not None:
            event.Skip()

            
########NEW FILE########
__FILENAME__ = shell
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `Shell` class.

See its documentation for more info.
'''

from __future__ import with_statement

import sys
import pprint

import wx.py.shell

from garlicsim.general_misc import temp_value_setters

from garlicsim_wx.widgets import WorkspaceWidget
import garlicsim
import garlicsim_wx


def display_hook(thing):
    '''
    Print a representation of an object.
    
    This uses `pprint` rather than the default Python display hook which uses
    `print`. This is used as a temporary display hook when working in the shell
    so that the shell will pretty-print all objects.
    '''
    if thing is not None:
        try:
            import __builtin__
            __builtin__._ = thing
        except ImportError:
            __builtins__._ = thing
        pprint.pprint(thing)


class TempDisplayHookSetter(temp_value_setters.TempValueSetter):
    '''
    Temporarily sets the system's display hook to be our pretty-printing one.
    '''
    def __init__(self):
        temp_value_setters.TempValueSetter.__init__(
            self,
            (sys, 'displayhook'),
            display_hook
        )
        

class Shell(wx.py.shell.Shell, WorkspaceWidget):
    '''
    A shell widget, allowing to execute arbitrary Python code.
    
    This is useful for examining the simulation.
    '''
    # todo: After every command in shell, must make the top emitter emit
    def __init__(self, frame):
        wx.py.shell.Shell.__init__(self, frame, size=(100, 100),
                                   locals=frame.gui_project.namespace,
                                   style=wx.SUNKEN_BORDER)
        WorkspaceWidget.__init__(self, frame)
        
        # We used to import `site` here to get `help` and others when frozen,
        # but now `garlicsim` has `bootstrap_py2exe` which bundles its own
        # version of `site` which creates `help` and a few other builtins.
        import __builtin__
        assert 'help' in __builtin__.__dict__
        del __builtin__
        
    
    def setLocalShell(self):
        # Making it a no-op to avoid reference to retarded `ShellFacade`.
        pass
    
    
    def push(self, command, silent=False):
        '''
        Send command to the interpreter for execution.
        
        If the command evaluates to some Python object, it will be
        pretty-printed in the shell.
        '''
        with TempDisplayHookSetter():
            return wx.py.shell.Shell.push(self, command, silent=silent)
########NEW FILE########
__FILENAME__ = state_repr_viewer
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines the `StateReprViewer` class.

See its documentation for more info.
'''

import wx
from garlicsim_wx.widgets import WorkspaceWidget
import garlicsim.general_misc.dict_tools as dict_tools
from garlicsim_wx.general_misc.flag_raiser import FlagRaiser

__all__ = ["StateReprViewer"]

class StateReprViewer(wx.Panel, WorkspaceWidget):
    '''Widget for showing the repr of the active state.'''
    def __init__(self, frame):
        wx.Panel.__init__(self, frame, size=(300, 300), style=wx.SUNKEN_BORDER)
        WorkspaceWidget.__init__(self, frame)

        self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM)
        
        self.Bind(wx.EVT_PAINT, self.on_paint)        
        
        self.text_ctrl = wx.TextCtrl(
            self,
            style=wx.TE_MULTILINE | wx.NO_BORDER
        )
        
        font_size = 12 if wx.Platform == '__WXMAC__' else 9
        
        font = wx.Font(font_size, wx.DEFAULT, wx.NORMAL, wx.BOLD, False,
                       u'Courier New')
        self.text_ctrl.SetFont(font)
        
        self.sizer_v = wx.BoxSizer(wx.VERTICAL)
        self.sizer_h = wx.BoxSizer(wx.HORIZONTAL)
        self.sizer_v.Add(self.sizer_h, 1, wx.EXPAND)
        self.sizer_h.Add(self.text_ctrl, 1, wx.EXPAND)
        
        self.SetSizer(self.sizer_v)
        self.sizer_v.Layout()
        
        self.state = None
        
        self.needs_recalculation_flag = True
        
        self.needs_update_emitter = \
            self.gui_project.emitter_system.make_emitter(
                inputs=(
                    self.gui_project.active_node_changed_or_modified_emitter,
                    # todo: put the active_state_changed whatever here
                    ),
                outputs=(
                    FlagRaiser(self, 'needs_recalculation_flag',
                               function=self._recalculate, delay=0.03),
                    ),
                name='state_repr_viewer_needs_recalculation',
            )
    

    def _recalculate(self):
        '''Recalculate the widget.'''
        if self.needs_recalculation_flag:
            if self.gui_project:
                active_state = self.gui_project.get_active_state()        
                if active_state:
                    if active_state is not self.state:
                        self.state = active_state
                        state_repr = dict_tools.fancy_string(vars(active_state))
                        self.text_ctrl.SetValue(state_repr)
            self.needs_recalculation_flag = False
        
    def on_paint(self, event):
        '''EVT_PAINT handler.'''
        event.Skip()
        # Notice that we are not checking the `needs_recalculation_flag` here.
        # The FlagRaiser's 30ms delay is small enough, and we don't need to have
        # very fast response time in the state repr viewer, so we can afford to
        # wait another 30ms before an update.
        
         
        
    

########NEW FILE########
__FILENAME__ = tree_browser
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
This module defines the `TreeBrowser` class.

See its documentation for more info.
'''

import os
from math import *

import pkg_resources
import wx
from wx.lib.scrolledpanel import ScrolledPanel

import garlicsim_wx.general_misc.vectorish as vectorish
from garlicsim_wx.general_misc import emitters
from garlicsim.general_misc import caching
from garlicsim_wx.general_misc import wx_tools
from garlicsim_wx.general_misc.flag_raiser import FlagRaiser

import garlicsim
import garlicsim_wx.misc.colors
from garlicsim_wx.widgets import WorkspaceWidget

from . import images as __images_package
images_package = __images_package.__name__


connector_length = 10 # length of connecting line between elements


my_color_replaced_bitmap = \
    caching.cache(max_size=80)(wx_tools.color_replaced_bitmap)


class TreeBrowser(ScrolledPanel, WorkspaceWidget):
    '''Widget for browsing a `garlicsim.data_structures.Tree`.'''
    def __init__(self, frame):
        # todo: on mouse drag should pause like seek bar does
        ScrolledPanel.__init__(self, frame, size=(100, 100),
                               style=wx.SUNKEN_BORDER)
        WorkspaceWidget.__init__(self, frame)
        
        self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM)
        self.SetBackgroundColour(wx_tools.get_background_color())
        
        self.SetupScrolling()
        #self.SetScrollRate(20,20)
        #self.sizer=wx.BoxSizer(wx.VERTICAL)
        #self.panel=wx.StaticBitmap(self,-1,wx.Bitmap("images\\snail.gif", wx.BITMAP_TYPE_ANY))#wx.Panel(self,-1,size=(-1,200))#wx.TextCtrl(self, -1, size=(-1,200), style=wx.TE_MULTILINE)
        #self.panel=wx.Panel(self,-1,size=(-1,100))
        #self.sizer.Add(self.panel,1,wx.EXPAND)
        #self.SetSizer(self.sizer)
        #self.EnableScrolling(True, True)
        #self.SetScrollbars(5, 30, 1055, 40)
        #self.sizer.Fit(self)
        #self.Centre()
        #self.SetVirtualSize((1000,1000))

        self.Bind(wx.EVT_PAINT, self.on_paint)
        self.Bind(wx.EVT_SIZE, self.on_size)
        self.Bind(wx.EVT_MOUSE_EVENTS, self.on_mouse_event)
        self.Bind(wx.EVT_KEY_DOWN, self.on_key_down)

        self.tree_remapping_flag = False
        self.recalculation_flag = False
        
        self.needs_tree_remapping_emitter = \
            self.gui_project.emitter_system.make_emitter(
                inputs=(
                    self.gui_project.tree_structure_modified_emitter,
                ),
                outputs=(
                    FlagRaiser(self, 'tree_remapping_flag'),
                ),
                name='needs_tree_remapping',
            )

        
        self.needs_recalculation_emitter = \
            self.gui_project.emitter_system.make_emitter(
                inputs=(
                    self.needs_tree_remapping_emitter,
                    self.gui_project.step_profiles_to_hues_modified_emitter,
                    self.gui_project.active_node_changed_or_modified_emitter,
                    self.gui_project.tree_modified_on_path_emitter,
                    # Note that if there's a non-structure tree change not on
                    # the path it won't affect us.
                ),
                outputs=(
                    FlagRaiser(self, 'recalculation_flag'),
                ),
                name='needs_recalculation',
            )
        
        self.clickable_map = {}
        
        elements_raw = {            
            'Untouched': 'graysquare.png',
            'Touched': 'graystar.png',
            'Unfinalized Touched': 'grayunfinalizedstar.png',
            'Untouched End': 'grayendsquare.png',
            'Touched End': 'grayendstar.png',
            'Block': 'grayblock.png',
            'Active Untouched': 'orangesquare.png',
            'Active Touched': 'orangestar.png',
            'Active Unfinalized Touched': 'orangeunfinalizedstar.png',
            'Active Untouched End': 'orangeendsquare.png',
            'Active Touched End': 'orangeendstar.png',
            'Active Block': 'orangeblock.png',
        }
        
        self.elements = {}
        for key in elements_raw:
            stream = pkg_resources.resource_stream(images_package,
                                                   elements_raw[key])
            self.elements[key] = wx.BitmapFromImage(
                wx.ImageFromStream(
                    stream,
                    wx.BITMAP_TYPE_ANY
                )
            )

    def on_paint(self, event):
        '''Refresh the tree browser.'''

        event.Skip()
        
        # todo: optimize so it groks the tree only when needed.
        
        self.tree_remapping_flag = False
        self.recalculation_flag = False
        # todo: now we just lower these flags retardedly, in future there will
        # be __recalculate
        
        if self.gui_project is None or \
           self.gui_project.project.tree is None or \
           len(self.gui_project.project.tree.roots) == 0:
            
            return

        dc = NiftyPaintDC(self, self.gui_project,
                          self.CalcScrolledPosition((0, 0)), self)
        
        dc.SetBackground(wx_tools.get_background_brush())
        dc.Clear()
        
        (self.clickable_map, (width, height)) = \
            dc.draw_tree(self.gui_project.project.tree)
        
        dc.Destroy() # This weird dc requires destroying
        
        self.SetVirtualSize((width,height))
        
        
    def on_size(self, e=None):
        self.Refresh()
        if e is not None:
            e.Skip()

    def on_mouse_event(self, e):
        #todo: should catch drag to outside of the window
        #(x,y)=self.CalcUnscrolledPosition(e.GetPositionTuple())

        (x, y) = e.GetPositionTuple()
        
        if e.LeftDClick():
            self.gui_project.toggle_playing()


        if e.LeftIsDown():
            thing = self.search_map(x,y)
            #print(thing)
            if thing is None:
                #maybe deselect?
                pass
            elif isinstance(thing, garlicsim.data_structures.End):
                self.gui_project.set_active_node(thing.parent)
            else:
                self.gui_project.set_active_node(thing)
                
        if e.RightDown():
            self.gui_project.stop_playing()
            thing = self.search_map(x,y)
            if thing is None:
                #Deselect!
                pass
            else:
                self.gui_project.set_active_node(thing)
                
            self.PopupMenu(self.frame.context_menu, e.GetPosition())


    def search_map(self, x, y):
        for key in self.clickable_map:
            (a, b, c, d) = key
            if (a <= x <= c) and (b <= y <= d):
                thing = self.clickable_map[key]
                if isinstance(thing, garlicsim.data_structures.Block):
                    ratio = (x - a) / float(c - a)
                    index = int(round(ratio*(len(thing)-1)))
                    return thing[index]
                else:
                    return thing
        return None

                
    def on_key_down(self, event):
        self.frame.ProcessEvent(event)


class NiftyPaintDC(wx.BufferedPaintDC):
    '''A PaintDC used to paint the tree in a tree browser.'''
    
    def __init__(self, window, gui_project, origin, tree_browser, *args,
                 **kwargs):
        wx.BufferedPaintDC.__init__(self, window, *args, **kwargs)
        
        self.gui_project = gui_project
        self.origin = origin
        self.tree_browser = tree_browser
        
        self.gc = wx.GraphicsContext.Create(self)
        assert isinstance(self.gc, wx.GraphicsContext)
        
        self.pen = pen = wx.Pen(wx.Colour(0, 0, 0), 1, wx.SOLID)
        pen.SetCap(wx.CAP_PROJECTING)
        pen.SetJoin(wx.JOIN_ROUND)
        
        self.SetPen(pen); self.gc.SetPen(pen)
        
        

    def draw_sub_tree(self, point, tree, start):

        if start.step_profile:
            color = garlicsim_wx.misc.colors.hue_to_light_color(
                self.gui_project.step_profiles_to_hues[start.step_profile]
            )
        else:
            color = wx.Colour(204, 204, 204)
        
        make_block_stripe = False

        if isinstance(start, garlicsim.data_structures.Block):
            
            type = 'Block'
            kids = start[-1].children
            if start == self.active_soft_block:
                make_block_stripe = True
                type = 'Active ' + type
                
        elif isinstance(start, garlicsim.data_structures.Node):
            
            kids = start.children
            
            if start.touched:
                type = 'Touched'
            else:
                type = 'Untouched'
                
            if start.still_in_editing:
                type = 'Unfinalized ' + type
                    
            if start == self.active_soft_block:
                type = 'Active ' + type
                
        else:
            
            raise Exception


        if make_block_stripe is True:

            bitmap = my_color_replaced_bitmap(
                self.tree_browser.elements['Block'],
                (0, 255, 0),
                wx_tools.wx_color_to_big_rgb(color)
            )
            bitmap_size = bitmap.GetSize()
            self.gc.DrawBitmap(bitmap, point[0], point[1],
                               bitmap_size[0], bitmap_size[1])
            bitmap_size = bitmap.GetSize()
            second_bitmap = self.tree_browser.elements[type]
            

            slice = [None, None]
            length = float(len(start))
            slice[0] = start.index(self.active_node) / length
            slice[1] = slice[0] + (1 / length)

            screen_slice = [
                floor(point[0] + 4 + (bitmap_size[0] - 8) * slice[0]),
                ceil(point[0] + 4 + (bitmap_size[0] - 8) * slice[1])
            ]
            
            self.pen.SetWidth(0)
            self.pen.SetStyle(wx.TRANSPARENT)
            self.gc.SetPen(self.pen)
            self.gc.SetBrush(wx.Brush(wx.Colour(255, 153, 51)))
            self.gc.DrawRectangle(screen_slice[0], point[1] + 4,
                                  screen_slice[1] - screen_slice[0],
                                  bitmap_size[1] - 8)
                                  

        else:
            bitmap = my_color_replaced_bitmap(
                self.tree_browser.elements[type],
                (0, 255, 0),
                wx_tools.wx_color_to_big_rgb(color)
            )
            bitmap_size = bitmap.GetSize()
            self.gc.DrawBitmap(bitmap, point[0], point[1],
                               bitmap_size[0], bitmap_size[1])

        temp = (point[0] + 1,
                point[1],
                point[0] + bitmap_size[0] - 2,
                point[1] + bitmap_size[1])
        
        self.clickable_map[temp] = start
        del temp



        last_height = 0
        total_height = 0
        self_width = bitmap_size[0] + connector_length
        max_width = self_width
        line_start = vectorish.add(
            point,
            (
                bitmap_size[0] - 1,
                bitmap_size[1] // 2
            )
        )
        
        for kid in kids:
            line_end = vectorish.add(
                point,
                (
                    self_width + 1,
                    total_height + bitmap_size[1] // 2
                )
            )
            
            temp = vectorish.add(point, (self_width, total_height))
            (new_width, new_height) = \
                self.draw_sub_tree(temp, tree, kid.soft_get_block())
            del temp
        
            if kid.step_profile:
                color = garlicsim_wx.misc.colors.hue_to_light_color(
                    self.gui_project.step_profiles_to_hues[kid.step_profile]
                    )
            else:
                color = wx.Colour(0, 0, 0)
            
            self.pen.SetColour(wx.Colour(0, 0, 0))
            self.pen.SetWidth(1)
            self.pen.SetStyle(wx.SOLID)
            self.gc.SetPen(self.pen)
            
            self.gc.StrokeLine(line_start[0], line_start[1],
                               line_end[0], line_end[1])
            max_width = max(max_width, self_width + new_width)
            total_height += new_height
            
        
        ends = start.ends if isinstance(start, garlicsim.data_structures.Node)\
             else start[-1].ends
        for end in ends:
            line_end = vectorish.add(
                point,
                (
                    self_width + 1,
                 total_height + bitmap_size[1] // 2
                )
            )
            
            temp = vectorish.add(point, (self_width, total_height))
            (new_width, new_height) = \
                self.draw_end(temp, tree, end)
            del temp
            
            if end.step_profile:
                color = garlicsim_wx.misc.colors.hue_to_light_color(
                    self.gui_project.step_profiles_to_hues[end.step_profile]
                    )
            else:
                color = wx.Colour(0, 0, 0)
            
            self.pen.SetColour(wx.Colour(0, 0, 0))
            self.pen.SetWidth(1)
            self.pen.SetStyle(wx.SOLID)
            self.gc.SetPen(self.pen)
            
            self.gc.StrokeLine(line_start[0], line_start[1],
                               line_end[0], line_end[1])
            max_width = max(max_width, self_width + new_width)
            total_height += new_height

        return (
            max_width,
            max(
                total_height,
                bitmap_size[1] + connector_length
            )
        )

    
    def draw_end(self, point, tree, start):

        assert isinstance(start, garlicsim.data_structures.End)
        
        if start.step_profile:
            color = garlicsim_wx.misc.colors.hue_to_light_color(
                self.gui_project.step_profiles_to_hues[start.step_profile]
            )
        else:
            color = wx.Colour(204, 204, 204)
        
        bitmap = my_color_replaced_bitmap(
            self.tree_browser.elements['Untouched End'],
            (0, 255, 0),
            wx_tools.wx_color_to_big_rgb(color)
        )
        self.DrawBitmapPoint(bitmap, point, useMask=True)
        bitmap_size = bitmap.GetSize()

        temp = (point[0],
                point[1],
                point[0] + bitmap_size[0],
                point[1] + bitmap_size[1])
        
        self.clickable_map[temp] = start
        
        last_height = 0
        total_height = 0
        self_width = bitmap_size[0] + connector_length
        max_width = self_width
        line_start = vectorish.add(
            point,
            (
                bitmap_size[0] - 1,
                bitmap_size[1] // 2
            )
        )
        
        

        return (
            max_width,
            max(
                total_height,
                bitmap_size[1] + connector_length
            )
        )
    
    def draw_tree(self, tree):
        '''
        Draw the tree.
        '''

        if self.gui_project:
            self.clickable_map = {}
            self.active_node = self.gui_project.active_node
            try:
                self.active_soft_block = self.active_node.soft_get_block()
            except AttributeError:
                self.active_soft_block = None
    
            sizes = []
            pos = vectorish.add((connector_length, connector_length),
                                self.origin)
            for root in tree.roots:
                size = self.draw_sub_tree(
                    pos,
                    tree,
                    root.soft_get_block()
                )
                pos = vectorish.add(pos, (size[0], 0))
                sizes.append(size)
            
            width = sum(size[0] for size in sizes) + \
                  (connector_length * len(sizes))
            height = max(size[1] for size in sizes) + connector_length
            return (self.clickable_map, (width, height))


'''

Maybe I'll use this sometime:

                        "Selected Untouched": wx.Bitmap("images\\bluesquare.png", wx.BITMAP_TYPE_ANY),    \
                       "Selected Touched": wx.Bitmap("images\\bluestar.png", wx.BITMAP_TYPE_ANY),    \
                       "Selected Block": wx.Bitmap("images\\blueblock.png", wx.BITMAP_TYPE_ANY),    \
'''


'''

Maybe I'll use this sometime:

class Object(object):
    def __init__(self,*args,**kwargs):
        pass

class StateContainer(Object):
    def __init__(self,parent=None,connector_class=None,*args,**kwargs):
        Object.__init__(self,*args,**kwargs)
        assert [x for x in [parent,connector_class] if x==None]!=[None]
        self.parent=parent
        connector=connector_class(parent,self)

        self.children={} # {child: connector}



class Node(StateContainer):
    def __init__(self,*args,**kwargs):
        StateContainer.__init__(self,*args,**kwargs)
        pass

class TouchedNode(Node):
    def __init__(self,*args,**kwargs):
        Node.__init__(self,*args,**kwargs)
        pass

class UntouchedNode(Node):
    def __init__(self,*args,**kwargs):
        Node.__init__(self,*args,**kwargs)
        pass

class Block(StateContainer):
    def __init__(self,*args,**kwargs):
        StateContainer.__init__(self,*args,**kwargs)
        pass

class Connector(Object):
    def __init__(self,parent,child,*args,**kwargs):
        Object.__init__(self,*args,**kwargs)
        parent.children[child]=self
'''

########NEW FILE########
__FILENAME__ = almost_import_stdlib
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

"""
"Almost" import the entire Python 2.6 standard library.

This is so py2exe will think we're actually using all of it, and bundle it for
our app.

Todo: This currently doesn't import submodules which aren't imported by the
package itself. (For example `email`.)
"""

if False:
    import AutoComplete
    import AutoCompleteWindow
    import AutoExpand
    import BaseHTTPServer
    import Bastion
    import Bindings
    import CGIHTTPServer
    import CallTipWindow
    import CallTips
    import Canvas
    import ClassBrowser
    import CodeContext
    import ColorDelegator
    import ConfigParser
    import Cookie
    import Debugger
    import Delegator
    import Dialog
    import DocXMLRPCServer
    import EditorWindow
    import FileDialog
    import FileList
    import FixTk
    import FormatParagraph
    import GrepDialog
    import HTMLParser
    import HyperParser
    import IOBinding
    import IdleHistory
    import MimeWriter
    import MultiCall
    import MultiStatusBar
    import ObjectBrowser
    import OutputWindow
    import ParenMatch
    import PathBrowser
    import Percolator
    import PyParse
    import PyShell
    import Queue
    import RemoteDebugger
    import RemoteObjectBrowser
    import ReplaceDialog
    import ScriptBinding
    import ScrolledList
    import ScrolledText
    import SearchDialog
    import SearchDialogBase
    import SearchEngine
    import SimpleDialog
    import SimpleHTTPServer
    import SimpleXMLRPCServer
    import SocketServer
    import StackViewer
    import StringIO
    import Tix
    import Tkconstants
    import Tkdnd
    import Tkinter
    import ToolTip
    import TreeWidget
    import UndoDelegator
    import UserDict
    import UserList
    import UserString
    import WidgetRedirector
    import WindowList
    import ZoomHeight
    import _LWPCookieJar
    import _MozillaCookieJar
    import __future__
    import _abcoll
    import _bsddb
    import _ctypes
    import _ctypes_test
    import _elementtree
    import _hashlib
    import _msi
    import _multiprocessing
    import _socket
    import _sqlite3
    import _ssl
    import _strptime
    import _testcapi
    import _threading_local
    import _tkinter
    import abc
    import aboutDialog
    import aifc
    import anydbm
    import ast
    import asynchat
    import asyncore
    import atexit
    import audiodev
    import base64
    import bdb
    import binhex
    import bisect
    import bsddb
    import bz2
    import cProfile
    import calendar
    import cgi
    import cgitb
    import chunk
    import cmd
    import code
    import codecs
    import codeop
    import collections
    import colorsys
    import commands
    import compileall
    import compiler
    import configDialog
    import configHandler
    import configHelpSourceEdit
    import configSectionNameDialog
    import contextlib
    import cookielib
    import copy
    import copy_reg
    import csv
    import ctypes
    import curses
    import dbhash
    import decimal
    import difflib
    import dircache
    import dis
    import distutils
    import doctest
    import dumbdbm
    import dummy_thread
    import dummy_threading
    import dynOptionMenuWidget
    import email
    import encodings
    import filecmp
    import fileinput
    import fnmatch
    import formatter
    import fpformat
    import fractions
    import ftplib
    import functools
    import genericpath
    import getopt
    import getpass
    import gettext
    import glob
    import gzip
    import hashlib
    import heapq
    import hmac
    import hotshot
    import htmlentitydefs
    import htmllib
    import httplib
    import idle
    import idlelib
    import idlever
    import ihooks
    import imaplib
    import imghdr
    import imputil
    import inspect
    import io
    import json
    import keybindingDialog
    import keyword
    import lib2to3
    import linecache
    import locale
    import logging
    import macosxSupport
    import macpath
    import macurl2path
    import mailbox
    import mailcap
    import markupbase
    import md5
    import mhlib
    import mimetools
    import mimetypes
    import mimify
    import modulefinder
    import msilib
    import multifile
    import multiprocessing
    import mutex
    import netrc
    import new
    import nntplib
    import ntpath
    import nturl2path
    import numbers
    import opcode
    import optparse
    import os
    import os2emxpath
    import pdb
    import pickle
    import pickletools
    import pipes
    import pkgutil
    import platform
    import plistlib
    import popen2
    import poplib
    import posixfile
    import posixpath
    import pprint
    import profile
    import pstats
    import pty
    import py_compile
    import pyclbr
    import pydoc
    import pydoc_topics
    import pyexpat
    import quopri
    import random
    import re
    import repr
    import rexec
    import rfc822
    import rlcompleter
    import robotparser
    import rpc
    import run
    import runpy
    import sched
    import select
    import sets
    import sgmllib
    import sha
    import shelve
    import shlex
    import shutil
    import site
    import smtpd
    import smtplib
    import sndhdr
    import socket
    import sqlite3
    import sre
    import sre_compile
    import sre_constants
    import sre_parse
    import ssl
    import stat
    import statvfs
    import string
    import stringold
    import stringprep
    import struct
    import subprocess
    import sunau
    import sunaudio
    import symbol
    import symtable
    import tabbedpages
    import tabnanny
    import tarfile
    import telnetlib
    import tempfile
    import test
    import testcode
    import textView
    import textwrap
    import this
    import threading
    import timeit
    import tkColorChooser
    import tkCommonDialog
    import tkFileDialog
    import tkFont
    import tkMessageBox
    import tkSimpleDialog
    import toaiff
    import token
    import tokenize
    import trace
    import traceback
    import tty
    import turtle
    import types
    import unicodedata
    import unittest
    import urllib
    import urllib2
    import urlparse
    import user
    import uu
    import uuid
    import warnings
    import wave
    import weakref
    import webbrowser
    import whichdb
    import winsound
    import wsgiref
    import xdrlib
    import xml
    import xmllib
    import xmlrpclib
    import zipfile
########NEW FILE########
__FILENAME__ = GarlicSim
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''A script for starting GarlicSim from an executable.'''

import sys
import os.path
import multiprocessing


# "Almost importing" entire Python standard library, so it will all get
# packaged with `py2exe`:
if False:
    # The `if False` is important here, even though `almost_import_stdlib`
    # already has one wrapping it inside, because `almost_import_stdlib.py`
    # won't get packaged at all with py2exe, so trying to import it will raise
    # an `ImportError`.
    import almost_import_stdlib


use_psyco = False
if not ('--psyco=off' in sys.argv):
    try:
        import psyco
        use_psyco = True
    except ImportError:
        pass
    
    
if __name__ == '__main__':
    multiprocessing.freeze_support()
    
    import garlicsim
    import garlicsim_wx
    
    if use_psyco:
        psyco.full()
    garlicsim_wx.start()
########NEW FILE########
__FILENAME__ = _test_garlicsim_wx
#!/usr/bin/env python

# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Script for launching `garlicsim_wx` tests when installed in local Python.'''


import test_garlicsim_wx


if __name__ == '__main__':
    test_garlicsim_wx.invoke_nose()
########NEW FILE########
__FILENAME__ = test_find_clear_place_on_circle
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Testing module for `find_clear_place_on_circle`.'''

import nose.tools

from garlicsim_wx.general_misc.misc_tools import find_clear_place_on_circle

def test_wraparound():
    '''Test when clear place is on the wraparound.'''
    result = find_clear_place_on_circle((0.3, 0.5, 0.8), 1)
    nose.tools.assert_almost_equal(result, 0.05)
########NEW FILE########
__FILENAME__ = test_trivial
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''Testing module for `garlicsim_wx`.'''


def test_trivial():
    '''
    Trivial test.

    This is just a placeholder test.
    '''
    pass
    
    
########NEW FILE########
__FILENAME__ = make_distribution
#!/usr/bin/env python

# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Script for packaging GarlicSim as a complete program to end users.

Currently implemented only for Windows, using `py2exe`.

The distribution files for Windows will be put in the `win_dist` folder.

Options:

    --help
        Show this help screen    
        
    --installer [OR] -i
        After making distribution directory, create installer.
        On Windows, this uses Inno Setup.
        
Windows-only options:        
        
    --issc=[PATH]            
        Path to `issc.exe`, needed only if (a) making a Windows installer
        and (b) `issc.exe` is in a non-standard location)
        
'''

import shutil
import os.path
import platform
import sys
import glob


repo_root_path = os.path.realpath(os.path.split(__file__)[0])
garlicsim_wx_path = os.path.join(repo_root_path, 'garlicsim_wx')
assert __name__ == '__main__'


if '--help' in sys.argv:
    sys.stdout.write(__doc__ + '\n')
    exit()

operating_system = platform.system()
    
if operating_system != 'Windows':
    raise NotImplementedError("You're not on Windows, and making a "
                              "distribution on Linux or Mac is not yet "
                              "supported.")

produce_installer = ('--installer' in sys.argv) or ('-i' in sys.argv)

if produce_installer:
    sys.stdout.write('Preparing to package GarlicSim for Windows users using '
                     'py2exe and produce Windows installer.\n')
else: # not produce_installer
    sys.stdout.write('Preparing to package GarlicSim for Windows users using '
                     'py2exe.\n')

if produce_installer:
    ### Figuring out location of Inno Setup compiler: #########################
    #                                                                         #
    issc_specifiers = [arg for arg in sys.argv if arg.startswith('--issc=')]
    if issc_specifiers:
        (issc_specifier,) = issc_specifiers
        path_to_issc = issc_specifier[7:]
        if path_to_issc[0] == path_to_issc[-1] == '"':
            path_to_issc = path_to_issc[1:-1]
        if not os.path.isfile(path_to_issc):
            raise Exception('The path to `issc.exe` that you specified does '
                            'not exist. Make sure to include the `.exe` file '
                            'itself in the path.')
    else:
        path_to_issc = \
            'c:\\Program Files\\Inno Setup 5\\ISCC.exe'
        if not os.path.isfile(path_to_issc):
            raise Exception("The Inno Setup compiler `issc.exe` could not be "
                            "found. If you don't have Inno Setup installed, "
                            "install it. If it's installed and you still get "
                            "this message, specify the path to `issc.exe` by "
                            "using the `--issc=[PATH]` flag.")
        
    #                                                                         #
    ### Finished figuring out location of Inno Setup compiler. ################
    

### Deleting old build files: #################################################
#                                                                             #
def assert_no_unknown_folders():
    '''Assert there are no unknown folders in `garlicsim_wx`.'''
    existing_folders = set(
        [name for name in os.listdir(garlicsim_wx_path) if
         os.path.isdir(os.path.join(garlicsim_wx_path, name))]
    )
    assert existing_folders == \
           set(('garlicsim_wx', 'test_garlicsim_wx', 'py2exe_cruft'))

folders_to_delete = []
for folder in [os.path.join(garlicsim_wx_path, 'build'),
               os.path.join(garlicsim_wx_path, 'garlicsim_wx.egg-info'),
               os.path.join(repo_root_path, 'win_dist')]:
    if os.path.exists(folder):
        folders_to_delete.append(folder)

if folders_to_delete:
    sys.stdout.write('Preparing to delete old build folders.\n')
    for folder_to_delete in folders_to_delete:
        short_name = os.path.split(folder_to_delete)[1]
        sys.stdout.write("Deleting the '%s' folder... " % short_name)
        shutil.rmtree(folder_to_delete)
        sys.stdout.write('Done.\n')
    assert_no_unknown_folders()
else: # No folders to delete
    assert_no_unknown_folders()
    sys.stdout.write('No previous build folders to delete.\n')


if produce_installer:
    existing_installers = \
        glob.glob(os.path.join(repo_root_path, 'GarlicSim-*.exe'))
    if existing_installers:
        sys.stdout.write('Preparing to remove old installer file%s.\n' % \
                         ('s' if (len(existing_installers) > 1) else ''))
        for existing_installer in existing_installers:
            sys.stdout.write('Removing old `%s` file... ' % existing_installer)
            os.remove(existing_installer)
            sys.stdout.write('Done.')

sys.stdout.write('Working area clean.\n')
#                                                                             #
### Finished deleting old build files. ########################################

### Packaging with py2exe: ####################################################
#                                                                             #
sys.stdout.write('Launching py2exe.\n')

old_cwd = os.getcwd()
os.chdir(garlicsim_wx_path)
try:
    temp_result = os.system('"%s" setup.py py2exe' % sys.executable)
    if temp_result != 0:
        sys.exit(temp_result)
finally:
    os.chdir(old_cwd)

sys.stdout.write('Py2exe packaging complete. Distribution files are in the '
                 '`win_dist` folder.\n')
#                                                                             #
### Finished packaging with py2exe. ###########################################
    

if produce_installer:
    ### Creating Windows installer with Inno Setup: ###########################
    #                                                                         #
    sys.stdout.write('Preparing to create Windows installer using Inno '
                     'Setup.\n')
    
    os.chdir(garlicsim_wx_path)
    try:
        # (There are no less than six quotes in this command, because of weird
        # `cmd.exe /C` conventions.)
        create_installer_command = '""%s" "%s""' % (
            path_to_issc,
            os.path.join(garlicsim_wx_path, 'installer_script.iss')
        )
        sys.exit(os.system(create_installer_command))
    finally:
        os.chdir(old_cwd)

    #                                                                         #
    ### Finished creating Windows installer with Inno Setup. ##################

########NEW FILE########
__FILENAME__ = make_zip
#!/usr/bin/env python

# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Zip all the GarlicSim packages into zip archives in the `build` folder.

This is used for testing that GarlicSim works properly when running from zip
archive.

Note: The only reason we create zip files with numbers (e.g. '1.zip') instead
of names (e.g. 'garlicsim_lib.zip') is for Windows XP compatibility; Windows XP
limits the length of a path that a file may have, so we can't afford to have a
15-letter long zip name, and then under that serve the GarlicSim packages,
because it will cause Python to raise an `ImportError` under Windows XP.
'''

from __future__ import with_statement

import sys
import re
import fnmatch
import os.path
import zipfile
import contextlib
import shutil


def zip_folder(folder, zip_path, ignored_patterns=[]):
    '''
    Zip `folder` into a zip file specified by `zip_path`.
    
    Note: Creates a folder inside the zip with the same name of the original
    folder, in contrast to other implementation which put all of the files on
    the root level of the zip.
    
    `ignored_patterns` are fnmatch-style patterns specifiying file-paths to
    ignore.
    
    Any empty sub-folders will be ignored.
    '''
    assert os.path.isdir(folder)
    source_folder = os.path.realpath(folder)
    
    ignored_re_patterns = [re.compile(fnmatch.translate(ignored_pattern)) for
                           ignored_pattern in ignored_patterns]
    
    zip_name = os.path.splitext(os.path.split(zip_path)[1])[0]
    source_folder_name = os.path.split(source_folder)[1]
            
    with contextlib.closing(
        zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED)
        ) as zip_file:
        
        for root, subfolders, files in os.walk(source_folder):
            
            for file_path in files:
                
                if any(ignored_re_pattern.match(os.path.join(root, file_path))
                       for ignored_re_pattern in ignored_re_patterns):
                    continue
                
                absolute_file_path = os.path.join(root, file_path)
                
                destination_file_path = os.path.join(
                    source_folder_name,
                    absolute_file_path[(len(source_folder) + len(os.sep)):]
                )
                
                zip_file.write(absolute_file_path, destination_file_path)

                
def make_zip():
    '''
    Zip all the GarlicSim packages into zip archives in the `build` folder.
    
    This cleans any previous zip archives from the `build` folder.
    '''
    ###########################################################################
    #                                                                         #
    module_path = os.path.realpath(os.path.split(__file__)[0])
    assert module_path.endswith(os.path.sep.join(('misc', 'testing', 'zip')))
    repo_root_path = os.path.realpath(os.path.join(module_path, '../../..'))
    assert module_path == os.path.realpath(
        os.path.join(repo_root_path, 'misc', 'testing', 'zip')
    )
    #                                                                         #
    ###########################################################################
           
    ### Preparing build folder: ###############################################
    #                                                                         #
    build_folder = os.path.join(module_path, 'build')
    if os.path.exists(build_folder):
        sys.stdout.write('Deleting old `build` folder... ')
        shutil.rmtree(build_folder)
        sys.stdout.write('Done.\n')
    sys.stdout.write('Creating `build` folder... ')
    os.mkdir(build_folder)
    sys.stdout.write('Done.\n')
    #                                                                         #
    ### Finished preparing build folder. ######################################
    
    ### Zipping packages into zip files: ######################################
    #                                                                         #
    package_names = ['garlicsim', 'garlicsim_lib', 'garlicsim_wx']
    
    for i, package_name in enumerate(package_names):
        
        sys.stdout.write("Preparing to zip folder '%s'... " % package_name)
        package_path = os.path.join(repo_root_path, package_name, package_name)
        assert os.path.isdir(package_path)
        zip_destination_path = os.path.join(build_folder,
                                            (str(i) + '.zip'))
        
        sys.stdout.write('Zipping... ')
        zip_folder(package_path, zip_destination_path,
                   ignored_patterns=['*.pyc', '*.pyo', '*__pycache__*'])
        
        sys.stdout.write('Done.\n')
    #                                                                         #
    ### Finished zipping packages into zip files. #############################
    
    sys.stdout.write('Finished zipping all folders.\n')
    
    # todo: can make some test here that checks that the files were zipped
    # properly, have a correct data, and no pyo or pyc files were copied.

if __name__ == '__main__':
    make_zip()
########NEW FILE########
__FILENAME__ = testing_utilities
# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Defines utilities for testing GarlicSim from a zip archive.

Used by `run_tests.py` in the GarlicSim repo root.
'''

import sys
import os.path
import imp


frozen = getattr(sys, 'frozen', None)
our_path = os.path.realpath(os.path.split(__file__)[0])


def exists(module_name):
    '''
    Return whether a module by the name `module_name` exists.
    
    This seems to be the best way to carefully import a module.
    
    Currently implemented for top-level packages only. (i.e. no dots.)
    
    Doesn't support modules imported from a zip file.
    '''
    assert '.' not in module_name
    try:
        imp.find_module(module_name)
    except ImportError:
        return False
    else:
        return True


def prepare_zip_testing(package_names):
    '''Zip all GarlicSim modules and import them for testing.'''
    
    sys.stdout.write('Preparing to zip GarlicSim packages, and then run tests '
                     'with GarlicSim imported from zip files.\n')
    
    assert not frozen

    command_for_making_zip = '"%s" "%s"' % (
            sys.executable,
            os.path.realpath(os.path.join(our_path, 'make_zip.py')),
    )
    
    if os.name == 'nt': # Conforming to weird Windows standards:
        command_for_making_zip = '"%s"' % command_for_making_zip
        
    result = os.system(command_for_making_zip)
    
    if result != 0:
        exit(result)
        
    for package_name in package_names:
        assert not exists(package_name)
        assert package_name not in sys.modules

    sys.stdout.write('Importing all GarlicSim packages from zip files... ')
        
    for i, package_name in enumerate(package_names):
        zip_file = os.path.realpath(
            os.path.join(our_path, 'build', (str(i) + '.zip'))
        )
        assert zip_file not in sys.path
        sys.path.append(zip_file)
        package = __import__(package_name)
        assert '.zip' in package.__file__
    
    sys.stdout.write('Done.\n')
    
    
def ensure_zip_testing_was_legit(package_names):
    '''
    Ensure GarlicSim packages were indeed used from zip.
    
    This is used only in `--from-zip` testing, to ensure that the GarlicSim
    packages weren't used from the source folders accidentally.
    '''
    sys.stdout.write('Confirming all GarlicSim packages were used from zip '
                     'files... ')
    for i, package_name in enumerate(package_names):
        assert package_name in sys.modules
        package = sys.modules[package_name]
        assert '.zip' in package.__file__
        
        raw_module_names = \
            [module_name for module_name in sys.modules.keys() if
             module_name.split('.')[0] == package_name]
        
        # Filtering out module names that map to `None`, because of a bug,
        # probably in `zipimport`, which litters `sys.modules` with
        # non-sense modules:
        
        module_names = [module_name for module_name in raw_module_names if
                        sys.modules[module_name] is not None]
        
        module_paths = [sys.modules[module_name].__file__ for
                        module_name in module_names]
        
        zip_file_name = str(i) + '.zip'
        snippet_from_real_folder_path = \
            os.path.sep.join((package_name, package_name))
        for module_path in module_paths:
            assert zip_file_name in module_path
            assert snippet_from_real_folder_path not in module_path
    sys.stdout.write('Done.\n')
########NEW FILE########
__FILENAME__ = run_gui
#!/usr/bin/env python

# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''A little module to start the `garlicsim_wx` GUI without installing it.'''

import sys 
import os.path


path_to_garlicsim = os.path.realpath('garlicsim')
path_to_garlicsim_lib = os.path.realpath('garlicsim_lib')
path_to_garlicsim_wx = os.path.realpath('garlicsim_wx')

for path in [path_to_garlicsim, path_to_garlicsim_lib, path_to_garlicsim_wx]:
    if path not in sys.path:
        sys.path.append(path)

arguments = sys.argv[1:]

use_psyco = False
if not ('--psyco=off' in arguments):
    try:
        import psyco
        use_psyco = True
    except ImportError:
        pass
    
    
def start():
    '''Start the GUI.'''
    
    import garlicsim
    import garlicsim_wx
    
    if use_psyco:
        psyco.full()
    garlicsim_wx.start()
    

if __name__ == '__main__':
    start()
########NEW FILE########
__FILENAME__ = run_tests
#!/usr/bin/env python

# Copyright 2009-2011 Ram Rachum.
# This program is distributed under the LGPL2.1 license.

'''
Script for running tests on all GarlicSim packages together.

Nose is used to run the tests, and any extraneous arguments will be passed to
Nose; type `nosetests --help` to see Nose's list of arguments.

GarlicSim-specific arguments:

    --from-zip
        Test GarlicSim when imported from zip files
    
    --from-py2exe
        Test GarlicSim when imported from py2exe distribution
        
    --from-win-installer
        Test GarlicSim when installed from Windows installer.        
        Currently not fully implemented; only creates a Windows installer for
        you as `GarlicSim-x.y.z.exe`, you have to run it yourself and then run
        `run_tests.exe` in the installation folder.

    --help
        Show this help screen
'''

import os.path
import sys
import imp
import types
import glob


frozen = getattr(sys, 'frozen', None)


if frozen:
    our_path = os.path.realpath(os.path.split(sys.executable)[0])
else: # not frozen
    our_path = os.path.realpath(os.path.split(__file__)[0])

    
### Defining import-related utilities: ########################################
#                                                                             #
def exists(module_name):
    '''
    Return whether a module by the name `module_name` exists.
    
    This seems to be the best way to carefully import a module.
    
    Currently implemented for top-level packages only. (i.e. no dots.)
    
    Doesn't support modules imported from a zip file.
    '''
    assert '.' not in module_name
    try:
        imp.find_module(module_name)
    except ImportError:
        return False
    else:
        return True

def import_by_path(path, name=None):
    '''Import module/package by path.'''
    short_name = os.path.splitext(os.path.split(path)[1])[0]
    if name is None: name = short_name
    path_to_dir = os.path.dirname(path)
    my_file = None
    try:
        (my_file, pathname, description) = \
            imp.find_module(short_name, [path_to_dir])
        module = imp.load_module(name, my_file, pathname, description)
    finally:
        if my_file is not None:
            my_file.close()
        
    return module
#                                                                             #
### Finished defining import-related utilities. ###############################
    
### Tweaking nose: ############################################################
#                                                                             #
try:
    import nose
except ImportError:
    import warnings
    warnings.warn('Is Nose installed? It must be for the GarlicSim tests to '
                  'run.')
    raise

if nose.__versioninfo__ < (1, 0, 0):
    raise Exception('Nose version 1.0.0 or higher is required to run tests.')
    
class TestProgram(nose.core.TestProgram):
    '''
    Tester for GarlicSim.
    
    We subclass `nose.core.TestProgram` to make it collect test configurations
    from all the different packages in this repo, and use our own `Config`
    class.
    '''
    def makeConfig(self, env, plugins=None):
        '''
        Load a Config, pre-filled with user config files if any are found.
        
        We override `nose.core.TestProgram.makeConfig` to make it collect test
        configurations from all the different packages in this repo, and use
        our own `Config` class.
        '''
        if frozen:
            cfg_files = [os.path.join(our_path, 'setup.cfg')]
        else: # not frozen
            cfg_files = [
                os.path.join(our_path, 'garlicsim', 'setup.cfg'),
                os.path.join(our_path, 'garlicsim_lib', 'setup.cfg'),
                os.path.join(our_path, 'garlicsim_wx', 'setup.cfg')
            ]
        if plugins:
            manager = nose.core.PluginManager(plugins=plugins)
        else:
            manager = nose.core.DefaultPluginManager()
        return Config(
            env=env, files=cfg_files, plugins=manager)
    
class Config(nose.config.Config):
    '''Nose configuration.''' 
    def configureWhere(self, where):
        '''
        Configure the working directory or directories for the test run.
        
        We override `nose.config.Config.configureWhere` to avoid adding
        together the locations from all the `setup.cfg` files, because Nose
        doesn't handle that well. So we use this script's path, which doesn't
        have any tests on it, as the official 'where' directory, while we pass
        the real test folders as arguments to `TestProgram`, without any
        `--where` flag.
        '''
        return nose.config.Config.configureWhere(
            self,
            our_path
        )

def wantFile(self, file):
    '''
    Is the file a wanted test file?
    
    We are overriding `nose.selector.Selector.wantFile` by monkeypatching it;
    the original implementation doesn't take tests from `.pyc` and `.pyo`
    files, which is problematic for us because when packaging with `py2exe`, we
    get only `.pyc` files in the distribution. So here we override it to take
    `.pyc` and `.pyo` files, but only if they don't have a source module
    associated with them, so we won't run the same test twice.
    '''
    log = nose.selector.log
    # never, ever load files that match anything in ignore
    # (.* _* and *setup*.py by default)
    base = nose.selector.op_basename(file)
    ignore_matches = [ ignore_this for ignore_this in self.ignoreFiles
                       if ignore_this.search(base) ]
    if ignore_matches:
        log.debug('%s matches ignoreFiles pattern; skipped',
                  base) 
        return False
    if not self.config.includeExe and os.access(file, os.X_OK):
        log.info('%s is executable; skipped', file)
        return False
    dummy, ext = nose.selector.op_splitext(base)
    pysrc = ext == '.py'
    
    ### Taking sourceless binary Python files: ################################
    #                                                                         #
    is_binary_python_module = (ext in ['.pyc', '.pyo'])

    if is_binary_python_module:
        corresponding_python_source_file = (os.path.splitext(file)[0] + '.py')
        has_corresponding_source_file = \
            os.path.exists(corresponding_python_source_file)
    
    wanted = self.matches(base) and (pysrc or 
         (is_binary_python_module and not has_corresponding_source_file))
    #                                                                         #
    ### Finished taking sourceless binary Python files. #######################
    
    plug_wants = self.plugins.wantFile(file)
    if plug_wants is not None:
        log.debug("plugin setting want %s to %s", file, plug_wants)
        wanted = plug_wants
    log.debug("wantFile %s? %s", file, wanted)
    return wanted    
nose.selector.Selector.wantFile = \
    types.MethodType(wantFile, None, nose.selector.Selector)

def loadTestsFromDir(self, path):
    """Load tests from the directory at path. This is a generator
    -- each suite of tests from a module or other file is yielded
    and is expected to be executed before the next file is
    examined.
    """
    from nose.loader import (log, add_path, op_abspath, op_isfile, op_isdir,
                             Failure, remove_path, sort_list, regex_last_key,
                             op_join, ispackage)
    
    log.debug("load from dir %s", path)
    plugins = self.config.plugins
    plugins.beforeDirectory(path)
    if self.config.addPaths:
        paths_added = add_path(path, self.config)

    entries = os.listdir(path)
    sort_list(entries, regex_last_key(self.config.testMatch))
    for entry in entries:
        # this hard-coded initial-dot test will be removed:
        # http://code.google.com/p/python-nose/issues/detail?id=82
        if entry.startswith('.'):
            continue
        entry_path = op_abspath(op_join(path, entry))
        is_file = op_isfile(entry_path)
        wanted = False
        if is_file:
            is_dir = False
            wanted = self.selector.wantFile(entry_path)
        else:
            is_dir = op_isdir(entry_path)
            if is_dir:
                # this hard-coded initial-underscore test will be removed:
                # http://code.google.com/p/python-nose/issues/detail?id=82
                if entry.startswith('_'):
                    continue
                wanted = self.selector.wantDirectory(entry_path)
        is_package = ispackage(entry_path)
        if wanted:
            if is_file:
                plugins.beforeContext()
                ### Identifying Python files: #################################
                #                                                             #
                if '.py' in entry[-4:]:
                    yield self.loadTestsFromName(
                        entry_path, discovered=True)
                else:
                    yield self.loadTestsFromFile(entry_path)
                #                                                             #
                ### Finished identifying Python files. ########################
                plugins.afterContext()
            elif is_package:
                # Load the entry as a package: given the full path,
                # loadTestsFromName() will figure it out
                yield self.loadTestsFromName(
                    entry_path, discovered=True)
            else:
                # Another test dir in this one: recurse lazily
                yield self.suiteClass(
                    lambda: self.loadTestsFromDir(entry_path))
    tests = []
    for test in plugins.loadTestsFromDir(path):
        tests.append(test)
    # TODO: is this try/except needed?
    try:
        if tests:
            yield self.suiteClass(tests)
    except (KeyboardInterrupt, SystemExit):
        raise
    except:
        yield self.suiteClass([Failure(*sys.exc_info())])
    
    # pop paths
    if self.config.addPaths:
        for p in paths_added:
          remove_path(p)
    plugins.afterDirectory(path)
nose.loader.TestLoader.loadTestsFromDir = \
    types.MethodType(loadTestsFromDir, None, nose.loader.TestLoader)
#                                                                             #
### Finished tweaking Nose. ###################################################


package_names = ['garlicsim', 'garlicsim_lib', 'garlicsim_wx']
if frozen:
    test_packages_paths = [os.path.join(our_path, 'lib', 'test_%s' %
                           package_name) for package_name in package_names]
    
else: # not frozen
    test_packages_paths = \
        [os.path.join(our_path, package_name, 'test_%s' % package_name)
         for package_name in package_names]

###############################################################################

if __name__ == '__main__':
    
    try:
        import multiprocessing
    except ImportError:
        pass
    else:
        multiprocessing.freeze_support()
    
    argv = sys.argv[:]
    
    if '--help' in argv:
        sys.stdout.write(__doc__ + '\n')
        exit()
    
    sys.stdout.write('Preparing to run tests using Python %s\n' % \
                     sys.version)    
    
    testing_from_zip = '--from-zip' in argv
    testing_from_py2exe = ('--from-py2exe' in argv) or \
        ((frozen is not None) and ('win_dist' in our_path))
    testing_from_win_installer = bool(
        ('--from-win-installer' in argv) or
        ((frozen is not None) and glob.glob(os.path.join(our_path, 'unins*')))
    )
    
    if testing_from_zip + testing_from_py2exe + testing_from_win_installer > 1:
        raise Exception("Can test either from repo, or from zip, or from "
                        "py2exe, or from Windows installer. Can't have more "
                        "than one.")
        
    if testing_from_py2exe:
        
        if os.name != 'nt':
            raise Exception("Can't run tests from `py2exe` on a non-Windows "
                            "platform.")
        
        sys.stdout.write('Running tests from `py2exe` distribution.\n')
    
        if not frozen:
            
            argv.remove('--from-py2exe')
            
            temp_result = os.system(
                '""%s" "%s""' % (
                    sys.executable,
                    os.path.join(
                        our_path,
                        'make_distribution.py'
                    )
                )
            )
            
            if temp_result != 0:
                sys.exit(temp_result)
                
            sys.exit(
                os.system('"%s" %s' % (os.path.join(our_path,
                          'win_dist', 'run_tests.exe'), ' '.join(argv[1:])))
            )

            
    if testing_from_win_installer:
        
        if os.name != 'nt':
            raise Exception("Can't run tests from Windows installation on "
                            "a non-Windows platform.")
        
        if '--from-win-installer' in argv:            
            argv.remove('--from-win-installer')
        
        sys.stdout.write('Running tests from Windows Inno Setup '
                         'installation.\n')

        if not frozen:
            
            temp_result = os.system(
                    '""%s" "%s" --installer"' % (
                        sys.executable,
                        os.path.join(
                            our_path,
                            'make_distribution.py'
                        )
                    )
                )
            
            if temp_result != 0:
                sys.exit(temp_result)
                
            sys.stdout.write(
                'Now please manually run the `GarlicSim-x.y.z.exe` '
                'installer and then run `run_tests.exe` in the '
                'installation folder. Sorry about that.\n'
            )
            sys.exit(0)
    
    if testing_from_zip:
        argv.remove('--from-zip')
        zip_testing_utilities = import_by_path(
            os.path.join(our_path, 'misc', 'testing', 'zip',
                         'testing_utilities')
        )
        zip_testing_utilities.prepare_zip_testing(package_names)
        
    if not (testing_from_zip or testing_from_py2exe or
            testing_from_win_installer):
        
        sys.stdout.write('Running tests directly from GarlicSim repo.\n')
        
    # Adding test packages to arguments to have Nose take tests from them:
    argv += test_packages_paths[::-1]
    # (Reversing package order for now, to put the shorter tests first.)
    
    
    try:
        #######################################################################
        # This is the heavy line, which actually causes Nose to start running
        # tests:
        TestProgram(argv=argv)
        #######################################################################
    
    finally:
        if testing_from_zip:
            zip_testing_utilities.ensure_zip_testing_was_legit(package_names)
        elif testing_from_py2exe:
            sys.stdout.write('Finished testing from `py2exe` distribution.\n')
        elif testing_from_win_installer:
            sys.stdout.write('Finished testing from Windows installation.\n')
        else:
            sys.stdout.write('Finished testing from repo.\n')


########NEW FILE########
