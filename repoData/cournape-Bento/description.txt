.. vim syntax=rst

What is Yaku
============

Yaku is a simple system (think make) in python, aimed at building python
extensions, although it could be used for other tasks if python is your thing

Main features
=============

The main features of Yaku are:

    - Simplicity above all (core code ideally ~ 1000 LOC - currently ~ 1500 LOC)
    - Easy to extend:
	- adding handler for new source types (.pyx for cython, .f for Fortran,
	  .i for SWIG) may be done in one importable module, without the need
	  for monkey-patching or subclasses as currently required by distutils
	- adding new compilers or new tools is also easier
    - Simple dependency handling: whenever a source file content changes, all
      targets which depend on it will be considered out of date
    - Although not yet implemented, parallel builds may be added relatively
      simply
    - Can be used as a library to be controled by an external python process.
      Yaku raison-d'etre is to be the build tool for bento

What Yaku is not
================

Yaku is not a replacement for real build systems like scons or waf. To keep it
simple, I made a few design choices which significantly impact what it can do:

    - Yaku has no notion of source directory - you have to build things from
      the original source directory
    - Once Yaku's DAG is built, it is assumed to never change, and adding new
      dependencies on the fly is not possible. For example, if you have a .c.in
      -> .c task, it won't be possible for yaku to scan changes in the .c file
      (additional headers, etc...)
    - Yaku does not aim at being very fast. It does not uses fancy algorithms,
      and is unlikely to work very well for thousand of source files, although
      it does work ok for packages as large as scipy.

Yaku's design is mostly a dumb-downed rip-off of waf, with a focus on making it
usable as a library. When I started yaku, using waf as a library was a bit
difficult, but the new 1.6 version improved things quite a bit, and I may just
replace yaku by waf at that point.

Why Yaku ?
==========

Currently, the vast majority of python C extensions are built using distutils.
Distutils is an imperative, inflexible way of building extensions.  Instead,
one could use a real build system like the aforementioned waf or scons. But
both are rather large codebases, with their own release schedule.  Yaky aims at
replacing the build infrastructure from distutils. It is used as the default
build engine for bento, but I hope it may become a simple, default engine for
other distributions tools like setuptools/distribute.

Yaku vs distutils
=================

With distutils:

    - Handling new kind of sources (SWIG, Cython, etc...) requires extending
      distutils Commands through subclassing, which cause various issues when
      you need to integrate distutils extensions through various sources.
    - Distutils has no notion of dependency handling
    - Adding new compiler or new type of targets (ctypes, etc...) is a black
      art that few people master
    - Distutils codebase is horrible, and needlessly complex.

Yaku is based around a Task concept similar to make rules, and has a
callback-like system to register new source files types (.pyx for cython or
pyrex, .i for swig, etc...).

    - Each task has a signature, which is used to determine whether a task
      should be executed. The signature depends on the source file content, the
      target content, the build environment as well as the dependencies content
      (md5 checksum), so that changes can be reliably detected.
    - It uses dependencies defined in each task to build things in the correct
      order.
    - Task are automatically built for files with registered file extension,
      and new hooks for extension can be added.
    - Automatic dependency handling (scanning C/C++ files to detect its
      dependencies) may be added later

Note that by default, yaku currently uses the same compilation options as
distutils, but that may change in the future given the inconsistencies in
various bits to get options from (sysconfig, msvc compiler classes/instances,
etc...).

What's with the name ?
======================

Yaku means "bake" or "grill" in Japanese. It also happens that yaki-niku
("grilled meat") is one of my favorite food in Japan.

Example to use distutils instead of default build tool to build C extensions.

.. image:: https://secure.travis-ci.org/cournape/Bento.png
    :alt: Travis CI Build Status

Bento is an alternative to distutils-based packaging tools such as distutils,
setuptools or distribute. Bento focus on reproducibility, extensibility and
simplicity (in that order).

Packaging is as simple as writing a bento.info file with a file which looks as
follows::

    Name: Foo
    Author: John Doe

    Library:
        Packages: foo

The package is then installed with bentomaker, the command line interface to
bento::

    bentomaker install

Installing
==========

To install bento, you can either:

    * install bento from itself (recommended)::

        python bootstrap.py
        ./bentomaker install

    * install bento using setuptools (not recommended)::

        python setup.py install

Python3 support
---------------

Bento supports python 3 as is, so there is no need to run 2to3 on it (doing so
will probably break it).

Development
============

Bento discussions happen on the bento Mailing list (bento@librelist.com,
archive on `bento-ml`_). To subscribe, you simply need to send an email to the
list. Development is on `github`_. Bugs should be reported on bento
`issue-tracker`_. Online `documentation`_ is available on github as well.

Why you should use bento ?
==========================

    * Straightfoward package description, in an indentation-based syntax
      similar to python
    * Simple packages can have their setup.py automatically converted through
      the 'convert' command
    * Distutils compatibility mode so that a bento package can be installed
      through pip
    * Adding new commands is simple
    * Pluggable build-backend: you can build your C extensions with a real
      build system such as waf or scons.
    * Easy to customize install paths from the command line, with sensible
      defaults on every platform
    * Installing data files such as manpages, configuration, etc... is
      straightforward and customizable through the command line
    * Supports all python versions >= 2.4 (including 3.x)
    * Designed with reproducibility in mind: re-running the same command twice
      should produce the same result (idempotency)
    * Preliminary support for windows installers (.exe), eggs and mpkg.

But bento does more:

    * Designed as a library from the ground up, with a focus on robustness and
      extensibility:

        * new commands can be inserted before/after an existing one without
          modifying the latter (no monkey-patching needed)
        * easy to add command line options to existing commands
        * each command has a pre/post hook
        * API designed such as commands need to know very little from each other.
        * Moving toward a node-based architecture for robust file location
          (waf-based design)
        * No global variable/singleton in bento itself

    * Easily bundable, one-file distribution to avoid extra-dependencies when
      using bento. You only need to add one file to your sources, no need for
      your users to install anything.
    * Basic support for console scripts ala setuptools
    * Dependency-based extension builders (source content change is
      automatically rebuilt)
    * Parallel build support for C extensions
    * Low-level interface to the included build tool to override/change any
      compilation parameter (compilation flag, compiler, etc...)

Planned features:

    * Reliable and fast (parallel) 2->3 convertion.
    * Support for msi packages
    * Reliable conversion between packaging formats on the platforms where it
      makes sense (egg <-> wininst, mpkg <-> egg, etc...)
    * Provide API to enable Linux distributors to write simple extensions for
      packaging bento-packages as they see fit
    * Infrastructure for a correctly designed package index, using
      well-known packaging practices instead of the broken easy_install + pypi
      model (easy mirroring, enforced metadata, indexing to enable
      querying-before-installing, reliable install, etc...).

WHILE BENTO IS ALREADY USABLE, IT MAY STILL SIGNIFICANTLY CHANGE IN BACKWARD
INCOMPATIBLE WAYS UNTIL THE FIRST ALPHA.

.. _github: http://github.com/cournape/Bento.git
.. _issue-tracker: http://github.com/cournape/bento/issues
.. _documentation: http://cournape.github.com/Bento
.. _bento-ml: http://librelist.com/browser/bento

