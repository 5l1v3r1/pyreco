Style #1
==============================

Constraints:

- Very small amount of primary memory, typically orders of magnitude
  smaller than the data that needs to be processed/generated. 
  (The example sets the limit to 1024 cells)

- No labels -- i.e. no variable names or tagged memory addresses. All we have is
  memory that is addressable with numbers.

Possible names:

- Good old times
- Early 50s style

NOTE: this example program takes a good 5-10 minutes to run over 
Pride and Prejudice

Style #2
==============================

Constraints:

- Existence of an all-important data stack. All operations
  (conditionals, arithmetic, etc.) are done over data on the stack

- Existence of a heap for storing data that's needed for later
  operations. The heap data can be associated with names
  (i.e. variables). As said above, all operations are done over
  data on the stack, so any heap data that needs to be operated upon
  needs to be moved first to the stack and eventually back to the heap

- Abstraction in the form of user-defined "procedures" (i.e. names
  bound to a set of instructions), which may be called something else
  entirely

Possible names:

- Go-Forth (as in the Forth programming language)
- Stack machine


Style #3
==============================

Constraints:

- No abstractions
- No use of library functions

Possible names:

- Monolith
- Labyrinth
- Brain dump

Style #4
==============================

Constraints:

- Larger problem decomposed in procedural abstractions
- Larger problem solved as a sequence of commands, each corresponding to a procedure

Possible names:

- Cookbook
- Procedural

Style #5
==============================

Constraints:

- Larger problem decomposed in functional abstractions. Functions, according to Mathematics, are relations from inputs to outputs.
- Larger problem solved as a pipeline of function applications

Possible names:

- Candy factory
- Functional
- Pipeline

Style #6
==============================

Constraints:

- As few lines of code as possible

Possible names:

- Code golf
- Try hard

Style #7
==============================

Constraints:

- All, or a significant part, of the problem is modelled by
  induction. That is, specify the base case (n_0) and then the n+1
  rule

Possible names:

- Infinite mirror
- Inductive
- Recursive


Style #8
==============================

Variation of the candy factory style, with the following additional constraints:

- Each function takes an additional parameter, usually the last, which is another function
- That function parameter is applied at the end of the current function
- That function parameter is given as input what would be the output of the current function
- Larger problem is solved as a pipeline of functions, but where the next function to be applied is given as parameter to the current function

Possible names:

- Kick your teammate forward!
- Continuation-passing style
- Crochet loop

Style #9
==============================

Constraints:

- Existence of an abstraction to which values can be
converted. 

- This abstraction provides operations to (1) wrap
around values, so that they become the abstraction; (2) bind
itself to functions, so to establish sequences of functions;
and (3) unwrap the value, so to examine the final result.

- Larger problem is solved as a pipeline of functions bound
together, with unwrapping happening at the end.

- Particularly for The One style, the bind operation simply
calls the given function, giving it the value that it holds, and holds
on to the returned value.


Possible names:

- The One
- Monadic Identity
- The wrapper of all things
- Imperative functional style

Style #10
==============================

Constraints:

- The larger problem is decomposed into 'things' that make sense for
  the problem domain 

- Each 'thing' is a capsule of data that exposes procedures to the
  rest of the world

- Data is never accessed directly, only through these procedures

- Capsules can reappropriate procedures defined in other capsules

Possible names:

- Things
- Object-oriented style
- The Kingdom of Nouns (http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html)

Style #14
==============================

Constraints:

- The larger problem is decomposed into 'things' that make sense for
  the problem domain 

- Each 'thing' is a capsule of data that exposes one single procedure,
  namely the ability to receive and dispatch messages that are sent to
  it

- Message dispatch can result in sending the message to another capsule

Possible names:

- Letterbox
- Messaging style
- Objects
- Actors

Style #12
==============================

Constraints:

- The larger problem is decomposed into 'things' that make sense for
  the problem domain 

- Each 'thing' is a map from keys to values. Some values
are procedures/functions.

Possible names:

- Closed Maps
- Prototypes


Style #13
==============================

Constraints:

- The larger problem is decomposed into 'abstract things' that make
  sense for the problem domain

- Each abstract thing is described by what operations the things of
  that abstraction can eventually do

- Concrete things are then bound, somehow, to the abstractions; mechanisms
  for doing that vary

- The rest of the application uses the things not by what they are but
  by they do in abstract

Possible names:

- Abstract things
- Abstract data types

Style #14
==============================

Constraints:

- Larger problem is decomposed into entities using some form of abstraction
  (objects, modules or similar)

- The entities are never called on directly for actions

- The entities provide interfaces for other entities to be
  able to register callbacks

- At certain points of the computation, the entities call on the other
  entities that have registered for callbacks

Possible names:

- Hollywood agent: "don't call us, we'll call you"
- Inversion of control
- Callback heaven/hell

Style #15
==============================

Constraints:

- Larger problem is decomposed into entities using some form of abstraction
  (objects, modules or similar)

- The entities are never called on directly for actions

- Existence of an infrastructure for publishing and subscribing to
  events, aka the bulletin board

- Entities post event subscriptions (aka 'wanted') to the bulletin
  board and publish events (aka 'offered') to the bulletin board. the
  bulletin board does all the event management and distribution

Possible names:

- Bulletin board
- Publish-Subscribe

Style #16
==============================

Constraints:

- The problem is decomposed using some form of abstraction (procedures, functions, objects, etc.)

- The abstractions have access to information about themselves, although they cannot modify that information


Possible names:

- Introspective
- Navel-gazing


Style #17
==============================

Constraints:

- The program has access to information about itself, i.e. introspection

- The program can modify itself -- adding more abstractions, variables, etc. at run-time


Possible names:

- Reflective, as in "I see me, so I can change myself"
- Metaprogramming style
- Self-referential


Style #18
==============================

Constraints:

- The problem is decomposed using some form of abstraction (procedures, functions, objects, etc.)

- Aspects of the problem are added to the main program without any
  edits to the source code of the abstractions. These side functions
  latch on the main abstractions by naming them, as in "I'm an aspect
  of foo (even though foo may not know it!)"


Possible names:

- Asides
- Aspect-oriented style
- Rewriting the story

Style #19
==============================

Constraints:

- The problem is decomposed using some form of abstraction
  (procedures, functions, objects, etc.)

- All or some of those abstractions are physically encapsulated into
  their own, usually pre-compiled, packages. Main program and each of
  the packages are compiled independently. These packages are loaded
  dynamically by the main program, usually in the beginning (but not
  necessarily).

- Main program uses functions/objects from the dynamically-loaded
  packages, without knowing which exact implementations will be
  used. New implementations can be used without having to adapt or
  recompile the main program.

- External specification of which packages to load. This can be done
  by a configuration file, path conventions, user input or other
  mechanisms for external specification of code to be linked at run
  time.

Possible names:

- No commitment
- Plugins
- Dependency injection

Style #20
==============================

Constraints:

- Every single procedure and function checks the sanity of its
  arguments and either returns something sensible when the arguments
  are unreasonable or assigns them reasonable values

- All code blocks check for possible errors and escape the block
  when things go wrong, setting the state to something reasonable

Possible names:

- Constructive
- Defensive
- Hopeful
- Shit happens, life goes on

(See http://en.wikipedia.org/wiki/Constructivism_(mathematics))

Style #21
==============================

Constraints:

- Every single procedure and function checks the sanity of its
  arguments and refuses to continue when the arguments are
  unreasonable

- All code blocks check for all possible errors, possibly print out
  context-specific messages when errors occur, and pass the errors
  up the function call chain

Possible names:

- Tantrum
- Design by contract
- Mental breakdown

Style #22
==============================

Constraints:

- Every single procedure and function checks the sanity of its
  arguments and refuses to continue when the arguments are
  unreasonable, jumping out of the function

- When calling out other functions, program functions only check for
  errors if they are in a position to react meaningully

- Error handling occurs at higher levels of function call chains,
  wherever it is meaningul to do so

Possible names:

- Passive aggressive
- Exception



Style #23
==============================

Constraints:

- Existence of a run-time typechecker

- Procedures and functions declare what types of arguments they expect

- If callers send arguments of types that are't expected, the
  procedures/functions are not executed


Possible names:

- declared intentions
- "You've been warned!"


Style #24
==============================

This style is a variation of style #09, The One, with the following additional constraints:

Constraints:

- Core program functions have no side effects of any kind, including IO

- All IO actions must be contained in computation sequences that are
  clearly separated from the pure functions

- All sequences that have IO must be called from the main program

Possible names:

- Quarantine
- Monadic IO
- Imperative functional style

Style #25
==============================

Constraints:

- The input data of the problem is modeled as entities with relations between them

- The data is placed in tables, with columns potentially cross-referencing data in other tables

- Existence of a relational query engine

- The problem is solved by issuing queries over the tabular data

Possible names:

- Tabular
- Flatland
- Relational

Style #26
==============================

Constraints:

- The problem is modeled like a spreadsheet, with columns of data and formulas

- Some data depends on other data according to formulas. When data
  changes, the dependent data also changes automatically.


Possible names:

- Spreadsheet
- Dataflow
- Active data

Style #27
==============================

Constraints:

- Data comes to functions in streams, rather than as a complete whole all at at once
- Functions are filters / transformers from one kind of data stream to another

Possible names:

- Lazy rivers
- Data streams
- Dataflow
- Data generators

Style #28
==============================

Similar to the letterbox style, but where the 'things' have
independent threads of execution.

Constraints:

- The larger problem is decomposed into 'things' that make sense for
  the problem domain 

- Each 'thing' has a queue meant for other \textit{things} to place
messages in it

- Each 'thing' is a capsule of data that exposes only its
ability to receive messages via the queue

- Each 'thing' has its own thread of execution independent of the
others.

Possible names:

- Free agents
- Active letterbox
- Actors

Style #29
==============================

Constraints:

- Existence of one or more units that execute concurrently

- Existence of one or more data spaces where concurrent units store and
  retrieve data

- No direct data exchanges between the concurrent units, other than via the data spaces

Possible names:

- Dataspaces
- Linda


Style #30
==============================

Constraints:

- Input data is divided in chunks, similar to what an inverse multiplexer does to input signals

- A map function applies a given worker function to each chunk of data, potentially in parallel

- A reduce function takes the results of the many worker functions and recombines them into a coherent output

Possible names:

- Map-reduce
- Inverse multiplexer (check out electronics)

Style #31
==============================

Very similar to style #30, but with an additional twist

Constraints:

- Input data is divided in chunks, similar to what an inverse multiplexer does to input signals

- A map function applies a given worker function to each chunk of data, potentially in parallel

- The results of the many worker functions are reshuffled in a way
  that allows for the reduce step to be also parallelized

- The reshuffled chunks of data are given as input to a second map
  function that takes a reducible function as input

Possible names:

- Map-reduce 
- Hadoop style
- Double inverse multiplexer 

Style #32
==============================

Constraints:

- The application is divided into three components: the model, the
  view and the controller. The model represents the application's
  data; the view represents a specific rendition of the data; the
  controller provides for input/output, for populating/updating the
  model and for invoking the right view.

Possible names:

- Trinity
- Model/View/Controller


Style #33
==============================

REST = REpresentational State Transfer (http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)

REST is a style for network-based interactive applications that
underlies the Web. The example here doesn't go over the network, but
preserves the main contraints of REST, which are:

- Interactive: end-to-end between an active agent (e.g. a person) and a backend

- Separation between Client (user interface) and Server (data storage)

- Statelessness, as in client--stateless-server: every request from
  client to server must contain all the information necessary for the
  server to serve the request. The server cannot store
  context of the interaction. Session state is on the client.

- Uniform interface: resources that are created and retrieved,
  resource identifiers and hypermedia representation that is the
  engine of application state

Additionally, the networked style has the following contraints, not shown here:

- Cache

- Layered system

- Code-on-demand

Possible names:

- RESTful
- Stateless Ping-Pong


Style #34
==============================

Constraints:

- No returns before the end of procedures or functions

- No breaks or continues in iterations

Possible names:

- The flow



Exercises in Programming Style
==============================

Comprehensive collection of well-known, and not so well-known, programming
styles using a simple computational task, term frequency. All programs run 
with the following command line:

$ python tf-NN.py ../pride-and-prejudice.txt

Additions are welcome! 

You can contribute: 
- an example program that follows one of the existing styles, but written in a
  different programming language 
- an entirely new programming style
- new names for the existing styles
- discussion of names, pros and cons of each style

Please follow the conventions suggested by the existing code base,
specifically:

- If you are contributing a program in a different programming language,
add that file to the corresponding style folder and call it tf-nn.ext,
where nn is the style number and ext is the language's standard
extension suffix.

- If you are contributing a new style, make a new folder called
nn-funname and add an example program in that folder called
tf-nn.ext. (nn is the next avalaible number in the collection)
Additionally, add a README.md file that clearly describes the
contraints for writing programs in that style. I will only consider
new styles corresponding to constraints that are clearly different
from the ones that already exist in the collection. (different
programs written in existing styles are exercises for students, and
should not be here)

Contributions of new names and discussion should be done under Issues
or on the Wiki part of this repo.

To test your work, make sure your script is executable and then run:

```
./test/test.sh NN
```

Where `NN` is the number prefix of the directory you're adding.

Never stop exercising!

Love,
Crista

P.S. Inspiration for this collection: http://en.wikipedia.org/wiki/Exercises_in_Style


