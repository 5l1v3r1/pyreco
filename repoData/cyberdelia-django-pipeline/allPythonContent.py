__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Pipeline documentation build configuration file, created by
# sphinx-quickstart on Sat Apr 30 17:47:55 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys
import os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'django-pipeline'
copyright = u'2011-2014, Timothée Peignier'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '1.3'
# The full version, including alpha/beta/rc tags.
release = '1.3.24'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
#html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'django-pipelinedoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'django-pipeline.tex', u'Pipeline Documentation',
   u'Timothée Peignier', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'django-pipeline', u'Pipeline Documentation',
     [u'Timothée Peignier'], 1)
]

########NEW FILE########
__FILENAME__ = coffee
from __future__ import unicode_literals

from pipeline.conf import settings
from pipeline.compilers import SubProcessCompiler


class CoffeeScriptCompiler(SubProcessCompiler):
    output_extension = 'js'

    def match_file(self, path):
        return path.endswith('.coffee') or path.endswith('.litcoffee')

    def compile_file(self, infile, outfile, outdated=False, force=False):
        if not outdated and not force:
            return  # File doesn't need to be recompiled
        command = "%s -cp %s %s > %s" % (
            settings.PIPELINE_COFFEE_SCRIPT_BINARY,
            settings.PIPELINE_COFFEE_SCRIPT_ARGUMENTS,
            infile,
            outfile
        )
        return self.execute_command(command)

########NEW FILE########
__FILENAME__ = less
from __future__ import unicode_literals

from os.path import dirname

from pipeline.conf import settings
from pipeline.compilers import SubProcessCompiler


class LessCompiler(SubProcessCompiler):
    output_extension = 'css'

    def match_file(self, filename):
        return filename.endswith('.less')

    def compile_file(self, infile, outfile, outdated=False, force=False):
        command = "%s %s %s %s" % (
            settings.PIPELINE_LESS_BINARY,
            settings.PIPELINE_LESS_ARGUMENTS,
            infile,
            outfile
        )
        return self.execute_command(command, cwd=dirname(infile))

########NEW FILE########
__FILENAME__ = livescript
from __future__ import unicode_literals

from pipeline.conf import settings
from pipeline.compilers import SubProcessCompiler


class LiveScriptCompiler(SubProcessCompiler):
    output_extension = 'js'

    def match_file(self, path):
        return path.endswith('.ls')

    def compile_file(self, infile, outfile, outdated=False, force=False):
        if not outdated and not force:
            return  # File doesn't need to be recompiled
        command = "%s -cp %s %s > %s" % (
            settings.PIPELINE_LIVE_SCRIPT_BINARY,
            settings.PIPELINE_LIVE_SCRIPT_ARGUMENTS,
            infile,
            outfile
        )
        return self.execute_command(command)

########NEW FILE########
__FILENAME__ = sass
from __future__ import unicode_literals

from os.path import dirname

from pipeline.conf import settings
from pipeline.compilers import SubProcessCompiler


class SASSCompiler(SubProcessCompiler):
    output_extension = 'css'

    def match_file(self, filename):
        return filename.endswith(('.scss', '.sass'))

    def compile_file(self, infile, outfile, outdated=False, force=False):
        command = "%s %s %s:%s" % (
            settings.PIPELINE_SASS_BINARY,
            settings.PIPELINE_SASS_ARGUMENTS,
            infile,
            outfile
        )
        return self.execute_command(command, cwd=dirname(infile))

########NEW FILE########
__FILENAME__ = stylus
from __future__ import unicode_literals

from os.path import dirname

from pipeline.conf import settings
from pipeline.compilers import SubProcessCompiler


class StylusCompiler(SubProcessCompiler):
    output_extension = 'css'

    def match_file(self, filename):
        return filename.endswith('.styl')

    def compile_file(self, infile, outfile, outdated=False, force=False):
        command = "%s %s %s" % (
            settings.PIPELINE_STYLUS_BINARY,
            settings.PIPELINE_STYLUS_ARGUMENTS,
            infile
        )
        return self.execute_command(command, cwd=dirname(infile))

########NEW FILE########
__FILENAME__ = closure
from __future__ import unicode_literals

from pipeline.conf import settings
from pipeline.compressors import SubProcessCompressor


class ClosureCompressor(SubProcessCompressor):
    def compress_js(self, js):
        command = '%s %s' % (settings.PIPELINE_CLOSURE_BINARY, settings.PIPELINE_CLOSURE_ARGUMENTS)
        return self.execute_command(command, js)

########NEW FILE########
__FILENAME__ = cssmin
from __future__ import unicode_literals

from pipeline.conf import settings
from pipeline.compressors import SubProcessCompressor


class CSSMinCompressor(SubProcessCompressor):
    def compress_css(self, css):
        command = "%s %s" % (settings.PIPELINE_CSSMIN_BINARY, settings.PIPELINE_CSSMIN_ARGUMENTS)
        return self.execute_command(command, css)

########NEW FILE########
__FILENAME__ = csstidy
from __future__ import unicode_literals

from django.core.files import temp as tempfile

from pipeline.conf import settings
from pipeline.compressors import SubProcessCompressor


class CSSTidyCompressor(SubProcessCompressor):
    def compress_css(self, css):
        output_file = tempfile.NamedTemporaryFile(suffix='.pipeline')

        command = '%s - %s %s' % (
            settings.PIPELINE_CSSTIDY_BINARY,
            settings.PIPELINE_CSSTIDY_ARGUMENTS,
            output_file.name
        )
        self.execute_command(command, css)

        filtered_css = output_file.read()
        output_file.close()
        return filtered_css

########NEW FILE########
__FILENAME__ = jsmin
from __future__ import absolute_import, unicode_literals

from pipeline.compressors import CompressorBase


class JSMinCompressor(CompressorBase):
    """
    JS compressor based on the Python library jsmin
    (http://pypi.python.org/pypi/jsmin/).
    """
    def compress_js(self, js):
        from jsmin import jsmin
        return jsmin(js)

########NEW FILE########
__FILENAME__ = slimit
from __future__ import absolute_import, unicode_literals

from pipeline.compressors import CompressorBase


class SlimItCompressor(CompressorBase):
    """
    JS compressor based on the Python library slimit
    (http://pypi.python.org/pypi/slimit/).
    """
    def compress_js(self, js):
        from slimit import minify
        return minify(js)

########NEW FILE########
__FILENAME__ = uglifyjs
from __future__ import unicode_literals

from pipeline.conf import settings
from pipeline.compressors import SubProcessCompressor


class UglifyJSCompressor(SubProcessCompressor):
    def compress_js(self, js):
        command = '%s %s' % (settings.PIPELINE_UGLIFYJS_BINARY, settings.PIPELINE_UGLIFYJS_ARGUMENTS)
        if self.verbose:
            command += ' --verbose'
        return self.execute_command(command, js)

########NEW FILE########
__FILENAME__ = yuglify
from __future__ import unicode_literals

from pipeline.conf import settings
from pipeline.compressors import SubProcessCompressor


class YuglifyCompressor(SubProcessCompressor):
    def compress_common(self, content, compress_type, arguments):
        command = '%s --type=%s %s' % (settings.PIPELINE_YUGLIFY_BINARY, compress_type, arguments)
        return self.execute_command(command, content)

    def compress_js(self, js):
        return self.compress_common(js, 'js', settings.PIPELINE_YUGLIFY_JS_ARGUMENTS)

    def compress_css(self, css):
        return self.compress_common(css, 'css', settings.PIPELINE_YUGLIFY_CSS_ARGUMENTS)

########NEW FILE########
__FILENAME__ = yui
from __future__ import unicode_literals

from pipeline.conf import settings
from pipeline.compressors import SubProcessCompressor


class YUICompressor(SubProcessCompressor):
    def compress_common(self, content, compress_type, arguments):
        command = '%s --type=%s %s' % (settings.PIPELINE_YUI_BINARY, compress_type, arguments)
        return self.execute_command(command, content)

    def compress_js(self, js):
        return self.compress_common(js, 'js', settings.PIPELINE_YUI_JS_ARGUMENTS)

    def compress_css(self, css):
        return self.compress_common(css, 'css', settings.PIPELINE_YUI_CSS_ARGUMENTS)

########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
from __future__ import unicode_literals

from django.conf import settings as _settings

DEFAULTS = {
    'DEBUG': False,

    'PIPELINE_ENABLED': not _settings.DEBUG,

    'PIPELINE_ROOT': _settings.STATIC_ROOT,
    'PIPELINE_URL': _settings.STATIC_URL,

    'PIPELINE_STORAGE': 'pipeline.storage.PipelineFinderStorage',

    'PIPELINE_CSS_COMPRESSOR': 'pipeline.compressors.yuglify.YuglifyCompressor',
    'PIPELINE_JS_COMPRESSOR': 'pipeline.compressors.yuglify.YuglifyCompressor',
    'PIPELINE_COMPILERS': [],

    'PIPELINE_CSS': {},
    'PIPELINE_JS': {},

    'PIPELINE_TEMPLATE_NAMESPACE': "window.JST",
    'PIPELINE_TEMPLATE_EXT': ".jst",
    'PIPELINE_TEMPLATE_FUNC': "template",
    'PIPELINE_TEMPLATE_SEPARATOR': "_",

    'PIPELINE_DISABLE_WRAPPER': False,

    'PIPELINE_CSSTIDY_BINARY': '/usr/bin/env csstidy',
    'PIPELINE_CSSTIDY_ARGUMENTS': '--template=highest',

    'PIPELINE_YUGLIFY_BINARY': '/usr/bin/env yuglify',
    'PIPELINE_YUGLIFY_CSS_ARGUMENTS': '--terminal',
    'PIPELINE_YUGLIFY_JS_ARGUMENTS': '--terminal',

    'PIPELINE_YUI_BINARY': '/usr/bin/env yuicompressor',
    'PIPELINE_YUI_CSS_ARGUMENTS': '',
    'PIPELINE_YUI_JS_ARGUMENTS': '',

    'PIPELINE_CLOSURE_BINARY': '/usr/bin/env closure',
    'PIPELINE_CLOSURE_ARGUMENTS': '',

    'PIPELINE_UGLIFYJS_BINARY': '/usr/bin/env uglifyjs',
    'PIPELINE_UGLIFYJS_ARGUMENTS': '',

    'PIPELINE_CSSMIN_BINARY': '/usr/bin/env cssmin',
    'PIPELINE_CSSMIN_ARGUMENTS': '',

    'PIPELINE_COFFEE_SCRIPT_BINARY': '/usr/bin/env coffee',
    'PIPELINE_COFFEE_SCRIPT_ARGUMENTS': '',

    'PIPELINE_LIVE_SCRIPT_BINARY': '/usr/bin/env lsc',
    'PIPELINE_LIVE_SCRIPT_ARGUMENTS': '',

    'PIPELINE_SASS_BINARY': '/usr/bin/env sass',
    'PIPELINE_SASS_ARGUMENTS': '--update',

    'PIPELINE_STYLUS_BINARY': '/usr/bin/env stylus',
    'PIPELINE_STYLUS_ARGUMENTS': '',

    'PIPELINE_LESS_BINARY': '/usr/bin/env lessc',
    'PIPELINE_LESS_ARGUMENTS': '',

    'PIPELINE_MIMETYPES': (
        (b'text/coffeescript', '.coffee'),
        (b'text/less', '.less'),
        (b'application/javascript', '.js'),
        (b'text/x-sass', '.sass'),
        (b'text/x-scss', '.scss')
    ),

    'PIPELINE_EMBED_MAX_IMAGE_SIZE': 32700,
    'PIPELINE_EMBED_PATH': r'[/]?embed/',
}


class PipelineSettings(object):
    '''
    Lazy Django settings wrapper for Django Pipeline
    '''
    def __init__(self, wrapped_settings):
        self.wrapped_settings = wrapped_settings

    def __getattr__(self, name):
        if hasattr(self.wrapped_settings, name):
            return getattr(self.wrapped_settings, name)
        elif name in DEFAULTS:
            return DEFAULTS[name]
        else:
            raise AttributeError("'%s' setting not found" % name)

settings = PipelineSettings(_settings)

########NEW FILE########
__FILENAME__ = exceptions
from __future__ import unicode_literals


class PipelineException(Exception):
    pass


class PackageNotFound(PipelineException):
    pass


class CompilerError(PipelineException):
    pass


class CompressorError(PipelineException):
    pass

########NEW FILE########
__FILENAME__ = finders
from itertools import chain

from django.contrib.staticfiles.finders import BaseFinder, AppDirectoriesFinder, FileSystemFinder, find
from django.utils._os import safe_join

from pipeline.conf import settings


class PipelineFinder(BaseFinder):
    def find(self, path, all=False):
        """
        Looks for files in PIPELINE_CSS and PIPELINE_JS
        """
        matches = []
        for elem in chain(settings.PIPELINE_CSS.values(), settings.PIPELINE_JS.values()):
            if elem['output_filename'] == path:
                match = safe_join(settings.PIPELINE_ROOT, path)
                if not all:
                    return match
                matches.append(match)
        return matches

    def list(self, *args):
        return []


class CachedFileFinder(BaseFinder):
    def find(self, path, all=False):
        """
        Work out the uncached name of the file and look that up instead
        """
        try:
            start, _, extn = path.rsplit('.', 2)
            path = '.'.join((start, extn))
            return find(path, all=all)
        except ValueError:
            return []

    def list(self, *args):
        return []


class PatternFilterMixin(object):
    ignore_patterns = []

    def get_ignored_patterns(self):
        return list(set(self.ignore_patterns))

    def list(self, ignore_patterns):
        if ignore_patterns:
            ignore_patterns = ignore_patterns + self.get_ignored_patterns()
        return super(PatternFilterMixin, self).list(ignore_patterns)


class AppDirectoriesFinder(PatternFilterMixin, AppDirectoriesFinder):
    """
    Like AppDirectoriesFinder, but doesn't return any additional ignored
    patterns.

    This allows us to concentrate/compress our components without dragging
    the raw versions in via collectstatic.
    """
    ignore_patterns = [
        '*.js',
        '*.css',
        '*.less',
        '*.scss',
    ]


class FileSystemFinder(PatternFilterMixin, FileSystemFinder):
    """
    Like FileSystemFinder, but doesn't return any additional ignored patterns

    This allows us to concentrate/compress our components without dragging
    the raw versions in too.
    """
    ignore_patterns = [
        '*.js',
        '*.less',
        '*.scss',
        '*.sh',
        '*.html',
        '*.md',
        '*.markdown',
        '*.php',
        '*.txt',
        'README*',
        'LICENSE*',
        '*examples*',
        '*test*',
        '*bin*',
        '*samples*',
        '*docs*',
        '*build*',
        '*demo*',
        'Makefile*',
        'Gemfile*',
    ]

########NEW FILE########
__FILENAME__ = glob
from __future__ import unicode_literals

import os
import re
import fnmatch

from pipeline.storage import default_storage

__all__ = ["glob", "iglob"]


def glob(pathname):
    """Return a list of paths matching a pathname pattern.

    The pattern may contain simple shell-style wildcards a la fnmatch.

    """
    return sorted(list(iglob(pathname)))


def iglob(pathname):
    """Return an iterator which yields the paths matching a pathname pattern.

    The pattern may contain simple shell-style wildcards a la fnmatch.

    """
    if not has_magic(pathname):
        try:
            if default_storage.exists(pathname):
                yield pathname
        except NotImplementedError:
            # Being optimistic
            yield pathname
        return
    dirname, basename = os.path.split(pathname)
    if not dirname:
        for name in glob1(dirname, basename):
            yield name
        return
    if has_magic(dirname):
        dirs = iglob(dirname)
    else:
        dirs = [dirname]
    if has_magic(basename):
        glob_in_dir = glob1
    else:
        glob_in_dir = glob0
    for dirname in dirs:
        for name in glob_in_dir(dirname, basename):
            yield os.path.join(dirname, name)

# These 2 helper functions non-recursively glob inside a literal directory.
# They return a list of basenames. `glob1` accepts a pattern while `glob0`
# takes a literal basename (so it only has to check for its existence).


def glob1(dirname, pattern):
    try:
        directories, files = default_storage.listdir(dirname)
        names = directories + files
    except Exception:
        # We are not sure that dirname is a real directory
        # and storage implementations are really exotic.
        return []
    if pattern[0] != '.':
        names = [x for x in names if x[0] != '.']
    return fnmatch.filter(names, pattern)


def glob0(dirname, basename):
    if default_storage.exists(os.path.join(dirname, basename)):
        return [basename]
    return []


magic_check = re.compile('[*?[]')


def has_magic(s):
    return magic_check.search(s) is not None

########NEW FILE########
__FILENAME__ = ext
from __future__ import unicode_literals

from jinja2 import nodes, TemplateSyntaxError
from jinja2.ext import Extension

from django.contrib.staticfiles.storage import staticfiles_storage

from pipeline.packager import PackageNotFound
from pipeline.utils import guess_type
from pipeline.templatetags.compressed import CompressedMixin


class PipelineExtension(CompressedMixin, Extension):
    tags = set(['compressed_css', 'compressed_js'])

    def parse(self, parser):
        tag = next(parser.stream)

        package_name = parser.parse_expression()
        if not package_name:
            raise TemplateSyntaxError("Bad package name", tag.lineno)

        args = [package_name]
        if tag.value == "compressed_css":
            return nodes.CallBlock(self.call_method('package_css', args), [], [], []).set_lineno(tag.lineno)

        if tag.value == "compressed_js":
            return nodes.CallBlock(self.call_method('package_js', args), [], [], []).set_lineno(tag.lineno)

        return []

    def package_css(self, package_name, *args, **kwargs):
        try:
            package = self.package_for(package_name, 'css')
        except PackageNotFound:
            return ''  # fail silently, do not return anything if an invalid group is specified
        return self.render_compressed(package, 'css')

    def render_css(self, package, path):
        template_name = package.template_name or "pipeline/css.jinja"
        context = package.extra_context
        context.update({
            'type': guess_type(path, 'text/css'),
            'url': staticfiles_storage.url(path)
        })
        template = self.environment.get_template(template_name)
        return template.render(context)

    def render_individual_css(self, package, paths, **kwargs):
        tags = [self.render_css(package, path) for path in paths]
        return '\n'.join(tags)

    def package_js(self, package_name, *args, **kwargs):
        try:
            package = self.package_for(package_name, 'js')
        except PackageNotFound:
            return ''  # fail silently, do not return anything if an invalid group is specified
        return self.render_compressed(package, 'js')

    def render_js(self, package, path):
        template_name = package.template_name or "pipeline/js.jinja"
        context = package.extra_context
        context.update({
            'type': guess_type(path, 'text/javascript'),
            'url': staticfiles_storage.url(path)
        })
        template = self.environment.get_template(template_name)
        return template.render(context)

    def render_inline(self, package, js):
        context = package.extra_context
        context.update({
            'source': js
        })
        template = self.environment.get_template("pipeline/inline_js.jinja")
        return template.render(context)

    def render_individual_js(self, package, paths, templates=None):
        tags = [self.render_js(package, js) for js in paths]
        if templates:
            tags.append(self.render_inline(package, templates))
        return '\n'.join(tags)

########NEW FILE########
__FILENAME__ = manifest
from __future__ import unicode_literals

import os

from django.contrib.staticfiles.finders import get_finders
from django.contrib.staticfiles.storage import staticfiles_storage

from pipeline.conf import settings

from manifesto import Manifest

from pipeline.packager import Packager


class PipelineManifest(Manifest):
    def __init__(self):
        self.packager = Packager()
        self.packages = self.collect_packages()
        self.finders = get_finders()
        self.package_files = []

    def collect_packages(self):
        packages = []
        for package_name in self.packager.packages['css']:
            package = self.packager.package_for('css', package_name)
            if package.manifest:
                packages.append(package)
        for package_name in self.packager.packages['js']:
            package = self.packager.package_for('js', package_name)
            if package.manifest:
                packages.append(package)
        return packages

    def cache(self):
        ignore_patterns = getattr(settings, "STATICFILES_IGNORE_PATTERNS", None)

        if settings.PIPELINE_ENABLED:
            for package in self.packages:
                path = package.output_filename
                self.package_files.append(path)
                yield staticfiles_storage.url(path)
        else:
            for package in self.packages:
                for path in self.packager.compile(package.paths):
                    self.package_files.append(path)
                    yield staticfiles_storage.url(path)

        for finder in self.finders:
            for path, storage in finder.list(ignore_patterns):
                # Prefix the relative path if the source storage contains it
                if getattr(storage, 'prefix', None):
                    prefixed_path = os.path.join(storage.prefix, path)
                else:
                    prefixed_path = path

                # Dont add any doubles
                if prefixed_path not in self.package_files:
                    self.package_files.append(prefixed_path)
                    yield staticfiles_storage.url(prefixed_path)

########NEW FILE########
__FILENAME__ = middleware
from __future__ import unicode_literals

from django.core.exceptions import MiddlewareNotUsed
from django.utils.encoding import DjangoUnicodeDecodeError
from django.utils.html import strip_spaces_between_tags as minify_html

from pipeline.conf import settings


class MinifyHTMLMiddleware(object):
    def __init__(self):
        if not settings.PIPELINE_ENABLED:
            raise MiddlewareNotUsed

    def process_response(self, request, response):
        if response.has_header('Content-Type') and 'text/html' in response['Content-Type']:
            try:
                response.content = minify_html(response.content.strip())
                response['Content-Length'] = str(len(response.content))
            except DjangoUnicodeDecodeError:
                pass
        return response

########NEW FILE########
__FILENAME__ = models

########NEW FILE########
__FILENAME__ = packager
from __future__ import unicode_literals

from django.contrib.staticfiles.finders import find
from django.core.files.base import ContentFile
from django.utils.encoding import smart_str

from pipeline.compilers import Compiler
from pipeline.compressors import Compressor
from pipeline.conf import settings
from pipeline.exceptions import PackageNotFound
from pipeline.glob import glob
from pipeline.signals import css_compressed, js_compressed
from pipeline.storage import default_storage


class Package(object):
    def __init__(self, config):
        self.config = config
        self._sources = []

    @property
    def sources(self):
        if not self._sources:
            paths = []
            for pattern in self.config.get('source_filenames', []):
                for path in glob(pattern):
                    if not path in paths and find(path):
                        paths.append(str(path))
            self._sources = paths
        return self._sources

    @property
    def paths(self):
        return [path for path in self.sources
                if not path.endswith(settings.PIPELINE_TEMPLATE_EXT)]

    @property
    def templates(self):
        return [path for path in self.sources
                if path.endswith(settings.PIPELINE_TEMPLATE_EXT)]

    @property
    def output_filename(self):
        return self.config.get('output_filename')

    @property
    def extra_context(self):
        return self.config.get('extra_context', {})

    @property
    def template_name(self):
        return self.config.get('template_name')

    @property
    def variant(self):
        return self.config.get('variant')

    @property
    def manifest(self):
        return self.config.get('manifest', True)


class Packager(object):
    def __init__(self, storage=default_storage, verbose=False, css_packages=None, js_packages=None):
        self.storage = storage
        self.verbose = verbose
        self.compressor = Compressor(storage=storage, verbose=verbose)
        self.compiler = Compiler(verbose=verbose)
        if css_packages is None:
            css_packages = settings.PIPELINE_CSS
        if js_packages is None:
            js_packages = settings.PIPELINE_JS
        self.packages = {
            'css': self.create_packages(css_packages),
            'js': self.create_packages(js_packages),
        }

    def package_for(self, kind, package_name):
        try:
            return self.packages[kind][package_name]
        except KeyError:
            raise PackageNotFound(
                "No corresponding package for %s package name : %s" % (
                    kind, package_name
                )
            )

    def individual_url(self, filename):
        return self.storage.url(filename)

    def pack_stylesheets(self, package, **kwargs):
        return self.pack(package, self.compressor.compress_css, css_compressed,
                         output_filename=package.output_filename,
                         variant=package.variant, **kwargs)

    def compile(self, paths, force=False):
        return self.compiler.compile(paths, force=force)

    def pack(self, package, compress, signal, **kwargs):
        output_filename = package.output_filename
        if self.verbose:
            print("Saving: %s" % output_filename)
        paths = self.compile(package.paths, force=True)
        content = compress(paths, **kwargs)
        self.save_file(output_filename, content)
        signal.send(sender=self, package=package, **kwargs)
        return output_filename

    def pack_javascripts(self, package, **kwargs):
        return self.pack(package, self.compressor.compress_js, js_compressed, templates=package.templates, **kwargs)

    def pack_templates(self, package):
        return self.compressor.compile_templates(package.templates)

    def save_file(self, path, content):
        return self.storage.save(path, ContentFile(smart_str(content)))

    def create_packages(self, config):
        packages = {}
        if not config:
            return packages
        for name in config:
            packages[name] = Package(config[name])
        return packages

########NEW FILE########
__FILENAME__ = signals
from __future__ import unicode_literals

from django.dispatch import Signal


css_compressed = Signal(providing_args=["package"])
js_compressed = Signal(providing_args=["package"])

########NEW FILE########
__FILENAME__ = storage
from __future__ import unicode_literals

import gzip

from io import BytesIO

from django.contrib.staticfiles import finders
from django.contrib.staticfiles.storage import CachedStaticFilesStorage, StaticFilesStorage
from django.contrib.staticfiles.utils import matches_patterns

from django.core.exceptions import ImproperlyConfigured
from django.core.files.base import File
from django.core.files.storage import get_storage_class
from django.utils.functional import LazyObject

from pipeline.conf import settings


class PipelineMixin(object):
    packing = True

    def post_process(self, paths, dry_run=False, **options):
        if dry_run:
            return

        from pipeline.packager import Packager
        packager = Packager(storage=self)
        for package_name in packager.packages['css']:
            package = packager.package_for('css', package_name)
            output_file = package.output_filename
            if self.packing:
                packager.pack_stylesheets(package)
            paths[output_file] = (self, output_file)
            yield output_file, output_file, True
        for package_name in packager.packages['js']:
            package = packager.package_for('js', package_name)
            output_file = package.output_filename
            if self.packing:
                packager.pack_javascripts(package)
            paths[output_file] = (self, output_file)
            yield output_file, output_file, True

        super_class = super(PipelineMixin, self)
        if hasattr(super_class, 'post_process'):
            for name, hashed_name, processed in super_class.post_process(paths.copy(), dry_run, **options):
                yield name, hashed_name, processed

    def get_available_name(self, name):
        if self.exists(name):
            self.delete(name)
        return name


class GZIPMixin(object):
    gzip_patterns = ("*.css", "*.js")

    def _compress(self, original_file):
        content = BytesIO()
        gzip_file = gzip.GzipFile(mode='wb', fileobj=content)
        gzip_file.write(original_file.read())
        gzip_file.close()
        content.seek(0)
        return File(content)

    def post_process(self, paths, dry_run=False, **options):
        super_class = super(GZIPMixin, self)
        if hasattr(super_class, 'post_process'):
            for name, hashed_name, processed in super_class.post_process(paths.copy(), dry_run, **options):
                if hashed_name != name:
                    paths[hashed_name] = (self, hashed_name)
                yield name, hashed_name, processed

        if dry_run:
            return

        for path in paths:
            if path:
                if not matches_patterns(path, self.gzip_patterns):
                    continue
                original_file = self.open(path)
                gzipped_path = "{0}.gz".format(path)
                if self.exists(gzipped_path):
                    self.delete(gzipped_path)
                gzipped_file = self._compress(original_file)
                gzipped_path = self.save(gzipped_path, gzipped_file)
                yield gzipped_path, gzipped_path, True


class NonPackagingMixin(object):
    packing = False


class PipelineStorage(PipelineMixin, StaticFilesStorage):
    pass


class NonPackagingPipelineStorage(NonPackagingMixin, PipelineStorage):
    pass


class PipelineCachedStorage(PipelineMixin, CachedStaticFilesStorage):
    pass


class NonPackagingPipelineCachedStorage(NonPackagingMixin, PipelineCachedStorage):
    pass


class BaseFinderStorage(PipelineStorage):
    finders = None

    def __init__(self, finders=None, *args, **kwargs):
        if finders is not None:
            self.finders = finders
        if self.finders is None:
            raise ImproperlyConfigured("The storage %r doesn't have a finders class assigned." % self.__class__)
        super(BaseFinderStorage, self).__init__(*args, **kwargs)

    def path(self, name):
        path = self.finders.find(name)
        if not path:
            path = super(BaseFinderStorage, self).path(name)
        return path

    def exists(self, name):
        exists = self.finders.find(name) is not None
        if not exists:
            return super(BaseFinderStorage, self).exists(name)
        return exists

    def listdir(self, path):
        directories, files = [], []
        for finder in self.finders.get_finders():
            try:
                storages = finder.storages.values()
            except AttributeError:
                continue
            else:
                for storage in storages:
                    try:
                        new_directories, new_files = storage.listdir(path)
                    except OSError:
                        pass
                    else:
                        directories.extend(new_directories)
                        files.extend(new_files)
        return directories, files

    def find_storage(self, name):
        for finder in self.finders.get_finders():
            path = finder.find(name)
            if path:
                for storage in finder.storages.values():
                    if path.startswith(storage.location):
                        return path, storage

        raise ValueError("The file '%s' could not be found with %r." % (name, self))

    def _open(self, name, mode="rb"):
        name, storage = self.find_storage(name)
        return storage._open(name, mode)

    def _save(self, name, content):
        name, storage = self.find_storage(name)
        # Ensure we overwrite file, since we have no control on external storage
        if storage.exists(name):
            storage.delete(name)
        return storage._save(name, content)


class PipelineFinderStorage(BaseFinderStorage):
    finders = finders


class DefaultStorage(LazyObject):
    def _setup(self):
        self._wrapped = get_storage_class(settings.PIPELINE_STORAGE)()


default_storage = DefaultStorage()

########NEW FILE########
__FILENAME__ = compressed
from __future__ import unicode_literals

from django.contrib.staticfiles.storage import staticfiles_storage

from django import template
from django.template.loader import render_to_string
from django.utils.safestring import mark_safe

from pipeline.conf import settings
from pipeline.packager import Packager, PackageNotFound
from pipeline.utils import guess_type

register = template.Library()


class CompressedMixin(object):
    def package_for(self, package_name, package_type):
        package = {
            'js': getattr(settings, 'PIPELINE_JS', {}).get(package_name, {}),
            'css': getattr(settings, 'PIPELINE_CSS', {}).get(package_name, {}),
        }[package_type]

        if package:
            package = {package_name: package}

        packager = {
            'js': Packager(css_packages={}, js_packages=package),
            'css': Packager(css_packages=package, js_packages={}),
        }[package_type]

        return packager.package_for(package_type, package_name)

    def render_compressed(self, package, package_type):
        if settings.PIPELINE_ENABLED:
            method = getattr(self, "render_{0}".format(package_type))
            return method(package, package.output_filename)
        else:
            packager = Packager()
            method = getattr(self, "render_individual_{0}".format(package_type))
            paths = packager.compile(package.paths)
            templates = packager.pack_templates(package)
            return method(package, paths, templates=templates)


class CompressedCSSNode(CompressedMixin, template.Node):
    def __init__(self, name):
        self.name = name

    def render(self, context):
        package_name = template.Variable(self.name).resolve(context)
        try:
            package = self.package_for(package_name, 'css')
        except PackageNotFound:
            return ''  # fail silently, do not return anything if an invalid group is specified
        return self.render_compressed(package, 'css')

    def render_css(self, package, path):
        template_name = package.template_name or "pipeline/css.html"
        context = package.extra_context
        context.update({
            'type': guess_type(path, 'text/css'),
            'url': mark_safe(staticfiles_storage.url(path))
        })
        return render_to_string(template_name, context)

    def render_individual_css(self, package, paths, **kwargs):
        tags = [self.render_css(package, path) for path in paths]
        return '\n'.join(tags)


class CompressedJSNode(CompressedMixin, template.Node):
    def __init__(self, name):
        self.name = name

    def render(self, context):
        package_name = template.Variable(self.name).resolve(context)
        try:
            package = self.package_for(package_name, 'js')
        except PackageNotFound:
            return ''  # fail silently, do not return anything if an invalid group is specified
        return self.render_compressed(package, 'js')

    def render_js(self, package, path):
        template_name = package.template_name or "pipeline/js.html"
        context = package.extra_context
        context.update({
            'type': guess_type(path, 'text/javascript'),
            'url': mark_safe(staticfiles_storage.url(path))
        })
        return render_to_string(template_name, context)

    def render_inline(self, package, js):
        context = package.extra_context
        context.update({
            'source': js
        })
        return render_to_string("pipeline/inline_js.html", context)

    def render_individual_js(self, package, paths, templates=None):
        tags = [self.render_js(package, js) for js in paths]
        if templates:
            tags.append(self.render_inline(package, templates))
        return '\n'.join(tags)


@register.tag
def compressed_css(parser, token):
    try:
        tag_name, name = token.split_contents()
    except ValueError:
        raise template.TemplateSyntaxError('%r requires exactly one argument: the name of a group in the PIPELINE_CSS setting' % token.split_contents()[0])
    return CompressedCSSNode(name)


@register.tag
def compressed_js(parser, token):
    try:
        tag_name, name = token.split_contents()
    except ValueError:
        raise template.TemplateSyntaxError('%r requires exactly one argument: the name of a group in the PIPELINE_JS setting' % token.split_contents()[0])
    return CompressedJSNode(name)

########NEW FILE########
__FILENAME__ = utils
from __future__ import unicode_literals

import mimetypes
import posixpath

try:
    from urllib.parse import quote
except ImportError:
    from urllib import quote

from django.utils import importlib
from django.utils.encoding import smart_str

from pipeline.conf import settings


def to_class(class_str):
    if not class_str:
        return None

    module_bits = class_str.split('.')
    module_path, class_name = '.'.join(module_bits[:-1]), module_bits[-1]
    module = importlib.import_module(module_path)
    return getattr(module, class_name, None)


def filepath_to_uri(path):
    if path is None:
        return path
    return quote(smart_str(path).replace("\\", "/"), safe="/~!*()'#?")


def guess_type(path, default=None):
    for type, ext in settings.PIPELINE_MIMETYPES:
        mimetypes.add_type(type, ext)
    mimetype, _ = mimetypes.guess_type(path)
    if not mimetype:
        return default
    return smart_str(mimetype)


def relpath(path, start=posixpath.curdir):
    """Return a relative version of a path"""
    if not path:
        raise ValueError("no path specified")

    start_list = posixpath.abspath(start).split(posixpath.sep)
    path_list = posixpath.abspath(path).split(posixpath.sep)

    # Work out how much of the filepath is shared by start and path.
    i = len(posixpath.commonprefix([start_list, path_list]))

    rel_list = [posixpath.pardir] * (len(start_list) - i) + path_list[i:]
    if not rel_list:
        return posixpath.curdir
    return posixpath.join(*rel_list)

########NEW FILE########
__FILENAME__ = models

########NEW FILE########
__FILENAME__ = settings
import os
local_path = lambda path: os.path.join(os.path.dirname(__file__), path)

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'TEST_NAME': ':memory:'
    }
}

SITE_ID = 1

INSTALLED_APPS = [
    'django.contrib.contenttypes',
    'django.contrib.sites',
    'django.contrib.sessions',
    'django.contrib.staticfiles',
    'django.contrib.auth',
    'django.contrib.admin',
    'pipeline',
    'tests',
    'tests.tests'
]

ROOT_URLCONF = 'tests.urls'

MEDIA_URL = '/media/'

MEDIA_ROOT = local_path('media')

STATICFILES_STORAGE = 'pipeline.storage.PipelineStorage'
STATIC_ROOT = local_path('static/')
STATIC_URL = '/static/'
STATICFILES_DIRS = (
    ('pipeline', local_path('assets/')),
    local_path('assets2/'),
)
STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder'
)

SECRET_KEY = "django-pipeline"

TEMPLATE_DIRS = (
    local_path('templates'),
)

PIPELINE_CSS = {
    'screen': {
        'source_filenames': (
            'pipeline/css/first.css',
            'pipeline/css/second.css',
            'pipeline/css/urls.css'
        ),
        'output_filename': 'screen.css'
    }
}
PIPELINE_JS = {
    'scripts': {
        'source_filenames': (
            'pipeline/js/first.js',
            'pipeline/js/second.js',
            'pipeline/js/application.js',
            'pipeline/templates/**/*.jst'
        ),
        'output_filename': 'scripts.js'
    },
    'scripts_async': {
        'source_filenames': (
            'pipeline/js/first.js',
            'pipeline/js/second.js',
            'pipeline/js/application.js',
            'pipeline/templates/**/*.jst'
        ),
        'output_filename': 'scripts_async.js',
        'extra_context': {
            'async': True,
        }
    },
    'scripts_defer': {
        'source_filenames': (
            'pipeline/js/first.js',
            'pipeline/js/second.js',
            'pipeline/js/application.js',
            'pipeline/templates/**/*.jst'
        ),
        'output_filename': 'scripts_defer.js',
        'extra_context': {
            'defer': True,
        }
    },
    'scripts_async_defer': {
        'source_filenames': (
            'pipeline/js/first.js',
            'pipeline/js/second.js',
            'pipeline/js/application.js',
            'pipeline/templates/**/*.jst'
        ),
        'output_filename': 'scripts_async_defer.js',
        'extra_context': {
            'async': True,
            'defer': True,
        }
    }
}

########NEW FILE########
__FILENAME__ = test_compiler
from __future__ import unicode_literals

from django.test import TestCase

from pipeline.conf import settings
from pipeline.compilers import Compiler, CompilerBase

from tests.utils import _


class DummyCompiler(CompilerBase):
    output_extension = 'js'

    def match_file(self, path):
        return path.endswith('.coffee')

    def compile_file(self, infile, outfile, outdated=False, force=False):
        return


class CompilerTest(TestCase):
    def setUp(self):
        self.compiler = Compiler()
        self.old_compilers = settings.PIPELINE_COMPILERS
        settings.PIPELINE_COMPILERS = ['tests.tests.test_compiler.DummyCompiler']

    def test_output_path(self):
        output_path = self.compiler.output_path("js/helpers.coffee", "js")
        self.assertEqual(output_path, "js/helpers.js")

    def test_compilers_class(self):
        compilers_class = self.compiler.compilers
        self.assertEqual(compilers_class[0], DummyCompiler)

    def test_compile(self):
        paths = self.compiler.compile([
            _('pipeline/js/dummy.coffee'),
            _('pipeline/js/application.js'),
        ])
        self.assertEqual([_('pipeline/js/dummy.js'), _('pipeline/js/application.js')], list(paths))

    def tearDown(self):
        settings.PIPELINE_COMPILERS = self.old_compilers

########NEW FILE########
__FILENAME__ = test_compressor
# -*- coding: utf-8 -*-
from __future__ import unicode_literals

import base64
import os

try:
    from mock import patch
except ImportError:
    from unittest.mock import patch  # noqa

from django.test import TestCase
from django.test.utils import override_settings

from pipeline.compressors import Compressor, TEMPLATE_FUNC, \
    SubProcessCompressor
from pipeline.compressors.yuglify import YuglifyCompressor

from tests.utils import _


class CompressorTest(TestCase):
    def setUp(self):
        self.maxDiff = None
        self.compressor = Compressor()

    def test_js_compressor_class(self):
        self.assertEqual(self.compressor.js_compressor, YuglifyCompressor)

    def test_css_compressor_class(self):
        self.assertEqual(self.compressor.css_compressor, YuglifyCompressor)

    def test_concatenate_and_rewrite(self):
        css = self.compressor.concatenate_and_rewrite([
            _('pipeline/css/first.css'),
            _('pipeline/css/second.css')
        ], 'css/screen.css')
        self.assertEqual(""".concat {\n  display: none;\n}\n\n.concatenate {\n  display: block;\n}\n""", css)

    def test_concatenate(self):
        js = self.compressor.concatenate([
            _('pipeline/js/first.js'),
            _('pipeline/js/second.js')
        ])
        self.assertEqual("""function concat() {\n  console.log(arguments);\n}\n\nfunction cat() {\n  console.log("hello world");\n}\n""", js)

    @patch.object(base64, 'b64encode')
    def test_encoded_content(self, mock):
        self.compressor.asset_contents.clear()
        self.compressor.encoded_content(_('pipeline/images/arrow.png'))
        self.assertTrue(mock.called)
        mock.reset_mock()
        self.compressor.encoded_content(_('pipeline/images/arrow.png'))
        self.assertFalse(mock.called)

    def test_encoded_content_output(self):
        self.compressor.asset_contents.clear()
        encoded = self.compressor.encoded_content(_('pipeline/images/arrow.png'))
        expected = ('iVBORw0KGgoAAAANSUhEUgAAAAkAAAAGCAYAAAARx7TFAAAAMk'
                    'lEQVR42oXKwQkAMAxC0Q7rEk5voSEepCHC9/SOpLV3JPULgArV'
                    'RtDIMEEiQ4NECRNdciCfK3K3wvEAAAAASUVORK5CYII=')
        self.assertEqual(encoded, expected)

    def test_relative_path(self):
        relative_path = self.compressor.relative_path("images/sprite.png", 'css/screen.css')
        self.assertEqual(relative_path, '../images/sprite.png')

    def test_base_path(self):
        base_path = self.compressor.base_path([
            _('js/templates/form.jst'), _('js/templates/field.jst')
        ])
        self.assertEqual(base_path, _('js/templates'))

    def test_absolute_path(self):
        absolute_path = self.compressor.absolute_path('../../images/sprite.png',
            'css/plugins/')
        self.assertEqual(absolute_path, 'images/sprite.png')
        absolute_path = self.compressor.absolute_path('/images/sprite.png',
            'css/plugins/')
        self.assertEqual(absolute_path, '/images/sprite.png')

    def test_template_name(self):
        name = self.compressor.template_name('templates/photo/detail.jst',
            'templates/')
        self.assertEqual(name, 'photo_detail')
        name = self.compressor.template_name('templates/photo_edit.jst', '')
        self.assertEqual(name, 'photo_edit')
        name = self.compressor.template_name('templates\photo\detail.jst',
            'templates\\')
        self.assertEqual(name, 'photo_detail')

    @override_settings(PIPELINE_TEMPLATE_SEPARATOR='/')
    def test_template_name_separator(self):
        name = self.compressor.template_name('templates/photo/detail.jst',
            'templates/')
        self.assertEqual(name, 'photo/detail')
        name = self.compressor.template_name('templates/photo_edit.jst', '')
        self.assertEqual(name, 'photo_edit')
        name = self.compressor.template_name('templates\photo\detail.jst',
            'templates\\')
        self.assertEqual(name, 'photo/detail')

    def test_compile_templates(self):
        templates = self.compressor.compile_templates([_('pipeline/templates/photo/list.jst')])
        self.assertEqual(templates, """window.JST = window.JST || {};\n%s\nwindow.JST[\'list\'] = template(\'<div class="photo">\\n <img src="<%%= src %%>" />\\n <div class="caption">\\n  <%%= caption %%>\\n </div>\\n</div>\');\n""" % TEMPLATE_FUNC)
        templates = self.compressor.compile_templates([
            _('pipeline/templates/video/detail.jst'),
            _('pipeline/templates/photo/detail.jst')
        ])
        self.assertEqual(templates, """window.JST = window.JST || {};\n%s\nwindow.JST[\'video_detail\'] = template(\'<div class="video">\\n <video src="<%%= src %%>" />\\n <div class="caption">\\n  <%%= description %%>\\n </div>\\n</div>\');\nwindow.JST[\'photo_detail\'] = template(\'<div class="photo">\\n <img src="<%%= src %%>" />\\n <div class="caption">\\n  <%%= caption %%> by <%%= author %%>\\n </div>\\n</div>\');\n""" % TEMPLATE_FUNC)

    def test_embeddable(self):
        self.assertFalse(self.compressor.embeddable(_('pipeline/images/sprite.png'), None))
        self.assertFalse(self.compressor.embeddable(_('pipeline/images/arrow.png'), 'datauri'))
        self.assertTrue(self.compressor.embeddable(_('pipeline/images/embed/arrow.png'), 'datauri'))
        self.assertFalse(self.compressor.embeddable(_('pipeline/images/arrow.dat'), 'datauri'))

    def test_construct_asset_path(self):
        asset_path = self.compressor.construct_asset_path("../../images/sprite.png",
            "css/plugins/gallery.css", "css/gallery.css")
        self.assertEqual(asset_path, "../images/sprite.png")
        asset_path = self.compressor.construct_asset_path("/images/sprite.png",
            "css/plugins/gallery.css", "css/gallery.css")
        self.assertEqual(asset_path, "/images/sprite.png")

    def test_url_rewrite(self):
        output = self.compressor.concatenate_and_rewrite([
            _('pipeline/css/urls.css'),
        ], 'css/screen.css')
        self.assertEqual("""@font-face {
  font-family: 'Pipeline';
  src: url(../pipeline/fonts/pipeline.eot);
  src: url(../pipeline/fonts/pipeline.eot?#iefix) format('embedded-opentype');
  src: local('☺'), url(../pipeline/fonts/pipeline.woff) format('woff'), url(../pipeline/fonts/pipeline.ttf) format('truetype'), url(../pipeline/fonts/pipeline.svg#IyfZbseF) format('svg');
  font-weight: normal;
  font-style: normal;
}
.relative-url {
  background-image: url(../pipeline/images/sprite-buttons.png);
}
.relative-url-querystring {
  background-image: url(../pipeline/images/sprite-buttons.png?v=1.0#foo=bar);
}
.absolute-url {
  background-image: url(/images/sprite-buttons.png);
}
.absolute-full-url {
  background-image: url(http://localhost/images/sprite-buttons.png);
}
.no-protocol-url {
  background-image: url(//images/sprite-buttons.png);
}
""", output)

    def test_url_rewrite_data_uri(self):
        output = self.compressor.concatenate_and_rewrite([
            _('pipeline/css/nested/nested.css'),
        ], 'pipeline/screen.css')
        self.assertEqual(""".data-url {
  background-image: url(data:image/svg+xml;charset=US-ASCII,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22iso-8859-1%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20%20width%3D%2212px%22%20height%3D%2214px%22%20viewBox%3D%220%200%2012%2014%22%20style%3D%22enable-background%3Anew%200%200%2012%2014%3B%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20d%3D%22M11%2C6V5c0-2.762-2.239-5-5-5S1%2C2.238%2C1%2C5v1H0v8h12V6H11z%20M6.5%2C9.847V12h-1V9.847C5.207%2C9.673%2C5%2C9.366%2C5%2C9%20c0-0.553%2C0.448-1%2C1-1s1%2C0.447%2C1%2C1C7%2C9.366%2C6.793%2C9.673%2C6.5%2C9.847z%20M9%2C6H3V5c0-1.657%2C1.343-3%2C3-3s3%2C1.343%2C3%2C3V6z%22%2F%3E%3Cg%3E%3C%2Fg%3E%3Cg%3E%3C%2Fg%3E%3Cg%3E%3C%2Fg%3E%3Cg%3E%3C%2Fg%3E%3Cg%3E%3C%2Fg%3E%3Cg%3E%3C%2Fg%3E%3Cg%3E%3C%2Fg%3E%3Cg%3E%3C%2Fg%3E%3Cg%3E%3C%2Fg%3E%3Cg%3E%3C%2Fg%3E%3Cg%3E%3C%2Fg%3E%3Cg%3E%3C%2Fg%3E%3Cg%3E%3C%2Fg%3E%3Cg%3E%3C%2Fg%3E%3Cg%3E%3C%2Fg%3E%3C%2Fsvg%3E);
}
""", output)

    def test_compressor_subprocess_unicode(self):
        tests_path = os.path.dirname(os.path.dirname(__file__))
        output = SubProcessCompressor(False).execute_command(
            '/usr/bin/env cat',
            open(tests_path + '/assets/css/unicode.css').read())
        self.assertEqual(""".some_class {
  // Some unicode
  content: "áéíóú";
}
""", output)

########NEW FILE########
__FILENAME__ = test_glob
from __future__ import unicode_literals

import os
import shutil

from django.core.files.base import ContentFile
from django.core.files.storage import FileSystemStorage
from django.test import TestCase

from pipeline import glob

local_path = lambda path: os.path.join(os.path.dirname(__file__), path)


class GlobTest(TestCase):
    def normpath(self, *parts):
        return os.path.normpath(os.path.join(*parts))

    def mktemp(self, *parts):
        filename = self.normpath(*parts)
        base, file = os.path.split(filename)
        base = os.path.join(self.storage.location, base)
        if not os.path.exists(base):
            os.makedirs(base)
        self.storage.save(filename, ContentFile(""))

    def assertSequenceEqual(self, l1, l2):
        self.assertEqual(set(l1), set(l2))

    def setUp(self):
        self.storage = FileSystemStorage(local_path('glob_dir'))
        self.old_storage = glob.default_storage
        glob.default_storage = self.storage
        self.mktemp('a', 'D')
        self.mktemp('aab', 'F')
        self.mktemp('aaa', 'zzzF')
        self.mktemp('ZZZ')
        self.mktemp('a', 'bcd', 'EF')
        self.mktemp('a', 'bcd', 'efg', 'ha')

    def glob(self, *parts):
        if len(parts) == 1:
            pattern = parts[0]
        else:
            pattern = os.path.join(*parts)
        return glob.glob(pattern)

    def tearDown(self):
        shutil.rmtree(self.storage.location)
        glob.default_storage = self.old_storage

    def test_glob_literal(self):
        self.assertSequenceEqual(self.glob('a'),
            [self.normpath('a')])
        self.assertSequenceEqual(self.glob('a', 'D'),
            [self.normpath('a', 'D')])
        self.assertSequenceEqual(self.glob('aab'),
            [self.normpath('aab')])
        self.assertSequenceEqual(self.glob('zymurgy'), [])

    def test_glob_one_directory(self):
        self.assertSequenceEqual(self.glob('a*'),
            map(self.normpath, ['a', 'aab', 'aaa']))
        self.assertSequenceEqual(self.glob('*a'),
            map(self.normpath, ['a', 'aaa']))
        self.assertSequenceEqual(self.glob('aa?'),
            map(self.normpath, ['aaa', 'aab']))
        self.assertSequenceEqual(self.glob('aa[ab]'),
            map(self.normpath, ['aaa', 'aab']))
        self.assertSequenceEqual(self.glob('*q'), [])

    def test_glob_nested_directory(self):
        if os.path.normcase("abCD") == "abCD":
            # case-sensitive filesystem
            self.assertSequenceEqual(self.glob('a', 'bcd', 'E*'),
                [self.normpath('a', 'bcd', 'EF')])
        else:
            # case insensitive filesystem
            self.assertSequenceEqual(self.glob('a', 'bcd', 'E*'), [
                self.normpath('a', 'bcd', 'EF'),
                self.normpath('a', 'bcd', 'efg')
            ])
        self.assertSequenceEqual(self.glob('a', 'bcd', '*g'),
            [self.normpath('a', 'bcd', 'efg')])

    def test_glob_directory_names(self):
        self.assertSequenceEqual(self.glob('*', 'D'),
            [self.normpath('a', 'D')])
        self.assertSequenceEqual(self.glob('*', '*a'), [])
        self.assertSequenceEqual(self.glob('a', '*', '*', '*a'),
           [self.normpath('a', 'bcd', 'efg', 'ha')])
        self.assertSequenceEqual(self.glob('?a?', '*F'),
            map(self.normpath, [os.path.join('aaa', 'zzzF'),
            os.path.join('aab', 'F')]))

    def test_glob_directory_with_trailing_slash(self):
        # We are verifying that when there is wildcard pattern which
        # ends with os.sep doesn't blow up.
        paths = glob.glob('*' + os.sep)
        self.assertEqual(len(paths), 4)
        self.assertTrue(all([os.sep in path for path in paths]))

########NEW FILE########
__FILENAME__ = test_middleware
# -*- coding: utf-8 -*-
from __future__ import unicode_literals

from django.test import TestCase
from django.conf import settings
from django.core.urlresolvers import reverse

from tests.utils import pipeline_settings


class MiddlewareTest(TestCase):
    def test_middleware_off(self):
        response = self.client.get(reverse('admin:index'))

        self.assertIn('text/html', response['Content-Type'])
        # Should not come if not compressed
        self.assertNotIn('Content-Length', response)

    def test_middleware_on(self):
        CUSTOM_MIDDLEWARE = (
            'django.middleware.gzip.GZipMiddleware',
            'pipeline.middleware.MinifyHTMLMiddleware',
        ) + settings.MIDDLEWARE_CLASSES

        with self.settings(MIDDLEWARE_CLASSES=CUSTOM_MIDDLEWARE):
            response = self.client.get(reverse('admin:index'))

            self.assertIn('text/html', response['Content-Type'])

            length = str(len(response.content))
            self.assertEqual(length, response['Content-Length'])

    def test_middleware_pipeline_enabled(self):
        CUSTOM_MIDDLEWARE = (
            'django.middleware.gzip.GZipMiddleware',
            'pipeline.middleware.MinifyHTMLMiddleware',
        ) + settings.MIDDLEWARE_CLASSES

        with self.settings(MIDDLEWARE_CLASSES=CUSTOM_MIDDLEWARE):
            with pipeline_settings(PIPELINE_ENABLED=True):
                response = self.client.get(reverse('admin:index'))
                self.assertNotIn(b'    ', response.content)

    def test_middleware_pipeline_disabled(self):
        CUSTOM_MIDDLEWARE = (
            'django.middleware.gzip.GZipMiddleware',
            'pipeline.middleware.MinifyHTMLMiddleware',
        ) + settings.MIDDLEWARE_CLASSES

        with self.settings(MIDDLEWARE_CLASSES=CUSTOM_MIDDLEWARE):
            with pipeline_settings(PIPELINE_ENABLED=False):
                response = self.client.get(reverse('admin:index'))
                self.assertIn(b'    ', response.content)

########NEW FILE########
__FILENAME__ = test_packager
from __future__ import unicode_literals

from django.test import TestCase

from pipeline.packager import Packager, PackageNotFound

from tests.utils import _


class PackagerTest(TestCase):
    def test_package_for(self):
        packager = Packager()
        packager.packages['js'] = packager.create_packages({
            'application': {
                'source_filenames': (
                    _('pipeline/js/application.js'),
                ),
                'output_filename': 'application.js'
            }
        })
        try:
            packager.package_for('js', 'application')
        except PackageNotFound:
            self.fail()
        try:
            packager.package_for('js', 'broken')
            self.fail()
        except PackageNotFound:
            pass

    def test_templates(self):
        packager = Packager()
        packages = packager.create_packages({
            'templates': {
                'source_filenames': (
                    _('pipeline/templates/photo/list.jst'),
                ),
                'output_filename': 'templates.js',
            }
        })
        self.assertEqual(packages['templates'].templates, [_('pipeline/templates/photo/list.jst')])

########NEW FILE########
__FILENAME__ = test_storage
from __future__ import unicode_literals

from django.test import TestCase

from pipeline.storage import PipelineStorage, PipelineFinderStorage

from tests.utils import pipeline_settings


class StorageTest(TestCase):
    def test_post_process_dry_run(self):
        with pipeline_settings(PIPELINE_JS_COMPRESSOR=None, PIPELINE_CSS_COMPRESSOR=None):
            processed_files = PipelineStorage().post_process({}, True)
            self.assertEqual(list(processed_files), [])

    def test_post_process(self):
        storage = PipelineStorage()
        with pipeline_settings(PIPELINE_JS_COMPRESSOR=None, PIPELINE_CSS_COMPRESSOR=None):
            processed_files = storage.post_process({})
            self.assertTrue(('screen.css', 'screen.css', True) in processed_files)
            self.assertTrue(('scripts.js', 'scripts.js', True) in processed_files)

    def test_find_storage(self):
        try:
            storage = PipelineFinderStorage()
            storage.find_storage('app.css')
        except ValueError:
            self.fail()

########NEW FILE########
__FILENAME__ = test_template
# -*- coding: utf-8 -*-
from __future__ import unicode_literals

from jinja2 import Environment, PackageLoader

from django.template import Template, Context
from django.test import TestCase

from pipeline.jinja2.ext import PipelineExtension

from tests.utils import pipeline_settings


class JinjaTest(TestCase):
    def setUp(self):
        self.env = Environment(extensions=[PipelineExtension], loader=
            PackageLoader('pipeline', 'templates'))

    def test_no_package(self):
        template = self.env.from_string(u"""{% compressed_css "unknow" %}""")
        self.assertEqual(u'', template.render())
        template = self.env.from_string(u"""{% compressed_js "unknow" %}""")
        self.assertEqual(u'', template.render())

    def test_package_css(self):
        template = self.env.from_string(u"""{% compressed_css "screen" %}""")
        self.assertEqual(u'<link href="/static/screen.css" rel="stylesheet" type="text/css" />', template.render())

    def test_package_css_disabled(self):
        with pipeline_settings(PIPELINE_ENABLED=False):
            template = self.env.from_string(u"""{% compressed_css "screen" %}""")
            self.assertEqual(u'''<link href="/static/pipeline/css/first.css" rel="stylesheet" type="text/css" />
<link href="/static/pipeline/css/second.css" rel="stylesheet" type="text/css" />
<link href="/static/pipeline/css/urls.css" rel="stylesheet" type="text/css" />''', template.render())

    def test_package_js(self):
        template = self.env.from_string(u"""{% compressed_js "scripts" %}""")
        self.assertEqual(u'<script type="application/javascript" src="/static/scripts.js" charset="utf-8"></script>', template.render())

    def test_package_js_async(self):
        template = self.env.from_string(u"""{% compressed_js "scripts_async" %}""")
        self.assertEqual(u'<script async type="application/javascript" src="/static/scripts_async.js" charset="utf-8"></script>', template.render())

    def test_package_js_defer(self):
        template = self.env.from_string(u"""{% compressed_js "scripts_defer" %}""")
        self.assertEqual(u'<script defer type="application/javascript" src="/static/scripts_defer.js" charset="utf-8"></script>', template.render())

    def test_package_js_async_defer(self):
        template = self.env.from_string(u"""{% compressed_js "scripts_async_defer" %}""")
        self.assertEqual(u'<script async defer type="application/javascript" src="/static/scripts_async_defer.js" charset="utf-8"></script>', template.render())


class DjangoTest(TestCase):
    def render_template(self, template):
        return Template(template).render(Context())

    def test_compressed_empty(self):
        rendered = self.render_template(u"""{% load compressed %}{% compressed_css "unknow" %}""")
        self.assertEqual(u"", rendered)

    def test_compressed_css(self):
        rendered = self.render_template(u"""{% load compressed %}{% compressed_css "screen" %}""")
        self.assertEqual(u'<link href="/static/screen.css" rel="stylesheet" type="text/css" />', rendered)

    def test_compressed_js(self):
        rendered = self.render_template(u"""{% load compressed %}{% compressed_js "scripts" %}""")
        self.assertEqual(u'<script type="application/javascript" src="/static/scripts.js" charset="utf-8"></script>', rendered)

    def test_compressed_js_async(self):
        rendered = self.render_template(u"""{% load compressed %}{% compressed_js "scripts_async" %}""")
        self.assertEqual(u'<script async type="application/javascript" src="/static/scripts_async.js" charset="utf-8"></script>', rendered)

    def test_compressed_js_defer(self):
        rendered = self.render_template(u"""{% load compressed %}{% compressed_js "scripts_defer" %}""")
        self.assertEqual(u'<script defer type="application/javascript" src="/static/scripts_defer.js" charset="utf-8"></script>', rendered)

    def test_compressed_js_async_defer(self):
        rendered = self.render_template(u"""{% load compressed %}{% compressed_js "scripts_async_defer" %}""")
        self.assertEqual(u'<script async defer type="application/javascript" src="/static/scripts_async_defer.js" charset="utf-8"></script>', rendered)

########NEW FILE########
__FILENAME__ = test_utils
# -*- coding: utf-8 -*-
from __future__ import unicode_literals

from django.test import TestCase

from pipeline.utils import guess_type


class UtilTest(TestCase):
    def test_guess_type(self):
        self.assertEqual('text/css', guess_type('stylesheet.css'))
        self.assertEqual('text/coffeescript', guess_type('application.coffee'))
        self.assertEqual('text/less', guess_type('stylesheet.less'))

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, include
from django.contrib import admin

urlpatterns = patterns(
    '',
    (r'^admin/', include(admin.site.urls)),
)

########NEW FILE########
__FILENAME__ = utils
import contextlib
import os

from pipeline.conf import settings


def _(path):
    # Make sure the path contains only the correct separator
    return path.replace('/', os.sep).replace('\\', os.sep)


@contextlib.contextmanager
def pipeline_settings(**kwargs):
    try:
        saved = {}
        for name, value in kwargs.items():
            saved[name] = getattr(settings, name)
            setattr(settings, name, value)
        yield
    finally:
        for name, value in saved.items():
            setattr(settings, name, value)

########NEW FILE########
