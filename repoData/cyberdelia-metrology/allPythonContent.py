__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# metrology documentation build configuration file, created by
# sphinx-quickstart on Thu Mar 22 11:40:53 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('..'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'metrology'
copyright = u'2012, Timoth√©e Peignier'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.10'
# The full version, including alpha/beta/rc tags.
release = '0.10.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'metrologydoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'metrology.tex', u'metrology Documentation',
   u'Timothee Peignier', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'metrology', u'metrology Documentation',
     [u'Timothee Peignier'], 1)
]

########NEW FILE########
__FILENAME__ = exceptions
class MetrologyException(Exception):
    pass


class RegistryException(MetrologyException):
    pass


class ArgumentException(MetrologyException):
    pass


class ReporterException(MetrologyException):
    pass

########NEW FILE########
__FILENAME__ = counter
from atomic import AtomicLong


class Counter(object):
    """
    A counter is like a gauge, but you can increment or decrement its value ::

      counter = Metrology.counter('pending-jobs')
      counter.increment()
      counter.decrement()
      counter.count

    """
    def __init__(self):
        self._count = AtomicLong(0)

    def increment(self, value=1):
        """Increment the counter. By default it will increment by 1.

        :param value: value to increment the counter.
        """
        self._count += value

    def decrement(self, value=1):
        """Decrement the counter. By default it will decrement by 1.

        :param value: value to decrement the counter.
        """
        self._count -= value

    def clear(self):
        self._count.value = 0

    @property
    def count(self):
        """Return the current value of the counter."""
        return self._count.value

########NEW FILE########
__FILENAME__ = derive
from atomic import AtomicLong

from metrology.instruments.meter import Meter
from metrology.stats import EWMA


class Derive(Meter):
    """
    A derive is like a meter but accepts an absolute counter as input.

      derive = Metrology.derive('network.io')
      derive.mark()
      derive.count

    """
    def __init__(self, average_class=EWMA):
        self.last = AtomicLong(0)
        super(Derive, self).__init__(average_class)

    def mark(self, value=1):
        """Record an event with the derive.

        :param value: counter value to record
        """
        last = self.last.get_and_set(value)
        if last <= value:
            value = value - last
        super(Derive, self).mark(value)

########NEW FILE########
__FILENAME__ = gauge
from __future__ import division

import math

from atomic import AtomicLong


class Gauge(object):
    """
    A gauge is an instantaneous measurement of a value ::

      class JobGauge(metrology.instruments.Gauge):
          @property
          def value(self):
              return len(queue)

      gauge = Metrology.gauge('pending-jobs', JobGauge())

    """
    @property
    def value(self):
        """"""
        raise NotImplementedError


class RatioGauge(Gauge):
    """A ratio gauge is a simple way to create a gauge which is the ratio between two numbers"""
    def numerator(self):
        raise NotImplementedError

    def denominator(self):
        raise NotImplementedError

    @property
    def value(self):
        d = self.denominator()
        if math.isnan(d) or math.isinf(d) or d == 0.0 or d == 0:
            return float('nan')
        return self.numerator() / d


class PercentGauge(RatioGauge):
    """A percent gauge is a ratio gauge where the result is normalized to a value between 0 and 100."""
    @property
    def value(self):
        value = super(PercentGauge, self).value
        return value * 100


class ToggleGauge(Gauge):
    _value = AtomicLong(1)

    @property
    def value(self):
        try:
            return self._value.value
        finally:
            self._value.value = 0

########NEW FILE########
__FILENAME__ = healthcheck


class HealthCheck(object):
    """
    A health check is a small self-test to verify that a specific component or responsibility is performing correctly ::

      class DatabaseHealthCheck(metrology.healthcheck.HealthCheck):
          def __init__(self, database):
              self.database = database

          def check(self):
              if database.ping():
                  return True
              return False

      health_check = Metrology.health_check('database', DatabaseHealthCheck(database))
      health_check.check()

    """
    def check(self):
        """Returns True if what is being checked is healthy"""
        raise NotImplementedError

########NEW FILE########
__FILENAME__ = histogram
from __future__ import division

import sys

from atomic import AtomicLong, AtomicLongArray

from metrology.stats.sample import UniformSample, ExponentiallyDecayingSample


class Histogram(object):
    """
    A histogram measures the statistical distribution of values in a stream of data. In addition to minimum, maximum, mean, it also measures median, 75th, 90th, 95th, 98th, 99th, and 99.9th percentiles ::

      histogram = Metrology.histogram('response-sizes')
      histogram.update(len(response.content))

    Metrology provides two types of histograms: uniform and exponentially decaying.
    """
    DEFAULT_SAMPLE_SIZE = 1028
    DEFAULT_ALPHA = 0.015

    def __init__(self, sample):
        self.sample = sample
        self.counter = AtomicLong(0)
        self.minimum = AtomicLong(sys.maxsize)
        self.maximum = AtomicLong(-sys.maxsize - 1)
        self.sum = AtomicLong(0)
        self.var = AtomicLongArray([-1, 0])

    def clear(self):
        self.sample.clear()
        self.counter.value = 0
        self.minimum.value = None
        self.maximum.value = None
        self.sum.value = 0
        self.var.value = [-1, 0]

    def update(self, value):
        self.counter += 1
        self.sample.update(value)
        self.max = value
        self.min = value
        self.sum += value
        self.update_variance(value)

    @property
    def snapshot(self):
        return self.sample.snapshot()

    @property
    def count(self):
        """Return number of values."""
        return self.counter.value

    def get_max(self):
        if self.counter.value > 0:
            return self.maximum.value
        return 0.0

    def set_max(self, potential_max):
        done = False
        while not done:
            current_max = self.maximum.value
            done = (current_max is not None and current_max >= potential_max) \
                or self.maximum.compare_and_swap(current_max, potential_max)

    max = property(get_max, set_max, doc="""Returns the maximun value.""")

    def get_min(self):
        if self.counter.value > 0:
            return self.minimum.value
        return 0.0

    def set_min(self, potential_min):
        done = False
        while not done:
            current_min = self.minimum.value
            done = (current_min is not None and current_min <= potential_min) \
                or self.minimum.compare_and_swap(current_min, potential_min)

    min = property(get_min, set_min, doc="""Returns the minimum value.""")

    @property
    def mean(self):
        """Returns the mean value."""
        if self.counter.value > 0:
            return self.sum.value / self.counter.value
        return 0.0

    @property
    def stddev(self):
        """Returns the standard deviation."""
        if self.counter.value > 0:
            return self.variance ** .5
        return 0.0

    @property
    def variance(self):
        """Returns variance"""
        if self.counter.value <= 1:
            return 0.0
        return self.var.value[1] / (self.counter.value - 1)

    def update_variance(self, value):
        def variance(old_values):
            if old_values[0] == -1:
                new_values = (value, 0)
            else:
                old_m = old_values[0]
                old_s = old_values[1]

                new_m = old_m + ((value - old_m) / self.counter.value)
                new_s = old_s + ((value - old_m) * (value - new_m))

                new_values = (new_m, new_s)
            return new_values
        self.var.value = variance(self.var.value)


class HistogramUniform(Histogram):
    """
    A uniform histogram produces quantiles which are valid for the entirely of the histogram's lifetime. It will return a median value, for example, which is the median of all the values the histogram has ever been updated with.

    Use a uniform histogram when you're interested in long-term measurements. Don't use one where you'd want to know if the distribution of the underlying data stream has changed recently.
    """
    def __init__(self):
        sample = UniformSample(self.DEFAULT_SAMPLE_SIZE)
        super(HistogramUniform, self).__init__(sample)


class HistogramExponentiallyDecaying(Histogram):
    """
    A exponentially decaying histogram produces quantiles which are representative of approximately the last five minutes of data.
    Unlike the uniform histogram, a biased histogram represents recent data, allowing you to know very quickly if the distribution of the data has changed.
    """
    def __init__(self):
        sample = ExponentiallyDecayingSample(self.DEFAULT_SAMPLE_SIZE, self.DEFAULT_ALPHA)
        super(HistogramExponentiallyDecaying, self).__init__(sample)

########NEW FILE########
__FILENAME__ = meter
from functools import wraps
from time import time

from atomic import AtomicLong

from metrology.stats import EWMA
from metrology.utils import now


def ticker(method):
    @wraps(method)
    def wrapper(self, *args, **kwargs):
        self._tick()
        return method(self, *args, **kwargs)
    return wrapper


class Meter(object):
    """A meter measures the rate of events over time (e.g., "requests per second").
    In addition to the mean rate, you can also track 1, 5 and 15 minutes moving averages ::

      meter = Metrology.meter('requests')
      meter.mark()
      meter.count

    """
    def __init__(self, average_class=EWMA):
        self.counter = AtomicLong(0)
        self.start_time = now()
        self.last_tick = AtomicLong(self.start_time)

        self.interval = EWMA.INTERVAL
        self.m1_rate = EWMA.m1()
        self.m5_rate = EWMA.m5()
        self.m15_rate = EWMA.m15()

    def _tick(self):
        old_tick, new_tick = self.last_tick.value, time()
        age = new_tick - old_tick
        ticks = int(age / self.interval)
        new_tick = old_tick + (ticks * self.interval)
        if ticks and self.last_tick.compare_and_swap(old_tick, new_tick):
            for _ in range(ticks):
                self.tick()

    @property
    def count(self):
        """Returns the total number of events that have been recorded."""
        return self.counter.value

    def clear(self):
        self.counter.value = 0
        self.start_time = time()

        self.m1_rate.clear()
        self.m5_rate.clear()
        self.m15_rate.clear()

    @ticker
    def mark(self, value=1):
        """Record an event with the meter. By default it will record one event.

        :param value: number of event to record
        """
        self.counter += value
        self.m1_rate.update(value)
        self.m5_rate.update(value)
        self.m15_rate.update(value)

    def tick(self):
        self.m1_rate.tick()
        self.m5_rate.tick()
        self.m15_rate.tick()

    @property
    @ticker
    def one_minute_rate(self):
        """Returns the one-minute average rate."""
        return self.m1_rate.rate

    @property
    @ticker
    def five_minute_rate(self):
        """Returns the five-minute average rate."""
        return self.m5_rate.rate

    @property
    @ticker
    def fifteen_minute_rate(self):
        """Returns the fifteen-minute average rate."""
        return self.m15_rate.rate

    @property
    def mean_rate(self):
        """Returns the mean rate of the events since the start of the process."""
        if self.counter.value == 0:
            return 0.0
        else:
            elapsed = time() - self.start_time
            return self.counter.value / elapsed

    def stop(self):
        pass

########NEW FILE########
__FILENAME__ = timer
from astrolabe.interval import Interval

from metrology.instruments.histogram import HistogramExponentiallyDecaying
from metrology.instruments.meter import Meter


class Timer(object):
    """
    A timer measures both the rate that a particular piece of code is called and the distribution of its duration ::

      timer = Metrology.timer('responses')
      with timer:
          do_something()

    """
    def __init__(self, histogram=HistogramExponentiallyDecaying):
        self.meter = Meter()
        self.histogram = histogram()

    def clear(self):
        self.meter.clear()
        self.histogram.clear()

    def update(self, duration):
        """Records the duration of an operation."""
        if duration >= 0:
            self.meter.mark()
            self.histogram.update(duration)

    @property
    def snapshot(self):
        return self.histogram.snapshot

    def __enter__(self):
        self.interval = Interval.now()
        return self

    def __exit__(self, type, value, callback):
        duration = self.interval.stop()
        self.update(duration)

    @property
    def count(self):
        """Returns the number of measurements that have been made."""
        return self.histogram.count

    @property
    def one_minute_rate(self):
        """Returns the one-minute average rate."""
        return self.meter.one_minute_rate

    @property
    def five_minute_rate(self):
        """Returns the five-minute average rate."""
        return self.meter.five_minute_rate

    @property
    def fifteen_minute_rate(self):
        """Returns the fifteen-minute average rate."""
        return self.meter.fifteen_minute_rate

    @property
    def mean_rate(self):
        """Returns the mean rate of the events since the start of the process."""
        return self.meter.mean_rate

    @property
    def min(self):
        """Returns the minimum amount of time spent in the operation."""
        return self.histogram.min

    @property
    def max(self):
        """Returns the maximum amount of time spent in the operation."""
        return self.histogram.max

    @property
    def mean(self):
        """Returns the mean time spent in the operation."""
        return self.histogram.mean

    @property
    def stddev(self):
        """Returns the standard deviation of the mean spent in the operation."""
        return self.histogram.stddev

    def stop(self):
        self.meter.stop()


class UtilizationTimer(Timer):
    """
    A specialized timer that calculates the percentage of wall-clock time that was spent ::

      utimer = Metrology.utilization_timer('responses')
      with utimer:
        do_something()

    """
    def __init__(self, histogram=HistogramExponentiallyDecaying):
        super(UtilizationTimer, self).__init__(histogram)
        self.duration_meter = Meter()

    def clear(self):
        super(UtilizationTimer, self).clear()
        self.duration_meter.clear()

    def update(self, duration):
        super(UtilizationTimer, self).update(duration)
        if duration >= 0:
            self.duration_meter.mark(duration)

    @property
    def one_minute_utilization(self):
        """Returns the one-minute average utilization as a percentage."""
        return self.duration_meter.one_minute_rate

    @property
    def five_minute_utilization(self):
        """Returns the five-minute average utilization as a percentage."""
        return self.duration_meter.five_minute_rate

    @property
    def fifteen_minute_utilization(self):
        """Returns the fifteen-minute average utilization as a percentage."""
        return self.duration_meter.fifteen_minute_rate

    @property
    def mean_utilization(self):
        """Returns the mean (average) utilization as a percentage since the process started."""
        return self.duration_meter.mean_rate

    def stop(self):
        super(UtilizationTimer, self).stop()
        self.duration_meter.stop()

########NEW FILE########
__FILENAME__ = registry
import inspect

from threading import RLock

from metrology.exceptions import RegistryException
from metrology.instruments import Counter, Derive, Meter, Timer, UtilizationTimer, HistogramUniform


class Registry(object):
    def __init__(self):
        self.lock = RLock()
        self.metrics = {}

    def clear(self):
        with self.lock:
            for metric in self.metrics.values():
                if hasattr(metric, 'stop'):
                    metric.stop()
            self.metrics.clear()

    def counter(self, name):
        return self.add_or_get(name, Counter)

    def meter(self, name):
        return self.add_or_get(name, Meter)

    def gauge(self, name, klass):
        return self.add_or_get(name, klass)

    def timer(self, name):
        return self.add_or_get(name, Timer)

    def utilization_timer(self, name):
        return self.add_or_get(name, UtilizationTimer)

    def health_check(self, name, klass):
        return self.add_or_get(name, klass)

    def histogram(self, name, klass=None):
        if not klass:
            klass = HistogramUniform
        return self.add_or_get(name, klass)

    def derive(self, name):
        return self.add_or_get(name, Derive)

    def get(self, name):
        with self.lock:
            return self.metrics[name]

    def add(self, name, metric):
        with self.lock:
            if name in self.metrics:
                raise RegistryException("{0} already present in the registry.".format(name))
            else:
                self.metrics[name] = metric

    def add_or_get(self, name, klass):
        with self.lock:
            metric = self.metrics.get(name)
            if metric is not None:
                if not isinstance(metric, klass):
                    raise RegistryException("{0} is not of type {1}.".format(name, klass))
            else:
                if inspect.isclass(klass):
                    metric = klass()
                else:
                    metric = klass
                self.metrics[name] = metric
            return metric

    def stop(self):
        self.clear()

    def __iter__(self):
        with self.lock:
            for name, metric in self.metrics.items():
                yield name, metric

registry = Registry()

########NEW FILE########
__FILENAME__ = base
from metrology.registry import registry
from metrology.utils.periodic import PeriodicTask


class Reporter(PeriodicTask):
    def __init__(self, interval=60, *args, **options):
        self.registry = options.get('registry', registry)
        super(Reporter, self).__init__(interval=interval)

    def task(self):
        self.write()

    def write(self):
        raise NotImplementedError

########NEW FILE########
__FILENAME__ = ganglia
from __future__ import absolute_import
from ganglia import GMetric

from metrology.instruments.counter import Counter
from metrology.instruments.gauge import Gauge
from metrology.instruments.histogram import Histogram
from metrology.instruments.meter import Meter
from metrology.reporter.base import Reporter


class GangliaReporter(Reporter):
    """
    A ganglia reporter that send metrics to ganglia ::

      reporter = GangliaReporter('Report Group Name', 'localhost', 8649, 'udp', interval=60)
      reporter.start()

    :param default_group_name: default group name for ganglia
    :param host: hostname of gmond
    :param port: port of gmond
    :param protocol: protocol for gmond sockets
    :param interval: time between each reporting
    """

    def __init__(self, default_group_name, host, port, protocol="udp", *args, **kwargs):
        super(GangliaReporter, self).__init__(*args, **kwargs)
        self.default_group_name = default_group_name
        self.gmetric = GMetric("{0}://{1}:{2}".format(protocol, host, port))
        self.groups = {}

    def set_group(self, metric_name, group_name):
        """Override the group name for certain metrics."""
        self.groups[metric_name] = group_name

    def write(self):
        for name, metric in self.registry:
            if isinstance(metric, Meter):
                self.send(name, 'Count', metric.count, 'int32', 'count')
                self.send(name, 'One Minute Rate', metric.one_minute_rate, 'double', 'per second')
                self.send(name, 'Five Minute Rate', metric.five_minute_rate, 'double', 'per second')
                self.send(name, 'Fifteen Minute Rate', metric.fifteen_minute_rate, 'double', 'per second')
                self.send(name, 'Mean Rate', metric.mean_rate, 'double', 'per second')
            elif isinstance(metric, Gauge):
                self.send(name, 'Value', metric.value(), 'int32', 'value')
            elif isinstance(metric, Histogram):
                self.send(name, 'Count', metric.count, 'int32', 'count')
                self.send(name, 'Mean value', metric.mean, 'double', 'mean value')
                self.send(name, 'Variance', metric.variance, 'double', 'variance')
            elif isinstance(metric, Counter):
                self.send(name, 'Count', metric.count, 'int32', 'count')

    def send(self, name, tracker, value, kind, unit):
        if tracker:
            name = "{0} - {1}".format(name, tracker)
        group = self.groups.get(name, self.default_group_name)
        self.gmetric.send(name=name, value=value, type=kind, units=unit, group=group)

########NEW FILE########
__FILENAME__ = graphite
import re
import socket
import pickle
import struct

from metrology.instruments import *  # noqa
from metrology.reporter.base import Reporter
from metrology.utils import now


class GraphiteReporter(Reporter):
    """
    A graphite reporter that send metrics to graphite ::

      reporter = GraphiteReporter('graphite.local', 2003)
      reporter.start()

    :param host: hostname of graphite
    :param port: port of graphite
    :param interval: time between each reporting
    :param prefix: metrics name prefix
    """
    def __init__(self, host, port, **options):
        self.host = host
        self.port = port

        self.prefix = options.get('prefix')
        self.pickle = options.get('pickle', False)
        self.batch_size = options.get('batch_size', 100)
        if self.batch_size <= 0:
            self.batch_size = 1
        super(GraphiteReporter, self).__init__(**options)
        self.batch_count = 0
        if self.pickle:
            self._buffered_send_metric = self._buffered_pickle_send_metric
            self._send = self._send_pickle
            self.batch_buffer = []
        else:
            self._buffered_send_metric = self._buffered_plaintext_send_metric
            self._send = self._send_plaintext
            self.batch_buffer = ""

    @property
    def socket(self):
        if not hasattr(self, '_socket'):
            self._socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self._socket.connect((self.host, self.port))
        return self._socket

    def write(self):
        for name, metric in self.registry:
            if isinstance(metric, Meter):
                self.send_metric(name, 'meter', metric, [
                    'count', 'one_minute_rate', 'five_minute_rate',
                    'fifteen_minute_rate', 'mean_rate'
                ])
            if isinstance(metric, Gauge):
                self.send_metric(name, 'gauge', metric, [
                    'value'
                ])
            if isinstance(metric, UtilizationTimer):
                self.send_metric(name, 'timer', metric, [
                    'count', 'one_minute_rate', 'five_minute_rate',
                    'fifteen_minute_rate', 'mean_rate',
                    'min', 'max', 'mean', 'stddev',
                    'one_minute_utilization', 'five_minute_utilization',
                    'fifteen_minute_utilization', 'mean_utilization'
                ], [
                    'median', 'percentile_95th'
                ])
            if isinstance(metric, Timer):
                self.send_metric(name, 'timer', metric, [
                    'count', 'one_minute_rate', 'five_minute_rate',
                    'fifteen_minute_rate', 'mean_rate',
                    'min', 'max', 'mean', 'stddev'
                ], [
                    'median', 'percentile_95th'
                ])
            if isinstance(metric, Counter):
                self.send_metric(name, 'counter', metric, [
                    'count'
                ])
            if isinstance(metric, Histogram):
                self.send_metric(name, 'histogram', metric, [
                    'count', 'min', 'max', 'mean', 'stddev',
                ], [
                    'median', 'percentile_95th'
                ])

        # Send metrics that might be in buffers
        self._send()

    def send_metric(self, name, type, metric, keys, snapshot_keys=None):
        if snapshot_keys is None:
            snapshot_keys = []
        base_name = re.sub(r"\s+", "_", name)
        if self.prefix:
            base_name = "{0}.{1}".format(self.prefix, base_name)

        for name in keys:
            value = True
            value = getattr(metric, name)
            self._buffered_send_metric(base_name, name, value, now())

        if hasattr(metric, 'snapshot'):
            snapshot = metric.snapshot
            for name in snapshot_keys:
                value = True
                value = getattr(snapshot, name)
                self._buffered_send_metric(base_name, name, value, now())

    def _buffered_plaintext_send_metric(self, base_name, name, value, t, force=False):
        self.batch_count += 1
        self.batch_buffer += "{0}.{1} {2} {3}\n".format(
            base_name, name, value, now())
        # Check if we reach batch size and send
        if self.batch_count >= self.batch_size:
            self._send_plaintext()

    def _buffered_pickle_send_metric(self, base_name, name, value, t):
        self.batch_count += 1
        self.batch_buffer.append(("{0}.{1}".format(base_name, name), (t, value)))
        # Check if we reach batch size and send
        if self.batch_count >= self.batch_size:
            self._send_pickle()

    def _send_plaintext(self):
        if len(self.batch_buffer):
            self.socket.sendall(self.batch_buffer + "\n")
            # Reinitialze buffer and counter
            self.batch_count = 0
            self.batch_buffer = ""

    def _send_pickle(self):
        if len(self.batch_buffer):
            payload = pickle.dumps(self.batch_buffer)
            header = struct.pack("!L", len(payload))
            message = header + payload
            self.socket.sendall(message)
            # Reinitialze buffer and counter
            self.batch_count = 0
            self.batch_buffer = []

########NEW FILE########
__FILENAME__ = librato
import re

from json import dumps

from metrology.exceptions import ReporterException
from metrology.instruments import *  # noqa
from metrology.reporter.base import Reporter
from metrology.utils import now


class LibratoReporter(Reporter):
    """
    A librato metrics reporter that send metrics to librato ::

        reporter = LibratoReporter("<email>", "<token>", source="front.local")
        reporter.start()

    :param email: your librato email
    :param token: your librato api token
    :param source: source of the metric
    :param interval: time between each reporting
    :param prefix: metrics name prefix
    :param filters: allow given keys to be send
    :param excludes: exclude given keys to be send
    """
    def __init__(self, email, token, **options):
        self.email = email
        self.token = token

        try:
            import requests  # noqa
        except:
            raise ReporterException("Librato reporter requires the 'requests' library")

        self.filters = options.get('filters')
        self.excludes = options.get('excludes')
        self.source = options.get('source')
        self.prefix = options.get('prefix')
        super(LibratoReporter, self).__init__(**options)

    def list_metrics(self):
        for name, metric in self.registry:
            if isinstance(metric, Meter):
                yield self.prepare_metric(name, 'meter', metric, [
                    'count', 'one_minute_rate', 'five_minute_rate',
                    'fifteen_minute_rate', 'mean_rate'
                ])
            if isinstance(metric, Gauge):
                yield self.prepare_metric(name, 'gauge', metric, [
                    'value'
                ])
            if isinstance(metric, UtilizationTimer):
                yield self.prepare_metric(name, 'timer', metric, [
                    'count', 'one_minute_rate', 'five_minute_rate',
                    'fifteen_minute_rate', 'mean_rate',
                    'min', 'max', 'mean', 'stddev',
                    'one_minute_utilization', 'five_minute_utilization',
                    'fifteen_minute_utilization', 'mean_utilization'
                ], [
                    'median', 'percentile_95th'
                ])
            if isinstance(metric, Timer):
                yield self.prepare_metric(name, 'timer', metric, [
                    'count', 'one_minute_rate', 'five_minute_rate',
                    'fifteen_minute_rate', 'mean_rate',
                    'min', 'max', 'mean', 'stddev'
                ], [
                    'median', 'percentile_95th'
                ])
            if isinstance(metric, Counter):
                yield self.prepare_metric(name, 'counter', metric, [
                    'count'
                ])
            if isinstance(metric, Histogram):
                yield self.prepare_metric(name, 'histogram', metric, [
                    'count', 'min', 'max', 'mean', 'stddev',
                ], [
                    'median', 'percentile_95th'
                ])

    def write(self):
        import requests
        metrics = {
            "gauges": [data for metric in self.list_metrics() for type, data in metric if type == "gauge"],
            "counters": [data for metric in self.list_metrics() for type, data in metric if type == "counter"]
        }
        requests.post("https://metrics-api.librato.com/v1/metrics",
                      data=dumps(metrics),
                      auth=(self.email, self.token),
                      headers={'content-type': 'application/json'})

    def prepare_metric(self, name, type, metric, keys, snapshot_keys=[]):
        base_name = re.sub(r"\s+", "_", name)
        if self.prefix:
            base_name = "{0}.{1}".format(self.prefix, base_name)

        time = now()
        type = "gauge" if type != "counter" else "counter"

        if self.filters:
            keys = filter(lambda key: key in self.filters, keys)
            snapshot_keys = filter(lambda key: key in self.filters, snapshot_keys)

        if self.excludes:
            keys = filter(lambda key: key not in self.excludes, keys)
            snapshot_keys = filter(lambda key: key in self.excludes, snapshot_keys)

        for name in keys:
            value = getattr(metric, name)
            yield type, {
                "name": "{0}.{1}".format(base_name, name),
                "source": self.source,
                "time": time,
                "value": value
            }

        if hasattr(metric, 'snapshot'):
            snapshot = metric.snapshot
            for name in snapshot_keys:
                value = getattr(snapshot, name)
                yield type, {
                    "name": "{0}.{1}".format(base_name, name),
                    "source": self.source,
                    "time": time,
                    "value": value
                }

########NEW FILE########
__FILENAME__ = logger
import logging

from metrology.instruments import *  # noqa
from metrology.reporter.base import Reporter


class LoggerReporter(Reporter):
    """
    A logging reporter that write metrics to a logger ::

      reporter = LoggerReporter(level=logging.DEBUG, interval=10)
      reporter.start()

    :param logger: logger to use
    :param level: logger level
    :param interval: time between each reporting
    :param prefix: metrics name prefix
    """
    def __init__(self, logger=logging, level=logging.INFO, **options):
        self.logger = logger
        self.level = level

        self.prefix = options.get('prefix')
        super(LoggerReporter, self).__init__(**options)

    def write(self):
        for name, metric in self.registry:
            if isinstance(metric, Meter):
                self.log_metric(name, 'meter', metric, [
                    'count', 'one_minute_rate', 'five_minute_rate',
                    'fifteen_minute_rate', 'mean_rate'
                ])
            if isinstance(metric, Gauge):
                self.log_metric(name, 'gauge', metric, [
                    'value'
                ])
            if isinstance(metric, UtilizationTimer):
                self.log_metric(name, 'timer', metric, [
                    'count', 'one_minute_rate', 'five_minute_rate',
                    'fifteen_minute_rate', 'mean_rate',
                    'min', 'max', 'mean', 'stddev',
                    'one_minute_utilization', 'five_minute_utilization',
                    'fifteen_minute_utilization', 'mean_utilization'
                ], [
                    'median', 'percentile_95th'
                ])
            if isinstance(metric, Timer):
                self.log_metric(name, 'timer', metric, [
                    'count', 'one_minute_rate', 'five_minute_rate',
                    'fifteen_minute_rate', 'mean_rate',
                    'min', 'max', 'mean', 'stddev'
                ], [
                    'median', 'percentile_95th'
                ])
            if isinstance(metric, Counter):
                self.log_metric(name, 'counter', metric, [
                    'count'
                ])
            if isinstance(metric, Histogram):
                self.log_metric(name, 'histogram', metric, [
                    'count', 'min', 'max', 'mean', 'stddev',
                ], [
                    'median', 'percentile_95th'
                ])

    def log_metric(self, name, type, metric, keys, snapshot_keys=None):
        if snapshot_keys is None:
            snapshot_keys = []
        messages = []
        if self.prefix:
            messages.append(self.prefix)

        messages.append(name)
        messages.append(type)

        for name in keys:
            messages.append("{0}={1}".format(name, getattr(metric, name)))

        if hasattr(metric, 'snapshot'):
            snapshot = metric.snapshot
            for name in snapshot_keys:
                messages.append("{0}={1}".format(name, getattr(snapshot, name)))

        self.logger.log(self.level, " ".join(messages))

########NEW FILE########
__FILENAME__ = ewma
import math

from atomic import AtomicLong


class EWMA(object):
    INTERVAL = 5.0
    SECONDS_PER_MINUTE = 60.0

    ONE_MINUTE = 1
    FIVE_MINUTES = 5
    FIFTEEN_MINUTES = 15

    M1_ALPHA = 1 - math.exp(-INTERVAL / SECONDS_PER_MINUTE / ONE_MINUTE)
    M5_ALPHA = 1 - math.exp(-INTERVAL / SECONDS_PER_MINUTE / FIVE_MINUTES)
    M15_ALPHA = 1 - math.exp(-INTERVAL / SECONDS_PER_MINUTE / FIFTEEN_MINUTES)

    @classmethod
    def m1(cls):
        return EWMA(cls.M1_ALPHA, cls.INTERVAL)

    @classmethod
    def m5(cls):
        return EWMA(cls.M5_ALPHA, cls.INTERVAL)

    @classmethod
    def m15(cls):
        return EWMA(cls.M15_ALPHA, cls.INTERVAL)

    def __init__(self, alpha, interval):
        self.alpha = alpha
        self.interval = interval

        self.initialized = False
        self._rate = 0.0
        self._uncounted = AtomicLong(0)

    def clear(self):
        self.initialized = False
        self._rate = 0.0
        self._uncounted.value = 0

    def update(self, value):
        self._uncounted += value

    def tick(self):
        count = self._uncounted.swap(0)
        instant_rate = count / self.interval

        if self.initialized:
            self._rate += self.alpha * (instant_rate - self._rate)
        else:
            self._rate = instant_rate
            self.initialized = True

    @property
    def rate(self):
        return self._rate

########NEW FILE########
__FILENAME__ = sample
import heapq
import math
import random
import sys

from threading import RLock

from atomic import AtomicLong

from metrology.stats.snapshot import Snapshot
from metrology.utils import now


class UniformSample(object):
    def __init__(self, reservoir_size):
        self.counter = AtomicLong(0)
        self.values = [0] * reservoir_size

    def clear(self):
        self.values = [0] * len(self.values)
        self.counter.value = 0

    def size(self):
        count = self.counter.value
        if count > len(self.values):
            return len(self.values)
        return count

    def __len__(self):
        return self.size

    def snapshot(self):
        return Snapshot(self.values[0:self.size()])

    def update(self, value):
        self.counter += 1
        new_count = self.counter.value

        if new_count <= len(self.values):
            self.values[new_count - 1] = value
        else:
            index = random.uniform(0, new_count)
            if index < len(self.values):
                self.values[int(index)] = value


class ExponentiallyDecayingSample(object):
    def __init__(self, reservoir_size, alpha):
        self.values = []
        self.next_scale_time = AtomicLong(0)
        self.alpha = alpha
        self.reservoir_size = reservoir_size
        self.lock = RLock()
        self.rescale_threshold = ExponentiallyDecayingSample.calculate_rescale_threshold(alpha)
        self.clear()

    @staticmethod
    def calculate_rescale_threshold(alpha):
        # determine rescale-threshold such that we will not overflow exp() in
        # weight function, and subsequently not overflow into inf on dividing
        # by random.random()
        min_rand = 1.0 / (2 ** 32)  # minimum non-zero value from random()
        safety = 2.0                # safety pad for numerical inaccuracy
        max_value = sys.float_info.max * min_rand / safety
        return int(math.log(max_value) / alpha)

    def clear(self):
        with self.lock:
            self.values = []
            self.start_time = now()
            self.next_scale_time.value = self.start_time + self.rescale_threshold

    def size(self):
        with self.lock:
            return len(self.values)

    def __len__(self):
        return self.size()

    def snapshot(self):
        with self.lock:
            return Snapshot(val for _, val in self.values)

    def weight(self, timestamp):
        return math.exp(self.alpha * (timestamp - self.start_time))

    def rescale(self, now, next_time):
        if self.next_scale_time.compare_and_swap(next_time, now + self.rescale_threshold):
            with self.lock:
                rescaleFactor = math.exp(-self.alpha * (now - self.start_time))
                self.values = [(k * rescaleFactor, v) for k, v in self.values]
                self.start_time = now

    def rescale_if_necessary(self):
        time = now()
        next_time = self.next_scale_time.value
        if time > next_time:
            self.rescale(time, next_time)

    def update(self, value, timestamp=None):
        if timestamp is None:
            timestamp = now()

        self.rescale_if_necessary()
        with self.lock:
            try:
                priority = self.weight(timestamp) / random.random()
            except (OverflowError, ZeroDivisionError):
                priority = sys.float_info.max

            if len(self.values) < self.reservoir_size:
                heapq.heappush(self.values, (priority, value))
            else:
                heapq.heappushpop(self.values, (priority, value))

########NEW FILE########
__FILENAME__ = snapshot
import math

from metrology.exceptions import ArgumentException


class Snapshot(object):
    MEDIAN_Q = 0.5
    P75_Q = 0.75
    P95_Q = 0.95
    P98_Q = 0.98
    P99_Q = 0.99
    P999_Q = 0.999

    def __init__(self, values):
        self.values = sorted(values)

    def value(self, quantile):
        if 0.0 > quantile > 1.0:
            raise ArgumentException("Quantile must be between 0.0 and 1.0")

        if not self.values:
            return 0.0

        pos = quantile * (len(self.values) + 1)

        if pos < 1:
            return self.values[0]

        if pos >= len(self.values):
            return self.values[-1]

        lower = self.values[int(pos) - 1]
        upper = self.values[int(pos)]
        return lower + (pos - math.floor(pos)) * (upper - lower)

    def size(self):
        return len(self.values)

    def __len__(self):
        return self.size()

    @property
    def median(self):
        return self.value(self.MEDIAN_Q)

    @property
    def percentile_75th(self):
        return self.value(self.P75_Q)

    @property
    def percentile_95th(self):
        return self.value(self.P95_Q)

    @property
    def percentile_98th(self):
        return self.value(self.P98_Q)

    @property
    def percentile_99th(self):
        return self.value(self.P99_Q)

    @property
    def percentile_999th(self):
        return self.value(self.P999_Q)

########NEW FILE########
__FILENAME__ = periodic
from threading import Thread, Event


class PeriodicTask(Thread):
    def __init__(self, interval=5., target=None):
        super(PeriodicTask, self).__init__()
        self.status = Event()
        self.interval = interval
        self.target = target
        self.daemon = True

    def stop(self):
        self.status.set()

    @property
    def stopped(self):
        return self.status.isSet()

    def run(self):
        while True:
            if self.stopped:
                return
            self.status.wait(self.interval)
            self.task()

    def task(self):
        if not self.target:
            raise NotImplementedError
        self.target()

########NEW FILE########
__FILENAME__ = test_counter
from unittest import TestCase

from metrology.instruments.counter import Counter


class CounterTest(TestCase):
    def setUp(self):
        self.counter = Counter()

    def test_increment(self):
        self.counter.increment()
        self.assertEqual(1, self.counter.count)

    def test_increment_more(self):
        self.counter.increment(10)
        self.assertEqual(10, self.counter.count)

    def test_clear(self):
        self.counter.increment(10)
        self.counter.clear()
        self.assertEqual(0, self.counter.count)

    def test_decrement(self):
        self.counter.increment(10)
        self.counter.decrement()
        self.assertEqual(9, self.counter.count)

    def test_decrement_more(self):
        self.counter.increment(10)
        self.counter.decrement(9)
        self.assertEqual(1, self.counter.count)

########NEW FILE########
__FILENAME__ = test_derive
from unittest import TestCase

from metrology.instruments.derive import Derive


class DeriveTest(TestCase):
    def setUp(self):
        self.derive = Derive()

    def test_derive(self):
        self.derive.mark()
        self.assertEqual(1, self.derive.count)

    def test_blank_derive(self):
        self.assertEqual(0, self.derive.count)
        self.assertEqual(0.0, self.derive.mean_rate)

    def test_derive_value(self):
        self.derive.mark(3)
        self.assertEqual(3, self.derive.count)

    def test_one_minute_rate(self):
        self.derive.mark(1000)
        self.derive.tick()
        self.assertEqual(200, self.derive.one_minute_rate)

    def tearDown(self):
        self.derive.stop()

########NEW FILE########
__FILENAME__ = test_gauge
import math

from unittest import TestCase

from metrology.instruments.gauge import Gauge, RatioGauge, PercentGauge, \
    ToggleGauge


class DummyGauge(Gauge):
    @property
    def value(self):
        return "wow"


class DummyRatioGauge(RatioGauge):
    def __init__(self, numerator, denominator):
        self.num = numerator
        self.den = denominator

    def numerator(self):
        return self.num

    def denominator(self):
        return self.den


class DummyPercentGauge(DummyRatioGauge, PercentGauge):
    pass


class GaugeTest(TestCase):
    def setUp(self):
        self.gauge = DummyGauge()

    def test_return_value(self):
        self.assertEqual(self.gauge.value, "wow")


class RatioGaugeTest(TestCase):
    def test_ratio(self):
        gauge = DummyRatioGauge(2, 4)
        self.assertEqual(gauge.value, 0.5)

    def test_divide_by_zero(self):
        gauge = DummyRatioGauge(100, 0)
        self.assertTrue(math.isnan(gauge.value))

    def test_divide_by_infinite(self):
        gauge = DummyRatioGauge(100, float('inf'))
        self.assertTrue(math.isnan(gauge.value))

    def test_divide_by_nan(self):
        gauge = DummyRatioGauge(100, float('nan'))
        self.assertTrue(math.isnan(gauge.value))


class PercentGaugeTest(TestCase):
    def test_percentage(self):
        gauge = DummyPercentGauge(2, 4)
        self.assertEqual(gauge.value, 50.)

    def test_with_nan(self):
        gauge = DummyPercentGauge(2, 0)
        self.assertTrue(math.isnan(gauge.value))


class ToggleGaugeTest(TestCase):
    def test_return_one_then_zero(self):
        gauge = ToggleGauge()
        self.assertEqual(gauge.value, 1)
        self.assertEqual(gauge.value, 0)
        self.assertEqual(gauge.value, 0)
        self.assertEqual(gauge.value, 0)

########NEW FILE########
__FILENAME__ = test_healthcheck

from unittest import TestCase

from metrology.instruments.healthcheck import HealthCheck


class DummyHealthCheck(HealthCheck):
    def check(self):
        return True


class HealthCheckTest(TestCase):
    def setUp(self):
        self.health_check = DummyHealthCheck()

    def test_return_check(self):
        self.assertEqual(self.health_check.check(), True)

########NEW FILE########
__FILENAME__ = test_histogram
from threading import Thread
from unittest import TestCase

from metrology.stats.sample import ExponentiallyDecayingSample
from metrology.instruments.histogram import Histogram, HistogramUniform, \
    HistogramExponentiallyDecaying


class HistogramTest(TestCase):
    def test_uniform_sample_min(self):
        histogram = HistogramUniform()
        histogram.update(5)
        histogram.update(10)
        self.assertEqual(5, histogram.min)

    def test_uniform_sample_max(self):
        histogram = HistogramUniform()
        histogram.update(5)
        histogram.update(10)
        self.assertEqual(10, histogram.max)

    def test_uniform_sample_mean(self):
        histogram = HistogramUniform()
        histogram.update(5)
        histogram.update(10)
        self.assertEqual(7.5, histogram.mean)

    def test_uniform_sample_mean_threaded(self):
        histogram = HistogramUniform()

        def update():
            for i in range(100):
                histogram.update(5)
                histogram.update(10)
        for thread in [Thread(target=update) for i in range(10)]:
            thread.start()
            thread.join()
        self.assertEqual(7.5, histogram.mean)

    def test_uniform_sample_2000(self):
        histogram = HistogramUniform()
        for i in range(2000):
            histogram.update(i)
        self.assertEqual(1999, histogram.max)

    def test_uniform_sample_snapshot(self):
        histogram = HistogramUniform()
        for i in range(100):
            histogram.update(i)
        snapshot = histogram.snapshot
        self.assertEqual(49.5, snapshot.median)

    def test_uniform_sample_snapshot_threaded(self):
        histogram = HistogramUniform()

        def update():
            for i in range(100):
                histogram.update(i)
        for thread in [Thread(target=update) for i in range(10)]:
            thread.start()
            thread.join()
        snapshot = histogram.snapshot
        self.assertEqual(49.5, snapshot.median)

    def test_exponential_sample_min(self):
        histogram = HistogramExponentiallyDecaying()
        histogram.update(5)
        histogram.update(10)
        self.assertEqual(5, histogram.min)

    def test_exponential_sample_max(self):
        histogram = HistogramExponentiallyDecaying()
        histogram.update(5)
        histogram.update(10)
        self.assertEqual(10, histogram.max)

    def test_exponential_sample_mean(self):
        histogram = HistogramExponentiallyDecaying()
        histogram.update(5)
        histogram.update(10)
        self.assertEqual(7.5, histogram.mean)

    def test_exponential_sample_mean_threaded(self):
        histogram = HistogramExponentiallyDecaying()

        def update():
            for i in range(100):
                histogram.update(5)
                histogram.update(10)
        for thread in [Thread(target=update) for i in range(10)]:
            thread.start()
            thread.join()
        self.assertEqual(7.5, histogram.mean)

    def test_exponential_sample_2000(self):
        histogram = HistogramExponentiallyDecaying()
        for i in range(2000):
            histogram.update(i)
        self.assertEqual(1999, histogram.max)

    def test_exponential_sample_snapshot(self):
        histogram = HistogramExponentiallyDecaying()
        for i in range(100):
            histogram.update(i)
        snapshot = histogram.snapshot
        self.assertEqual(49.5, snapshot.median)

    def test_exponential_sample_snapshot_threaded(self):
        histogram = HistogramExponentiallyDecaying()

        def update():
            for i in range(100):
                histogram.update(i)
        for thread in [Thread(target=update) for i in range(10)]:
            thread.start()
            thread.join()
        snapshot = histogram.snapshot
        self.assertEqual(49.5, snapshot.median)

    def test_sample_overflow_error(self):
        sample = ExponentiallyDecayingSample(Histogram.DEFAULT_SAMPLE_SIZE,
                                             Histogram.DEFAULT_ALPHA)
        sample.start_time = 946681200.0
        histogram = Histogram(sample)
        histogram.update(5)
        self.assertEqual(5, histogram.min)

########NEW FILE########
__FILENAME__ = test_meter
from threading import Thread
from unittest import TestCase

from metrology.instruments.meter import Meter


class MeterTest(TestCase):
    def setUp(self):
        self.meter = Meter()

    def test_meter(self):
        self.meter.mark()
        self.assertEqual(1, self.meter.count)

    def test_blank_meter(self):
        self.assertEqual(0, self.meter.count)
        self.assertEqual(0.0, self.meter.mean_rate)

    def test_meter_value(self):
        self.meter.mark(3)
        self.assertEqual(3, self.meter.count)

    def test_one_minute_rate(self):
        self.meter.mark(1000)
        self.meter.tick()
        self.assertEqual(200, self.meter.one_minute_rate)

    def test_meter_threaded(self):
        def mark():
            for i in range(100):
                self.meter.mark()
        for thread in [Thread(target=mark) for i in range(10)]:
            thread.start()
            thread.join()
        self.assertEqual(1000, self.meter.count)

    def tearDown(self):
        self.meter.stop()

########NEW FILE########
__FILENAME__ = test_timer
import time

from unittest import TestCase

from metrology.instruments.timer import Timer, UtilizationTimer


class TimerTest(TestCase):
    def setUp(self):
        self.timer = Timer()

    def tearDown(self):
        self.timer.stop()

    def test_timer(self):
        for i in range(3):
            with self.timer:
                time.sleep(0.1)
        self.assertAlmostEqual(100, self.timer.mean, delta=10)
        self.assertAlmostEqual(100, self.timer.snapshot.median, delta=10)


class UtilizationTimerTest(TestCase):
    def setUp(self):
        self.timer = UtilizationTimer()

    def tearDown(self):
        self.timer.stop()

    def test_timer(self):
        for i in range(5):
            self.timer.update(100)
            self.timer.update(150)
        self.timer.meter.tick()
        self.timer.duration_meter.tick()

        self.assertAlmostEqual(250, self.timer.one_minute_utilization, delta=10)

########NEW FILE########
__FILENAME__ = test_ganglia
from ganglia import GMetric

try:
    from mock import patch
except ImportError:
    from unittest.mock import patch  # noqa

from unittest import TestCase

from metrology import Metrology
from metrology.reporter.ganglia import GangliaReporter


class GangliaReporterTest(TestCase):
    def setUp(self):
        self.reporter = GangliaReporter("Group Name", "localhost", 8649)

        Metrology.meter('meter').mark()
        Metrology.counter('counter').increment()
        Metrology.timer('timer').update(5)
        Metrology.utilization_timer('utimer').update(5)

    def tearDown(self):
        self.reporter.stop()
        Metrology.stop()

    @patch.object(GMetric, "send")
    def test_write(self, mock):
        self.reporter.write()
        self.assertTrue(mock.send.assert_called())

########NEW FILE########
__FILENAME__ = test_graphite
try:
    from StringIO import StringIO
    from mock import patch
except ImportError:
    from io import StringIO  # noqa
    from unittest.mock import patch  # noqa

from unittest import TestCase

from metrology import Metrology
from metrology.reporter.graphite import GraphiteReporter


class GraphiteReporterTest(TestCase):
    def setUp(self):
        pass

    def tearDown(self):
        Metrology.stop()

    @patch.object(GraphiteReporter, 'socket')
    def test_send_nobatch(self, mock):
        self.reporter = GraphiteReporter('localhost', 3333, batch_size=1)

        Metrology.meter('meter').mark()
        Metrology.counter('counter').increment()
        Metrology.timer('timer').update(5)
        Metrology.utilization_timer('utimer').update(5)
        Metrology.histogram('histogram').update(5)
        self.reporter.write()
        self.assertTrue(mock.send.assert_called())
        self.assertEqual(50, len(mock.sendall.call_args_list))
        self.reporter.stop()

    @patch.object(GraphiteReporter, 'socket')
    def test_send_batch(self, mock):
        self.reporter = GraphiteReporter('localhost', 3333, batch_size=2)

        Metrology.meter('meter').mark()
        Metrology.counter('counter').increment()
        Metrology.timer('timer').update(5)
        Metrology.utilization_timer('utimer').update(5)
        Metrology.histogram('histogram').update(5)
        self.reporter.write()
        self.assertTrue(mock.send.assert_called())
        self.assertEqual(25, len(mock.sendall.call_args_list))
        self.reporter.stop()

########NEW FILE########
__FILENAME__ = test_graphite_pickle
try:
    from StringIO import StringIO
    from mock import patch
except ImportError:
    from io import StringIO  # noqa
    from unittest.mock import patch  # noqa

from unittest import TestCase

from metrology import Metrology
from metrology.reporter.graphite import GraphiteReporter


class GraphiteReporterTest(TestCase):
    def setUp(self):
        pass

    def tearDown(self):
        Metrology.stop()

    @patch.object(GraphiteReporter, 'socket')
    def test_send_nobatch(self, mock):
        self.reporter = GraphiteReporter('localhost', 3334, pickle=True, batch_size=1)

        Metrology.meter('meter').mark()
        Metrology.counter('counter').increment()
        Metrology.timer('timer').update(5)
        Metrology.utilization_timer('utimer').update(5)
        Metrology.histogram('histogram').update(5)
        self.reporter.write()
        self.assertTrue(mock.sendall.assert_called())
        self.assertEqual(50, len(mock.sendall.call_args_list))
        self.reporter.stop()

    @patch.object(GraphiteReporter, 'socket')
    def test_send_batch(self, mock):
        self.reporter = GraphiteReporter('localhost', 3334, pickle=True, batch_size=2)

        Metrology.meter('meter').mark()
        Metrology.counter('counter').increment()
        Metrology.timer('timer').update(5)
        Metrology.utilization_timer('utimer').update(5)
        Metrology.histogram('histogram').update(5)
        self.reporter.write()
        self.assertTrue(mock.sendall.assert_called())
        self.assertEqual(25, len(mock.sendall.call_args_list))
        self.reporter.stop()

########NEW FILE########
__FILENAME__ = test_librato
import requests

try:
    from mock import patch
except ImportError:
    from unittest.mock import patch  # noqa

from unittest import TestCase

from metrology import Metrology
from metrology.reporter.librato import LibratoReporter


class LibratoReporterTest(TestCase):
    def setUp(self):
        self.reporter = LibratoReporter("<email>", "<token>")

        Metrology.meter('meter').mark()
        Metrology.counter('counter').increment()
        Metrology.timer('timer').update(5)
        Metrology.utilization_timer('utimer').update(5)

    def tearDown(self):
        self.reporter.stop()
        Metrology.stop()

    @patch.object(requests, "post")
    def test_write(self, mock):
        self.reporter.write()
        self.assertTrue(mock.send.assert_called())
        self.assertTrue("gauges" in mock.call_args_list[0][1]['data'])
        self.assertTrue("counters" in mock.call_args_list[0][1]['data'])

########NEW FILE########
__FILENAME__ = test_logger
import logging

try:
    from StringIO import StringIO
except ImportError:
    from io import StringIO  # noqa

from unittest import TestCase

from metrology import Metrology
from metrology.reporter.logger import LoggerReporter


class LoggerReporterTest(TestCase):
    def setUp(self):
        self.output = StringIO()
        logging.basicConfig(stream=self.output, level=logging.INFO)

        self.reporter = LoggerReporter()

        Metrology.meter('meter').mark()
        Metrology.counter('counter').increment()
        Metrology.timer('timer').update(5)
        Metrology.utilization_timer('utimer').update(5)

    def tearDown(self):
        self.reporter.stop()
        Metrology.stop()

    def test_write(self):
        self.reporter.write()
        self.assertTrue("median=" in self.output.getvalue())

########NEW FILE########
__FILENAME__ = test_ewma
from unittest import TestCase

from metrology.stats.ewma import EWMA


class EwmaTest(TestCase):
    def _one_minute(self, ewma):
        for i in range(12):
            ewma.tick()

    def test_one_minute_ewma(self):
        ewma = EWMA.m1()
        ewma.update(3)
        ewma.tick()
        self.assertAlmostEqual(ewma.rate, 0.6, places=6)

        self._one_minute(ewma)
        self.assertAlmostEqual(ewma.rate, 0.22072766, places=6)

        self._one_minute(ewma)
        self.assertAlmostEqual(ewma.rate, 0.08120117, places=6)

    def test_five_minute_ewma(self):
        ewma = EWMA.m5()
        ewma.update(3)
        ewma.tick()
        self.assertAlmostEqual(ewma.rate, 0.6, places=6)

        self._one_minute(ewma)
        self.assertAlmostEqual(ewma.rate, 0.49123845, places=6)

        self._one_minute(ewma)
        self.assertAlmostEqual(ewma.rate, 0.40219203, places=6)

    def test_fifteen_minute_ewma(self):
        ewma = EWMA.m15()
        ewma.update(3)
        ewma.tick()
        self.assertAlmostEqual(ewma.rate, 0.6, places=6)

        self._one_minute(ewma)
        self.assertAlmostEqual(ewma.rate, 0.56130419, places=6)

        self._one_minute(ewma)
        self.assertAlmostEqual(ewma.rate, 0.52510399, places=6)

    def test_clear_ewma(self):
        ewma = EWMA.m15()
        ewma.update(3)
        ewma.tick()
        ewma.clear()
        self.assertAlmostEqual(ewma.rate, 0)

########NEW FILE########
__FILENAME__ = test_sample
import math

from unittest import TestCase

try:
    from mock import patch
except ImportError:
    from unittest.mock import patch  # noqa

from metrology.stats.sample import UniformSample, ExponentiallyDecayingSample


class UniformSampleTest(TestCase):
    def test_sample(self):
        sample = UniformSample(100)
        for i in range(1000):
            sample.update(i)
        snapshot = sample.snapshot()
        self.assertEqual(sample.size(), 100)
        self.assertEqual(snapshot.size(), 100)

        for value in snapshot.values:
            self.assertTrue(value < 1000.0)
            self.assertTrue(value >= 0.0)


class ExponentiallyDecayingSampleTest(TestCase):
    def test_sample_1000(self):
        sample = ExponentiallyDecayingSample(100, 0.99)
        for i in range(1000):
            sample.update(i)
        self.assertEqual(sample.size(), 100)
        snapshot = sample.snapshot()
        self.assertEqual(snapshot.size(), 100)

        for value in snapshot.values:
            self.assertTrue(value < 1000.0)
            self.assertTrue(value >= 0.0)

    def test_sample_10(self):
        sample = ExponentiallyDecayingSample(100, 0.99)
        for i in range(10):
            sample.update(i)
        self.assertEqual(sample.size(), 10)

        snapshot = sample.snapshot()
        self.assertEqual(snapshot.size(), 10)

        for value in snapshot.values:
            self.assertTrue(value < 10.0)
            self.assertTrue(value >= 0.0)

    def test_sample_100(self):
        sample = ExponentiallyDecayingSample(1000, 0.01)
        for i in range(100):
            sample.update(i)
        self.assertEqual(sample.size(), 100)

        snapshot = sample.snapshot()
        self.assertEqual(snapshot.size(), 100)

        for value in snapshot.values:
            self.assertTrue(value < 100.0)
            self.assertTrue(value >= 0.0)

    def timestamp_to_priority_is_noop(f):
        """
        Decorator that patches ExponentiallyDecayingSample class such that the
        timestamp->priority function is a no-op.
        """
        weight_fn = "metrology.stats.sample.ExponentiallyDecayingSample.weight"
        return patch(weight_fn, lambda self, x: x)(patch("random.random", lambda: 1.0)(f))

    @timestamp_to_priority_is_noop
    def test_sample_eviction(self):
        kSampleSize = 10
        kDefaultValue = 1.0
        sample = ExponentiallyDecayingSample(kSampleSize, 0.01)

        timestamps = range(1, kSampleSize * 2)
        for count, timestamp in enumerate(timestamps):
            sample.update(kDefaultValue, timestamp)
            self.assertLessEqual(len(sample.values), kSampleSize)
            self.assertLessEqual(len(sample.values), count + 1)
            expected_min_key = timestamps[max(0, count + 1 - kSampleSize)]
            self.assertEqual(min(sample.values)[0], expected_min_key)

    @timestamp_to_priority_is_noop
    def test_sample_ordering(self):
        kSampleSize = 3
        sample = ExponentiallyDecayingSample(kSampleSize, 0.01)

        timestamps = range(1, kSampleSize + 1)
        values = ["value_{0}".format(i) for i in timestamps]
        expected = list(zip(timestamps, values))
        for timestamp, value in expected:
            sample.update(value, timestamp)
        self.assertListEqual(sorted(sample.values), expected)

        # timestamp less than any existing => no-op
        sample.update("ignore", 0.5)
        self.assertEqual(sorted(sample.values), expected)

        # out of order insertions
        expected = [3.0, 4.0, 5.0]
        sample.update("ignore", 5.0)
        sample.update("ignore", 4.0)
        self.assertListEqual(sorted(k for k, _ in sample.values), expected)

        # collision
        marker = "marker"
        replacement_timestamp = 5.0
        expected = [4.0, 5.0, 5.0]
        sample.update(marker, replacement_timestamp)
        self.assertListEqual(sorted(k for k, _ in sample.values), expected)

        replacement_timestamp = 4.0
        expected = [4.0, 5.0, 5.0]
        sample.update(marker, replacement_timestamp)
        self.assertListEqual(sorted(k for k, _ in sample.values), expected)

    def test_rescale_threshold(self):
        infinity = float('inf')
        for alpha in (0.015, 1e-10, 1):
            rescale_threshold = ExponentiallyDecayingSample.calculate_rescale_threshold(alpha)
            min_rand_val = 1.0 / (2 ** 32)
            max_priority = math.exp(alpha * rescale_threshold) / min_rand_val
            self.assertLess(max_priority, infinity)

########NEW FILE########
__FILENAME__ = test_snapshot
from unittest import TestCase

from metrology.stats.snapshot import Snapshot


class SnapshotTest(TestCase):
    def setUp(self):
        self.snapshot = Snapshot([5, 1, 2, 3, 4])

    def test_median(self):
        self.assertAlmostEqual(self.snapshot.median, 3, 1)

    def test_75th_percentile(self):
        self.assertAlmostEqual(self.snapshot.percentile_75th, 4.5, 1)

    def test_95th_percentile(self):
        self.assertAlmostEqual(self.snapshot.percentile_95th, 5.0, 1)

    def test_98th_percentile(self):
        self.assertAlmostEqual(self.snapshot.percentile_98th, 5.0, 1)

    def test_99th_percentile(self):
        self.assertAlmostEqual(self.snapshot.percentile_99th, 5.0, 1)

    def test_999th_percentile(self):
        self.assertAlmostEqual(self.snapshot.percentile_999th, 5.0, 1)

    def test_size(self):
        self.assertEqual(self.snapshot.size(), 5)

########NEW FILE########
__FILENAME__ = test_metrology
from unittest import TestCase

from metrology import Metrology
from metrology.instruments.gauge import Gauge
from metrology.instruments.healthcheck import HealthCheck
from metrology.registry import registry


class MetrologyTest(TestCase):
    def setUp(self):
        registry.clear()

    def tearDown(self):
        registry.clear()

    def test_get(self):
        Metrology.counter('test')
        self.assertTrue(Metrology.get('test') is not None)

    def test_counter(self):
        self.assertTrue(Metrology.counter('test') is not None)

    def test_meter(self):
        self.assertTrue(Metrology.meter('test') is not None)

    def test_gauge(self):
        self.assertTrue(Metrology.gauge('test', Gauge) is not None)

    def test_timer(self):
        self.assertTrue(Metrology.timer('test') is not None)

    def test_utilization_timer(self):
        self.assertTrue(Metrology.utilization_timer('test') is not None)

    def test_histogram(self):
        self.assertTrue(Metrology.histogram('test') is not None)

    def test_health_check(self):
        health = Metrology.health_check('test', HealthCheck)
        self.assertTrue(health is not None)

########NEW FILE########
__FILENAME__ = test_registry
from unittest import TestCase

from metrology.registry import Registry
from metrology.instruments.gauge import Gauge
from metrology.instruments.healthcheck import HealthCheck


class DummyGauge(Gauge):
    def value(self):
        return "wow"


class DummyHealthCheck(HealthCheck):
    def check(self):
        return True


class RegistryTest(TestCase):
    def setUp(self):
        self.registry = Registry()

    def tearDown(self):
        self.registry.stop()

    def test_counter(self):
        self.assertTrue(self.registry.counter('test') is not None)

    def test_meter(self):
        self.assertTrue(self.registry.meter('test') is not None)

    def test_gauge(self):
        self.assertTrue(self.registry.gauge('test', DummyGauge()) is not None)

    def test_timer(self):
        self.assertTrue(self.registry.timer('test') is not None)

    def test_utilization_timer(self):
        self.assertTrue(self.registry.utilization_timer('test') is not None)

    def test_histogram(self):
        self.assertTrue(self.registry.histogram('test') is not None)

    def test_health_check(self):
        health = self.registry.health_check('test', DummyHealthCheck())
        self.assertTrue(health is not None)

########NEW FILE########
