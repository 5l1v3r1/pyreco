__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# django-getpaid documentation build configuration file, created by
# sphinx-quickstart on Mon Jul 16 21:16:46 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

sys.path.append(os.path.join(
                        os.path.join(os.path.dirname(__file__), os.pardir),
                        os.pardir
                    )
                )
sys.path.append( os.path.join(
                                os.path.join(
                                        os.path.join(os.path.dirname(__file__), os.pardir),
                                        os.pardir
                                ),
                                'getpaid_test_project'
                        )
                )

#import django
os.environ.setdefault("DJANGO_SETTINGS_MODULE", "getpaid_test_project.settings_docs")

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'django-getpaid'
copyright = u'2012-2013, Krzysztof Dorosz'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '1.6.0'
# The full version, including alpha/beta/rc tags.
release = '1.6.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'django-getpaiddoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'django-getpaid.tex', u'django-getpaid Documentation',
   u'Krzysztof Dorosz', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'django-getpaid', u'django-getpaid Documentation',
     [u'Krzysztof Dorosz'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'django-getpaid', u'django-getpaid Documentation',
   u'Krzysztof Dorosz', 'django-getpaid', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = abstract_mixin
#
# This work by Patryk Zawadzki is licensed under a Creative Commons
# Attribution-NonCommercial-ShareAlike 2.5 Poland.
#
# taken from:
# http://room-303.com/blog/2010/04/27/django-abstrakcji-ciag-dalszy/
# http://gist.github.com/584106
#


class AbstractMixin(object):
    _classcache = {}

    @classmethod
    def contribute(cls):
        return {}

    @classmethod
    def construct(cls, *args, **kwargs):
        attrs = cls.contribute(*args, **kwargs)
        attrs.update({
            '__module__': cls.__module__,
            'Meta': type('Meta', (), {'abstract': True}),
        })
        key = (args, tuple(kwargs.items()))
        if not key in cls._classcache:
            clsname = ('%s%x' % (cls.__name__, hash(key))) \
                .replace('-', '_')
            cls._classcache[key] = type(clsname, (cls, ), attrs)
        return cls._classcache[key]

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from getpaid.models import Payment


class PaymentAdmin(admin.ModelAdmin):
    list_display = ('id', 'amount', 'currency', 'status', 'created_on', 'paid_on', 'amount_paid')
    list_filter = ('status', 'created_on', 'paid_on')
    search_fields = ('id', )
    raw_id_fields = ('order', )


admin.site.register(Payment, PaymentAdmin)

########NEW FILE########
__FILENAME__ = models
def build_models(payment_class):
    return []

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url
from django.views.decorators.csrf import csrf_exempt
from getpaid.backends.dotpay.views import ReturnView
from getpaid.backends.dotpay.views import OnlineView

urlpatterns = patterns('',
    url(r'^online/$', csrf_exempt(OnlineView.as_view()), name='getpaid-dotpay-online'),
    url(r'^return/(?P<pk>\d+)/$', csrf_exempt(ReturnView.as_view()), name='getpaid-dotpay-return'),

)

########NEW FILE########
__FILENAME__ = views
import logging
from django.core.urlresolvers import reverse
from django.http import HttpResponse, HttpResponseRedirect
from django.views.generic.base import View
from django.views.generic.detail import DetailView
from getpaid.backends.dotpay import PaymentProcessor
from getpaid.models import Payment

logger = logging.getLogger('getpaid.backends.dotpay')


class OnlineView(View):
    """
    This View answers on PayU online request that is acknowledge of payment
    status change.

    The most important logic of this view is delegated to ``PaymentProcessor.online()`` method
    """
    def post(self, request, *args, **kwargs):

        try:
            params = {
                'id': request.POST['id'],
                'status': request.POST['status'],
                'control': request.POST['control'],
                't_id': request.POST['t_id'],
                'amount': request.POST['amount'],
                'email': request.POST['email'],

                'orginal_amount': request.POST['orginal_amount'],
                't_status': request.POST['t_status'],
                'md5': request.POST['md5'],


                'service': request.POST.get('service', ''),
                'code': request.POST.get('code', ''),
                'username': request.POST.get('username', ''),
                'password': request.POST.get('password', ''),

            }
        except KeyError:
            logger.warning('Got malformed POST request: %s' % str(request.POST))
            return HttpResponse('MALFORMED')

        status = PaymentProcessor.online(params, ip=request.META['REMOTE_ADDR'])
        return HttpResponse(status)


class ReturnView(DetailView):
    """
    This view just redirects to standard backend success or failure link.
    """
    model = Payment

    def post(self, request, *args, **kwargs):
        return self.get(request, *args, **kwargs)

    def render_to_response(self, context, **response_kwargs):
        if self.request.POST['status'] == 'OK':
            return HttpResponseRedirect(reverse('getpaid-success-fallback', kwargs={'pk': self.object.pk}))
        else:
            return HttpResponseRedirect(reverse('getpaid-failure-fallback', kwargs={'pk': self.object.pk}))

########NEW FILE########
__FILENAME__ = forms
from django.forms import forms
from django.forms.fields import ChoiceField
from django.utils.translation import ugettext as _


class DummyQuestionForm(forms.Form):
    """
    This dummy form asks for payment authorization.
    """
    authorize_payment = ChoiceField(label=_("authorization"), choices=((1, _('yes')), (0, _('no'))))

########NEW FILE########
__FILENAME__ = models
def build_models(payment_class):
    """
    Here you can dynamically build a Model class that needs to have ForeignKey to Payment model
    """
    return []

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url
from getpaid.backends.dummy.views import DummyAuthorizationView

urlpatterns = patterns('',
    url(r'^payment/authorization/(?P<pk>[0-9]+)/$', DummyAuthorizationView.as_view(), name='getpaid-dummy-authorization'),
)

########NEW FILE########
__FILENAME__ = views
from django.core.urlresolvers import reverse
from django.shortcuts import get_object_or_404
from django.views.generic.edit import FormView
from getpaid.backends.dummy import PaymentProcessor
from getpaid.backends.dummy.forms import DummyQuestionForm
from getpaid.models import Payment


class DummyAuthorizationView(FormView):
    form_class = DummyQuestionForm
    template_name = "getpaid_dummy_backend/dummy_authorization.html"

    def get_context_data(self, **kwargs):
        context = super(DummyAuthorizationView, self).get_context_data(**kwargs)
        self.payment = get_object_or_404(Payment, pk=self.kwargs['pk'], status='in_progress', backend='getpaid.backends.dummy')
        context['payment'] = self.payment
        context['order'] = self.payment.order
        context['order_name'] = PaymentProcessor(self.payment).get_order_description(self.payment, self.payment.order)  # TODO: Refactoring of get_order_description needed, should not require payment arg
        return context

    def get_success_url(self):
        url = None
        if self.success:
            url = reverse('getpaid-success-fallback', kwargs={'pk': self.payment.pk})
        else:
            url = reverse('getpaid-failure-fallback', kwargs={'pk': self.payment.pk})
        return url

    def form_valid(self, form):
        # Change payment status and jump to success_url or failure_url
        self.payment = get_object_or_404(Payment, pk=self.kwargs['pk'], status='in_progress', backend='getpaid.backends.dummy')

        if form.cleaned_data['authorize_payment'] == '1':
            self.success = True
            if not self.payment.on_success():
                # This method returns if payment was fully paid
                # if it is not, we should alert user that payment was not successfully ended anyway
                self.success = False
        else:
            self.success = False
            self.payment.on_failure()
        return super(DummyAuthorizationView, self).form_valid(form)

########NEW FILE########
__FILENAME__ = models
def build_models(payment_class):
    return []

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url
from django.views.decorators.csrf import csrf_exempt
from getpaid.backends.moip.views import NotificationsView, SuccessView

urlpatterns = patterns('',
    url(r'^notifications/$', csrf_exempt(NotificationsView.as_view()), name='getpaid-moip-notifications'),
    url(r'^success/(?P<pk>\d+)/$', csrf_exempt(SuccessView.as_view()), name='getpaid-moip-success'),
)

########NEW FILE########
__FILENAME__ = views
import logging
from django.core.urlresolvers import reverse
from django.http import HttpResponse, Http404, HttpResponseRedirect
from django.views.generic import DetailView
from django.views.generic.base import View
from getpaid.backends.moip import PaymentProcessor
from getpaid.models import Payment

logger = logging.getLogger('getpaid.backends.moip')


class NotificationsView(View):
    """
    This view answers on Moip notifications requests.
    See http://labs.moip.com.br/referencia/nasp/

    The most important logic of this view is delegated to the
    ``PaymentProcessor.processNotification()`` method
    """
    def post(self, request, *args, **kwargs):
        try:
            params = {
                'id': request.POST['id_transacao'],
                'amount': request.POST['valor'],
                'status': request.POST['status_pagamento'],
                'moip_id': request.POST['cod_moip'],
                'email': request.POST['email_consumidor'],
            }
        except KeyError:
            logger.warning('Got malformed POST request: %s' % str(request.POST))
            raise Http404

        status = PaymentProcessor.process_notification(params)
        return HttpResponse(status)


class SuccessView(DetailView):
    """
    This view just redirects to standard backend success link.
    """
    model = Payment

    def render_to_response(self, context, **response_kwargs):
        return HttpResponseRedirect(reverse('getpaid-success-fallback', kwargs={'pk': self.object.pk}))

########NEW FILE########
__FILENAME__ = forms
from django import forms


class PaymillForm(forms.Form):
    token = forms.CharField(widget=forms.HiddenInput())

########NEW FILE########
__FILENAME__ = models
def build_models(payment_class):
    return []

########NEW FILE########
__FILENAME__ = tests
"""
This file demonstrates writing tests using the unittest module. These will pass
when you run "manage.py test".

Replace this with more appropriate tests for your application.
"""

from django.test import TestCase


class SimpleTest(TestCase):
    def test_basic_addition(self):
        """
        Tests that 1 + 1 always equals 2.
        """
        self.assertEqual(1 + 1, 2)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url
from getpaid.backends.paymill.views import PaymillView

urlpatterns = patterns('',
    url(r'^payment/authorization/(?P<pk>[0-9]+)/$', PaymillView.as_view(), name='getpaid-paymill-authorization'),
)

########NEW FILE########
__FILENAME__ = views
from django.core.urlresolvers import reverse
from django.shortcuts import get_object_or_404
from django.views.generic.edit import FormView
from . import PaymentProcessor
from .forms import PaymillForm
from getpaid.models import Payment
import pymill


class PaymillView(FormView):
    form_class = PaymillForm
    template_name = 'getpaid_paymill_backend/paymill.html'

    def get_context_data(self, **kwargs):
        context = super(PaymillView, self).get_context_data(**kwargs)
        self.payment = get_object_or_404(Payment, pk=self.kwargs['pk'], status='in_progress', backend='getpaid.backends.paymill')
        context['payment'] = self.payment
        context['amount_int'] = int(self.payment.amount * 100)
        context['order'] = self.payment.order
        context['order_name'] = PaymentProcessor(self.payment).get_order_description(self.payment, self.payment.order)  # TODO: Refactoring of get_order_description needed, should not require payment arg
        context['PAYMILL_PUBLIC_KEY'] = PaymentProcessor.get_backend_setting('PAYMILL_PUBLIC_KEY')
        return context

    def get_success_url(self):
        url = None
        if self.success:
            url = reverse('getpaid-success-fallback', kwargs={'pk': self.payment.pk})
        else:
            url = reverse('getpaid-failure-fallback', kwargs={'pk': self.payment.pk})
        return url

    def form_valid(self, form):
        # Change payment status and jump to success_url or failure_url
        self.payment = get_object_or_404(Payment, pk=self.kwargs['pk'], status='in_progress', backend='getpaid.backends.paymill')

        pmill = pymill.Pymill(PaymentProcessor.get_backend_setting('PAYMILL_PRIVATE_KEY'))

        token = form.cleaned_data['token']
        card = pmill.new_card(token)

        amount = int(self.payment.amount * 100)
        currency = self.payment.currency

        transaction = pmill.transact(amount, payment=card, currency=currency)

        if transaction:
            self.success = True
            if not self.payment.on_success():
                # This method returns if payment was fully paid
                # if it is not, we should alert user that payment was not successfully ended anyway
                self.success = False
        else:
            self.success = False
            self.payment.on_failure()
        return super(PaymillView, self).form_valid(form)

########NEW FILE########
__FILENAME__ = payu_configuration
from django.contrib.sites.models import Site
from django.core.management.base import BaseCommand
from django.core.urlresolvers import reverse
from getpaid.backends.payu import PaymentProcessor


class Command(BaseCommand):
    help = 'Display URL path for PayU Online URL configuration'

    def handle(self, *args, **options):

        current_site = Site.objects.get_current()

        self.stdout.write('Login to PayU configuration page and setup following links:\n\n')
        self.stdout.write(' * Success URL: http://%s%s\n                https://%s%s\n\n' % (
            current_site.domain,
            reverse('getpaid-payu-success', kwargs={'pk': 1234}).replace('1234', '%orderId%'),
            current_site.domain,
            reverse('getpaid-payu-success', kwargs={'pk': 1234}).replace('1234', '%orderId%'),

            )
        )

        self.stdout.write(' * Failure URL: http://%s%s\n                https://%s%s\n\n' % (
            current_site.domain,
            reverse('getpaid-payu-failure', kwargs={'pk': 1234, 'error': 9999}).replace('1234', r'%orderId%').replace('9999', r'%error%'),
            current_site.domain,
            reverse('getpaid-payu-failure', kwargs={'pk': 1234, 'error': 9999}).replace('1234', r'%orderId%').replace('9999', r'%error%'),
            )

        )

        self.stdout.write(' * Online  URL: http://%s%s\n                https://%s%s\n\n' % (
            current_site.domain,
            reverse('getpaid-payu-online'),
            current_site.domain,
            reverse('getpaid-payu-online'),
            )
        )

        self.stdout.write('To change domain name please edit Sites settings. Don\'t forget to setup your web server to accept https connection in order to use secure links.\n')
        if PaymentProcessor.get_backend_setting('testing', False):
            self.stdout.write('\nTesting mode is ON\nPlease be sure that you enabled testing payments in PayU configuration page.\n')
        if PaymentProcessor.get_backend_setting('signing', False):
            self.stdout.write('\nRequest signing is ON\n * Please be sure that you enabled signing payments in PayU configuration page.\n')

########NEW FILE########
__FILENAME__ = models
def build_models(payment_class):
    return []

########NEW FILE########
__FILENAME__ = tasks
import logging
from celery.task.base import task
from django.db.models.loading import get_model


logger = logging.getLogger('getpaid.backends.payu')


@task(max_retries=50, default_retry_delay=2*60)
def get_payment_status_task(payment_id, session_id):
    Payment = get_model('getpaid', 'Payment')
    try:
        payment = Payment.objects.get(pk=int(payment_id))
    except Payment.DoesNotExist:
        logger.error('Payment does not exist pk=%d' % payment_id)
        return
    from getpaid.backends.payu import PaymentProcessor # Avoiding circular import
    processor = PaymentProcessor(payment)
    processor.get_payment_status(session_id)


@task(max_retries=50, default_retry_delay=2 * 60)
def accept_payment(payment_id, session_id):
    Payment = get_model('getpaid', 'Payment')
    try:
        payment = Payment.objects.get(pk=int(payment_id))
    except Payment.DoesNotExist:
        logger.error('Payment does not exist pk=%d' % payment_id)
        return

    from getpaid.backends.payu import PaymentProcessor # Avoiding circular import
    processor = PaymentProcessor(payment)
    processor.accept_payment(session_id)
########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url
from django.views.decorators.csrf import csrf_exempt
from getpaid.backends.payu.views import OnlineView, SuccessView, FailureView

urlpatterns = patterns('',
    url(r'^online/$', csrf_exempt(OnlineView.as_view()), name='getpaid-payu-online'),
    url(r'^success/(?P<pk>\d+)/', csrf_exempt(SuccessView.as_view()), name='getpaid-payu-success'),
    url(r'^failure/(?P<pk>\d+)/(?P<error>\d+)/', csrf_exempt(FailureView.as_view()), name='getpaid-payu-failure'),

)

########NEW FILE########
__FILENAME__ = views
import logging
from django.core.urlresolvers import reverse
from django.http import HttpResponse, HttpResponseRedirect
from django.views.generic.base import View
from django.views.generic.detail import DetailView
from getpaid.backends.payu import PaymentProcessor
from getpaid.models import Payment

logger = logging.getLogger('getpaid.backends.payu')


class OnlineView(View):
    """
    This View answers on PayU online request that is acknowledge of payment
    status change.

    The most important logic of this view is delegated to ``PaymentProcessor.online()`` method
    """
    def post(self, request, *args, **kwargs):
        try:
            pos_id = request.POST['pos_id']
            session_id = request.POST['session_id']
            ts = request.POST['ts']
            sig = request.POST['sig']
        except KeyError:
            logger.warning('Got malformed POST request: %s' % str(request.POST))
            return HttpResponse('MALFORMED')

        status = PaymentProcessor.online(pos_id, session_id, ts, sig)
        return HttpResponse(status)


class SuccessView(DetailView):
    """
    This view just redirects to standard backend success link.
    """
    model = Payment

    def render_to_response(self, context, **response_kwargs):
        return HttpResponseRedirect(reverse('getpaid-success-fallback', kwargs={'pk': self.object.pk}))


class FailureView(DetailView):
    """
    This view just redirects to standard backend failure link.
    """
    model = Payment

    def render_to_response(self, context, **response_kwargs):
        logger.error("Payment %s failed on backend error %s" % (self.kwargs['pk'], self.kwargs['error']))
        return HttpResponseRedirect(reverse('getpaid-failure-fallback', kwargs={'pk': self.object.pk}))

########NEW FILE########
__FILENAME__ = przelewy24_configuration
from django.contrib.sites.models import Site
from django.core.management.base import BaseCommand
from django.core.urlresolvers import reverse
from getpaid.backends.przelewy24 import PaymentProcessor


class Command(BaseCommand):
    help = 'Additional Przelewy24 configuration'

    def handle(self, *args, **options):
        current_site = Site.objects.get_current()

        self.stdout.write(
            'Please contact with Przelewy24 (serwis@przelewy24.pl) and provide them with the following URL: \n\n')

        self.stdout.write(
            ('https://' if PaymentProcessor.get_backend_setting('ssl_return', False) else 'http://') + '%s%s\n\n' % (
                current_site.domain, reverse('getpaid-przelewy24-online'))
        )

        self.stdout.write(
            'This is an additional URL for accepting payment status updates.\n\n')

        self.stdout.write(
            'To change domain name please edit Sites settings. Don\'t forget to setup your web server to accept https connection in order to use secure links.\n')
        if PaymentProcessor.get_backend_setting('sandbox', False):
            self.stdout.write('\nSandbox mode is ON.\n')

########NEW FILE########
__FILENAME__ = models
def build_models(payment_class):
    return []

########NEW FILE########
__FILENAME__ = tasks
import logging
from celery.task.base import task
from django.db.models.loading import get_model

logger = logging.getLogger('getpaid.backends.przelewy24')


@task
def get_payment_status_task(payment_id, p24_session_id, p24_order_id, p24_kwota):
    Payment = get_model('getpaid', 'Payment')
    try:
        payment = Payment.objects.get(pk=int(payment_id))
    except Payment.DoesNotExist:
        logger.error('Payment does not exist pk=%d' % payment_id)
        return

    from getpaid.backends.przelewy24 import PaymentProcessor  # Avoiding circular import
    processor = PaymentProcessor(payment)
    processor.get_payment_status(p24_session_id, p24_order_id, p24_kwota)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url
from django.views.decorators.csrf import csrf_exempt
from getpaid.backends.przelewy24.views import OnlineView, SuccessView, FailureView

urlpatterns = patterns('',
    url(r'^online/$', csrf_exempt(OnlineView.as_view()), name='getpaid-przelewy24-online'),
    url(r'^success/(?P<pk>\d+)/', csrf_exempt(SuccessView.as_view()), name='getpaid-przelewy24-success'),
    url(r'^failure/(?P<pk>\d+)/', csrf_exempt(FailureView.as_view()), name='getpaid-przelewy24-failure'),

)

########NEW FILE########
__FILENAME__ = views
import logging
from django.core.urlresolvers import reverse
from django.http import HttpResponse, HttpResponseRedirect
from django.views.generic.base import View
from django.views.generic.detail import DetailView
from getpaid.backends.przelewy24 import PaymentProcessor
from getpaid.models import Payment

logger = logging.getLogger('getpaid.backends.przelewy24')


class OnlineView(View):
    """
    This View answers on Przelewy24 online request that is acknowledge of payment
    status change.
    """

    def post(self, request, *args, **kwargs):
        try:
            p24_session_id = request.POST['p24_session_id']
            p24_order_id = request.POST['p24_order_id']
            p24_kwota = request.POST['p24_kwota']
            p24_order_id_full = request.POST['p24_order_id_full']
            p24_crc = request.POST['p24_crc']
        except KeyError:
            logger.warning('Got malformed POST request: %s' % str(request.POST))
            return HttpResponse('MALFORMED', status=500)

        if PaymentProcessor.on_payment_status_change(p24_session_id, p24_order_id, p24_kwota, p24_order_id_full,
                                                     p24_crc):
            return HttpResponse('OK')
        else:
            return HttpResponse('CRC ERR')


class SuccessView(DetailView):
    """
    This view just redirects to standard backend success link after it schedule payment status checking.
    """
    model = Payment

    def get(self, request, *args, **kwargs):
        return HttpResponse('GET not allowed')

    def post(self, request, *args, **kwargs):
        try:
            p24_session_id = request.POST['p24_session_id']
            p24_order_id = request.POST['p24_order_id']
            p24_kwota = request.POST['p24_kwota']
            p24_order_id_full = request.POST['p24_order_id_full']
            p24_crc = request.POST['p24_crc']
        except KeyError:
            logger.warning('Got malformed POST request: %s' % str(request.POST))
            return HttpResponse('MALFORMED', status=500)

        PaymentProcessor.on_payment_status_change(p24_session_id, p24_order_id, p24_kwota, p24_order_id_full, p24_crc)

        self.object = self.get_object()
        context = self.get_context_data(object=self.object)
        return self.render_to_response(context)

    def render_to_response(self, context, **response_kwargs):
        return HttpResponseRedirect(reverse('getpaid-success-fallback', kwargs={'pk': self.object.pk}))


class FailureView(DetailView):
    """
    This view just redirects to standard backend failure link after it schedule payment status checking.
    """
    model = Payment

    def post(self, request, *args, **kwargs):
        try:
            p24_session_id = request.POST['p24_session_id']
            p24_order_id = request.POST['p24_order_id']
            p24_kwota = request.POST['p24_kwota']
            p24_order_id_full = request.POST['p24_order_id_full']
            p24_crc = request.POST['p24_crc']
        except KeyError:
            logger.warning('Got malformed POST request: %s' % str(request.POST))
            return HttpResponse('MALFORMED', status=500)

        PaymentProcessor.on_payment_status_change(p24_session_id, p24_order_id, p24_kwota, p24_order_id_full, p24_crc)

        self.object = self.get_object()
        context = self.get_context_data(object=self.object)
        return self.render_to_response(context)

    def render_to_response(self, context, **response_kwargs):
        logger.error("Payment %s failed on backend error" % (self.kwargs['pk'],))
        return HttpResponseRedirect(reverse('getpaid-failure-fallback', kwargs={'pk': self.object.pk}))

########NEW FILE########
__FILENAME__ = transferuj_configuration
from django.core.management.base import BaseCommand
from getpaid.backends.transferuj import PaymentProcessor


class Command(BaseCommand):
    help = 'Display URL path for Transferuj.pl Online URL configuration'

    def handle(self, *args, **options):

        key = PaymentProcessor.get_backend_setting('key', None)
        if key is None:
            self.stdout.write('Please be sure to provide "key" setting for this backend (random max. 16 characters)')
        else:
            self.stdout.write('Please setup in Transferuj.pl user defined key (for security signing): %s\n' % key)

########NEW FILE########
__FILENAME__ = models
def build_models(payment_class):
    return []

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url
from django.views.decorators.csrf import csrf_exempt
from getpaid.backends.transferuj.views import OnlineView, SuccessView, FailureView

urlpatterns = patterns('',
    url(r'^online/$', csrf_exempt(OnlineView.as_view()), name='getpaid-transferuj-online'),
    url(r'^success/(?P<pk>\d+)/$', csrf_exempt(SuccessView.as_view()), name='getpaid-transferuj-success'),
    url(r'^failure/(?P<pk>\d+)/$', csrf_exempt(FailureView.as_view()), name='getpaid-transferuj-failure'),

)

########NEW FILE########
__FILENAME__ = views
import logging
from django.core.urlresolvers import reverse
from django.http import HttpResponse, HttpResponseRedirect
from django.views.generic.base import View
from django.views.generic.detail import DetailView
from getpaid.backends.transferuj import PaymentProcessor
from getpaid.models import Payment

logger = logging.getLogger('getpaid.backends.transferuj')


class OnlineView(View):
    """
    This View answers on Transferuj.pl payment status change request

    The most important logic of this view is delegated to ``PaymentProcessor.online()`` method
    """
    def post(self, request, *args, **kwargs):
        try:
            id = request.POST['id']
            tr_id = request.POST['tr_id']
            tr_date = request.POST['tr_date']
            tr_crc = request.POST['tr_crc']
            tr_amount = request.POST['tr_amount']
            tr_paid = request.POST['tr_paid']
            tr_desc = request.POST['tr_desc']
            tr_status = request.POST['tr_status']
            tr_error = request.POST['tr_error']
            tr_email = request.POST['tr_email']
            md5sum = request.POST['md5sum']
        except KeyError:
            logger.warning('Got malformed POST request: %s' % str(request.POST))
            return HttpResponse('MALFORMED')

        status = PaymentProcessor.online(request.META['REMOTE_ADDR'], id, tr_id, tr_date, tr_crc, tr_amount, tr_paid, tr_desc, tr_status, tr_error, tr_email, md5sum)
        return HttpResponse(status)


class SuccessView(DetailView):
    """
    This view just redirects to standard backend success link.
    """
    model = Payment

    def render_to_response(self, context, **response_kwargs):
        return HttpResponseRedirect(reverse('getpaid-success-fallback', kwargs={'pk': self.object.pk}))


class FailureView(DetailView):
    """
    This view just redirects to standard backend failure link.
    """
    model = Payment

    def render_to_response(self, context, **response_kwargs):
        return HttpResponseRedirect(reverse('getpaid-failure-fallback', kwargs={'pk': self.object.pk}))

########NEW FILE########
__FILENAME__ = forms
from django.conf import settings
from django.core.exceptions import ValidationError
from django.forms import forms
from django.forms.fields import ChoiceField, CharField
from django.forms.models import ModelChoiceField
from django.forms.widgets import HiddenInput, RadioSelect, RadioFieldRenderer, RadioInput
from django.utils.encoding import force_unicode
from django.utils.safestring import mark_safe
from django.utils.translation import ugettext as _
from getpaid.models import Order
from utils import get_backend_choices, import_name


class PaymentRadioInput(RadioInput):
    def __init__(self, name, value, attrs, choice, index):
        super(PaymentRadioInput, self).__init__(name, value, attrs, choice, index)
        logo_url = import_name(choice[0]).PaymentProcessor.get_logo_url()
        if logo_url:
            self.choice_label = mark_safe('<img src="%s%s" alt="%s">' % (
                getattr(settings, 'STATIC_URL', ''),
                logo_url,
                force_unicode(choice[1]),
                )
            )


class PaymentRadioFieldRenderer(RadioFieldRenderer):
    def __iter__(self):
        for i, choice in enumerate(self.choices):
            yield PaymentRadioInput(self.name, self.value, self.attrs.copy(), choice, i)

    def __getitem__(self, idx):
        choice = self.choices[idx]  # Let the IndexError propogate
        return PaymentRadioInput(self.name, self.value, self.attrs.copy(), choice, idx)


class PaymentRadioSelect(RadioSelect):
    renderer = PaymentRadioFieldRenderer


class PaymentMethodForm(forms.Form):
    """
    Displays all available payments backends as choice list.
    """

    def __init__(self, currency, *args, **kwargs):
        super(PaymentMethodForm, self).__init__(*args, **kwargs)
        backends = get_backend_choices(currency)
        self.fields['backend'] = ChoiceField(
            choices=backends,
            initial=backends[0][0] if len(backends) else '',
            label=_("Payment method"),
            widget=PaymentRadioSelect,
        )

    order = ModelChoiceField(widget=HiddenInput, queryset=Order.objects.all())

    def clean_order(self):
        if hasattr(self.cleaned_data['order'], 'is_ready_for_payment'):
            if not self.cleaned_data['order'].is_ready_for_payment():
                raise ValidationError(_('Order cannot be paid'))
        return self.cleaned_data['order']


class PaymentHiddenInputsPostForm(forms.Form):
    def __init__(self, items, *args, **kwargs):
        super(PaymentHiddenInputsPostForm, self).__init__(*args, **kwargs)

        for key in items:
            self.fields[key] = CharField(initial=items[key], widget=HiddenInput)

########NEW FILE########
__FILENAME__ = middleware
class SetRemoteAddrFromForwardedForMiddleware(object):
    def process_request(self, request):
        try:
            real_ip = request.META['HTTP_X_FORWARDED_FOR']
        except KeyError:
            pass
        else:
            # HTTP_X_FORWARDED_FOR can be a comma-separated list of IPs.
            # Take just the first one.
            real_ip = real_ip.split(",")[0]
            request.META['REMOTE_ADDR'] = real_ip

########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.utils.timezone import utc
from django.utils.translation import ugettext_lazy as _
from datetime import datetime
import sys
from abstract_mixin import AbstractMixin
import signals
from utils import import_backend_modules
from django.conf import settings

PAYMENT_STATUS_CHOICES = (
        ('new', _("new")),
        ('in_progress', _("in progress")),
        ('partially_paid', _("partially paid")),
        ('paid', _("paid")),
        ('failed', _("failed")),
        )


class PaymentManager(models.Manager):
    def get_query_set(self):
        return super(PaymentManager, self).get_query_set().select_related('order')


class PaymentFactory(models.Model, AbstractMixin):
    """
    This is an abstract class that defines a structure of Payment model that will be
    generated dynamically with one additional field: ``order``
    """
    amount = models.DecimalField(_("amount"), decimal_places=4, max_digits=20)
    currency = models.CharField(_("currency"), max_length=3)
    status = models.CharField(_("status"), max_length=20, choices=PAYMENT_STATUS_CHOICES, default='new', db_index=True)
    backend = models.CharField(_("backend"), max_length=50)
    created_on = models.DateTimeField(_("created on"), auto_now_add=True, db_index=True)
    paid_on = models.DateTimeField(_("paid on"), blank=True, null=True, default=None, db_index=True)
    amount_paid = models.DecimalField(_("amount paid"), decimal_places=4, max_digits=20, default=0)
    external_id = models.CharField(_("external id"), max_length=64, blank=True, null=True)
    description = models.CharField(_("description"), max_length=128, blank=True, null=True)

    class Meta:
        abstract = True

    def __unicode__(self):
        return _("Payment #%(id)d") % {'id': self.id}

    @classmethod
    def contribute(cls, order, **kwargs):
        return {'order': models.ForeignKey(order, **kwargs)}

    @classmethod
    def create(cls, order, backend):
        """
            Builds Payment object based on given Order instance
        """
        payment = Payment()
        payment.order = order
        payment.backend = backend
        signals.new_payment_query.send(sender=None, order=order, payment=payment)
        if payment.currency is None or payment.amount is None:
            raise NotImplementedError('Please provide a listener for getpaid.signals.new_payment_query')
        payment.save()
        signals.new_payment.send(sender=None, order=order, payment=payment)
        return payment

    def get_processor(self):
        try:
            __import__(self.backend)
            module = sys.modules[self.backend]
            return module.PaymentProcessor
        except (ImportError, AttributeError):
            raise ValueError("Backend '%s' is not available or provides no processor." % self.backend)

    def change_status(self, new_status):
        """
        Always change payment status via this method. Otherwise the signal
        will not be emitted.
        """
        if self.status != new_status:
            # do anything only when status is really changed
            old_status = self.status
            self.status = new_status
            self.save()
            signals.payment_status_changed.send(
                sender=type(self), instance=self,
                old_status=old_status, new_status=new_status
            )

    def on_success(self, amount=None):
        """
        Called when payment receives successful balance income. It defaults to
        complete payment, but can optionally accept received amount as a parameter
        to handle partial payments.

        Returns boolean value if payment was fully paid
        """
        if getattr(settings, 'USE_TZ', False):
            self.paid_on = datetime.utcnow().replace(tzinfo=utc)
        else:
            self.paid_on = datetime.now()
        if amount:
            self.amount_paid = amount
        else:
            self.amount_paid = self.amount
        fully_paid = (self.amount_paid >= self.amount)
        if fully_paid:
            self.change_status('paid')
        else:
            self.change_status('partially_paid')
        return fully_paid

    def on_failure(self):
        """
        Called when payment was failed
        """
        self.change_status('failed')


from django.db.models.loading import cache as app_cache, register_models
#from utils import import_backend_modules


def register_to_payment(order_class, **kwargs):
    """
    A function for registering unaware order class to ``getpaid``. This will
    generate a ``Payment`` model class that will store payments with
    ForeignKey to original order class

    This also will build a model class for every enabled backend.
    """
    global Payment
    global Order

    class Payment(PaymentFactory.construct(order=order_class, **kwargs)):
        objects = PaymentManager()

        class Meta:
            ordering = ('-created_on',)
            verbose_name = _("Payment")
            verbose_name_plural = _("Payments")

    Order = order_class

    # Now build models for backends

    backend_models_modules = import_backend_modules('models')
    for backend_name, models in backend_models_modules.items():
        app_cache.register_models(backend_name, *models.build_models(Payment))
    return Payment

########NEW FILE########
__FILENAME__ = signals
from django.dispatch import Signal

new_payment_query = Signal(providing_args=['order', 'payment'])
new_payment_query.__doc__ = """
Sent to ask for filling Payment object with additional data:
    payment.amount:			total amount of an order
    payment.currency:		amount currency

This data cannot be filled by ``getpaid`` because it is Order structure
agnostic. After filling values just do return.
"""

user_data_query = Signal(providing_args=['order', 'user_data'])
new_payment_query.__doc__ = """
Sent to ask for filling user additional data:
    user_data['email']:		user email
    user_data['lang']:      lang code in ISO 2-char format

This data cannot be filled by ``getpaid`` because it is Order structure
agnostic. After filling values just do return.
"""

new_payment = Signal(providing_args=['order', 'payment'])
new_payment.__doc__ = """Sent after creating new payment."""


payment_status_changed = Signal(providing_args=['old_status', 'new_status'])
payment_status_changed.__doc__ = """Sent when Payment status changes."""


redirecting_to_payment_gateway_signal = Signal(providing_args=['request', 'order', 'payment', 'backend'])
redirecting_to_payment_gateway_signal.__doc__ = """
Sent just a moment before redirecting. A hook for analytics tools.
"""

########NEW FILE########
__FILENAME__ = tests
"""
This file demonstrates writing tests using the unittest module. These will pass
when you run "manage.py test".

Replace this with more appropriate tests for your application.
"""

from decimal import Decimal
from django.core.urlresolvers import reverse
from django.db.models.loading import get_model

from django.test import TestCase
from django.test.client import Client
import mock
from getpaid.backends import przelewy24
import getpaid.backends.payu
import getpaid.backends.transferuj

from getpaid_test_project.orders.models import Order


class TransferujBackendTestCase(TestCase):
    def test_online_not_allowed_ip(self):
        self.assertEqual('IP ERR',
                         getpaid.backends.transferuj.PaymentProcessor.online('0.0.0.0', None, None, None, None, None,
                                                                             None, None, None, None, None, None))

        #Tests allowing IP given in settings
        with self.settings(GETPAID_BACKENDS_SETTINGS={
            'getpaid.backends.transferuj': {'allowed_ip': ('1.1.1.1', '1.2.3.4'), 'key': ''},
        }):
            self.assertEqual('IP ERR',
                             getpaid.backends.transferuj.PaymentProcessor.online('0.0.0.0', None, None, None, None,
                                                                                 None, None, None, None, None, None,
                                                                                 None))
            self.assertNotEqual('IP ERR',
                                getpaid.backends.transferuj.PaymentProcessor.online('1.1.1.1', None, None, None, None,
                                                                                    None, None, None, None, None, None,
                                                                                    None))
            self.assertNotEqual('IP ERR',
                                getpaid.backends.transferuj.PaymentProcessor.online('1.2.3.4', None, None, None, None,
                                                                                    None, None, None, None, None, None,
                                                                                    None))

        #Tests allowing all IP
        with self.settings(GETPAID_BACKENDS_SETTINGS={
            'getpaid.backends.transferuj': {'allowed_ip': [], 'key': ''},
        }):
            self.assertNotEqual('IP ERR',
                                getpaid.backends.transferuj.PaymentProcessor.online('0.0.0.0', None, None, None, None,
                                                                                    None, None, None, None, None, None,
                                                                                    None))
            self.assertNotEqual('IP ERR',
                                getpaid.backends.transferuj.PaymentProcessor.online('1.1.1.1', None, None, None, None,
                                                                                    None, None, None, None, None, None,
                                                                                    None))
            self.assertNotEqual('IP ERR',
                                getpaid.backends.transferuj.PaymentProcessor.online('1.2.3.4', None, None, None, None,
                                                                                    None, None, None, None, None, None,
                                                                                    None))

    def test_online_wrong_sig(self):
        self.assertEqual('SIG ERR',
                         getpaid.backends.transferuj.PaymentProcessor.online('195.149.229.109', '1234', '1', '', '1',
                                                                             '123.45', None, None, None, None, None,
                                                                             'xxx'))
        self.assertNotEqual('SIG ERR',
                            getpaid.backends.transferuj.PaymentProcessor.online('195.149.229.109', '1234', '1', '', '1',
                                                                                '123.45', None, None, None, None, None,
                                                                                '21b028c2dbdcb9ca272d1cc67ed0574e'))

    def test_online_wrong_id(self):
        self.assertEqual('ID ERR',
                         getpaid.backends.transferuj.PaymentProcessor.online('195.149.229.109', '1111', '1', '', '1',
                                                                             '123.45', None, None, None, None, None,
                                                                             '15bb75707d4374bc6e578c0cbf5a7fc7'))
        self.assertNotEqual('ID ERR',
                            getpaid.backends.transferuj.PaymentProcessor.online('195.149.229.109', '1234', '1', '', '1',
                                                                                '123.45', None, None, None, None, None,
                                                                                'f5f8276fbaa98a6e05b1056ab7c3a589'))

    def test_online_crc_error(self):
        self.assertEqual('CRC ERR',
                         getpaid.backends.transferuj.PaymentProcessor.online('195.149.229.109', '1234', '1', '',
                                                                             '99999', '123.45', None, None, None, None,
                                                                             None, 'f5f8276fbaa98a6e05b1056ab7c3a589'))
        self.assertEqual('CRC ERR',
                         getpaid.backends.transferuj.PaymentProcessor.online('195.149.229.109', '1234', '1', '',
                                                                             'GRRGRRG', '123.45', None, None, None,
                                                                             None, None,
                                                                             '6a9e045010c27dfed24774b0afa37d0b'))

    def test_online_payment_ok(self):
        Payment = get_model('getpaid', 'Payment')
        order = Order(name='Test EUR order', total='123.45', currency='PLN')
        order.save()
        payment = Payment(order=order, amount=order.total, currency=order.currency, backend='getpaid.backends.payu')
        payment.save(force_insert=True)
        self.assertEqual('TRUE', getpaid.backends.transferuj.PaymentProcessor.online('195.149.229.109', '1234', '1', '',
                                                                                     payment.pk, '123.45', '123.45', '',
                                                                                     'TRUE', 0, '',
                                                                                     '21b028c2dbdcb9ca272d1cc67ed0574e'))
        payment = Payment.objects.get(pk=payment.pk)
        self.assertEqual(payment.status, 'paid')
        self.assertNotEqual(payment.paid_on, None)
        self.assertEqual(payment.amount_paid, Decimal('123.45'))

    def test_online_payment_ok_over(self):
        Payment = get_model('getpaid', 'Payment')
        order = Order(name='Test EUR order', total='123.45', currency='PLN')
        order.save()
        payment = Payment(order=order, amount=order.total, currency=order.currency, backend='getpaid.backends.payu')
        payment.save(force_insert=True)
        self.assertEqual('TRUE', getpaid.backends.transferuj.PaymentProcessor.online('195.149.229.109', '1234', '1', '',
                                                                                     payment.pk, '123.45', '223.45', '',
                                                                                     'TRUE', 0, '',
                                                                                     '21b028c2dbdcb9ca272d1cc67ed0574e'))
        payment = Payment.objects.get(pk=payment.pk)
        self.assertEqual(payment.status, 'paid')
        self.assertNotEqual(payment.paid_on, None)
        self.assertEqual(payment.amount_paid, Decimal('223.45'))

    def test_online_payment_partial(self):
        Payment = get_model('getpaid', 'Payment')
        order = Order(name='Test EUR order', total='123.45', currency='PLN')
        order.save()
        payment = Payment(order=order, amount=order.total, currency=order.currency, backend='getpaid.backends.payu')
        payment.save(force_insert=True)
        self.assertEqual('TRUE', getpaid.backends.transferuj.PaymentProcessor.online('195.149.229.109', '1234', '1', '',
                                                                                     payment.pk, '123.45', '23.45', '',
                                                                                     'TRUE', 0, '',
                                                                                     '21b028c2dbdcb9ca272d1cc67ed0574e'))
        payment = Payment.objects.get(pk=payment.pk)
        self.assertEqual(payment.status, 'partially_paid')
        self.assertNotEqual(payment.paid_on, None)
        self.assertEqual(payment.amount_paid, Decimal('23.45'))

    def test_online_payment_failure(self):
        Payment = get_model('getpaid', 'Payment')
        order = Order(name='Test EUR order', total='123.45', currency='PLN')
        order.save()
        payment = Payment(order=order, amount=order.total, currency=order.currency, backend='getpaid.backends.payu')
        payment.save(force_insert=True)
        self.assertEqual('TRUE', getpaid.backends.transferuj.PaymentProcessor.online('195.149.229.109', '1234', '1', '',
                                                                                     payment.pk, '123.45', '23.45', '',
                                                                                     False, 0, '',
                                                                                     '21b028c2dbdcb9ca272d1cc67ed0574e'))
        payment = Payment.objects.get(pk=payment.pk)
        self.assertEqual(payment.status, 'failed')


def fake_payment_get_response_success(request):
    class fake_response:
        def read(self):
            return """
status:OK
trans_id:234748067
trans_pos_id:123456789
trans_session_id:99:1342616247.41
trans_order_id:99
trans_amount:12345
trans_status:99
trans_pay_type:t
trans_pay_gw_name:pt
trans_desc:Test 2
trans_desc2:
trans_create:2012-07-18 14:57:28
trans_init:
trans_sent:
trans_recv:
trans_cancel:20trans_12-07-18 14:57:30
trans_auth_fraud:0
trans_ts:1342616255805
trans_sig:4d4df5557b89a4e2d8c48436b1dd3fef
"""

    return fake_response()


def fake_payment_get_response_failure(request):
    class fake_response:
        def read(self):
            return """
status:OK
trans_id:234748067
trans_pos_id:123456789
trans_session_id:98:1342616247.41
trans_order_id:98
trans_amount:12345
trans_status:2
trans_pay_type:t
trans_pay_gw_name:pt
trans_desc:Test 2
trans_desc2:
trans_create:2012-07-18 14:57:28
trans_init:
trans_sent:
trans_recv:
trans_cancel:2012-07-18 14:57:30
trans_auth_fraud:0
trans_ts:1342616255805
trans_sig:ee77e9515599e3fd2b3721dff50111dd
"""

    return fake_response()


class PayUBackendTestCase(TestCase):
    def setUp(self):
        self.client = Client()


    def test_parse_text_result(self):
        t1 = '''status:OK

trans_id:349659572
trans_pos_id:105664
trans_session_id:48:1379695300.48
trans_ts:1379695309225
trans_sig:e4e981bfa780fa78fb077ca1f9295f2a

        '''
        self.assertEqual(getpaid.backends.payu.PaymentProcessor._parse_text_response(t1),
                         {
                             'status': 'OK',
                             'trans_id': '349659572',
                             'trans_pos_id': '105664',
                             'trans_session_id': '48:1379695300.48',
                             'trans_ts': '1379695309225',
                             'trans_sig': 'e4e981bfa780fa78fb077ca1f9295f2a',
                         }
        )

    def test_online_malformed(self):
        response = self.client.post(reverse('getpaid-payu-online'), {})
        self.assertEqual(response.content, 'MALFORMED')

    def test_online_sig_err(self):
        response = self.client.post(reverse('getpaid-payu-online'), {
            'pos_id': 'wrong',
            'session_id': '10:11111',
            'ts': '1111',
            'sig': 'wrong sig',
        })
        self.assertEqual(response.content, 'SIG ERR')

    def test_online_wrong_pos_id_err(self):
        response = self.client.post(reverse('getpaid-payu-online'), {
            'pos_id': '12345',
            'session_id': '10:11111',
            'ts': '1111',
            'sig': '0d6129738c0aee9d4eb56f2a1db75ab4',
        })
        self.assertEqual(response.content, 'POS_ID ERR')

    def test_online_wrong_session_id_err(self):
        response = self.client.post(reverse('getpaid-payu-online'), {
            'pos_id': '123456789',
            'session_id': '111111',
            'ts': '1111',
            'sig': 'fcf3db081d5085b45fe86ed0c6a9aa5e',
        })
        self.assertEqual(response.content, 'SESSION_ID ERR')

    def test_online_ok(self):
        response = self.client.post(reverse('getpaid-payu-online'), {
            'pos_id': '123456789',
            'session_id': '1:11111',
            'ts': '1111',
            'sig': '2a78322c06522613cbd7447983570188',
        })
        self.assertEqual(response.content, 'OK')

    @mock.patch("urllib2.urlopen", fake_payment_get_response_success)
    def test_payment_get_paid(self):
        Payment = get_model('getpaid', 'Payment')
        order = Order(name='Test EUR order', total='123.45', currency='PLN')
        order.save()
        payment = Payment(pk=99, order=order, amount=order.total, currency=order.currency,
                          backend='getpaid.backends.payu')
        payment.save(force_insert=True)
        payment = Payment.objects.get(
            pk=99)  # this line is because django bug https://code.djangoproject.com/ticket/5903
        processor = getpaid.backends.payu.PaymentProcessor(payment)
        processor.get_payment_status('99:1342616247.41')
        self.assertEqual(payment.status, 'paid')
        self.assertNotEqual(payment.paid_on, None)
        self.assertNotEqual(payment.amount_paid, Decimal('0'))

    @mock.patch("urllib2.urlopen", fake_payment_get_response_failure)
    def test_payment_get_failed(self):
        Payment = get_model('getpaid', 'Payment')
        order = Order(name='Test EUR order', total='123.45', currency='PLN')
        order.save()
        payment = Payment(pk=98, order=order, amount=order.total, currency=order.currency,
                          backend='getpaid.backends.payu')
        payment.save(force_insert=True)
        payment = Payment.objects.get(
            pk=98)  # this line is because django bug https://code.djangoproject.com/ticket/5903
        processor = getpaid.backends.payu.PaymentProcessor(payment)
        processor.get_payment_status('98:1342616247.41')
        self.assertEqual(payment.status, 'failed')
        self.assertEqual(payment.paid_on, None)
        self.assertEqual(payment.amount_paid, Decimal('0'))


def fake_przelewy24_payment_get_response_success(request):
    class fake_response:
        def read(self):
            return """RESULT
TRUE"""

    return fake_response()


def fake_przelewy24_payment_get_response_failed(request):
    class fake_response:
        def read(self):
            return """RESULT
ERR
123
Some error description"""

    return fake_response()


class Przelewy24PaymentProcessorTestCase(TestCase):
    def test_sig(self):
        # Test based on p24 documentation
        sig = przelewy24.PaymentProcessor.compute_sig({
                                                          'key1': '9999',
                                                          'key2': '2500',
                                                          'key3': 'ccc',
                                                          'key4': 'abcdefghijk',
                                                          'crc': 'a123b456c789d012',

                                                      }, ('key4', 'key1', 'key2', 'crc'), 'a123b456c789d012')
        self.assertEqual(sig, 'e2c43dec9578633c518e1f514d3b434b')

    @mock.patch("urllib2.urlopen", fake_przelewy24_payment_get_response_success)
    def test_get_payment_status_success(self):
        Payment = get_model('getpaid', 'Payment')
        order = Order(name='Test PLN order', total='123.45', currency='PLN')
        order.save()
        payment = Payment(pk=191, order=order, amount=order.total, currency=order.currency,
                          backend='getpaid.backends.przelewy24')
        payment.save(force_insert=True)
        payment = Payment.objects.get(pk=191)
        processor = getpaid.backends.przelewy24.PaymentProcessor(payment)
        processor.get_payment_status(p24_session_id='191:xxx:xxx', p24_order_id='191:external', p24_kwota='12345')
        self.assertEqual(payment.status, 'paid')
        self.assertEqual(payment.external_id, '191:external')
        self.assertNotEqual(payment.paid_on, None)
        self.assertEqual(payment.amount_paid, Decimal('123.45'))

    @mock.patch("urllib2.urlopen", fake_przelewy24_payment_get_response_success)
    def test_get_payment_status_success_partial(self):
        Payment = get_model('getpaid', 'Payment')
        order = Order(name='Test PLN order', total='123.45', currency='PLN')
        order.save()

        payment = Payment(pk=192, order=order, amount=order.total, currency=order.currency,
                          backend='getpaid.backends.przelewy24')
        payment.save(force_insert=True)
        payment = Payment.objects.get(pk=192)
        processor = getpaid.backends.przelewy24.PaymentProcessor(payment)
        processor.get_payment_status(p24_session_id='192:xxx:xxx', p24_order_id='192:external', p24_kwota='12245')
        self.assertEqual(payment.status, 'partially_paid')
        self.assertEqual(payment.external_id, '192:external')
        self.assertNotEqual(payment.paid_on, None)
        self.assertEqual(payment.amount_paid, Decimal('122.45'))

    @mock.patch("urllib2.urlopen", fake_przelewy24_payment_get_response_failed)
    def test_get_payment_status_failed(self):
        Payment = get_model('getpaid', 'Payment')
        order = Order(name='Test PLN order', total='123.45', currency='PLN')
        order.save()

        payment = Payment(pk=192, order=order, amount=order.total, currency=order.currency,
                          backend='getpaid.backends.przelewy24')
        payment.save(force_insert=True)
        payment = Payment.objects.get(pk=192)
        processor = getpaid.backends.przelewy24.PaymentProcessor(payment)
        processor.get_payment_status(p24_session_id='192:xxx:xxx', p24_order_id='192:external', p24_kwota='12245')
        self.assertEqual(payment.status, 'failed')
        self.assertEqual(payment.paid_on, None)
        self.assertEqual(payment.amount_paid, Decimal('0.0'))


########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url, include
from getpaid.views import NewPaymentView, FallbackView
from getpaid.utils import import_backend_modules

includes_list = []
for backend_name, urls in import_backend_modules('urls').items():
    includes_list.append(url(r'^%s/' % backend_name, include(urls)))

urlpatterns = patterns('',
    url(r'^new/payment/(?P<currency>[A-Z]{3})/$', NewPaymentView.as_view(), name='getpaid-new-payment'),
    url(r'^payment/success/(?P<pk>\d+)/$', FallbackView.as_view(success=True), name='getpaid-success-fallback'),
    url(r'^payment/failure/(?P<pk>\d+)$', FallbackView.as_view(success=False), name='getpaid-failure-fallback'),
    *includes_list

)

########NEW FILE########
__FILENAME__ = utils
from django.conf import settings
import sys


def import_name(name):
    components = name.split('.')

    if len(components) == 1:
        # direct module, import the module directly
        mod = __import__(name, globals(), locals(), [name])
    else:
        # the module is within another, so we
        # need to import it from there
        parent_path = components[0:-1]
        module_name = components[-1]

        parent_mod = __import__(
            '.'.join(parent_path), globals(), locals(), [module_name])
        mod = getattr(parent_mod, components[-1])

    return mod


def import_backend_modules(submodule=None):
    backends = getattr(settings, 'GETPAID_BACKENDS', [])
    modules = {}
    for backend_name in backends:
        fqmn = backend_name
        if submodule:
            fqmn = '%s.%s' % (fqmn, submodule)
        __import__(fqmn)
        module = sys.modules[fqmn]
        modules[backend_name] = module
    return modules


def get_backend_choices(currency=None):
    """
    Get active backends modules. Backend list can be filtered by supporting given currency.
    """
    choices = []
    backends_names = getattr(settings, 'GETPAID_BACKENDS', [])

    for backend_name in backends_names:
        backend = import_name(backend_name)
        if currency:
            if currency in backend.PaymentProcessor.BACKEND_ACCEPTED_CURRENCY:
                choices.append((backend_name, backend.PaymentProcessor.BACKEND_NAME, ))
        else:
            choices.append((backend_name, backend.PaymentProcessor.BACKEND_NAME, ))
    return choices


def get_backend_settings(backend):
    """
    Returns backend settings. If it does not exist it fails back to empty dict().
    """
    backends_settings = getattr(settings, 'GETPAID_BACKENDS_SETTINGS', {})
    try:
        return backends_settings[backend]
    except KeyError:
        return {}

########NEW FILE########
__FILENAME__ = views
# Create your views here.
from django.conf import settings
from django.core.exceptions import PermissionDenied, ImproperlyConfigured
from django.core.urlresolvers import reverse
from django.http import Http404, HttpResponseRedirect
from django.shortcuts import get_object_or_404
from django.template.response import TemplateResponse
from django.views.generic import DetailView
from django.views.generic.base import RedirectView, TemplateView
from django.views.generic.edit import FormView
from getpaid.forms import PaymentMethodForm
from getpaid.models import Payment
from getpaid.signals import redirecting_to_payment_gateway_signal


class NewPaymentView(FormView):
    form_class = PaymentMethodForm
    template_name = "getpaid/payment_post_form.html"

    def get_form(self, form_class):
        self.currency = self.kwargs['currency']
        return form_class(self.currency, **self.get_form_kwargs())

    def get(self, request, *args, **kwargs):
        """
        This view operates only on POST requests from order view where you select payment method
        """
        raise Http404

    def form_valid(self, form):
        from getpaid.models import Payment
        payment = Payment.create(form.cleaned_data['order'], form.cleaned_data['backend'])
        processor = payment.get_processor()(payment)
        gateway_url_tuple = processor.get_gateway_url(self.request)
        payment.change_status('in_progress')
        redirecting_to_payment_gateway_signal.send(sender=None, request=self.request, order=form.cleaned_data['order'], payment=payment, backend=form.cleaned_data['backend'])

        if gateway_url_tuple[1].upper() == 'GET':
            return HttpResponseRedirect(gateway_url_tuple[0])
        elif gateway_url_tuple[1].upper() == 'POST':
            context = self.get_context_data()
            context['gateway_url'] = processor.get_gateway_url(self.request)[0]
            context['form'] = processor.get_form(gateway_url_tuple[2])

            return TemplateResponse(request=self.request,
                template=self.get_template_names(),
                context=context)
        else:
            raise ImproperlyConfigured()

    def form_invalid(self, form):
        raise PermissionDenied


class FallbackView(RedirectView):
    success = None
    permanent = False

    def get_redirect_url(self, **kwargs):
        self.payment = get_object_or_404(Payment, pk=self.kwargs['pk'])

        if self.success:
            url_name = getattr(settings, 'GETPAID_SUCCESS_URL_NAME', None)
            if url_name is not None:
                return reverse(url_name, kwargs={'pk': self.payment.order_id})
        else:
            url_name = getattr(settings, 'GETPAID_FAILURE_URL_NAME', None)
            if url_name is not None:
                return reverse(url_name, kwargs={'pk': self.payment.order_id})
        return self.payment.order.get_absolute_url()

########NEW FILE########
__FILENAME__ = forms
from decimal import Decimal
from django.core.exceptions import ValidationError
from django.forms.models import ModelForm
from getpaid_test_project.orders.models import Order

class OrderForm(ModelForm):
    class Meta:
        model = Order
        exclude = ('status', )

    def clean_total(self):
        if self.cleaned_data['total'] <= Decimal('0'):
            raise ValidationError('Provide some reasonable item price')
        return self.cleaned_data['total']
########NEW FILE########
__FILENAME__ = listeners
import logging
from getpaid import signals

logger = logging.getLogger('getpaid_test_project')

def new_payment_query_listener(sender, order=None, payment=None, **kwargs):
    """
    Here we fill only two obligatory fields of payment, and leave signal handler
    """
    payment.amount = order.total
    payment.currency = order.currency

    logger.debug("new_payment_query_listener, amount=%s, currency=%s" % (payment.amount, payment.currency))

signals.new_payment_query.connect(new_payment_query_listener)

def payment_status_changed_listener(sender, instance, old_status, new_status, **kwargs):
    """
    Here we will actually do something, when payment is accepted.
    E.g. lets change an order status.
    """
    logger.debug("payment_status_changed_listener, old=%s, new=%s" % (old_status, new_status))
    if old_status != 'paid' and new_status == 'paid':
        # Ensures that we process order only one
        instance.order.status = 'P'
        instance.order.save()

signals.payment_status_changed.connect(payment_status_changed_listener)


def user_data_query_listener(sender, order=None, user_data=None, **kwargs):
    """
    Here we fill some static user data, just for test
    """
    user_data['email'] = 'test@test.com'
    # user_data['lang'] = 'EN'

signals.user_data_query.connect(user_data_query_listener)
########NEW FILE########
__FILENAME__ = models
from django.core.urlresolvers import reverse
from django.db import models
import getpaid

class Order(models.Model):
    """
    This is an example Order object. This one is very simple - is only one item,
    but you can easily create more complicated models with multi-items it does not matter
    for payment processing.
    """
    name = models.CharField(max_length=100, default="Lock, Stock and Two Smoking Barrels")
    total = models.DecimalField(decimal_places=2, max_digits=8, default='199.99')
    currency = models.CharField(max_length=3, default='EUR')
    status = models.CharField(max_length=1, blank=True, default='W', choices=(('W', 'Waiting for payment'),
                                                                               ('P', 'Payment complete')))
    def get_absolute_url(self):
        return reverse('order_detail', kwargs={'pk': self.pk})

    def __unicode__(self):
        return self.name

    def clean(self):
        self.currency = self.currency.upper()


getpaid.register_to_payment(Order, unique=False, related_name='payments')

#noinspection PyUnresolvedReferences
import listeners
########NEW FILE########
__FILENAME__ = tests
"""
This file demonstrates writing tests using the unittest module. These will pass
when you run "manage.py test".

Replace this with more appropriate tests for your application.
"""
from django.core.urlresolvers import reverse
from django.db.models.loading import get_model

from django.test import TestCase
from django.test.client import Client

from getpaid_test_project.orders.models import Order


class OrderTest(TestCase):
    def setUp(self):
        self.client = Client()

    def test_order_view(self):
        order = Order(name='Test EUR order', total=100, currency='EUR')
        order.save()
        self.assertTemplateUsed(self.client.get(order.get_absolute_url()), 'orders/order_detail.html')

    def test_successful_create_payment_dummy_eur(self):
        """
        Tests if payment is successfully created
        """
        order = Order(name='Test EUR order', total=100, currency='EUR')
        order.save()
        response = self.client.post(reverse('getpaid-new-payment', kwargs={'currency': 'EUR'}),
                                    {'order': order.pk,
                                     'backend': 'getpaid.backends.dummy'}
        )
        self.assertEqual(response.status_code, 302)
        Payment = get_model('getpaid', 'Payment')
        payment = Payment.objects.get(order=order.pk)
        self.assertEqual(payment.backend, 'getpaid.backends.dummy')
        self.assertEqual(payment.amount, order.total)
        self.assertEqual(payment.currency, order.currency)
        self.assertEqual(payment.status, 'in_progress')
        self.assertEqual(payment.paid_on, None)
        self.assertEqual(payment.amount_paid, 0)

    def test_successful_create_payment_payu_pln(self):
        """
        Tests if payment is successfully created
        """
        order = Order(name='Test PLN order', total=100, currency='PLN')
        order.save()
        response = self.client.post(reverse('getpaid-new-payment', kwargs={'currency': 'PLN'}),
                                    {'order': order.pk,
                                     'backend': 'getpaid.backends.payu'}
        )
        self.assertEqual(response.status_code, 302)
        Payment = get_model('getpaid', 'Payment')
        payment = Payment.objects.get(order=order.pk)
        self.assertEqual(payment.backend, 'getpaid.backends.payu')
        self.assertEqual(payment.amount, order.total)
        self.assertEqual(payment.currency, order.currency)
        self.assertEqual(payment.status, 'in_progress')
        self.assertEqual(payment.paid_on, None)
        self.assertEqual(payment.amount_paid, 0)


    def test_failure_create_payment_eur(self):
        """
        Tests if payment fails when wrong currency for backend.
        PayU accepts only PLN currency payments.
        """
        order = Order(name='Test EUR order', total=100, currency='EUR')
        order.save()
        response = self.client.post(reverse('getpaid-new-payment', kwargs={'currency': 'EUR'}),
                                    {'order': order.pk,
                                     'backend': 'getpaid.backends.payu'}
        )
        self.assertEqual(response.status_code, 403)


########NEW FILE########
__FILENAME__ = views
# Create your views here.
from django.views.generic import CreateView
from django.views.generic.detail import DetailView
from getpaid.forms import PaymentMethodForm
from getpaid_test_project.orders.forms import OrderForm
from getpaid_test_project.orders.models import Order

class HomeView(CreateView):
    model=Order
    template_name='home.html'
    form_class=OrderForm

    def get_context_data(self, **kwargs):
        context = super(HomeView, self).get_context_data(**kwargs)
        context['orders'] = Order.objects.all()
        return context


class OrderView(DetailView):
    model=Order

    def get_context_data(self, **kwargs):
        context = super(OrderView, self).get_context_data(**kwargs)
        context['payment_form'] = PaymentMethodForm(self.object.currency, initial={'order': self.object})
        return context


########NEW FILE########
__FILENAME__ = settings
# Django settings for getpaid_test_project project.


GETPAID_BACKENDS = (
    'getpaid.backends.dummy',
)

GETPAID_BACKENDS_SETTINGS = {
    # Please provide your settings for backends
#    'getpaid.backends.payu' : {
#            'pos_id' : 123456789,
#            'key1' : 'xxx',
#            'key2' : 'xxx',
#            'pos_auth_key': 'xxx',
#            'signing' : True,
#            #'testing' : True,
#        },
}

DEBUG = True
TEMPLATE_DEBUG = DEBUG

ADMINS = (
    # ('Your Name', 'your_email@example.com'),
)

MANAGERS = ADMINS

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3', # Add 'postgresql_psycopg2', 'mysql', 'sqlite3' or 'oracle'.
        'NAME': 'getpaid_test_project.db',                      # Or path to database file if using sqlite3.
        'USER': '',                      # Not used with sqlite3.
        'PASSWORD': '',                  # Not used with sqlite3.
        'HOST': '',                      # Set to empty string for localhost. Not used with sqlite3.
        'PORT': '',                      # Set to empty string for default. Not used with sqlite3.
    }
}

# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# On Unix systems, a value of None will cause Django to use the same
# timezone as the operating system.
# If running in a Windows environment this must be set to the same as your
# system time zone.
TIME_ZONE = 'America/Chicago'

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'en-us'

SITE_ID = 1

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

# If you set this to False, Django will not format dates, numbers and
# calendars according to the current locale.
USE_L10N = True

# If you set this to False, Django will not use timezone-aware datetimes.
USE_TZ = True

# Absolute filesystem path to the directory that will hold user-uploaded files.
# Example: "/home/media/media.lawrence.com/media/"
MEDIA_ROOT = ''

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash.
# Examples: "http://media.lawrence.com/media/", "http://example.com/media/"
MEDIA_URL = ''

# Absolute path to the directory static files should be collected to.
# Don't put anything in this directory yourself; store your static files
# in apps' "static/" subdirectories and in STATICFILES_DIRS.
# Example: "/home/media/media.lawrence.com/static/"
STATIC_ROOT = ''

# URL prefix for static files.
# Example: "http://media.lawrence.com/static/"
STATIC_URL = '/static/'

# Additional locations of static files
STATICFILES_DIRS = (
    # Put strings here, like "/home/html/static" or "C:/www/django/static".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

# List of finder classes that know how to find static files in
# various locations.
STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
#    'django.contrib.staticfiles.finders.DefaultStorageFinder',
)

# Make this unique, and don't share it with anybody.
SECRET_KEY = '2$3=q&amp;0#3@et=$7v4=+uc$ny81sjj_!%w7)z_p)rc6jb+##kz!'

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
#     'django.template.loaders.eggs.Loader',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    # Uncomment the next line for simple clickjacking protection:
    # 'django.middleware.clickjacking.XFrameOptionsMiddleware',
)

ROOT_URLCONF = 'getpaid_test_project.urls'

# Python dotted path to the WSGI application used by Django's runserver.
WSGI_APPLICATION = 'getpaid_test_project.wsgi.application'

TEMPLATE_DIRS = (
    # Put strings here, like "/home/html/django_templates" or "C:/www/django/templates".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    # Uncomment the next line to enable the admin:
    'django.contrib.admin',
    # Uncomment the next line to enable admin documentation:
    # 'django.contrib.admindocs',

    'djcelery',
    'djcelery.transport',

    'getpaid',




    'getpaid_test_project.orders',
) + GETPAID_BACKENDS

# A sample logging configuration. The only tangible logging
# performed by this configuration is to send an email to
# the site admins on every HTTP 500 error when DEBUG=False.
# See http://docs.djangoproject.com/en/dev/topics/logging for
# more details on how to customize your logging configuration.
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'filters': {
        'require_debug_false': {
            '()': 'django.utils.log.RequireDebugFalse'
        }
    },
    'handlers': {
        'mail_admins': {
            'level': 'ERROR',
            'filters': ['require_debug_false'],
            'class': 'django.utils.log.AdminEmailHandler'
        },
        'console' : {
            'level':'DEBUG',
            'class':'logging.StreamHandler',

        },
    },
    'loggers': {
        'django.request': {
            'handlers': ['mail_admins'],
            'level': 'ERROR',
            'propagate': True,
        },

        'getpaid_test_project':{
            'handlers': ['console'],
            'level': 'DEBUG',
        },

        #You can do some fancy logging ;)
        'getpaid.backends.payu':{
            'handlers': ['console'],
            'level': 'DEBUG',
        },
        'getpaid.backends.przelewy24':{
            'handlers': ['console'],
            'level': 'DEBUG',
        },
        'getpaid.backends.transferuj':{
            'handlers': ['console'],
            'level': 'DEBUG',
        }

    }
}


# This example uses the simplest django-celery queue possible - Database, don't use it on production!

BROKER_URL = 'django://'



import djcelery
djcelery.setup_loader()

########NEW FILE########
__FILENAME__ = settings_docs
import os
import sys
sys.path.insert(0, os.getcwd())
sys.path.insert(0, os.path.join(os.getcwd(), os.pardir))
#noinspection PyUnresolvedReferences
from settings import *
########NEW FILE########
__FILENAME__ = settings_test
#noinspection PyUnresolvedReferences
from settings import *

GETPAID_BACKENDS = (
    'getpaid.backends.dummy',
    'getpaid.backends.payu',
    'getpaid.backends.transferuj',
    'getpaid.backends.przelewy24',
)

INSTALLED_APPS += GETPAID_BACKENDS

GETPAID_BACKENDS_SETTINGS = {
    # Please provide your settings for backends
    'getpaid.backends.payu': {
        'pos_id': 123456789,
        'key1': 'xxx',
        'key2': 'xxx',
        'pos_auth_key': 'xxx',
        'signing': True,
        #        'testing' : True,
    },

    'getpaid.backends.transferuj': {
        'id': 1234,
        'key': 'AAAAAAAA',

    },

    'getpaid.backends.przelewy24': {
        'id': 1234,
        'crc': '1111111111111111',
    },

}


########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, include, url
from getpaid_test_project.orders.views import OrderView, HomeView
from django.contrib import admin

admin.autodiscover()

urlpatterns = patterns('getpaid_test_project',
    url(r'^$', HomeView.as_view(), name='home'),
    url(r'^order/(?P<pk>\d+)/$', OrderView.as_view(), name='order_detail'),


    url(r'', include('getpaid.urls')),

    (r'^admin/', include(admin.site.urls)),
)

########NEW FILE########
__FILENAME__ = wsgi
"""
WSGI config for getpaid_test_project project.

This module contains the WSGI application used by Django's development server
and any production WSGI deployments. It should expose a module-level variable
named ``application``. Django's ``runserver`` and ``runfcgi`` commands discover
this application via the ``WSGI_APPLICATION`` setting.

Usually you will have the standard Django WSGI application here, but it also
might make sense to replace the whole Django WSGI application with a custom one
that later delegates to the Django one. For example, you could introduce WSGI
middleware here, or combine a Django application with an application of another
framework.

"""
import os

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "getpaid_test_project.settings")

# This application object is used by any WSGI server configured to use this
# file. This includes Django's development server, if the WSGI_APPLICATION
# setting points here.
from django.core.wsgi import get_wsgi_application
application = get_wsgi_application()

# Apply WSGI middleware here.
# from helloworld.wsgi import HelloWorldApplication
# application = HelloWorldApplication(application)

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
import os
import sys

if __name__ == "__main__":
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "getpaid_test_project.settings")

    from django.core.management import execute_from_command_line

    execute_from_command_line(sys.argv)

########NEW FILE########
