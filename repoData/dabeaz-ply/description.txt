This example is incomplete.  Was going to specify an ANSI C parser.
This is part of it.

Inspired by a September 14, 2006 Salon article "Why Johnny Can't Code" by
David Brin (http://www.salon.com/tech/feature/2006/09/14/basic/index.html),
I thought that a fully working BASIC interpreter might be an interesting,
if not questionable, PLY example.  Uh, okay, so maybe it's just a bad idea,
but in any case, here it is.

In this example, you'll find a rough implementation of 1964 Dartmouth BASIC
as described in the manual at:

   http://www.bitsavers.org/pdf/dartmouth/BASIC_Oct64.pdf

See also:

  http://en.wikipedia.org/wiki/Dartmouth_BASIC

This dialect is downright primitive---there are no string variables
and no facilities for interactive input. Moreover, subroutines and functions
are brain-dead even more than they usually are for BASIC. Of course,
the GOTO statement is provided.

Nevertheless, there are a few interesting aspects of this example:

  - It illustrates a fully working interpreter including lexing, parsing,
    and interpretation of instructions.
 
  - The parser shows how to catch and report various kinds of parsing
    errors in a more graceful way.

  - The example both parses files (supplied on command line) and
    interactive input entered line by line.

  - It shows how you might represent parsed information.  In this case,
    each BASIC statement is encoded into a Python tuple containing the
    statement type and parameters.  These tuples are then stored in
    a dictionary indexed by program line numbers.

  - Even though it's just BASIC, the parser contains more than 80
    rules and 150 parsing states. Thus, it's a little more meaty than
    the calculator example.

To use the example, run it as follows:

   % python basic.py hello.bas
   HELLO WORLD
   %

or use it interactively:

   % python basic.py
   [BASIC] 10 PRINT "HELLO WORLD"
   [BASIC] 20 END
   [BASIC] RUN
   HELLO WORLD
   [BASIC]

The following files are defined:

   basic.py         - High level script that controls everything
   basiclex.py      - BASIC tokenizer
   basparse.py      - BASIC parser
   basinterp.py     - BASIC interpreter that runs parsed programs.

In addition, a number of sample BASIC programs (.bas suffix) are
provided.  These were taken out of the Dartmouth manual.

Disclaimer: I haven't spent a ton of time testing this and it's likely that
I've skimped here and there on a few finer details (e.g., strictly enforcing
variable naming rules).  However, the interpreter seems to be able to run
the examples in the BASIC manual.

Have fun!

-Dave







This example is Andrew Dalke's GardenSnake language. It shows how to process an
indentation-like language like Python.   Further details can be found here:

http://dalkescientific.com/writings/diary/archive/2006/08/30/gardensnake_language.html


An example showing how to use Python optimized mode.
To run:

  - First run 'python calc.py'

  - Then run 'python -OO calc.py'

If working correctly, the second version should run the
same way.

Simple examples:
   calc       - Simple calculator
   classcalc  - Simple calculate defined as a class
   
Complex examples
   ansic       - ANSI C grammar from K&R
   BASIC       - A small BASIC interpreter
   GardenSnake - A simple python-like language
   yply        - Converts Unix yacc files to PLY programs.


yply.py

This example implements a program yply.py that converts a UNIX-yacc
specification file into a PLY-compatible program.  To use, simply
run it like this:

   % python yply.py [-nocode] inputfile.y >myparser.py

The output of this program is Python code. In the output,
any C code in the original file is included, but is commented out.
If you use the -nocode option, then all of the C code in the
original file is just discarded.

To use the resulting grammer with PLY, you'll need to edit the
myparser.py file. Within this file, some stub code is included that
can be used to test the construction of the parsing tables. However,
you'll need to do more editing to make a workable parser.

Disclaimer:  This just an example I threw together in an afternoon.
It might have some bugs.  However, it worked when I tried it on
a yacc-specified C++ parser containing 442 rules and 855 parsing
states.

Comments:

1. This example does not parse specification files meant for lex/flex.
   You'll need to specify the tokenizer on your own.

2. This example shows a number of interesting PLY features including
    
     - Parsing of literal text delimited by nested parentheses
     - Some interaction between the parser and the lexer.
     - Use of literals in the grammar specification
     - One pass compilation.  The program just emits the result,
       there is no intermediate parse tree.

3. This program could probably be cleaned up and enhanced a lot.
   It would be great if someone wanted to work on this (hint).

-Dave
       

PLY (Python Lex-Yacc)                   Version 3.5

Copyright (C) 2001-2012,
David M. Beazley (Dabeaz LLC)
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright notice,
  this list of conditions and the following disclaimer.  
* Redistributions in binary form must reproduce the above copyright notice, 
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.  
* Neither the name of the David Beazley or Dabeaz LLC may be used to
  endorse or promote products derived from this software without
  specific prior written permission. 

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Introduction
============

PLY is a 100% Python implementation of the common parsing tools lex
and yacc. Here are a few highlights:

 -  PLY is very closely modeled after traditional lex/yacc.
    If you know how to use these tools in C, you will find PLY
    to be similar.

 -  PLY provides *very* extensive error reporting and diagnostic 
    information to assist in parser construction.  The original
    implementation was developed for instructional purposes.  As
    a result, the system tries to identify the most common types
    of errors made by novice users.  

 -  PLY provides full support for empty productions, error recovery,
    precedence specifiers, and moderately ambiguous grammars.

 -  Parsing is based on LR-parsing which is fast, memory efficient, 
    better suited to large grammars, and which has a number of nice
    properties when dealing with syntax errors and other parsing problems.
    Currently, PLY builds its parsing tables using the LALR(1)
    algorithm used in yacc.

 -  PLY uses Python introspection features to build lexers and parsers.  
    This greatly simplifies the task of parser construction since it reduces 
    the number of files and eliminates the need to run a separate lex/yacc 
    tool before running your program.

 -  PLY can be used to build parsers for "real" programming languages.
    Although it is not ultra-fast due to its Python implementation,
    PLY can be used to parse grammars consisting of several hundred
    rules (as might be found for a language like C).  The lexer and LR 
    parser are also reasonably efficient when parsing typically
    sized programs.  People have used PLY to build parsers for
    C, C++, ADA, and other real programming languages.

How to Use
==========

PLY consists of two files : lex.py and yacc.py.  These are contained
within the 'ply' directory which may also be used as a Python package.
To use PLY, simply copy the 'ply' directory to your project and import
lex and yacc from the associated 'ply' package.  For example:

     import ply.lex as lex
     import ply.yacc as yacc

Alternatively, you can copy just the files lex.py and yacc.py
individually and use them as modules.  For example:

     import lex
     import yacc

The file setup.py can be used to install ply using distutils.

The file doc/ply.html contains complete documentation on how to use
the system.

The example directory contains several different examples including a
PLY specification for ANSI C as given in K&R 2nd Ed.   

A simple example is found at the end of this document

Requirements
============
PLY requires the use of Python 2.2 or greater.  However, you should
use the latest Python release if possible.  It should work on just
about any platform.  PLY has been tested with both CPython and Jython.
It also seems to work with IronPython.

Resources
=========
More information about PLY can be obtained on the PLY webpage at:

     http://www.dabeaz.com/ply

For a detailed overview of parsing theory, consult the excellent
book "Compilers : Principles, Techniques, and Tools" by Aho, Sethi, and
Ullman.  The topics found in "Lex & Yacc" by Levine, Mason, and Brown
may also be useful.

A Google group for PLY can be found at

     http://groups.google.com/group/ply-hack

Acknowledgments
===============
A special thanks is in order for all of the students in CS326 who
suffered through about 25 different versions of these tools :-).

The CHANGES file acknowledges those who have contributed patches.

Elias Ioup did the first implementation of LALR(1) parsing in PLY-1.x. 
Andrew Waters and Markus Schoepflin were instrumental in reporting bugs
and testing a revised LALR(1) implementation for PLY-2.0.

Special Note for PLY-3.0
========================
PLY-3.0 the first PLY release to support Python 3. However, backwards
compatibility with Python 2.2 is still preserved. PLY provides dual
Python 2/3 compatibility by restricting its implementation to a common
subset of basic language features. You should not convert PLY using
2to3--it is not necessary and may in fact break the implementation.

Example
=======

Here is a simple example showing a PLY implementation of a calculator
with variables.

    # -----------------------------------------------------------------------------
    # calc.py
    #
    # A simple calculator with variables.
    # -----------------------------------------------------------------------------

    tokens = (
        'NAME','NUMBER',
        'PLUS','MINUS','TIMES','DIVIDE','EQUALS',
        'LPAREN','RPAREN',
        )

    # Tokens

    t_PLUS    = r'\+'
    t_MINUS   = r'-'
    t_TIMES   = r'\*'
    t_DIVIDE  = r'/'
    t_EQUALS  = r'='
    t_LPAREN  = r'\('
    t_RPAREN  = r'\)'
    t_NAME    = r'[a-zA-Z_][a-zA-Z0-9_]*'

    def t_NUMBER(t):
        r'\d+'
        t.value = int(t.value)
        return t

    # Ignored characters
    t_ignore = " \t"

    def t_newline(t):
        r'\n+'
        t.lexer.lineno += t.value.count("\n")

    def t_error(t):
        print("Illegal character '%s'" % t.value[0])
        t.lexer.skip(1)

    # Build the lexer
    import ply.lex as lex
    lex.lex()

    # Precedence rules for the arithmetic operators
    precedence = (
        ('left','PLUS','MINUS'),
        ('left','TIMES','DIVIDE'),
        ('right','UMINUS'),
        )

    # dictionary of names (for storing variables)
    names = { }

    def p_statement_assign(p):
        'statement : NAME EQUALS expression'
        names[p[1]] = p[3]

    def p_statement_expr(p):
        'statement : expression'
        print(p[1])

    def p_expression_binop(p):
        '''expression : expression PLUS expression
                      | expression MINUS expression
                      | expression TIMES expression
                      | expression DIVIDE expression'''
        if p[2] == '+'  : p[0] = p[1] + p[3]
        elif p[2] == '-': p[0] = p[1] - p[3]
        elif p[2] == '*': p[0] = p[1] * p[3]
        elif p[2] == '/': p[0] = p[1] / p[3]

    def p_expression_uminus(p):
        'expression : MINUS expression %prec UMINUS'
        p[0] = -p[2]

    def p_expression_group(p):
        'expression : LPAREN expression RPAREN'
        p[0] = p[2]

    def p_expression_number(p):
        'expression : NUMBER'
        p[0] = p[1]

    def p_expression_name(p):
        'expression : NAME'
        try:
            p[0] = names[p[1]]
        except LookupError:
            print("Undefined name '%s'" % p[1])
            p[0] = 0

    def p_error(p):
        print("Syntax error at '%s'" % p.value)

    import ply.yacc as yacc
    yacc.yacc()

    while 1:
        try:
            s = raw_input('calc > ')   # use input() on Python 3
        except EOFError:
            break
        yacc.parse(s)


Bug Reports and Patches
=======================
My goal with PLY is to simply have a decent lex/yacc implementation
for Python.  As a general rule, I don't spend huge amounts of time
working on it unless I receive very specific bug reports and/or
patches to fix problems. I also try to incorporate submitted feature
requests and enhancements into each new version.  To contact me about
bugs and/or new features, please send email to dave@dabeaz.com.

In addition there is a Google group for discussing PLY related issues at

    http://groups.google.com/group/ply-hack
 
-- Dave










This directory mostly contains tests for various types of error
conditions.  To run:

  $ python testlex.py 
  $ python testyacc.py 

The script 'cleanup.sh' cleans up this directory to its original state.

