__FILENAME__ = ast
# -*- coding: utf-8 -*-
"""
    ast
    ~~~

    The `ast` module helps Python applications to process trees of the Python
    abstract syntax grammar.  The abstract syntax itself might change with
    each Python release; this module helps to find out programmatically what
    the current grammar looks like and allows modifications of it.

    An abstract syntax tree can be generated by passing `ast.PyCF_ONLY_AST` as
    a flag to the `compile()` builtin function or by using the `parse()`
    function from this module.  The result will be a tree of objects whose
    classes all inherit from `ast.AST`.

    A modified abstract syntax tree can be compiled into a Python code object
    using the built-in `compile()` function.

    Additionally various helper functions are provided that make working with
    the trees simpler.  The main intention of the helper functions and this
    module in general is to provide an easy to use interface for libraries
    that work tightly with the python syntax (template engines for example).


    :copyright: Copyright 2008 by Armin Ronacher.
    :license: Python License.
"""
from _ast import *


BOOLOP_SYMBOLS = {
    And:        'and',
    Or:         'or'
}

BINOP_SYMBOLS = {
    Add:        '+',
    Sub:        '-',
    Mult:       '*',
    Pow:        '**',
    Div:        '/',
    FloorDiv:   '//',
    Mod:        '%',
    LShift:     '<<',
    RShift:     '>>',
    BitOr:      '|',
    BitAnd:     '&',
    BitXor:     '^'
}

CMPOP_SYMBOLS = {
    Eq:         '==',
    Gt:         '>',
    GtE:        '>=',
    In:         'in',
    Is:         'is',
    IsNot:      'is not',
    Lt:         '<',
    LtE:        '<=',
    NotEq:      '!=',
    NotIn:      'not in'
}

UNARYOP_SYMBOLS = {
    Invert:     '~',
    Not:        'not',
    UAdd:       '+',
    USub:       '-'
}

ALL_SYMBOLS = {}
ALL_SYMBOLS.update(BOOLOP_SYMBOLS)
ALL_SYMBOLS.update(BINOP_SYMBOLS)
ALL_SYMBOLS.update(CMPOP_SYMBOLS)
ALL_SYMBOLS.update(UNARYOP_SYMBOLS)


def parse(expr, filename='<unknown>', mode='exec'):
    """Parse an expression into an AST node."""
    return compile(expr, filename, mode, PyCF_ONLY_AST)


def literal_eval(node_or_string):
    """Safe evaluate a literal.  The string or node provided may include any
    of the following python structures: strings, numbers, tuples, lists,
    dicts, booleans or None.
    """
    _safe_names = {'None': None, 'True': True, 'False': False}
    if isinstance(node_or_string, basestring):
        node_or_string = parse(node_or_string, mode='eval')
    if isinstance(node_or_string, Expression):
        node_or_string = node_or_string.body
    def _convert(node):
        if isinstance(node, Str):
            return node.s
        elif isinstance(node, Num):
            return node.n
        elif isinstance(node, Tuple):
            return tuple(map(_convert, node.elts))
        elif isinstance(node, List):
            return list(map(_convert, node.elts))
        elif isinstance(node, Dict):
            return dict((_convert(k), _convert(v)) for k, v
                        in zip(node.keys, node.values))
        elif isinstance(node, Name):
            if node.id in _safe_names:
                return _safe_names[node.id]
        raise ValueError('malformed string')
    return _convert(node_or_string)


def dump(node, annotate_fields=True, include_attributes=False):
    """A very verbose representation of the node passed.  This is useful for
    debugging purposes.  Per default the returned string will show the names
    and the values for fields.  This makes the code impossible to evaluate,
    if evaluation is wanted `annotate_fields` must be set to False.
    Attributes such as line numbers and column offsets are dumped by default.
    If this is wanted, `include_attributes` can be set to `True`.
    """
    def _format(node):
        if isinstance(node, AST):
            fields = [(a, _format(b)) for a, b in iter_fields(node)]
            rv = '%s(%s' % (node.__class__.__name__, ', '.join(
                ('%s=%s' % field for field in fields)
                if annotate_fields else
                (b for a, b in fields)
            ))
            if include_attributes and node._attributes:
                rv += fields and ', ' or ' '
                rv += ', '.join('%s=%s' % (a, _format(getattr(node, a)))
                                for a in node._attributes)
            return rv + ')'
        elif isinstance(node, list):
            return '[%s]' % ', '.join(_format(x) for x in node)
        return repr(node)
    if not isinstance(node, AST):
        raise TypeError('expected AST, got %r' % node.__class__.__name__)
    return _format(node)


def copy_location(new_node, old_node):
    """Copy the source location hint (`lineno` and `col_offset`) from the
    old to the new node if possible and return the new one.
    """
    new_attributes = getattr(new_node, '_attributes', ()) or ()
    old_attributes = getattr(old_node, '_attributes', ()) or ()
    for attr in 'lineno', 'col_offset':
        if attr in old_attributes and attr in new_attributes \
           and hasattr(old_node, attr):
            setattr(new_node, attr, getattr(old_node, attr))
    return new_node


def fix_missing_locations(node):
    """Some nodes require a line number and the column offset.  Without that
    information the compiler will abort the compilation.  Because it can be
    a dull task to add appropriate line numbers and column offsets when
    adding new nodes this function can help.  It copies the line number and
    column offset of the parent node to the child nodes without this
    information.

    Unlike `copy_location` this works recursive and won't touch nodes that
    already have a location information.
    """
    def _fix(node, lineno, col_offset):
        attrs = getattr(node, '_attributes', ()) or ()
        if 'lineno' in attrs:
            if not hasattr(node, 'lineno'):
                node.lineno = lineno
            else:
                lineno = node.lineno
        if 'col_offset' in attrs:
            if not hasattr(node, 'col_offset'):
                node.col_offset = col_offset
            else:
                col_offset = node.col_offset
        for child in iter_child_nodes(node):
            _fix(child, lineno, col_offset)
    _fix(node, 1, 0)
    return node


def increment_lineno(node, n=1):
    """Increment the line numbers of all nodes by `n` if they have line number
    attributes.  This is useful to "move code" to a different location in a
    file.
    """
    if 'lineno' in getattr(node, '_attributes', ()) or ():
        node.lineno = getattr(node, 'lineno', 0) + n
    for child in walk(node):
        child._attributes = getattr(child, '_attributes', ()) or ()
        if 'lineno' in getattr(child, '_attributes', ()) or ():
            child.lineno = getattr(child, 'lineno', 0) + n
    return node


def iter_fields(node):
    """Iterate over all fields of a node, only yielding existing fields."""
    for field in getattr(node, '_fields', ()) or ():
        try:
            yield field, getattr(node, field)
        except AttributeError:
            pass


def get_fields(node):
    """Like `iter_fiels` but returns a dict."""
    return dict(iter_fields(node))


def iter_child_nodes(node):
    """Iterate over all child nodes or a node."""
    for name, field in iter_fields(node):
        if isinstance(field, AST):
            yield field
        elif isinstance(field, list):
            for item in field:
                if isinstance(item, AST):
                    yield item


def get_child_nodes(node):
    """Like `iter_child_nodes` but returns a list."""
    return list(iter_child_nodes(node))


def get_docstring(node, trim=True):
    """Return the docstring for the given node or `None` if no docstring can
    be found.  If the node provided does not accept docstrings a `TypeError`
    will be raised.
    """
    if not isinstance(node, (FunctionDef, ClassDef, Module)):
        raise TypeError("%r can't have docstrings" % node.__class__.__name__)
    if node.body and isinstance(node.body[0], Expr) and \
       isinstance(node.body[0].value, Str):
        doc = node.body[0].value.s
        if trim:
            doc = trim_docstring(doc)
        return doc


def trim_docstring(docstring):
    """Trim a docstring.  This should probably go into the inspect module."""
    lines = docstring.expandtabs().splitlines()

    # Find minimum indentation of any non-blank lines after first line.
    from sys import maxint
    margin = maxint
    for line in lines[1:]:
        content = len(line.lstrip())
        if content:
            indent = len(line) - content
            margin = min(margin, indent)

    # Remove indentation.
    if lines:
        lines[0] = lines[0].lstrip()
    if margin < maxint:
        for i in range(1, len(lines)):
            lines[i] = lines[i][margin:]

    # Remove any trailing or leading blank lines.
    while lines and not lines[-1]:
        lines.pop()
    while lines and not lines[0]:
        lines.pop(0)
    return '\n'.join(lines)


def get_symbol(operator):
    """Return the symbol of the given operator node or node type."""
    if isinstance(operator, AST):
        operator = type(operator)
    try:
        return ALL_SYMBOLS[operator]
    except KeyError:
        raise LookupError('no known symbol for %r' % operator)


def walk(node):
    """Iterate over all nodes.  This is useful if you only want to modify nodes
    in place and don't care about the context or the order the nodes are
    returned.
    """
    from collections import deque
    todo = deque([node])
    while todo:
        node = todo.popleft()
        todo.extend(iter_child_nodes(node))
        yield node


class NodeVisitor(object):
    """Walks the abstract syntax tree and call visitor functions for every
    node found.  The visitor functions may return values which will be
    forwarded by the `visit` method.

    Per default the visitor functions for the nodes are ``'visit_'`` +
    class name of the node.  So a `TryFinally` node visit function would
    be `visit_TryFinally`.  This behavior can be changed by overriding
    the `get_visitor` function.  If no visitor function exists for a node
    (return value `None`) the `generic_visit` visitor is used instead.

    Don't use the `NodeVisitor` if you want to apply changes to nodes during
    traversing.  For this a special visitor exists (`NodeTransformer`) that
    allows modifications.
    """

    def get_visitor(self, node):
        """Return the visitor function for this node or `None` if no visitor
        exists for this node.  In that case the generic visit function is
        used instead.
        """
        method = 'visit_' + node.__class__.__name__
        return getattr(self, method, None)

    def visit(self, node):
        """Visit a node."""
        f = self.get_visitor(node)
        if f is not None:
            return f(node)
        return self.generic_visit(node)

    def generic_visit(self, node):
        """Called if no explicit visitor function exists for a node."""
        for field, value in iter_fields(node):
            if isinstance(value, list):
                for item in value:
                    if isinstance(item, AST):
                        self.visit(item)
            elif isinstance(value, AST):
                self.visit(value)


class NodeTransformer(NodeVisitor):
    """Walks the abstract syntax tree and allows modifications of nodes.

    The `NodeTransformer` will walk the AST and use the return value of the
    visitor functions to replace or remove the old node.  If the return
    value of the visitor function is `None` the node will be removed
    from the previous location otherwise it's replaced with the return
    value.  The return value may be the original node in which case no
    replacement takes place.

    Here an example transformer that rewrites all `foo` to `data['foo']`::

        class RewriteName(NodeTransformer):

            def visit_Name(self, node):
                return copy_location(Subscript(
                    value=Name(id='data', ctx=Load()),
                    slice=Index(value=Str(s=node.id)),
                    ctx=node.ctx
                ), node)

    Keep in mind that if the node you're operating on has child nodes
    you must either transform the child nodes yourself or call the generic
    visit function for the node first.

    Nodes that were part of a collection of statements (that applies to
    all statement nodes) may also return a list of nodes rather than just
    a single node.

    Usually you use the transformer like this::

        node = YourTransformer().visit(node)
    """

    def generic_visit(self, node):
        for field, old_value in iter_fields(node):
            old_value = getattr(node, field, None)
            if isinstance(old_value, list):
                new_values = []
                for value in old_value:
                    if isinstance(value, AST):
                        value = self.visit(value)
                        if value is None:
                            continue
                        elif not isinstance(value, AST):
                            new_values.extend(value)
                            continue
                    new_values.append(value)
                old_value[:] = new_values
            elif isinstance(old_value, AST):
                new_node = self.visit(old_value)
                if new_node is None:
                    delattr(node, field)
                else:
                    setattr(node, field, new_node)
        return node

########NEW FILE########
__FILENAME__ = codegen
# -*- coding: utf-8 -*-
"""
    codegen
    ~~~~~~~

    Extension to ast that allow ast -> python code generation.

    :copyright: Copyright 2008 by Armin Ronacher.
    :license: BSD.
"""
from attest.ast import (BINOP_SYMBOLS, BOOLOP_SYMBOLS, CMPOP_SYMBOLS,
                        UNARYOP_SYMBOLS, NodeVisitor)


def to_source(node, indent_with=' ' * 4, add_line_information=False):
    """This function can convert a node tree back into python sourcecode.
    This is useful for debugging purposes, especially if you're dealing with
    custom asts not generated by python itself.

    It could be that the sourcecode is evaluable when the AST itself is not
    compilable / evaluable.  The reason for this is that the AST contains some
    more data than regular sourcecode does, which is dropped during
    conversion.

    Each level of indentation is replaced with `indent_with`.  Per default this
    parameter is equal to four spaces as suggested by PEP 8, but it might be
    adjusted to match the application's styleguide.

    If `add_line_information` is set to `True` comments for the line numbers
    of the nodes are added to the output.  This can be used to spot wrong line
    number information of statement nodes.
    """
    generator = SourceGenerator(indent_with, add_line_information)
    generator.visit(node)
    return ''.join(generator.result)


class SourceGenerator(NodeVisitor):
    """This visitor is able to transform a well formed syntax tree into python
    sourcecode.  For more details have a look at the docstring of the
    `node_to_source` function.
    """

    def __init__(self, indent_with, add_line_information=False):
        self.result = []
        self.indent_with = indent_with
        self.add_line_information = add_line_information
        self.indentation = 0
        self.new_lines = 0

    def write(self, x):
        if self.new_lines:
            if self.result:
                self.result.append('\n' * self.new_lines)
            self.result.append(self.indent_with * self.indentation)
            self.new_lines = 0
        self.result.append(x)

    def newline(self, node=None, extra=0):
        self.new_lines = max(self.new_lines, 1 + extra)
        if node is not None and self.add_line_information:
            self.write('# line: %s' % node.lineno)
            self.new_lines = 1

    def body(self, statements):
        self.new_line = True
        self.indentation += 1
        for stmt in statements:
            self.visit(stmt)
        self.indentation -= 1
        self.write('\n')

    def body_or_else(self, node, body=True):
        if body:
            self.body(node.body)
        if node.orelse:
            self.newline()
            self.write('else:')
            self.body(node.orelse)

    def signature(self, node):
        want_comma = []
        def write_comma():
            if want_comma:
                self.write(', ')
            else:
                want_comma.append(True)

        padding = [None] * (len(node.args) - len(node.defaults))
        for arg, default in zip(node.args, padding + node.defaults):
            write_comma()
            self.visit(arg)
            if default is not None:
                self.write('=')
                self.visit(default)
        if node.vararg is not None:
            write_comma()
            self.write('*' + node.vararg)
        if node.kwarg is not None:
            write_comma()
            self.write('**' + node.kwarg)

    def decorators(self, node):
        decor = getattr(node, 'decorator_list',
                getattr(node, 'decorators', ()))
        for decorator in decor:
            self.newline(decorator)
            self.write('@')
            self.visit(decorator)

    # Statements

    def visit_Assign(self, node):
        self.newline(node)
        for idx, target in enumerate(node.targets):
            if idx:
                self.write(', ')
            self.visit(target)
        self.write(' = ')
        self.visit(node.value)

    def visit_AugAssign(self, node):
        self.newline(node)
        self.visit(node.target)
        self.write(BINOP_SYMBOLS[type(node.op)] + '=')
        self.visit(node.value)

    def visit_ImportFrom(self, node):
        self.newline(node)
        self.write('from %s%s import ' % ('.' * node.level, node.module))
        for idx, item in enumerate(node.names):
            if idx:
                self.write(', ')
            self.visit(item)

    def visit_Import(self, node):
        self.newline(node)
        for item in node.names:
            self.write('import ')
            self.visit(item)

    def visit_Expr(self, node):
        self.newline(node)
        self.generic_visit(node)

    def visit_FunctionDef(self, node):
        self.newline(extra=1)
        self.decorators(node)
        self.newline(node)
        self.write('def %s(' % node.name)
        self.signature(node.args)
        self.write('):')
        self.body(node.body)

    def visit_ClassDef(self, node):
        have_args = []
        def paren_or_comma():
            if have_args:
                self.write(', ')
            else:
                have_args.append(True)
                self.write('(')

        self.newline(extra=2)
        self.decorators(node)
        self.newline(node)
        self.write('class %s' % node.name)
        for base in node.bases:
            paren_or_comma()
            self.visit(base)
        # XXX: the if here is used to keep this module compatible
        #      with python 2.6.
        if hasattr(node, 'keywords'):
            for keyword in node.keywords:
                paren_or_comma()
                self.write(keyword.arg + '=')
                self.visit(keyword.value)
            if node.starargs is not None:
                paren_or_comma()
                self.write('*')
                self.visit(node.starargs)
            if node.kwargs is not None:
                paren_or_comma()
                self.write('**')
                self.visit(node.kwargs)
        self.write(have_args and '):' or ':')
        self.body(node.body)

    def visit_If(self, node):
        self.newline(node)
        self.write('if ')
        self.visit(node.test)
        self.write(':')
        self.body(node.body)
        while node.orelse:
            else_ = node.orelse
            if len(else_) == 1 and isinstance(else_[0], If):
                node = else_[0]
                self.newline()
                self.write('elif ')
                self.visit(node.test)
                self.write(':')
                self.body(node.body)
            else:
                self.newline()
                self.write('else:')
                self.body(else_)
                break

    def visit_For(self, node):
        self.newline(node)
        self.write('for ')
        self.visit(node.target)
        self.write(' in ')
        self.visit(node.iter)
        self.write(':')
        self.body_or_else(node)

    def visit_While(self, node):
        self.newline(node)
        self.write('while ')
        self.visit(node.test)
        self.write(':')
        self.body_or_else(node)

    def visit_With(self, node):
        self.newline(node)
        self.write('with ')
        self.visit(node.context_expr)
        if node.optional_vars is not None:
            self.write(' as ')
            self.visit(node.optional_vars)
        self.write(':')
        self.body(node.body)

    def visit_Pass(self, node):
        self.newline(node)
        self.write('pass')

    def visit_Print(self, node):
        # XXX: python 2.6 only
        self.newline(node)
        self.write('print ')
        want_comma = False
        if node.dest is not None:
            self.write(' >> ')
            self.visit(node.dest)
            want_comma = True
        for value in node.values:
            if want_comma:
                self.write(', ')
            self.visit(value)
            want_comma = True
        if not node.nl:
            self.write(',')

    def visit_Delete(self, node):
        self.newline(node)
        self.write('del ')
        for idx, target in enumerate(node.targets):
            if idx:
                self.write(', ')
            self.visit(target)

    def visit_TryExcept(self, node):
        self.newline(node)
        self.write('try:')
        self.body(node.body)
        for handler in node.handlers:
            self.visit(handler)
        self.body_or_else(node, body=False)

    def visit_TryFinally(self, node):
        self.newline(node)
        self.write('try:')
        self.body(node.body)
        self.newline(node)
        self.write('finally:')
        self.body(node.finalbody)

    def visit_Global(self, node):
        self.newline(node)
        self.write('global ' + ', '.join(node.names))

    def visit_Nonlocal(self, node):
        self.newline(node)
        self.write('nonlocal ' + ', '.join(node.names))

    def visit_Return(self, node):
        self.newline(node)
        self.write('return ')
        self.visit(node.value)

    def visit_Break(self, node):
        self.newline(node)
        self.write('break')

    def visit_Continue(self, node):
        self.newline(node)
        self.write('continue')

    def visit_Raise(self, node):
        # XXX: Python 2.6 / 3.0 compatibility
        self.newline(node)
        self.write('raise')
        self.write(' ')
        if hasattr(node, 'exc') and node.exc is not None:
            self.visit(node.exc)
            if node.cause is not None:
                self.write(' from ')
                self.visit(node.cause)
        elif hasattr(node, 'type') and node.type is not None:
            self.visit(node.type)
            if node.inst is not None:
                self.write(', ')
                self.visit(node.inst)
            if node.tback is not None:
                self.write(', ')
                self.visit(node.tback)

    # Expressions

    def visit_Attribute(self, node):
        self.visit(node.value)
        self.write('.' + node.attr)

    def visit_Call(self, node):
        want_comma = []
        def write_comma():
            if want_comma:
                self.write(', ')
            else:
                want_comma.append(True)

        self.visit(node.func)
        self.write('(')
        for arg in node.args:
            write_comma()
            self.visit(arg)
        for keyword in node.keywords:
            write_comma()
            self.write(keyword.arg + '=')
            self.visit(keyword.value)
        if node.starargs is not None:
            write_comma()
            self.write('*')
            self.visit(node.starargs)
        if node.kwargs is not None:
            write_comma()
            self.write('**')
            self.visit(node.kwargs)
        self.write(')')

    def visit_Name(self, node):
        self.write(node.id)

    def visit_Str(self, node):
        self.write(repr(node.s))

    def visit_Bytes(self, node):
        self.write(repr(node.s))

    def visit_Num(self, node):
        self.write(repr(node.n))

    def visit_Tuple(self, node):
        self.write('(')
        idx = -1
        for idx, item in enumerate(node.elts):
            if idx:
                self.write(', ')
            self.visit(item)
        self.write(idx and ')' or ',)')

    def sequence_visit(left, right):
        def visit(self, node):
            self.write(left)
            for idx, item in enumerate(node.elts):
                if idx:
                    self.write(', ')
                self.visit(item)
            self.write(right)
        return visit

    visit_List = sequence_visit('[', ']')
    visit_Set = sequence_visit('{', '}')
    del sequence_visit

    def visit_Dict(self, node):
        self.write('{')
        for idx, (key, value) in enumerate(zip(node.keys, node.values)):
            if idx:
                self.write(', ')
            self.visit(key)
            self.write(': ')
            self.visit(value)
        self.write('}')

    def visit_BinOp(self, node):
        self.write('(')
        self.visit(node.left)
        self.write(' %s ' % BINOP_SYMBOLS[type(node.op)])
        self.visit(node.right)
        self.write(')')

    def visit_BoolOp(self, node):
        self.write('(')
        for idx, value in enumerate(node.values):
            if idx:
                self.write(' %s ' % BOOLOP_SYMBOLS[type(node.op)])
            self.visit(value)
        self.write(')')

    def visit_Compare(self, node):
        self.write('(')
        self.visit(node.left)
        for op, right in zip(node.ops, node.comparators):
            self.write(' %s ' % CMPOP_SYMBOLS[type(op)])
            self.visit(right)
        self.write(')')

    def visit_UnaryOp(self, node):
        self.write('(')
        op = UNARYOP_SYMBOLS[type(node.op)]
        self.write(op)
        if op == 'not':
            self.write(' ')
        self.visit(node.operand)
        self.write(')')

    def visit_Subscript(self, node):
        self.visit(node.value)
        self.write('[')
        self.visit(node.slice)
        self.write(']')

    def visit_Slice(self, node):
        if node.lower is not None:
            self.visit(node.lower)
        self.write(':')
        if node.upper is not None:
            self.visit(node.upper)
        if node.step is not None:
            self.write(':')
            if not (isinstance(node.step, Name) and node.step.id == 'None'):
                self.visit(node.step)

    def visit_ExtSlice(self, node):
        for idx, item in node.dims:
            if idx:
                self.write(', ')
            self.visit(item)

    def visit_Yield(self, node):
        self.write('yield')
        if node.value is not None:
            self.write(' ')
            self.visit(node.value)

    def visit_Lambda(self, node):
        self.write('lambda ')
        self.signature(node.args)
        self.write(': ')
        self.visit(node.body)

    def visit_Ellipsis(self, node):
        self.write('Ellipsis')

    def generator_visit(left, right):
        def visit(self, node):
            self.write(left)
            self.visit(node.elt)
            for comprehension in node.generators:
                self.visit(comprehension)
            self.write(right)
        return visit

    visit_ListComp = generator_visit('[', ']')
    visit_GeneratorExp = generator_visit('(', ')')
    visit_SetComp = generator_visit('{', '}')
    del generator_visit

    def visit_DictComp(self, node):
        self.write('{')
        self.visit(node.key)
        self.write(': ')
        self.visit(node.value)
        for comprehension in node.generators:
            self.visit(comprehension)
        self.write('}')

    def visit_IfExp(self, node):
        self.visit(node.body)
        self.write(' if ')
        self.visit(node.test)
        self.write(' else ')
        self.visit(node.orelse)

    def visit_Starred(self, node):
        self.write('*')
        self.visit(node.value)

    def visit_Repr(self, node):
        # XXX: python 2.6 only
        self.write('`')
        self.visit(node.value)
        self.write('`')

    # Helper Nodes

    def visit_alias(self, node):
        self.write(node.name)
        if node.asname is not None:
            self.write(' as ' + node.asname)

    def visit_comprehension(self, node):
        self.write(' for ')
        self.visit(node.target)
        self.write(' in ')
        self.visit(node.iter)
        if node.ifs:
            for if_ in node.ifs:
                self.write(' if ')
                self.visit(if_)

    def visit_excepthandler(self, node):
        self.newline(node)
        self.write('except')
        if node.type is not None:
            self.write(' (')
            self.visit(node.type)
            self.write(',)')
            if node.name is not None:
                self.write(', ')
                self.visit(node.name)
        self.write(':')
        self.body(node.body)

    visit_ExceptHandler = visit_excepthandler

    def visit_Assert(self, node):
        self.newline(node)
        self.write('assert ')
        self.visit(node.test)
        if node.msg is not None:
            self.write(', ')
            self.visit(node.msg)


if __name__ == '__main__':
    import sys
    print to_source(parse(open(sys.argv[1]).read()))

########NEW FILE########
__FILENAME__ = collectors
# coding:utf-8
from __future__ import with_statement

import inspect
import re
import sys

from contextlib import contextmanager
from functools  import wraps
from time       import time

from attest           import statistics
from attest.contexts  import capture_output
from attest.reporters import auto_reporter, AbstractReporter, TestResult
from attest.utils     import (counter, import_dotted_name, deep_get_members,
                              nested)


__all__ = ['Tests',
           'test_if',
           'test',
           'TestBase',
          ]


class Tests(object):
    """Collection of test functions.

    :param tests:
        String, or iterable of values, suitable as argument(s) to
        :meth:`register`.
    :param contexts:
        Iterable of callables that take no arguments and return a context
        manager.
    :param replace_tests:
        If true, :meth:`test` returns the wrapper function rather than the
        original. This option is available for backwards-compatibility.
    :param replace_contexts:
        If true, :meth:`context` returns the context manager rather than
        the original generator function. Provided for
        backwards-compatibility.

    .. versionadded:: 0.6
        Pass a single string to `tests` without wrapping it in an iterable.

    .. versionadded:: 0.6
        The `replace_tests` and `replace_contexts` parameters. The
        decorator methods now default to simply registering functions and
        leaving the original in place. This allows functions to be
        decorated and registered with multiple collections easily.

    """

    def __init__(self, tests=(), contexts=None,
                 replace_tests=False, replace_contexts=False):
        self._tests = []
        if isinstance(tests, basestring):
            self.register(tests)
        else:
            for collection in tests:
                self.register(collection)
        self._contexts = []
        if contexts is not None:
            self._contexts.extend(contexts)
        self.replace_tests = replace_tests
        self.replace_contexts = replace_contexts

    def __iter__(self):
        return iter(self._tests)

    def __len__(self):
        return len(self._tests)

    def test_if(self, condition):
        """Returns :meth:`test` if the `condition` is ``True``.

        .. versionadded:: 0.4

        """
        if condition:
            return self.test
        return lambda x: x

    def test(self, func):
        """Decorate a function as a test belonging to this collection."""
        @wraps(func)
        def wrapper():
            with nested(self._contexts) as context:
                context = [c for c in context if c is not None]
                argc = len(inspect.getargspec(func)[0])
                args = []
                for arg in context:
                    if type(arg) is tuple:  # type() is intentional
                        args.extend(arg)
                    else:
                        args.append(arg)
                func(*args[:argc])
        wrapper.__wrapped__ = func
        self._tests.append(wrapper)
        if self.replace_tests:
            return wrapper
        return func

    def context(self, func):
        """Decorate a function as a :func:`~contextlib.contextmanager`
        for running the tests in this collection in. Corresponds to setup
        and teardown in other testing libraries.

        ::

            db = Tests()

            @db.context
            def connect():
                con = connect_db()
                try:
                    yield con
                finally:
                    con.disconnect()

            @db.test
            def using_connection(con):
                assert con is not None

        The above corresponds to::

            db = Tests()

            @contextmanager
            def connect():
                con = connect_db()
                try:
                    yield con
                finally:
                    con.disconnect()

            @db.test
            def using_connection():
                with connect() as con:
                    assert con is not None

        The difference is that this decorator applies the context to all
        tests defined in its collection, so it's less repetitive.

        Yielding :const:`None` or nothing passes no arguments to the test,
        yielding a single value other than a tuple passes that value as
        the sole argument to the test, yielding a tuple splats the tuple
        as the arguments to the test. If you want to yield a tuple as
        the sole argument, wrap it in a one-tuple or unsplat the args
        in the test.

        You can have more than one context, which will be run in order
        using :func:`contextlib.nested`, and their yields will be passed in
        order to the test functions.

        .. versionadded:: 0.2 Nested contexts.

        .. versionchanged:: 0.5
            Tests will gets as many arguments as they ask for.

        """
        context = contextmanager(func)
        context.__wrapped__ = func
        self._contexts.append(context)
        if self.replace_contexts:
            return context
        return func

    def register_if(self, condition):
        """Returns :meth:`register` if the `condition` is ``True``.

        .. versionadded:: 0.4

        """
        if condition:
            return self.register
        return lambda x: x

    def register(self, tests):
        """Merge in other tests.

        :param tests:
            * A class, which is then instantiated and return allowing it to be
              used as a decorator for :class:`TestBase` classes.
            * A string, representing the dotted name to one of:

              * a module or package, which is recursively scanned for
                :class:`Tests` instances that are not private
              * an iterable yielding tests
            * Otherwise any iterable object is assumed to yield tests.

        Any of these can be passed in a list to the :class:`Tests`
        constructor.

        .. versionadded:: 0.2
            Refer to collections by import path as a string

        .. versionadded:: 0.6
            Recursive scanning of modules and packages

        .. versionchanged:: 0.6
            Tests are only added if not already added

        """
        if inspect.isclass(tests):
            self._tests.extend(tests())
            return tests
        elif isinstance(tests, basestring):
            def istests(obj):
                return isinstance(obj, Tests)
            obj = import_dotted_name(tests)
            if inspect.ismodule(obj):
                for tests in deep_get_members(tests, istests):
                    self.register(tests)
                return
            tests = obj
        for test in tests:
            if not test in self._tests:
                self._tests.append(test)

    def test_suite(self):
        """Create a :class:`unittest.TestSuite` instance from this collection.

        """
        from unittest import TestSuite, FunctionTestCase
        suite = TestSuite()
        for test in self:
            suite.addTest(FunctionTestCase(test))
        return suite

    def test_case(self):
        """Create a :class:`unittest.TestCase` class from this collection.

        Tests in the collection are added as instance methods on the
        ``TestCase``. Method names are prefixed with ``test_`` if they're not
        already. Duplicate method names are given a ``_#`` suffix.

        .. testsetup::

            from attest import Tests

        Example::

            >>> suite = Tests()
            >>> @suite.test
            ... def simple():
            ...     pass
            ...
            >>> @suite.test
            ... def simple():
            ...     pass
            ...
            >>> TestCase = suite.test_case()
            >>> assert TestCase.test_simple
            >>> assert TestCase.test_simple_2

        """
        from unittest import TestCase
        counts = counter()
        methods = {}
        for func in self:
            # handle <lambda>
            name = re.sub("[^a-zA-Z0-9_]", "", func.__name__)
            if not name:
                name = "unnamed"
            if not name.startswith("test_"):
                name = "test_%s" % (name, )
            count = counts.increment(name)
            if count > 1:
                name = "%s_%s" % (name, count)
            methods[name] = staticmethod(func)
        return type("Tests", (TestCase, ), methods)

    def run(self, reporter=auto_reporter,
            full_tracebacks=False, fail_fast=False,
            debugger=False, no_capture=False, keyboard_interrupt=False):
        """Run all tests in this collection.

        :param reporter:
            An instance of :class:`~attest.reporters.AbstractReporter` or a
            callable returning something implementing that API (not
            enforced).
        :param full_tracebacks:
            Control if the call stack of Attest is hidden in tracebacks.
        :param fail_fast:
            Stop after the first failure.
        :param debugger:
            Enter PDB when tests fail.
        :param keyboard_interrupt:
            Let KeyboardInterrupt exceptions (CTRL+C) propagate.

        .. versionchanged:: 0.6 Added `full_tracebacks` and `fail_fast`.

        """
        assertions, statistics.assertions = statistics.assertions, 0
        if not isinstance(reporter, AbstractReporter):
            reporter = reporter()
        reporter.begin(self._tests)
        for test in self:
            result = TestResult(test=test, full_tracebacks=full_tracebacks,
                                debugger=debugger)
            result.time = time()
            try:
                out, err = [], []
                if no_capture:
                    if test() is False:
                        raise AssertionError('test() is False')
                else:
                    with capture_output() as (out, err):
                        if test() is False:
                            raise AssertionError('test() is False')
            except KeyboardInterrupt:
                if keyboard_interrupt:
                    raise
                else:
                    break
            except BaseException, e:
                result.time = time() - result.time
                result.error = e
                result.stdout, result.stderr = out, err
                result.exc_info = sys.exc_info()
                reporter.failure(result)
                if fail_fast:
                    break
            else:
                result.time = time() - result.time
                result.stdout, result.stderr = out, err
                reporter.success(result)
        try:
            reporter.finished()
        finally:
            statistics.assertions = assertions

    def main(self):
        """Interface to :meth:`run` with command-line options.

        ``-h``, ``--help``
            Show a help message

        ``-r NAME``, ``--reporter NAME``
            Select reporter by name with
            :func:`~attest.reporters.get_reporter_by_name`

        ``--full-tracebacks``
            Show complete tracebacks without hiding Attest's own call stack

        ``-l``, ``--list-reporters``
            List the names of all installed reporters

        ``-p FILENAME``, ``--profile FILENAME``
            Run the tests in cProfile and store the results in FILENAME


        Remaining arguments are passed to the reporter.

        .. versionadded:: 0.2

        .. versionchanged:: 0.4 ``--list-reporters`` was added.

        .. versionchanged:: 0.6 ``--full-tracebacks`` was added.

        """
        from attest.run import main
        main(self)


def test_if(condition):
    """Returns :func:`test` if the `condition` is ``True``.

    .. versionadded:: 0.4

    """
    if condition:
        return test
    return lambda x: x


def test(meth):
    """Mark a :class:`TestBase` method as a test and wrap it to run in the
    :meth:`TestBase.__context__` of the subclass.

    """
    @wraps(meth)
    def wrapper(self):
        with contextmanager(self.__context__)():
            meth(self)
    wrapper.__test__ = True
    return wrapper


class TestBase(object):
    """Base for test classes. Decorate test methods with :func:`test`. Needs
    to be registered with a :class:`Tests` collection to be run. For setup
    and teardown, override :meth:`__context__` like a
    :func:`~contextlib.contextmanager` (without the decorator).

    ::

        class Math(TestBase):

            def __context__(self):
                self.two = 1 + 1
                yield
                del self.two

            @test
            def arithmetics(self):
                assert self.two == 2

        suite = Tests([Math()])
        suite.run()

    """

    def __context__(self):
        yield

    def __iter__(self):
        for name in dir(self):
            attr = getattr(self, name)
            if getattr(attr, '__test__', False) and callable(attr):
                yield attr

########NEW FILE########
__FILENAME__ = contexts
import sys

from contextlib import contextmanager
from shutil     import rmtree
from tempfile   import mkdtemp

try:
    from cStringIO import StringIO
except ImportError:
    from StringIO  import StringIO

from attest            import statistics
from attest.deprecated import _repr


__all__ = ['capture_output',
           'disable_imports',
           'Error',
           'raises',
           'tempdir',
           'warns',
          ]


@contextmanager
def capture_output():
    """Captures standard output and error during the context. Returns a
    tuple of the two streams as lists of lines, added after the context has
    executed.

    .. testsetup::

        from attest import capture_output

    >>> with capture_output() as (out, err):
    ...    print 'Captured'
    ...
    >>> out
    ['Captured']

    """
    stdout, stderr = sys.stdout, sys.stderr
    sys.stdout, sys.stderr = StringIO(), StringIO()
    out, err = [], []
    try:
        yield out, err
    finally:
        out.extend(sys.stdout.getvalue().splitlines())
        err.extend(sys.stderr.getvalue().splitlines())
        sys.stdout, sys.stderr = stdout, stderr


@contextmanager
def disable_imports(*names):
    """Blocks the given `names` from being imported inside the context.
    This is useful for testing import-dependent fallbacks.

    .. testsetup::

        from attest import disable_imports

    >>> with disable_imports('sys'):
    ...     import sys
    ...
    Traceback (most recent call last):
    ImportError: 'sys' is disabled

    .. versionadded:: 0.4

    """
    import __builtin__
    import_ = __builtin__.__import__
    def __import__(name, *args, **kwargs):
        if name in names:
            raise ImportError('%r is disabled' % name)
        return import_(name, *args, **kwargs)
    __builtin__.__import__ = __import__
    try:
        yield
    finally:
        __builtin__.__import__ = import_


class Error(object):
    """Container of metadata for an exception caught by :func:`raises`.

    Attribute access and string adaption is forwarded to the exception
    object. To test the type however you need to use the :attr:`exc`
    attribute directly.

    .. versionadded:: 0.5

    """

    #: The actual exception instance.
    exc = None

    def __getattr__(self, name):
        return getattr(self.exc, name)

    def __str__(self):
        return str(self.exc)

    def __repr__(self):
        return u'<Error %s>' % repr(self.exc)


@contextmanager
def raises(*exceptions):
    """Fails if none of the `exceptions` are raised inside the context.
    This reverses failure semantics and is useful for testing code that
    uses exceptions as part of its API.

    .. testsetup::

        from attest import raises

    >>> with raises(IOError) as error:
    ...    open('/etc/passwd', 'w')
    ...
    >>> error.errno
    13

    :param exceptions: Expected exception classes.
    :returns: An :class:`Error` on which the caught exception is set after
        the context has executed, if one was raised.
    :raises AssertionError: If none of the expected exceptions are raised
        in the context.

    .. versionadded:: 0.5

    .. autoclass:: Error
        :members:

    """
    statistics.assertions += 1
    error = Error()
    try:
        yield error
    except exceptions, e:
        error.exc = e
    else:
        exceptions = exceptions[0] if len(exceptions) == 1 else exceptions
        raise AssertionError("didn't raise %s when expected" % _repr(exceptions))


@contextmanager
def tempdir(*args, **kwargs):
    """Creates a temporary directory, removing it and everything in it when
    the context exits. For files you can use
    :func:`~tempfile.TemporaryFile` as a context manager.

    Returns the path to the directory. Arguments are passed to
    :func:`~tempfile.mkdtemp`.

    .. versionadded:: 0.6

    """
    d = mkdtemp(*args, **kwargs)
    try:
        yield d
    finally:
        rmtree(d)


@contextmanager
def warns(*warnings, **opts):
    """Context manager that succeeds if all `warnings` are issued inside the
    context. Yields a list of matching captured warnings as exception objects.

    .. testsetup::

        from attest import warns
        import warnings

    >>> with warns(UserWarning) as captured:
    ...     warnings.warn("Example warning", UserWarning)
    ...
    >>> unicode(captured[0]) == "Example warning"
    True

    :param any: Require only *one* of the warnings to be issued (rather than
        all).

    .. note::

        :mod:`warnings` filtering is overridden to ``"always"`` for monitored
        warnings.

    """
    import warnings as warnings_

    captured = []
    old_filters, old_showwarning = warnings_.filters, warnings_.showwarning
    warnings_.filters = old_filters[:]

    def showwarning(message, category, *args, **kwargs):
        if category not in warnings:
            old_showwarning(message, category, *args, **kwargs)
            return
        captured.append(message)
    warnings_.showwarning = showwarning

    for warning in warnings:
        warnings_.simplefilter("always", warning)

    try:
        yield captured
        if opts.get("any", False):
            assert captured
        else:
            assert set(warnings) == set(map(type, captured))
    finally:
        warnings_.filters = old_filters
        warnings_.showwarning = old_showwarning

########NEW FILE########
__FILENAME__ = deprecated
import inspect

from contextlib import contextmanager

from attest import statistics


__all__ = ['Loader',
           'assert_',
           'Assert',
          ]


class Loader(object):
    """Run tests with Attest via distribute.

    .. deprecated:: 0.5
        :meth:`~attest.reporters.AbstractReporter.test_loader` is preferred.

    """

    def loadTestsFromNames(self, names, module=None):
        mod, collection = names[0].rsplit('.', 1)
        mod = __import__(mod, fromlist=[collection])
        collection = getattr(mod, collection)
        collection.run()
        raise SystemExit


def assert_(expr, msg=None):
    """Like `assert`, but counts the assertion.

    .. deprecated:: 0.5 :func:`~attest.eval.assert_hook` is preferred.

    """
    statistics.assertions += 1
    if not expr:
        if msg is None:
            raise AssertionError
        raise AssertionError(msg)
    return expr


class Assert(object):
    """Wrap an object such that boolean operations on it fails with an
    :exc:`AssertionError` if the operation results in :const:`False`,
    with more helpful error messages on failure than `assert`.

    A test failure is simply an unhandled exception, so it is completely
    optional to use this class.

    Examples::

        Assert(1 + 1) == 2
        2 in Assert([1, 2, 3])

    Attributes are proxied to the wrapped object, returning the result
    wrapped as well::

        hello = Assert('hello')
        hello == 'hello'
        hello.upper() == 'HELLO'
        hello.capitalize() == 'Hello'

    Used in boolean context, fails if non-true. These all fail::

        bool(Assert(0))
        if Assert(0): pass
        assert Assert(0)

    Identical to, except for the more helpful failure message::

        Assert(bool(0)) == True

    If you pass more than one argument, the first is assumed to be a
    predicate callable to which the rest of the arguments are passed. These
    are identical::

        Assert.isinstance(0, int)
        Assert(isinstance, 0, int)

    .. deprecated:: 0.5 :func:`~attest.eval.assert_hook` is preferred.

    """

    #: The wrapped object
    obj = None

    def __init__(self, *args):
        if len(args) == 1:
            obj = args[0]
            if isinstance(obj, Assert):
                self.obj = obj.obj
            else:
                self.obj = obj
        elif len(args) > 1:
            args = list(args)
            predicate = args.pop(0)
            name = predicate.__name__
            arglist = ', '.join(map(_repr, args))
            self.obj = assert_(predicate(*args),
                               'not %s(%s)' % (name, arglist))

    @property
    def __class__(self):
        return Assert(self.obj.__class__)

    def __str__(self):
        """Wrapped proxy to the wrapped object's *__str__*, can be used for
        testing the string adaption of the object::

            Assert(1).__str__() == '1'

        .. warning:: :func:`str` on :class:`Assert` objects does not work.

        """
        return Assert(self.obj.__str__())

    def __getattr__(self, name):
        """Proxy all attributes to the wrapped object, wrapping the
        result.

        """
        return Assert(getattr(self.obj, name))

    def __call__(self, *args, **kwargs):
        """Allow calling of wrapped callables, wrapping the return value.
        Useful for testing methods on a wrapped object via attribute
        proxying::

            Assert('Hello').upper() == 'HELLO'

        """
        return Assert(self.obj(*args, **kwargs))

    def __getitem__(self, key):
        """Access an item on the wrapped object and return the result
        wrapped as well.

        ::

            Assert([1, 2, 3])[1] == 2

        """
        return Assert(self.obj[key])

    def __eq__(self, obj):
        """Test for equality with ``==``."""
        return assert_(self.obj == obj, '%r != %r' % (self.obj, obj))

    def __ne__(self, obj):
        """Test for inequality with ``!=``."""
        return assert_(self.obj != obj, '%r == %r' % (self.obj, obj))

    def is_(self, obj):
        """The `is` operator is not overridable, for good reasons
        (that would defeat its purpose), so you can use this method for
        asserting identity::

            Assert(True).is_(True)

        .. versionchanged:: 0.3
            Checks the wrapped object for :class:`Assert` instances.

        """
        if isinstance(obj, Assert):
            obj = obj.obj
        return assert_(self.obj is obj, '%r is not %r' % (self.obj, obj))

    def is_not(self, obj):
        """The negated form of :meth:`is_`, corresponding to the ``is not``
        operation::

            Assert([]).is_not([])

        .. versionchanged:: 0.3
            Checks the wrapped object for :class:`Assert` instances.

        """
        if isinstance(obj, Assert):
            obj = obj.obj
        return assert_(self.obj is not obj, '%r is %r' % (self.obj, obj))

    def __contains__(self, obj):
        """Test for membership with `in`."""
        return assert_(obj in self.obj, '%r not in %r' % (obj, self.obj))

    def in_(self, obj):
        """Assert membership. While you can use the `in` operator,
        its order is inconsistent with the rest of the operators and doesn't
        work with the ``not in`` operation.

        ::

            2 in Assert([1, 2, 3])
            Assert(2).in_([1, 2, 3])

        """
        return assert_(self.obj in obj, '%r not in %r' % (self.obj, obj))

    def not_in(self, obj):
        """The negated form of :meth:`in_`, corresponding to the ``not in``
        operation

        ::

            Assert(0).not_in([1, 2, 3])

        """
        return assert_(self.obj not in obj, '%r in %r' % (self.obj, obj))

    def __lt__(self, obj):
        """Test for lesserness with ``<``."""
        return assert_(self.obj < obj, '%r >= %r' % (self.obj, obj))

    def __le__(self, obj):
        """Test for lesserness or equality with ``<=``."""
        return assert_(self.obj <= obj, '%r > %r' % (self.obj, obj))

    def __gt__(self, obj):
        """Test for greaterness with ``>``."""
        return assert_(self.obj > obj, '%r <= %r' % (self.obj, obj))

    def __ge__(self, obj):
        """Test for greaterness or equality with ``>=``."""
        return assert_(self.obj >= obj, '%r < %r' % (self.obj, obj))

    def __nonzero__(self):
        """Test for truthiness in boolean context."""
        return bool(assert_(self.obj, 'not %r' % self.obj))

    @staticmethod
    @contextmanager
    def raises(*exceptions):
        """Context manager that fails if *none* of the `exceptions` are
        raised. Yields the captured exception as an :term:`assertive
        object`.

        ::

            with Assert.raises(IOError) as error:
                open('/etc/passwd', 'w')

            error.errno == 13

        :param exceptions: Expected exception classes.

        """
        statistics.assertions += 1
        proxy = Assert()
        try:
            yield proxy
        except exceptions, error:
            proxy.obj = error
        else:
            if len(exceptions) > 1:
                errors = '(' + ', '.join(e.__name__ for e in exceptions) + ')'
            else:
                errors = exceptions[0].__name__
            raise AssertionError("didn't raise %s" % errors)

    @staticmethod
    @contextmanager
    def not_raising(exception):
        """Context manager that fails if a particular exception is raised.
        A raised exception constitutes a failure anyway and this is mainly
        used for testing Attest itself.

        ::

            with Assert.not_raising(IOError):
                open('/etc/passwd', 'r')

        :param exception: An exception class.

        """
        statistics.assertions += 1
        try:
            yield
        except exception:
            raise AssertionError('raised %s' % exception.__name__)

    @staticmethod
    def isinstance(obj, classinfo):
        """Test that an object is an instance of a class or a :func:`tuple`
        of classes. Corresponds to :func:`.isinstance`.

        .. versionadded:: 0.4

        """
        if isinstance(obj, Assert):
            obj = obj.obj
        return assert_(isinstance(obj, classinfo),
                       'not isinstance(%r, %s)' % (obj, _repr(classinfo)))

    @staticmethod
    def not_isinstance(obj, classinfo):
        """Negated version of :meth:`isinstance`.

        .. versionadded:: 0.4

        """
        if isinstance(obj, Assert):
            obj = obj.obj
        return assert_(not isinstance(obj, classinfo),
                       'isinstance(%r, %s)' % (obj, _repr(classinfo)))

    @staticmethod
    def issubclass(obj, cls):
        """Test that `obj` is a subclass of `cls` or a subclass of a class
        inside `cls`. Corresponds to :func:`.issubclass`.

        .. versionadded:: 0.4

        """
        if isinstance(obj, Assert):
            obj = obj.obj
        return assert_(issubclass(obj, cls),
                       'not issubclass(%s, %s)' % (_repr(obj), _repr(cls)))

    @staticmethod
    def not_issubclass(obj, cls):
        """Negated version of :meth:`issubclass`.

        .. versionadded:: 0.4

        """
        if isinstance(obj, Assert):
            obj = obj.obj
        return assert_(not issubclass(obj, cls),
                       'issubclass(%s, %s)' % (_repr(obj), _repr(cls)))

    @property
    def json(self):
        """Parse the wrapped object as JSON. Requires Python 2.6 or the
        simplejson package.

        .. versionadded:: 0.4

        """
        try:
            import simplejson as json
        except ImportError:
            import json
        return Assert(json.loads(self.obj))

    def css(self, selector):
        """Parse the wrapped object as :abbr:`HTML
        (HyperText Markup Language)` and return an :term:`assertive
        <assertive object>` list of elements matching the :abbr:`CSS
        (Cascading Style Sheets)` `selector`.  Requires lxml 2.0 or newer.

        .. note::

            Not tested on Python 2.5 and PyPy due to difficulties
            installing lxml for these implementations.

        .. versionadded:: 0.4

        """
        from lxml import html
        return Assert(html.fromstring(self.obj).cssselect(selector))

    def xpath(self, path):
        """Parse the wrapped object as :abbr:`XML
        (eXtensible Markup Language)` and return an :term:`assertive
        <assertive object>` list of elements matching the :abbr:`XPath
        (XML Path Language)` *path*.  Requires lxml 2.0 or newer.

        .. note::

            Not tested on Python 2.5 and PyPy due to difficulties
            installing lxml for these implementations.

        .. versionadded:: 0.4

        """
        from lxml import etree
        return Assert(etree.fromstring(self.obj).xpath(path))

    def passed_to(self, func, *args, **kwargs):
        """Pass the unwrapped object to a function and return its result
        as an :term:`assertive object`.

        These are identical::

            Assert(len([1, 2, 3])) == 3
            Assert([1, 2, 3]).passed_to(len) == 3

        Mainly useful with Assert objects that comes from the outside, e.g.
        yielded from a context, from methods like :meth:`css` etc.

        .. versionadded:: 0.4

        """
        return Assert(func(self.obj, *args, **kwargs))

    def attr(self, name):
        """Safely get an attribute from the wrapped object.

        .. versionadded:: 0.4

        """
        return Assert(getattr(self.obj, name))

    def __repr__(self):
        """Not proxied to the wrapped object. To test that do something
        like::

            Assert(repr(obj)) == 'expectation'

        """
        return 'Assert(%r)' % self.obj


def _repr(obj):
    """Internal :func:`repr` that tries to be more close to original
    code.

    """
    if inspect.isclass(obj):
        return obj.__name__
    elif type(obj) is tuple:
        return '(%s)' % ', '.join(map(_repr, obj))
    return repr(obj)

########NEW FILE########
__FILENAME__ = hook
from __future__ import with_statement

import imp
import inspect
import os
import sys

from attest         import ast, statistics
from attest.codegen import to_source, SourceGenerator


__all__ = ['COMPILES_AST',
           'ExpressionEvaluator',
           'TestFailure',
           'assert_hook',
           'AssertTransformer',
           'AssertImportHook',
          ]


try:
    compile(ast.parse('pass'), '<string>', 'exec')
except TypeError:
    COMPILES_AST = False
else:
    COMPILES_AST = True


class ExpressionEvaluator(SourceGenerator):
    """Evaluates ``expr`` in the context of ``globals`` and ``locals``,
    expanding the values of variables and the results of binary operations, but
    keeping comparison and boolean operators.

    .. testsetup::

        from attest import ExpressionEvaluator

    >>> var = 1 + 2
    >>> value = ExpressionEvaluator('var == 5 - 3', globals(), locals())
    >>> value.late_visit()
    >>> repr(value)
    '(3 == 2)'
    >>> bool(value)
    False

    .. versionadded:: 0.5

    """

    def __init__(self, expr, globals, locals):
        self.expr = expr
        # Putting locals in globals for closures
        self.globals = dict(globals)
        self.locals = locals
        self.globals.update(self.locals)

        self.result = []
        self.node = ast.parse(self.expr).body[0].value

    # Trigger visit after init because we don't want to
    # evaluate twice in case of a successful assert
    def late_visit(self):
        self.visit(self.node)

    def __repr__(self):
        return ''.join(self.result)

    def __str__(self):
        return '\n'.join((self.expr, repr(self)))

    def __nonzero__(self):
        return bool(eval(self.expr, self.globals, self.locals))

    def eval(self, node):
        return eval(to_source(node), self.globals, self.locals)

    def write(self, s):
        self.result.append(str(s))

    def visit_Name(self, node):
        value = self.eval(node)
        if getattr(value, '__name__', None):
            self.write(value.__name__)
        else:
            self.write(repr(value))

    def generic_visit(self, node):
        self.write(repr(self.eval(node)))

    visit_BinOp = visit_Subscript = generic_visit
    visit_ListComp = visit_GeneratorExp = generic_visit
    visit_SetComp = visit_DictComp = generic_visit
    visit_Call = visit_Attribute = generic_visit


class TestFailure(AssertionError):
    """Extended :exc:`AssertionError` used by the assert hook.

    :param value: The asserted expression evaluated with
        :class:`ExpressionEvaluator`.
    :param msg: Optional message passed to the assertion.

    .. versionadded:: 0.5

    """

    def __init__(self, value, msg=''):
        self.value = value
        AssertionError.__init__(self, msg)


def assert_hook(expr, msg='', globals=None, locals=None):
    """Like ``assert``, but using :class:`ExpressionEvaluator`. If
    you import this in test modules and the :class:`AssertImportHook` is
    installed (which it is automatically the first time you import from
    :mod:`attest`), ``assert`` statements are rewritten as a call to
    this.

    The import must be a top-level *from* import, example::

        from attest import Tests, assert_hook

    .. versionadded:: 0.5

    """
    statistics.assertions += 1
    if globals is None:
        globals = inspect.stack()[1][0].f_globals
    if locals is None:
        locals = inspect.stack()[1][0].f_locals
    value = ExpressionEvaluator(expr, globals, locals)
    if not value:
        # Visit only if assertion fails
        value.late_visit()
        raise TestFailure(value, msg)


# Build AST nodes on 2.5 more easily
def _build(node, **kwargs):
    node = node()
    for key, value in kwargs.iteritems():
        setattr(node, key, value)
    return node


class AssertTransformer(ast.NodeTransformer):
    """Parses `source` with :mod:`_ast` and transforms `assert`
    statements into calls to :func:`assert_hook`.

    .. warning::

        CPython 2.5 doesn't compile AST nodes and when that fails this
        transformer will generate source code from the AST instead. While
        Attest's own tests passes on CPython 2.5, there might be code that
        it currently would render back incorrectly, most likely resulting
        in a failure. Because Python's syntax is simple, this isn't very
        likely, but you might want to :meth:`~AssertImportHook.disable` the
        import hook if you test regularly on CPython 2.5.

        It also messes up the line numbers so they don't match the original
        source code, meaning tracebacks will point to the line numbers in
        the *generated* source and preview the code on that line in the
        *original* source. The improved error message with the import hook
        is often worth it however, and failures will still point to the
        right file and function.

    .. versionadded:: 0.5

    """

    def __init__(self, source, filename=''):
        self.source = source
        self.filename = filename

    @property
    def should_rewrite(self):
        """:const:`True` if the source imports :func:`assert_hook`."""
        return ('assert_hook' in self.source and
                any(s.module == 'attest' and
                    any(n.name == 'assert_hook' for n in s.names)
                    for s in ast.parse(self.source).body
                    if isinstance(s, ast.ImportFrom)))

    def make_module(self, name, newpath=None):
        """Compiles the transformed code into a module object which it also
        inserts in :data:`sys.modules`.

        :returns: The module object.

        """
        module = imp.new_module(name)
        module.__file__ = self.filename
        if newpath:
            module.__path__ = newpath
        sys.modules[name] = module
        exec self.code in vars(module)
        return module

    @property
    def node(self):
        """The transformed AST node."""
        node = ast.parse(self.source, self.filename)
        node = self.visit(node)
        ast.fix_missing_locations(node)
        return node

    @property
    def code(self):
        """The :attr:`node` compiled into a code object."""
        if COMPILES_AST:
            return compile(self.node, self.filename, 'exec')
        return compile(to_source(self.node), self.filename, 'exec')

    def visit_Assert(self, node):
        args = [_build(ast.Str, s=to_source(node.test)),
                node.msg if node.msg is not None else _build(ast.Str, s=''),
                _build(ast.Call,
                    func=_build(ast.Name, id='globals', ctx=ast.Load()),
                    args=[], keywords=[], starargs=None, kwargs=None),
                _build(ast.Call,
                    func=_build(ast.Name, id='locals', ctx=ast.Load()),
                    args=[], keywords=[], starargs=None, kwargs=None)
               ]
        return ast.copy_location(
            _build(ast.Expr, value=_build(ast.Call,
                   func=_build(ast.Name, id='assert_hook', ctx=ast.Load()),
                   args=args, keywords=[], starargs=None, kwargs=None)), node)


class AssertImportHookEnabledDescriptor(object):

    def __get__(self, instance, owner):
        return any(isinstance(ih, owner) for ih in sys.meta_path)


class AssertImportHook(object):
    """An :term:`importer` that transforms imported modules with
    :class:`AssertTransformer`.

    .. versionadded:: 0.5

    """

    #: Class property, :const:`True` if the hook is enabled.
    enabled = AssertImportHookEnabledDescriptor()

    @classmethod
    def enable(cls):
        """Enable the import hook."""
        cls.disable()
        sys.meta_path.insert(0, cls())

    @classmethod
    def disable(cls):
        """Disable the import hook."""
        sys.meta_path[:] = [ih for ih in sys.meta_path
                               if not isinstance(ih, cls)]

    def __init__(self):
        self._cache = {}

    def __enter__(self):
        sys.meta_path.insert(0, self)

    def __exit__(self, exc_type, exc_value, traceback):
        sys.meta_path.remove(self)

    def find_module(self, name, path=None):
        lastname = name.rsplit('.', 1)[-1]
        try:
            self._cache[name] = imp.find_module(lastname, path), path
        except ImportError:
            return
        return self

    def load_module(self, name):
        if name in sys.modules:
            return sys.modules[name]

        source, filename, newpath = self.get_source(name)
        (fd, fn, info), path = self._cache[name]

        if source is None:
            return imp.load_module(name, fd, fn, info)

        transformer = AssertTransformer(source, filename)

        if not transformer.should_rewrite:
            fd, fn, info = imp.find_module(name.rsplit('.', 1)[-1], path)
            return imp.load_module(name, fd, fn, info)

        try:
            return transformer.make_module(name, newpath)
        except Exception, err:
            raise ImportError('cannot import %s: %s' % (name, err))

    def get_source(self, name):
        try:
            (fd, fn, info), path = self._cache[name]
        except KeyError:
            raise ImportError(name)

        code = filename = newpath = None
        if info[2] == imp.PY_SOURCE:
            filename = fn
            with fd:
                code = fd.read()
        elif info[2] == imp.PY_COMPILED:
            filename = fn[:-1]
            with open(filename, 'U') as f:
                code = f.read()
        elif info[2] == imp.PKG_DIRECTORY:
            filename = os.path.join(fn, '__init__.py')
            newpath = [fn]
            with open(filename, 'U') as f:
                code = f.read()

        return code, filename, newpath

########NEW FILE########
__FILENAME__ = pygments
from __future__ import absolute_import
from pygments.style import Style
from pygments.token import *


COLOR_1 = '#e6dccc'
COLOR_2 = '#1e214f'
COLOR_3 = '#b5242e'
COLOR_4 = '#1e4f34'
COLOR_5 = '#537b99'


class Attest(Style):
    default_style = ""
    styles = {
        Comment: 'italic ' + COLOR_5,
        Keyword: 'bold ' + COLOR_2,
        Operator: 'bold ' + COLOR_4,
        Punctuation: '#777',
        Number: COLOR_4,
        Name: '#000',
        Name.Decorator: 'bold ' + COLOR_2,
        Name.Builtin: COLOR_2,
        Name.Exception: 'bold ' + COLOR_3,
        Generic.Error: 'bold ' + COLOR_3,
        String: COLOR_3
    }

########NEW FILE########
__FILENAME__ = reporters
# coding:utf-8
from __future__ import absolute_import, with_statement

import inspect
import os
import sys
import traceback
import unittest
import _ast

from os            import path
from pkg_resources import iter_entry_points
from datetime      import datetime
try:
    from abc import ABCMeta, abstractmethod
except ImportError:
    ABCMeta = type
    abstractmethod = lambda x: x

from attest      import statistics, utils
from attest.hook import (ExpressionEvaluator,
                         TestFailure,
                         COMPILES_AST,
                         AssertImportHook)


# TODO: find some better test
ANSI_COLORS_SUPPORT = True
if sys.platform == 'win32':
    try:
        import colorama
    except ImportError:
        ANSI_COLORS_SUPPORT = False
    else:
        colorama.init()


__all__ = ['TestResult',
           'AbstractReporter',
           'PlainReporter',
           'FancyReporter',
           'auto_reporter',
           'XmlReporter',
           'XUnitReporter',
           'QuickFixReporter',
           'get_reporter_by_name',
           'get_all_reporters',
          ]


class TestResult(object):
    """Container for result data from running a test.

    .. versionadded:: 0.4

    """

    def __init__(self, **kwargs):
        for key, value in kwargs.iteritems():
            setattr(self, key, value)

    full_tracebacks = False

    debugger = False

    #: The test callable.
    test = None

    #: The exception instance, if the test failed.
    error = None

    #: The :func:`~sys.exc_info` of the exception, if the test failed.
    exc_info = None

    #: A list of lines the test printed on the standard output.
    stdout = None

    #: A list of lines the test printed on the standard error.
    stderr = None

    def debug(self):
        if self.debugger:
            import pdb
            tb = self.exc_info[2]
            pdb.post_mortem(tb)

    @property
    def test_name(self):
        """A representative name for the test, similar to its import path.

        """
        parts = []
        if self.test.__module__ != '__main__':
            parts.append(self.test.__module__)
        if hasattr(self.test, 'im_class'):
            parts.append(self.test.im_class.__name__)
        parts.append(self.test.__name__)
        return '.'.join(parts)

    @property
    def raw_traceback(self):
        """Like :func:`traceback.extract_tb` with uninteresting entries
        removed.

        .. versionadded:: 0.5

        """
        tb = traceback.extract_tb(self.exc_info[2])
        if self.full_tracebacks:
            return tb
        if not COMPILES_AST and AssertImportHook.enabled:
            newtb = []
            for filename, lineno, funcname, text in tb:
                newtb.append((filename, 0, funcname, None))
            tb = newtb
        clean = []
        thisfile = path.abspath(path.dirname(__file__))
        for item in tb:
            failfile = path.abspath(path.dirname(item[0]))
            if failfile != thisfile:
                clean.append(item)
        return clean

    @property
    def traceback(self):
        """The traceback for the exception, if the test failed, cleaned up.

        """
        clean = self.raw_traceback
        lines = ['Traceback (most recent call last):\n']
        lines += traceback.format_list(clean)
        msg = str(self.error)
        lines += traceback.format_exception_only(self.exc_info[0], msg)
        return ''.join(lines)[:-1]

    @property
    def assertion(self):
        if isinstance(self.error, TestFailure):
            expressions = str(self.error.value)
            return '\n'.join('assert %s' % expr
                             for expr in expressions.splitlines())

    @property
    def equality_diff(self):
        if not isinstance(self.error, TestFailure):
            return
        # Create a dummy test case to use its assert* methods
        case = unittest.FunctionTestCase(lambda: None)
        case.maxDiff = 2000
        # Type-specific methods are only available since Python 2.7
        if hasattr(case, '_type_equality_funcs'):
            node = self.error.value.node
            if (isinstance(node, _ast.Compare) and len(node.ops) == 1 and
                    isinstance(node.ops[0], _ast.Eq)):
                # The assertion is something like 'left == right'
                left = self.error.value.eval(node.left)
                right = self.error.value.eval(node.comparators[0])
                if type(left) is type(right):
                    asserter = case._type_equality_funcs.get(type(left))
                    if asserter is not None:
                        if isinstance(asserter, basestring):
                            asserter = getattr(case, asserter)
                        try:
                            asserter(left, right)
                        except AssertionError, exc:
                            return '%s\n' % exc.args[0]


def _test_loader_factory(reporter):
    class Loader(object):
        def loadTestsFromNames(self, names, module=None):
            from .collectors import Tests
            Tests(names).run(reporter)
            raise SystemExit
    return Loader()


class AbstractReporter(object):
    """Optional base for reporters, serves as documentation and improves
    errors for incomplete reporters.

    """

    __metaclass__ = ABCMeta

    @classmethod
    def test_loader(cls):
        """Creates a basic unittest test loader using this reporter. This
        can be used to run tests via distribute, for example::

            setup(
                test_loader='attest:FancyReporter.test_loader',
                test_suite='tests.collection',
            )

        Now, ``python setup.py -q test`` is equivalent to::

            from attest import FancyReporter
            from tests import collection
            collection.run(FancyReporter)

        If you want to run the tests as a normal unittest suite,
        try :meth:`~attest.collectors.Tests.test_suite` instead::

            setup(
                test_suite='tests.collection.test_suite'
            )

        .. versionadded:: 0.5

        """
        return _test_loader_factory(cls)

    @abstractmethod
    def begin(self, tests):
        """Called when a test run has begun.

        :param tests: The list of test functions we will be running.

        """
        raise NotImplementedError

    @abstractmethod
    def success(self, result):
        """Called when a test succeeds.

        :param result: Result data for the succeeding test.
        :type result: :class:`TestResult`

        .. versionchanged:: 0.4
            Parameters changed to `result`.

        """
        raise NotImplementedError

    @abstractmethod
    def failure(self, result):
        """Called when a test fails.

        :param result: Result data for the failing test.
        :type result: :class:`TestResult`

        .. versionchanged:: 0.4
            Parameters changed to `result`.

        """
        raise NotImplementedError

    @abstractmethod
    def finished(self):
        """Called when all tests have run."""
        raise NotImplementedError


class PlainReporter(AbstractReporter):
    """Plain text ASCII output for humans."""

    def begin(self, tests):
        self.total = len(tests)
        self.failures = []

    def success(self, result):
        sys.stdout.write('.')
        sys.stdout.flush()

    def failure(self, result):
        if isinstance(result.error, AssertionError):
            sys.stdout.write('F')
        else:
            sys.stdout.write('E')
        sys.stdout.flush()
        self.failures.append(result)

    def finished(self):
        print
        print

        width, _ = utils.get_terminal_size()
        for result in self.failures:
            print result.test_name
            if result.test.__doc__:
                print inspect.getdoc(result.test)
            print '-' * width
            if result.stdout:
                print '->', '\n'.join(result.stdout)
            if result.stderr:
                print 'E:', '\n'.join(result.stderr)
            print result.traceback
            print
            result.debug()

        print 'Failures: %s/%s (%s assertions)' % (len(self.failures),
                                                   self.total,
                                                   statistics.assertions)

        if self.failures:
            raise SystemExit(1)


class FancyReporter(AbstractReporter):
    """Heavily uses ANSI escape codes for fancy output to 256-color
    terminals. Progress of running the tests is indicated by a progressbar
    and failures are shown with syntax highlighted tracebacks.

    :param style:
        `Pygments`_ style for tracebacks.
    :param verbose:
        Report on tests regardless of failure.
    :param colorscheme:
        If `style` is *light* or *dark*, maps token names to color names.

    .. admonition:: Styles

        Available styles can be listed with ``pygmentize -L styles``. The
        special values ``'light'`` and ``'dark'`` (referring to the terminal's
        background) use the 16 system colors rather than assuming a 256-color
        terminal.

        Defaults to *light* or the environment variable
        :envvar:`ATTEST_PYGMENTS_STYLE`.

    .. versionchanged:: 0.6 Added the 16-color styles *light* and *dark*
        and the complementary `colorscheme` option

    .. _Pygments: http://pygments.org/

    """

    def __init__(self, style=None, verbose=False, colorscheme=None):
        import progressbar, pygments
        self.style = style
        self.verbose = verbose
        self.colorscheme = colorscheme
        self.total_time  = 0
        if style is None:
            self.style = os.environ.get('ATTEST_PYGMENTS_STYLE', 'light')

    def begin(self, tests):
        from progressbar import ProgressBar, Percentage, ETA, SimpleProgress
        widgets = ['[', Percentage(), '] ', SimpleProgress(), ' ', ETA()]
        self.counter = 0
        self.progress = ProgressBar(maxval=len(tests), widgets=widgets)
        if tests:
            self.progress.start()
        self.passes = []
        self.failures = []

    def success(self, result):
        self.counter += 1
        self.total_time += result.time
        self.progress.update(self.counter)
        self.passes.append(result)

    def failure(self, result):
        self.counter += 1
        self.total_time += result.time
        self.progress.update(self.counter)
        self.failures.append(result)

    def finished(self):
        from pygments.lexers import (PythonTracebackLexer, PythonLexer,
                                     DiffLexer)
        if ANSI_COLORS_SUPPORT:
            from pygments.console import colorize
            from pygments import highlight

            if self.style in ('light', 'dark'):
                from pygments.formatters import TerminalFormatter
                formatter = TerminalFormatter(bg=self.style)
                if self.colorscheme is not None:
                    from pygments.token import string_to_tokentype
                    for token, value in self.colorscheme.iteritems():
                        token = string_to_tokentype(token.capitalize())
                        formatter.colorscheme[token] = (value, value)
            else:
                from pygments.formatters import Terminal256Formatter
                formatter = Terminal256Formatter(style=self.style)
        else:
            # ANSI color codes seem not to be supported, make colorize()
            # and highlight() no-ops.
            formatter = None
            def colorize(_format, text):
                return text
            def highlight(text, _lexer, _formatter):
                return text

        if self.counter:
            self.progress.finish()
        print

        width, _ = utils.get_terminal_size()
        def show(result):
            print colorize('bold', result.test_name)
            if result.test.__doc__:
                print inspect.getdoc(result.test)
            print colorize('faint', '─' * width)
            for line in result.stdout:
                print colorize('bold', '→'),
                print line
            for line in result.stderr:
                print colorize('red', '→'),
                print line

        if self.verbose:
            for result in self.passes:
                if result.stdout or result.stderr:
                    show(result)
                    print

        for result in self.failures:
            show(result)

            # result.traceback seems to be in UTF-8 on my system (eg. for
            # literal unicode strings) but I guess this depends on the source
            # file encoding. Tell Pygments to guess: try UTF-8 and then latin1.
            # Without an `encoding` argument, Pygments just uses latin1.
            print highlight(result.traceback,
                            PythonTracebackLexer(encoding='guess'),
                            formatter)

            assertion = result.assertion
            if assertion is not None:
                print highlight(assertion,
                                PythonLexer(encoding='guess'),
                                formatter)

            equality_diff = result.equality_diff
            if equality_diff is not None:
                print highlight(equality_diff,
                                DiffLexer(encoding='guess'),
                                formatter)

            result.debug()

        if self.failures:
            failed = colorize('red', str(len(self.failures)))
        else:
            failed = len(self.failures)
        print 'Failures: %s/%s (%s assertions, %.3f seconds)' % (
            failed, self.counter, statistics.assertions, self.total_time)

        if self.failures:
            raise SystemExit(1)


def auto_reporter(**opts):
    """Select a reporter based on the target output and installed
    dependencies.

    This is the default reporter.

    :param opts: Passed to :class:`FancyReporter` if it is used.
    :rtype:
        :class:`FancyReporter` if output is a terminal and the progressbar
        and pygments packages are installed, otherwise a
        :class:`PlainReporter`.

    .. versionchanged:: 0.5
        A `test_loader` function attribute similar to
        :meth:`AbstractReporter.test_loader`.

    """
    if hasattr(sys.stdout, 'isatty') and sys.stdout.isatty():
        try:
            return FancyReporter(**opts)
        except ImportError:
            pass
    return PlainReporter()

auto_reporter.test_loader = lambda: _test_loader_factory(auto_reporter)


class XmlReporter(AbstractReporter):
    """Report the result of a testrun in an XML format. Not compatible with
    JUnit or XUnit.

    """

    def __init__(self):
        self.escape = __import__('cgi').escape

    def begin(self, tests):
        print '<?xml version="1.0" encoding="UTF-8"?>'
        print '<testreport tests="%d">' % len(tests)

    def success(self, result):
        print '  <pass name="%s"/>' % result.test_name

    def failure(self, result):
        if isinstance(result.error, AssertionError):
            tag = 'fail'
        else:
            tag = 'error'
        print '  <%s name="%s" type="%s">' % (tag, result.test_name,
                                              result.exc_info[0].__name__)
        print self.escape('\n'.join(' ' * 4 + line
                                    for line in
                                    result.traceback.splitlines()),
                          quote=True)
        print '  </%s>' % tag

    def finished(self):
        print '</testreport>'


class XUnitReporter(AbstractReporter):
    """Report the result of a testrun in an XUnit XML format.
    """

    def __init__(self, file=None):
        self.file = file
        self.escape = __import__('cgi').escape
        self.reports = []
        self.errors = 0
        self.failures = 0
        self.successes = 0
        self.total_time = 0
        try:
            import socket
            self.hostname = socket.gethostname()
        except:
            self.hostname = 'unknown'
        self.timestamp = datetime.isoformat(datetime.today())

    def begin(self, tests):
        pass

    def success(self, result):
        self.successes += 1
        self.total_time += result.time
        self.reports.append(
            '<testcase classname="%s" name="%s" time="%f" />' % (
                result.test_name, result.test.__name__, result.time))
        if self.file:
            print result.test_name, "... ok"

    def failure(self, result):
        self.total_time += result.time
        if isinstance(result.error, AssertionError):
            tag = 'failure'
            self.failures += 1
        else:
            tag = 'error'
            self.errors += 1

        error = '<testcase classname="%s" name="%s" time="%f">\n' % (
            result.test_name, result.test.__name__, result.time)

        error += '<%s type="%s" message="%s"><![CDATA[\n' % (
            tag,
            result.exc_info[0].__name__,
            self.escape(repr(result.exc_info[1]), quote=True))
        error += self.escape(
            '\n'.join(line
                    for line in
                    result.traceback.splitlines()),
            quote=True)
        error += '\n]]>\n</%s>\n</testcase>' % tag
        self.reports.append(error)
        if self.file:
            print result.test_name, "... ", tag

    def finished(self):
        out = '<?xml version="1.0" encoding="UTF-8"?>\n'
        out += ('<testsuite name="attest" tests="%d" ' +
                   'errors="%d" failures="%d" ' +
                   'hostname="%s" timestamp="%s" time="%f">\n') % (
                (self.errors + self.failures + self.successes),
                self.errors,
                self.failures,
                self.hostname,
                self.timestamp,
                self.total_time)
        out += '<properties />\n'
        out += '\n'.join(self.reports)
        out += '\n</testsuite>\n'

        if not self.file:
            print out
        else:
            with open(self.file, "w") as f:
                f.write(out)

        if self.failures + self.errors:
            raise SystemExit(1)


class QuickFixReporter(AbstractReporter):
    """Report failures in a format that's understood by Vim's quickfix
    feature.

    Write a Makefile that runs your tests with this reporter and
    then from Vim you can do ``:mak``. If there's failures, Vim will jump
    to the first one by opening the offending file and positioning the
    cursor at the relevant line; you can jump between failures with ``:cn``
    and ``:cp``. For more information try `:help quickfix
    <http://vimdoc.sourceforge.net/htmldoc/quickfix.html>`_.

    Example Makefile (remember to indent with tabs not spaces)::

        test:
            @python runtests.py -rquickfix

    .. versionadded:: 0.5

    """

    failed = False

    def begin(self, tests):
        pass

    def success(self, result):
        pass

    def failure(self, result):
        self.failed = True
        fn, lineno = result.raw_traceback[-1][:2]
        type, msg = result.exc_info[0].__name__, str(result.exc_info[1])
        if msg:
            msg = ': ' + msg
        print "%s:%s: %s%s" % (fn, lineno, type, msg)

    def finished(self):
        if self.failed:
            raise SystemExit(1)


def get_reporter_by_name(name, default='auto'):
    """Get an :class:`AbstractReporter` by name, falling back on a default.

    Reporters are registered via setuptools entry points, in the
    ``'attest.reporters'`` group. A third-party reporter can thus register
    itself using this in its :file:`setup.py`::

        setup(
            entry_points = {
                'attest.reporters': [
                    'name = import.path.to:callable'
                ]
            }
        )

    Names for the built in reporters:

    * ``'fancy'`` — :class:`FancyReporter`
    * ``'plain'`` — :class:`PlainReporter`
    * ``'xunit'`` – :class:`XUnitReporter`
    * ``'quickfix'`` — :class:`QuickFixReporter`
    * ``'xml'`` — :class:`XmlReporter`
    * ``'auto'`` — :func:`auto_reporter`

    :param name: One of the above strings.
    :param default:
        The fallback reporter if no reporter has the supplied name,
        defaulting to ``'auto'``.
    :raises KeyError:
        If neither the name or the default is a valid name of a reporter.
    :rtype: Callable returning an instance of an :class:`AbstractReporter`.

    .. versionchanged:: 0.4
        Reporters are registered via setuptools entry points.

    """
    reporter = None
    if name is not None:
        reporter = list(iter_entry_points('attest.reporters', name))
    if not reporter:
        reporter = list(iter_entry_points('attest.reporters', default))
    if not reporter:
        raise KeyError
    return reporter[0].load(require=False)


def get_all_reporters():
    """Iterable yielding the names of all registered reporters.

    .. testsetup::

        from attest import get_all_reporters

    >>> list(get_all_reporters())
    ['xml', 'plain', 'xunit', 'fancy', 'auto', 'quickfix']

    .. versionadded:: 0.4

    """
    for ep in iter_entry_points('attest.reporters'):
        yield ep.name

########NEW FILE########
__FILENAME__ = run
from __future__ import with_statement

import sys
import os
from os import path

from pkg_resources import get_distribution
from optparse import OptionParser, make_option
from attest.collectors import Tests
from attest.reporters import get_all_reporters, get_reporter_by_name
from attest.utils import parse_options
from attest.hook import AssertImportHook


def make_parser(**kwargs):
    args = dict(
        prog='attest',
        usage='%prog [options] [tests...] [key=value...]',
        version=get_distribution('Attest').version,

        description=(
            'The positional "tests" are dotted '
            'names for modules or packages that are scanned '
            'recursively for Tests instances, or dotted names '
            'for any other object that iterates over tests. If '
            'not provided, packages in the working directory '
            'are scanned.\n'
            'The key/value pairs are passed to the '
            'reporter constructor, after some command-line '
            'friendly parsing.'
        ),

        option_list=[
            make_option('-d', '--debugger',
                action='store_true',
                help='enter pdb for failing tests',
            ),
            make_option('-r', '--reporter',
                metavar='NAME',
                help='select reporter by name'
            ),
            make_option('-l', '--list-reporters',
                action='store_true',
                help='list available reporters'
            ),
            make_option('-n', '--no-capture',
                action='store_true',
                help="don't capture stderr and stdout"
            ),
            make_option('--full-tracebacks',
                action='store_true',
                help="don't clean tracebacks"
            ),
            make_option('--fail-fast',
                action='store_true',
                help='stop at first failure'
            ),
            make_option('--native-assert',
                action='store_true',
                help="don't hook the assert statement"
            ),
            make_option('-p', '--profile',
                metavar='FILENAME',
                help='enable tests profiling and store results in filename'
            ),
            make_option('-k', '--keyboard-interrupt',
                action='store_true',
                help="Let KeyboardInterrupt exceptions (CTRL+C) propagate"
            ),
        ]
    )
    args.update(kwargs)
    return OptionParser(**args)


def main(tests=None, **kwargs):
    parser = make_parser(**kwargs)
    options, args = parser.parse_args()

    # When run as a console script (i.e. ``attest``), the CWD isn't
    # ``sys.path[0]``, but it should be. It's important to do this early in
    # case custom reporters are being used that make the assumption that CWD is
    # on ``sys.path``.
    cwd = os.getcwd()
    if sys.path[0] not in ('', cwd):
        sys.path.insert(0, cwd)

    if options.list_reporters:
        for reporter in get_all_reporters():
            print reporter
        return

    opts = parse_options(args)
    reporter = get_reporter_by_name(options.reporter)(**opts)

    if not tests:
        names = [arg for arg in args if '=' not in arg]
        if not names:
            names = [name for name in os.listdir('.')
                          if path.isfile('%s/__init__.py' % name)]

        if options.native_assert:
            tests = Tests(names)
        else:
            with AssertImportHook():
                tests = Tests(names)

    def run():
        tests.run(reporter, full_tracebacks=options.full_tracebacks,
                            fail_fast=options.fail_fast,
                            debugger=options.debugger,
                            no_capture=options.no_capture,
                            keyboard_interrupt=options.keyboard_interrupt)

    if options.profile:
        filename = options.profile
        import cProfile
        cProfile.runctx('run()', globals(), locals(), filename)
        print 'Wrote profiling results to %r.' % (filename,)
    else:
        run()


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = statistics
assertions = 0

########NEW FILE########
__FILENAME__ = asserts
from __future__ import with_statement

from attest import Tests, Assert


suite = Tests()


@suite.test
def raises():
    """Assert.raises"""

    try:
        with Assert.raises(RuntimeError):
            pass
    except AssertionError, e:
        Assert(e).__str__() == "didn't raise RuntimeError"
    else:
        raise AssertionError("didn't fail for missing exception")

    # Groups of allowed exceptions
    try:
        with Assert.raises(RuntimeError, ValueError):
            pass
    except AssertionError, e:
        Assert(e).__str__() == "didn't raise (RuntimeError, ValueError)"
    else:
        raise AssertionError("didn't fail for missing exception")

    with Assert.raises(RuntimeError, ValueError) as error:
        raise RuntimeError
    error.__class__.is_(RuntimeError)

    with Assert.raises(RuntimeError, ValueError) as error:
        raise ValueError('invaluable')
    error.__class__.is_(ValueError)
    error.__str__() == 'invaluable'

    with Assert.raises(AssertionError):
        error.args == ('valuable',)


@suite.test
def not_raising():
    """Assert.not_raising"""

    with Assert.raises(AssertionError):
        with Assert.not_raising(RuntimeError):
            raise RuntimeError

    try:
        with Assert.not_raising(RuntimeError):
            pass
    except Exception:
        raise AssertionError('failed despite not raising RuntimeError')


@suite.test
def equality():
    """Assert() == and !="""

    Assert(1) == 1
    Assert(1) != 0

    with Assert.raises(AssertionError):
        Assert(1) == 0

    with Assert.raises(AssertionError):
        Assert(1) != 1


@suite.test
def compare():
    """Assert() comparisons"""

    Assert(1) > 0
    Assert(0) < 1
    Assert(1) >= 0
    Assert(1) >= 1
    Assert(0) <= 0
    Assert(0) <= 1

    with Assert.raises(AssertionError):
        Assert(0) > 1

    with Assert.raises(AssertionError):
        Assert(1) < 0

    with Assert.raises(AssertionError):
        Assert(0) >= 1

    with Assert.raises(AssertionError):
        Assert(0) >= 1

    with Assert.raises(AssertionError):
        Assert(1) <= 0

    with Assert.raises(AssertionError):
        Assert(1) <= 0


@suite.test
def contains():
    """Assert() membership"""

    1 in Assert([0,1,2])
    Assert(1).in_([0,1,2])
    Assert(3).not_in([0,1,2])

    with Assert.raises(AssertionError):
        3 in Assert([0,1,2])

    with Assert.raises(AssertionError):
        Assert(3).in_([0,1,2])

    with Assert.raises(AssertionError):
        Assert(1).not_in([0,1,2])


@suite.test
def identity():
    """Assert() object identity"""

    Assert(True).is_(True)
    Assert(False).is_not(True)
    Assert(True).is_(Assert(True))
    Assert(False).is_not(Assert(True))
    Assert([]).is_not([])

    with Assert.raises(AssertionError):
        Assert(False).is_(True)

    with Assert.raises(AssertionError):
        Assert(True).is_not(True)

    with Assert.raises(AssertionError):
        Assert(False).is_(Assert(True))

    with Assert.raises(AssertionError):
        Assert(True).is_not(Assert(True))

    with Assert.raises(AssertionError):
        Assert([]).is_([])


@suite.test
def proxy():
    """Assert().remote_attribute"""

    hello = Assert('hello')
    hello == 'hello'
    hello.upper() == 'HELLO'
    hello.attr('upper').attr('__name__') == 'upper'

    with Assert.raises(AssertionError):
        hello.upper() == 'hello'

    with Assert.raises(AssertionError):
        Assert(3).__str__() == '4'

    with Assert.raises(AssertionError):
        hello.attr('upper').attr('__name__') == 'lower'


@suite.test
def boolean():
    """Assert() in boolean context"""

    bool(Assert(1))

    with Assert.raises(AssertionError):
        bool(Assert(0))


@suite.test
def nested_assert():
    """Assert(Assert(var)) is Assert(var)"""

    Assert(Assert('hello')).__class__.is_(str)


@suite.test
def isinstance():
    """Assert.isinstance"""

    with Assert.raises(AssertionError) as error:
        Assert.isinstance('hello', (int, float))
    error.__str__() == "not isinstance('hello', (int, float))"

    with Assert.raises(AssertionError) as error:
        Assert.isinstance('hello', int)
    error.__str__() == "not isinstance('hello', int)"

    Assert.isinstance('hello', basestring)


@suite.test
def not_isinstance():
    """Assert.not_isinstance"""

    with Assert.raises(AssertionError) as error:
        Assert.not_isinstance(1, (int, float))
    error.__str__() == "isinstance(1, (int, float))"

    with Assert.raises(AssertionError) as error:
        Assert.not_isinstance(1, int)
    error.__str__() == "isinstance(1, int)"

    Assert.not_isinstance('hello', int)


@suite.test
def issubclass():
    """Assert.issubclass"""

    with Assert.raises(AssertionError) as error:
        Assert.issubclass(str, (int, float))
    error.__str__() == "not issubclass(str, (int, float))"

    with Assert.raises(AssertionError) as error:
        Assert.issubclass(str, int)
    error.__str__() == "not issubclass(str, int)"

    Assert.issubclass(str, str)


@suite.test
def not_issubclass():
    """Assert.not_issubclass"""

    with Assert.raises(AssertionError) as error:
        Assert.not_issubclass(int, (int, float))
    error.__str__() == "issubclass(int, (int, float))"

    with Assert.raises(AssertionError) as error:
        Assert.not_issubclass(int, int)
    error.__str__() == "issubclass(int, int)"

    Assert.not_issubclass(int, str)


@suite.test
def json():
    """Assert.json"""

    Assert('{"works": true}').json == dict(works=True)
    Assert('{"works": true}').json != dict(works=False)

    with Assert.raises(AssertionError):
        Assert('{"works": true}').json != dict(works=True)

    with Assert.raises(AssertionError):
        Assert('{"works": true}').json == dict(works=False)


try:
    import lxml
except ImportError:
    lxml = None

@suite.test_if(lxml)
def css():
    """Assert.css"""

    html = Assert("""
        <div id="maincontent">
            <div class="container">
                <p>Hello World</p>
            </div>
        </div>
    """)

    html.css('#maincontent .container p')[0].text == 'Hello World'

    with Assert.raises(AssertionError):
        html.css('#maincontent .container p')[0].text != 'Hello World'


@suite.test_if(lxml)
def xpath():
    """Assert.xpath"""

    xml = Assert("""
        <div id="maincontent">
            <div class="container">
                <p>Hello World</p>
            </div>
        </div>
    """)

    path = '/div[@id="maincontent"]/div[@class="container"]/p'
    xml.xpath(path)[0].text == 'Hello World'

    with Assert.raises(AssertionError):
        xml.xpath(path)[0].text != 'Hello World'


@suite.test
def passed_to():
    """Assert.passed_to"""

    Assert([1, 2, 3]).passed_to(len) == 3
    Assert(1).passed_to(str) == '1'
    Assert('a').passed_to(int, 16) == 10
    Assert('a').passed_to(int, base=16) == 10

    with Assert.raises(AssertionError):
        Assert([1, 2, 3]).passed_to(len) != 3

    with Assert.raises(AssertionError):
        Assert(1).passed_to(str) != '1'

    with Assert.raises(AssertionError):
        Assert('a').passed_to(int, 16) != 10

    with Assert.raises(AssertionError):
        Assert('a').passed_to(int, base=16) != 10


@suite.test
def predicate():
    with Assert.raises(AssertionError):
        Assert(bool, 0)
    Assert(bool, 1)

########NEW FILE########
__FILENAME__ = classy
from attest import TestBase, test, Tests, test_if, assert_hook, TestFailure

from .collectors import TestReporter


class Classy(TestBase):

    @test
    def fail(self):
        assert 1 == 2

    @test
    def succeed(self):
        assert 1 == 1


class Contextual(TestBase):

    def __context__(self):
        self.two = 1 + 1
        yield
        del self.two

    @test
    def succeed(self):
        assert self.two == 2


suite = Tests()


@suite.test
def classbased_test_runs():
    """Tests().register(TestBase())"""

    instance = Classy()
    col = Tests([instance])

    assert len(col) == 2
    assert list(col)[0] == instance.fail

    result = TestReporter()
    col.run(result)

    assert len(result.succeeded) == 1
    assert len(result.failed) == 1

    assert result.failed[0].test == instance.fail
    assert result.failed[0].exc_info[0] is TestFailure


@suite.test
def class_context():
    """TestBase().__context__"""

    instance = Contextual()
    col = Tests([instance])

    result = TestReporter()
    col.run(result)

    assert hasattr(instance, 'two') == False
    assert len(result.failed) == 0
    assert len(result.succeeded) == 1


@suite.test
def decorative():
    """@Tests().register(TestBase)"""

    col = Tests()
    assert len(col) == 0

    class DecoratedTest(TestBase):

        @test
        def noop(self):
            pass

        @test
        def nothing(self):
            pass

    DecoratedTest = col.register(DecoratedTest)

    assert issubclass(DecoratedTest, TestBase) == True
    assert len(col) == 2


@suite.test
def decorative_conditional():
    """@Tests().register_if(condition)(TestBase)"""

    col = Tests()

    class IncludedTest(TestBase):

        @test
        def foo(self):
            pass

        @test
        def bar(self):
            pass


    class ExcludedTest(TestBase):

        @test
        def spam(self):
            pass

        @test
        def eggs(self):
            pass

    col.register_if(True)(IncludedTest)
    col.register_if(False)(ExcludedTest)

    assert len(col) == 2
    assert sorted(test.__name__ for test in col) == ['bar', 'foo']


@suite.test
def conditional():
    """@test_if(condition)"""

    col = Tests()

    class TestClass(TestBase):
        @test
        def foo(self):
            pass

        @test_if(True)
        def bar(self):
            pass

        @test_if(False)
        def baz(self):
            assert False

    col.register(TestClass)

    result = TestReporter()
    col.run(result)
    assert len(result.failed) == 0
    assert len(result.succeeded) == 2

########NEW FILE########
__FILENAME__ = collectors
from __future__ import with_statement
from attest import (AbstractReporter, Tests, TestBase, Assert, assert_hook,
                    test, TestFailure)


class TestReporter(AbstractReporter):

    def begin(self, tests):
        self.succeeded = []
        self.failed = []

    def success(self, result):
        self.succeeded.append(result)

    def failure(self, result):
        self.failed.append(result)

    def finished(self):
        pass


suite = Tests()


@suite.test
def decorator():
    """@Tests().test"""

    col = Tests()

    @col.test
    def one(): pass

    @col.test
    def two(): pass

    assert len(col) == 2
    assert [func.__wrapped__ for func in col] == [one, two]


@suite.test
def context():
    """@Tests().context"""

    col = Tests(replace_tests=True)

    @col.test
    def test(calculated):
        assert calculated == 2

    @col.context
    def context():
        calculated = 1 + 1
        yield calculated

    @col.test
    def noctx():
        pass

    test()
    noctx()

    col2 = Tests()

    @col2.context
    def empty():
        yield

    @col2.test
    def test2():
        pass

    test2()

    col3 = Tests(replace_tests=True)

    @col3.context
    def multiple():
        yield 1, 2, 3

    @col3.test
    def test3(one, two, three):
        assert one == 1
        assert two == 2
        assert three == 3

    @col3.test
    def test3_2(one, two):
        assert one == 1
        assert two == 2

    test3()
    test3_2()

    col4 = Tests(replace_tests=True)

    @col4.context
    def nested():
        yield 1

    @col4.context
    def nested():
        yield

    @col4.context
    def nested():
        yield 2

    @col4.test
    def test4(one, two):
        assert one == 1
        assert two == 2

    test4()

    from contextlib import contextmanager

    @contextmanager
    def context5():
        yield 1

    col5 = Tests(contexts=[context5], replace_tests=True)

    @col5.test
    def test5(one):
        assert one == 1

    test5()


@suite.test
def run():
    """Tests().run"""

    col = Tests()

    @col.test
    def fail():
        assert 1 == 2

    @col.test
    def succeed():
        assert 1 == 1

    @col.test
    def exit():
        raise SystemExit

    result = TestReporter()
    with Assert.not_raising(SystemExit):
        col.run(result)

    assert len(result.failed) == 2
    assert len(result.succeeded) == 1

    assert result.failed[0].test.__wrapped__ is fail
    assert result.failed[0].exc_info[0] is TestFailure
    assert result.succeeded[0].test.__wrapped__ is succeed


@suite.test
def conditional():
    """@Tests().test_if(condition)"""

    col = Tests(replace_tests=True)

    @col.test_if(True)
    def include():
        pass

    @col.test_if(False)
    def exclude():
        pass

    assert include in col
    assert exclude not in col


@suite.test
def unittest():
    """Compatibility with Python's unittest package"""
    signals = set()

    example = Tests()

    @example.test
    def simple():
        signals.add("one")

    class Test(TestBase):
        @test
        def simple(self):
            signals.add("two")
    Test = example.register(Test)  # Python 2.5

    # unittest.TestCase
    TestCase = example.test_case()

    TestCase("test_simple").debug()
    assert signals == set(["one"])

    # unittest.TestSuite
    test_suite = example.test_suite()

    signals.clear()
    test_suite.debug()
    assert signals == set(["one", "two"])


@suite.test
def testcase_naming():
    example = Tests()

    @example.test
    def simple():
        pass

    @example.test
    def simple():
        """Duplicate name, should have ``_2`` appended."""

    class Test(TestBase):
        @test
        def simple():
            """Another duplicate, should have ``_3`` appended."""
    Test = example.register(Test)  # Python 2.5

    @example.test
    def test_something():
        """Already prepended with ``test_`` - should be used verbatim."""

    example.test(lambda self: None)

    TestCase = example.test_case()
    assert TestCase.test_simple
    assert TestCase.test_simple_2
    assert TestCase.test_simple_3
    assert TestCase.test_something
    assert TestCase.test_lambda


########NEW FILE########
__FILENAME__ = contexts
from __future__ import with_statement

import sys
import os
from os import path
import warnings

from attest import Tests, assert_hook, Assert
import attest


suite = Tests()


@suite.test
def capture():
    """capture_output()"""

    stdout, stderr = sys.stdout, sys.stderr

    with attest.capture_output() as (out, err):
        print 'Capture the flag!'
        print >>sys.stderr, 'Rapture the flag?'

    assert out == ['Capture the flag!']
    assert err == ['Rapture the flag?']

    assert sys.stdout is stdout
    assert sys.stderr is stderr


@suite.test
def disable_imports():
    with attest.disable_imports('sys', 'os'):
        with Assert.raises(ImportError):
            import sys

        with Assert.raises(ImportError):
            import os

    import sys
    import os

    with attest.disable_imports():
        import datetime
        assert datetime is sys.modules['datetime']


@suite.test
def raises():
    try:
        with attest.raises(RuntimeError):
            pass
    except AssertionError, e:
        assert type(e) is AssertionError
        assert str(e) == "didn't raise RuntimeError when expected"
    else:
        raise AssertionError

    # Groups of allowed exceptions
    try:
        with attest.raises(RuntimeError, ValueError):
            pass
    except AssertionError, e:
        assert type(e) is AssertionError
        assert str(e) == "didn't raise (RuntimeError, ValueError) when expected"
    else:
        raise AssertionError

    with attest.raises(RuntimeError, ValueError) as error:
        raise RuntimeError
    assert isinstance(error.exc, RuntimeError)

    with attest.raises(RuntimeError, ValueError) as error:
        raise ValueError('invaluable')
    assert isinstance(error.exc, ValueError) and str(error) == 'invaluable'

    with attest.raises(AssertionError):
        assert error.args == ('valuable',)


@suite.test
def tempdir():
    with attest.tempdir() as d:
        assert path.isdir(d)
        assert os.listdir(d) == []
        open(path.join(d, 'tempfile'), 'w').close()
        assert os.listdir(d) == ['tempfile']
    assert not path.exists(d)


@suite.test
def warns():
    with attest.warns(UserWarning) as captured:
        warnings.warn("foo")
        warnings.warn("bar", DeprecationWarning)

    assert len(captured) == 1
    assert unicode(captured[0]) == "foo"

    with attest.raises(AssertionError):
        with attest.warns(UserWarning):
            pass

    with attest.raises(AssertionError):
        with attest.warns(UserWarning, DeprecationWarning):
            warnings.warn("foo")

    with attest.warns(UserWarning, DeprecationWarning, any=True):
        warnings.warn("foo")

    if hasattr(warnings, "catch_warnings"):  # not available in Python 2.5
        with warnings.catch_warnings():
            warnings.simplefilter("error", UserWarning)
            with attest.warns(UserWarning):
                warnings.warn("foo")
            with attest.raises(UserWarning):
                warnings.warn("bar")

########NEW FILE########
__FILENAME__ = foo

########NEW FILE########
__FILENAME__ = hook
from attest import Tests, assert_hook
from attest.hook import ExpressionEvaluator


suite = Tests()


@suite.test
def eval():
    value = 1 + 1

    samples = {
        'isinstance(value, int)': 'True',
        'value == int("2")': "(2 == 2)",
        'type(value).__name__': "'int'",
        'value == 5 - 3': '(2 == 2)',
        '{"value": value}': "{'value': 2}",
        '[v for v in [value]]': '[2]',
    }

    for expr, result in samples.iteritems():
        expr = ExpressionEvaluator(expr, globals(), locals())
        expr.late_visit()
        ev = repr(expr)
        assert ev == result
        assert bool(ev) is True


@suite.test
def initpy_with_relative_import():
    # Ensure that packages with an __init__.py file that use both assert_hook
    # and relative imports are hooked properly.
    from . import dummy

########NEW FILE########
__FILENAME__ = reporters
from __future__ import with_statement

import sys
import inspect
from traceback import format_exception_only

from attest import (Tests, Assert, assert_hook, TestFailure, COMPILES_AST,
                    utils)
import attest

from . import _meta


SOURCEFILE = inspect.getsourcefile(_meta)
LINENO = 21
EXCEPTION = format_exception_only(TestFailure, '')[0].rstrip()


suite = Tests()


@suite.test
def get_all_reporters():
    reporters = set(['auto', 'fancy', 'plain', 'xml', 'quickfix', 'xunit'])
    assert set(attest.get_all_reporters()) == reporters


@suite.test
def get_reporter_by_name():
    reporters = dict(auto=attest.auto_reporter,
                     fancy=attest.FancyReporter,
                     plain=attest.PlainReporter,
                     xml=attest.XmlReporter,
                    )
    for name, reporter in reporters.iteritems():
        assert attest.get_reporter_by_name(name) == reporter


@suite.test
def auto_reporter():
    # Inside tests, sys.stdout is not a tty
    assert isinstance(attest.auto_reporter(), attest.PlainReporter)

    class FakeTTY(object):

        def isatty(self):
            return True

    sys.stdout, orig = FakeTTY(), sys.stdout
    try:
        assert isinstance(attest.auto_reporter(), attest.FancyReporter)
        with attest.disable_imports('progressbar', 'pygments'):
            assert isinstance(attest.auto_reporter(), attest.PlainReporter)
    finally:
        sys.stdout = orig


@suite.test_if(COMPILES_AST)
def xml_reporter():
    """XmlReporter"""

    with attest.capture_output() as (out, err):
        _meta.suite.run(attest.XmlReporter)

    for line, expected in zip(out[:5] + out[-3:], [
        '<?xml version="1.0" encoding="UTF-8"?>',
        '<testreport tests="2">',
        '  <pass name="attest.tests._meta.passing"/>',
        '  <fail name="attest.tests._meta.failing" type="TestFailure">',
        '    Traceback (most recent call last):',
        '    %s' % EXCEPTION,
        '  </fail>',
        '</testreport>',
    ]):
        assert line == expected


@suite.test_if(COMPILES_AST)
def plain_reporter():
    """PlainReporter"""

    with attest.capture_output() as (out, err):
        with Assert.raises(SystemExit):
            _meta.suite.run(attest.PlainReporter)

    width, _ = utils.get_terminal_size()
    for line, expected in zip(out[:7] + out[-3:], [
        '.F',
        '',
        'attest.tests._meta.failing',
        '-' * width,
        '-> stdout',
        'E: stderr',
        'Traceback (most recent call last):',
        '%s' % EXCEPTION,
        '',
        'Failures: 1/2 (1 assertions)',
    ]):
        assert line == expected


@suite.test_if(COMPILES_AST)
def quickfix_reporter():
    """QuickFixReporter"""

    with attest.capture_output() as (out, err):
        with Assert.raises(SystemExit):
            _meta.suite.run(attest.QuickFixReporter)

    assert out == ['%s:%d: TestFailure' % (SOURCEFILE, LINENO)]


@suite.test
def empty_run_zero_division_regression():
    Tests().run(attest.FancyReporter)

########NEW FILE########
__FILENAME__ = utils
from __future__ import with_statement
import inspect
from contextlib import contextmanager
from attest import Tests, assert_hook, utils, disable_imports, raises
import attest
from attest.utils import import_dotted_name

suite = Tests()


@suite.test
def terminal_size():
    size = utils.get_terminal_size()
    assert type(size) is tuple
    assert len(size) == 2
    assert type(size[0]) is int
    assert type(size[1]) is int

    with disable_imports('fcntl', 'termios'):
        size = utils.get_terminal_size()
        assert size == (80, 24)
        size = utils.get_terminal_size((1, 2))
        assert size == (1, 2)


@suite.test
def string_importing():
    assert import_dotted_name('attest') is attest
    assert import_dotted_name('attest.tests') is attest.tests
    assert import_dotted_name('attest.utils') is utils
    assert import_dotted_name('attest.utils:import_dotted_name') \
           is import_dotted_name
    assert import_dotted_name('attest.utils.import_dotted_name') \
           is import_dotted_name


    with raises(AttributeError):
        import_dotted_name('attest._nil')

    with raises(ImportError):
        with disable_imports('attest'):
            import_dotted_name('attest')


@suite.test
def iter_mods():
    core = ['attest'] + ['attest.' + mod for mod in
            '''ast codegen collectors contexts deprecated hook __main__
               reporters run statistics utils pygments'''.split()]
    tests = ['attest.tests'] + ['attest.tests.' + mod for mod in
            '''asserts classy collectors contexts hook _meta reporters utils
               dummy dummy.foo'''.split()]

    found = list(utils.deep_iter_modules('attest'))
    expected = core + tests
    assert set(expected) == set(found)
    assert len(expected) == len(found)

    found = list(utils.deep_iter_modules('attest.tests'))
    expected = tests
    assert set(expected) == set(found)
    assert len(expected) == len(found)

    found = list(utils.deep_iter_modules('attest.ast'))
    assert found == ['attest.ast']

    with raises(AttributeError):
        list(utils.deep_iter_modules('attest._nil'))

    with disable_imports('attest'):
        with raises(ImportError):
            list(utils.deep_iter_modules('attest'))


@suite.test
def get_members_recursively():
    deepfunc = lambda x: getattr(x, '__name__', '').startswith('deep_')
    found = list(utils.deep_get_members('attest', deepfunc))
    expected = [utils.deep_get_members, utils.deep_iter_modules]
    assert found == expected

    getters = lambda x: getattr(x, '__name__', '').startswith('get')
    found = set(utils.deep_get_members('inspect', getters))
    expected = set(v for (k, v) in inspect.getmembers(inspect, getters))
    assert found == expected


@suite.test
def reporter_options():
    opts = utils.parse_options([
        'style = dark',
        'verbose=yes',
        'quiet=no',
        'switch=on',
        'bigbutton=off',
        'bool=true',
        'lie=false',
        'num=3',
        'list=1,2,3',
        'pair=foo:bar',
        'dict=foo:bar,abc:123',
        'notopt',
        'empty=',
        'void=none',
        'hyphens-are-ok=true',
    ])

    assert opts == dict(
        style='dark',
        verbose=True,
        quiet=False,
        switch=True,
        bigbutton=False,
        bool=True,
        lie=False,
        num=3,
        list=(1, 2, 3),
        pair=dict(foo='bar'),
        dict=dict(foo='bar', abc=123),
        empty=None,
        void=None,
        hyphens_are_ok=True,
    )


@suite.test
def nesting_contexts():

    signals = []

    @contextmanager
    def one():
        signals.append('inner one')
        try:
            yield 'one'
        finally:
            signals.append('outer one')

    @contextmanager
    def two():
        signals.append('inner two')
        try:
            yield 'two'
        finally:
            signals.append('outer two')

    ctx = utils.nested([one, two])
    assert not signals

    with raises(ZeroDivisionError):
        with ctx as args:
            assert signals == ['inner one', 'inner two']
            assert args == ['one', 'two']
            1/0
    assert signals == ['inner one', 'inner two', 'outer two', 'outer one']

    args = None
    signals = []

    @contextmanager
    def one():
        signals.append('inner one')
        try:
            yield 'one'
        finally:
            signals.append('outer one')

    @contextmanager
    def two():
        signals.append('inner two')
        1/0
        try:
            yield 'two'
        finally:
            signals.append('outer two')

    ctx = utils.nested([one, two])
    assert not signals

    with raises(ZeroDivisionError):
        with ctx as args:
            pass

    assert signals == ['inner one', 'inner two', 'outer one']
    assert args is None


@suite.test
def counter():
    counter = utils.counter()
    assert counter.increment("a") == 1
    assert counter == {"a": 1}


@suite.test
def nested():
    try:
        with utils.nested([]):
            assert 1 == 0, "message"

    except AssertionError, e:
        print e.args
        assert e.args == ("message", )

########NEW FILE########
__FILENAME__ = _meta
"""

    Test tests for testing testing.

"""
import sys
from attest import Tests, assert_hook


suite = Tests()

@suite.test
def passing():
    pass

@suite.test
def failing():
    print 'stdout'
    print >>sys.stderr, 'stderr'
    value = 1 + 1
    assert value == 3

########NEW FILE########
__FILENAME__ = utils
import sys

from array      import array
from contextlib import contextmanager
from inspect    import getmembers
from pkgutil    import iter_modules
from six        import reraise


__all__ = ['get_terminal_size',
           'import_dotted_name',
           'deep_iter_modules',
           'deep_get_members',
           'parse_options',
           'nested',
           'counter']


def get_terminal_size(default=(80, 24)):
    """Try to get the size of the terminal as a tuple ``(width, height)``
    falling back on `default`.

    .. versionadded:: 0.6

    """
    try:
        import fcntl, termios
    except ImportError:
        return default
    try:
        ary = array('h', fcntl.fcntl(sys.stdin, termios.TIOCGWINSZ, chr(0) * 8))
        return ary[1], ary[0]
    except IOError:
        return default


def import_dotted_name(name):
    """Get an object by its "dotted name", a string representing its import
    location. The last dot can also be a colon instead.

    .. versionadded:: 0.6

    """
    name = str(name)
    if ':' in name:
        module, obj = name.split(':', 1)
    elif '.' in name:
        module, obj = name.rsplit('.', 1)
    else:
        return __import__(name, level=0)
    mod = __import__(module, fromlist=[obj], level=0)
    return getattr(mod, obj)


def deep_iter_modules(name):
    """Iterate over all modules under an import name. Like
    :func:`~pkgutil.iter_modules` but recursive, and yielding the dotted
    names of each module.

    .. versionadded:: 0.6

    """
    mod = import_dotted_name(name)
    yield name
    if not hasattr(mod, '__path__'):
        return
    for _, name, _ in iter_modules(mod.__path__, name + '.'):
        for name in deep_iter_modules(name):
            yield name


def deep_get_members(name, predicate=None, private=False):
    """Get all top-level objects in all modules under `name` satisfying
    `predicate` if provided, ignoring private modules and objects unless
    `private` is true.

    .. versionadded:: 0.6

    """
    seen = set()
    for name in deep_iter_modules(name):
        mod = import_dotted_name(name)
        name = name.rsplit('.', 1)[-1]
        if not private and name.startswith('_'):
            continue
        for name, value in getmembers(mod, predicate):
            if id(value) in seen or not private and name.startswith('_'):
                continue
            yield value
            seen.add(id(value))


def parse_options(args):
    types = dict(yes=True, no=False, on=True, off=False,
                 true=True, false=False, none=None)

    def parse_key(key):
        return key.strip().replace('-', '_')

    def parse_value(value):
        value = value.strip()

        if not value:
            return

        if value in types:
            return types[value]

        if ',' in value:
            seq = tuple(map(parse_value, value.split(',')))
            if all(isinstance(v, dict) for v in seq):
                d = {}
                for v in seq:
                    d.update(v)
                return d
            return seq

        if ':' in value:
            return dict([map(parse_value, value.split(':', 1))])

        try:
            return int(value)
        except ValueError:
            return value

    def parse_option(option):
        key, value = option.split('=', 1)
        key, value = parse_key(key), parse_value(value)
        return key, value

    args = [arg for arg in args if '=' in arg]
    opts = dict(map(parse_option, args))
    return opts


@contextmanager
def nested(constructors):
    exc = None, None, None
    args = []
    exits = []
    try:
        for constructor in constructors:
            manager = constructor()
            args.append(manager.__enter__())
            exits.append(manager.__exit__)
        yield args
    except:
        exc = sys.exc_info()
    finally:
        for exit in reversed(exits):
            try:
                if exit(*exc):
                    exc = None, None, None
            except:
                exc = sys.exc_info()
        if exc != (None, None, None):
            reraise(*exc)


class counter(dict):
    def increment(self, key):
        if key not in self:
            self[key] = 1
        else:
            self[key] += 1
        return self[key]

########NEW FILE########
__FILENAME__ = __main__
from .run import main

if __name__ == '__main__':
    main(prog='python -mattest')

########NEW FILE########
__FILENAME__ = conf
# coding:utf-8

import sys
import os

from pkg_resources import get_distribution

sys.path.insert(0, os.path.abspath('..'))


project = u'Attest'
copyright = u'2010-2011, Dag Odenhall'
release = get_distribution(project).version
version = release.split('dev', 1)[0]


extensions =\
    ['sphinx.ext.autodoc',
     'sphinx.ext.intersphinx',
     'sphinx.ext.viewcode',
     'sphinx.ext.doctest',
    ]

intersphinx_mapping =\
    {'http://docs.python.org/dev/': None,
    }


master_doc = 'index'
add_module_names = False
modindex_common_prefix = ['attest.']


if 'dev' in release:  # RTD
    html_theme = 'default'
else:
    html_theme = 'attest'
    html_theme_path = ['_themes']

html_static_path = ['_static']
html_use_opensearch = 'http://packages.python.org/Attest'
html_sidebars =\
    {'**':
        ['globaltoc.html',
         'searchbox.html',
        ],
    }


try:
    import sphinxcontrib.spelling
except ImportError:
    pass
else:
    extensions.append('sphinxcontrib.spelling')
    spelling_lang = 'en_UK'
    spelling_word_list_filename = os.path.abspath('non-typos.txt')

########NEW FILE########
__FILENAME__ = sampletests
from attest import Tests, assert_hook

samples = Tests()

@samples.test
def number_and_sequence():
    number = 2 + 3
    sequence = [1, 2, 3]
    assert number in sequence and isinstance(number, float)

if __name__ == '__main__':
    samples.main()

########NEW FILE########
