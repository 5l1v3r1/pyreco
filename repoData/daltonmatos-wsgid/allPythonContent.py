__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# wsgid documentation build configuration file, created by
# sphinx-quickstart on Wed Feb 13 20:15:05 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

class Mock(object):
    def __init__(self, *args, **kwargs):
        pass

    def __call__(self, *args, **kwargs):
        return Mock()

    @classmethod
    def __getattr__(cls, name):
        if name in ('__file__', '__path__'):
            return '/dev/null'
        elif name[0] == name[0].upper():
            mockType = type(name, (), {})
            mockType.__module__ = __name__
            return mockType
        else:
            return Mock()

on_rtd = os.environ.get('READTHEDOCS', None) == 'True'

if on_rtd:
    MOCK_MODULES = ['zmq']
    for mod_name in MOCK_MODULES:
        sys.modules[mod_name] = Mock()


# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.intersphinx', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'wsgid'
copyright = u'2013, Dalton Barreto'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
sys.path.insert(0, '../')
from wsgid import __version__
version = __version__
# The full version, including alpha/beta/rc tags.
release = __version__

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'sphinxdoc'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'wsgiddoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index2', 'wsgid.tex', u'wsgid Documentation',
   u'Dalton Barreto', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index2', 'wsgid', u'wsgid Documentation',
     [u'Dalton Barreto'], 1)
]


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/': None}

########NEW FILE########
__FILENAME__ = timecalc

from time import time
from wsgid.interfaces.filters import IPostRequestFilter, IPreRequestFilter
from wsgid.core import Plugin


r = {}


# Example of two filters that works togheter.
# The PreRequestFilter uses the wsgid.core.Message to store the
# Start time fo the request.
#
# After the WSGI app is called, the PostRequestFilter calculates
# the amount of time the request took to run completely.
#
# Note that this time can potentially not be accuarte. If you have many
# PostRequestFilters and this filters happens to be the last one in the
# execution chain, the final calculated time will be distorted.


class CalcTimePreReqFilter(Plugin):

    implements = [IPreRequestFilter, ]

    def process(self, message, environ):
        r[message.client_id] = time()


class CalcTimePostReqFilter(Plugin):

    implements = [IPostRequestFilter, ]

    def process(self, message, status, headers, body):
        elapsed = time() - r[message.client_id]
        del r[message.client_id]
        return (status, headers + [('X-Time', "{0} ms".format(str(elapsed)))], body)

    def exception(self, message, e):
        pass

########NEW FILE########
__FILENAME__ = workerpid
import os

from wsgid.interfaces.filters import IPostRequestFilter
from wsgid.core import Plugin


class WorkerPidFilter(Plugin):
    '''
     Simple fillter that adds one more response header containing the
     pid of the Wsgid workers that was running the WSGI application
    '''

    implements = [IPostRequestFilter, ]

    def process(self, message, status, headers, body):
        return (status, headers + [('X-Worker', os.getpid())], body)

    def exception(self, message, e):
        pass

########NEW FILE########
__FILENAME__ = wsgid_test
#encoding: utf-8

import unittest
from wsgid.core import Wsgid
from wsgid.test import FakeOptions
import wsgid.conf
import urllib2
import time
import logging
logging.basicConfig(level=logging.DEBUG)
import multiprocessing
logger = multiprocessing.log_to_stderr()
logger.setLevel(multiprocessing.SUBDEBUG)

class WsgidServeTest(unittest.TestCase):

    def setUp(self):
        wsgid.conf.settings = FakeOptions(mongrel2_chroot=None)

    def test_app_return_body(self):
        def app(environ, start_response):
            start_response('200 OK', [('Some-Header', 'Some-Value')])
            return ['Body content']
        pid = self._run_wsgid(app)
        try:
            r = urllib2.urlopen('http://127.0.0.1:8888/py/abc/')
            body = r.read()
            self.assertEquals(body, 'Body content')
        finally:
            self._kill_wsgid(pid)

    def test_app_return_body_with_more_than_one_item(self):
        '''
        Ensure that when the WSGI app returns ['Line1', 'Line2', ...]
        Wsgid joins all parts to build the complete body
        '''
        def app(env, start_response):
            start_response('200 OK', [])
            return ['More Lines\n', 'And more...\n']
        pid = self._run_wsgid(app)
        try:
            r = urllib2.urlopen('http://127.0.0.1:8888/py/abc/')
            self.assertEquals('More Lines\nAnd more...\n', r.read())
        finally:
            self._kill_wsgid(pid)

    def test_app_use_write_callable(self):
        def app(env, start_response):
            write = start_response('200 OK', [])
            write('One Line\n')
            write('Two Lines\n')
            return None
        pid = self._run_wsgid(app)
        try:
            r = urllib2.urlopen('http://127.0.0.1:8888/py/abc/')
            self.assertEquals('One Line\nTwo Lines\n', r.read())
        finally:
            self._kill_wsgid(pid)

    def test_app_return_an_iterable(self):
        '''
            Instead of returnin a list, a app can return an object that is iterable
        '''
        def app(environ, start_response):
            class Body(object):
                def __init__(self, parts):
                    self.parts = parts

                def __iter__(self):
                    for a in self.parts:
                        yield a

            start_response('200 OK', [])
            return Body(['Line One\n', 'Line Two\n'])

        pid = self._run_wsgid(app)
        try:
            r = urllib2.urlopen('http://127.0.0.1:8888/py/abc/')
            self.assertEquals('Line One\nLine Two\n', r.read())
        finally:
            self._kill_wsgid(pid)

    def test_app_receives_a_post_request(self):
        '''
        A Simple POST that do not use mongrel2's async upload
        '''
        def app(environ, start_response):
            start_response('200 OK', [])
            if environ['REQUEST_METHOD'] == 'POST':
                return [environ['wsgi.input'].read()]

        pid = self._run_wsgid(app)
        try:
            r = urllib2.urlopen('http://127.0.0.1:8888/py/post', data='Some post data')
            self.assertEquals('Some post data', r.read())
        finally:
            self._kill_wsgid(pid)

    def _run_wsgid(self, app):
        def _serve(app):
            import multiprocessing
            w = Wsgid(app,
                'tcp://127.0.0.1:8889',
                'tcp://127.0.0.1:8890')
            w.log = multiprocessing.get_logger()
            w.log.setLevel(logging.DEBUG)
            w.serve()
        import multiprocessing
        p = multiprocessing.Process(target=_serve, args=(app,))

        p.start()
        time.sleep(1)
        return p.pid

    def _kill_wsgid(self, pid):
        import os
        os.kill(pid, 15)

########NEW FILE########
__FILENAME__ = settings

########NEW FILE########
__FILENAME__ = urls

########NEW FILE########
__FILENAME__ = cli_test
#encoding: utf-8

import sys
import signal
import os
import logging

import unittest
from wsgid.core.cli import Cli
from wsgid.core import parser, WsgidApp, validate_input_params, _is_valid_socket
from wsgid.commands import CommandInit
from wsgid.test import fullpath, FakeOptions
import wsgid.conf

import daemon

from mock import patch, Mock, MagicMock


ROOT_PATH = fullpath(__file__)
FIXTURES_PATH = os.path.join(ROOT_PATH, 'fixtures')


class CliTest(unittest.TestCase):

    @patch('sys.stderr')
    def setUp(self, *args):
        self.cli = Cli()
        # As we are dealing with a command line test, we have do clean the passed arguments
        # so the tested applications does not try to use them
        sys.argv[1:] = []
        self.fake_app_path = os.path.join(fullpath(__file__), 'app-path')

        # Ok, not pretty but better than re-implementing this in python
        os.system("rm -rf {0}".format(os.path.join(self.fake_app_path, 'pid/')))
        self.cli.options = parser._parse_args()
        self.cli.options.app_path = self.fake_app_path

        CommandInit().run(FakeOptions(app_path=self.fake_app_path))

    def tearDown(self):
        wsgid.conf.settings = None

    def test_nodaemon(self):
        opts = self._parse()
        self.assertTrue(opts['detach_process'])

    def test_daemon_keep_sigterm_handler(self):
        opt = self._parse()
        self.assertTrue(opt['detach_process'])
        handler = signal.getsignal(signal.SIGTERM)
        self.assertEquals(opt['signal_map'][signal.SIGTERM], handler)

    def test_nodaemon_keep_basic_fds(self):
        '''
        When not a daemon we must keep std{in, out, err}
        '''
        opt = self._parse('--no-daemon')
        self.assertFalse(opt['detach_process'])
        self.assertEquals(opt['stdin'], sys.stdin)
        self.assertEquals(opt['stdout'], sys.stdout)
        self.assertEquals(opt['stderr'], sys.stderr)

    def test_no_chroot_if_no_app_path(self):
        '''
        If we choose to --chroot and --app-path is not passed, we should
        use the current working dir as the --app-path
        '''
        with patch('os.getcwd') as cwd:
            cwd.return_value = '/tmp'
            opt = self._parse('--chroot')
            self.assertEquals('/tmp', opt['chroot_directory'])

    def test_no_chroot(self):
        '''
        We shoud not chroot if --chroot is not passed.
        '''
        opt = self._parse('--app-path=./')
        self.assertFalse(opt.has_key('chroot_directory'))

    def test_drop_priv(self):
        '''
        If we are chrooting we must drop privileges.
        '''
        opt = self._parse('--app-path=./', '--chroot')
        stat = os.stat('./')
        self.assertEquals(opt['uid'], stat.st_uid)
        self.assertEquals(opt['gid'], stat.st_gid)

    def test_chroot_has_absolute_app_path(self):
        '''
        chroot_diretocry should have the absolute path of --app-path
        '''
        opt = self._parse('--chroot', '--app-path=./')
        abspath = os.path.abspath(os.getcwd())
        self.assertEquals(opt['chroot_directory'], abspath)

    def test_parse_workers_as_integer(self):
        sys.argv[1:] = ['--workers=3']
        opts = parser._parse_args()
        self.assertTrue(type(int), opts.workers)

    def _parse(self, *opts):
        sys.argv[1:] = opts
        return self.cli._create_daemon_options(parser.parse_options())

    def test_ajust_log_path_app_path(self):
        '''
        We must generate all logs inside <app-path>/logs
        '''
        app_path = os.path.join('../', os.path.dirname(__file__), 'app-path')
        sys.argv[1:] = ['--app-path=%s' % app_path]
        opt = parser._parse_args()
        self.cli._set_loggers(opt)
        handlers = self.cli.log.handlers
        self.assertTrue(isinstance(handlers[0], logging.FileHandler))
        self.assertEquals(os.path.join(app_path, 'logs/wsgid.log'), handlers[0].baseFilename)

    def test_full_path_empty_path(self):
        self.assertEquals(parser._full_path(None), None)

    def test_should_droppriv_if_app_path_is_passed(self):
        '''
        Even if we do not chroot, we must drop priv.
        '''
        app_path = os.path.join('../', os.path.dirname(__file__), 'app-path')
        argv = ['--app-path=%s' % app_path]
        stat = os.stat(parser._full_path(app_path))
        opts = self._parse(*argv)
        self.assertEquals(opts['uid'], stat.st_uid)
        self.assertEquals(opts['gid'], stat.st_gid)

    def test_load_wsgid_json_file(self):
        '''
        If we have a wsgid.json file inside app-path, so we must use it.
        '''
        app_path = os.path.join('../', os.path.dirname(__file__), 'app-path')
        # All we have to do is pass --app-path, so wsgfid ca find ${app-path}/wsgid.json
        sys.argv[1:] = ['--app-path=%s' % app_path]
        options = parser.parse_options()
        self.assertEquals('tcp://127.0.0.1:5000', options.recv)
        self.assertEquals('tcp://127.0.0.1:5001', options.send)
        self.assertEquals(4, options.workers)
        self.assertEquals(True, options.debug)
        self.assertEquals(True, options.keep_alive) #If one option does now exist in the config file, we get the default value
        self.assertEquals(False, options.chroot)
        self.assertEquals(True, options.stdout)

        self.assertEquals({'ENV1': 'VALUE1', 'ENV2': 'VALUE2'}, options.envs)

    def test_wsgid_json_overwrites_command_line(self):
        app_path = os.path.join('../', os.path.dirname(__file__), 'app-path')
        sys.argv[1:] = ['--app-path={0}'.format(app_path), '--workers=8']
        options = parser.parse_options()
        self.assertEquals(4, options.workers)

    def test_autocreate_pid_folder_structure(self):

        os.system("rm -rf {0}".format(os.path.join(self.fake_app_path, 'pid/')))
        pid_folder = os.path.join(self.fake_app_path, 'pid')
        master_pid_folder = os.path.join(pid_folder, 'master')
        worker_pid_folder = os.path.join(pid_folder, 'worker')
        master_pid_file = os.path.join(master_pid_folder, '42.pid')
        worker_pid_file = os.path.join(worker_pid_folder, '43.pid')

        self.assertFalse(os.path.exists(pid_folder))
        self.assertFalse(os.path.exists(master_pid_folder))
        self.assertFalse(os.path.exists(worker_pid_folder))

        self.cli._write_pid(42, self.cli.MASTER)
        self.cli._write_pid(43, self.cli.WORKER)

        # Check we created all necessary paths
        self.assertTrue(os.path.exists(pid_folder))
        self.assertTrue(os.path.exists(master_pid_folder))
        self.assertTrue(os.path.exists(worker_pid_folder))

        self.assertTrue(os.path.exists(os.path.join(master_pid_folder, '42.pid')))
        self.assertTrue(os.path.exists(os.path.join(worker_pid_folder, '43.pid')))

        self.assertEquals("42", file(master_pid_file).read())
        self.assertEquals("43", file(worker_pid_file).read())

    def test_remove_pid(self):
        self.cli._write_pid(42, self.cli.MASTER)
        pid_file = os.path.join(self.fake_app_path, 'pid/master/42.pid')

        self.cli._remove_pid(42, self.cli.MASTER)
        self.assertFalse(os.path.exists(pid_file))

    @patch('sys.stderr')
    def test_start_workers_when_nodaemon(self, *args):
        '''
        Doing this wsgid is able to run with a process supervisor.
        See: issue/20 at github
        '''
        path = os.path.join(FIXTURES_PATH, 'nodaemon-app')
        initcmd = CommandInit()
        initcmd.run(FakeOptions(app_path=path))
        with patch('daemon.DaemonContext', new=MagicMock()):
            with patch.object(Cli, '_create_worker'):
                with patch('wsgid.core.cli.validate_input_params'):
                    with patch.object(Cli, '_wait_workers'):
                        daemon.DaemonContext.__enter__ = Mock()
                        daemon.DaemonContext.__exit__ = Mock()
                        sys.argv[1:] = ['--workers=3', '--no-daemon', '--app-path={0}'.format(path)]
                        cli = Cli()
                        cli.run()
                        self.assertEquals(3, cli._create_worker.call_count)
                        self.assertEquals(1, cli._wait_workers.call_count)

    def test_daemon_should_create_normal_logs(self):
        '''
        When using only --do-daemon (without --stdout) logs must be
        redirected to log file.
        '''
        opts = FakeOptions(app_path="/some/path", no_daemon=True, stdout=False, debug=None, chroot=None)
        with patch('logging.FileHandler'):
            cli = Cli()
            cli._set_loggers(opts)
            self.assertEquals(1, logging.FileHandler.call_count)
            self.assertEquals((("/some/path/logs/wsgid.log",), {}), logging.FileHandler.call_args)

    def test_create_log_for_stdout(self):
        '''
        When we pass --stdout all logs must be pointed to stdout.
        '''
        opts = FakeOptions(app_path="/some/path", no_daemon=True, stdout=True, debug=None, chroot=None)
        with patch('logging.StreamHandler'):
            cli = Cli()
            cli._set_loggers(opts)
            self.assertEquals(1, logging.StreamHandler.call_count)

    @patch('sys.stderr')
    def test_clean_pid_files_on_keyboard_interrupt(self, *args):
        path = os.path.join(FIXTURES_PATH, 'clean-pids-app')
        initcmd = CommandInit()
        opts = FakeOptions(app_path=path)
        initcmd.run(opts)
        open(os.path.join(path, 'pid/master/3340.pid'), 'w')
        open(os.path.join(path, 'pid/worker/2736.pid'), 'w')
        open(os.path.join(path, 'pid/worker/3847.pid'), 'w')
        with patch('os.wait'):
            with patch('os.getpid'):
                os.getpid.side_effect = lambda: 3340
                os.wait.side_effect = KeyboardInterrupt()
                cli = Cli()
                cli.options = opts
                cli.log = Mock()
                cli.workers = [2736, 3847]
                cli._wait_workers()
                app = WsgidApp(path)
                self.assertEquals([], app.master_pids())
                self.assertEquals([], app.worker_pids())

    def test_check_zmq_sockets(self):
        self.assertTrue(_is_valid_socket("tcp://127.0.0.1:8080"))
        self.assertTrue(_is_valid_socket("tcp://*:8080"))
        self.assertTrue(_is_valid_socket("tcp://machine.intranet.org:8080"))
        self.assertTrue(_is_valid_socket("ipc:///tmp/sock"))
        self.assertTrue(_is_valid_socket("inproc://#2"))
        self.assertTrue(_is_valid_socket("pgm:///tmp/sock"))
        self.assertFalse(_is_valid_socket("tcp://127.0.0.1"))
        self.assertFalse(_is_valid_socket("tcp://127.0.0.1:abc"))
        self.assertFalse(_is_valid_socket("invalid://127.0.0.1:abc"))

    def test_socket_validation(self):
        validate_input_params(app_path='/tmp', send='tcp://127.0.0.1:8800', recv='ipc:///tmp/sock')
        self.assertRaises(Exception, validate_input_params, app_path='/tmp', send='invalid://127.0.0.1:88')
        self.assertRaises(Exception, validate_input_params, app_path='/tmp', recv='tcp://127.0.0.1:89')
        self.assertRaises(Exception, validate_input_params, app_path='/tmp', recv='tcp://127.0.0.1', \
                send='ipc:///tmp/sock')
        self.assertRaises(Exception, validate_input_params, app_path='/tmp', recv='tcp://127.0.0.1:89', \
                send='invalid://127.0.0.1:88')

########NEW FILE########
__FILENAME__ = commands_test


import unittest
from wsgid.commands import *
from wsgid.test import FakeOptions, fullpath
import os
import simplejson

from mock import patch, Mock
import signal


ROOT_PATH = fullpath(__file__)
FIXTURES_PATH = os.path.join(ROOT_PATH, 'fixtures')
APP_PATH = os.path.join(FIXTURES_PATH, "newapp")

#Generates a fresh full path for the given app_name
def new_app_path(app_name):
  return os.path.join(FIXTURES_PATH, app_name)

class CommandInitTest(unittest.TestCase):

  def setUp(self):
    self.init = CommandInit()
    self.opt = FakeOptions(app_path=APP_PATH)

  '''
   If the the --app-path does not exist, create.
  '''
  @patch('sys.stderr')
  def test_create_root_folter_if_not_exists(self, *args):
    self.init.run(self.opt)
    self.assertTrue(os.path.exists(APP_PATH), "Did not create the app root folder")

  @patch('sys.stderr')
  def test_create_pid_structure(self, *args):
    self.init.run(self.opt)
    self.assertTrue(os.path.exists(os.path.join(APP_PATH, "pid")), "Did not create pid folder")
    self.assertTrue(os.path.exists(os.path.join(APP_PATH, "pid/master")), "Did not create master pid folder")
    self.assertTrue(os.path.exists(os.path.join(APP_PATH, "pid/worker")), "Did not create workers pid folder")

  @patch('sys.stderr')
  def test_create_log_dir(self, *args):
    self.init.run(self.opt)
    self.assertTrue(os.path.exists(os.path.join(APP_PATH, "logs")), "Did not create logs folder")

  @patch('sys.stderr')
  def test_create_app_dir(self, *args):
    self.init.run(self.opt)
    self.assertTrue(os.path.exists(os.path.join(APP_PATH, "app")), "Did not create app folder")

  @patch('sys.stderr')
  def test_create_plugins_dir(self, *args):
    self.init.run(self.opt)
    self.assertTrue(os.path.exists(os.path.join(APP_PATH, "plugins")), "Did not create app folder")

  '''
   Checks there is no problem if we run "init" on an already
   inited path
  '''
  @patch('sys.stderr')
  def test_init_an_already_inited_path(self, *args):
    self.init.run(FakeOptions(app_path=APP_PATH))
    os.system("rm -rf {0}".format(os.path.join(APP_PATH, 'pid')))
    self.init.run(FakeOptions(app_path=APP_PATH))
    self.assertTrue(os.path.exists(os.path.join(APP_PATH, "app")))
    self.assertTrue(os.path.exists(os.path.join(APP_PATH, "logs")))
    self.assertTrue(os.path.exists(os.path.join(APP_PATH, "pid")))
    self.assertTrue(os.path.exists(os.path.join(APP_PATH, "pid/master")))
    self.assertTrue(os.path.exists(os.path.join(APP_PATH, "pid/worker")))
    self.assertTrue(os.path.exists(os.path.join(APP_PATH, "plugins")), "plugins dir should exist")

class CommandConfigTest(unittest.TestCase):

  @patch('sys.stderr')
  def setUp(self, *args):
    self.config = CommandConfig()
    self.init = CommandInit()
    self.CLEAN_PATH = os.path.join(FIXTURES_PATH, 'clean-path')
    self.opt = FakeOptions(app_path=self.CLEAN_PATH, wsgi_app="app.frontends.wsgi.application",\
                      debug=True, no_daemon=True, workers=8, keep_alive=True, chroot=True,\
                      recv="tcp://127.0.0.1:7000", send="tcp://127.0.0.1:7001",\
                      no_debug=False, no_chroot=False, no_keep_alive=False, mongrel2_chroot = '/var',
                      django=False)

    self.init.run(self.opt)

  '''
   if ${app-path}/wsgid.json does not exists, create
  '''
  def test_create_json_if_not_exist(self):
    self.config.run(self.opt)
    self.assertTrue(os.path.exists(os.path.join(self.CLEAN_PATH, "wsgid.json")))

  '''
   An option passed on the command line, overrides the same option in the
   config file.
  '''
  def test_override_option(self):
    # Write an config file so we can override some options
    f = file(os.path.join(self.CLEAN_PATH, "wsgid.json"), "w+")
    simplejson.dump({"recv": "tcp://127.0.0.1:3000", "debug": "True", "workers": 8, "chroot": "True"}, f)
    f.close()

    # Here we override some options
    self.opt.recv ="tcp://127.0.0.1:4000"
    self.opt.workers = 8
    self.opt.chroot = None

    # Run the config command
    self.config.run(self.opt)

    # Check that the options passed on the command line are the new config options
    h = simplejson.loads(file(os.path.join(self.CLEAN_PATH, "wsgid.json"), "r+").read())
    self.assertEquals("tcp://127.0.0.1:4000", h['recv'])
    self.assertEquals("True", h['debug'])
    self.assertEquals(8, h['workers'])
    self.assertEquals("True", h['chroot']) # An option nos passed on the command line should remain on the config file


  def test_create_all_options(self):
    open(os.path.join(self.CLEAN_PATH, 'wsgid.json'), 'w+') #Clean any old config file created by other tests
    opt = FakeOptions(app_path=self.CLEAN_PATH, wsgi_app="app.frontends.wsgi.application",\
                      debug=True, no_daemon=True, workers=8, keep_alive=True, chroot=True,\
                      recv="tcp://127.0.0.1:7000", send="tcp://127.0.0.1:7001",\
                      no_debug=False, no_chroot=False, no_keep_alive=False, mongrel2_chroot = '/var/www',
                      django=True)
    self.config.run(opt)
    h = simplejson.loads(file(os.path.join(self.CLEAN_PATH, "wsgid.json"), "r+").read())
    self.assertEquals("app.frontends.wsgi.application", h['wsgi_app'])
    self.assertEquals("True", h['debug'])
    self.assertEquals(8, h['workers'])
    self.assertEquals("True", h['keep_alive'])
    self.assertEquals("True", h['chroot'])
    self.assertEquals("True", h['no_daemon'])
    self.assertEquals("tcp://127.0.0.1:7000", h['recv'])
    self.assertEquals("tcp://127.0.0.1:7001", h['send'])
    self.assertEquals("/var/www", h['mongrel2_chroot'])
    self.assertEquals("True", h['django'])

  def test_validate_recv(self):
    open(os.path.join(self.CLEAN_PATH, 'wsgid.json'), 'w+') #Clean any old config file created by other tests
    opt = FakeOptions(app_path=self.CLEAN_PATH, wsgi_app="app.frontends.wsgi.application",\
                      debug=True, no_daemon=True, workers=8, keep_alive=True, chroot=True,\
                      recv="tcp//127.0.0.1:7000", send="tcp://127.0.0.1:7001",\
                      no_debug=False, no_chroot=False, no_keep_alive=False, mongrel2_chroot = '/var/www',
                      django=True)
    self.assertRaises(Exception, self.config.run, opt)

  def test_validate_send(self):
    open(os.path.join(self.CLEAN_PATH, 'wsgid.json'), 'w+') #Clean any old config file created by other tests
    opt = FakeOptions(app_path=self.CLEAN_PATH, wsgi_app="app.frontends.wsgi.application",\
                      debug=True, no_daemon=True, workers=8, keep_alive=True, chroot=True,\
                      recv="tcp://127.0.0.1:7000", send="tcp:/127.0.0.1:7001",\
                      no_debug=False, no_chroot=False, no_keep_alive=False, mongrel2_chroot = '/var/www',
                      django=True)
    self.assertRaises(Exception, self.config.run, opt)

  '''
    the no_debug options is an extra option added by the config command
  '''
  def test_disable_boolean_option(self):
    opt = FakeOptions(app_path=self.CLEAN_PATH, wsgi_app="app.frontends.wsgi.application",\
                      no_debug=True, debug=True, workers=9, keep_alive=True, chroot=True,\
                      recv="tcp://127.0.0.1:7000", send="tcp://127.0.0.1:7001",
                      no_chroot=False, no_keep_alive=False, no_daemon = False, mongrel2_chroot = '/var',
                      django=False)
    self.config.run(opt)
    h = simplejson.loads(file(os.path.join(self.CLEAN_PATH, "wsgid.json"), "r+").read())
    self.assertEquals("app.frontends.wsgi.application", h['wsgi_app'])
    self.assertEquals("False", h['debug'])


class CommandManageTest(unittest.TestCase):

  @patch('sys.stderr')
  def setUp(self, *args):
     self.init = CommandInit()
     self.manage = CommandManage()
     self.opt = FakeOptions(app_path=APP_PATH, send_signal=signal.SIGTERM)
     self.init.run(self.opt)

  def test_match_command_names_matches(self):
    self.assertTrue(self.manage.name_matches('stop'))
    self.assertTrue(self.manage.name_matches('restart'))
    self.assertFalse(self.manage.name_matches('start'))

  def test_command_name(self):
    self.assertEquals('restart, stop', self.manage.command_name())

  def test_run_stop_command(self):
    open(os.path.join(APP_PATH, "pid/master/2968.pid"), "w")
    open(os.path.join(APP_PATH, "pid/master/9847.pid"), "w")

    with patch('os.kill'):
      self.manage.run(self.opt, command_name = 'stop')
      self.assertEquals(2, os.kill.call_count)
      self.assertTrue(((9847, 15), {}) in os.kill.call_args_list)
      self.assertTrue(((2968, 15), {}) in os.kill.call_args_list)

  def test_run_restart_command(self):
    open(os.path.join(APP_PATH, "pid/worker/3847.pid"), "w")
    open(os.path.join(APP_PATH, "pid/worker/4857.pid"), "w")

    with patch('os.kill'):
      self.manage.run(self.opt, command_name = 'restart')
      self.assertEquals(2, os.kill.call_count)
      self.assertTrue(((3847, 15), {}) in os.kill.call_args_list)
      self.assertTrue(((4857, 15), {}) in os.kill.call_args_list)

  @patch('sys.stderr')
  def test_send_custom_signal(self, *args):
    apppath = new_app_path('custom-signal')
    opts = FakeOptions(app_path=apppath, send_signal=9)
    self.init.run(opts)
    open(os.path.join(apppath, "pid/master/3847.pid"), "w")
    open(os.path.join(apppath, "pid/worker/3690.pid"), "w")

    with patch('os.kill'):
      self.manage.run(opts, command_name = 'stop')
      self.manage.run(opts, command_name = 'restart')
      self.assertEquals(2, os.kill.call_count)
      #Check that we sent SIGKILL
      self.assertEquals( [((3847, 9), {}), ((3690, 9), {})], os.kill.call_args_list)


  def test_kill_already_dead_pid(self):
    open(os.path.join(APP_PATH, "pid/worker/3847.pid"), "w")
    open(os.path.join(APP_PATH, "pid/worker/4857.pid"), "w")

    with patch('os.kill'):
      os.kill = Mock(side_effect=OSError("No such process"))
      self.manage.run(self.opt, command_name = 'restart')
      self.assertEquals(2, os.kill.call_count)
      self.assertTrue(((3847, 15), {}) in os.kill.call_args_list)
      self.assertTrue(((4857, 15), {}) in os.kill.call_args_list)

  '''
   Check that wsgid does not crash if we have invalid pid files
  '''
  @patch('sys.stderr')
  def test_invalid_pid_files(self, *args):
    new_path = os.path.join(FIXTURES_PATH, 'crash-app')
    opts = FakeOptions(app_path=new_path, send_signal=signal.SIGTERM)
    self.init.run(opts)
    open(os.path.join(new_path, "pid/worker/crash.pid"), "w")

    with patch('os.kill'):
      self.manage.run(opts, command_name = 'restart')
      self.assertEquals(0, os.kill.call_count)

class CommandStatusTest(unittest.TestCase):

  @patch('sys.stderr')
  def setUp(self, *args):
     self.init = CommandInit()
     self.manage = CommandManage()
     self.new_path = os.path.join(FIXTURES_PATH, 'status-command')
     self.opt = FakeOptions(app_path=self.new_path, send_signal=signal.SIGTERM)
     self.init.run(self.opt)


  def test_command_name(self):
    self.assertEquals('status', CommandStatus().command_name())

  def test_command_name_matches(self):
    self.assertTrue(CommandStatus().name_matches('status'))
    self.assertFalse(CommandStatus().name_matches('ostatus'))

  def test_list_master_pids(self):
    with patch('os.kill'): #So od.kill reports any pid as "running"
      with patch('sys.stdout'):
        open(os.path.join(self.new_path, "pid/master/3847.pid"), "w")
        open(os.path.join(self.new_path, "pid/worker/4857.pid"), "w")
        CommandStatus().run(self.opt)
        self.assertEquals(3, sys.stdout.write.call_count)
        self.assertEquals([(("Status: Running\n",), {}),
                           (("Master pid(s): 3847\n",), {}),
                           (("Worker pid(s): 4857\n",), {})], sys.stdout.write.call_args_list)

  def test_list_worker_pids(self):
    path = os.path.join(FIXTURES_PATH, 'worker-pids-app')
    with patch('sys.stderr'):
      CommandInit().run(FakeOptions(app_path=path))

    with patch('os.kill'): #So os.kill reports any pid as "running"
      with patch('sys.stdout'):
       open(os.path.join(path, "pid/worker/3847.pid"), "w")
       open(os.path.join(path, "pid/worker/3948.pid"), "w")
       open(os.path.join(path, "pid/worker/4857.pid"), "w")
       CommandStatus().run(FakeOptions(app_path=path))
       self.assertEquals(3, sys.stdout.write.call_count)
       self.assertEquals([(("Status: Running\n",), {}),
                          (("Master pid(s): \n",), {}),
                          (("Worker pid(s): 3847, 3948, 4857\n",), {})], sys.stdout.write.call_args_list)

  def test_status_when_no_worker_pids(self):
    path = os.path.join(FIXTURES_PATH, 'noworker-pids-app')
    with patch('sys.stderr'):
      CommandInit().run(FakeOptions(app_path=path))

    with patch('sys.stdout'):
     open(os.path.join(path, "pid/master/3847.pid"), "w")
     CommandStatus().run(FakeOptions(app_path=path))
     self.assertEquals(3, sys.stdout.write.call_count)
     self.assertEquals([(("Status: Stopped\n",), {}),
                        (("Master pid(s): 3847\n",), {}),
                        (("Worker pid(s): \n",), {})], sys.stdout.write.call_args_list)

  def test_check_pids_are_running(self):
    path = os.path.join(FIXTURES_PATH, 'check-running-pids-app')
    with patch('sys.stderr'):
      CommandInit().run(FakeOptions(app_path=path))

    with patch('sys.stdout'):
     with patch('os.kill'):
       os.kill.side_effect = OSError("No such process")
       open(os.path.join(path, "pid/master/3847.pid"), "w")
       # Even having a valid worker pid, the final status must be Stopped becaus this process does not exist
       open(os.path.join(path, "pid/worker/2845.pid"), "w")
       CommandStatus().run(FakeOptions(app_path=path))
       self.assertEquals(3, sys.stdout.write.call_count)
       self.assertEquals([(("Status: Stopped\n",), {}),
                          (("Master pid(s): 3847\n",), {}),
                          (("Worker pid(s): 2845(dead)\n",), {})], sys.stdout.write.call_args_list)


########NEW FILE########
__FILENAME__ = core_test



import unittest
from wsgid.core import run_command
from wsgid.commands import *
import plugnplay
import sys

from mock import Mock

class CoreTest(unittest.TestCase):


  def test_ICommand_must_receive_command_name(self):
      mock_command = Mock(wraps=CommandManage())

      # Very dirty hack to replace CommandManage implementation inside plugnplay
      saved = plugnplay.man.iface_implementors[ICommand]
      plugnplay.man.iface_implementors[ICommand] = [mock_command]
      sys.argv[:] = ['wsgid', 'stop', '--app-path=/tmp/app-path']

      found_implementor = run_command()
      
      plugnplay.man.iface_implementors[ICommand] = saved

      self.assertTrue(found_implementor, "Did not find any ICommand implementing stop command")
      self.assertTrue(mock_command.run.called, "ManageCommand.run() not called")
      print mock_command.run.call_args
      self.assertEquals({'command_name': 'stop'}, mock_command.run.call_args[1])

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
from django.core.management import execute_manager
import imp
try:
    imp.find_module('settings') # Assumed to be in the same directory.
except ImportError:
    import sys
    sys.stderr.write("Error: Can't find the file 'settings.py' in the directory containing %r. It appears you've customized things.\nYou'll have to run django-admin.py, passing it your settings module.\n" % __file__)
    sys.exit(1)

import settings

if __name__ == "__main__":
    execute_manager(settings)

########NEW FILE########
__FILENAME__ = settings
# Django settings for mydjangoapp project.

DEBUG = True
TEMPLATE_DEBUG = DEBUG

ADMINS = (
    # ('Your Name', 'your_email@example.com'),
)

MANAGERS = ADMINS

MY_CUSTOM_SETTING = "Custom"
MY_OTHER_CUSTOM_SETTING = "still-the-same-value"

MY_HASH = {
        'subhash': {
            'k1': 'v1',
            'k2': 'v2'
        }
}

GENERIC_SETTING = True

MY_LIST_SETTING = ['some value', 'another one', 'ok, enough']

TUPLE_SETTING = ('one', 'two')

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql', # Add 'postgresql_psycopg2', 'postgresql', 'mysql', 'sqlite3' or 'oracle'.
        'NAME': 'pgdb',                      # Or path to database file if using sqlite3.
        'USER': 'postgres',                      # Not used with sqlite3.
        'PASSWORD': 'pgpasswd',                  # Not used with sqlite3.
        'HOST': 'localhost',                      # Set to empty string for localhost. Not used with sqlite3.
        'PORT': '5432',                      # Set to empty string for default. Not used with sqlite3.
    }
}

# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# On Unix systems, a value of None will cause Django to use the same
# timezone as the operating system.
# If running in a Windows environment this must be set to the same as your
# system time zone.
TIME_ZONE = 'America/Chicago'

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'en-us'

SITE_ID = 1

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

# If you set this to False, Django will not format dates, numbers and
# calendars according to the current locale
USE_L10N = True

# Absolute filesystem path to the directory that will hold user-uploaded files.
# Example: "/home/media/media.lawrence.com/media/"
MEDIA_ROOT = ''

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash.
# Examples: "http://media.lawrence.com/media/", "http://example.com/media/"
MEDIA_URL = ''

# Absolute path to the directory static files should be collected to.
# Don't put anything in this directory yourself; store your static files
# in apps' "static/" subdirectories and in STATICFILES_DIRS.
# Example: "/home/media/media.lawrence.com/static/"
STATIC_ROOT = ''

# URL prefix for static files.
# Example: "http://media.lawrence.com/static/"
STATIC_URL = '/static/'

# URL prefix for admin static files -- CSS, JavaScript and images.
# Make sure to use a trailing slash.
# Examples: "http://foo.com/static/admin/", "/static/admin/".
ADMIN_MEDIA_PREFIX = '/static/admin/'

# Additional locations of static files
STATICFILES_DIRS = (
    # Put strings here, like "/home/html/static" or "C:/www/django/static".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

# List of finder classes that know how to find static files in
# various locations.
STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
#    'django.contrib.staticfiles.finders.DefaultStorageFinder',
)

# Make this unique, and don't share it with anybody.
SECRET_KEY = 'd6a=ki$a!@vg3%7k6_x$!0er&h^d%%v5*_x1s%ck0#7i1(p4^7'

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
#     'django.template.loaders.eggs.Loader',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
)

ROOT_URLCONF = 'mydjangoapp.urls'

TEMPLATE_DIRS = (
    # Put strings here, like "/home/html/django_templates" or "C:/www/django/templates".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    # Uncomment the next line to enable the admin:
    # 'django.contrib.admin',
    # Uncomment the next line to enable admin documentation:
    # 'django.contrib.admindocs',
)

# A sample logging configuration. The only tangible logging
# performed by this configuration is to send an email to
# the site admins on every HTTP 500 error.
# See http://docs.djangoproject.com/en/dev/topics/logging for
# more details on how to customize your logging configuration.
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'mail_admins': {
            'level': 'ERROR',
            'class': 'django.utils.log.AdminEmailHandler'
        }
    },
    'loggers': {
        'django.request': {
            'handlers': ['mail_admins'],
            'level': 'ERROR',
            'propagate': True,
        },
    }
}

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import patterns, include, url

# Uncomment the next two lines to enable the admin:
# from django.contrib import admin
# admin.autodiscover()

urlpatterns = patterns('',
    # Examples:
    # url(r'^$', 'mydjangoapp.views.home', name='home'),
    # url(r'^mydjangoapp/', include('mydjangoapp.foo.urls')),

    # Uncomment the admin/doc line below to enable admin documentation:
    # url(r'^admin/doc/', include('django.contrib.admindocs.urls')),

    # Uncomment the next line to enable the admin:
    # url(r'^admin/', include(admin.site.urls)),
)

########NEW FILE########
__FILENAME__ = djangoloader


import unittest
import os
import sys

from wsgid.loaders.djangoloader import DjangoAppLoader
from wsgid.test import fullpath, FakeOptions
import wsgid.conf
from mock import patch, Mock
from django.conf import settings
import django

FIXTURE = fullpath(__file__)
WSGID_APP_NAME = 'django-wsgid-app'
DJANGOAPP_NO_INIT = 'djangonoinit'

class DjangoLoaderTest(unittest.TestCase):

  def setUp(self):
    dirname = os.path.dirname(__file__)
    self.abs_app_path = os.path.join(FIXTURE, WSGID_APP_NAME)
    self.wsgid_appfolder_fullpath = os.path.join(self.abs_app_path, 'app/')
    self.app_loader = DjangoAppLoader()
    wsgid.conf.settings = FakeOptions(django=False)

  '''
   Ensure we can load a djangoapp even with hidden folders
   inside the wsgi-app folder.
  '''
  def test_can_load_with_hidden_folder(self):

    self.assertTrue(self.app_loader.can_load(self.wsgid_appfolder_fullpath))

    with patch('os.listdir'):
      os.listdir.return_value = ['.git', '.hg', 'mydjangoapp']

      app = self.app_loader.load_app(self.wsgid_appfolder_fullpath, 'app')
      self.assertEquals(django.core.handlers.wsgi.WSGIHandler, app.__class__)
      self.assertEquals("mydjangoapp.settings", os.environ['DJANGO_SETTINGS_MODULE'])

  '''
   Check that we can recognize a simple wsgid app with a django app inside
  '''
  def test_can_load_django_app(self, *args):
      self.assertTrue(self.app_loader.can_load(self.wsgid_appfolder_fullpath))

  '''
   Check that if the --django option was passed, djangoloader returns always True
  '''
  def test_can_load_forced_as_django(self, *args):
      with patch('wsgid.conf.settings') as setting:
        setting.django = True
        self.assertTrue(self.app_loader.can_load("whatever"))

  '''
   A valid django folder must be importable, so we have to check
   that __init__.py exists.
  '''
  def test_django_folder_must_have_init(self):
      djangoapp_path = os.path.join(FIXTURE, 'wsgidapp-noinit/app')
      self.assertFalse(self.app_loader.can_load(djangoapp_path))

  def test_django_project_folder_added_to_sys_path(self):
      with patch('sys.path') as mock_syspath:
        with patch('os.listdir'):
            dirs = ['mydjangoapp', 'otherdjangoapp']
            os.listdir.return_value = dirs
            self.assertTrue(self.app_loader.can_load(self.wsgid_appfolder_fullpath))

            os.listdir.return_value = list(reversed(dirs))
            self.app_loader.load_app(self.wsgid_appfolder_fullpath, 'appname')
            self.assertEquals("mydjangoapp.settings", os.environ['DJANGO_SETTINGS_MODULE'])

            djangoproject_folder = os.path.join(self.wsgid_appfolder_fullpath, 'mydjangoapp')
            expected = [((self.wsgid_appfolder_fullpath,), {}), ((djangoproject_folder,), {})]
            self.assertEquals(expected ,mock_syspath.append.call_args_list)

  '''
   Check if we return False for a non-django app folder
  '''
  def test_not_django_wsgid_app_folder(self):
    with patch('os.listdir'):
      os.listdir.return_value  = []
      self.assertFalse(self.app_loader.can_load(self.wsgid_appfolder_fullpath))

  '''
    Since os.list returns the result in a random order, DjangoAppLoader can return True for can_load()
    but get a different result on the second call to os.listdir (inside load_app())
    We should consistently load the django app from the same folder we said we could load it.
  '''
  def test_prepared_for_os_listdir_random(self):
    with patch('os.listdir'):
      dirs = ['mydjangoapp', 'otherdjangoapp']
      os.listdir.return_value = dirs
      self.assertTrue(self.app_loader.can_load(self.wsgid_appfolder_fullpath))

      os.listdir.return_value = list(reversed(dirs))
      self.app_loader.load_app(self.wsgid_appfolder_fullpath, 'appname')
      self.assertEquals("mydjangoapp.settings", os.environ['DJANGO_SETTINGS_MODULE'])

  '''
   Check that we can load a django app that is not the first one (in alphabetical order)
  '''
  def test_can_load_the_second_folder(self):
    with patch('os.listdir'):
      os.listdir.return_value = ['anotherfolder', 'mydjangoapp']
      self.assertTrue(self.app_loader.can_load(self.wsgid_appfolder_fullpath))
      self.app_loader.load_app(self.wsgid_appfolder_fullpath, None)
      self.assertEquals("mydjangoapp.settings", os.environ['DJANGO_SETTINGS_MODULE'])

  '''
   Any setting inside settngs.py that are *not* mentioned on django.json must
   remain available when we do:
       from django.conf settings
       settings.MY_NON_OVERRIDEN_OPTION
  '''
  def test_custom_options_must_remain(self):
      app_path = os.path.join(FIXTURE, WSGID_APP_NAME, 'app')
      self.app_loader.load_app(app_path)
      self.assertEquals('still-the-same-value', settings.MY_OTHER_CUSTOM_SETTING)


  '''
   If we have a setting in django.json that does not exist in settings,
   we must create it
  '''
  def test_create_new_setting(self):
      app_path = os.path.join(FIXTURE, WSGID_APP_NAME, 'app')
      self.app_loader.load_app(app_path)
      self.assertEquals('a new value', settings.NEW_SETTING)

  '''
   If we have a TEST_OPT inside settings.py and this same
   options inside wsgidappfolder/django.json, the JSON version
   must be available at:
       from django.conf import settings
       settings.TEST_OPT
   after DjangoAppLodare loads this app.
  '''
  def test_override_existing_settings_option(self):
      app_path = os.path.join(FIXTURE, WSGID_APP_NAME, 'app')
      self.app_loader.load_app(app_path)
      self.assertEquals('other-value', settings.MY_CUSTOM_SETTING)

  '''
   If django.json contains a setting that is a dict we must "join" this
   dict from django.json with the dict loaded from app's settings.py
  '''
  def test_join_hash_setting(self):
      app_path = os.path.join(FIXTURE, WSGID_APP_NAME, 'app')
      self.app_loader.load_app(app_path)
      self.assertTrue(isinstance(settings.DATABASES, dict))
      self.assertEquals(2, len(settings.DATABASES))

      self.assertEquals("django.db.backends.postgresql", settings.DATABASES['default']['ENGINE'])
      self.assertEquals("pgdb", settings.DATABASES['default']['NAME'])
      self.assertEquals("postgres", settings.DATABASES['default']['USER'])
      self.assertEquals("pgpasswd", settings.DATABASES['default']['PASSWORD'])
      self.assertEquals("localhost", settings.DATABASES['default']['HOST'])
      self.assertEquals("5432", settings.DATABASES['default']['PORT'])

      self.assertEquals("mysql", settings.DATABASES['myotherdb']['ENGINE'])
      self.assertEquals("mydb", settings.DATABASES['myotherdb']['NAME'])
      self.assertEquals("user", settings.DATABASES['myotherdb']['USER'])
      self.assertEquals("passwd", settings.DATABASES['myotherdb']['PASSWORD'])
      self.assertEquals("localhost", settings.DATABASES['myotherdb']['HOST'])
      self.assertEquals("3598", settings.DATABASES['myotherdb']['PORT'])

  def test_override_hash_setting(self):
      app_path = os.path.join(FIXTURE, WSGID_APP_NAME, 'app')
      self.app_loader.load_app(app_path)
      self.assertTrue(isinstance(settings.MY_HASH, dict))
      self.assertEquals(1, len(settings.MY_HASH))

      self.assertEquals("new-v1", settings.MY_HASH['subhash']['k1'])
      self.assertEquals("new-v2", settings.MY_HASH['subhash']['k2'])
      self.assertEquals("new-v3", settings.MY_HASH['subhash']['k3'])


  '''
   Whataver is on django.json, overrides settings.py, even if
   settings are of different types
   This does not apply if original settings is dict or tuple
  '''
  def test_django_json_overrides_settings(self):
      app_path = os.path.join(FIXTURE, WSGID_APP_NAME, 'app')
      self.app_loader.load_app(app_path)
      self.assertTrue(isinstance(settings.GENERIC_SETTING, dict))
      self.assertEquals(1, len(settings.GENERIC_SETTING))
      self.assertEquals("v", settings.GENERIC_SETTING['k'])


  '''
   If we find a list settings we must append the extra values at the
   end of the found list
  '''
  def test_list_setting(self):
      setattr(settings, 'MY_LIST_SETTING', ['some value', 'another one'])
      app_path = os.path.join(FIXTURE, WSGID_APP_NAME, 'app')
      self.app_loader.load_app(app_path)
      self.assertTrue(isinstance(settings.MY_LIST_SETTING, list))
      self.assertEquals(['some value', 'another one', 'one more'], settings.MY_LIST_SETTING)

  '''
    If we have a setting on django.json (that is a list) with the same name of another
    setting (that is a tuple), the list must be converted to tuple.
  '''
  def test_convert_list_to_tuple(self):
      setattr(settings, 'TUPLE_SETTING', ('one', 'two'))
      app_path = os.path.join(FIXTURE, WSGID_APP_NAME, 'app')
      self.app_loader.load_app(app_path)
      self.assertTrue(isinstance(settings.TUPLE_SETTING, tuple))
      self.assertEquals(('one', 'two', 'three'), settings.TUPLE_SETTING)




########NEW FILE########
__FILENAME__ = loaders
#encoding: utf-8

import unittest

from wsgid.loaders import import_object

class ImportObjectTest(unittest.TestCase):

  def test_import_existing_object(self):
    join_obj = import_object('os.path.join')
    from os.path import join as real_obj
    self.assertEquals(join_obj, real_obj)

  def test_import_non_existing_object(self):
    self.assertRaises(Exception, import_object, 'os.path.joinnames')

########NEW FILE########
__FILENAME__ = message
#encoding: utf-8


import unittest
from wsgid.core.message import Message
import json



class PaserTest(unittest.TestCase):


  def setUp(self):
    self.server_id = "uuid"
    self.client_id = "42"
    self.path = "/some/path"
    self.header_json = json.dumps({'header':'value'})
    self.netstring = "%d:%s,4:body," % (len(self.header_json), self.header_json)


  def test_parse_mongrel2_message(self):
    msg = "%s %s %s %s" % (self.server_id, self.client_id,\
        self.path, self.netstring)
    parsed_message = Message(msg)
    self.assertEquals(self.server_id, parsed_message.server_id)
    self.assertEquals(self.client_id, parsed_message.client_id)
    self.assertEquals(self.path, parsed_message.path)
    self.assertEquals(self.netstring, parsed_message.netstring)

  def test_parse_body_with_space(self):
    body_with_space = "%d:%s,12:body w space," % (len(self.header_json), self.header_json)
    msg = "%s %s %s %s" % (self.server_id, self.client_id,\
        self.path, body_with_space)
    parsed_message = Message(msg)
    self.assertEquals(self.server_id, parsed_message.server_id)
    self.assertEquals(self.client_id, parsed_message.client_id)
    self.assertEquals(self.path, parsed_message.path)
    self.assertEquals(body_with_space, parsed_message.netstring)

  def test_parse_headers_with_space(self):
    header_w_space = json.dumps({'name': 'value with space'})
    headers_with_space = "%d:%s,4:body," % (len(header_w_space), header_w_space)
    msg = "%s %s %s %s" % (self.server_id, self.client_id,\
        self.path, headers_with_space)
    parsed_message = Message(msg)
    self.assertEquals(self.server_id, parsed_message.server_id)
    self.assertEquals(self.client_id, parsed_message.client_id)
    self.assertEquals(self.path, parsed_message.path)
    self.assertEquals(headers_with_space, parsed_message.netstring)

  def test_parse_real_headers(self):
    headers = {'PATH': '/some/path', 'PATTERN': '/some.*', 'host': 'localhost'}
    headers_json = json.dumps(headers)

    netstring = "%d:%s,4:body," % (len(headers_json), headers_json)

    msg = "%s %s %s %s" % (self.server_id, self.client_id,\
                           self.path, netstring)

    parsed_message = Message(msg)

    self.assertEqual(netstring, parsed_message.netstring)
    self.assertEqual(headers, parsed_message.headers)

  def test_parse_real_body(self):
    body = "<html> <body> some content </body> </html>"

    netstring = "%d:%s,%d:%s," % (len(self.header_json), self.header_json,\
                                  len(body), body)

    msg = "%s %s %s %s" % (self.server_id, self.client_id,\
                           self.path, netstring)
    parsed_message = Message(msg)

    self.assertEqual(body, parsed_message.body)

  def test_message_is_disconnect(self):
    msg = "uuid 1 @* %s"
    header = json.dumps({'METHOD': 'JSON'})
    body = json.dumps({'type': 'disconnect'})
    netstring = "%d:%s,%d:%s," % (len(header), header, len(body), body)
    parsed = Message(msg % netstring)
    self.assertTrue(parsed.is_disconnect())

  def test_is_start_async_upload(self):
      parsed = Message(self._build_m2message("body", {'x-mongrel2-upload-start': '/tmp/m2upload.38dG47'}))
      self.assertTrue(parsed.is_upload_start())

  def test_get_start_async_upload_path(self):
      parsed = Message(self._build_m2message("body", {'x-mongrel2-upload-start': '/tmp/m2upload.38dG47'}))
      self.assertEquals('/tmp/m2upload.38dG47', parsed.async_upload_path)


  def test_is_finish_async_upload(self):
      parsed = Message(self._build_m2message("body", {'x-mongrel2-upload-start': '/tmp/m2upload.38dG47' ,'x-mongrel2-upload-done': '/tmp/m2upload.38dG47'}))
      self.assertTrue(parsed.is_upload_done())
      self.assertFalse(parsed.is_upload_start())

  def test_is_finish_async_upload_check_values(self):
      parsed = Message(self._build_m2message("body", {'x-mongrel2-upload-start': '/tmp/m2uplo' ,'x-mongrel2-upload-done': '/tmp/m2upload.38dG47'}))
      self.assertFalse(parsed.is_upload_done())

  def test_is_finish_async_upload_no_start_header(self):
      parsed = Message(self._build_m2message("body", {'x-mongrel2-upload-done': '/tmp/m2upload.38dG47'}))
      self.assertFalse(parsed.is_upload_done())

  def test_is_finish_async_upload_no_finish_header(self):
      parsed = Message(self._build_m2message("body", {'x-mongrel2-upload-start': '/tmp/m2upload.38dG47'}))
      self.assertFalse(parsed.is_upload_done())

  def _build_m2message(self, body, headers, uuid='uuid', connid = '1', path = '/'):
      hdr_content = json.dumps(headers)
      net_str = "{len_hdr}:{header},{len_body}:{body},".format(len_hdr = len(hdr_content), header = hdr_content, len_body = len(body), body = body)
      msg = "{uuid} {connid} {path} {netstring}".format(uuid = uuid, connid = connid, path = path, netstring = net_str)
      return msg


########NEW FILE########
__FILENAME__ = parser_test




import unittest
from wsgid.core import parser
from wsgid.core.parser import CommandLineOption, BOOL, INT, STRING, LIST
import wsgid.conf

import sys
import signal
import platform

from mock import patch
from wsgid.commands import *

class ParserTest(unittest.TestCase):


  def setUp(self):
      wsgid.conf.settings = None

  '''
    Test if we correctly parse options added by sub-commands
    --no-daemon is added by the config command
  '''
  def test_parse_aditional_options(self):
    sys.argv[1:] = ['--no-debug', '--app-path=/tmp']
    opts = parser.parse_options()
    self.assertTrue(opts.no_debug)

  def test_parse_aditional_options_py26(self):
    with patch('platform.python_version'):
      platform.python_version.return_value = '2.6'
      # Call the parser
      sys.argv[1:] = ['--no-debug', '--app-path=/tmp']
      opts = parser.parse_options()
      self.assertTrue(opts.no_debug)

  '''
   Tests that the default signal os 15 (SIGTERM)
  '''
  def test_default_signal(self):
    sys.argv[1:] = ['--app-path=/tmp']
    opts = parser.parse_options()
    self.assertEquals(signal.SIGTERM, opts.send_signal)

  def test_parse_workers_as_integer(self):
    with patch('platform.python_version'):
      platform.python_version.return_value = '2.7.1'
      sys.argv[1:] = ['--workers=4']
      opts = parser.parse_options()
      self.assertEquals(4, opts.workers)

  def test_parse_default_workers_as_integer(self):
    with patch('platform.python_version'):
      platform.python_version.return_value = '2.7.1'
      sys.argv[1:] = []
      opts = parser.parse_options()
      self.assertEquals(1, opts.workers)

  def test_parse_forced_django_app(self):
    sys.argv[1:] = ['--app-path=/tmp', '--django']

    opts = parser.parse_options()
    self.assertTrue(wsgid.conf.settings.django)

  def test_parse_forced_django_defaults_to_false(self):
    sys.argv[1:] = ['--app-path=/tmp']

    opts = parser.parse_options()
    self.assertFalse(wsgid.conf.settings.django)

  '''
   Ensure we save the parsed options at wsgid.conf.settings
  '''
  def test_write_conf_settings(self):
    sys.argv[1:] = ['--app-path=/tmp', '--debug', '--no-daemon']

    self.assertTrue(wsgid.conf.settings is None)
    opts = parser.parse_options()
    self.assertTrue(wsgid.conf.settings is not None)
    self.assertEquals('/tmp', wsgid.conf.settings.app_path)
    self.assertTrue(wsgid.conf.settings.debug)
    self.assertTrue(wsgid.conf.settings.no_daemon)

  def test_no_parse_twice(self):
    sys.argv[1:] = ['--app-path=/tmp', '--debug']

    opts = parser.parse_options()
    self.assertTrue(wsgid.conf.settings is not None)
    self.assertEquals('/tmp', wsgid.conf.settings.app_path)
    self.assertTrue(wsgid.conf.settings.debug)

    sys.argv[1:] = ['--app-path=/tmp/2', '--debug', '--recv=tcp://127.0.0.1:9000']
    parser.parse_options()
    self.assertEquals(None, wsgid.conf.settings.recv)
    self.assertEquals('/tmp', wsgid.conf.settings.app_path)

  def test_app_path_defaults_to_pwd(self):
    sys.argv[1:] = []
    with patch('os.getcwd') as cwd:
      cwd.return_value = '/my/path'
      opts = parser.parse_options()
      self.assertEquals('/my/path', opts.app_path)


class CommandLineOptionTest(unittest.TestCase):


  def test_bool_default_true(self):
    opt = CommandLineOption(name="debug", type = BOOL, dest = 'debug', default_value = True)
    self.assertEquals('--debug', opt.name)
    self.assertEquals('store_true', opt.action)
    self.assertEquals('debug', opt.dest)

  def test_bool_default_false(self):
    opt = CommandLineOption(name="no-debug", type = BOOL, dest = 'nodebug', default_value = False)
    self.assertEquals('--no-debug', opt.name)
    self.assertEquals('store_false', opt.action)
    self.assertEquals('nodebug', opt.dest)

  def test_default_dest(self):
    opt = CommandLineOption(name="no-debug", type = BOOL, default_value = False)
    self.assertEquals('--no-debug', opt.name)
    self.assertEquals('store_false', opt.action)
    self.assertEquals('no_debug', opt.dest)

  def test_default_action(self):
    opt = CommandLineOption(name="no-debug", default_value = False)
    self.assertEquals('store', opt.action)

  def test_bool_correct_type(self):
    opt = CommandLineOption(name="no-debug", type = BOOL, default_value = False)
    self.assertEquals(bool, opt.type)

  def test_int_correct_type(self):
    opt = CommandLineOption(name="workers", type = INT)
    self.assertEquals(int, opt.type)

########NEW FILE########
__FILENAME__ = startresponse_test
#encoding: utf-8


import unittest
from wsgid.core import StartResponse, StartResponseCalledTwice, Wsgid
from wsgid.core.message import Message
from wsgid import __version__
from mock import patch, Mock, call, ANY

class StartResponseTest(unittest.TestCase):



  def setUp(self):
    self.wsgid = Wsgid()
    self.socket = Mock()
    self.socket.send.return_value = None
    self.wsgid.send_sock = self.socket
    message = Message('1 2 / 22:{"VERSION":"HTTP/1.0"},0:,')
    self.start_response = StartResponse(message, self.wsgid)


  def test_start_response_app_return_iterable(self):
    headers = [('Header', 'Value'), ('Other-Header', 'More-Value')]
    self.start_response('200 OK', headers)
    self.assertEquals(headers, self.start_response.headers)
    self.assertEquals('200 OK', self.start_response.status)

  # start_response no longer accumulates the body
  #def test_acumulate_body_data(self):
  #  write_fn = self.start_response('200 OK', [])
  #  write_fn('First Line\n')
  #  write_fn('Second One\n')
  #  self.assertEquals('First Line\nSecond One\n', self.start_response.body)

  '''
   Ensure that it's possible to change the status/headers values if the write callable
   was called yet
  '''
  def test_change_status_value(self):
    self.start_response('200 OK', [('Header', 'Value')])
    self.assertEquals('200 OK', self.start_response.status)
    self.assertEquals([('Header', 'Value')], self.start_response.headers)
    import sys
    self.start_response('500 Internal Server Error', [('More-Header', 'Other-Value')], sys.exc_info())
    self.assertEquals('500 Internal Server Error', self.start_response.status)
    self.assertEquals([('More-Header', 'Other-Value')], self.start_response.headers)

  '''
   start_response should re-raise the exception raise by the app
  '''
  def test_call_start_response_after_called_write(self):
    write_fn = self.start_response('200 OK', [])
    write_fn('Body\n') # Response sent to client
    try:
      raise Exception()
    except:
      import sys
      exec_info = sys.exc_info()
      self.assertRaises(exec_info[0], self.start_response, '500 Server Error', [], exec_info)

  def test_call_start_response_twice_without_exec_info(self):
    self.start_response('200 OK', [])
    self.assertRaises(StartResponseCalledTwice, self.start_response, '500 OK', [])


  def test_should_close(self):
    message = Message('1 2 / 22:{"VERSION":"HTTP/1.0"},0:,')
    start_response = StartResponse(message, self.wsgid)
    self.assertEquals(start_response.should_close, True)

    headers = '{"VERSION":"HTTP/1.0", "connection":"close"}'
    message = Message('1 2 / %d:%s,0:,' %(len(headers),headers))
    start_response = StartResponse(message, self.wsgid)
    self.assertEquals(start_response.should_close, True)

    headers = '{"VERSION":"HTTP/1.0", "connection":"keep-alive"}'
    message = Message('1 2 / %d:%s,0:,' %(len(headers),headers))
    start_response = StartResponse(message, self.wsgid)
    self.assertEquals(start_response.should_close, False)

    message = Message('1 2 / 22:{"VERSION":"HTTP/1.1"},0:,')
    start_response = StartResponse(message, self.wsgid)
    self.assertEquals(start_response.should_close, False)

    headers = '{"VERSION":"HTTP/1.1", "connection":"close"}'
    message = Message('1 2 / %d:%s,0:,' %(len(headers),headers))
    start_response = StartResponse(message, self.wsgid)
    self.assertEquals(start_response.should_close, True)

    headers = '{"VERSION":"HTTP/1.1", "connection":"keep-alive"}'
    message = Message('1 2 / %d:%s,0:,' %(len(headers),headers))
    start_response = StartResponse(message, self.wsgid)
    self.assertEquals(start_response.should_close, False)

  def test_finalize_headers(self):
    headers = []
    message = Message('1 2 / 22:{"VERSION":"HTTP/1.0"},0:,')
    start_response = StartResponse(message, self.wsgid)
    write_fn = start_response("200 OK", headers)        
    start_response._finalize_headers()
    headers = start_response.headers[:]
    expected_headers = [('X-Wsgid', __version__), ('Date', ANY)]
    self.assertEquals(headers, expected_headers)
    self.assertEquals(start_response.chunked, False)
    self.assertEquals(start_response.should_close, True)

    headers = []
    headers_str = '{"VERSION":"HTTP/1.0","te":"chunked"}'
    message = Message('1 2 / %d:%s,0:,' %(len(headers_str),headers_str))
    start_response = StartResponse(message, self.wsgid)
    write_fn = start_response("200 OK", headers)        
    start_response._finalize_headers()
    headers = start_response.headers[:]
    expected_headers = [('X-Wsgid', __version__),('Date', ANY), ('Transfer-Encoding','chunked')]
    self.assertEquals(headers, expected_headers)
    self.assertEquals(start_response.chunked, True)
    self.assertEquals(start_response.should_close, True)

    headers = []
    message = Message('1 2 / 22:{"VERSION":"HTTP/1.1"},0:,')
    start_response = StartResponse(message, self.wsgid)
    write_fn = start_response("200 OK", headers)        
    start_response._finalize_headers()
    headers = start_response.headers[:]
    expected_headers = [('X-Wsgid', __version__),('Date', ANY), ('Transfer-Encoding','chunked')]
    self.assertEquals(headers, expected_headers)
    self.assertEquals(start_response.chunked, True)
    self.assertEquals(start_response.should_close, False)

    headers = [('content-length','42')]
    message = Message('1 2 / 22:{"VERSION":"HTTP/1.1"},0:,')
    start_response = StartResponse(message, self.wsgid)
    write_fn = start_response("200 OK", headers)        
    start_response._finalize_headers()
    headers = start_response.headers[:]
    expected_headers = [('content-length','42'), ('X-Wsgid', __version__), ('Date', ANY)]
    self.assertEquals(headers, expected_headers)
    self.assertEquals(start_response.chunked, False)
    self.assertEquals(start_response.should_close, False)
    
    


########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
from django.core.management import execute_manager
import imp
try:
    imp.find_module('settings') # Assumed to be in the same directory.
except ImportError:
    import sys
    sys.stderr.write("Error: Can't find the file 'settings.py' in the directory containing %r. It appears you've customized things.\nYou'll have to run django-admin.py, passing it your settings module.\n" % __file__)
    sys.exit(1)

import settings

if __name__ == "__main__":
    execute_manager(settings)

########NEW FILE########
__FILENAME__ = settings
# Django settings for djangonoinit project.

DEBUG = True
TEMPLATE_DEBUG = DEBUG

ADMINS = (
    # ('Your Name', 'your_email@example.com'),
)

MANAGERS = ADMINS

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.', # Add 'postgresql_psycopg2', 'postgresql', 'mysql', 'sqlite3' or 'oracle'.
        'NAME': '',                      # Or path to database file if using sqlite3.
        'USER': '',                      # Not used with sqlite3.
        'PASSWORD': '',                  # Not used with sqlite3.
        'HOST': '',                      # Set to empty string for localhost. Not used with sqlite3.
        'PORT': '',                      # Set to empty string for default. Not used with sqlite3.
    }
}

# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# On Unix systems, a value of None will cause Django to use the same
# timezone as the operating system.
# If running in a Windows environment this must be set to the same as your
# system time zone.
TIME_ZONE = 'America/Chicago'

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'en-us'

SITE_ID = 1

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

# If you set this to False, Django will not format dates, numbers and
# calendars according to the current locale
USE_L10N = True

# Absolute filesystem path to the directory that will hold user-uploaded files.
# Example: "/home/media/media.lawrence.com/media/"
MEDIA_ROOT = ''

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash.
# Examples: "http://media.lawrence.com/media/", "http://example.com/media/"
MEDIA_URL = ''

# Absolute path to the directory static files should be collected to.
# Don't put anything in this directory yourself; store your static files
# in apps' "static/" subdirectories and in STATICFILES_DIRS.
# Example: "/home/media/media.lawrence.com/static/"
STATIC_ROOT = ''

# URL prefix for static files.
# Example: "http://media.lawrence.com/static/"
STATIC_URL = '/static/'

# URL prefix for admin static files -- CSS, JavaScript and images.
# Make sure to use a trailing slash.
# Examples: "http://foo.com/static/admin/", "/static/admin/".
ADMIN_MEDIA_PREFIX = '/static/admin/'

# Additional locations of static files
STATICFILES_DIRS = (
    # Put strings here, like "/home/html/static" or "C:/www/django/static".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

# List of finder classes that know how to find static files in
# various locations.
STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
#    'django.contrib.staticfiles.finders.DefaultStorageFinder',
)

# Make this unique, and don't share it with anybody.
SECRET_KEY = '7g@6jli10&ufjgz(cd8y-6jr3fm1u12ls0yl^ao=k!k9bewu35'

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
#     'django.template.loaders.eggs.Loader',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
)

ROOT_URLCONF = 'djangonoinit.urls'

TEMPLATE_DIRS = (
    # Put strings here, like "/home/html/django_templates" or "C:/www/django/templates".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    # Uncomment the next line to enable the admin:
    # 'django.contrib.admin',
    # Uncomment the next line to enable admin documentation:
    # 'django.contrib.admindocs',
)

# A sample logging configuration. The only tangible logging
# performed by this configuration is to send an email to
# the site admins on every HTTP 500 error.
# See http://docs.djangoproject.com/en/dev/topics/logging for
# more details on how to customize your logging configuration.
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'mail_admins': {
            'level': 'ERROR',
            'class': 'django.utils.log.AdminEmailHandler'
        }
    },
    'loggers': {
        'django.request': {
            'handlers': ['mail_admins'],
            'level': 'ERROR',
            'propagate': True,
        },
    }
}

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import patterns, include, url

# Uncomment the next two lines to enable the admin:
# from django.contrib import admin
# admin.autodiscover()

urlpatterns = patterns('',
    # Examples:
    # url(r'^$', 'djangonoinit.views.home', name='home'),
    # url(r'^djangonoinit/', include('djangonoinit.foo.urls')),

    # Uncomment the admin/doc line below to enable admin documentation:
    # url(r'^admin/doc/', include('django.contrib.admindocs.urls')),

    # Uncomment the next line to enable the admin:
    # url(r'^admin/', include(admin.site.urls)),
)

########NEW FILE########
__FILENAME__ = wsgidapp_test
#encoding: utf-8
import unittest
from wsgid.test import fullpath, FakeOptions
from wsgid.commands import CommandInit
from wsgid.core import WsgidApp
import os

from mock import patch

FIXTURE = os.path.join(fullpath(__file__), 'fixtures')

class WsgidAppTest(unittest.TestCase):

    @patch('sys.stderr')
    def setUp(self, *args):
        self.init = CommandInit()
        self.empty_apppath = os.path.join(FIXTURE, 'empty-app')
        self.init.run(FakeOptions(app_path=self.empty_apppath))
        self.empty_wsgidapp = WsgidApp(self.empty_apppath)

    def test_check_valid_wsgid_app_folder(self):
        self.assertTrue(self.empty_wsgidapp.is_valid(), "Did not recognize as a valid wsgid app folder")

    def test_return_empty_master_pids(self):
        self.assertEquals([], self.empty_wsgidapp.master_pids())

    def test_return_empty_worker_pids(self):
        self.assertEquals([], self.empty_wsgidapp.worker_pids())

    def test_return_plugins_dir(self):
        self.assertEquals(os.path.join(self.empty_apppath, 'plugins'), self.empty_wsgidapp.pluginsdir)

    @patch('sys.stderr')
    def test_return_pids(self, *args):
        app = os.path.join(FIXTURE, 'app-with-pids')
        self.init.run(FakeOptions(app_path=app))
        open(os.path.join(app, 'pid/master/3345.pid'), 'w')
        open(os.path.join(app, 'pid/master/2938.pid'), 'w')
        open(os.path.join(app, 'pid/master/no-pid.pid'), 'w')

        open(os.path.join(app, 'pid/worker/8756.pid'), 'w')
        open(os.path.join(app, 'pid/worker/3948.pid'), 'w')
        open(os.path.join(app, 'pid/worker/invalid.pid'), 'w')

        wsgidapp = WsgidApp(app)
        # Invalid pidfiles must be ignored
        self.assertEquals([2938, 3345], wsgidapp.master_pids())
        self.assertEquals([3948, 8756], wsgidapp.worker_pids())



########NEW FILE########
__FILENAME__ = wsgid_test
#encoding: utf-8


from collections import namedtuple
import unittest

from wsgid.core import Wsgid, Plugin
from wsgid.core.parser import parse_options
from wsgid.interfaces.filters import IPreRequestFilter, IPostRequestFilter
from wsgid.core.message import Message
import wsgid.conf as conf
from wsgid import __version__
import sys
import simplejson
import plugnplay

from mock import patch, Mock, call, ANY

class WsgidTest(unittest.TestCase):

  def setUp(self):
    self.wsgid = Wsgid()
    self.wsgid.send_sock = Mock()
    self.sample_headers = {
          'METHOD': 'GET',
          'VERSION': 'HTTP/1.1',
          'PATTERN': '/root',
          'URI': '/more/path/',
          'PATH': '/more/path',
          'QUERY': 'a=1&b=4&d=4',
          'host': 'localhost',
          'content-length': '42',
          'content-type': 'text/plain',
          'x-forwarded-for': '127.0.0.1'
        }
    sys.argv[1:] = []
    parse_options()

  def tearDown(self):
    self.sample_headers = {}
    conf.settings = None



  '''
   Creates the SCRIPT_NAME header from the mongrel2 PATTERN header.
   SCRIPT_NAME should be the PATTERN without any regex parts.
  '''
  def test_script_name_header_simple_path(self):
    self.sample_headers['PATTERN'] = "/py"
    environ = self.wsgid._create_wsgi_environ(self.sample_headers)
    self.assertEquals("/py", environ['SCRIPT_NAME'])

  def test_environ_script_name_header_more_comples_header(self):
    self.sample_headers['PATTERN'] = '/some/more/path/'
    environ = self.wsgid._create_wsgi_environ(self.sample_headers)
    self.assertEquals("/some/more/path", environ['SCRIPT_NAME'])

  def test_environ_script_name_header_root(self):
    self.sample_headers['PATTERN'] = '/'
    environ = self.wsgid._create_wsgi_environ(self.sample_headers)
    self.assertEquals("", environ['SCRIPT_NAME'])


  '''
   PATH_INFO comes from (URI - SCRIPT_NAME) or (PATH - SCRIPT_NAME)
  '''
  def test_environ_path_info(self):

    self.sample_headers['PATTERN'] = '/py'
    self.sample_headers['PATH'] = '/py/some/py/path'
    environ = self.wsgid._create_wsgi_environ(self.sample_headers)
    self.assertEquals("/some/py/path", environ['PATH_INFO'])

  def test_environ_path_info_app_root(self):
    self.sample_headers['PATTERN'] = '/py'
    self.sample_headers['PATH'] = '/py'
    environ = self.wsgid._create_wsgi_environ(self.sample_headers)
    self.assertEquals("", environ['PATH_INFO'])


  def test_environ_unquoted_path_info(self):
    self.sample_headers['PATTERN'] = '/py/'
    self.sample_headers['PATH'] = '/py/so%20me/special%3f/user%40path'
    environ = self.wsgid._create_wsgi_environ(self.sample_headers)
    self.assertEquals('/so me/special?/user@path', environ['PATH_INFO'])

  '''
   Generates de REQUEST_METHOD variable
  '''
  def test_environ_request_method(self):
    environ = self.wsgid._create_wsgi_environ(self.sample_headers)
    self.assertTrue(environ.has_key('REQUEST_METHOD'))
    self.assertEquals('GET', environ['REQUEST_METHOD'])


  def test_environ_query_string(self):
    environ = self.wsgid._create_wsgi_environ(self.sample_headers)
    self.assertEquals("a=1&b=4&d=4", environ['QUERY_STRING'])

  def test_environ_no_query_string(self):
    #Not always we have a QUERY_STRING
    del self.sample_headers['QUERY']
    environ = self.wsgid._create_wsgi_environ(self.sample_headers)
    self.assertEquals("", environ['QUERY_STRING'])


  def test_environ_server_port(self):
    self.sample_headers['host'] = 'localhost:443'
    environ = self.wsgid._create_wsgi_environ(self.sample_headers)
    self.assertEquals('443', environ['SERVER_PORT'])

  def test_environ_server_port_default_port(self):
    self.sample_headers['host'] = 'localhost'
    environ = self.wsgid._create_wsgi_environ(self.sample_headers)
    self.assertEquals('80', environ['SERVER_PORT'])

  def test_environ_server_name(self):
    self.sample_headers['host'] = 'localhost:8080'
    environ = self.wsgid._create_wsgi_environ(self.sample_headers)
    self.assertEquals('localhost', environ['SERVER_NAME'])

  def test_environ_server_name_default_port(self):
    self.sample_headers['host'] = 'someserver'
    environ = self.wsgid._create_wsgi_environ(self.sample_headers)
    self.assertEquals('someserver', environ['SERVER_NAME'])

  '''
   HTTP_HOST must inclue the port, if present.
  '''
  def test_environ_http_host(self):
    self.sample_headers['host'] = 'localhost:8080'
    environ = self.wsgid._create_wsgi_environ(self.sample_headers)
    self.assertEquals('localhost:8080', environ['HTTP_HOST'])

  def test_environ_content_type(self):
    self.sample_headers['content-type'] = 'application/xml'
    environ = self.wsgid._create_wsgi_environ(self.sample_headers)
    self.assertEquals('application/xml', environ['CONTENT_TYPE'])

  def test_environ_no_content_type(self):
    del self.sample_headers['content-type']
    environ = self.wsgid._create_wsgi_environ(self.sample_headers)
    self.assertEquals('', environ['CONTENT_TYPE'])

  def test_environ_content_length(self):
    self.sample_headers['content-length'] = '42'
    environ = self.wsgid._create_wsgi_environ(self.sample_headers)
    self.assertEquals('42', environ['CONTENT_LENGTH'])

  def test_environ_no_content_length(self):
    del self.sample_headers['content-length']
    environ = self.wsgid._create_wsgi_environ(self.sample_headers)
    self.assertEquals('', environ['CONTENT_LENGTH'])

  '''
   Comes from mongrel2 VERSION header
  '''
  def test_environ_server_protocol(self):
    environ = self.wsgid._create_wsgi_environ(self.sample_headers)
    self.assertTrue(environ.has_key('SERVER_PROTOCOL'))
    self.assertEquals('HTTP/1.1', environ['SERVER_PROTOCOL'])


  def test_eviron_remote_addr(self):
    environ = self.wsgid._create_wsgi_environ(self.sample_headers)
    self.assertEquals('127.0.0.1', environ['REMOTE_ADDR'])


  '''
   Non Standard headers (X-) are passed untouched
  '''
  def test_environ_non_standart_headers(self):
    self.sample_headers['X-Some-Header'] = 'some-value'
    self.sample_headers['x-other-header'] = 'other-value'

    environ = self.wsgid._create_wsgi_environ(self.sample_headers)
    self.assertEquals('some-value', environ['HTTP_X_SOME_HEADER'])
    self.assertEquals('other-value', environ['HTTP_X_OTHER_HEADER'])

  def test_environ_http_host_header(self):
    environ = self.wsgid._create_wsgi_environ(self.sample_headers)
    self.assertEquals('localhost', environ['HTTP_HOST'])

  '''
   All headers (but HTTP common headers and X- headers) must be HTTP_ prefixed
  '''
  def test_environ_other_headers(self):
    self.sample_headers['my_header'] = 'some-value'
    self.sample_headers['OTHER_HEADER'] = 'other-value'
    self.sample_headers['X-Some-Header'] = 'x-header'
    self.sample_headers['Accept'] = '*/*'
    self.sample_headers['Referer'] = 'http://www.someserver.com'

    environ = self.wsgid._create_wsgi_environ(self.sample_headers)
    self.assertEquals('some-value', environ['HTTP_MY_HEADER'])
    self.assertEquals('other-value', environ['HTTP_OTHER_HEADER'])
    self.assertEquals('x-header', environ['HTTP_X_SOME_HEADER'])
    self.assertEquals('*/*', environ['HTTP_ACCEPT'])
    self.assertEquals('http://www.someserver.com', environ['HTTP_REFERER'])


  '''
   Test a complete request, with all typed of headers.
  '''
  def test_eviron_complete_request(self):
    request = {
          'METHOD': 'GET',
          'VERSION': 'HTTP/1.1',
          'PATTERN': '/py',
          'URI': '/py/some/path',
          'PATH': '/py/some/path',
          'QUERY': 'a=1&b=4&d=4',
          'host': 'localhost',
          'Accept': '*/*',
          'CUSTOM_HEADER': 'value',
          'User-Agent': 'some user agent/1.0',
          'content-length': '42',
          'content-type': 'text/plain',
          'x-forwarded-for': '127.0.0.1'
        }

    environ = self.wsgid._create_wsgi_environ(request)
    self.assertEquals(24, len(environ))
    self.assertEquals('GET', environ['REQUEST_METHOD'])
    self.assertEquals('HTTP/1.1', environ['SERVER_PROTOCOL'])
    self.assertEquals('/py', environ['SCRIPT_NAME'])
    self.assertEquals('a=1&b=4&d=4', environ['QUERY_STRING'])
    self.assertEquals('/some/path', environ['PATH_INFO'])
    self.assertEquals('localhost', environ['SERVER_NAME'])
    self.assertEquals('80', environ['SERVER_PORT'])
    self.assertEquals('value', environ['HTTP_CUSTOM_HEADER'])
    self.assertEquals('*/*', environ['HTTP_ACCEPT'])
    self.assertEquals('some user agent/1.0', environ['HTTP_USER_AGENT'])
    self.assertEquals('42', environ['CONTENT_LENGTH'])
    self.assertEquals('42', environ['content-length'])
    self.assertEquals('text/plain', environ['CONTENT_TYPE'])
    self.assertEquals('text/plain', environ['content-type'])
    self.assertEquals('localhost', environ['HTTP_HOST'])
    self.assertEquals('127.0.0.1', environ['REMOTE_ADDR'])

  '''
   Some values are fixed:
    * wsgi.multithread = False
    * wsgi.multiprocess = True
    * wsgi.run_once = True
    * wsgi.version = (1,0)
  '''
  def test_environ_fixed_values(self):
    environ = self.wsgid._create_wsgi_environ(self.sample_headers)
    self.assertEquals(False, environ['wsgi.multithread'])
    self.assertEquals(True, environ['wsgi.multiprocess'])
    self.assertEquals(True, environ['wsgi.run_once'])
    self.assertEquals((1,0), environ['wsgi.version'])
    # url_scheme defaults to http
    self.assertEquals("http", environ['wsgi.url_scheme'])
    self.assertEquals(sys.stderr, environ['wsgi.errors'])

  def test_url_scheme_http(self):
    self.sample_headers['URL_SCHEME'] = 'http'
    environ = self.wsgid._create_wsgi_environ(self.sample_headers)
    self.assertEquals('http', environ['wsgi.url_scheme'])

  def test_url_scheme_https(self):
    self.sample_headers['URL_SCHEME'] = 'https'
    environ = self.wsgid._create_wsgi_environ(self.sample_headers)
    self.assertEquals('https', environ['wsgi.url_scheme'])

  def test_join_m2_chroot_to_async_upload_path(self):
      # The value in x-mongrel2-upload-{start,done} should be prepended with the
      # value of --m2-chroot, passed on the command line
      with patch('zmq.Context'):
          def _serve_request(wsgid, m2message, expected_final_path):
            with patch.object(wsgid, '_create_wsgi_environ'):
                wsgid._create_wsgi_environ.return_value = {}
                with patch("__builtin__.open") as mock_open:
                    with patch('os.unlink'):
                        wsgid._call_wsgi_app(message)
                        self.assertEquals(1, mock_open.call_count)
                        mock_open.assert_called_with(expected_final_path)

          self._reparse_options('--mongrel2-chroot=/var/mongrel2')
          wsgid = Wsgid(app = Mock(return_value=['body response']))
          wsgid.send_sock = Mock()
          message = self._create_fake_m2message('/uploads/m2.84Yet4')
          _serve_request(wsgid, message, '/var/mongrel2/uploads/m2.84Yet4')
          self._reparse_options()
          _serve_request(wsgid, message, '/uploads/m2.84Yet4')


  def test_remove_async_file_after_request_finishes_ok(self):
      # Since mongrel2 does not remove the originial temp file, wsgid
      # must remove it after the request was successfully (or not) handled.
      with patch('zmq.Context'):
          with patch('os.unlink') as mock_unlink:
            def _serve_request(wsgid, m2message):
                with patch.object(wsgid, '_create_wsgi_environ'):
                    wsgid._create_wsgi_environ.return_value = {}
                    with patch("__builtin__.open"):
                        wsgid._call_wsgi_app(message,)

            wsgid = Wsgid(app = Mock(return_value=['body response']))
            wsgid.send_sock = Mock()
            message = self._create_fake_m2message('/uploads/m2.84Yet4')
            _serve_request(wsgid, message)
            mock_unlink.assert_called_with('/uploads/m2.84Yet4')


  def test_remove_async_file_after_failed_request(self):
      # Even if the request failed, wsgid must remove the temporary file.
       with patch('zmq.Context'):
          with patch('os.unlink') as mock_unlink:
            def _serve_request(wsgid, m2message):
                with patch.object(wsgid, '_create_wsgi_environ'):
                    wsgid._create_wsgi_environ.return_value = {}
                    with patch("__builtin__.open"):
                        wsgid._call_wsgi_app(message)

            wsgid = Wsgid(app = Mock(side_effect = Exception("Failed")))
            wsgid.send_sock = Mock()
            wsgid.log = Mock()
            message = self._create_fake_m2message('/uploads/m2.84Yet4')
            _serve_request(wsgid, message)
            mock_unlink.assert_called_with('/uploads/m2.84Yet4')

  def test_protect_against_exception_on_file_removal(self):
        with patch('zmq.Context'):
          with patch('os.unlink') as mock_unlink:
            mock_unlink.side_effect = OSError("File does not exist")
            def _serve_request(wsgid, m2message):
                with patch.object(wsgid, '_create_wsgi_environ'):
                    wsgid._create_wsgi_environ.return_value = {}
                    with patch("__builtin__.open"):
                        wsgid._call_wsgi_app(message)

            wsgid = Wsgid(app = Mock(return_value = ['body response']))
            wsgid.send_sock = Mock()
            wsgid.log = Mock()
            message = self._create_fake_m2message('/uploads/m2.84Yet4')
            _serve_request(wsgid, message)
            self.assertEquals(1, wsgid.log.exception.call_count)

  def test_do_not_try_to_remove_if_not_upload_request(self):
         with patch('zmq.Context'):
          with patch('os.unlink') as mock_unlink:
            def _serve_request(wsgid, m2message):
                with patch.object(wsgid, '_create_wsgi_environ'):
                    wsgid._create_wsgi_environ.return_value = {}
                    with patch("__builtin__.open"):
                        wsgid._call_wsgi_app(message)

            wsgid = Wsgid(app = Mock(return_value = ['body response']))
            wsgid.send_sock = Mock()
            wsgid.log = Mock()
            message = Mock()
            message.headers = {'VERSION':'HTTP/1.1'} #It's not an upload message
            message.client_id = 'uuid'
            message.server_id = '1'
            message.is_upload_done.return_value = False
            _serve_request(wsgid, message)
            self.assertEquals(0, mock_unlink.call_count)

  def _reparse_options(self, *args):
      sys.argv[1:] = args
      conf.settings = None
      parse_options()

  def _create_fake_m2message(self, async_upload_path):
        message = Mock()
        message.headers = {'x-mongrel2-upload-start': async_upload_path,
                            'x-mongrel2-upload-done': async_upload_path,
                            'VERSION' : 'HTTP/1.0'}
        message.async_upload_path = async_upload_path
        message.server_id = 'uuid'
        message.client_id = '42'
        return message

class WsgidReplyTest(unittest.TestCase):

  def setUp(self):
    self.sample_uuid = 'bb3ce668-4528-11e0-94e3-001fe149503a'
    self.sample_conn_id = '42'
    self.message = Message('%s %s / 22:{"VERSION":"HTTP/1.0"},0:,' % (self.sample_uuid, self.sample_conn_id))


  def test_reply(self):
    wsgid = Wsgid()
    socket = Mock()
    socket.send.return_value = None
    wsgid.send_sock = socket


    headers = [('Header', 'Value'), ('X-Other-Header', 'Other-Value')]
    body = "Hello World\n"
    wsgid._reply(self.message, '200 OK', headers=headers, body=body)
    m2msg = socket.send.call_args[0][0]
    resp = "%s 2:42, HTTP/1.1 200 OK\r\n\
Header: Value\r\n\
X-Other-Header: Other-Value\r\n\
\r\n\
Hello World\n" % (self.sample_uuid, )
    self.assertEquals(resp, m2msg)


class WsgidContentLengthTest(unittest.TestCase):

  def setUp(self):
    self.sample_uuid = 'bb3ce668-4528-11e0-94e3-001fe149503a'
    self.sample_conn_id = '42'
    self.message = Message('%s %s / 22:{"VERSION":"HTTP/1.0"},0:,' % (self.sample_uuid, self.sample_conn_id))

    settings_obj = namedtuple('object', 'mongrel2_chroot')
    conf.settings = settings_obj(mongrel2_chroot='/var/mongrel2')

  def test_content_length(self):
    def app(env, start):
        start("200 OK", [])
        return ["Hello"]

    wsgid = Wsgid(app)
    socket = Mock()
    socket.send.return_value = None
    wsgid.send_sock = socket
    with patch.object(wsgid, "_reply") as reply, \
          patch.object(wsgid, "_create_wsgi_environ") :
        wsgid._call_wsgi_app(self.message)
        headers = reply.call_args_list[0][0][2]
        self.assertEquals(headers, [('Content-Length', '5'), ('X-Wsgid', __version__),  ('Date', ANY) ])
  def test_no_cotent_length(self):
    def app(env, start):
        start("200 OK", [])
        return ["Hello", "There"]
    wsgid = Wsgid(app)
    socket = Mock()
    socket.send.return_value = None
    wsgid.send_sock = socket
    with patch.object(wsgid, "_reply") as reply, \
          patch.object(wsgid, "_create_wsgi_environ") :
        wsgid._call_wsgi_app(self.message)
        headers = reply.call_args_list[0][0][2]

        self.assertEquals(headers, [('X-Wsgid', __version__), ('Date', ANY)])


class AlmostAlwaysTrue(object):

    def __init__(self, total_iterations=1):
        self.total_iterations = total_iterations
        self.current_iteration = 0

    def __call__(self):
        if self.current_iteration < self.total_iterations:
            self.current_iteration += 1
            return bool(1)
        return bool(0)


class WsgidRequestFiltersTest(unittest.TestCase):

    def setUp(self):
        self.sample_headers = {
            'METHOD': 'GET',
            'VERSION': 'HTTP/1.0', #prevent chunking
            'PATTERN': '/root',
            'URI': '/more/path/',
            'PATH': '/more/path',
            'QUERY': 'a=1&b=4&d=4',
            'host': 'localhost',
            'content-length': '42',
            'content-type': 'text/plain',
            'x-forwarded-for': '127.0.0.1'
            }
        body = "Some body"
        headers_str = simplejson.dumps(self.sample_headers)
        self.raw_msg = "SID CID /path {len}:{h}:{lenb}:{b}".format(len=len(headers_str), h=headers_str, lenb=len(body), b=body)
        plugnplay.man.iface_implementors = {}
        conf.settings = namedtuple('object', 'mongrel2_chroot')
        self.start_response_mock = namedtuple('object', ['headers_sent', 'status', 'headers'], verbose=False)

    '''
     This also tests if the modified environ is passed to the WSGI app
    '''
    def test_call_pre_request_filter(self):
        class SimpleFilter(Plugin):
            implements = [IPreRequestFilter, ]

            def process(self, messaage, environ):
                environ['X-Added-Header'] = 'Value'

        sock_mock = Mock()
        sock_mock.recv.return_value = self.raw_msg

        app_mock = Mock()
        wsgid = Wsgid(app=app_mock)
        with patch.object(wsgid, '_create_wsgi_environ') as environ_mock, \
                patch.object(wsgid, '_setup_zmq_endpoints', Mock(return_value=(sock_mock, sock_mock))), \
                patch.object(wsgid, '_should_serve', AlmostAlwaysTrue(1)):

            environ_mock.return_value = self.sample_headers.copy()
            wsgid.serve()
            expected_environ = self.sample_headers
            expected_environ.update({'X-Added-Header': 'Value'})
            assert [call(expected_environ, ANY)] == app_mock.call_args_list

    def test_filter_raises_exception_but_app_still_called(self):
        class SimpleExceptionFilter(Plugin):
            implements = [IPreRequestFilter, ]

            def process(self, messaage, environ):
                raise Exception()

        sock_mock = Mock()
        sock_mock.recv.return_value = self.raw_msg

        app_mock = Mock()
        wsgid = Wsgid(app=app_mock)
        with patch.object(wsgid, '_create_wsgi_environ') as environ_mock, \
                patch.object(wsgid, '_setup_zmq_endpoints', Mock(return_value=(sock_mock, sock_mock))), \
                patch.object(wsgid, '_should_serve', AlmostAlwaysTrue(1)):

            environ_mock.return_value = self.sample_headers.copy()
            wsgid.serve()
            assert 1 == app_mock.call_count
            assert [call(self.sample_headers, ANY)] == app_mock.call_args_list

    def test_call_other_filters_if_one_raises_exception(self):
        class SimpleExceptionFilter(Plugin):
            implements = [IPreRequestFilter, ]

            def process(self, messaage, environ):
                raise Exception()

        class SimpleFilter(Plugin):
            implements = [IPreRequestFilter, ]

            def process(self, messaage, environ):
                environ['X-New'] = 'Other Value'

        sock_mock = Mock()
        sock_mock.recv.return_value = self.raw_msg

        app_mock = Mock()
        wsgid = Wsgid(app=app_mock)
        with patch.object(wsgid, '_create_wsgi_environ') as environ_mock, \
                patch.object(wsgid, '_setup_zmq_endpoints', Mock(return_value=(sock_mock, sock_mock))), \
                patch.object(wsgid, '_should_serve', AlmostAlwaysTrue(1)):

            environ_mock.return_value = self.sample_headers.copy()
            wsgid.serve()
            assert 1 == app_mock.call_count
            expected_environ = self.sample_headers
            expected_environ.update({'X-New': 'Other Value'})
            assert [call(expected_environ, ANY)] == app_mock.call_args_list

    def test_log_filter_exception(self):
        exception = Exception()
        class SimpleExceptionFilter(Plugin):
            implements = [IPreRequestFilter, ]

            def process(self, messaage, environ):
                raise exception

        sock_mock = Mock()
        sock_mock.recv.return_value = self.raw_msg

        app_mock = Mock()
        wsgid = Wsgid(app=app_mock)
        with patch.object(wsgid, '_create_wsgi_environ') as environ_mock, \
                patch.object(wsgid, '_setup_zmq_endpoints', Mock(return_value=(sock_mock, sock_mock))), \
                patch.object(wsgid, '_should_serve', AlmostAlwaysTrue(1)), \
                patch('wsgid.core.log') as mock_log:

            environ_mock.return_value = self.sample_headers.copy()
            wsgid.serve()
            assert [call(exception)] == mock_log.exception.call_args_list

    def test_pass_wsgi_environ_through_pre_request_filters(self):
        class AFilter(Plugin):
            implements = [IPreRequestFilter, ]

            def process(self, messaage, environ):
                environ['X-A'] = 'Header A'

        class BFilter(Plugin):
            implements = [IPreRequestFilter, ]

            def process(self, message, environ):
                environ['X-B'] = 'Header B'

        sock_mock = Mock()
        sock_mock.recv.return_value = self.raw_msg

        app_mock = Mock()
        wsgid = Wsgid(app=app_mock)
        with patch.object(wsgid, '_create_wsgi_environ') as environ_mock, \
                patch.object(wsgid, '_setup_zmq_endpoints', Mock(return_value=(sock_mock, sock_mock))), \
                patch.object(wsgid, '_should_serve', AlmostAlwaysTrue(1)):

            environ_mock.return_value = self.sample_headers.copy()
            wsgid.serve()
            assert 1 == app_mock.call_count
            expected_environ = self.sample_headers
            expected_environ.update({'X-A': 'Header A', 'X-B': 'Header B'})
            assert [call(expected_environ, ANY)] == app_mock.call_args_list

    def test_call_post_request_filter(self):
        class PostRequestFilter(Plugin):
            implements = [IPostRequestFilter, ]

            def process(self, message, status, headers, write, finish):
                return ('200 OK from filter', headers + [('X-Post-Header', 'Value')], write, finish)

        sock_mock = Mock()
        sock_mock.recv.return_value = self.raw_msg

        app_mock = Mock()
        app_mock.return_value = ('Line1', 'Line2')  # Response body lines
        wsgid = Wsgid(app=app_mock)
        with patch.object(wsgid, '_create_wsgi_environ') as environ_mock, \
                patch.object(wsgid, '_setup_zmq_endpoints', Mock(return_value=(sock_mock, sock_mock))), \
                patch.object(wsgid, '_should_serve', AlmostAlwaysTrue(1)), \
                patch.object(wsgid, '_reply') as reply_mock:

            environ_mock.return_value = self.sample_headers.copy()
            wsgid.serve()
            assert 1 == app_mock.call_count
            headers =  [('X-Wsgid', __version__), ('Date',ANY), ('X-Post-Header', 'Value')]
            self.assertEqual( [call(ANY, '200 OK from filter', headers, 'Line1'),
                              call(ANY, None, None, 'Line2'), ANY],
                         reply_mock.call_args_list)

    def test_call_post_request_exception(self):

        filter_mock = Mock()
        plugnplay.man.iface_implementors[IPostRequestFilter] = [filter_mock]

        sock_mock = Mock()
        sock_mock.recv.return_value = self.raw_msg

        app_mock = Mock(side_effect=Exception())
        wsgid = Wsgid(app=app_mock)
        with patch.object(wsgid, '_create_wsgi_environ') as environ_mock, \
                patch.object(wsgid, '_setup_zmq_endpoints', Mock(return_value=(sock_mock, sock_mock))), \
                patch.object(wsgid, '_should_serve', AlmostAlwaysTrue(1)), \
                patch.object(wsgid, '_reply'):

            environ_mock.return_value = self.sample_headers.copy()
            wsgid.serve()
            assert 1 == filter_mock.exception.call_count

    def test_pass_app_response_through_post_request_filters(self):
        class APostRequestFilter(Plugin):
            implements = [IPostRequestFilter, ]

            def process(self, message, status, headers, write, finish):
                def new_finish():
                    return finish() + 'FA'
                return (status, headers, write, new_finish)

        class BPostRequestFilter(Plugin):
            implements = [IPostRequestFilter, ]

            def process(self, message, status, headers, write, finish):
                def new_finish():
                    return finish()  + 'FB'
                return (status, headers, write, new_finish)


        sock_mock = Mock()
        sock_mock.recv.return_value = self.raw_msg

        app_mock = Mock()
        app_mock.return_value = ('Line1', 'Line2')  # Response body lines
        wsgid = Wsgid(app=app_mock)
        with patch.object(wsgid, '_create_wsgi_environ') as environ_mock, \
                patch.object(wsgid, '_setup_zmq_endpoints', Mock(return_value=(sock_mock, sock_mock))), \
                patch.object(wsgid, '_should_serve', AlmostAlwaysTrue(1)), \
                patch.object(wsgid, '_reply') as reply_mock:

            environ_mock.return_value = self.sample_headers.copy()
            wsgid.serve()
            assert 1 == app_mock.call_count
            self.assertEquals( [call(ANY, '', [('X-Wsgid', __version__), ('Date', ANY)], 'Line1'),
                                call(ANY, None, None, 'Line2'),
                                call(ANY, None, None, 'FAFB'), ANY], reply_mock.call_args_list)

    def test_ensure_a_broken_post_request_filter_does_not_crash_a_sucessful_request(self):
        class APostRequestFilter(Plugin):
            implements = [IPostRequestFilter, ]

            def process(self, message, status, headers, write,finish):
                def new_finish():
                    return finish() + 'FA'
                return (status, headers,write,new_finish)

        class BPostRequestFilter(Plugin):
            implements = [IPostRequestFilter, ]

            def process(self, message, status, headers, write,finish):
                def new_finish():
                    return finish()  + 'FB'
                # Here we return a wrong tuple. wsgid must be able not to crash
                # the request because of this
                return (headers,write,new_finish)


        sock_mock = Mock()
        sock_mock.recv.return_value = self.raw_msg

        app_mock = Mock()
        app_mock.return_value = ('Line1', 'Line2')  # Response body lines
        wsgid = Wsgid(app=app_mock)
        with patch.object(wsgid, '_create_wsgi_environ') as environ_mock, \
                patch.object(wsgid, '_setup_zmq_endpoints', Mock(return_value=(sock_mock, sock_mock))), \
                patch.object(wsgid, '_should_serve', AlmostAlwaysTrue(1)), \
                patch.object(wsgid, '_reply') as reply_mock:

            environ_mock.return_value = self.sample_headers.copy()
            wsgid.serve()
            assert 1 == app_mock.call_count
            self.assertEqual( [call(ANY, '', [('X-Wsgid', __version__), ('Date', ANY)], 'Line1'),
                               call(ANY, None, None, 'Line2'),
                               call(ANY, None, None, 'FA'), ANY] , reply_mock.call_args_list)

########NEW FILE########
__FILENAME__ = config
from wsgid.core import Plugin, validate_input_params
from wsgid.core.command import ICommand
from wsgid.core.parser import CommandLineOption, BOOL
import os
import simplejson


class CommandConfig(Plugin):

    implements = [ICommand]

    def command_name(self):
        return 'config'

    def name_matches(self, cname):
        return "config" == cname

    def run(self, options, **kwargs):
        config_file = os.path.join(options.app_path, 'wsgid.json')
        f = self._open_config_file(config_file)
        s = f.read()
        cfg_values = {}
        if s:
            cfg_values = simplejson.loads(s)

        # Copy the values
        self._override_if_not_none('wsgi_app', cfg_values, options.wsgi_app)
        self._override_if_not_none('debug', cfg_values, options.debug)
        if options.workers > 1:
            self._override_if_not_none('workers', cfg_values, options.workers, convert_func=int)
        self._override_if_not_none('keep_alive', cfg_values, options.keep_alive)
        self._override_if_not_none('chroot', cfg_values, options.chroot)
        self._override_if_not_none('no_daemon', cfg_values, options.no_daemon)
        self._override_if_not_none('recv', cfg_values, options.recv)
        self._override_if_not_none('send', cfg_values, options.send)
        self._override_if_not_none('mongrel2_chroot', cfg_values, options.mongrel2_chroot)
        self._override_if_not_none('django', cfg_values, options.django)

        # Custom config command options
        if options.no_debug:
            cfg_values['debug'] = str((not options.no_debug))

        validate_input_params(send=cfg_values['send'], recv=cfg_values['recv'])
        # Rewrite the config file
        f.seek(0)
        f.truncate()
        simplejson.dump(cfg_values, f, indent="  ")
        f.close()

    def extra_options(self):
        return [CommandLineOption(name='no-debug', help='Turns off debug option', type=BOOL, default_value=None),
                CommandLineOption(name='no-keep-alive', help='Turns off Keep alive option', type=BOOL),
                CommandLineOption(name='no-chroot', help='Turns off Chroot option', type=BOOL)]

    def _open_config_file(self, path):
        if os.path.exists(path):
            return open(path, "r+")
        return open(path, "w+")

    def _override_if_not_none(self, opt_name, dest, value, convert_func=str):
        if value:
            dest[opt_name] = convert_func(value)

########NEW FILE########
__FILENAME__ = init


from wsgid.core import Plugin
from wsgid.core.command import ICommand
import os
import sys
from wsgid.core.parser import CommandLineOption, BOOL


class CommandInit(Plugin):

    implements = [ICommand]

    def command_name(self):
        return 'init'

    def name_matches(self, cname):
        return "init" == cname

    def run(self, options, **kwargs):
        sys.stderr.write("Initializing wsgid app folder in {0}...\n".format(options.app_path))
        needed_folders = ['pid', 'pid/master', 'pid/worker', 'app', 'logs', 'plugins']
        self._create_if_not_exist(options.app_path)

        for folder in needed_folders:
            self._create_if_not_exist(os.path.join(options.app_path, folder))

    def extra_options(self):
        return [CommandLineOption(name='no-init', help='Turns off debug option', type=BOOL)]

    def _create_if_not_exist(self, path):
        if not os.path.exists(path):
            os.mkdir(path)

########NEW FILE########
__FILENAME__ = manage

from wsgid.core import Plugin, log as logger, WsgidApp
from wsgid.core.command import ICommand
from wsgid.core.parser import INT, CommandLineOption
import os
import signal
import re


class CommandManage(Plugin):
    '''
    Includes both stop and restart commands
    '''
    REGEX_PIDFILE = re.compile("[0-9]+\.pid")

    SUPPORTED_COMMANDS = ['restart', 'stop']
    implements = [ICommand]

    def command_name(self):
        return ', '.join(self.SUPPORTED_COMMANDS)

    def name_matches(self, cname):
        return cname in self.SUPPORTED_COMMANDS

    def run(self, options, command_name=None):
        if command_name:
            method = getattr(self, "_{0}".format(command_name))
            method(options)

    def extra_options(self):
        return [CommandLineOption(name='send-signal',
                                  help='Choose a custom signal to send to master/workers processes. Default signal is SIGTERM.',
                                  type=INT,
                                  default_value=signal.SIGTERM)]

    def _stop(self, options):
        wsgidapp = WsgidApp(options.app_path)
        logger.info("Stopping master processes at {0}...".format(options.app_path))
        pids = wsgidapp.master_pids()
        self._kill_pids(pids, options.send_signal, 'master')

    def _restart(self, options):
        wsgidapp = WsgidApp(options.app_path)
        logger.info("Restarting worker processes at {0}...".format(options.app_path))
        pids = wsgidapp.worker_pids()
        self._kill_pids(pids, options.send_signal, 'worker')

    def _kill_pids(self, pids, signum, pidtype):
        for pidnumber in pids:
            logger.debug("Sending signal {sig} to {pidtype} pid={pid}".format(pid=pidnumber, sig=signum, pidtype=pidtype))
            self._sigkill(pidnumber, signum)

    def _sigkill(self, pid, signum):
        try:
            os.kill(pid, signum)
        except:
            logger.debug("Non existant pid {0}".format(pid))

########NEW FILE########
__FILENAME__ = status


from wsgid.core.command import ICommand
from wsgid.core import Plugin
from wsgid.core import WsgidApp
import sys
import os


class CommandStatus(Plugin):

    implements = [ICommand]

    def command_name(self):
        return 'status'

    def name_matches(self, name):
        return name == 'status'

    def run(self, options, **kwargs):
        app = WsgidApp(options.app_path)
        status = {True: 'Running', False: 'Stopped'}
        sys.stdout.write("Status: {status}\n".format(status=status[self._any_running(app.worker_pids())]))
        sys.stdout.write("Master pid(s): {pids}\n".format(pids=", ".join([str(p) for p in app.master_pids()])))
        sys.stdout.write("Worker pid(s): {pids}\n".format(pids=", ".join([self._prepare_pid(p) for p in app.worker_pids()])))

    def _any_running(self, pids):
        '''
        Return True if at least one of the passed pids is running
        '''
        return len(filter(self._pid_exists, pids)) > 0

    def _pid_exists(self, pid):
        '''
        True id the given pid is running, False otherwise
        '''
        try:
            os.kill(pid, 0)
            return True
        except:
            return False

    def _prepare_pid(self, pid):
        '''
        Prepare a "status string" for this pid
        '''
        if self._pid_exists(pid):
            return str(pid)
        else:
            return "{0}(dead)".format(pid)

    def extra_options(self):
        return []

########NEW FILE########
__FILENAME__ = conf


# this will be rewritten when command line options
# are first parsed
settings = None

########NEW FILE########
__FILENAME__ = cli
#encoding: utf-8

import sys
import logging
import os

from . import run_command, validate_input_params, log
import wsgid
from ..commands import *
import parser

import plugnplay
import daemon


class Cli(object):
    '''
    Command Line interface for wsgid
    '''

    # PID types we may create
    MASTER, WORKER = range(2)

    def __init__(self):
        self.log = log

    def run(self):
        if run_command():
            sys.exit(0)

        options = parser.parse_options()
        validate_input_params(app_path=options.app_path,
                              recv=options.recv, send=options.send)

        self.options = options  # Will be used by the signal handlers
        try:
            daemon_options = self._create_daemon_options(options)
            ctx = daemon.DaemonContext(**daemon_options)

            with ctx:
                # Now that we are chrooted (if desired) we should correct
                # the paths
                options.app_path = self._normalize_path(options)
                self._set_loggers(options)

                wsgidapp = WsgidApp(options.app_path)
                self.log.debug("Loading plugins from {pluginsdir}".format(pluginsdir=wsgidapp.pluginsdir))
                plugnplay.set_plugin_dirs(wsgidapp.pluginsdir)
                plugnplay.load_plugins(logger=self.log)

                self.log.debug("Using configs values {cfg}".format(cfg=options))
                self.log.debug("Dropping privileges to: uid={uid}, gid={gid}".format(uid=daemon_options['uid'], gid=daemon_options['gid']))
                self.log.info("Master process started")
                self.log.debug("Creating master pid file at {0}".format(self._return_pid_file_path(os.getpid(), self.MASTER)))
                self._write_pid(os.getpid(), self.MASTER)
                self._load_plugins(options)

                self.workers = []
                for worker in range(options.workers):
                    pid = self._create_worker(options)
                    self.workers.append(pid)
                #Now we can register the master process SIGTERM handler
                signal.signal(signal.SIGTERM, self._sigterm_handler)
                self._wait_workers()
        except Exception:
            import traceback
            exc = sys.exc_info()
            self.log.info("".join(traceback.format_exception(exc[0], exc[1], exc[2])))
            self._remove_pid(os.getpid(), self.MASTER)
            sys.exit(1)

    def _write_pid(self, pid, pid_type):
        # Create the base pid folder
        self._mkdir_if_not_exist(os.path.join(self.options.app_path, 'pid'))

        pid_folder = self._return_pid_folder(pid_type)
        self._mkdir_if_not_exist(pid_folder)

        pid_file_path = self._return_pid_file_path(pid, pid_type)
        pid_file = open(pid_file_path, 'w')
        self.log.debug("Creating pid file at {0}".format(pid_file_path))
        pid_file.write(str(pid))
        pid_file.close()

    def _return_pid_file_path(self, pid, pid_type):
        return os.path.join(self._return_pid_folder(pid_type), '{0}.pid'.format(pid))

    def _remove_pid(self, pid, pid_type):
        pid_file = self._return_pid_file_path(pid, pid_type)
        self.log.debug("Removing pid file at {0}".format(pid_file))
        if os.path.isfile(pid_file):
            os.unlink(pid_file)

    def _return_pid_folder(self, pid_type):

        pid_folders = {
            self.MASTER: os.path.join(self.options.app_path, 'pid/master'),
            self.WORKER: os.path.join(self.options.app_path, 'pid/worker')
        }
        return pid_folders[pid_type]

    def _mkdir_if_not_exist(self, path):
        if not os.path.exists(path):
            os.mkdir(path, 0700)

    def _sigterm_handler(self, sig, stack):
        '''
          This is the SIGTERM handler of the master process.
          This method kills any worker left when master process is killed
        '''
        self.log.debug("SIGTERM received, killing any pending worker")
        for p in self.workers:
            self.log.debug("Killing worker pid={pid}".format(pid=p))
            os.kill(p, signal.SIGTERM)
            self._remove_pid(p, self.WORKER)
        self.log.info("Exiting...")
        self._remove_pid(os.getpid(), self.MASTER)
        sys.exit(0)

    def _wait_workers(self):
        while True:
            try:
                dead_worker = os.wait()
                self.workers.remove(dead_worker[0])
                self.log.info("Worker finished, pid={pid} retval={retval}".format(pid=dead_worker[0], retval=dead_worker[1]))
                self._remove_pid(dead_worker[0], self.WORKER)

                if self.options.keep_alive:
                    new_worker = self._create_worker(self.options)
                    self.workers.append(new_worker)
                    self.log.debug("Current active workers={workers}".format(workers=self.workers))
                if not self.workers:
                    self.log.debug("No more workers to wait for and no keep alive requested, exiting...")
                    self._remove_pid(os.getpid(), self.MASTER)
                    sys.exit(0)
            except KeyboardInterrupt:
                for worker in self.workers:
                    self._remove_pid(worker, self.WORKER)
                self._remove_pid(os.getpid(), self.MASTER)
                return

    def _load_plugins(self, options):
        if options.loader_dir:
            plugnplay.set_plugin_dirs(*options.loader_dir)
            plugnplay.load_plugins()

    def _create_daemon_options(self, options):
        daemon = {'detach_process': not options.no_daemon}
        daemon.update({'stdin': sys.stdin,
                       'stdout': sys.stdout,
                       'stderr': sys.stderr})
        if options.no_daemon:
            # If we are not a daemon we must maintain the basic signal handlers
            daemon.update({'signal_map': {
                signal.SIGTTIN: signal.getsignal(signal.SIGTTIN),
                signal.SIGTTOU: signal.getsignal(signal.SIGTTOU),
                signal.SIGTSTP: signal.getsignal(signal.SIGTSTP),
                signal.SIGTERM: signal.getsignal(signal.SIGTERM)
            }})
        else:
            daemon.update({'signal_map':
                          {signal.SIGTERM: signal.getsignal(signal.SIGTERM)}
                          })

        daemon.update({'uid': os.getuid(), 'gid': os.getgid()})

        if options.app_path:
            full_path = options.app_path
            stat = os.stat(full_path)
            daemon.update({'uid': stat.st_uid,
                           'gid': stat.st_gid})

        if options.chroot:
            full_path = options.app_path
            stat = os.stat(full_path)
            daemon.update({'chroot_directory': full_path,
                           'uid': stat.st_uid,
                           'gid': stat.st_gid})
        return daemon

    def _normalize_path(self, options):
        if options.chroot:
            return '/'
        return options.app_path

    def _create_worker(self, options):
        '''
        Forks a new wsgid worker, return the pid of this worker
        '''
        pid = os.fork()
        if pid == 0:
            self.workers = []
            self.log = logging.getLogger('wsgid')
            signal.signal(signal.SIGTERM, signal.SIG_DFL)
            self._call_wsgid(options)

        self.log.info("New wsgid worker created pid={pid}".format(pid=pid))
        self._write_pid(pid, self.WORKER)
        return pid

    def _call_wsgid(self, options):
        from wsgid.core import Wsgid
        from ..loaders import load_app

        # Create the env vars
        if options.envs:
            for k, v in options.envs.iteritems():
                os.environ[k] = v

        # The app source-code is inside an "app" folder, so we join this part
        # here and pass it to the AppLoaders.
        wsgi_app = load_app(os.path.join(options.app_path, 'app'), options.wsgi_app)
        wsgid = Wsgid(wsgi_app, options.recv, options.send)
        wsgid.serve()

    def _set_loggers(self, options):
        level = logging.INFO if not options.debug else logging.DEBUG
        logger = log
        logger.setLevel(level)

        if options.chroot:
            log_path = os.path.join('/', 'logs/wsgid.log')

        if options.no_daemon and options.stdout:
            console = logging.StreamHandler()
        else:
            log_path = os.path.join(options.app_path or '/tmp', 'logs/wsgid.log')
            console = logging.FileHandler(log_path)

        console.setLevel(level)

        formatter = logging.Formatter("%(asctime)s - %(name)s [pid=%(process)d] - %(levelname)s - %(message)s")
        console.setFormatter(formatter)

        logger.addHandler(console)
        self.log = logger
        wsgid.core.log = logger

########NEW FILE########
__FILENAME__ = command
from plugnplay import Interface


class ICommand(Interface):

    def command_name(self):
        """
        Returns the command name. This name will be used to show aditional
        options when calling wsgid --help
        """
        pass

    def name_matches(self, command_name):
        """
        Returns True if this command implementor
        can run the command passed as {command_name} parameter
        Returns False otherwise
        """
        pass

    def run(self, options, command_name=None):
        """
        Officially runs the command and receive the same options that
        was passed on the command line

        The optional command_name parameter is useful when you have the same
        implementation for two different commands

        Retuns nothing
        """
        pass

    def extra_options(self):
        """
        Return a list of wsgid.options.parser.CommandLineOption instances
        """
        pass

########NEW FILE########
__FILENAME__ = message
#encoding: utf-8

import json


HEADER_UPLOAD_START = 'x-mongrel2-upload-start'
HEADER_UPLOAD_DONE = 'x-mongrel2-upload-done'


class Message(object):
    """
      Represents a mongrel2 raw message
      Here we have:
       * server_id: The ID of the server that sent us this message
       * client_id: The id of the client that must receive our response
       * path: The path that was requested
       * netstring: More raw data. Here is the headers and the request body
       * headers: Mongrel headers already parsed. json -> dict
       * body: Original request body
    """

    def __init__(self, m2message):
        self.server_id, self.client_id, \
            self.path, self.netstring = m2message.split(' ', 3)
        len_headers, rest = self.netstring.split(':', 1)

        self.headers = json.loads(rest[:int(len_headers)])
        rest_with_body = rest[int(len_headers) + 1:]
        len_body, rest = rest_with_body.split(':', 1)
        self.body = rest[:int(len_body)]

    def is_disconnect(self):
        return self.path == '@*' and self.headers['METHOD'] == 'JSON'

    def is_upload_start(self):
        return 'x-mongrel2-upload-start' in self.headers and not self.is_upload_done()

    def is_upload_done(self):
        start = self.headers.get(HEADER_UPLOAD_START, 'start')
        finish = self.headers.get(HEADER_UPLOAD_DONE, 'done')
        return start == finish

    @property
    def async_upload_path(self):
        return self.headers.get(HEADER_UPLOAD_START, None)

########NEW FILE########
__FILENAME__ = parser
#encoding: utf-8

from .. import __version__, __progname__, __description__
from .. import conf

import os
import argparse
from command import ICommand


BOOL, STRING, LIST, INT = range(4)
TYPES = {INT: int,
         BOOL: bool,
         LIST: list,
         STRING: str}


def _parse_args():
    parser = argparse.ArgumentParser(prog=__progname__, description=__description__, version=__version__, conflict_handler='resolve')
    commands = ICommand.implementors()
    for command in commands:
        name = command.command_name()
        option_group = parser.add_argument_group(description="Options added by the {0} subcommand".format(name))
        # Add the custom command aditional options
        for opt in command.extra_options():
            option_group.add_argument(opt.name, help=opt.help, dest=opt.dest, action=opt.action, default=opt.default_value)

    # Add wsgid core options
    for opt in _create_core_options():
        if opt.type is bool:
            # We cannot pass type= when action is 'store_true', go figure!
            parser.add_argument(opt.name, help=opt.help, dest=opt.dest, action=opt.action, default=opt.default_value)
        else:
            parser.add_argument(opt.name, help=opt.help, type=opt.type, dest=opt.dest, action=opt.action, default=opt.default_value)
    return parser.parse_args()


class CommandLineOption(object):

    def __init__(self, name=None, shortname=None, help=None, type=STRING, dest=None, default_value=True):
        self.name = "--{0}".format(name)
        self.shortname = shortname
        self.help = help
        self.action = 'store'
        self.type = TYPES.get(type, str)

        if type is BOOL and default_value is False:
            self.action = 'store_false'
        elif type is BOOL:
            self.action = 'store_true'

        if type is LIST:
            self.action = 'append'

        self.dest = dest
        if not dest:
            self.dest = name.replace('-', '_')
        self.default_value = default_value

    def __str__(self):
        return "{name}".format(name=self.name)


def add_option(name=None, shortname=None, help=None, type=None, dest=None, default_value=None, namespace='core'):
    if name:
        return CommandLineOption(name, shortname, help, type, dest, default_value)


def _create_core_options():
    '''
    Create the list of main CLI options
    '''
    return [add_option('app-path', help="Path to the WSGI application", dest="app_path"),
            add_option('wsgi-app', help="Full qualified name for the WSGI application object", dest="wsgi_app"),
            add_option('loader-dir', help="Aditional dir for custom Application Loaders", dest="loader_dir"),
            add_option('debug', help="Runs wsgid in debug mode. Lots of logging.", dest="debug", type=BOOL),
            add_option('stdout', help="Redirect all logs to stdout. Use this with --no-daemon to see the logs on the same terminal wsgid was started",
                       dest="stdout", type=BOOL),
            add_option('no-daemon', help="Runs wsgid in the foreground, printing all logs to stderr",
                       type=BOOL, dest="no_daemon"),
            add_option('workers', help="Starts a fixed number of wsgid processes. Defaults to 1",
                       type=INT, dest="workers", default_value=1),
            add_option('keep-alive', help="Automatically respawn any dead worker. Killink the master process kills any pending worker",
                       type=BOOL, dest="keep_alive", default_value=True),
            add_option('chroot', help="Chroot to the value of --app-path, before loading the app.",
                       type=BOOL, dest="chroot"),
            add_option('django', help="Force the app to be loaded as a django app",
                       type=BOOL, dest="django"),
            add_option('recv', help="TCP socket used to receive data from mongrel2. Format is IP:Port or *:Port to listen on any local IP",
                       dest="recv"),
            add_option(name='send',
                       help="TCP socket used to return data to mongrel2. Format is IP:Port",
                       dest="send"),
            add_option(name='mongrel2-chroot',
                       help="This the chroot of your mongrel2 server. This value will be prepended to the temporary file create by \
                        mongrel2 when receiving big requests. This is needed to the async upload work correctly.",
                       dest="mongrel2_chroot")]


def parse_options(use_config=True):

    if conf.settings:  # Do not parse twice
        return conf.settings
    options = _parse_args()
    options.app_path = _full_path(options.app_path or os.getcwd())
    options.envs = {}

    if options.app_path:
        # Check the existence of app-path/wsgid.json, if yes use it
        # instead of command line options
        filepath = os.path.join(options.app_path, 'wsgid.json')
        if os.path.exists(filepath) and use_config:
            try:
                import simplejson as json
            except:
                # Fallback to python's built-in
                import json
            json_cfg = json.loads(file(filepath).read())

            options.send = _return_str(json_cfg.setdefault('send', options.send))
            options.recv = _return_str(json_cfg.setdefault('recv', options.recv))
            options.debug = _return_bool(json_cfg.setdefault('debug', options.debug))
            options.workers = int(json_cfg.setdefault('workers', options.workers or 1))
            options.keep_alive = _return_bool(json_cfg.setdefault('keep_alive', options.keep_alive))
            options.wsgi_app = _return_str(json_cfg.setdefault('wsgi_app', options.wsgi_app))
            options.no_daemon = _return_str(json_cfg.setdefault('no_daemon', options.no_daemon))
            options.chroot = _return_bool(json_cfg.setdefault('chroot', options.chroot))
            options.stdout = _return_bool(json_cfg.setdefault('stdout', options.stdout))
            options.mongrel2_chroot = _return_str(json_cfg.setdefault('mongrel2_chroot', options.mongrel2_chroot))
            options.envs = json_cfg.setdefault('envs', {})

    conf.settings = options
    return options


def _return_bool(option):
    if option and str(option).lower() == 'true':
        return True
    return False


def _return_str(option):
    if option:
        return str(option)
    return option


def _full_path(path=None):
    if path:
        return os.path.abspath(os.path.expanduser(path))
    return path

########NEW FILE########
__FILENAME__ = filters
import plugnplay


class IPreRequestFilter(plugnplay.Interface):

    '''
     Receives the already parsed mongrel2 message object (wsgid.core.Message)
     and the WSGI environ
    '''
    def process(self, m2Message, environ):
        pass


class IPostRequestFilter(plugnplay.Interface):

    '''
     Should always return a tuple of the form: (status, headers, write, finish)
     even if it does not modify any of the values
    '''
    def process(self, m2message, status, write, finish):
        pass

    def exception(self, m2message, exception):
        pass

########NEW FILE########
__FILENAME__ = djangoloader
from wsgid.loaders import IAppLoader
from wsgid.core import Plugin, log
import wsgid.conf
try:
    from django.conf import settings
except ImportError:
    pass  # Without django its unlikely anyone intends on using the DjangoAppLoader

import os
import sys
import simplejson


class DjangoAppLoader(Plugin):
    implements = [IAppLoader]

    def _not_hidden_folder(self, name):
        return not name.startswith('.')

    def _valid_dirs(self, app_path):
        return sorted(filter(self._not_hidden_folder, os.listdir(app_path)))

    def _first_djangoproject_dir(self, app_path):
        dirs = self._valid_dirs(app_path)
        log.debug("{0} Possible valid djangoapp folders: {1}".format(len(dirs), dirs))
        for d in dirs:
            settings_path = os.path.join(app_path, d, 'settings.py')
            init_path = os.path.join(app_path, d, '__init__.py')
            if os.path.exists(settings_path) and os.path.exists(init_path):
                return d
        return None

    def can_load(self, app_path):
        return wsgid.conf.settings.django or self._first_djangoproject_dir(app_path) is not None

    def _load_django_extra_options(self, path):
        parsed = {}
        conf_file = os.path.join(path, 'django.json')
        log.debug("Reading {0}".format(conf_file))
        if os.path.exists(conf_file):
            try:
                parsed = simplejson.load(open(conf_file))
            except:
                log.exception("Error parsing {file}".format(file=conf_file))
        return parsed

    def load_app(self, app_path, app_full_name=None):
        logger = log
        # Since we receive here --app-path + app/, we need to remove the last part
        # because django.json lives in --app-path
        wsgidapp_path = os.path.dirname(app_path)

        extra = self._load_django_extra_options(wsgidapp_path)

        site_name = self._first_djangoproject_dir(app_path)
        os.environ['DJANGO_SETTINGS_MODULE'] = '{0}.settings'.format(site_name)
        logger.debug("Using DJANGO_SETTINGS_MODULE = {0}".format(os.environ['DJANGO_SETTINGS_MODULE']))

        new_syspath = os.path.join(app_path, site_name)

        logger.debug("Adding {0} to sys.path".format(app_path))
        sys.path.append(app_path)
        logger.debug("Adding {0} to sys.path".format(new_syspath))
        sys.path.append(new_syspath)

        # Here we force django to load the app settings
        settings._some_value = True
        # Clean up
        del settings._some_value

        for k, v in extra.items():
            setting_value = None
            if hasattr(settings, k):
                setting_value = getattr(settings, k)

            if isinstance(v, dict) and setting_value and isinstance(setting_value, dict):
                for k2, v2 in v.items():
                    getattr(settings, k)[k2] = v2
            elif isinstance(v, list) and setting_value and isinstance(setting_value, list):
                setting_value += v
            elif isinstance(v, list) and setting_value and isinstance(setting_value, tuple):
                #Since we cannot modify the original tuple, we must re-create it
                setattr(settings, k, setting_value + tuple(v))
            else:
                setattr(settings, k, v)

        import django.core.handlers.wsgi
        return django.core.handlers.wsgi.WSGIHandler()

    def _is_all_instance(self, instance_of, *args):
        '''
        Check if isinstance(args[0], instance_of) returns True for *all*
        members of *args
        '''
        for a in args:
            if not isinstance(a, instance_of):
                return False
        return True

########NEW FILE########
__FILENAME__ = test
#encoding: utf8

import os


class FakeOptions(object):
    def __init__(self, **kwargs):
        for k, v in kwargs.items():
            setattr(self, k, v)


def fullpath(path):
    '''
    Returns the full absolute path
    of the path received.

    Useful when you want to know the full
    path of the current file, eg:

    full_path(__file__)
    '''
    return os.path.dirname(os.path.abspath(os.path.expanduser(path)))

########NEW FILE########
