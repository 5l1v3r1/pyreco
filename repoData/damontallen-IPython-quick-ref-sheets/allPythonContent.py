__FILENAME__ = Build_dict
from Parse_flags import *
from collections import OrderedDict as Or_dict

def add_subject(_type_, Quick_ref_dic, lines=[], index=0, subject=''):
    """This function adds a new ordered dict to the Quick_ref_dic with the 
    line that the index points to (or subject) as the key to the ordered dict.  
    This key is returned as the current subject.  The ordered dict is 
    initialized with "_type_" being set to the passed in _type_."""
    if not subject:
        subject = lines[index]
    current_dic = Or_dict()
    current_dic['_type_'] = _type_
    Quick_ref_dic[subject] = current_dic
    return subject
    
def strip_leading_empties(test_list):
    if test_list[0].strip()=='':#is the righthand column empty
                #print("Empty right!!!")
                #print(_right)
                #shift the explanations to the top of the example
                for index_b, b in enumerate(test_list):
                    #print(b, index_b)
                    if b.strip()!='':
                        #index_b +=1
                        break
                test_list = test_list[index_b:]
    return test_list
    
def add_multiline(current_dict,_multiline_flag, line='', left=[], right=[]):
    """This function starts or adds to an array of multiline text in the 
    current_dict.  The particular arrar is designated by the _multiline_flag."""
    if current_dict['_type_']=='Comment':
        if _multiline_flag not in current_dict:
            current_dict[_multiline_flag] = []
        current_dict[_multiline_flag].append(line)
    else:
        current_dict[_multiline_flag] = list(zip(left, right))
    
def build_dict(lines, break_at=-1):
    """This function takes an array of strings generated by quickref and turns 
    it into an ordered dict"""
    Quick_ref_dic = Or_dict()
    start_up = Or_dict(
        [('ipython',                        'Open IPython terminal console'),
         ('ipython qtconsole',              'Open IPython qtconsole'), 
         ('ipython notebook',               'Open IPython Notebook (browser interface)'), 
         ('ipython notebook --pylab inline','Open IPython Notebook with inline graphs'), 
         ('ipython notebook --pylab qt',    'Open IPython Notebook with popup graphs'), 
         ('ipython3',                       'Use the Python3 version of IPython'), 
         ('ipython --help-all',             'Show all IPython start flags')])
    in_comment = False
    multiline = {'In multiline':False,'column':'Left','Entry':''}
    lines.append(None)
    for index, line in enumerate(lines):
        if index==break_at:
            break
        if line == None:
            break
        elif not(line) or '=======' in line: #skip empty lines 
            in_comment = False
            continue
        elif title_check(lines, index): 
            """Check to see if the current line is the title"""
            subject = add_subject('Title', Quick_ref_dic, lines, index)
            current_dict = Quick_ref_dic[subject]
            for L_entry, R_entry in start_up.items():#Add start_up to the quickref
                current_dict[L_entry]=R_entry
            subject = add_subject("Heading", Quick_ref_dic, subject='Within IPython:')
            #add_multiline(current_dict,_multiline_flag, left=left, right=right)
            continue
        elif  heading_check(lines, index):# or comment_check(lines, index):
            """Check to see if the current line is a new heading"""
            subject = add_subject('Heading', Quick_ref_dic, lines, index)
            continue
        elif comment_check(lines, index, in_comment): 
            """Check to see if the current line is a comment instead of an 
            example"""
            #print("Line = {}".format( line))
            if not in_comment:
                in_comment = True
                #break_section = True
                cur_com = '_Comment_starts_at_{}_'.format(str(index))
                subject = add_subject('Comment', Quick_ref_dic, subject=cur_com)
            comment = line
            current_dict = Quick_ref_dic[subject]
            add_multiline(current_dict,cur_com, line=comment)
            continue
        else:
            try:
                next_line = lines(index+1)
            except:
                next_line = ''
            #print("comment? {}".format(in_comment))
            #print("line is -- {}".format(line))
            m_line_start = multiline_start_check(lines, index, in_comment)
            #print(" m_line_start ={}".format( m_line_start))
            end_multiline = not right_column_check(next_line) 
            end_multiline = end_multiline and multiline['column'] == 'Right'
            parts = patch_range(line) #break the line up into parts
        
        if m_line_start or multiline['In multiline']:
            """Check to see is the current line is the start of a multilined 
            example """
            if m_line_start and not multiline['In multiline']:
                multiline['In multiline']=True
                multiline['column']='Left'
                multiline['Entry'] = '_Multiline_Flag_{}_'.format(str(index))
                _left = []
                _right = []
            rhc = right_column_check(line)
            #print("line parts are: {}\n".format(parts))
            if len(parts)==1:
                if not rhc:
                    parts.append('')
                else:
                    multiline['column']=='Right'
                    parts = [''] + parts
            else:
                multiline['column'] = 'Right'
            _left.append(parts[0].strip())
            _right.append(parts[1].strip())

        if end_multiline:
            #add the multiline explanation to Quick_ref_dic
            _right = strip_leading_empties(_right)
            _left.reverse()
            _left = strip_leading_empties(_left)
            _left.reverse()
            len_diff = len(_left)-len(_right)
            if len_diff>0: #make the two columns the same length
                _right += [' ']*len_diff
            elif len_diff<0:
                _left += [' ']*(-len_diff)
            current_dict = Quick_ref_dic[subject]
            if len(_right)>1:
                M_key = multiline['Entry']
                add_multiline(current_dict, M_key, left=_left, right=_right)
            else: #if it is not really a multiline entry....
                Quick_ref_dic[subject][_left[0]]=_right[0]
            #reset multiline values
            multiline={'In multiline':False,'column':'Left','Entry':''}
        
        elif (len(parts)>1 or not(line))and not(multiline['In multiline']):                                            #was elif
            """This line contains atleast part of an example and maybe even part
             of an explanation """
            
            part_key = parts[0].strip() #######

            Quick_ref_dic[subject][part_key]=parts[1] #######
    #print("******\n")    
    return Quick_ref_dic

########NEW FILE########
__FILENAME__ = helper
#! /usr/bin/env python3

from os import system as sys

ver2=["sudo apt-get install python-zmq --assume-yes",
"sudo apt-get install python-pip --assume-yes",
"sudo apt-get install ipython --assume-yes",
"sudo apt-get install python-matplotlib -assume-yes",
"sudo apt-get install ipython-notebook --assume-yes",
"sudo apt-get install ipython-qtconsole --assume-yes"]

ver3=["sudo apt-get install python3-zmq --assume-yes",
"sudo apt-get install python3-dev --assume-yes",
"sudo apt-get install python3-pip --assume-yes",
"sudo apt-get install ipython3 --assume-yes",
"sudo apt-get install python3-matplotlib -assume-yes",
"sudo apt-get install ipython3-notebook --assume-yes",
"sudo apt-get install ipython3-qtconsole --assume-yes"]

lib2=["sudo apt-get install python-numpy --assume-yes",
"sudo apt-get install python-scipy --assume-yes",
"sudo apt-get install python-serial -assume-yes",
"sudo apt-get install python-sympy -assume-yes"]


lib3=["sudo apt-get install python3-numpy --assume-yes",
"sudo apt-get install python3-scipy --assume-yes",
"sudo apt-get install python3-serial -assume-yes",
"sudo apt-get install python3-sympy -assume-yes"]

def install2():
    print("installing version 2")
    for cmd in ver2:
        sys(cmd)
    
def install3():
    print("installing version 3")
    for cmd in ver3:
        sys(cmd)

def lib2install():
    print("installing python2 libraries")
    for cmd in lib2:
        sys(cmd)

def lib3install():
    print("installing python3 libraries")
    for cmd in lib3:
        sys(cmd)

if __name__=="__main__":
    choice = ""
    while not(choice=="2" or choice=="3" or choice=="b"):
        print("Install IPyton for Python2.7, Python3.2, or both? (2, 3, [b - default])")
        choice = input()
        if choice=="":
            choice = "b"
            break
        if not(choice=="2" or choice=="3" or choice=="b"):
            print("\nThat is not a valid choice.\n")
    if choice=="2":
        install2()
    elif choice=="3":
        install3()
    else:
        install2()
        install3()
    state = choice
    choice = ""
    while not(choice=="y" or choice=="n"):
        print("Do you wish to install the additional libaries for numpy, scipy, sympy, and serial? (n, [y - default])")
        choice = input()
        if choice=="":
            break
        if not(choice=="n" or choice=="y"):
            print("\nThat is not a valid choice.\n")
    if choice=="y":
        if state=="2":
            lib2install()
        elif state="3":
            lib3install()
        else:
            lib2install()
            lib3install()

########NEW FILE########
__FILENAME__ = IPython3_dir
#!/usr/bin/python3

from PySide import QtGui
import os
import subprocess
import sys

def main():
    app = QtGui.QApplication([])
    dialog = QtGui.QFileDialog()
    dialog.setDirectory("/home/damon/Documents/CODE/Programing/Python/IPython Notebook Folders (links)")
    dialog.setOption(QtGui.QFileDialog.ShowDirsOnly)
    dialog.setFileMode(QtGui.QFileDialog.Directory)
    chose_ = dialog.exec_()
    if chose_==1:
        directory = dialog.directory()
        print(directory.path())
        os.chdir(directory.path())
        cmd = "ipython3 notebook --pylab inline"
        try:
            subprocess.call(cmd,shell=True)
        except OSError:
            sys.stderr.write("Execution failed"+cmd)
            sys.stderr.flush()
    sys.exit()
    
if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = IPython_dir
#!/usr/bin/python

from PySide import QtGui
import os
import subprocess
import sys

def main():
    app = QtGui.QApplication([])
    dialog = QtGui.QFileDialog()
    dialog.setDirectory("/home/damon/Documents/CODE/Programing/Python/IPython Notebook Folders (links)")
    dialog.setOption(QtGui.QFileDialog.ShowDirsOnly)
    dialog.setFileMode(QtGui.QFileDialog.Directory)
    chose_ = dialog.exec_()
    if chose_==1:
        directory = dialog.directory()
        print(directory.path())
        os.chdir(directory.path())
        cmd = "ipython notebook --pylab inline"
        try:
            subprocess.call(cmd,shell=True)
        except OSError:
            print >>sys.stderr, "Execution failed:"+cmd
    sys.exit()
    
if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = write_shortcuts
files = ['IPython Notebook QT plotting.sh','Start IPython Notebook.sh']
from os import getcwd, chmod, stat
from subprocess import call
for FILE in files:
    with open(FILE, 'r') as f:
        contents = f.read()
    pwd = getcwd()
    contents.replace('Full path to the IPython Notebooks',cwd)
    desktop = '~/Desktop/'+FILE
    with open(desktop, 'w') as f:
        f.write()
    chmod(desktop,stat.S_IEXEC)
stop="Stop IPython Notebook.sh"
call("cp "+stop+" ~/Desktop")
chmod('~/Desktop/'+stop, stat.S_IEXEC)
print "Shortcuts placed on Desktop\n"        

########NEW FILE########
__FILENAME__ = HTML_Table_funcs
def clean_text(text):
    """This function replaces problem characters with HTML friendly characters """
    if '<' in text or '>' in text: #allow for the display of <n> and <tab>
        text = text.replace('<','&#60')
        text = text.replace('>','&#62')
    if '$' in text: #ensure that $ renders as a $
        #$ will render correctly when viewed in a browser but not
        #using IPython.display.HTML
        pass
    text=text.replace(" ",'&nbsp')
    text= text.strip('\b')
    return text


def multiline_html(lines, columns = 2):
    """This function handels multi line examples"""
    table = ''
    top_style = '  style="border-bottom: 1px solid transparent;">'
    mid_style = '  style="border-top: 1px solid transparent; border-bottom: '
    mid_style += '1px solid transparent;">'
    bot_style = '  style="border-top: 1px solid transparent;">'
    left_text=""
    if columns==2:
        right_text="" #if exists
    for line in lines:
        if line!=lines[-1]:
            br="<BR>"
        else:
            br=""
        
        if columns==2:    
            right_text+=clean_text(line[1])+br
            left_text+=clean_text(line[0])+br
        else:
            left_text+=clean_text(line)+br
    if columns!=2:
        table += '<tr><td colspan="2"; >'+left_text+'</td></tr>\n'
    else:
        table += '<tr><td> {0} </td><td> {1} </td></tr>\n'.format(left_text, right_text)
    #for line in lines:
    #    if line==lines[0]:
    #        style =  top_style
    #    elif line==lines[-1]:
    #        style = bot_style
    #    else:
    #        style =  mid_style
    #    if columns == 2:
    #        table += '<tr><td {0} {1} </td><td {0} {2}</tr>\n'.format(style,  line[0], line[1])
    #    else:
    #        table += '<tr><td colspan="2"; ' + style +  line + '</td></tr>\n'
    return table

def build_HTML_table(_Dict, Start_key = '', end_key='', max_line=-1, start_later =-1):
    """This function builds a HTML table of the quickref text like the one seen 
    at http://dl.dropboxusercontent.com/u/54552252/ipython-quickref.pdf.
    If Start_key is passed then the table will only start when the dictionary 
    subject contains the Start_key.  If end_key is passed then the table ends
    just before the subject contains the end_key.  Between Start_key and end_key
    you can take a slice out of the ordered dictionary _Dict."""
    
    Table = '<table border="1" cellpadding="3" cellspacing="0"  '
    Table += 'style="border:1px solid black;border-collapse:collapse;font-family:verdana;font-size:13px">\n'
    
    comment_start = True
    show = False
    if Start_key != '':
        start, Just_now = False, True
    else:
        start, Just_now = True, False
    count, start_count = 0, 0
    for subject, sub_entries in _Dict.items():
        if not start and Start_key not in subject: #start at this subject
            continue       
        else:
            if not start:
                start = True
        if (end_key in subject and end_key != '') or (count>=max_line and max_line>0): 
            #end the table at this subject or this line
            break
        label = clean_text(subject)
        if  sub_entries['_type_'] == 'Title' or sub_entries['_type_'] == 'Heading':
            skip_line = start_later > start_count and start_later>0
            if not skip_line:
                if sub_entries['_type_'] == 'Title':
                    color = 'lightBlue'#'00FFFF'#
                    count +=2
                else:
                    color = '#D5E0C5'#'99FF99'#(213,224,197)
                    count +=2
                    if not Just_now:
                        Table+='<tr><td colspan="2"; > </td></tr>\n'
                        count +=1
                background = '  style="background-color:'+color+';" ' #background-color
                Table += "<tr><td"+background+' colspan="2"; ><b>'
                Table += label+"</b></td></tr>\n"
                Table += '<tr><td colspan="2"; > </td></tr>\n'
            for example, explanation in sub_entries.items():
                if skip_line:
                    if '_type_' in example:
                        continue
                    if '_Multiline_Flag_' not in example:
                        start_count +=1
                        #print(start_later, start_count)
                    else:
                        start_count +=len(explanation)
                    skip_line = start_later > start_count and start_later>0
                    continue
                if ('_Multiline_Flag_' not in example) and ('_type_' not in example):
                    text_left = clean_text(example)
                    text_right = clean_text(explanation)
                    Table+="<tr><td >"+text_left+"</td><td>"+text_right+"</td></tr>\n"
                    count+=1
                elif '_Multiline_Flag_' in example:
                    new = multiline_html(explanation)
                    Table += new
                    count+=len(explanation)
                if count>=max_line and max_line>0:
                    break
        if sub_entries['_type_'] == 'Comment':
            Table+='<tr><td colspan="2"; > </td></tr>\n'
            comment_flag = '_Comment_starts_at_'
            for titles in list(sub_entries.keys()):
                if comment_flag in titles:
                    comments = sub_entries[titles]
                    new = multiline_html(comments, columns = 1)
                    Table+=new
                    count+=len(comments)+1
        Just_now = False
    Table+='<tr><td colspan="2"; > </td></tr>\n'
    Table +="</table>"
    count+=1
    #print("Count = {}".format(count))
    return Table
    
def Table_container(Widths,tables):#, height='auto'
    """This function assembles a group of tables into one container, arainging them left to right."""
    Total_width = sum(Widths)+20*len(tables)
    Container = ''
    L_px = 10
    for index, width in enumerate(Widths):
        style =  '<style>\n div.Table_{}'.format(index)
        style += '{\n left:0%; \n'
        style += 'width:{}px; \n margin-left: {}px;\n position:absolute;\n'.format(width, L_px)
        L_px+=width+20
        style += '}\n</style>\n'
        Container+=style
    Container += '<div id="container" style="height_min=800px;width:{}px">\n'.format(Total_width)#height,
    for index, stuff in enumerate(zip(Widths, tables)):
        width, table = stuff
        Name = 'Table'+str(index)
        Container += '<div class="Table_{}" id="{}" style="height:auto;min_width:{}px;">{}</div>\n'.format(index, Name, width, table)
    Container+='</div>'
    return Container    
    
    
    

    
    
    
    
    
    
    
    
    
'''def multiline_List(lines, columns = 2):
    """This function handels multi line examples"""
    Row_list=[]
    for line in lines:
        if columns == 2:
            Row_list.append([line[0],line[1]])
        else:
            Row_list.append([line,''])
    return Row_list


def build_table_list(_Dict, Start_key = '', end_key=''):##
    """This function builds a list of lists out of the quickref text to be used
    to build a table using ipy_table.
    http://dl.dropboxusercontent.com/u/54552252/ipython-quickref.pdf"""
    comment_start = True
    count = 0
    Table_list = []
    #print(Start_key)
    if Start_key != '':
        start = False
        Just_now = True
    else:
        start = True
        Just_now = False
    for subject, sub_entries in _Dict.items():
        if not start and Start_key not in subject: #start at this subject
            #print("Skipping {}".format(subject))
            continue
        else:
            if not start:
                #print("Starting now!")
                start = True
        if end_key in subject and end_key != '': #end at this subject
            break
        label = clean_text(subject)
        if sub_entries['_type_'] == 'Title' or sub_entries['_type_'] == 'Heading':
            if sub_entries['_type_'] == 'Title':
                count +=2
            else:
                count +=3
                if not Just_now:
                    #print('HERE {}'.format(subject))
                    Table_list.append(['',''])
            Table_list.append( [label,''])
            Table_list.append(['',''])
            for example, explanation in sub_entries.items():
                if ('_Multiline_Flag_' not in example) and ('_type_' not in example):
                    text_left = clean_text(example)
                    text_right = clean_text(explanation)
                    Table_list.append([text_left,text_right])
                    count +=1
                elif '_Multiline_Flag_' in example:
                    rows = multiline_List(explanation)
                    Table_list+=rows
                    count+=len(explanation)
        if sub_entries['_type_'] == 'Comment':
            comment_flag = '_Comment_starts_at_'
            for titles in list(sub_entries.keys()):
                if comment_flag in titles:
                    comments = sub_entries[titles]
                    rows = multiline_List(comments, columns = 1)#Comment_lines(sub_entries)
                    Table_list.append(['',''])
                    Table_list+=rows
                    count+=len(comments)+1
        Just_now=False
    Table_list += [['','']]
    print("Count = {}".format(count))
    return Table_list
'''


########NEW FILE########
__FILENAME__ = load_quickref_text_magic
from IPython.core.magic import (magics_class, line_magic)
from IPython.core.magics.basic import BasicMagics #Where _magic_docs is defined, also BasicMagics inherits the Magics already
@magics_class
class MyMagics(BasicMagics):
    @line_magic
    def quickref_text(self, line): 
        """ Return the quickref text to be assigned to a variable """
        from IPython.core.usage import quick_reference
        qr = quick_reference + self._magic_docs(brief=True)
        return qr
            
ip = get_ipython()
ip.register_magics(MyMagics)

#quickref_text = %quickref_text

########NEW FILE########
__FILENAME__ = modification_code
@line_magic               #Inserted at line 380 in the basic.py source code file
def quickref_file(self,arg): #Added to save the quickref text to disk
    """ Save a quick reference sheet on disk """
    from IPython.core.usage import quick_reference
    qr = quick_reference + self._magic_docs(brief=True)
    #page.page(qr)
    with open('quick_ref.txt','w') as f:
        f.write(qr)

########NEW FILE########
__FILENAME__ = open_html_in_new_tab

import tempfile
import webbrowser
import os
import time

def open_html(text):
    """This function takes in html text and opens it in a new tab.  It does this
    by writing the text to a file in a temporary directory, then opening that 
    file with the webbrowser module.  The temporary directory only exists for
    3 seconds.  Note: This function was written in Python 3.3 and was not tested
    in any other version."""
    pwd = os.getcwd()
    tmp_dir = tempfile.TemporaryDirectory(dir=pwd)
    tmp_file = tmp_dir.name+"/text.html"
    with open(tmp_file, 'w') as f:
        f.write(text)
    webbrowser.open(tmp_file,2)
    time.sleep(3)
    tmp_dir.cleanup()

########NEW FILE########
__FILENAME__ = Parse_flags
def patch_range(line, strip = True):
    """This function returns a list of parts that include ranges (i.e. [2:5]) if
    they were present in the original line."""
    pieces = line.split(':')
    parts = []
    tmp = ''
    for part in pieces:
        if part.count('[')>part.count(']') and not(tmp):
            tmp = part
            continue
        if tmp:
            piece = tmp+':'+part
            if strip:
                part = piece.strip()
            #parts.append()
            tmp=''
        else:
            if strip:
                part = part.strip()
        parts.append(part)
    if right_column_check(line):
        parts = [parts[0]]
    return parts

def heading_check(lines, index):
    """This function determines if the line at the provided index is a heading."""
    if index >= 0:
        pre_line = lines[index-1]
    else:
        pre_line = ''
    try:
        next_line = lines[index+1]
    except:
        next_line = ''
    check = (not(pre_line) and not(next_line))
    return check

def title_check(lines, index):
    """This functions checks to see if the index is pointing at the title line."""
    if index >= 0:
        pre_line = lines[index-1]
    else:
        pre_line = ''
    try:
        next_line = lines[index+1]
    except:
        next_line = ''
    check = (not(pre_line) and ("=======" in next_line))
    return check

def right_column_check(line):
    """This function determines if the line is part of an explanation, 
    e.i. it belongs in the right-hand column"""
    #line = lines[index]
    return (('\t' in line) or (' '*4 == line[0:4]))

def comment_check(lines, index, in_comment = False):
    """This fuinction determines if the line is a comment rather than an example or a subject header"""
    if index >= 0:
        pre_line = lines[index-1]
    else:
        pre_line = ''
    try:
        next_line = lines[index+1]
    except:
        next_line = ''
    cur_line = lines[index]
    #colon_not_in_line = ":" not in cur_line
    line_before_multipart = len(patch_range(pre_line))>1
    exists = lines[index] !=''
    blank_line_before = not(pre_line)
    parts = patch_range(cur_line)
    cur_line_multipart = len(parts)>1
    pre_parts = patch_range(pre_line)
    pre_multi_part = len(pre_parts)
    raw_parts = patch_range(cur_line, False)
    first_part_comment = raw_parts[0].strip()==raw_parts[0] #like "Remeber: This is ..."
    not_right_hand_column = not(right_column_check(cur_line))
    next_not_right_hand_column = not(right_column_check(next_line))
    
    check0 = in_comment
    check1 = not(cur_line_multipart) and in_comment and len(parts[0])>20 
    check2 = not(cur_line_multipart) and blank_line_before
    check3 = blank_line_before and cur_line_multipart and first_part_comment
    check4 = not_right_hand_column 
    check5 = next_not_right_hand_column
    check6 = "=====" not in lines[index] 
    line = lines[index]
    return ((check0 or check1 or check2 or check3) and check4 and check5 and check6 and exists) 

def multiline_start_check(lines, index, in_comments = True):#multiline_check
    """This function determines if the current line is actually the start of a multiple line example"""
    try:
        next_line = lines[index+1]
    except:
        next_line = ''
    cur_line = lines[index]
    if cur_line !="":
        not_just_cmd = cur_line.strip()[-1]!=':'
    else:
        not_just_cmd = True
    not_in_comments = not in_comments
    not_empty = cur_line.strip() != ''
    not_markdown = '=====' not in cur_line
    parts = patch_range(cur_line)
    one_part = len(parts) == 1
    not_right_hand_column = not(right_column_check(cur_line))
    next_right_hand = right_column_check(next_line)
    check1 = one_part and not_right_hand_column #and not_just_cmd
    check2 = not_empty and not_markdown and not_in_comments
    check3 = next_right_hand #and not_just_cmd
    return (check1 and check2) or check3

def check_for_range(lines, index):
    """Check for range text, i.e. [2:5], in the line """
    parts = lines[index].split(':')
    check = False
    for part in parts:
        check = check or ('[' in part and ']' not in part)
    return check


########NEW FILE########
__FILENAME__ = quickref_text_magic
from IPython.core.magic import (magics_class, line_magic)
from IPython.core.magics.basic import BasicMagics #Where _magic_docs is defined, also BasicMagics inherits the Magics already
@magics_class
class MyMagics(BasicMagics):
    @line_magic
    def quickref_text(self, line): 
        """ Return the quickref text to be assigned to a variable """
        from IPython.core.usage import quick_reference
        qr = quick_reference + self._magic_docs(brief=True)
        return qr
            
ip = get_ipython()
ip.register_magics(MyMagics)

#quickref_text = %quickref_text

########NEW FILE########
__FILENAME__ = SVG_Table_Classes
from math import floor

class rectangle(object):
    """This object contains top_left, bottom_right, background, border_color, line_width"""
    def __init__(self):
        self.top_left = [0,0]
        self.bottom_right = [100, 30]
        self.background = (255,255,255)#white background
        self.border_color = (0,0,0)#border color
        self.line_width = 1 #line width


def draw_rec(rect_obj):
    BR = rect_obj.bottom_right
    TL = rect_obj.top_left
    back = rect_obj.background
    stroke_clr = rect_obj.border_color
    lin_width = rect_obj.line_width
    svc_rec_list = ['<rect ',
                    'height="{}"'.format(BR[1]),
                    'width="{}" '.format(BR[0]-TL[0]),
                    'style="',
                    'fill:rgb{};'.format(back),
                    'stroke:rgb{};'.format(stroke_clr),
                    'stroke-width:{}" '.format(lin_width), 
                    'x="{}" '.format(TL[0]+lin_width),
                    'y="{}" />\n'.format(TL[1]+lin_width)]
    return ' '.join(svc_rec_list)

def SVG_text(TL=(0,0), font_size=12, height=16, text='', font_color=(0,0,0), font_weight='normal', x_shift=0, font_family="Arial"):
    """This function generates the SVG text to display text.  It also supports multiple line text is \n is in the text"""
    x,y = TL
    if '\n' in text:
        y+=font_size+1
        #print(TL)
    else:
        y+=int(floor((height+font_size)/2))-1
    x += round(font_size/2) + x_shift
    list_of_text = text.split('\n')
    add_list=[]
    if len(list_of_text)>1:
        for index, text in enumerate(list_of_text[1:]):
            inst_y = y+(index+1)*(font_size+2)
            add_text = '<tspan x="{}" y="{}">'.format(x, inst_y)+text+'</tspan>'
            add_list.append(add_text)
    Text_list = ['<text x="{}" '.format(x),
                 'y="{}" '.format(y),
                 'font-size= "{}" '.format(font_size),
                 'font-weight = "{}" '.format(font_weight),
                 'style="fill:rgb{}" '.format(font_color),
                 'font-family="{}">'.format(font_family),
                 list_of_text[0]]
    Text_list+=add_list#+['\n']
    Text_list+=['</text>\n'] 
    return "".join(Text_list)

def Set_SVG_view(width, height, svg_display_text):
    """This function sets the viewbox and the height of an SVG object."""
    text = '<svg viewBox="0 0 {width} {height}" height="{height}" xmlns="http://www.w3.org/2000/svg" version="1.1">\n'.format(width=width, height=height)
    text+=svg_display_text+'</svg>'
    return(text)



class SVG_Text_obj(object):
    """This is a base class for handeling text objects"""
    def __init__(self, text="", font_size=12, font_color=(0,0,0), font_weight="normal", border_width=1, TL=(0,0), font_family="Arial"):
        """Initiailize"""
        self.line_width = self.check_line_width(border_width)
        self.font_weight = self.check_font_weight(font_weight)
        self.font_color = self.check_color(font_color)
        self.__font_size__ = self.check_font_size(font_size)
        self.__height__ = self.check_height(self.__font_size__, self.line_width)
        self.text = text
        self.Top_left = TL
        self.font_family=font_family


   
    def check_font_weight(self, font_weight):
        """This method validates the font_weight then returens it. Valid weights are
            normal | bold | bolder | lighter | 100 | 200 | 300| 400 | 500 | 600 | 700 | 800 | 900"""
        validweights = ["normal", "bold", "bolder", "lighter", 100, 200, 300, 400, 500,
                        600, 700, 800, 900, '100', '200', '300', '400', '500', '600', 
                        '700', '800', '900']
        try:
            assert(font_weight in validweights)
            return font_weight
        except:
            raise(RuntimeError("Font weight must be one of the following: {}".format(validweights)))
    
    def check_line_width(self, border_width):
        """This method validates the border_width then returns it."""
        try:
            assert(border_width>=0 and border_width == int(border_width))
            return border_width
        except:
            raise(RuntimeError("Line widths must be a positive integer.")) 
    
    def check_font_size(self, size):
        """This method validates size and returns it"""
        try:
            assert(size>=3 and size == int(size))
            return size
        except:
            raise(RuntimeError("Font size must be an integer 3 or greater.")) 
    
    def check_color(self, color):
        """This method is used to set the color of color_to_set or raise an error if
           the RGV values are invalid."""
        try:
            assert(min(color)>=0 and max(color)<256)
            return color
        except:
            raise(RuntimeError("RGB color values must be between 0 and 255 inclusive"))
    
    def check_height(self, font_size, border_width, height_to_check=0):
        """The method determines the minimum height based on the font_size 
           and the with of the lines on top and bottom.  Returns the greater 
           of set_height and the minimum height to set_height."""
        try:
            row_count=len(self.text.split('\n'))#+1
            #print("Here now and row_count is %d"% row_count)
            if row_count<1:
                row_count=1
        except:
            #print("An error occured")
            row_count=1
            pass
        min_height = row_count*(font_size+2*border_width)+2
        #print("min_height = %d"% min_height)
        #print("Height to check is %d" % height_to_check)
        
        return max(min_height, height_to_check)
        
        
    def set_font_size(self, font_size_to_set, size, height_to_set=0, border_width=0):
        """This method validates size then sets font_size_to_set.  If 
           border_width and height_to_set are provided then it will also update the 
           height_to_set."""
        self.__font_size__ = self.check_font_size(size)
        self.__height__ = self.check_height(self.__font_size__, border_width, self.__height__)
        
    def set_height(self, height):
        #print("here")
        self.__height__ = self.check_height(self.__font_size__, self.line_width, height)
        
    
    def get_SVG_text(self):
        return SVG_text(self.Top_left, self.__font_size__, self.__height__, self.text, self.font_color, self.font_weight, font_family=self.font_family)
        


class Table_Header(SVG_Text_obj):
    """This is a header object for the top row of a table.  If the header text using 
       the set_header_text (or this is created with the header text) the header will
       be set to show (self.Show_header = True)."""
    def __init__(self, text="", bordercolor=(0,0,0), height=25, size=14, font_color=(0,0,0), background=(255,255,255), line_width=1, TL=(0,0), width=100, font_family="Arial"):
        """Initiailize"""
        super().__init__(text, size, font_color, "bold", line_width, TL, font_family)
        self.Show_header = False
        self.Header_width = width
        self.set_header_text(text)
        self.__height__ = self.check_height(self.__font_size__, self.line_width, height)
        self.Header_border_color = self.check_color(bordercolor)
        self.Header_background = self.check_color(background)

    
    def set_header_text(self, text=""):
        """This method let the user set the text of the header of the table.  By default if the text is set then the
           header is set to show but it can be turned off by setting self.Show_header=False."""
        if len(text)>0:
            self.text = text
            self.Show_header = True
        else:
            print("No header was added")
            
    @property
    def bottom(self):
        return self.__height__+self.line_width+self.Top_left[1]-1
    
    def get_SVG_header(self):
        if self.Show_header:
            rect_obj = rectangle()
            rect_obj.top_left = self.Top_left
            BR=[self.Header_width+self.Top_left[0],self.__height__]
            rect_obj.bottom_right = BR
            rect_obj.background = self.Header_background
            rect_obj.border_color = self.Header_border_color
            rect_obj.line_width = self.line_width
            Text = draw_rec(rect_obj)
            Text += SVG_text(self.Top_left, self.__font_size__, self.__height__, self.text, 
                             self.font_color, self.font_weight, font_family=self.font_family)
            return Text 
        else:
            return ""

class Table_rows(SVG_Text_obj):
    #__Count__=0
    def __init__(self, font_size=12, line_width=1, top_left=(0,0), text_list=[], width=100, font_color=(0,0,0), background=(255,255,255), border_color=(0,0,0),font_family="Arial"):
        """Initiailize"""
        super().__init__("", font_size, font_color, "normal", line_width, top_left, font_family)
        self.row_width = width
        self.__column_locations__ = [0]

        self.__text_list__ = self.check_text_list(text_list)
        self.Show_rows = len(self.__text_list__)>0
        self.__count__ = 0
        self.set_count(self.__count__)
        self.row_border_color = self.check_color(border_color)
        self.row_background = self.check_color(background)
        self.x_shift=0
        
 
    def check_text_list(self, text_list=[]):
        """This method validates that every element in the text_list is a list of equal lenght"""
        try:
            if len(text_list)>0:
                check_len = len(text_list[0])
                same_size = not(sum([len(x)!=check_len for x in text_list]))
                assert(same_size==True)
        except:
            raise(RuntimeError("Every row must be a list containing the same number of elements"))
        return text_list
    
    @property
    def column_locations(self):
        return [location-self.Top_left[0] for location in self.__column_locations__]
    
    @column_locations.setter
    def column_locations(self, locations):
        locations = [local+self.Top_left[0] for local in locations]
        self.__set_column_locations__(locations)
    
    @property
    def bottom(self):
        return (self.line_width+self.__height__)*self.__count__+self.Top_left[1]
    
    def set_text_list(self, text_list):
        """This method first validates the text_list then sets the internal text_list and updates 
           the row count."""
        self.__text_list__ = self.check_text_list(text_list)
        self.set_count(self.__count__)
        try:
            if self.column_locations[0]<0:
                self.column_locations=[0]
        except:
            self.column_locations=[0]
        self.Show_rows = True
    
    def set_count(self, count):
        """This method lets you add rows beyond the lenght of the text_list."""
        try:
            assert(count>=0 and int(count)==count)
        except:
            raise(RuntimeError("The row count must be a postive integer"))
        self.__count__ = max(count,len(self.__text_list__))
        self.Show_rows = True
    
    def __set_column_locations__(self, locations=[0]):
        """This method sets the vertical dividers and text placement of the columns in the table."""
        try:
            assert(max(locations)<=self.row_width+self.Top_left[0])
            assert(min(locations)>=0)#+self.Top_left[0]>=0)
            if len(locations)<len(self.__text_list__[0]):
                more = len(self.__text_list__[0])-len(locations)
                step = 10
                start = locations[-1]+step
                stop = more*step+locations[-1]
                locations+=list(range(start, stop, step))
            self.__column_locations__=locations
        except:
            print(locations)
            raise(RuntimeError("Column locations must all be greater than or equal to zero and be less than or equal to the row width."))
        
    def get_SVG_rows(self):
        if self.Show_rows:
            try:
                columns = len(self.__text_list__[0])
            except:
                columns = 1
            TL = list(self.Top_left)
            #self.check_height(self.__font_size__, self.line_width)            
            row_height=self.__height__+self.__count__*self.line_width

            BR = [self.row_width+TL[0],row_height]
            rect_obj = rectangle()
            rect_obj.top_left = TL
            rect_obj.bottom_right = BR
            rect_obj.background = self.row_background
            rect_obj.border_color = self.row_border_color
            rect_obj.line_width = self.line_width
            Text = ""
            
            for row in range(self.__count__):
                #Text += draw_rec(rect_obj)
                try:
                    row_text = self.__text_list__[row]
                    #this is to check for a minimum number of column locations
                    if len(self.column_locations)<len(row_text):
                        print("column_locations are not set, using defaults")
                        self.column_locations = list(range(0,(len(row_text))*20,20))
                        #print(self.column_locations)
                    #print(column_count)
                    for self.text in row_text: #Set row height to the height of the tallest entry in that row
                        self.__height__=self.check_height(self.__font_size__, self.line_width, self.__height__)     
                    row_height=self.__height__+self.__count__*self.line_width
                    BR[1]=row_height
                    rect_obj.bottom_right = BR
                    Text += draw_rec(rect_obj)
                    Top_left = list(TL)
                    for self.text, x_local in zip(row_text, self.__column_locations__):
                        if x_local<TL[0]:
                            print(x_local)
                        Top_left[0]=x_local
                        Text += SVG_text(Top_left, self.__font_size__, row_height, self.text, 
                                         self.font_color, self.font_weight, self.x_shift, self.font_family)
                except: #there was no row text so draw an empty rectangle
                    Text += draw_rec(rect_obj)
                TL[1]+=row_height
            bottom = TL[1]+self.line_width
            top = self.Top_left[1]+self.line_width
            
            for hor_local in self.__column_locations__:
                if hor_local<=TL[0]:
                    continue
                line = '<line x1="{0}" y1="{1}" x2="{0}" y2="{2}" '.format(hor_local, top, bottom)
                line +='style="stroke:rgb{0}; stroke-width:{1}"/>\n'.format(self.row_border_color, self.line_width)
                Text+=line
            return Text 
        else:
            return ""


def clean_text(text):
    """This function replaces problem characters with HTML friendly characters """
    if '<' in text or '>' in text: #allow for the display of <n> and <tab>
        text = text.replace('<','&lt;')#'&#60')
        text = text.replace('>','&gt;')#'&#62')
    if '$' in text: #ensure that $ renders as a $
        #$ will render correctly when viewed in a browser but not
        #using IPython.display.HTML
        pass
    #text=text.replace(" ",'&nbsp')
    text= text.strip('\b')
    return text

########NEW FILE########
__FILENAME__ = Test
from Parse_flags import *
from Build_dict import *

#Right hand column check
def test_multispace_Rcolumn():
    """Test that lines with multiple spaces in front are flagged to be in the right-hand column"""
    Lines = [":",'    ?obj, ??obj).']
    assert right_column_check(Lines[1]) == True
    
def test_tab_escape_Rcolumn():
    """Test that lines with tab escapes infront are flagged to be in the right-hand column"""
    Lines = [":",'\tRight-hand column material']
    assert right_column_check(Lines[1]) == True

def test_empty_Rcolumn():
    """Test enrties are empty are not flagged as a right-hand column"""
    Lines = [":",'','\tRight-hand column material']
    assert right_column_check(Lines[1]) == False
    
#heading and title check
    
def test_heading_check():
    """Test that lines that have blank lines before and after are flagged as headings"""
    Lines = ['','Heading','']
    assert heading_check(Lines,1) == True

def test_title_check():
    """Test that lines that have blank lines before and a row of ==== after are flagged as titles"""
    Lines = ['','Title Here','===========']
    assert title_check(Lines,1) == True
    
def test_empty_heading_check():
    """Test enrties are empty are not flagged as a heading"""
    Lines = ['','','Heading','']
    assert heading_check(Lines,1) == False

def test_title_check():
    """Test enrties are empty are not flagged as a heading title"""
    Lines = ['','','Title Here','===========']
    assert title_check(Lines,1) == False
    
    
#comment check

def test_comment_check_Type_0():
    """0 - Test that lines without : and have blank lines before are flagged as comments"""
    Lines = ['','comment here','']
    assert comment_check(Lines,1) == True

def test_comment_check_Type_1():
    """1 - Test that lines like "rember: comment" with blank lines before are flagged as comments"""
    Lines = ['','Rember: comment','' ]
    assert comment_check(Lines,1) == True

def test_comment_check_Type_2():
    """2 - Test that lines without : and have a : in the line before but are NOT right hand columns not are flagged as comments"""
    Lines = ['a:b','comment here','']
    assert comment_check(Lines,1, False) == False
    
def test_comment_check_Type_3():
    """3 - Test that lines that are part of multi-line comments are flagged as comments"""
    Lines = ['comment here is really long','comment here','' ]
    assert comment_check(Lines,1, True) == True
    
def test_comment_check_Type_4():
    """4 - Test that lines with "=========" in them are not flagged as comments"""
    Lines = ['Title','=========','']
    assert comment_check(Lines,1) == False
    
def test_comment_check_Type_5():
    """5 - Test that lines that are right hand columns are not flagged as comments"""
    Lines = [':','\tnot comment', '']
    assert comment_check(Lines,1) == False
    
def test_empty_comment_check_6():
    """6 - Test enrties are empty are not flagged as a comment"""
    Lines = [':','', 'Heading']
    assert comment_check(Lines,1) == False

def test_empty_comment_check_7():
    """7 - Test command only lines are not flagged as a comment"""
    Lines = ['','cmd:', '         explained']
    assert comment_check(Lines,1) == False
    
#multiline check

def test_multiline_start_check():
    """Test that lines are part of commands that span multiple lines are flaged as such"""
    Lines = ['','cmd: info','\tcmd part 1','\tcmd part 2', 'cmd2: info', 'info']
    assert multiline_start_check(Lines, 1, False) == True

def test_check_for_range_multiline():  #RANGE CHECK
    """2 - Test that multi-lines that contain ranges like [2:5] are flagged correctly"""
    Lines = ["", "[2:5]range"]
    assert check_for_range(Lines, 1) == True
    
#def test_multiline_start_check2(): #A reality check is done prior to assigning a multiline flag
#    """3 - Test enrties that are just example folowed by the info on the next line are not flaged as multiline"""
#    Lines = ['cmd: info','cmd part 1:','          cmd part 2', 'cmd part 3', 'info']
#    assert multiline_start_check(Lines, 1, False) == False

def test_multiline_start_check3():
    """4 - Test enrties that are have multiple lines of explanation are flaged as multiline"""
    Lines = ['cmd: info','obj?, obj??      : Get help, or more help for object (also works as'
            ,'                   ?obj, ??obj).', 'cmd part 3', 'info']
    assert multiline_start_check(Lines, 1, False) == True
    
def test_multiline_start_check4():
    """5  - Test enrties that are not multiple lines are not flaged as such"""
    Lines = ['cmd: info','Test cmd: exlpained','next cmd: exlpained', 'cmd part 3', 'info']
    assert multiline_start_check(Lines, 1, False) == False
    
def test_multiline_start_check5():
    """6 - Test enrties that are have multiple lines of explanation are just after an empty line flaged as multiline"""
    Lines = ['','obj?, obj??      : Get help, or more help for object (also works as'
            ,'                   ?obj, ??obj).', 'cmd part 3', 'info']
    assert multiline_start_check(Lines, 1, False) == True

def test_multiline_start_check6():
    """7 - Test enrties that right hand entries are not flagged as a multiline start"""
    Lines = ['','obj??      : Get help, or more help for object (also works as'
            ,'                   ?obj, ??obj).', 'cmd part 3', 'info']
    assert multiline_start_check(Lines, 2, False) == False

def test_empty_multiline():
    """Test enrties are empty are not flagged as a multiline start"""
    Lines = ['','','Title', 'cmd part 3', 'info']
    assert multiline_start_check(Lines, 1, False) == False
    
def test_markdown_not_multiline():
    """Test enrties are empty are not flagged as a multiline start"""
    Lines = ['','Title', '===============', '']
    assert multiline_start_check(Lines, 2, False) == False

def test_multiline_example_and_explain():
    """Test enrties that have multiple lines of example and explanation are flagged as a multiline start"""
    Lines = ["%timeit x=10     : time the 'x=10' statement with high precision.",
            '%%timeit x=2**100',
             "x**100           : time 'x*100' with a setup of 'x=2**100'; setup code is not",
             '                   counted.  This is an example of a cell magic.']
    assert multiline_start_check(Lines, 1, False) == True
    
def test_comments_not_multiline():
    """Test that comments are not flagged as a multiline start"""
    Lines = ['',
            'Remember: TAB completion works in many contexts, not just file names',
            'or python names.', '']
    assert multiline_start_check(Lines, 1, True) == False
    
#range check
    
def test_check_for_range_empty():
    """Test enrties are empty are not flagged as a range"""
    Lines = ["", "","[2:5]range"]
    assert check_for_range(Lines, 1) == False
    
def test_check_for_range():
    """Test that lines that contain ranges like [2:5] are flagged correctly"""
    Lines = ["", "[2:5]:range"]
    assert check_for_range(Lines, 1) == True
      
    

#range patch check
     
def test_range_patch():
    """Test that lines containing ranges are parsed correctly"""
    line = '[2:5] : is a range example'
    parts = patch_range(line)
    check = parts == ['[2:5]','is a range example']
    assert check == True

def test_range_patch_2():
    """Test that lines that do not contain ranges are parsed correctly"""
    line = 'this : is not a range example'
    parts = patch_range(line)
    check = parts == ['this','is not a range example']
    assert check == True

########NEW FILE########
