__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# django-flash documentation build configuration file, created by
# sphinx-quickstart on Sun Feb  1 01:49:12 2009.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# The contents of this file are pickled, so don't put values in the namespace
# that aren't pickleable (module imports are okay, they're removed automatically).
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If your extensions are in another directory, add it here. If the directory
# is relative to the documentation root, use os.path.abspath to make it
# absolute, like shown here.
sys.path.append('./src')

# General configuration
# ---------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Django-Flash'
copyright = u'2008-2010, Destaquenet Technology Solutions'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '1.8'
# The full version, including alpha/beta/rc tags.
release = '1.8'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
# language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'


# Options for HTML output
# -----------------------

# The style sheet to use for HTML and HTML Help pages. A file of that name
# must exist either in Sphinx' static/ path, or in one of the custom paths
# given in html_static_path.
html_style = 'default.css'

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, the reST sources are included in the HTML build as _sources/<name>.
#html_copy_source = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'django-flashdoc'


# Options for LaTeX output
# ------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, document class [howto/manual]).
latex_documents = [
  ('index', 'django-flash.tex', ur'Django-flash Documentation',
   ur'Destaquenet Technology Solutions', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True

# Fix import errors
from django.conf import settings
settings.configure()

########NEW FILE########
__FILENAME__ = fabfile
# -*- coding: utf-8 -*-

"""Build script used to test, build and deploy django-flash using several
Python versions.

In order to test and build django-flash in these different environments,
this script requires different virtualenvs, each one targeted to a specific
Python version:

    * django-flash-py2.7 - for Python 2.7
    * django-flash-py2.6 - for Python 2.6
    * django-flash-py2.5 - for Python 2.5

Also, each one of these virtualenvs must have the following packages
installed:
    
    * Django   (version 1.0+)
    * Pysqlite (version recommended by the current Django version)

Finally, to use this script, you must install the packages below to your
default Python installation:

    * Fabric 0.9+

That's it. You can now see all available targets provided by this build
script by running the command line below:

    $ cd /path/to/django-flash
    $ fab -l
"""

import os
import re
import sys

from fabric.api import *


# Adds the 'src' to the Python path
sys.path += ('src',)

# Supported Python versions
env.versions        = ('2.7', '2.6', '2.5')
env.default_version = env.versions[0]

# Environment info
env.project        = 'django-flash'
env.virtualenv_dir = os.environ['WORKON_HOME'] or '~/.virtualenvs'
env.default_editor = os.environ['EDITOR']      or 'vi'

# Files that contain version information
env.new_version_files = (
    'setup.py',
    'src/djangoflash/__init__.py',
    'doc/source/conf.py',
    'doc/source/changelog.rst',
)

# Information needed to build the documentation
env.sphinx_output = 'build/sphinx'
env.sphinx_latex  = '%s/latex' % env.sphinx_output
env.sphinx_html   = '%s/html' % env.sphinx_output
env.doc_output    = 'djangoflash'

# Host where the documentation website lives
env.hosts  = ['destaquenet.com']
env.doc_folder = '/home/destaquenet/public_html'


def setup(command, version=env.default_version):
     """Executes the given setup command with a virtual Python installation.
     """
     local('%s/%s-py%s/bin/python setup.py %s' %
             (env.virtualenv_dir, env.project, version, command))

def test():
    """Runs all tests in different Python versions.
    """
    for version in env.versions:
        setup('test', version)

def clean():
    """Removes the build directory.
    """
    local('rm -fR build')

def build_docs():
    """Builds the documentation in PDF and HTML.
    """
    clean()
    setup('build_sphinx')
    setup('build_sphinx -b latex')
    local('make -C ' + env.sphinx_latex)

def zip_docs():
    """Creates a zip file with the complete documentation.
    """
    build_docs()
    local('cp %s/%s.pdf %s' %
            (env.sphinx_latex, env.project, env.sphinx_html))
    local('cd %s; mv html %s; zip -r9 %s.zip %s' %
            ((env.sphinx_output,) + (env.doc_output,)*3))

def register_pypi():
    """Register the current version on PyPI.
    """
    setup('register')

def deploy_src():
    """Deploy the source code to PyPI.
    """
    setup('sdist upload')

def deploy_eggs():
    """Upload Python Eggs to PyPI.
    """
    for version in env.versions:
        setup('bdist_egg upload', version)

def deploy_pypi():
    """Deploys all artifacts to PyPI.
    """
    test()
    register_pypi()
    deploy_src()
    deploy_eggs()

def deploy_website():
    """Deploys the documentation website.
    """
    zip_docs()
    put('%s/%s.zip' %
            (env.sphinx_output, env.doc_output), env.doc_folder)
    run('cd %s; rm -R %s; unzip %s.zip; rm %s.zip' %
            ((env.doc_folder,) + (env.doc_output,)*3))

def deploy():
    """Deploys the application to PyPI and updates the documentation website.
    """
    deploy_pypi()
    deploy_website()

def tag_new_version():
    """Updates the version number, pushing the changes and tagging afterwards.
    """
    # Checks if there are changed or untracked files
    git_status_file = 'build/git_status'
    local('git status > %s' % git_status_file, fail='ignore')
    if re.search(r'(Changed|Untracked)', file(git_status_file, 'r').read()):
        print 'There are changed or untracked files. Aborting...'
        return

    # Brings up the text editor with the files to be changed
    for f in env.new_version_files:
        local('%s %s' % (env.default_editor, f))

    # Asks for confirmation
    prompt('tag_proceed', 'You are about to commit and push the version '
                          'changes. Continue?', default='y')

    if env.tag_proceed.upper() != 'Y':
        print 'Aborting...'
        return

    # Commits and tags the new release
    from djangoflash import __version__
    local('git commit -am "Updated version number."; git push', fail='ignore')
    local('git tag -am "Tagged version %s." %s; git push --tags' %
            ((__version__,)*2), fail='ignore')
    local('git push --tags')


########NEW FILE########
__FILENAME__ = json_impl
# -*- coding: utf-8 -*-

"""This module provides a JSON-based codec implementation.
"""

try:
    import json 
except ImportError:
    from django.utils import simplejson as json

from djangoflash.codec import BaseCodec
from djangoflash.models import FlashScope


class CodecClass(BaseCodec):
    """JSON-based codec implementation.
    """
    def __init__(self):
        """Returns a new JSON-based codec.
        """
        BaseCodec.__init__(self)

    def encode(self, flash):
        """Encodes the given *flash* as a JSON string.
        """
        return json.dumps(flash.to_dict())

    def decode(self, encoded_flash):
        """Restores the *flash* from the given JSON string.
        """
        return FlashScope(json.loads(encoded_flash))

########NEW FILE########
__FILENAME__ = json_zlib_impl
# -*- coding: utf-8 -*-

"""This module provides a JSON-based codec implementation that uses the
:mod:`zlib` module to reduce the encoded flash footprint.
"""

import zlib

from djangoflash.codec.json_impl import CodecClass as JSONCodecClass
from djangoflash.models import FlashScope


class CodecClass(JSONCodecClass):
    """JSON/zlib-based codec implementation.
    """
    def __init__(self):
        """Returns a new JSON/zlib-based codec.
        """
        JSONCodecClass.__init__(self)

    def encode(self, flash):
        """Encodes the given *flash* as a zlib compressed JSON string.
        """
        return zlib.compress(JSONCodecClass.encode(self, flash))

    def decode(self, encoded_flash):
        """Restores the *flash* from the given zlib compressed JSON string.
        """
        return JSONCodecClass.decode(self, zlib.decompress(encoded_flash))

########NEW FILE########
__FILENAME__ = pickle_impl
# -*- coding: utf-8 -*-

"""This module provides a Pickle-based codec implementation.

.. warning::
   The use of this codec is not recommended since the
   `Pickle documentation <http://docs.python.org/library/pickle.html>`_ itself
   clearly states that it's not intended to be secure against erroneous or
   maliciously constructed data.
"""

try:
    import cPickle as pickle
except ImportError:
    import pickle

from djangoflash.codec import BaseCodec


class CodecClass(BaseCodec):
    """Pickle-based codec implementation.
    """
    def __init__(self):
        """Returns a new Pickle-based codec.
        """
        BaseCodec.__init__(self)

    def encode(self, flash):
        """Encodes the given *flash* as a Pickle dump string.
        """
        return pickle.dumps(flash, pickle.HIGHEST_PROTOCOL)

    def decode(self, encoded_flash):
        """Restores the *flash* from the given Pickle dump string.
        """
        return pickle.loads(encoded_flash)

########NEW FILE########
__FILENAME__ = context_processors
# -*- coding: utf-8 -*-

"""
This module provides the context processor that exposes
:class:`djangoflash.models.FlashScope` objects to view templates.

To plug this context processor to your Django project, edit your project's
``settings.py`` file as follows::

    TEMPLATE_CONTEXT_PROCESSORS = (
        'djangoflash.context_processors.flash',
    )


Doing this, the view templates will be able to access the *flash* contents
using the ``flash`` context variable.

.. warning::
   Your views should use the :class:`RequestContext` class to render the
   templates, otherwise the ``flash`` variable (along with *all* other
   variables provided by other context processors) won't be available to them.
   Please read the
   `Django docs <http://docs.djangoproject.com/en/dev/ref/templates/api/>`_
   for further instructions.

"""

from django.core.exceptions import SuspiciousOperation
from djangoflash.models import FlashScope


# Name of the variable used to keep FlashScope objects both as an attribute
# django.http.HttpRequest and the template context.
CONTEXT_VAR = 'flash'

def flash(request):
    """This context processor gets the :class:`FlashScope` object from the
    current *request* and adds it to the template context:
    
    .. code-block:: html+django
    
       <html>
           <head></head>
           <body>
               request.flash['message'] = {{ flash.message }}
           </body>
       </html>
    
    """
    flash_scope = None
    try:
        flash_scope = getattr(request, CONTEXT_VAR)
        if not isinstance(flash_scope, FlashScope):
            raise SuspiciousOperation('Invalid flash: %s' % repr(flash_scope))
    except AttributeError:
        # Exposes an empty flash when none is available
        flash_scope = FlashScope()
    return {CONTEXT_VAR: flash_scope}

########NEW FILE########
__FILENAME__ = decorators
# -*- coding: utf-8 -*-

"""This module provides decorators to simplify common tasks.
"""

from djangoflash.context_processors import CONTEXT_VAR


def keep_messages(*keys):
    """Prevents specific values from being removed during the processing of
    the decorated view. If this decorator is used with no args, the entire
    flash is preserved.
    """
    def _keep_messages(view_method):
        def _wrapped_view_method(request, *args, **kwargs):
            if hasattr(request, CONTEXT_VAR):
                flash = getattr(request, CONTEXT_VAR)
                flash.keep(*keys)
                return view_method(request, *args, **kwargs)
        return _wrapped_view_method

    if len(keys) == 1 and callable(keys[0]):
        view_method = keys[0]
        keys = []
        return _keep_messages(view_method)
    return _keep_messages

########NEW FILE########
__FILENAME__ = middleware
# -*- coding: utf-8 -*-

"""
This module provides the :class:`FlashMiddleware` class, which manages the
*flash* whenever a HTTP request hits the server.

To plug this middleware to your Django project, edit your project's
``settings.py`` file as follows::

    MIDDLEWARE_CLASSES = (
        'djangoflash.middleware.FlashMiddleware',
    )
"""

from urlparse import urlparse

from django.conf import settings
from django.core.exceptions import SuspiciousOperation
from django.core import urlresolvers
from django.views.static import serve

from djangoflash.context_processors import CONTEXT_VAR
from djangoflash.models import FlashScope
from djangoflash.storage import storage


# This middleware integrates gracefully with CommonMiddleware
_COMMON_MIDDLEWARE_CLASS = 'django.middleware.common.CommonMiddleware'


class FlashMiddleware(object):
    """This middleware uses the flash storage backend specified by the
    project's ``settings.py`` file in order to store and retrieve
    :class:`djangoflash.models.FlashScope` objects, being also responsible for
    expiring old flash-scoped objects.

    .. note::
       This class is designed to be used by the Django framework itself.
    """

    def process_request(self, request):
        """This method is called by the Django framework when a *request* hits
        the server.
        """
        flash = _get_flash_from_storage(request)
        if _should_update_flash(request):
            flash.update()

    def process_response(self, request, response):
        """This method is called by the Django framework when a *response* is
        sent back to the user.
        """
        flash = _get_flash_from_request(request)
        if flash:
            storage.set(flash, request, response)
        else:
            _get_flash_from_storage(request)

        return response


def _get_flash_from_storage(request):
    """Gets the flash from the storage, adds it to the given request and
    returns it. A new :class:`FlashScope` is used if the storage is empty.
    """
    flash = storage.get(request) or FlashScope()
    setattr(request, CONTEXT_VAR, flash)
    return flash

def _get_flash_from_request(request):
    """Returns the :class:`FlashScope` object from the given request. If it
    couldn't be found, returns None.
    """
    flash = None
    if hasattr(request, CONTEXT_VAR):
        flash = getattr(request, CONTEXT_VAR)
        if not isinstance(flash, FlashScope):
            raise SuspiciousOperation('Invalid flash: %s' % repr(flash))
    return flash

def _should_update_flash(request):
    """Returns True if the flash should be updated, False otherwise.
    """
    return not _is_trailing_slash_missing(request) and \
        not _is_request_to_serve(request)

def _is_request_to_serve(request):
    """Returns True if *request* resolves to the built-in ``serve`` view,
    False othersise.
    """
    # Are we running in debug mode?
    debug = getattr(settings, 'DEBUG', False)

    # Uses the value of DEBUG as default value to FLASH_IGNORE_MEDIA
    if getattr(settings, 'FLASH_IGNORE_MEDIA', debug):
        try:
            return urlresolvers.resolve(request.path_info)[0] == serve
        except urlresolvers.Resolver404:
            pass
    return False

def _is_trailing_slash_missing(request):
    """Returns True if the requested URL are elegible to be intercepted by the
    CommonMiddleware (if it's being used), which  issues a HttpRedirect when a
    trailing slash is missing. Returns False otherwise.
    """
    if _COMMON_MIDDLEWARE_CLASS in settings.MIDDLEWARE_CLASSES:
        path = request.path
        if getattr(settings, 'APPEND_SLASH', False) and not path.endswith('/'):
            if not _is_valid_path(path) and _is_valid_path('%s/' % path):
                return True
    return False

def _is_valid_path(path):
    """Returns True if *path* resolves against the default URL resolver,
    False otherwise.
    """
    try:
        urlresolvers.resolve(path)
        return True
    except urlresolvers.Resolver404:
        pass
    return False

########NEW FILE########
__FILENAME__ = models
# -*- coding: utf-8 -*-

"""This module provides the :class:`FlashScope` class, which provides a simple
way to pass temporary objects between views.
"""


# Map keys used when exporting/importing a FlashScope to/from a dict
_SESSION_KEY = '_session'
_USED_KEY    = '_used'


class FlashScope(object):
    """The purpose of this class is to implement the *flash*, which is a
    temporary storage mechanism that looks like a Python dictionary, so you
    can store values associated with keys and later retrieve them.
    
    It has one special property: by default, values stored into the *flash*
    during the processing of a request will be available during the processing
    of the immediately following request. Once that second request has been
    processed, those values are removed automatically from the storage.
    
    The following operations are supported by :class:`FlashScope` instances:

    .. describe:: len(flash)

       Returns the number of items in *flash*.

    .. describe:: flash[key]

       Returns the item of *flash* with key *key*.  Raises a :exc:`KeyError` if
       *key* is not found.

    .. describe:: flash[key] = value

       Sets ``flash[key]`` to *value*.

    .. describe:: del flash[key]

       Removes ``flash[key]``. Raises a :exc:`KeyError` if *key* is not found.

    .. describe:: key in flash

       Returns ``True`` if *flash* has a key *key*, else ``False``.

    .. describe:: key not in flash

       Equivalent to ``not key in flash``.

    .. describe:: flash.now[key] = value

       Sets ``flash[key]`` to *value* and marks it as *used*.

    .. describe:: flash.now(**items)

       Puts *items* into *flash* and marks those items  as *used*.

    .. describe:: flash.now.add(key, *values)

       Appends one or more *values* to *key* in *flash*.
    """

    def __init__(self, data=None):
        """Returns a new flash. If *data* is not provided, an empty flash is
        returned. Otherwise, the given *data* will be used to pre-populate
        this flash.
        """
        self.now = _ImmediateFlashScopeAdapter(self)
        if data:
            self._import_data(data)
        else:
            self._session, self._used = {}, {}

    def __contains__(self, key):
        """Returns ``True`` if there's a value under the given *key*.
        """
        return key in self._session

    def __getitem__(self, key):
        """Retrieves a value. Raises a :exc:`KeyError` if *key* does not exists.
        """
        return self._session[key]

    def __setitem__(self, key, value):
        """Puts a *value* under the given *key*.
        """
        self._session[key] = value
        self._update_status(key, is_used=False)

    def __delitem__(self, key):
        """Removes the value under the given *key*.
        """
        if key in self:
            del self._session[key]
        if key in self._used:
            del self._used[key]

    def __len__(self):
        """Returns the number of values inside this flash.
        """
        return len(self._session)

    def _update_status(self, key=None, is_used=True):
        """Updates the status of a given value (or all values if no *key*
        is given). The *is_used* argument tells if that value should be marked
        as *used* (should be discarded) or *unused* (should be kept).

        If a *used* value is being marked as *used* again, it is automatically
        removed from this flash.
        """
        if not key:
            for existing_key in self.keys():
                self._update_status(existing_key, is_used)
        else:
            if not is_used:
                if key in self._used:
                    del self._used[key]
            else:
                if key in self._used:
                    del self[key]
                else:
                    self._used[key] = None

    def keys(self):
        """Returns the list of keys.
        """
        return self._session.keys()

    def values(self):
        """Returns the list of values.
        """
        return self._session.values()

    def items(self):
        """Returns the list of items as tuples ``(key, value)``.
        """
        return self._session.items()

    def iterkeys(self):
        """Returns an iterator over the keys.
        """
        return self._session.iterkeys()

    def itervalues(self):
        """Returns an iterator over the values.
        """
        return self._session.itervalues()

    def iteritems(self):
        """Returns an iterator over the ``(key, value)`` items.
        """
        return self._session.iteritems()

    def get(self, key, default=None):
        """Gets the value under the given *key*. If the *key* is not found,
        *default* is returned instead.
        """
        return self._session.get(key, default)

    def pop(self, key, default=None):
        """Removes the specified *key* and returns the corresponding value. If
        *key* is not found, *default* is returned instead.
        """
        value = self._session.pop(key, default)
        if key in self._used:
            del self._used[key]
        return value

    def put(self, **kwargs):
        """Puts one or more values into this flash.
        """
        for key, value in kwargs.items():
            self[key] = value

    def add(self, key, *values):
        """Appends one or more *values* to *key* in this flash.
        """
        if key in self:
            current_value = self[key]
            if not isinstance(current_value, list):
                self[key] = [current_value]
                self[key].extend(values)
            else:
                current_value.extend(values)
                self[key] = current_value
        else:
            self[key] = list(values)

    def clear(self):
        """Removes all items from this flash.
        """
        self._session.clear()
        self._used.clear()

    def discard(self, *keys):
        """Marks the entire current flash or a single value as *used*, so when
        the next request hit the server, those values will be automatically
        removed from this flash by :class:`FlashMiddleware`.
        """
        self._update_status(*keys)

    def keep(self, *keys):
        """Prevents specific values from being removed on the next request.
        If this method is called with no args, the entire flash is preserved.
        """
        if not keys:
            self._update_status(is_used=False)
        else:
            for key in keys:
                self._update_status(key, is_used=False)

    def update(self):
        """Mark for removal entries that were kept, and delete unkept ones.

        .. note::
           This method is called automatically by
           :class:`djangoflash.middleware.FlashMiddleware` when a HTTP
           request hits the server, so never call this method yourself, unless
           you have a very good reason to do so.
        """
        self._update_status()

    def to_dict(self):
        """Exports this flash to a :class:`dict`.
        """
        return {_SESSION_KEY: self._session.copy(),
                _USED_KEY   : self._used.copy()}

    def _import_data(self, data):
        """Imports the given :class:`dict` to this flash.
        """
        if not isinstance(data, dict):
            raise TypeError('Expected a dictionary')

        if not _SESSION_KEY in data or not _USED_KEY in data:
            raise ValueError("Dictionary doesn't contains the expected data")

        if not isinstance(data[_SESSION_KEY], dict):
            raise ValueError("data['%s'] must be a dict." % _SESSION_KEY)

        if not isinstance(data[_USED_KEY], dict):
            raise ValueError("data['%s'] must be a dict." % _USED_KEY)

        self._session = data[_SESSION_KEY].copy()
        self._used    = data[_USED_KEY].copy()


class _ImmediateFlashScopeAdapter(object):
    """This class is used to add support for immediate flash values to an
    existing instance of :class:`FlashScope`. An immediate flash value is a
    value that is available to this request, but not to the next.
    """

    def __init__(self, delegate):
        """Returns a new flash wrapper which delegates certain calls to the
        given *delegate*.
        """
        self.delegate = delegate

    def __getitem__(self, key):
        """Retrieves a value. Raises a :exc:`KeyError` if *key* does
        not exists.
        """
        return self.delegate[key]

    def __contains__(self, key):
        """Returns ``True`` if there's a value under the given *key*.
        """
        return key in self.delegate

    def __setitem__(self, key, value):
        """Puts a *value* into this flash under the given *key*.
        """
        self.delegate[key] = value
        self.delegate.discard(key)

    def put(self, **kwargs):
        """Puts one or more values into this flash.
        """
        for key, value in kwargs.items():
            self[key] = value

    def add(self, key, *values):
        """Appends one or more values to a key in this flash.
        """
        self.delegate.add(key, *values)
        self.delegate.discard(key)

########NEW FILE########
__FILENAME__ = cookie
# -*- coding: utf-8 -*-

"""This module provides a cookie-based flash storage backend.

.. warning::
   The actual :class:`FlashScope` object is sent back to the user in a cookie.
   Although some encryption is performed to help spot when the flash data is
   modified by third-parties, this backend should be avoided when sensitive
   information is stored in the *flash*.

.. warning::
   Although in general user agents' cookie support should have no fixed limits,
   according to `RFC-2965 <http://www.ietf.org/rfc/rfc2965.txt>`_, section 5.3,
   all implementations must support at least 4096 bytes per cookie. So be
   careful about the amount of data you store in the *flash* when using this
   storage backend.
"""

from djangoflash.codec import codec


class FlashStorageClass(object):
    """Cookie-based flash storage backend.
    """

    def __init__(self):
        """Returns a new cookie-based flash storage backend.
        """
        self._key = '_djflash_cookie'

    def set(self, flash, request, response):
        """Stores the given :class:`FlashScope` object in a cookie.
        """
        if flash:
            response.set_cookie(self._key, codec.encode_and_sign(flash))
        elif self._key in request.COOKIES:
            response.delete_cookie(self._key)

    def get(self, request):
        """Returns :class:`FlashScope` object stored in a cookie.
        """
        data = request.COOKIES.get(self._key)
        if data:
            return codec.decode_signed(data)

########NEW FILE########
__FILENAME__ = session
# -*- coding: utf-8 -*-

"""This module provides a session-based flash storage backend.

Since this backend relies on the user's session, you need to include the
:class:`SessionMiddleware` class to the ``MIDDLEWARE_CLASSES`` section of your
project's ``settings.py`` file::

    MIDDLEWARE_CLASSES = (
        'django.contrib.sessions.middleware.SessionMiddleware',
        'djangoflash.middleware.FlashMiddleware',
    )

.. seealso::
  :ref:`configuration`
"""

class FlashStorageClass(object):
    """Session-based flash storage backend.
    """
    def __init__(self):
        """Returns a new session-based flash storage backend.
        """
        self._key = '_djflash_session'

    def set(self, flash, request, response):
        """Stores the given :class:`FlashScope` object in the session.
        """
        if hasattr(request, 'session'):
            if flash:
                request.session[self._key] = flash
            elif self._key in request.session:
                del request.session[self._key]

    def get(self, request):
        """Returns :class:`FlashScope` object stored in the session.
        """
        if hasattr(request, 'session') and self._key in request.session:
            return request.session[self._key]

########NEW FILE########
__FILENAME__ = codec
# -*- coding: utf-8 -*-

"""djangoflash.codec test cases.
"""

from unittest import TestCase

from django.core.exceptions import SuspiciousOperation

from djangoflash import codec
from djangoflash.codec import pickle_impl, json_impl, json_zlib_impl, BaseCodec
from djangoflash.models import FlashScope


class CodecTestCase(TestCase):
    """Tests methods used to parse flash storage URIs and create flash storage
    objects.
    """
    def test_get_pickle_codec_by_alias(self):
        """Codec: 'pickle' should resolve to Pickle-based codec.
        """
        codec_impl = codec.get_codec('pickle')
        self.assertTrue(isinstance(codec_impl, pickle_impl.CodecClass))

    def test_get_json_codec_by_alias(self):
        """Codec: 'json' should resolve to JSON-based codec.
        """
        codec_impl = codec.get_codec('json')
        self.assertTrue(isinstance(codec_impl, json_impl.CodecClass))

    def test_get_json_zlib_codec_by_alias(self):
        """Codec: 'json_zlib' should resolve to JSON/zlib-based codec.
        """
        codec_impl = codec.get_codec('json_zlib')
        self.assertTrue(isinstance(codec_impl, json_impl.CodecClass))
        self.assertTrue(isinstance(codec_impl, json_zlib_impl.CodecClass))

    def test_get_codec_by_module_name(self):
        """Codec: 'djangoflash.codec.json_impl' should resolve to JSON-based codec.
        """
        codec_impl = codec.get_codec('djangoflash.codec.json_impl')
        self.assertTrue(isinstance(codec_impl, json_impl.CodecClass))

    def test_get_codec_by_invalid_module_name(self):
        """Codec: Should raise an error when resolving a module name that doesn't exists.
        """
        operation = lambda: codec.get_codec('invalid.module.path')
        self.assertRaises(ImportError, operation)

    def test_get_codec_by_invalid_module(self):
        """Codec: Should raise an error when module doesn't provide a codec class.
        """
        operation = lambda: codec.get_codec('djangoflash.models')
        self.assertRaises(AttributeError, operation)


class BaseCodecTestCase(TestCase):
    """Tests the tampered checks and signing logic.
    """
    def setUp(self):
        """Creates a codec and a sample flash.
        """
        self.codec = json_impl.CodecClass()
        self.flash = FlashScope()
        self.flash['info'] = 'Info'
        self.flash.update()
        self.expected = 'eyJfc2Vzc2lvbiI6IHsiaW5mbyI6ICJJbmZvIn0sICJfdXNlZCI6' \
                        'IHsiaW5mbyI6IG51bGx9fWZk\nNDViYTljMmU3MWJlZjBjYjcxOW' \
                        'EwYjdlYzJlZjUx\n'

    def test_encode_and_sign(self):
        """Codec: BaseCodec should return an encoded and signed version of the flash.
        """
        encoded_and_signed = self.codec.encode_and_sign(self.flash)
        self.assertEqual(self.expected, encoded_and_signed)

    def test_decoded_signed(self):
        """Codec: BaseCodec should decode an encoded and signed version of the flash.
        """
        flash = self.codec.decode_signed(self.expected)
        self.assertEqual('Info', flash['info'])
        flash.update()
        self.assertFalse('info' in flash)

    def test_decoded_tampered(self):
        """Codec: BaseCodec should not decode a tampered version of the flash.
        """
        tampered = 'eyJfc2Vzc2lvbiI6IHsiaW6mbyI6ICJJbmZvIn0sICJfdXNlZCI6IHsia' \
                   'W5mbyI6IG51bGx9fWZk\nNDViYTljMmU3MWJlZjBjYjcxOWEwYjdlYzJl' \
                   'ZjUx\n'
        operation = lambda: self.codec.decode_signed(tampered)
        self.assertRaises(SuspiciousOperation, operation)


class PickleCodecTestCase(TestCase):
    """Tests the Pickle-based serialization codec implementation.
    """
    def setUp(self):
        """Creates a Pickle-based codec and a sample flash.
        """
        self.codec = pickle_impl.CodecClass()
        self.flash = FlashScope()
        self.flash['info'] = 'Info'
        self.flash.update()
        self.expected = '\x80\x02cdjangoflash.models\nFlashScope\nq\x01)\x81q' \
                        '\x02}q\x03(U\x03nowq\x04cdjangoflash.models\n_Immedi' \
                        'ateFlashScopeAdapter\nq\x05)\x81q\x06}q\x07U\x08dele' \
                        'gateq\x08h\x02sbU\x08_sessionq\t}q\nU\x04infoq\x0bU' \
                        '\x04Infoq\x0csU\x05_usedq\r}q\x0eh\x0bNsub.'

    def test_encode(self):
        """Codec: Pickle-based codec should return a Pickle dump of the flash.
        """
        self.assertEqual(self.expected, self.codec.encode(self.flash))

    def test_decode(self):
        """Codec: Pickle-based codec should restore the flash from a Pickle dump string.
        """
        flash = self.codec.decode(self.expected)
        self.assertEqual('Info', flash['info'])
        flash.update()
        self.assertFalse('info' in flash)


class JSONCodecTestCase(TestCase):
    """Tests the JSON-based serialization codec implementation.
    """
    def setUp(self):
        """Creates a JSON-based codec and a sample flash.
        """
        self.expected = '{"_session": {"info": "Info"}, ' \
                        '"_used": {"info": null}}'
        self.codec = json_impl.CodecClass()
        self.flash = FlashScope()
        self.flash['info'] = 'Info'
        self.flash.update()

    def test_encode(self):
        """Codec: JSON-based codec should return a JSON version of the flash.
        """
        self.assertEqual(self.expected, self.codec.encode(self.flash))

    def test_decode(self):
        """Codec: JSON-based codec should restore the flash from a JSON string.
        """
        flash = self.codec.decode(self.expected)
        self.assertEqual('Info', flash['info'])
        flash.update()
        self.assertFalse('info' in flash)


class JSONZlibCodecTestCase(TestCase):
    """Tests the JSON/zlib-based serialization codec implementation.
    """
    def setUp(self):
        """Creates a JSON\zlib-based codec and a sample flash.
        """
        self.expected = 'x\x9c\xabV\x8a/N-.\xce\xcc\xcfS\xb2R\xa8V\xca\xccK' \
                        '\xcb\x072\x94<At\xad\x8e\x82R|iqj\n\xb2T^iNNm-\x00' \
                        '\xf5\xa2\x12\x03'
        self.codec = json_zlib_impl.CodecClass()
        self.flash = FlashScope()
        self.flash['info'] = 'Info'
        self.flash.update()

    def test_encode(self):
        """Codec: JSON\zlib-based codec should return a zlib compressed JSON version of the flash.
        """
        self.assertEqual(self.expected, self.codec.encode(self.flash))

    def test_decode(self):
        """Codec: JSON\zlib-based codec should restore the flash from a zlib compressed JSON string.
        """
        flash = self.codec.decode(self.expected)
        self.assertEqual('Info', flash['info'])
        flash.update()
        self.assertFalse('info' in flash)

########NEW FILE########
__FILENAME__ = context_processors
# -*- coding: utf-8 -*-

"""djangoflash.context_processors test cases.
"""

from unittest import TestCase

from django.core.exceptions import SuspiciousOperation
from django.http import HttpRequest

from djangoflash.context_processors import CONTEXT_VAR, flash
from djangoflash.models import FlashScope


class FlashContextProcessorTestCase(TestCase):
    """Tests the context processor used to expose the flash to view templates.
    """
    def setUp(self):
        self.request = HttpRequest()
        self.scope = FlashScope();
        setattr(self.request, CONTEXT_VAR, self.scope);

    def test_expose_flash(self):
        """FlashContextProcessor: should expose the flash to view templates.
        """
        self.assertEqual(flash(self.request), {CONTEXT_VAR:self.scope})

    def test_expose_inexistent_flash(self):
        """FlashContextProcessor: should fail when there's no flash available.
        """
        delattr(self.request, CONTEXT_VAR)
        self.assertTrue(isinstance(flash(self.request)[CONTEXT_VAR], \
            FlashScope))

    def test_expose_invalid_flash(self):
        """FlashContextProcessor: should fail when exposing an invalid object as being the flash.
        """
        self.request.flash = 'Invalid object'
        self.assertRaises(SuspiciousOperation, flash, self.request)

########NEW FILE########
__FILENAME__ = decorators
# -*- coding: utf-8 -*-

"""djangoflash.decorators test cases.
"""

from unittest import TestCase

from django.http import HttpRequest

from djangoflash.decorators import keep_messages
from djangoflash.models import FlashScope


# Only exports test cases
__all__ = ['KeepMessagesDecoratorTestCase']


def view_method(request):
    """Function that simulates a Django view.
    """
    if hasattr(request, 'flash'):
        request.flash.update()
        return True
    return False


class KeepMessagesDecoratorTestCase(TestCase):
    """Tests the keep_messages decorator.
    """
    def setUp(self):
        """Create a request with an used message inside the flash.
        """
        self.request = HttpRequest()
        self.request.flash = self.flash = FlashScope()
        self.flash['message'] = 'Message'
        self.flash.update()

    def test_decorator_with_no_flash(self):
        """Decorators: keep_messages should not break when there's no flash scope attached to the request.
        """
        self.request = HttpRequest()
        view = keep_messages(view_method)
        self.assertFalse(view(self.request))

    def test_decorator_with_no_args(self):
        """Decorators: keep_messages with no args should avoid the removal of all flash-scoped values. 
        """
        view = keep_messages(view_method)
        self.assertEqual('Message', self.flash['message'])

        self.assertTrue(view(self.request))
        self.assertEqual('Message', self.flash['message'])

        view_method(self.request)
        self.assertFalse('message' in self.flash)

    def test_decorator_with_empty_args(self):
        """Decorators: keep_messages with empty args should avoid the removal of all flash-scoped values. 
        """
        view = keep_messages()(view_method)
        self.assertEqual('Message', self.flash['message'])

        self.assertTrue(view(self.request))
        self.assertEqual('Message', self.flash['message'])

        view_method(self.request)
        self.assertFalse('message' in self.flash)

    def test_decorator_with_args(self):
        """Decorators: keep_messages should avoid the removal of specific flash-scoped values.
        """
        view = keep_messages('message', 'another_message')(view_method)
        self.assertEqual('Message', self.flash['message'])

        self.assertTrue(view(self.request))
        self.assertEqual('Message', self.flash['message'])

        view_method(self.request)
        self.assertFalse('message' in self.flash)

    def test_decorator_with_invalid_arg(self):
        """Decorators: keep_messages should not avoid the removal of flash-scoped values.
        """
        view = keep_messages('another_message')(view_method)
        self.assertEqual('Message', self.flash['message'])

        self.assertTrue(view(self.request))
        self.assertFalse('message' in self.flash)

########NEW FILE########
__FILENAME__ = models
# -*- coding: utf-8 -*-

"""djangoflash.models test cases.
"""

from unittest import TestCase

from djangoflash.models import FlashScope, _SESSION_KEY, _USED_KEY


class FlashScopeTestCase(TestCase):
    """Tests the FlashScope object.
    """
    def setUp(self):
        """Create a FlashScope object to be used by the test methods.
        """
        self.flash = FlashScope()
        self.flash['info'] = 'Info'

    def test_restore(self):
        """FlashScope: Should restore the flash using a dict.
        """
        data = {_SESSION_KEY: {'info' : 'Info',
                               'error': 'Error'},
                _USED_KEY   : {'error': None}}
        self.flash = FlashScope(data)
        self.assertEqual(2, len(self.flash))
        self.assertEqual('Info', self.flash['info'])
        self.assertEqual('Error', self.flash['error'])
        self.flash.update()
        self.assertEqual('Info', self.flash['info'])
        self.assertFalse('error' in self.flash)

    def test_restore_immutability(self):
        """FlashScope: Should restore the flash using a shallow copy of a dict.
        """
        data = {_SESSION_KEY: {'info' : 'Info',
                               'error': 'Error'},
                _USED_KEY   : {'error': None}}
        self.flash = FlashScope(data)
        self.assertEqual('Info', self.flash['info'])
        del data[_SESSION_KEY]['info']
        self.assertTrue('info' in self.flash)

    def test_restore_with_invalid_type(self):
        """FlashScope: Should not restore the flash using an invalid object.
        """
        self.assertRaises(TypeError, lambda: FlashScope('invalid_data'))

    def test_restore_with_invalid_keys(self):
        """FlashScope: Should not restore the flash using a dict with invalid keys.
        """
        data = {_SESSION_KEY: None}
        self.assertRaises(ValueError, lambda: FlashScope(data))
        data = {_USED_KEY: None}
        self.assertRaises(ValueError, lambda: FlashScope(data))

    def test_restore_with_invalid_values(self):
        """FlashScope: Should not restore the flash using a dict with invalid values.
        """
        data = {_SESSION_KEY: {}, _USED_KEY: None}
        self.assertRaises(ValueError, lambda: FlashScope(data))
        data = {_SESSION_KEY: None, _USED_KEY: {}}
        self.assertRaises(ValueError, lambda: FlashScope(data))

    def test_contains(self):
        """FlashScope: "key in flash" syntax should be supported.
        """
        self.assertFalse('error' in self.flash)
        self.assertEqual('Info', self.flash['info'])

    def test_get_invalid_item(self):
        """FlashScope: Should raise KeyError if trying to get an invalid value.
        """
        self.assertRaises(KeyError, lambda: self.flash['error']);

    def test_set_item(self):
        """FlashScope: flash[key] = value" syntax should be supported.
        """
        self.flash['error'] = 'Error'
        self.assertEqual('Error', self.flash['error']);

    def test_del_item(self):
        """FlashScope: "del flash[key]" syntax should be supported.
        """
        self.assertEqual('Info', self.flash['info'])
        del self.flash['info']
        self.assertFalse('info' in self.flash)

    def test_clear(self):
        """FlashScope: flash.clear() should remove all items from the flash scope.
        """
        self.flash['error'] = 'Error'
        self.assertEqual(2, len(self.flash))
        self.flash.clear()
        self.assertEqual(0, len(self.flash))

    def test_len(self):
        """FlashScope: "len(flash)" syntax should be supported.
        """
        self.assertEqual(1, len(self.flash))

    def test_keys(self):
        """FlashScope: Should return the list of keys stored in the flash scope.
        """
        self.assertEqual(['info'], self.flash.keys())

    def test_values(self):
        """FlashScope: Should return the list of values stored in the flash scope.
        """
        self.assertEqual(['Info'], self.flash.values())

    def test_items(self):
        """FlashScope: Should return the list of items stored in the flash scope.
        """
        self.assertEqual([('info', 'Info')], self.flash.items())

    def test_iterkeys(self):
        """FlashScope: Should return an iterator to the keys stored in the flash scope.
        """
        iterator = self.flash.iterkeys()
        self.assertEqual('info', iterator.next())
        self.assertRaises(StopIteration, iterator.next)

    def test_itervalues(self):
        """FlashScope: Should return an iterator to the values stored in the flash scope.
        """
        iterator = self.flash.itervalues()
        self.assertEqual('Info', iterator.next())
        self.assertRaises(StopIteration, iterator.next)

    def test_iteritems(self):
        """FlashScope: Should return an iterator to the items stored in the flash scope.
        """
        iterator = self.flash.iteritems()
        self.assertEqual(('info', 'Info'), iterator.next())
        self.assertRaises(StopIteration, iterator.next)

    def test_add_with_existing_non_list_value(self):
        """FlashScope: Should append a value to a key even if the current value is not a list.
        """
        self.flash.add('info', 'Error')
        self.assertEqual(['Info', 'Error'], self.flash['info'])

    def test_add_with_existing_list_value(self):
        """FlashScope: Should append a value if the current value is a list.
        """
        self.flash['error'] = ['Error 1']
        self.flash.add('error', 'Error 2')
        self.assertEqual(['Error 1', 'Error 2'], self.flash['error'])

    def test_add_with_non_existing_value(self):
        """FlashScope: Should add a value even if the given key doesn't exists.
        """
        self.flash.add('error', 'Error')
        self.assertEqual(['Error'], self.flash['error'])

    def test_add_across_requests(self):
        """FlashScope: Should keep a key when a value is appended to it.
        """
        self.flash['error'] = 'Error 1'
        self.flash.update()
        self.flash.add('error', 'Error 2')
        self.assertEqual(['Error 1', 'Error 2'], self.flash['error'])
        self.flash.update()
        self.assertEqual(['Error 1', 'Error 2'], self.flash['error'])
        self.flash.update()
        self.assertFalse('error' in self.flash)

    def test_get(self):
        """FlashScope: Should return a default value if the given key doesn' exists.
        """
        self.assertEqual('Oops', self.flash.get('error', 'Oops'))
        self.assertEqual('Info', self.flash.get('info', 'Something'))
        self.assertEqual(None, self.flash.get('error'))

    def test_pop(self):
        """FlashScope: Should pop a value from the flash scope.
        """
        self.assertEqual(None, self.flash.pop('error'))
        self.assertEqual('Info', self.flash.pop('info'))
        self.assertFalse('info' in self.flash)

    def test_pop_used_value(self):
        """FlashScope: Should pop a used value from the flash scope.
        """
        self.flash.update()
        self.assertEqual('Info', self.flash.pop('info'))
        self.assertFalse('info' in self.flash)

    def test_put(self):
        """FlashScope: Should put several keys into the flash scope at the same time.
        """
        self.flash.put(warn='Warning', error='Error')
        self.assertEqual('Warning', self.flash['warn'])
        self.assertEqual('Error', self.flash['error'])

    def test_discard(self):
        """FlashScope: Should mark a value for removal.
        """
        self.flash.discard()
        self.flash.update()
        self.assertFalse('info' in self.flash)

    def test_keep(self):
        """FlashScope: Should avoid the removal of specific values.
        """
        self.flash.update()
        self.flash.keep('info')
        self.flash.update()
        self.assertEqual('Info', self.flash['info'])
        self.flash.update()
        self.assertFalse('info' in self.flash)

    def test_keep_all(self):
        """FlashScope: Should avoid the removal of all values.
        """
        self.flash.update()
        self.flash.keep()
        self.flash.update()
        self.assertEqual('Info', self.flash['info'])
        self.flash.update()
        self.assertFalse('info' in self.flash)

    def test_replace_used_value(self):
        """FlashScope: Should keep a key when its value is replaced.
        """
        self.flash.update()
        self.assertEqual('Info', self.flash['info'])
        self.flash['info'] = 'Error'
        self.assertEqual('Error', self.flash['info'])
        self.flash.update()
        self.assertEqual('Error', self.flash['info'])
        self.flash.update()
        self.assertFalse('info' in self.flash)

    def test_empty_to_dict(self):
        """FlashScope: Should export the flash data to a dict even if it's empty.
        """
        self.flash = FlashScope()
        expected_data = {_SESSION_KEY: {}, _USED_KEY:{}}
        data = self.flash.to_dict()
        self.assertEqual(expected_data, data)

    def test_to_dict(self):
        """FlashScope: Should export the flash data to a dict.
        """
        self.flash.update()
        self.flash['error'] = 'Error'
        expected_data = {_SESSION_KEY: {'info' : 'Info',
                                        'error': 'Error'},
                         _USED_KEY   : {'info' : None}}
        data = self.flash.to_dict()
        self.assertEqual(expected_data, data)

    def test_to_dict_immutability(self):
        """FlashScope: Should export a copy of the flash data as a dict.
        """
        data = self.flash.to_dict()
        del self.flash['info']
        self.assertEqual('Info', data[_SESSION_KEY]['info'])


class ImmediateFlashScope(TestCase):
    """Tests the ``Flashscope.now``.
    """
    def setUp(self):
        """Create a FlashScope object to be used by the test methods.
        """
        self.flash = FlashScope()
        self.flash.now['info'] = 'Info'

    def test_now(self):
        """FlashScope.now: "flash.now[key] = value" syntax should be supported.
        """
        self.assertEqual('Info', self.flash['info'])
        self.flash.update()
        self.assertFalse('info' in self.flash)

    def test_alternative_now(self):
        """FlashScope.now: Immediate values (flash.now) should be supported.
        """
        self.flash.now.put(error='Error')
        self.assertEqual('Error', self.flash['error'])
        self.flash.update()
        self.assertFalse('error' in self.flash)

    def test_contains(self):
        """FlashScope.now: "key in flash.now" syntax should be supported.
        """
        self.assertFalse('error' in self.flash.now)
        self.flash.now['error'] = 'Error'
        self.assertTrue('error' in self.flash.now)

    def test_get_invalid_item(self):
        """FlashScope.now: Should raise KeyError if trying to get an invalid item.
        """
        self.assertRaises(KeyError, lambda: self.flash.now['error']);

    def test_add_with_non_existing_value(self):
        """FlashScope.now: Should append an immediate value even if the given key doesn't exists.
        """
        self.flash.now.add('error', 'Error 1')
        self.flash.now.add('error', 'Error 2', 'Error 3')
        self.assertEqual(['Error 1', 'Error 2', 'Error 3'], self.flash['error'])

    def test_add_with_existing_non_list_value(self):
        """FlashScope.now: Should append immediate values to a key even if the current value is not a list.
        """
        self.flash.now.add('info', 'Error 1')
        self.flash.now.add('info', 'Error 2', 'Error 3')
        self.assertEqual(['Info', 'Error 1', 'Error 2', 'Error 3'], self.flash['info'])

    def test_add_with_existing_list_value(self):
        """FlashScope.now: Should append an immediate value if the current value is a list.
        """
        self.flash.now['error'] = ['Error 1']
        self.flash.now.add('error', 'Error 2')
        self.flash.now.add('error', 'Error 3', 'Error 4')
        self.assertEqual(['Error 1', 'Error 2', 'Error 3', 'Error 4'], self.flash['error'])


class MixedFlashScope(TestCase):
    """Tests mixing regular and immediate values.
    """
    def setUp(self):
        """Create a FlashScope object to be used by the test methods.
        """
        self.flash = FlashScope()

    def test_replace_with_immediate_value(self):
        """FlashScope: Should replace a regular value by an immediate value.
        """
        self.flash['info'] = 'Info'
        self.flash.update()
        self.assertEqual('Info', self.flash['info'])
        self.flash.now['info'] = 'Error'
        self.assertEqual('Error', self.flash['info'])
        self.flash.update()
        self.assertFalse('info' in self.flash)

    def test_replace_immediate_with_regular_value(self):
        """FlashScope: Should replace an immediate value with a regular value.
        """
        self.flash.now['info'] = 'Info'
        self.assertEqual('Info', self.flash['info'])
        self.flash['info'] = 'Error'
        self.flash.update()
        self.assertEqual('Error', self.flash['info'])
        self.flash.update()
        self.assertFalse('info' in self.flash)

    def test_add_immediate_with_existing_regular_value(self):
        """FlashScope.now: Should add an immediate value to a regular key, expiring on the current request.
        """
        self.flash['error'] = 'Error 1'
        self.flash.now.add('error', 'Error 2')
        self.assertEqual(['Error 1', 'Error 2'], self.flash['error'])
        self.flash.update()
        self.assertFalse('error' in self.flash)

    def test_add_immediate_with_existing_regular_list(self):
        """FlashScope.now: Should add an immediate value to a regular list, expiring on the current request.
        """
        self.flash['error'] = ['Error 1']
        self.flash.now.add('error', 'Error 2')
        self.assertEqual(['Error 1', 'Error 2'], self.flash['error'])
        self.flash.update()
        self.assertFalse('error' in self.flash)

    def test_add_regular_with_existing_immediate_value(self):
        """FlashScope: Should add a regular value to an immediate key, expiring on the next request.
        """
        self.flash.now['error'] = 'Error 1'
        self.flash.add('error', 'Error 2')
        self.assertEqual(['Error 1', 'Error 2'], self.flash['error'])
        self.flash.update()
        self.assertEqual(['Error 1', 'Error 2'], self.flash['error'])
        self.flash.update()
        self.assertFalse('error' in self.flash)

    def test_add_regular_with_existing_immediate_list(self):
        """FlashScope: Should add a regular value to an immediate list, expiring on the next request.
        """
        self.flash.now['error'] = ['Error 1']
        self.flash.add('error', 'Error 2')
        self.assertEqual(['Error 1', 'Error 2'], self.flash['error'])
        self.flash.update()
        self.assertEqual(['Error 1', 'Error 2'], self.flash['error'])
        self.flash.update()
        self.assertFalse('error' in self.flash)

########NEW FILE########
__FILENAME__ = storage
# -*- coding: utf-8 -*-

"""djangoflash.storage test cases.
"""

from unittest import TestCase

from django.http import HttpRequest, HttpResponse

from djangoflash.models import FlashScope
from djangoflash import storage
from djangoflash.storage import session, cookie


class StorageTestCase(TestCase):
    """Tests methods used to parse flash storage URIs and create flash storage
    objects.
    """
    def test_get_session_storage_by_alias(self):
        """Storage: 'session' should resolve to session flash storage.
        """
        storage_impl = storage.get_storage('session')
        self.assertTrue(isinstance(storage_impl, session.FlashStorageClass))

    def test_get_cookie_storage_by_alias(self):
        """Storage: 'cookie' should resolve to cookie flash storage.
        """
        storage_impl = storage.get_storage('cookie')
        self.assertTrue(isinstance(storage_impl, cookie.FlashStorageClass))

    def test_get_storage_by_module_name(self):
        """Storage: 'djangoflash.storage.cookie' should resolve to cookie flash storage.
        """
        storage_impl = storage.get_storage('djangoflash.storage.cookie')
        self.assertTrue(isinstance(storage_impl, cookie.FlashStorageClass))

    def test_get_storage_by_invalid_module_name(self):
        """Storage: Should raise an error when resolving a module name that doesn't exists.
        """
        operation = lambda: storage.get_storage('invalid.module.path')
        self.assertRaises(ImportError, operation)

    def test_get_storage_by_invalid_module(self):
        """Storage: Should raise an error when module doesn't provide a storage class.
        """
        operation = lambda: storage.get_storage('djangoflash.models')
        self.assertRaises(AttributeError, operation)


class SessionFlashStorageTestCase(TestCase):
    """Tests the session-based flash storage class.
    """
    def setUp(self):
        """Creates a cookie-based flash storage for testing.
        """
        self.request = HttpRequest()
        self.request.session = {}
        self.response = HttpResponse('')
        self.flash = FlashScope()
        self.storage = session.FlashStorageClass()

    def _get_flash(self):
        """Returns the flash contents from the session.
        """
        return self.request.session[self.storage._key]

    def test_set_null_object(self):
        """SessionStorage: should not store null values.
        """
        self.storage.set(None, self.request, self.response)
        self.assertEqual(0, len(self.request.session))

    def test_set_empty_object(self):
        """SessionStorage: should not store empty objects.
        """
        self.storage.set(self.flash, self.request, self.response)
        self.assertEqual(0, len(self.request.session))

    def test_clear_storage(self):
        """SessionStorage: should remove flash contents from the session.
        """
        self.flash['message'] = 'Message'
        self.storage.set(self.flash, self.request, self.response)
        self.assertEqual('Message', self._get_flash()['message'])

        # The flash should be completely removed from the session
        del self.flash['message']
        self.storage.set(self.flash, self.request, self.response)
        self.assertRaises(KeyError, self._get_flash)

    def test_set_object(self):
        """Session storage: should store valid objects.
        """
        self.flash['message'] = 'Message'
        self.storage.set(self.flash, self.request, self.response)
        self.assertEqual(1, len(self.request.session))

    def test_get_empty(self):
        """SessionStorage: should return nothing when empty.
        """
        self.assertEqual(None, self.storage.get(self.request))

    def test_get(self):
        """SessionStorage: should return the stored object.
        """
        self.flash['message'] = 'Message'
        self.storage.set(self.flash, self.request, self.response)
        self.assertEqual('Message', self.storage.get(self.request)['message'])


class CookieFlashStorageTestCase(TestCase):
    """Tests the cookie-based flash storage class.
    """
    def setUp(self):
        """Creates a cookie-based flash storage for testing.
        """
        self.request = HttpRequest()
        self.response = HttpResponse('')
        self.flash = FlashScope()
        self.storage = cookie.FlashStorageClass()

    def _transfer_cookies_from_response_to_request(self):
        """Transfers the cookies set in the response to the request.
        """
        for key, cookie in self.response.cookies.items():
            self.request.COOKIES[key] = cookie.value

    def _get_cookie(self):
        """Returns the cookie used to store the flash contents.
        """
        return self.response.cookies[self.storage._key]

    def test_set_null_object(self):
        """CookieStorage: should not store null values.
        """
        self.storage.set(None, self.request, self.response)
        self.assertEqual(0, len(self.response.cookies))

    def test_set_empty_object(self):
        """CookieStorage: should not store an empty object.
        """
        self.storage.set(self.flash, self.request, self.response)
        self.assertEqual(0, len(self.response.cookies))

    def test_clear_storage(self):
        """CookieStorage: should set an empty/expired cookie.
        """
        self.flash['message'] = 'Message'
        self.storage.set(self.flash, self.request, self.response)

        # Simulates a request-response cycle
        self._transfer_cookies_from_response_to_request()
        del self.flash['message']

        # Cookie should be empty/expired
        self.storage.set(self.flash, self.request, self.response)
        self.assertEqual(0, self._get_cookie()['max-age'])
        self.assert_(not self._get_cookie().value)

    def test_set_object(self):
        """CookieStorage: should store valid objects.
        """
        self.flash['message'] = 'Message'
        self.storage.set(self.flash, self.request, self.response)
        self.assertEqual(1, len(self.response.cookies))

    def test_get_empty(self):
        """CookieStorage: should return nothing when empty.
        """
        self.assertEqual(None, self.storage.get(self.request))

    def test_get(self):
        """CookieStorage: should return the stored object.
        """
        self.flash['message'] = 'Message'
        self.storage.set(self.flash, self.request, self.response)
        self.assertEqual(None, self.storage.get(self.request))

        # Simulates a request-response cycle
        self._transfer_cookies_from_response_to_request()
        self.assertEqual('Message', self.storage.get(self.request)['message'])

########NEW FILE########
__FILENAME__ = suite
# -*- coding: utf-8 -*-

"""Project's test suite.
"""

import sys

# Adds the Django test project to system path
from django.core.management import setup_environ
import djangoflash.tests.testproj.settings as project_settings
sys.path.insert(0, setup_environ(project_settings))

# Imports unit tests
from context_processors import *
from decorators import *
from models import *
from storage import *
from codec import *

# Now, the integration tests, which depends on SQLite
has_sqlite = True

try:
    import sqlite3
except ImportError:
    try:
        import pysqlite2
        has_sqlite = True
    except ImportError:
        pass

# Runs the integration tests if at least one module was found
if has_sqlite:
    # Bootstraps integration environment
    import django.test.utils as test_utils
    from django.db import connection
    test_utils.setup_test_environment()
    connection.creation.create_test_db()

    # Imports integration tests
    from testproj.app.tests import *
else:
    print >> sys.stderr, 'Integration: module "sqlite3" (or "pysqlite2") is required... SKIPPED'

########NEW FILE########
__FILENAME__ = models
# -*- coding: utf-8 -*-

"""Create your models here.
"""

########NEW FILE########
__FILENAME__ = tests
# -*- coding: utf-8 -*-

"""Integration test cases.
"""

from django.conf import settings
from django.core.exceptions import SuspiciousOperation
from django.core.urlresolvers import reverse
from django.test import TestCase

from djangoflash.context_processors import CONTEXT_VAR
from djangoflash.middleware import FlashScope

from testproj.app import views


class IntegrationTestCase(TestCase):
    """Test the middleware and the context processors working within a real
    Django application.
    """
    def _flash(self):
        """Shortcut to get the flash from the view context.
        """
        return self.response.context[CONTEXT_VAR]

    def test_default_lifecycle(self):
        """Integration: a value should be automatically removed from the flash.
        """
        self.response = self.client.get(reverse(views.set_flash_var))
        self.assertEqual('Message', self._flash()['message'])

        self.response = self.client.get(reverse(views.render_template))
        self.assertEqual('Message', self._flash()['message'])

        # Flash value will be removed when this request hits the app
        self.response = self.client.get(reverse(views.render_template))
        self.assertFalse('message' in self._flash())

    def test_value_in_template(self):
        """Integration: a value should be accessible by the templating system.
        """
        def _assert_content(content, exists=True):
            if exists:
                matcher = self.assertTrue
            else:
                matcher = self.assertFalse
            matcher(self.response.content.find(content) > 0)

        self.response = self.client.get(reverse(views.set_flash_var))
        _assert_content('Flash context: Message', exists=True)

        self.response = self.client.get(reverse(views.render_template))
        _assert_content('Flash context: Message', exists=True)

        # Flash value will be removed when this request hits the app
        self.response = self.client.get(reverse(views.render_template))
        _assert_content('Flash context: Message', exists=False)

    def test_keep_lifecycle(self):
        """Integration: a value shouldn't be removed from the flash when it is kept.
        """
        self.response = self.client.get(reverse(views.set_flash_var))
        self.assertEqual('Message', self._flash()['message'])

        self.response = self.client.get(reverse(views.keep_var))
        self.assertEqual('Message', self._flash()['message'])

        # Flash value won't be removed now because it was explicitely kept
        self.response = self.client.get(reverse(views.render_template))
        self.assertEqual('Message', self._flash()['message'])

        # Flash value will be removed when this request hits the app
        self.response = self.client.get(reverse(views.render_template))
        self.assertFalse('message' in self._flash())

    def test_keep_decorator(self):
        """Integration: keep_messages decorator should behave exactly like keep.
        """
        self.response = self.client.get(reverse(views.set_flash_var))
        self.assertEqual('Message', self._flash()['message'])

        self.response = self.client.get(reverse(views.keep_var_decorator))
        self.assertEqual('Message', self._flash()['message'])

        # Flash value won't be removed now because it was explicitely kept
        self.response = self.client.get(reverse(views.render_template))
        self.assertEqual('Message', self._flash()['message'])

        # Flash value will be removed when this request hits the app
        self.response = self.client.get(reverse(views.render_template))
        self.assertFalse('message' in self._flash())

    def test_now_lifecycle(self):
        """Integration: an immediate value shouldn't survive the next request.
        """
        self.response = self.client.get(reverse(views.set_now_var))
        self.assertEqual('Message', self._flash()['message'])

        # Flash value will be removed when this request hits the app
        self.response = self.client.get(reverse(views.render_template))
        self.assertFalse('message' in self._flash())

    def test_discard_lifecycle(self):
        """Integration: a discarded value shouldn't survive to the next request.
        """
        self.response = self.client.get(reverse(views.discard_var))
        self.assertEqual('Message', self._flash()['message'])

        # Flash value will be removed when this request hits the app
        self.response = self.client.get(reverse(views.render_template))
        self.assertFalse('message' in self._flash())

    def test_multiple_variables_lifecycle(self):
        """Integration: the flash should control several values independently.
        """
        self.response = self.client.get(reverse(views.set_flash_var))
        self.assertEqual('Message', self._flash()['message'])

        self.response = self.client.get(reverse(views.set_another_flash_var))
        self.assertEqual('Message', self._flash()['message'])
        self.assertEqual('Another message', self._flash()['anotherMessage'])

        # 'message' will be removed when this request hits the app
        self.response = self.client.get(reverse(views.render_template))
        self.assertFalse('message' in self._flash())
        self.assertEqual('Another message', self._flash()['anotherMessage'])

        # 'anotherMessage' will be removed when this request hits the app
        self.response = self.client.get(reverse(views.render_template))
        self.assertFalse('message' in self._flash())
        self.assertFalse('anotherMessage' in self._flash())

    def test_remove_flash(self):
        """Integration: an empty flash should be provided when none is available.
        """
        self.response = self.client.get(reverse(views.remove_flash))
        self.assertTrue(isinstance(self._flash(), FlashScope))

    def test_replace_flash_with_invalid_object(self):
        """Integration: an exception should be raised when exposing an invalid object as being the flash.
        """
        self.assertRaises(SuspiciousOperation, self.client.get, reverse(views.replace_flash))

    def test_request_to_serve_view_without_ignore(self):
        """Integration: request to static resources should trigger the flash update.
        """
        # Requests to static resources should trigger the flash update
        settings.FLASH_IGNORE_MEDIA = False

        self.response = self.client.get(reverse(views.set_flash_var))
        self.assertEqual('Message', self._flash()['message'])

        self.response = self.client.get(settings.MEDIA_URL + 'test.css')
        self.assertEqual(200, self.response.status_code)

        # Flash value will be removed when this request hits the app
        self.response = self.client.get(reverse(views.render_template))
        self.assertFalse('message' in self._flash())

    def test_request_to_serve_view_with_ignore(self):
        """Integration: request to static resources should not trigger the flash update, if properly configured.
        """
        # Requests to static resources should not trigger the flash update
        settings.FLASH_IGNORE_MEDIA = True

        self.response = self.client.get(reverse(views.set_flash_var))
        self.assertEqual('Message', self._flash()['message'])

        self.response = self.client.get(settings.MEDIA_URL + 'test.css')
        self.assertEqual(200, self.response.status_code)

        self.response = self.client.get(reverse(views.render_template))
        self.assertEqual('Message', self._flash()['message'])

        # Flash value will be removed when this request hits the app
        self.response = self.client.get(reverse(views.render_template))
        self.assertFalse('message' in self._flash())

    def test_request_to_serve_view_with_default_value(self):
        """Integration: request to static resources should not trigger the flash update in debug mode.
        """
        # Deletes the setting, let the middleware figure out the default value
        if hasattr(settings, 'FLASH_IGNORE_MEDIA'):
            del settings.FLASH_IGNORE_MEDIA

        self.response = self.client.get(reverse(views.set_flash_var))
        self.assertEqual('Message', self._flash()['message'])

        self.response = self.client.get(settings.MEDIA_URL + 'test.css')
        self.assertEqual(200, self.response.status_code)

        self.response = self.client.get(reverse(views.render_template))
        self.assertEqual('Message', self._flash()['message'])

        # Flash value will be removed when this request hits the app
        self.response = self.client.get(reverse(views.render_template))
        self.assertFalse('message' in self._flash())

    def test_flash_with_common_middleware_and_missing_trailing_slash(self):
        """Integration: missing trailing slash in URL should not affect the flash lifecycle when using the CommonMiddleware.
        """
        self.response = self.client.get(reverse(views.set_flash_var))
        self.assertEqual('Message', self._flash()['message'])

        # This request should be intercepted by CommonMiddleware and the flash should not be updated
        self.response = self.client.get('/default')

        self.response = self.client.get(reverse(views.render_template))
        self.assertEqual('Message', self._flash()['message'])

        # Flash value will be removed when this request hits the app
        self.response = self.client.get(reverse(views.render_template))
        self.assertFalse('message' in self._flash())

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *

from testproj.app import views

urlpatterns = patterns('',
    (r'^default/$', views.render_template),
    (r'^set_flash_var/$', views.set_flash_var),
    (r'^set_another_flash_var/$', views.set_another_flash_var),
    (r'^set_now_var/$', views.set_now_var),
    (r'^keep_var/$', views.keep_var),
    (r'^keep_var_decorator/$', views.keep_var_decorator),
    (r'^discard_var/$', views.discard_var),
    (r'^replace_flash/$', views.replace_flash),
    (r'^remove_flash/$', views.remove_flash),
)

########NEW FILE########
__FILENAME__ = views
# Create your views here.

from django.core.urlresolvers import reverse
from django.http import HttpResponse, HttpResponseRedirect
from django.shortcuts import render_to_response
from django.template import RequestContext

from djangoflash.decorators import keep_messages


def render_template(request):
    return render_to_response('simple.html', \
        context_instance=RequestContext(request))

def set_flash_var(request):
    request.flash['message'] = 'Message'
    return render_template(request)

def set_another_flash_var(request):
    request.flash['anotherMessage'] = 'Another message'
    return render_template(request)

def set_now_var(request):
    request.flash.now['message'] = 'Message'
    return render_template(request)

def keep_var(request):
    request.flash.keep('message')
    return render_template(request)

@keep_messages('message')
def keep_var_decorator(request):
    return render_template(request)

def discard_var(request):
    # Should behave the same way 'flash.now' does
    request.flash['message'] = 'Message'
    request.flash.discard('message')
    return render_template(request)

def replace_flash(request):
    request.flash = "Replacing the flash with a string"
    return render_template(request)

def remove_flash(request):
    # I've seen this happen, I'm not kidding... :)
    del request.flash
    return render_template(request)

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
from django.core.management import execute_manager
try:
    import settings # Assumed to be in the same directory.
except ImportError:
    import sys
    sys.stderr.write("Error: Can't find the file 'settings.py' in the directory containing %r. It appears you've customized things.\nYou'll have to run django-admin.py, passing it your settings module.\n(If the file settings.py does indeed exist, it's causing an ImportError somehow.)\n" % __file__)
    sys.exit(1)

if __name__ == "__main__":
    execute_manager(settings)

########NEW FILE########
__FILENAME__ = settings
# Django settings for testproj project.

import os

DEBUG = True
TEMPLATE_DEBUG = DEBUG

# For Django < 1.2
DATABASE_ENGINE = 'sqlite3'
DATABASE_NAME = 'db'

# For Django >= 1.2
DATABASES = {
    'default': {
        'ENGINE':'django.db.backends.sqlite3',
        'NAME': 'db'
    }
}

SECRET_KEY = 'g9b@q$)=^xd2g@-7pg=j=h3*8+xd#hgn-9je@iq5_m#seg&d1y'

MEDIA_URL = '/media/'
ADMIN_MEDIA_PREFIX = '/admin/'
MEDIA_ROOT = os.path.normpath(os.path.dirname(__file__) + '/media/')

TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.load_template_source',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'djangoflash.middleware.FlashMiddleware',
)

TEMPLATE_CONTEXT_PROCESSORS = (
    'djangoflash.context_processors.flash',
    'django.core.context_processors.media',
)

ROOT_URLCONF = 'testproj.urls'

TEMPLATE_DIRS = (
    os.path.normpath(os.path.dirname(__file__) + '/templates'),
)

INSTALLED_APPS = (
    'app',
    'django.contrib.sessions',
)


# Settings introduced by Django-Flash:

# FLASH_IGNORE_MEDIA = DEBUG     # True, False
# FLASH_STORAGE      = 'session' # 'session, 'cookie', 'path.to.module'
# FLASH_CODEC        = 'json'    # 'json', 'json_zlib', 'pickle', 'path.to.module'

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *

from django.conf import settings

urlpatterns = patterns('',
    (r'', include('testproj.app.urls')),

    # django-flash needs to ignore requests to static files, in development mode
    (r'^media/(?P<path>.*)$', 'django.views.static.serve', \
          {'document_root': settings.MEDIA_ROOT, 'show_indexes': True}),
)

########NEW FILE########
__FILENAME__ = views
# -*- coding: utf-8 -*-

"""Django-Flash doesn't provide any Django views.
"""

########NEW FILE########
