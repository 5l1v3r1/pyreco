__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Django Suit documentation build configuration file, created by
# sphinx-quickstart on Tue Feb  5 23:35:55 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

try:
    import sphinx_rtd_theme

    html_theme = 'sphinx_rtd_theme'
    html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]
except ImportError:
    html_theme = 'default'

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Django Suit'
copyright = u'2013, Kaspars Sprogis (darklow)'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.2.8'
# The full version, including alpha/beta/rc tags.
release = '0.2.8'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
# html_theme = 'sphinx_rtd_theme'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []
# html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'DjangoSuitdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
    # The paper size ('letterpaper' or 'a4paper').
    #'papersize': 'letterpaper',

    # The font size ('10pt', '11pt' or '12pt').
    #'pointsize': '10pt',

    # Additional stuff for the LaTeX preamble.
    #'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
    ('index', 'DjangoSuit.tex', u'Django Suit Documentation',
     u'Kaspars Sprogis (darklow)', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'djangosuit', u'Django Suit Documentation',
     [u'Kaspars Sprogis (darklow)'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
    ('index', 'DjangoSuit', u'Django Suit Documentation',
     u'Kaspars Sprogis (darklow)', 'DjangoSuit',
     'One line description of project.',
     'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
import os
import sys

if __name__ == "__main__":
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "suit.tests.settings")

    from django.core.management import execute_from_command_line

    execute_from_command_line(sys.argv)

########NEW FILE########
__FILENAME__ = admin
import copy
from django.conf import settings
from django.contrib.admin import ModelAdmin
from django.contrib.admin.views.main import ChangeList
from django.contrib.contenttypes import generic
from django.forms import ModelForm
from django.contrib import admin
from django.db import models
from suit.widgets import NumberInput, SuitSplitDateTimeWidget


class SortableModelAdminBase(object):
    """
    Base class for SortableTabularInline and SortableModelAdmin
    """
    sortable = 'order'

    class Media:
        js = ('suit/js/sortables.js',)


class SortableListForm(ModelForm):
    """
    Just Meta holder class
    """

    class Meta:
        widgets = {
            'order': NumberInput(
                attrs={'class': 'hide input-mini suit-sortable'})
        }


class SortableChangeList(ChangeList):
    """
    Class that forces ordering by sortable param only
    """

    def get_ordering(self, request, queryset):
        return [self.model_admin.sortable, '-' + self.model._meta.pk.name]


class SortableTabularInlineBase(SortableModelAdminBase):
    """
    Sortable tabular inline
    """

    def __init__(self, *args, **kwargs):
        super(SortableTabularInlineBase, self).__init__(*args, **kwargs)

        self.ordering = (self.sortable,)
        self.fields = self.fields or []
        if self.fields and self.sortable not in self.fields:
            self.fields = list(self.fields) + [self.sortable]

    def formfield_for_dbfield(self, db_field, **kwargs):
        if db_field.name == self.sortable:
            kwargs['widget'] = SortableListForm.Meta.widgets['order']
        return super(SortableTabularInlineBase, self).formfield_for_dbfield(
            db_field, **kwargs)


class SortableTabularInline(SortableTabularInlineBase, admin.TabularInline):
    pass


class SortableGenericTabularInline(SortableTabularInlineBase,
                                   generic.GenericTabularInline):
    pass


class SortableStackedInlineBase(SortableModelAdminBase):
    """
    Sortable stacked inline
    """

    def get_fieldsets(self, *args, **kwargs):
        """
        Iterate all fieldsets and make sure sortable is in the first fieldset
        Remove sortable from every other fieldset, if by some reason someone
        has added it
        """
        fieldsets = super(SortableStackedInlineBase, self).get_fieldsets(
            *args, **kwargs)

        sortable_added = False
        for fieldset in fieldsets:
            for line in fieldset:
                if not line or not isinstance(line, dict):
                    continue

                fields = line.get('fields')
                if self.sortable in fields:
                    fields.remove(self.sortable)

                # Add sortable field always as first
                if not sortable_added:
                    fields.insert(0, self.sortable)
                    sortable_added = True
                    break

        return fieldsets

    def formfield_for_dbfield(self, db_field, **kwargs):
        if db_field.name == self.sortable:
            kwargs['widget'] = copy.deepcopy(
                SortableListForm.Meta.widgets['order'])
            kwargs['widget'].attrs['class'] += ' suit-sortable-stacked'
            kwargs['widget'].attrs['rowclass'] = ' suit-sortable-stacked-row'
        return super(SortableStackedInlineBase, self).formfield_for_dbfield(
            db_field, **kwargs)


class SortableStackedInline(SortableStackedInlineBase, admin.StackedInline):
    pass


class SortableGenericStackedInline(SortableStackedInlineBase,
                                   generic.GenericStackedInline):
    pass


class SortableModelAdmin(SortableModelAdminBase, ModelAdmin):
    """
    Sortable tabular inline
    """
    list_per_page = 500

    def __init__(self, *args, **kwargs):
        super(SortableModelAdmin, self).__init__(*args, **kwargs)

        self.ordering = (self.sortable,)
        if self.list_display and self.sortable not in self.list_display:
            self.list_display = list(self.list_display) + [self.sortable]

        self.list_editable = self.list_editable or []
        if self.sortable not in self.list_editable:
            self.list_editable = list(self.list_editable) + [self.sortable]

        self.exclude = self.exclude or []
        if self.sortable not in self.exclude:
            self.exclude = list(self.exclude) + [self.sortable]

    def merge_form_meta(self, form):
        """
        Prepare Meta class with order field widget
        """
        if not getattr(form, 'Meta', None):
            form.Meta = SortableListForm.Meta
        if not getattr(form.Meta, 'widgets', None):
            form.Meta.widgets = {}
        form.Meta.widgets[self.sortable] = SortableListForm.Meta.widgets[
            'order']

    def get_changelist_form(self, request, **kwargs):
        form = super(SortableModelAdmin, self).get_changelist_form(request,
                                                                   **kwargs)
        self.merge_form_meta(form)
        return form

    def get_changelist(self, request, **kwargs):
        return SortableChangeList

    def save_model(self, request, obj, form, change):
        if not obj.pk:
            max_order = obj.__class__.objects.aggregate(
                models.Max(self.sortable))
            try:
                next_order = max_order['%s__max' % self.sortable] + 1
            except TypeError:
                next_order = 1
            setattr(obj, self.sortable, next_order)
        super(SortableModelAdmin, self).save_model(request, obj, form, change)


# Quite aggressive detection and intrusion into Django CMS
# Didn't found any other solutions though
if 'cms' in settings.INSTALLED_APPS:
    try:
        from cms.admin.forms import PageForm

        PageForm.Meta.widgets = {
            'publication_date': SuitSplitDateTimeWidget,
            'publication_end_date': SuitSplitDateTimeWidget,
        }
    except ImportError:
        pass


########NEW FILE########
__FILENAME__ = config
from django.contrib.admin import ModelAdmin
from django.conf import settings
from . import VERSION


def default_config():
    return {
        'VERSION': VERSION,

        # configurable
        'ADMIN_NAME': 'Django Suit',
        'HEADER_DATE_FORMAT': 'l, jS F Y',
        'HEADER_TIME_FORMAT': 'H:i',

        # form
        'SHOW_REQUIRED_ASTERISK': True,
        'CONFIRM_UNSAVED_CHANGES': True,

        # menu
        'SEARCH_URL': '/admin/auth/user/',
        'MENU_OPEN_FIRST_CHILD': True,
        'MENU_ICONS': {
            'auth': 'icon-lock',
            'sites': 'icon-leaf',
        },
        # 'MENU_EXCLUDE': ('auth.group',),
        # 'MENU': (
        #     'sites',
        #     {'app': 'auth', 'icon':'icon-lock', 'models': ('user', 'group')},
        #     {'label': 'Settings', 'icon':'icon-cog', 'models': ('auth.user', 'auth.group')},
        #     {'label': 'Support', 'icon':'icon-question-sign', 'url': '/support/'},
        # ),

        # misc
        'LIST_PER_PAGE': 20
    }


def get_config(param=None):
    config_key = 'SUIT_CONFIG'
    if hasattr(settings, config_key):
        config = getattr(settings, config_key, {})
    else:
        config = default_config()
    if param:
        value = config.get(param)
        if value is None:
            value = default_config().get(param)
        return value
    return config

# Reverse default actions position
ModelAdmin.actions_on_top = False
ModelAdmin.actions_on_bottom = True

# Set global list_per_page
ModelAdmin.list_per_page = get_config('LIST_PER_PAGE')

def setup_filer():
    from suit.widgets import AutosizedTextarea
    from filer.admin.imageadmin import ImageAdminForm
    from filer.admin.fileadmin import FileAdminChangeFrom

    def ensure_meta_widgets(meta_cls):
        if not hasattr(meta_cls, 'widgets'):
            meta_cls.widgets = {}

        meta_cls.widgets['description'] = AutosizedTextarea

    ensure_meta_widgets(ImageAdminForm.Meta)
    ensure_meta_widgets(FileAdminChangeFrom.Meta)


if 'filer' in settings.INSTALLED_APPS:
    setup_filer()

########NEW FILE########
__FILENAME__ = models
# Just an empty models.py file, so that we can run tests

########NEW FILE########
__FILENAME__ = suit_list
from copy import copy
from inspect import getargspec
from django import template
from django.template import Context
from django.template.loader import get_template
from django.utils.safestring import mark_safe
from django.contrib.admin.templatetags.admin_list import result_list
from django.contrib.admin.views.main import ALL_VAR, PAGE_VAR
from django.utils.html import escape

try:
    # Python 3.
    from urllib.parse import parse_qs
except ImportError:
    # Python 2.5+
    from urlparse import urlparse

    try:
        # Python 2.6+
        from urlparse import parse_qs
    except ImportError:
        # Python <=2.5
        from cgi import parse_qs

register = template.Library()

DOT = '.'


@register.simple_tag
def paginator_number(cl, i):
    """
    Generates an individual page index link in a paginated list.
    """
    if i == DOT:
        return '<li class="disabled"><a href="#" onclick="return false;">..' \
               '.</a></li>'
    elif i == cl.page_num:
        return mark_safe(
            '<li class="active"><a href="">%d</a></li> ' % (i + 1))
    else:
        return mark_safe('<li><a href="%s"%s>%d</a></li> ' % (
            escape(cl.get_query_string({PAGE_VAR: i})),
            (i == cl.paginator.num_pages - 1 and ' class="end"' or ''),
            i + 1))


@register.simple_tag
def paginator_info(cl):
    paginator = cl.paginator
    entries_from = (
        (paginator.per_page * cl.page_num) + 1) if paginator.count > 0 else 0
    entries_to = entries_from - 1 + paginator.per_page
    if paginator.count < entries_to:
        entries_to = paginator.count
    return '%s - %s' % (entries_from, entries_to)


@register.inclusion_tag('admin/pagination.html')
def pagination(cl):
    """
    Generates the series of links to the pages in a paginated list.
    """
    paginator, page_num = cl.paginator, cl.page_num

    pagination_required = (not cl.show_all or not cl.can_show_all) \
        and cl.multi_page
    if not pagination_required:
        page_range = []
    else:
        ON_EACH_SIDE = 3
        ON_ENDS = 2

        # If there are 10 or fewer pages, display links to every page.
        # Otherwise, do some fancy
        if paginator.num_pages <= 8:
            page_range = range(paginator.num_pages)
        else:
            # Insert "smart" pagination links, so that there are always ON_ENDS
            # links at either end of the list of pages, and there are always
            # ON_EACH_SIDE links at either end of the "current page" link.
            page_range = []
            if page_num > (ON_EACH_SIDE + ON_ENDS):
                page_range.extend(range(0, ON_EACH_SIDE - 1))
                page_range.append(DOT)
                page_range.extend(range(page_num - ON_EACH_SIDE, page_num + 1))
            else:
                page_range.extend(range(0, page_num + 1))
            if page_num < (paginator.num_pages - ON_EACH_SIDE - ON_ENDS - 1):
                page_range.extend(
                    range(page_num + 1, page_num + ON_EACH_SIDE + 1))
                page_range.append(DOT)
                page_range.extend(
                    range(paginator.num_pages - ON_ENDS, paginator.num_pages))
            else:
                page_range.extend(range(page_num + 1, paginator.num_pages))

    need_show_all_link = cl.can_show_all and not cl.show_all and cl.multi_page
    return {
        'cl': cl,
        'pagination_required': pagination_required,
        'show_all_url': need_show_all_link and cl.get_query_string(
            {ALL_VAR: ''}),
        'page_range': page_range,
        'ALL_VAR': ALL_VAR,
        '1': 1,
    }


@register.simple_tag
def suit_list_filter_select(cl, spec):
    tpl = get_template(spec.template)
    choices = list(spec.choices(cl))
    field_key = spec.field_path if hasattr(spec, 'field_path') else \
        spec.parameter_name
    matched_key = field_key
    for choice in choices:
        query_string = choice['query_string'][1:]
        query_parts = parse_qs(query_string)

        value = ''
        matches = {}
        for key in query_parts.keys():
            if key == field_key:
                value = query_parts[key][0]
                matched_key = key
            elif key.startswith(
                            field_key + '__') or '__' + field_key + '__' in key:
                value = query_parts[key][0]
                matched_key = key

            if value:
                matches[matched_key] = value

        # Iterate matches, use first as actual values, additional for hidden
        i = 0
        for key, value in matches.items():
            if i == 0:
                choice['name'] = key
                choice['val'] = value
            else:
                choice['additional'] = '%s=%s' % (key, value)
            i += 1

    return tpl.render(Context({
        'field_name': field_key,
        'title': spec.title,
        'choices': choices,
        'spec': spec,
    }))


@register.filter
def headers_handler(result_headers, cl):
    """
    Adds field name to css class, so we can style specific columns
    """
    # field = cl.list_display.get()
    attrib_key = 'class_attrib'
    for i, header in enumerate(result_headers):
        field_name = cl.list_display[i]
        if field_name == 'action_checkbox':
            continue
        if not attrib_key in header:
            header[attrib_key] = mark_safe(' class=""')

        pattern = 'class="'
        if pattern in header[attrib_key]:
            replacement = '%s%s-column ' % (pattern, field_name)
            header[attrib_key] = mark_safe(
                header[attrib_key].replace(pattern, replacement))

    return result_headers


def dict_to_attrs(attrs):
    return mark_safe(' ' + ' '.join(['%s="%s"' % (k, v)
                                     for k, v in attrs.items()]))


@register.inclusion_tag('admin/change_list_results.html', takes_context=True)
def result_list_with_context(context, cl):
    """
    Wraps Djangos default result_list to ammend the context with the request.

    This gives us access to the request in change_list_results.
    """
    res = result_list(cl)
    res['request'] = context['request']
    return res


@register.simple_tag(takes_context=True)
def result_row_attrs(context, cl, row_index):
    """
    Returns row attributes based on object instance
    """
    row_index -= 1
    attrs = {
        'class': 'row1' if row_index % 2 == 0 else 'row2'
    }
    suit_row_attributes = getattr(cl.model_admin, 'suit_row_attributes', None)
    if not suit_row_attributes:
        return dict_to_attrs(attrs)

    instance = cl.result_list[row_index]

    # Backwards compatibility for suit_row_attributes without request argument
    args = getargspec(suit_row_attributes)
    if 'request' in args[0]:
        new_attrs = suit_row_attributes(instance, context['request'])
    else:
        new_attrs = suit_row_attributes(instance)

    if not new_attrs:
        return dict_to_attrs(attrs)

    # Validate
    if not isinstance(new_attrs, dict):
        raise TypeError('"suit_row_attributes" must return dict. Got: %s: %s' %
                        (new_attrs.__class__.__name__, new_attrs))

    # Merge 'class' attribute
    if 'class' in new_attrs:
        attrs['class'] += ' ' + new_attrs.pop('class')

    attrs.update(new_attrs)
    return dict_to_attrs(attrs)


@register.filter
def cells_handler(results, cl):
    """
    Changes result cell attributes based on object instance and field name
    """
    suit_cell_attributes = getattr(cl.model_admin, 'suit_cell_attributes', None)
    if not suit_cell_attributes:
        return results

    class_pattern = 'class="'
    td_pattern = '<td'
    th_pattern = '<th'
    for row, result in enumerate(results):
        instance = cl.result_list[row]
        for col, item in enumerate(result):
            field_name = cl.list_display[col]
            attrs = copy(suit_cell_attributes(instance, field_name))
            if not attrs:
                continue

            # Validate
            if not isinstance(attrs, dict):
                raise TypeError('"suit_cell_attributes" must return dict. '
                                'Got: %s: %s' % (
                                    attrs.__class__.__name__, attrs))

            # Merge 'class' attribute
            if class_pattern in item.split('>')[0] and 'class' in attrs:
                css_class = attrs.pop('class')
                replacement = '%s%s ' % (class_pattern, css_class)
                result[col] = mark_safe(
                    item.replace(class_pattern, replacement))

            # Add rest of attributes if any left
            if attrs:
                cell_pattern = td_pattern if item.startswith(
                    td_pattern) else th_pattern

                result[col] = mark_safe(
                    item.replace(cell_pattern,
                                 td_pattern + dict_to_attrs(attrs)))

    return results

########NEW FILE########
__FILENAME__ = suit_menu
from django import template
from django.contrib import admin
from django.contrib.admin import AdminSite
from django.core.handlers.wsgi import WSGIRequest
from django.core.urlresolvers import reverse, resolve

try:
    from django.utils.six import string_types
except ImportError:
    # For Django < 1.4.2
    string_types = basestring,

import warnings
from suit.config import get_config

register = template.Library()


@register.assignment_tag(takes_context=True)
def get_menu(context, request):
    """
    :type request: WSGIRequest
    """
    if not isinstance(request, WSGIRequest):
        return None

    # Try to get app list
    template_response = get_admin_site(context.current_app).index(request)
    try:
        app_list = template_response.context_data['app_list']
    except Exception:
        return

    return Menu(context, request, app_list).get_app_list()


def get_admin_site(current_app):
    """
    Method tries to get actual admin.site class, if any custom admin sites
    were used. Couldn't find any other references to actual class other than
    in func_closer dict in index() func returned by resolver.
    """
    try:
        resolver_match = resolve(reverse('%s:index' % current_app))
        for func_closure in resolver_match.func.func_closure:
            if isinstance(func_closure.cell_contents, AdminSite):
                return func_closure.cell_contents
    except:
        pass
    return admin.site


class Menu(object):
    app_activated = False

    def __init__(self, context, request, app_list):
        self.request = request
        self.app_list = app_list

        # Detect current app, if any
        try:
            self.ctx_app = context['app_label'].lower()
        except Exception:
            self.ctx_app = None

        # Get current model plural name, if any
        try:
            self.ctx_model_plural = context['opts'].verbose_name_plural.lower()
        except Exception:
            self.ctx_model_plural = None

        # Flatten all models from native apps
        self.all_models = [model for app in app_list for model in app['models']]

        # Init config variables
        self.init_config()

        super(Menu, self).__init__()

    def init_config(self):
        self.conf_exclude = get_config('MENU_EXCLUDE')
        self.conf_open_first_child = get_config('MENU_OPEN_FIRST_CHILD')
        self.conf_icons = get_config('MENU_ICONS')
        self.conf_menu_order = get_config('MENU_ORDER')
        self.conf_menu = get_config('MENU')

    def get_app_list(self):
        menu = None
        if self.conf_menu:
            menu = self.make_menu(self.conf_menu)
        elif self.conf_menu_order:
            menu = self.make_menu_from_old_format(self.conf_menu_order)
        else:
            menu = self.make_menu_from_native_only()

        # Add icons and match active
        if menu:
            self.activate_menu(menu)

        return menu

    def make_menu(self, config):
        menu = []
        if not isinstance(config, (tuple, list)):
            raise TypeError('Django Suit MENU config parameter must be '
                            'tuple or list. Got %s' % repr(config))
        for app in config:
            app = self.make_app(app)
            if app:
                menu.append(app)

        return menu

    def make_app(self, app_def):
        if isinstance(app_def, dict):
            app = app_def.copy()
        elif isinstance(app_def, string_types):
            if app_def == '-':
                app = self.make_separator()
            else:
                app = self.make_app_from_native(app_def)
        else:
            raise TypeError('MENU list item must be string or dict. Got %s'
                            % repr(app_def))
        if app:
            return self.process_app(app)

    def process_app(self, app):

        if 'app' in app:
            app = self.process_semi_native_app(app)

        if not app:
            return

        # Process icons
        self.process_icons(app)

        # Ensure required keys for template are set
        self.ensure_app_keys(app)

        # Exclude apps
        if self.app_is_excluded(app):
            return

        # Handle app permissions
        if self.app_is_forbidden(app):
            return

        # Process app models
        self.process_models(app)

        # Set link from child
        models = app.get('models', [])
        if self.conf_open_first_child and models:
            app['orig_url'] = app['url']
            app['url'] = models[0]['url']

        # Process absolute/named/model type urls
        app['url'] = self.process_url(app['url'], app)

        return app


    def app_is_forbidden(self, app):
        return app['permissions'] and \
               not self.user_has_permission(app['permissions'])

    def app_is_excluded(self, app):
        return self.conf_exclude and app['name'] in self.conf_exclude

    def process_icons(self, app):
        """
        If icon key is present but value is '' or None, set empty 'icon-'
        If key not found, try to set icon from SUIT_ICONS
        """
        if 'icon' in app:
            app['icon'] = app['icon'] or 'icon-'
        elif self.conf_icons and 'name' in app and \
                        app['name'] in self.conf_icons:
            app['icon'] = self.conf_icons[app['name']]

    def process_semi_native_app(self, app):
        """
        Process app defined as { app: 'app' }
        """
        app_from_native = self.make_app_from_native(app['app'])
        if app_from_native:
            del app['app']
            app_from_native.update(app)
            return app_from_native

    def make_menu_from_native_only(self):
        menu = []
        for app in self.app_list:
            app_name = ''
            app_url = app.get('app_url')
            if app_url:
                app_url_parts = app['app_url'].split('/')
                if len(app_url_parts) > 1:
                    app_name = app_url_parts[-2]
            app = self.convert_native_app(app, app_name)
            if app:
                app = self.process_app(app)
            if app:
                menu.append(app)

        return menu

    def make_app_from_native(self, app_name):
        app = self.find_native_app(app_name)
        if app:
            return self.convert_native_app(app, app_name)

    def find_native_app(self, app_name):
        for app in self.app_list:
            if app['name'].lower() == app_name:
                return app

    def convert_native_app(self, native_app, app_name):
        models = []
        native_models = native_app.get('models', {})
        if native_models:
            for model in native_models:
                models.append(self.convert_native_model(model, app_name))

        # Skip native apps with no models
        if not models:
            return

        return {
            'label': native_app['name'],
            'url': native_app['app_url'],
            'models': models,
            'name': app_name
        }

    def make_separator(self):
        return {
            'separator': True
        }

    def process_models(self, app):
        models = []
        models_def = app.get('models', [])
        for model_def in models_def:
            model = self.make_model(model_def, app['name'])
            if model:
                models.append(model)

        app['models'] = models

    def make_model(self, model_def, app_name):
        if isinstance(model_def, dict):
            model = model_def.copy()
        elif isinstance(model_def, string_types):
            model = self.make_model_from_native(model_def, app_name)
        else:
            raise TypeError('MENU list item must be string or dict. Got %s'
                            % repr(model_def))
        if model:
            return self.process_model(model, app_name)

    def make_model_from_native(self, model_name, app_name):
        model = self.find_native_model(model_name, app_name)
        if model:
            return self.convert_native_model(model, app_name)

    def find_native_model(self, model_name, app_name):
        model_name = self.get_model_name(app_name, model_name)
        for native_model in self.all_models:
            if model_name == self.get_native_model_name(native_model):
                return native_model

    def model_is_excluded(self, model_name):
        return self.conf_exclude and model_name in self.conf_exclude

    def get_model_name(self, app_name, model_name):
        if '.' not in model_name:
            model_name = '%s.%s' % (app_name, model_name)
        return model_name

    def get_native_model_name(self, model):
        """
        Get model name by its last part of url
        """
        url_parts = self.get_native_model_url(model).rstrip('/').split('/')
        root_url_parts = reverse('admin:index').rstrip('/').split('/')
        return '.'.join(url_parts[len(root_url_parts):][:2])

    def convert_native_model(self, model, app_name):
        return {
            'label': model['name'],
            'url': self.get_native_model_url(model),
            'name': self.get_native_model_name(model),
            'app': app_name
        }

    def get_native_model_url(self, model):
        return model.get('admin_url', model.get('add_url', ''))

    def process_model(self, model, app_name):
        if 'model' in model:
            model = self.process_semi_native_model(model, app_name)

        if model:
            self.ensure_model_keys(model)

            if 'app' in model and 'name' in model:
                model_name = self.get_model_name(model['app'], model['name'])

                if self.model_is_excluded(model_name):
                    return

            # Handle model permissions
            if self.model_is_forbidden(model):
                return

            # Detect if named url and convert it to absolute
            model['url'] = self.process_url(model['url'])

            return model

    def model_is_forbidden(self, model):
        return model['permissions'] and \
               not self.user_has_permission(model['permissions'])

    def process_semi_native_model(self, model, app_name):
        """
        Process app defined as { model: 'model' }
        """
        model_from_native = self.make_model_from_native(model['model'],
                                                        app_name)
        if model_from_native:
            del model['model']
            model_from_native.update(model)
            return model_from_native

    def ensure_app_keys(self, app):
        keys = ['label', 'url', 'icon', 'permissions', 'name', 'is_active',
                'blank']
        self.fill_keys(app, keys)

    def ensure_model_keys(self, model):
        keys = ['label', 'url', 'permissions', 'is_active', 'blank']
        self.fill_keys(model, keys)

    def fill_keys(self, dict, keys):
        for key in keys:
            if key not in dict:
                dict[key] = None

    def user_has_permission(self, perms):
        perms = perms if isinstance(perms, (list, tuple)) else (perms,)
        return self.request.user.has_perms(perms)

    def activate_menu(self, menu):
        for app in menu:

            # Make 'model' key as 'models' to unite activation logic
            if 'model' in app and not app['models']:
                app['models'] = [app['model']]

            # Activate models
            if app['models']:
                self.activate_models(app)

            # Mark as active by url match
            if not self.app_activated \
                and (self.request.path == app['url']
                     or self.request.path == app.get('orig_url')):
                app['is_active'] = self.app_activated = True

        if not self.app_activated:
            self.activate_menu_by_url(menu)

        # Last chance, try to activate by name
        if not self.app_activated:
            for app in menu:
                self.activate_models(app, match_by_name=True)

    def activate_models(self, app, match_by_name=False):
        for model in app['models']:
            if not match_by_name:
                # Mark as active by url or model plural name match
                model['is_active'] = self.request.path == model['url']
            else:
                model['is_active'] = self.ctx_model_plural == model[
                    'label'].lower()

            # Mark parent as active too
            if model['is_active'] and not self.app_activated:
                app['is_active'] = self.app_activated = True

    def activate_menu_by_url(self, menu):
        """
        If no active app/model is found in good/correct way, try to match
        by simple "startswith" in request path. Some apps doesn't provide
        nice app_label (django-filer for ex.) therefore this is the only way
        """
        for app in menu:
            for model in app['models']:
                if model['url'] and self.request.path.startswith(model['url']):
                    model['is_active'] = True
                    app['is_active'] = self.app_activated = True
                    break
            if self.app_activated:
                break

        # If still no active app found, match by app original url if any
        if not self.app_activated:
            for app in menu:
                orig_url = app.get('orig_url')
                if orig_url and self.request.path.startswith(orig_url):
                    app['is_active'] = self.app_activated = True

    def process_url(self, url, app=None):
        """
        Try to guess if it is absolute url or named
        """
        if url is None:
            return ''

        if not url or '/' in url:
            return url

        # Model link, ex: 'auth.user'
        if '.' in url:
            url_parts = url.split('.')
            model = self.make_model_from_native(url_parts[1], url_parts[0])
            if model:
                if app:
                    app['model'] = model
                return model['url']

        # Try to resolve as named url, ex: 'admin:index'
        try:
            return reverse(url)
        except:
            return url

    def make_menu_from_old_format(self, conf_order):
        import sys

        if 'test' not in sys.argv:
            warnings.warn(
                'Django Suit "MENU_ORDER" setting is deprecated. Use new "MENU"'
                ' key instead, see Documentation for new syntax.',
                DeprecationWarning)

        new_conf = []
        for order in conf_order:
            new_app = {}
            if isinstance(order, (tuple, list)):
                app_name = order[0]
                models_order = order[1] if len(order) > 1 else None
                if isinstance(app_name, string_types):
                    new_app['app'] = app_name
                elif isinstance(app_name, (tuple, list)):
                    mapping = ('label', 'url', 'icon', 'permissions')
                    for i, val in enumerate(app_name):
                        new_app[mapping[i]] = val
                if models_order and isinstance(models_order, (tuple, list)):
                    models = []
                    for model in models_order:
                        if isinstance(model, string_types):
                            models.append({'model': model})
                        elif isinstance(model, (list, tuple)):
                            mapping = ('label', 'url', 'permissions')
                            new_model = {}
                            for i, val in enumerate(model):
                                new_model[mapping[i]] = val
                            models.append(new_model)

                    new_app['models'] = models
            if new_app:
                new_conf.append(new_app)

        return self.make_menu(new_conf)

########NEW FILE########
__FILENAME__ = suit_tags
from django import template
from django.contrib.admin.util import lookup_field
from django.core.exceptions import ObjectDoesNotExist
from django.core.urlresolvers import NoReverseMatch, reverse
from django.db.models import ForeignKey
from django.template.defaulttags import NowNode
from django.utils.safestring import mark_safe
from suit.config import get_config
from suit import utils

register = template.Library()


@register.filter(name='suit_conf')
def suit_conf(name):
    value = get_config(name)
    return mark_safe(value) if isinstance(value, str) else value


@register.tag
def suit_date(parser, token):
    return NowNode(get_config('HEADER_DATE_FORMAT'))


@register.tag
def suit_time(parser, token):
    return NowNode(get_config('HEADER_TIME_FORMAT'))


@register.filter
def field_contents_foreign_linked(admin_field):
    """Return the .contents attribute of the admin_field, and if it
    is a foreign key, wrap it in a link to the admin page for that
    object.

    Use by replacing '{{ field.contents }}' in an admin template (e.g.
    fieldset.html) with '{{ field|field_contents_foreign_linked }}'.
    """
    fieldname = admin_field.field['field']
    displayed = admin_field.contents()
    obj = admin_field.form.instance

    if not hasattr(admin_field.model_admin,
                   'linked_readonly_fields') or fieldname not in admin_field \
        .model_admin \
        .linked_readonly_fields:
        return displayed

    try:
        fieldtype, attr, value = lookup_field(fieldname, obj,
                                              admin_field.model_admin)
    except ObjectDoesNotExist:
        fieldtype = None

    if isinstance(fieldtype, ForeignKey):
        try:
            url = admin_url(value)
        except NoReverseMatch:
            url = None
        if url:
            displayed = "<a href='%s'>%s</a>" % (url, displayed)
    return mark_safe(displayed)


@register.filter
def admin_url(obj):
    info = (obj._meta.app_label, obj._meta.module_name)
    return reverse("admin:%s_%s_change" % info, args=[obj.pk])


@register.simple_tag
def suit_bc(*args):
    return utils.value_by_version(args)


@register.assignment_tag
def suit_bc_value(*args):
    return utils.value_by_version(args)

########NEW FILE########
__FILENAME__ = config
from django.contrib.admin import ModelAdmin
from django.conf import settings
from suit import VERSION
from suit.config import default_config, get_config
from suit.templatetags.suit_tags import admin_url
from suit.tests.models import Book
from suit.tests.mixins import UserTestCaseMixin, ModelsTestCaseMixin


class ConfigTestCase(UserTestCaseMixin):
    def test_default_config(self):
        default_suit_config = default_config()
        self.assertEqual(VERSION, default_suit_config['VERSION'])

    def test_suit_config_when_not_defined(self):
        try:
            del settings.SUIT_CONFIG
        except AttributeError:
            pass
        default_suit_config = default_config()
        self.assertEqual(get_config('ADMIN_NAME'),
                         default_suit_config['ADMIN_NAME'])

        # Defined as None, should also use fallback
        admin_name = None
        settings.SUIT_CONFIG = {
            'ADMIN_NAME': admin_name
        }
        self.assertEqual(get_config('ADMIN_NAME'),
                         default_suit_config['ADMIN_NAME'])

    def test_suit_config_when_defined_but_no_key(self):
        settings.SUIT_CONFIG = {
            'RANDOM_KEY': 123
        }
        default_suit_config = default_config()
        self.assertEqual(get_config('ADMIN_NAME'),
                         default_suit_config['ADMIN_NAME'])
        # Defined as empty, should stay empty
        admin_name = ''
        settings.SUIT_CONFIG = {
            'ADMIN_NAME': admin_name
        }
        self.assertEqual(get_config('ADMIN_NAME'), admin_name)

    def test_suit_config_when_defined(self):
        admin_name = 'Custom Name'
        settings.SUIT_CONFIG = {
            'ADMIN_NAME': admin_name
        }
        self.assertEqual(get_config('ADMIN_NAME'), admin_name)

    def test_django_modeladmin_overrides(self):
        self.assertEqual(ModelAdmin.actions_on_top, False)
        self.assertEqual(ModelAdmin.actions_on_bottom, True)
        self.assertEqual(ModelAdmin.list_per_page, get_config('LIST_PER_PAGE'))


class ConfigWithModelsTestCase(ModelsTestCaseMixin, UserTestCaseMixin):

    def create_book(self):
        book = Book(pk=2, name='Some book')
        book.save()
        return book

    def test_confirm_unsaved_changes(self):
        self.login_superuser()
        settings.SUIT_CONFIG['CONFIRM_UNSAVED_CHANGES'] = True
        book = self.create_book()

        response = self.client.get(admin_url(book))
        content_if_true = 'confirmExitIfModified'
        self.assertContains(response, content_if_true)

        # Test without unsaved changes
        settings.SUIT_CONFIG['CONFIRM_UNSAVED_CHANGES'] = False
        response = self.client.get(admin_url(book))
        self.assertNotContains(response, content_if_true)


    def test_show_required_asterisk(self):
        self.login_superuser()
        settings.SUIT_CONFIG['SHOW_REQUIRED_ASTERISK'] = True
        book = self.create_book()

        response = self.client.get(admin_url(book))
        content_if_true = ".required:after { content: '*';"
        self.assertContains(response, content_if_true)

        # Test without confirm
        settings.SUIT_CONFIG['SHOW_REQUIRED_ASTERISK'] = False
        response = self.client.get(admin_url(book))
        self.assertNotContains(response, content_if_true)

########NEW FILE########
__FILENAME__ = mixins
from django.conf import settings
from django.contrib.auth.models import User
from django.core.management import call_command
from django.core.urlresolvers import reverse
from django.db.models.loading import load_app
from django.test import TestCase
from random import randint


class UserTestCaseMixin(TestCase):
    superuser = None
    user = None

    def login_superuser(self):
        if not self.superuser:
            self.superuser = self.create_superuser()
        self.client.login(username=self.superuser.username, password='password')

    def create_superuser(self):
        return User.objects.create_superuser('admin-%s' % str(randint(1, 9999)),
                                             'test@test.com', 'password')

    def create_user(self):
        user = User.objects.create_user('user-%s' % str(randint(1, 9999)),
                                        'test2@test2.com', 'password')
        user.is_staff = True
        user.save()
        return user

    def login_user(self):
        if not self.user:
            self.user = self.create_user()
        self.client.login(username=self.user.username, password='password')

    def get_response(self, url=None):
        url = url or reverse('admin:index')
        self.response = self.client.get(url)


class ModelsTestCaseMixin(TestCase):
    def _pre_setup(self):
        self.saved_INSTALLED_APPS = settings.INSTALLED_APPS
        self.saved_DEBUG = settings.DEBUG
        test_app = 'suit.tests'
        settings.INSTALLED_APPS = tuple(
            list(self.saved_INSTALLED_APPS) + [test_app]
        )
        settings.DEBUG = True
        # load our fake application and syncdb
        load_app(test_app)
        call_command('syncdb', verbosity=0, interactive=False)
        super(ModelsTestCaseMixin, self)._pre_setup()

    def _post_teardown(self):
        settings.INSTALLED_APPS = self.saved_INSTALLED_APPS
        settings.DEBUG = self.saved_DEBUG
        super(ModelsTestCaseMixin, self)._post_teardown()

########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.contrib import admin


class Book(models.Model):
    name = models.CharField(max_length=64)

    def __unicode__(self):
        return self.name

    class Meta:
        ordering = ('-id',)


class Album(models.Model):
    name = models.CharField(max_length=64)

    def __unicode__(self):
        return self.name


class BookAdmin(admin.ModelAdmin):
    list_filter = ('id', 'name',)
    list_display = ('id', 'name',)

    def suit_row_attributes(self, obj, request):
        return {'class': 'suit_row_attr_class-%s' % obj.name,
                'data': obj.pk,
                'data-request': request}

    def suit_cell_attributes(self, obj, column):
        return {'class': 'suit_cell_attr_class-%s-%s' % (column, obj.name),
                'data': obj.pk}


class AlbumAdmin(admin.ModelAdmin):
    def suit_row_attributes(self, obj):
        """No request defined to test backward-compatibility"""
        return {'class': 'suit_row_album_attr_class-%s' % obj.name,
                'data-album': obj.pk}


class User(models.Model):
    """
    Class to test menu marking as active if two apps have model with same name
    """
    name = models.CharField(max_length=64)


admin.site.register(Book, BookAdmin)
admin.site.register(Album, AlbumAdmin)
admin.site.register(User)

########NEW FILE########
__FILENAME__ = settings
# Django settings for testproject project.

DEBUG = True
TEMPLATE_DEBUG = DEBUG
DEBUG_PROPAGATE_EXCEPTIONS = True

ADMINS = ()
MANAGERS = ADMINS

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
    }
}


TIME_ZONE = 'Europe/Riga'
LANGUAGE_CODE = 'en-uk'
SITE_ID = 1
USE_I18N = True
USE_L10N = True
MEDIA_ROOT = ''
MEDIA_URL = ''
SECRET_KEY = 'vaO4Y<g#YRWG8;Md8noiLp>.w(w~q_b=|1`?9<x>0KxA%UB!63'

TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
)

ROOT_URLCONF = 'suit.tests.urls'
TEMPLATE_DIRS = ()

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',

    'suit',
    'django.contrib.admin',
)

STATIC_URL = '/static/'

from django.conf.global_settings import TEMPLATE_CONTEXT_PROCESSORS as TCP

TEMPLATE_CONTEXT_PROCESSORS = TCP + (
    'django.core.context_processors.request',
)

SUIT_CONFIG = {}

########NEW FILE########
__FILENAME__ = form_tabs
from django.conf import settings
from django.contrib import admin
from django.core.urlresolvers import reverse
from django.template.base import TemplateDoesNotExist
from django.utils.translation import ugettext
from suit.templatetags.suit_menu import get_menu
from suit.tests.mixins import ModelsTestCaseMixin, UserTestCaseMixin
from suit.tests.models import Book, BookAdmin


class TabbedBookAdmin(BookAdmin):
    list_filter = ('id', 'name',)
    suit_form_tabs = (('tab1', 'Tab1'), ('tab2', ugettext('Tab2')))
    suit_form_includes = None


admin.site.unregister(Book)
admin.site.register(Book, TabbedBookAdmin)


class FormTabsTestCase(ModelsTestCaseMixin, UserTestCaseMixin):
    def setUp(self):
        self.login_superuser()
        self.url = reverse('admin:tests_book_add')
        self.get_response(self.url)

    def test_tabs_appearance(self):
        for x in range(0, 2):
            vars = (TabbedBookAdmin.suit_form_tabs[x][0],
                    TabbedBookAdmin.suit_form_tabs[x][1])
            self.assertContains(self.response, '<li><a href="#%s">%s</a></li>' %
                                               vars)

    def test_template_includes(self):
        suit_form_include = 'admin/date_hierarchy.html'
        TabbedBookAdmin.suit_form_includes = (
            (suit_form_include, 'top', 'tab1'),
        )
        self.get_response(self.url)
        self.assertTemplateUsed(self.response,
                                'suit/includes/change_form_includes.html')
        self.assertTemplateUsed(self.response, suit_form_include)
        self.assertContains(self.response,
                            '<div class="suit-include suit-tab suit-tab-tab1">')

########NEW FILE########
__FILENAME__ = suit_list
from django.contrib.admin import ModelAdmin
from django.contrib.admin.templatetags.admin_list import result_list
from django.core.urlresolvers import reverse
from suit.templatetags.suit_list import paginator_number, paginator_info, \
    pagination, suit_list_filter_select, headers_handler, dict_to_attrs, \
    result_row_attrs, cells_handler
from suit.tests.mixins import UserTestCaseMixin, ModelsTestCaseMixin
from suit.tests.models import Album, Book


class ModelAdminMock(object):
    def suit_row_attributes(self, obj):
        return {'class': obj.name, 'data': obj.pk}

    def suit_cell_attributes(self, obj, column):
        return {'class': 'col-' + column, 'data': obj.pk}


class ChangeListMock(object):
    list_display = ('action_checkbox', 'name', 'order', 'status')
    model_admin = ModelAdminMock()
    result_list = [Book(pk=1, name='beach'), Book(pk=2, name='sky')]


class SuitListTestCase(UserTestCaseMixin, ModelsTestCaseMixin):
    changelist = None
    book = None

    def get_changelist(self):
        self.get_response(reverse('admin:tests_book_changelist'))
        self.changelist = self.response.context_data['cl']

    def setUp(self):
        self.login_superuser()
        self.book = Book(name='Test')
        self.book.save()
        self.get_changelist()

    def test_paginator_number(self):
        output = paginator_number(self.changelist, 100)
        self.assertTrue('100' in output)

        output = paginator_number(self.changelist, '.')
        self.assertTrue('...' in output)

        output = paginator_number(self.changelist, 0)
        self.assertTrue('active' in output)

    def test_paginator_info(self):
        output = paginator_info(self.changelist)
        self.assertEqual('1 - 1', output)

    def test_pagination_one_page(self):
        pg = pagination(self.changelist)
        self.assertEqual(pg['cl'], self.changelist)
        self.assertEqual(pg['page_range'], [])
        self.assertEqual(pg['pagination_required'], False)

    def test_pagination_many_pages(self):
        per_page_original = ModelAdmin.list_per_page
        ModelAdmin.list_per_page = 20
        for x in range(25):
            book = Book(name='Test %d' % x)
            book.save()

        self.get_changelist()
        pg = pagination(self.changelist)
        ModelAdmin.list_per_page = per_page_original
        self.assertEqual(pg['cl'], self.changelist)
        self.assertEqual(len(pg['page_range']), 2)
        self.assertEqual(pg['pagination_required'], True)

    def test_suit_list_filter_select(self):
        filter_matches = (self.book.pk, self.book.name)
        self.assertEqual(len(self.changelist.filter_specs), 2)
        for i, spec in enumerate(self.changelist.filter_specs):
            filter_output = suit_list_filter_select(self.changelist, spec)
            self.assertTrue('value="%s"' % filter_matches[i] in filter_output)

    def test_suit_list_headers_handler(self):
        result_headers = [{'class_attrib': ' class="test"'}, {}]
        result = [{'class_attrib': ' class="test"'},
                  {'class_attrib': ' class="name-column "'}]
        cl = ChangeListMock()
        self.assertEqual(headers_handler(result_headers, cl), result)

    def test_suit_list_dict_to_attrs(self):
        attrs = {'class': 'test', 'data': 123}
        result = dict_to_attrs(attrs)
        self.assertTrue('data="123"' in result)
        self.assertTrue('class="test"' in result)

    def test_suit_list_result_row_attrs(self):
        cl = ChangeListMock()
        context = {'request': 'dummy'}
        result = result_row_attrs(context, cl, 1)
        self.assertTrue('data="1"' in result)
        self.assertTrue('class="row1 beach"' in result)
        result = result_row_attrs(context, cl, 2)
        self.assertTrue('data="2"' in result)
        self.assertTrue('class="row2 sky"' in result)

    def test_suit_list_result_row_attrs_by_response(self):
        Book.objects.all().delete()
        for x in range(2):
            book = Book(pk=x, name='sky-%s' % x)
            book.save()

        context = {'request': 'dummy'}
        self.get_changelist()
        result = result_row_attrs(context, self.changelist, 1)
        self.assertTrue('data="1"' in result)
        self.assertTrue('data-request="dummy"' in result)
        self.assertTrue('class="row1 suit_row_attr_class-sky-1"' in result)

    def test_suit_list_result_row_attrs_backwards_compatible(self):
        Album.objects.all().delete()
        album = Album(pk=1, name="foo")
        album.save()

        # A bit more verbose and manual, as this is the only test against album
        # changelist
        self.get_response(reverse('admin:tests_album_changelist'))
        changelist = self.response.context_data['cl']

        context = {'request': 'dummy'}
        result = result_row_attrs(context, changelist, 1)
        self.assertTrue('data-album="1"' in result)
        self.assertTrue('class="row1 suit_row_album_attr_class-foo"' in result)

    def test_suit_list_cells_handler(self):
        results = [
            ['<td></td>', '<th class="test"></th>',
             '<td><input class=""></td>'],
            ['<td></td>', '<th class="test"></th>',
             '<td><input class=""></td>'],
        ]
        result = [['<td data="1" class="col-action_checkbox"></td>',
                   '<td data="1" class="test"></th>',
                   '<td data="1" class="col-order"><input class=""></td>'],
                  ['<td data="2" class="col-action_checkbox"></td>',
                   '<td data="2" class="test"></th>',
                   '<td data="2" class="col-order"><input class=""></td>']]
        cl = ChangeListMock()
        result = cells_handler(results, cl)
        self.assertTrue('data="1"' in result[0][0])
        self.assertTrue('data="1"' in result[0][1])
        self.assertTrue('data="1"' in result[0][2])
        self.assertTrue('class="col-action_checkbox"' in result[0][0])
        self.assertTrue('class="test"' in result[0][1])
        self.assertTrue('class="col-order"' in result[0][2])

    def test_suit_list_cells_handler_by_response(self):
        Book.objects.all().delete()
        for x in range(2):
            book = Book(pk=x, name='sky-%s' % x)
            book.save()

        self.get_changelist()
        cl = self.changelist
        results = result_list(cl)['results']
        result_cells = cells_handler(results, cl)
        self.assertTrue(
            'class="suit_cell_attr_class-id-sky-1"' in result_cells[0][1])
        self.assertTrue(' data="1"' in result_cells[0][1])

########NEW FILE########
__FILENAME__ = suit_menu
from django.conf import settings
from django.contrib.auth.models import Permission
from django.core.urlresolvers import reverse
from suit.templatetags.suit_menu import get_menu
from suit.tests.mixins import ModelsTestCaseMixin, UserTestCaseMixin

# conditional import, force_unicode was renamed in Django 1.5
try:
    from django.utils.encoding import force_unicode
except ImportError:
    from django.utils.encoding import force_text as force_unicode


class SuitMenuTestCase(ModelsTestCaseMixin, UserTestCaseMixin):
    def setUp(self):
        self.setUpConfig()
        self.login_superuser()

    def setUpConfig(self):
        settings.SUIT_CONFIG.update({
            'MENU_OPEN_FIRST_CHILD': True,
            'MENU_ICONS': {
                'auth': 'icon-auth-assert',
            },
            'MENU_EXCLUDE': [],
            'MENU': [
                'tests',
                {'app': 'tests'},
                {'app': 'tests', 'label': 'Custom'},
                {'app': 'tests', 'icon': 'icon-test-assert'},
                {'app': 'tests', 'icon': ''},
                {'app': 'tests', 'icon': None},
                {'app': 'auth'},
                '-',
                {'label': 'Custom', 'url': '/custom/'},
                {'label': 'Custom2', 'url': '/custom2/', 'permissions': 'x'},
                {'label': 'Custom3', 'url': '/custom3/', 'permissions': ('y',)},
                {'label': 'Custom4', 'url': '/custom4/', 'blank': True},
                {'label': 'C4', 'url': '/c/4', 'models': ('book',)},
                {'label': 'C5', 'url': '/c/5', 'models': ('tests.book',)},
                {'label': 'C6', 'url': 'admin:index', 'models':
                    ({'label': 'mx', 'url': 'admin:index'},)},
                {'label': 'C7', 'url': 'tests.book'},
                {'app': 'tests', 'models': []},
                {'app': 'tests', 'models': ['book', 'album']},
                {'app': 'tests', 'models': ['tests.book', 'tests.album']},
                {'app': 'tests', 'models': [
                    'book', 'tests.book',
                    {
                        'model': 'tests.album',
                        'label': 'Albumzzz',
                        'url': '/albumzzz/',
                    }, {
                        'label': 'CustModel',
                        'url': '/cust-mod/',
                        'permissions': 'z'
                    }]},
            ]
        })

    def setUpOldConfig(self):
        settings.SUIT_CONFIG.update({
            'MENU_OPEN_FIRST_CHILD': False,
            'MENU_ICONS': {
                'tests': 'icon-fire icon-test-against-keyword',
            },
            'MENU_ORDER': (
                ('tests', ('book',)),
                (('Custom app name', '/custom-url-test/', 'icon-custom-app'), (
                    ('Custom link', '/admin/custom/', 'tests.add_book'),
                    ('Check out error 404', '/admin/non-existant/',
                     ('mega-perms',)),
                    'tests.album'
                )),
                (('Custom app no models', '/custom-app-no-models',
                  '', 'mega-rights'),),
                (('Custom app no models tuple perms', '/custom-app-tuple-perms',
                  '', ('mega-rights',)),),
            ),
            'MENU_EXCLUDE': []
        })
        del settings.SUIT_CONFIG['MENU']

    def make_menu_from_response(self):
        return get_menu(self.response.context[-1], self.response._request)

    def test_menu_search_url_formats(self):
        # Test named url as defined in setUp config
        settings.SUIT_CONFIG['SEARCH_URL'] = 'admin:tests_book_changelist'
        admin_root = reverse('admin:index')
        self.get_response()
        self.assertContains(self.response,
                            'action="%stests/book/"' % admin_root)

        # Test absolute url
        absolute_search_url = '/absolute/search/url'
        settings.SUIT_CONFIG['SEARCH_URL'] = absolute_search_url
        self.get_response()
        self.assertContains(self.response, absolute_search_url)

    def test_menu(self):
        mc = settings.SUIT_CONFIG['MENU']
        self.get_response()
        menu = self.make_menu_from_response()
        self.assertEqual(len(menu), len(mc))

        # as string
        i = 0
        first_model_url = reverse('admin:tests_album_changelist')
        self.assertEqual(menu[i]['url'], first_model_url)
        self.assertEqual(len(menu[i]['models']), 3)
        self.assertEqual(menu[i]['name'], mc[i])
        self.assertEqual(menu[i]['label'], 'Tests')
        self.assertEqual(menu[i]['icon'], None)
        self.assertEqual(menu[i]['models'][0]['url'], first_model_url)
        self.assertEqual(force_unicode(menu[0]['models'][0]['label']), 'Albums')

        i += 1 # as dict
        self.assertEqual(menu[i]['url'], first_model_url)
        self.assertEqual(len(menu[i]['models']), 3)

        i += 1 # with label
        self.assertEqual(menu[i]['label'], mc[i]['label'])

        i += 1 # with icon
        self.assertEqual(menu[i]['icon'], mc[i]['icon'])

        i += 1 # with icon=''
        self.assertEqual(menu[i]['icon'], 'icon-')

        i += 1 # with is is None
        self.assertEqual(menu[i]['icon'], 'icon-')

        i += 1 # icon from SUIT_ICONS
        self.assertEqual(menu[i]['icon'], 'icon-auth-assert')

        i += 1 # separator
        self.assertEqual(menu[i]['separator'], True)

        i += 1 # custom app
        self.assertEqual(menu[i]['label'], mc[i]['label'])
        self.assertEqual(menu[i]['url'], mc[i]['url'])

        i += 1 # custom app, with perms as string
        self.assertEqual(menu[i]['label'], mc[i]['label'])

        i += 1 # custom app, with perms as tuple
        self.assertEqual(menu[i]['label'], mc[i]['label'])

        i += 1 # custom app, with perms as tuple
        self.assertEqual(menu[i]['blank'], True)

        i += 1 # custom app with wrong model
        self.assertEqual(menu[i]['label'], mc[i]['label'])
        self.assertEqual(menu[i]['models'], [])
        self.assertEqual(menu[i]['url'], mc[i]['url'])

        i += 1 # custom app with correct model
        first_model_url = reverse('admin:tests_book_changelist')
        self.assertEqual(menu[i]['label'], mc[i]['label'])
        self.assertEqual(len(menu[i]['models']), 1)
        self.assertEqual(menu[i]['url'], first_model_url)

        i += 1 # custom app and model with named urls
        expected_url = reverse('admin:index')
        self.assertEqual(menu[i]['url'], expected_url)
        self.assertEqual(menu[i]['models'][0]['url'], expected_url)

        i += 1 # with url by model
        books_url = reverse('admin:tests_book_changelist')
        self.assertEqual(menu[i]['url'], books_url)

        i += 1 # with empty models
        self.assertEqual(menu[i]['models'], [])
        self.assertEqual(menu[i]['url'],
                         reverse('admin:app_list', args=[mc[i]['app']]))

        i += 1 # with ordered models
        first_model_url = reverse('admin:tests_book_changelist')
        self.assertEqual(menu[i]['models'][0]['url'], first_model_url)
        self.assertEqual(len(menu[i]['models']), 2)

        i += 1 # with prefixed  models
        first_model_url = reverse('admin:tests_book_changelist')
        self.assertEqual(menu[i]['models'][0]['url'], first_model_url)
        self.assertEqual(len(menu[i]['models']), 2)

        i += 1 # with dict models
        first_model_url = reverse('admin:tests_book_changelist')
        self.assertEqual(menu[i]['models'][0]['url'], first_model_url)
        self.assertEqual(len(menu[i]['models']), 4)
        self.assertEqual(force_unicode(menu[i]['models'][2]['label']),
                         mc[i]['models'][2]['label'])
        self.assertEqual(force_unicode(menu[i]['models'][2]['url']),
                         mc[i]['models'][2]['url'])
        self.assertEqual(force_unicode(menu[i]['models'][3]['label']),
                         mc[i]['models'][3]['label'])
        self.assertEqual(force_unicode(menu[i]['models'][3]['url']),
                         mc[i]['models'][3]['url'])


    def test_menu_app_exclude(self):
        settings.SUIT_CONFIG['MENU'] = ({'app': 'tests', 'models': ['book']},
                                        {'app': 'auth'}, 'auth')
        settings.SUIT_CONFIG['MENU_EXCLUDE'] = ('auth', 'tests.book')
        self.get_response()
        menu = self.make_menu_from_response()
        self.assertEqual(len(menu), 1)
        self.assertEqual(menu[0]['models'], [])

    def test_menu_model_exclude_with_string_app(self):
        settings.SUIT_CONFIG['MENU'] = ('tests',)
        settings.SUIT_CONFIG['MENU_EXCLUDE'] = ('tests.book',)
        self.get_response()
        menu = self.make_menu_from_response()
        self.assertEqual(len(menu), 1)
        self.assertEqual(len(menu[0]['models']), 2)

    def test_menu_custom_app(self):
        label = 'custom'
        icon = 'icon-custom'
        settings.SUIT_CONFIG['MENU'] = ({'label': label, 'icon': icon},)
        self.get_response()
        menu = self.make_menu_from_response()
        self.assertEqual(len(menu), 1)
        self.assertEqual(menu[0]['label'], label)
        self.assertEqual(menu[0]['icon'], icon)

    def test_menu_custom_app_permissions(self):
        settings.SUIT_CONFIG['MENU'] = ({'label': 'a',
                                         'permissions': 'secure-perms'},
                                        {'label': 'b',
                                         'permissions': ('secure-perms',)},
                                        {'label': 'c', 'models': [
                                            {'label': 'model1',
                                             'permissions': 'x'}]},)
        self.client.logout()
        self.login_user()
        self.get_response()
        menu = self.make_menu_from_response()
        self.assertEqual(len(menu), 1)
        self.assertEqual(len(menu[0]['models']), 0)

        # Now do the same with super user
        self.client.logout()
        self.login_superuser()
        self.get_response()
        menu = self.make_menu_from_response()
        self.assertEqual(len(menu), 3)
        self.assertEqual(len(menu[2]['models']), 1)

    def test_menu_app_marked_as_active(self):
        self.get_response(reverse('admin:app_list', args=['tests']))
        self.assertContains(self.response, '<li class="active">')
        menu = self.make_menu_from_response()
        self.assertTrue(menu[0]['is_active'])

    def test_menu_app_marked_as_active_model_link(self):
        settings.SUIT_CONFIG['MENU'] = (
            {'label': 'tests-user', 'url': 'tests.user'},
            {'label': 'auth-user', 'url': 'auth.user'},
        )
        self.get_response(reverse('admin:auth_user_add'))
        self.assertContains(self.response, '<li class="active">')

        # Test if right user model is activated, when models have identical name
        menu = self.make_menu_from_response()
        self.assertFalse(menu[0]['is_active'])
        self.assertTrue(menu[1]['is_active'])

    def test_menu_model_marked_as_active(self):
        self.get_response(reverse('admin:tests_album_changelist'))
        menu = self.make_menu_from_response()
        self.assertTrue(menu[0]['is_active'])
        self.assertTrue(menu[0]['models'][0]['is_active'])

    def test_only_native_apps(self):
        del settings.SUIT_CONFIG['MENU']
        if 'MENU_ORDER' in settings.SUIT_CONFIG:
            del settings.SUIT_CONFIG['MENU_ORDER']
        icon = 'icon-auth-assert'
        settings.SUIT_CONFIG['MENU_ICONS'] = {'auth': icon}
        self.get_response()
        menu = self.make_menu_from_response()
        self.assertEqual(len(menu), 4)
        self.assertEqual(menu[0]['icon'], icon)

    def test_user_with_add_but_not_change(self):
        settings.SUIT_CONFIG['MENU'] = ({'app': 'tests', 'models': ['book']},
                                        {'app': 'auth'}, 'auth')
        settings.SUIT_CONFIG['MENU_EXCLUDE'] = ()
        self.client.logout()
        self.login_user()
        self.user.user_permissions.add(
            Permission.objects.get(codename='add_book'))
        self.user.save()
        self.get_response()
        menu = self.make_menu_from_response()
        add_book_url = reverse('admin:tests_book_add')
        self.assertEqual(menu[0]['url'], add_book_url)
        self.assertEqual(menu[0]['models'][0]['url'], add_book_url)

    #
    # Tests for old menu config format
    #
    def test_old_menu_init(self):
        # Template usage
        self.client.logout()
        self.login_superuser()
        self.setUpOldConfig()
        self.get_response()
        self.assertTemplateUsed(self.response, 'suit/menu.html')
        self.assertContains(self.response, 'left-nav')
        self.assertContains(self.response, 'icon-test-against-keyword')
        app_list = self.response.context_data['app_list']
        pass
        # print self.response.content

    def test_old_menu_custom_app_and_models(self):
        # Test custom app name, url and icon
        self.setUpOldConfig()
        self.get_response()
        menu_order = settings.SUIT_CONFIG['MENU_ORDER']
        self.assertContains(self.response, menu_order[1][0][0])
        self.assertContains(self.response, menu_order[1][0][1])
        self.assertContains(self.response, menu_order[1][0][2])
        # Test custom app no models name, url and icon
        self.assertContains(self.response, menu_order[2][0][0])
        self.assertContains(self.response, menu_order[2][0][1])
        self.assertContains(self.response, menu_order[2][0][2])
        # Test custom app when perms defined but is allowed
        self.assertContains(self.response, menu_order[2][0][0])
        # Test cross-linked app
        self.assertContains(self.response, 'tests/album')

    def test_old_menu_when_open_first_child_is_true(self):
        # Test custom app name, url and icon
        self.setUpOldConfig()
        settings.SUIT_CONFIG['MENU_OPEN_FIRST_CHILD'] = True
        self.get_response()
        menu_order = settings.SUIT_CONFIG['MENU_ORDER']
        self.assertNotContains(self.response, menu_order[1][0][1])

    def test_old_custom_menu_permissions(self):
        self.client.logout()
        self.login_user()
        self.setUpOldConfig()
        self.get_response()
        # Test for menu at all for simple user
        self.assertTemplateUsed(self.response, 'suit/menu.html')
        self.assertContains(self.response, 'left-nav')
        menu_order = settings.SUIT_CONFIG['MENU_ORDER']
        # Test custom model when perms defined as string
        self.assertNotContains(self.response, menu_order[1][1][0][0])
        # Test custom model when perms defined as tuple
        self.assertNotContains(self.response, menu_order[1][1][1][0])
        # Test custom app when perms defined as string
        self.assertNotContains(self.response, menu_order[2][0][0])
        # Test custom app when perms defined as tuple
        self.assertNotContains(self.response, menu_order[3][0][0])

    def test_old_menu_marked_as_active(self):
        self.setUpOldConfig()
        self.get_response(reverse('admin:app_list', args=['tests']))
        self.assertContains(self.response, '<li class="active">')


class SuitMenuAdminRootURLTestCase(SuitMenuTestCase):
    urls = 'suit.tests.urls.admin_at_root'


class SuitMenuAdminI18NURLTestCase(SuitMenuTestCase):
    urls = 'suit.tests.urls.admin_i18n'


class SuitMenuAdminCustomURLTestCase(SuitMenuTestCase):
    urls = 'suit.tests.urls.admin_custom'

########NEW FILE########
__FILENAME__ = suit_tags
import datetime
from django.conf import settings
from django.test import TestCase
from suit import utils
from suit.templatetags.suit_tags import suit_conf, suit_date, suit_time, \
    admin_url, field_contents_foreign_linked, suit_bc, suit_bc_value
from django.db import models
from django.contrib import admin
from django.contrib.admin.helpers import AdminReadonlyField


class Country(models.Model):
    name = models.CharField(max_length=64)

    def __unicode__(self):
        return self.name


class City(models.Model):
    name = models.CharField(max_length=64)
    country = models.ForeignKey(Country)

    def __unicode__(self):
        return self.name


class CityAdmin(admin.ModelAdmin):
    readonly_fields = ('country',)
    pass


admin.site.register(Country)
admin.site.register(City, CityAdmin)


class SuitTagsTestCase(TestCase):
    """
    TemplateTags - suit_tags.py test case
    """

    def test_suit_config_string(self):
        admin_name = 'Custom Name'
        settings.SUIT_CONFIG = {
            'ADMIN_NAME': admin_name
        }
        value = suit_conf('ADMIN_NAME')
        self.assertEqual(value, admin_name)
        self.assertTrue('Safe' in value.__class__.__name__)

    def test_suit_config_mark_safe(self):
        list = (1, 2, 3)
        settings.SUIT_CONFIG = {
            'SOME_LIST': list
        }
        value = suit_conf('SOME_LIST')
        self.assertEqual(value, list)
        self.assertEqual(value.__class__.__name__, 'tuple')

    def test_suit_date_and_time(self):
        settings.SUIT_CONFIG = {
            'HEADER_DATE_FORMAT': 'Y-m-d',
            'HEADER_TIME_FORMAT': 'H:i',
        }
        self.assertEqual(datetime.datetime.now().strftime('%Y-%m-%d'),
                         suit_date({}, {}).render({}))
        self.assertEqual(datetime.datetime.now().strftime('%H:%M'),
                         suit_time({}, {}).render({}))

    def test_admin_url(self):
        country = Country(pk=1, name='USA')
        assert '/country/1' in admin_url(country)
        pass

    def test_field_contents_foreign_linked(self):
        country = Country(pk=1, name='France')
        city = City(pk=1, name='Paris', country=country)

        ma = CityAdmin(City, admin.site)

        # Create form
        request = None
        form = ma.get_form(request, city)
        form.instance = city
        ro_field = AdminReadonlyField(form, 'country', True, ma)

        self.assertEqual(country.name,
                         field_contents_foreign_linked(ro_field))

        # Now it should return as link
        ro_field.model_admin.linked_readonly_fields = ('country',)
        assert admin_url(country) in field_contents_foreign_linked(ro_field)

    def test_suit_bc(self):
        args = [utils.django_major_version(), 'a']
        self.assertEqual(utils.value_by_version(args), suit_bc(*args))

    def test_suit_bc_value(self):
        args = [utils.django_major_version(), 'a']
        self.assertEqual(utils.value_by_version(args), suit_bc_value(*args))

########NEW FILE########
__FILENAME__ = test
from . import *

########NEW FILE########
__FILENAME__ = admin_at_root
from django.conf.urls import patterns, include, url
from django.contrib import admin

admin.autodiscover()

urlpatterns = patterns('',
    # Examples for custom menu
    url(r'^', include(admin.site.urls)),
)

########NEW FILE########
__FILENAME__ = admin_custom
from django.conf.urls import patterns, include, url
from django.contrib import admin

admin.autodiscover()

urlpatterns = patterns('',
    # Examples for custom menu
    url(r'^foo/bar/', include(admin.site.urls)),
)

########NEW FILE########
__FILENAME__ = admin_i18n
from django.conf.urls import include, url
from django.conf.urls.i18n import i18n_patterns
from django.contrib import admin

admin.autodiscover()

urlpatterns = i18n_patterns('',
    # Examples for custom menu
    url(r'^admin/', include(admin.site.urls)),
)

########NEW FILE########
__FILENAME__ = utils
from django import get_version
from suit import utils
from django.test import TestCase


class UtilsTestCase(TestCase):
    def test_django_major_version(self):
        self.assertEqual(utils.django_major_version(), float(get_version()[:3]))

    def get_args(self):
        return [1.4, 'x', 1.5, 'y', 's', 'z']

    def test_args_to_dict(self):
        args = self.get_args()
        result = {1.4: 'x', 1.5: 'y', 's': 'z'}
        self.assertEqual(utils.args_to_dict(args), result)

    def test_value_by_version(self):
        args = [utils.django_major_version(), 'a']
        self.assertEqual(utils.value_by_version(args), 'a')


########NEW FILE########
__FILENAME__ = widgets
from django.test import TestCase
from suit.widgets import LinkedSelect, HTML5Input, EnclosedInput, \
    NumberInput, SuitDateWidget, SuitTimeWidget, SuitSplitDateTimeWidget, \
    AutosizedTextarea
from django.utils.translation import ugettext as _
from django.contrib.admin.templatetags.admin_static import static


class WidgetsTestCase(TestCase):
    def test_NumberInput(self):
        inp = NumberInput()
        self.assertEqual('number', inp.input_type)

    def test_HTML5Input(self):
        input_type = 'calendar'
        inp = HTML5Input(input_type=input_type)
        self.assertEqual(input_type, inp.input_type)

    def test_LinkedSelect(self):
        ls = LinkedSelect()
        self.assertTrue('linked-select' in ls.attrs['class'])

    def test_LinkedSelect_with_existing_attr(self):
        ls = LinkedSelect(attrs={'class': 'custom-class', 'custom': 123})
        self.assertEqual('linked-select custom-class', ls.attrs['class'])
        self.assertEqual(ls.attrs['custom'], 123)

    def render_enclosed_widget(self, enclosed_widget):
        return enclosed_widget.render('enc', 123)

    def get_enclosed_widget_html(self, values):
        return '<div class="input-prepend input-append">%s<input name="enc" ' \
               'type="text" value="123" />%s</div>' % values

    def test_EnclosedInput_as_text(self):
        inp = EnclosedInput(prepend='p', append='a')
        output = self.render_enclosed_widget(inp)
        result = ('<span class="add-on">p</span>',
                  '<span class="add-on">a</span>')
        self.assertHTMLEqual(output, self.get_enclosed_widget_html(result))

    def test_EnclosedInput_as_icon(self):
        inp = EnclosedInput(prepend='icon-fire', append='icon-leaf')
        output = self.render_enclosed_widget(inp)
        result = ('<span class="add-on"><i class="icon-fire"></i></span>',
                  '<span class="add-on"><i class="icon-leaf"></i></span>')
        self.assertHTMLEqual(output, self.get_enclosed_widget_html(result))

    def test_EnclosedInput_as_html(self):
        inp = EnclosedInput(prepend='<em>p</em>', append='<em>a</em>')
        output = self.render_enclosed_widget(inp)
        result = ('<em>p</em>', '<em>a</em>')
        self.assertHTMLEqual(output, self.get_enclosed_widget_html(result))

    def test_SuitDateWidget(self):
        sdw = SuitDateWidget()
        self.assertTrue('vDateField' in sdw.attrs['class'])

    def test_SuitDateWidget_with_existing_class_attr(self):
        sdw = SuitDateWidget(attrs={'class': 'custom-class'})
        self.assertTrue('vDateField ' in sdw.attrs['class'])
        self.assertTrue(' custom-class' in sdw.attrs['class'])
        self.assertEqual(_('Date:')[:-1], sdw.attrs['placeholder'])

    def test_SuitDateWidget_with_existing_placeholder_attr(self):
        sdw = SuitDateWidget(attrs={'class': 'custom-cls', 'placeholder': 'p'})
        self.assertTrue('vDateField ' in sdw.attrs['class'])
        self.assertTrue(' custom-cls' in sdw.attrs['class'])
        self.assertEqual('p', sdw.attrs['placeholder'])

    def get_SuitDateWidget_output(self):
        return '<div class="input-append suit-date"><input class="vDateField ' \
               'input-small " name="sdw" placeholder="Date" ' \
               'size="10" type="text" /><span class="add-on"><i ' \
               'class="icon-calendar"></i></span></div>'

    def test_SuitDateWidget_output(self):
        sdw = SuitDateWidget(attrs={'placeholder': 'Date'})
        output = sdw.render('sdw', '')
        self.assertHTMLEqual(
            self.get_SuitDateWidget_output(), output)

    def test_SuitTimeWidget(self):
        sdw = SuitTimeWidget()
        self.assertTrue('vTimeField' in sdw.attrs['class'])

    def test_SuitTimeWidget_with_existing_class_attr(self):
        sdw = SuitTimeWidget(attrs={'class': 'custom-class'})
        self.assertTrue('vTimeField ' in sdw.attrs['class'])
        self.assertTrue(' custom-class' in sdw.attrs['class'])
        self.assertEqual(_('Time:')[:-1], sdw.attrs['placeholder'])

    def test_SuitTimeWidget_with_existing_placeholder_attr(self):
        sdw = SuitTimeWidget(attrs={'class': 'custom-cls', 'placeholder': 'p'})
        self.assertTrue('vTimeField ' in sdw.attrs['class'])
        self.assertTrue(' custom-cls' in sdw.attrs['class'])
        self.assertEqual('p', sdw.attrs['placeholder'])

    def get_SuitTimeWidget_output(self):
        return '<div class="input-append suit-date suit-time"><input ' \
               'class="vTimeField input-small " name="sdw" ' \
               'placeholder="Time" size="8" type="text" /><span ' \
               'class="add-on"><i class="icon-time"></i></span></div>'

    def test_SuitTimeWidget_output(self):
        sdw = SuitTimeWidget(attrs={'placeholder': 'Time'})
        output = sdw.render('sdw', '')
        self.assertHTMLEqual(
            self.get_SuitTimeWidget_output(),
            output)

    def test_SuitSplitDateTimeWidget(self):
        ssdtw = SuitSplitDateTimeWidget()
        output = ssdtw.render('sdw', '')
        dwo = self.get_SuitDateWidget_output().replace('sdw', 'sdw_0')
        two = self.get_SuitTimeWidget_output().replace('sdw', 'sdw_1')
        self.assertHTMLEqual(output, '<div class="datetime">%s %s</div>' %
                                     (dwo, two))

    def test_AutosizedTextarea(self):
        txt = AutosizedTextarea()
        self.assertTrue('autosize' in txt.attrs['class'])
        self.assertEqual(2, txt.attrs['rows'])

    def test_AutosizedTextarea_with_existing_attrs(self):
        txt = AutosizedTextarea(attrs={'class': 'custom-class', 'rows': 3})
        self.assertTrue('autosize ' in txt.attrs['class'])
        self.assertTrue(' custom-class' in txt.attrs['class'])
        self.assertEqual(txt.attrs['rows'], 3)

    def test_AutosizedTextarea_output(self):
        txt = AutosizedTextarea()
        self.assertHTMLEqual(txt.render('txt', ''), (
            '<textarea class="autosize " cols="40" name="txt" '
            'rows="2">\r\n</textarea><script type="text/javascript">Suit.$('
            '\'#id_txt\').autosize();</script>'))

    def test_AutosizedTextarea_media(self):
        txt = AutosizedTextarea()
        js_url = static('suit/js/jquery.autosize-min.js')
        self.assertHTMLEqual(str(txt.media),
                             '<script type="text/javascript" src="%s"></script>'
                             % js_url)

########NEW FILE########
__FILENAME__ = utils
from django import VERSION


def django_major_version():
    return float('.'.join([str(i) for i in VERSION][:2]))


def value_by_version(args):
    """
    Return value by version
    Return latest value if version not found
    """
    version_map = args_to_dict(args)
    return version_map.get(django_major_version(),
                           list(version_map.values())[-1])


def args_to_dict(args):
    """
    Convert template tag args to dict
    Format {% suit_bc 1.5 'x' 1.6 'y' %} to { '1.5': 'x', '1.6': 'y' }
    """
    return dict(zip(args[0::2], args[1::2]))

########NEW FILE########
__FILENAME__ = watch_less
import sys
import os
import time

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler, FileModifiedEvent


class LessCompiler(FileSystemEventHandler):

    def __init__(self, source):
        self.source = source
        FileSystemEventHandler.__init__(self)

    def compile_css(self):
        if len(sys.argv) < 3:
            destination = self.source.replace('less', 'css')
        else:
            destination = sys.argv[2]
        cmd = 'lessc %s > %s -x' % (source, os.path.abspath(destination))
        print(cmd)
        os.system(cmd)

    def on_any_event(self, event):
        if '__' not in event.src_path and isinstance(event, FileModifiedEvent):
            self.compile_css()


if __name__ == "__main__":

    if len(sys.argv) < 2:
        sys.stderr.write(
            'Usage: %s source [destination=../css/$1.css]\n' % sys.argv[0])
        sys.exit(1)

    source = os.path.abspath(sys.argv[1])
    event_handler = LessCompiler(source)
    # Run once at startup
    event_handler.compile_css()
    observer = Observer()
    observer.schedule(event_handler, os.path.dirname(source), recursive=True)
    observer.start()
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        observer.stop()
    observer.join()

########NEW FILE########
__FILENAME__ = widgets
from django.contrib.admin.widgets import AdminTimeWidget, AdminDateWidget
from django.forms import TextInput, Select, Textarea
from django.utils.safestring import mark_safe
from django import forms
from django.utils.translation import ugettext as _
from django.contrib.admin.templatetags.admin_static import static


class NumberInput(TextInput):
    """
    HTML5 Number input
    Left for backwards compatibility
    """
    input_type = 'number'


class HTML5Input(TextInput):
    """
    Supports any HTML5 input
    http://www.w3schools.com/html/html5_form_input_types.asp
    """

    def __init__(self, attrs=None, input_type=None):
        self.input_type = input_type
        super(HTML5Input, self).__init__(attrs)


#
class LinkedSelect(Select):
    """
    Linked select - Adds link to foreign item, when used with foreign key field
    """

    def __init__(self, attrs=None, choices=()):
        attrs = _make_attrs(attrs, classes="linked-select")
        super(LinkedSelect, self).__init__(attrs, choices)


class EnclosedInput(TextInput):
    """
    Widget for bootstrap appended/prepended inputs
    """

    def __init__(self, attrs=None, prepend=None, append=None):
        """
        For prepend, append parameters use string like %, $ or html
        """
        self.prepend = prepend
        self.append = append
        super(EnclosedInput, self).__init__(attrs=attrs)

    def enclose_value(self, value):
        """
        If value doesn't starts with html open sign "<", enclose in add-on tag
        """
        if value.startswith("<"):
            return value
        if value.startswith("icon-"):
            value = '<i class="%s"></i>' % value
        return '<span class="add-on">%s</span>' % value

    def render(self, name, value, attrs=None):
        output = super(EnclosedInput, self).render(name, value, attrs)
        div_classes = []
        if self.prepend:
            div_classes.append('input-prepend')
            self.prepend = self.enclose_value(self.prepend)
            output = ''.join((self.prepend, output))
        if self.append:
            div_classes.append('input-append')
            self.append = self.enclose_value(self.append)
            output = ''.join((output, self.append))

        return mark_safe(
            '<div class="%s">%s</div>' % (' '.join(div_classes), output))


class AutosizedTextarea(Textarea):
    """
    Autosized Textarea - textarea height dynamically grows based on user input
    """

    def __init__(self, attrs=None):
        new_attrs = _make_attrs(attrs, {"rows": 2}, "autosize")
        super(AutosizedTextarea, self).__init__(new_attrs)

    @property
    def media(self):
        return forms.Media(js=[static("suit/js/jquery.autosize-min.js")])

    def render(self, name, value, attrs=None):
        output = super(AutosizedTextarea, self).render(name, value, attrs)
        output += mark_safe(
            "<script type=\"text/javascript\">Suit.$('#id_%s').autosize();</script>"
            % name)
        return output


#
# Original date widgets with addition html
#
class SuitDateWidget(AdminDateWidget):
    def __init__(self, attrs=None, format=None):
        defaults = {'placeholder': _('Date:')[:-1]}
        new_attrs = _make_attrs(attrs, defaults, "vDateField input-small")
        super(SuitDateWidget, self).__init__(attrs=new_attrs, format=format)

    def render(self, name, value, attrs=None):
        output = super(SuitDateWidget, self).render(name, value, attrs)
        return mark_safe(
            '<div class="input-append suit-date">%s<span '
            'class="add-on"><i class="icon-calendar"></i></span></div>' %
            output)


class SuitTimeWidget(AdminTimeWidget):
    def __init__(self, attrs=None, format=None):
        defaults = {'placeholder': _('Time:')[:-1]}
        new_attrs = _make_attrs(attrs, defaults, "vTimeField input-small")
        super(SuitTimeWidget, self).__init__(attrs=new_attrs, format=format)

    def render(self, name, value, attrs=None):
        output = super(SuitTimeWidget, self).render(name, value, attrs)
        return mark_safe(
            '<div class="input-append suit-date suit-time">%s<span '
            'class="add-on"><i class="icon-time"></i></span></div>' %
            output)


class SuitSplitDateTimeWidget(forms.SplitDateTimeWidget):
    """
    A SplitDateTime Widget that has some admin-specific styling.
    """

    def __init__(self, attrs=None):
        widgets = [SuitDateWidget, SuitTimeWidget]
        forms.MultiWidget.__init__(self, widgets, attrs)

    def format_output(self, rendered_widgets):
        out_tpl = '<div class="datetime">%s %s</div>'
        return mark_safe(out_tpl % (rendered_widgets[0], rendered_widgets[1]))


def _make_attrs(attrs, defaults=None, classes=None):
    result = defaults.copy() if defaults else {}
    if attrs:
        result.update(attrs)
    if classes:
        result["class"] = " ".join((classes, result.get("class", "")))
    return result

########NEW FILE########
