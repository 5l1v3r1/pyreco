__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# dRest documentation build configuration file, created by
# sphinx-quickstart on Fri Dec 16 19:22:53 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

VERSION = '0.9'
RELEASE = '0.9.13'

sys.path.insert(0, os.path.abspath('../../src/drest/'))

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = [
    'sphinx.ext.autodoc',
    'sphinx.ext.extlinks',
    ]

extlinks = {'issue' : ('https://github.com/derks/drest/issues/%s', 'Issue #')}

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = 'dRest'
copyright = '2012, BJ Dierkes'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = VERSION

# The full version, including alpha/beta/rc tags.
release = RELEASE

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'nature'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'dRestdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'dRest.tex', 'dRest Documentation',
   'BJ Dierkes', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'drest', 'dRest Documentation',
     ['BJ Dierkes'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'dRest', 'dRest Documentation',
   'BJ Dierkes', 'dRest', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = api
"""dRest core API connection library."""

import re
from . import interface, resource, request, serialization, meta, exc
from . import response

class API(meta.MetaMixin):
    """
    The API class acts as a high level 'wrapper' around multiple lower level
    handlers.  Most of the meta arguments are optionally passed to one or 
    more handlers upon instantiation.  All handler classes must be passed
    *un-instantiated*.
    
    Arguments:
    
        baseurl
            Translated to self.baseurl (for convenience).
            
    Optional Arguments and Meta:
        
        debug
            Boolean.  Toggle debug console output.  Default: False.
            
        baseurl
            The base url to the API endpoint.
            
        request_handler
            The Request Handler class that performs the actual HTTP (or other) 
            requests.  Default: drest.request.RequestHandler.
            
        resource_handler
            The Resource Handler class that is used when api.add_resource is
            called.  Default: drest.resource.ResourceHandler.
        
        response_handler
            An un-instantiated Response Handler class used to return 
            responses to the caller.  Default: drest.response.ResponseHandler.
            
        serialization_handler
            An un-instantiated Serialization Handler class used to 
            serialize/deserialize data.  
            Default: drest.serialization.JsonSerializationHandler.
                
        ignore_ssl_validation
            Boolean.  Whether or not to ignore ssl validation errors.  
            Default: False
            
        serialize
            Boolean.  Whether or not to serialize data before sending 
            requests.  Default: False.
        
        deserialize
            Boolean.  Whether or not to deserialize data before returning
            the Response object.  Default: True.
            
        trailing_slash
            Boolean.  Whether or not to append a trailing slash to the 
            request url.  Default: True.
        
        extra_headers
            A dictionary of key value pairs that are added to the HTTP headers
            of *every* request.  Passed to request_handler.add_header().
        
        extra_params
            A dictionary of key value pairs that are added to the POST, or 
            'payload' data sent with *every* request.  Passed to 
            request_handler.add_param().
            
        extra_url_params
            A dictionary of key value pairs that are added to the GET/URL
            parameters of *every* request.  Passed to 
            request_handler.add_extra_url_param().
    
        timeout
            The amount of seconds where a request should timeout.  Default: 30

    Usage
    
    .. code-block:: python
    
        import drest

        # Create a generic client api object
        api = drest.API('http://localhost:8000/api/v1/')

        # Or something more customized:
        api = drest.API(
            baseurl='http://localhost:8000/api/v1/',
            trailing_slash=False,
            ignore_ssl_validation=True,
            )

        # Or even more so:
        class MyAPI(drest.API):
            class Meta:
                baseurl = 'http://localhost:8000/api/v1/'
                extra_headers = dict(MyKey='Some Value For Key')
                extra_params = dict(some_param='some_value')
                request_handler = MyCustomRequestHandler
        api = MyAPI()

        # By default, the API support HTTP Basic Auth with username/password.
        api.auth('john.doe', 'password')

        # Make calls openly
        response = api.make_request('GET', '/users/1/')

        # Or attach a resource
        api.add_resource('users')

        # Get available resources
        api.resources

        # Get all objects of a resource
        response = api.users.get()

        # Get a single resource with primary key '1'
        response = api.users.get(1)

        # Update a resource with primary key '1'
        response = api.users.get(1)
        updated_data = response.data.copy()
        updated_data['first_name'] = 'John'
        updated_data['last_name'] = 'Doe'

        response = api.users.put(data['id'], updated_data)

        # Create a resource
        user_data = dict(
            username='john.doe',
            password='oober-secure-password',
            first_name='John',
            last_name='Doe',
            )
        response = api.users.post(user_data)

        # Delete a resource with primary key '1'
        response = api.users.delete(1)
    """
    class Meta:
        baseurl = None
        request_handler = request.RequestHandler
        resource_handler = resource.RESTResourceHandler
        extra_headers = {}
        extra_params = {}
        extra_url_params = {}
        
    def __init__(self, baseurl=None, **kw):
        if baseurl:
            kw['baseurl'] = baseurl
        super(API, self).__init__(**kw)        
        
        self.baseurl = self._meta.baseurl.strip('/')
        self._resources = []

        self._setup_request_handler(**kw)
        
    def _setup_request_handler(self, **kw):
        request.validate(self._meta.request_handler)
        self.request = self._meta.request_handler(**kw)

        # just makes things easier to be able to wrap meta under the api
        # and pass it to the request handler.
        for meta in dir(self._meta):
            if meta.startswith('_'):
                continue
            if hasattr(self.request._meta, meta):
                setattr(self.request._meta, meta, getattr(self._meta, meta))
                
        for key in self._meta.extra_headers:
            self.request.add_header(key, self._meta.extra_headers[key])
        
        for key in self._meta.extra_params:
            self.request.add_param(key, self._meta.extra_params[key])
        
        for key in self._meta.extra_url_params:
            self.request.add_url_param(key, self._meta.extra_url_params[key])
            
    def auth(self, user, password, **kw):
        """
        This authentication mechanism implements HTTP Basic Authentication.
                        
        Required Arguments:
        
            user
                The API username.
                
            password
                The password of that user.
                
        """
        self.request.set_auth_credentials(user, password)
            
    def make_request(self, method, path, params=None, headers=None):
        if params is None:
            params = {}
        if headers is None:
            headers = {}
        url = "%s/%s/" % (self.baseurl.strip('/'), path.strip('/'))
        return self.request.make_request(method, url, params, headers)
        
    @property
    def resources(self):
        return self._resources
        
    def add_resource(self, name, resource_handler=None, path=None):
        """
        Add a resource handler to the api object.
        
        Required Arguments:
        
            name
                The name of the resource.  This is generally the basic name 
                of the resource on the API.  For example '/api/v0/users/' 
                would likely be called 'users' and will be accessible as
                'api.users' from which additional calls can be made.  For 
                example 'api.users.get()'.  
        
        Optional Arguments:
        
            resource_handler
                The resource handler class to use.  Defaults to 
                self._meta.resource_handler.
            
            path
                The path to the resource on the API (after the base url).
                Defaults to '/<name>/'.
        
        
        Nested Resources:
            
        It is possible to attach resources in a 'nested' fashion.  For example
        passing a name of 'my.nested.users' would be accessible as 
        api.my.nested.users.get().
        
        Usage:
        
        .. code-block:: python
        
            api.add_resource('users')
            response = api.users.get()
            
            # Or for nested resources
            api.add_resource('my.nested.users', path='/users/')
            response = api.my.nested.users.get()
            
        """
        safe_list = ['.', '_']
        for char in name:
            if char in safe_list:
                continue
            if not char.isalnum():
                raise exc.dRestResourceError(
                    "resource name must be alpha-numeric."
                    )
        
        if not path:
            path = '%s' % name
        else:
            path = path.strip('/')
            
        if not resource_handler:
            resource_handler = self._meta.resource_handler
            
        resource.validate(resource_handler)
        handler = resource_handler(self, name, path)
        if hasattr(self, name):
            raise exc.dRestResourceError(
                "The object '%s' already exist on '%s'" % (name, self))
                    
        
        # break up if nested
        parts = name.split('.')
        if len(parts) == 1:
            setattr(self, name, handler)
        elif len(parts) > 1:
            first = parts.pop(0)
            last = parts.pop()
            
            # add the first object to self
            setattr(self, first, resource.NestedResource())
            first_obj = getattr(self, first)
            current_obj = first_obj
            
            # everything in between
            for part in parts:
                setattr(current_obj, part, resource.NestedResource())
                current_obj = getattr(current_obj, part)
            
            # add the actual resource to the chain of nested objects
            setattr(current_obj, last, handler)        
            
        self._resources.append(name)
        
class TastyPieAPI(API):
    """
    This class implements an API client, specifically tailored for
    interfacing with `TastyPie <http://django-tastypie.readthedocs.org/en/latest>`_.
    
    Optional / Meta Arguments:
    
        auth_mech
            The auth mechanism to use.  One of ['basic', 'api_key'].
            Default: 'api_key'.
            
        auto_detect_resources
            Boolean.  Whether or not to auto detect, and add resource objects
            to the api.  Default: True.
            
    
    Authentication Mechanisms
    
    Currently the only supported authentication mechanism are:
    
        * ApiKeyAuthentication
        * BasicAuthentication
    
    Usage
    
    Please note that the following example use ficticious resource data.  
    What is returned, and sent to the API is unique to the API itself.  Please
    do not copy and paste any of the following directly without modifying the
    request parameters per your use case.
    
    Create the client object, and authenticate with a user/api_key pair by 
    default:
    
    .. code-block:: python
    
        import drest
        api = drest.api.TastyPieAPI('http://localhost:8000/api/v0/')
        api.auth('john.doe', '34547a497326dde80bcaf8bcee43e3d1b5f24cc9')
    
    
    OR authenticate against HTTP Basic Auth:
    
    .. code-block:: python
    
        import drest
        api = drest.api.TastyPieAPI('http://localhost:8000/api/v0/',
                                    auth_mech='basic')
        api.auth('john.doe', 'my_password')
    
    
    As drest auto-detects TastyPie resources, you can view those at:
    
    .. code-block:: python    
    
        api.resources
        
    And access their schema:
    
    .. code-block:: python  
    
        api.users.schema
        
    As well as make the usual calls such as:
    
    .. code-block:: python  
    
        api.users.get()
        api.users.get(<pk>)
        api.users.put(<pk>, data_dict)
        api.users.post(data_dict)
        api.users.delete(<pk>)
        
    What about filtering? (these depend on how the `API is configured <http://django-tastypie.readthedocs.org/en/latest/resources.html#basic-filtering>`_):
    
    .. code-block:: python
    
        api.users.get(params=dict(username='admin'))
        api.users.get(params=dict(username__icontains='admin'))
        ...
        
    See :mod:`drest.api.API` for more standard usage examples.
        
    """
    class Meta:
        request_handler = request.TastyPieRequestHandler
        resource_handler = resource.TastyPieResourceHandler
        auto_detect_resources = True
        auth_mech = 'api_key'
        
    auth_mechanizms = ['api_key', 'basic']
        
    def __init__(self, *args, **kw):
        super(TastyPieAPI, self).__init__(*args, **kw)
        if self._meta.auto_detect_resources:
            self.find_resources()
    
    def auth(self, *args, **kw):
        """
        Authenticate the request, determined by Meta.auth_mech.  Arguments
        and Keyword arguments are just passed to the auth_mech function.
        
        """
        if self._meta.auth_mech in self.auth_mechanizms:
            func = getattr(self, '_auth_via_%s' % self._meta.auth_mech)
            func(*args, **kw)
        else:
            raise exc.dRestAPIError("Unknown TastyPie auth mechanism.")
            
    def _auth_via_basic(self, user, password, **kw):
        """
        This is just a wrapper around drest.api.API.auth().
        
        """
        return super(TastyPieAPI, self).auth(user, password)
    
    def _auth_via_api_key(self, user, api_key, **kw):
        """
        This authentication mechanism adds an Authorization header for 
        user/api_key per the 
        `TastyPie Documentation <http://django-tastypie.readthedocs.org/en/latest/authentication_authorization.html>`_.
                        
        Required Arguments:
        
            user
                The API username.
                
            api_key
                The API Key of that user.
                
        """
        key = 'Authorization'
        value = 'ApiKey %s:%s' % (user, api_key)
        self.request.add_header(key, value)
       
    def find_resources(self):
        """
        Find available resources, and add them via add_resource().
        
        """
        response = self.make_request('GET', '/')
        for resource in list(response.data.keys()):
            if resource not in self._resources:
                self.add_resource(resource)
    

########NEW FILE########
__FILENAME__ = exc

class dRestError(Exception):
    """Generic dRest Errors."""
    def __init__(self, msg):
        self.msg = msg
    
    def __repr__(self):
        return "<dRestError: %s>" % self.msg
    
    def __str__(self):
        return str(self.msg)
    
class dRestInterfaceError(dRestError):
    """dRest Interface Errors."""
    
    def __init__(self, msg):
        super(dRestInterfaceError, self).__init__(msg)
    
    def __repr__(self):
        return "dRestInterfaceError: %s" % self.msg
        
class dRestRequestError(dRestError):
    """dRest Request Errors."""
    def __init__(self, msg, response):
        super(dRestRequestError, self).__init__(msg)
        self.response = response
    
    def __repr__(self):
        return "dRestRequestError: %s" % self.msg
            
class dRestResourceError(dRestError):
    """dRest Resource Errors."""
    
    def __init__(self, msg):
        super(dRestResourceError, self).__init__(msg)
    
    def __repr__(self):
        return "dRestResourceError: %s" % self.msg
        
class dRestAPIError(dRestError):
    """dRest API Errors."""
    
    def __init__(self, msg):
        super(dRestAPIError, self).__init__(msg)
    
    def __repr__(self):
        return "dRestAPIError: %s" % self.msg
        
########NEW FILE########
__FILENAME__ = interface

from . import exc

class Interface(object):
    """
    This is an abstract base class that all interface classes should 
    subclass from.
    
    """
    def __init__(self):
        """
        An interface definition class.  All Interfaces should subclass from
        here.  Note that this is not an implementation and should never be
        used directly.
        """
        raise exc.dRestInterfaceError("Interfaces can not be used directly.")
            
class Attribute(object):
    """
    Defines an Interface attribute.
    
    Usage:
    
    .. code-block:: python
    
        from drest import interface
        
        class MyInterface(interface.Interface):
            my_attribute = interface.Attribute("A description of my_attribute.")
            
    """
    def __init__(self, description):
        """
        An interface attribute definition.
        
        Required Arguments:
        
            description
                The description of the attribute.
                
        """
        self.description = description
    
    def __repr__(self):
        return "Attribute: %s" % self.description
    
    def __str__(self):
        return str(self.__repr__())    
        
def validate(interface, obj, members, metas=[]):
    """
    A wrapper to validate interfaces.
    
    Required Arguments:
    
        interface
            The interface class to validate against
            
        obj
            The object to validate.
            
        members
            A list of object members that must exist.
            
    Optional Arguments:
        
        metas
            A list of meta parameters that must exist.
             
    """
    invalid = []

    for member in members:
        if not hasattr(obj, member):
            invalid.append(member)
            
    if hasattr(obj, '_meta'):
        for meta in metas:
            if not hasattr(obj._meta, meta):
                invalid.append('_meta.%s' % meta)
            
    if invalid:
        raise exc.dRestInterfaceError("Invalid or missing: %s in %s" % \
                                      (invalid, obj))
########NEW FILE########
__FILENAME__ = meta
"""dRest core meta functionality.  Barrowed from http://slumber.in/."""

class Meta(object):
    """
    Model that acts as a container class for a meta attributes for a larger
    class. It stuffs any kwarg it gets in it's init as an attribute of itself.

    """

    def __init__(self, **kw):
        self._merge(kw)

    def _merge(self, dict_obj):
        for key, value in dict_obj.items():
            setattr(self, key, value)
            
class MetaMixin(object):
    """
    Mixin that provides the Meta class support to add settings to instances
    of slumber objects. Meta settings cannot start with a _.

    """

    def __init__(self, *args, **kw):
        # Get a List of all the Classes we in our MRO, find any attribute named
        #     Meta on them, and then merge them together in order of MRO
        metas = reversed([x.Meta for x in self.__class__.mro() \
                                  if hasattr(x, "Meta")])
        final_meta = {}

        # Merge the Meta classes into one dict
        for meta in metas:
            final_meta.update(dict([x for x in list(meta.__dict__.items()) \
                                       if not x[0].startswith("_")]))

        # Update the final Meta with any kw passed in
        for key in list(final_meta.keys()):
            if key in kw:
                final_meta[key] = kw.pop(key)

        self._meta = Meta(**final_meta)

        # FIX ME: object.__init__() doesn't take params without exception
        super(MetaMixin, self).__init__()
########NEW FILE########
__FILENAME__ = request

import os
import sys

if sys.version_info[0] < 3:
    import httplib # pragma: no cover
    from urllib import urlencode # pragma: no cover
    from urllib2 import urlopen # pragma: no cover

else:
    from http import client as httplib # pragma: no cover
    from urllib.parse import urlencode # pragma: no cover
    from urllib.request import urlopen # pragma: no cover

import socket
from httplib2 import Http, ServerNotFoundError

from . import exc, interface, meta, serialization, response

def validate(obj):
    """Validates a handler implementation against the IRequest interface."""
    members = [
        'add_param',
        'add_url_param',
        'add_header',
        'make_request',
        'handle_response',
        ]
    metas = [
        'response_handler',
        'serialization_handler',
        'serialize',
        'deserialize',
        ]
    interface.validate(IRequest, obj, members, metas)

class IRequest(interface.Interface):
    """
    This class defines the Request Handler Interface.  Classes that
    implement this handler must provide the methods and attributes defined
    below.

    All implementations must provide sane 'default' functionality when
    instantiated with no arguments.  Meaning, it can and should accept
    optional parameters that alter how it functions, but can not require
    any parameters.

    Implementations do *not* subclass from interfaces.

    """

    def add_param(key, value):
        """
        Add extra parameters to pass along with  *every* request.
        These are passed with the request 'payload' (serialized if a
        serialization handler is enabled).  With GET requests they are
        appended to the URL.

        Required Arguments:

            key
                The key of the parameter to add.

            value
                The value of the parameter to add.

        """

    def add_url_param(key, value):
        """
        Similar to 'add_params', however this function adds extra parameters
        to the url for *every* request.
        These are *not* passed with the request 'payload' (serialized if a
        serialization handler is enabled) except for GET requests.

        Required Arguments:

            key
                The key of the parameter to add.

            value
                The value of the parameter to add.

        """


    def add_header(key, value):
        """
        Add extra headers to pass along with *every* request.

        Required Arguments:

            key
                The key of the header to add.

            value
                The value of the header to add.

        """

    def make_request(method, path, params=None, headers=None):
        """
        Make a request with the upstream API.

        Required Arguments:

            method
                The HTTP method to request as.  I.e. ['GET', 'POST', 'PUT',
                'DELETE', '...'].

            path
                The of the request url *after* the baseurl.


        Optional Arguments:

            params
                Dictionary of parameters to pass with the request.  These will be serialized
                if configured to serialize.

            headers
                Dictionary of headers to pass to the request.

        """

    def handle_response(response_object):
        """
        Called after the request is made.  This is a convenient place for
        developers to handle what happens during every request per their
        application needs.

        Required Arguments:

            response_object
                The response object created by the request.

        """

class RequestHandler(meta.MetaMixin):
    """
    Generic class that handles HTTP requests.  Uses the Json Serialization
    handler by default, but only 'deserializes' response content.

    Optional Arguments / Meta:

        debug
            Boolean.  Toggle debug console output.  Default: False.

        ignore_ssl_validation
            Boolean.  Whether or not to ignore ssl validation errors.
            Default: False

        response_handler
            An un-instantiated Response Handler class used to return
            responses to the caller.  Default: drest.response.ResponseHandler.

        serialization_handler
            An un-instantiated Serialization Handler class used to
            serialize/deserialize data.
            Default: drest.serialization.JsonSerializationHandler.

        serialize
            Boolean.  Whether or not to serialize data before sending
            requests.  Default: False.

        deserialize
            Boolean.  Whether or not to deserialize data before returning
            the Response object.  Default: True.

        trailing_slash
            Boolean.  Whether or not to append a trailing slash to the
            request url.  Default: True.

        timeout
            The amount of seconds where a request should timeout.
            Default: None

    """
    class Meta:
        debug = False
        ignore_ssl_validation = False
        response_handler = response.ResponseHandler
        serialization_handler = serialization.JsonSerializationHandler
        serialize = False
        deserialize = True
        trailing_slash = True
        allow_get_body = False
        timeout = None

    def __init__(self, **kw):
        super(RequestHandler, self).__init__(**kw)
        self._extra_params = {}
        self._extra_url_params = {}
        self._extra_headers = {}
        self._auth_credentials = ()
        self._http = None

        if 'DREST_DEBUG' in os.environ and \
           os.environ['DREST_DEBUG'] in [1, '1']:
            self._meta.debug = True

        response.validate(self._meta.response_handler)
        if self._meta.serialization_handler:
            serialization.validate(self._meta.serialization_handler)
            self._serialization = self._meta.serialization_handler(**kw)
            headers = self._serialization.get_headers()
            for key in headers:
                self.add_header(key, headers[key])
        else:
            self._meta.serialize = False
            self._meta.deserialize = False

    def _serialize(self, data):
        if self._meta.serialize:
            return self._serialization.serialize(data)
        else:
            return data

    def _deserialize(self, data):
        if self._meta.deserialize:
            return self._serialization.deserialize(data)
        else:
            return data

    def set_auth_credentials(self, user, password):
        """
        Set the authentication user and password that will be used for
        HTTP Basic and Digest Authentication.

        Required Arguments:

            user
                The authentication username.

            password
                That user's password.

        """
        self._auth_credentials = (user, password)
        self._clear_http()

    def add_param(self, key, value):
        """
        Adds a key/value to self._extra_params, which is sent with every
        request.

        Required Arguments:

            key
                The key of the parameter.

            value
                The value of 'key'.

        """
        self._extra_params[key] = value

    def add_url_param(self, key, value):
        """
        Adds a key/value to self._extra_url_params, which is sent with every
        request (in the URL).

        Required Arguments:

            key
                The key of the parameter.

            value
                The value of 'key'.

        """
        self._extra_url_params[key] = value

    def add_header(self, key, value):
        """
        Adds a key/value to self._extra_headers, which is sent with every
        request.

        Required Arguments:

            key
                The key of the parameter.

            value
                The value of 'key'.

        """
        self._extra_headers[key] = value

    def _get_http(self):
        """
        Returns either the existing (cached) httplib2.Http() object, or
        a new instance of one.

        """
        if self._http == None:
            if self._meta.ignore_ssl_validation:
                self._http = Http(disable_ssl_certificate_validation=True,
                                  timeout=self._meta.timeout)
            else:
                self._http = Http(timeout=self._meta.timeout)

            if self._auth_credentials:
                self._http.add_credentials(self._auth_credentials[0],
                                           self._auth_credentials[1])
        return self._http

    def _clear_http(self):
        self._http = None

    def _make_request(self, url, method, payload=None, headers=None):
        """
        A wrapper around httplib2.Http.request.

        Required Arguments:

            url
                The url of the request.

            method
                The method of the request. I.e. 'GET', 'PUT', 'POST', 'DELETE'.

        Optional Arguments:

            payload
                The urlencoded parameters.

            headers
                Additional headers of the request.

        """
        if payload is None:
            if self._meta.serialize:
                payload = self._serialize({})
            else:
                payload = urlencode({})
        if headers is None:
            headers = {}

        try:
            http = self._get_http()
            return http.request(url, method, payload, headers=headers)

        except socket.error as e:
            # Try again just in case there was an issue with the cached _http
            try:
                self._clear_http()
                return self._get_http().request(url, method, payload,
                                                headers=headers)
            except socket.error as e:
                raise exc.dRestAPIError(e)

        except ServerNotFoundError as e:
            raise exc.dRestAPIError(e.args[0])

    def _get_complete_url(self, method, url, params):
        url = "%s%s" % (url.strip('/'), '/' if self._meta.trailing_slash else '')

        if method == 'GET':
            url_params = dict(self._extra_url_params, **params)
        else:
            url_params = self._extra_url_params

        if url_params:
            url = "%s?%s" % (url, urlencode(url_params))

        return url

    def make_request(self, method, url, params=None, headers=None):
        """
        Make a call to a resource based on path, and parameters.

        Required Arguments:

            method
                One of HEAD, GET, POST, PUT, PATCH, DELETE, etc.

            url
                The full url of the request (without any parameters).  Any
                params (with GET method) and self.extra_url_params will be
                added to this url.

        Optional Arguments:

            params
                Dictionary of additional (one-time) keyword arguments for the
                request.

            headers
                Dictionary of additional (one-time) headers of the request.

        """
        if params is None:
            params = {}
        if headers is None:
            headers = {}
        params = dict(self._extra_params, **params)
        headers = dict(self._extra_headers, **headers)
        url = self._get_complete_url(method, url, params)

        if self._meta.serialize:
            payload = self._serialize(params)
        else:
            payload = urlencode(params)

        if self._meta.debug:
            print('DREST_DEBUG: method=%s url=%s params=%s headers=%s' % \
                   (method, url, payload, headers))


        if method is 'GET' and not self._meta.allow_get_body:
            payload = ''
            if self._meta.debug:
                print("DREST_DEBUG: supressing body for GET request")

        res_headers, data = self._make_request(url, method, payload,
                                               headers=headers)
        unserialized_data = data
        serialized_data = None
        if self._meta.deserialize:
            serialized_data = data
            data = self._deserialize(data)

        return_response = response.ResponseHandler(
            int(res_headers['status']), data, res_headers,
            )

        return self.handle_response(return_response)

    def handle_response(self, response_object):
        """
        A simple wrapper to handle the response.  By default raises
        exc.dRestRequestError if the response code is within 400-499, or 500.
        Must return the original, or modified, response object.

        Required Arguments:

            response_object
                The response object created by the request.

        """
        response = response_object
        if (400 <= response.status <=499) or (response.status == 500):
            msg = "Received HTTP Code %s - %s" % (
                   response.status,
                   httplib.responses[int(response.status)])
            raise exc.dRestRequestError(msg, response=response)
        return response

class TastyPieRequestHandler(RequestHandler):
    """
    This class implements the IRequest interface, specifically tailored for
    interfacing with `TastyPie <http://django-tastypie.readthedocs.org/en/latest>`_.

    See :mod:`drest.request.RequestHandler` for Meta options and usage.

    """
    class Meta:
        serialize = True
        deserialize = True
        serialization_handler  = serialization.JsonSerializationHandler

    def __init__(self, **kw):
        super(TastyPieRequestHandler, self).__init__(**kw)

########NEW FILE########
__FILENAME__ = resource

import re
from . import interface, exc, meta, request

def validate(obj):
    """Validates a handler implementation against the IResource interface."""
    members = [
        'filter',
        ]
    metas = [
        'baseurl',
        'resource',
        'path',
        'request',
        ]
    interface.validate(IResource, obj, members)

class IResource(interface.Interface):
    """
    This class defines the Resource Handler Interface.  Classes that
    implement this handler must provide the methods and attributes defined
    below.

    All implementations must provide sane 'default' functionality when
    instantiated with no arguments.  Meaning, it can and should accept
    optional parameters that alter how it functions, but can not require
    any parameters.

    Implementations do *not* subclass from interfaces.

    """

class ResourceHandler(meta.MetaMixin):
    """
    This class acts as a base class that other resource handler should
    subclass from.

    """
    class Meta:
        pass

    def __init__(self, api_obj, name, path, **kw):
        super(ResourceHandler, self).__init__(**kw)
        self.api = api_obj
        self.path = path
        self.name = name

    def filter(self, params):
        """
        Give the ability to alter params before sending the request.

        Required Arguments:

            params
                The list of params that will be passed to the endpoint.

        """
        return params

class RESTResourceHandler(ResourceHandler):
    """
    This class implements the IResource interface, specifically for
    interacting with REST-like resources.  It provides convenient functions
    that wrap around the typical GET, PUT, POST, DELETE actions.

    Optional Arguments / Meta:

        api_obj
            The api (parent) object that this resource is being attached to.

        name
            The name of the resource on the API.

        path
            The path to the resource (after api.baseurl).

    Usage:

    .. code-block:: python

        import drest

        class MyAPI(drest.api.API):
            class Meta:
                resource_handler = drest.resource.RESTResourceHandler
        ...

    """
    def __init__(self, api_obj, name, path, **kw):
        super(RESTResourceHandler, self).__init__(api_obj, name, path, **kw)

    def get(self, resource_id=None, params=None):
        """
        Get all records for a resource, or a single resource record.

        Optional Arguments:

            resource_id
                The resource id (may also be a label in some environments).

            params
                Additional request parameters to pass along.

        """
        if params is None:
            params = {} # pragma: no cover
        if resource_id:
            path = '/%s/%s' % (self.path, resource_id)
        else:
            path = '/%s' % self.path

        try:
            response = self.api.make_request('GET', path,
                                             params=self.filter(params))
        except exc.dRestRequestError as e:
            msg = "%s (resource: %s, id: %s)" % (e.msg, self.name,
                                                 resource_id)
            raise exc.dRestRequestError(msg, e.response)

        return response

    def create(self, params=None):
        """A synonym for self.post()."""
        if params is None:
            params = {} # pragma: no cover

        return self.post(params)

    def post(self, params=None):
        """
        Create a new resource.

        Required Arguments:

            params
                A dictionary of parameters (different for every resource).

        """
        if params is None:
            params = {} # pragma: no cover

        params = self.filter(params)
        path = '/%s' % self.path

        try:
            response = self.api.make_request('POST', path, self.filter(params))
        except exc.dRestRequestError as e:
            msg = "%s (resource: %s)" % (e.msg, self.name)
            raise exc.dRestRequestError(msg, e.response)

        return response

    def update(self, resource_id, params=None):
        """A synonym for self.put()."""
        if params is None:
            params = {} # pragma: no cover

        return self.put(resource_id, params)

    def put(self, resource_id, params=None):
        """
        Update an existing resource.

        Required Arguments:

            resource_id
                The id of the resource to update.

            params
                A dictionary of parameters (different for every resource).

        """
        if params is None:
            params = {} # pragma: no cover

        params = self.filter(params)
        path = '/%s/%s' % (self.path, resource_id)

        try:
            response = self.api.make_request('PUT', path, params)
        except exc.dRestRequestError as e:
            msg = "%s (resource: %s, id: %s)" % (e.msg, self.name,
                                                 resource_id)
            raise exc.dRestRequestError(msg, e.response)

        return response

    def patch(self, resource_id, params=None):
        """
        Update only specific items of an existing resource.

        Required Arguments:

            resource_id
                The id of the resource to update.

            params
                A dictionary of parameters (different for every resource).

        """
        if params is None:
            params = {} # pragma: no cover

        params = self.filter(params)
        path = '/%s/%s' % (self.path, resource_id)

        try:
            response = self.api.make_request('PATCH', path, params)
        except exc.dRestRequestError as e:
            msg = "%s (resource: %s, id: %s)" % (e.msg, self.name,
                                                 resource_id)
            raise exc.dRestRequestError(msg, e.response)

        return response

    def delete(self, resource_id, params=None):
        """
        Delete resource record.

        Required Arguments:

            resource_id
                The resource id

        Optional Arguments:

            params
                Some resource might allow additional parameters.  For example,
                the user resource has a 'rdikwid' (really delete I know what
                I'm doing) option which causes a user to *really* be deleted
                (normally deletion only sets the status to 'Deleted').

        """
        if params is None:
            params = {} # pragma: no cover
        path = '/%s/%s' % (self.path, resource_id)
        try:
            response = self.api.make_request('DELETE', path, params)
        except exc.dRestRequestError as e:
            msg = "%s (resource: %s, id: %s)" % (e.msg, self.name,
                                                 resource_id)
            raise exc.dRestRequestError(msg, e.response)

        return response

class TastyPieResourceHandler(RESTResourceHandler):
    """
    This class implements the IResource interface, specifically tailored for
    interfacing with `TastyPie <http://django-tastypie.readthedocs.org/en/latest>`_.

    """
    class Meta:
        """
        Handler meta-data (can be passed as keyword arguments to the parent
        class).

        """
        request = request.TastyPieRequestHandler
        """The request handler used to make requests.
           Default: TastyPieRequestHandler."""

        collection_name = 'objects'
        """The name of the collection.  Default: objects"""

    def __init__(self, api_obj, name, path, **kw):
        super(TastyPieResourceHandler, self).__init__(api_obj, name, path, **kw)
        self._schema = None

    def get_by_uri(self, resource_uri, params=None):
        """
        A wrapper around self.get() that accepts a TastyPie 'resource_uri'
        rather than a 'pk' (primary key).

        :param resource_uri: The resource URI to GET.
        :param params: Any additional keyword arguments are passed as extra
         request parameters.

        Usage:

        .. code-block:: python

            import drest
            api = drest.api.TastyPieAPI('http://localhost:8000/api/v0/')
            api.auth(user='john.doe',
                     api_key='34547a497326dde80bcaf8bcee43e3d1b5f24cc9')
            response = api.users.get_by_uri('/api/v1/users/234/')

        """
        if params is None:
            params = {} # pragma: no cover

        resource_uri = resource_uri.rstrip('/')
        pk = resource_uri.split('/')[-1]
        return self.get(pk, params)

    def patch_list(self, create_objects=[], delete_objects=[]):
        """
        Tastypie resources have a patch_list method that allows you to create
        and delete bulk collections of objects. This uses HTTP PATCH.

        :param create_objects: List of objects to create in dict form.
        :param delete_objects: List of objects to delete in dict form.

        """
        create_objects = [self.filter(o) for o in create_objects]
        delete_objects = [self.filter(o) for o in delete_objects]
        delete_collection_name = "deleted_%s" % self._meta.collection_name
        data = {
            self._meta.collection_name: create_objects,
            delete_collection_name: delete_objects,
        }
        return self.api.make_request('PATCH', self.path, data)

    @property
    def schema(self):
        """
        Returns the resources schema.

        """
        if not self._schema:
            response = self.api.make_request('GET', '%s/schema' % self.path)
            self._schema = response.data

        return self._schema

class NestedResource(object):
    pass

########NEW FILE########
__FILENAME__ = response

from . import exc, meta, interface

def validate(obj):
    """Validates a handler implementation against the IResponse interface."""
    members = [
        'status',
        'data',
        'headers',
        ]
    metas = []
    interface.validate(IResponse, obj, members, metas)
    
class IResponse(interface.Interface):
    """
    This class defines the Response Handler Interface.  Classes that 
    implement this handler must provide the methods and attributes defined 
    below.
    
    All implementations must provide sane 'default' functionality when 
    instantiated with no arguments.  Meaning, it can and should accept 
    optional parameters that alter how it functions, but can not require
    any parameters.  
    
    Implementations do *not* subclass from interfaces.
            
    """
    status = interface.Attribute('The response status (i.e. HTTP code).')
    data = interface.Attribute('The data returned by the request.')
    headers = interface.Attribute('The headers returned by the request.')
    
class ResponseHandler(meta.MetaMixin):
    class Meta:
        pass
    
    status = None
    data = None
    headers = None
    
    def __init__(self, status, data, headers):
        self.status = int(status)
        self.data = data
        self.headers = headers

########NEW FILE########
__FILENAME__ = serialization

from . import interface, exc, meta

def validate(obj):
    """Validates a handler implementation against the ISerialize interface."""
    members = [
        'serialize',
        'deserialize',
        'get_headers',
        ]
    interface.validate(ISerialization, obj, members)
    
class ISerialization(interface.Interface):
    """
    This class defines the Serialization Handler Interface.  Classes that 
    implement this handler must provide the methods and attributes defined 
    below.
    
    All implementations must provide sane 'default' functionality when 
    instantiated with no arguments.  Meaning, it can and should accept 
    optional parameters that alter how it functions, but can not require
    any parameters.  
    
    Implementations do *not* subclass from interfaces.
            
    """

    def get_headers():
        """
        Return a dictionary of additional headers to include in requests.
        
        """
        
    def deserialize():
        """
        Load a serialized string and return a dictionary of key/value pairs.
        
        Required Arguments:
        
            serialized_data
                A string of serialzed data.
        
        Returns: dict
        
        """
        
    def serialize():
        """
        Dump a dictionary of values from a serialized string.
        
        Required Arguments:
                                
            data_dict
                A data dictionary to serialize.

        Returns: string
        
        """
        
class SerializationHandler(meta.MetaMixin):
    """
    Generic Serialization Handler.  Should be used to subclass from.
            
    """
    def __init__(self, **kw):
        super(SerializationHandler, self).__init__(**kw)
        
    def get_headers(self):
        return {}
        
    def deserialize(self, serialized_string):
        raise NotImplementedError
    
    def serialize(self, dict_obj):
        raise NotImplementedError
        

class JsonSerializationHandler(SerializationHandler):
    """
    This handler implements the ISerialization interface using the standard 
    json library.
    
    """
    def __init__(self, **kw):
        try:
            import json # pragma: no cover
        except ImportError as e: # pragma: no cover
            import simplejson as json # pragma: no cover
            
        self.backend = json
        super(JsonSerializationHandler, self).__init__(**kw)
        
    def deserialize(self, serialized_string):
        try:
            # Fix for Python3
            if type(serialized_string) == bytes:
                serialized_string = serialized_string.decode('utf-8')
        
            return self.backend.loads(serialized_string)
        except ValueError as e:
            return dict(error=e.args[0])

    def serialize(self, dict_obj):
        return self.backend.dumps(dict_obj)
                
    def get_headers(self):
        headers = {
            'Content-Type' : 'application/json',
            }
        return headers

########NEW FILE########
__FILENAME__ = testing

import os
MOCKAPI = os.environ.get('DREST_MOCKAPI', 'http://localhost:8000/api/v0')


########NEW FILE########
__FILENAME__ = api_tests
"""Tests for drest.api."""

import os
import unittest
from nose.tools import ok_, eq_, raises

import drest
from drest.testing import MOCKAPI

api = drest.api.API(MOCKAPI)

class MyAPI(drest.api.TastyPieAPI):
    class Meta:
        baseurl = MOCKAPI
        extra_headers = dict(foo='bar')
        extra_params = dict(foo2='bar2')
        extra_url_params = dict(foo3='bar3')
        
class APITestCase(unittest.TestCase):
    def test_auth(self):
        api.auth('john.doe', 'password')
        eq_(api.request._auth_credentials[0], 'john.doe')
        eq_(api.request._auth_credentials[1], 'password')
    
    def test_custom_auth(self):
        class MyAPI(drest.API):
            def auth(self, *args, **kw):
                for key in kw:
                    self.request.add_url_param(key, kw[key])
        myapi = MyAPI(MOCKAPI)
        myapi.auth(user='john.doe', password='password')
        eq_(myapi.request._extra_url_params['user'], 'john.doe')
        eq_(myapi.request._extra_url_params['password'], 'password')

    def test_wrapped_meta(self):
        class MyAPI2(drest.api.TastyPieAPI):
            class Meta:
                trailing_slash = False

        myapi = MyAPI2(MOCKAPI)
        eq_(myapi.request._meta.trailing_slash, False)
    
    def test_extra_headers(self):
        api = MyAPI()
        eq_('bar', api.request._extra_headers['foo'])
    
    def test_extra_params(self):
        api = MyAPI()
        eq_('bar2', api.request._extra_params['foo2'])
    
    def test_extra_url_params(self):
        api = MyAPI()
        eq_('bar3', api.request._extra_url_params['foo3'])
    
    def test_request(self):
        response = api.make_request('GET', '/')
        res = 'users' in response.data
        ok_(res)

    def test_add_resource(self):
        api.add_resource('users')
        response = api.users.get()
    
        api.add_resource('users2', path='/users/')
        response = api.users2.get()
    
        api.add_resource('users3', path='/users/', 
                         resource_handler=drest.resource.RESTResourceHandler)
        response = api.users3.get()
    
    @raises(drest.exc.dRestResourceError)
    def test_duplicate_resource(self):
        api.add_resource('users')

    @raises(drest.exc.dRestResourceError)
    def test_bad_resource_name(self):
        api.add_resource('some!bogus-name')

    def test_nested_resource_name(self):
        api.add_resource('nested.users.resource', path='/users/')
        eq_(api.nested.__class__, drest.resource.NestedResource)
        eq_(api.nested.users.__class__, drest.resource.NestedResource)
        eq_(api.nested.users.resource.__class__, drest.resource.RESTResourceHandler)
    
    def test_tastypieapi_via_apikey_auth(self):
        api = drest.api.TastyPieAPI(MOCKAPI)
        api.auth(user='john.doe', api_key='JOHN_DOE_API_KEY')
    
        # verify headers
        eq_(api.request._extra_headers, 
            {'Content-Type': 'application/json', 
             'Authorization': 'ApiKey john.doe:JOHN_DOE_API_KEY'})
    
        # verify resources
        res = 'users' in api.resources
        ok_(res)
        res = 'projects' in api.resources
        ok_(res)
    
        # and requests
        response = api.users_via_apikey_auth.get()
        eq_(response.data['objects'][0]['username'], 'admin')
    
        response = api.projects.get(params=dict(label__startswith='Test Project'))
        ok_(response.data['objects'][0]['label'].startswith('Test Project'))

    def test_tastypieapi_via_basic_auth(self):
        api = drest.api.TastyPieAPI(MOCKAPI, auth_mech='basic')
        api.auth(user='john.doe', password='password')

        eq_(api.request._auth_credentials[0], 'john.doe')
        eq_(api.request._auth_credentials[1], 'password')
    
        # verify resources
        res = 'users' in api.resources
        ok_(res)
        res = 'projects' in api.resources
        ok_(res)
    
        # and requests
        response = api.users_via_basic_auth.get()
        eq_(response.data['objects'][0]['username'], 'admin')

    @raises(drest.exc.dRestAPIError)
    def test_tastypieapi_via_unknown_auth(self):
        api = drest.api.TastyPieAPI(MOCKAPI, auth_mech='bogus')
        api.auth(user='john.doe', password='password')

########NEW FILE########
__FILENAME__ = exc_tests
"""Tests for drest.exc."""

import os
import unittest
from nose.tools import eq_, raises
import drest
from drest.testing import MOCKAPI

api = drest.api.API(MOCKAPI)

class ExceptionTestCase(unittest.TestCase):
    @raises(drest.exc.dRestError)
    def test_error(self):
        try:
            raise drest.exc.dRestError('Error Msg')
        except drest.exc.dRestError as e:
            e.__repr__()
            eq_(e.msg, 'Error Msg')
            eq_(e.__str__(), str(e.msg))
            raise

    @raises(drest.exc.dRestInterfaceError)
    def test_interface_error(self):
        try:
            raise drest.exc.dRestInterfaceError('Error Msg')
        except drest.exc.dRestInterfaceError as e:
            e.__repr__()
            eq_(e.msg, 'Error Msg')
            eq_(e.__str__(), str(e.msg))
            raise

    @raises(drest.exc.dRestRequestError)
    def test_request_error(self):
        try:
            api = drest.api.API(MOCKAPI)
            response = api.make_request('GET', '/')
            raise drest.exc.dRestRequestError('Error Msg', response)
        except drest.exc.dRestRequestError as e:
            e.__repr__()
            eq_(e.msg, 'Error Msg')
            eq_(e.__str__(), str(e.msg))
            raise
        
    @raises(drest.exc.dRestResourceError)
    def test_resource_error(self):
        try:
            raise drest.exc.dRestResourceError('Error Msg')
        except drest.exc.dRestResourceError as e:
            e.__repr__()
            eq_(e.msg, 'Error Msg')
            eq_(e.__str__(), str(e.msg))
            raise
        
    @raises(drest.exc.dRestAPIError)
    def test_api_error(self):
        try:
            raise drest.exc.dRestAPIError('Error Msg')
        except drest.exc.dRestAPIError as e:
            e.__repr__()
            eq_(e.msg, 'Error Msg')
            eq_(e.__str__(), str(e.msg))
            raise
########NEW FILE########
__FILENAME__ = interface_tests
"""Tests for drest.interface."""

import os
import unittest
from nose.tools import eq_, raises
import drest
from drest.testing import MOCKAPI

api = drest.api.API(MOCKAPI)

class ITest(drest.interface.Interface):
    pass

class TestHandler(drest.meta.MetaMixin):
    class Meta:
        test_meta = 'some value'
        
    def test_func(self):
        pass
    
    def __repr__(self):
        return 'TestHandler'
     
class InterfaceTestCase(unittest.TestCase):
    @raises(drest.exc.dRestInterfaceError)
    def test_interface(self):
        _int = drest.interface.Interface()

    def test_attribute(self):
        attr = drest.interface.Attribute('Attr Description')
        eq_(str(attr), 'Attribute: Attr Description')

    def test_validate(self):
        drest.interface.validate(ITest, TestHandler(), ['test_func'])

    def test_validate_meta(self):
        drest.interface.validate(ITest, TestHandler(), ['test_func'], ['test_meta'])

    @raises(drest.exc.dRestInterfaceError)
    def test_validate_missing_member(self):
        try:
            drest.interface.validate(ITest, TestHandler(), ['missing_func'])
        except drest.exc.dRestInterfaceError as e:
            eq_(e.msg, "Invalid or missing: ['missing_func'] in TestHandler")
            raise

    @raises(drest.exc.dRestInterfaceError)
    def test_validate_missing_meta(self):
        try:
            drest.interface.validate(ITest, TestHandler(), [], ['missing_meta'])
        except drest.exc.dRestInterfaceError as e:
            eq_(e.msg, "Invalid or missing: ['_meta.missing_meta'] in TestHandler")
            raise
########NEW FILE########
__FILENAME__ = meta_tests
"""Tests for drest.meta."""

from nose.tools import eq_
import drest
    
class Test(drest.meta.MetaMixin):
    class Meta:
        some_param = None
        
    def __init__(self, **kw):
        super(Test, self).__init__(**kw)
        
def test_meta():
    test = Test(some_param='some_value')
    eq_(test._meta.some_param, 'some_value')
########NEW FILE########
__FILENAME__ = request_tests
"""Tests for drest.request."""

import os
import unittest
import mock
from random import random
from nose.tools import eq_, ok_, raises

try:
    import json
except ImportError as e:
    import simplejson as json

import drest
from drest.testing import MOCKAPI

class RequestTestCase(unittest.TestCase):
    def test_debug(self):
        os.environ['DREST_DEBUG'] = '1'
        req = drest.request.RequestHandler(debug=True)
        req.make_request('GET', '%s/' % MOCKAPI)
        eq_(req._meta.debug, True)
        os.environ['DREST_DEBUG'] = '0'

    def test_no_serialization(self):
        req = drest.request.RequestHandler(serialization_handler=None)
        response = req.make_request('GET', '%s/users/1/' % MOCKAPI)
        eq_(response.data, req._deserialize(response.data))
        eq_(dict(foo='bar'), req._serialize(dict(foo='bar')))
        eq_(json.loads(response.data.decode('utf-8'))['username'], 'admin')

    @raises(drest.exc.dRestAPIError)
    def test_socket_error(self):
        req = drest.request.RequestHandler()
        try:
            response = req.make_request('GET', 'http://bogusurl.localhost/')
        except drest.exc.dRestAPIError as e:
            res = e.__repr__().find('Unable to find the server')
            test_res = res >= 0
            ok_(test_res)
            raise

    @raises(drest.exc.dRestAPIError)
    def test_socket_timeout(self):
        req = drest.request.RequestHandler(timeout=1)
        try:
            response = req.make_request(
                'GET',
                'http://localhost:8000/fake_long_request/',
                params=dict(seconds=10),
                )
        except drest.exc.dRestAPIError as e:
            res = e.__repr__().find('timed out')
            test_res = res >= 0
            ok_(test_res)
            raise

    @raises(drest.exc.dRestAPIError)
    def test_server_not_found_error(self):
        req = drest.request.RequestHandler()
        try:
            response = req.make_request('GET', 'http://bogus.example.com/api/')
        except drest.exc.dRestAPIError as e:
            res = e.__repr__().find('Unable to find the server')
            test_res = res >= 0
            ok_(test_res)
            raise

    def test_trailing_slash(self):
        req = drest.request.RequestHandler(trailing_slash=False)
        response = req.make_request('GET', '%s/users/1/' % MOCKAPI)

    def test_extra_params(self):
        params = {}
        params['label'] = "Project Label %s" % random()
        req = drest.request.TastyPieRequestHandler()
        req.add_param('label', params['label'])
        eq_(req._extra_params, params)
        response = req.make_request('POST', '%s/projects/' % MOCKAPI, params)

    def test_payload_and_headers_are_none(self):
        req = drest.request.TastyPieRequestHandler()
        response = req._make_request('%s/projects/' % MOCKAPI, 'GET',
                                     payload=None, headers=None)

        req = drest.request.TastyPieRequestHandler(serialize=False)
        response = req._make_request('%s/projects/' % MOCKAPI, 'GET',
                                     payload=None, headers=None)

    def test_extra_url_params(self):
        req = drest.request.RequestHandler()
        req.add_url_param('username__icontains', 'ad')
        eq_(req._extra_url_params, dict(username__icontains='ad'))
        response = req.make_request('GET', '%s/users/' % MOCKAPI)
        eq_(response.data['objects'][0]['username'], 'admin')

    def test_extra_headers(self):
        req = drest.request.RequestHandler(serialization_handler=None)
        req.add_header('some_key', 'some_value')
        eq_(req._extra_headers, dict(some_key='some_value'))
        response = req.make_request('GET', '%s/users/' % MOCKAPI)

    @raises(drest.exc.dRestRequestError)
    def test_handle_response(self):
        req = drest.request.RequestHandler()
        response = req.make_request('GET', '%s/users/1/' % MOCKAPI)
        response.status = 404
        try:
            req.handle_response(response)
        except drest.exc.dRestRequestError as e:
            eq_(e.msg, 'Received HTTP Code 404 - Not Found')
            raise

    def test_ignore_ssl_validation(self):
        req = drest.request.RequestHandler(serialization_handler=None,
                                           ignore_ssl_validation=True)
        req.make_request('GET', '%s/users/' % MOCKAPI)

    def test_get_request_allow_get_body(self):
        # lighttpd denies GET requests with data in the body by default
        class MyRequestHandler(drest.request.RequestHandler):
            class Meta:
                allow_get_body = False

        request = MyRequestHandler()
        request._get_http = mock.Mock()
        request._get_http().request.return_value = ({'status': 200}, '')
        url = '%s/users/' % MOCKAPI
        request.make_request('GET', url, {"param1": "value1"})
        headers = {'Content-Type': 'application/json'}

        url = url + '?param1=value1'
        request._get_http()\
               .request.assert_called_with(url, 'GET', '', headers=headers)

########NEW FILE########
__FILENAME__ = resource_tests
"""Tests for drest.resource."""

import os
import re
import unittest
import copy
from random import random
from nose.tools import eq_, ok_, raises

import drest
from drest.testing import MOCKAPI

class ResourceTestCase(unittest.TestCase):
    def test_rest_get_all(self):
        api = drest.api.API(MOCKAPI)
        api.add_resource('users')
        response = api.users.get()
        eq_(response.data['objects'][0]['username'], 'admin')

    def test_rest_get_one(self):
        api = drest.api.API(MOCKAPI)
        api.add_resource('users')
        response = api.users.get(2)
        eq_(response.data['username'], 'john.doe')

    @raises(drest.exc.dRestRequestError)
    def test_rest_get_one_bad(self):
        api = drest.api.API(MOCKAPI)
        api.add_resource('users', path='/bogus_path/')
        try:
            response = api.users.get(1)
        except drest.exc.dRestRequestError as e:
            eq_(e.msg, 'Received HTTP Code 404 - Not Found (resource: users, id: 1)')
            raise

    def test_rest_post(self):
        api = drest.api.TastyPieAPI(MOCKAPI)
        api.auth(user='john.doe', api_key='JOHNDOE_API_KEY')
        rand_label = "Test Project %s" % random()
        response = api.projects.post(dict(label=rand_label))
        ok_(response.status, 200)

        m = re.match('http://(.*):8000\/api\/v0\/(.*)\/', 
                     response.headers['location'])
        ok_(m)

    @raises(drest.exc.dRestRequestError)
    def test_rest_post_bad(self):
        api = drest.api.API(MOCKAPI)
        api.add_resource('users', path='/bogus_path/')
        try:
            response = api.users.post({})
        except drest.exc.dRestRequestError as e:
            eq_(e.msg, 'Received HTTP Code 404 - Not Found (resource: users)')
            raise
        
    def test_rest_create(self):
        api = drest.api.TastyPieAPI(MOCKAPI)
        api.auth(user='john.doe', api_key='JOHNDOE_API_KEY')
        rand_label = "Test Project %s" % random()
        response = api.projects.create(dict(label=rand_label))
        ok_(response.status, 200)

    def test_rest_put(self):
        rand_label = "Test Project %s" % random()
        api = drest.api.TastyPieAPI(MOCKAPI)
        response = api.projects.get(1)

        response.data['label'] = rand_label
        response = api.projects.put(1, response.data)
    
        response = api.projects.get(1)
        eq_(response.data['label'], rand_label)

    @raises(drest.exc.dRestRequestError)
    def test_rest_put_bad(self):
        api = drest.api.API(MOCKAPI)
        api.add_resource('users', path='/bogus_path/')
        try:
            response = api.users.put(1)
        except drest.exc.dRestRequestError as e:
            eq_(e.msg, 'Received HTTP Code 404 - Not Found (resource: users, id: 1)')
            raise
        
    def test_rest_update(self):
        rand_label = "Test Project %s" % random()
        api = drest.api.TastyPieAPI(MOCKAPI)
        response = api.projects.get(1)

        response.data['label'] = rand_label
        response = api.projects.update(1, response.data)
    
        response = api.projects.get(1)
        eq_(response.data['label'], rand_label)

    def test_rest_patch(self):
        rand_label = "Test Project %s" % random()
        api = drest.api.TastyPieAPI(MOCKAPI)
        response = api.projects.get(1)

        new_data = dict()
        new_data['label'] = rand_label
        response = api.projects.patch(1, new_data)
        eq_(response.status, 202)
        
        response = api.projects.get(1)
        eq_(response.data['label'], rand_label)
        
        
    @raises(drest.exc.dRestRequestError)
    def test_rest_patch_bad(self):
        api = drest.api.API(MOCKAPI)
        api.add_resource('users', path='/bogus_path/')
        try:
            response = api.users.patch(1)
        except drest.exc.dRestRequestError as e:
            eq_(e.msg, 'Received HTTP Code 404 - Not Found (resource: users, id: 1)')
            raise
            
    def test_rest_delete(self):
        api = drest.api.TastyPieAPI(MOCKAPI)
        rand_label = "Test Project %s" % random()
    
        response = api.projects.create(dict(label=rand_label))
        ok_(response.status, 200)
    
        response = api.projects.get(params=dict(label__exact=rand_label))
        response = api.projects.delete(response.data['objects'][0]['id'])
        eq_(response.status, 204)

    @raises(drest.exc.dRestRequestError)
    def test_rest_delete_bad(self):
        api = drest.api.API(MOCKAPI)
        api.add_resource('users', path='/bogus_path/')
        try:
            response = api.users.delete(100123123)
        except drest.exc.dRestRequestError as e:
            eq_(e.msg, 'Received HTTP Code 404 - Not Found (resource: users, id: 100123123)')
            raise

    def test_tastypie_resource_handler(self):
        api = drest.api.TastyPieAPI(MOCKAPI)
        api.auth(user='john.doe', api_key='JOHNDOE_API_KEY')
        response = api.users.get_by_uri('/api/v0/users/1/')
        eq_(response.data['username'], 'admin')

    def test_tastypie_schema(self):
        api = drest.api.TastyPieAPI(MOCKAPI)
        eq_(api.users.schema['allowed_list_http_methods'], ['get'])

    def test_tastypie_patch_list(self):
        api = drest.api.TastyPieAPI(MOCKAPI)
        api.auth(user='john.doe', api_key='JOHNDOE_API_KEY')
        # Test Creating:
        new_project1 = dict(
            update_date='2013-02-27T21:07:26.403343',
            create_date='2013-02-27T21:07:26.403323',
            label='NewProject1'
            )

        new_project2 = dict(
            update_date='2013-02-27T21:07:27.403343',
            create_date='2013-02-27T21:07:27.403323',
            label='NewProject2'
            )

        response = api.projects.patch_list([new_project1, new_project2])
        eq_(response.status, 202)
        
        projects = api.projects.get().data['objects']
        labels = [p['label'] for p in projects]
        
        res = new_project1['label'] in labels
        ok_(res)
        
        res = new_project2['label'] in labels
        ok_(res)
        
        new_labels = ['NewProject1', 'NewProject2']
        new_uris = [p['resource_uri'] for p in projects \
                                      if p['label'] in new_labels]
        
        # Test Deleting:
        response = api.projects.patch_list([], new_uris)
        eq_(response.status, 202)
        
        projects = api.projects.get().data['objects']
        labels = [p['label'] for p in projects]
        
        res = 'NewProject1' not in labels
        ok_(res)
        
        res = 'NewProject2' not in labels
        ok_(res)

########NEW FILE########
__FILENAME__ = response_tests
"""Tests for drest.response."""

import os
import unittest
from nose.tools import ok_, eq_, raises

import drest
from drest.testing import MOCKAPI

api = drest.api.TastyPieAPI(MOCKAPI)

class ResponseTestCase(unittest.TestCase):
    def test_good_status(self):
        response = api.users.get()
        eq_(response.status, 200)
    
    @raises(drest.exc.dRestRequestError)
    def test_bad_status(self):
        try:
            response = api.users.get(132412341)
        except drest.exc.dRestRequestError as e:
            eq_(e.response.status, 404)
            raise
    
########NEW FILE########
__FILENAME__ = serialization_tests
"""Tests for drest.serialization."""

import os
import unittest

try:
    import json
except ImportError as e:
    import simplejson as json
    
from nose.tools import eq_, raises
import drest

class SerializationTestCase(unittest.TestCase):
    def test_serialization(self):
        s = drest.serialization.SerializationHandler()
        s.get_headers()
    
    @raises(NotImplementedError)
    def test_serialization_serialize(self):
        s = drest.serialization.SerializationHandler()
        s.get_headers()
        s.serialize({})

    @raises(NotImplementedError)
    def test_serialization_deserialize(self):
        s = drest.serialization.SerializationHandler()
        s.get_headers()
        s.deserialize(json.dumps({}))
    

########NEW FILE########
__FILENAME__ = api

from django.contrib.auth.models import User

from tastypie import fields
from tastypie.authentication import ApiKeyAuthentication, BasicAuthentication
from tastypie.authentication import DigestAuthentication
from tastypie.authorization import Authorization
from tastypie.validation import FormValidation
from tastypie.http import HttpUnauthorized
from tastypie.resources import ModelResource, ALL
from tastypie.api import Api
from tastypie.utils import trailing_slash

from mockapi.projects.models import Project

### READ ONLY API V0

class UserResource(ModelResource):    
    class Meta:
        queryset = User.objects.all()
        resource_name = 'users'
        filtering = {
            'username': ALL,
            }
        allowed_methods = ['get']

class UserResourceViaApiKeyAuth(ModelResource):    
    class Meta:
        queryset = User.objects.all()
        authentication = ApiKeyAuthentication()
        resource_name = 'users_via_apikey_auth'
        filtering = {
            'label': ALL,
            }
        allowed_methods = ['get']
        
class UserResourceViaBasicAuth(ModelResource):    
    class Meta:
        queryset = User.objects.all()
        authentication = BasicAuthentication()
        resource_name = 'users_via_basic_auth'
        filtering = {
            'label': ALL,
            }
        allowed_methods = ['get']

class UserResourceViaDigestAuth(ModelResource):    
    class Meta:
        queryset = User.objects.all()
        authentication = DigestAuthentication()
        resource_name = 'users_via_digest_auth'
        filtering = {
            'label': ALL,
            }
        allowed_methods = ['get']
        
class ProjectResource(ModelResource):
    class Meta:
        queryset = Project.objects.all()
        authorization = Authorization()
        resource_name = 'projects'
        filtering = {
            'label': ALL,
            }
        allowed_methods = ['get', 'put', 'post', 'delete', 'patch']
        
v0_api = Api(api_name='v0')
v0_api.register(UserResource())
v0_api.register(UserResourceViaApiKeyAuth())
v0_api.register(UserResourceViaBasicAuth())
v0_api.register(UserResourceViaDigestAuth())
v0_api.register(ProjectResource())

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
import os
import sys

if __name__ == "__main__":
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "mockapi.settings")

    from django.core.management import execute_from_command_line

    execute_from_command_line(sys.argv)

########NEW FILE########
__FILENAME__ = models

from django.db import models

class Project(models.Model):
    class Meta:
        db_table = 'projects'
        
    create_date = models.DateTimeField(auto_now_add=True)
    update_date = models.DateTimeField(auto_now_add=True, auto_now=True)                     
    label = models.CharField(max_length=128, blank=False, unique=True)
    
    def __unicode__(self):
        return unicode(self.label)
    
    def __str__(self):
        return self.label
########NEW FILE########
__FILENAME__ = views

from django.http import HttpResponse
from time import sleep

def fake_long_request(request):
    seconds = int(request.GET['seconds'])
    sleep(seconds)
    html = "<html><body>Slept %s seconds.</body></html>" % seconds
    return HttpResponse(html)
########NEW FILE########
__FILENAME__ = settings

import os

DEBUG = True
TEMPLATE_DEBUG = DEBUG

ADMINS = (
    # ('Your Name', 'your_email@example.com'),
)

MANAGERS = ADMINS

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': ':memory:',
        'USER': '',
        'PASSWORD': '',
        'HOST': '',
        'PORT': '',
    }
}

TIME_ZONE = 'America/Chicago'
LANGUAGE_CODE = 'en-us'
SITE_ID = 1
USE_I18N = True
USE_L10N = True
MEDIA_ROOT = ''
MEDIA_URL = ''
STATIC_ROOT = ''
STATIC_URL = '/static/'
ADMIN_MEDIA_PREFIX = '/static/admin/'
STATICFILES_DIRS = ()
STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
)
SECRET_KEY = '^kg0a9j$s^yja&ruzp9w#9j2k^c!mt9z3n@2j$zqgcywf#-wa2'
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
)
MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
)
ROOT_URLCONF = 'mockapi.urls'
TEMPLATE_DIRS = ()
FIXTURE_DIRS = (
    os.path.join(os.path.dirname(__file__), 'fixtures'),
)

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'tastypie',
    'mockapi.projects',
)
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'mail_admins': {
            'level': 'ERROR',
            'class': 'django.utils.log.AdminEmailHandler'
        }
    },
    'loggers': {
        'django.request': {
            'handlers': ['mail_admins'],
            'level': 'ERROR',
            'propagate': True,
        },
    }
}

########NEW FILE########
__FILENAME__ = urls

from django.http import HttpResponse
from django.conf.urls import patterns, include, url
from mockapi.api import v0_api

def render_null(request):
    return HttpResponse('')

urlpatterns = patterns('',
    url(r'^api/', include(v0_api.urls)),
    url(r'^favicon.ico/$', render_null),
    url(r'^fake_long_request/$',
        'mockapi.projects.views.fake_long_request')
)

########NEW FILE########
