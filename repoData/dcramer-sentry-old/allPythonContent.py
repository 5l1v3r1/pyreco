__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Sentry documentation build configuration file, created by
# sphinx-quickstart on Wed Oct 20 16:21:42 2010.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
#extensions = ['sphinxtogithub']
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Sentry'
copyright = u'2010, David Cramer'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.

version = __import__('pkg_resources').get_distribution('django-sentry').version
# The full version, including alpha/beta/rc tags.
release = version

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Sentrydoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Sentry.tex', u'Sentry Documentation',
   u'David Cramer', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'sentry', u'Sentry Documentation',
     [u'David Cramer'], 1)
]

########NEW FILE########
__FILENAME__ = base
"""
sentry.client.base
~~~~~~~~~~~~~~~~~~

:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
:license: BSD, see LICENSE for more details.
"""

from __future__ import absolute_import

import base64
import datetime
import hashlib
import logging
import simplejson
import time
import uuid
import urllib2

import sentry
from sentry import app
from sentry.core import processors
from sentry.models import Group, Event
from sentry.utils import get_versions, transform
from sentry.utils.api import get_mac_signature, get_auth_header

class ModuleProxyCache(dict):
    def __missing__(self, key):
        module, class_name = key.rsplit('.', 1)

        handler = getattr(__import__(module, {}, {}, [class_name], -1), class_name)
        
        self[key] = handler
        
        return handler

class SentryClient(object):
    def __init__(self, *args, **kwargs):
        self.logger = logging.getLogger('sentry.errors')
        self.module_cache = ModuleProxyCache()

    def capture(self, event_type, tags=None, data=None, date=None, time_spent=None, event_id=None,
                extra=None, culprit=None, **kwargs):
        """
        Captures and processes an event and pipes it off to SentryClient.send.
        
        To use structured data (interfaces) with capture:
        
        >>> capture('Message', message='foo', data={
        >>>     'sentry.interfaces.Http': {
        >>>         'url': '...',
        >>>         'data': {},
        >>>         'querystring': '...',
        >>>         'method': 'POST',
        >>>     },
        >>> })
        
        The finalized ``data`` structure contains the following (some optional) builtin values:
        
        >>> {
        >>>     'culprit': 'full.module.name', # or /arbitrary/path
        >>>     # the culprit version information
        >>>     'version': ('full.module.name', 'version string'),
        >>>     # all detectable installed modules
        >>>     'modules': {
        >>>         'full.module.name': 'version string',
        >>>     },
        >>>     # arbitrary data provided by user
        >>>     'extra': {
        >>>         'key': 'value',
        >>>     }
        >>> }
        
        :param event_type: the module path to the Event class. Builtins can use shorthand class
                           notation and exclude the full module path.
        :param tags: a list of tuples (key, value) specifying additional tags for event
        :param data: the data base, useful for specifying structured data interfaces. Any key which contains a '.'
                     will be assumed to be a data interface.
        :param date: the datetime of this event
        :param time_spent: a float value representing the duration of the event
        :param event_id: a 32-length unique string identifying this event
        :param extra: a dictionary of additional standard metadata
        :param culprit: a string representing the cause of this event (generally a path to a function)
        :return: a 32-length string identifying this event
        """
        if data is None:
            data = {}
        if tags is None:
            tags = []
        if extra is None:
            extra = {}
        if date is None:
            date = datetime.datetime.now()

        if '.' not in event_type:
            # Assume it's a builtin
            event_type = 'sentry.events.%s' % event_type

        handler = self.module_cache[event_type]()

        result = handler.capture(**kwargs)

        tags = list(tags) + result.pop('tags', [])

        if not culprit:
            culprit = result.pop('culprit')

        for k, v in result.iteritems():
            if k not in data:
                data[k] = v
            else:
                data[k].update(v)

        for k, v in data.iteritems():
            if '.' not in k:
                continue

            interface = self.module_cache[k]
            data[k] = interface(**v).serialize()
        
        tags.append(('server', app.config['NAME']))

        versions = get_versions()

        data['modules'] = versions

        if culprit:
            data['culprit'] = culprit

            # get list of modules from right to left
            parts = culprit.split('.')
            module_list = ['.'.join(parts[:idx]) for idx in xrange(1, len(parts)+1)][::-1]
            version = None
            module = None
            for m in module_list:
                if m in versions:
                    module = m
                    version = versions[m]

            # store our "best guess" for application version
            if version:
                data['version'] = (module, version),

        # TODO: Cache should be handled by the db backend by default (as we expect a fast access backend)
        # if app.config['THRASHING_TIMEOUT'] and app.config['THRASHING_LIMIT']:
        #     cache_key = 'sentry:%s:%s' % (kwargs.get('class_name') or '', checksum)
        #     added = cache.add(cache_key, 1, app.config['THRASHING_TIMEOUT'])
        #     if not added:
        #         try:
        #             thrash_count = cache.incr(cache_key)
        #         except (KeyError, ValueError):
        #             # cache.incr can fail. Assume we aren't thrashing yet, and
        #             # if we are, hope that the next error has a successful
        #             # cache.incr call.
        #             thrash_count = 0
        #         if thrash_count > app.config['THRASHING_LIMIT']:
        #             return

        # for filter_ in filters.all():
        #     kwargs = filter_(None).process(kwargs) or kwargs

        # create ID client-side so that it can be passed to application
        event_id = uuid.uuid4().hex

        # Run the data through processors

        for processor in processors.all():
            data.update(self.module_cache[processor].process(data))

        # Make sure all data is coerced
        data = transform(data)

        self.send(event_type=event_type, tags=tags, data=data, date=date, time_spent=time_spent, event_id=event_id)

        return event_id

    def store(self, event_type, tags, data, date, time_spent, event_id, **kwargs):
        """
        Saves a new event to the datastore.
        """
        module, class_name = event_type.rsplit('.', 1)

        handler = getattr(__import__(module, {}, {}, [class_name], -1), class_name)()

        event_hash = hashlib.md5('|'.join(k or '' for k in handler.get_event_hash(**data[handler.interface]))).hexdigest()

        event = Event.objects.create(
            pk=event_id,
            type=event_type,
            hash=event_hash,
            date=date,
            time_spent=time_spent,
            tags=tags,
        )
        event.set_meta(**data)

        event_message = handler.to_string(data[handler.interface])

        group, created = Group.objects.get_or_create(
            type=event_type,
            hash=event_hash,
            defaults={
                'count': 1,
                'time_spent': time_spent or 0,
                'tags': tags,
                'message': event_message,
            }
        )
        if not created:
            group.incr('count')
            if time_spent:
                group.incr('time_spent', time_spent)

        group.update(last_seen=event.date, score=group.get_score())

        group.add_relation(event, date.strftime('%s.%m'))

        # TODO: we need to manually add indexes per sort+filter value pair

        return event, group

    def send_remote(self, url, data, headers=None):
        if headers is None:
            headers = {}
        req = urllib2.Request(url, headers=headers)
        try:
            response = urllib2.urlopen(req, data, app.config['REMOTE_TIMEOUT']).read()
        except:
            response = urllib2.urlopen(req, data).read()
        return response

    def send(self, **kwargs):
        "Sends the message to the server."
        if app.config['REMOTES']:
            if kwargs.get('date'):
                kwargs['date'] = kwargs['date'].strftime('%Y-%m-%dT%H:%M:%S.%f')
            for url in app.config['REMOTES']:
                message = base64.b64encode(simplejson.dumps(kwargs).encode('zlib'))
                timestamp = time.time()
                nonce = uuid.uuid4().hex
                signature = get_mac_signature(app.config['KEY'], message, nonce, timestamp)
                headers={
                    'Authorization': get_auth_header(signature, timestamp, '%s/%s' % (self.__class__.__name__, sentry.VERSION), nonce),
                    'Content-Type': 'application/octet-stream',
                }
                
                try:
                    return self.send_remote(url=url, data=message, headers=headers)
                except urllib2.HTTPError, e:
                    body = e.read()
                    self.logger.error('Unable to reach Sentry log server: %s (url: %%s, body: %%s)' % (e,), url, body,
                                 exc_info=True, extra={'data':{'body': body, 'remote_url': url}})
                    self.logger.log(kwargs.pop('level', None) or logging.ERROR, kwargs.pop('message', None))
                except urllib2.URLError, e:
                    self.logger.error('Unable to reach Sentry log server: %s (url: %%s)' % (e,), url,
                                 exc_info=True, extra={'data':{'remote_url': url}})
                    self.logger.log(kwargs.pop('level', None) or logging.ERROR, kwargs.pop('message', None))
        else:
            return self.store(**kwargs)

class DummyClient(SentryClient):
    "Sends events into an empty void"
    def send(self, **kwargs):
        return None

########NEW FILE########
__FILENAME__ = client
"""
sentry.client.celery.client
~~~~~~~~~~~~~~~~~~~~~~~~~~~

:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
:license: BSD, see LICENSE for more details.
"""

from sentry.client.base import SentryClient
from sentry.client.celery import tasks

class CelerySentryClient(SentryClient):
    def send(self, **kwargs):
        "Errors through celery"
        tasks.send.delay(kwargs)
########NEW FILE########
__FILENAME__ = conf
"""
sentry.client.celery.conf
~~~~~~~~~~~~~~~~~~~~~~~~~

:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
:license: BSD, see LICENSE for more details.
"""

class SentryCeleryConfig(object):
    CELERY_ROUTING_KEY = 'sentry'
########NEW FILE########
__FILENAME__ = models
"""
sentry.client.celery.models
~~~~~~~~~~~~~~~~~~~~~~~~~~~

:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
:license: BSD, see LICENSE for more details.
"""

########NEW FILE########
__FILENAME__ = tasks
"""
sentry.client.celery.tasks
~~~~~~~~~~~~~~~~~~~~~~~~~~

:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
:license: BSD, see LICENSE for more details.
"""

from celery.decorators import task
from sentry.client.base import SentryClient
from sentry.client.celery import conf

@task(routing_key=conf.CELERY_ROUTING_KEY)
def send(data):
    return SentryClient().send(**data)

########NEW FILE########
__FILENAME__ = runner
#!/usr/bin/env python
"""
sentry.collector.scripts.runner
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
:license: BSD, see LICENSE for more details.
"""

import eventlet
import os
import os.path
import sys

from daemon.daemon import DaemonContext
from daemon.runner import DaemonRunner, make_pidlockfile
from eventlet import wsgi
from optparse import OptionParser

from sentry import VERSION, app
from sentry.middleware import WSGIErrorMiddleware

class SentryCollector(DaemonRunner):
    pidfile_timeout = 10
    start_message = u"started with pid %(pid)d"

    def __init__(self, host=None, port=None, pidfile=None,
                 logfile=None, daemonize=False, debug=False):
        if not logfile:
            logfile = app.config['WEB_LOG_FILE']

        logfile = os.path.realpath(logfile)
        pidfile = os.path.realpath(pidfile or app.config['WEB_PID_FILE'])
        
        if daemonize:
            detach_process = True
        else:
            detach_process = False

        self.daemon_context = DaemonContext(detach_process=detach_process)
        self.daemon_context.stdout = open(logfile, 'w+')
        self.daemon_context.stderr = open(logfile, 'w+', buffering=0)

        self.pidfile = make_pidlockfile(pidfile, self.pidfile_timeout)

        self.daemon_context.pidfile = self.pidfile

        self.host = host or app.config['WEB_HOST']
        self.port = port or app.config['WEB_PORT']

        self.debug = debug

        # HACK: set app to self so self.app.run() works
        self.app = self

    def execute(self, action):
        self.action = action
        if self.daemon_context.detach_process is False and self.action == 'start':
            # HACK:
            self.run()
        else:
            self.do_action()

    def run(self):
        # Import views/templatetags to ensure registration
        import sentry.collector.views

        upgrade()
        app.wsgi_app = WSGIErrorMiddleware(app.wsgi_app)
        if self.debug:
            app.run(host=self.host, port=self.port, debug=self.debug)
        else:
            wsgi.server(eventlet.listen((self.host, self.port)), app)

def cleanup(days=30, tags=None):
    from sentry.models import Group, Event
    import datetime
    
    ts = datetime.datetime.now() - datetime.timedelta(days=days)
    
    for event in Event.objects.order_by('date'):
        if event.date > ts:
            break
        event.delete()
    
    for group in Group.objects.order_by('last_seen'):
        if group.last_seen > ts:
            break
        event.delete()


def upgrade():
    pass
    # from sentry.conf import settings
    # 
    # call_command('syncdb', database=settings.DATABASE_USING or 'default', interactive=False)
    # 
    # if 'south' in django_settings.INSTALLED_APPS:
    #     call_command('migrate', database=settings.DATABASE_USING or 'default', interactive=False)

def main():
    command_list = ('start', 'stop', 'restart', 'cleanup', 'upgrade')
    args = sys.argv
    if len(args) < 2 or args[1] not in command_list:
        print "usage: sentry [command] [options]"
        print
        print "Available subcommands:"
        for cmd in command_list:
            print "  ", cmd
        sys.exit(1)

    parser = OptionParser(version="%%prog %s" % VERSION)
    parser.add_option('--config', metavar='CONFIG')
    if args[1] == 'start':
        parser.add_option('--debug', action='store_true', default=False, dest='debug')
        parser.add_option('--host', metavar='HOSTNAME')
        parser.add_option('--port', type=int, metavar='PORT')
        parser.add_option('--daemon', action='store_true', default=False, dest='daemonize')
        parser.add_option('--no-daemon', action='store_false', default=False, dest='daemonize')
        parser.add_option('--pidfile', dest='pidfile')
        parser.add_option('--logfile', dest='logfile')
    elif args[1] == 'stop':
        parser.add_option('--pidfile', dest='pidfile')
        parser.add_option('--logfile', dest='logfile')
    elif args[1] == 'cleanup':
        parser.add_option('--days', default='30', type=int,
                          help='Numbers of days to truncate on.')
        parser.add_option('--tags',
                          help='Limit truncation to only entries tagged with key:value.')

    (options, args) = parser.parse_args()

    if options.config:
        app.config.from_pyfile(options.config)
    else:
        config_path = os.path.expanduser(os.path.join('~', '.sentry', 'sentry.conf.py'))
        if os.path.exists(config_path):
            app.config.from_pyfile(config_path)

    if args[0] == 'upgrade':
        upgrade()

    elif args[0] == 'start':
        web = SentryCollector(host=options.host, port=options.port,
                           pidfile=options.pidfile, logfile=options.logfile,
                           daemonize=options.daemonize, debug=options.debug)
        web.execute(args[0])

    elif args[0] == 'restart':
        web = SentryCollector()
        web.execute(args[0])
  
    elif args[0] == 'stop':
        web = SentryCollector(pidfile=options.pidfile, logfile=options.logfile)
        web.execute(args[0])

    elif args[0] == 'cleanup':
        cleanup(days=options.days, tags=options.tags)

    sys.exit(0)

if __name__ == '__main__':
    main()
########NEW FILE########
__FILENAME__ = views
"""
sentry.web.api
~~~~~~~~~~~~~~

:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
:license: BSD, see LICENSE for more details.
"""

import base64
import datetime
import simplejson
import logging
import time

from sentry import app
from sentry.utils import is_float
from sentry.utils.api import get_mac_signature, parse_auth_header

from flask import request, abort

@app.route('/api/store/', methods=['POST'])
def store():
    """
    Accepts a gzipped JSON POST body.
    
    If ``PUBLIC_WRITES`` is truthy, the Authorization header is ignored.
    
    Format resembles the following:
    
    >>> {
    >>>     "event_type": "Exception",
    >>>     "tags": [ ["level", "error"], ["server", "sentry.local"] ],
    >>>     "date": "2010-06-18T22:31:45",
    >>>     "time_spent": 0.0,
    >>>     "event_id": "452dfa92380f438f98159bb75b9469e5",
    >>>     "data": {
    >>>         "culprit": "path.to.function",
    >>>         "version": ["module", "version string"],
    >>>         "modules": {
    >>>             "module": "version string"
    >>>         },
    >>>         "extra": {
    >>>             "key": "value",
    >>>         },
    >>>         "sentry.interfaces.Http": {
    >>>             "url": "http://example.com/foo/bar",
    >>>             "method": "POST",
    >>>             "querystring": "baz=bar&foo=baz",
    >>>             "data": {
    >>>                 "key": "value"
    >>>             }
    >>>         },
    >>>         "sentry.interfaces.Exception": {
    >>>             "type": "ValueError",
    >>>             "value": "An example exception"
    >>>         },
    >>>         "sentry.interfaces.Stacktrace": {
    >>>             "frames": [
    >>>                 {
    >>>                     "filename": "/path/to/filename.py",
    >>>                     "module": "path.to.module",
    >>>                     "function": "function_name",
    >>>                     "vars": {
    >>>                         "key": "value"
    >>>                     }
    >>>                 }
    >>>             ]
    >>>         }
    >>>     }
    >>> }
    """
    has_header = request.environ.get('AUTHORIZATION', '').startswith('Sentry')
    if not (app.config['PUBLIC_WRITES'] or has_header):
        abort(401,'Unauthorized')

    data = request.data

    if has_header:
        auth_vars = parse_auth_header(request.META['AUTHORIZATION'])
    
        signature = auth_vars.get('signature')
        timestamp = auth_vars.get('timestamp')
        nonce = auth_vars.get('nonce')

        # TODO: check nonce

        # Signed data packet
        if signature and timestamp:
            try:
                timestamp = float(timestamp)
            except ValueError:
                abort(400, 'Invalid Timestamp')

            if timestamp < time.time() - 3600: # 1 hour
                abort(410, 'Message has expired')

            if signature != get_mac_signature(app.config['KEY'], data, timestamp, nonce):
                abort(403, 'Invalid signature')
        else:
            abort(401,'Unauthorized')

    logger = logging.getLogger('sentry.web.api.store')

    try:
        data = base64.b64decode(data).decode('zlib')
    except Exception, e:
        # This error should be caught as it suggests that there's a
        # bug somewhere in the client's code.
        logger.exception('Bad data received')
        abort(400, 'Bad data decoding request (%s, %s)' % (e.__class__.__name__, e))

    try:
        data = simplejson.loads(data)
    except Exception, e:
        # This error should be caught as it suggests that there's a
        # bug somewhere in the client's code.
        logger.exception('Bad data received')
        abort(403, 'Bad data reconstructing object (%s, %s)' % (e.__class__.__name__, e))

    # XXX: ensure keys are coerced to strings
    data = dict((str(k), v) for k, v in data.iteritems())

    if 'date' in data:
        if is_float(data['date']):
            data['date'] = datetime.datetime.fromtimestamp(float(data['date']))
        else:
            if '.' in data['date']:
                format = '%Y-%m-%dT%H:%M:%S.%f'
            else:
                format = '%Y-%m-%dT%H:%M:%S'
            data['date'] = datetime.datetime.strptime(data['date'], format)

    event, group = app.client.store(**data)
    
    return event.pk

########NEW FILE########
__FILENAME__ = middleware
"""
sentry.contrib.django.middleware
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
:license: BSD, see LICENSE for more details.
"""

from __future__ import absolute_import

from sentry import capture

class Sentry404CatchMiddleware(object):
    def process_response(self, request, response):
        if response.status_code != 404:
            return response
        message_id = capture('Message', message='Http 404 at %s' % (request.build_absolute_uri()), tags=(('level', 'info'), ('logger', 'http404')))
        request.sentry = {
            'id': message_id,
        }
        return response

    # sentry_exception_handler(sender=Sentry404CatchMiddleware, request=request)

class SentryResponseErrorIdMiddleware(object):
    """
    Appends the X-Sentry-ID response header for referencing a message within
    the Sentry datastore.
    """
    def process_response(self, request, response):
        if not getattr(request, 'sentry', None):
            return response
        response['X-Sentry-ID'] = request.sentry['id']
        return response

########NEW FILE########
__FILENAME__ = models
"""
sentry.contrib.django.models
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
:license: BSD, see LICENSE for more details.
"""

from __future__ import absolute_import

from django.core.signals import got_request_exception

from sentry import capture

def sentry_exception_handler(request=None, **kwargs):
    event_id = capture('Exception')

    if request:
        # attach the sentry object to the request
        request.sentry = {
            'id': event_id,
        }

got_request_exception.connect(sentry_exception_handler)


########NEW FILE########
__FILENAME__ = cleaner
"""
sentry.core.cleaner
~~~~~~~~~~~~~~~~~~~

:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
:license: BSD, see LICENSE for more details.
"""

from sentry import app
from sentry.models import Group, Event

import logging
import datetime
import time
import threading

class Cleaner(threading.Thread):
    """
    Manages cleaning up expired messages.
    """
    def __init__(self, app):
        self.app = app
        self.logger = logging.getLogger('sentry.core.cleaner')
        super(Cleaner, self).__init__()

    def run(self):
        while True:
            time.sleep(5)

            if not app.config['TRUNCATE_AFTER']:
                continue
            
            cutoff = datetime.datetime.now() - app.config['TRUNCATE_AFTER']
            # XXX: this could be more efficient if we took interest in what
            # groups an event is part of, and checked them while iterating the events
            for event in Event.objects.order_by('date')[:100]:
                if event.date > cutoff:
                    continue

                self.logger.debug('Cleaning up %r' % event)
                event.delete()

            for group in Group.objects.order_by('last_seen')[:100]:
                if group.last_seen > cutoff:
                    continue

                self.logger.debug('Cleaning up %r' % group)
                group.delete()

########NEW FILE########
__FILENAME__ = plugins
"""
sentry.core.plugins
~~~~~~~~~~~~~~~~~~~

:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
:license: BSD, see LICENSE for more details.
"""

# Based on http://martyalchin.com/2008/jan/10/simple-plugin-framework/

from flask import url_for

class PluginMount(type):
    def __init__(cls, name, bases, attrs):
        if not hasattr(cls, 'plugins'):
            # This branch only executes when processing the mount point itself.
            # So, since this is a new plugin type, not an implementation, this
            # class shouldn't be registered as a plugin. Instead, it sets up a
            # list where plugins can be registered later.
            cls.plugins = {}
        else:
            # This must be a plugin implementation, which should be registered.
            # Simply appending it to the list is all that's needed to keep
            # track of it later.
            cls.slug = getattr(cls, 'slug', None) or cls.title.replace(' ', '-').lower()
            cls.plugins[cls.slug] = cls

# class ActionProvider:
#     """
#     Base interface for adding action providers.
# 
#     Plugins implementing this reference should provide the following attributes:
# 
#     ========  ========================================================
#     title     The text to be displayed, describing the action
# 
#     view      The view which will perform this action
# 
#     selected  Boolean indicating whether the action is the one
#               currently being performed
#     
#     ========  ========================================================
#     """
#     __metaclass__ = PluginMount
# 
#     def __init__(self):
#         self.url = url_for('group_plugin_action', slug=cls.slug)
# 
#     def __call__(self, request):
#         self.selected = request.path == self.url
#         if not self.selected:
#             return
# 
#         return self.perform(request)

class GroupActionProvider:
    # TODO: should be able to specify modal support

    __metaclass__ = PluginMount
    
    new_window = False

    @classmethod
    def get_url(cls, group_id):
        return url_for('group_plugin_action', group_id=group_id, slug=cls.slug)

    def __init__(self, group_id):
        self.url = self.__class__.get_url(group_id)

    def __call__(self, request, group):
        self.selected = request.path == self.url
        if not self.selected:
            return
        return self.view(request, group)

    def view(self):
        """
        Handles the view logic. If no response is given, we continue to the next action provider.
        """

    def tags(self, request, tag_list, group):
        """Modifies the tag list for a grouped message."""
        return tag_list

    def actions(self, request, action_list, group):
        """Modifies the action list for a grouped message."""
        return action_list

    def panels(self, request, panel_list, group):
        """Modifies the panel list for a grouped message."""
        return panel_list

    def widget(self, request, group):
        """
        Renders as a widget in the group details sidebar.
        """

########NEW FILE########
__FILENAME__ = processors
"""
sentry.core.processors
~~~~~~~~~~~~~~~~~~~~~~

:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
:license: BSD, see LICENSE for more details.
"""

import logging

from sentry import app

_CACHE = None
def all(from_cache=True):
    global _CACHE

    if _CACHE is None or not from_cache:
        modules = []
        for path in app.config['PROCESSORS']:
            module_name, class_name = path.rsplit('.', 1)
            try:
                module = __import__(module_name, {}, {}, class_name)
                handler = getattr(module, class_name)
            except Exception:
                logger = logging.getLogger(__name__)
                logger.exception('Unable to import %s' % (path,))
                continue
            modules.append(handler())

        _CACHE = modules

    for f in _CACHE:
        yield f

class Processor(object):
    def process(self, data, **kwargs):
        resp = self.get_data(data)
        if resp:
            data = resp
        return data

class SantizePasswordsProcessor(Processor):
    """
    Asterisk out passwords from password fields in frames.
    """
    def process(self, data, **kwargs):
        if 'sentry.interfaces.Stacktrace' in data:
            if 'frames' in data['sentry.interfaces.Stacktrace']:
                for frame in data['sentry.interfaces.Stacktrace']['frames']:
                    if 'vars' in frame:
                        for k,v in frame['vars'].iteritems():
                            if k.startswith('password'):
                                # store mask as a fixed length for security
                                frame['vars'][k] = '*'*16
        return data
########NEW FILE########
__FILENAME__ = base
"""
sentry.db.backends.base
~~~~~~~~~~~~~~~~~~~~~~~

:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
:license: BSD, see LICENSE for more details.
"""

import hashlib
import uuid

class SentryBackend(object):
    def _get_schema_name(self, schema):
        return schema.__name__.lower()

    def _get_composite_key(self, **keys):
        return hashlib.md5(';'.join('%s=%s' % (k, v) for k, v in keys.iteritems())).hexdigest()

    def generate_key(self, schema):
        return uuid.uuid4().hex

########NEW FILE########
__FILENAME__ = redis
"""
sentry.db.backends.redis
~~~~~~~~~~~~~~~~~~~~~~~~

:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
:license: BSD, see LICENSE for more details.
"""

from __future__ import absolute_import

from sentry.db.backends.base import SentryBackend

import datetime
import redis

class RedisBackend(SentryBackend):
    def __init__(self, host='localhost', port=6379, db=0, key_prefix=''):
        self.conn = redis.Redis(host, port, db)
        self.key_prefix = key_prefix

    ## Keys
    
    def _get_key(self, key):
        return '%s:%s' % (self.key_prefix, key)
    
    def _get_data_key(self, schema, pk):
        return self._get_key('data:%s:%s' % (self._get_schema_name(schema), pk))

    def _get_metadata_key(self, schema, pk):
        return self._get_key('metadata:%s:%s' % (self._get_schema_name(schema), pk))

    def _get_index_key(self, schema, index):
        return self._get_key('index:%s:%s' % (self._get_schema_name(schema), index))

    def _get_relation_key(self, from_schema, from_pk, to_schema):
        return self._get_key('rindex:%s:%s:%s' % (self._get_schema_name(from_schema), from_pk, self._get_schema_name(to_schema)))

    def _get_constraint_key(self, schema, kwargs):
        return self._get_key('cindex:%s:%s' % (self._get_schema_name(schema), self._get_composite_key(**kwargs)))

    ## Hash table lookups

    def create_model(self, schema):
        return

    def add(self, schema, **values):
        # generates a pk and sets the values
        pk = self.generate_key(schema)
        if values:
            self.set(schema, pk, **values)
        return pk

    def delete(self, schema, pk):
        self.conn.delete(self._get_data_key(schema, pk))
        self.conn.delete(self._get_metadata_key(schema, pk))

    def set(self, schema, pk, **values):
        if values:
            self.conn.hmset(self._get_data_key(schema, pk), values)

    def get(self, schema, pk):
        return self.conn.hgetall(self._get_data_key(schema, pk))

    def incr(self, schema, pk, key, amount=1):
        return self.conn.hincrby(self._get_data_key(schema, pk), key, amount)

    # meta data is stored in a seperate key to avoid collissions and heavy getall pulls

    def set_meta(self, schema, pk, **values):
        self.conn.hmset(self._get_metadata_key(schema, pk), values)

    def get_meta(self, schema, pk):
        return self.conn.hgetall(self._get_metadata_key(schema, pk))

    def get_data(self, schema, pk):
        return self.conn.hgetall(self._get_data_key(schema, pk))

    def count(self, schema, index='default'):
        return self.conn.zcard(self._get_index_key(schema, index))

    def list(self, schema, index='default', offset=0, limit=-1, desc=False):
        if limit > 0:
            end = offset+limit
        else:
            end = limit
        pk_set = self.conn.zrange(self._get_index_key(schema, index), start=offset, end=end, desc=desc)
        return [(pk, self.get_data(schema, pk)) for pk in pk_set]

    ## Indexes using sorted sets

    def add_relation(self, from_schema, from_pk, to_schema, to_pk, score):
        # adds a relation to a sorted index for base instance
        if isinstance(score, datetime.datetime):
            score = score.strftime('%s.%m')
        self.conn.zadd(self._get_relation_key(from_schema, from_pk, to_schema), to_pk, float(score))

    def remove_relation(self, from_schema, from_pk, to_schema, to_pk=None):
        if to_pk:
            self.conn.zrem(self._get_relation_key(from_schema, from_pk, to_schema), to_pk)
        else:
            self.conn.delete(self._get_relation_key(from_schema, from_pk, to_schema))

    def list_relations(self, from_schema, from_pk, to_schema, offset=0, limit=-1, desc=False):
        # lists relations in a sorted index for base instance
        # XXX: this is O(n)+1, ugh
        if limit > 0:
            end = offset+limit
        else:
            end = limit
            
        pk_set = self.conn.zrange(self._get_relation_key(from_schema, from_pk, to_schema), start=offset, end=end, desc=desc)

        return [(pk, self.conn.hgetall(self._get_data_key(to_schema, pk))) for pk in pk_set]

    def add_to_index(self, schema, pk, index, score):
        # adds an instance to a sorted index
        if isinstance(score, datetime.datetime):
            score = score.strftime('%s.%m')
        self.conn.zadd(self._get_index_key(schema, index), pk, float(score))

    def remove_from_index(self, schema, pk, index):
        self.conn.zrem(self._get_index_key(schema, index), pk)

    ## Generic indexes

    # TODO: can we combine constraint indexes with sort indexes? (at least the API)

    def add_to_cindex(self, schema, pk, **kwargs):
        # adds an index to a composite index (for checking uniqueness)
        self.conn.sadd(self._get_constraint_key(schema, kwargs), pk)

    def remove_from_cindex(self, schema, pk, **kwargs):
        # adds an index to a composite index (for checking uniqueness)
        self.conn.srem(self._get_constraint_key(schema, kwargs), pk)

    def list_by_cindex(self, schema, **kwargs):
        # returns a list of keys associated with a constraint
        return list(self.conn.smembers(self._get_constraint_key(schema, kwargs)))

########NEW FILE########
__FILENAME__ = backend
"""
sentry.db.backends.sqlalchemy
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
:license: BSD, see LICENSE for more details.
"""

from __future__ import absolute_import

from sentry.db.backends.base import SentryBackend

import datetime

from sqlalchemy import create_engine
from sqlalchemy.sql import select

from sentry.db.backends.sqlalchemy.models import metadata, model_map

class SQLAlchemyBackend(SentryBackend):
    def __init__(self, uri, **kwargs):
        self.engine = create_engine(uri, **kwargs)

    def create_model(self, schema):
        metadata.create(model_map[schema])

    ## Hash table lookups

    def add(self, schema, **values):
        # generates a pk and sets the values
        pk = self.generate_key(schema)
        table = model_map[schema]
        query = table.insert(id=pk, **values)
        self.engine.execute(query)
        return pk

    def delete(self, schema, pk):
        table = model_map[schema]
        query = table.delete(table.c.id==pk)
        self.engine.execute(query)

    def set(self, schema, pk, **values):
        table = model_map[schema]
        query = table.update(table.c.id==pk).values(**values)
        self.engine.execute(query)

    def get(self, schema, pk):
        table = model_map[schema]
        query = select([table], table.c.id==pk)
        return self.engine.execute(query).fetchone()

    def incr(self, schema, pk, key, amount=1):
        table = model_map[schema]
        query = table.update(table.c.id==pk, {key: getattr(table.c, key) + amount})
        self.engine.execute(query)
    
    # meta data is stored in a seperate key to avoid collissions and heavy getall pulls

    # TODO:
    def set_meta(self, schema, pk, **values):
        self.conn.hmset(self._get_metadata_key(schema, pk), values)

    def get_meta(self, schema, pk):
        return self.conn.hgetall(self._get_metadata_key(schema, pk))

    def get_data(self, schema, pk):
        return self.conn.hgetall(self._get_data_key(schema, pk))

    def count(self, schema, index='default'):
        return self.conn.zcard(self._get_index_key(schema, index))

    def list(self, schema, index='default', offset=0, limit=-1, desc=False):
        if limit > 0:
            end = offset+limit
        else:
            end = limit
        pk_set = self.conn.zrange(self._get_index_key(schema, index), start=offset, end=end, desc=desc)
        return [(pk, self.get_data(schema, pk)) for pk in pk_set]

    ## Indexes using sorted sets

    def add_relation(self, from_schema, from_pk, to_schema, to_pk, score):
        # adds a relation to a sorted index for base instance
        if isinstance(score, datetime.datetime):
            score = score.strftime('%s.%m')
        self.conn.zadd(self._get_relation_key(from_schema, from_pk, to_schema), to_pk, float(score))

    def remove_relation(self, from_schema, from_pk, to_schema, to_pk=None):
        if to_pk:
            self.conn.zrem(self._get_relation_key(from_schema, from_pk, to_schema), to_pk)
        else:
            self.conn.delete(self._get_relation_key(from_schema, from_pk, to_schema))

    def list_relations(self, from_schema, from_pk, to_schema, offset=0, limit=-1, desc=False):
        # lists relations in a sorted index for base instance
        # XXX: this is O(n)+1, ugh
        if limit > 0:
            end = offset+limit
        else:
            end = limit
            
        pk_set = self.conn.zrange(self._get_relation_key(from_schema, from_pk, to_schema), start=offset, end=end, desc=desc)

        return [(pk, self.conn.hgetall(self._get_data_key(to_schema, pk))) for pk in pk_set]

    def add_to_index(self, schema, pk, index, score):
        # adds an instance to a sorted index
        if isinstance(score, datetime.datetime):
            score = score.strftime('%s.%m')
        self.conn.zadd(self._get_index_key(schema, index), pk, float(score))

    def remove_from_index(self, schema, pk, index):
        self.conn.zrem(self._get_index_key(schema, index), pk)

    ## Generic indexes

    # TODO: can we combine constraint indexes with sort indexes? (at least the API)

    def add_to_cindex(self, schema, pk, **kwargs):
        # adds an index to a composite index (for checking uniqueness)
        self.conn.sadd(self._get_constraint_key(schema, kwargs), pk)

    def remove_from_cindex(self, schema, pk, **kwargs):
        # adds an index to a composite index (for checking uniqueness)
        self.conn.srem(self._get_constraint_key(schema, kwargs), pk)

    def list_by_cindex(self, schema, **kwargs):
        # returns a list of keys associated with a constraint
        return list(self.conn.smembers(self._get_constraint_key(schema, kwargs)))

########NEW FILE########
__FILENAME__ = models
import sentry.models
from sentry.db import models

from sqlalchemy import Table, Column, Integer, Float, String, Text, \
                       DateTime, MetaData

__all__ = ('metadata', 'model_map', 'model_meta')

column_map = {
    models.String: lambda x: String(255, default=x.default, nullable=True),
    models.Text: lambda x: Text(default=x.default, nullable=True),
    models.Integer: lambda x: Integer(default=x.default, nullable=True),
    models.Float: lambda x: Float(default=x.default, nullable=True),
    models.DateTime: lambda x: DateTime(default=x.default, nullable=True),
    models.List: lambda x: Text(default=x.default, nullable=True),
}

model_map = {}
model_meta = {}

def create_sqlalchemy_def(metadata, model):
    columns = [
        Column('id', String(32), primary_key=True),
    ]
    for name, field in model._meta.fields: 
        columns.append(Column(name, column_map[field](field), nullable=True))

    table = Table(model.__name__.lower(), metadata, *columns)
    
    return table

def create_sqlalchemy_metadata_def(metadata, model):
    columns = [
        Column('id', String(32), primary_key=True),
        Column('key', String(255), primary_key=True),
        Column('value', Text(nullable=True), primary_key=True),
    ]

    table = Table('%s_metadata' % (model.__name__.lower(),), metadata, *columns)
    
    return table

metadata = MetaData()
# metadata.create_all(engine) 

for var in dir(sentry.models):
    if isinstance(var, models.Model):
        model_map[var] = create_sqlalchemy_def(metadata, var)
        model_meta[var] = create_sqlalchemy_metadata_def(metadata, var)

########NEW FILE########
__FILENAME__ = models
"""
sentry.db.models
~~~~~~~~~~~~~~~~

:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
:license: BSD, see LICENSE for more details.
"""

# Inspired by Django's models

import datetime
import simplejson

try:
    import cPickle as pickle
except ImportError:
    import pickle

from sentry import app

def to_db(model, values):
    result = {}
    for k, v in values.iteritems():
        field = model._meta.fields.get(k)
        if field:
            v = field.to_db(v)
            if v is None:
                v = ''
        else:
            v = simplejson.dumps(v)
        result[k] = v
    return result

class DoesNotExist(Exception):
    pass

class DuplicateKeyError(Exception):
    pass

class ManagerDescriptor(object):
    def __init__(self, manager):
        self.manager = manager

    def __get__(self, instance, type=None):
        if instance != None:
            raise AttributeError("Manager isn't accessible via %s instances" % type.__name__)
        return self.manager

class QuerySet(object):
    def __init__(self, model, order_by=None, filter_by=None):
        assert not (order_by and filter_by)
        self.model = model
        self.index = order_by or self.model._meta.ordering
        self.filter = filter_by
    
    def __repr__(self):
        return u'<%s: %s>' % (self.__class__.__name__, list(self))

    def __getitem__(self, key):
        is_slice = isinstance(key, slice)
        if is_slice:
            assert key.step == 1 or key.step is None
            start = key.start or 0
            stop = key.stop
        else:
            start = key
            stop = key + 1

        if stop == -1:
            num = stop
        else:
            num = stop - start
        
        if self.index.startswith('-'):
            desc = True
            index = self.index[1:]
        else:
            desc = False
            index = self.index

        results = self._get_results(start, num, index, desc)
        
        if is_slice:
            return results
        return results[0]

    def __len__(self):
        if self.index.startswith('-'):
            index = self.index[1:]
        else:
            index = self.index
        
        return app.db.count(self.model, index)

    def __iter__(self):
        for r in self[0:-1]:
            yield r

    def _get_results(self, start, num, index, desc=False):
        if self.filter:
            data = [(pk, app.db.get_data(self.model, pk)) for pk in app.db.list_by_cindex(self.model, **to_db(self.model, self.filter))]
        else:
            data = app.db.list(self.model, index, start, num, desc)

        return [self.model(pk, **data) for pk, data in data]

    def order_by(self, index):
        assert not self.filter
        self.index = index
        return self
    
class Manager(object):
    def __init__(self, model):
        self.model = model

    def count(self):
        return app.db.count(self.model, self.model._meta.ordering)

    def get_query_set(self):
        return QuerySet(self.model)

    def filter(self, **kwargs):
        assert len(kwargs) == 1
        return QuerySet(self.model, filter_by=kwargs)

    def all(self):
        return self.get_query_set()

    def order_by(self, index):
        return self.get_query_set().order_by(index)

    def get(self, pk):
        data = app.db.get(self.model, pk)
        if data == {}:
            raise self.model.DoesNotExist
        return self.model(pk, **data)

    def create(self, **values):
        instance = self.model(**values)
        instance.save()

        return instance

    def set_meta(self, pk, **values):
        if not values:
            return
        app.db.set_meta(self.model, pk, **to_db(self.model, values))

    def get_meta(self, pk):
        return dict((k, simplejson.loads(v)) for k, v in app.db.get_meta(self.model, pk).iteritems())

    def remove_from_index(self, pk, index):
        return app.db.remove_from_index(self.model, pk, index)

    def add_to_index(self, pk, index, score):
        return app.db.add_to_index(self.model, pk, index, score)

    def get_or_create(self, defaults=None, **index):
        # return (instance, created)

        pk_set = app.db.list_by_cindex(self.model, **to_db(self.model, index))
        if len(pk_set) == 1:
            return self.get(pk_set[0]), False
        elif pk_set:
            raise self.model.MultipleObjectsReturned

        if defaults is None:
            defaults = {}
        else:
            defaults = defaults.copy()
        defaults.update(index)

        inst = self.create(**defaults)

        return inst, True

class Options(object):
    def __init__(self, meta, attrs):
        # Grab fields
        fkeys = []
        fields = []
        for obj_name, obj in attrs.iteritems():
            if isinstance(obj, ForeignKey):
                fkeys.append((obj_name, obj))
            elif isinstance(obj, Field):
                fields.append((obj_name, obj))
        
        self.relations = fkeys
        self.fields = dict(fields)

        default_order = meta.__dict__.get('ordering')

        self.ordering = default_order or 'default'

        self.sortables = list(meta.__dict__.get('sortables', []))

        self.indexes = list(meta.__dict__.get('indexes', []))

        if self.ordering != 'default':
            self.sortables.append(self.ordering)

        # If we've specified ordering, and ordering is not already defined
        # as a sort index, we must register it
        if default_order and default_order not in self.sortables:
            self.sortables.append(default_order)

class ModelDescriptor(type):
    def __new__(cls, name, bases, attrs):
        super_new = super(ModelDescriptor, cls).__new__
        parents = [b for b in bases if isinstance(b, ModelDescriptor)]
        if not parents:
            # If this isn't a subclass of Model, don't do anything special.
            return super_new(cls, name, bases, attrs)

        module = attrs.pop('__module__')
        new_class = super_new(cls, name, bases, {'__module__': module})
        attr_meta = attrs.pop('Meta', None)
        if not attr_meta:
            meta = getattr(new_class, 'Meta', None)
        else:
            meta = attr_meta
        setattr(new_class, '_meta', Options(meta, attrs))

        # Setup default manager
        setattr(new_class, 'objects', Manager(new_class))

        # Add all attributes to the class.
        for obj_name, obj in attrs.iteritems():
            setattr(new_class, obj_name, obj)

        return new_class

class Model(object):
    __metaclass__ = ModelDescriptor

    DoesNotExist = DoesNotExist
    DuplicateKeyError = DuplicateKeyError

    def __init__(self, pk=None, **kwargs):
        self.pk = pk
        for attname, field in self._meta.fields.iteritems():
            try:
                val = field.to_python(kwargs.pop(attname))
            except KeyError:
                val = field.get_default()
            setattr(self, attname, val)
        if kwargs:
            raise ValueError('%s are not part of the schema for %s' % (', '.join(kwargs.keys()), self.__class__.__name__))

    def __eq__(self, other):
        return type(other) == type(self) and other.pk == self.pk

    def __setattr__(self, key, value):
        # XXX: is this the best approach for validating attributes
        field = self._meta.fields.get(key)
        if field and value:
            value = field.to_python(value)
        object.__setattr__(self, key, value)

    def __repr__(self):
        return u'<%s: %s>' % (self.__class__.__name__, unicode(self))

    def __unicode__(self):
        return self.pk or u'None'

    def decr(self, key, amount=1):
        result = app.db.decr(self.__class__, self.pk, key, amount)
        if key in self._meta.sortables:
            self.objects.add_to_index(self.pk, key, result)
        setattr(self, key, result)
        return result

    def incr(self, key, amount=1):
        result = app.db.incr(self.__class__, self.pk, key, amount)
        if key in self._meta.sortables:
            self.objects.add_to_index(self.pk, key, result)
        setattr(self, key, result)
        return result

    def save(self):
        model = self.__class__
        
        values = dict((name, getattr(self, name)) for name in self._meta.fields.iterkeys())

        # Ensure we've grabbed a primary key
        # XXX: API might need some work here yet
        created = not self.pk
        if created:
            self.pk = app.db.add(model)

        self.update(**values)
        
        if created:
            # Ensure we save our default index (this only happens
            # on instance creation)
            ordering = model._meta.ordering
            if ordering == 'default':
                value = datetime.datetime.now()
                self.objects.add_to_index(self.pk, 'default', value)

    def update(self, **values):
        assert self.pk
        
        model = self.__class__

        result = app.db.set(model, self.pk, **to_db(model, values))

        for index in self._meta.sortables:
            if index in values:
                self.objects.add_to_index(self.pk, index, getattr(self, index) or 0.0)

        # TODO: we need to deal w/ unsetting the previous keys
        for index in self._meta.indexes:
            index_values = dict((name, getattr(self, name)) for name in index)
            app.db.add_to_cindex(model, self.pk, **to_db(model, index_values))

        for k, v in values.iteritems():
            setattr(self, k, v)

        return result

    def delete(self):
        assert self.pk

        model = self.__class__
        
        # remove indexes
        for index in self._meta.sortables:
            self.objects.remove_from_index(self.pk, index)

        for index in self._meta.indexes:
            index_values = dict((name, getattr(self, name)) for name in index)
            app.db.remove_from_cindex(model, self.pk, **to_db(model, index_values))

        ordering = self._meta.ordering
        if ordering == 'default':
            self.objects.remove_from_index(self.pk, 'default')

        # remove relation keys
        for name, field in self._meta.relations:
            app.db.remove_relation(model, self.pk)
            # TODO: clean up remaining relation

        # remove instance
        app.db.delete(model, self.pk)

    def set_meta(self, **values):
        self.objects.set_meta(self.pk, **values)

    def get_meta(self):
        return self.objects.get_meta(self.pk)

    def add_relation(self, instance, score):
        # add child relation
        app.db.add_relation(self.__class__, self.pk, instance.__class__, instance.pk, score)
        # add parent relation
        app.db.add_relation(instance.__class__, instance.pk, self.__class__, self.pk, score)

    def get_relations(self, model, offset=0, limit=100, desc=True):
        return [model(pk, **data) for pk, data in app.db.list_relations(self.__class__, self.pk, model, offset, limit, desc)]

    def _get_data(self):
        return self.get_meta() or {}
    data = property(_get_data)

class Field(object):
    def __init__(self, default=None, **kwargs):
        self.default = default

    def get_default(self):
        if not self.default:
            value = self.to_python(None)
        elif callable(self.default):
            value = self.default()
        else:
            value = self.default
        return value

    def to_db(self, value=None):
        if value is None:
            value = ''
        return value

    def to_python(self, value=None):
        return value

class ForeignKey(object):
    def __init__(self, to_model):
        self.to_model = to_model

class String(Field):
    def to_python(self, value=None):
        if value:
            value = unicode(value)
        else:
            value = u''
        return value

class Text(String):
    pass

class Integer(Field):
    def to_python(self, value=None):
        if value:
            value = int(value)
        else:
            value = 0
        return value

class Float(Field):
    def to_python(self, value=None):
        if value:
            value = float(value)
        else:
            value = 0.0
        return value

class DateTime(Field):
    def to_db(self, value=None):
        if isinstance(value, datetime.datetime):
            # TODO: coerce this to UTC
            value = value.isoformat()
        return value

    def to_python(self, value=None):
        if value and not isinstance(value, datetime.datetime):
            # TODO: coerce this to a UTC datetime object
            if '.' in value:
                value = datetime.datetime.strptime(value, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                value = datetime.datetime.strptime(value, '%Y-%m-%dT%H:%M:%S')
        return value

class List(Field):
    def to_db(self, value=None):
        if isinstance(value, (tuple, list)):
            value = pickle.dumps(value)
        return value

    def to_python(self, value=None):
        if not value:
            value = []
        elif isinstance(value, basestring):
            value = pickle.loads(value)
        return value
########NEW FILE########
__FILENAME__ = events
"""
sentry.events
~~~~~~~~~~~~~

:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
:license: BSD, see LICENSE for more details.
"""

import re
import sys

from sentry import app
from sentry.utils import transform

__all__ = ('BaseEvent', 'Exception', 'Message', 'Query')

class BaseEvent(object):
    def to_string(self, data):
        raise NotImplementedError
    
    def get_data(self, **kwargs):
        return {}
    
    def get_tags(self, **kwargs):
        return []
    
    def capture(self, **kwargs):
        # tags and culprit are special cased and not stored with the
        # default metadata
        return {
            'culprit': None,
            'tags': self.get_tags(**kwargs),
            self.interface: self.get_data(**kwargs),
        }

class Exception(BaseEvent):
    """
    Exceptions store the following metadata:

    - value: 'My exception value'
    - type: 'module.ClassName'
    - frames: a list of serialized frames (see _get_traceback_frames)
    - template: 'template/name.html'
    """
    interface = 'sentry.interfaces.Exception'
    
    def to_string(self, data):
        if data['value']:
            return '%s: %s' % (data['type'], data['value'])
        return data['type']

    def get_event_hash(self, type, value, **kwargs):
        # TODO: Need to add in the frames without line numbers
        return [type, value]

    def capture(self, exc_info=None, **kwargs):
        if exc_info is None:
            exc_info = sys.exc_info()
        
        exc_type, exc_value, exc_traceback = exc_info
        
        tags = [('level', 'error')]
        
        culprit = self._get_culprit(exc_info[2])

        if hasattr(exc_type, '__class__'):
            exc_module = exc_type.__class__.__module__
            if exc_module == '__builtin__':
                exc_type = exc_type.__name__
            else:
                exc_type = '%s.%s' % (exc_module, exc_type.__name__)
        else:
            exc_module = None
            exc_type = exc_type.__name__

        # if isinstance(exc_value, TemplateSyntaxError) and hasattr(exc_value, 'source'):
        #     origin, (start, end) = exc_value.source
        #     result['template'] = (origin.reload(), start, end, origin.name)
        #     result['tags'].append(('template', origin.loadname))

        return {
            'culprit': culprit,
            'tags': tags,
            'sentry.interfaces.Exception': {
                'value': transform(exc_value),
                'type': exc_type,
            },
            'sentry.interfaces.Stacktrace': {
                'frames': self._get_traceback_frames(exc_traceback)
            },
        }

    def _iter_tb(self, tb):
        while tb:
            # support for __traceback_hide__ which is used by a few libraries
            # to hide internal frames.
            if tb.tb_frame.f_locals.get('__traceback_hide__'):
                continue
            yield tb
            tb = tb.tb_next

    def _get_lines_from_file(self, filename, lineno, context_lines, loader=None, module_name=None):
        """
        Returns context_lines before and after lineno from file.
        Returns (pre_context_lineno, pre_context, context_line, post_context).
        """
        source = None
        if loader is not None and hasattr(loader, "get_source"):
            source = loader.get_source(module_name)
            if source is not None:
                source = source.splitlines()
        if source is None:
            try:
                f = open(filename)
                try:
                    source = f.readlines()
                finally:
                    f.close()
            except (OSError, IOError):
                pass
        if source is None:
            return None, [], None, []

        encoding = 'ascii'
        for line in source[:2]:
            # File coding may be specified. Match pattern from PEP-263
            # (http://www.python.org/dev/peps/pep-0263/)
            match = re.search(r'coding[:=]\s*([-\w.]+)', line)
            if match:
                encoding = match.group(1)
                break
        source = [unicode(sline, encoding, 'replace') for sline in source]

        lower_bound = max(0, lineno - context_lines)
        upper_bound = lineno + context_lines

        pre_context = [line.strip('\n') for line in source[lower_bound:lineno]]
        context_line = source[lineno].strip('\n')
        post_context = [line.strip('\n') for line in source[lineno+1:upper_bound]]

        return lower_bound, pre_context, context_line, post_context

    def _get_culprit(self, traceback):
        # We iterate through each frame looking for a deterministic culprit
        # When one is found, we mark it as last "best guess" (best_guess) and then
        # check it against SENTRY_EXCLUDE_PATHS. If it isnt listed, then we
        # use this option. If nothing is found, we use the "best guess".
        def contains(iterator, value):
            for k in iterator:
                if value.startswith(k):
                    return True
            return False

        if app.config['INCLUDE_PATHS']:
            modules = app.config['INCLUDE_PATHS']
        else:
            modules = []

        best_guess = None
        for tb in self._iter_tb(traceback):
            frame = tb.tb_frame
            try:
                culprit = '.'.join([frame.f_globals['__name__'], frame.f_code.co_name])
            except:
                continue
            if contains(modules, culprit):
                if not (contains(app.config['EXCLUDE_PATHS'], culprit) and best_guess):
                    best_guess = culprit
            elif best_guess:
                break
    
        return best_guess

    def _get_traceback_frames(self, tb):
        frames = []
        for tb in self._iter_tb(tb):
            filename = tb.tb_frame.f_code.co_filename
            function = tb.tb_frame.f_code.co_name
            lineno = tb.tb_lineno - 1
            loader = tb.tb_frame.f_globals.get('__loader__')
            module_name = tb.tb_frame.f_globals.get('__name__')
            pre_context_lineno, pre_context, context_line, post_context = self._get_lines_from_file(filename, lineno, 7, loader, module_name)
            if pre_context_lineno is not None:
                frames.append({
                    'id': id(tb),
                    'filename': filename,
                    'module': module_name,
                    'function': function,
                    'lineno': lineno + 1,
                    # TODO: vars need to be references
                    'vars': tb.tb_frame.f_locals,
                    'pre_context': pre_context,
                    'context_line': context_line,
                    'post_context': post_context,
                    'pre_context_lineno': pre_context_lineno + 1,
                })
        return frames

class Message(BaseEvent):
    """
    Messages store the following metadata:

    - message: 'My message from %s about %s'
    - params: ('foo', 'bar')
    """

    interface = 'sentry.interfaces.Message'

    def to_string(self, data):
        return data['message'] % tuple(data.get('params', ()))

    def get_event_hash(self, message, params=(), **kwargs):
        return [message] + list(params)

    def get_data(self, message, params=(), **kwargs):
        return {
            'message': message,
            'params': params,
        }
        
class Query(BaseEvent):
    """
    Messages store the following metadata:

    - query: 'SELECT * FROM table'
    - engine: 'postgesql_psycopg2'
    """
    interface = 'sentry.interfaces.Query'
    
    def to_string(self, data):
        return data['query']
    
    def get_event_hash(self, query, engine, **kwargs):
        return [query, engine]

    def get_data(self, query, engine, **kwargs):
        return {
            'query': query,
            'engine': engine,
        }
########NEW FILE########
__FILENAME__ = interfaces
"""
sentry.interfaces
~~~~~~~~~~~~~~~~~

:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
:license: BSD, see LICENSE for more details.
"""

import urlparse

from flask import render_template

# unserialization concept is based on pickle
class _EmptyClass(object):
    pass

def unserialize(klass, data):
    value = _EmptyClass()
    value.__class__ = klass
    value.__setstate__(data)
    return value

class Interface(object):
    """
    An interface is a structured represntation of data, which may
    render differently than the default ``extra`` metadata in an event.
    """

    def __setstate__(self, data):
        self.__dict__.update(self.unserialize(data))

    def __getstate__(self):
        return self.serialize()

    def unserialize(self, data):
        return data
        
    def serialize(self):
        return {}
    
    def to_html(self, event):
        return ''

class Message(Interface):
    def __init__(self, message, params):
        self.message = message
        self.params = params
    
    def serialize(self):
        return {
            'message': self.message,
            'params': self.params,
        }

class Query(Interface):
    def __init__(self, query, engine):
        self.query = query
        self.engine = engine
    
    def serialize(self):
        return {
            'query': self.query,
            'engine': self.engine,
        }

class Stacktrace(Interface):
    def __init__(self, frames):
        self.frames = frames
    
    def serialize(self):
        return {
            'frames': self.frames,
        }
    
    def to_html(self, event):
        return render_template('sentry/partial/interfaces/stacktrace.html', **{
            'frames': self.frames,
        })

class Exception(Interface):
    def __init__(self, type, value):
        self.type = type
        self.value = value
    
    def serialize(self):
        return {
            'type': self.type,
            'value': self.value,
        }
    
    def to_html(self, event):
        return render_template('sentry/partial/interfaces/exception.html', **{
            'exception_value': self.value,
            'exception_type': self.type,
        })

class Http(Interface):
    # methods as defined by http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html
    METHODS = ('GET', 'POST', 'PUT', 'OPTIONS', 'HEAD', 'DELETE', 'TRACE', 'CONNECT')
    
    def __init__(self, url, method, data=None, querystring=None, **kwargs):
        if data is None:
            data = {}

        method = method.upper()

        assert method in self.METHODS

        urlparts = urlparse.urlsplit(url)

        if not querystring:
            # define querystring from url
            querystring = urlparts.query

        elif querystring.startswith('?'):
            # remove '?' prefix
            querystring = querystring[1:]

        self.url = '%s://%s%s' % (urlparts.scheme, urlparts.netloc, urlparts.path)
        self.method = method
        self.data = data
        self.querystring = querystring
    
    def serialize(self):
        return {
            'url': self.url,
            'method': self.method,
            'data': self.data,
            'querystring': self.querystring,
        }

    def to_html(self, event):
        return render_template('sentry/partial/interfaces/http.html', **{
            'full_url': '?'.join(filter(None, [self.url, self.querystring])),
            'url': self.url,
            'method': self.method,
            'data': self.data,
            'querystring': self.querystring,
        })
        

########NEW FILE########
__FILENAME__ = middleware
"""
sentry.middleware
~~~~~~~~~~~~~~~~~

:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
:license: BSD, see LICENSE for more details.
"""

import sys

from sentry import capture
from werkzeug.wsgi import get_current_url

class WSGIErrorMiddleware(object):
    def __init__(self, application):
        self.application = application

    def __call__(self, environ, start_response):
        try:
            return self.application(environ, start_response)
        except Exception:
            exc_info = sys.exc_info()
            self.handle_exception(exc_info, environ)
            exc_info = None
            raise

    def handle_exception(self, exc_info, environ):
        event_id = capture('Exception',
            exc_info=exc_info,
            data={
                'sentry.interfaces.Http': {
                    'method': environ.get('REQUEST_METHOD'),
                    'url': get_current_url(environ, strip_querystring=True),
                    'querystring': environ.get('QUERY_STRING'),
                },
            },
        )
        return event_id

########NEW FILE########
__FILENAME__ = models
"""
sentry.models
~~~~~~~~~~~~~

:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
:license: BSD, see LICENSE for more details.
"""

from __future__ import absolute_import

import datetime
import hashlib

from sentry.interfaces import unserialize
from sentry.db import models
from sentry.utils.compat import math

class Group(models.Model):
    """
    Stores an aggregate (summary) of Event's for a combination of tags
    given a slice.
    """

    # key is (type, hash)

    # this is the combination of md5(' '.join(tags)) + md5(event)
    type            = models.String() # length 32
    hash            = models.String() # length 32
    # one line summary used for rendering
    message         = models.Text()
    state           = models.Integer(default=0)
    count           = models.Integer(default=0)
    score           = models.Float(default=0.0)
    time_spent      = models.Integer(default=0)
    first_seen      = models.DateTime(default=datetime.datetime.now)
    last_seen       = models.DateTime(default=datetime.datetime.now)
    # This is a meta element which needs magically created or something
    # score           = models.Float(default=0.0)
    tags            = models.List()

    class Meta:
        ordering = 'last_seen'
        sortables = ('time_spent', 'first_seen', 'last_seen', 'score')
        indexes = (('type', 'hash'),)

    def save(self, *args, **kwargs):
        created = not self.pk
        self.score = self.get_score()
        super(Group, self).save(*args, **kwargs)
        if created:
            EventType.add_group(self)
            Tag.add_group(self)

    def delete(self, *args, **kwargs):
        super(Group, self).delete(*args, **kwargs)
        EventType.remove_group(self)
        Tag.remove_group(self)

    def get_score(self):
        return float(abs(math.log(self.count) * 600 + float(self.last_seen.strftime('%s.%m'))))

class Event(models.Model):
    """
    An individual event. It's processor (type) handles input and output, as well as
    group summarization.
    """

    # the hash of this event is defined by its processor (type)
    hash            = models.String()
    type            = models.String()
    date            = models.DateTime(default=datetime.datetime.now)
    time_spent      = models.Integer(default=0) # in ms
    tags            = models.List()

    class Meta:
        ordering = 'date'

    def get_version(self):
        if not self.data:
            return
        if 'version' not in self.data:
            return
        return self.data['version']

    def get_processor(self):
        # TODO: should use general import cache
        mod_name, class_name = self.type.rsplit('.', 1)
        processor = getattr(__import__(mod_name, {}, {}, [class_name]), class_name)()
        return processor
    
    def get_interfaces(self):
        # TODO: should use general import cache
        interfaces = []
        for k, v in self.data.iteritems():
            if '.' not in k:
                continue
            
            mod_name, class_name = k.rsplit('.', 1)
            interface = getattr(__import__(mod_name, {}, {}, [class_name]), class_name)
            interfaces.append(unserialize(interface, v))
        return interfaces

class EventType(models.Model):
    """
    Stores a list of all event types seen, as well as
    a tally of the number of events recorded.
    """
    # full module path to Event class, e.g. sentry.events.Exception
    path            = models.String()
    # number of unique groups seen for this event
    count           = models.Integer(default=0)

    class Meta:
        ordering = 'count'
        indexes = (('path',),)

    def __unicode__(self):
        return self.path

    @classmethod
    def add_group(cls, group):
        et, created = cls.objects.get_or_create(
            path=group.type,
            defaults={
                'count': 1,
            }
        )
        if not created:
            et.incr('count', 1)
    
    @classmethod
    def remove_group(cls, group):
        try:
            et = cls.objects.get(path=group.type)
        except EventType.DoesNotExist:
            return

        et.decr('count', 1)
        if et.count <= 0:
            et.delete()

class Tag(models.Model):
    """
    Stores a unique value of a tag.
    """

    key             = models.String() # length 16?
    # hash is md5('key=value')
    hash            = models.String() # length 32
    value           = models.String()
    count           = models.Integer(default=0)

    class Meta:
        ordering = 'count'
        indexes = (('hash',), ('key',))

    def __unicode__(self):
        return u"%s=%s; count=%s" % (self.key, self.value, self.count)

    @classmethod
    def add_group(cls, group):
        for key, value in group.tags:
            hash = hashlib.md5(u'%s=%s' % (key, value)).hexdigest()
            tag, created = cls.objects.get_or_create(
                hash=hash,
                defaults={
                    'key': key,
                    'value': value,
                    'count': 1,
                }
            )
            if not created:
                tag.incr('count', 1)
    
    @classmethod
    def remove_group(cls, group):
        for key, value in group.tags:
            try:
                tag = cls.objects.get(hash=hash)
            except cls.DoesNotExist:
                continue

            tag.decr('count', 1)
            if tag.count <= 0:
                tag.delete()

########NEW FILE########
__FILENAME__ = conf
from django.conf import settings

# Either API_KEY or USERNAME/PASSWORD should be specified for non-anonymous
# XXX: In redmine as of Oct 15 2010 API KEY auth does not support creating issues

REDMINE_API_KEY = getattr(settings, 'SENTRY_REDMINE_API_KEY', None)
REDMINE_URL = getattr(settings, 'SENTRY_REDMINE_URL', None)
REDMINE_PROJECT_SLUG = getattr(settings, 'SENTRY_REDMINE_PROJECT_SLUG', None)

REDMINE_USERNAME = getattr(settings, 'SENTRY_REDMINE_USERNAME', None)
REDMINE_PASSWORD = getattr(settings, 'SENTRY_REDMINE_PASSWORd', None)

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'RedmineIssue'
        db.create_table('sentry_redmine_redmineissue', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('group', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['sentry.GroupedMessage'])),
            ('issue_id', self.gf('django.db.models.fields.PositiveIntegerField')()),
        ))
        db.send_create_signal('sentry_redmine', ['RedmineIssue'])


    def backwards(self, orm):
        
        # Deleting model 'RedmineIssue'
        db.delete_table('sentry_redmine_redmineissue')


    models = {
        'sentry.groupedmessage': {
            'Meta': {'unique_together': "(('logger', 'view', 'checksum'),)", 'object_name': 'GroupedMessage'},
            'checksum': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'class_name': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '128', 'null': 'True', 'blank': 'True'}),
            'data': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'first_seen': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_seen': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'db_index': 'True'}),
            'level': ('django.db.models.fields.PositiveIntegerField', [], {'default': '40', 'db_index': 'True', 'blank': 'True'}),
            'logger': ('django.db.models.fields.CharField', [], {'default': "'root'", 'max_length': '64', 'db_index': 'True', 'blank': 'True'}),
            'message': ('django.db.models.fields.TextField', [], {}),
            'status': ('django.db.models.fields.PositiveIntegerField', [], {'default': '0', 'db_index': 'True'}),
            'times_seen': ('django.db.models.fields.PositiveIntegerField', [], {'default': '1'}),
            'traceback': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'view': ('django.db.models.fields.CharField', [], {'max_length': '200', 'null': 'True', 'blank': 'True'})
        },
        'sentry_redmine.redmineissue': {
            'Meta': {'object_name': 'RedmineIssue'},
            'group': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sentry.GroupedMessage']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'issue_id': ('django.db.models.fields.PositiveIntegerField', [], {})
        }
    }

    complete_apps = ['sentry_redmine']

########NEW FILE########
__FILENAME__ = models
from django import forms
from django.core.context_processors import csrf
from django.core.urlresolvers import reverse
from django.db import models
from django.http import HttpResponseRedirect
from django.shortcuts import render_to_response
from django.utils import simplejson
from django.utils.safestring import mark_safe

from sentry.core.plugins import GroupActionProvider
from sentry.models import GroupedMessage
from sentry.plugins.sentry_redmine import conf

import base64
import urllib
import urllib2

class RedmineIssue(models.Model):
    group = models.ForeignKey(GroupedMessage)
    issue_id = models.PositiveIntegerField()

class RedmineIssueForm(forms.Form):
    subject = forms.CharField(max_length=200)
    description = forms.CharField(widget=forms.Textarea())

class CreateRedmineIssue(GroupActionProvider):
    title = 'Create Redmine Issue'

    def actions(self, request, action_list, group):
        if 'redmine' not in group.data:
            action_list.append((self.title, self.__class__.get_url(group.pk)))
        return action_list

    def view(self, request, group):
        if request.POST:
            form = RedmineIssueForm(request.POST)
            if form.is_valid():
                data = simplejson.dumps({
                    'key': conf.REDMINE_API_KEY,
                    'issue': {
                        'subject': form.cleaned_data['subject'],
                        'description': form.cleaned_data['description'],
                    }
                })
                url = conf.REDMINE_URL + '/projects/' + conf.REDMINE_PROJECT_SLUG + '/issues.json'
                
                req = urllib2.Request(url, urllib.urlencode({
                    'key': conf.REDMINE_API_KEY,
                }), headers={
                    'Content-type': 'application/json',
                })

                if conf.REDMINE_USERNAME and conf.REDMINE_PASSWORD:
                    authstring = base64.encodestring('%s:%s' % (conf.REDMINE_USERNAME, conf.REDMINE_PASSWORD))[:-1]
                    req.add_header("Authorization", "Basic %s" % authstring)
                
                try:
                    response = urllib2.urlopen(req, data).read()
                except urllib2.HTTPError, e:
                    if e.code == 422:
                        data = simplejson.loads(e.read())
                        form.errors['__all__'] = 'Missing or invalid data'
                        for message in data:
                            for k, v in message.iteritems():
                                if k in form.fields:
                                    form.errors.setdefault(k, []).append(v)
                                else:
                                    form.errors['__all__'] += '; %s: %s' % (k, v)
                    else:
                        form.errors['__all__'] = 'Bad response from Redmine: %s %s' % (e.code, e.msg)
                except urllib2.URLError, e:
                    form.errors['__all__'] = 'Unable to reach Redmine host: %s' % (e.reason,)
                else:
                    data = simplejson.loads(response)
                    RedmineIssue.objects.create(group=group, issue_id=data['id'])
                    group.data['redmine'] = {'issue_id': data['id']}
                    group.save()
                    return HttpResponseRedirect(reverse('sentry:group', args=[group.pk]))
        else:
            description = 'Sentry Message: %s' % request.build_absolute_uri(group.get_absolute_url())
            description += '\n\n<pre>' + (group.traceback or group.message) + '</pre>'

            form = RedmineIssueForm(initial={
                'subject': group.error(),
                'description': description,
            })
            
        global_errors = form.errors.get('__all__')

        BASE_TEMPLATE = "sentry/group/details.html"

        context = locals()
        context.update(csrf(request))

        return render_to_response('sentry/plugins/redmine/create_issue.html', context)

    def tags(self, request, tags, group):
        if 'redmine' in group.data:
            issue_id = group.data['redmine']['issue_id']
            tags.append(mark_safe('<a href="%s">#%s</a>' % (
                '%s/issues/%s' % (conf.REDMINE_URL, issue_id),
                issue_id,
            )))
        return tags
########NEW FILE########
__FILENAME__ = models
from django.shortcuts import render_to_response
from django.template.loader import render_to_string

from sentry.core.plugins import GroupActionProvider

class ServerGroupPanel(GroupActionProvider):
    """Adds additional support for showing information about servers including:
    
    * A panel which shows all servers a message was seen on.
    * A sidebar module which shows the servers most actively seen on.
    """
    
    title = 'Servers'

    def panels(self, request, panel_list, group):
        panel_list.append((self.title, self.__class__.get_url(group.pk)))
        return panel_list

    def view(self, request, group):
        return render_to_response('sentry/plugins/sentry_servers/index.html', locals())
    
    def widget(self, request, group):
        return render_to_string('sentry/plugins/sentry_servers/widget.html', locals())
########NEW FILE########
__FILENAME__ = models
from django.shortcuts import render_to_response
from django.template.loader import render_to_string

from sentry.core.plugins import GroupActionProvider

class SiteGroupPanel(GroupActionProvider):
    """Adds additional support for showing information about sites including:
    
    * A panel which shows all sites a message was seen on.
    * A sidebar module which shows the sites most actively seen on.
    """
    
    title = 'Sites'

    def panels(self, request, panel_list, group):
        panel_list.append((self.title, self.__class__.get_url(group.pk)))
        return panel_list

    def view(self, request, group):
        return render_to_response('sentry/plugins/sentry_sites/index.html', locals())
    
    def widget(self, request, group):
        return render_to_string('sentry/plugins/sentry_sites/widget.html', locals())
########NEW FILE########
__FILENAME__ = models
from django.shortcuts import render_to_response
from django.template.loader import render_to_string

from sentry.core.plugins import GroupActionProvider

class ServerUrlsPanel(GroupActionProvider):
    """Adds additional support for showing information about urls including:
    
    * A panel which shows all urls a message was seen on.
    * A sidebar module which shows the urls most actively seen on.
    """
    
    title = 'URLs'

    def panels(self, request, panel_list, group):
        panel_list.append((self.title, self.__class__.get_url(group.pk)))
        return panel_list

    def view(self, request, group):
        return render_to_response('sentry/plugins/sentry_urls/index.html', locals())
    
    def widget(self, request, group):
        return render_to_string('sentry/plugins/sentry_urls/widget.html', locals())
########NEW FILE########
__FILENAME__ = api
"""
sentry.utils.api
~~~~~~~~~~~~~~~~

:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
:license: BSD, see LICENSE for more details.
"""

from sentry import VERSION

import binascii
import hashlib
import hmac

def get_auth_header(signature, timestamp, client, nonce):
    return 'Sentry signature=%s, timestamp=%s, nonce=%s, client=%s' % (
        signature,
        timestamp,
        nonce,
        VERSION,
    )

def parse_auth_header(header):
    return dict(map(lambda x: x.strip().split('='), header.split(' ', 1)[1].split(',')))

def get_mac_signature(key, data, timestamp, nonce):
    """
    Returns BASE64 ( HMAC-SHA1 (key, data) )
    """
    hashed = hmac.new(str(key), '%s %s %s' % (timestamp, nonce, data), hashlib.sha1)
    return binascii.b2a_base64(hashed.digest())[:-1]
########NEW FILE########
__FILENAME__ = compat
"""
sentry.utils.compat
~~~~~~~~~~~~~~~~~~~

Contains compatibility imports (generally c-module replacements)

:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
:license: BSD, see LICENSE for more details.
"""

try:
    import cPickle as pickle
except ImportError:
    import pickle

try:
    import cmath as math
except ImportError:
    import math

########NEW FILE########
__FILENAME__ = encoding
"""
sentry.utils.encoding
~~~~~~~~~~~~~~~~~~~~~

:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
:license: BSD, see LICENSE for more details.
"""

# Adopted from Django
import types
import datetime
from decimal import Decimal

def is_protected_type(obj):
    """Determine if the object instance is of a protected type.

    Objects of protected types are preserved as-is when passed to
    force_unicode(strings_only=True).
    """
    return isinstance(obj, (
        types.NoneType,
        int, long,
        datetime.datetime, datetime.date, datetime.time,
        float, Decimal)
    )

def force_unicode(s, encoding='utf-8', strings_only=False, errors='strict'):
    """
    Similar to smart_unicode, except that lazy instances are resolved to
    strings, rather than kept as lazy objects.

    If strings_only is True, don't convert (some) non-string-like objects.
    """
    # Handle the common case first, saves 30-40% in performance when s
    # is an instance of unicode. This function gets called often in that
    # setting.
    if isinstance(s, unicode):
        return s
    if strings_only and is_protected_type(s):
        return s
    try:
        if not isinstance(s, basestring,):
            if hasattr(s, '__unicode__'):
                s = unicode(s)
            else:
                try:
                    s = unicode(str(s), encoding, errors)
                except UnicodeEncodeError:
                    if not isinstance(s, Exception):
                        raise
                    # If we get to here, the caller has passed in an Exception
                    # subclass populated with non-ASCII data without special
                    # handling to display as a string. We need to handle this
                    # without raising a further exception. We do an
                    # approximation to what the Exception's standard str()
                    # output should be.
                    s = ' '.join([force_unicode(arg, encoding, strings_only,
                            errors) for arg in s])
        elif not isinstance(s, unicode):
            # Note: We use .decode() here, instead of unicode(s, encoding,
            # errors), so that if s is a SafeString, it ends up being a
            # SafeUnicode at the end.
            s = s.decode(encoding, errors)
    except UnicodeDecodeError, e:
        if not isinstance(s, Exception):
            raise UnicodeDecodeError(s, *e.args)
        else:
            # If we get to here, the caller has passed in an Exception
            # subclass populated with non-ASCII bytestring data without a
            # working unicode method. Try to handle this without raising a
            # further exception by individually forcing the exception args
            # to unicode.
            s = ' '.join([force_unicode(arg, encoding, strings_only,
                    errors) for arg in s])
    return s
########NEW FILE########
__FILENAME__ = shortcuts
"""
sentry.utils.shortcuts
~~~~~~~~~~~~~~~~~~~~~~

:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
:license: BSD, see LICENSE for more details.
"""

from flask import abort

def get_object_or_404(Model, **kwargs):
    try:
        return Model.objects.get(**kwargs)
    except Model.DoesNotExist:
        abort(404)
########NEW FILE########
__FILENAME__ = feeds
"""
sentry.web.feeds
~~~~~~~~~~~~~~~~

:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
:license: BSD, see LICENSE for more details.
"""

from django.core.urlresolvers import reverse
from django.http import HttpResponse
from django.utils import feedgenerator
from django.utils.translation import ugettext_lazy as _

from sentry.models import Event, Group

class MessageFeed(object):
    def __call__(self, request):
        feed_dict = {
            'title': self.get_title(request),
            'link': request.build_absolute_uri(self.get_link(request)),
            'description': '',
            'language': u'en',
            'feed_url': request.build_absolute_uri(),
        }
        feed = feedgenerator.Rss201rev2Feed(**feed_dict)

        qs = self.get_query_set(request)

        for obj in qs[0:10]:
            link = self.get_item_url(request, obj)
            if link:
                link = request.build_absolute_uri(link)
            feed.add_item(
                title=str(obj or ''),
                link=link,
                description=obj.description() or '',
                pubdate=self.get_item_date(request, obj) or '',
            )

        return HttpResponse(feed.writeString('utf-8'), mimetype='application/xml')

    def get_title(self, request):
        return _('log events')

    def get_link(self, request):
        return reverse('sentry')

    def get_model(self, request):
        return Message

    def get_query_set(self, request):
        qs = self.get_model(request).objects.all().order_by(self.get_order_field(request))
        if request.GET.get('level') > 0:
            qs = qs.filter(level__gte=request.GET['level'])
        elif request.GET.get('server_name'):
            qs = qs.filter(server_name=request.GET['server_name'])
        elif request.GET.get('logger'):
            qs = qs.filter(logger=request.GET['logger'])
        elif request.GET.get('site'):
            qs = qs.filter(site=request.GET['site'])
        return qs

    def get_order_field(self, request):
        return '-datetime'

    def get_item_url(self, request, obj):
        return reverse('sentry:group', args=[obj.group_id])

    def get_item_date(self, request, obj):
        return obj.datetime

class SummaryFeed(MessageFeed):
    def get_title(self, request):
        return _('log summaries')

    def get_link(self, request):
        return reverse('sentry')

    def get_model(self, request):
        return GroupedMessage

    def get_query_set(self, request):
        qs = super(SummaryFeed, self).get_query_set(request)
        return qs.filter(status=0)

    def get_order_field(self, request):
        return '-last_seen'

    def get_item_url(self, request, obj):
        return reverse('sentry:group', args=[obj.pk])

    def get_item_date(self, request, obj):
        return obj.last_seen
########NEW FILE########
__FILENAME__ = filters
"""
sentry.web.filters
~~~~~~~~~~~~~~~~~~

:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
:license: BSD, see LICENSE for more details.
"""

# Widget api is pretty ugly
from __future__ import absolute_import

import logging

from flask import request
from jinja2 import Markup, escape
from sentry import app
from sentry.models import Tag

_CACHE = None
def all(from_cache=True):
    global _CACHE

    if _CACHE is None or not from_cache:
        modules = []
        for key, path in app.config['FILTERS']:
            module_name, class_name = path.rsplit('.', 1)
            try:
                module = __import__(module_name, {}, {}, class_name)
                handler = getattr(module, class_name)
            except Exception:
                logger = logging.getLogger(__name__)
                logger.exception('Unable to import %s' % (path,))
                continue
            modules.append(handler(key))

        _CACHE = modules

    for f in _CACHE:
        yield f

class Widget(object):
    def __init__(self, filter):
        self.filter = filter

    def get_query_string(self):
        return self.filter.get_query_string()

class TextWidget(Widget):
    def render(self, value, placeholder='', **kwargs):
        return Markup('<div class="filter-text"><p class="textfield"><input type="text" name="%(name)s" value="%(value)s" placeholder="%(placeholder)s"/></p><p class="submit"><input type="submit" class="search-submit"/></p></div>' % dict(
            name=self.filter.get_query_param(),
            value=escape(value),
            placeholder=escape(placeholder or 'enter %s' % self.filter.label.lower()),
        ))

class ChoiceWidget(Widget):
    def render(self, value, **kwargs):
        choices = self.filter.get_choices()
        query_string = self.get_query_string()
        tag = self.filter.get_query_param()

        output = ['<ul class="filter-list" rel="%s">' % (tag,)]
        output.append('<li%(active)s><a href="%(query_string)s&amp;%(tag)s=">Any %(label)s</a></li>' % dict(
            active=not value and ' class="active"' or '',
            query_string=query_string,
            label=self.filter.label,
            tag=tag,
        ))
        for key, val in choices:
            key = unicode(key)
            output.append('<li%(active)s rel="%(key)s"><a href="%(query_string)s&amp;%(tag)s=%(key)s">%(value)s</a></li>' % dict(
                active=value == key and ' class="active"' or '',
                tag=tag,
                key=key,
                value=val,
                query_string=query_string,
            ))
        output.append('</ul>')
        return Markup('\n'.join(output))

class Filter(object):
    label = ''
    widget = None
    # This must be a string
    default = ''
    show_label = True
    
    def __init__(self, tag):
        self.tag = tag
        self.label = tag.title()
    
    def is_set(self):
        return bool(self.get_value())
    
    def get_value(self):
        return request.args.get(self.get_query_param(), self.default) or ''
    
    def get_query_param(self):
        return getattr(self, 'query_param', self.tag)

    def get_widget(self):
        return self.widget(self)
    
    def get_query_string(self):
        tag = self.tag
        query_dict = request.args.copy()
        if 'p' in query_dict:
            del query_dict['p']
        if tag in query_dict:
            del query_dict[self.tag]
        return ''
        # TODO: urlencode doesnt exist on Flask request dicts
        return '?' + query_dict.urlencode()
    
    def get_choices(self):
        return [(t.value, t.value) for t in Tag.objects.filter(key=self.tag)]
    
    def get_query_set(self, queryset):
        from sentry.models import MessageIndex
        kwargs = {self.tag: self.get_value()}
        if self.tag.startswith('data__'):
            return MessageIndex.objects.get_for_queryset(queryset, **kwargs)
        return queryset.filter(**kwargs)
    
    def process(self, data):
        return data
    
    def render(self):
        widget = self.get_widget()
        return widget.render(self.get_value())

class Choice(Filter):
    widget = ChoiceWidget

########NEW FILE########
__FILENAME__ = data_faker
#!/usr/bin/env python
"""
sentry.scripts.data_faker
~~~~~~~~~~~~~~~~~~~~~~~~~

:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
:license: BSD, see LICENSE for more details.
"""

from sentry import VERSION, app, capture
from sentry.interfaces import Http

import os.path
import random
import sys
from optparse import OptionParser

def main():
    parser = OptionParser(version="%%prog %s" % VERSION)
    parser.add_option('--config', metavar='CONFIG')
    parser.add_option('--num', default=100)
    (options, args) = parser.parse_args()

    if options.config:
        app.config.from_pyfile(options.config)
    else:
        config_path = os.path.expanduser(os.path.join('~', '.sentry', 'sentry.conf.py'))
        if os.path.exists(config_path):
            app.config.from_pyfile(config_path)

    exceptions = [ValueError, SyntaxError, KeyError, IndexError, OSError]
    messages = [
        'Old Man, sorry.  What knight live in that castle over there?',
        'You fight with the strength of many men, Sir knight.',
        'A witch!  A witch!  A witch!  We\'ve got a witch!  A witch!',
        'Does wood sink in water?',
        'The wise Sir Bedemir was the first to join King Arthur\'s knights, but other illustrious names were soon to follow',
    ]
    urls = [
        'http://example.com',
        'http://example.com/foo/bar/',
        'http://example.com/foo/bar/?baz=biz',
    ]
    sql_queries = ['SELECT * FROM table', 'INSERT INTO FOO (a, b, c) VALUES (1, 2, 3)', 'TRUNCATE TABLE baz']
    sql_engines = ['psycopg2', 'mysqldb', 'oracle']
    http_methods = Http.METHODS
    
    for n in xrange(options.num):
        x = random.randint(0, 2)
        if x == 0:
            event = 'Exception'
            kwargs = {}
            exc_class = exceptions[n % len(exceptions)]
            exc_value = messages[n % len(messages)]
            try:
                raise exc_class(exc_value)
            except:
                kwargs = {'exc_info': sys.exc_info()}
        elif x == 1:
            event = 'Message'
            kwargs = {'message': messages[n % len(messages)]}
        elif x == 2:
            event = 'Query'
            kwargs = {'query': sql_queries[n % len(sql_queries)], 'engine': sql_engines[n % len(sql_engines)]}

        if random.randint(0, 1) == 1:
            kwargs['data'] = {
                'sentry.interfaces.Http': {
                    'url': urls[n % len(urls)],
                    'method': http_methods[n % len(http_methods)],
                }
            }

        capture(event, **kwargs)

    sys.exit(0)

if __name__ == '__main__':
    main()
########NEW FILE########
__FILENAME__ = runner
#!/usr/bin/env python
"""
sentry.web.scripts.runner
~~~~~~~~~~~~~~~~~~~~~~~~~

:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
:license: BSD, see LICENSE for more details.
"""

import eventlet
import os
import os.path
import sys

from daemon.daemon import DaemonContext
from daemon.runner import DaemonRunner, make_pidlockfile
from eventlet import wsgi
from optparse import OptionParser

from sentry import VERSION, app
from sentry.middleware import WSGIErrorMiddleware

class SentryWeb(DaemonRunner):
    pidfile_timeout = 10
    start_message = u"started with pid %(pid)d"

    def __init__(self, host=None, port=None, pidfile=None,
                 logfile=None, daemonize=False, debug=False):
        if not logfile:
            logfile = app.config['WEB_LOG_FILE']

        logfile = os.path.realpath(logfile)
        pidfile = os.path.realpath(pidfile or app.config['WEB_PID_FILE'])
        
        if daemonize:
            detach_process = True
        else:
            detach_process = False

        self.daemon_context = DaemonContext(detach_process=detach_process)
        self.daemon_context.stdout = open(logfile, 'w+')
        self.daemon_context.stderr = open(logfile, 'w+', buffering=0)

        self.pidfile = make_pidlockfile(pidfile, self.pidfile_timeout)

        self.daemon_context.pidfile = self.pidfile

        self.host = host or app.config['WEB_HOST']
        self.port = port or app.config['WEB_PORT']

        self.debug = debug

        # HACK: set app to self so self.app.run() works
        self.app = self

    def execute(self, action):
        self.action = action
        if self.daemon_context.detach_process is False and self.action == 'start':
            # HACK:
            self.run()
        else:
            self.do_action()

    def run(self):
        # Import views/templatetags to ensure registration
        import sentry.web.templatetags
        import sentry.web.views

        upgrade()
        app.wsgi_app = WSGIErrorMiddleware(app.wsgi_app)

        if self.debug:
            app.run(host=self.host, port=self.port, debug=self.debug)
        else:
            wsgi.server(eventlet.listen((self.host, self.port)), app)

def cleanup(days=30, tags=None):
    from sentry.models import Group, Event
    import datetime
    
    ts = datetime.datetime.now() - datetime.timedelta(days=days)
    
    for event in Event.objects.order_by('date'):
        if event.date > ts:
            break
        event.delete()
    
    for group in Group.objects.order_by('last_seen'):
        if group.last_seen > ts:
            break
        event.delete()


def upgrade():
    pass
    # from sentry.conf import settings
    # 
    # call_command('syncdb', database=settings.DATABASE_USING or 'default', interactive=False)
    # 
    # if 'south' in django_settings.INSTALLED_APPS:
    #     call_command('migrate', database=settings.DATABASE_USING or 'default', interactive=False)

def main():
    command_list = ('start', 'stop', 'restart', 'cleanup', 'upgrade')
    args = sys.argv
    if len(args) < 2 or args[1] not in command_list:
        print "usage: sentry [command] [options]"
        print
        print "Available subcommands:"
        for cmd in command_list:
            print "  ", cmd
        sys.exit(1)

    parser = OptionParser(version="%%prog %s" % VERSION)
    parser.add_option('--config', metavar='CONFIG')
    if args[1] == 'start':
        parser.add_option('--debug', action='store_true', default=False, dest='debug')
        parser.add_option('--host', metavar='HOSTNAME')
        parser.add_option('--port', type=int, metavar='PORT')
        parser.add_option('--daemon', action='store_true', default=False, dest='daemonize')
        parser.add_option('--no-daemon', action='store_false', default=False, dest='daemonize')
        parser.add_option('--pidfile', dest='pidfile')
        parser.add_option('--logfile', dest='logfile')
    elif args[1] == 'stop':
        parser.add_option('--pidfile', dest='pidfile')
        parser.add_option('--logfile', dest='logfile')
    elif args[1] == 'cleanup':
        parser.add_option('--days', default='30', type=int,
                          help='Numbers of days to truncate on.')
        parser.add_option('--tags',
                          help='Limit truncation to only entries tagged with key:value.')

    (options, args) = parser.parse_args()

    if options.config:
        app.config.from_pyfile(options.config)
    else:
        config_path = os.path.expanduser(os.path.join('~', '.sentry', 'sentry.conf.py'))
        if os.path.exists(config_path):
            app.config.from_pyfile(config_path)

    if args[0] == 'upgrade':
        upgrade()

    elif args[0] == 'start':
        web = SentryWeb(host=options.host, port=options.port,
                           pidfile=options.pidfile, logfile=options.logfile,
                           daemonize=options.daemonize, debug=options.debug)
        web.execute(args[0])

    elif args[0] == 'restart':
        web = SentryWeb()
        web.execute(args[0])
  
    elif args[0] == 'stop':
        web = SentryWeb(pidfile=options.pidfile, logfile=options.logfile)
        web.execute(args[0])

    elif args[0] == 'cleanup':
        cleanup(days=options.days, tags=options.tags)

    sys.exit(0)

if __name__ == '__main__':
    main()
########NEW FILE########
__FILENAME__ = templatetags
"""
sentry.web.templatetags
~~~~~~~~~~~~~~~~~~~~~~~

:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
:license: BSD, see LICENSE for more details.
"""

from sentry import app
#from sentry.plugins import GroupActionProvider

from flaskext.babel import ngettext, gettext
from jinja2 import Markup, escape

import datetime
import simplejson

@app.template_filter()
def maybe_link(value):
    if value.startswith('http') and '://' in value:
        value = escape(value)
        return Markup(u'<a href="%s">%s</a>' % (value, value))
    return value

@app.template_filter()
def as_sorted(value):
    return sorted(value)

@app.template_filter()
def is_dict(value):
    return isinstance(value, dict)

@app.template_filter()
def with_priority(result_list, key='score'):
    if result_list:
        if isinstance(result_list[0], dict):
            _get = lambda x, k: x[k]
        else:
            _get = lambda x, k: getattr(x, k, 0)

        min_, max_ = min([_get(r, key) for r in result_list]), max([_get(r, key) for r in result_list])
        mid = (max_ - min_) / 4
        for result in result_list:
            val = _get(result, key)
            if val > max_ - mid:
                priority = 'veryhigh'
            elif val > max_ - mid * 2:
                priority = 'high'
            elif val > max_ - mid * 3:
                priority = 'medium'
            elif val > max_ - mid * 4:
                priority = 'low'
            else:
                priority = 'verylow'
            yield result, priority

@app.template_filter()
def num_digits(value):
    return len(str(value))

@app.template_filter()
def chart_data(group, max_days=90):
    return {}
    hours = max_days*24

    today = datetime.datetime.now().replace(microsecond=0, second=0, minute=0)
    min_date = today - datetime.timedelta(hours=hours)

    if get_db_engine(getattr(conn, 'alias', 'default')).startswith('oracle'):
        method = conn.ops.date_trunc_sql('hh24', 'datetime')
    else:
        method = conn.ops.date_trunc_sql('hour', 'datetime')

    chart_qs = list(group.message_set.all()\
                      .filter(datetime__gte=min_date)\
                      .extra(select={'grouper': method}).values('grouper')\
                      .annotate(num=Count('id')).values_list('grouper', 'num')\
                      .order_by('grouper'))

    if not chart_qs:
        return {}

    rows = dict(chart_qs)

    #just skip zeroes
    first_seen = hours
    while not rows.get(today - datetime.timedelta(hours=first_seen)) and first_seen > 24:
        first_seen -= 1

    return {
        'points': [rows.get(today-datetime.timedelta(hours=d), 0) for d in xrange(first_seen, -1, -1)],
        'categories': [str(today-datetime.timedelta(hours=d)) for d in xrange(first_seen, -1, -1)],
    }

@app.template_filter()
def to_json(data):
    return simplejson.dumps(data)

@app.context_processor
def sentry_version():
    import sentry
    return {'sentry_version': sentry.VERSION}

@app.template_filter()
def get_actions(group):
    # TODO:
    return []

@app.template_filter()
def get_panels(group):
    # TODO:
    return []

@app.template_filter()
def get_widgets(group):
    # TODO:
    return []

# @app.template_filter()
# def get_actions(group):
#     action_list = []
#     for cls in GroupActionProvider.plugins.itervalues():
#         inst = cls(group.pk)
#         action_list = inst.actions(request, action_list, group)
#     for action in action_list:
#         yield action[0], action[1], request.path == action[1]
# 
# @app.template_filter()
# def get_panels(group):
#     panel_list = []
#     for cls in GroupActionProvider.plugins.itervalues():
#         inst = cls(group.pk)
#         panel_list = inst.panels(request, panel_list, group)
#     for panel in panel_list:
#         yield panel[0], panel[1], request.path == panel[1]
# 
# @app.template_filter()
# def get_widgets(group):
#     for cls in GroupActionProvider.plugins.itervalues():
#         inst = cls(group.pk)
#         resp = inst.widget(request, group)
#         if resp:
#             yield resp

@app.template_filter()
def timesince(d, now=None):
    """
    Takes two datetime objects and returns the time between d and now
    as a nicely formatted string, e.g. "10 minutes".  If d occurs after now,
    then "0 minutes" is returned.

    Units used are years, months, weeks, days, hours, and minutes.
    Seconds and microseconds are ignored.  Up to two adjacent units will be
    displayed.  For example, "2 weeks, 3 days" and "1 year, 3 months" are
    possible outputs, but "2 weeks, 3 hours" and "1 year, 5 days" are not.

    Adapted from http://blog.natbat.co.uk/archive/2003/Jun/14/time_since
    """
    if not d:
        return 'Never'
    
    if d < datetime.datetime.now() - datetime.timedelta(days=5):
        return d.date()
    
    chunks = (
      (60 * 60 * 24 * 365, lambda n: ngettext('year', 'years', n)),
      (60 * 60 * 24 * 30, lambda n: ngettext('month', 'months', n)),
      (60 * 60 * 24 * 7, lambda n : ngettext('week', 'weeks', n)),
      (60 * 60 * 24, lambda n : ngettext('day', 'days', n)),
      (60 * 60, lambda n: ngettext('hour', 'hours', n)),
      (60, lambda n: ngettext('minute', 'minutes', n))
    )
    # Convert datetime.date to datetime.datetime for comparison.
    if not isinstance(d, datetime.datetime):
        d = datetime.datetime(d.year, d.month, d.day)
    if now and not isinstance(now, datetime.datetime):
        now = datetime.datetime(now.year, now.month, now.day)

    if not now:
        if d.tzinfo:
            now = datetime.datetime.now(d.tzinfo)
        else:
            now = datetime.datetime.now()

    # ignore microsecond part of 'd' since we removed it from 'now'
    delta = now - (d - datetime.timedelta(0, 0, d.microsecond))
    since = delta.days * 24 * 60 * 60 + delta.seconds
    if since <= 0:
        # d is in the future compared to now, stop processing.
        return d.date()
    for i, (seconds, name) in enumerate(chunks):
        count = since // seconds
        if count != 0:
            break
    s = gettext('%(number)d %(type)s', number=count, type=name(count))

    if s == '0 minutes':
        return 'Just now'
    if s == '1 day':
        return 'Yesterday'
    return s + ' ago'

@app.template_filter(name='truncatechars')
def truncatechars(value, arg):
    """
    Truncates a string after a certain number of chars.

    Argument: Number of chars to truncate after.
    """
    try:
        length = int(arg)
    except ValueError: # Invalid literal for int().
        return value # Fail silently.
    if len(value) > length:
        return value[:length] + '...'
    return value

########NEW FILE########
__FILENAME__ = views
"""
sentry.web.views
~~~~~~~~~~~~~~~~

:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
:license: BSD, see LICENSE for more details.
"""

# TODO: this needs to be entirely flask

import datetime
import re
import simplejson

from jinja2 import Markup
from flask import render_template, redirect, request, url_for, \
                  abort, Response

from sentry import app
from sentry.core.plugins import GroupActionProvider
from sentry.models import Group, Event, EventType
from sentry.web import filters
from sentry.web.templatetags import with_priority
from sentry.utils.shortcuts import get_object_or_404

uuid_re = re.compile(r'^[a-z0-9]{32}$')

def login_required(func):
    def wrapped(*args, **kwargs):
        # TODO: auth
        # if not app.config['PUBLIC']:
        #     if not request.user.is_authenticated():
        #         return redirect(url_for('login'))
        #     if not request.user.has_perm('sentry.can_view'):
        #         return redirect(url_for('login'))
        return func(request, *args, **kwargs)
    wrapped.__doc__ = func.__doc__
    wrapped.__name__ = func.__name__
    wrapped.__wraps__ = getattr(func, '__wraps__', func)
    return wrapped

@app.errorhandler(404)
def page_not_found(e):
    return render_template('sentry/404.html'), 404

@app.errorhandler(500)
def internal_server_error(e):
    return render_template('sentry/500.html'), 500

@app.context_processor
def context():
    return {
        'event_type_list': EventType.objects.all(),
    }

@app.route('/auth/login/')
def login():
    # TODO:
    pass

@app.route('/auth/logout/')
def logout():
    # TODO:
    pass

@login_required
@app.route('/search/')
def search():
    try:
        page = int(request.args.get('p', 1))
    except (TypeError, ValueError):
        page = 1

    query = request.args.get('q')
    has_search = bool(app.config['SEARCH_ENGINE'])

    if query:
        if uuid_re.match(query):
            # Forward to message if it exists
            try:
                event = Event.objects.get(query)
            except Event.DoesNotExist:
                pass
            else:
                return redirect(event.get_absolute_url())
        elif not has_search:
            return render_template('sentry/invalid_message_id.html')
        else:
            # TODO:
            # event_list = get_search_query_set(query)
            raise NotImplementedError
    else:
        event_list = Group.objects.none()
    
    sort = request.args.get('sort')
    if sort == 'date':
        event_list = event_list.order_by('-last_seen')
    elif sort == 'new':
        event_list = event_list.order_by('-first_seen')
    else:
        sort = 'relevance'

    return render_template('sentry/search.html', **{
        'event_list': event_list,
        'query': query,
        'sort': sort,
        'request': request,
        'page': page,
    })

@login_required
@app.route('/')
def index():
    filter_list = list(filters.all())

    try:
        page = int(request.args.get('p', 1))
    except (TypeError, ValueError):
        page = 1

    event_list = Group.objects.all()

    sort = request.args.get('sort')
    if sort == 'date':
        event_list = event_list.order_by('-last_seen')
    elif sort == 'new':
        event_list = event_list.order_by('-first_seen')
    elif sort == 'count':
        event_list = event_list.order_by('-count')
    else:
        sort = 'priority'
        event_list = event_list.order_by('-score')

    any_filter = False
    # for filter_ in filters:
    #     if not filter_.is_set():
    #         continue
    #     any_filter = True
        # event_list = filter_.get_query_set(event_list)

    today = datetime.datetime.now()

    has_realtime = page == 1
    
    return render_template('sentry/index.html', **{
        'has_realtime': has_realtime,
        'event_list': event_list,
        'today': today,
        'sort': sort,
        'any_filter': any_filter,
        'request': request,
        'filter_list': filter_list,
    })

@login_required
@app.route('/api/')
def ajax_handler():
    op = request.form.get('op')

    if op == 'poll':
        filters = []
        for filter_ in filters.all():
            filters.append(filter_(request))

        event_list = Group.objects

        sort = request.args.get('sort')
        if sort == 'date':
            event_list = event_list.order_by('-last_seen')
        elif sort == 'new':
            event_list = event_list.order_by('-first_seen')
        elif sort == 'count':
            event_list = event_list.order_by('-count')
        else:
            sort = 'priority'
            event_list = event_list.order_by('-score')

        # for filter_ in filters:
        #     if not filter_.is_set():
        #         continue
        #     event_list = filter_.get_query_set(event_list)

        data = [
            (m.pk, {
                'html': render_template('sentry/partial/group.html', **{
                    'group': m,
                    'priority': p,
                    'request': request,
                }),
                'count': m.times_seen,
                'priority': p,
            }) for m, p in with_priority(event_list[0:15])]

    elif op == 'resolve':
        gid = request.REQUEST.get('gid')
        if not gid:
            abort(403)
        try:
            group = Group.objects.get(pk=gid)
        except Group.DoesNotExist:
            abort(403)

        group.update(status=1)

        if not request.is_ajax():
            return redirect(request.environ['HTTP_REFERER'])

        data = [
            (m.pk, {
                'html': render_template('sentry/partial/group.html', **{
                    'group': m,
                    'request': request,
                }),
                'count': m.times_seen,
            }) for m in [group]]
    else:
        abort(400)

    return Response(simplejson.dumps(data), mimetype='application/json')

@login_required
@app.route('/group/<group_id>/')
def group_details(group_id):
    group = get_object_or_404(Group, pk=group_id)
    
    last_event = group.get_relations(Event, limit=1)[0]

    def iter_data(obj):
        for k, v in obj.data.get('extra', {}).iteritems():
            if k.startswith('_') or k in ['url']:
                continue
            yield k, v

    return render_template('sentry/group/details.html', **{
        'page': 'details',
        'interface_list': filter(None, [Markup(i.to_html(last_event) or '') for i in last_event.get_interfaces()]),
        'group': group,
        'json_data': iter_data(last_event),
    })

@login_required
@app.route('/group/<group_id>/events/')
def group_event_list(group_id):
    group = get_object_or_404(Group, pk=group_id)

    event_list = group.get_relations(Event)

    return render_template('sentry/group/event_list.html', **{
        'page': 'events',
        'group': group,
        'event_list': event_list,
    })

@login_required
@app.route('/group/<group_id>/events/<event_id>/')
def group_event_details(group_id, event_id):
    group = get_object_or_404(Group, pk=group_id)
    event = get_object_or_404(Event, pk=event_id)

    def iter_data(obj):
        for k, v in obj.data['extra'].iteritems():
            if k.startswith('_') or k in ['url']:
                continue
            yield k, v

    return render_template('sentry/group/event.html', **{
        'page': 'events',
        'json_data': iter_data(event),
        'group': group,
        'event': event,
        'interface_list': filter(None, [Markup(i.to_html(event) or '') for i in event.get_interfaces()]),
    })

@login_required
@app.route('/group/<group_id>/<path:slug>')
def group_plugin_action(group_id, slug):
    group = get_object_or_404(Group, pk=group_id)
    
    try:
        cls = GroupActionProvider.plugins[slug]
    except KeyError:
        abort(404, 'Plugin not found')
    response = cls(group_id)(request, group)
    if response:
        return response
    return redirect(request.environ.get('HTTP_REFERER') or url_for('index'))

########NEW FILE########
__FILENAME__ = test_redis
from .. import BaseTest


from sentry.db.backends.redis import RedisBackend

class MockModel(object):
    __name__ = 'test'

class RedisBackendTest(BaseTest):
    def setUp(self):
        self.backend = RedisBackend(db=9)
        self.schema = MockModel()
        self.redis = self.backend.conn
        
    def test_add(self):
        pk1 = self.backend.add(self.schema, **{'foo': 'bar'})
        self.assertTrue(pk1)

        key = self.backend._get_data_key(self.schema, pk1)
        self.assertEquals(len(self.redis.hgetall(key)), 1)
        self.assertEquals(self.redis.hget(key, 'foo'), 'bar')
        
        pk2 = self.backend.add(self.schema)
        self.assertTrue(pk2)
        self.assertNotEquals(pk1, pk2)

        key = self.backend._get_data_key(self.schema, pk2)
        self.assertFalse(self.redis.hgetall(key))

    def test_delete(self):
        pk = 'foo'
        key = self.backend._get_data_key(self.schema, pk)
        metakey = self.backend._get_metadata_key(self.schema, pk)

        self.redis.hset(key, pk, {'foo': 'bar'})
        self.redis.hset(metakey, pk, {'foo': 'bar'})
        
        self.backend.delete(self.schema, pk)
        
        self.assertFalse(self.redis.hgetall(key))
        self.assertFalse(self.redis.hgetall(metakey))

    def test_set(self):
        pk = 'foo'

        key = self.backend._get_data_key(self.schema, pk)
        self.backend.set(self.schema, pk, **{'foo': 'bar'})
        self.assertEquals(len(self.redis.hgetall(key)), 1)
        self.assertEquals(self.redis.hget(key, 'foo'), 'bar')
########NEW FILE########
__FILENAME__ = test_base
from .. import BaseTest

from sentry import app
from sentry.client import ClientProxy
from sentry.client.logging import LoggingSentryClient

class ClientTest(BaseTest):
    def test_client_proxy(self):
        proxy = ClientProxy(app)

        app.config['CLIENT'] = 'sentry.client.logging.LoggingSentryClient'

        self.assertTrue(isinstance(proxy._ClientProxy__get_client(), LoggingSentryClient))
        self.assertEquals(proxy._ClientProxy__get_client(), proxy._ClientProxy__get_client())
    
        app.config['CLIENT'] = 'sentry.client.base.SentryClient'
        
        self.assertFalse(isinstance(proxy._ClientProxy__get_client(), LoggingSentryClient))
        self.assertEquals(proxy._ClientProxy__get_client(), proxy._ClientProxy__get_client())

########NEW FILE########
__FILENAME__ = test_logging
from .. import BaseTest

import logging

from sentry.client import get_client
from sentry.models import Event

class LoggingTest(BaseTest):
    def test_simple(self):
        client = get_client('sentry.client.logging.LoggingSentryClient')
        
        _foo = {'': None}
        
        class handler(logging.Handler):
            def emit(self, record):
                _foo[''] = record

        logger = client.logger
        logger.addHandler(handler())
        
        event_id = client.capture('Message', message='hello world')
        
        self.assertRaises(Event.DoesNotExist, Event.objects.get, event_id)
        
        self.assertEquals(_foo[''].getMessage(), 'hello world')
        self.assertEquals(_foo[''].levelno, client.default_level)

########NEW FILE########
__FILENAME__ = test_django
from ... import BaseTest

from django.conf import settings
from os.path import join, dirname

if not settings.configured:
    settings.configure(
        DATABASE_ENGINE='sqlite3',
        DATABASES={
            'default': {
                'ENGINE': 'sqlite3',
                'TEST_NAME': ':memory:',
            },
        },
        # HACK: this fixes our threaded runserver remote tests
        # DATABASE_NAME='test_sentry',
        # TEST_DATABASE_NAME='test_sentry',
        INSTALLED_APPS=[
            'django.contrib.auth',
            'django.contrib.admin',
            'django.contrib.sessions',
            'django.contrib.sites',

            # Included to fix Disqus' test Django which solves IntegrityMessage case
            'django.contrib.contenttypes',

            'djcelery', # celery client

            # 'sentry',
            'sentry.contrib.django',
        ],
        TEMPLATE_DIRS = (join(dirname(__file__), 'bad_templates'),),
        ROOT_URLCONF='tests.test_contrib.django.urls',
        DEBUG=False,
        SITE_ID=1,
        BROKER_HOST="localhost",
        BROKER_PORT=5672,
        BROKER_USER="guest",
        BROKER_PASSWORD="guest",
        BROKER_VHOST="/",
        CELERY_ALWAYS_EAGER=True,
        SENTRY_THRASHING_LIMIT=0,
        TEMPLATE_DEBUG=True,
    )
    import djcelery
    djcelery.setup_loader()

from django.http import HttpRequest
from sentry.contrib.django.models import sentry_exception_handler
from sentry.models import Event

class DjangoTest(BaseTest):
    def test_exception_handler(self):
        request = HttpRequest()
        
        try:
            raise ValueError('foo bar')
        except:
            sentry_exception_handler(request)
        
        self.assertTrue(hasattr(request, 'sentry'))
        
        event_id = request.sentry['id']
        
        event = Event.objects.get(event_id)

        data = event.data

        self.assertTrue('sentry.interfaces.Exception' in data)
        event_data = data['sentry.interfaces.Exception']
        self.assertTrue('value' in event_data)
        self.assertEquals(event_data['value'], 'foo bar')
        self.assertTrue('type' in event_data)
        self.assertEquals(event_data['type'], 'ValueError')

        self.assertTrue('sentry.interfaces.Stacktrace' in data)
        event_data = data['sentry.interfaces.Stacktrace']
        self.assertTrue('frames' in event_data)
        self.assertEquals(len(event_data['frames']), 1)
        frame = event_data['frames'][0]
        self.assertTrue('function' in frame)
        self.assertEquals(frame['function'], 'test_exception_handler')
        self.assertTrue('lineno' in frame)
        self.assertTrue(frame['lineno'] > 0)
        self.assertTrue('module' in frame)
        self.assertEquals(frame['module'], 'tests.test_contrib.django.test_django')
        self.assertTrue('id' in frame)
        self.assertTrue('filename' in frame)

    def test_django_testclient(self):
        from django.test import Client
        from django.template import TemplateSyntaxError
        c = Client()

        self.assertRaises(TemplateSyntaxError, c.get('/no_such_view/'))

        event = Event.objects.all()[0]
        data = event.data

        self.assertTrue('sentry.interfaces.Exception' in data)

        event_data = data['sentry.interfaces.Exception']

        self.assertTrue('type' in event_data)
        self.assertEquals(event_data['type'], 'TemplateSyntaxError')


        self.assertTrue('sentry.interfaces.Stacktrace' in data)
        event_data = data['sentry.interfaces.Stacktrace']
        self.assertEquals(len(event_data['frames']), 14)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *
from django.views.generic.simple import redirect_to

urlpatterns = patterns('',
    (r'^example/$', redirect_to, {'url': 'http://www.example.com'}),
)
########NEW FILE########
__FILENAME__ = views

########NEW FILE########
__FILENAME__ = test_logbook
from .. import BaseTest

from logbook import Logger
from sentry.contrib.logbook import SentryHandler
from sentry.models import Event

class LogbookTest(BaseTest):
    def test_simple(self):
        logger = Logger('sentry.tests.test_contrib.test_logbook')
        handler = SentryHandler('INFO')
        with handler.applicationbound():
            logger.warn('foo')
        
        event = Event.objects.all()[0]

        self.assertEquals(event.type, 'sentry.events.Message')
        self.assertEquals(event.time_spent, 0)
        self.assertTrue('sentry.interfaces.Message' in event.data)
        event_data = event.data['sentry.interfaces.Message']
        self.assertTrue('message' in event_data)
        self.assertEquals(event_data['message'], 'foo')
        self.assertTrue('params' in event_data)
        self.assertEquals(event_data['params'], [])
        
        tags = dict(event.tags)
        self.assertTrue('level' in tags)
        self.assertEquals(tags['level'], 'warning')

    def test_exception(self):
        logger = Logger('sentry.tests.test_contrib.test_logbook')
        handler = SentryHandler('INFO')
        with handler.applicationbound():
            try:
                raise ValueError('foo')
            except:
                logger.exception('foo bar')
        
        event = Event.objects.all()[0]

        self.assertEquals(event.type, 'sentry.events.Exception')
        self.assertEquals(event.time_spent, 0)
        self.assertTrue('sentry.interfaces.Exception' in event.data)
        event_data = event.data['sentry.interfaces.Exception']
        self.assertTrue('type' in event_data)
        self.assertEquals(event_data['type'], 'ValueError')
        self.assertTrue('value' in event_data)
        self.assertEquals(event_data['value'], 'foo')
        
        tags = dict(event.tags)
        self.assertTrue('level' in tags)
        self.assertEquals(tags['level'], 'error')

########NEW FILE########
__FILENAME__ = test_logging
from .. import BaseTest

import logging

from sentry.contrib.logging import SentryHandler
from sentry.models import Event

class LoggingTest(BaseTest):
    def test_simple(self):
        handler = SentryHandler()
        
        logger = logging.getLogger('sentry.tests.test_contrib.test_logging')
        logger.setLevel(logging.INFO)
        logger.addHandler(handler)

        logger.info('foo')
        
        event = Event.objects.all()[0]

        self.assertEquals(event.type, 'sentry.events.Message')
        self.assertEquals(event.time_spent, 0)
        self.assertTrue('sentry.interfaces.Message' in event.data)
        event_data = event.data['sentry.interfaces.Message']
        self.assertTrue('message' in event_data)
        self.assertEquals(event_data['message'], 'foo')
        self.assertTrue('params' in event_data)
        self.assertEquals(event_data['params'], [])
        
        tags = dict(event.tags)
        self.assertTrue('level' in tags)
        self.assertEquals(tags['level'], 'info')

    def test_exception(self):
        handler = SentryHandler()
        
        logger = logging.getLogger('sentry.tests.test_contrib.test_logging')
        logger.setLevel(logging.INFO)
        logger.addHandler(handler)

        try:
            raise ValueError('foo')
        except:
            logger.exception('foo bar')
        
        event = Event.objects.all()[0]

        self.assertEquals(event.type, 'sentry.events.Exception')
        self.assertEquals(event.time_spent, 0)
        self.assertTrue('sentry.interfaces.Exception' in event.data)
        event_data = event.data['sentry.interfaces.Exception']
        self.assertTrue('type' in event_data)
        self.assertEquals(event_data['type'], 'ValueError')
        self.assertTrue('value' in event_data)
        self.assertEquals(event_data['value'], 'foo')
        
        tags = dict(event.tags)
        self.assertTrue('level' in tags)
        self.assertEquals(tags['level'], 'error')

########NEW FILE########
__FILENAME__ = test_events
from . import BaseTest

import datetime
import sys

from sentry import app, capture
from sentry.models import Event, Tag, Group

class SentryTest(BaseTest):
    # Some quick ugly high level tests to get shit working fast
    def test_create(self):
        # redis is so blazing fast that we have to artificially inflate dates
        # or tests wont pass :)
        now = datetime.datetime.now()

        event, group = app.client.store(
            'sentry.events.Message',
            tags=(
                ('server', 'foo.bar'),
                ('culprit', 'foo.bar.zoo.baz'),
            ),
            date=now,
            time_spent=53,
            data={
                'sentry.interfaces.Message': {
                    'message': 'hello world'
                }
            },
            event_id='foobar',
        )
        group_id = group.pk

        self.assertTrue(group.pk)
        self.assertEquals(group.type, 'sentry.events.Message')
        self.assertEquals(group.time_spent, 53)
        self.assertEquals(group.count, 1)
        self.assertEquals(len(group.tags), 2)

        tag = group.tags[0]

        self.assertEquals(tag[0], 'server')
        self.assertEquals(tag[1], 'foo.bar')

        tag = group.tags[1]

        self.assertEquals(tag[0], 'culprit')
        self.assertEquals(tag[1], 'foo.bar.zoo.baz')

        events = group.get_relations(Event)

        self.assertEquals(len(events), 1)

        event = events[0]

        self.assertEquals(event.time_spent, group.time_spent)
        self.assertEquals(event.type, group.type)
        self.assertEquals(event.date, group.last_seen)
        self.assertEquals(len(event.tags), 2)

        tag = event.tags[0]

        self.assertEquals(tag[0], 'server')
        self.assertEquals(tag[1], 'foo.bar')

        tag = event.tags[1]

        self.assertEquals(tag[0], 'culprit')
        self.assertEquals(tag[1], 'foo.bar.zoo.baz')

        event, group = app.client.store(
            'sentry.events.Message',
            tags=(
                ('server', 'foo.bar'),
            ),
            date=now + datetime.timedelta(seconds=1),
            time_spent=100,
            data={
                'sentry.interfaces.Message': {
                    'message': 'hello world',
                },
            },
            event_id='foobar2',
        )

        self.assertEquals(group.pk, group_id)
        self.assertEquals(group.count, 2)
        self.assertEquals(group.time_spent, 153)
        self.assertEquals(len(group.tags), 2)

        tag = group.tags[0]

        self.assertEquals(tag[0], 'server')
        self.assertEquals(tag[1], 'foo.bar')

        tag = group.tags[1]

        self.assertEquals(tag[0], 'culprit')
        self.assertEquals(tag[1], 'foo.bar.zoo.baz')

        events = group.get_relations(Event, desc=False)

        self.assertEquals(len(events), 2)

        event = events[1]

        self.assertEquals(event.time_spent, 100)
        self.assertEquals(event.type, group.type)
        self.assertEquals(group.last_seen, event.date)
        self.assertEquals(len(event.tags), 1)

        tag = event.tags[0]

        self.assertEquals(tag[0], 'server')
        self.assertEquals(tag[1], 'foo.bar')

        tags = Tag.objects.order_by('-count')

        self.assertEquals(len(tags), 2, tags)

        groups = Group.objects.all()

        self.assertEquals(len(groups), 1)

        event, group = app.client.store(
            'sentry.events.Message',
            tags=(
                ('server', 'foo.bar'),
            ),
            date=now + datetime.timedelta(seconds=1),
            time_spent=100,
            data={
                'sentry.interfaces.Message': {
                    'message': 'hello world 2',
                },
            },
            event_id='foobar2',
        )

        self.assertNotEquals(group.pk, group_id)
        self.assertEquals(group.count, 1)
        self.assertEquals(group.time_spent, 100)
        self.assertEquals(len(group.tags), 1)

        tag = group.tags[0]

        self.assertEquals(tag[0], 'server')
        self.assertEquals(tag[1], 'foo.bar')

        events = group.get_relations(Event, desc=False)

        self.assertEquals(len(events), 1)

        event = events[0]

        self.assertEquals(event.time_spent, 100)
        self.assertEquals(event.type, group.type)
        self.assertEquals(group.last_seen, event.date)
        self.assertEquals(len(event.tags), 1)

        tag = event.tags[0]

        self.assertEquals(tag[0], 'server')
        self.assertEquals(tag[1], 'foo.bar')

        tags = Tag.objects.order_by('-count')

        self.assertEquals(len(tags), 2, tags)

        tag = tags[0]

        self.assertEquals(tag.key, 'server')
        self.assertEquals(tag.value, 'foo.bar')
        self.assertEquals(tag.count, 2)

        tag = tags[1]

        self.assertEquals(tag.key, 'culprit')
        self.assertEquals(tag.value, 'foo.bar.zoo.baz')
        self.assertEquals(tag.count, 1)

        groups = Group.objects.all()

        self.assertEquals(len(groups), 2)

    def test_tags(self):
        event_id = capture('Message', message='foo', tags=[('level', 'info')])

        event = Event.objects.get(event_id)

        self.assertEquals(len(event.tags), 2, event.tags)

        tags = dict(event.tags)

        self.assertTrue('level' in tags)
        self.assertEquals(tags['level'], 'info')
        
        self.assertTrue('server' in tags)
        self.assertEquals(tags['server'], app.config['NAME'])

    def test_message_event(self):
        event_id = capture('Message', message='foo')

        event = Event.objects.get(event_id)

        self.assertEquals(event.type, 'sentry.events.Message')
        self.assertEquals(event.time_spent, 0)
        self.assertTrue('sentry.interfaces.Message' in event.data)
        event_data = event.data['sentry.interfaces.Message']
        self.assertTrue('message' in event_data)
        self.assertEquals(event_data['message'], 'foo')
        self.assertTrue('params' in event_data)
        self.assertEquals(event_data['params'], [])

    def test_query_event(self):
        event_id = capture('Query', query='SELECT * FROM table', engine='psycopg2', time_spent=36)

        event = Event.objects.get(event_id)

        self.assertEquals(event.type, 'sentry.events.Query')
        self.assertEquals(event.time_spent, 36)

    def test_exception_event_without_exc_info(self):
        try:
            raise ValueError('foo bar')
        except:
            pass

        # Exception pulls in sys.exc_info()
        # by default
        event_id = capture('Exception')

        event = Event.objects.get(event_id)

        self.assertEquals(event.type, 'sentry.events.Exception')
        self.assertEquals(event.time_spent, 0)

        data = event.data

        self.assertTrue('sentry.interfaces.Exception' in data)
        event_data = data['sentry.interfaces.Exception']
        self.assertTrue('value' in event_data)
        self.assertEquals(event_data['value'], 'foo bar')
        self.assertTrue('type' in event_data)
        self.assertEquals(event_data['type'], 'ValueError')
        
        self.assertTrue('sentry.interfaces.Stacktrace' in data)
        event_data = data['sentry.interfaces.Stacktrace']
        self.assertTrue('frames' in event_data)
        self.assertEquals(len(event_data['frames']), 1)
        frame = event_data['frames'][0]
        self.assertTrue('function' in frame)
        self.assertEquals(frame['function'], 'test_exception_event_without_exc_info')
        self.assertTrue('lineno' in frame)
        self.assertTrue(frame['lineno'] > 0)
        self.assertTrue('module' in frame)
        self.assertEquals(frame['module'], 'tests.test_events')
        self.assertTrue('id' in frame)
        self.assertTrue('filename' in frame)

    def test_exception_event_with_exc_info(self):
        try:
            raise ValueError('foo bar')
        except:
            exc_info = sys.exc_info()

        # We raise a second event to ensure we actually reference
        # the first event
        try:
            raise SyntaxError('baz')
        except:
            pass

        # Exception pulls in sys.exc_info()
        # by default
        event_id = capture('Exception', exc_info=exc_info)

        event = Event.objects.get(event_id)

        self.assertEquals(event.type, 'sentry.events.Exception')
        self.assertEquals(event.time_spent, 0)

        data = event.data

        self.assertTrue('sentry.interfaces.Exception' in data)
        event_data = data['sentry.interfaces.Exception']
        self.assertTrue('value' in event_data)
        self.assertEquals(event_data['value'], 'foo bar')
        self.assertTrue('type' in event_data)
        self.assertEquals(event_data['type'], 'ValueError')

        self.assertTrue('sentry.interfaces.Stacktrace' in data)
        event_data = data['sentry.interfaces.Stacktrace']
        self.assertTrue('frames' in event_data)
        self.assertEquals(len(event_data['frames']), 1)
        frame = event_data['frames'][0]
        self.assertTrue('function' in frame)
        self.assertEquals(frame['function'], 'test_exception_event_with_exc_info')
        self.assertTrue('lineno' in frame)
        self.assertTrue(frame['lineno'] > 0)
        self.assertTrue('module' in frame)
        self.assertEquals(frame['module'], 'tests.test_events')
        self.assertTrue('id' in frame)
        self.assertTrue('filename' in frame)

    def test_context_processors(self):
        try:
            username = 'random_user'
            password = 'secret42'
            raise ValueError('foo bar')
        except:
            exc_info = sys.exc_info()

        # We raise a second event to ensure we actually reference
        # the first event
        try:
            raise SyntaxError('baz')
        except:
            pass

        # Exception pulls in sys.exc_info()
        # by default
        event_id = capture('Exception')

        event = Event.objects.get(event_id)
        self.assertTrue('sentry.interfaces.Stacktrace' in event.data)
        event_data = event.data['sentry.interfaces.Stacktrace']
        frame = event_data['frames'][0]
        self.assertEquals(frame['vars']['password'], '****************')

########NEW FILE########
__FILENAME__ = test_http
from .. import BaseTest

from sentry import capture
from sentry.models import Event
from sentry.interfaces import Http, unserialize

class HttpIntegrationTest(BaseTest):
    def test_create(self):
        event_id = capture('Message', message='hello world', data={
            'sentry.interfaces.Http': {
                'url': 'http://example.com/foo/?bar=baz',
                'method': 'GET',
            }
        })

        event = Event.objects.get(event_id)

        self.assertTrue('sentry.interfaces.Http' in event.data)
        
        result = event.data['sentry.interfaces.Http']

        self.assertTrue('url' in result, result)
        self.assertEquals(result['url'], 'http://example.com/foo/')
        self.assertTrue('method' in result, result)
        self.assertEquals(result['method'], 'GET')
        self.assertTrue('data' in result, result)
        self.assertEquals(result['data'], {})
        self.assertTrue('querystring' in result, result)
        self.assertEquals(result['querystring'], 'bar=baz')
        
class HttpTest(BaseTest):
    def test_unserialize(self):
        http = unserialize(Http, {
            'url': 'http://example.com/foo/',
            'method': 'GET',
            'data': {},
            'querystring': 'bar=baz',
        })
        self.assertEquals(http.url, 'http://example.com/foo/')
        self.assertEquals(http.method, 'GET')
        self.assertEquals(http.data, {})
        self.assertEquals(http.querystring, 'bar=baz')

    def test_serialize(self):
        http = Http('http://example.com/foo/', 'GET', {}, 'bar=baz')
        result = http.serialize()
        self.assertTrue('url' in result, result)
        self.assertEquals(result['url'], 'http://example.com/foo/')
        self.assertTrue('method' in result, result)
        self.assertEquals(result['method'], 'GET')
        self.assertTrue('data' in result, result)
        self.assertEquals(result['data'], {})
        self.assertTrue('querystring' in result, result)
        self.assertEquals(result['querystring'], 'bar=baz')

    def test_serialize_and_unserialize(self):
        http = Http('http://example.com/foo/', 'GET', {}, 'bar=baz')
        result = unserialize(Http, http.serialize()).serialize()
        self.assertTrue('url' in result, result)
        self.assertEquals(result['url'], 'http://example.com/foo/')
        self.assertTrue('method' in result, result)
        self.assertEquals(result['method'], 'GET')
        self.assertTrue('data' in result, result)
        self.assertEquals(result['data'], {})
        self.assertTrue('querystring' in result, result)
        self.assertEquals(result['querystring'], 'bar=baz')

    def test_querystring_extraction(self):
        http = Http('http://example.com/foo/?bar=baz', 'GET')
        result = http.serialize()
        self.assertTrue('url' in result, result)
        self.assertEquals(result['url'], 'http://example.com/foo/')
        self.assertTrue('querystring' in result, result)
        self.assertEquals(result['querystring'], 'bar=baz')

    def test_querystring_prefix(self):
        http = Http('http://example.com/foo/', 'GET', {}, '?bar=baz')
        result = http.serialize()
        self.assertTrue('url' in result, result)
        self.assertEquals(result['url'], 'http://example.com/foo/')
        self.assertTrue('querystring' in result, result)
        self.assertEquals(result['querystring'], 'bar=baz')

    def test_lowercase_method(self):
        http = Http('http://example.com/foo/?bar=baz', 'get')
        result = http.serialize()
        self.assertTrue('method' in result, result)
        self.assertEquals(result['method'], 'GET')

    def test_invalid_method(self):
        self.assertRaises(AssertionError, Http, 'http://example.com/foo/?bar=baz', 'biz')

########NEW FILE########
__FILENAME__ = test_orm
from . import BaseTest

from sentry.db import models

class TestModel(models.Model):
    str_ = models.String()
    int_ = models.Integer()
    float_ = models.Float()
    list_ = models.List()
    
    class Meta:
        sortables = ('int_', 'float_')
        indexes = (('str_',),)


class ORMTest(BaseTest):
    def test_create(self):
        inst = TestModel.objects.create(
            str_='foo',
            int_=0,
            float_=0.1,
            list_=[1, 2, 3],
        )
        self.assertEquals(TestModel.objects.count(), 1)
        self.assertTrue(inst.pk)
        self.assertEquals(inst.str_, 'foo')
        self.assertEquals(inst.int_, 0)
        self.assertEquals(inst.float_, 0.1)
        self.assertEquals(len(inst.list_), 3)
        self.assertTrue(1 in inst.list_)
        self.assertTrue(2 in inst.list_)
        self.assertTrue(3 in inst.list_)

    def test_get_or_create(self):
        inst, created = TestModel.objects.get_or_create(str_='foo', defaults={
            'int_': 0,
            'float_': 0.1,
            'list_': [1, 2, 3],
        })
        self.assertTrue(created)
        self.assertEquals(TestModel.objects.count(), 1)
        self.assertTrue(inst.pk)
        self.assertEquals(inst.str_, 'foo')
        self.assertEquals(inst.int_, 0)
        self.assertEquals(inst.float_, 0.1)
        self.assertEquals(len(inst.list_), 3)
        self.assertTrue(1 in inst.list_)
        self.assertTrue(2 in inst.list_)
        self.assertTrue(3 in inst.list_)

        inst, created = TestModel.objects.get_or_create(str_='foo', defaults={
            'int_': 1,
            'float_': 1.1,
            'list_': [1],
        })
        self.assertFalse(created)
        self.assertEquals(TestModel.objects.count(), 1)
        self.assertTrue(inst.pk)
        self.assertEquals(inst.str_, 'foo')
        self.assertEquals(inst.int_, 0)
        self.assertEquals(inst.float_, 0.1)
        self.assertTrue(len(inst.list_), 3)
        self.assertTrue(1 in inst.list_)
        self.assertTrue(2 in inst.list_)
        self.assertTrue(3 in inst.list_)

    def test_get(self):
        self.assertEquals(TestModel.objects.count(), 0)

        self.assertRaises(TestModel.DoesNotExist, TestModel.objects.get, 'foo')

        inst = TestModel.objects.create(str_='foo')

        self.assertEquals(TestModel.objects.count(), 1)

        self.assertEquals(TestModel.objects.get(inst.pk), inst)

    def test_delete(self):
        self.assertEquals(TestModel.objects.count(), 0)

        inst = TestModel.objects.create(str_='foo')

        self.assertEquals(TestModel.objects.count(), 1)
        
        inst.delete()

        self.assertEquals(TestModel.objects.count(), 0)

        self.assertRaises(TestModel.DoesNotExist, TestModel.objects.get, 'foo')

    def test_saving_behavior(self):
        self.assertEquals(TestModel.objects.count(), 0)

        inst = TestModel()
        
        self.assertFalse(inst.pk)
        
        self.assertEquals(TestModel.objects.count(), 0)
        
        inst.save()
        
        self.assertTrue(inst.pk)
        self.assertEquals(TestModel.objects.count(), 1)
        self.assertEquals(TestModel.objects.get(inst.pk), inst)

        self.assertEquals(inst.str_, '')
        self.assertEquals(inst.int_, 0)
        self.assertEquals(inst.float_, 0.0)
        self.assertEquals(len(inst.list_), 0)
        
        inst.update(str_='foo')

        self.assertEquals(TestModel.objects.count(), 1)
        self.assertEquals(inst.str_, 'foo')
        self.assertEquals(inst.int_, 0)
        self.assertEquals(inst.float_, 0.0)
        self.assertEquals(len(inst.list_), 0)
        
        inst = TestModel.objects.get(pk=inst.pk)

        self.assertEquals(inst.str_, 'foo')
        self.assertEquals(inst.int_, 0)
        self.assertEquals(inst.float_, 0.0)
        self.assertEquals(len(inst.list_), 0)

        inst = TestModel(float_=1.0)
        
        self.assertFalse(inst.pk)
        
        inst.save()

        self.assertEquals(TestModel.objects.count(), 2)
        
        self.assertEquals(inst.str_, '')
        self.assertEquals(inst.int_, 0)
        self.assertEquals(inst.float_, 1.0)
        self.assertEquals(len(inst.list_), 0)
########NEW FILE########
__FILENAME__ = test_api
from .. import BaseTest, with_settings

import base64
import simplejson
from sentry import app
from sentry.client.base import SentryClient
from sentry.models import Event

class InternalRemoteSentryClient(SentryClient):
    def send_remote(self, url, data, headers=None):
        if headers is None:
            headers = {}
        client = app.test_client()
        return client.post(url, data=data, headers=headers)

class StoreIntegrationTest(BaseTest):
    @with_settings(PUBLIC_WRITES=True, REMOTES=['/api/store/'])
    def test_client(self):
        client = InternalRemoteSentryClient()
        event_id = client.capture('Message', message='foo')
        
        event = Event.objects.get(event_id)

        self.assertEquals(event.type, 'sentry.events.Message')
        self.assertEquals(event.time_spent, 0)
        self.assertTrue('sentry.interfaces.Message' in event.data)
        event_data = event.data['sentry.interfaces.Message']
        self.assertTrue('message' in event_data)
        self.assertEquals(event_data['message'], 'foo')
        self.assertTrue('params' in event_data)
        self.assertEquals(event_data['params'], [])

class StoreTest(BaseTest):
    @with_settings(PUBLIC_WRITES=True)
    def test_simple(self):
        response = self.client.post('/api/store/', data=base64.b64encode(simplejson.dumps({
            "event_type": "sentry.events.Exception",
            "tags": [ ["level", "error"], ["server", "sentry.local"] ],
            "date": "2010-06-18T22:31:45",
            "time_spent": 0.0,
            "event_id": "452dfa92380f438f98159bb75b9469e5",
            "data": {
                "culprit": "path.to.function",
                "version": ["module", "version string"],
                "modules": {
                    "module": "version string"
                },
                "extra": {
                    "key": "value",
                },
                "sentry.interfaces.Http": {
                    "url": "http://example.com/foo/bar",
                    "method": "POST",
                    "querystring": "baz=bar&foo=baz",
                    "data": {
                        "key": "value"
                    }
                },
                "sentry.interfaces.Exception": {
                    "type": "ValueError",
                    "value": "An example exception",
                    "frames": [
                        {
                            "filename": "/path/to/filename.py",
                            "module": "path.to.module",
                            "function": "function_name",
                            "vars": {
                                "key": "value"
                            }
                        }
                    ]
                }
            }
        }).encode('zlib')))
        
        self.assertEquals(response.status_code, 200)

        event_id = response.data
        
        event = Event.objects.get(event_id)

        self.assertTrue('sentry.interfaces.Http' in event.data)
        
        result = event.data['sentry.interfaces.Http']

        self.assertTrue('url' in result, result)
        self.assertEquals(result['url'], 'http://example.com/foo/bar')
        self.assertTrue('method' in result, result)
        self.assertEquals(result['method'], 'POST')
        self.assertTrue('data' in result, result)
        self.assertTrue('key' in result['data'])
        self.assertEquals(result['data']['key'], 'value')
        self.assertTrue('querystring' in result, result)
        self.assertEquals(result['querystring'], 'baz=bar&foo=baz')
########NEW FILE########
