__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Gargoyle documentation build configuration file, created by
# sphinx-quickstart on Fri May  6 11:47:36 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

sys.path.insert(0, os.path.dirname(__file__))
os.environ['DJANGO_SETTINGS_MODULE'] = 'django_settings'

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Gargoyle'
copyright = u'2011, DISQUS'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = __import__('pkg_resources').get_distribution('gargoyle').version
# The full version, including alpha/beta/rc tags.
release = version

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Gargoyledoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Gargoyle.tex', u'Gargoyle Documentation',
   u'DISQUS', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'gargoyle', u'Gargoyle Documentation',
     [u'DISQUS'], 1)
]

########NEW FILE########
__FILENAME__ = django_settings
import os.path
import sys
# Django settings for example_project project.

DEBUG = True
TEMPLATE_DEBUG = True

ADMINS = (
    # ('Your Name', 'your_email@domain.com'),
)

INTERNAL_IPS = ('127.0.0.1',)

MANAGERS = ADMINS

PROJECT_ROOT = os.path.dirname(__file__)

sys.path.insert(0, os.path.abspath(os.path.join(PROJECT_ROOT, '..')))

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3', # Add 'postgresql_psycopg2', 'postgresql', 'mysql', 'sqlite3' or 'oracle'.
        'NAME': 'gargoyle',                      # Or path to database file if using sqlite3.
        'USER': 'postgres',                      # Not used with sqlite3.
        'PASSWORD': '',                  # Not used with sqlite3.
        'HOST': '',                      # Set to empty string for localhost. Not used with sqlite3.
        'PORT': '',                      # Set to empty string for default. Not used with sqlite3.
    }
}

# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# On Unix systems, a value of None will cause Django to use the same
# timezone as the operating system.
# If running in a Windows environment this must be set to the same as your
# system time zone.
TIME_ZONE = 'America/Los_Angeles'

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'en-us'

SITE_ID = 1

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

# If you set this to False, Django will not format dates, numbers and
# calendars according to the current locale
USE_L10N = True

# Absolute path to the directory that holds media.
# Example: "/home/media/media.lawrence.com/"
MEDIA_ROOT = ''

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash if there is a path component (optional in other cases).
# Examples: "http://media.lawrence.com", "http://example.com/media/"
MEDIA_URL = ''

# URL prefix for admin media -- CSS, JavaScript and images. Make sure to use a
# trailing slash.
# Examples: "http://foo.com/media/", "/media/".
ADMIN_MEDIA_PREFIX = '/admin/media/'

# Make this unique, and don't share it with anybody.
SECRET_KEY = ')*)&8a36)6%74e@-ne5(-!8a(vv#tkv)(eyg&@0=zd^pl!7=y@'

ROOT_URLCONF = 'example_project.urls'

TEMPLATE_DIRS = (
    # Put strings here, like "/home/html/django_templates" or "C:/www/django/templates".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
    os.path.join(PROJECT_ROOT, 'templates'),
)

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'nexus',
    'gargoyle',
    'south',
)

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
from django.core.management import execute_manager

try:
    import settings # Assumed to be in the same directory.
except ImportError:
    import sys
    sys.stderr.write("Error: Can't find the file 'settings.py' in the directory containing %r. It appears you've customized things.\nYou'll have to run django-admin.py, passing it your settings module.\n(If the file settings.py does indeed exist, it's causing an ImportError somehow.)\n" % __file__)
    sys.exit(1)

if __name__ == "__main__":
    execute_manager(settings)

########NEW FILE########
__FILENAME__ = settings
import os.path
import sys
# Django settings for example_project project.

DEBUG = True
TEMPLATE_DEBUG = True

ADMINS = (
    # ('Your Name', 'your_email@domain.com'),
)

INTERNAL_IPS = ('127.0.0.1',)

MANAGERS = ADMINS

PROJECT_ROOT = os.path.dirname(__file__)

sys.path.insert(0, os.path.abspath(os.path.join(PROJECT_ROOT, '..')))

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3', # Add 'postgresql_psycopg2', 'postgresql', 'mysql', 'sqlite3' or 'oracle'.
        'NAME': 'gargoyle.db',                      # Or path to database file if using sqlite3.
        'USER': '',                      # Not used with sqlite3.
        'PASSWORD': '',                  # Not used with sqlite3.
        'HOST': '',                      # Set to empty string for localhost. Not used with sqlite3.
        'PORT': '',                      # Set to empty string for default. Not used with sqlite3.
    }
}

# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# On Unix systems, a value of None will cause Django to use the same
# timezone as the operating system.
# If running in a Windows environment this must be set to the same as your
# system time zone.
TIME_ZONE = 'America/Los_Angeles'

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'en-us'

SITE_ID = 1

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

# If you set this to False, Django will not format dates, numbers and
# calendars according to the current locale
USE_L10N = True

# Absolute path to the directory that holds media.
# Example: "/home/media/media.lawrence.com/"
MEDIA_ROOT = ''

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash if there is a path component (optional in other cases).
# Examples: "http://media.lawrence.com", "http://example.com/media/"
MEDIA_URL = ''

# URL prefix for admin media -- CSS, JavaScript and images. Make sure to use a
# trailing slash.
# Examples: "http://foo.com/media/", "/media/".
ADMIN_MEDIA_PREFIX = '/admin/media/'

# Make this unique, and don't share it with anybody.
SECRET_KEY = ')*)&8a36)6%74e@-ne5(-!8a(vv#tkv)(eyg&@0=zd^pl!7=y@'

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
#     'django.template.loaders.eggs.Loader',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
)

ROOT_URLCONF = 'example_project.urls'

TEMPLATE_DIRS = (
    # Put strings here, like "/home/html/django_templates" or "C:/www/django/templates".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
    os.path.join(PROJECT_ROOT, 'templates'),
)

NEXUS_MEDIA_PREFIX = '/media/'

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'nexus',
    'gargoyle',
    'south',
    # Uncomment the next line to enable the admin:
    # 'django.contrib.admin',
)

try:
    from local_settings import *
except ImportError, e:
    print e
########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *

import nexus

nexus.autodiscover()

urlpatterns = patterns('',
    url(r'', include(nexus.site.urls)),
)

########NEW FILE########
__FILENAME__ = admin
"""
gargoyle.admin
~~~~~~~~~~~~~~

:copyright: (c) 2010 DISQUS.
:license: Apache License 2.0, see LICENSE for more details.
"""

from django.contrib import admin
from gargoyle.models import Switch


class SwitchAdmin(admin.ModelAdmin):
    list_display = ('label', 'key', 'status')
    list_filter = ('status',)
    search_fields = ('label', 'key', 'value')

admin.site.register(Switch, SwitchAdmin)

########NEW FILE########
__FILENAME__ = builtins
"""
gargoyle.builtins
~~~~~~~~~~~~~~~~~

:copyright: (c) 2010 DISQUS.
:license: Apache License 2.0, see LICENSE for more details.
"""

from gargoyle import gargoyle
from gargoyle.conditions import ModelConditionSet, RequestConditionSet, Percent, String, Boolean, \
    ConditionSet, OnOrAfterDate

from django.conf import settings
from django.contrib.auth.models import AnonymousUser
from django.core.validators import validate_ipv4_address

import socket
import struct


try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()


class UserConditionSet(ModelConditionSet):
    username = String()
    email = String()
    is_anonymous = Boolean(label='Anonymous')
    is_active = Boolean(label='Active')
    is_staff = Boolean(label='Staff')
    is_superuser = Boolean(label='Superuser')
    date_joined = OnOrAfterDate(label='Joined on or after')

    def can_execute(self, instance):
        return isinstance(instance, (User, AnonymousUser))

    def is_active(self, instance, conditions):
        """
        value is the current value of the switch
        instance is the instance of our type
        """
        if isinstance(instance, User):
            return super(UserConditionSet, self).is_active(instance, conditions)

        # HACK: allow is_authenticated to work on AnonymousUser
        condition = conditions.get(self.get_namespace(), {}).get('is_anonymous')
        if condition is not None:
            return bool(condition)
        return None

gargoyle.register(UserConditionSet(User))


class IPAddress(String):
    def clean(self, value):
        validate_ipv4_address(value)
        return value


class IPAddressConditionSet(RequestConditionSet):
    percent = Percent()
    ip_address = IPAddress(label='IP Address')
    internal_ip = Boolean(label='Internal IPs')

    def get_namespace(self):
        return 'ip'

    def get_field_value(self, instance, field_name):
        # XXX: can we come up w/ a better API?
        # Ensure we map ``percent`` to the ``id`` column
        if field_name == 'percent':
            return self._ip_to_int(instance.META['REMOTE_ADDR'])
        elif field_name == 'ip_address':
            return instance.META['REMOTE_ADDR']
        elif field_name == 'internal_ip':
            return instance.META['REMOTE_ADDR'] in settings.INTERNAL_IPS
        return super(IPAddressConditionSet, self).get_field_value(instance, field_name)

    def _ip_to_int(self, ip):
        if '.' in ip:
            # IPv4
            return sum([int(x) for x in ip.split('.')])
        if ':' in ip:
            # IPv6
            hi, lo = struct.unpack('!QQ', socket.inet_pton(socket.AF_INET6, ip))
            return (hi << 64) | lo
        raise ValueError('Invalid IP Address %r' % ip)

    def get_group_label(self):
        return 'IP Address'

gargoyle.register(IPAddressConditionSet())


class HostConditionSet(ConditionSet):
    hostname = String()

    def get_namespace(self):
        return 'host'

    def can_execute(self, instance):
        return instance is None

    def get_field_value(self, instance, field_name):
        if field_name == 'hostname':
            return socket.gethostname()

    def get_group_label(self):
        return 'Host'

gargoyle.register(HostConditionSet())

########NEW FILE########
__FILENAME__ = conditions
"""
gargoyle.conditions
~~~~~~~~~~~~~~~~~~~

:copyright: (c) 2010 DISQUS.
:license: Apache License 2.0, see LICENSE for more details.
"""

# TODO: i18n
# Credit to Haystack for abstraction concepts

import datetime

from django.http import HttpRequest
from django.utils.html import escape
from django.utils.safestring import mark_safe
from django.core.validators import ValidationError

from gargoyle.models import EXCLUDE

import itertools


def titlize(s):
    return s.title().replace('_', ' ')


class Field(object):
    default_help_text = None

    def __init__(self, label=None, help_text=None):
        self.label = label
        self.help_text = help_text or self.default_help_text
        self.set_values(None)

    def set_values(self, name):
        self.name = name
        if name and not self.label:
            self.label = titlize(name)

    def is_active(self, condition, value):
        return condition == value

    def validate(self, data):
        value = data.get(self.name)
        if value:
            value = self.clean(value)
            assert isinstance(value, basestring), 'clean methods must return strings'
        return value

    def clean(self, value):
        return value

    def render(self, value):
        return mark_safe('<input type="text" value="%s" name="%s"/>' % (escape(value or ''), escape(self.name)))

    def display(self, value):
        return value
        # return '%s: %s' % (self.label, value) - For Cramer to not to forget how to use his own code


class Boolean(Field):
    def is_active(self, condition, value):
        return bool(value)

    def render(self, value):
        return mark_safe('<input type="hidden" value="1" name="%s"/>' % (escape(self.name),))

    def display(self, value):
        return self.label


class Choice(Field):
    def __init__(self, choices, **kwargs):
        self.choices = choices
        super(Choice, self).__init__(**kwargs)

    def is_active(self, condition, value):
        return value in self.choices

    def clean(self, value):
        if value not in self.choices:
            raise ValidationError
        return value


class Range(Field):
    def is_active(self, condition, value):
        return value >= condition[0] and value <= condition[1]

    def validate(self, data):
        value = filter(None, [data.get(self.name + '[min]'), data.get(self.name + '[max]')]) or None
        return self.clean(value)

    def clean(self, value):
        if value:
            try:
                map(int, value)
            except (TypeError, ValueError):
                raise ValidationError('You must enter valid integer values.')
        return '-'.join(value)

    def render(self, value):
        if not value:
            value = ['', '']
        return mark_safe('<input type="text" value="%s" placeholder="from" name="%s[min]"/> - <input type="text" placeholder="to" value="%s" name="%s[max]"/>' %
                         (escape(value[0]), escape(self.name), escape(value[1]), escape(self.name)))

    def display(self, value):
        value = value.split('-')
        return '%s: %s-%s' % (self.label, value[0], value[1])


class Percent(Range):
    default_help_text = 'Enter two ranges. e.g. 0-50 is lower 50%'

    def is_active(self, condition, value):
        condition = map(int, condition.split('-'))
        mod = value % 100
        return mod >= condition[0] and mod <= condition[1]

    def display(self, value):
        value = value.split('-')
        return '%s: %s%% (%s-%s)' % (self.label, int(value[1]) - int(value[0]), value[0], value[1])

    def clean(self, value):
        value = super(Percent, self).clean(value)
        if value:
            numeric = value.split('-')
            if int(numeric[0]) < 0 or int(numeric[1]) > 100:
                raise ValidationError('You must enter values between 0 and 100.')
            if int(numeric[0]) > int(numeric[1]):
                raise ValidationError('Start value must be less than end value.')
        return value


class String(Field):
    pass


class AbstractDate(Field):
    DATE_FORMAT = "%Y-%m-%d"
    PRETTY_DATE_FORMAT = "%d %b %Y"

    def str_to_date(self, value):
        return datetime.datetime.strptime(value, self.DATE_FORMAT).date()

    def display(self, value):
        date = self.str_to_date(value)
        return "%s: %s" % (self.label, date.strftime(self.PRETTY_DATE_FORMAT))

    def clean(self, value):
        try:
            date = self.str_to_date(value)
        except ValueError, e:
            raise ValidationError("Date must be a valid date in the format YYYY-MM-DD.\n(%s)" % e.message)

        return date.strftime(self.DATE_FORMAT)

    def render(self, value):
        if not value:
            value = datetime.date.today().strftime(self.DATE_FORMAT)

        return mark_safe('<input type="text" value="%s" name="%s"/>' % (escape(value), escape(self.name)))

    def is_active(self, condition, value):
        assert isinstance(value, datetime.date)
        if isinstance(value, datetime.datetime):
            # datetime.datetime cannot be compared to datetime.date with > and < operators
            value = value.date()

        condition_date = self.str_to_date(condition)
        return self.date_is_active(condition_date, value)

    def date_is_active(self, condition_date, value):
        raise NotImplementedError


class BeforeDate(AbstractDate):
    def date_is_active(self, before_this_date, value):
        return value < before_this_date


class OnOrAfterDate(AbstractDate):
    def date_is_active(self, after_this_date, value):
        return value >= after_this_date


class ConditionSetBase(type):
    def __new__(cls, name, bases, attrs):
        attrs['fields'] = {}

        # Inherit any fields from parent(s).
        parents = [b for b in bases if isinstance(b, ConditionSetBase)]

        for p in parents:
            fields = getattr(p, 'fields', None)

            if fields:
                attrs['fields'].update(fields)

        for field_name, obj in attrs.items():
            if isinstance(obj, Field):
                field = attrs.pop(field_name)
                field.set_values(field_name)
                attrs['fields'][field_name] = field

        instance = super(ConditionSetBase, cls).__new__(cls, name, bases, attrs)

        return instance


class ConditionSet(object):
    __metaclass__ = ConditionSetBase

    def __repr__(self):
        return '<%s>' % (self.__class__.__name__,)

    def get_id(self):
        """
        Returns a string representing a unique identifier for this ConditionSet
        instance.
        """
        return '%s.%s' % (self.__module__, self.__class__.__name__)

    def can_execute(self, instance):
        """
        Given an instance, returns a boolean of whether this ConditionSet
        can return a valid condition check.
        """
        return True

    def get_namespace(self):
        """
        Returns a string specifying a unique registration namespace for this ConditionSet
        instance.
        """
        return self.__class__.__name__

    def get_field_value(self, instance, field_name):
        """
        Given an instance, and the name of an attribute, returns the value
        of that attribute on the instance.

        Default behavior will map the ``percent`` attribute to ``id``.
        """
        # XXX: can we come up w/ a better API?
        # Ensure we map ``percent`` to the ``id`` column
        if field_name == 'percent':
            field_name = 'id'
        value = getattr(instance, field_name)
        if callable(value):
            value = value()
        return value

    def has_active_condition(self, conditions, instances):
        """
        Given a list of instances, and the conditions active for
        this switch, returns a boolean reprsenting if any
        conditional is met, including a non-instance default.
        """
        return_value = None
        for instance in itertools.chain(instances, [None]):
            if not self.can_execute(instance):
                continue
            result = self.is_active(instance, conditions)
            if result is False:
                return False
            elif result is True:
                return_value = True
        return return_value

    def is_active(self, instance, conditions):
        """
        Given an instance, and the conditions active for this switch, returns
        a boolean representing if the feature is active.
        """
        return_value = None
        for name, field in self.fields.iteritems():
            field_conditions = conditions.get(self.get_namespace(), {}).get(name)
            if field_conditions:
                value = self.get_field_value(instance, name)
                for status, condition in field_conditions:
                    exclude = status == EXCLUDE
                    if field.is_active(condition, value):
                        if exclude:
                            return False
                        return_value = True
                    else:
                        if exclude:
                            return_value = True
        return return_value

    def get_group_label(self):
        """
        Returns a string representing a human readable version
        of this ConditionSet instance.
        """
        return self.__class__.__name__


class ModelConditionSet(ConditionSet):
    percent = Percent()

    def __init__(self, model):
        self.model = model

    def __repr__(self):
        return '<%s: %s>' % (self.__class__.__name__, self.model.__name__)

    def can_execute(self, instance):
        return isinstance(instance, self.model)

    def get_id(self):
        return '%s.%s(%s)' % (self.__module__, self.__class__.__name__, self.get_namespace())

    def get_namespace(self):
        return '%s.%s' % (self.model._meta.app_label, self.model._meta.module_name)

    def get_group_label(self):
        return self.model._meta.verbose_name.title()


class RequestConditionSet(ConditionSet):
    def get_namespace(self):
        return 'request'

    def can_execute(self, instance):
        return isinstance(instance, HttpRequest)

########NEW FILE########
__FILENAME__ = decorators
"""
gargoyle.decorators
~~~~~~~~~~~~~~~~~~~

:copyright: (c) 2010 DISQUS.
:license: Apache License 2.0, see LICENSE for more details.
"""

from functools import wraps
from gargoyle import gargoyle

from django.core.urlresolvers import reverse
from django.http import Http404, HttpResponseRedirect


def switch_is_active(key, redirect_to=None, gargoyle=gargoyle):
    def _switch_is_active(func):
        @wraps(func)
        def wrapped(request, *args, **kwargs):
            if not gargoyle.is_active(key, request):
                if not redirect_to:
                    raise Http404('Switch \'%s\' is not active' % key)
                elif redirect_to.startswith('/'):
                    return HttpResponseRedirect(redirect_to)
                else:
                    return HttpResponseRedirect(reverse(redirect_to))
            return func(request, *args, **kwargs)
        return wrapped
    return _switch_is_active

########NEW FILE########
__FILENAME__ = helpers
"""
gargoyle.helpers
~~~~~~~~~~~~~~~~

:copyright: (c) 2010 DISQUS.
:license: Apache License 2.0, see LICENSE for more details.
"""

from django.core.serializers.json import DjangoJSONEncoder
from django.http import HttpRequest

import datetime
import uuid

# Django 1.5+ compat
try:
    import json
except ImportError:
    import django.utils.simplejson as json


class MockRequest(HttpRequest):
    """
    A mock request object which stores a user
    instance and the ip address.
    """
    def __init__(self, user=None, ip_address=None):
        from django.contrib.auth.models import AnonymousUser

        self.user = user or AnonymousUser()
        self.GET = {}
        self.POST = {}
        self.COOKIES = {}
        self.META = {
            'REMOTE_ADDR': ip_address,
        }


class BetterJSONEncoder(DjangoJSONEncoder):
    def default(self, obj):
        if isinstance(obj, uuid.UUID):
            return obj.hex
        elif isinstance(obj, datetime.datetime):
            return obj.strftime('%Y-%m-%dT%H:%M:%S.%fZ')
        elif isinstance(obj, (set, frozenset)):
            return list(obj)
        return super(BetterJSONEncoder, self).default(obj)


def dumps(value, **kwargs):
    return json.dumps(value, cls=BetterJSONEncoder, **kwargs)

########NEW FILE########
__FILENAME__ = add_switch
from optparse import make_option
from django.core.management.base import BaseCommand, CommandError

from gargoyle.models import Switch, DISABLED, GLOBAL


class Command(BaseCommand):
    args = 'switch_name'
    help = 'Adds or updates the specified gargoyle switch.'

    option_list = BaseCommand.option_list + (
        make_option(
            '--disabled',
            action='store_const',
            const=DISABLED,
            default=GLOBAL,
            dest='status',
            help='Create a disabled switch.'),
    )

    def handle(self, *args, **kwargs):
        if len(args) != 1:
            raise CommandError("Specify a gargoyle switch name to add.")

        status = kwargs['status']
        switch, created = Switch.objects.get_or_create(
            key=args[0],
            defaults=dict(status=status),
        )
        if not created and switch.status != status:
            switch.status = status
            switch.save()

########NEW FILE########
__FILENAME__ = remove_switch
from django.core.management.base import BaseCommand, CommandError

from gargoyle.models import Switch


class Command(BaseCommand):
    args = 'switch_name'
    help = 'Removes the specified gargoyle switch.'

    def handle(self, *args, **kwargs):
        if len(args) != 1:
            raise CommandError("Specify a gargoyle switch name to remove.")

        Switch.objects.filter(key=args[0]).delete()

########NEW FILE########
__FILENAME__ = manager
from django.conf import settings
from django.core.cache import get_cache
from django.http import HttpRequest

from gargoyle.models import Switch, DISABLED, SELECTIVE, GLOBAL, INHERIT, \
    INCLUDE, EXCLUDE
from gargoyle.proxy import SwitchProxy

from modeldict import ModelDict


class SwitchManager(ModelDict):
    DISABLED = DISABLED
    SELECTIVE = SELECTIVE
    GLOBAL = GLOBAL
    INHERIT = INHERIT

    INCLUDE = INCLUDE
    EXCLUDE = EXCLUDE

    def __init__(self, *args, **kwargs):
        self._registry = {}
        super(SwitchManager, self).__init__(*args, **kwargs)

    def __repr__(self):
        return "<%s: %s (%s)>" % (self.__class__.__name__, self.model, self._registry.values())

    def __getitem__(self, key):
        """
        Returns a SwitchProxy, rather than a Switch. It allows us to
        easily extend the Switches method and automatically include our
        manager instance.
        """
        return SwitchProxy(self, super(SwitchManager, self).__getitem__(key))

    def is_active(self, key, *instances, **kwargs):
        """
        Returns ``True`` if any of ``instances`` match an active switch. Otherwise
        returns ``False``.

        >>> gargoyle.is_active('my_feature', request) #doctest: +SKIP
        """
        default = kwargs.pop('default', False)

        # Check all parents for a disabled state
        parts = key.split(':')
        if len(parts) > 1:
            child_kwargs = kwargs.copy()
            child_kwargs['default'] = None
            result = self.is_active(':'.join(parts[:-1]), *instances, **child_kwargs)

            if result is False:
                return result
            elif result is True:
                default = result

        try:
            switch = self[key]
        except KeyError:
            # switch is not defined, defer to parent
            return default

        if switch.status == GLOBAL:
            return True
        elif switch.status == DISABLED:
            return False
        elif switch.status == INHERIT:
            return default

        conditions = switch.value
        # If no conditions are set, we inherit from parents
        if not conditions:
            return default

        if instances:
            # HACK: support request.user by swapping in User instance
            instances = list(instances)
            for v in instances:
                if isinstance(v, HttpRequest) and hasattr(v, 'user'):
                    instances.append(v.user)

        # check each switch to see if it can execute
        return_value = False

        for switch in self._registry.itervalues():
            result = switch.has_active_condition(conditions, instances)
            if result is False:
                return False
            elif result is True:
                return_value = True

        # there were no matching conditions, so it must not be enabled
        return return_value

    def register(self, condition_set):
        """
        Registers a condition set with the manager.

        >>> condition_set = MyConditionSet() #doctest: +SKIP
        >>> gargoyle.register(condition_set) #doctest: +SKIP
        """

        if callable(condition_set):
            condition_set = condition_set()
        self._registry[condition_set.get_id()] = condition_set

    def unregister(self, condition_set):
        """
        Unregisters a condition set with the manager.

        >>> gargoyle.unregister(condition_set) #doctest: +SKIP
        """
        if callable(condition_set):
            condition_set = condition_set()
        self._registry.pop(condition_set.get_id(), None)

    def get_condition_set_by_id(self, switch_id):
        """
        Given the identifier of a condition set (described in
        ConditionSet.get_id()), returns the registered instance.
        """
        return self._registry[switch_id]

    def get_condition_sets(self):
        """
        Returns a generator yielding all currently registered
        ConditionSet instances.
        """
        return self._registry.itervalues()

    def get_all_conditions(self):
        """
        Returns a generator which yields groups of lists of conditions.

        >>> for set_id, label, field in gargoyle.get_all_conditions(): #doctest: +SKIP
        >>>     print "%(label)s: %(field)s" % (label, field.label) #doctest: +SKIP
        """
        for condition_set in sorted(self.get_condition_sets(), key=lambda x: x.get_group_label()):
            group = unicode(condition_set.get_group_label())
            for field in condition_set.fields.itervalues():
                yield condition_set.get_id(), group, field

    def as_request(self, user=None, ip_address=None):
        from gargoyle.helpers import MockRequest

        return MockRequest(user, ip_address)


if hasattr(settings, 'GARGOYLE_CACHE_NAME'):
    gargoyle = SwitchManager(Switch, key='key', value='value', instances=True,
                         auto_create=getattr(settings, 'GARGOYLE_AUTO_CREATE', True),
                         cache=get_cache(settings.GARGOYLE_CACHE_NAME))
else:
    gargoyle = SwitchManager(Switch, key='key', value='value', instances=True,
                         auto_create=getattr(settings, 'GARGOYLE_AUTO_CREATE', True))

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

try:
    from django.utils.timezone import now as timezone_aware_now
except ImportError:
    from datetime import datetime
    timezone_aware_now = datetime.now

class Migration(SchemaMigration):

    def forwards(self, orm):

        # Adding model 'Switch'
        db.create_table('gargoyle_switch', (
            ('key', self.gf('django.db.models.fields.CharField')(max_length=32, primary_key=True)),
            ('value', self.gf('jsonfield.fields.JSONField')(default='{}')),
            ('label', self.gf('django.db.models.fields.CharField')(max_length=32, null=True)),
            ('date_created', self.gf('django.db.models.fields.DateTimeField')(default=timezone_aware_now)),
            ('description', self.gf('django.db.models.fields.TextField')(null=True)),
            ('status', self.gf('django.db.models.fields.PositiveSmallIntegerField')(default=1)),
        ))
        db.send_create_signal('gargoyle', ['Switch'])


    def backwards(self, orm):

        # Deleting model 'Switch'
        db.delete_table('gargoyle_switch')


    models = {
        'gargoyle.switch': {
            'Meta': {'object_name': 'Switch'},
            'date_created': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'description': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '32', 'primary_key': 'True'}),
            'label': ('django.db.models.fields.CharField', [], {'max_length': '32', 'null': 'True'}),
            'status': ('django.db.models.fields.PositiveSmallIntegerField', [], {'default': '1'}),
            'value': ('jsonfield.fields.JSONField', [], {'default': "'{}'"})
        }
    }

    complete_apps = ['gargoyle']

########NEW FILE########
__FILENAME__ = 0002_auto__add_field_switch_date_modified
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

try:
    from django.utils.timezone import now as timezone_aware_now
except ImportError:
    from datetime import datetime
    timezone_aware_now = datetime.now

class Migration(SchemaMigration):

    def forwards(self, orm):

        # Adding field 'Switch.date_modified'
        db.add_column('gargoyle_switch', 'date_modified', self.gf('django.db.models.fields.DateTimeField')(default=timezone_aware_now), keep_default=False)


    def backwards(self, orm):

        # Deleting field 'Switch.date_modified'
        db.delete_column('gargoyle_switch', 'date_modified')


    models = {
        'gargoyle.switch': {
            'Meta': {'object_name': 'Switch'},
            'date_created': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'date_modified': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'description': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '32', 'primary_key': 'True'}),
            'label': ('django.db.models.fields.CharField', [], {'max_length': '32', 'null': 'True'}),
            'status': ('django.db.models.fields.PositiveSmallIntegerField', [], {'default': '1'}),
            'value': ('jsonfield.fields.JSONField', [], {'default': "'{}'"})
        }
    }

    complete_apps = ['gargoyle']

########NEW FILE########
__FILENAME__ = 0003_auto__chg_field_switch_label__chg_field_switch_key
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):

        # Changing field 'Switch.label'
        db.alter_column('gargoyle_switch', 'label', self.gf('django.db.models.fields.CharField')(max_length=64, null=True))

        # Changing field 'Switch.key'
        db.alter_column('gargoyle_switch', 'key', self.gf('django.db.models.fields.CharField')(max_length=64, primary_key=True))

    def backwards(self, orm):

        # Changing field 'Switch.label'
        db.alter_column('gargoyle_switch', 'label', self.gf('django.db.models.fields.CharField')(max_length=32, null=True))

        # Changing field 'Switch.key'
        db.alter_column('gargoyle_switch', 'key', self.gf('django.db.models.fields.CharField')(max_length=32, primary_key=True))

    models = {
        'gargoyle.switch': {
            'Meta': {'object_name': 'Switch'},
            'date_created': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'date_modified': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'description': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '64', 'primary_key': 'True'}),
            'label': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True'}),
            'status': ('django.db.models.fields.PositiveSmallIntegerField', [], {'default': '1'}),
            'value': ('jsonfield.fields.JSONField', [], {'default': "'{}'"})
        }
    }

    complete_apps = ['gargoyle']
########NEW FILE########
__FILENAME__ = models
"""
gargoyle.models
~~~~~~~~~~~~~~~

:copyright: (c) 2010 DISQUS.
:license: Apache License 2.0, see LICENSE for more details.
"""

from django.db import models
from django.conf import settings
from django.utils.translation import ugettext_lazy as _
try:
    from django.utils.timezone import now
except ImportError:
    import datetime
    now = datetime.datetime.now

from jsonfield import JSONField

DISABLED = 1
SELECTIVE = 2
GLOBAL = 3
INHERIT = 4

INCLUDE = 'i'
EXCLUDE = 'e'


class Switch(models.Model):
    """
    Stores information on all switches. Generally handled through an instance of ``ModelDict``,
    which is registered under the global ``gargoyle`` namespace.

    ``value`` is stored with by type label, and then by column:

    >>> {
    >>>   namespace: {
    >>>       id: [[INCLUDE, 0, 50], [INCLUDE, 'string']] // 50% of users
    >>>   }
    >>> }
    """

    STATUS_CHOICES = (
        (DISABLED, 'Disabled'),
        (SELECTIVE, 'Selective'),
        (GLOBAL, 'Global'),
        (INHERIT, 'Inherit'),
    )

    STATUS_LABELS = {
        INHERIT: 'Inherit from parent',
        GLOBAL: 'Active for everyone',
        SELECTIVE: 'Active for conditions',
        DISABLED: 'Disabled for everyone',
    }

    key = models.CharField(max_length=64, primary_key=True)
    value = JSONField(default="{}")
    label = models.CharField(max_length=64, null=True)
    date_created = models.DateTimeField(default=now)
    date_modified = models.DateTimeField(default=now)
    description = models.TextField(null=True)
    status = models.PositiveSmallIntegerField(default=DISABLED, choices=STATUS_CHOICES)

    class Meta:
        permissions = (
            ("can_view", "Can view"),
        )
        verbose_name = _('switch')
        verbose_name_plural = _('switches')

    def __init__(self, *args, **kwargs):
        if (
            kwargs and
            hasattr(settings, 'GARGOYLE_SWITCH_DEFAULTS') and
            'key' in kwargs and
            'status' not in kwargs
        ):
            key = kwargs['key']
            switch_default = settings.GARGOYLE_SWITCH_DEFAULTS.get(key)
            if switch_default is not None:
                is_active = switch_default.get('is_active')
                if is_active is True:
                    kwargs['status'] = GLOBAL
                elif is_active is False:
                    kwargs['status'] = DISABLED
                if not kwargs.get('label'):
                    kwargs['label'] = switch_default.get('label')
                if not kwargs.get('description'):
                    kwargs['description'] = switch_default.get('description')

        return super(Switch, self).__init__(*args, **kwargs)

    def __unicode__(self):
        return u"%s=%s" % (self.key, self.value)

    def to_dict(self, manager):
        data = {
            'key': self.key,
            'status': self.status,
            'statusLabel': self.get_status_label(),
            'label': self.label or self.key.title(),
            'description': self.description,
            'date_modified': self.date_modified,
            'date_created': self.date_created,
            'conditions': [],
        }

        last = None
        for condition_set_id, group, field, value, exclude in self.get_active_conditions(manager):
            if not last or last['id'] != condition_set_id:
                if last:
                    data['conditions'].append(last)

                last = {
                    'id': condition_set_id,
                    'label': group,
                    'conditions': []
                }

            last['conditions'].append((field.name, value, field.display(value), exclude))
        if last:
            data['conditions'].append(last)

        return data

    def add_condition(self, manager, condition_set, field_name, condition, exclude=False, commit=True):
        """
        Adds a new condition and registers it in the global ``gargoyle`` switch manager.

        If ``commit`` is ``False``, the data will not be written to the database.

        >>> switch = gargoyle['my_switch'] #doctest: +SKIP
        >>> condition_set_id = condition_set.get_id() #doctest: +SKIP
        >>> switch.add_condition(condition_set_id, 'percent', [0, 50], exclude=False) #doctest: +SKIP
        """
        condition_set = manager.get_condition_set_by_id(condition_set)

        assert isinstance(condition, basestring), 'conditions must be strings'

        namespace = condition_set.get_namespace()

        if namespace not in self.value:
            self.value[namespace] = {}
        if field_name not in self.value[namespace]:
            self.value[namespace][field_name] = []
        if condition not in self.value[namespace][field_name]:
            self.value[namespace][field_name].append((exclude and EXCLUDE or INCLUDE, condition))

        if commit:
            self.save()

    def remove_condition(self, manager, condition_set, field_name, condition, commit=True):
        """
        Removes a condition and updates the global ``gargoyle`` switch manager.

        If ``commit`` is ``False``, the data will not be written to the database.

        >>> switch = gargoyle['my_switch'] #doctest: +SKIP
        >>> condition_set_id = condition_set.get_id() #doctest: +SKIP
        >>> switch.remove_condition(condition_set_id, 'percent', [0, 50]) #doctest: +SKIP
        """
        condition_set = manager.get_condition_set_by_id(condition_set)

        namespace = condition_set.get_namespace()

        if namespace not in self.value:
            return

        if field_name not in self.value[namespace]:
            return

        self.value[namespace][field_name] = [c for c in self.value[namespace][field_name] if c[1] != condition]

        if not self.value[namespace][field_name]:
            del self.value[namespace][field_name]

            if not self.value[namespace]:
                del self.value[namespace]

        if commit:
            self.save()

    def clear_conditions(self, manager, condition_set, field_name=None, commit=True):
        """
        Clears conditions given a set of parameters.

        If ``commit`` is ``False``, the data will not be written to the database.

        Clear all conditions given a ConditionSet, and a field name:

        >>> switch = gargoyle['my_switch'] #doctest: +SKIP
        >>> condition_set_id = condition_set.get_id() #doctest: +SKIP
        >>> switch.clear_conditions(condition_set_id, 'percent') #doctest: +SKIP

        You can also clear all conditions given a ConditionSet:

        >>> switch = gargoyle['my_switch'] #doctest: +SKIP
        >>> condition_set_id = condition_set.get_id() #doctest: +SKIP
        >>> switch.clear_conditions(condition_set_id) #doctest: +SKIP
        """
        condition_set = manager.get_condition_set_by_id(condition_set)

        namespace = condition_set.get_namespace()

        if namespace not in self.value:
            return

        if not field_name:
            del self.value[namespace]
        elif field_name not in self.value[namespace]:
            return
        else:
            del self.value[namespace][field_name]

        if commit:
            self.save()

    def get_active_conditions(self, manager):
        """
        Returns a generator which yields groups of lists of conditions.

        >>> for label, set_id, field, value, exclude in gargoyle.get_all_conditions(): #doctest: +SKIP
        >>>     print "%(label)s: %(field)s = %(value)s (exclude: %(exclude)s)" % (label, field.label, value, exclude) #doctest: +SKIP
        """
        for condition_set in sorted(manager.get_condition_sets(), key=lambda x: x.get_group_label()):
            ns = condition_set.get_namespace()
            condition_set_id = condition_set.get_id()
            if ns in self.value:
                group = condition_set.get_group_label()
                for name, field in condition_set.fields.iteritems():
                    for value in self.value[ns].get(name, []):
                        try:
                            yield condition_set_id, group, field, value[1], value[0] == EXCLUDE
                        except TypeError:
                            continue

    def get_status_label(self):
        if self.status == SELECTIVE and not self.value:
            status = GLOBAL
        else:
            status = self.status

        return self.STATUS_LABELS[status]

########NEW FILE########
__FILENAME__ = nexus_modules
"""
gargoyle.nexus_modules
~~~~~~~~~~~~~~~~~~~~~~

:copyright: (c) 2010 DISQUS.
:license: Apache License 2.0, see LICENSE for more details.
"""

import logging
import nexus
import os.path

from functools import wraps

from django.conf import settings
from django.http import HttpResponse, HttpResponseNotFound

from gargoyle import gargoyle, autodiscover
from gargoyle.helpers import dumps
from gargoyle.models import Switch, DISABLED
from gargoyle.conditions import ValidationError
from gargoyle import signals


GARGOYLE_ROOT = os.path.dirname(__file__)

autodiscover()

logger = logging.getLogger('gargoyle.switches')


class GargoyleException(Exception):
    def __init__(self, message):
        self.message = message

    def __str__(self):
        return self.message


def json(func):
    "Decorator to make JSON views simpler"

    def wrapper(self, request, *args, **kwargs):
        try:
            response = {
                "success": True,
                "data": func(self, request, *args, **kwargs)
            }
        except GargoyleException, exc:
            response = {
                "success": False,
                "data": exc.message
            }
        except Switch.DoesNotExist:
            response = {
                "success": False,
                "data": "Switch cannot be found"
            }
        except ValidationError, e:
            response = {
                "success": False,
                "data": u','.join(map(unicode, e.messages)),
            }
        except Exception:
            if settings.DEBUG:
                import traceback
                traceback.print_exc()
            raise
        return HttpResponse(dumps(response), mimetype="application/json")
    wrapper = wraps(func)(wrapper)
    return wrapper


class GargoyleModule(nexus.NexusModule):
    home_url = 'index'
    name = 'gargoyle'

    def get_title(self):
        return 'Gargoyle'

    def get_urls(self):
        try:
            from django.conf.urls import patterns, url
        except ImportError:  # Django<=1.4
            from django.conf.urls.defaults import patterns, url

        urlpatterns = patterns('',
                               url(r'^add/$', self.as_view(self.add), name='add'),
                               url(r'^update/$', self.as_view(self.update), name='update'),
                               url(r'^delete/$', self.as_view(self.delete), name='delete'),
                               url(r'^status/$', self.as_view(self.status), name='status'),
                               url(r'^conditions/add/$', self.as_view(self.add_condition), name='add-condition'),
                               url(r'^conditions/remove/$', self.as_view(self.remove_condition), name='remove-condition'),
                               url(r'^$', self.as_view(self.index), name='index'),
                               )

        return urlpatterns

    def render_on_dashboard(self, request):
        active_switches_count = Switch.objects.exclude(status=DISABLED).count()

        switches = list(Switch.objects.exclude(status=DISABLED).order_by("date_created")[:5])

        return self.render_to_string('gargoyle/nexus/dashboard.html', {
            'switches': switches,
            'active_switches_count': active_switches_count,
        })

    def index(self, request):
        sort_by = request.GET.get('by', '-date_modified')

        if sort_by not in self.valid_sort_orders:
            return HttpResponseNotFound('Invalid sort order.')

        switches = list(Switch.objects.all().order_by(sort_by))

        return self.render_to_response("gargoyle/index.html", {
            "switches": [s.to_dict(gargoyle) for s in switches],
            "all_conditions": list(gargoyle.get_all_conditions()),
            "sorted_by": sort_by
        }, request)

    def add(self, request):
        key = request.POST.get("key")

        if not key:
            raise GargoyleException("Key cannot be empty")

        if len(key) > 64:
            raise GargoyleException("Key must be less than or equal to 64 characters in length")

        label = request.POST.get("name", "").strip()

        if len(label) > 64:
            raise GargoyleException("Name must be less than or equal to 64 characters in length")

        switch, created = Switch.objects.get_or_create(
            key=key,
            defaults=dict(
                label=label or None,
                description=request.POST.get("desc")
            )
        )

        if not created:
            raise GargoyleException("Switch with key %s already exists" % key)

        logger.info('Switch %r added (%%s)' % switch.key,
                    ', '.join('%s=%r' % (k, getattr(switch, k)) for k in sorted(('key', 'label', 'description', ))))

        signals.switch_added.send(
            sender=self,
            request=request,
            switch=switch,
        )

        return switch.to_dict(gargoyle)
    add = json(add)

    def update(self, request):
        switch = Switch.objects.get(key=request.POST.get("curkey"))

        key = request.POST.get("key")

        if len(key) > 64:
            raise GargoyleException("Key must be less than or equal to 64 characters in length")

        label = request.POST.get("name", "")

        if len(label) > 64:
            raise GargoyleException("Name must be less than or equal to 64 characters in length")

        values = dict(
            label=label,
            key=key,
            description=request.POST.get("desc"),
        )

        changes = {}
        for attribute, value in values.iteritems():
            new_value = getattr(switch, attribute)
            if new_value != value:
                changes[attribute] = (value, new_value)

        if changes:
            if switch.key != key:
                switch.delete()
                switch.key = key

            switch.label = label
            switch.description = request.POST.get("desc")
            switch.save()

            logger.info('Switch %r updated %%s' % switch.key,
                        ', '.join('%s=%r->%r' % (k, v[0], v[1]) for k, v in sorted(changes.iteritems())))

            signals.switch_updated.send(
                sender=self,
                request=request,
                switch=switch,
                changes=changes,
            )

        return switch.to_dict(gargoyle)
    update = json(update)

    def status(self, request):
        switch = Switch.objects.get(key=request.POST.get("key"))

        try:
            status = int(request.POST.get("status"))
        except ValueError:
            raise GargoyleException("Status must be integer")

        old_status = switch.status
        old_status_label = switch.get_status_display()

        if switch.status != status:
            switch.status = status
            switch.save()

            logger.info('Switch %r updated (status=%%s->%%s)' % switch.key,
                        old_status_label, switch.get_status_display())

            signals.switch_status_updated.send(
                sender=self,
                request=request,
                switch=switch,
                old_status=old_status,
                status=status,
            )

        return switch.to_dict(gargoyle)
    status = json(status)

    def delete(self, request):
        switch = Switch.objects.get(key=request.POST.get("key"))
        switch.delete()

        logger.info('Switch %r removed' % switch.key)

        signals.switch_deleted.send(
            sender=self,
            request=request,
            switch=switch,
        )

        return {}
    delete = json(delete)

    def add_condition(self, request):
        key = request.POST.get("key")
        condition_set_id = request.POST.get("id")
        field_name = request.POST.get("field")
        exclude = int(request.POST.get("exclude") or 0)

        if not all([key, condition_set_id, field_name]):
            raise GargoyleException("Fields cannot be empty")

        field = gargoyle.get_condition_set_by_id(condition_set_id).fields[field_name]
        value = field.validate(request.POST)

        switch = gargoyle[key]
        switch.add_condition(condition_set_id, field_name, value, exclude=exclude)

        logger.info('Condition added to %r (%r, %s=%r, exclude=%r)' % (switch.key,
                    condition_set_id, field_name, value, bool(exclude)))

        signals.switch_condition_added.send(
            sender=self,
            request=request,
            switch=switch,
            condition={
                'condition_set_id': condition_set_id,
                'field_name': field_name,
                'value': value,
            },
        )

        return switch.to_dict(gargoyle)
    add_condition = json(add_condition)

    def remove_condition(self, request):
        key = request.POST.get("key")
        condition_set_id = request.POST.get("id")
        field_name = request.POST.get("field")
        value = request.POST.get("value")

        if not all([key, condition_set_id, field_name, value]):
            raise GargoyleException("Fields cannot be empty")

        switch = gargoyle[key]
        switch.remove_condition(condition_set_id, field_name, value)

        logger.info('Condition removed from %r (%r, %s=%r)' % (switch.key,
                    condition_set_id, field_name, value))

        signals.switch_condition_removed.send(
            sender=self,
            request=request,
            switch=switch,
            condition={
                'condition_set_id': condition_set_id,
                'field_name': field_name,
                'value': value,
            },
        )

        return switch.to_dict(gargoyle)
    remove_condition = json(remove_condition)

    @property
    def valid_sort_orders(self):
        fields = ['label', 'date_created', 'date_modified']
        return fields + ['-' + f for f in fields]

nexus.site.register(GargoyleModule, 'gargoyle')

########NEW FILE########
__FILENAME__ = proxy
class SwitchProxy(object):
    def __init__(self, manager, switch):
        self._switch = switch
        self._manager = manager

    def __getattr__(self, attr):
        if attr in self.__dict__:
            return self.__dict__[attr]
        else:
            return getattr(self._switch, attr)

    def __setattr__(self, attr, value):
        if attr in ('_switch', '_manager'):
            object.__setattr__(self, attr, value)
        else:
            setattr(self._switch, attr, value)

    def add_condition(self, *args, **kwargs):
        return self._switch.add_condition(self._manager, *args, **kwargs)

    def remove_condition(self, *args, **kwargs):
        return self._switch.remove_condition(self._manager, *args, **kwargs)

    def clear_conditions(self, *args, **kwargs):
        return self._switch.clear_conditions(self._manager, *args, **kwargs)

    def get_active_conditions(self, *args, **kwargs):
        return self._switch.get_active_conditions(self._manager, *args, **kwargs)

########NEW FILE########
__FILENAME__ = signals
import django.dispatch

#: This signal is sent when a switch is added (similar to Django's post_save, when
#: created is True).
#:
#: Example subscriber::
#:
#:      def switch_added_callback(sender, request, switch, **extra):
#:          logging.debug('Switch was added: %r', switch.label)
#:
#:      from gargoyle.signals import switch_added
#:      switch_added.connect(switch_added_callback)
switch_added = django.dispatch.Signal(providing_args=["request", "switch"])

#: This signal is sent when a switch is deleted (similar to Django's post_delete).
#:
#: Example subscriber::
#:
#:      def switch_deleted_callback(sender, request, switch, **extra):
#:          logging.debug('Switch was deleted: %r', switch.label)
#:
#:      from gargoyle.signals import switch_deleted
#:      switch_deleted.connect(switch_deleted_callback)
switch_deleted = django.dispatch.Signal(providing_args=["request", "switch"])

#: This signal is sent when a switch is updated (similar to Django's post_save, when
#: created is False).
#:
#: Example subscriber::
#:
#:      def switch_updated_callback(sender, request, switch, **extra):
#:          logging.debug('Switch was updated: %r', switch.label)
#:
#:      from gargoyle.signals import switch_updated
#:      switch_updated.connect(switch_updated_callback)
switch_updated = django.dispatch.Signal(providing_args=["request", "switch", "changes"])

#: This signal is sent when a condition is removed from a switch.
#:
#: Example subscriber::
#:
#:      def switch_status_updated_callback(sender, request, switch, status, **extra):
#:          logging.debug('Switch has updated status: %r; %r', switch.label, status)
#:
#:      from gargoyle.signals import switch_status_updated
#:      switch_status_updated.connect(switch_status_updated_callback)
switch_status_updated = django.dispatch.Signal(providing_args=["request", "switch", "status", "old_status"])

#: This signal is sent when a condition is added to a switch.
#:
#: Example subscriber::
#:
#:     def switch_condition_added_callback(sender, request, switch, condition, **extra):
#:         logging.debug('Switch has new condition: %r; %r', switch.label, condition)
#:
#:     from gargoyle.signals import switch_condition_added
#:     switch_condition_added.connect(switch_condition_added_callback)
switch_condition_added = django.dispatch.Signal(providing_args=["request", "switch", "condition"])

#: This signal is sent when a condition is removed from a switch.
#:
#: Example subscriber::
#:
#:      def switch_condition_deleted_callback(sender, request, switch, condition, **extra):
#:          logging.debug('Switch has deleted condition: %r; %r', switch.label, condition)
#:
#:      from gargoyle.signals import switch_condition_deleted
#:      switch_condition_deleted.connect(switch_condition_deleted_callback)
switch_condition_removed = django.dispatch.Signal(providing_args=["request", "switch", "condition"])

########NEW FILE########
__FILENAME__ = gargoyle_helpers
"""
gargoyle.templatetags.gargoyle_helpers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:copyright: (c) 2010 DISQUS.
:license: Apache License 2.0, see LICENSE for more details.
"""

from django import template

register = template.Library()


def raw(parser, token):
    # Whatever is between {% raw %} and {% endraw %} will be preserved as
    # raw, unrendered template code.
    text = []
    parse_until = 'endraw'
    tag_mapping = {
        template.TOKEN_TEXT: ('', ''),
        template.TOKEN_VAR: ('{{', '}}'),
        template.TOKEN_BLOCK: ('{%', '%}'),
        template.TOKEN_COMMENT: ('{#', '#}'),
    }
    # By the time this template tag is called, the template system has already
    # lexed the template into tokens. Here, we loop over the tokens until
    # {% endraw %} and parse them to TextNodes. We have to add the start and
    # end bits (e.g. "{{" for variables) because those have already been
    # stripped off in a previous part of the template-parsing process.
    while parser.tokens:
        token = parser.next_token()
        if token.token_type == template.TOKEN_BLOCK and token.contents == parse_until:
            return template.TextNode(u''.join(text))
        start, end = tag_mapping[token.token_type]
        text.append(u'%s%s%s' % (start, token.contents, end))
    parser.unclosed_block_tag(parse_until)
raw = register.tag(raw)


def render_field(field, value=None):
    return field.render(value)
render_field = register.filter(render_field)


def sort_by_key(field, currently):
    is_negative = currently.find('-') is 0
    current_field = currently.lstrip('-')

    if current_field == field and is_negative:
        return field
    elif current_field == field:
        return '-' + field
    else:
        return field

sort_by_key = register.filter(sort_by_key)


def sort_field(sort_string):
    return sort_string.lstrip('-')

sort_field = register.filter(sort_field)

########NEW FILE########
__FILENAME__ = gargoyle_tags
"""
gargoyle.templatetags.gargoyle_tags
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:copyright: (c) 2010 DISQUS.
:license: Apache License 2.0, see LICENSE for more details.
"""

from django import template

from gargoyle import gargoyle

register = template.Library()


@register.tag
def ifswitch(parser, token):
    bits = token.split_contents()
    if len(bits) < 2:
        raise template.TemplateSyntaxError("%r tag requires an argument" % token.contents.split()[0])

    name = bits[1]
    instances = bits[2:]

    nodelist_true = parser.parse(('else', 'endifswitch'))
    token = parser.next_token()

    if token.contents == 'else':
        nodelist_false = parser.parse(('endifswitch',))
        parser.delete_first_token()
    else:
        nodelist_false = template.NodeList()

    return SwitchNode(nodelist_true, nodelist_false, name, instances)


class SwitchNode(template.Node):
    def __init__(self, nodelist_true, nodelist_false, name, instances):
        self.nodelist_true = nodelist_true
        self.nodelist_false = nodelist_false
        self.name = name
        self.instances = [template.Variable(i) for i in instances]

    def render(self, context):
        instances = [i.resolve(context) for i in self.instances]
        if 'request' in context:
            instances.append(context['request'])

        if not gargoyle.is_active(self.name, *instances):
            return self.nodelist_false.render(context)

        return self.nodelist_true.render(context)

########NEW FILE########
__FILENAME__ = testutils
"""
gargoyle.testutils
~~~~~~~~~~~~~~~~~~

:copyright: (c) 2010 DISQUS.
:license: Apache License 2.0, see LICENSE for more details.
"""

from functools import wraps

from gargoyle import gargoyle


class SwitchContextManager(object):
    """
    Allows temporarily enabling or disabling a switch.

    Ideal for testing.

    >>> @switches(my_switch_name=True)
    >>> def foo():
    >>>     print gargoyle.is_active('my_switch_name')

    >>> def foo():
    >>>     with switches(my_switch_name=True):
    >>>         print gargoyle.is_active('my_switch_name')

    You may also optionally pass an instance of ``SwitchManager``
    as the first argument.

    >>> def foo():
    >>>     with switches(gargoyle, my_switch_name=True):
    >>>         print gargoyle.is_active('my_switch_name')
    """
    def __init__(self, gargoyle=gargoyle, **keys):
        self.gargoyle = gargoyle
        self.is_active_func = gargoyle.is_active
        self.keys = keys
        self._state = {}
        self._values = {
            True: gargoyle.GLOBAL,
            False: gargoyle.DISABLED,
        }

    def __call__(self, func):
        @wraps(func)
        def inner(*args, **kwargs):
            with self:
                return func(*args, **kwargs)
        return inner

    def __enter__(self):
        self.patch()

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.unpatch()

    def patch(self):
        def is_active(gargoyle):
            is_active_func = gargoyle.is_active

            def wrapped(key, *args, **kwargs):
                if key in self.keys:
                    return self.keys[key]
                return is_active_func(key, *args, **kwargs)
            return wrapped

        self.gargoyle.is_active = is_active(self.gargoyle)

    def unpatch(self):
        self.gargoyle.is_active = self.is_active_func

switches = SwitchContextManager

########NEW FILE########
__FILENAME__ = runtests
#!/usr/bin/env python

"""
runtests
~~~~~~~~

:copyright: (c) 2010 DISQUS.
:license: Apache License 2.0, see LICENSE for more details.
"""

import sys

from django.conf import settings
from optparse import OptionParser

if not settings.configured:
    settings.configure(
        DATABASE_ENGINE='sqlite3',
        DATABASES={
            'default': {
                'ENGINE': 'django.db.backends.sqlite3',
            },
        },
        INSTALLED_APPS=[
            'django.contrib.auth',
            'django.contrib.admin',
            'django.contrib.sessions',
            'django.contrib.sites',

            # Included to fix Disqus' test Django which solves IntegrityMessage case
            'django.contrib.contenttypes',
            'gargoyle',
            'south',

            'tests',
        ],
        ROOT_URLCONF='',
        DEBUG=False,
        TEMPLATE_DEBUG=True,
        GARGOYLE_SWITCH_DEFAULTS={
            'active_by_default': {
              'is_active': True,
              'label': 'Default Active',
              'description': 'When you want the newness',
            },
            'inactive_by_default': {
              'is_active': False,
              'label': 'Default Inactive',
              'description': 'Controls the funkiness.',
            },
        },
        SITE_ID=1,
    )

from django_nose import NoseTestSuiteRunner


def runtests(*test_args, **kwargs):
    if 'south' in settings.INSTALLED_APPS:
        from south.management.commands import patch_for_test_db_setup
        patch_for_test_db_setup()

    if not test_args:
        test_args = ['tests']

    test_runner = NoseTestSuiteRunner(**kwargs)

    failures = test_runner.run_tests(test_args)
    sys.exit(failures)

if __name__ == '__main__':
    parser = OptionParser()
    parser.add_option('--verbosity', dest='verbosity', action='store', default=1, type=int)
    parser.add_options(NoseTestSuiteRunner.options)
    (options, args) = parser.parse_args()

    runtests(*args, **options.__dict__)

########NEW FILE########
__FILENAME__ = models
"""
:copyright: (c) 2010 DISQUS.
:license: Apache License 2.0, see LICENSE for more details.
"""

########NEW FILE########
__FILENAME__ = tests
"""
:copyright: (c) 2010 DISQUS.
:license: Apache License 2.0, see LICENSE for more details.
"""

import datetime
import sys

from django.conf import settings
from django.contrib.auth.models import User, AnonymousUser
from django.core.cache import cache
from django.core.management.base import CommandError
from django.core.management import call_command
from django.http import HttpRequest, Http404, HttpResponse
from django.utils import simplejson
from django.test import TestCase
from django.template import Context, Template, TemplateSyntaxError

import gargoyle
from gargoyle.builtins import IPAddressConditionSet, UserConditionSet, HostConditionSet
from gargoyle.decorators import switch_is_active
from gargoyle.helpers import MockRequest
from gargoyle.models import Switch, SELECTIVE, DISABLED, GLOBAL, INHERIT
from gargoyle.management.commands.add_switch import Command as AddSwitchCmd
from gargoyle.management.commands.remove_switch import (
    Command as RemoveSwitchCmd
)
from gargoyle.manager import SwitchManager
from gargoyle.testutils import switches

import socket


class APITest(TestCase):
    urls = 'tests.urls'

    def setUp(self):
        self.user = User.objects.create(username='foo', email='foo@example.com')
        self.gargoyle = SwitchManager(Switch, key='key', value='value', instances=True, auto_create=True)
        self.gargoyle.register(UserConditionSet(User))
        self.gargoyle.register(IPAddressConditionSet())
        self.internal_ips = settings.INTERNAL_IPS

    def tearDown(self):
        settings.INTERNAL_IPS = self.internal_ips

    def test_builtin_registration(self):
        self.assertTrue('gargoyle.builtins.UserConditionSet(auth.user)' in self.gargoyle._registry)
        self.assertTrue('gargoyle.builtins.IPAddressConditionSet' in self.gargoyle._registry)
        self.assertEquals(len(list(self.gargoyle.get_condition_sets())), 2, self.gargoyle)

    def test_user(self):
        condition_set = 'gargoyle.builtins.UserConditionSet(auth.user)'

        # we need a better API for this (model dict isnt cutting it)
        switch = Switch.objects.create(
            key='test',
            status=SELECTIVE,
        )
        switch = self.gargoyle['test']

        switch.add_condition(
            condition_set=condition_set,
            field_name='percent',
            condition='0-50',
        )

        user = User(pk=5)
        self.assertTrue(self.gargoyle.is_active('test', user))

        user = User(pk=8771)
        self.assertFalse(self.gargoyle.is_active('test', user))

        switch.add_condition(
            condition_set=condition_set,
            field_name='is_staff',
            condition='1',
        )

        user = User(pk=8771, is_staff=True)
        self.assertTrue(self.gargoyle.is_active('test', user))

        user = User(pk=8771, is_superuser=True)
        self.assertFalse(self.gargoyle.is_active('test', user))

        switch.add_condition(
            condition_set=condition_set,
            field_name='is_superuser',
            condition='1',
        )

        user = User(pk=8771, is_superuser=True)
        self.assertTrue(self.gargoyle.is_active('test', user))

        # test with mock request
        self.assertTrue(self.gargoyle.is_active('test', self.gargoyle.as_request(user=user)))

        # test date joined condition
        user = User(pk=8771)
        self.assertFalse(self.gargoyle.is_active('test', user))

        switch.add_condition(
            condition_set=condition_set,
            field_name='date_joined',
            condition='2011-07-01',
        )

        user = User(pk=8771, date_joined=datetime.datetime(2011, 07, 02))
        self.assertTrue(self.gargoyle.is_active('test', user))

        user = User(pk=8771, date_joined=datetime.datetime(2012, 07, 02))
        self.assertTrue(self.gargoyle.is_active('test', user))

        user = User(pk=8771, date_joined=datetime.datetime(2011, 06, 02))
        self.assertFalse(self.gargoyle.is_active('test', user))

        user = User(pk=8771, date_joined=datetime.datetime(2011, 07, 01))
        self.assertTrue(self.gargoyle.is_active('test', user))

        switch.clear_conditions(condition_set=condition_set)
        switch.add_condition(
            condition_set=condition_set,
            field_name='email',
            condition='bob@example.com',
        )

        user = User(pk=8771, email="bob@example.com")
        self.assertTrue(self.gargoyle.is_active('test', user))

        user = User(pk=8771, email="bob2@example.com")
        self.assertFalse(self.gargoyle.is_active('test', user))

        user = User(pk=8771)
        self.assertFalse(self.gargoyle.is_active('test', user))

    def test_exclusions(self):
        condition_set = 'gargoyle.builtins.UserConditionSet(auth.user)'

        switch = Switch.objects.create(
            key='test',
            status=SELECTIVE,
        )
        switch = self.gargoyle['test']

        switch.add_condition(
            condition_set=condition_set,
            field_name='is_staff',
            condition='1',
        )
        switch.add_condition(
            condition_set=condition_set,
            field_name='username',
            condition='foo',
        )
        switch.add_condition(
            condition_set=condition_set,
            field_name='username',
            condition='bar',
            exclude=True
        )

        user = User(pk=0, username='foo', is_staff=False)
        self.assertTrue(self.gargoyle.is_active('test', user))

        user = User(pk=0, username='foo', is_staff=True)
        self.assertTrue(self.gargoyle.is_active('test', user))

        user = User(pk=0, username='bar', is_staff=False)
        self.assertFalse(self.gargoyle.is_active('test', user))

        user = User(pk=0, username='bar', is_staff=True)
        self.assertFalse(self.gargoyle.is_active('test', user))

    def test_only_exclusions(self):
        condition_set = 'gargoyle.builtins.UserConditionSet(auth.user)'

        switch = Switch.objects.create(
            key='test',
            status=SELECTIVE,
        )
        switch = self.gargoyle['test']

        # Intent is that this condition is True for all users *except* if the
        # username == bar
        switch.add_condition(
            condition_set=condition_set,
            field_name='username',
            condition='bar',
            exclude=True
        )

        # username=='foo', so should be active
        user = User(pk=0, username='foo', is_staff=False)
        self.assertTrue(self.gargoyle.is_active('test', user))

        # username=='foo', so should be active
        user = User(pk=0, username='foo', is_staff=True)
        self.assertTrue(self.gargoyle.is_active('test', user))

        # username=='bar', so should not be active
        user = User(pk=0, username='bar', is_staff=False)
        self.assertFalse(self.gargoyle.is_active('test', user))

        # username=='bar', so should not be active
        user = User(pk=0, username='bar', is_staff=True)
        self.assertFalse(self.gargoyle.is_active('test', user))

    def test_decorator_for_user(self):
        condition_set = 'gargoyle.builtins.UserConditionSet(auth.user)'

        switch = Switch.objects.create(
            key='test',
            status=DISABLED,
        )
        switch = self.gargoyle['test']

        @switch_is_active('test')
        def test(request):
            return True

        request = HttpRequest()
        request.user = self.user

        self.assertRaises(Http404, test, request)

        switch.status = SELECTIVE
        switch.save()

        self.assertRaises(Http404, test, request)

        switch.add_condition(
            condition_set=condition_set,
            field_name='username',
            condition='foo',
        )

        self.assertTrue(test(request))

    def test_decorator_for_ip_address(self):
        condition_set = 'gargoyle.builtins.IPAddressConditionSet'

        switch = Switch.objects.create(
            key='test',
            status=DISABLED,
        )
        switch = self.gargoyle['test']

        @switch_is_active('test')
        def test(request):
            return True

        request = HttpRequest()
        request.META['REMOTE_ADDR'] = '192.168.1.1'

        self.assertRaises(Http404, test, request)

        switch.status = SELECTIVE
        switch.save()

        switch.add_condition(
            condition_set=condition_set,
            field_name='ip_address',
            condition='192.168.1.1',
        )

        self.assertTrue(test(request))

        # add in a second condition, so that removing the first one won't kick
        # in the "no conditions returns is_active True for selective switches"
        switch.add_condition(
            condition_set=condition_set,
            field_name='ip_address',
            condition='192.168.1.2',
        )

        switch.remove_condition(
            condition_set=condition_set,
            field_name='ip_address',
            condition='192.168.1.1',
        )

        self.assertRaises(Http404, test, request)

        switch.add_condition(
            condition_set=condition_set,
            field_name='ip_address',
            condition='192.168.1.1',
        )

        self.assertTrue(test(request))

        switch.clear_conditions(
            condition_set=condition_set,
            field_name='ip_address',
        )

        switch.add_condition(
            condition_set=condition_set,
            field_name='percent',
            condition='50-100',
        )

        self.assertTrue(test(request))

        switch.clear_conditions(
            condition_set=condition_set,
        )

        switch.add_condition(
            condition_set=condition_set,
            field_name='percent',
            condition='0-50',
        )

        self.assertRaises(Http404, test, request)

    def test_decorator_with_redirect(self):
        Switch.objects.create(
            key='test',
            status=DISABLED,
        )

        request = HttpRequest()
        request.user = self.user

        @switch_is_active('test', redirect_to='/foo')
        def test(request):
            return HttpResponse()

        response = test(request)
        self.assertTrue(response.status_code, 302)
        self.assertTrue('Location' in response)
        self.assertTrue(response['Location'], '/foo')

        @switch_is_active('test', redirect_to='gargoyle_test_foo')
        def test2(request):
            return HttpResponse()

        response = test2(request)
        self.assertTrue(response.status_code, 302)
        self.assertTrue('Location' in response)
        self.assertTrue(response['Location'], '')

    def test_global(self):
        switch = Switch.objects.create(
            key='test',
            status=DISABLED,
        )
        switch = self.gargoyle['test']

        self.assertFalse(self.gargoyle.is_active('test'))
        self.assertFalse(self.gargoyle.is_active('test', self.user))

        switch.status = GLOBAL
        switch.save()

        self.assertTrue(self.gargoyle.is_active('test'))
        self.assertTrue(self.gargoyle.is_active('test', self.user))

    def test_disable(self):
        switch = Switch.objects.create(key='test')

        switch = self.gargoyle['test']

        switch.status = DISABLED
        switch.save()

        self.assertFalse(self.gargoyle.is_active('test'))

        self.assertFalse(self.gargoyle.is_active('test', self.user))

    def test_deletion(self):
        switch = Switch.objects.create(key='test')

        switch = self.gargoyle['test']

        self.assertTrue('test' in self.gargoyle)

        switch.delete()

        self.assertFalse('test' in self.gargoyle)

    def test_expiration(self):
        switch = Switch.objects.create(key='test')

        switch = self.gargoyle['test']

        switch.status = DISABLED
        switch.save()

        self.assertFalse(self.gargoyle.is_active('test'))

        Switch.objects.filter(key='test').update(value={}, status=GLOBAL)

        # cache shouldn't have expired
        self.assertFalse(self.gargoyle.is_active('test'))

        # lookup cache_key in a modeldict 1.2/1.4 compatible way
        if hasattr(self.gargoyle, 'remote_cache_key'):
            cache_key = self.gargoyle.remote_cache_key
        else:
            cache_key = self.gargoyle.cache_key
        # in memory cache shouldnt have expired
        cache.delete(cache_key)
        self.assertFalse(self.gargoyle.is_active('test'))
        switch.status, switch.value = GLOBAL, {}
        # Ensure post save gets sent
        self.gargoyle._post_save(sender=None, instance=switch, created=False)

        # any request should expire the in memory cache
        self.client.get('/')

        self.assertTrue(self.gargoyle.is_active('test'))

    def test_anonymous_user(self):
        condition_set = 'gargoyle.builtins.UserConditionSet(auth.user)'

        switch = Switch.objects.create(key='test')

        switch = self.gargoyle['test']

        switch.status = SELECTIVE
        switch.save()

        user = AnonymousUser()

        self.assertFalse(self.gargoyle.is_active('test', user))

        switch.add_condition(
            condition_set=condition_set,
            field_name='percent',
            condition='1-10',
        )

        self.assertFalse(self.gargoyle.is_active('test', user))

        switch.clear_conditions(
            condition_set=condition_set,
        )

        self.assertFalse(self.gargoyle.is_active('test', user))

        switch.add_condition(
            condition_set=condition_set,
            field_name='is_anonymous',
            condition='1',
        )

        self.assertTrue(self.gargoyle.is_active('test', user))

        switch.add_condition(
            condition_set=condition_set,
            field_name='percent',
            condition='1-10',
        )

        self.assertTrue(self.gargoyle.is_active('test', user))

    def test_ip_address_internal_ips(self):
        condition_set = 'gargoyle.builtins.IPAddressConditionSet'

        Switch.objects.create(
            key='test',
            status=SELECTIVE,
        )
        switch = self.gargoyle['test']

        request = HttpRequest()
        request.META['REMOTE_ADDR'] = '192.168.1.1'

        self.assertFalse(self.gargoyle.is_active('test', request))

        switch.add_condition(
            condition_set=condition_set,
            field_name='internal_ip',
            condition='1',
        )

        settings.INTERNAL_IPS = ['192.168.1.1']

        self.assertTrue(self.gargoyle.is_active('test', request))

        settings.INTERNAL_IPS = []

        self.assertFalse(self.gargoyle.is_active('test', request))

    def test_ip_address(self):
        condition_set = 'gargoyle.builtins.IPAddressConditionSet'

        switch = Switch.objects.create(
            key='test',
            status=SELECTIVE,
        )
        switch = self.gargoyle['test']

        request = HttpRequest()
        request.META['REMOTE_ADDR'] = '192.168.1.1'

        self.assertFalse(self.gargoyle.is_active('test', request))

        switch.add_condition(
            condition_set=condition_set,
            field_name='ip_address',
            condition='192.168.1.1',
        )

        self.assertTrue(self.gargoyle.is_active('test', request))

        switch.clear_conditions(
            condition_set=condition_set,
        )
        switch.add_condition(
            condition_set=condition_set,
            field_name='ip_address',
            condition='127.0.0.1',
        )

        self.assertFalse(self.gargoyle.is_active('test', request))

        switch.clear_conditions(
            condition_set=condition_set,
        )

        self.assertFalse(self.gargoyle.is_active('test', request))

        switch.add_condition(
            condition_set=condition_set,
            field_name='percent',
            condition='50-100',
        )

        self.assertTrue(self.gargoyle.is_active('test', request))

        # test with mock request
        self.assertTrue(self.gargoyle.is_active('test', self.gargoyle.as_request(ip_address='192.168.1.1')))

        switch.clear_conditions(
            condition_set=condition_set,
        )
        switch.add_condition(
            condition_set=condition_set,
            field_name='percent',
            condition='0-50',
        )
        self.assertFalse(self.gargoyle.is_active('test', request))

        self.assertTrue(self.gargoyle.is_active('test', self.gargoyle.as_request(ip_address='::1')))

        switch.clear_conditions(
            condition_set=condition_set,
        )
        switch.add_condition(
            condition_set=condition_set,
            field_name='percent',
            condition='0-50',
        )
        self.assertFalse(self.gargoyle.is_active('test', request))

    def test_to_dict(self):
        condition_set = 'gargoyle.builtins.IPAddressConditionSet'

        switch = Switch.objects.create(
            label='my switch',
            description='foo bar baz',
            key='test',
            status=SELECTIVE,
        )

        switch.add_condition(
            manager=self.gargoyle,
            condition_set=condition_set,
            field_name='ip_address',
            condition='192.168.1.1',
        )

        result = switch.to_dict(self.gargoyle)

        self.assertTrue('label' in result)
        self.assertEquals(result['label'], 'my switch')

        self.assertTrue('status' in result)
        self.assertEquals(result['status'], SELECTIVE)

        self.assertTrue('description' in result)
        self.assertEquals(result['description'], 'foo bar baz')

        self.assertTrue('key' in result)
        self.assertEquals(result['key'], 'test')

        self.assertTrue('conditions' in result)
        self.assertEquals(len(result['conditions']), 1)

        condition = result['conditions'][0]
        self.assertTrue('id' in condition)
        self.assertEquals(condition['id'], condition_set)
        self.assertTrue('label' in condition)
        self.assertEquals(condition['label'], 'IP Address')
        self.assertTrue('conditions' in condition)
        self.assertEquals(len(condition['conditions']), 1)

        inner_condition = condition['conditions'][0]
        self.assertEquals(len(inner_condition), 4)
        self.assertTrue(inner_condition[0], 'ip_address')
        self.assertTrue(inner_condition[1], '192.168.1.1')
        self.assertTrue(inner_condition[2], '192.168.1.1')
        self.assertFalse(inner_condition[3])

    def test_remove_condition(self):
        condition_set = 'gargoyle.builtins.UserConditionSet(auth.user)'

        switch = Switch.objects.create(
            key='test',
            status=SELECTIVE,
        )
        switch = self.gargoyle['test']

        user5 = User(pk=5, email='5@example.com')

        # inactive if selective with no conditions
        self.assertFalse(self.gargoyle.is_active('test', user5))

        user8771 = User(pk=8771, email='8771@example.com', is_superuser=True)
        switch.add_condition(
            condition_set=condition_set,
            field_name='is_superuser',
            condition='1',
        )
        self.assertTrue(self.gargoyle.is_active('test', user8771))
        # No longer is_active for user5 as we have other conditions
        self.assertFalse(self.gargoyle.is_active('test', user5))

        switch.remove_condition(
            condition_set=condition_set,
            field_name='is_superuser',
            condition='1',
        )

        # back to inactive for everyone with no conditions
        self.assertFalse(self.gargoyle.is_active('test', user5))
        self.assertFalse(self.gargoyle.is_active('test', user8771))

    def test_switch_defaults(self):
        """Test that defaults pulled from GARGOYLE_SWITCH_DEFAULTS.

        Requires SwitchManager to use auto_create.

        """
        self.assertTrue(self.gargoyle.is_active('active_by_default'))
        self.assertFalse(self.gargoyle.is_active('inactive_by_default'))
        self.assertEquals(
            self.gargoyle['inactive_by_default'].label,
            'Default Inactive',
        )
        self.assertEquals(
            self.gargoyle['active_by_default'].label,
            'Default Active',
        )
        active_by_default = self.gargoyle['active_by_default']
        active_by_default.status = DISABLED
        active_by_default.save()
        self.assertFalse(self.gargoyle.is_active('active_by_default'))

    def test_invalid_condition(self):
        condition_set = 'gargoyle.builtins.UserConditionSet(auth.user)'

        switch = Switch.objects.create(
            key='test',
            status=SELECTIVE,
        )
        switch = self.gargoyle['test']

        user5 = User(pk=5, email='5@example.com')

        # inactive if selective with no conditions
        self.assertFalse(self.gargoyle.is_active('test', user5))

        user8771 = User(pk=8771, email='8771@example.com', is_superuser=True)
        switch.add_condition(
            condition_set=condition_set,
            field_name='foo',
            condition='1',
        )
        self.assertFalse(self.gargoyle.is_active('test', user8771))

    def test_inheritance(self):
        condition_set = 'gargoyle.builtins.UserConditionSet(auth.user)'

        # we need a better API for this (model dict isnt cutting it)
        switch = Switch.objects.create(
            key='test',
            status=SELECTIVE,
        )
        switch = self.gargoyle['test']

        switch.add_condition(
            condition_set=condition_set,
            field_name='percent',
            condition='0-50',
        )

        switch = Switch.objects.create(
            key='test:child',
            status=INHERIT,
        )
        switch = self.gargoyle['test']

        user = User(pk=5)
        self.assertTrue(self.gargoyle.is_active('test:child', user))

        user = User(pk=8771)
        self.assertFalse(self.gargoyle.is_active('test:child', user))

        switch = self.gargoyle['test']
        switch.status = DISABLED

        user = User(pk=5)
        self.assertFalse(self.gargoyle.is_active('test:child', user))

        user = User(pk=8771)
        self.assertFalse(self.gargoyle.is_active('test:child', user))

        switch = self.gargoyle['test']
        switch.status = GLOBAL

        user = User(pk=5)
        self.assertTrue(self.gargoyle.is_active('test:child', user))

        user = User(pk=8771)
        self.assertTrue(self.gargoyle.is_active('test:child', user))

    def test_parent_override_child_state(self):
        Switch.objects.create(
            key='test',
            status=DISABLED,
        )

        Switch.objects.create(
            key='test:child',
            status=GLOBAL,
        )

        self.assertFalse(self.gargoyle.is_active('test:child'))

    def test_child_state_is_used(self):
        Switch.objects.create(
            key='test',
            status=GLOBAL,
        )

        Switch.objects.create(
            key='test:child',
            status=DISABLED,
        )

        self.assertFalse(self.gargoyle.is_active('test:child'))

    def test_parent_override_child_condition(self):
        condition_set = 'gargoyle.builtins.UserConditionSet(auth.user)'

        Switch.objects.create(
            key='test',
            status=SELECTIVE,
        )

        parent = self.gargoyle['test']

        parent.add_condition(
            condition_set=condition_set,
            field_name='username',
            condition='bob',
        )

        Switch.objects.create(
            key='test:child',
            status=GLOBAL,
        )

        user = User(username='bob')
        self.assertTrue(self.gargoyle.is_active('test:child', user))

        user = User(username='joe')
        self.assertFalse(self.gargoyle.is_active('test:child', user))

        self.assertFalse(self.gargoyle.is_active('test:child'))

    def test_child_condition_differing_than_parent_loses(self):
        condition_set = 'gargoyle.builtins.UserConditionSet(auth.user)'

        Switch.objects.create(
            key='test',
            status=SELECTIVE,
        )

        parent = self.gargoyle['test']

        parent.add_condition(
            condition_set=condition_set,
            field_name='username',
            condition='bob',
        )

        Switch.objects.create(
            key='test:child',
            status=SELECTIVE,
        )

        child = self.gargoyle['test:child']

        child.add_condition(
            condition_set=condition_set,
            field_name='username',
            condition='joe',
        )

        user = User(username='bob')
        self.assertFalse(self.gargoyle.is_active('test:child', user))

        user = User(username='joe')
        self.assertFalse(self.gargoyle.is_active('test:child', user))

        user = User(username='john')
        self.assertFalse(self.gargoyle.is_active('test:child', user))

        self.assertFalse(self.gargoyle.is_active('test:child'))

    def test_child_condition_including_parent_wins(self):
        condition_set = 'gargoyle.builtins.UserConditionSet(auth.user)'

        Switch.objects.create(
            key='test',
            status=SELECTIVE,
        )

        parent = self.gargoyle['test']

        parent.add_condition(
            condition_set=condition_set,
            field_name='username',
            condition='bob',
        )

        Switch.objects.create(
            key='test:child',
            status=SELECTIVE,
        )

        child = self.gargoyle['test:child']

        child.add_condition(
            condition_set=condition_set,
            field_name='username',
            condition='bob',
        )
        child.add_condition(
            condition_set=condition_set,
            field_name='username',
            condition='joe',
        )

        user = User(username='bob')
        self.assertTrue(self.gargoyle.is_active('test:child', user))

        user = User(username='joe')
        self.assertFalse(self.gargoyle.is_active('test:child', user))

        user = User(username='john')
        self.assertFalse(self.gargoyle.is_active('test:child', user))

        self.assertFalse(self.gargoyle.is_active('test:child'))


class ConstantTest(TestCase):
    def setUp(self):
        self.gargoyle = SwitchManager(Switch, key='key', value='value', instances=True)

    def test_disabled(self):
        self.assertTrue(hasattr(self.gargoyle, 'DISABLED'))
        self.assertEquals(self.gargoyle.DISABLED, 1)

    def test_selective(self):
        self.assertTrue(hasattr(self.gargoyle, 'SELECTIVE'))
        self.assertEquals(self.gargoyle.SELECTIVE, 2)

    def test_global(self):
        self.assertTrue(hasattr(self.gargoyle, 'GLOBAL'))
        self.assertEquals(self.gargoyle.GLOBAL, 3)

    def test_include(self):
        self.assertTrue(hasattr(self.gargoyle, 'INCLUDE'))
        self.assertEquals(self.gargoyle.INCLUDE, 'i')

    def test_exclude(self):
        self.assertTrue(hasattr(self.gargoyle, 'EXCLUDE'))
        self.assertEquals(self.gargoyle.EXCLUDE, 'e')


class MockRequestTest(TestCase):
    def setUp(self):
        self.gargoyle = SwitchManager(Switch, key='key', value='value', instances=True)

    def test_empty_attrs(self):
        req = MockRequest()
        self.assertEquals(req.META['REMOTE_ADDR'], None)
        self.assertEquals(req.user.__class__, AnonymousUser)

    def test_ip(self):
        req = MockRequest(ip_address='127.0.0.1')
        self.assertEquals(req.META['REMOTE_ADDR'], '127.0.0.1')
        self.assertEquals(req.user.__class__, AnonymousUser)

    def test_user(self):
        user = User.objects.create(username='foo', email='foo@example.com')
        req = MockRequest(user=user)
        self.assertEquals(req.META['REMOTE_ADDR'], None)
        self.assertEquals(req.user, user)

    def test_as_request(self):
        user = User.objects.create(username='foo', email='foo@example.com')

        req = self.gargoyle.as_request(user=user, ip_address='127.0.0.1')

        self.assertEquals(req.META['REMOTE_ADDR'], '127.0.0.1')
        self.assertEquals(req.user, user)


class TemplateTagTest(TestCase):
    urls = 'tests.urls'

    def setUp(self):
        self.user = User.objects.create(username='foo', email='foo@example.com')
        self.gargoyle = SwitchManager(Switch, key='key', value='value', instances=True)
        self.gargoyle.register(UserConditionSet(User))

    def test_simple(self):
        Switch.objects.create(
            key='test',
            status=GLOBAL,
        )

        template = Template("""
            {% load gargoyle_tags %}
            {% ifswitch test %}
            hello world!
            {% endifswitch %}
        """)
        rendered = template.render(Context())

        self.assertTrue('hello world!' in rendered)

    def test_else(self):
        Switch.objects.create(
            key='test',
            status=DISABLED,
        )

        template = Template("""
            {% load gargoyle_tags %}
            {% ifswitch test %}
            hello world!
            {% else %}
            foo bar baz
            {% endifswitch %}
        """)
        rendered = template.render(Context())

        self.assertTrue('foo bar baz' in rendered)
        self.assertFalse('hello world!' in rendered)

    def test_with_request(self):
        condition_set = 'gargoyle.builtins.UserConditionSet(auth.user)'

        switch = Switch.objects.create(
            key='test',
            status=SELECTIVE,
        )
        switch = self.gargoyle['test']

        switch.add_condition(
            condition_set=condition_set,
            field_name='percent',
            condition='0-50',
        )

        request = HttpRequest()
        request.user = self.user

        template = Template("""
            {% load gargoyle_tags %}
            {% ifswitch test %}
            hello world!
            {% else %}
            foo bar baz
            {% endifswitch %}
        """)
        rendered = template.render(Context({'request': request}))

        self.assertFalse('foo bar baz' in rendered)
        self.assertTrue('hello world!' in rendered)

    def test_missing_name(self):
        self.assertRaises(TemplateSyntaxError, Template, """
            {% load gargoyle_tags %}
            {% ifswitch %}
            hello world!
            {% endifswitch %}
        """)

    def test_with_custom_objects(self):
        condition_set = 'gargoyle.builtins.UserConditionSet(auth.user)'

        switch = Switch.objects.create(
            key='test',
            status=SELECTIVE,
        )
        switch = self.gargoyle['test']

        switch.add_condition(
            condition_set=condition_set,
            field_name='percent',
            condition='0-50',
        )

        request = HttpRequest()
        request.user = self.user

        # Pass in request.user explicitly.
        template = Template("""
            {% load gargoyle_tags %}
            {% ifswitch test request.user %}
            hello world!
            {% else %}
            foo bar baz
            {% endifswitch %}
        """)
        rendered = template.render(Context({'request': request}))

        self.assertFalse('foo bar baz' in rendered)
        self.assertTrue('hello world!' in rendered)


class HostConditionSetTest(TestCase):
    def setUp(self):
        self.gargoyle = SwitchManager(Switch, key='key', value='value', instances=True, auto_create=True)
        self.gargoyle.register(HostConditionSet())

    def test_simple(self):
        condition_set = 'gargoyle.builtins.HostConditionSet'

        # we need a better API for this (model dict isnt cutting it)
        switch = Switch.objects.create(
            key='test',
            status=SELECTIVE,
        )
        switch = self.gargoyle['test']

        self.assertFalse(self.gargoyle.is_active('test'))

        switch.add_condition(
            condition_set=condition_set,
            field_name='hostname',
            condition=socket.gethostname(),
        )

        self.assertTrue(self.gargoyle.is_active('test'))


class SwitchContextManagerTest(TestCase):
    def setUp(self):
        self.gargoyle = SwitchManager(Switch, key='key', value='value', instances=True, auto_create=True)

    def test_as_decorator(self):
        switch = self.gargoyle['test']
        switch.status = DISABLED

        @switches(self.gargoyle, test=True)
        def test():
            return self.gargoyle.is_active('test')

        self.assertTrue(test())
        self.assertEquals(self.gargoyle['test'].status, DISABLED)

        switch.status = GLOBAL
        switch.save()

        @switches(self.gargoyle, test=False)
        def test2():
            return self.gargoyle.is_active('test')

        self.assertFalse(test2())
        self.assertEquals(self.gargoyle['test'].status, GLOBAL)

    def test_context_manager(self):
        switch = self.gargoyle['test']
        switch.status = DISABLED

        with switches(self.gargoyle, test=True):
            self.assertTrue(self.gargoyle.is_active('test'))

        self.assertEquals(self.gargoyle['test'].status, DISABLED)

        switch.status = GLOBAL
        switch.save()

        with switches(self.gargoyle, test=False):
            self.assertFalse(self.gargoyle.is_active('test'))

        self.assertEquals(self.gargoyle['test'].status, GLOBAL)


class CommandAddSwitchTestCase(TestCase):

    def setUp(self):
        self.gargoyle = SwitchManager(Switch, key='key', value='value', instances=True, auto_create=True)

    def test_requires_single_arg(self):
        too_few_too_many = [
            [],
            ['one', 'two'],
        ]
        for args in too_few_too_many:
            command = AddSwitchCmd()

            self.assertRaises(CommandError, command.handle, *args)

    def test_add_switch_default_status(self):
        self.assertFalse('switch_default' in self.gargoyle)

        call_command('add_switch', 'switch_default')

        self.assertTrue('switch_default' in self.gargoyle)
        self.assertEqual(GLOBAL, self.gargoyle['switch_default'].status)

    def test_add_switch_with_status(self):
        self.assertFalse('switch_disabled' in self.gargoyle)

        call_command('add_switch', 'switch_disabled', status=DISABLED)

        self.assertTrue('switch_disabled' in self.gargoyle)
        self.assertEqual(DISABLED, self.gargoyle['switch_disabled'].status)

    def test_update_switch_status_disabled(self):
        Switch.objects.create(key='test', status=GLOBAL)
        self.assertEqual(GLOBAL, self.gargoyle['test'].status)

        call_command('add_switch', 'test', status=DISABLED)

        self.assertEqual(DISABLED, self.gargoyle['test'].status)

    def test_update_switch_status_to_default(self):
        Switch.objects.create(key='test', status=DISABLED)
        self.assertEqual(DISABLED, self.gargoyle['test'].status)

        call_command('add_switch', 'test')

        self.assertEqual(GLOBAL, self.gargoyle['test'].status)


class CommandRemoveSwitchTestCase(TestCase):

    def setUp(self):
        self.gargoyle = SwitchManager(Switch, key='key', value='value', instances=True, auto_create=True)

    def test_requires_single_arg(self):
        too_few_too_many = [
            [],
            ['one', 'two'],
        ]
        for args in too_few_too_many:
            command = RemoveSwitchCmd()

            self.assertRaises(CommandError, command.handle, *args)

    def test_removes_switch(self):
        Switch.objects.create(key='test')
        self.assertTrue('test' in self.gargoyle)

        call_command('remove_switch', 'test')

        self.assertFalse('test' in self.gargoyle)

    def test_remove_non_switch_doesnt_error(self):
        self.assertFalse('idontexist' in self.gargoyle)

        call_command('remove_switch', 'idontexist')

        self.assertFalse('idontexist' in self.gargoyle)


class HelpersTestCase(TestCase):

    def setUp(self):
        self.old_gargoyle_helpers = sys.modules.pop('gargoyle.helpers')
        del gargoyle.helpers

        self.old_json = sys.modules.pop('json')
        sys.modules['json'] = None

    def tearDown(self):
        if self.old_json is not None:
            sys.modules['json'] = self.old_json
        else:
            del sys.modules['json']
        sys.modules['gargoyle.helpers'] = self.old_gargoyle_helpers
        gargoyle.helpers = self.old_gargoyle_helpers

    def test_json_compat(self):
        # fake json module so test works even in python 2.5
        mock_json = object()
        sys.modules['json'] = mock_json

        # reload helpers module to get json reimported
        from gargoyle.helpers import json
        self.assertEqual(json, mock_json)

    def test_simplejson_compat(self):
        # reload helpers module to get json reimported
        from gargoyle.helpers import json
        self.assertEqual(json, simplejson)

########NEW FILE########
__FILENAME__ = urls
"""
:copyright: (c) 2010 DISQUS.
:license: Apache License 2.0, see LICENSE for more details.
"""

from django.conf.urls.defaults import *


def foo(request):
    from django.http import HttpResponse
    return HttpResponse()

urlpatterns = patterns('',
    url('', foo, name='gargoyle_test_foo'),
)

########NEW FILE########
