__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Overseer documentation build configuration file, created by
# sphinx-quickstart on Wed Feb  2 17:28:01 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Overseer'
copyright = u'2011, DISQUS'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.2.0'
# The full version, including alpha/beta/rc tags.
release = version

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Overseerdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Overseer.tex', u'Overseer Documentation',
   u'DISQUS', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'overseer', u'Overseer Documentation',
     [u'DISQUS'], 1)
]

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
from django.core.management import execute_manager
try:
    import settings # Assumed to be in the same directory.
except ImportError, exc:
    import sys
    import traceback
    sys.stderr.write("Error: Can't find the file 'settings.py' in the directory containing %r. It appears you've customized things.\nYou'll have to run django-admin.py, passing it your settings module.\n(If the file settings.py does indeed exist, it's causing an ImportError somehow.)\n" % __file__)
    sys.stderr.write("\nFor debugging purposes, the exception was:\n\n")
    traceback.print_exc()
    sys.exit(1)

if __name__ == "__main__":
    execute_manager(settings)

########NEW FILE########
__FILENAME__ = settings
import os.path

OVERSEER_ROOT = os.path.dirname(__import__('overseer').__file__)

DEBUG = True

DATABASE_ENGINE = 'sqlite3'
DATABASE_NAME = 'overseer.sqlite'

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.admin',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',

    'devserver',
    'overseer',
    'south',
)

ADMIN_MEDIA_PREFIX = '/admin/media/'

ROOT_URLCONF = 'urls'

DEVSERVER_MODULES = ()

TEMPLATE_DIRS = (
    # Put strings here, like "/home/html/django_templates" or "C:/www/django/templates".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
    os.path.join(OVERSEER_ROOT, 'templates', 'overseer'),
)

TEMPLATE_CONTEXT_PROCESSORS = (
    'django.contrib.auth.context_processors.auth',
    'overseer.context_processors.default',
)

try:
    from local_settings import *
except ImportError:
    pass
########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *

from django.contrib import admin

admin.autodiscover()

def handler500(request):
    """
    500 error handler.

    Templates: `500.html`
    Context: None
    """
    from django.template import Context, loader
    from django.http import HttpResponseServerError
    from overseer.context_processors import default
    import logging
    import sys
    try:
        context = default(request)
    except Exception, e:
        logging.error(e, exc_info=sys.exc_info(), extra={'request': request})
        context = {}
    
    context['request'] = request
    
    t = loader.get_template('500.html') # You need to create a 500.html template.
    return HttpResponseServerError(t.render(Context(context)))

urlpatterns = patterns('',
    url(r'^admin/', include(admin.site.urls)),
    url(r'^', include('overseer.urls', namespace='overseer')),
)
########NEW FILE########
__FILENAME__ = admin
"""
overseer.admin
~~~~~~~~~~~~~~

:copyright: (c) 2011 DISQUS.
:license: Apache License 2.0, see LICENSE for more details.
"""

from django import forms
from django.contrib import admin

from overseer import conf
from overseer.models import Service, Event, EventUpdate, Subscription

class SubscriptionInline(admin.StackedInline):
    model = Subscription.services.through
    extra = 1

class ServiceAdmin(admin.ModelAdmin):
    list_display = ('name', 'status', 'order', 'date_updated')
    search_fields = ('name', 'description')
    prepopulated_fields = {'slug': ('name',)}
    inlines = [SubscriptionInline]

class EventForm(forms.ModelForm):
    if conf.TWITTER_ACCESS_TOKEN and conf.TWITTER_ACCESS_SECRET:
        post_to_twitter = forms.BooleanField(required=False, label="Post to Twitter", help_text="This will send a tweet with a brief summary, the permalink to the event (if BASE_URL is defined), and the hashtag of #status for EACH update you add below.")

    class Meta:
        model = EventUpdate

class EventUpdateInline(admin.StackedInline):
    model = EventUpdate
    extra = 1

class EventAdmin(admin.ModelAdmin):
    form = EventForm
    list_display = ('date_created', 'description', 'status', 'date_updated')
    search_fields = ('description', 'message')
    list_filter = ('services',)
    inlines = [EventUpdateInline]

    def save_formset(self, request, form, formset, change):
        instances = formset.save()
        if 'post_to_twitter' in form.cleaned_data and form.cleaned_data['post_to_twitter']:
            for obj in instances:
                obj.event.post_to_twitter(obj.get_message())

class EventUpdateAdmin(admin.ModelAdmin):
    list_display = ('date_created', 'message', 'status', 'event')
    search_fields = ('message',)

class SubscriptionAdmin(admin.ModelAdmin):
    fields = ('email', 'services',)

admin.site.register(Service, ServiceAdmin)
admin.site.register(Event, EventAdmin)
admin.site.register(EventUpdate, EventUpdateAdmin)
admin.site.register(Subscription, SubscriptionAdmin)

########NEW FILE########
__FILENAME__ = conf
"""
overseer.conf
~~~~~~~~~~~~~

:copyright: (c) 2011 DISQUS.
:license: Apache License 2.0, see LICENSE for more details.
"""

from django.conf import settings

base = getattr(settings, 'OVERSEER_CONFIG', {})

TITLE = base.get('TITLE', 'Service Status')
NAME = base.get('NAME', 'Service Status')
MEDIA_PREFIX = base.get('MEDIA_PREFIX', None)

TWITTER_CONSUMER_KEY = base.get('TWITTER_CONSUMER_KEY')
TWITTER_CONSUMER_SECRET = base.get('TWITTER_CONSUMER_SECRET')

# Run manage.py overseer_twitter_auth to generate an access key
TWITTER_ACCESS_TOKEN = base.get('TWITTER_ACCESS_TOKEN')
TWITTER_ACCESS_SECRET = base.get('TWITTER_ACCESS_SECRET')

BASE_URL = base.get('BASE_URL')

ALLOW_SUBSCRIPTIONS = base.get('ALLOW_SUBSCRIPTIONS', False)

FROM_EMAIL = base.get('FROM_EMAIL')
########NEW FILE########
__FILENAME__ = context_processors
"""
overseer.context_processors
~~~~~~~~~~~~~~~~~~~~~~~~~~~

:copyright: (c) 2011 DISQUS.
:license: Apache License 2.0, see LICENSE for more details.
"""

from django.core.urlresolvers import reverse

import overseer
from overseer import conf

def default(request):
    return {
        'request': request,
        'OVERSEER_TITLE': conf.TITLE,
        'OVERSEER_NAME': conf.NAME,
        'OVERSEER_MEDIA_PREFIX': (conf.MEDIA_PREFIX or reverse('overseer:media')).rstrip('/'),
        'OVERSEER_VERSION': overseer.VERSION,
        'OVERSEER_ALLOW_SUBSCRIPTIONS': conf.ALLOW_SUBSCRIPTIONS,
    }
########NEW FILE########
__FILENAME__ = forms
"""
overseer.forms
~~~~~~~~~~~~~~

:copyright: (c) 2011 DISQUS.
:license: Apache License 2.0, see LICENSE for more details.
"""

from django import forms

from overseer.models import Service, Subscription, UnverifiedSubscription

class BaseSubscriptionForm(forms.ModelForm):
    services = forms.ModelMultipleChoiceField(queryset=Service.objects.all(), widget=forms.CheckboxSelectMultiple())

    class Meta:
        fields = ('services',)
        model = Subscription

class NewSubscriptionForm(BaseSubscriptionForm):
    email = forms.EmailField(widget=forms.TextInput(attrs={'placeholder': 'you@example.com'}))
    
    class Meta:
        fields = ('email', 'services',)
        model = UnverifiedSubscription

    def clean_email(self):
        value = self.cleaned_data.get('email')
        if value:
            value = value.lower()
        return value            

class UpdateSubscriptionForm(BaseSubscriptionForm):
    unsubscribe = forms.BooleanField(required=False)
    services = forms.ModelMultipleChoiceField(queryset=Service.objects.all(), widget=forms.CheckboxSelectMultiple(), required=False)

########NEW FILE########
__FILENAME__ = overseer_twitter_auth
"""
overseer.management.commands.overseer_twitter_auth
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:copyright: (c) 2011 DISQUS.
:license: Apache License 2.0, see LICENSE for more details.
"""

from cStringIO import StringIO

import sys
import webbrowser

from django.core.management.base import BaseCommand

from overseer import conf

class Command(BaseCommand):
    def handle(self, **options):
        import urlparse
        import oauth2 as oauth

        consumer_key = conf.TWITTER_CONSUMER_KEY
        consumer_secret = conf.TWITTER_CONSUMER_SECRET

        request_token_url = 'http://twitter.com/oauth/request_token'
        access_token_url = 'http://twitter.com/oauth/access_token'
        authorize_url = 'http://twitter.com/oauth/authorize'

        consumer = oauth.Consumer(consumer_key, consumer_secret)
        client = oauth.Client(consumer)

        # Step 1: Get a request token. This is a temporary token that is used for 
        # having the user authorize an access token and to sign the request to obtain 
        # said access token.

        resp, content = client.request(request_token_url, "GET")
        if resp['status'] != '200':
            raise Exception("Invalid response %s." % resp['status'])

        request_token = dict(urlparse.parse_qsl(content))

        print "Request Token:"
        print "    - oauth_token        = %s" % request_token['oauth_token']
        print "    - oauth_token_secret = %s" % request_token['oauth_token_secret']
        print 

        # Step 2: Redirect to the provider. Since this is a CLI script we do not 
        # redirect. In a web application you would redirect the user to the URL
        # below.

        print "We are opening a new browser window to authorize your account"
        print 
        webbrowser.open("%s?oauth_token=%s" % (authorize_url, request_token['oauth_token']))
        print 

        # After the user has granted access to you, the consumer, the provider will
        # redirect you to whatever URL you have told them to redirect to. You can 
        # usually define this in the oauth_callback argument as well.
        oauth_verifier = raw_input('Enter your PIN number once authorized: ')

        # Step 3: Once the consumer has redirected the user back to the oauth_callback
        # URL you can request the access token the user has approved. You use the 
        # request token to sign this request. After this is done you throw away the
        # request token and use the access token returned. You should store this 
        # access token somewhere safe, like a database, for future use.
        token = oauth.Token(request_token['oauth_token'],
            request_token['oauth_token_secret'])
        token.set_verifier(oauth_verifier)
        client = oauth.Client(consumer, token)

        resp, content = client.request(access_token_url, "POST")
        access_token = dict(urlparse.parse_qsl(content))

        print 
        print "Configuration changes:"
        print 
        print "    'TWITTER_ACCESS_TOKEN':  '%s'," % access_token['oauth_token']
        print "    'TWITTER_ACCESS_SECRET': '%s'," % access_token['oauth_token_secret']
        print
        print "Add the above values to your OVERSEER_CONFIG setting" 
        print

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'Service'
        db.create_table('overseer_service', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=128)),
            ('slug', self.gf('django.db.models.fields.SlugField')(unique=True, max_length=128, db_index=True)),
            ('description', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
            ('status', self.gf('django.db.models.fields.SmallIntegerField')(default=0)),
            ('order', self.gf('django.db.models.fields.IntegerField')(default=0)),
            ('date_created', self.gf('django.db.models.fields.DateTimeField')(default=datetime.datetime.now)),
            ('date_updated', self.gf('django.db.models.fields.DateTimeField')(default=datetime.datetime.now)),
        ))
        db.send_create_signal('overseer', ['Service'])

        # Adding model 'Event'
        db.create_table('overseer_event', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('status', self.gf('django.db.models.fields.SmallIntegerField')(default=0)),
            ('peak_status', self.gf('django.db.models.fields.SmallIntegerField')(default=0)),
            ('description', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
            ('message', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
            ('date_created', self.gf('django.db.models.fields.DateTimeField')(default=datetime.datetime.now)),
            ('date_updated', self.gf('django.db.models.fields.DateTimeField')(default=datetime.datetime.now)),
        ))
        db.send_create_signal('overseer', ['Event'])

        # Adding M2M table for field services on 'Event'
        db.create_table('overseer_event_services', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('event', models.ForeignKey(orm['overseer.event'], null=False)),
            ('service', models.ForeignKey(orm['overseer.service'], null=False))
        ))
        db.create_unique('overseer_event_services', ['event_id', 'service_id'])

        # Adding model 'EventUpdate'
        db.create_table('overseer_eventupdate', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('event', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['overseer.Event'])),
            ('status', self.gf('django.db.models.fields.SmallIntegerField')()),
            ('message', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
            ('date_created', self.gf('django.db.models.fields.DateTimeField')(default=datetime.datetime.now)),
        ))
        db.send_create_signal('overseer', ['EventUpdate'])


    def backwards(self, orm):
        
        # Deleting model 'Service'
        db.delete_table('overseer_service')

        # Deleting model 'Event'
        db.delete_table('overseer_event')

        # Removing M2M table for field services on 'Event'
        db.delete_table('overseer_event_services')

        # Deleting model 'EventUpdate'
        db.delete_table('overseer_eventupdate')


    models = {
        'overseer.event': {
            'Meta': {'object_name': 'Event'},
            'date_created': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'date_updated': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'description': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'message': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'peak_status': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'services': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['overseer.Service']", 'symmetrical': 'False'}),
            'status': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'})
        },
        'overseer.eventupdate': {
            'Meta': {'object_name': 'EventUpdate'},
            'date_created': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'event': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['overseer.Event']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'message': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'status': ('django.db.models.fields.SmallIntegerField', [], {})
        },
        'overseer.service': {
            'Meta': {'ordering': "('order', 'name')", 'object_name': 'Service'},
            'date_created': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'date_updated': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'description': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'order': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '128', 'db_index': 'True'}),
            'status': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'})
        }
    }

    complete_apps = ['overseer']

########NEW FILE########
__FILENAME__ = 0002_auto__add_subscription__add_unverifiedsubscription
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'Subscription'
        db.create_table('overseer_subscription', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('ident', self.gf('django.db.models.fields.CharField')(unique=True, max_length=32)),
            ('date_created', self.gf('django.db.models.fields.DateTimeField')(default=datetime.datetime.now)),
            ('email', self.gf('django.db.models.fields.EmailField')(unique=True, max_length=75)),
        ))
        db.send_create_signal('overseer', ['Subscription'])

        # Adding M2M table for field services on 'Subscription'
        db.create_table('overseer_subscription_services', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('subscription', models.ForeignKey(orm['overseer.subscription'], null=False)),
            ('service', models.ForeignKey(orm['overseer.service'], null=False))
        ))
        db.create_unique('overseer_subscription_services', ['subscription_id', 'service_id'])

        # Adding model 'UnverifiedSubscription'
        db.create_table('overseer_unverifiedsubscription', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('ident', self.gf('django.db.models.fields.CharField')(unique=True, max_length=32)),
            ('date_created', self.gf('django.db.models.fields.DateTimeField')(default=datetime.datetime.now)),
            ('email', self.gf('django.db.models.fields.EmailField')(max_length=75)),
        ))
        db.send_create_signal('overseer', ['UnverifiedSubscription'])

        # Adding M2M table for field services on 'UnverifiedSubscription'
        db.create_table('overseer_unverifiedsubscription_services', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('unverifiedsubscription', models.ForeignKey(orm['overseer.unverifiedsubscription'], null=False)),
            ('service', models.ForeignKey(orm['overseer.service'], null=False))
        ))
        db.create_unique('overseer_unverifiedsubscription_services', ['unverifiedsubscription_id', 'service_id'])


    def backwards(self, orm):
        
        # Deleting model 'Subscription'
        db.delete_table('overseer_subscription')

        # Removing M2M table for field services on 'Subscription'
        db.delete_table('overseer_subscription_services')

        # Deleting model 'UnverifiedSubscription'
        db.delete_table('overseer_unverifiedsubscription')

        # Removing M2M table for field services on 'UnverifiedSubscription'
        db.delete_table('overseer_unverifiedsubscription_services')


    models = {
        'overseer.event': {
            'Meta': {'object_name': 'Event'},
            'date_created': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'date_updated': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'description': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'message': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'peak_status': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'services': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['overseer.Service']", 'symmetrical': 'False'}),
            'status': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'})
        },
        'overseer.eventupdate': {
            'Meta': {'object_name': 'EventUpdate'},
            'date_created': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'event': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['overseer.Event']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'message': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'status': ('django.db.models.fields.SmallIntegerField', [], {})
        },
        'overseer.service': {
            'Meta': {'ordering': "('order', 'name')", 'object_name': 'Service'},
            'date_created': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'date_updated': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'description': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'order': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '128', 'db_index': 'True'}),
            'status': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'})
        },
        'overseer.subscription': {
            'Meta': {'object_name': 'Subscription'},
            'date_created': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'unique': 'True', 'max_length': '75'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'ident': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'}),
            'services': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['overseer.Service']", 'symmetrical': 'False'})
        },
        'overseer.unverifiedsubscription': {
            'Meta': {'object_name': 'UnverifiedSubscription'},
            'date_created': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'ident': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'}),
            'services': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['overseer.Service']", 'symmetrical': 'False'})
        }
    }

    complete_apps = ['overseer']

########NEW FILE########
__FILENAME__ = models
"""
overseer.models
~~~~~~~~~~~~~~~

A service's status should be:

- red if any(updates affecting service) are red
- yellow if any(updates affecting service) are yellow
- green if all(updates affecting service) are green

:copyright: (c) 2011 DISQUS.
:license: Apache License 2.0, see LICENSE for more details.
"""

import datetime
import oauth2
import urlparse
import uuid
import warnings

from django.core.mail import send_mail
from django.core.urlresolvers import reverse
from django.db import models
from django.db.models.signals import post_save, m2m_changed

from overseer import conf
from overseer.utils import SimpleTwitterClient

STATUS_CHOICES = (
    (0, 'No Problems'),
    (1, 'Some Issues'),
    (2, 'Unavailable'),
)

SUBSCRIPTION_EMAIL_TEMPLATE = """
A service's status has changed on %(name)s:

%(message)s

This update affects the following:

%(affects)s

----

To change your subscription settings, please visit %(sub_url)s

""".strip()

class Service(models.Model):
    """
    A ``Service`` can describe any part of your architecture. Each 
    service can have many events, in which the last event should be shown
    (unless the status is 'No Problems').
    """
    name = models.CharField(max_length=128)
    slug = models.SlugField(max_length=128, unique=True)
    description = models.TextField(blank=True, null=True)
    status = models.SmallIntegerField(choices=STATUS_CHOICES, editable=False, default=0)
    order = models.IntegerField(default=0)
    date_created = models.DateTimeField(default=datetime.datetime.now, editable=False)
    date_updated = models.DateTimeField(default=datetime.datetime.now, editable=False)
    
    class Meta:
        ordering = ('order', 'name')

    def __unicode__(self):
        return self.name

    @models.permalink
    def get_absolute_url(self):
        return ('overseer:service', [self.slug], {})

    @classmethod
    def handle_event_m2m_save(cls, sender, instance, action, reverse, model, pk_set, **kwargs):
        if not action.startswith('post_'):
            return
        if not pk_set:
            return
        
        if model is Service:
            for service in Service.objects.filter(pk__in=pk_set):
                service.update_from_event(instance)
        else:
            for event in Event.objects.filter(pk__in=pk_set):
                instance.update_from_event(event)

    @classmethod
    def handle_event_save(cls, instance, **kwargs):
        for service in instance.services.all():
            service.update_from_event(instance)

    def update_from_event(self, event):
        update_qs = Service.objects.filter(pk=self.pk)
        if event.date_updated > self.date_updated:
            # If the update is newer than the last update to the self
            update_qs.filter(date_updated__lt=event.date_updated)\
                     .update(date_updated=event.date_updated)
            self.date_updated = event.date_updated

        if event.status > self.status:
            # If our status more critical (higher) than the current
            # self status, update to match the current
            update_qs.filter(status__lt=event.status)\
                     .update(status=event.status)
            self.status = event.status

        elif event.status < self.status:
            # If no more events match the current self status, let's update
            # it to the current status
            if not Event.objects.filter(services=self, status=self.status)\
                                .exclude(pk=event.pk).exists():
                update_qs.filter(status__gt=event.status)\
                         .update(status=event.status)
                self.status = event.status

    def get_message(self):
        if self.status == 0:
            return 'This service is operating as expected.'
        elif self.status == 1:
            return 'This service is experiencing some issues.'
        elif self.status == 2:
            return 'This service may be unavailable.'
        return ''

def join_with_and(values):
    values = list(values)
    if len(values) == 2:
        return ' and '.join(values)
    elif len(values) > 2:
        return '%s, and %s' % (', '.join(values[:-1]), values[-1])
    return values[0]

class EventBase(models.Model):
    class Meta:
        abstract = True

    def get_message(self):
        if self.message:
            return self.message
        elif self.status == 0:
            return '%s operating as expected.' % join_with_and(a[1] for a in self.get_services())
        elif self.status == 1:
            return 'Experiencing some issues with %s.' % join_with_and(a[1] for a in self.get_services())
        elif self.status == 2:
            return '%s may be unavailable.' % join_with_and(a[1] for a in self.get_services())
        return ''

class Event(EventBase):
    """
    An ``Event`` is a collection of updates related to one event.
    
    - ``message`` stores the last message from ``StatusUpdate`` for this event.
    """
    services = models.ManyToManyField(Service)
    status = models.SmallIntegerField(choices=STATUS_CHOICES, editable=False, default=0)
    peak_status = models.SmallIntegerField(choices=STATUS_CHOICES, editable=False, default=0)
    description = models.TextField(null=True, blank=True, help_text='We will auto fill the description from the first event message if not set')
    message = models.TextField(null=True, blank=True, editable=False)
    date_created = models.DateTimeField(default=datetime.datetime.now, editable=False)
    date_updated = models.DateTimeField(default=datetime.datetime.now, editable=False)

    def __unicode__(self):
        return u"%s on %s" % (self.date_created, '; '.join(self.services.values_list('name', flat=True)))

    @models.permalink
    def get_absolute_url(self):
        return ('overseer:event', [self.pk], {})

    def get_services(self):
        return self.services.values_list('slug', 'name')

    def get_duration(self):
        return self.date_updated - self.date_created

    def post_to_twitter(self, message=None):
        """Update twitter status, i.e., post a tweet"""

        consumer = oauth2.Consumer(key=conf.TWITTER_CONSUMER_KEY,
                                  secret=conf.TWITTER_CONSUMER_SECRET)
        token = oauth2.Token(key=conf.TWITTER_ACCESS_TOKEN, secret=conf.TWITTER_ACCESS_SECRET)
        client = SimpleTwitterClient(consumer=consumer, token=token)

        if not message:
            message = self.get_message()
        
        hash_tag = '#status'
        
        if conf.BASE_URL:
            permalink = urlparse.urljoin(conf.BASE_URL, reverse('overseer:event_short', args=[self.pk]))
            if len(message) + len(permalink) + len(hash_tag) > 138:
                message = '%s.. %s %s' % (message[:140-4-len(hash_tag)-len(permalink)], permalink, hash_tag)
            else:
                message = '%s %s %s' % (message, permalink, hash_tag) 
        else:
            if len(message) + len(hash_tag) > 139:
                message = '%s.. %s' % (message[:140-3-len(hash_tag)], hash_tag)
            else:
                message = '%s %s' % (message, hash_tag)
                
        return client.update_status(message)

    @classmethod
    def handle_update_save(cls, instance, created, **kwargs):
        event = instance.event

        if created:
            is_latest = True
        elif EventUpdate.objects.filter(event=event).order_by('-date_created')\
                                .values_list('event', flat=True)[0] == event.pk:
            is_latest = True
        else:
            is_latest = False

        if is_latest:
            update_kwargs = dict(
                status=instance.status,
                date_updated=instance.date_created,
                message=instance.message
            )

            if not event.description:
                update_kwargs['description'] = instance.message
                
            if not event.peak_status or event.peak_status < instance.status:
                update_kwargs['peak_status'] = instance.status

            Event.objects.filter(pk=event.pk).update(**update_kwargs)

            for k, v in update_kwargs.iteritems():
                setattr(event, k, v)

            # Without sending the signal Service will fail to update
            post_save.send(sender=Event, instance=event, created=False)

class EventUpdate(EventBase):
    """
    An ``EventUpdate`` contains a single update to an ``Event``. The latest update
    will always be reflected within the event, carrying over it's ``status`` and ``message``.
    """
    event = models.ForeignKey(Event)
    status = models.SmallIntegerField(choices=STATUS_CHOICES)
    message = models.TextField(null=True, blank=True)
    date_created = models.DateTimeField(default=datetime.datetime.now, editable=False)

    def __unicode__(self):
        return unicode(self.date_created)

    def get_services(self):
        return self.event.services.values_list('slug', 'name')

class BaseSubscription(models.Model):
    ident = models.CharField(max_length=32, unique=True)
    date_created = models.DateTimeField(default=datetime.datetime.now, editable=False)
    services = models.ManyToManyField(Service)

    class Meta:
        abstract = True

    def __unicode__(self):
        return self.email

    def save(self, *args, **kwargs):
        if not self.ident:
            self.ident = uuid.uuid4().hex
        super(BaseSubscription, self).save(*args, **kwargs)

class Subscription(BaseSubscription):
    """
    Represents an email subscription.
    """
    email = models.EmailField(unique=True)

    @classmethod
    def handle_update_save(cls, instance, created, **kwargs):
        if not created:
            return

        if not conf.ALLOW_SUBSCRIPTIONS:
            return

        if not conf.FROM_EMAIL:
            # TODO: grab system default
            warnings.warn('Configuration error with Oveerseer: FROM_EMAIL is not set')
            return
        
        if not conf.BASE_URL:
            warnings.warn('Configuration error with Oveerseer: BASE_URL is not set')
            return
        
        services = list(instance.event.services.all())
        affects = '\n'.join('- %s' % s.name for s in services)
        message = instance.get_message()
        
        for email, ident in cls.objects.filter(services__in=services)\
                                       .values_list('email', 'ident')\
                                       .distinct():
            # send email
            body = SUBSCRIPTION_EMAIL_TEMPLATE % dict(
                sub_url = urlparse.urljoin(conf.BASE_URL, reverse('overseer:update_subscription', args=[ident])),
                message = message,
                affects = affects,
                name = conf.NAME,
            )
            send_mail('Status Change on %s' % conf.NAME, body, conf.FROM_EMAIL, [email],
                      fail_silently=True)

class UnverifiedSubscription(BaseSubscription):
    """
    A temporary store for unverified subscriptions.
    """
    email = models.EmailField()

post_save.connect(Service.handle_event_save, sender=Event)
post_save.connect(Event.handle_update_save, sender=EventUpdate)
m2m_changed.connect(Service.handle_event_m2m_save, sender=Event.services.through)
post_save.connect(Subscription.handle_update_save, sender=EventUpdate)
########NEW FILE########
__FILENAME__ = overseer_helpers
"""
overseer.templatetags.overseer_helpers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:copyright: (c) 2011 DISQUS.
:license: Apache License 2.0, see LICENSE for more details.
"""

import datetime

from django import template
from django.template.defaultfilters import stringfilter

register = template.Library()

@register.filter
def timesince(value):
    from django.template.defaultfilters import timesince
    if not value:
        return 'Never'
    if value < datetime.datetime.now() - datetime.timedelta(days=5):
        return value.date()
    value = (' '.join(timesince(value).split(' ')[0:2])).strip(',')
    if value == '0 minutes':
        return 'Just now'
    if value == '1 day':
        return 'Yesterday'
    return value + ' ago'

@register.filter(name='truncatechars')
@stringfilter
def truncatechars(value, arg):
    """
    Truncates a string after a certain number of chars.

    Argument: Number of chars to truncate after.
    """
    try:
        length = int(arg)
    except ValueError: # Invalid literal for int().
        return value # Fail silently.
    if len(value) > length:
        return value[:length] + '...'
    return value
truncatechars.is_safe = True

@register.filter
def duration(value):
    if isinstance(value, datetime.timedelta):
        value = value.days * 24 * 3600 + value.seconds
    hours, minutes, seconds = 0, 0, 0
    if value > 3600:
        hours = value / 3600
        value = value % 3600
    if value > 60:
        minutes = value / 60
        value = value % 60
    seconds = value
    if hours:
        return '%s hours' % (hours,)
    if minutes:
        return '%s minutes' % (minutes,)
    if seconds:
        return '%s seconds' % (seconds,)
    return 'n/a'
########NEW FILE########
__FILENAME__ = tests
"""
overseer.tests.tests
~~~~~~~~~~~~~~~~~~~~

:copyright: (c) 2011 DISQUS.
:license: Apache License 2.0, see LICENSE for more details.
"""

from django.core import mail
from django.test import TestCase

from overseer import conf
from overseer.models import Service, Event, EventUpdate, Subscription

class OverseerTestCase(TestCase):
    urls = 'overseer.tests.urls'
    
    def setUp(self):
        self.service = Service.objects.create(
            name='Test',
            slug='test',
        )
        conf.FROM_EMAIL = 'foo@example.com'
        conf.BASE_URL = 'http://example.com'
    
    def refresh(self, inst):
        return inst.__class__.objects.get(pk=inst.pk)

    def test_subscriptions(self):
        conf.ALLOW_SUBSCRIPTIONS = True
        
        sub = Subscription.objects.create(
            email='foo@example.com',
        )
        sub.services = [self.service]
        
        event = Event.objects.create()
        event.services.add(self.service)
        
        EventUpdate.objects.create(
            event=event,
            status=2,
        )
    
        self.assertEquals(len(mail.outbox), 1)

        msg = mail.outbox[0]

        self.assertEquals(len(msg.to), 1)
        self.assertEquals(msg.to[0], 'foo@example.com')

        body = msg.body

        self.assertTrue('Test may be unavailable' in body)
        self.assertTrue('http://example.com/subscription/%s/' % sub.ident in body)
        
        conf.ALLOW_SUBSCRIPTIONS = False

    def test_cascading_saves(self):
        event = Event.objects.create()
        event.services.add(self.service)
        
        service = self.refresh(self.service)
        
        self.assertEquals(service.status, 0)
        self.assertEquals(event.status, 0)
        self.assertEquals(service.date_updated, event.date_updated)
        
        update = EventUpdate.objects.create(
            event=event,
            status=2,
            message='holy omg wtf',
        )
        
        service = self.refresh(self.service)
        event = self.refresh(event)
        
        self.assertEquals(service.status, update.status)
        self.assertEquals(event.status, update.status)
        self.assertEquals(event.description, update.message)
        self.assertEquals(event.message, update.message)
        self.assertEquals(event.date_updated, update.date_created)
        self.assertEquals(service.date_updated, update.date_created)

########NEW FILE########
__FILENAME__ = urls
"""
overseer.tests.urls
~~~~~~~~~~~~~~~~~~~

:copyright: (c) 2011 DISQUS.
:license: Apache License 2.0, see LICENSE for more details.
"""

from django.conf.urls.defaults import *

from django.contrib import admin

admin.autodiscover()

def handler500(request):
    """
    500 error handler.

    Templates: `500.html`
    Context: None
    """
    from django.template import Context, loader
    from django.http import HttpResponseServerError
    from overseer.context_processors import default
    import logging
    import sys
    try:
        context = default(request)
    except Exception, e:
        logging.error(e, exc_info=sys.exc_info(), extra={'request': request})
        context = {}
    
    context['request'] = request
    
    t = loader.get_template('500.html') # You need to create a 500.html template.
    return HttpResponseServerError(t.render(Context(context)))

urlpatterns = patterns('',
    url(r'^admin/', include(admin.site.urls)),
    url(r'^', include('overseer.urls', namespace='overseer')),
)
########NEW FILE########
__FILENAME__ = urls
"""
overseer.urls
~~~~~~~~~~~~~

:copyright: (c) 2011 DISQUS.
:license: Apache License 2.0, see LICENSE for more details.
"""

from django.conf.urls.defaults import *

import os.path

urlpatterns = patterns('',
    url(r'^media/(?P<path>.+)?$', 'django.views.static.serve', {
        'document_root': os.path.join(os.path.dirname(__file__), 'media'),
        'show_indexes': True
    }, name='media'),

    url(r'^$', 'overseer.views.index', name='index'),
    url(r'^service/(?P<slug>[^/]+)/$', 'overseer.views.service', name='service'),
    url(r'^service/(?P<slug>[^/]+)/last-event/$', 'overseer.views.last_event', name='last_event'),
    url(r'^event/(?P<id>[^/]+)/$', 'overseer.views.event', name='event'),
    url(r'^(?P<id>\d+)$', 'django.views.generic.simple.redirect_to', {'url': 'event/%(id)s/'}, name='event_short'),
    url(r'^subscribe/$', 'overseer.views.create_subscription', name='create_subscription'),
    url(r'^subscription/(?P<ident>[^/]+)/$', 'overseer.views.update_subscription', name='update_subscription'),
    url(r'^subscription/(?P<ident>[^/]+)/verify/$', 'overseer.views.verify_subscription', name='verify_subscription'),
)
########NEW FILE########
__FILENAME__ = utils
"""
overseer.utils
~~~~~~~~~~~~~~

:copyright: (c) 2011 DISQUS.
:license: Apache License 2.0, see LICENSE for more details.
"""

import httplib
import oauth2

# example client using httplib with headers
class SimpleTwitterClient(oauth2.Client):

    def __init__(self, server='api.twitter.com', port=httplib.HTTP_PORT, request_token_url='',
                 access_token_url='', authorization_url='', consumer=None, token=None):
        self.server = server
        self.port = port
        self.request_token_url = request_token_url
        self.access_token_url = access_token_url
        self.authorization_url = authorization_url
        self.connection = httplib.HTTPConnection("%s:%d" % (self.server, self.port))
        self.consumer = consumer
        self.token = token

    def fetch_request_token(self, oauth_request):
        # via headers
        # -> OAuthToken
        self.connection.request(oauth_request.http_method, self.request_token_url, headers=oauth_request.to_header()) 
        response = self.connection.getresponse()
        return oauth2.Token.from_string(response.read())

    def fetch_access_token(self, oauth_request):
        # via headers
        # -> OAuthToken
        self.connection.request(oauth_request.http_method, self.access_token_url, headers=oauth_request.to_header()) 
        response = self.connection.getresponse()
        return oauth2.Token.from_string(response.read())

    def authorize_token(self, oauth_request):
        # via url
        # -> typically just some okay response
        self.connection.request(oauth_request.http_method, oauth_request.to_url()) 
        response = self.connection.getresponse()
        return response.read()

    def update_status(self, status):
        # via post body
        # -> some protected resources
        headers = {'Content-Type' :'application/x-www-form-urlencoded'}
        params = {
            'status': status,
        }
        oauth_request = oauth2.Request.from_consumer_and_token(
            consumer=self.consumer, token=self.token, http_method='POST',
            http_url='http://%s/1/statuses/update.json' % self.server, parameters=params)
        oauth_request.sign_request(oauth2.SignatureMethod_HMAC_SHA1(), self.consumer, self.token)
        
        self.connection.request('POST', '/1/statuses/update.json',
                                body=oauth_request.to_postdata(), headers=headers)
        response = self.connection.getresponse()
        return response, response.read()
########NEW FILE########
__FILENAME__ = views
"""
overseer.views
~~~~~~~~~~~~~~

:copyright: (c) 2011 DISQUS.
:license: Apache License 2.0, see LICENSE for more details.
"""

import datetime
import urlparse

from django.core.context_processors import csrf
from django.core.mail import send_mail
from django.core.urlresolvers import reverse
from django.db.models.query import Q
from django.http import HttpResponseRedirect
from django.views.decorators.csrf import csrf_protect

from overseer import context_processors, conf
from overseer.forms import NewSubscriptionForm, UpdateSubscriptionForm
from overseer.models import Service, Event, Subscription, UnverifiedSubscription

def requires(value_or_callable):
    def wrapped(func):
        def call(request, *args, **kwargs):
            if callable(value_or_callable):
                result = value_or_callable(request)
            else:
                result = value_or_callable
            
            if not result:
                return HttpResponseRedirect(reverse('overseer:index'))
            
            return func(request, *args, **kwargs)
        return call
    return wrapped

def respond(template, context={}, request=None, **kwargs):
    "Calls render_to_response with a RequestConext"
    from django.http import HttpResponse
    from django.template import RequestContext
    from django.template.loader import render_to_string    

    if request:
        default = context_processors.default(request)
        default.update(context)
    else:
        default = context.copy()
    
    rendered = render_to_string(template, default, context_instance=request and RequestContext(request) or None)
    return HttpResponse(rendered, **kwargs)

def index(request):
    "Displays a list of all services and their current status."
    
    service_list = Service.objects.all()
    
    event_list = list(Event.objects\
                             .filter(Q(status__gt=0) | Q(date_updated__gte=datetime.datetime.now()-datetime.timedelta(days=1)))\
                             .order_by('-date_created')[0:6])
    
    if event_list:
        latest_event, event_list = event_list[0], event_list[1:]
    else:
        latest_event = None
    
    return respond('overseer/index.html', {
        'service_list': service_list,
        'event_list': event_list,
        'latest_event': latest_event,
    }, request)

def service(request, slug):
    "Displays a list of all services and their current status."
    
    try:
        service = Service.objects.get(slug=slug)
    except Service.DoesNotExist:
        return HttpResponseRedirect(reverse('overseer:index'))
        
    event_list = service.event_set.order_by('-date_created')
    
    return respond('overseer/service.html', {
        'service': service,
        'event_list': event_list,
    }, request)

def event(request, id):
    "Displays a list of all services and their current status."
    
    try:
        evt = Event.objects.get(pk=id)
    except Event.DoesNotExist:
        return HttpResponseRedirect(reverse('overseer:index'))
    
    update_list = list(evt.eventupdate_set.order_by('-date_created'))
    
    return respond('overseer/event.html', {
        'event': evt,
        'update_list': update_list,
    }, request)

def last_event(request, slug):
    "Displays a list of all services and their current status."
    
    try:
        service = Service.objects.get(slug=slug)
    except Service.DoesNotExist:
        return HttpResponseRedirect(reverse('overseer:index'))
    
    try:
        evt = service.event_set.order_by('-date_created')[0]
    except IndexError:
        return HttpResponseRedirect(service.get_absolute_url())
    
    return event(request, evt.pk)

@requires(conf.ALLOW_SUBSCRIPTIONS)
@csrf_protect
def update_subscription(request, ident):
    "Shows subscriptions options for a verified subscriber."
    
    try:
        subscription = Subscription.objects.get(ident=ident)
    except Subscription.DoesNotExist:
        return respond('overseer/invalid_subscription_token.html', {}, request)

    if request.POST:
        form = UpdateSubscriptionForm(request.POST, instance=subscription)
        if form.is_valid():
            if form.cleaned_data['unsubscribe']:
                subscription.delete()
        
                return respond('overseer/unsubscribe_confirmed.html', {
                    'email': subscription.email,
                })
            else:
                form.save()

            return HttpResponseRedirect(request.get_full_path())
    else:
        form = UpdateSubscriptionForm(instance=subscription)
        
    context = csrf(request)
    context.update({
        'form': form,
        'subscription': subscription,
        'service_list': Service.objects.all(),
    })

    return respond('overseer/update_subscription.html', context, request)

@requires(conf.ALLOW_SUBSCRIPTIONS)
@csrf_protect
def create_subscription(request):
    "Shows subscriptions options for a new subscriber."
    
    if request.POST:
        form = NewSubscriptionForm(request.POST)
        if form.is_valid():
            unverified = form.save()

            body = """Please confirm your email address to subscribe to status updates from %(name)s:\n\n%(link)s""" % dict(
                name=conf.NAME,
                link=urlparse.urljoin(conf.BASE_URL, reverse('overseer:verify_subscription', args=[unverified.ident]))
            )

            # Send verification email
            from_mail = conf.FROM_EMAIL
            if not from_mail:
                from_mail = 'overseer@%s' % request.get_host().split(':', 1)[0]
            
            send_mail('Confirm Subscription', body, from_mail, [unverified.email],
                      fail_silently=True)
            
            # Show success page
            return respond('overseer/create_subscription_complete.html', {
                'subscription': unverified,
            }, request)
    else:
        form = NewSubscriptionForm()

    context = csrf(request)
    context.update({
        'form': form,
        'service_list': Service.objects.all(),
    })

    return respond('overseer/create_subscription.html', context, request)

@requires(conf.ALLOW_SUBSCRIPTIONS)
def verify_subscription(request, ident):
    """
    Verifies an unverified subscription and create or appends
    to an existing subscription.
    """
    
    try:
        unverified = UnverifiedSubscription.objects.get(ident=ident)
    except UnverifiedSubscription.DoesNotExist:
        return respond('overseer/invalid_subscription_token.html', {}, request)
    
    subscription = Subscription.objects.get_or_create(email=unverified.email, defaults={
        'ident': unverified.ident,
    })[0]

    subscription.services = unverified.services.all()
    
    unverified.delete()
    
    return respond('overseer/subscription_confirmed.html', {
        'subscription': subscription,
    }, request)
########NEW FILE########
__FILENAME__ = runtests
#!/usr/bin/env python
"""
runtests
~~~~~~~~

:copyright: (c) 2011 DISQUS.
:license: Apache License 2.0, see LICENSE for more details.
"""

import sys
from os.path import dirname, abspath

from django.conf import settings

if not settings.configured:
    settings.configure(
        DATABASE_ENGINE='sqlite3',
        INSTALLED_APPS=[
            'django.contrib.auth',
            'django.contrib.admin',
            'django.contrib.contenttypes',
            'django.contrib.sessions',
            'django.contrib.sites',

            'overseer',
        ],
        ROOT_URLCONF='',
        DEBUG=False,
    )

from django.test.simple import run_tests

def runtests(*test_args):
    if not test_args:
        test_args = ['overseer']
    parent = dirname(abspath(__file__))
    sys.path.insert(0, parent)
    failures = run_tests(test_args, verbosity=1, interactive=True)
    sys.exit(failures)

if __name__ == '__main__':
    runtests(*sys.argv[1:])
########NEW FILE########
