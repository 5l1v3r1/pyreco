This model is based on the arducopter mode from James Goppert, and
adapted for use in the ArduPilot test system. Many thanks to all who
have contributed!

This model is based on the Rascal110 from FlightGear, and adapted for
use in the ArduPilot test system. Many thanks to all who have
contributed!





This information has not been updated for the Rascal, please ignore, we
are still at pre-pre-pre-alpha with this model!

PIPER J3 CUB PERFORMANCE DATA
=============================

[This information is copied from the 1946 J3C-65 owner's handbook.]

                             FLYING HINTS

The Piper Cub Special represents more than 15 years of diligent
aircraft engineering and manufacturing experience.  Its simplicity of
design and construction, its low operating and maintenance costs, its
inherent stability, ruggedness, and its outstanding safety and ease of
flying, have made it the most popular airplane in aviation history.
The Piper Cub Special is the time-tested product of millions of hours
of flying under all conceivable conditions both in the military and in
peace time.

There are hints on starting, flying, stopping, and other related
topics that are important to the owner who wants to conserve his
airplane -- keep it in maximum airworthy condition -- and enjoy a full
measure of flying satisfaction.


First, each pilot should become familiar enough with his Piper Cub
Special that he can accomplish a satisfactory pre-flight inspection.
This check is simple and requires only a few minutes.  See Section IX
for check list.  Daily check of airplane prior to flight should be the
first in a number of safe flying habits the pilot should acquire.


A. BEFORE STARTING ENGINE

(1) Make routine check of gasoline supply.  Visible fuel gauge is
integral part of gas tank cap; it will not show number of gallons but
will show proportion of fuel in tank by length of rod which extends
upward from cap.  A full tank of 12 U.S. gallons will be indicated by
11 inches of rod extending beyond cap.  Keep gas gauge rod clean and
smooth with crocus cloth for accuracy and freedom of movement.

(2) Check oil level in engine sump by removing oil cap and gauge.  Oil
stick should indicate oil level up to index mark of 4 quarts.

(3) Check freedom of movement of flight and engine controls.


B. STARTING ENGINE

(1) Chock wheels, or have occupant who is familiar with controls set
brakes in cabin.

(2) Ignition switch OFF.  Verify.

(3) Set throttle approximately 1/10 open.

(4) Push fuel shut-off ON.

(5) Turn propeller through several times.

(6) Turn ignition switch ON.

(7) Start engine by pulling propeller through with a snap.

CAUTION -- Always handle propeller as if switch were "ON."  Stand as
far in front of propeller as possible.  Use both hands and grasp one
blad approximately midway from tip.  Do not overgrasp blade.  Do not
wear long, loose clothing.  Make sure footing is sure to preclude
possibility of feet slipping.

(8) If engine does not start, turn switch OFF.  Turn primer knob to
unlock, pull out, pump three or four times, then reseat primer and
lock by turning in opposite direction.  In extremely cold weather a
few strokes of the primer as the engine starts will enable it to keep
running.  NOTE -- Avoid excessive priming as it causes raw gasoline to
wash lubricating oil from engine cylinder walls.  Do not prime warm
engine.

(9) Repeat starting procedures 6, 7.

(10) If engine loads up and refuses to start, turn ignition switch
"OFF,", open throttle wide and turn propeller through backwards
several times to unload excessive gas mixture in cylinders.  Then
close throttle and repeat starting procedure.


C. ENGINE WARM-UP

(1) As soon as engine starts, advance throttle slightly to idle at 700
R.P.M.  Check engine instruments.  If oil pressure gauge does not
indicate pressure within 30 seconds, stop engine immediately, check
and correct trouble before any further operation.  Oil temperature
during operating should not rise above 200° F. and oil pressure should
not fall below 30 pounds.  With engine warm, idling speed should be
550-600 R.P.M.

(2) Rev engine up to 2100 R.P.M. on both magnetos.  Switch to LEFT and
RIGHT magnetos.  R.P.M. drop should not be over 75 R.P.M.  CAUTION
--Do not operate engine on either single magneto for more than 30
seconds at a time, as this tends to foul the non-operating spark plugs
in the ignition circuit of the magneto that is switched off.


D. STOPPING ENGINE

(1) Never cut switch immediately after landing as this causes engine
to cool too rapidly.

(2) Idle engine, especially in high temperature operating conditions,
for several minutes.  It is advisable to switch to each magneto for 30
second intervals to allow gradual cooling of engine.  This helps to
prevent overheating of spark plug insulators and will lessen tendency
for "after-firing."

(3) Check for carburetor heat OFF during idling.


E. TAXIING

(1) Open throttle to start airplane in motion; then close throttle to
a setting sufficient to keep airplane rolling.  Do not keep throttle
advanced so that it is necessary to control taxi speed of airplane
with brakes.  This causes unnecessary wear and tear on brakes and
tires.

(2) Taxi slowly (speed of a fast walk) controlling direction with
rudder which is connected to a steerable tail wheel.  Use brakes only
for positive, precision ground control when necessary.

(3) Taxi upwind with stick back; downwind with stick foreward.  When
ground winds are in excess of 15 M.P.H., turn into wind using ailerons
in direction of turn; apply ailerons away from the turn when turning
downwind.  This procedure helps to prevent the wind "picking up" a
wing during windy, gusty conditions.  Always make ground turns slowly.


F. GENERAL FLYING

(1) For takeoff use full throttle, heading into wind.  Airplane loaded
will become airborne at approximately 39 M.P.H.  Best climb speed is
an indicated 55 M.P.H.

(2) Indicated R.P.M. for cruising speed of 73 M.P.H. is 2150.
Take-off R.P.M. is 2300.  Do not fly at full throttle over 3 minutes.

(3) Use CARBURETOR AIR HEAT when engine runs "rough" and tachometer
shows drop in R.P.M. which may be due to ice forming in carburetor.
Tachometer should recover to within 50 R.P.M. below normal when using
carburetor heat.  Push heater to "OFF" position, and if icing
condition has been cleared, R.P.M. should return to normal.  Continued
use of carburetor heat will only cause increased fuel consumption and
loss of power.

(4) Maximum permissible diving speed is 122 M.P.H.


G. APPROACH AND LANDING

(1) Push carburetor heat ON prior to throttling back for glide, or for
any other flight maneuver.

(2) Glide between 50-60 M.P.H. depending upon loading of airplane and
gust conditions.

NOTE -- "Clear" engine by opening throttle gently, every 200-250 feet
of descent during a long glide so that engine temperature will be
maintained.

Throttle action on the part of the pilot should be smooth and gentle
at all times.


H. PARKING AND MOORING

(1) After termination of flight, enter flying time in aircraft and
engine log books.

(2) Turn ignition and fuel OFF.

(3) Chcok the wheels of airplane.

(4) If airplane is not to be flown for some time, it should be
hangared or tied down.  Use good quality 1/2" - 5/8" diameter rope.
Secure to lift assist handle at aft end of fuselage; also at upper end
of both front wing lift struts where they attach to wing.  Make sure
that rope passes between aileron cable and lift strut.  Mooring ropes,
when airplane is tied down, should have no slack.

(5) Lock aileron and elevator controls by wrapping front seat belt
completely around rear control stick, tighten and buckle.

(6) Under excessively wind conditions, airplane should be tailed into
wind for mooring.




[Here is my older information.]

These are the only numbers I could find.  They are for a J3 Cub with
an 85HP engine rather than 65 hp, so some adjustments may be
necessary.  The source is

  http://www.evergreenfs.com/planedata.htm


Speeds
------
  Best rate of climb (Vy):   65 mph (57 kt)
  Best angle of climb (Vx):  55 mph (48 kt)
  Cruise:                    70 mph (61 kt)
  Never-exceed (Vne):       122 mph (106 kt)
  Best Glide (Vglide):       60 mph (52 kt)
  Stall (Vs):                38 mph (33 kt)
  Maneuvering (Va):          70 mph (61 kt)
  Approach:               50-60 mph (44-52 kt)

Power
-----
  Take off:                  full
  Climb:                     50 rpm below full
  Cruise:                    2300 rpm
  Approach:                  1200 rpm
  Practice stalls:           1200 rpm

Distances
---------
  Take-off:                  450-800 ft
  Landing:                   200-800 ft

Fuel
----
  Total fuel:                12 gal US
  Usable fuel:               12 gal US
  Grade:                     80/87
  GPH:                       5 gal US/hr

========================================================================
    DYNAMIC LINK LIBRARY : APMPlannerXplanes Project Overview
========================================================================

AppWizard has created this APMPlannerXplanes DLL for you.  

This file contains a summary of what you will find in each of the files that
make up your APMPlannerXplanes application.

APMPlannerXplanes.vcxproj
    This is the main project file for VC++ projects generated using an Application Wizard. 
    It contains information about the version of Visual C++ that generated the file, and 
    information about the platforms, configurations, and project features selected with the
    Application Wizard.

APMPlannerXplanes.vcxproj.filters
    This is the filters file for VC++ projects generated using an Application Wizard. 
    It contains information about the association between the files in your project 
    and the filters. This association is used in the IDE to show grouping of files with
    similar extensions under a specific node (for e.g. ".cpp" files are associated with the
    "Source Files" filter).

APMPlannerXplanes.cpp
    This is the main DLL source file.

APMPlannerXplanes.h
    This file contains a class declaration.

AssemblyInfo.cpp
	Contains custom attributes for modifying assembly metadata.

/////////////////////////////////////////////////////////////////////////////
Other notes:

AppWizard uses "TODO:" to indicate parts of the source code you
should add to or customize.

/////////////////////////////////////////////////////////////////////////////

ï»¿
to use saved settings
set
CommsBase.SettingsOption
ï»¿
to use the thememanager
set
            Controls.MainSwitcher.ApplyTheme += MissionPlanner.Utilities.ThemeManager.ApplyThemeTo;
            MissionPlanner.Controls.InputBox.ApplyTheme += MissionPlanner.Utilities.ThemeManager.ApplyThemeTo;

using System;
using System.IO;
using System.Collections;
using com.utils.bundle;

/// <summary>
/// This class was first written by Drew Noakes in Java.
///
/// This is public domain software - that is, you can do whatever you want
/// with it, and include it software that is licensed under the GNU or the
/// BSD license, or whatever other licence you choose, including proprietary
/// closed source licenses.  I do ask that you leave this lcHeader in tact.
///
/// If you make modifications to this code that you think would benefit the
/// wider community, please send me a copy and I'll post it on my site.
///
/// If you make use of this code, Drew Noakes will appreciate hearing 
/// about it: <a href="mailto:drew@drewnoakes.com">drew@drewnoakes.com</a>
///
/// Latest Java version of this software kept at 
/// <a href="http://drewnoakes.com">http://drewnoakes.com/</a>
///
/// The C# class was made by Ferret Renaud: 
/// <a href="mailto:renaud91@free.fr">renaud91@free.fr</a>
/// If you find a bug in the C# code, feel free to mail me.
/// </summary>
namespace com.drew.metadata
{
	/// <summary>
	/// This abstract class represent the mother class of all tag descriptor.
	/// </summary>
	[Serializable]
	public abstract class AbstractTagDescriptor 
	{
        /// <summary>
        /// Contains all commons words.
        /// </summary>
        protected static readonly IResourceBundle BUNDLE = ResourceBundleFactory.CreateDefaultBundle("Commons");

		protected AbstractDirectory directory;

		/// <summary>
		/// Constructor of the object
		/// </summary>
		/// <param name="aDirectory">a directory</param>
		public AbstractTagDescriptor(AbstractDirectory aDirectory) : base()
		{
            this.directory = aDirectory;
		}

		/// <summary>
		/// Returns a descriptive value of the the specified tag for this image. 
		/// Where possible, known values will be substituted here in place of the raw tokens actually 
		/// kept in the Exif segment. 
		/// If no substitution is available, the value provided by GetString(int) will be returned.
		/// This and GetString(int) are the only 'get' methods that won't throw an exception.
		/// </summary>
		/// <param name="aTagType">the tag to find a description for</param>
		/// <returns>a description of the image'str value for the specified tag, or null if the tag hasn't been defined.</returns>
		public abstract string GetDescription(int aTagType);
	}
}

using System;
using com.drew.metadata;

/// <summary>
/// This class was first written by Drew Noakes in Java.
///
/// This is public domain software - that is, you can do whatever you want
/// with it, and include it software that is licensed under the GNU or the
/// BSD license, or whatever other licence you choose, including proprietary
/// closed source licenses.  I do ask that you leave this lcHeader in tact.
///
/// If you make modifications to this code that you think would benefit the
/// wider community, please send me a copy and I'll post it on my site.
///
/// If you make use of this code, Drew Noakes will appreciate hearing 
/// about it: <a href="mailto:drew@drewnoakes.com">drew@drewnoakes.com</a>
///
/// Latest Java version of this software kept at 
/// <a href="http://drewnoakes.com">http://drewnoakes.com/</a>
///
/// The C# class was made by Ferret Renaud: 
/// <a href="mailto:renaud91@free.fr">renaud91@free.fr</a>
/// If you find a bug in the C# code, feel free to mail me.
/// </summary>
namespace com.drew.metadata.exif
{
	/// <summary>
	/// Tag descriptor for a Canon camera
	/// </summary>
	public class CanonDescriptor : AbstractTagDescriptor 
	{
		/// <summary>
		/// Constructor of the object
		/// </summary>
        /// <param name="aDirectory">a directory</param>
		public CanonDescriptor(AbstractDirectory aDirectory) : base(aDirectory)
		{
		}

		/// <summary>
		/// Returns a descriptive value of the the specified tag for this image. 
		/// Where possible, known values will be substituted here in place of the raw tokens actually 
		/// kept in the Exif segment. 
		/// If no substitution is available, the value provided by GetString(int) will be returned.
		/// This and GetString(int) are the only 'get' methods that won't throw an exception.
		/// </summary>
		/// <param name="aTagType">the tag to find a description for</param>
		/// <returns>a description of the image'str value for the specified tag, or null if the tag hasn't been defined.</returns>
		public override string GetDescription(int aTagType) 
		{
			switch(aTagType) 
			{
                case CanonDirectory.TAG_CANON_STATE1_MACRO_MODE:
                    return this.GetMacroModeDescription();
                case CanonDirectory.TAG_CANON_STATE1_SELF_TIMER_DELAY:
                    return this.GetSelfTimerDelayDescription();
                case CanonDirectory.TAG_CANON_STATE1_FLASH_MODE:
                    return this.GetFlashModeDescription();
                case CanonDirectory.TAG_CANON_STATE1_CONTINUOUS_DRIVE_MODE:
                    return this.GetContinuousDriveModeDescription();
                case CanonDirectory.TAG_CANON_STATE1_FOCUS_MODE_1:
                    return this.GetFocusMode1Description();
                case CanonDirectory.TAG_CANON_STATE1_IMAGE_SIZE:
                    return this.GetImageSizeDescription();
                case CanonDirectory.TAG_CANON_STATE1_EASY_SHOOTING_MODE:
                    return this.GetEasyShootingModeDescription();
                case CanonDirectory.TAG_CANON_STATE1_CONTRAST:
                    return this.GetContrastDescription();
                case CanonDirectory.TAG_CANON_STATE1_SATURATION:
                    return this.GetSaturationDescription();
                case CanonDirectory.TAG_CANON_STATE1_SHARPNESS:
                    return this.GetSharpnessDescription();
                case CanonDirectory.TAG_CANON_STATE1_ISO:
                    return this.GetIsoDescription();
                case CanonDirectory.TAG_CANON_STATE1_METERING_MODE:
                    return this.GetMeteringModeDescription();
                case CanonDirectory.TAG_CANON_STATE1_AF_POINT_SELECTED:
                    return this.GetAfPointSelectedDescription();
                case CanonDirectory.TAG_CANON_STATE1_EXPOSURE_MODE:
                    return this.GetExposureModeDescription();
                case CanonDirectory.TAG_CANON_STATE1_LONG_FOCAL_LENGTH:
                    return this.GetLongFocalLengthDescription();
                case CanonDirectory.TAG_CANON_STATE1_SHORT_FOCAL_LENGTH:
                    return this.GetShortFocalLengthDescription();
                case CanonDirectory.TAG_CANON_STATE1_FOCAL_UNITS_PER_MM:
                    return this.GetFocalUnitsPerMillimetreDescription();
                case CanonDirectory.TAG_CANON_STATE1_FLASH_DETAILS:
                    return this.GetFlashDetailsDescription();
                case CanonDirectory.TAG_CANON_STATE1_FOCUS_MODE_2:
                    return this.GetFocusMode2Description();
                case CanonDirectory.TAG_CANON_STATE2_WHITE_BALANCE:
                    return this.GetWhiteBalanceDescription();
                case CanonDirectory.TAG_CANON_STATE2_AF_POINT_USED:
                    return this.GetAfPointUsedDescription();
                case CanonDirectory.TAG_CANON_STATE2_FLASH_BIAS:
                    return this.GetFlashBiasDescription();

                case CanonDirectory.TAG_CANON_STATE1_FLASH_ACTIVITY:
                    return this.GetFlashActivityDescription();
                case CanonDirectory.TAG_CANON_STATE1_FOCUS_TYPE:
                    return this.GetFocusTypeDescription();
                case CanonDirectory.TAG_CANON_STATE1_DIGITAL_ZOOM:
                    return this.GetDigitalZoomDescription();
                case CanonDirectory.TAG_CANON_STATE1_QUALITY:
                    return this.GetQualityDescription();
                case CanonDirectory.TAG_CANON_CUSTOM_FUNCTION_LONG_EXPOSURE_NOISE_REDUCTION:
                    return this.GetLongExposureNoiseReductionDescription();
                case CanonDirectory.TAG_CANON_CUSTOM_FUNCTION_SHUTTER_AUTO_EXPOSURE_LOCK_BUTTONS:
                    return this.GetShutterAutoExposureLockButtonDescription();
                case CanonDirectory.TAG_CANON_CUSTOM_FUNCTION_MIRROR_LOCKUP:
                    return this.GetMirrorLockupDescription();
                case CanonDirectory.TAG_CANON_CUSTOM_FUNCTION_TV_AV_AND_EXPOSURE_LEVEL:
                    return this.GetTvAndAvExposureLevelDescription();
                case CanonDirectory.TAG_CANON_CUSTOM_FUNCTION_AF_ASSIST_LIGHT:
                    return this.GetAutoFocusAssistLightDescription();
                case CanonDirectory.TAG_CANON_CUSTOM_FUNCTION_SHUTTER_SPEED_IN_AV_MODE:
                    return this.GetShutterSpeedInAvModeDescription();
                case CanonDirectory.TAG_CANON_CUSTOM_FUNCTION_BRACKETTING:
                    return this.GetAutoExposureBrackettingSequenceAndAutoCancellationDescription();
                case CanonDirectory.TAG_CANON_CUSTOM_FUNCTION_SHUTTER_CURTAIN_SYNC:
                    return this.GetShutterCurtainSyncDescription();
                case CanonDirectory.TAG_CANON_CUSTOM_FUNCTION_AF_STOP:
                    return this.GetLensAutoFocusStopButtonDescription();
                case CanonDirectory.TAG_CANON_CUSTOM_FUNCTION_FILL_FLASH_REDUCTION:
                    return this.GetFillFlashReductionDescription();
                case CanonDirectory.TAG_CANON_CUSTOM_FUNCTION_MENU_BUTTON_RETURN:
                    return this.GetMenuButtonReturnPositionDescription();
                case CanonDirectory.TAG_CANON_CUSTOM_FUNCTION_SET_BUTTON_FUNCTION:
                    return this.GetSetButtonFunctionWhenShootingDescription();
                case CanonDirectory.TAG_CANON_CUSTOM_FUNCTION_SENSOR_CLEANING:
                    return this.GetSensorCleaningDescription();
                default: 
					return base.directory.GetString(aTagType);
			}
		}

        /// <summary>
        /// Returns the menu button return position Description. 
        /// </summary>
        /// <returns>the menu button return position Description.</returns>
        private string GetMenuButtonReturnPositionDescription()
        {
            if (!base.directory.ContainsTag(CanonDirectory.TAG_CANON_CUSTOM_FUNCTION_MENU_BUTTON_RETURN))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(CanonDirectory.TAG_CANON_CUSTOM_FUNCTION_MENU_BUTTON_RETURN);
            switch (lcVal)
            {
                case 0: return BUNDLE["TOP"];
                case 1: return BUNDLE["PREVIOUS_VOLATILE"];
                case 2: return BUNDLE["PREVIOUS"];
                default: return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Returns the set button function when shooting Description. 
        /// </summary>
        /// <returns>the set button function when shooting Description.</returns>
        private string GetSetButtonFunctionWhenShootingDescription()
        {
            if (!base.directory.ContainsTag(CanonDirectory.TAG_CANON_CUSTOM_FUNCTION_SET_BUTTON_FUNCTION))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(CanonDirectory.TAG_CANON_CUSTOM_FUNCTION_SET_BUTTON_FUNCTION);
            switch (lcVal)
            {
                case 0: return BUNDLE["NOT_ASSIGNED"];
                case 1: return BUNDLE["CHANGE_QUALITY"];
                case 2: return BUNDLE["CHANGE_ISO_SPEED"];
                case 3: return BUNDLE["SELECT_PARAMETERS"];
                default: return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Returns the sensor cleaning Description. 
        /// </summary>
        /// <returns>the sensor cleaning Description.</returns>
        private string GetSensorCleaningDescription()
        {
            if (!base.directory.ContainsTag(CanonDirectory.TAG_CANON_CUSTOM_FUNCTION_SENSOR_CLEANING))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(CanonDirectory.TAG_CANON_CUSTOM_FUNCTION_SENSOR_CLEANING);
            switch (lcVal)
            {
                case 0: return BUNDLE["DISABLED"];
                case 1: return BUNDLE["ENABLED"];
                default: return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Returns the fill flash reduction Description. 
        /// </summary>
        /// <returns>the fill flash reduction Description.</returns>
        private string GetFillFlashReductionDescription()
        {
            if (!base.directory.ContainsTag(CanonDirectory.TAG_CANON_CUSTOM_FUNCTION_FILL_FLASH_REDUCTION))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(CanonDirectory.TAG_CANON_CUSTOM_FUNCTION_FILL_FLASH_REDUCTION);
            switch (lcVal)
            {
                case 0: return BUNDLE["ENABLED"];
                case 1: return BUNDLE["DISABLED"];
                default: return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Returns the lens auto focus stop Description. 
        /// </summary>
        /// <returns>the lens auto focus stop Description.</returns>
        private string GetLensAutoFocusStopButtonDescription()
        {
            if (!base.directory.ContainsTag(CanonDirectory.TAG_CANON_CUSTOM_FUNCTION_AF_STOP))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(CanonDirectory.TAG_CANON_CUSTOM_FUNCTION_AF_STOP);
            switch (lcVal)
            {
                case 0: return BUNDLE["AF_STOP"];
                case 1: return BUNDLE["OPERATE_AF"];
                case 2: return BUNDLE["LOCK_AE_AND_START_TIMER"];
                default: return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }
        
        /// <summary>
        /// Returns the shutter curtain sync Description. 
        /// </summary>
        /// <returns>the shutter curtain sync Description.</returns>
        private string GetShutterCurtainSyncDescription()
        {
            if (!base.directory.ContainsTag(CanonDirectory.TAG_CANON_CUSTOM_FUNCTION_SHUTTER_CURTAIN_SYNC))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(CanonDirectory.TAG_CANON_CUSTOM_FUNCTION_SHUTTER_CURTAIN_SYNC);
            switch (lcVal)
            {
                case 0: return BUNDLE["1_CURTAIN_SYNC"];
                case 1: return BUNDLE["2_CURTAIN_SYNC"];
                default: return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Returns the auto exposure bracketting sequence and auto cancellation Description. 
        /// </summary>
        /// <returns>the auto exposure bracketting sequence and auto cancellation Description.</returns>
        private string GetAutoExposureBrackettingSequenceAndAutoCancellationDescription()
        {
            if (!base.directory.ContainsTag(CanonDirectory.TAG_CANON_CUSTOM_FUNCTION_BRACKETTING))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(CanonDirectory.TAG_CANON_CUSTOM_FUNCTION_BRACKETTING);
            switch (lcVal)
            {
                case 0: return BUNDLE["0_M_P_ENABLED"];
                case 1: return BUNDLE["0_M_P_DISABLED"];
                case 2: return BUNDLE["M_0_P_ENABLED"];
                case 3: return BUNDLE["M_0_P_DISABLED"];
                default: return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Returns the shutter speed in Av mode Description. 
        /// </summary>
        /// <returns>the shutter speed in Av mode Description.</returns>
        private string GetShutterSpeedInAvModeDescription()
        {
            if (!base.directory.ContainsTag(CanonDirectory.TAG_CANON_CUSTOM_FUNCTION_SHUTTER_SPEED_IN_AV_MODE))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(CanonDirectory.TAG_CANON_CUSTOM_FUNCTION_SHUTTER_SPEED_IN_AV_MODE);
            switch (lcVal)
            {
                case 0: return BUNDLE["AUTOMATIC"];
                case 1: return BUNDLE["1_200_FIXED"];
                default: return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Returns the auto focus assist light Description. 
        /// </summary>
        /// <returns>the auto focus assist light Description.</returns>
        private string GetAutoFocusAssistLightDescription()
        {
            if (!base.directory.ContainsTag(CanonDirectory.TAG_CANON_CUSTOM_FUNCTION_AF_ASSIST_LIGHT))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(CanonDirectory.TAG_CANON_CUSTOM_FUNCTION_AF_ASSIST_LIGHT);
            switch (lcVal)
            {
                case 0: return BUNDLE["ON_AUTO"];
                case 1: return BUNDLE["OFF"];
                default: return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Returns the Tv and Av exposure level Description. 
        /// </summary>
        /// <returns>the Tv and Av exposure level Description.</returns>
        private string GetTvAndAvExposureLevelDescription()
        {
            if (!base.directory.ContainsTag(CanonDirectory.TAG_CANON_CUSTOM_FUNCTION_TV_AV_AND_EXPOSURE_LEVEL))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(CanonDirectory.TAG_CANON_CUSTOM_FUNCTION_TV_AV_AND_EXPOSURE_LEVEL);
            switch (lcVal)
            {
                case 0: return BUNDLE["1_2_STOP"];
                case 1: return BUNDLE["1_2_STOP"];
                default: return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Returns the mirror lock up Description. 
        /// </summary>
        /// <returns>the mirror lock up Description.</returns>
        private string GetMirrorLockupDescription()
        {
            if (!base.directory.ContainsTag(CanonDirectory.TAG_CANON_CUSTOM_FUNCTION_MIRROR_LOCKUP))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(CanonDirectory.TAG_CANON_CUSTOM_FUNCTION_MIRROR_LOCKUP);
            switch (lcVal)
            {
                case 0: return BUNDLE["DISABLED"];
                case 1: return BUNDLE["ENABLED"];
                default: return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Returns the shutter auto exposure lock button Description. 
        /// </summary>
        /// <returns>the shutter auto exposure lock button Description.</returns>
        private string GetShutterAutoExposureLockButtonDescription()
        {
            if (!base.directory.ContainsTag(CanonDirectory.TAG_CANON_CUSTOM_FUNCTION_SHUTTER_AUTO_EXPOSURE_LOCK_BUTTONS))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(CanonDirectory.TAG_CANON_CUSTOM_FUNCTION_SHUTTER_AUTO_EXPOSURE_LOCK_BUTTONS);
            switch (lcVal)
            {
                case 0: return BUNDLE["AF_AE_LOCK"];
                case 1: return BUNDLE["AE_LOCK_AF"];
                case 2: return BUNDLE["AE_AF_LOCK"];
                case 3: return BUNDLE["AE_RELEASE_AE_AF"];
                default: return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Returns the long exposure noise reduction Description. 
        /// </summary>
        /// <returns>the long exposure noise reduction Description.</returns>
        private string GetLongExposureNoiseReductionDescription()
        {
            if (!base.directory.ContainsTag(CanonDirectory.TAG_CANON_CUSTOM_FUNCTION_LONG_EXPOSURE_NOISE_REDUCTION))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(CanonDirectory.TAG_CANON_CUSTOM_FUNCTION_LONG_EXPOSURE_NOISE_REDUCTION);
            switch (lcVal)
            {
                case 0: return BUNDLE["OFF"];
                case 1: return BUNDLE["ON"];
                default: return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Returns the quality Description. 
        /// </summary>
        /// <returns>the quality Description.</returns>
        private string GetQualityDescription()
        {
            if (!base.directory.ContainsTag(CanonDirectory.TAG_CANON_STATE1_QUALITY))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(CanonDirectory.TAG_CANON_STATE1_QUALITY);
            switch (lcVal)
            {
                case 2:
                    return BUNDLE["NORMAL"];
                case 3:
                    return BUNDLE["FINE"];
                case 5:
                    return BUNDLE["SUPERFINE"];
                default:
                    return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Returns the digital zoom Description. 
        /// </summary>
        /// <returns>the digital zoom Description.</returns>
        private string GetDigitalZoomDescription()
        {
            if (!base.directory.ContainsTag(CanonDirectory.TAG_CANON_STATE1_DIGITAL_ZOOM))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(CanonDirectory.TAG_CANON_STATE1_DIGITAL_ZOOM);
            switch (lcVal)
            {
                case 0:
                    return BUNDLE["NO_DIGITAL_ZOOM"];
                case 1:
                    return BUNDLE["DIGITAL_ZOOM", "2"];
                case 2:
                    return BUNDLE["DIGITAL_ZOOM", "4"];
                default:
                    return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Returns the focus type Description. 
        /// </summary>
        /// <returns>the focus type Description.</returns>
        private string GetFocusTypeDescription()
        {
            if (!base.directory.ContainsTag(CanonDirectory.TAG_CANON_STATE1_FOCUS_TYPE))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(CanonDirectory.TAG_CANON_STATE1_FOCUS_TYPE);
            switch (lcVal)
            {
                case 0:
                    return BUNDLE["MANUAL"];
                case 1:
                case 2:
                    return BUNDLE["AUTO"];
                case 3:
                    return BUNDLE["CLOSE_UP_MACRO"];
                case 8:
                    return BUNDLE["LOCKED_PAN_MODE"];
                default:
                    return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Returns the Flash actvity  Description. 
        /// </summary>
        /// <returns>the Flash activity Description.</returns>
        private string GetFlashActivityDescription()
        {
            if (!base.directory.ContainsTag(CanonDirectory.TAG_CANON_STATE1_FLASH_ACTIVITY))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(CanonDirectory.TAG_CANON_STATE1_FLASH_ACTIVITY);
            switch (lcVal)
            {
                case 0:
                    return BUNDLE["FLASH_DID_NOT_FIRE"];
                case 1:
                    return BUNDLE["FLASH_FIRED"];
                default:
                    return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }


		/// <summary>
		/// Returns the Flash Bias Description. 
		/// </summary>
		/// <returns>the Flash Bias Description.</returns>
		private string GetFlashBiasDescription() 
		{
            if (!base.directory
                .ContainsTag(CanonDirectory.TAG_CANON_STATE2_FLASH_BIAS))
            {
                return null;
            }
			int lcVal =
				base.directory.GetInt(
				CanonDirectory.TAG_CANON_STATE2_FLASH_BIAS);
            bool isNegative = false;
            if (lcVal > 0xF000)
            {
                isNegative = true;
                lcVal = 0xFFFF - lcVal;
                lcVal++;
            }

            // this tag is interesting in that the values returned are:
            //  0, 0.375, 0.5, 0.626, 1
            // not
            //  0, 0.33,  0.5, 0.66,  1
            return BUNDLE["FLASH_BIAS_NEW", ((isNegative) ? "-" : ""), (lcVal / 32.0).ToString()];
		}

		/// <summary>
		/// Returns Af Point Used Description. 
		/// </summary>
		/// <returns>the Af Point Used Description.</returns>
		private string GetAfPointUsedDescription()
		{
            if (!base.directory
                .ContainsTag(
                CanonDirectory.TAG_CANON_STATE2_AF_POINT_USED))
            {
                return null;
            }
			int lcVal =
				base.directory.GetInt(
				CanonDirectory.TAG_CANON_STATE2_AF_POINT_USED);
			if ((lcVal & 0x7) == 0) 
			{
				return BUNDLE["RIGHT"];
			} 
			else if ((lcVal & 0x7) == 1) 
			{
				return BUNDLE["CENTER"];;
			} 
			else if ((lcVal & 0x7) == 2) 
			{
				return BUNDLE["LEFT"];
			} 
			else 
			{
				return BUNDLE["UNKNOWN", lcVal.ToString()];
			}
		}

		/// <summary>
		/// Returns White Balance Description. 
		/// </summary>
		/// <returns>the White Balance Description.</returns>
		private string GetWhiteBalanceDescription() 
		{
			if (!base.directory
				.ContainsTag(
				CanonDirectory.TAG_CANON_STATE2_WHITE_BALANCE))
				return null;
			int lcVal =
				base.directory.GetInt(
				CanonDirectory.TAG_CANON_STATE2_WHITE_BALANCE);
			switch (lcVal) 
			{
				case 0 :
					return BUNDLE["AUTO"];
				case 1 :
					return BUNDLE["SUNNY"];
				case 2 :
					return BUNDLE["CLOUDY"];
				case 3 :
					return BUNDLE["TUNGSTEN"];
				case 4 :
					return BUNDLE["FLUORESCENT"];
				case 5 :
					return BUNDLE["FLASH"];
				case 6 :
					return BUNDLE["CUSTOM"];
				default :
					return BUNDLE["UNKNOWN", lcVal.ToString()];
			}
		}

		/// <summary>
		/// Returns Focus Mode 2 description. 
		/// </summary>
		/// <returns>the Focus Mode 2 description</returns>
		private string GetFocusMode2Description() 
		{
            if (!base.directory
                .ContainsTag(CanonDirectory.TAG_CANON_STATE1_FOCUS_MODE_2))
            {
                return null;
            }
			int lcVal =
				base.directory.GetInt(
				CanonDirectory.TAG_CANON_STATE1_FOCUS_MODE_2);
			switch (lcVal) 
			{
				case 0 :
					return BUNDLE["SINGLE"];
				case 1 :
					return BUNDLE["CONTINUOUS"];
				default :
					return BUNDLE["UNKNOWN", lcVal.ToString()];
			}
		}

		/// <summary>
		/// Returns Flash Details description. 
		/// </summary>
		/// <returns>the Flash Details description</returns>
		private string GetFlashDetailsDescription()  
		{
            if (!base.directory
                .ContainsTag(
                CanonDirectory.TAG_CANON_STATE1_FLASH_DETAILS))
            {
                return null;
            }
			int lcVal =
				base.directory.GetInt(
				CanonDirectory.TAG_CANON_STATE1_FLASH_DETAILS);
			if (((lcVal << 14) & 1) > 0) 
			{
				return BUNDLE["EXTERNAL_E_TTL"];
			}
			if (((lcVal << 13) & 1) > 0) 
			{
				return BUNDLE["INTERNAL_FLASH"];
			}
			if (((lcVal << 11) & 1) > 0) 
			{
				return BUNDLE["FP_SYNC_USED"];
			}
			if (((lcVal << 4) & 1) > 0) 
			{
				return BUNDLE["FP_SYNC_ENABLED"];
			}
			return BUNDLE["UNKNOWN", lcVal.ToString()];
		}

		/// <summary>
		/// Returns Focal Units Per Millimetre description. 
		/// </summary>
		/// <returns>the Focal Units Per Millimetre description</returns>
		private string GetFocalUnitsPerMillimetreDescription() 
		{
            if (!base.directory
                .ContainsTag(
                CanonDirectory.TAG_CANON_STATE1_FOCAL_UNITS_PER_MM))
            {
                return "";
            }
			int lcVal =
				base.directory.GetInt(
				CanonDirectory.TAG_CANON_STATE1_FOCAL_UNITS_PER_MM);
			if (lcVal != 0) 
			{
				return lcVal.ToString();
			} 
			return "";
		}

		/// <summary>
		/// Returns Short Focal Length description. 
		/// </summary>
		/// <returns>the Short Focal Length description</returns>
		private string GetShortFocalLengthDescription()  
		{
            if (!base.directory
                .ContainsTag(
                CanonDirectory.TAG_CANON_STATE1_SHORT_FOCAL_LENGTH))
            {
                return null;
            }
			int lcVal =
				base.directory.GetInt(
				CanonDirectory.TAG_CANON_STATE1_SHORT_FOCAL_LENGTH);
			string units = GetFocalUnitsPerMillimetreDescription();
			return BUNDLE["FOCAL_LENGTH", lcVal.ToString(), units];
		}

		/// <summary>
		/// Returns Long Focal Length description. 
		/// </summary>
		/// <returns>the Long Focal Length description</returns>
		private string GetLongFocalLengthDescription() 
		{
            if (!base.directory
                .ContainsTag(
                CanonDirectory.TAG_CANON_STATE1_LONG_FOCAL_LENGTH))
            {
                return null;
            }
			int lcVal =
				base.directory.GetInt(
				CanonDirectory.TAG_CANON_STATE1_LONG_FOCAL_LENGTH);
			string units = GetFocalUnitsPerMillimetreDescription();
			return BUNDLE["FOCAL_LENGTH", lcVal.ToString(), units];
		}

		/// <summary>
		/// Returns Exposure Mode description. 
		/// </summary>
		/// <returns>the Exposure Mode description</returns>
		private string GetExposureModeDescription() 
		{
            if (!base.directory
                .ContainsTag(
                CanonDirectory.TAG_CANON_STATE1_EXPOSURE_MODE))
            {
                return null;
            }
			int lcVal =
				base.directory.GetInt(
				CanonDirectory.TAG_CANON_STATE1_EXPOSURE_MODE);
			switch (lcVal) 
			{
				case 0 :
					return BUNDLE["EASY_SHOOTING"];
				case 1 :
					return BUNDLE["PROGRAM"];
				case 2 :
					return BUNDLE["TV_PRIORITY"];
				case 3 :
					return BUNDLE["AV_PRIORITY"];
				case 4 :
					return BUNDLE["MANUAL"];
				case 5 :
					return BUNDLE["A_DEP"];
				default :
					return BUNDLE["UNKNOWN", lcVal.ToString()];
			}
		}

		/// <summary>
		/// Returns Af Point Selected description. 
		/// </summary>
		/// <returns>the Af Point Selected description</returns>
		private string GetAfPointSelectedDescription() 
		{
            if (!base.directory
                .ContainsTag(
                CanonDirectory.TAG_CANON_STATE1_AF_POINT_SELECTED))
            {
                return null;
            }
			int lcVal =
				base.directory.GetInt(
				CanonDirectory.TAG_CANON_STATE1_AF_POINT_SELECTED);
			switch (lcVal) 
			{
				case 0x3000 :
					return BUNDLE["NONE_MF"];
				case 0x3001 :
					return BUNDLE["AUTO_SELECTED"];
				case 0x3002 :
					return BUNDLE["RIGHT"];
				case 0x3003 :
					return BUNDLE["CENTER"];
				case 0x3004 :
					return BUNDLE["LEFT"];
				default :
					return BUNDLE["UNKNOWN", lcVal.ToString()];
			}
		}

		/// <summary>
		/// Returns Metering Mode description. 
		/// </summary>
		/// <returns>the Metering Mode description</returns>
		private string GetMeteringModeDescription() 
		{
            if (!base.directory
                .ContainsTag(
                CanonDirectory.TAG_CANON_STATE1_METERING_MODE))
            {
                return null;
            }
			int lcVal =
				base.directory.GetInt(
				CanonDirectory.TAG_CANON_STATE1_METERING_MODE);
			switch (lcVal) 
			{
				case 3 :
					return BUNDLE["EVALUATIVE"];
				case 4 :
					return BUNDLE["PARTIAL"];
				case 5 :
					return BUNDLE["CENTER_WEIGHTED"];
				default :
					return BUNDLE["UNKNOWN", lcVal.ToString()];
			}
		}

		/// <summary>
		/// Returns ISO description. 
		/// </summary>
		/// <returns>the ISO description</returns>
		private string GetIsoDescription() 
		{
            if (!base.directory
                .ContainsTag(CanonDirectory.TAG_CANON_STATE1_ISO))
            {
                return null;
            }
			int lcVal =
				base.directory.GetInt(CanonDirectory.TAG_CANON_STATE1_ISO);
			switch (lcVal) 
			{
				case 0 :
					return BUNDLE["ISO_NOT_SPECIFIED"];
				case 15 :
					return BUNDLE["AUTO"];
				case 16 :
					return BUNDLE["ISO", "50"];
				case 17 :
					return BUNDLE["ISO", "100"];
				case 18 :
					return BUNDLE["ISO", "200"];
				case 19 :
					return BUNDLE["ISO", "400"];
				default :
					return BUNDLE["UNKNOWN", lcVal.ToString()];
			}
		}

		/// <summary>
		/// Returns Sharpness description. 
		/// </summary>
		/// <returns>the Sharpness description</returns>
		private string GetSharpnessDescription() 
		{
            if (!base.directory
                .ContainsTag(CanonDirectory.TAG_CANON_STATE1_SHARPNESS))
            {
                return null;
            }
			int lcVal =
				base.directory.GetInt(
				CanonDirectory.TAG_CANON_STATE1_SHARPNESS);
			switch (lcVal) 
			{
				case 0xFFFF :
					return BUNDLE["LOW"];
				case 0x000 :
					return BUNDLE["NORMAL"];
				case 0x001 :
					return BUNDLE["HIGH"];
				default :
					return BUNDLE["UNKNOWN", lcVal.ToString()];
			}
		}

		/// <summary>
		/// Returns Saturation description. 
		/// </summary>
		/// <returns>the Saturation description</returns>
		private string GetSaturationDescription() 
		{
            if (!base.directory
                .ContainsTag(CanonDirectory.TAG_CANON_STATE1_SATURATION))
            {
                return null;
            }
			int lcVal =
				base.directory.GetInt(
				CanonDirectory.TAG_CANON_STATE1_SATURATION);
			switch (lcVal) 
			{
				case 0xFFFF :
					return BUNDLE["LOW"];
				case 0x000 :
					return BUNDLE["NORMAL"];
				case 0x001 :
					return BUNDLE["HIGH"];
				default :
					return BUNDLE["UNKNOWN", lcVal.ToString()];
			}
		}

		/// <summary>
		/// Returns Contrast description. 
		/// </summary>
		/// <returns>the Contrast description</returns>
		private string GetContrastDescription() 
		{
            if (!base.directory
                .ContainsTag(CanonDirectory.TAG_CANON_STATE1_CONTRAST))
            {
                return null;
            }
			int lcVal =
				base.directory.GetInt(
				CanonDirectory.TAG_CANON_STATE1_CONTRAST);
			switch (lcVal) 
			{
				case 0xFFFF :
					return BUNDLE["LOW"];
				case 0x000 :
					return BUNDLE["NORMAL"];
				case 0x001 :
					return BUNDLE["HIGH"];
				default :
					return BUNDLE["UNKNOWN", lcVal.ToString()];
			}
		}

		/// <summary>
		/// Returns Easy Shooting Mode description. 
		/// </summary>
		/// <returns>the Easy Shooting Mode description</returns>
		private string GetEasyShootingModeDescription() 
		{
            if (!base.directory
                .ContainsTag(
                CanonDirectory.TAG_CANON_STATE1_EASY_SHOOTING_MODE))
            {
                return null;
            }
			int lcVal =
				base.directory.GetInt(
				CanonDirectory.TAG_CANON_STATE1_EASY_SHOOTING_MODE);
			switch (lcVal) 
			{
				case 0 :
					return BUNDLE["FULL_AUTO"];
				case 1 :
					return BUNDLE["MANUAL"];
				case 2 :
					return BUNDLE["LANDSCAPE"];
				case 3 :
					return BUNDLE["FAST_SHUTTER"];
				case 4 :
					return BUNDLE["SLOW_SHUTTER"];
				case 5 :
					return BUNDLE["NIGHT"];
				case 6 :
					return BUNDLE["BLACK_AND_WHITE"];
				case 7 :
					return BUNDLE["SEPIA"];
				case 8 :
					return BUNDLE["PORTRAIT"];
				case 9 :
					return BUNDLE["SPORTS"];
				case 10 :
					return BUNDLE["MACRO_CLOSEUP"];
				case 11 :
					return BUNDLE["PAN_FOCUS"];
				default :
					return BUNDLE["UNKNOWN", lcVal.ToString()];
			}
		}

		/// <summary>
		/// Returns Image Size description. 
		/// </summary>
		/// <returns>the Image Size description</returns>
		private string GetImageSizeDescription() 
		{
            if (!base.directory
                .ContainsTag(CanonDirectory.TAG_CANON_STATE1_IMAGE_SIZE))
            {
                return null;
            }
			int lcVal =
				base.directory.GetInt(
				CanonDirectory.TAG_CANON_STATE1_IMAGE_SIZE);
			switch (lcVal) 
			{
				case 0 :
					return BUNDLE["LARGE"];
				case 1 :
					return BUNDLE["MEDIUM"];
				case 2 :
					return BUNDLE["SMALL"];
				default :
					return BUNDLE["UNKNOWN", lcVal.ToString()];
			}
		}

		/// <summary>
		/// Returns Focus Mode 1 description. 
		/// </summary>
		/// <returns>the Focus Mode 1 description</returns>
		private string GetFocusMode1Description() 
		{
            if (!base.directory
                .ContainsTag(CanonDirectory.TAG_CANON_STATE1_FOCUS_MODE_1))
            {
                return null;
            }
			int lcVal =
				base.directory.GetInt(
				CanonDirectory.TAG_CANON_STATE1_FOCUS_MODE_1);
			switch (lcVal) 
			{
				case 0 :
					return BUNDLE["ONE_SHOT"];
				case 1 :
					return BUNDLE["AI_SERVO"];
				case 2 :
					return BUNDLE["AI_FOCUS"];
				case 3 :
					return BUNDLE["MF"];
				case 4 :
					// TODO should check field 32 here (FOCUS_MODE_2)
					return BUNDLE["SINGLE"];
				case 5 :
					return BUNDLE["CONTINUOUS"];
				case 6 :
					return BUNDLE["MF"];
				default :
					return BUNDLE["UNKNOWN", lcVal.ToString()];
			}
		}

		/// <summary>
		/// Returns Continuous Drive Mode description. 
		/// </summary>
		/// <returns>the Continuous Drive Mode description</returns>
		private string GetContinuousDriveModeDescription()
		{
            if (!base.directory
                .ContainsTag(
                CanonDirectory
                .TAG_CANON_STATE1_CONTINUOUS_DRIVE_MODE))
            {
                return null;
            }
			int lcVal =
				base.directory.GetInt(
				CanonDirectory.TAG_CANON_STATE1_CONTINUOUS_DRIVE_MODE);
			switch (lcVal) 
			{
				case 0 :
					if (base.directory
						.GetInt(
						CanonDirectory
						.TAG_CANON_STATE1_SELF_TIMER_DELAY)
						== 0) 
					{
						return BUNDLE["SINGLE_SHOT"];
					} 
					else 
					{
						return BUNDLE["SINGLE_SHOT_WITH_SELF_TIMER"];
					}
				case 1 :
					return BUNDLE["CONTINUOUS"];
				default :
					return BUNDLE["UNKNOWN", lcVal.ToString()];
			}
		}

		/// <summary>
		/// Returns Flash Mode description. 
		/// </summary>
		/// <returns>the Flash Mode description</returns>
		private string GetFlashModeDescription() 
		{
            if (!base.directory
                .ContainsTag(CanonDirectory.TAG_CANON_STATE1_FLASH_MODE))
            {
                return null;
            }
			int lcVal =
				base.directory.GetInt(
				CanonDirectory.TAG_CANON_STATE1_FLASH_MODE);
			switch (lcVal) 
			{
				case 0 :
					return BUNDLE["NO_FLASH_FIRED"];
				case 1 :
					return BUNDLE["AUTO"];
				case 2 :
					return BUNDLE["ON"];
				case 3 :
					return BUNDLE["RED_EYE_REDUCTION"];
				case 4 :
					return BUNDLE["SLOW_SYNCHRO"];
				case 5 :
					return BUNDLE["AUTO_AND_RED_EYE_REDUCTION"];
				case 6 :
					return BUNDLE["ON_AND_RED_EYE_REDUCTION"];
				case 16 :
					// note: this lcVal not set on Canon D30
					return BUNDLE["EXTERNAL_FLASH"];
				default :
					return BUNDLE["UNKNOWN", lcVal.ToString()];
			}
		}

		/// <summary>
		/// Returns Self Timer Delay description. 
		/// </summary>
		/// <returns>the Self Timer Delay description</returns>
		private string GetSelfTimerDelayDescription() 
		{
            if (!base.directory
                .ContainsTag(
                CanonDirectory.TAG_CANON_STATE1_SELF_TIMER_DELAY))
            {
                return null;
            }
			int lcVal =
				base.directory.GetInt(
				CanonDirectory.TAG_CANON_STATE1_SELF_TIMER_DELAY);
			if (lcVal == 0) 
			{
				return BUNDLE["SELF_TIMER_DELAY_NOT_USED"];
			} 
			// TODO find an image that tests this calculation
			return BUNDLE["SELF_TIMER_DELAY", ((double) lcVal * 0.1d).ToString()];
		}

		/// <summary>
		/// Returns Macro Mode description. 
		/// </summary>
		/// <returns>the Macro Mode description</returns>
		private string GetMacroModeDescription() 
		{
            if (!base.directory
                .ContainsTag(CanonDirectory.TAG_CANON_STATE1_MACRO_MODE))
            {
                return null;
            }
			int lcVal =
				base.directory.GetInt(
				CanonDirectory.TAG_CANON_STATE1_MACRO_MODE);
			switch (lcVal) 
			{
                case 0:
                    return BUNDLE["OFF"];
				case 1 :
					return BUNDLE["MACRO"];
				case 2 :
					return BUNDLE["NORMAL"];
				default :
					return BUNDLE["UNKNOWN", lcVal.ToString()];
			}
		}
	}
}
using System;
using System.Collections;
using com.drew.metadata;

/// <summary>
/// This class was first written by Drew Noakes in Java.
///
/// This is public domain software - that is, you can do whatever you want
/// with it, and include it software that is licensed under the GNU or the
/// BSD license, or whatever other licence you choose, including proprietary
/// closed source licenses.  I do ask that you leave this lcHeader in tact.
///
/// If you make modifications to this code that you think would benefit the
/// wider community, please send me a copy and I'll post it on my site.
///
/// If you make use of this code, Drew Noakes will appreciate hearing 
/// about it: <a href="mailto:drew@drewnoakes.com">drew@drewnoakes.com</a>
///
/// Latest Java version of this software kept at 
/// <a href="http://drewnoakes.com">http://drewnoakes.com/</a>
///
/// The C# class was made by Ferret Renaud: 
/// <a href="mailto:renaud91@free.fr">renaud91@free.fr</a>
/// If you find a bug in the C# code, feel free to mail me.
/// </summary>
namespace com.drew.metadata.exif
{
	/// <summary>
	/// Tag descriptor for a casio camera
	/// </summary>
	public class CasioType1Descriptor : AbstractTagDescriptor 					
	{
		/// <summary>
		/// Constructor of the object
		/// </summary>
		/// <param name="aDirectory">a base.directory</param>
		public CasioType1Descriptor(AbstractDirectory aDirectory) : base(aDirectory) 
		{		
		}

		/// <summary>
		/// Returns a descriptive value of the the specified tag for this image. 
		/// Where possible, known values will be substituted here in place of the raw tokens actually 
		/// kept in the Exif segment. 
		/// If no substitution is available, the value provided by GetString(int) will be returned.
		/// This and GetString(int) are the only 'get' methods that won't throw an exception.
		/// </summary>
		/// <param name="aTagType">the tag to find a description for</param>
		/// <returns>a description of the image'str value for the specified tag, or null if the tag hasn't been defined.</returns>
		public override string GetDescription(int aTagType) 
		{
			switch(aTagType) 
			{
				case CasioType1Directory.TAG_CASIO_RECORDING_MODE:
					return this.GetRecordingModeDescription();
				case CasioType1Directory.TAG_CASIO_QUALITY:
					return this.GetQualityDescription();
				case CasioType1Directory.TAG_CASIO_FOCUSING_MODE:
					return this.GetFocusingModeDescription();
				case CasioType1Directory.TAG_CASIO_FLASH_MODE:
					return this.GetFlashModeDescription();
				case CasioType1Directory.TAG_CASIO_FLASH_INTENSITY:
					return this.GetFlashIntensityDescription();
				case CasioType1Directory.TAG_CASIO_OBJECT_DISTANCE:
					return this.GetObjectDistanceDescription();
				case CasioType1Directory.TAG_CASIO_WHITE_BALANCE:
					return this.GetWhiteBalanceDescription();
				case CasioType1Directory.TAG_CASIO_DIGITAL_ZOOM:
					return this.GetDigitalZoomDescription();
				case CasioType1Directory.TAG_CASIO_SHARPNESS:
					return this.GetSharpnessDescription();
				case CasioType1Directory.TAG_CASIO_CONTRAST:
					return this.GetContrastDescription();
				case CasioType1Directory.TAG_CASIO_SATURATION:
					return this.GetSaturationDescription();
				case CasioType1Directory.TAG_CASIO_CCD_SENSITIVITY:
					return GetCcdSensitivityDescription();
				default :
					return base.directory.GetString(aTagType);
			}
		}

		/// <summary>
		/// Returns the Ccd Sensitivity Description. 
		/// </summary>
		/// <returns>the Ccd Sensitivity Description.</returns>
		private string GetCcdSensitivityDescription() 
		{
            if (!base.directory
                .ContainsTag(CasioType1Directory.TAG_CASIO_CCD_SENSITIVITY))
            {
                return null;
            }
			int lcVal =
				base.directory.GetInt(
				CasioType1Directory.TAG_CASIO_CCD_SENSITIVITY);
			switch (lcVal) 
			{
					// these four for QV3000
				case 64 :
					return BUNDLE["NORMAL"];
				case 125 :
					return BUNDLE["CCD_P_1"];
				case 250 :
					return BUNDLE["CCD_P_2"];
				case 244 :
					return BUNDLE["CCD_P_3"];
					// these two for QV8000/2000
				case 80 :
					return BUNDLE["NORMAL"];
				case 100 :
					return BUNDLE["HIGH"];
				default :
					return BUNDLE["UNKNOWN", lcVal.ToString()];
			}
		}

		/// <summary>
		/// Returns the saturation Description. 
		/// </summary>
		/// <returns>the saturation Description.</returns>
		private string GetSaturationDescription() 
		{
            if (!base.directory
                .ContainsTag(CasioType1Directory.TAG_CASIO_SATURATION))
            {
                return null;
            }
			int lcVal =
				base.directory.GetInt(CasioType1Directory.TAG_CASIO_SATURATION);
			switch (lcVal) 
			{
				case 0 :
					return BUNDLE["NORMAL"];
				case 1 :
					return BUNDLE["LOW"];
				case 2 :
					return BUNDLE["HIGH"];
				default :
					return BUNDLE["UNKNOWN", lcVal.ToString()];
			}
		}

		/// <summary>
		/// Returns the contrast Description. 
		/// </summary>
		/// <returns>the contrast Description.</returns>
		private string GetContrastDescription() 
		{
            if (!base.directory
                .ContainsTag(CasioType1Directory.TAG_CASIO_CONTRAST))
            {
                return null;
            }
			int lcVal =
				base.directory.GetInt(CasioType1Directory.TAG_CASIO_CONTRAST);
			switch (lcVal) 
			{
				case 0 :
					return BUNDLE["NORMAL"];
				case 1 :
					return BUNDLE["LOW"];
				case 2 :
					return BUNDLE["HIGH"];
				default :
					return BUNDLE["UNKNOWN", lcVal.ToString()];
			}
		}

		/// <summary>
		/// Returns the sharpness Description. 
		/// </summary>
		/// <returns>the sharpness Description.</returns>
		private string GetSharpnessDescription() 
		{
            if (!base.directory
                .ContainsTag(CasioType1Directory.TAG_CASIO_SHARPNESS))
            {
                return null;
            }
			int lcVal =
				base.directory.GetInt(CasioType1Directory.TAG_CASIO_SHARPNESS);
			switch (lcVal) 
			{
				case 0 :
					return BUNDLE["NORMAL"];
				case 1 :
					return BUNDLE["SOFT"];;
				case 2 :
					return BUNDLE["HARD"];;
				default :
					return BUNDLE["UNKNOWN", lcVal.ToString()];
			}
		}

		/// <summary>
		/// Returns the Digital Zoom Description. 
		/// </summary>
		/// <returns>the Digital Zoom Description.</returns>
		private string GetDigitalZoomDescription() 
		{
            if (!base.directory
                .ContainsTag(CasioType1Directory.TAG_CASIO_DIGITAL_ZOOM))
            {
                return null;
            }
			int lcVal =
				base.directory.GetInt(CasioType1Directory.TAG_CASIO_DIGITAL_ZOOM);
			switch (lcVal) 
			{
                case 0x10000:
                    return BUNDLE["NO_DIGITAL_ZOOM"];
                case 0x10001:
                case 0x20000:
                    return BUNDLE["DIGITAL_ZOOM", "2"];
                case 0x40000:
                    return BUNDLE["DIGITAL_ZOOM", "4"];
                default:
					return BUNDLE["UNKNOWN", lcVal.ToString()];
			}
		}

		/// <summary>
		/// Returns the White Balance Description. 
		/// </summary>
		/// <returns>the White Balance Description.</returns>
		private string GetWhiteBalanceDescription() 
		{
            if (!base.directory
                .ContainsTag(CasioType1Directory.TAG_CASIO_WHITE_BALANCE))
            {
                return null;
            }
			int lcVal =
				base.directory.GetInt(CasioType1Directory.TAG_CASIO_WHITE_BALANCE);
			switch (lcVal) 
			{
				case 1 :
					return BUNDLE["AUTO"];
				case 2 :
					return BUNDLE["TUNGSTEN"];
				case 3 :
					return BUNDLE["DAYLIGHT"];
				case 4 :
					return BUNDLE["FLUORESCENT"];
				case 5 :
					return BUNDLE["SHADE"];
				case 129 :
					return BUNDLE["MANUAL"];
				default :
					return BUNDLE["UNKNOWN", lcVal.ToString()];
			}
		}

		/// <summary>
		/// Returns the Object Distance Description. 
		/// </summary>
		/// <returns>the Object Distance Description.</returns>
		private string GetObjectDistanceDescription() 
		{
            if (!base.directory
                .ContainsTag(CasioType1Directory.TAG_CASIO_OBJECT_DISTANCE))
            {
                return null;
            }
			int lcVal =
				base.directory.GetInt(
				CasioType1Directory.TAG_CASIO_OBJECT_DISTANCE);
			return BUNDLE["DISTANCE_MM", lcVal.ToString()];
		}

		/// <summary>
		/// Returns the Flash Intensity Description. 
		/// </summary>
		/// <returns>the Flash Intensity Description.</returns>
		private string GetFlashIntensityDescription() 
		{
            if (!base.directory
                .ContainsTag(CasioType1Directory.TAG_CASIO_FLASH_INTENSITY))
            {
                return null;
            }
			int lcVal =
				base.directory.GetInt(
				CasioType1Directory.TAG_CASIO_FLASH_INTENSITY);
			switch (lcVal) 
			{
				case 11 :
					return BUNDLE["WEAK"];
				case 13 :
					return BUNDLE["NORMAL"];
				case 15 :
					return BUNDLE["STRONG"];
				default :
					return BUNDLE["UNKNOWN", lcVal.ToString()];
			}
		}

		/// <summary>
		/// Returns the Flash Mode Description. 
		/// </summary>
		/// <returns>the Flash Mode Description.</returns>
		private string GetFlashModeDescription() 
		{
            if (!base.directory
                .ContainsTag(CasioType1Directory.TAG_CASIO_FLASH_MODE))
            {
                return null;
            }
			int lcVal =
				base.directory.GetInt(CasioType1Directory.TAG_CASIO_FLASH_MODE);
			switch (lcVal) 
			{
				case 1 :
					return BUNDLE["AUTO"];
				case 2 :
					return BUNDLE["ON"];
				case 3 :
					return BUNDLE["OFF"];
				case 4 :
                    // this documented as additional value for off here:
                    // http://www.ozhiker.com/electronics/pjmt/jpeg_info/casio_mn.html
					return BUNDLE["RED_EYE_REDUCTION"];
				default :
					return BUNDLE["UNKNOWN", lcVal.ToString()];
			}
		}

		/// <summary>
		/// Returns the Focusing Mode Description. 
		/// </summary>
		/// <returns>the Focusing Mode Description.</returns>
		private string GetFocusingModeDescription() 
		{
            if (!base.directory
                .ContainsTag(CasioType1Directory.TAG_CASIO_FOCUSING_MODE))
            {
                return null;
            }
			int lcVal =
				base.directory.GetInt(CasioType1Directory.TAG_CASIO_FOCUSING_MODE);
			switch (lcVal) 
			{
				case 2 :
					return BUNDLE["MACRO"];
				case 3 :
					return BUNDLE["AUTO_FOCUS"];
				case 4 :
					return BUNDLE["MANUAL_FOCUS"];
				case 5 :
					return BUNDLE["INFINITY"];
				default :
					return BUNDLE["UNKNOWN", lcVal.ToString()];
			}
		}

		/// <summary>
		/// Returns the quality Description. 
		/// </summary>
		/// <returns>the quality Description.</returns>
		private string GetQualityDescription() 
		{
            if (!base.directory.ContainsTag(CasioType1Directory.TAG_CASIO_QUALITY))
            {
                return null;
            }
			int lcVal =
				base.directory.GetInt(CasioType1Directory.TAG_CASIO_QUALITY);
			switch (lcVal) 
			{
				case 1 :
					return BUNDLE["ECONOMY"];
				case 2 :
					return BUNDLE["NORMAL"];
				case 3 :
					return BUNDLE["FINE"];
				default :
					return BUNDLE["UNKNOWN", lcVal.ToString()];
			}
		}

		/// <summary>
		/// Returns the Focussing Mode Description. 
		/// </summary>
		/// <returns>the Focussing Mode Description.</returns>
		private string GetFocussingModeDescription() 
		{
            if (!base.directory
                .ContainsTag(CasioType1Directory.TAG_CASIO_FOCUSING_MODE))
            {
                return null;
            }
			int lcVal =
				base.directory.GetInt(CasioType1Directory.TAG_CASIO_FOCUSING_MODE);
			switch (lcVal) 
			{
				case 2 :
					return BUNDLE["MACRO"];
				case 3 :
					return BUNDLE["AUTO_FOCUS"];
				case 4 :
					return BUNDLE["MANUAL_FOCUS"];
				case 5 :
					return BUNDLE["INFINITY"];
				default :
					return BUNDLE["UNKNOWN", lcVal.ToString()];
			}
		}

		/// <summary>
		/// Returns the Recording Mode Description. 
		/// </summary>
		/// <returns>the Recording Mode Description.</returns>
		private string GetRecordingModeDescription() 
		{
            if (!base.directory
                .ContainsTag(CasioType1Directory.TAG_CASIO_RECORDING_MODE))
            {
                return null;
            }
			int lcVal =
				base.directory.GetInt(CasioType1Directory.TAG_CASIO_RECORDING_MODE);
			switch (lcVal) 
			{
				case 1 :
					return BUNDLE["SINGLE_SHUTTER"];
				case 2 :
					return BUNDLE["PANORAMA"];
				case 3 :
					return BUNDLE["NIGHT_SCENE"];
				case 4 :
					return BUNDLE["PORTRAIT"];
				case 5 :
					return BUNDLE["LANDSCAPE"];
				default :
					return BUNDLE["UNKNOWN", lcVal.ToString()];
			}
		}
	}
}
using System;
using System.Collections;
using com.drew.metadata;

/// <summary>
/// This class was first written by Drew Noakes in Java.
///
/// This is public domain software - that is, you can do whatever you want
/// with it, and include it software that is licensed under the GNU or the
/// BSD license, or whatever other licence you choose, including proprietary
/// closed source licenses.  I do ask that you leave this lcHeader in tact.
///
/// If you make modifications to this code that you think would benefit the
/// wider community, please send me a copy and I'll post it on my site.
///
/// If you make use of this code, Drew Noakes will appreciate hearing 
/// about it: <a href="mailto:drew@drewnoakes.com">drew@drewnoakes.com</a>
///
/// Latest Java version of this software kept at 
/// <a href="http://drewnoakes.com">http://drewnoakes.com/</a>
///
/// The C# class was made by Ferret Renaud: 
/// <a href="mailto:renaud91@free.fr">renaud91@free.fr</a>
/// If you find a bug in the C# code, feel free to mail me.
/// </summary>
namespace com.drew.metadata.exif
{
    /// <summary>
    /// Tag descriptor for a casio camera type 2
    /// </summary>
    public class CasioType2Descriptor : AbstractTagDescriptor
    {
        /// <summary>
        /// Constructor of the object
        /// </summary>
        /// <param name="aDirectory">a base.directory</param>
        public CasioType2Descriptor(AbstractDirectory aDirectory)
            : base(aDirectory)
        {
        }

        /// <summary>
        /// Returns a descriptive value of the the specified tag for this image. 
        /// Where possible, known values will be substituted here in place of the raw tokens actually 
        /// kept in the Exif segment. 
        /// If no substitution is available, the value provided by GetString(int) will be returned.
        /// This and GetString(int) are the only 'get' methods that won't throw an exception.
        /// </summary>
        /// <param name="aTagType">the tag to find a description for</param>
        /// <returns>a description of the image'str value for the specified tag, or null if the tag hasn't been defined.</returns>
        public override string GetDescription(int aTagType)
        {
            switch (aTagType)
            {
                case CasioType2Directory.TAG_CASIO_TYPE2_THUMBNAIL_DIMENSIONS:
                    return this.GetThumbnailDimensionsDescription();
                case CasioType2Directory.TAG_CASIO_TYPE2_THUMBNAIL_SIZE:
                    return this.GetThumbnailSizeDescription();
                case CasioType2Directory.TAG_CASIO_TYPE2_THUMBNAIL_OFFSET:
                    return this.GetThumbnailOffsetDescription();
                case CasioType2Directory.TAG_CASIO_TYPE2_QUALITY_MODE:
                    return this.GetQualityModeDescription();
                case CasioType2Directory.TAG_CASIO_TYPE2_IMAGE_SIZE:
                    return this.GetImageSizeDescription();
                case CasioType2Directory.TAG_CASIO_TYPE2_FOCUS_MODE_1:
                    return this.GetFocusMode1Description();
                case CasioType2Directory.TAG_CASIO_TYPE2_ISO_SENSITIVITY:
                    return this.GetIsoSensitivityDescription();
                case CasioType2Directory.TAG_CASIO_TYPE2_WHITE_BALANCE_1:
                    return this.GetWhiteBalance1Description();
                case CasioType2Directory.TAG_CASIO_TYPE2_FOCAL_LENGTH:
                    return this.GetFocalLengthDescription();
                case CasioType2Directory.TAG_CASIO_TYPE2_SATURATION:
                    return this.GetSaturationDescription();
                case CasioType2Directory.TAG_CASIO_TYPE2_CONTRAST:
                    return this.GetContrastDescription();
                case CasioType2Directory.TAG_CASIO_TYPE2_SHARPNESS:
                    return this.GetSharpnessDescription();
                case CasioType2Directory.TAG_CASIO_TYPE2_PRINT_IMAGE_MATCHING_INFO:
                    return this.GetPrintImageMatchingInfoDescription();
                case CasioType2Directory.TAG_CASIO_TYPE2_CASIO_PREVIEW_THUMBNAIL:
                    return this.GetCasioPreviewThumbnailDescription();
                case CasioType2Directory.TAG_CASIO_TYPE2_WHITE_BALANCE_BIAS:
                    return this.GetWhiteBalanceBiasDescription();
                case CasioType2Directory.TAG_CASIO_TYPE2_WHITE_BALANCE_2:
                    return this.GetWhiteBalance2Description();
                case CasioType2Directory.TAG_CASIO_TYPE2_OBJECT_DISTANCE:
                    return this.GetObjectDistanceDescription();
                case CasioType2Directory.TAG_CASIO_TYPE2_FLASH_DISTANCE:
                    return this.GetFlashDistanceDescription();
                case CasioType2Directory.TAG_CASIO_TYPE2_RECORD_MODE:
                    return this.GetRecordModeDescription();
                case CasioType2Directory.TAG_CASIO_TYPE2_SELF_TIMER:
                    return this.GetSelfTimerDescription();
                case CasioType2Directory.TAG_CASIO_TYPE2_QUALITY:
                    return this.GetQualityDescription();
                case CasioType2Directory.TAG_CASIO_TYPE2_FOCUS_MODE_2:
                    return this.GetFocusMode2Description();
                case CasioType2Directory.TAG_CASIO_TYPE2_TIME_ZONE:
                    return this.GetTimeZoneDescription();
                case CasioType2Directory.TAG_CASIO_TYPE2_BESTSHOT_MODE:
                    return this.GetBestShotModeDescription();
                case CasioType2Directory.TAG_CASIO_TYPE2_CCD_ISO_SENSITIVITY:
                    return this.GetCcdIsoSensitivityDescription();
                case CasioType2Directory.TAG_CASIO_TYPE2_COLOR_MODE:
                    return this.GetColorModeDescription();
                case CasioType2Directory.TAG_CASIO_TYPE2_ENHANCEMENT:
                    return this.GetEnhancementDescription();
                case CasioType2Directory.TAG_CASIO_TYPE2_FILTER:
                    return this.GetFilterDescription();
                default:
                    return base.directory.GetString(aTagType);
            }
        }

        /// <summary>
        /// Returns filter Description. 
        /// </summary>
        /// <returns>the filter Description.</returns>
        private string GetFilterDescription()
        {
            if (!base.directory.ContainsTag(CasioType2Directory.TAG_CASIO_TYPE2_FILTER))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(CasioType2Directory.TAG_CASIO_TYPE2_FILTER);
            switch (lcVal)
            {
                case 0:
                    return BUNDLE["OFF"];
                default:
                    return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Returns enhancement Description. 
        /// </summary>
        /// <returns>the enhancement Description.</returns>
        private string GetEnhancementDescription()
        {
            if (!base.directory.ContainsTag(CasioType2Directory.TAG_CASIO_TYPE2_ENHANCEMENT))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(CasioType2Directory.TAG_CASIO_TYPE2_ENHANCEMENT);
            switch (lcVal)
            {
                case 0:
                    return BUNDLE["OFF"];
                default:
                    return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Returns color mode Description. 
        /// </summary>
        /// <returns>the color mode Description.</returns>
        private string GetColorModeDescription()
        {
            if (!base.directory.ContainsTag(CasioType2Directory.TAG_CASIO_TYPE2_COLOR_MODE))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(CasioType2Directory.TAG_CASIO_TYPE2_COLOR_MODE);
            switch (lcVal)
            {
                case 0:
                    return BUNDLE["OFF"];
                default:
                    return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Returns CCD ISO sensitivity Description. 
        /// </summary>
        /// <returns>the CCD ISO sensitivity Description.</returns>
        private string GetCcdIsoSensitivityDescription()
        {
            if (!base.directory.ContainsTag(CasioType2Directory.TAG_CASIO_TYPE2_CCD_ISO_SENSITIVITY))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(CasioType2Directory.TAG_CASIO_TYPE2_CCD_ISO_SENSITIVITY);
            switch (lcVal)
            {
                case 0:
                    return BUNDLE["OFF"];
                case 1:
                    return BUNDLE["ON"];
                default:
                    return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Returns best shot mode Description. 
        /// </summary>
        /// <returns>the best shot mode Description.</returns>
        private string GetBestShotModeDescription()
        {
            if (!base.directory.ContainsTag(CasioType2Directory.TAG_CASIO_TYPE2_BESTSHOT_MODE))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(CasioType2Directory.TAG_CASIO_TYPE2_BESTSHOT_MODE);
            switch (lcVal)
            {
                default:
                    return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Returns time zone Description. 
        /// </summary>
        /// <returns>the time zone Description.</returns>
        private string GetTimeZoneDescription()
        {
            if (!base.directory.ContainsTag(CasioType2Directory.TAG_CASIO_TYPE2_TIME_ZONE))
            {
                return null;
            }
            return base.directory.GetString(CasioType2Directory.TAG_CASIO_TYPE2_TIME_ZONE);
        }

        /// <summary>
        /// Returns focus mode 2 Description. 
        /// </summary>
        /// <returns>the focus mode 2 Description.</returns>
        private string GetFocusMode2Description()
        {
            if (!base.directory.ContainsTag(CasioType2Directory.TAG_CASIO_TYPE2_FOCUS_MODE_2))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(CasioType2Directory.TAG_CASIO_TYPE2_FOCUS_MODE_2);
            switch (lcVal)
            {
                case 1:
                    return BUNDLE["FIXATION"];
                case 6:
                    return BUNDLE["MULTI_AREA_FOCUS"];
                default:
                    return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Returns quality description Description. 
        /// </summary>
        /// <returns>the quality description Description.</returns>
        private string GetQualityDescription()
        {
            if (!base.directory.ContainsTag(CasioType2Directory.TAG_CASIO_TYPE2_QUALITY))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(CasioType2Directory.TAG_CASIO_TYPE2_QUALITY);
            switch (lcVal)
            {
                case 3:
                    return BUNDLE["FINE"];
                default:
                    return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Returns self timer Description. 
        /// </summary>
        /// <returns>the self timer Description.</returns>
        private string GetSelfTimerDescription()
        {
            if (!base.directory.ContainsTag(CasioType2Directory.TAG_CASIO_TYPE2_SELF_TIMER))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(CasioType2Directory.TAG_CASIO_TYPE2_SELF_TIMER);
            switch (lcVal)
            {
                case 1:
                    return BUNDLE["OFF"];
                default:
                    return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Returns record mode Description. 
        /// </summary>
        /// <returns>the record mode Description.</returns>
        private string GetRecordModeDescription()
        {
            if (!base.directory.ContainsTag(CasioType2Directory.TAG_CASIO_TYPE2_RECORD_MODE))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(CasioType2Directory.TAG_CASIO_TYPE2_RECORD_MODE);
            switch (lcVal)
            {
                case 2:
                    return BUNDLE["NORMAL"];
                default:
                    return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Returns flash distance Description. 
        /// </summary>
        /// <returns>the flash distance Description.</returns>
        private string GetFlashDistanceDescription()
        {
            if (!base.directory.ContainsTag(CasioType2Directory.TAG_CASIO_TYPE2_FLASH_DISTANCE))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(CasioType2Directory.TAG_CASIO_TYPE2_FLASH_DISTANCE);
            switch (lcVal)
            {
                case 0:
                    return BUNDLE["OFF"];
                default:
                    return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Returns object distance Description. 
        /// </summary>
        /// <returns>the object distance Description.</returns>
        private string GetObjectDistanceDescription()
        {
            if (!base.directory.ContainsTag(CasioType2Directory.TAG_CASIO_TYPE2_OBJECT_DISTANCE))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(CasioType2Directory.TAG_CASIO_TYPE2_OBJECT_DISTANCE);
            return BUNDLE["DISTANCE_MM", lcVal.ToString()];
        }

        /// <summary>
        /// Returns white balance 2 Description. 
        /// </summary>
        /// <returns>the white balance 2 Description.</returns>
        private string GetWhiteBalance2Description()
        {
            if (!base.directory.ContainsTag(CasioType2Directory.TAG_CASIO_TYPE2_WHITE_BALANCE_2))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(CasioType2Directory.TAG_CASIO_TYPE2_WHITE_BALANCE_2);
            switch (lcVal)
            {
                case 0:
                    return BUNDLE["MANUAL"];
                case 1:
                    return BUNDLE["AUTO"]; // unsure about this
                case 4:
                    return BUNDLE["FLASH"]; // unsure about this
                case 12:
                    return BUNDLE["FLASH"];
                default:
                    return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Returns white balance bias Description. 
        /// </summary>
        /// <returns>the white balance bias Description.</returns>
        private string GetWhiteBalanceBiasDescription()
        {
            if (!base.directory.ContainsTag(CasioType2Directory.TAG_CASIO_TYPE2_WHITE_BALANCE_BIAS))
            {
                return null;
            }
            return base.directory.GetString(CasioType2Directory.TAG_CASIO_TYPE2_WHITE_BALANCE_BIAS);
        }

        /// <summary>
        /// Returns casio preview thumbnail Description. 
        /// </summary>
        /// <returns>the casio preview thumbnail Description.</returns>
        private string GetCasioPreviewThumbnailDescription()
        {
            if (!base.directory.ContainsTag(CasioType2Directory.TAG_CASIO_TYPE2_CASIO_PREVIEW_THUMBNAIL))
            {
                return null;
            }
            byte[] lcBytes = base.directory.GetByteArray(CasioType2Directory.TAG_CASIO_TYPE2_CASIO_PREVIEW_THUMBNAIL);
            return BUNDLE["BYTES_OF_IMAGE_DATA", lcBytes.Length.ToString()];
        }

        /// <summary>
        /// Returns Print Image Matching Info Description. 
        /// </summary>
        /// <returns>the Print Image Matching Info Description.</returns>
        private string GetPrintImageMatchingInfoDescription()
        {
            // TODO research PIM specification http://www.ozhiker.com/electronics/pjmt/jpeg_info/pim.html
            if (!base.directory.ContainsTag(CasioType2Directory.TAG_CASIO_TYPE2_PRINT_IMAGE_MATCHING_INFO))
            {
                return null;
            }
            return base.directory.GetString(CasioType2Directory.TAG_CASIO_TYPE2_PRINT_IMAGE_MATCHING_INFO);
        }

        /// <summary>
        /// Returns sharpness description Description. 
        /// </summary>
        /// <returns>the sharpness description Description.</returns>
        private string GetSharpnessDescription()
        {
            if (!base.directory.ContainsTag(CasioType2Directory.TAG_CASIO_TYPE2_SHARPNESS))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(CasioType2Directory.TAG_CASIO_TYPE2_SHARPNESS);
            switch (lcVal)
            {
                case 0:
                    return "-1";
                case 1:
                    return BUNDLE["NORMAL"];
                case 2:
                    return "+1";
                default:
                    return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Returns contrast Description. 
        /// </summary>
        /// <returns>the contrast Description.</returns>
        private string GetContrastDescription()
        {
            if (!base.directory.ContainsTag(CasioType2Directory.TAG_CASIO_TYPE2_CONTRAST))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(CasioType2Directory.TAG_CASIO_TYPE2_CONTRAST);
            switch (lcVal)
            {
                case 0:
                    return "-1";
                case 1:
                    return BUNDLE["NORMAL"];
                case 2:
                    return "+1";
                default:
                    return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Returns saturation Description. 
        /// </summary>
        /// <returns>the saturation Description.</returns>
        private string GetSaturationDescription()
        {
            if (!base.directory.ContainsTag(CasioType2Directory.TAG_CASIO_TYPE2_SATURATION))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(CasioType2Directory.TAG_CASIO_TYPE2_SATURATION);
            switch (lcVal)
            {
                case 0:
                    return "-1";
                case 1:
                    return BUNDLE["NORMAL"];
                case 2:
                    return "+1";
                default:
                    return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Returns focal length Description. 
        /// </summary>
        /// <returns>the focal length Description.</returns>
        private string GetFocalLengthDescription()
        {
            if (!base.directory.ContainsTag(CasioType2Directory.TAG_CASIO_TYPE2_FOCAL_LENGTH)) return null;
            double lcVal = base.directory.GetDouble(CasioType2Directory.TAG_CASIO_TYPE2_FOCAL_LENGTH);
            return BUNDLE["DISTANCE_MM", (lcVal / 10.0).ToString()];
        }

        /// <summary>
        /// Returns white balance 1 Description. 
        /// </summary>
        /// <returns>the white balance 1 Description.</returns>
        private string GetWhiteBalance1Description()
        {
            if (!base.directory.ContainsTag(CasioType2Directory.TAG_CASIO_TYPE2_WHITE_BALANCE_1))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(CasioType2Directory.TAG_CASIO_TYPE2_WHITE_BALANCE_1);
            switch (lcVal)
            {
                case 0:
                    return BUNDLE["AUTO"];
                case 1:
                    return BUNDLE["DAYLIGHT"];
                case 2:
                    return BUNDLE["SHADE"];
                case 3:
                    return BUNDLE["TUNGSTEN"];
                case 4:
                    return BUNDLE["FLUORESCENT"];
                case 5:
                    return BUNDLE["MANUAL"];
                default:
                    return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Returns ISO sensitivity Description. 
        /// </summary>
        /// <returns>the ISO sensitivity Description.</returns>
        private string GetIsoSensitivityDescription()
        {
            if (!base.directory.ContainsTag(CasioType2Directory.TAG_CASIO_TYPE2_ISO_SENSITIVITY))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(CasioType2Directory.TAG_CASIO_TYPE2_ISO_SENSITIVITY);
            switch (lcVal)
            {
                case 3:
                    return BUNDLE["ISO", "50"];
                case 4:
                    return BUNDLE["ISO","64"];
                case 6:
                    return BUNDLE["ISO","100"];
                case 9:
                    return BUNDLE["ISO","200"];
                default:
                    return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Returns focus mode 1 Description. 
        /// </summary>
        /// <returns>the focus mode 1 Description.</returns>
        private string GetFocusMode1Description()
        {
            if (!base.directory.ContainsTag(CasioType2Directory.TAG_CASIO_TYPE2_FOCUS_MODE_1))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(CasioType2Directory.TAG_CASIO_TYPE2_FOCUS_MODE_1);
            switch (lcVal)
            {
                case 0:
                    return BUNDLE["NORMAL"];
                case 1:
                    return BUNDLE["MACRO"];
                default:
                    return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Returns image size Description. 
        /// </summary>
        /// <returns>the image size Description.</returns>
        private string GetImageSizeDescription()
        {
            if (!base.directory.ContainsTag(CasioType2Directory.TAG_CASIO_TYPE2_IMAGE_SIZE))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(CasioType2Directory.TAG_CASIO_TYPE2_IMAGE_SIZE);
            switch (lcVal)
            {
                case 0: return BUNDLE["PIXELS", "640 x 480"];
                case 4: return BUNDLE["PIXELS", "1600 x 1200"];
                case 5: return BUNDLE["PIXELS", "2048 x 1536"];
                case 20: return BUNDLE["PIXELS", "2288 x 1712"];
                case 21: return BUNDLE["PIXELS", "2592 x 1944"];
                case 22: return BUNDLE["PIXELS", "2304 x 1728"];
                case 36: return BUNDLE["PIXELS", "3008 x 2008"];
                default: return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Returns quality mode Description. 
        /// </summary>
        /// <returns>the quality mode Description.</returns>
        private string GetQualityModeDescription()
        {
            if (!base.directory.ContainsTag(CasioType2Directory.TAG_CASIO_TYPE2_QUALITY_MODE))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(CasioType2Directory.TAG_CASIO_TYPE2_QUALITY_MODE);
            switch (lcVal)
            {
                case 1:
                    return BUNDLE["FINE"];
                case 2:
                    return BUNDLE["SUPERFINE"];
                default:
                    return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Returns thumbnail lcOffset Description. 
        /// </summary>
        /// <returns>the thumbnail lcOffset Description.</returns>
        private string GetThumbnailOffsetDescription()
        {
            if (!base.directory.ContainsTag(CasioType2Directory.TAG_CASIO_TYPE2_THUMBNAIL_OFFSET))
            {
                return null;
            }
            return base.directory.GetString(CasioType2Directory.TAG_CASIO_TYPE2_THUMBNAIL_OFFSET);
        }

        /// <summary>
        /// Returns thumbnail size Description. 
        /// </summary>
        /// <returns>the thumbnail size Description.</returns>
        private string GetThumbnailSizeDescription()
        {
            if (!base.directory.ContainsTag(CasioType2Directory.TAG_CASIO_TYPE2_THUMBNAIL_SIZE))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(CasioType2Directory.TAG_CASIO_TYPE2_THUMBNAIL_SIZE);
            return BUNDLE["BYTES", lcVal.ToString()];
        }

        /// <summary>
        /// Returns thumbnail dimension Description. 
        /// </summary>
        /// <returns>the thumbnail dimension Description.</returns>
        private string GetThumbnailDimensionsDescription()
        {
            if (!base.directory.ContainsTag(CasioType2Directory.TAG_CASIO_TYPE2_THUMBNAIL_DIMENSIONS))
            {
                return null;
            }
            int[] lcDimensions = base.directory.GetIntArray(CasioType2Directory.TAG_CASIO_TYPE2_THUMBNAIL_DIMENSIONS);
            if (lcDimensions.Length != 2)
            {
                return base.directory.GetString(CasioType2Directory.TAG_CASIO_TYPE2_THUMBNAIL_DIMENSIONS);
            }
            return BUNDLE["PIXELS_BI", lcDimensions[0].ToString(), lcDimensions[1].ToString()];
        }
    }
}
using System;
using System.Collections;
using System.Text;
using com.drew.metadata;
using com.drew.lang;
using com.utils;

/// <summary>
/// This class was first written by Drew Noakes in Java.
///
/// This is public domain software - that is, you can do whatever you want
/// with it, and include it software that is licensed under the GNU or the
/// BSD license, or whatever other licence you choose, including proprietary
/// closed source licenses.  I do ask that you leave this lcHeader in tact.
///
/// If you make modifications to this code that you think would benefit the
/// wider community, please send me a copy and I'll post it on my site.
///
/// If you make use of this code, Drew Noakes will appreciate hearing 
/// about it: <a href="mailto:drew@drewnoakes.com">drew@drewnoakes.com</a>
///
/// Latest Java version of this software kept at 
/// <a href="http://drewnoakes.com">http://drewnoakes.com/</a>
///
/// The C# class was made by Ferret Renaud: 
/// <a href="mailto:renaud91@free.fr">renaud91@free.fr</a>
/// If you find a bug in the C# code, feel free to mail me.
/// </summary>
namespace com.drew.metadata.exif
{
	/// <summary>
	/// Tag descriptor for almost every images
	/// </summary>
	public class ExifDescriptor : AbstractTagDescriptor 
	{
		/// <summary>
		/// Dictates whether rational values will be represented in decimal format in instances 
		/// where decimal notation is elegant (such as 1/2 -> 0.5, but not 1/3).
		/// </summary>
		private readonly bool allowDecimalRepresentationOfRationals = true;

		/// <summary>
		/// Constructor of the object
		/// </summary>
		/// <param name="directory">a directory</param>
		public ExifDescriptor(AbstractDirectory directory) : base(directory)
		{		
		}

		/// <summary>
		/// Returns a descriptive value of the the specified tag for this image. 
		/// Where possible, known values will be substituted here in place of the raw tokens actually 
		/// kept in the Exif segment. 
		/// If no substitution is available, the value provided by GetString(int) will be returned.
		/// This and GetString(int) are the only 'get' methods that won't throw an exception.
		/// </summary>
		/// <param name="aTagType">the tag to find a description for</param>
		/// <returns>a description of the image'str value for the specified tag, or null if the tag hasn't been defined.</returns>
		public override string GetDescription(int aTagType) 
		{
			switch(aTagType) 
			{
				case ExifDirectory.TAG_ORIENTATION:
					return GetOrientationDescription();
				case ExifDirectory.TAG_RESOLUTION_UNIT:
					return GetResolutionDescription();
				case ExifDirectory.TAG_YCBCR_POSITIONING:
					return GetYCbCrPositioningDescription();
				case ExifDirectory.TAG_EXPOSURE_TIME:
					return GetExposureTimeDescription();
				case ExifDirectory.TAG_SHUTTER_SPEED:
					return GetShutterSpeedDescription();
				case ExifDirectory.TAG_FNUMBER:
					return GetFNumberDescription();
				case ExifDirectory.TAG_X_RESOLUTION:
					return GetXResolutionDescription();
				case ExifDirectory.TAG_Y_RESOLUTION:
					return GetYResolutionDescription();
				case ExifDirectory.TAG_THUMBNAIL_OFFSET:
					return GetThumbnailOffSetDescription();
				case ExifDirectory.TAG_THUMBNAIL_LENGTH:
					return GetThumbnailLengthDescription();
				case ExifDirectory.TAG_COMPRESSION_LEVEL:
					return GetCompressionLevelDescription();
				case ExifDirectory.TAG_SUBJECT_DISTANCE:
					return GetSubjectDistanceDescription();
				case ExifDirectory.TAG_METERING_MODE:
					return GetMeteringModeDescription();
				case ExifDirectory.TAG_FLASH:
					return GetFlashDescription();
				case ExifDirectory.TAG_FOCAL_LENGTH:
					return GetFocalLengthDescription();
				case ExifDirectory.TAG_COLOR_SPACE:
					return GetColorSpaceDescription();
				case ExifDirectory.TAG_EXIF_IMAGE_WIDTH:
					return GetExifImageWidthDescription();
				case ExifDirectory.TAG_EXIF_IMAGE_HEIGHT:
					return GetExifImageHeightDescription();
				case ExifDirectory.TAG_FOCAL_PLANE_UNIT:
					return GetFocalPlaneResolutionUnitDescription();
				case ExifDirectory.TAG_FOCAL_PLANE_X_RES:
					return GetFocalPlaneXResolutionDescription();
				case ExifDirectory.TAG_FOCAL_PLANE_Y_RES:
					return GetFocalPlaneYResolutionDescription();
				case ExifDirectory.TAG_THUMBNAIL_IMAGE_WIDTH:
					return GetThumbnailImageWidthDescription();
				case ExifDirectory.TAG_THUMBNAIL_IMAGE_HEIGHT:
					return GetThumbnailImageHeightDescription();
				case ExifDirectory.TAG_BITS_PER_SAMPLE:
					return GetBitsPerSampleDescription();
				case ExifDirectory.TAG_COMPRESSION:
					return GetCompressionDescription();
				case ExifDirectory.TAG_PHOTOMETRIC_INTERPRETATION:
					return GetPhotometricInterpretationDescription();
				case ExifDirectory.TAG_ROWS_PER_STRIP:
					return GetRowsPerStripDescription();
				case ExifDirectory.TAG_STRIP_BYTE_COUNTS:
					return GetStripByteCountsDescription();
				case ExifDirectory.TAG_SAMPLES_PER_PIXEL:
					return GetSamplesPerPixelDescription();
				case ExifDirectory.TAG_PLANAR_CONFIGURATION:
					return GetPlanarConfigurationDescription();
				case ExifDirectory.TAG_YCBCR_SUBSAMPLING:
					return GetYCbCrSubsamplingDescription();
				case ExifDirectory.TAG_EXPOSURE_PROGRAM:
					return GetExposureProgramDescription();
				case ExifDirectory.TAG_APERTURE:
					return GetApertureValueDescription();
				case ExifDirectory.TAG_MAX_APERTURE:
					return GetMaxApertureValueDescription();
				case ExifDirectory.TAG_SENSING_METHOD:
					return GetSensingMethodDescription();
				case ExifDirectory.TAG_EXPOSURE_BIAS:
					return GetExposureBiasDescription();
				case ExifDirectory.TAG_FILE_SOURCE:
					return GetFileSourceDescription();
				case ExifDirectory.TAG_SCENE_TYPE:
					return GetSceneTypeDescription();
				case ExifDirectory.TAG_COMPONENTS_CONFIGURATION:
					return GetComponentConfigurationDescription();
				case ExifDirectory.TAG_EXIF_VERSION:
					return GetExifVersionDescription();
				case ExifDirectory.TAG_FLASHPIX_VERSION:
					return GetFlashPixVersionDescription();
				case ExifDirectory.TAG_REFERENCE_BLACK_WHITE:
					return GetReferenceBlackWhiteDescription();
				case ExifDirectory.TAG_ISO_EQUIVALENT:
					return GetIsoEquivalentDescription();
				case ExifDirectory.TAG_THUMBNAIL_DATA:
					return GetThumbnailDescription();
				case ExifDirectory.TAG_XP_AUTHOR:
					return GetXPAuthorDescription();
				case ExifDirectory.TAG_XP_COMMENTS:
					return GetXPCommentsDescription();
				case ExifDirectory.TAG_XP_KEYWORDS:
					return GetXPKeywordsDescription();
				case ExifDirectory.TAG_XP_SUBJECT:
					return GetXPSubjectDescription();
				case ExifDirectory.TAG_XP_TITLE:
					return GetXPTitleDescription();
                case ExifDirectory.TAG_SUBFILE_TYPE:
                    return GetNewSubfileTypeDescription();
                case ExifDirectory.TAG_NEW_SUBFILE_TYPE :
                    return GetNewSubfileTypeDescription();
                case ExifDirectory.TAG_THRESHOLDING :
                    return GetThresholdingDescription();
                case ExifDirectory.TAG_FILL_ORDER :
                    return GetFillOrderDescription();
                case ExifDirectory.TAG_SUBJECT_DISTANCE_RANGE :
                    return GetSubjectDistanceRangeDescription();
                case ExifDirectory.TAG_SHARPNESS :
                    return GetSharpnessDescription();
                case ExifDirectory.TAG_SATURATION :
                    return GetSaturationDescription();
                case ExifDirectory.TAG_CONTRAST:
                    return GetContrastDescription();
                case ExifDirectory.TAG_GAIN_CONTROL:
                    return GetGainControlDescription();
                case ExifDirectory.TAG_SCENE_CAPTURE_TYPE:
                    return GetSceneCaptureTypeDescription();
                case ExifDirectory.TAG_FOCAL_LENGTH_IN_35MM_FILM:
                    return Get35mmFilmEquivFocalLengthDescription();
                case ExifDirectory.TAG_DIGITAL_ZOOM_RATIO:
                    return GetDigitalZoomRatioDescription();
                case ExifDirectory.TAG_WHITE_BALANCE_MODE :
                    return GetWhiteBalanceModeDescription();
                case ExifDirectory.TAG_EXPOSURE_MODE:
                    return GetExposureModeDescription();

				default :
					return base.directory.GetString(aTagType);
			}
		}

        /// <summary>
        /// Gets the custom rendered description.
        /// </summary>
        /// <returns>The custom rendered description</returns>
        private string GetCustomRenderedDescription()
        {
            if (!base.directory.ContainsTag(ExifDirectory.TAG_CUSTOM_RENDERED))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(ExifDirectory.TAG_CUSTOM_RENDERED);
            switch (lcVal)
            {
                case 0:
                    return BUNDLE["NORMAL_PROCESS"];
                case 1:
                    return BUNDLE["CUSTOM_PROCESS"];
                default:
                    return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Gets the exposure mode description.
        /// </summary>
        /// <returns>The exposure mode description</returns>
        private string GetExposureModeDescription()
        {
            if (!base.directory.ContainsTag(ExifDirectory.TAG_EXPOSURE_MODE))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(ExifDirectory.TAG_EXPOSURE_MODE);
            switch (lcVal)
            {
                case 0:
                    return BUNDLE["AUTO_EXPOSURE"];
                case 1:
                    return BUNDLE["MANUAL_EXPOSURE"];
                case 2:
                    return BUNDLE["AUTO_BRACKET"];
                default:
                    return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }


        /// <summary>
        /// Gets the white balance mode description.
        /// </summary>
        /// <returns>The white balance mode description</returns>
        private string GetWhiteBalanceModeDescription()
        {
            if (!base.directory.ContainsTag(ExifDirectory.TAG_WHITE_BALANCE_MODE))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(ExifDirectory.TAG_WHITE_BALANCE_MODE);
            switch (lcVal)
            {
                case 0:
                    return BUNDLE["AUTO_WHITE_BALANCE"];
                case 1:
                    return BUNDLE["MANUAL_WHITE_BALANCE"];
                default:
                    return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }


        /// <summary>
        /// Gets the digital zoom ratio description.
        /// </summary>
        /// <returns>The digital zoom ratio description</returns>
        private string GetDigitalZoomRatioDescription()
        {
            if (!base.directory.ContainsTag(ExifDirectory.TAG_DIGITAL_ZOOM_RATIO))
            {
                return null;
            }
            Rational lcRational = base.directory.GetRational(ExifDirectory.TAG_DIGITAL_ZOOM_RATIO);
            if (lcRational.GetNumerator() == 0)
            {
                return BUNDLE["DIGITAL_ZOOM_NOT_USED"];
            }

            return (lcRational.DoubleValue()).ToString();
        }

        /// <summary>
        /// Gets the 35mm film equivalent focal length description.
        /// </summary>
        /// <returns>The 35mm film equivalent focal length description</returns>
        private string Get35mmFilmEquivFocalLengthDescription()
        {
            if (!base.directory.ContainsTag(ExifDirectory.TAG_FOCAL_LENGTH_IN_35MM_FILM))
            {
                return null;
            }
            int lcEquivalentFocalLength = base.directory.GetInt(ExifDirectory.TAG_FOCAL_LENGTH_IN_35MM_FILM);

            if (lcEquivalentFocalLength == 0)
            {
                return BUNDLE["UNKNOWN", lcEquivalentFocalLength.ToString()];
            }
            return BUNDLE["DISTANCE_MM", lcEquivalentFocalLength.ToString()];
        }

        /// <summary>
        /// Gets the scene capture type description.
        /// </summary>
        /// <returns>The scene capture type description</returns>
        private string GetSceneCaptureTypeDescription()
        {
            if (!base.directory.ContainsTag(ExifDirectory.TAG_SCENE_CAPTURE_TYPE))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(ExifDirectory.TAG_SCENE_CAPTURE_TYPE);
            switch (lcVal)
            {
                case 0:
                    return BUNDLE["STANDARD"];
                case 1:
                    return BUNDLE["LANDSCAPE"];
                case 2:
                    return BUNDLE["PORTRAIT"];
                case 3:
                    return BUNDLE["NIGHT_SCENE"];
                default:
                    return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Gets the gain control description.
        /// </summary>
        /// <returns>The gain control description</returns>
        private string GetGainControlDescription()
        {
            if (!base.directory.ContainsTag(ExifDirectory.TAG_GAIN_CONTROL))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(ExifDirectory.TAG_GAIN_CONTROL);
            switch (lcVal)
            {
                case 0:
                    return BUNDLE["NONE"];
                case 1:
                    return BUNDLE["LOW_GAIN_UP"];
                case 2:
                    return BUNDLE["LOW_GAIN_DOWN"];
                case 3:
                    return BUNDLE["HIGH_GAIN_UP"];
                case 4:
                    return BUNDLE["HIGH_GAIN_DOWN"];
                default:
                    return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }


        /// <summary>
        /// Gets the contrast description.
        /// </summary>
        /// <returns>The constrast description</returns>
        private string GetContrastDescription()
        {
            if (!base.directory.ContainsTag(ExifDirectory.TAG_CONTRAST))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(ExifDirectory.TAG_CONTRAST);
            switch (lcVal)
            {
                case 0:
                    return BUNDLE["NONE"];
                case 1:
                    return BUNDLE["SOFT"];
                case 2:
                    return BUNDLE["HARD"];
                default:
                    return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Gets the subfile type description.
        /// </summary>
        /// <returns>The subfile type description</returns>
        private string getSubfileTypeDescription()
        {
            if (!base.directory.ContainsTag(ExifDirectory.TAG_SUBFILE_TYPE))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(ExifDirectory.TAG_SUBFILE_TYPE);
            switch (lcVal)
            {
                case 1: return BUNDLE["FULL_RESOLUTION_IMAGE"];
                case 2: return BUNDLE["REDUCED_RESOLUTION_IMAGE"];
                case 3: return BUNDLE["SINGLE_PAGE_OF_MULTI_PAGE_IMAGE"];
                default:
                    return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Gets the new subfile type description.
        /// </summary>
        /// <returns>The new subfile type description</returns>
        private string GetNewSubfileTypeDescription()
        {
            if (!base.directory.ContainsTag(ExifDirectory.TAG_NEW_SUBFILE_TYPE))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(ExifDirectory.TAG_NEW_SUBFILE_TYPE);
            switch (lcVal)
            {
                case 1: return BUNDLE["FULL_RESOLUTION_IMAGE"];
                case 2: return BUNDLE["REDUCED_RESOLUTION_IMAGE"];
                case 3: return BUNDLE["SINGLE_PAGE_OF_MULTI_PAGE_REDUCED_RESOLUTION_IMAGE"];
                case 4: return BUNDLE["TRANSPARENCY_MASK"];
                case 5: return BUNDLE["TRANSPARENCY_MASK_OF_REDUCED_RESOLUTION_IMAGE"];
                case 6: return BUNDLE["TRANSPARENCY_MASK_OF_MULTI_PAGE_IMAGE"];
                case 7: return BUNDLE["TRANSPARENCY_MASK_OF_REDUCED_RESOLUTION_MULTI_PAGE_IMAGE"];
                default:
                    return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Gets the new thresholding description.
        /// </summary>
        /// <returns>The thresholding description</returns>
        private string GetThresholdingDescription()
        {
            if (!base.directory.ContainsTag(ExifDirectory.TAG_THRESHOLDING))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(ExifDirectory.TAG_THRESHOLDING);
            switch (lcVal)
            {
                case 1: return BUNDLE["NO_DITHERING_OR_HALFTONING"];
                case 2: return BUNDLE["ORDERED_DITHER_OR_HALFTONE"];
                case 3: return BUNDLE["RANDOMIZED_DITHER"];
                default:
                    return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Gets the fill order description.
        /// </summary>
        /// <returns>The fill order description</returns>
        private string GetFillOrderDescription()
        {
            if (!base.directory.ContainsTag(ExifDirectory.TAG_FILL_ORDER))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(ExifDirectory.TAG_FILL_ORDER);
            switch (lcVal)
            {
                case 1: return BUNDLE["NORMAL"];
                case 2: return BUNDLE["REVERSED"];
                default:
                    return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Gets the subject distance range description.
        /// </summary>
        /// <returns>The subject distance range description</returns>
        private string GetSubjectDistanceRangeDescription()
        {
            if (!base.directory.ContainsTag(ExifDirectory.TAG_SUBJECT_DISTANCE_RANGE))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(ExifDirectory.TAG_SUBJECT_DISTANCE_RANGE);
            switch (lcVal)
            {
                case 1:
                    return BUNDLE["MACRO"];
                case 2:
                    return BUNDLE["CLOSE_VIEW"];
                case 3:
                    return BUNDLE["DISTANT_VIEW"];
                default:
                    return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Gets the sharpness description.
        /// </summary>
        /// <returns>The sharpness description</returns>
        private string GetSharpnessDescription()
        {
            if (!base.directory.ContainsTag(ExifDirectory.TAG_SHARPNESS))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(ExifDirectory.TAG_SHARPNESS);
            switch (lcVal)
            {
                case 0:
                    return BUNDLE["NONE"];
                case 1:
                    return BUNDLE["LOW"];
                case 2:
                    return BUNDLE["HARD"];
                default:
                    return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }

        /// <summary>
        /// Gets the saturation description.
        /// </summary>
        /// <returns>The saturation description</returns>
        private string GetSaturationDescription()
        {
            if (!base.directory.ContainsTag(ExifDirectory.TAG_SATURATION))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(ExifDirectory.TAG_SATURATION);
            switch (lcVal)
            {
                case 0:
                    return BUNDLE["NONE"];
                case 1:
                    return BUNDLE["LOW_SATURATION"];
                case 2:
                    return BUNDLE["HIGH_SATURATION"];
                default:
                    return BUNDLE["UNKNOWN", lcVal.ToString()];
            }
        }



		/// <summary>
		/// Returns the Thumbnail Description. 
		/// </summary>
		/// <returns>the Thumbnail Description.</returns>
		private string GetThumbnailDescription() 
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_THUMBNAIL_DATA))
            {
                return null;
            }
			int[] lcThumbnailBytes =
				base.directory.GetIntArray(ExifDirectory.TAG_THUMBNAIL_DATA);
			return BUNDLE["THUMBNAIL_BYTES", lcThumbnailBytes.Length.ToString()];
		}

		/// <summary>
		/// Returns the Iso Equivalent Description. 
		/// </summary>
		/// <returns>the Iso Equivalent Description.</returns>
		private string GetIsoEquivalentDescription() 
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_ISO_EQUIVALENT))
            {
                return null;
            }
			int lcIsoEquiv = base.directory.GetInt(ExifDirectory.TAG_ISO_EQUIVALENT);
			if (lcIsoEquiv < 50) 
			{
				lcIsoEquiv *= 200;
			}
			return lcIsoEquiv.ToString();
		}

		/// <summary>
		/// Returns the Reference Black White Description. 
		/// </summary>
		/// <returns>the Reference Black White Description.</returns>
		private string GetReferenceBlackWhiteDescription()
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_REFERENCE_BLACK_WHITE))
            {
                return null;
            }
			int[] lcInts =
				base.directory.GetIntArray(ExifDirectory.TAG_REFERENCE_BLACK_WHITE);

			string[] lcSPos = new string[] {lcInts[0].ToString(), lcInts[1].ToString(),lcInts[2].ToString(),lcInts[3].ToString(),lcInts[4].ToString(),lcInts[5].ToString()};
			return BUNDLE["POS",lcSPos];
		}

		/// <summary>
		/// Returns the Exif Version Description. 
		/// </summary>
		/// <returns>the Exif Version Description.</returns>
		private string GetExifVersionDescription() 
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_EXIF_VERSION))
            {
                return null;
            }
			int[] lcInts = base.directory.GetIntArray(ExifDirectory.TAG_EXIF_VERSION);
			return ExifDescriptor.ConvertBytesToVersionString(lcInts);
		}

		/// <summary>
		/// Returns the Flash Pix Version Description. 
		/// </summary>
		/// <returns>the Flash Pix Version Description.</returns>
		private string GetFlashPixVersionDescription() 
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_FLASHPIX_VERSION))
            {
                return null;
            }
			int[] lcInts = base.directory.GetIntArray(ExifDirectory.TAG_FLASHPIX_VERSION);
			return ExifDescriptor.ConvertBytesToVersionString(lcInts);
		}

		/// <summary>
		/// Returns the Scene Type Description. 
		/// </summary>
		/// <returns>the Scene Type Description.</returns>
		private string GetSceneTypeDescription() 
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_SCENE_TYPE))
            {
                return null;
            }
			int lcSceneType = base.directory.GetInt(ExifDirectory.TAG_SCENE_TYPE);
			if (lcSceneType == 1) 
			{
				return BUNDLE["DIRECTLY_PHOTOGRAPHED_IMAGE"];
			} 
			return BUNDLE["UNKNOWN", lcSceneType.ToString()];
		}

		/// <summary>
		/// Returns the File Source Description. 
		/// </summary>
		/// <returns>the File Source Description.</returns>
		private string GetFileSourceDescription() 
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_FILE_SOURCE))
            {
                return null;
            }
			int lcFileSource = base.directory.GetInt(ExifDirectory.TAG_FILE_SOURCE);
			if (lcFileSource == 3) 
			{
				return BUNDLE["DIGITAL_STILL_CAMERA"];
			} 
			return BUNDLE["UNKNOWN", lcFileSource.ToString()];
		}

		/// <summary>
		/// Returns the Exposure Bias Description. 
		/// </summary>
		/// <returns>the Exposure Bias Description.</returns>
		private string GetExposureBiasDescription() 
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_EXPOSURE_BIAS))
            {
                return null;
            }
			Rational lcExposureBias =
				base.directory.GetRational(ExifDirectory.TAG_EXPOSURE_BIAS);
			return lcExposureBias.ToSimpleString(true);
		}

		/// <summary>
		/// Returns the Max Aperture Value Description. 
		/// </summary>
		/// <returns>the Max Aperture Value Description.</returns>
		private string GetMaxApertureValueDescription() 
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_MAX_APERTURE))
            {
                return null;
            }
			double lcApertureApex =
				base.directory.GetDouble(ExifDirectory.TAG_MAX_APERTURE);
			double lcRootTwo = Math.Sqrt(2);
			double lcFStop = Math.Pow(lcRootTwo, lcApertureApex);
			return BUNDLE["APERTURE", lcFStop.ToString("0.#")];
		}

		/// <summary>
		/// Returns the Aperture Value Description. 
		/// </summary>
		/// <returns>the Aperture Value Description.</returns>
		private string GetApertureValueDescription() 
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_APERTURE))
            {
                return null;
            }
			double lcApertureApex = base.directory.GetDouble(ExifDirectory.TAG_APERTURE);
			double lcRootTwo = Math.Sqrt(2);
			double lcFStop = Math.Pow(lcRootTwo, lcApertureApex);
			return BUNDLE["APERTURE", lcFStop.ToString("0.#")];
		}

		/// <summary>
		/// Returns the Exposure Program Description. 
		/// </summary>
		/// <returns>the Exposure Program Description.</returns>
		private string GetExposureProgramDescription() 
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_EXPOSURE_PROGRAM))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(ExifDirectory.TAG_EXPOSURE_PROGRAM);
			switch (lcVal) 
			{
				case 1 :
					return BUNDLE["MANUAL_CONTROL"];
				case 2 :
					return BUNDLE["PROGRAM_NORMAL"];
				case 3 :
					return BUNDLE["APERTURE_PRIORITY"];
				case 4 :
					return BUNDLE["SHUTTER_PRIORITY"];
				case 5 :
					return BUNDLE["PROGRAM_CREATIVE"];
				case 6 :
					return BUNDLE["PROGRAM_ACTION"];
				case 7 :
					return BUNDLE["PORTRAIT_MODE"];
				case 8 :
					return BUNDLE["LANDSCAPE_MODE"];
				default :
					return BUNDLE["UNKNOWN_PROGRAM", lcVal.ToString()];
			}
		}

		/// <summary>
		/// Returns the YCbCr Subsampling Description. 
		/// </summary>
		/// <returns>the YCbCr Subsampling Description.</returns>
		private string GetYCbCrSubsamplingDescription() 
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_YCBCR_SUBSAMPLING))
            {
                return null;
            }
			int[] lcPositions =
				base.directory.GetIntArray(ExifDirectory.TAG_YCBCR_SUBSAMPLING);
			if (lcPositions[0] == 2 && lcPositions[1] == 1) 
			{
				return BUNDLE["YCBCR_422"];
			} 
			else if (lcPositions[0] == 2 && lcPositions[1] == 2) 
			{
				return BUNDLE["YCBCR_420"];
			} 
    		return BUNDLE["UNKNOWN"];
		}

		/// <summary>
		/// Returns the Planar Configuration Description. 
		/// </summary>
		/// <returns>the Planar Configuration Description.</returns>
		private string GetPlanarConfigurationDescription()
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_PLANAR_CONFIGURATION))
            {
                return null;
            }
			// When image format is no compression YCbCr, this aValue shows byte aligns of YCbCr
			// data. If aValue is '1', Y/Cb/Cr aValue is chunky format, contiguous for each subsampling
			// pixel. If aValue is '2', Y/Cb/Cr aValue is separated and stored to Y plane/Cb plane/Cr
			// plane format.

			switch (base.directory.GetInt(ExifDirectory.TAG_PLANAR_CONFIGURATION)) 
			{
				case 1 :
					return BUNDLE["CHUNKY"];
				case 2 :
					return BUNDLE["SEPARATE"];
				default :
					return BUNDLE["UNKNOWN_CONFIGURATION"];
			}
		}

		/// <summary>
		/// Returns the Samples Per Pixel Description. 
		/// </summary>
		/// <returns>the Samples Per Pixel Description.</returns>
		private string GetSamplesPerPixelDescription() 
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_SAMPLES_PER_PIXEL))
            {
                return null;
            }
			return BUNDLE["SAMPLES_PIXEL", base.directory.GetString(ExifDirectory.TAG_SAMPLES_PER_PIXEL)];
		}

		/// <summary>
		/// Returns the Rows Per Strip Description. 
		/// </summary>
		/// <returns>the Rows Per Strip Description.</returns>
		private string GetRowsPerStripDescription() 
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_ROWS_PER_STRIP))
            {
                return null;
            }
			return BUNDLE["ROWS_STRIP", base.directory.GetString(ExifDirectory.TAG_ROWS_PER_STRIP)];
		}

		/// <summary>
		/// Returns the Strip Byte Counts Description. 
		/// </summary>
		/// <returns>the Strip Byte Counts Description.</returns>
		private string GetStripByteCountsDescription() 
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_STRIP_BYTE_COUNTS))
            {
                return null;
            }
			return BUNDLE["BYTES", base.directory.GetString(ExifDirectory.TAG_STRIP_BYTE_COUNTS)];
		}

		/// <summary>
		/// Returns the Photometric Interpretation Description. 
		/// </summary>
		/// <returns>the Photometric Interpretation Description.</returns>
		private string GetPhotometricInterpretationDescription()
		{
            if (!base.directory
                .ContainsTag(ExifDirectory.TAG_PHOTOMETRIC_INTERPRETATION))
            {
                return null;
            }
			// Shows the color space of the image data components. '1' means monochrome,
			// '2' means RGB, '6' means YCbCr.
            switch (base.directory
                .GetInt(ExifDirectory.TAG_PHOTOMETRIC_INTERPRETATION))
            {
                case 0: return BUNDLE["WHITE_IS_ZERO"];
                case 1: return BUNDLE["BLACK_IS_ZERO"];
                case 2: return BUNDLE["RGB"];
                case 3: return BUNDLE["RGB_PALETTE"];
                case 4: return BUNDLE["TRANSPARENCY_MASK"];
                case 5: return BUNDLE["CMYK"];
                case 6: return BUNDLE["YCBCR"];
                case 8: return BUNDLE["CIELAB"];
                case 9: return BUNDLE["ICCLAB"];
                case 10: return BUNDLE["ITULAB"];
                case 32803: return BUNDLE["COLOR_FILTER_ARRAY"];
                case 32844: return BUNDLE["PIXAR_LOGL"];
                case 32845: return BUNDLE["PIXAR_LOGLUV"];
                case 32892: return BUNDLE["LINEAR_RAW"];
                default: return BUNDLE["UNKNOWN_COLOR_SPACE"];
            }
		}

		/// <summary>
		/// Returns the Compression Description. 
		/// </summary>
		/// <returns>the Compression Description.</returns>
		private string GetCompressionDescription() 
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_COMPRESSION))
            {
                return null;
            }
			// '1' means no compression, '6' means JPEG compression.
            switch (base.directory.GetInt(ExifDirectory.TAG_COMPRESSION))
            {
                case 1: return BUNDLE["UNCOMPRESSED"];
                case 2: return BUNDLE["CCITT_1D"];
                case 3: return BUNDLE["T4_GROUP_3_FAC"];
                case 4: return BUNDLE["T6_GROUP_4_FAC"];
                case 5: return BUNDLE["LZW"];
                case 6: return BUNDLE["JPEG_OLD_STYLE"];
                case 7: return BUNDLE["JPEG"];
                case 8: return BUNDLE["ADOBE_DEFLATE"];
                case 9: return BUNDLE["JBIG_B_W"];
                case 10: return BUNDLE["JBIG_COLOR"];
                case 32766: return BUNDLE["NEXT"];
                case 32771: return BUNDLE["CCIRLEW"];
                case 32773: return BUNDLE["PACKBITS"];
                case 32809: return BUNDLE["THUNDERSCA"];
                case 32895: return BUNDLE["IT8CTPAD"];
                case 32896: return BUNDLE["IT8LW"];
                case 32897: return BUNDLE["IT8MP"];
                case 32898: return BUNDLE["IT8BL"];
                case 32908: return BUNDLE["PIXARFILM"];
                case 32909: return BUNDLE["PIXARLOG"];
                case 32946: return BUNDLE["DEFLATE"];
                case 32947: return BUNDLE["DCS"];
                case 32661: return BUNDLE["JBIG"];
                case 32676: return BUNDLE["SGILOG"];
                case 32677: return BUNDLE["SGILOG24"];
                case 32712: return BUNDLE["JPEG_2000"];
                case 32713: return BUNDLE["NIKON_NEF_COMPRESSED"];
                default: return BUNDLE["UNKNOWN_COMPRESSION"];
            }
		}

		/// <summary>
		/// Returns the Bits Per Sample Description. 
		/// </summary>
		/// <returns>the Bits Per Sample Description.</returns>
		private string GetBitsPerSampleDescription() 
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_BITS_PER_SAMPLE))
            {
                return null;
            }
			return BUNDLE["BITS_COMPONENT_PIXEL",base.directory.GetString(ExifDirectory.TAG_BITS_PER_SAMPLE)];
		}

		/// <summary>
		/// Returns the Thumbnail Image Width Description. 
		/// </summary>
		/// <returns>the Thumbnail Image Width Description.</returns>
		private string GetThumbnailImageWidthDescription() 
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_THUMBNAIL_IMAGE_WIDTH))
            {
                return null;
            }
			return BUNDLE["PIXELS", base.directory.GetString(ExifDirectory.TAG_THUMBNAIL_IMAGE_WIDTH)];
		}

		/// <summary>
		/// Returns the Thumbnail Image Height Description. 
		/// </summary>
		/// <returns>the Thumbnail Image Height Description.</returns>
		private string GetThumbnailImageHeightDescription() 
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_THUMBNAIL_IMAGE_HEIGHT))
            {
                return null;
            }
			return BUNDLE["PIXELS", base.directory.GetString(ExifDirectory.TAG_THUMBNAIL_IMAGE_HEIGHT)];
		}

		/// <summary>
		/// Returns the Focal Plane X Resolution Description. 
		/// </summary>
		/// <returns>the Focal Plane X Resolution Description.</returns>
		private string GetFocalPlaneXResolutionDescription()
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_FOCAL_PLANE_X_RES))
            {
                return null;
            }
			Rational lcRational =
				base.directory.GetRational(ExifDirectory.TAG_FOCAL_PLANE_X_RES);
			return BUNDLE["FOCAL_PLANE", lcRational.GetReciprocal().ToSimpleString(allowDecimalRepresentationOfRationals),
			GetFocalPlaneResolutionUnitDescription().ToLower()];
		}

		/// <summary>
		/// Returns the Focal Plane Y Resolution Description. 
		/// </summary>
		/// <returns>the Focal Plane Y Resolution Description.</returns>
		private string GetFocalPlaneYResolutionDescription()
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_FOCAL_PLANE_Y_RES))
            {
                return null;
            }
			Rational lcRational =
				base.directory.GetRational(ExifDirectory.TAG_FOCAL_PLANE_Y_RES);
			return BUNDLE["FOCAL_PLANE", lcRational.GetReciprocal().ToSimpleString(allowDecimalRepresentationOfRationals),
				GetFocalPlaneResolutionUnitDescription().ToLower()];
		}

		/// <summary>
		/// Returns the Focal Plane Resolution Unit Description. 
		/// </summary>
		/// <returns>the Focal Plane Resolution Unit Description.</returns>
		private string GetFocalPlaneResolutionUnitDescription()
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_FOCAL_PLANE_UNIT))
            {
                return null;
            }
			// Unit of FocalPlaneXResoluton/FocalPlaneYResolution. '1' means no-unit,
			// '2' inch, '3' centimeter.
			switch (base.directory.GetInt(ExifDirectory.TAG_FOCAL_PLANE_UNIT)) 
			{
				case 1 :
					return BUNDLE["NO_UNIT"];
				case 2 :
					return BUNDLE["INCHES"];
				case 3 :
					return BUNDLE["CM"];
				default :
					return "";
			}
		}

		/// <summary>
		/// Returns the Exif Image Width Description. 
		/// </summary>
		/// <returns>the Exif Image Width Description.</returns>
		private string GetExifImageWidthDescription() 
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_EXIF_IMAGE_WIDTH))
            {
                return null;
            }
			return BUNDLE["PIXELS", base.directory.GetInt(ExifDirectory.TAG_EXIF_IMAGE_WIDTH).ToString()];
		}

		/// <summary>
		/// Returns the Exif Image Height Description. 
		/// </summary>
		/// <returns>the Exif Image Height Description.</returns>
		private string GetExifImageHeightDescription() 
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_EXIF_IMAGE_HEIGHT))
            {
                return null;
            }
			return BUNDLE["PIXELS", base.directory.GetInt(ExifDirectory.TAG_EXIF_IMAGE_HEIGHT).ToString()];
		}

		/// <summary>
		/// Returns the Color Space Description. 
		/// </summary>
		/// <returns>the Color Space Description.</returns>
		private string GetColorSpaceDescription() 
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_COLOR_SPACE))
            {
                return null;
            }
			int lcColorSpace = base.directory.GetInt(ExifDirectory.TAG_COLOR_SPACE);
            switch (lcColorSpace)
            {
                case 1: return BUNDLE["SRGB"];
                case 65535: return BUNDLE["UNDEFINED"];
                default: return BUNDLE["UNKNOWN"];
            }
		}

		/// <summary>
		/// Returns the Focal Length Description. 
		/// </summary>
		/// <returns>the Focal Length Description.</returns>
		private string GetFocalLengthDescription() 
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_FOCAL_LENGTH))
            {
                return null;
            }
			Rational lcFocalLength =
				base.directory.GetRational(ExifDirectory.TAG_FOCAL_LENGTH);
			return BUNDLE["DISTANCE_MM", (lcFocalLength.DoubleValue()).ToString("0.0##")];
		}

		/// <summary>
		/// Returns the Flash Description. 
		/// </summary>
		/// <returns>the Flash Description.</returns>
		private string GetFlashDescription() 
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_FLASH))
            {
                return null;
            }          
            int lcVal = base.directory.GetInt(ExifDirectory.TAG_FLASH);
            StringBuilder sb = new StringBuilder();

            if ((lcVal & 0x1) != 0)
            {
                sb.Append(BUNDLE["FLASH_FIRED"]);
            }
            else
            {
                sb.Append(BUNDLE["FLASH_DID_NOT_FIRE"]);
            }

            // check if we're able to detect a return, before we mention it
            if ((lcVal & 0x4) != 0)
            {
                sb.Append(", ");
                if ((lcVal & 0x2) != 0)
                {
                    sb.Append(BUNDLE["RETURN_DETECTED"]);
                }
                else
                {
                    sb.Append(BUNDLE["RETURN_NOT_DETECTED"]);
                }
            }

            if ((lcVal & 0x10) != 0)
            {
                sb.Append(", ").Append(BUNDLE["AUTO"]);
            }

            if ((lcVal & 0x40) != 0)
            {
                sb.Append(", ").Append(BUNDLE["RED_EYE_REDUCTION"]);
            }

            return sb.ToString();
		}

		/// <summary>
		/// Returns the light source Description. 
		/// </summary>
        /// <returns>the light source Description.</returns>
		private string GetLightSourceDescription() 
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_LIGHT_SOURCE))
            {
                return null;
            }
            int lcVal = base.directory.GetInt(ExifDirectory.TAG_LIGHT_SOURCE);
			switch (lcVal) 
			{
				case 0 :
					return BUNDLE["UNKNOWN"];
				case 1 :
					return BUNDLE["DAYLIGHT"];
				case 2 :
					return BUNDLE["FLUORESCENT"];
				case 3 :
					return BUNDLE["TUNGSTEN"];
				case 10 :
					return BUNDLE["FLASH"];
				case 17 :
					return BUNDLE["STANDARD_LIGHT"];
				case 18 :
					return BUNDLE["STANDARD_LIGHT_B"];
				case 19 :
					return BUNDLE["STANDARD_LIGHT_C"];
				case 20 :
					return BUNDLE["D55"];
				case 21 :
					return BUNDLE["D65"];
				case 22 :
					return BUNDLE["D75"];
				case 255 :
					return BUNDLE["OTHER"];
				default :
					return BUNDLE["UNKNOWN", lcVal.ToString()];
			}
		}

		/// <summary>
		/// Returns the Metering Mode Description. 
		/// </summary>
		/// <returns>the Metering Mode Description.</returns>
		private string GetMeteringModeDescription() 
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_METERING_MODE))
            {
                return null;
            }
			// '0' means unknown, '1' average, '2' center weighted average, '3' spot
			// '4' multi-spot, '5' multi-segment, '6' partial, '255' other
			int lcMeteringMode = base.directory.GetInt(ExifDirectory.TAG_METERING_MODE);
			switch (lcMeteringMode) 
			{
				case 0 :
					return BUNDLE["UNKNOWN"];
				case 1 :
					return BUNDLE["AVERAGE"];
				case 2 :
					return BUNDLE["CENTER_WEIGHTED_AVERAGE"];
				case 3 :
					return BUNDLE["SPOT"];
				case 4 :
					return BUNDLE["MULTI_SPOT"];
				case 5 :
					return BUNDLE["MULTI_SEGMENT"];
				case 6 :
					return BUNDLE["PARTIAL"];
				case 255 :
					return BUNDLE["OTHER"];
				default :
					return "";
			}
		}

		/// <summary>
		/// Returns the Subject Distance Description. 
		/// </summary>
		/// <returns>the Subject Distance Description.</returns>
		private string GetSubjectDistanceDescription() 
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_SUBJECT_DISTANCE))
            {
                return null;
            }
			Rational lcDistance =
				base.directory.GetRational(ExifDirectory.TAG_SUBJECT_DISTANCE);
			return BUNDLE["METRES", (lcDistance.DoubleValue()).ToString("0.0##")];
		}

		/// <summary>
		/// Returns the Compression Level Description. 
		/// </summary>
		/// <returns>the Compression Level Description.</returns>
		private string GetCompressionLevelDescription() 
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_COMPRESSION_LEVEL))
            {
                return null;
            }
			Rational lcCompressionRatio =
				base.directory.GetRational(ExifDirectory.TAG_COMPRESSION_LEVEL);
			string lcRatio =
				lcCompressionRatio.ToSimpleString(
				allowDecimalRepresentationOfRationals);
			if (lcCompressionRatio.IsInteger() && lcCompressionRatio.IntValue() == 1) 
			{
				return BUNDLE["BIT_PIXEL", lcRatio];
			} 
    		return BUNDLE["BITS_PIXEL", lcRatio];
		}

		/// <summary>
		/// Returns the Thumbnail Length Description. 
		/// </summary>
		/// <returns>the Thumbnail Length Description.</returns>
		private string GetThumbnailLengthDescription() 
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_THUMBNAIL_LENGTH))
            {
                return null;
            }
			return BUNDLE["BYTES", base.directory.GetString(ExifDirectory.TAG_THUMBNAIL_LENGTH)];
		}

		/// <summary>
		/// Returns the Thumbnail OffSet Description. 
		/// </summary>
		/// <returns>the Thumbnail OffSet Description.</returns>
		private string GetThumbnailOffSetDescription() 
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_THUMBNAIL_OFFSET))
            {
                return null;
            }
			return BUNDLE["BYTES", base.directory.GetString(ExifDirectory.TAG_THUMBNAIL_OFFSET)];
		}

		/// <summary>
		/// Returns the Y Resolution Description. 
		/// </summary>
		/// <returns>the Y Resolution Description.</returns>
		private string GetYResolutionDescription() 
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_Y_RESOLUTION))
            {
                return null;
            }
			Rational lcResolution =
				base.directory.GetRational(ExifDirectory.TAG_Y_RESOLUTION);
			return BUNDLE["DOTS_PER", lcResolution.ToSimpleString(allowDecimalRepresentationOfRationals),GetResolutionDescription().ToLower()];
		}

		/// <summary>
		/// Returns the X Resolution Description. 
		/// </summary>
		/// <returns>the X Resolution Description.</returns>
		private string GetXResolutionDescription() 
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_X_RESOLUTION))
            {
                return null;
            }
			Rational lcResolution =
				base.directory.GetRational(ExifDirectory.TAG_X_RESOLUTION);
			return BUNDLE["DOTS_PER", lcResolution.ToSimpleString(allowDecimalRepresentationOfRationals),GetResolutionDescription().ToLower()];
		}

		/// <summary>
		/// Returns the Exposure Time Description. 
		/// </summary>
		/// <returns>the Exposure Time Description.</returns>
		private string GetExposureTimeDescription() 
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_EXPOSURE_TIME))
            {
                return null;
            }
			return BUNDLE["SEC", base.directory.GetString(ExifDirectory.TAG_EXPOSURE_TIME)];
		}

		/// <summary>
		/// Returns the Shutter Speed Description. 
		/// </summary>
		/// <returns>the Shutter Speed Description.</returns>
		private string GetShutterSpeedDescription() 
		{
            // I believe this method to now be stable, but am leaving some 
            // alternative snippets of code in here, to assist anyone who'lcStr 
            // looking into this (given that I don't have a public CVS).
            if (!base.directory.ContainsTag(ExifDirectory.TAG_SHUTTER_SPEED))
            {
                return null;
            }
            // Thanks to Mark Edwards for spotting and patching a bug in the calculation of this
            // description (spotted bug using a Canon EOS 300D)
            // thanks also to Gli Blr for spotting this bug
            float lcApexValue = base.directory.GetFloat(ExifDirectory.TAG_SHUTTER_SPEED);
            if (lcApexValue <= 1)
            {
                float lcApexPower = (float)(1 / (Math.Exp(lcApexValue * Math.Log(2))));
                long lcApexPower10 = (long)Math.Round((double)lcApexPower * 10.0);
                float lcFApexPower = (float)lcApexPower10 / 10.0f;
                return BUNDLE["SHUTTER_SPEED_SEC", lcFApexPower.ToString()];
            }
            else
            {
                int apexPower = (int)((Math.Exp(lcApexValue * Math.Log(2))));
                return BUNDLE["SHUTTER_SPEED", apexPower.ToString()];
            }

            // This alternative implementation offered by Bill Richards
            // TODO determine which is the correct / more-correct implementation
            // double apexValue = base.directory.GetDouble(ExifDirectory.TAG_SHUTTER_SPEED);
            // double apexPower = Math.Pow(2.0, apexValue);

            // StringBuilder sb = new StringBuilder();
            // if (apexPower > 1) {
            // apexPower = Math.Floor(apexPower);
            // }
            // if (apexPower < 1) {
            // sb.Append((int)Math.Round(1/apexPower));
            // } else {
            // sb.Append("1/");
            // sb.Append((int)apexPower);
            // }
            // sb.Append(" sec");
            // return sb.ToString();
		}

		/// <summary>
		/// Returns the F Number Description. 
		/// </summary>
		/// <returns>the F Number Description.</returns>
		private string GetFNumberDescription() 
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_FNUMBER))
            {
                return null;
            }
			Rational lcFNumber = base.directory.GetRational(ExifDirectory.TAG_FNUMBER);
			return BUNDLE["APERTURE", lcFNumber.DoubleValue().ToString("0.#")];
		}

		/// <summary>
		/// Returns the YCbCr Positioning Description. 
		/// </summary>
		/// <returns>the YCbCr Positioning Description.</returns>
		private string GetYCbCrPositioningDescription() 
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_YCBCR_POSITIONING))
            {
                return null;
            }
			int lcYCbCrPosition =
				base.directory.GetInt(ExifDirectory.TAG_YCBCR_POSITIONING);
			switch (lcYCbCrPosition) 
			{
				case 1 :
					return BUNDLE["CENTER_OF_PIXEL_ARRAY"];
				case 2 :
					return BUNDLE["DATUM_POINT"];
				default :
					return lcYCbCrPosition.ToString();
			}
		}

		/// <summary>
		/// Returns the Orientation Description. 
		/// </summary>
		/// <returns>the Orientation Description.</returns>
		private string GetOrientationDescription() 
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_ORIENTATION))
            {
                return null;
            }
			int lcOrientation = base.directory.GetInt(ExifDirectory.TAG_ORIENTATION);
			switch (lcOrientation) 
			{
				case 1 :
					return BUNDLE["TOP_LEFT_SIDE"];
				case 2 :
					return BUNDLE["TOP_RIGHT_SIDE"];
				case 3 :
					return BUNDLE["BOTTOM_RIGHT_SIDE"];
				case 4 :
					return BUNDLE["BOTTOM_LEFT_SIDE"];
				case 5 :
					return BUNDLE["LEFT_SIDE_TOP"];
				case 6 :
					return BUNDLE["RIGHT_SIDE_TOP"];
				case 7 :
					return BUNDLE["RIGHT_SIDE_BOTTOM"];
				case 8 :
					return BUNDLE["LEFT_SIDE_BOTTOM"];
				default :
					return lcOrientation.ToString();
			}
		}

		/// <summary>
		/// Returns the Resolution Description. 
		/// </summary>
		/// <returns>the Resolution Description.</returns>
		private string GetResolutionDescription() 
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_RESOLUTION_UNIT))
            {
                return "";
            }
			// '1' means no-unit, '2' means inch, '3' means centimeter. Default aValue is '2'(inch)
			int lcResolutionUnit = base.directory.GetInt(ExifDirectory.TAG_RESOLUTION_UNIT);
			switch (lcResolutionUnit) 
			{
				case 1 :
					return BUNDLE["NO_UNIT"];
				case 2 :
					return BUNDLE["INCHES"];
				case 3 :
					return BUNDLE["CM"];
				default :
					return "";
			}
		}

		/// <summary>
		/// Returns the Sensing Method Description. 
		/// </summary>
		/// <returns>the Sensing Method Description.</returns>
		private string GetSensingMethodDescription() 
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_SENSING_METHOD))
            {
                return null;
            }
			// '1' Not defined, '2' One-chip color area sensor, '3' Two-chip color area sensor
			// '4' Three-chip color area sensor, '5' Color sequential area sensor
			// '7' Trilinear sensor '8' Color sequential linear sensor,  'Other' reserved
			int lcSensingMethod = base.directory.GetInt(ExifDirectory.TAG_SENSING_METHOD);
			switch (lcSensingMethod) 
			{
				case 1 :
					return BUNDLE["NOT_DEFINED"];
				case 2 :
					return BUNDLE["ONE_CHIP_COLOR"];
				case 3 :
					return BUNDLE["TWO_CHIP_COLOR"];
				case 4 :
					return BUNDLE["THREE_CHIP_COLOR"];
				case 5 :
					return BUNDLE["COLOR_SEQUENTIAL"];
				case 7 :
					return BUNDLE["TRILINEAR_SENSOR"];
				case 8 :
					return BUNDLE["COLOR_SEQUENTIAL_LINEAR"];
				default :
					return "";
			}
		}

		/// <summary>
		/// Returns the XP author description. 
		/// </summary>
		/// <returns>the XP author description.</returns>
		private string GetXPAuthorDescription() 
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_XP_AUTHOR))
            {
                return null;
            }
			return Utils.Decode(base.directory.GetByteArray(ExifDirectory.TAG_XP_AUTHOR), true);
		}

		/// <summary>
		/// Returns the XP comments description. 
		/// </summary>
		/// <returns>the XP comments description.</returns>
		private string GetXPCommentsDescription()
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_XP_COMMENTS))
            {
                return null;
            }
			return Utils.Decode(base.directory.GetByteArray(ExifDirectory.TAG_XP_COMMENTS), true);
        } 

		/// <summary>
		/// Returns the XP keywords description. 
		/// </summary>
		/// <returns>the XP keywords description.</returns>
		private string  GetXPKeywordsDescription()
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_XP_KEYWORDS))
            {
                return null;
            }
			return Utils.Decode(base.directory.GetByteArray(ExifDirectory.TAG_XP_KEYWORDS), true);
		} 

		/// <summary>
		/// Returns the XP subject description. 
		/// </summary>
		/// <returns>the XP subject description.</returns>
		private string  GetXPSubjectDescription()
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_XP_SUBJECT))
            {
                return null;
            }
			return Utils.Decode(base.directory.GetByteArray(ExifDirectory.TAG_XP_SUBJECT), true);
		} 

		/// <summary>
		/// Returns the XP title description. 
		/// </summary>
		/// <returns>the XP title description.</returns>
		private string  GetXPTitleDescription() 
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_XP_TITLE))
            {
                return null;
            }
			return Utils.Decode(base.directory.GetByteArray(ExifDirectory.TAG_XP_TITLE), true);
		}


		/// <summary>
		/// Returns the Component Configuration Description. 
		/// </summary>
		/// <returns>the Component Configuration Description.</returns>
		private string GetComponentConfigurationDescription()
		{
            if (!base.directory.ContainsTag(ExifDirectory.TAG_COMPONENTS_CONFIGURATION))
            {
                return null;
            }
			int[] lcComponents =
				base.directory.GetIntArray(ExifDirectory.TAG_COMPONENTS_CONFIGURATION);
			string[] lcComponentStrings = { "", "Y", "Cb", "Cr", "R", "G", "B" };
			StringBuilder lcComponentConfig = new StringBuilder();
			for (int i = 0; i < Math.Min(4, lcComponents.Length); i++) 
			{
				int lcId = lcComponents[i];
				if (lcId > 0 && lcId < lcComponentStrings.Length) 
				{
					lcComponentConfig.Append(lcComponentStrings[lcId]);
				}
			}
			return lcComponentConfig.ToString();
		}

		/// <summary>
		/// Takes a series of 4 bytes from the specified offSet, and converts these to a 
		/// well-known version number, where possible.  For example, (hex) 30 32 31 30 == 2.10).
		/// </summary>
        /// <param name="someComponents">the four version values</param>
		/// <returns>the version as a string of form 2.10</returns>
		public static string ConvertBytesToVersionString(int[] someComponents) 
		{
			StringBuilder lcVersion = new StringBuilder();
			for (int i = 0; i < 4 && i < someComponents.Length; i++) 
			{
                // In order to avoid strange characters in some version (like Nikon)
                if (someComponents[i] > 31)
                {
                    if (i == 2)
                    {
                        lcVersion.Append('.');
                    }
                    string digit = ((char)someComponents[i]).ToString();
                    if (i == 0 && "0".Equals(digit))
                    {
                        continue;
                    }
                    lcVersion.Append(digit);
                }
			}
			return lcVersion.ToString();
		}
	}
}
using System;
using System.Collections;
using System.Text;
using com.drew.metadata;
using com.drew.lang;

/// <summary>
/// This class was first written by Drew Noakes in Java.
///
/// This is public domain software - that is, you can do whatever you want
/// with it, and include it software that is licensed under the GNU or the
/// BSD license, or whatever other licence you choose, including proprietary
/// closed source licenses.  I do ask that you leave this lcHeader in tact.
///
/// If you make modifications to this code that you think would benefit the
/// wider community, please send me a copy and I'll post it on my site.
///
/// If you make use of this code, Drew Noakes will appreciate hearing 
/// about it: <a href="mailto:drew@drewnoakes.com">drew@drewnoakes.com</a>
///
/// Latest Java version of this software kept at 
/// <a href="http://drewnoakes.com">http://drewnoakes.com/</a>
///
/// The C# class was made by Ferret Renaud: 
/// <a href="mailto:renaud91@free.fr">renaud91@free.fr</a>
/// If you find a bug in the C# code, feel free to mail me.
/// </summary>
namespace com.drew.metadata.exif
{
	/// <summary>
	/// Tag descriptor for almost every images
	/// </summary>
	public class ExifInteropDescriptor : AbstractTagDescriptor 
	{
		/// <summary>
		/// Constructor of the object
		/// </summary>
		/// <param name="base.directory">a base.directory</param>
		public ExifInteropDescriptor(AbstractDirectory aDirectory) : base(aDirectory)
		{
		}

		/// <summary>
		/// Returns a descriptive value of the the specified tag for this image. 
		/// Where possible, known values will be substituted here in place of the raw tokens actually 
		/// kept in the Exif segment. 
		/// If no substitution is available, the value provided by GetString(int) will be returned.
		/// This and GetString(int) are the only 'get' methods that won't throw an exception.
		/// </summary>
		/// <param name="aTagType">the tag to find a description for</param>
		/// <returns>a description of the image'str value for the specified tag, or null if the tag hasn't been defined.</returns>
		public override string GetDescription(int tagType)  
		{
			switch(tagType) 
			{
				case ExifInteropDirectory.TAG_INTEROP_INDEX:
					return GetInteropIndexDescription();
				case ExifInteropDirectory.TAG_INTEROP_VERSION:
					return GetInteropVersionDescription();
				default:
					return base.directory.GetString(tagType);
			}
		}

		/// <summary>
		/// Returns the Interop Version Description. 
		/// </summary>
		/// <returns>the Interop Version Description.</returns>
		private string GetInteropVersionDescription()  
		{
			if (!base.directory.ContainsTag(ExifInteropDirectory.TAG_INTEROP_VERSION))
				return null;
			int[] ints =
				base.directory.GetIntArray(ExifInteropDirectory.TAG_INTEROP_VERSION);
			return ExifDescriptor.ConvertBytesToVersionString(ints);
		}

		/// <summary>
		/// Returns the Interop index Description. 
		/// </summary>
		/// <returns>the Interop index Description.</returns>
		private string GetInteropIndexDescription() 
		{
			if (!base.directory.ContainsTag(ExifInteropDirectory.TAG_INTEROP_INDEX))
				return null;
			string interopIndex =
				base.directory.GetString(ExifInteropDirectory.TAG_INTEROP_INDEX).Trim();
			if ("R98".Equals(interopIndex.ToUpper())) 
			{
				return BUNDLE["RECOMMENDED_EXIF_INTEROPERABILITY"];
			} 
			else 
			{
				return BUNDLE["UNKNOWN", interopIndex.ToString()];
			}
		}
	}
}

using System;
using System.Collections;
using System.Text;
using System.IO;
using com.drew.metadata;
using com.drew.lang;

/// <summary>
/// This class was first written by Drew Noakes in Java.
///
/// This is public domain software - that is, you can do whatever you want
/// with it, and include it software that is licensed under the GNU or the
/// BSD license, or whatever other licence you choose, including proprietary
/// closed source licenses.  I do ask that you leave this lcHeader in tact.
///
/// If you make modifications to this code that you think would benefit the
/// wider community, please send me a copy and I'll post it on my site.
///
/// If you make use of this code, Drew Noakes will appreciate hearing 
/// about it: <a href="mailto:drew@drewnoakes.com">drew@drewnoakes.com</a>
///
/// Latest Java version of this software kept at 
/// <a href="http://drewnoakes.com">http://drewnoakes.com/</a>
///
/// The C# class was made by Ferret Renaud: 
/// <a href="mailto:renaud91@free.fr">renaud91@free.fr</a>
/// If you find a bug in the C# code, feel free to mail me.
/// </summary>
namespace com.drew.metadata.exif
{
	/// <summary>
	/// Fujifilm'str digicam added the MakerNote tag from the Year2000'str model 
	/// (e.g.Finepix1400, Finepix4700). It uses IFD format and start from ASCII character 
	/// 'FUJIFILM', and next 4 bytes(aValue 0x000c) points the offSet to first IFD entry. 
	/// Example of actual data structure is shown below.
	/// :0000: 46 55 4A 49 46 49 4C 4D-0C 00 00 00 0F 00 00 00 :0000: FUJIFILM........
	/// :0010: 07 00 04 00 00 00 30 31-33 30 00 10 02 00 08 00 :0010: ......0130......
	/// There are two big differences to the other manufacturers.
	/// - Fujifilm'str Exif data uses Motorola align, but MakerNote ignores it and uses Intel align.
	/// - The other manufacturer'str MakerNote counts the "offSet to data" from the first byte of 
	///   TIFF lcHeader (same as the other IFD), but Fujifilm counts it from the first byte of MakerNote itself.
	/// </summary>
	public class FujifilmDescriptor : AbstractTagDescriptor 
	{
		/// <summary>
		/// Constructor of the object
		/// </summary>
		/// <param name="aDirectory">a base.directory</param>
		public FujifilmDescriptor(AbstractDirectory aDirectory) : base(aDirectory)
		{		
		}

		/// <summary>
		/// Returns a descriptive value of the the specified tag for this image. 
		/// Where possible, known values will be substituted here in place of the raw tokens actually 
		/// kept in the Exif segment. 
		/// If no substitution is available, the value provided by GetString(int) will be returned.
		/// This and GetString(int) are the only 'get' methods that won't throw an exception.
		/// </summary>
		/// <param name="aTagType">the tag to find a description for</param>
		/// <returns>a description of the image'str value for the specified tag, or null if the tag hasn't been defined.</returns>
		public override string GetDescription(int tagType)  
		{
			switch(tagType) 
			{
				case FujifilmDirectory.TAG_FUJIFILM_SHARPNESS :
					return GetSharpnessDescription();
				case FujifilmDirectory.TAG_FUJIFILM_WHITE_BALANCE :
					return GetWhiteBalanceDescription();
				case FujifilmDirectory.TAG_FUJIFILM_COLOR :
					return GetColorDescription();
				case FujifilmDirectory.TAG_FUJIFILM_TONE :
					return GetToneDescription();
				case FujifilmDirectory.TAG_FUJIFILM_FLASH_MODE :
					return GetFlashModeDescription();
				case FujifilmDirectory.TAG_FUJIFILM_FLASH_STRENGTH :
					return GetFlashStrengthDescription();
				case FujifilmDirectory.TAG_FUJIFILM_MACRO :
					return GetMacroDescription();
				case FujifilmDirectory.TAG_FUJIFILM_FOCUS_MODE :
					return GetFocusModeDescription();
				case FujifilmDirectory.TAG_FUJIFILM_SLOW_SYNCHRO :
					return GetSlowSyncDescription();
				case FujifilmDirectory.TAG_FUJIFILM_PICTURE_MODE :
					return GetPictureModeDescription();
				case FujifilmDirectory.TAG_FUJIFILM_CONTINUOUS_TAKING_OR_AUTO_BRACKETTING :
					return GetContinuousTakingOrAutoBrackettingDescription();
				case FujifilmDirectory.TAG_FUJIFILM_BLUR_WARNING :
					return GetBlurWarningDescription();
				case FujifilmDirectory.TAG_FUJIFILM_FOCUS_WARNING :
					return GetFocusWarningDescription();
				case FujifilmDirectory.TAG_FUJIFILM_AE_WARNING :
					return GetAutoExposureWarningDescription();
				default :
					return base.directory.GetString(tagType);
			}
		}

		/// <summary>
		/// Returns the Auto Exposure Description. 
		/// </summary>
		/// <returns>the Auto Exposure Description.</returns>
		private string GetAutoExposureWarningDescription()
		{
			if (!base.directory
				.ContainsTag(FujifilmDirectory.TAG_FUJIFILM_AE_WARNING))
				return null;
			int aValue =
				base.directory.GetInt(
				FujifilmDirectory.TAG_FUJIFILM_AE_WARNING);
			switch (aValue) 
			{
				case 0 :
					return BUNDLE["AE_GOOD"];
				case 1 :
					return BUNDLE["OVER_EXPOSED"];
				default :
					return BUNDLE["UNKNOWN", aValue.ToString()];
			}
		}

		/// <summary>
		/// Returns the Focus Warning Description. 
		/// </summary>
		/// <returns>the Focus Warning Description.</returns>
		private string GetFocusWarningDescription()  
		{
			if (!base.directory
				.ContainsTag(FujifilmDirectory.TAG_FUJIFILM_FOCUS_WARNING))
				return null;
			int aValue =
				base.directory.GetInt(
				FujifilmDirectory.TAG_FUJIFILM_FOCUS_WARNING);
			switch (aValue) 
			{
				case 0 :
					return BUNDLE["AUTO_FOCUS_GOOD"];
				case 1 :
					return BUNDLE["OUT_OF_FOCUS"];
				default :
					return BUNDLE["UNKNOWN", aValue.ToString()];
			}
		}

		/// <summary>
		/// Returns the Blur Warning Description. 
		/// </summary>
		/// <returns>the Blur Warning Description.</returns>
		private string GetBlurWarningDescription()  
		{
			if (!base.directory
				.ContainsTag(FujifilmDirectory.TAG_FUJIFILM_BLUR_WARNING))
				return null;
			int aValue =
				base.directory.GetInt(
				FujifilmDirectory.TAG_FUJIFILM_BLUR_WARNING);
			switch (aValue) 
			{
				case 0 :
					return BUNDLE["NO_BLUR_WARNING"];
				case 1 :
					return BUNDLE["BLUR_WARNING"];
				default :
					return BUNDLE["UNKNOWN", aValue.ToString()];
			}
		}

		/// <summary>
		/// Returns the Continuous Taking Or AutoBracketting Description. 
		/// </summary>
		/// <returns>the Continuous Taking Or AutoBracketting Description.</returns>
		private string GetContinuousTakingOrAutoBrackettingDescription()
		{
			if (!base.directory
				.ContainsTag(
				FujifilmDirectory
				.TAG_FUJIFILM_CONTINUOUS_TAKING_OR_AUTO_BRACKETTING))
				return null;
			int aValue =
				base.directory.GetInt(
				FujifilmDirectory
				.TAG_FUJIFILM_CONTINUOUS_TAKING_OR_AUTO_BRACKETTING);
			switch (aValue) 
			{
				case 0 :
					return BUNDLE["OFF"];
				case 1 :
					return BUNDLE["ON"];
				default :
					return BUNDLE["UNKNOWN", aValue.ToString()];
			}
		}

		/// <summary>
		/// Returns the Picture Mode Description. 
		/// </summary>
		/// <returns>the Picture Mode Description.</returns>
		private string GetPictureModeDescription()  
		{
			if (!base.directory
				.ContainsTag(FujifilmDirectory.TAG_FUJIFILM_PICTURE_MODE))
				return null;
			int aValue =
				base.directory.GetInt(
				FujifilmDirectory.TAG_FUJIFILM_PICTURE_MODE);
			switch (aValue) 
			{
				case 0 :
					return BUNDLE["AUTO"];
				case 1 :
					return BUNDLE["PORTRAIT_SCENE"];
				case 2 :
					return BUNDLE["LANDSCAPE_SCENE"];
				case 4 :
					return BUNDLE["SPORTS_SCENE"];
				case 5 :
					return BUNDLE["NIGHT_SCENE"];
				case 6 :
					return BUNDLE["PROGRAM_AE"];
				case 256 :
					return BUNDLE["APERTURE_PRIORITY_AE"];
				case 512 :
					return BUNDLE["SHUTTER_PRIORITY_AE"];
				case 768 :
					return BUNDLE["MANUAL_EXPOSURE"];
				default :
					return BUNDLE["UNKNOWN", aValue.ToString()];
			}
		}

		/// <summary>
		/// Returns the Slow Sync Description. 
		/// </summary>
		/// <returns>the Slow Sync Description.</returns>
		private string GetSlowSyncDescription()  
		{
			if (!base.directory
				.ContainsTag(FujifilmDirectory.TAG_FUJIFILM_SLOW_SYNCHRO))
				return null;
			int aValue =
				base.directory.GetInt(
				FujifilmDirectory.TAG_FUJIFILM_SLOW_SYNCHRO);
			switch (aValue) 
			{
				case 0 :
					return BUNDLE["OFF"];
				case 1 :
					return BUNDLE["ON"];
				default :
					return BUNDLE["UNKNOWN", aValue.ToString()];
			}
		}

		/// <summary>
		/// Returns the Focus Mode Description. 
		/// </summary>
		/// <returns>the Focus Mode Description.</returns>
		private string GetFocusModeDescription()  
		{
			if (!base.directory
				.ContainsTag(FujifilmDirectory.TAG_FUJIFILM_FOCUS_MODE))
				return null;
			int aValue =
				base.directory.GetInt(
				FujifilmDirectory.TAG_FUJIFILM_FOCUS_MODE);
			switch (aValue) 
			{
				case 0 :
					return BUNDLE["AUTO_FOCUS"];
				case 1 :
					return BUNDLE["MANUAL_FOCUS"];
				default :
					return BUNDLE["UNKNOWN", aValue.ToString()];
			}
		}

		/// <summary>
		/// Returns the Macro Description. 
		/// </summary>
		/// <returns>the Macro Description.</returns>
		private string GetMacroDescription()  
		{
			if (!base.directory
				.ContainsTag(FujifilmDirectory.TAG_FUJIFILM_MACRO))
				return null;
			int aValue =
				base.directory.GetInt(FujifilmDirectory.TAG_FUJIFILM_MACRO);
			switch (aValue) 
			{
				case 0 :
					return BUNDLE["OFF"];
				case 1 :
					return BUNDLE["ON"];
				default :
					return BUNDLE["UNKNOWN", aValue.ToString()];
			}
		}

		/// <summary>
		/// Returns the Flash Strength Description. 
		/// </summary>
		/// <returns>the Flash Strength Description.</returns>
		private string GetFlashStrengthDescription()  
		{
			if (!base.directory
				.ContainsTag(
				FujifilmDirectory.TAG_FUJIFILM_FLASH_STRENGTH))
				return null;
			Rational aValue =
				base.directory.GetRational(
				FujifilmDirectory.TAG_FUJIFILM_FLASH_STRENGTH);
			return BUNDLE["FLASH_STRENGTH", aValue.ToSimpleString(false)];
		}

		/// <summary>
		/// Returns the Flash Mode Description. 
		/// </summary>
		/// <returns>the Flash Mode Description.</returns>
		private string GetFlashModeDescription()  
		{
			if (!base.directory
				.ContainsTag(FujifilmDirectory.TAG_FUJIFILM_FLASH_MODE))
				return null;
			int aValue =
				base.directory.GetInt(
				FujifilmDirectory.TAG_FUJIFILM_FLASH_MODE);
			switch (aValue) 
			{
				case 0 :
					return BUNDLE["AUTO"];
				case 1 :
					return BUNDLE["ON"];
				case 2 :
					return BUNDLE["OFF"];
				case 3 :
					return BUNDLE["RED_EYE_REDUCTION"];
				default :
					return BUNDLE["UNKNOWN", aValue.ToString()];
			}
		}

		/// <summary>
		/// Returns the Tone Description. 
		/// </summary>
		/// <returns>the Tone Description.</returns>
		private string GetToneDescription()  
		{
			if (!base.directory
				.ContainsTag(FujifilmDirectory.TAG_FUJIFILM_TONE))
				return null;
			int aValue =
				base.directory.GetInt(FujifilmDirectory.TAG_FUJIFILM_TONE);
			switch (aValue) 
			{
				case 0 :
					return BUNDLE["NORMAL_STD"];
				case 256 :
					return BUNDLE["HIGH_HARD"];
				case 512 :
					return BUNDLE["LOW_ORG"];
				default :
					return BUNDLE["UNKNOWN", aValue.ToString()];
			}
		}

		/// <summary>
		/// Returns the Color Description. 
		/// </summary>
		/// <returns>the Color Description.</returns>
		private string GetColorDescription()  
		{
			if (!base.directory
				.ContainsTag(FujifilmDirectory.TAG_FUJIFILM_COLOR))
				return null;
			int aValue =
				base.directory.GetInt(FujifilmDirectory.TAG_FUJIFILM_COLOR);
			switch (aValue) 
			{
				case 0 :
					return BUNDLE["NORMAL_STD"];
				case 256 :
					return BUNDLE["HIGH"];
				case 512 :
					return BUNDLE["LOW_ORG"];
				default :
					return BUNDLE["UNKNOWN", aValue.ToString()];
			}
		}

		/// <summary>
		/// Returns the White Balance Description. 
		/// </summary>
		/// <returns>the White Balance Description.</returns>
		private string GetWhiteBalanceDescription()  
		{
			if (!base.directory
				.ContainsTag(FujifilmDirectory.TAG_FUJIFILM_WHITE_BALANCE))
				return null;
			int aValue =
				base.directory.GetInt(
				FujifilmDirectory.TAG_FUJIFILM_WHITE_BALANCE);
			switch (aValue) 
			{
				case 0 :
					return BUNDLE["AUTO"];
				case 256 :
					return BUNDLE["DAYLIGHT"];
				case 512 :
					return BUNDLE["CLOUDY"];
				case 768 :
					return BUNDLE["DAYLIGHTCOLOR_FLUORESCENCE"];
				case 769 :
					return BUNDLE["DAYWHITECOLOR_FLUORESCENCE"];
				case 770 :
					return BUNDLE["WHITE_FLUORESCENCE"];
				case 1024 :
					return BUNDLE["INCANDENSCENSE"];
				case 3840 :
					return BUNDLE["CUSTOM_WHITE_BALANCE"];
				default :
					return BUNDLE["UNKNOWN", aValue.ToString()];
			}
		}

		/// <summary>
		/// Returns the Sharpness Description. 
		/// </summary>
		/// <returns>the Sharpness Description.</returns>
		private string GetSharpnessDescription()  
		{
			if (!base.directory
				.ContainsTag(FujifilmDirectory.TAG_FUJIFILM_SHARPNESS))
				return null;
			int aValue =
				base.directory.GetInt(
				FujifilmDirectory.TAG_FUJIFILM_SHARPNESS);
			switch (aValue) 
			{
				case 1 :
				case 2 :
					return BUNDLE["SOFT"];
				case 3 :
					return BUNDLE["NORMAL"];
				case 4 :
				case 5 :
					return BUNDLE["HARD"];
				default :
					return BUNDLE["UNKNOWN", aValue.ToString()];
			}
		}
	}
}
using System;
using System.Collections;
using System.Text;
using System.IO;
using com.drew.metadata;
using com.drew.lang;

/// <summary>
/// This class was first written by Drew Noakes in Java.
///
/// This is public domain software - that is, you can do whatever you want
/// with it, and include it software that is licensed under the GNU or the
/// BSD license, or whatever other licence you choose, including proprietary
/// closed source licenses.  I do ask that you leave this lcHeader in tact.
///
/// If you make modifications to this code that you think would benefit the
/// wider community, please send me a copy and I'll post it on my site.
///
/// If you make use of this code, Drew Noakes will appreciate hearing 
/// about it: <a href="mailto:drew@drewnoakes.com">drew@drewnoakes.com</a>
///
/// Latest Java version of this software kept at 
/// <a href="http://drewnoakes.com">http://drewnoakes.com/</a>
///
/// The C# class was made by Ferret Renaud: 
/// <a href="mailto:renaud91@free.fr">renaud91@free.fr</a>
/// If you find a bug in the C# code, feel free to mail me.
/// </summary>
namespace com.drew.metadata.exif
{
	/// <summary>
	/// Tag descriptor for GPS
	/// </summary>
	public class GpsDescriptor : AbstractTagDescriptor 
	{
		/// <summary>
		/// Constructor of the object
		/// </summary>
		/// <param name="aDirectory">a base.directory</param>
		public GpsDescriptor(AbstractDirectory aDirectory) : base(aDirectory)
		{
		}

		/// <summary>
		/// Returns a descriptive value of the the specified tag for this image. 
		/// Where possible, known values will be substituted here in place of the raw tokens actually 
		/// kept in the Exif segment. 
		/// If no substitution is available, the value provided by GetString(int) will be returned.
		/// This and GetString(int) are the only 'get' methods that won't throw an exception.
		/// </summary>
		/// <param name="aTagType">the tag to find a description for</param>
		/// <returns>a description of the image'str value for the specified tag, or null if the tag hasn't been defined.</returns>
		public override string GetDescription(int tagType)  
		{
			switch(tagType) 
			{
				case GpsDirectory.TAG_GPS_ALTITUDE :
					return GetGpsAltitudeDescription();
				case GpsDirectory.TAG_GPS_ALTITUDE_REF :
					return GetGpsAltitudeRefDescription();
				case GpsDirectory.TAG_GPS_STATUS :
					return GetGpsStatusDescription();
				case GpsDirectory.TAG_GPS_MEASURE_MODE :
					return GetGpsMeasureModeDescription();
				case GpsDirectory.TAG_GPS_SPEED_REF :
					return GetGpsSpeedRefDescription();
				case GpsDirectory.TAG_GPS_TRACK_REF :
				case GpsDirectory.TAG_GPS_IMG_DIRECTION_REF :					
				case GpsDirectory.TAG_GPS_DEST_BEARING_REF :
					return GetGpsDirectionReferenceDescription(tagType);
				case GpsDirectory.TAG_GPS_TRACK :
				case GpsDirectory.TAG_GPS_IMG_DIRECTION :
				case GpsDirectory.TAG_GPS_DEST_BEARING :
					return GetGpsDirectionDescription(tagType);
				case GpsDirectory.TAG_GPS_DEST_DISTANCE_REF :
					return GetGpsDestinationReferenceDescription();
				case GpsDirectory.TAG_GPS_TIME_STAMP :
					return GetGpsTimeStampDescription();
					// three rational numbers -- displayed in HH"MM"SS.ss
				case GpsDirectory.TAG_GPS_LONGITUDE :
					return GetGpsLongitudeDescription();
				case GpsDirectory.TAG_GPS_LATITUDE :
					return GetGpsLatitudeDescription();
				default :
					return base.directory.GetString(tagType);
			}
		}

		/// <summary>
		/// Returns the Gps Latitude Description. 
		/// </summary>
		/// <returns>the Gps Latitude Description.</returns>
		private string GetGpsLatitudeDescription()  
		{
            if (!base.directory.ContainsTag(GpsDirectory.TAG_GPS_LATITUDE))
            {
                return null;
            }
			return GetHoursMinutesSecondsDescription(GpsDirectory.TAG_GPS_LATITUDE);
		}

		/// <summary>
		/// Returns the Gps Longitude Description. 
		/// </summary>
		/// <returns>the Gps Longitude Description.</returns>
		private string GetGpsLongitudeDescription()  
		{
            if (!base.directory.ContainsTag(GpsDirectory.TAG_GPS_LONGITUDE))
            {
                return null;
            }
			return GetHoursMinutesSecondsDescription(
				GpsDirectory.TAG_GPS_LONGITUDE);
		}

		/// <summary>
		/// Returns the Hours Minutes Seconds Description. 
		/// </summary>
        /// <param name="aTagType">the tag type</param>
		/// <returns>the Hours Minutes Seconds Description.</returns>
		private string GetHoursMinutesSecondsDescription(int tagType)
		{
			Rational[] components = base.directory.GetRationalArray(tagType);
			// TODO create an HoursMinutesSecods class ??
			int deg = components[0].IntValue();
			float min = components[1].FloatValue();
			float sec = components[2].FloatValue();
			// carry fractions of minutes into seconds -- thanks Colin Briton
			sec += (min % 1) * 60;
			string[] tab = new string[] {deg.ToString(), ((int) min).ToString(), sec.ToString()};
			return BUNDLE["HOURS_MINUTES_SECONDS", tab];
		}

		/// <summary>
		/// Returns the Gps Time Stamp Description. 
		/// </summary>
		/// <returns>the Gps Time Stamp Description.</returns>
		private string GetGpsTimeStampDescription()  
		{
			// time in hour, min, sec
            if (!base.directory.ContainsTag(GpsDirectory.TAG_GPS_TIME_STAMP))
            {
                return null;
            }
			int[] timeComponents =
				base.directory.GetIntArray(GpsDirectory.TAG_GPS_TIME_STAMP);
			string[] tab = new string[] {timeComponents[0].ToString(), timeComponents[1].ToString(), timeComponents[2].ToString()};
			return BUNDLE["GPS_TIME_STAMP", tab];
		}

		/// <summary>
		/// Returns the Gps Destination Reference Description. 
		/// </summary>
		/// <returns>the Gps Destination Reference Description.</returns>
		private string GetGpsDestinationReferenceDescription() 
		{
            if (!base.directory.ContainsTag(GpsDirectory.TAG_GPS_DEST_DISTANCE_REF))
            {
                return null;
            }
			string destRef =
				base.directory.GetString(GpsDirectory.TAG_GPS_DEST_DISTANCE_REF).Trim().ToUpper();
            switch (destRef)
            {
                case "K": return BUNDLE["KILOMETERS"];
                case "M": return BUNDLE["MILES"];
                case "N": return BUNDLE["KNOTS"];
                default: return BUNDLE["UNKNOWN", destRef];
            }
		}

		/// <summary>
		/// Returns the Gps Direction Description. 
		/// </summary>
		/// <returns>the Gps Direction Description.</returns>
		private string GetGpsDirectionDescription(int tagType) 
		{
            if (!base.directory.ContainsTag(tagType))
            {
                return null;
            }
			string gpsDirection = base.directory.GetString(tagType).Trim();
			return BUNDLE["DEGREES", gpsDirection];
		}

		/// <summary>
		/// Returns the Gps Direction Reference Description. 
		/// </summary>
		/// <returns>the Gps Direction Reference Description.</returns>
		private string GetGpsDirectionReferenceDescription(int tagType) 
		{
            if (!base.directory.ContainsTag(tagType))
            {
                return null;
            }
			string gpsDistRef = base.directory.GetString(tagType).Trim().ToUpper();
            switch (gpsDistRef)
            {
                case "T": return BUNDLE["TRUE_DIRECTION"];
                case "M": return BUNDLE["MAGNETIC_DIRECTION"];
                default: return BUNDLE["UNKNOWN", gpsDistRef];
            }
		}

		/// <summary>
		/// Returns the Gps Speed Ref Description. 
		/// </summary>
		/// <returns>the Gps Speed Ref Description.</returns>
		private string GetGpsSpeedRefDescription() 
		{
            if (!base.directory.ContainsTag(GpsDirectory.TAG_GPS_SPEED_REF))
            {
                return null;
            }
			string gpsSpeedRef =
				base.directory.GetString(GpsDirectory.TAG_GPS_SPEED_REF).Trim().ToUpper();
            switch (gpsSpeedRef)
            {
                case "K": return BUNDLE["KPH"];
                case "M": return BUNDLE["MPH"];
                case "N": return BUNDLE["KNOTS"];
                default: return BUNDLE["UNKNOWN", gpsSpeedRef];
            }
		}

		/// <summary>
		/// Returns the Gps Measure Mode Description. 
		/// </summary>
		/// <returns>the Gps Measure Mode Description.</returns>
        private string GetGpsMeasureModeDescription()
        {
            if (!base.directory.ContainsTag(GpsDirectory.TAG_GPS_MEASURE_MODE))
            {
                return null;
            }
            string gpsSpeedMeasureMode =
                base.directory.GetString(GpsDirectory.TAG_GPS_MEASURE_MODE).Trim();

            switch (gpsSpeedMeasureMode)
            {
                case "2":
                case "3": return BUNDLE["DIMENSIONAL_MEASUREMENT", gpsSpeedMeasureMode];
                default: return BUNDLE["UNKNOWN", gpsSpeedMeasureMode];
            }
        }

		/// <summary>
		/// Returns the Gps Status Description. 
		/// </summary>
		/// <returns>the Gps Status Description.</returns>
		private string GetGpsStatusDescription() 
		{
            if (!base.directory.ContainsTag(GpsDirectory.TAG_GPS_STATUS))
            {
                return null;
            }
			string gpsStatus =
				base.directory.GetString(GpsDirectory.TAG_GPS_STATUS).Trim().ToUpper();
            switch (gpsStatus)
            {
                case "A": return BUNDLE["MEASUREMENT_IN_PROGESS"];
                case "V": return BUNDLE["MEASUREMENT_INTEROPERABILITY"];
                default: return BUNDLE["UNKNOWN", gpsStatus];
            }
		}

		/// <summary>
		/// Returns the Gps Altitude Ref Description. 
		/// </summary>
		/// <returns>the Gps Altitude Ref Description.</returns>
		private string GetGpsAltitudeRefDescription()  
		{
            if (!base.directory.ContainsTag(GpsDirectory.TAG_GPS_ALTITUDE_REF))
            {
                return null;
            }
			int alititudeRef = base.directory.GetInt(GpsDirectory.TAG_GPS_ALTITUDE_REF);
			if (alititudeRef == 0) 
			{
				return BUNDLE["SEA_LEVEL"];
			} 
			return BUNDLE["UNKNOWN", alititudeRef.ToString()];
		}

		/// <summary>
		/// Returns the Gps Altitude Description. 
		/// </summary>
		/// <returns>the Gps Altitude Description.</returns>
		private string GetGpsAltitudeDescription()  
		{
            if (!base.directory.ContainsTag(GpsDirectory.TAG_GPS_ALTITUDE))
            {
                return null;
            }
			string alititude =
				base.directory.GetRational(
				GpsDirectory.TAG_GPS_ALTITUDE).ToSimpleString(
				true);
			return BUNDLE["METRES", alititude];
		}
	}
}

using System;
using System.Collections;
using System.Text;
using System.IO;
using com.drew.metadata;
using com.drew.lang;

/// <summary>
/// This class was first written by Drew Noakes in Java.
///
/// This is public domain software - that is, you can do whatever you want
/// with it, and include it software that is licensed under the GNU or the
/// BSD license, or whatever other licence you choose, including proprietary
/// closed source licenses.  I do ask that you leave this lcHeader in tact.
///
/// If you make modifications to this code that you think would benefit the
/// wider community, please send me a copy and I'll post it on my site.
///
/// If you make use of this code, Drew Noakes will appreciate hearing 
/// about it: <a href="mailto:drew@drewnoakes.com">drew@drewnoakes.com</a>
///
/// Latest Java version of this software kept at 
/// <a href="http://drewnoakes.com">http://drewnoakes.com/</a>
///
/// The C# class was made by Ferret Renaud: 
/// <a href="mailto:renaud91@free.fr">renaud91@free.fr</a>
/// If you find a bug in the C# code, feel free to mail me.
/// </summary>
namespace com.drew.metadata.exif
{
	/// <summary>
	/// Tag descriptor for Kodak
    /// 
    /// Thanks to David Carson for the initial version of this class.
	/// </summary>
	public class KodakDescriptor : AbstractTagDescriptor 
	{
		/// <summary>
		/// Constructor of the object
		/// </summary>
		/// <param name="directory">a directory</param>
        public KodakDescriptor(AbstractDirectory directory)
            : base(directory)
		{
		}

        /// <summary>
        /// Returns a descriptive value of the the specified tag for this image. 
        /// Where possible, known values will be substituted here in place of the raw tokens actually 
        /// kept in the Exif segment. 
        /// If no substitution is available, the value provided by GetString(int) will be returned.
        /// This and GetString(int) are the only 'get' methods that won't throw an exception.
        /// </summary>
        /// <param name="aTagType">the tag to find a description for</param>
        /// <returns>a description of the image'str value for the specified tag, or null if the tag hasn't been defined.</returns>
        public override string GetDescription(int aTagType)
        {
            return base.directory.GetString(aTagType);
        }
	}
}

using System;
using System.Collections;
using System.Text;
using System.IO;
using com.drew.metadata;
using com.drew.lang;

/// <summary>
/// This class was first written by Drew Noakes in Java.
///
/// This is public domain software - that is, you can do whatever you want
/// with it, and include it software that is licensed under the GNU or the
/// BSD license, or whatever other licence you choose, including proprietary
/// closed source licenses.  I do ask that you leave this lcHeader in tact.
///
/// If you make modifications to this code that you think would benefit the
/// wider community, please send me a copy and I'll post it on my site.
///
/// If you make use of this code, Drew Noakes will appreciate hearing 
/// about it: <a href="mailto:drew@drewnoakes.com">drew@drewnoakes.com</a>
///
/// Latest Java version of this software kept at 
/// <a href="http://drewnoakes.com">http://drewnoakes.com/</a>
///
/// The C# class was made by Ferret Renaud: 
/// <a href="mailto:renaud91@free.fr">renaud91@free.fr</a>
/// If you find a bug in the C# code, feel free to mail me.
/// </summary>
namespace com.drew.metadata.exif
{
    /// <summary>
    /// Tag descriptor for Kyocera
    /// </summary>
    public class KyoceraDescriptor : AbstractTagDescriptor
    {
        /// <summary>
        /// Constructor of the object
        /// </summary>
        /// <param name="aDirectory">a base.directory</param>
        public KyoceraDescriptor(AbstractDirectory aDirectory)
            : base(aDirectory)
        {
        }

        /// <summary>
        /// Returns a descriptive value of the the specified tag for this image. 
        /// Where possible, known values will be substituted here in place of the raw tokens actually 
        /// kept in the Exif segment. 
        /// If no substitution is available, the value provided by GetString(int) will be returned.
        /// This and GetString(int) are the only 'get' methods that won't throw an exception.
        /// </summary>
        /// <param name="aTagType">the tag to find a description for</param>
        /// <returns>a description of the image'str value for the specified tag, or null if the tag hasn't been defined.</returns>
        public override string GetDescription(int aTagType)
        {
            switch (aTagType)
            {
                case KyoceraDirectory.TAG_KYOCERA_PRINT_IMAGE_MATCHING_INFO:
                    return GetPrintImageMatchingInfoDescription();
                case KyoceraDirectory.TAG_KYOCERA_PROPRIETARY_THUMBNAIL:
                    return GetProprietaryThumbnailDataDescription();
                default:
                    return base.directory.GetString(aTagType);
            }
        }

        /// <summary>
        /// Returns Print Image Matching (PIM) Info Description. 
        /// </summary>
        /// <returns>the Print Image Matching (PIM) Info Description.</returns>
        private string GetPrintImageMatchingInfoDescription()
        {
            if (!base.directory.ContainsTag(KyoceraDirectory.TAG_KYOCERA_PRINT_IMAGE_MATCHING_INFO))
            {
                return null;
            }
            byte[] bytes = base.directory.GetByteArray(KyoceraDirectory.TAG_KYOCERA_PRINT_IMAGE_MATCHING_INFO);
            return BUNDLE["BYTES",bytes.Length.ToString()];
        }

        /// <summary>
        /// Returns Proprietary Thumbnail Format Data Description. 
        /// </summary>
        /// <returns>the Proprietary Thumbnail Format Data Description.</returns>
        private string GetProprietaryThumbnailDataDescription()
        {
            if (!base.directory.ContainsTag(KyoceraDirectory.TAG_KYOCERA_PROPRIETARY_THUMBNAIL))
            {
                return null;
            }
            byte[] bytes = base.directory.GetByteArray(KyoceraDirectory.TAG_KYOCERA_PROPRIETARY_THUMBNAIL);
            return BUNDLE["BYTES", bytes.Length.ToString()];
        }
    }
}

using System;
using System.Collections;
using System.Text;
using System.IO;
using com.drew.metadata;
using com.drew.lang;

/// <summary>
/// This class was first written by Drew Noakes in Java.
///
/// This is public domain software - that is, you can do whatever you want
/// with it, and include it software that is licensed under the GNU or the
/// BSD license, or whatever other licence you choose, including proprietary
/// closed source licenses.  I do ask that you leave this lcHeader in tact.
///
/// If you make modifications to this code that you think would benefit the
/// wider community, please send me a copy and I'll post it on my site.
///
/// If you make use of this code, Drew Noakes will appreciate hearing 
/// about it: <a href="mailto:drew@drewnoakes.com">drew@drewnoakes.com</a>
///
/// Latest Java version of this software kept at 
/// <a href="http://drewnoakes.com">http://drewnoakes.com/</a>
///
/// The C# class was made by Ferret Renaud: 
/// <a href="mailto:renaud91@free.fr">renaud91@free.fr</a>
/// If you find a bug in the C# code, feel free to mail me.
/// </summary>
namespace com.drew.metadata.exif
{
	/// <summary>
	/// There are 3 formats of Nikon'str MakerNote. MakerNote of E700/E800/E900/E900S/E910/E950 starts 
	/// from ASCII string "Nikon". Data format is the same as IFD, but it starts from offSet 0x08. 
	/// This is the same as Olympus except start string. Example of actual data structure is shown below.
	/// :0000: 4E 69 6B 6F 6E 00 01 00-05 00 02 00 02 00 06 00 Nikon...........
	/// :0010: 00 00 EC 02 00 00 03 00-03 00 01 00 00 00 06 00 ................
	/// </summary>
	public class NikonType1Descriptor : AbstractTagDescriptor 
	{

		/// <summary>
		/// Constructor of the object
		/// </summary>
		/// <param name="aDirectory">a base.directory</param>
		public NikonType1Descriptor(AbstractDirectory aDirectory) : base(aDirectory)
		{		
		}

		/// <summary>
		/// Returns a descriptive value of the the specified tag for this image. 
		/// Where possible, known values will be substituted here in place of the raw tokens actually 
		/// kept in the Exif segment. 
		/// If no substitution is available, the value provided by GetString(int) will be returned.
		/// This and GetString(int) are the only 'get' methods that won't throw an exception.
		/// </summary>
		/// <param name="aTagType">the tag to find a description for</param>
		/// <returns>a description of the image'str value for the specified tag, or null if the tag hasn't been defined.</returns>
		public override string GetDescription(int tagType)  
		{
			switch(tagType) 
			{
				case NikonType1Directory.TAG_NIKON_TYPE1_QUALITY :
					return GetQualityDescription();
				case NikonType1Directory.TAG_NIKON_TYPE1_COLOR_MODE :
					return GetColorModeDescription();
				case NikonType1Directory.TAG_NIKON_TYPE1_IMAGE_ADJUSTMENT :
					return GetImageAdjustmentDescription();
				case NikonType1Directory.TAG_NIKON_TYPE1_CCD_SENSITIVITY :
					return GetCcdSensitivityDescription();
				case NikonType1Directory.TAG_NIKON_TYPE1_WHITE_BALANCE :
					return GetWhiteBalanceDescription();
				case NikonType1Directory.TAG_NIKON_TYPE1_FOCUS :
					return GetFocusDescription();
				case NikonType1Directory.TAG_NIKON_TYPE1_DIGITAL_ZOOM :
					return GetDigitalZoomDescription();
				case NikonType1Directory.TAG_NIKON_TYPE1_CONVERTER :
					return GetConverterDescription();
				default :
					return base.directory.GetString(tagType);
			}
		}

		/// <summary>
		/// Returns the Converter Description. 
		/// </summary>
		/// <returns>the Converter Description.</returns>
		private string GetConverterDescription()  
		{
            if (!base.directory
                .ContainsTag(
                NikonType1Directory.TAG_NIKON_TYPE1_CONVERTER))
            {
                return null;
            }
			int aValue =
				base.directory.GetInt(
				NikonType1Directory.TAG_NIKON_TYPE1_CONVERTER);
			switch (aValue) 
			{
				case 0 :
					return BUNDLE["NONE"];
				case 1 :
					return BUNDLE["FISHEYE_CONVERTER"];
				default :
					return BUNDLE["UNKNOWN", aValue.ToString()];
			}
		}

		/// <summary>
		/// Returns the Digital Zoom Description. 
		/// </summary>
		/// <returns>the Digital Zoom Description.</returns>
		private string GetDigitalZoomDescription()  
		{
            if (!base.directory
                .ContainsTag(
                NikonType1Directory.TAG_NIKON_TYPE1_DIGITAL_ZOOM))
            {
                return null;
            }
			Rational aValue =
				base.directory.GetRational(
				NikonType1Directory.TAG_NIKON_TYPE1_DIGITAL_ZOOM);
			if (aValue.GetNumerator() == 0) 
			{
				return BUNDLE["NO_DIGITAL_ZOOM"];
			}
			return BUNDLE["DIGITAL_ZOOM", aValue.ToSimpleString(true)];
		}

		/// <summary>
		/// Returns the Focus Description. 
		/// </summary>
		/// <returns>the Focus Description.</returns>
		private string GetFocusDescription()  
		{
            if (!base.directory
                .ContainsTag(NikonType1Directory.TAG_NIKON_TYPE1_FOCUS))
            {
                return null;
            }
			Rational aValue =
				base.directory.GetRational(
				NikonType1Directory.TAG_NIKON_TYPE1_FOCUS);
			if (aValue.GetNumerator() == 1 && aValue.GetDenominator() == 0) 
			{
				return BUNDLE["INFINITE"];
			}
			return aValue.ToSimpleString(true);
		}

		/// <summary>
		/// Returns the White Balance Description. 
		/// </summary>
		/// <returns>the White Balance Description.</returns>
		private string GetWhiteBalanceDescription()  
		{
            if (!base.directory
                .ContainsTag(
                NikonType1Directory.TAG_NIKON_TYPE1_WHITE_BALANCE))
            {

                return null;
            }
			int aValue =
				base.directory.GetInt(
				NikonType1Directory.TAG_NIKON_TYPE1_WHITE_BALANCE);
			switch (aValue) 
			{
				case 0 :
					return BUNDLE["AUTO"];
				case 1 :
					return BUNDLE["PRESET"];
				case 2 :
					return BUNDLE["DAYLIGHT"];
				case 3 :
					return BUNDLE["INCANDESCENSE"];
				case 4 :
					return BUNDLE["FLUORESCENT"];
				case 5 :
					return BUNDLE["CLOUDY"];
				case 6 :
					return BUNDLE["SPEEDLIGHT"];
				default :
					return BUNDLE["UNKNOWN", aValue.ToString()];
			}
		}

		/// <summary>
		/// Returns the Ccd Sensitivity Description. 
		/// </summary>
		/// <returns>the Ccd Sensitivity Description.</returns>
		private string GetCcdSensitivityDescription()  
		{
            if (!base.directory
                .ContainsTag(
                NikonType1Directory.TAG_NIKON_TYPE1_CCD_SENSITIVITY))
            {
                return null;
            }
			int aValue =
				base.directory.GetInt(
				NikonType1Directory.TAG_NIKON_TYPE1_CCD_SENSITIVITY);
			switch (aValue) 
			{
				case 0 :
					return BUNDLE["ISO","80"];
				case 2 :
					return BUNDLE["ISO","160"];
				case 4 :
					return BUNDLE["ISO","320"];
				case 5 :
					return BUNDLE["ISO","100"];
				default :
					return BUNDLE["UNKNOWN", aValue.ToString()];
			}
		}

		/// <summary>
		/// Returns the Image Adjustment Description. 
		/// </summary>
		/// <returns>the Image Adjustment Description.</returns>
		private string GetImageAdjustmentDescription()  
		{
            if (!base.directory
                .ContainsTag(
                NikonType1Directory.TAG_NIKON_TYPE1_IMAGE_ADJUSTMENT))
            {
                return null;
            }
			int aValue =
				base.directory.GetInt(
				NikonType1Directory.TAG_NIKON_TYPE1_IMAGE_ADJUSTMENT);
			switch (aValue) 
			{
				case 0 :
					return BUNDLE["NORMAL"];
				case 1 :
					return BUNDLE["BRIGHT_P"];
				case 2 :
					return BUNDLE["BRIGHT_M"];
				case 3 :
					return BUNDLE["CONTRAST_P"];
				case 4 :
					return BUNDLE["CONTRAST_M"];
				default :
					return BUNDLE["UNKNOWN", aValue.ToString()];
			}
		}

		/// <summary>
		/// Returns the Color Mode Description. 
		/// </summary>
		/// <returns>the Color Mode Description.</returns>
		private string GetColorModeDescription()  
		{
            if (!base.directory
                .ContainsTag(
                NikonType1Directory.TAG_NIKON_TYPE1_COLOR_MODE))
            {
                return null;
            }
			int aValue =
				base.directory.GetInt(
				NikonType1Directory.TAG_NIKON_TYPE1_COLOR_MODE);
			switch (aValue) 
			{
				case 1 :
					return BUNDLE["COLOR"];
				case 2 :
					return BUNDLE["MONOCHROME"];
				default :
					return BUNDLE["UNKNOWN", aValue.ToString()];
			}
		}

		/// <summary>
		/// Returns the Quality Description. 
		/// </summary>
		/// <returns>the Quality Description.</returns>
		private string GetQualityDescription()  
		{
            if (!base.directory
                .ContainsTag(NikonType1Directory.TAG_NIKON_TYPE1_QUALITY))
            {
                return null;
            }
			int aValue =
				base.directory.GetInt(
				NikonType1Directory.TAG_NIKON_TYPE1_QUALITY);
			switch (aValue) 
			{
				case 1 :
					return BUNDLE["VGA_BASIC"];
				case 2 :
					return BUNDLE["VGA_NORMAL"];
				case 3 :
					return BUNDLE["VGA_FINE"];
				case 4 :
					return BUNDLE["SXGA_BASIC"];
				case 5 :
					return BUNDLE["SXGA_NORMAL"];
				case 6 :
					return BUNDLE["SXGA_FINE"];
				default :
					return BUNDLE["UNKNOWN", aValue.ToString()];
			}
		}
	}
}
using System;
using System.Collections;
using System.Text;
using System.IO;
using com.drew.metadata;
using com.drew.lang;

/// <summary>
/// This class was first written by Drew Noakes in Java.
///
/// This is public domain software - that is, you can do whatever you want
/// with it, and include it software that is licensed under the GNU or the
/// BSD license, or whatever other licence you choose, including proprietary
/// closed source licenses.  I do ask that you leave this lcHeader in tact.
///
/// If you make modifications to this code that you think would benefit the
/// wider community, please send me a copy and I'll post it on my site.
///
/// If you make use of this code, Drew Noakes will appreciate hearing 
/// about it: <a href="mailto:drew@drewnoakes.com">drew@drewnoakes.com</a>
///
/// Latest Java version of this software kept at 
/// <a href="http://drewnoakes.com">http://drewnoakes.com/</a>
///
/// The C# class was made by Ferret Renaud: 
/// <a href="mailto:renaud91@free.fr">renaud91@free.fr</a>
/// If you find a bug in the C# code, feel free to mail me.
/// </summary>
namespace com.drew.metadata.exif
{
    /// <summary>
    /// Tag descriptor for Nikon
    /// </summary>
    public class NikonType2Descriptor : AbstractTagDescriptor
    {
        /// <summary>
        /// Constructor of the object
        /// </summary>
        /// <param name="base.directory">a base.directory</param>
        public NikonType2Descriptor(AbstractDirectory aDirectory)
            : base(aDirectory)
        {
        }

        /// <summary>
        /// Returns a descriptive value of the the specified tag for this image. 
        /// Where possible, known values will be substituted here in place of the raw tokens actually 
        /// kept in the Exif segment. 
        /// If no substitution is available, the value provided by GetString(int) will be returned.
        /// This and GetString(int) are the only 'get' methods that won't throw an exception.
        /// </summary>
        /// <param name="aTagType">the tag to find a description for</param>
        /// <returns>a description of the image'str value for the specified tag, or null if the tag hasn't been defined.</returns>
        public override string GetDescription(int tagType)
        {
            switch (tagType)
            {
                case NikonType2Directory.TAG_NIKON_TYPE2_LENS:
                    return GetLensDescription();
                case NikonType2Directory.TAG_NIKON_TYPE2_CAMERA_HUE_ADJUSTMENT:
                    return GetHueAdjustmentDescription();
                case NikonType2Directory.TAG_NIKON_TYPE2_CAMERA_COLOR_MODE:
                    return GetColorModeDescription();
                case NikonType2Directory.TAG_NIKON_TYPE2_AUTO_FLASH_COMPENSATION:
                    return GetAutoFlashCompensationDescription();
                case NikonType2Directory.TAG_NIKON_TYPE2_ISO_1:
                    return GetIsoSettingDescription();
                case NikonType2Directory.TAG_NIKON_TYPE2_DIGITAL_ZOOM:
                    return GetDigitalZoomDescription();
                case NikonType2Directory.TAG_NIKON_TYPE2_AF_FOCUS_POSITION:
                    return GetAutoFocusPositionDescription();
                case NikonType2Directory.TAG_NIKON_TYPE2_FIRMWARE_VERSION:
                    return GetAutoFirmwareVersionDescription();
                default:
                    return base.directory.GetString(tagType);
            }
        }

        /// <summary>
        /// Returns auto focus position Description. 
        /// </summary>
        /// <returns>the auto focus position Description.</returns>
        private string GetAutoFocusPositionDescription()
        {
            if (!base.directory.ContainsTag(NikonType2Directory.TAG_NIKON_TYPE2_AF_FOCUS_POSITION))
            {
                return null;
            }
            int[] values = base.directory.GetIntArray(NikonType2Directory.TAG_NIKON_TYPE2_AF_FOCUS_POSITION);
            if (values.Length != 4 || values[0] != 0 || values[2] != 0 || values[3] != 0)
            {
                return BUNDLE["UNKNOWN", base.directory.GetString(NikonType2Directory.TAG_NIKON_TYPE2_AF_FOCUS_POSITION)];
            }
            switch (values[1])
            {
                case 0:
                    return BUNDLE["CENTER"];
                case 1:
                    return BUNDLE["TOP"];
                case 2:
                    return BUNDLE["BOTTOM"];
                case 3:
                    return BUNDLE["LEFT"];
                case 4:
                    return BUNDLE["RIGHT"];
                default:
                    return BUNDLE["UNKNOWN", values[1].ToString()];
            }
        }

        /// <summary>
        /// Returns digital zoom Description. 
        /// </summary>
        /// <returns>the digital zoom Description.</returns>
        private string GetDigitalZoomDescription()
        {
            if (!base.directory.ContainsTag(NikonType2Directory.TAG_NIKON_TYPE2_DIGITAL_ZOOM))
            {
                return null;
            }
            Rational rational = base.directory.GetRational(NikonType2Directory.TAG_NIKON_TYPE2_DIGITAL_ZOOM);
            if (rational.IntValue() == 1)
            {
                return BUNDLE["NO_DIGITAL_ZOOM"];
            }
            return BUNDLE["DIGITAL_ZOOM", rational.ToSimpleString(true)];
        }

        /// <summary>
        /// Returns iso setting Description. 
        /// </summary>
        /// <returns>the iso setting Description.</returns>
        private string GetIsoSettingDescription()
        {
            if (!base.directory.ContainsTag(NikonType2Directory.TAG_NIKON_TYPE2_ISO_1))
            {
                return null;
            }
            int[] values = base.directory.GetIntArray(NikonType2Directory.TAG_NIKON_TYPE2_ISO_1);
            if (values[0] != 0 || values[1] == 0)
            {
                return BUNDLE["UNKNOWN", base.directory.GetString(NikonType2Directory.TAG_NIKON_TYPE2_ISO_1)];
            }
            return BUNDLE["ISO", values[1].ToString()];
        }

        /// <summary>
        /// Returns auto flash compensation Description. 
        /// </summary>
        /// <returns>the auto flash compensation Description.</returns>
        private Rational GetAutoFlashCompensation()
        {
            if (!base.directory.ContainsTag(NikonType2Directory.TAG_NIKON_TYPE2_AUTO_FLASH_COMPENSATION))
            {
                return null;
            }
            byte[] bytes = base.directory.GetByteArray(NikonType2Directory.TAG_NIKON_TYPE2_AUTO_FLASH_COMPENSATION);

            if (bytes.Length == 3)
            {
                byte denominator = bytes[2];
                int numerator = (int)bytes[0] * bytes[1];
                return new Rational(numerator, denominator);
            }
            return null;
        }

        /// <summary>
        /// Returns auto falsh compensation Description. 
        /// </summary>
        /// <returns>the auto falsh compensation Description.</returns>
        private string GetAutoFlashCompensationDescription()
        {
            Rational ev = this.GetAutoFlashCompensation();

            if (ev == null)
            {
                return BUNDLE["UNKNOWN", "null"];
            }
            return BUNDLE["FLASH_SIMPLE", ev.FloatValue().ToString("0.##")];
        }

        /// <summary>
        /// Returns lens Description. 
        /// </summary>
        /// <returns>the lens Description.</returns>
        private string GetLensDescription()
        {
            if (!base.directory.ContainsTag(NikonType2Directory.TAG_NIKON_TYPE2_LENS))
            {
                return null;
            }

            Rational[] lensValues = base.directory.GetRationalArray(NikonType2Directory.TAG_NIKON_TYPE2_LENS);

            if (lensValues.Length != 4)
            {
                return base.directory.GetString(NikonType2Directory.TAG_NIKON_TYPE2_LENS);
            }
            string[] tab = new string[] { lensValues[0].IntValue().ToString(), lensValues[1].IntValue().ToString(), lensValues[2].IntValue().ToString(), lensValues[3].IntValue().ToString() };
            return BUNDLE["LENS", tab];
        }

        /// <summary>
        /// Returns hue adjustement Description. 
        /// </summary>
        /// <returns>the hue adjustement Description.</returns>
        private string GetHueAdjustmentDescription()
        {
            if (!base.directory.ContainsTag(NikonType2Directory.TAG_NIKON_TYPE2_CAMERA_HUE_ADJUSTMENT))
            {
                return null;
            }

            return BUNDLE["DEGREES", base.directory.GetString(NikonType2Directory.TAG_NIKON_TYPE2_CAMERA_HUE_ADJUSTMENT)];
        }

        /// <summary>
        /// Returns color mode Description. 
        /// </summary>
        /// <returns>the color mode Description.</returns>
        private string GetColorModeDescription()
        {
            if (!base.directory.ContainsTag(NikonType2Directory.TAG_NIKON_TYPE2_CAMERA_COLOR_MODE))
            {
                return null;
            }

            String raw = base.directory.GetString(NikonType2Directory.TAG_NIKON_TYPE2_CAMERA_COLOR_MODE);
            if (raw.StartsWith("MODE1"))
            {
                return BUNDLE["MODE_I_SRGB"];
            }

            return raw;
        }

        /// <summary>
        /// Returns auto firmware version Description. 
        /// </summary>
        /// <returns>the auto firmware version Description.</returns>
        private string GetAutoFirmwareVersionDescription()
        {
            if (!base.directory.ContainsTag(NikonType2Directory.TAG_NIKON_TYPE2_FIRMWARE_VERSION))
            {
                return null;
            }

            int[] ints = base.directory.GetIntArray(NikonType2Directory.TAG_NIKON_TYPE2_FIRMWARE_VERSION);
            return ExifDescriptor.ConvertBytesToVersionString(ints);
        }
    }
}

using System;
using System.Collections;
using System.Text;
using System.IO;
using com.drew.metadata;
using com.drew.lang;

/// <summary>
/// This class was first written by Drew Noakes in Java.
///
/// This is public domain software - that is, you can do whatever you want
/// with it, and include it software that is licensed under the GNU or the
/// BSD license, or whatever other licence you choose, including proprietary
/// closed source licenses.  I do ask that you leave this lcHeader in tact.
///
/// If you make modifications to this code that you think would benefit the
/// wider community, please send me a copy and I'll post it on my site.
///
/// If you make use of this code, Drew Noakes will appreciate hearing 
/// about it: <a href="mailto:drew@drewnoakes.com">drew@drewnoakes.com</a>
///
/// Latest Java version of this software kept at 
/// <a href="http://drewnoakes.com">http://drewnoakes.com/</a>
///
/// The C# class was made by Ferret Renaud: 
/// <a href="mailto:renaud91@free.fr">renaud91@free.fr</a>
/// If you find a bug in the C# code, feel free to mail me.
/// </summary>
namespace com.drew.metadata.exif
{
	/// <summary>
	/// Tag descriptor for Olympus
	/// </summary>
	public class OlympusDescriptor : AbstractTagDescriptor 
	{
		/// <summary>
		/// Constructor of the object
		/// </summary>
		/// <param name="aDirectory">a base.directory</param>
		public OlympusDescriptor(AbstractDirectory aDirectory) : base(aDirectory)
		{		
		}

		/// <summary>
		/// Returns a descriptive value of the the specified tag for this image. 
		/// Where possible, known values will be substituted here in place of the raw tokens actually 
		/// kept in the Exif segment. 
		/// If no substitution is available, the value provided by GetString(int) will be returned.
		/// This and GetString(int) are the only 'get' methods that won't throw an exception.
		/// </summary>
		/// <param name="aTagType">the tag to find a description for</param>
		/// <returns>a description of the image'str value for the specified tag, or null if the tag hasn't been defined.</returns>
		public override string GetDescription(int tagType)  
		{
			switch(tagType) 
			{
				case OlympusDirectory.TAG_OLYMPUS_SPECIAL_MODE :
					return GetSpecialModeDescription();
				case OlympusDirectory.TAG_OLYMPUS_JPEG_QUALITY :
					return GetJpegQualityDescription();
				case OlympusDirectory.TAG_OLYMPUS_MACRO_MODE :
					return GetMacroModeDescription();
				case OlympusDirectory.TAG_OLYMPUS_DIGI_ZOOM_RATIO :
					return GetDigiZoomRatioDescription();
				default:
					return base.directory.GetString(tagType);
			}
		}

		/// <summary>
		/// Returns the Digi Zoom Ratio Description. 
		/// </summary>
		/// <returns>the Digi Zoom Ratio Description.</returns>
		private string GetDigiZoomRatioDescription()  
		{
            if (!base.directory
                .ContainsTag(OlympusDirectory.TAG_OLYMPUS_DIGI_ZOOM_RATIO))
            {
                return null;
            }
			int aValue =
				base.directory.GetInt(
				OlympusDirectory.TAG_OLYMPUS_DIGI_ZOOM_RATIO);
			switch (aValue) 
			{
				case 0 :
					return BUNDLE["NORMAL"];
                case 1:
                    return BUNDLE["DIGITAL_ZOOM", "1"];
				case 2 :
                    return BUNDLE["DIGITAL_ZOOM", "2"];
				default :
					return BUNDLE["UNKNOWN", aValue.ToString()];
			}
		}

		/// <summary>
		/// Returns the Macro Mode Description. 
		/// </summary>
		/// <returns>the Macro Mode Description.</returns>
		private string GetMacroModeDescription()  
		{
            if (!base.directory
                .ContainsTag(OlympusDirectory.TAG_OLYMPUS_MACRO_MODE))
            {
                return null;
            }
			int aValue =
				base.directory.GetInt(OlympusDirectory.TAG_OLYMPUS_MACRO_MODE);
			switch (aValue) 
			{
				case 0 :
					return BUNDLE["NORMAL_NO_MACRO"];
				case 1 :
					return BUNDLE["MACRO"];
				default :
					return BUNDLE["UNKNOWN", aValue.ToString() ];
			}
		}

		/// <summary>
		/// Returns the Jpeg Quality Description. 
		/// </summary>
		/// <returns>the Jpeg Quality Description.</returns>
		private string GetJpegQualityDescription()  
		{
            if (!base.directory
                .ContainsTag(OlympusDirectory.TAG_OLYMPUS_JPEG_QUALITY))
            {
                return null;
            }
			int aValue =
				base.directory.GetInt(
				OlympusDirectory.TAG_OLYMPUS_JPEG_QUALITY);
			switch (aValue) 
			{
				case 1 :
					return BUNDLE["SQ"];
				case 2 :
					return BUNDLE["HQ"];
				case 3 :
					return BUNDLE["SHQ"];
				default :
					return BUNDLE["UNKNOWN", aValue.ToString() ];
			}
		}

		/// <summary>
		/// Returns the Special Mode Description. 
		/// </summary>
		/// <returns>the Special Mode Description.</returns>
		private string GetSpecialModeDescription()  
		{
            if (!base.directory
                .ContainsTag(OlympusDirectory.TAG_OLYMPUS_SPECIAL_MODE))
            {
                return null;
            }
			int[] values =
				base.directory.GetIntArray(
				OlympusDirectory.TAG_OLYMPUS_SPECIAL_MODE);
			StringBuilder desc = new StringBuilder();
			switch (values[0]) 
			{
				case 0 :
					desc.Append(BUNDLE["NORMAL_PICTURE_TAKING_MODE"]);
					break;
				case 1 :
					desc.Append(BUNDLE["UNKNOWN_PICTURE_TAKING_MODE"]);
					break;
				case 2 :
					desc.Append(BUNDLE["FAST_PICTURE_TAKING_MODE"]);
					break;
				case 3 :
					desc.Append(BUNDLE["PANORAMA_PICTURE_TAKING_MODE"]);
					break;
				default :
					desc.Append(BUNDLE["UNKNOWN_PICTURE_TAKING_MODE"]);
					break;
			}
			desc.Append(" - ");
			switch (values[1]) 
			{
				case 0 :
					desc.Append(BUNDLE["UNKNOWN_SEQUENCE_NUMBER"]);
					break;
				default :
					desc.Append(BUNDLE["X_RD_IN_A_SEQUENCE", values[1].ToString()]);
					break;
			}
			switch (values[2]) 
			{
				case 1 :
					desc.Append(BUNDLE["LEFT_TO_RIGHT_PAN_DIR"]);
					break;
				case 2 :
					desc.Append(BUNDLE["RIGHT_TO_LEFT_PAN_DIR"]);
					break;
				case 3 :
					desc.Append(BUNDLE["BOTTOM_TO_TOP_PAN_DIR"]);
					break;
				case 4 :
					desc.Append(BUNDLE["TOP_TO_BOTTOM_PAN_DIR"]);
					break;
			}
			return desc.ToString();
		}
	}
}
using System;
using System.Collections;
using System.Text;
using System.IO;
using com.drew.metadata;
using com.drew.lang;

/// <summary>
/// This class was first written by Drew Noakes in Java.
///
/// This is public domain software - that is, you can do whatever you want
/// with it, and include it software that is licensed under the GNU or the
/// BSD license, or whatever other licence you choose, including proprietary
/// closed source licenses.  I do ask that you leave this lcHeader in tact.
///
/// If you make modifications to this code that you think would benefit the
/// wider community, please send me a copy and I'll post it on my site.
///
/// If you make use of this code, Drew Noakes will appreciate hearing 
/// about it: <a href="mailto:drew@drewnoakes.com">drew@drewnoakes.com</a>
///
/// Latest Java version of this software kept at 
/// <a href="http://drewnoakes.com">http://drewnoakes.com/</a>
///
/// The C# class was made by Ferret Renaud: 
/// <a href="mailto:renaud91@free.fr">renaud91@free.fr</a>
/// If you find a bug in the C# code, feel free to mail me.
/// </summary>
namespace com.drew.metadata.exif
{
	/// <summary>
	/// Tag descriptor for Panasonic
	/// </summary>
	public class PanasonicDescriptor : AbstractTagDescriptor 
	{
		/// <summary>
		/// Constructor of the object
		/// </summary>
		/// <param name="aDirectory">a base.directory</param>
        public PanasonicDescriptor(AbstractDirectory aDirectory)
            : base(aDirectory)
		{		
		}

		/// <summary>
		/// Returns a descriptive value of the the specified tag for this image. 
		/// Where possible, known values will be substituted here in place of the raw tokens actually 
		/// kept in the Exif segment. 
		/// If no substitution is available, the value provided by GetString(int) will be returned.
		/// This and GetString(int) are the only 'get' methods that won't throw an exception.
		/// </summary>
		/// <param name="aTagType">the tag to find a description for</param>
		/// <returns>a description of the image'str value for the specified tag, or null if the tag hasn't been defined.</returns>
		public override string GetDescription(int tagType)  
		{
            switch (tagType)
            {
                case PanasonicDirectory.TAG_PANASONIC_MACRO_MODE:
                    return GetMacroModeDescription();
                case PanasonicDirectory.TAG_PANASONIC_RECORD_MODE:
                    return GetRecordModeDescription();
                case PanasonicDirectory.TAG_PANASONIC_PRINT_IMAGE_MATCHING_INFO:
                    return GetPrintImageMatchingInfoDescription();
                default:
                    return base.directory.GetString(tagType);
            }
        }

        /// <summary>
        /// Returns the print image matching info Description. 
        /// </summary>
        /// <returns>the print image matching info Description.</returns>
        private string GetPrintImageMatchingInfoDescription()
        {
            if (!base.directory.ContainsTag(PanasonicDirectory.TAG_PANASONIC_PRINT_IMAGE_MATCHING_INFO))
            {
                return null;
            }
            byte[] bytes = base.directory.GetByteArray(PanasonicDirectory.TAG_PANASONIC_PRINT_IMAGE_MATCHING_INFO);
            return BUNDLE["BYTES", bytes.Length.ToString()];
        }

        /// <summary>
        /// Returns the macro mode Description. 
        /// </summary>
        /// <returns>the macro mode Description.</returns>
        private string GetMacroModeDescription()
        {
            if (!base.directory.ContainsTag(PanasonicDirectory.TAG_PANASONIC_MACRO_MODE))
            {
                return null;
            }
            int value = base.directory.GetInt(PanasonicDirectory.TAG_PANASONIC_MACRO_MODE);
            switch (value)
            {
                case 1:
                    return BUNDLE["ON"];
                case 2:
                    return BUNDLE["OFF"];
                default:
                    return BUNDLE["UNKNOWN", value.ToString()];
            }
        }

        /// <summary>
        /// Returns record mode Description. 
        /// </summary>
        /// <returns>the record mode Description.</returns>
        private string GetRecordModeDescription()
        {
            if (!base.directory.ContainsTag(PanasonicDirectory.TAG_PANASONIC_RECORD_MODE))
            {
                return null;
            }
            int value = base.directory.GetInt(PanasonicDirectory.TAG_PANASONIC_RECORD_MODE);
            switch (value)
            {
                case 1:
                    return BUNDLE["NORMAL"];
                case 2:
                    return BUNDLE["PORTRAIT"];
                case 9:
                    return BUNDLE["MACRO"];
                default:
                    return BUNDLE["UNKNOWN", value.ToString()];
            }
        }


	}
}
using System;
using System.Collections;
using System.Text;
using System.IO;
using com.drew.metadata;
using com.drew.lang;

/// <summary>
/// This class was first written by Drew Noakes in Java.
///
/// This is public domain software - that is, you can do whatever you want
/// with it, and include it software that is licensed under the GNU or the
/// BSD license, or whatever other licence you choose, including proprietary
/// closed source licenses.  I do ask that you leave this lcHeader in tact.
///
/// If you make modifications to this code that you think would benefit the
/// wider community, please send me a copy and I'll post it on my site.
///
/// If you make use of this code, Drew Noakes will appreciate hearing 
/// about it: <a href="mailto:drew@drewnoakes.com">drew@drewnoakes.com</a>
///
/// Latest Java version of this software kept at 
/// <a href="http://drewnoakes.com">http://drewnoakes.com/</a>
///
/// The C# class was made by Ferret Renaud: 
/// <a href="mailto:renaud91@free.fr">renaud91@free.fr</a>
/// If you find a bug in the C# code, feel free to mail me.
/// </summary>
namespace com.drew.metadata.exif
{
    /// <summary>
    /// Tag descriptor for pentax
    /// </summary>
    public class PentaxDescriptor : AbstractTagDescriptor
    {
        /// <summary>
        /// Constructor of the object
        /// </summary>
        /// <param name="base.directory">a base.directory</param>
        public PentaxDescriptor(AbstractDirectory aDirectory)
            : base(aDirectory)
        {
        }

        /// <summary>
        /// Returns a descriptive value of the the specified tag for this image. 
        /// Where possible, known values will be substituted here in place of the raw tokens actually 
        /// kept in the Exif segment. 
        /// If no substitution is available, the value provided by GetString(int) will be returned.
        /// This and GetString(int) are the only 'get' methods that won't throw an exception.
        /// </summary>
        /// <param name="aTagType">the tag to find a description for</param>
        /// <returns>a description of the image'str value for the specified tag, or null if the tag hasn't been defined.</returns>
        public override string GetDescription(int tagType)
        {
            switch (tagType)
            {
                case PentaxDirectory.TAG_PENTAX_CAPTURE_MODE:
                    return GetCaptureModeDescription();
                case PentaxDirectory.TAG_PENTAX_QUALITY_LEVEL:
                    return GetQualityLevelDescription();
                case PentaxDirectory.TAG_PENTAX_FOCUS_MODE:
                    return GetFocusModeDescription();
                case PentaxDirectory.TAG_PENTAX_FLASH_MODE:
                    return GetFlashModeDescription();
                case PentaxDirectory.TAG_PENTAX_WHITE_BALANCE:
                    return GetWhiteBalanceDescription();
                case PentaxDirectory.TAG_PENTAX_DIGITAL_ZOOM:
                    return GetDigitalZoomDescription();
                case PentaxDirectory.TAG_PENTAX_SHARPNESS:
                    return GetSharpnessDescription();
                case PentaxDirectory.TAG_PENTAX_CONTRAST:
                    return GetContrastDescription();
                case PentaxDirectory.TAG_PENTAX_SATURATION:
                    return GetSaturationDescription();
                case PentaxDirectory.TAG_PENTAX_ISO_SPEED:
                    return GetIsoSpeedDescription();
                case PentaxDirectory.TAG_PENTAX_COLOR:
                    return GetColorDescription();
                case PentaxDirectory.TAG_PENTAX_PRINT_IMAGE_MATCHING_INFO:
                    return GetPrintImageMatchingInfoDescription();
                default:
                    return base.directory.GetString(tagType);
            }
        }

        /// <summary>
        /// Returns the color Description. 
        /// </summary>
        /// <returns>the color Description.</returns>
        private string GetColorDescription()
        {
            if (!base.directory.ContainsTag(PentaxDirectory.TAG_PENTAX_COLOR))
            {
                return null;
            }
            int aValue = base.directory.GetInt(PentaxDirectory.TAG_PENTAX_COLOR);
            switch (aValue)
            {
                case 1: return BUNDLE["NORMAL"];
                case 2: return BUNDLE["BLACK_AND_WHITE"];
                case 3: return BUNDLE["SEPIA"];
                default: return BUNDLE["UNKNOWN", aValue.ToString()];
            }
        }

        /// <summary>
        /// Returns the iso speed Description. 
        /// </summary>
        /// <returns>the iso speed Description.</returns>
        private string GetIsoSpeedDescription()
        {
            if (!base.directory.ContainsTag(PentaxDirectory.TAG_PENTAX_ISO_SPEED))
            {
                return null;
            }
            int aValue = base.directory.GetInt(PentaxDirectory.TAG_PENTAX_ISO_SPEED);
            switch (aValue)
            {
                case 100:
                case 10: return BUNDLE["ISO", "100"];
                case 16:
                case 200: return BUNDLE["ISO", "200"];
                default: return BUNDLE["UNKNOWN", aValue.ToString()];
            }
        }

        /// <summary>
        /// Returns the saturation Description. 
        /// </summary>
        /// <returns>the saturation Description.</returns>
        private string GetSaturationDescription()
        {
            if (!base.directory.ContainsTag(PentaxDirectory.TAG_PENTAX_SATURATION))
            {
                return null;
            }
            int aValue = base.directory.GetInt(PentaxDirectory.TAG_PENTAX_SATURATION);
            switch (aValue)
            {
                case 0: return BUNDLE["NORMAL"];
                case 1: return BUNDLE["LOW"];
                case 2: return BUNDLE["HIGH"];
                default: return BUNDLE["UNKNOWN", aValue.ToString()];
            }
        }

        /// <summary>
        /// Returns the contrast Description. 
        /// </summary>
        /// <returns>the contrast Description.</returns>
        private string GetContrastDescription()
        {
            if (!base.directory.ContainsTag(PentaxDirectory.TAG_PENTAX_CONTRAST))
            {
                return null;
            }
            int aValue = base.directory.GetInt(PentaxDirectory.TAG_PENTAX_CONTRAST);
            switch (aValue)
            {
                case 0: return BUNDLE["NORMAL"];
                case 1: return BUNDLE["LOW"];
                case 2: return BUNDLE["HIGH"];
                default: return BUNDLE["UNKNOWN", aValue.ToString()];
            }
        }

        /// <summary>
        /// Returns the sharpness Description. 
        /// </summary>
        /// <returns>the sharpness Description.</returns>
        private string GetSharpnessDescription()
        {
            if (!base.directory.ContainsTag(PentaxDirectory.TAG_PENTAX_SHARPNESS))
            {
                return null;
            }
            int aValue = base.directory.GetInt(PentaxDirectory.TAG_PENTAX_SHARPNESS);
            switch (aValue)
            {
                case 0: return BUNDLE["NORMAL"];
                case 1: return BUNDLE["SOFT"];
                case 2: return BUNDLE["HARD"];
                default: return BUNDLE["UNKNOWN", aValue.ToString()];
            }
        }

        /// <summary>
        /// Returns the digial zoom Description. 
        /// </summary>
        /// <returns>the digital zoom Description.</returns>
        private string GetDigitalZoomDescription()
        {
            if (!base.directory.ContainsTag(PentaxDirectory.TAG_PENTAX_DIGITAL_ZOOM))
            {
                return null;
            }
            float aValue = base.directory.GetFloat(PentaxDirectory.TAG_PENTAX_DIGITAL_ZOOM);
            if (aValue == 0)
            {
                return BUNDLE["OFF"];
            }
            return aValue.ToString();
        }

        /// <summary>
        /// Returns the white balance Description. 
        /// </summary>
        /// <returns>the white balance Description.</returns>
        private string GetWhiteBalanceDescription()
        {
            if (!base.directory.ContainsTag(PentaxDirectory.TAG_PENTAX_WHITE_BALANCE))
            {
                return null;
            }
            int aValue = base.directory.GetInt(PentaxDirectory.TAG_PENTAX_WHITE_BALANCE);
            switch (aValue)
            {
                case 0: return BUNDLE["AUTO"];
                case 1: return BUNDLE["DAYLIGHT"];
                case 2: return BUNDLE["SHADE"];
                case 3: return BUNDLE["TUNGSTEN"];
                case 4: return BUNDLE["FLUORESCENT"];
                case 5: return BUNDLE["MANUAL"];
                default: return BUNDLE["UNKNOWN", aValue.ToString()];
            }
        }

        /// <summary>
        /// Returns the flash mode Description. 
        /// </summary>
        /// <returns>the dlash mode Description.</returns>
        private string GetFlashModeDescription()
        {
            if (!base.directory.ContainsTag(PentaxDirectory.TAG_PENTAX_FLASH_MODE))
            {
                return null;
            }
            int aValue = base.directory.GetInt(PentaxDirectory.TAG_PENTAX_FLASH_MODE);
            switch (aValue)
            {
                case 1: return BUNDLE["AUTO"];
                case 2: return BUNDLE["FLASH_ON"];
                case 4: return BUNDLE["FLASH_OFF"];
                case 6: return BUNDLE["RED_EYE_REDUCTION"];
                default: return BUNDLE["UNKNOWN", aValue.ToString()];
            }
        }

        /// <summary>
        /// Returns the focus mode Description. 
        /// </summary>
        /// <returns>the focus mode Description.</returns>
        private string GetFocusModeDescription()
        {
            if (!base.directory.ContainsTag(PentaxDirectory.TAG_PENTAX_FOCUS_MODE))
            {
                return null;
            }
            int aValue = base.directory.GetInt(PentaxDirectory.TAG_PENTAX_FOCUS_MODE);
            switch (aValue)
            {
                case 2: return BUNDLE["CUSTOM"];
                case 3: return BUNDLE["AUTO"];
                default: return BUNDLE["UNKNOWN", aValue.ToString()];
            }
        }

        /// <summary>
        /// Returns the quality level Description. 
        /// </summary>
        /// <returns>the quality level Description.</returns>
        private string GetQualityLevelDescription()
        {
            if (!base.directory.ContainsTag(PentaxDirectory.TAG_PENTAX_QUALITY_LEVEL))
            {
                return null;
            }
            int aValue = base.directory.GetInt(PentaxDirectory.TAG_PENTAX_QUALITY_LEVEL);
            switch (aValue)
            {
                case 0: return BUNDLE["GOOD"];
                case 1: return BUNDLE["BETTER"];
                case 2: return BUNDLE["BEST"];
                default: return BUNDLE["UNKNOWN", aValue.ToString()];
            }
        }

        /// <summary>
        /// Returns the capture mode Description. 
        /// </summary>
        /// <returns>the capture mode Description.</returns>
        private string GetCaptureModeDescription()
        {
            if (!base.directory.ContainsTag(PentaxDirectory.TAG_PENTAX_CAPTURE_MODE))
            {
                return null;
            }
            int aValue = base.directory.GetInt(PentaxDirectory.TAG_PENTAX_CAPTURE_MODE);
            switch (aValue)
            {
                case 1: return BUNDLE["AUTO"];
                case 2: return BUNDLE["NIGHT_SCENE"];
                case 3: return BUNDLE["MANUAL"];
                case 4: return BUNDLE["MULTIPLE"];
                default: return BUNDLE["UNKNOWN", aValue.ToString()];
            }
        }

        /// <summary>
        /// Returns the print image matching info Description. 
        /// </summary>
        /// <returns>the print image matching info Description.</returns>
        private string GetPrintImageMatchingInfoDescription()
        {
            if (!base.directory.ContainsTag(PentaxDirectory.TAG_PENTAX_PRINT_IMAGE_MATCHING_INFO))
            {
                return null;
            }
            byte[] bytes = base.directory.GetByteArray(PentaxDirectory.TAG_PENTAX_PRINT_IMAGE_MATCHING_INFO);
            return BUNDLE["BYTES", bytes.Length.ToString()];
        }

    }
}
using System;
using System.Collections;
using System.Text;
using System.IO;
using com.drew.metadata;
using com.drew.lang;

/// <summary>
/// This class was first written by Drew Noakes in Java.
///
/// This is public domain software - that is, you can do whatever you want
/// with it, and include it software that is licensed under the GNU or the
/// BSD license, or whatever other licence you choose, including proprietary
/// closed source licenses.  I do ask that you leave this lcHeader in tact.
///
/// If you make modifications to this code that you think would benefit the
/// wider community, please send me a copy and I'll post it on my site.
///
/// If you make use of this code, Drew Noakes will appreciate hearing 
/// about it: <a href="mailto:drew@drewnoakes.com">drew@drewnoakes.com</a>
///
/// Latest Java version of this software kept at 
/// <a href="http://drewnoakes.com">http://drewnoakes.com/</a>
///
/// The C# class was made by Ferret Renaud: 
/// <a href="mailto:renaud91@free.fr">renaud91@free.fr</a>
/// If you find a bug in the C# code, feel free to mail me.
/// </summary>
namespace com.drew.metadata.exif
{
	/// <summary>
	/// Tag descriptor for sony
	/// </summary>
	public class SonyDescriptor : AbstractTagDescriptor 
	{
		/// <summary>
		/// Constructor of the object
		/// </summary>
		/// <param name="directory">a directory</param>
        public SonyDescriptor(AbstractDirectory directory)
            : base(directory)
		{		
		}

		/// <summary>
		/// Returns a descriptive value of the the specified tag for this image. 
		/// Where possible, known values will be substituted here in place of the raw tokens actually 
		/// kept in the Exif segment. 
		/// If no substitution is available, the value provided by GetString(int) will be returned.
		/// This and GetString(int) are the only 'get' methods that won't throw an exception.
		/// </summary>
		/// <param name="aTagType">the tag to find a description for</param>
		/// <returns>a description of the image'str value for the specified tag, or null if the tag hasn't been defined.</returns>
		public override string GetDescription(int tagType)  
		{
            return base.directory.GetString(tagType);
		}

	}
}
using System;
using com.drew.lang;
using com.drew.metadata;

/// <summary>
/// This class was first written by Drew Noakes in Java.
///
/// This is public domain software - that is, you can do whatever you want
/// with it, and include it software that is licensed under the GNU or the
/// BSD license, or whatever other licence you choose, including proprietary
/// closed source licenses.  I do ask that you leave this lcHeader in tact.
///
/// If you make modifications to this code that you think would benefit the
/// wider community, please send me a copy and I'll post it on my site.
///
/// If you make use of this code, Drew Noakes will appreciate hearing 
/// about it: <a href="mailto:drew@drewnoakes.com">drew@drewnoakes.com</a>
///
/// Latest Java version of this software kept at 
/// <a href="http://drewnoakes.com">http://drewnoakes.com/</a>
///
/// The C# class was made by Ferret Renaud: 
/// <a href="mailto:renaud91@free.fr">renaud91@free.fr</a>
/// If you find a bug in the C# code, feel free to mail me.
/// </summary>
namespace com.drew.metadata.iptc
{
	/// <summary>
	/// Tag descriptor for IPTC
	/// </summary>
	public class IptcDescriptor : AbstractTagDescriptor 
	{
		/// <summary>
		/// Constructor of the object
		/// </summary>
		/// <param name="aDirectory">a base.directory</param>
		public IptcDescriptor(AbstractDirectory aDirectory) : base(aDirectory)
		{
		}

		/// <summary>
		/// Returns a descriptive value of the the specified tag for this image. 
		/// Where possible, known values will be substituted here in place of the raw tokens actually 
		/// kept in the Exif segment. 
		/// If no substitution is available, the value provided by GetString(int) will be returned.
		/// This and GetString(int) are the only 'get' methods that won't throw an exception.
		/// </summary>
		/// <param name="aTagType">the tag to find a description for</param>
		/// <returns>a description of the image'str value for the specified tag, or null if the tag hasn't been defined.</returns>
		public override string GetDescription(int tagType) 
		{
            switch (tagType)
            {
                case IptcDirectory.TAG_URGENCY :
                    return GetUrgencyDescription();
                default:
                    return base.directory.GetString(tagType);
            }
			
		}

        /// <summary>
        /// Returns urgency Description. 
        /// </summary>
        /// <returns>the urgency Description.</returns>
        private string GetUrgencyDescription()
        {
            if (!base.directory
                .ContainsTag(IptcDirectory.TAG_URGENCY))
            {
                return null;
            }
            int aValue =
                base.directory.GetInt(
                IptcDirectory.TAG_URGENCY);
            switch (aValue)
            {
                case 49:
                    return BUNDLE["HIGH"];
                case 54:
                    return BUNDLE["NORMAL"];
                case 56:
                    return BUNDLE["LOW"];
                default:
                    return BUNDLE["UNKNOWN", aValue.ToString()];
            }
        }

	}
}
using System;
using com.drew.metadata;

/// <summary>
/// This class was first written by Drew Noakes in Java.
///
/// This is public domain software - that is, you can do whatever you want
/// with it, and include it software that is licensed under the GNU or the
/// BSD license, or whatever other licence you choose, including proprietary
/// closed source licenses.  I do ask that you leave this lcHeader in tact.
///
/// If you make modifications to this code that you think would benefit the
/// wider community, please send me a copy and I'll post it on my site.
///
/// If you make use of this code, Drew Noakes will appreciate hearing 
/// about it: <a href="mailto:drew@drewnoakes.com">drew@drewnoakes.com</a>
///
/// Latest Java version of this software kept at 
/// <a href="http://drewnoakes.com">http://drewnoakes.com/</a>
///
/// The C# class was made by Ferret Renaud: 
/// <a href="mailto:renaud91@free.fr">renaud91@free.fr</a>
/// If you find a bug in the C# code, feel free to mail me.
/// </summary>
namespace com.drew.metadata.jpeg
{
	/// <summary>
	/// Tag descriptor for Jpeg
	/// </summary>
	public class JpegCommentDescriptor : AbstractTagDescriptor 
	{
		/// <summary>
		/// Constructor of the object
		/// </summary>
		/// <param name="directory">a directory</param>
		public JpegCommentDescriptor(AbstractDirectory directory) : base(directory) 
		{
		}

		/// <summary>
		/// Returns a descriptive value of the the specified tag for this image. 
		/// Where possible, known values will be substituted here in place of the raw tokens actually 
		/// kept in the Exif segment. 
		/// If no substitution is available, the value provided by GetString(int) will be returned.
		/// This and GetString(int) are the only 'get' methods that won't throw an exception.
		/// </summary>
		/// <param name="aTagType">the tag to find a description for</param>
		/// <returns>a description of the image'str value for the specified tag, or null if the tag hasn't been defined.</returns>
		public override string GetDescription(int tagType) 
		{
			return base.directory.GetString(tagType);
		}
	}
}

using System;
using System.Text;
using System.IO;
using com.drew.metadata;

/// <summary>
/// This class was first written by Drew Noakes in Java.
///
/// This is public domain software - that is, you can do whatever you want
/// with it, and include it software that is licensed under the GNU or the
/// BSD license, or whatever other licence you choose, including proprietary
/// closed source licenses.  I do ask that you leave this lcHeader in tact.
///
/// If you make modifications to this code that you think would benefit the
/// wider community, please send me a copy and I'll post it on my site.
///
/// If you make use of this code, Drew Noakes will appreciate hearing 
/// about it: <a href="mailto:drew@drewnoakes.com">drew@drewnoakes.com</a>
///
/// Latest Java version of this software kept at 
/// <a href="http://drewnoakes.com">http://drewnoakes.com/</a>
///
/// The C# class was made by Ferret Renaud: 
/// <a href="mailto:renaud91@free.fr">renaud91@free.fr</a>
/// If you find a bug in the C# code, feel free to mail me.
/// </summary>
namespace com.drew.metadata.jpeg
{
	/// <summary>
	/// Tag descriptor for Jpeg
	/// </summary>
	public class JpegDescriptor : AbstractTagDescriptor 
	{
		/// <summary>
		/// Constructor of the object
		/// </summary>
		/// <param name="directory">a directory</param>
		public JpegDescriptor(AbstractDirectory directory) : base(directory)
		{
		}

		/// <summary>
		/// Returns a descriptive value of the the specified tag for this image. 
		/// Where possible, known values will be substituted here in place of the raw tokens actually 
		/// kept in the Exif segment. 
		/// If no substitution is available, the value provided by GetString(int) will be returned.
		/// This and GetString(int) are the only 'get' methods that won't throw an exception.
		/// </summary>
		/// <param name="aTagType">the tag to find a description for</param>
		/// <returns>a description of the image'str value for the specified tag, or null if the tag hasn't been defined.</returns>
		public override string GetDescription(int tagType) 
		{
			switch(tagType) 
			{
				case JpegDirectory.TAG_JPEG_COMPONENT_DATA_1 :
					return GetComponentDataDescription(0);
				case JpegDirectory.TAG_JPEG_COMPONENT_DATA_2 :
					return GetComponentDataDescription(1);
				case JpegDirectory.TAG_JPEG_COMPONENT_DATA_3 :
					return GetComponentDataDescription(2);
				case JpegDirectory.TAG_JPEG_COMPONENT_DATA_4 :
					return GetComponentDataDescription(3);
				case JpegDirectory.TAG_JPEG_DATA_PRECISION :
					return GetDataPrecisionDescription();
				case JpegDirectory.TAG_JPEG_IMAGE_HEIGHT :
					return GetImageHeightDescription();
				case JpegDirectory.TAG_JPEG_IMAGE_WIDTH :
					return GetImageWidthDescription();
				default :
					return base.directory.GetString(tagType);
			}
		}

		/// <summary>
		/// Gets the image width description
		/// </summary>
		/// <returns>the image width description</returns>
		public string GetImageWidthDescription() 
		{
            return BUNDLE["PIXELS", base.directory.GetString(JpegDirectory.TAG_JPEG_IMAGE_WIDTH)];
		}

		/// <summary>
		/// Gets the image height description
		/// </summary>
		/// <returns>the image height description</returns>
		public string GetImageHeightDescription() 
		{
            return BUNDLE["PIXELS", base.directory.GetString(JpegDirectory.TAG_JPEG_IMAGE_HEIGHT)];
		}

		/// <summary>
		/// Gets the Data Precision description
		/// </summary>
		/// <returns>the Data Precision description</returns>
		public string GetDataPrecisionDescription() 
		{
            return BUNDLE["BITS", base.directory.GetString(JpegDirectory.TAG_JPEG_DATA_PRECISION)];
		}

		/// <summary>
		/// Gets the Component Data description
		/// </summary>
		/// <param name="componentNumber">the component number</param>
		/// <returns>the Component Data description</returns>
		public string GetComponentDataDescription(int componentNumber) 
		{
			JpegComponent component =
                ((JpegDirectory)base.directory).GetComponent(componentNumber);
			if (component == null) 
			{
				throw new MetadataException("No Jpeg component exists with number " + componentNumber);
			}

			// {0} component: Quantization table {1}, Sampling factors {2} horiz/{3} vert
			string[] tab = new string[] {component.GetComponentName(), 
											component.QuantizationTableNumber.ToString(),
											component.HorizontalSamplingFactor.ToString(),
											component.VerticalSamplingFactor.ToString()};

			return BUNDLE["COMPONENT_DATA", tab];
		}
	}
}
ï»¿using SharpKml.Base;

namespace SharpKml.Dom
{
    /// <summary>
    /// Specifies a description of a <see cref="Feature"/>, which should be
    /// displayed in the description balloon.
    /// </summary>
    /// <remarks>
    /// <para>OGC KML 2.2 Section 9.1.3.10.</para>
    /// <para>The text may include HTML content, with any HTML links needing
    /// special processing. See the standards for details.</para>
    /// </remarks>
    [KmlElement("description")]
    public sealed class Description : Element, IHtmlContent
    {
        /// <summary>Gets or sets the content of this instance.</summary>
        /// <remarks>The value may contain well formed HTML.</remarks>
        public string Text
        {
            get
            {
                return this.InnerText;
            }
            set
            {
                this.ClearInnerText();
                this.AddInnerText(value);
            }
        }
    }
}

This directory exists so that 3rd party packages can be installed
here.  Read the source for site.py for more details.

MissionPlanner
==============

please see readme.txt
ï»¿
1. Install software

- Git
  http://code.google.com/p/msysgit/downloads/list
  Select a file summarized as "Full installer for official Git for Windows"
   with the highest version
- TortuiseGit
  http://code.google.com/p/tortoisegit/wiki/Download
- Visual Studio
  http://www.visualstudio.com/downloads/download-visual-studio-vs
  Select "Visual Studio Express 2013 for Windows Desktop"
- DirectX Redist
  http://www.microsoft.com/en-us/download/details.aspx?id=35
- Microsoft .NET 4.0

2. Check out

- Create an empty folder anywhere
- In explorer left click and select "Git Clone"
  set URL https://github.com/diydrones/MissionPlanner
  OK

3. Build

- Open ArdupilotMega.sln with Visual Studio express 2013 for windows desktop.
- Compile.


-----------MONO-------------
run using 
mono MissionPlanner.exe

run debuging
MONO_LOG_LEVEL=debug mono MissionPlanner.exe

you need prereq's
sudo apt-get install mono-runtime libmono-system-windows-forms4.0-cil libmono-system-core4.0-cil libmono-winforms2.0-cil libmono-corlib2.0-cil libmono-system-management4.0-cil libmono-system-xml-linq4.0-cil


