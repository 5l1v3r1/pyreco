__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# DjangoRestless documentation build configuration file, created by
# sphinx-quickstart on Sat Jul  7 20:18:28 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

sys.path.insert(0, os.path.abspath('..'))
sys.path.insert(1, os.path.join(os.path.abspath('..'), 'testproject'))

try:
    from django.core.management import setup_environ
    from testproject import settings
    setup_environ(settings)
except ImportError:
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'testproject.settings')
    from django.conf import settings  # noqa

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.coverage', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'DjangoRestless'
copyright = u'2012-2013, DjangoRestless contributors'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.0'
# The full version, including alpha/beta/rc tags.
release = '0.0.8'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'nature'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'DjangoRestlessdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'DjangoRestless.tex', u'DjangoRestless Documentation',
   u'Senko Rasic', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'djangorestless', u'DjangoRestless Documentation',
     [u'Senko Rasic'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'DjangoRestless', u'DjangoRestless Documentation',
   u'Senko Rasic', 'DjangoRestless', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = auth
from django.contrib import auth
from django.utils.encoding import DjangoUnicodeDecodeError
import base64

try:
    from django.utils.encoding import smart_text
except ImportError:
    from django.utils.encoding import smart_unicode as smart_text


from .views import Endpoint
from .http import Http200, Http401, Http403
from .models import serialize


__all__ = ['UsernamePasswordAuthMixin', 'BasicHttpAuthMixin',
    'AuthenticateEndpoint', 'login_required']


class UsernamePasswordAuthMixin(object):
    """
    :py:class:`restless.views.Endpoint` mixin providing user authentication
    based on username and password (as specified in "username" and "password"
    request GET params).
    """

    def authenticate(self, request):
        if request.method == 'POST':
            self.username = request.data.get('username')
            self.password = request.data.get('password')
        else:
            self.username = request.params.get('username')
            self.password = request.params.get('password')

        user = auth.authenticate(username=self.username,
            password=self.password)
        if user is not None and user.is_active:
            auth.login(request, user)


# Taken from Django Rest Framework
class BasicHttpAuthMixin(object):
    """
    :py:class:`restless.views.Endpoint` mixin providing user authentication
    based on HTTP Basic authentication.
    """

    def authenticate(self, request):
        if 'HTTP_AUTHORIZATION' in request.META:
            authdata = request.META['HTTP_AUTHORIZATION'].split()
            if len(authdata) == 2 and authdata[0].lower() == "basic":
                try:
                    raw = authdata[1].encode('ascii')
                    auth_parts = base64.b64decode(raw).split(b':')
                except:
                    return
                try:
                    uname, passwd = (smart_text(auth_parts[0]),
                        smart_text(auth_parts[1]))
                except DjangoUnicodeDecodeError:
                    return

                user = auth.authenticate(username=uname, password=passwd)
                if user is not None and user.is_active:
                    # We don't user auth.login(request, user) because
                    # may be running without session
                    request.user = user


def login_required(fn):
    """
    Decorator for :py:class:`restless.views.Endpoint` methods to require
    authenticated, active user. If the user isn't authenticated, HTTP 403 is
    returned immediately (HTTP 401 if Basic HTTP authentication is used).
    """
    def wrapper(self, request, *args, **kwargs):
        if request.user is None or not request.user.is_active:
            if isinstance(self, BasicHttpAuthMixin):
                return Http401()
            else:
                return Http403('forbidden')
        return fn(self, request, *args, **kwargs)
    wrapper.__name__ = fn.__name__
    wrapper.__doc__ = fn.__doc__
    return wrapper


class AuthenticateEndpoint(Endpoint, UsernamePasswordAuthMixin):
    """
    Session-based authentication API endpoint. Provides a GET method for
    authenticating the user based on passed-in "username" and "password"
    request params. On successful authentication, the method returns
    authenticated user details.

    Uses :py:class:`UsernamePasswordAuthMixin` to actually implement the
    Authentication API endpoint.

    On success, the user will get a response with their serialized User
    object, containing id, username, first_name, last_name and email fields.
    """

    user_fields = ('id', 'username', 'first_name', 'last_name', 'email')

    @login_required
    def get(self, request):
        return Http200(serialize(request.user, fields=self.user_fields))

########NEW FILE########
__FILENAME__ = http
from django import http
from django.core.serializers.json import DjangoJSONEncoder

try:
    # json module from python > 2.6
    import json
except ImportError:
    # use packaged django version of simplejson
    from django.utils import simplejson as json


__all__ = ['JSONResponse', 'JSONErrorResponse', 'HttpError',
    'Http200', 'Http201', 'Http400', 'Http401', 'Http403']


class JSONResponse(http.HttpResponse):
    """HTTP response with JSON body ("application/json" content type)"""

    def __init__(self, data, **kwargs):
        """
        Create a new JSONResponse with the provided data (will be serialized
        to JSON using django.core.serializers.json.DjangoJSONEncoder).
        """

        kwargs['content_type'] = 'application/json; charset=utf-8'
        super(JSONResponse, self).__init__(json.dumps(data,
            cls=DjangoJSONEncoder), **kwargs)


class JSONErrorResponse(JSONResponse):
    """HTTP Error response with JSON body ("application/json" content type)"""

    def __init__(self, reason, **additional_data):
        """
        Create a new JSONErrorResponse with the provided error reason (string)
        and the optional additional data (will be added to the resulting
        JSON object).
        """
        resp = {'error': reason}
        resp.update(additional_data)
        super(JSONErrorResponse, self).__init__(resp)


class Http200(JSONResponse):
    """HTTP 200 OK"""
    pass


class Http201(JSONResponse):
    """HTTP 201 CREATED"""
    status_code = 201


class Http400(JSONErrorResponse, http.HttpResponseBadRequest):
    """HTTP 400 Bad Request"""
    pass


class Http401(http.HttpResponse):
    """HTTP 401 UNAUTHENTICATED"""
    status_code = 401

    def __init__(self, typ='basic', realm="api"):
        super(Http401, self).__init__()
        if typ == 'basic':
            self['WWW-Authenticate'] = 'Basic realm="%s"' % realm
        else:
            assert False, 'Invalid type ' + str(typ)
            self.status_code = 403


class Http403(JSONErrorResponse, http.HttpResponseForbidden):
    """HTTP 403 FORBIDDEN"""
    pass


class Http404(JSONErrorResponse):
    """HTTP 404 Not Found"""
    status_code = 404


class Http409(JSONErrorResponse):
    """HTTP 409 Conflict"""
    status_code = 409


class Http500(JSONErrorResponse):
    """HTTP 500 Internal Server Error"""
    status_code = 500


class HttpError(Exception):
    """Exception that results in returning a JSONErrorResponse to the user."""

    def __init__(self, code, reason, **additional_data):
        super(HttpError, self).__init__(self, reason)
        self.response = JSONErrorResponse(reason, **additional_data)
        self.response.status_code = code

########NEW FILE########
__FILENAME__ = models
import six

from django.core import serializers
from django.db import models

from django.utils.encoding import force_text

__all__ = ['serialize', 'flatten']


def serialize_deprecated(src, fields=None, related=None):
    """Serialize Model or QuerySet to JSON format.

    By default, all of the model fields (including 'id') are serialized, and
    foreign key fields are serialized as the id of the referenced object.

    If 'fields' tuple/list is specified, only fields listed in it are
    serialized. If 'related' dict is specified, fields listed in it
    will be fully (recursively) serialized.

    Format of 'related' is:
        field_name -> (related_object_fields, related_object_related,
            flatten)
    As a shortcut, field_name -> None is equivalent to
        field_name -> (None, None, False)

    The values in 'related' specify 'fields' and 'related' arguments
    to be passed to the related object serialization. If 'flatten' is True,
    the items from the sub-dict will be added to the current dict instead of
    adding a single subdict under the 'field_name' key (useful for OneToOne
    relations, where a model basically just extends the base one).
    """

    # for m2m fields we'll get a Manager instead of a Model; deal with it
    # by just getting all the items

    if (isinstance(src, models.Manager) or
            isinstance(src, models.query.QuerySet)):
        return [serialize_deprecated(item, fields, related)
            for item in src.all()]

    if isinstance(src, list):
        return [serialize_deprecated(item, fields, related) for item in src]

    # we use the Django python serializer to serialize the model
    # and optionally recurse into related fields
    elif isinstance(src, models.Model):
        # serialize fields
        data = serializers.serialize('python', [src], fields=fields)
        data = data[0]['fields']
        if fields is None or 'id' in fields:
            data['id'] = src.id

        # recursively serialize full fields, if any
        if related:
            for k, v in related.items():
                if v is None:
                    v = (None, None, False)
                (sub_fields, sub_related, flatten) = v
                sub = serialize_deprecated(getattr(src, k), sub_fields,
                    sub_related)
                if flatten and sub:
                    for subk, subv in sub.items():
                        data[subk] = subv
                    if k in data:
                        del data[k]
                else:
                    data[k] = sub

        return data

    # just in case ordinary Python data sneaked past us, just return it
    else:
        return src


def serialize_model(obj, fields=None, include=None, exclude=None,
        fixup=None):

    fieldmap = {}
    for f in obj._meta.concrete_model._meta.local_fields:
        fieldmap[f.name] = f.attname

    def getfield(f):
        return getattr(obj, fieldmap.get(f, f))

    if fields is None:
        fields = list(fieldmap.keys())

    if exclude is not None:
        fields = [f for f in fields if f not in exclude]

    if include is not None:
        for i in include:
            if isinstance(i, tuple) or (isinstance(i, six.string_types)):
                fields.append(i)

    data = {}
    for f in fields:
        if isinstance(f, six.string_types):
            data[f] = force_text(getfield(f), strings_only=True)
        elif isinstance(f, tuple):
            k, v = f
            if callable(v):
                data[k] = v(obj)
            elif isinstance(v, dict):
                data[k] = serialize(getattr(obj, k), **v)

    if fixup:
        data = fixup(obj, data)

    return data


def serialize(src, fields=None, related=None, include=None, exclude=None,
        fixup=None):
    """Serialize Model or a QuerySet instance to Python primitives.

    By default, all the model fields (and only the model fields) are
    serialized. If the field is a Python primitive, it is serialized as such,
    otherwise it is converted to string in utf-8 encoding.

    If `fields` is specified, it is a list of attribute descriptions to be
    serialized, replacing the default (all model fields). If `include` is
    specified, it is a list of attribute descriptions to add to the default
    list. If `exclude` is specified, it is a list of attribute descriptions
    to remove from the default list.

    Each attribute description can be either:

      * a string - includes a correspondingly named attribute of the object
        being serialized (eg. `name`, or `created_at`); this can be a
        model field, a property, class variable or anything else that's
        an attribute on the instance

      * a tuple, where the first element is a string key and the second
        is a function taking one argument - function will be run with the
        object being serialized as the argument, and the function result will
        be included in the result, with the key being the first tuple element

      * a tuple, where the first element is a related model attribute name
        and the second is a dictionary - related model instance(s) will
        be serialized recursively and added as sub-object(s) to the object
        being serialized; the dictionary may specify `fields`, `include`,
        `exclude` and `fixup` options for the related models following the
        same semantics as for the object being serialized.

    The `fixup` argument, if defined, is a function taking two arguments, the
    object being serialized, and the serialization result dict, and returning
    the modified serialization result. It's useful in cases where it's
    neccessary to modify the result of the automatic serialization, but its
    use is discouraged if the same result can be obtained through the
    attribute descriptions.

    The `related` argument (a different way of specifying related
    objects to be serialized) is deprecated and included only for backwards
    compatibility.

    Example::

        serialize(obj, fields=[
            'name',   # obj.name
            'dob',    # obj.dob
            ('age', lambda obj: date.today() - obj.dob),
            ('jobs', dict(   # for job in obj.jobs.all()
                fields=[
                    'title',  # job.title
                    'from',   # job.from
                    'to',     # job.to,
                    ('duration', lambda job: job.to - job.from),
                ]
            ))
        ])

    Returns: a dict (if a single model instance was serialized) or a list
    od dicts (if a QuerySet was serialized) with the serialized data. The
    data returned is suitable for JSON serialization using Django's JSON
    serializator.
    """

    if related is not None:
        import warnings
        warnings.warn("'related' is deprecated syntax", DeprecationWarning)
        return serialize_deprecated(src, fields=fields, related=related)

    def subs(subsrc):
        return serialize(subsrc, fields=fields, include=include,
            exclude=exclude, fixup=fixup)

    if isinstance(src, models.Manager):
        return [subs(i) for i in src.all()]

    elif (isinstance(src, list) or
            isinstance(src, models.query.QuerySet) or
            isinstance(src, set)):
        return [subs(i) for i in src]

    elif isinstance(src, dict):
        return dict((k, subs(v)) for k, v in src.items())

    elif isinstance(src, models.Model):
        return serialize_model(src, fields=fields, include=include,
            exclude=exclude, fixup=fixup)

    else:
        return src


def flatten(attname):
    """Fixup helper for serialize.

    Given an attribute name, returns a fixup function suitable for serialize()
    that will pull all items from the sub-dict and into the main dict. If
    any of the keys from the sub-dict already exist in the main dict, they'll
    be overwritten.
    """

    def fixup(obj, data):
        for k, v in data[attname].items():
            data[k] = v
        del data[attname]
        return data
    return fixup

########NEW FILE########
__FILENAME__ = modelviews
from django.forms.models import modelform_factory

from .views import Endpoint
from .http import HttpError, Http200, Http201

from .models import serialize

__all__ = ['ListEndpoint', 'DetailEndpoint', 'ActionEndpoint']


def _get_form(form, model):
    if form:
        return form
    elif model:
        return modelform_factory(model)
    else:
        raise NotImplementedError('Form or Model class not specified')


class ListEndpoint(Endpoint):
    """
    List :py:class:`restless.views.Endpoint` supporting getting a list of
    objects and creating a new one. The endpoint exports two view methods by
    default: get (for getting the list of objects) and post (for creating a
    new object).

    The only required configuration for the endpoint is the `model`
    class attribute, which should be set to the model you want to have a list
    (and/or create) endpoints for.

    You can also provide a `form` class attribute, which should be the
    model form that's used for creating the model. If not provided, the
    default model class for the model will be created automatically.

    You can restrict the HTTP methods available by specifying the `methods`
    class variable.
    """

    model = None
    form = None
    methods = ['GET', 'POST']

    def get_query_set(self, request, *args, **kwargs):
        """Return a QuerySet that this endpoint represents.

        If `model` class attribute is set, this method returns the `all()`
        queryset for the model. You can override the method to provide custom
        behaviour. The `args` and `kwargs` parameters are passed in directly
        from the URL pattern match.

        If the method raises a :py:class:`restless.http.HttpError` exception,
        the rest of the request processing is terminated and the error is
        immediately returned to the client.
        """

        if self.model:
            return self.model.objects.all()
        else:
            raise HttpError(404, 'Resource Not Found')

    def serialize(self, objs):
        """Serialize the objects in the response.

        By default, the method uses the :py:func:`restless.models.serialize`
        function to serialize the objects with default behaviour. Override the
        method to customize the serialization.
        """

        return serialize(objs)

    def get(self, request, *args, **kwargs):
        """Return a serialized list of objects in this endpoint."""

        if 'GET' not in self.methods:
            raise HttpError(405, 'Method Not Allowed')

        qs = self.get_query_set(request, *args, **kwargs)
        return self.serialize(qs)

    def post(self, request, *args, **kwargs):
        """Create a new object."""

        if 'POST' not in self.methods:
            raise HttpError(405, 'Method Not Allowed')

        Form = _get_form(self.form, self.model)
        form = Form(request.data or None, request.FILES)
        if form.is_valid():
            obj = form.save()
            return Http201(self.serialize(obj))
            
        raise HttpError(400, 'Invalid Data', errors=form.errors)


class DetailEndpoint(Endpoint):
    """
    Detail :py:class:`restless.views.Endpoint` supports getting a single
    object from the database (HTTP GET), updating it (HTTP PUT) and deleting
    it (HTTP DELETE).

    The only required configuration for the endpoint is the `model`
    class attribute, which should be set to the model you want to have the
    detail endpoints for.

    You can also provide a `form` class attribute, which should be the
    model form that's used for updating the model. If not provided, the
    default model class for the model will be created automatically.

    You can restrict the HTTP methods available by specifying the `methods`
    class variable.

    """
    model = None
    form = None
    lookup_field = 'pk'
    methods = ['GET', 'PUT', 'DELETE']

    def get_instance(self, request, *args, **kwargs):
        """Return a model instance represented by this endpoint.

        If `model` is set and the primary key keyword argument is present,
        the method attempts to get the model with the primary key equal
        to the url argument.

        By default, the primary key keyword argument name is `pk`. This can
        be overridden by setting the `lookup_field` class attribute.

        You can override the method to provide custom behaviour. The `args`
        and `kwargs` parameters are passed in directly from the URL pattern
        match.

        If the method raises a :py:class:`restless.http.HttpError` exception,
        the rest of the request processing is terminated and the error is
        immediately returned to the client.
        """

        if self.model and self.lookup_field in kwargs:
            try:
                return self.model.objects.get(**{
                    self.lookup_field: kwargs.get(self.lookup_field)
                })
            except self.model.DoesNotExist:
                raise HttpError(404, 'Resource Not Found')
        else:
            raise HttpError(404, 'Resource Not Found')

    def serialize(self, obj):
        """Serialize the object in the response.

        By default, the method uses the :py:func:`restless.models.serialize`
        function to serialize the object with default behaviour. Override the
        method to customize the serialization.
        """

        return serialize(obj)

    def get(self, request, *args, **kwargs):
        """Return the serialized object represented by this endpoint."""

        if 'GET' not in self.methods:
            raise HttpError(405, 'Method Not Allowed')

        return self.serialize(self.get_instance(request, *args, **kwargs))

    def put(self, request, *args, **kwargs):
        """Update the object represented by this endpoint."""

        if 'PUT' not in self.methods:
            raise HttpError(405, 'Method Not Allowed')

        Form = _get_form(self.form, self.model)
        instance = self.get_instance(request, *args, **kwargs)
        form = Form(request.data or None, request.FILES,
            instance=instance)
        if form.is_valid():
            obj = form.save()
            return Http200(self.serialize(obj))
        raise HttpError(400, 'Invalid data', errors=form.errors)

    def delete(self, request, *args, **kwargs):
        """Delete the object represented by this endpoint."""

        if 'DELETE' not in self.methods:
            raise HttpError(405, 'Method Not Allowed')

        instance = self.get_instance(request, *args, **kwargs)
        instance.delete()
        return {}


class ActionEndpoint(DetailEndpoint):
    """
    A variant of :py:class:`DetailEndpoint` for supporting a RPC-style action
    on a resource. All the documentation for DetailEndpoint applies, but
    only the `POST` HTTP method is allowed by default, and it invokes the
    :py:meth:`ActionEndpoint.action` method to do the actual work.

    If you want to support any of the other HTTP methods with their default
    behaviour as in DetailEndpoint, just modify the `methods` list to
    include the methods you need.

    """
    methods = ['POST']

    def post(self, request, *args, **kwargs):
        if 'POST' not in self.methods:
            raise HttpError(405, 'Method Not Allowed')

        instance = self.get_instance(request, *args, **kwargs)
        return self.action(request, instance, *args, **kwargs)

    def action(self, request, obj, *args, **kwargs):
        raise HttpError(405, 'Method Not Allowed')

########NEW FILE########
__FILENAME__ = views
from django.views.generic import View
from django.utils.decorators import method_decorator
from django.views.decorators.csrf import csrf_exempt

from django.conf import settings
from django.http import HttpResponse
from .http import Http200, Http500, HttpError

import traceback
import json

__all__ = ['Endpoint']


class Endpoint(View):
    """
    Class-based Django view that should be extended to provide an API
    endpoint (resource). To provide GET, POST, PUT, HEAD or DELETE methods,
    implement the corresponding get(), post(), put(), head() or delete()
    method, respectively.

    If you also implement authenticate(request) method, it will be called
    before the main method to provide authentication, if needed. Auth mixins
    use this to provide authentication.

    The usual Django "request" object passed to methods is extended with a
    few more attributes:

      * request.content_type - the content type of the request
      * request.params - a dictionary with GET parameters
      * request.data - a dictionary with POST/PUT parameters, as parsed from
          either form submission or submitted application/json data payload
      * request.raw_data - string containing raw request body

    The view method should return either a HTTPResponse (for example, a
    redirect), or something else (usually a dictionary or a list). If something
    other than HTTPResponse is returned, it is first serialized into
    :py:class:`restless.http.JSONResponse` with a status code 200 (OK),
    then returned.

    The authenticate method should return either a HttpResponse, which will
    shortcut the rest of the request handling (the view method will not be
    called), or None (the request will be processed normally).

    Both methods can raise a :py:class:`restless.http.HttpError` exception
    instead of returning a HttpResponse, to shortcut the request handling and
    immediately return the error to the client.
    """

    @staticmethod
    def _parse_content_type(content_type):
        if ';' in content_type:
            ct, params = content_type.split(';', 1)
            try:
                params = dict(param.split('=') for param in params.split())
            except:
                params = {}
        else:
            ct = content_type
            params = {}
        return ct, params

    def _parse_body(self, request):
        if request.method not in ['POST', 'PUT', 'PATCH']:
            return

        ct, ct_params = self._parse_content_type(request.content_type)
        if ct == 'application/json':
            charset = ct_params.get('charset', 'utf-8')
            try:
                data = request.body.decode(charset)
                request.data = json.loads(data)
            except Exception as ex:
                raise HttpError(400, 'invalid JSON payload: %s' % ex)
        elif ((ct == 'application/x-www-form-urlencoded') or
                (ct.startswith('multipart/form-data'))):
            request.data = dict((k, v) for (k, v) in request.POST.items())
        else:
            request.data = request.body

    def _process_authenticate(self, request):
        if hasattr(self, 'authenticate') and callable(self.authenticate):
            auth_response = self.authenticate(request)

            if isinstance(auth_response, HttpResponse):
                return auth_response
            elif auth_response is None:
                pass
            else:
                raise TypeError('authenticate method must return '
                    'HttpResponse instance or None')

    @method_decorator(csrf_exempt)
    def dispatch(self, request, *args, **kwargs):
        request.content_type = request.META.get('CONTENT_TYPE', 'text/plain')
        request.params = dict((k, v) for (k, v) in request.GET.items())
        request.data = None
        request.raw_data = request.body

        try:
            self._parse_body(request)
            authentication_required = self._process_authenticate(request)
            if authentication_required:
                return authentication_required

            response = super(Endpoint, self).dispatch(request, *args, **kwargs)
        except HttpError as err:
            response = err.response
        except Exception as ex:
            if settings.DEBUG:
                response = Http500(str(ex), traceback=traceback.format_exc())
            else:
                raise

        if not isinstance(response, HttpResponse):
            response = Http200(response)
        return response

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
import os
import sys

if __name__ == "__main__":
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "testproject.settings")

    from django.core.management import execute_from_command_line

    execute_from_command_line(sys.argv)

########NEW FILE########
__FILENAME__ = forms
from django import forms

from .models import *

__all__ = ['AuthorForm']


class AuthorForm(forms.ModelForm):
    class Meta:
        model = Author

########NEW FILE########
__FILENAME__ = models
from django.db import models

__all__ = ['Author', 'Book', 'Publisher']


class Publisher(models.Model):
    name = models.CharField(max_length=255)


class Author(models.Model):
    name = models.CharField(max_length=255)


class Book(models.Model):
    author = models.ForeignKey(Author, related_name='books')
    publisher = models.ForeignKey(Publisher, related_name='publisher')
    title = models.CharField(max_length=255)
    isbn = models.CharField(max_length=64, unique=True)
    price = models.DecimalField(max_digits=20, decimal_places=2)

########NEW FILE########
__FILENAME__ = tests
from django.test import TestCase
from django.test.client import Client, MULTIPART_CONTENT
from django.core.urlresolvers import reverse
from django.contrib.auth.models import User
import json
from decimal import Decimal
import base64
import warnings
import six

from .models import *
from restless.models import serialize, flatten

try:
    from urllib.parse import urlencode
except ImportError:
    from urllib import urlencode


class TestClient(Client):

    @staticmethod
    def process(response):
        try:
            raw_data = response.content.decode('utf-8')
            response.json = json.loads(response.content.decode('utf-8'))
        except:
            response.json = None
        finally:
            return response

    def get(self, url_name, data={}, follow=False, extra={}, *args, **kwargs):
        return self.process(
            super(TestClient, self).get(
                reverse(url_name, args=args, kwargs=kwargs),
                data=data,
                follow=follow,
                **extra))

    def post(self, url_name, data={}, content_type=MULTIPART_CONTENT,
            follow=False, extra={}, *args, **kwargs):
        return self.process(
            super(TestClient, self).post(
                reverse(url_name, args=args, kwargs=kwargs),
                content_type=content_type,
                data=data,
                follow=follow,
                **extra))

    def put(self, url_name, data={}, content_type=MULTIPART_CONTENT,
            follow=False, *args, **kwargs):
        return self.process(
            super(TestClient, self).put(
                reverse(url_name, args=args, kwargs=kwargs),
                content_type=content_type, data=data, follow=follow))

    def delete(self, url_name, data={}, content_type=MULTIPART_CONTENT,
            follow=False, *args, **kwargs):
        return self.process(
            super(TestClient, self).delete(
                reverse(url_name, args=args, kwargs=kwargs),
                content_type=content_type, data=data, follow=follow))


class TestSerialization(TestCase):

    def setUp(self):
        self.author = Author.objects.create(name='User Foo')
        self.publisher = Publisher.objects.create(name='Publisher')
        self.books = []
        for i in range(10):
            b = self.author.books.create(author=self.author,
                title='Book %d' % i,
                isbn='123-1-12-123456-%d' % i,
                price=Decimal("10.0"),
                publisher=self.publisher)
            self.books.append(b)

    def test_full_shallow(self):
        """Test simple serialization, all fields, without recursing"""

        s = serialize(self.author)
        self.assertEqual(s, {'name': 'User Foo', 'id': self.author.id})

    def test_partial_shallow(self):
        """Test serialization of only selected fields"""

        s = serialize(self.author, ['name'])
        self.assertEqual(s, {'name': 'User Foo'})

    def test_shallow_foreign_key_serialization(self):
        """Test that foreign key fields are serialized as integer IDs."""

        s = serialize(self.books[0])
        self.assertEqual(s['author'], self.author.id)

    def test_serialize_related_deprecated(self):
        """Test serialization of related model"""

        with warnings.catch_warnings(record=True):
            s = serialize(self.author, related={'books': None})
        self.assertEqual(s['name'], 'User Foo')
        self.assertEqual(len(s['books']), len(self.books))
        for b in s['books']:
            self.assertTrue(b['title'].startswith('Book '))
            self.assertTrue(b['isbn'].startswith('123-1-12-123456-'))

    def test_serialize_related(self):
        """Test serialization of related model"""

        s = serialize(self.author, include=[('books', dict())])
        self.assertEqual(s['name'], 'User Foo')
        self.assertEqual(len(s['books']), len(self.books))
        for b in s['books']:
            self.assertTrue(b['title'].startswith('Book '))
            self.assertTrue(b['isbn'].startswith('123-1-12-123456-'))

    def test_serialize_related_partial_deprecated(self):
        """Test serialization of some fields of related model"""

        with warnings.catch_warnings(record=True):
            s = serialize(self.author, related={
                'books': ('title', None, False)
            })
        self.assertEqual(s['name'], 'User Foo')
        self.assertEqual(len(s['books']), len(self.books))
        for b in s['books']:
            self.assertTrue(b['title'].startswith('Book '))
            self.assertTrue('isbn' not in b)

    def test_serialize_related_partial(self):
        """Test serialization of some fields of related model"""

        s = serialize(self.author, include=[
            ('books', dict(
                fields=['title']
            ))
        ])
        self.assertEqual(s['name'], 'User Foo')
        self.assertEqual(len(s['books']), len(self.books))
        for b in s['books']:
            self.assertTrue(b['title'].startswith('Book '))
            self.assertTrue('isbn' not in b)

    def test_serialize_related_deep_deprecated(self):
        """Test serialization of twice-removed related model"""

        with warnings.catch_warnings(record=True):
            s = serialize(self.author, related={
                'books': (None, {
                    'publisher': None,
                }, None)})

        self.assertEqual(s['name'], 'User Foo')
        self.assertEqual(len(s['books']), len(self.books))
        for b in s['books']:
            self.assertTrue(b['title'].startswith('Book '))
            self.assertEqual(b['publisher']['name'], 'Publisher')

    def test_serialize_related_deep(self):
        """Test serialization of twice-removed related model"""

        s = serialize(self.author, include=[
            ('books', dict(
                include=[('publisher', dict())]
            ))
        ])

        self.assertEqual(s['name'], 'User Foo')
        self.assertEqual(len(s['books']), len(self.books))
        for b in s['books']:
            self.assertTrue(b['title'].startswith('Book '))
            self.assertEqual(b['publisher']['name'], 'Publisher')

    def test_serialize_related_flatten_deprecated(self):
        """Test injection of related models' fields into the serialized one"""

        b = self.books[0]
        s = serialize(b, related={
            'author': (None, None, True)
        })
        self.assertEqual(s['name'], b.author.name)

    def test_serialize_related_flatten(self):
        """Test injection of related models' fields into the serialized one"""

        b = self.books[0]
        s = serialize(b, fields=[
            ('author', dict())
        ], fixup=flatten('author'))

        self.assertEqual(s['name'], b.author.name)

    def test_serialize_queryset(self):
        """Test queryset serialization"""

        Author.objects.all().delete()
        a1 = Author.objects.create(name="foo")
        a2 = Author.objects.create(name="bar")
        qs = Author.objects.all()
        _ = list(qs)  # force sql query execution

        # Check that the same (cached) queryset is used, instead of a clone
        with self.assertNumQueries(0):
            s = serialize(qs)

        self.assertEqual(s,
            [
                {'name': a1.name, 'id': a1.id},
                {'name': a2.name, 'id': a2.id},
            ]
        )

    def test_serialize_list(self):
        """Test that list serialization deep-serializes list elements"""

        Author.objects.all().delete()
        a1 = Author.objects.create(name="foo")
        a2 = Author.objects.create(name="bar")
        s = serialize(list(Author.objects.all()))
        self.assertEqual(s,
            [
                {'name': a1.name, 'id': a1.id},
                {'name': a2.name, 'id': a2.id},
            ]
        )

    def test_serialize_dict(self):
        """Test that dict serialization deep-serializes dict values"""

        Author.objects.all().delete()
        a1 = Author.objects.create(name="foo")
        a2 = Author.objects.create(name="bar")
        s = serialize({'a1': a1, 'a2': a2})

        self.assertEqual(s['a1']['name'], a1.name)
        self.assertEqual(s['a2']['name'], a2.name)

    def test_serialize_set(self):
        """
        Test that set serialization deep-serializes set values and
        returns a list (since sets can't contain a dict and aren't JSON
        serializable).
        """

        Author.objects.all().delete()
        a1 = Author.objects.create(name="bar")
        a2 = Author.objects.create(name="foo")
        s = serialize(set(Author.objects.all()))
        self.assertTrue(isinstance(s, list))
        # Must cast back to set to ignore ordering
        self.assertEqual(sorted(s, key=lambda el: el['name']),
            [
                {'name': a1.name, 'id': a1.id},
                {'name': a2.name, 'id': a2.id},
            ]
        )


    def test_passthrough(self):
        """Test that non-ORM types just pass through the serializer"""

        data = {'a': ['b', 'c'], 'd': 1, 'e': "foo"}
        self.assertEqual(data, serialize(data))


class TestEndpoint(TestCase):

    def setUp(self):
        self.client = TestClient()
        self.author = Author.objects.create(name='User Foo')

    def test_author_list(self):
        """Exercise a simple GET request"""

        r = self.client.get('author_list')
        self.assertEqual(r.status_code, 200)
        self.assertEqual(len(r.json), 1)
        self.assertEqual(r.json[0]['id'], self.author.id)

    def test_author_details(self):
        """Exercise passing parameters to GET request"""

        r = self.client.get('author_detail', author_id=self.author.id)
        self.assertEqual(r.status_code, 200)
        self.assertEqual(r.json['id'], self.author.id)
        self.assertEqual(r.json['name'], 'User Foo')

    def test_author_details_not_found(self):
        """Exercise returning arbitrary HTTP status codes from view"""

        r = self.client.get('author_detail', author_id=self.author.id + 9999)
        self.assertEqual(r.status_code, 404)

    def test_author_details_invalid_method(self):
        """Exercise 405 if POST request doesn't pass form validation"""
        r = self.client.post('author_detail', author_id=self.author.id)
        self.assertEqual(r.status_code, 405)

    def test_create_author_form_encoded(self):
        """Exercise application/x-www-form-urlencoded POST"""

        r = self.client.post('author_list', data=urlencode({
            'name': 'New User',
        }), content_type='application/x-www-form-urlencoded')
        self.assertEqual(r.status_code, 201)
        self.assertEqual(r.json['name'], 'New User')
        self.assertEqual(r.json['name'],
            Author.objects.get(id=r.json['id']).name)

    def test_create_author_multipart(self):
        """Exercise multipart/form-data POST"""

        r = self.client.post('author_list', data={
            'name': 'New User',
        })  # multipart/form-data is default in test client
        self.assertEqual(r.status_code, 201)
        self.assertEqual(r.json['name'], 'New User')
        self.assertEqual(r.json['name'],
            Author.objects.get(id=r.json['id']).name)

    def test_create_author_json(self):
        """Exercise application/json POST"""

        r = self.client.post('author_list', data=json.dumps({
            'name': 'New User',
        }), content_type='application/json; charset=utf-8')
        self.assertEqual(r.status_code, 201)
        self.assertEqual(r.json['name'], 'New User')
        self.assertEqual(r.json['name'],
            Author.objects.get(id=r.json['id']).name)

    def test_invalid_json_payload(self):
        """Exercise invalid JSON handling"""

        r = self.client.post('author_list', data='xyz',
            content_type='application/json')
        self.assertEqual(r.status_code, 400)

    def test_delete_author(self):
        """Exercise DELETE request"""

        r = self.client.delete('author_detail', author_id=self.author.id)
        self.assertEqual(r.status_code, 200)
        self.assertEqual(Author.objects.count(), 0)

    def test_change_author(self):
        """Exercise PUT request"""

        r = self.client.put('author_detail', data=json.dumps({
            'name': 'User Bar'
        }), author_id=self.author.id, content_type='application/json')
        self.assertEqual(r.status_code, 200)
        self.assertEqual(r.json['name'], 'User Bar')
        self.assertEqual(r.json['name'],
            Author.objects.get(id=r.json['id']).name)

    def test_view_failure(self):
        """Exercise exception handling"""

        with self.settings(DEBUG=True):
            r = self.client.get('fail_view')

        self.assertEqual(r.status_code, 500)
        self.assertEqual(r.json['error'], "I'm being a bad view")
        self.assertTrue('traceback' in r.json)

    def test_raw_request_body(self):
        raw = b'\x01\x02\x03'
        r = self.client.post('echo_view', data=raw,
            content_type='text/plain')

        self.assertEqual(base64.b64decode(r.json['raw_data'].encode('ascii')),
            raw)

    def test_get_payload_is_ignored(self):
        """Test that body of the GET request is always ignored."""
        r = self.client.get('echo_view', extra={
            'CONTENT_TYPE': 'application/json'})
        # If the GET request body is not ignored, it (empty string) will be an
        # invalid JSON and will return 400 instead of 200.
        self.assertEqual(r.status_code, 200)

    def test_raising_http_error_returns_it(self):
        r = self.client.get('error_raising_view')
        self.assertEqual(r.status_code, 400)


class TestAuth(TestCase):

    def setUp(self):
        self.client = TestClient()
        self.user = User.objects.create_user(username='foo', password='bar')

    def test_login_success(self):
        """Test that correct username/password login succeeds"""

        r = self.client.get('login_view', data={
            'username': 'foo', 'password': 'bar',
        })
        self.assertEqual(r.status_code, 200)

    def test_login_failure(self):
        """Test that incorrect username/password login fails"""

        r = self.client.get('login_view', data={
            'username': 'nonexistent', 'password': 'pwd',
        })
        self.assertEqual(r.status_code, 403)

    def test_basic_auth_challenge(self):
        """Test that HTTP Basic Auth challenge is issued"""
        r = self.client.get('basic_auth_view')
        self.assertEqual(r.status_code, 401)

    def test_basic_auth_succeeds(self):
        """Test that HTTP Basic Auth succeeds"""

        r = self.client.get('basic_auth_view', extra={
            'HTTP_AUTHORIZATION': 'Basic ' +
                base64.b64encode(b'foo:bar').decode('ascii'),
        })
        self.assertEqual(r.status_code, 200)
        self.assertEqual(r.json['id'], self.user.id)

    def test_basic_auth_invalid_auth_payload(self):
        """Test that invalid Basic Auth payload doesn't crash the pasrser"""

        r = self.client.get('basic_auth_view', extra={
            'HTTP_AUTHORIZATION': 'Basic xyz',
        })
        self.assertEqual(r.status_code, 401)

    def test_custom_auth_fn_returning_none_allows_request(self):
        r = self.client.get('custom_auth_method', data={'user': 'friend'})
        self.assertEqual(r.status_code, 200)

    def test_custom_auth_fn_returning_httpresponse_shortcuts_request(self):
        r = self.client.get('custom_auth_method', data={'user': 'foe'})
        self.assertEqual(r.status_code, 403)

    def test_custom_auth_fn_raising_exception_shortcuts_request(self):
        r = self.client.get('custom_auth_method',
            data={'user': 'exceptional-foe'})
        self.assertEqual(r.status_code, 403)

    def test_custom_auth_fn_with_invalid_return_value_is_a_bug(self):
        ex = None
        try:
            self.client.get('custom_auth_method')
        except TypeError as e:
            ex = e

        self.assertIsNotNone(ex)


class TestModelViews(TestCase):

    def setUp(self):
        self.client = TestClient()
        self.publisher = Publisher.objects.create(name='User Foo')
        self.author = Author.objects.create(name='User Foo')
        self.book = self.author.books.create(author=self.author, title='Book',
            isbn='1234',  price=Decimal('10.0'), publisher=self.publisher)

    def test_publisher_list(self):
        """Excercise listing objects via ListEndpoint"""

        r = self.client.get('publisher_list')
        self.assertEqual(r.status_code, 200)
        self.assertEqual(len(r.json), 1)
        self.assertEqual(r.json[0]['id'], self.publisher.id)

    def test_publisher_create(self):
        """Excercise creating objects via ListEndpoint"""

        r = self.client.post('publisher_list', data=json.dumps({
            'name': 'Another Publisher'
            }), content_type='application/json')
        self.assertEqual(r.status_code, 201)
        self.assertTrue(Publisher.objects.filter(pk=r.json['id']).exists())

    def test_publisher_details(self):
        """Excercise getting a single object details via DetailEndpoint"""

        r = self.client.get('publisher_detail', pk=self.publisher.id)
        self.assertEqual(r.status_code, 200)
        self.assertEqual(r.json['id'], self.publisher.id)

    def test_publisher_update(self):
        """Excercise updating an object via POST via DetailEndpoint"""

        r = self.client.put('publisher_detail', pk=self.publisher.id,
            content_type='application/json', data=json.dumps({
                'name': 'Changed Name'
            }))
        self.assertEqual(r.status_code, 200)
        self.assertEqual(r.json['id'], self.publisher.id)
        p = Publisher.objects.get(id=self.publisher.id)
        self.assertEqual(p.name, 'Changed Name')

    def test_publisher_delete(self):
        """Excercise deleting an object via DetailEndpoint"""

        r = self.client.delete('publisher_detail', pk=self.publisher.id)
        self.assertEqual(r.status_code, 200)
        self.assertFalse(Publisher.objects.exists())

    def test_redonly_publisher_list_denies_creation(self):
        """Excercise method whitelist in ListEndpoint"""

        r = self.client.post('readonly_publisher_list', data=json.dumps({
            'name': 'Another Publisher'
            }), content_type='application/json')
        self.assertEqual(r.status_code, 405)

    def test_publisher_action(self):
        """Excercise RPC-style actions via ActionEndpoint"""

        r = self.client.post('publisher_action', pk=self.publisher.id,
            content_type='application/json')
        self.assertEqual(r.status_code, 200)
        self.assertEqual(r.json, {'result': 'done'})

    def test_book_details(self):
        """Excercise using custom lookup_field on a DetailEndpoint"""

        r = self.client.get('book_detail', isbn=self.book.isbn)
        self.assertEqual(r.status_code, 200)
        self.assertEqual(r.json['id'], self.book.id)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url

from .views import *

urlpatterns = patterns('',
    url(r'^authors/$', AuthorList.as_view(),
        name='author_list'),
    url(r'^authors/(?P<author_id>\d+)$', AuthorDetail.as_view(),
        name='author_detail'),

    url(r'^fail-view/$', FailsIntentionally.as_view(),
        name='fail_view'),
    url(r'^login-view/$', TestLogin.as_view(),
        name='login_view'),
    url(r'^basic-auth-view/$', TestBasicAuth.as_view(),
        name='basic_auth_view'),
    url(r'^custom-auth/$', TestCustomAuthMethod.as_view(),
        name='custom_auth_method'),
    url(r'^echo-view/$', EchoView.as_view(),
        name='echo_view'),
    url(r'^error-raising-view/$', ErrorRaisingView.as_view(),
        name='error_raising_view'),

    url(r'^publishers/$', PublisherAutoList.as_view(),
        name='publisher_list'),
    url(r'^publishers-ready-only/$', ReadOnlyPublisherAutoList.as_view(),
        name='readonly_publisher_list'),
    url(r'^publishers/(?P<pk>\d+)$', PublisherAutoDetail.as_view(),
        name='publisher_detail'),
    url(r'^publishers/(?P<pk>\d+)/do_something$', PublisherAction.as_view(),
        name='publisher_action'),

    url(r'^books/(?P<isbn>\d+)$', BookDetail.as_view(),
        name='book_detail'),

    url(r'^.*$', WildcardHandler.as_view()),
)

########NEW FILE########
__FILENAME__ = views
import base64

from restless.views import Endpoint
from restless.models import serialize
from restless.http import Http201, Http403, Http404, Http400, HttpError
from restless.auth import (AuthenticateEndpoint, BasicHttpAuthMixin,
    login_required)

from restless.modelviews import ListEndpoint, DetailEndpoint, ActionEndpoint

from .models import *
from .forms import *

__all__ = ['AuthorList', 'AuthorDetail', 'FailsIntentionally', 'TestLogin',
    'TestBasicAuth', 'WildcardHandler', 'EchoView', 'ErrorRaisingView',
    'PublisherAutoList', 'PublisherAutoDetail', 'ReadOnlyPublisherAutoList',
    'PublisherAction', 'BookDetail', 'TestCustomAuthMethod']


class AuthorList(Endpoint):
    def get(self, request):
        return serialize(Author.objects.all())

    def post(self, request):
        form = AuthorForm(request.data)
        if form.is_valid():
            author = form.save()
            return Http201(serialize(author))
        else:
            return Http400(reason='invalid author data',
                details=form.errors)


class AuthorDetail(Endpoint):
    def get(self, request, author_id=None):
        author_id = int(author_id)
        try:
            return serialize(Author.objects.get(id=author_id))
        except Author.DoesNotExist:
            return Http404(reason='no such author')

    def delete(self, request, author_id=None):
        author_id = int(author_id)
        Author.objects.get(id=author_id).delete()
        return 'ok'

    def put(self, request, author_id=None):
        author_id = int(author_id)
        try:
            author = Author.objects.get(id=author_id)
        except Author.DoesNotExist:
            return Http404(reason='no such author')

        form = AuthorForm(request.data, instance=author)
        if form.is_valid():
            author = form.save()
            return serialize(author)
        else:
            return Http400(reason='invalid author data',
                details=form.errors)


class FailsIntentionally(Endpoint):
    def get(self, request):
        raise Exception("I'm being a bad view")


class TestLogin(AuthenticateEndpoint):
    pass


class TestBasicAuth(Endpoint, BasicHttpAuthMixin):
    @login_required
    def get(self, request):
        return serialize(request.user)


class TestCustomAuthMethod(Endpoint):
    def authenticate(self, request):
        user = request.params.get('user')
        if user == 'friend':
            return None
        elif user == 'foe':
            return Http403('you shall not pass')
        elif user == 'exceptional-foe':
            raise HttpError(403, 'with exception')
        else:
            # this is an illegal return value for this function
            return 42

    def get(self, request):
        return 'OK'


class WildcardHandler(Endpoint):
    def dispatch(self, request, *args, **kwargs):
        return Http404('no such resource: %s %s' % (
            request.method, request.path))


class EchoView(Endpoint):
    def post(self, request):
        return {
            'headers': dict((k, str(v)) for k, v in request.META.items()),
            'raw_data': base64.b64encode(request.raw_data).decode('ascii')
        }

    def get(self, request):
        return self.post(request)

    def put(self, request):
        return self.post(request)


class ErrorRaisingView(Endpoint):
    def get(self, request):
        raise HttpError(400, 'raised error', extra_data='foo')


class PublisherAutoList(ListEndpoint):
    model = Publisher


class PublisherAutoDetail(DetailEndpoint):
    model = Publisher


class ReadOnlyPublisherAutoList(ListEndpoint):
    model = Publisher
    methods = ['GET']


class PublisherAction(ActionEndpoint):
    model = Publisher

    def action(self, obj, *args, **kwargs):
        return {'result': 'done'}


class BookDetail(DetailEndpoint):
    model = Book
    lookup_field = 'isbn'

########NEW FILE########
__FILENAME__ = settings

import os.path
import sys

ROOT_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
sys.path.insert(0, os.path.abspath(os.path.join(ROOT_DIR, '..')))

DEBUG = False
TEMPLATE_DEBUG = DEBUG

ADMINS = ()
MANAGERS = ADMINS

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': ':memory:',
    }
}

# TIME_ZONE = 'America/Chicago'
# LANGUAGE_CODE = 'en-us'
# SITE_ID = 1
USE_I18N = False
USE_L10N = False
USE_TZ = False
MEDIA_ROOT = ''
MEDIA_URL = os.path.join(ROOT_DIR, 'media') + '/'
STATIC_ROOT = os.path.join(ROOT_DIR, 'static')
STATIC_URL = '/static/'
STATICFILES_DIRS = ()
STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
)

SECRET_KEY = 'el_19c6=)u!re!6sg-&amp;5gm&amp;yb14@t=e!e+7r=th6x12d29(rsz'
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
)

ROOT_URLCONF = 'testproject.urls'
WSGI_APPLICATION = 'testproject.wsgi.application'

TEMPLATE_DIRS = ()

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'restless',
    'testapp',
)

AUTH_PROFILE_MODULE = 'testapp.Author'

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'filters': {
        'require_debug_false': {
            '()': 'django.utils.log.RequireDebugFalse'
        }
    },
    'handlers': {
        'mail_admins': {
            'level': 'ERROR',
            'filters': ['require_debug_false'],
            'class': 'django.utils.log.AdminEmailHandler'
        }
    },
    'loggers': {
        'django.request': {
            'handlers': ['mail_admins'],
            'level': 'ERROR',
            'propagate': True,
        },
    }
}

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, include, url
import testapp.urls

urlpatterns = patterns('',
    url('', include(testapp.urls)),
)

########NEW FILE########
__FILENAME__ = wsgi
"""
WSGI config for testproject project.

This module contains the WSGI application used by Django's development server
and any production WSGI deployments. It should expose a module-level variable
named ``application``. Django's ``runserver`` and ``runfcgi`` commands discover
this application via the ``WSGI_APPLICATION`` setting.

Usually you will have the standard Django WSGI application here, but it also
might make sense to replace the whole Django WSGI application with a custom one
that later delegates to the Django one. For example, you could introduce WSGI
middleware here, or combine a Django application with an application of another
framework.

"""
import os

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "testproject.settings")

# This application object is used by any WSGI server configured to use this
# file. This includes Django's development server, if the WSGI_APPLICATION
# setting points here.
from django.core.wsgi import get_wsgi_application
application = get_wsgi_application()

# Apply WSGI middleware here.
# from helloworld.wsgi import HelloWorldApplication
# application = HelloWorldApplication(application)

########NEW FILE########
