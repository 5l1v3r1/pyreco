---
layout: default
title: DocJSON
---

DocJSON is a simple document format for building Hypermedia Web APIs.

A DocJSON document consists of standard JSON, with the addition of a set of hypermedia controls that are used to express the actions that may be taken.  DocJSON is a flexible document format and does not impose any structural restrictions either on the data representation style, or on the layout of hypermedia controls used within the document.

**Warning:** *The DocJSON specification is currently in draft, and is subject to change at any time.*

---

## Specification

A document may be any valid JSON, with the single restriction that the object key `"_type"` is reserved. An JSON object which contains a key named `"_type"` is considered a control object.

Any URLs within a document may be either relative or absolute.  Relative URLs should be resolved with respect to the original document URL.

The following control objects are currently supported:

### Link

A DocJSON link is a control element that represents a hyperlink that may be followed by the client.

* A link is any JSON object containing the `"_type"` key with a value of `"link"`.
* A link must have a key named `href`, which must contain a URL.

#### Example

{% highlight json %}
    {
        "_type": "link",
        "href": "http://todo.example.com/?completed=True"
    }
{% endhighlight %}

### Form

A DocJSON form is a control element that enables arbitrary actions to be taken by the client.  Forms specify the URL and HTTP method that should be used for the action, as well as the details of any parameters that should be included in the request.

* A link is any JSON object containing the `"_type"` key with a value of `"form"`.
* A form must have a key named `href`, which must contain a URL.
* A form must have a key named `method`, which must contain a valid HTTP method name.
* A form may have a key named `fields`.  If present, it must contain a list of objects.
* Any fields in the list must contain a key named `name`, which must contain a string.
* Any fields in the list may contain a key named `required`, which must contain a boolean.  If not present, the field should be treated as `"required": false`.
 
#### Example

{% highlight json %}
    {
        "_type": "form",
        "href": "http://todo.example.com/create_todo/",
        "method": "POST",
        "fields": [
            {"name": "text", "required": true},
            {"name": "completed"}
        ]
    }
{% endhighlight %}

### List

A DocJSON list is a paginated list of data.  The contents of the list may be any type of object, but the server does not have to populate the entire list, and can use pagination to serve further objects to the client on request.

* A link is any JSON object containing the `"_type"` key with a value of `"list"`.
* A list must have a key named `items`, which must contain a list.
* A list should have a key named `next`, which must contain URL, or `null`.
* The target of the `next` link should be a URL that returns a DocJSON List document.

#### Example

{% highlight json %}
    {
        "_type": "list",
        "items": [
            ...
        ]
        "next": "http://todo.example.com/items/?page=2"
    }
{% endhighlight %}

---

## Why another Hypermedia format?

None of the existing hypermedia formats meet the particular design goals of DocJSON.

* Collection+JSON presents a full range of hypermedia controls, but is specfic to representing list-like data structures.
* HAL presents link controls, but lacks other hypermedia controls.
* JSON API is specfic to data syncing between client and server, and does not present general purpose hypermedia controls.
* HTML is sometimes used or proposed for Hypermedia APIs, and offers hypermedia controls, but is a poor fit for data representations.

DocJSON is designed with the aim of making developers lives easier, by introducing a flexible data format with a sufficienty complete set of hypermedia controls.  By doing so we enable generic client libraries to be used to interact with DocJSON APIs, rather than rebuilding client libraries from scratch with each new API service.

---

## Example

The following is an example of a DocJSON document representing a simple ToDo API.

{% highlight json %}
    {
        "tabs": {
            "all": {"_type": "link", "href": "/"},
            "active": {"_type": "link", "href": "/?completed=False"},
            "completed": {"_type": "link", "href": "/?completed=True"}
        }
        "search": {
            "_type": "form",
            "method": "GET",
            "href": "/",
            "fields": [
                {"name": "text", "required": true}
            ]
        }
        "add_todo": {
            "_type": "form",
            "method": "POST",
            "href": "/",
            "fields": [
                {"name": "title", "required": true}
            ]
        }
        "items": {
            "_type": "list",
            "items": [
                {
                    "delete": {
                        "_type": "form",
                        "method": "DELETE",
                        "href": "/467/"
                    },
                    "edit": {
                        "_type": "form",
                        "method": "PUT",
                        "href": "/467/",
                        "fields": [{"name": "text"}, {"name": "completed"}]
                    },
                    "text": "Call mum",
                    "completed": false,
                    "created": "2013-10-16T19:20:30+01:00"
                },
                {
                    "delete": {
                        "_type": "form",
                        "method": "DELETE",
                        "href": "/466/"
                    },
                    "edit": {
                        "_type": "form",
                        "method": "PUT",
                        "href": "/466/",
                        "fields": [{"name": "text"}, {"name": "completed"}]
                    },
                    "text": "Fix the garage lock",
                    "completed": true,
                    "created": "2013-09-14T10:17:30+01:00"
                },
                ...
            ]
            "next": "/?page=2"
        }
{% endhighlight %}

The document presents the API client with the following controls:

* A set of tabs for switching between all notes, and complete or incomplete notes only.
* A search control for displaying notes that match a search string.
* A control for creating new todo notes.
* A paginated list of notes.
* Edit and delete controls for each note.

---

## Using a DocJSON client

Let's take a look at using a client library for DocJSON, to see what it can do.  There's currently a Python implementation.  Other languages are planned.

Create and activate a new virtual environment, install `docjson`, and start python. 

{% highlight python %}
    bash: virtualenv env
    bash: source env/bin/activate
    bash: pip install docjson
    bash: python
    >>> doc = docjson.get('http://docjson.heroku.com')
    >>> print doc.notes
    [
        {
            'text': 'Call mum',
            'completed': False,
            'delete': form(),
            'edit': form([text], [completed])
        },
        {
            'text': 'Fix the garage lock',
            'completed': False,
            'delete': form(),
            'edit': form([text], [completed])
        },
        ...
    ]
{% endhighlight %}

#### Pagination


The first thing to notice here is the ellipsis at the end of our notes list.  That indicates that there are more items in the paginated list that havn't yet been fetched.

If we iterate over the list or fetch an index that we don't yet have then the required pages will automatically be fetched for us.

{% highlight python %}
    >>> print doc.notes[6]
    {
        'text': 'File tax return',
        'completed': True,
        'delete': form(),
        'edit': form([text], [completed])
    }
{% endhighlight %}

#### Using forms

We can also add new notes...

{% highlight python %}
    >>> for idx in range(3):
    >>>     doc = doc.add_note(text='New note #%d' % idx)
{% endhighlight %}

Or edit an existing note...

{% highlight python %}
    >>> doc = doc.notes[2].edit(completed=True)
{% endhighlight %}

{% highlight python %}
    >>> doc = doc.notes[0].delete()
{% endhighlight %}

If we attempt to use a form with incorrect parameters, the client library will alert us.

{% highlight python %}
    >>> doc = doc.add_note()
    SDFSDFSSDGSDFE
{% endhighlight %}

{% highlight python %}
    >>> doc = doc.add_note(foobar='New note')
    DGDFGDFFD
{% endhighlight %}

#### Searching

As well as the 

{% highlight python %}
    >>> doc = doc.search(term='garage')
    >>> print doc.notes
    [
        {
            'text': 'Fix the garage lock',
            'completed': False,
            'delete': form(),
            'edit': form([text], [completed])
        }
    ]
{% endhighlight %}

#### Following links

{% highlight python %}
    >>> doc = doc.tabs.completed.get()
    >>> for note in doc.notes:
    >>>     print note.completed, note.text
{% endhighlight %}

{% highlight python %}
    >>> doc = doc.tabs.incomplete.get().search(term='garage')
    >>> print doc.notes
{% endhighlight %}

---

## Writing DocJSON services

DocJSON is of course language independant, and you should be able to develop DocJSON services in any decent server-side framework, such as Rails, Django or Node.

The example service used above is developed using Django REST framework, you can take a look here **TODO**


## Why you should be excited

The `docjson` client we've demonstrated doesn't have an prior knowledge about the server it's communicating with, and yet it's able to present the developer with a complete, ready-to-go library for interacting with the service.

It's simple, discoverable, and the client will always be instantly up to date with any server-side API changes.

DocJSON is appropriate for a very wide range of APIs, as it allows for flexible data representation, and supports a full range of hypermedia controls rather than just links or just CRUD-style interactions.

## The future, and what you can do to help

First up, feedback!

**TODO**

we need client libraries in various different languages etc.etc.


*Credits: Icon based on [document image][document-image] by [Gustavo Cordeiro][gustavo-cordeiro].*

[document-image]: http://thenounproject.com/noun/document/#icon-No19369
[gustavo-cordeiro]: http://thenounproject.com/gustavogcps/#

# DocJSON

![DocJSON](docjson.png)

**JSON hypermedia documents** 

DocJSON is a simple document format for building Hypermedia Web APIs.

A DocJSON document consists of standard JSON with the addition of a set of hypermedia controls that are used to express the actions that may be taken.  DocJSON is a flexible document format that does not impose any structural restrictions either on the data representation style or on the layout of hypermedia controls used within the document.

---

## Specification

**Warning:** *The DocJSON specification is currently in draft, and is subject to change at any time.*

A DocJSON document is represented using standard JSON, with additional restriction that the object key `"_type"` is reserved. Any JSON object containing a key named `"_type"` is considered a control object.

The currently supported control objects are `"document"` and `"link"`.

The IANA registered media type for DocJSON documents is [`vnd.document+json`][IANA-docjson].  Clients SHOULD send an appropriate `Accept` header when making a request to a DocJSON API, typically this will be `"Accept: vnd.document+json"`.

### Document

A document is a control element that acts as a top-level container for the DocJSON representation.

* A document is any JSON object containing the `"_type"` key with a value of `"document"`.
* A document object MUST always appear exactly once and MUST always be the top-level element.

The most minimal valid DocJSON document is simply an empty document object:

    {"_type": "document"}

#### The structure of documents

Typically a document will contain a number of keys.  The 'meta' key is reserved for storing certain information about the document.  Other keys are used for storing the document content.

* A document SHOULD contain a key named `"meta"`, which SHOULD be an object.
* Unless an error is indicated as described below, then: 
  * The `"meta"` object SHOULD contain a key named `"url"`, which SHOULD be a string.
  * The `"meta"` object SHOULD contain a key named `"title"`, which SHOULD be a string.
  * The `"meta"` object MAY contain a key named `"description"`, which SHOULD be a string.
  * The document MAY contain other keys in addition to `"_type"` and `"meta"`.  These additional keys are used for representing the body of the document.

**An example document:**

    {
        "_type": "document",
        "meta": {
            "url": "https://example.com/example_api/",
            "title": "An example DocJSON API"
        }
        # ...other keys containing the body of the document
    }

The 'meta.url' key is used to represent the base URL for the document.  Any relative URLs appearing elsewhere in the document will be treated as relative to this URL.  The document may be refreshed at any time by fetching it again using this URL.

The 'meta.title' key is used for a short title containing information about the API.  It will typically consist of a single line.

The 'meta.description' key is used for a longer desciption containing information about the API.

#### Documents indicating failure conditions

In certain conditions a server may need to return an error response. In this case the 'meta' object will contain a single key named 'error'. 

* The 'meta' object MAY contain a key named 'error', which SHOULD be a string.
* If an error is indicated, then the document SHOULD NOT contain any other keys.

**An example error document:**

    {
        "_type": "document"
        "meta": {
            "error": "Permission denied"
        }
    }

### Link

A link is a control element that represents an action that may be performed by the client. 

* A link is any JSON object containing the `"_type"` key with a value of `"link"`.
* A link MUST have a key named `"url"`, which MUST contain a string.
* A link MAY contain a key named `"method"`, which SHOULD be a valid HTTP method name.  If not present, the HTTP method used for performing the action will default to `"GET"`.
* A link MAY contain a key named `"fields"`, which SHOULD be a list.
    * Each the item in the list SHOULD be an object.
    * Any items in the `"fields"` list SHOULD contain a key named `"name"`, which SHOULD contain a string matching the regular expression `[A-Za-z_][A-Za-z0-9_]*`.
   * Any items in the `"fields"` list MAY contain a key named `"required"`, which SHOULD contain a boolean.  If not present then the field will default to being treated as not required.
* A link SHOULD NOT contain any keys other than `"_type"`, `"url"`, `"method"` and `"fields"`.

**The following are examples of valid link objects:**

    # A link which makes a GET request.
    {
        '_type': 'link',
        'url': '/user_details/1234'
    }

    # A link which makes a GET request, using an absolute URL.
    {
        '_type': 'link',
        'url': 'http://example.com/user_details/1234'
    }

    # A link which makes a DELETE request.
    {
        '_type': 'link',
        'url': '/user_details/1234',
        'method': 'DELETE'
    }

    # A link which makes a POST request, including some parameters.
    {
        '_type': 'link',
        'url': '/user_details/1234',
        'method': 'POST',
        'fields': [
            {'name': 'email', 'required': True},
            {'name': 'notes'}
        ]
    }

---

## Why another Hypermedia format?

None of the existing hypermedia formats meet the particular design goals of DocJSON.

* `Collection+JSON` presents a full range of hypermedia controls but is specfic to representing list-like data structures.
* `HAL` presents link controls but lacks other hypermedia controls.
* `JSON API` is specfic to data syncing between client and server, and it does not present general purpose hypermedia controls.
* `JSON Hyperschema` is a *schema* for describing hypermedia documents rather than a hypermedia document format itself. 
* `HTML` is sometimes used or proposed for Hypermedia APIs, and offers hypermedia controls, but it is a poor fit for data representations.

DocJSON is designed with the aim of making developers' lives easier by introducing a flexible data format with a sufficiently complete set of hypermedia controls.  By doing so we enable generic client libraries to be used to interact with DocJSON APIs rather than rebuilding client libraries from scratch with each new API service.

---

## Example

The following is an example of a DocJSON document representing a simple API for storing ToDo notes.

    {
        "_type": "document", 
        "meta": {
            "url": "http://docjson.herokuapp.com/",
            "title": "DocJSON ToDo API (9 notes)"
        },
        "tabs": {
            "all": {"_type": "link", "url": "/"},
            "complete": {"_type": "link", "url": "/?completed=true"},
            "incomplete": {"_type": "link", "url": "/?completed=false"}
        },
        "create_note": {
            "_type": "link",
            "url": "/",
            "method": "POST",
            "fields": [
                {"name": "text", "required": true},
                {"name": "completed"}
            ]
        },
        "notes": [
            {
                "text": "Call mum",
                "completed": true,
                "edit": {
                    "_type": "link",
                    "url": "/13/",
                    "method": "PUT",
                    "fields": [{"name": "text"}, {"name": "completed"}]
                },
                "delete": {
                    "_type": "link",
                    "url": "/13/",
                    "method": "DELETE"
                }
           },
           {
                "text": "Fix the garage lock",
                "completed": true,
                "edit": {
                    "_type": "link",
                    "url": "/12/",
                    "method": "PUT",
                    "fields": [{"name": "text"}, {"name": "completed"}]
                },
                "delete": {
                    "_type": "link",
                    "url": "/12/",
                    "method": "DELETE"
                }
           },
           ...
       ]
   }

The document presents the API client with the following controls:

* A set of tabs for switching between all notes and complete or incomplete notes only.
* A control for creating new todo notes.
* A list of notes, including edit and delete controls for each note.

---

## Using a DocJSON client

Let's take a look at using a client library for DocJSON, to see what it can do.  There's currently a [Python implementation][python-client].  Other languages are planned.

Run `pip install docjson`, and start python. 

    bash: pip install docjson
    bash: python

#### Opening the API

To open the API we call `docjson.get()`. This example API is hosted on Heroku's free tier, so the first request may take a few seconds while the instance starts up.

    >>> doc = docjson.get('http://docjson.herokuapp.com')
    DocJSON ToDo API (9 notes) - http://docjson.herokuapp.com/

We can now inspect our current list of ToDo notes.

    >>> doc.notes
    [
        {
            text: 'Call mum',
            completed: False,
            delete(),
            edit([text], [completed])
        },
        {
            text: 'Fix the garage lock',
            completed: False,
            delete(),
            edit([text], [completed])
        },
        ...
    ]

#### Editing the ToDo notes

We can add new notes using the `create_note` link control.

    >>> doc.create_note(text='New note')
    DocJSON ToDo API (10 notes) - http://docjson.herokuapp.com/

Edit an existing note...

    >>> doc.notes[2].edit(completed=True)
    DocJSON ToDo API (10 notes) - http://docjson.herokuapp.com/

Or delete an existing note...

    >>> doc.notes[3].delete()
    DocJSON ToDo API (9 notes) - http://docjson.herokuapp.com/

If we attempt to submit a link with incorrect parameters, the client library will alert us.

    >>> doc.create_note()
    ValueError: Missing required parameter 'text'
    >>> doc.create_note(foobar='New note')
    ValueError: Unknown parameter 'foobar'

Similarly if we submit a link that causes the validation on the server to fail, we'll receive an error.

    >>> doc.create_note(text='foobar'*100)
    docjson.DocumentError: text - Ensure this value has at most 100 characters (it has 600).

#### Following the tab links

There are also a set of links nested under the `'tabs'` object, that we can follow.


    >>> doc.tabs
    {
        all(),
        complete(),
        incomplete()
    }

First let's retrieve a document containing just the completed notes.

    >>> doc.tabs.complete()
    DocJSON ToDo API (3 complete notes) - http://docjson.herokuapp.com/?completed=true
    >>> doc.notes
    [
        {
            'text': 'File tax return',
            'completed': True,
            'delete': form(),
            'edit': form([text], [completed])
        }
        ...
    ]

We can also switch to the `'incomplete'` tab to get a document just containing notes that have not been completed.

    >>> doc.tabs.incomplete()
    DocJSON ToDo API (6 incomplete notes) - http://docjson.herokuapp.com/?completed=false
    >>> doc.notes
    [
        {
            text: 'Call mum',
            completed: False,
            delete(),
            edit([text], [completed])
        },
        {
            text: 'Fix the garage lock',
            completed: False,
            delete()
            edit([text], [completed]),
        },
        ...
    ]

And switch back to all the notes again.

    >>> doc.tabs.all()
    DocJSON ToDo API (9 notes) - http://docjson.herokuapp.com/

---

## Writing DocJSON services

DocJSON is a language independant format, and you should be able to develop DocJSON services in any server-side framework, such as Node, Rails or Django.

The example service used above is developed using Django REST framework.  The source code for the example API [is available on GitHub][server-example].

## Why you should be excited

The `docjson` client we've demonstrated doesn't have any prior knowledge about the server it's communicating with, and yet it's able to present the developer with a complete, ready-to-go library for interacting with the service.

It's simple, discoverable, and the client will always be instantly up to date with any server-side API changes.

DocJSON is appropriate for a very wide range of APIs, as it allows for flexible data representation, and supports a full range of hypermedia controls rather than just hyperlinks, or just CRUD-style interactions.

## The future, and what you can do to help

First up, feedback!

If you're interested in DocJSON, I want to hear from you - what do you think works or doesn't work?  Would you consider using DocJSON for a service you're building?  Would you consider writing a DocJSON client library for your preffered programming language?  You can raise issues for discussion on the GitHub issue tracker, or e-mail the [Hypermedia mailing list][hypermedia-list].

Keep in mind that DocJSON is currently in early draft.  There are a number of possible future changes and additions to the specification including:

* Link relations, with the 'rel' attribute.
* Richer link fields, eg. type information, labels, descriptions etc.
* Control over media type used in link requests, eg json by default, but add support for file upload using form multipart encoding.  Possibly support raw file uploads using arbitrary media types (eg 'image/*' for image uploads, '*/*' for any file uploads.)
* Control over media types expected by responses, eg indicate image, video, audio links.

The intent is that the specification should remain relatively simple, but that the hypermedia controls should be sufficiently expressive.

I've also got some ideas around improving the python client library, and would definatly like to see ruby and javascript implmentations as a minimum.

Personally, I'm really excited.  I think there's huge potential for a simple, generic hypermedia type such as DocJSON.

*Credits: Icon based on [document image][document-image] by [Gustavo Cordeiro][gustavo-cordeiro].*

[document-image]: http://thenounproject.com/noun/document/#icon-No19369
[IANA-docjson]: http://www.iana.org/assignments/media-types/application/vnd.document+json
[python-client]: https://github.com/docjson/python-client
[server-example]: https://github.com/tomchristie/docjson-todo
[hypermedia-list]: http://librelist.com/browser/hypermedia/
[gustavo-cordeiro]: http://thenounproject.com/gustavogcps/# 

**First draft of a more formal spec**

Within this document, the key words MUST, MUST NOT, SHOULD, SHOULD NOT and RECOMMENDED have a specific meaning as defined by [RFC 2119][rfc2119].

## 1. The DocJSON media type.

* 1.1 The IANA media type for DocJSON documents is '[vnd.document+json][docjson-iana]'.
* 1.2 Client implementations SHOULD include an `Accept` header with a value of `vnd.document+json` when making an initial request.
* 1.3 If the server implementation provides for standard HTTP content negotiation based on the client 'Accept' header as defined in [RFC 2616, Section 14.1][rfc2616-sec14.1], then it is RECOMMENDED that the implementation accept but ignore any additional parameters included in the DocJSON media type as specified in the client `Accept` header.  (**See note 1**)

## 2. Parsing documents.

* 2.1 The document MUST be valid JSON.  (**See note 2**)
* 2.2 The top-level data structure MUST be an object.
* 2.3 It MUST contain an attribute named '_type'.
* 2.4 The value of the '_type' attribute MUST be 'document'.
* 2.5 It MUST also contain an attribute named 'meta'.
* 2.6 The type of the 'meta' attribute MUST be an object.
* 2.7 The 'meta' attribute MUST NOT contain an attribute named '_type'.
* 2.8 The 'meta' attribute MUST contain either an attribute named 'error' or an attribute named 'url'.
* 2.9 The type of any existing 'meta.error' attribute MUST be a string.
* 2.10 A document containing a valid 'meta.error' attribute should return an error condition without further parsing of the document. 
* 2.11 The type of the 'meta.url' attribute MUST be a string.
* 2.12 The value of the 'meta.url' attribute MUST be a URL with a scheme of either 'http' or 'https', and containing a non-empty 'net_loc' component, as defined in [RFC 1808, Section 2.1][rfc1808-sec2.1].
* 2.13 The 'meta' attribute MAY contain a 'title' attribute, and MAY contain a 'description' attribute.  If either exist, then the type of their value SHOULD be a string.  Client implementations SHOULD ignore 'title' or 'description' attributes that are not strings.
* 2.14 The 'meta' attribute SHOULD NOT contain any attributes other than 'error', 'url', 'title' or 'description'.  Client implementations SHOULD ignore any other attributes, but MUST NOT error if other attributes exist.  **(See note 3)**
* 2.15 'document' objects SHOULD only ever appear as the top-level object.  Client implementations MUST treat a 'document' object appearing anywhere else as a regular object, but strip the '_type' attribute.  **(See note 4)**

## 3. Parsing links.

* 3.1 JSON objects containing an attribute '_type' which has a value of 'link' MUST be treated as links.
* 3.2 A link object MUST contain an attribute named 'href'.
* 3.3 The type of the 'href' attribute MUST be a string.
* 3.4 The link object MAY contain an attribute named 'method'.
* 3.5 The type of the 'method' attribute MUST be a string.
* 3.6 After lowercasing, the value of the 'method' attribute SHOULD match one of 'get', 'post', 'put', 'delete', 'patch' or 'options'.  Client implementations SHOULD not attempt to follow links containing other methods, but MUST NOT error if an unknown method is present.  **(See note 5)**
* 3.7 The link object MAY contain an attribute named 'fields'.
* 3.8 The type of the 'fields' attribute MUST be a list.
* 3.9 The link object SHOULD NOT contain any attributes other than '_type', 'href', 'method', or 'fields'.  Client implementations SHOULD ignore any other attributes, but MUST NOT error if other attributes exist.  **(See note 6)**
* 3.10 Link objects SHOULD only ever appear as the value in an object or document, they SHOULD not ever appear as the value in a list.  Client implementations MUST ignore link objects that occur in a list.  **(See note 7)**

## 4. Parsing objects.

* 4.1 Objects SHOULD not contain an attribute '_type' with a value other than 'document' or 'link'.  Client implementations should treat objects with an unknown '\_type' as a regular object, but strip the '\_type' attribute.  **(See note 8)**

## 5. Following links.

* 5.1 Links indicate state transitions that may be made by the client.  The client is free to implement these state transitions as deamed appropriate.  State transitions might be implemented as: **1.** Updating a document in-place. **2.** Returning a new document on each transition.  **3.** Asyncronously making a callback with a new document when a transition completes.

## Notes.

Notes on future revisions are not intended to indicate *expected* changes, but merely to leave open the *possiblity* of later specification updates being made in a backwards compatible manner.

* Note 1: Future revisions *could* support additional parameters in the DocJSON media type.
* Note 2: Future revisions *could* support encodings other than JSON if the client explicitly indicates support for an alternative base encoding.
* Note 3: Future revisions *could* introduce other 'meta' attributes in a backwards compatible manner.
* Note 4: Future revisions *could* introduce embedded documents if required.
* Note 5: Future revisions *could* introduce other 'method' values in a backwards compatible manner.
* Note 6: Future revisions *could* introduce other link attributes in a backwards compatible manner.
* Note 7: Clients are free to implement links as methods on their parent object, and never need to handle bare links.
* Note 8: Future revisions *could* intoduce other DocJSON types in a backwards compatible manner.

[docjson-iana]: http://www.iana.org/assignments/media-types/application/vnd.document+json
[rfc2616-sec14.1]: http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.1
[rfc2119]: http://tools.ietf.org/html/rfc2119
[rfc1808-sec2.1]: http://tools.ietf.org/html/rfc1808#section-2.1
