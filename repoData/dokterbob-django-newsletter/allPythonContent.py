__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# django-newsletter documentation build configuration file, created by
# sphinx-quickstart on Wed Nov 13 13:53:07 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# Determine whether rendering on RTD
on_rtd = os.environ.get('READTHEDOCS', None) == 'True'

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('..'))

# Django bogus settings for autodoc
from django.conf import settings

settings.configure(
    SECRET_KEY='bogus', SITE_ID=1,
    INSTALLED_APPS=[
        'django.contrib.contenttypes',
        'django.contrib.sessions',
        'django.contrib.auth',
        'django.contrib.sites',
        'django_extensions',
        'sorl.thumbnail',
        'newsletter'
    ],
    DATABASES={
        'default': {
            'ENGINE': 'django.db.backends.sqlite3',
            'NAME': ':memory:'
        }
    }
)

from django.core.management import call_command
call_command('syncdb', interactive=False)

autodoc_default_flags = ['members', 'show-inheritance']
autodoc_member_order = 'bysource'

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.intersphinx']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'django-newsletter'
copyright = u'2013, Mathijs de Bruin'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.5'
# The full version, including alpha/beta/rc tags.
release = '0.5.1'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
add_module_names = False

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
modindex_common_prefix = ['newsletter']

# If true, keep warnings as "system message" paragraphs in the built documents.
#keep_warnings = False


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
if on_rtd:
    html_theme = 'default'
else:
    html_theme = 'nature'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'django-newsletterdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
'papersize': 'a4paper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'django-newsletter.tex', u'django-newsletter Documentation',
   u'Mathijs de Bruin', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'django-newsletter', u'django-newsletter Documentation',
     [u'Mathijs de Bruin'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'django-newsletter', u'django-newsletter Documentation',
   u'Mathijs de Bruin', 'django-newsletter', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

# If true, do not generate a @detailmenu in the "Top" node's menu.
#texinfo_no_detailmenu = False

intersphinx_mapping = {
  'django': ('http://django.readthedocs.org/en/latest/', None),

  # This causes namespace collisions with references. :s
  # 'python': ('http://python.readthedocs.org/en/latest/', None),
  # 'sphinx': ('http://sphinx.readthedocs.org/en/latest/', None),
}

########NEW FILE########
__FILENAME__ = csv_test
import csv
myfile = open("contacts_google.csv", "rb")
myreader = csv.reader(myfile)
firstrow = myreader.next()

# Find name column
colnum = 0
for column in firstrow:
    if 'naam' in column.lower() or 'name' in column.lower():
        namecol = colnum

        if 'display' in column.lower() or 'weergave' in column.lower():
            break

    colnum += 1
assert namecol is not None, 'Name column not found.'
print 'Name column found \'%s\'' % firstrow[namecol]

# Find email column
colnum = 0
for column in firstrow:
    if 'email' in column.lower() or 'e-mail' in column.lower():
        mailcol = colnum

        break

    colnum += 1
assert mailcol is not None, 'E-mail column not found.'
print 'E-mail column found \'%s\'' % firstrow[mailcol]

assert namecol != mailcol, 'Name and e-mail column should not be the same.'

print
print 'Extracting data...'
for row in myreader:
    print '----'
    print 'Name:', row[namecol]
    print 'Email:', row[mailcol]

########NEW FILE########
__FILENAME__ = csv_util
import csv
import codecs
import cStringIO


class UTF8Recoder:
    """
    Iterator that reads an encoded stream and reencodes the input to UTF-8
    """
    def __init__(self, f, encoding):
        self.reader = codecs.getreader(encoding)(f)

    def __iter__(self):
        return self

    def next(self):
        return self.reader.next().encode("utf-8")


class UnicodeReader:
    """
    A CSV reader which will iterate over lines in the CSV file "f",
    which is encoded in the given encoding.
    """

    def __init__(self, f, dialect=csv.excel, encoding="utf-8", **kwds):
        f = UTF8Recoder(f, encoding)
        self.reader = csv.reader(f, dialect=dialect, **kwds)

    def next(self):
        row = self.reader.next()
        return [unicode(s, "utf-8") for s in row]

    def __iter__(self):
        return self

    @property
    def line_num(self):
        return self.reader.line_num


class UnicodeWriter:
    """
    A CSV writer which will write rows to CSV file "f",
    which is encoded in the given encoding.
    """

    def __init__(self, f, dialect=csv.excel, encoding="utf-8", **kwds):
        # Redirect output to a queue
        self.queue = cStringIO.StringIO()
        self.writer = csv.writer(self.queue, dialect=dialect, **kwds)
        self.stream = f
        self.encoder = codecs.getincrementalencoder(encoding)()

    def writerow(self, row):
        self.writer.writerow([s.encode("utf-8") for s in row])
        # Fetch UTF-8 output from the queue ...
        data = self.queue.getvalue()
        data = data.decode("utf-8")
        # ... and reencode it into the target encoding
        data = self.encoder.encode(data)
        # write to the target stream
        self.stream.write(data)
        # empty queue
        self.queue.truncate(0)

    def writerows(self, rows):
        for row in rows:
            self.writerow(row)

########NEW FILE########
__FILENAME__ = ldif
"""
ldif - generate and parse LDIF data (see RFC 2849)

See http://python-ldap.sourceforge.net for details.

$Id: ldif.py,v 1.47 2008/03/10 08:34:29 stroeder Exp $

Python compability note:
Tested with Python 2.0+, but should work with Python 1.5.2+.
"""

__version__ = '0.5.5'

__all__ = [
    # constants
    'ldif_pattern',
    # functions
    'AttrTypeandValueLDIF', 'CreateLDIF', 'ParseLDIF',
    # classes
    'LDIFWriter',
    'LDIFParser',
    'LDIFRecordList',
    'LDIFCopy',
]

import urlparse
import urllib
import base64
import re
import types

try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO

attrtype_pattern = r'[\w;.]+(;[\w_-]+)*'
attrvalue_pattern = r'(([^,]|\\,)+|".*?")'
rdn_pattern = attrtype_pattern + r'[ ]*=[ ]*' + attrvalue_pattern
dn_pattern = rdn_pattern + r'([ ]*,[ ]*' + rdn_pattern + r')*[ ]*'
dn_regex = re.compile('^%s$' % dn_pattern)

ldif_pattern = \
    '^((dn(:|::) %(dn_pattern)s)|(%(attrtype_pattern)s(:|::) .*)$)+' % vars()

MOD_OP_INTEGER = {
    'add': 0, 'delete': 1, 'replace': 2
}

MOD_OP_STR = {
    0: 'add', 1: 'delete', 2: 'replace'
}

CHANGE_TYPES = ['add', 'delete', 'modify', 'modrdn']
valid_changetype_dict = {}
for c in CHANGE_TYPES:
    valid_changetype_dict[c] = None


SAFE_STRING_PATTERN = '(^(\000|\n|\r| |:|<)|[\000\n\r\200-\377]+|[ ]+$)'
safe_string_re = re.compile(SAFE_STRING_PATTERN)


def is_dn(s):
    """
    returns 1 if s is a LDAP DN
    """
    if s == '':
        return 1
    rm = dn_regex.match(s)
    return rm is not None and rm.group(0) == s


def needs_base64(s):
    """
    returns 1 if s has to be base-64 encoded because of special chars
    """
    return not safe_string_re.search(s) is None


def list_dict(l):
    """
    return a dictionary with all items of l being the keys of the dictionary
    """
    return dict([(i, None) for i in l])


class LDIFWriter:

    """
    Write LDIF entry or change records to file object
    Copy LDIF input to a file output object containing all data retrieved
    via URLs
    """

    def __init__(self, output_file, base64_attrs=None, cols=76, line_sep='\n'):
        """
        output_file
            file object for output
        base64_attrs
            list of attribute types to be base64-encoded in any case
        cols
            Specifies how many columns a line may have before it's
            folded into many lines.
        line_sep
            String used as line separator
        """
        self._output_file = output_file
        self._base64_attrs = list_dict(
            [a.lower() for a in (base64_attrs or [])])
        self._cols = cols
        self._line_sep = line_sep
        self.records_written = 0

    def _unfoldLDIFLine(self, line):
        """
        Write string line as one or more folded lines
        """
        # Check maximum line length
        line_len = len(line)
        if line_len <= self._cols:
            self._output_file.write(line)
            self._output_file.write(self._line_sep)
        else:
            # Fold line
            pos = self._cols
            self._output_file.write(line[0:min(line_len, self._cols)])
            self._output_file.write(self._line_sep)
            while pos < line_len:
                self._output_file.write(' ')
                self._output_file.write(
                    line[pos:min(line_len, pos + self._cols - 1)])
                self._output_file.write(self._line_sep)
                pos = pos + self._cols - 1
        return  # _unfoldLDIFLine()

    def _unparseAttrTypeandValue(self, attr_type, attr_value):
        """
        Write a single attribute type/value pair

        attr_type
              attribute type
        attr_value
              attribute value
        """
        if attr_type.lower() in self._base64_attrs or \
           needs_base64(attr_value):
            # Encode with base64
            self._unfoldLDIFLine(
                ':: '.join([
                    attr_type,
                    base64.encodestring(attr_value).replace('\n', '')
                ])
            )
        else:
            self._unfoldLDIFLine(': '.join([attr_type, attr_value]))
        return  # _unparseAttrTypeandValue()

    def _unparseEntryRecord(self, entry):
        """
        entry
            dictionary holding an entry
        """
        attr_types = entry.keys()[:]
        attr_types.sort()
        for attr_type in attr_types:
            for attr_value in entry[attr_type]:
                self._unparseAttrTypeandValue(attr_type, attr_value)

    def _unparseChangeRecord(self, modlist):
        """
        modlist
            list of additions (2-tuple) or modifications (3-tuple)
        """
        mod_len = len(modlist[0])
        if mod_len == 2:
            changetype = 'add'
        elif mod_len == 3:
            changetype = 'modify'
        else:
            raise ValueError("modlist item of wrong length")
        self._unparseAttrTypeandValue('changetype', changetype)
        for mod in modlist:
            if mod_len == 2:
                mod_type, mod_vals = mod
            elif mod_len == 3:
                mod_op, mod_type, mod_vals = mod
                self._unparseAttrTypeandValue(MOD_OP_STR[mod_op], mod_type)
            else:
                raise ValueError("Subsequent modlist item of wrong length")
            if mod_vals:
                for mod_val in mod_vals:
                    self._unparseAttrTypeandValue(mod_type, mod_val)
            if mod_len == 3:
                self._output_file.write('-' + self._line_sep)

    def unparse(self, dn, record):
        """
        dn
              string-representation of distinguished name
        record
              Either a dictionary holding the LDAP entry {attrtype:record}
              or a list with a modify list like for LDAPObject.modify().
        """
        if not record:
            # Simply ignore empty records
            return
        # Start with line containing the distinguished name
        self._unparseAttrTypeandValue('dn', dn)
        # Dispatch to record type specific writers
        if isinstance(record, types.DictType):
            self._unparseEntryRecord(record)
        elif isinstance(record, types.ListType):
            self._unparseChangeRecord(record)
        else:
            raise ValueError("Argument record must be dictionary or list")
        # Write empty line separating the records
        self._output_file.write(self._line_sep)
        # Count records written
        self.records_written = self.records_written + 1
        return  # unparse()


def CreateLDIF(dn, record, base64_attrs=None, cols=76):
    """
    Create LDIF single formatted record including trailing empty line.
    This is a compability function. Use is deprecated!

    dn
          string-representation of distinguished name
    record
          Either a dictionary holding the LDAP entry {attrtype:record}
          or a list with a modify list like for LDAPObject.modify().
    base64_attrs
          list of attribute types to be base64-encoded in any case
    cols
          Specifies how many columns a line may have before it's
          folded into many lines.
    """
    f = StringIO()
    ldif_writer = LDIFWriter(f, base64_attrs, cols, '\n')
    ldif_writer.unparse(dn, record)
    s = f.getvalue()
    f.close()
    return s


class LDIFParser:

    """
    Base class for a LDIF parser. Applications should sub-class this
    class and override method handle() to implement something meaningful.

    Public class attributes:
    records_read
          Counter for records processed so far
    """

    def _stripLineSep(self, s):
        """
        Strip trailing line separators from s, but no other whitespaces
        """
        if s[-2:] == '\r\n':
            return s[:-2]
        elif s[-1:] == '\n':
            return s[:-1]
        else:
            return s

    def __init__(
        self,
        input_file,
        ignored_attr_types=None,
        max_entries=0,
        process_url_schemes=None,
        line_sep='\n'
    ):
        """
        Parameters:
        input_file
            File-object to read the LDIF input from
        ignored_attr_types
            Attributes with these attribute type names will be ignored.
        max_entries
            If non-zero specifies the maximum number of entries to be
            read from f.
        process_url_schemes
            List containing strings with URLs schemes to process with urllib.
            An empty list turns off all URL processing and the attribute
            is ignored completely.
        line_sep
            String used as line separator
        """
        self._input_file = input_file
        self._max_entries = max_entries
        self._process_url_schemes = list_dict(
            [s.lower() for s in (process_url_schemes or [])])
        self._ignored_attr_types = list_dict(
            [a.lower() for a in (ignored_attr_types or [])])
        self._line_sep = line_sep
        self.records_read = 0

    def handle(self, dn, entry):
        """
        Process a single content LDIF record. This method should be
        implemented by applications using LDIFParser.
        """

    def _unfoldLDIFLine(self):
        """
        Unfold several folded lines with trailing space into one line
        """
        unfolded_lines = [self._stripLineSep(self._line)]
        self._line = self._input_file.readline()
        while self._line and self._line[0] == ' ':
            unfolded_lines.append(self._stripLineSep(self._line[1:]))
            self._line = self._input_file.readline()
        return ''.join(unfolded_lines)

    def _parseAttrTypeandValue(self):
        """
        Parse a single attribute type and value pair from one or
        more lines of LDIF data
        """
        # Reading new attribute line
        unfolded_line = self._unfoldLDIFLine()
        # Ignore comments which can also be folded
        while unfolded_line and unfolded_line[0] == '#':
            unfolded_line = self._unfoldLDIFLine()
        if (
            not unfolded_line or unfolded_line == '\n'
            or unfolded_line == '\r\n'
        ):
            return None, None
        try:
            colon_pos = unfolded_line.index(':')
        except ValueError:
            # Treat malformed lines without colon as non-existent
            return None, None
        attr_type = unfolded_line[0:colon_pos]
        # if needed attribute value is BASE64 decoded
        value_spec = unfolded_line[colon_pos:colon_pos + 2]
        if value_spec == '::':
            # attribute value needs base64-decoding
            attr_value = base64.decodestring(unfolded_line[colon_pos + 2:])
        elif value_spec == ':<':
            # fetch attribute value from URL
            url = unfolded_line[colon_pos + 2:].strip()
            attr_value = None
            if self._process_url_schemes:
                u = urlparse.urlparse(url)
                if u[0] in self._process_url_schemes:
                    attr_value = urllib.urlopen(url).read()
        elif value_spec == ':\r\n' or value_spec == '\n':
            attr_value = ''
        else:
            attr_value = unfolded_line[colon_pos + 2:].lstrip()
        return attr_type, attr_value

    def parse(self):
        """
        Continously read and parse LDIF records
        """
        self._line = self._input_file.readline()

        while (
            self._line and
            (not self._max_entries or self.records_read < self._max_entries)
        ):

            # Reset record
            version = None
            dn = None
            changetype = None
            modop = None
            entry = {}

            attr_type, attr_value = self._parseAttrTypeandValue()

            while attr_type is not None and attr_value is not None:
                if attr_type == 'dn':
                    # attr type and value pair was DN of LDIF record
                    if dn is not None:
                        raise ValueError(
                            "Two lines starting with dn: in one record."
                        )
                    if not is_dn(attr_value):
                        raise ValueError(
                            "No valid string-representation of "
                            "distinguished name %s." % (repr(attr_value))
                        )
                    dn = attr_value
                elif attr_type == 'version' and dn is None:
                    version = 1
                elif attr_type == 'changetype':
                    # attr type and value pair was DN of LDIF record
                    if dn is None:
                        raise ValueError(
                            "Read changetype: before getting valid dn: line."
                        )
                    if changetype is not None:
                        raise ValueError(
                            "Two lines starting with changetype: "
                            "in one record."
                        )
                    if not attr_value in valid_changetype_dict:
                        raise ValueError("changetype value %s is invalid." % (
                            repr(attr_value))
                        )
                    changetype = attr_value
                elif (
                    attr_value is not None and
                    not attr_type.lower() in self._ignored_attr_types
                ):
                    # Add the attribute to the entry if not ignored attribute
                    if attr_type in entry:
                        entry[attr_type].append(attr_value)
                    else:
                        entry[attr_type] = [attr_value]

                # Read the next line within an entry
                attr_type, attr_value = self._parseAttrTypeandValue()

            if entry:
                # append entry to result list
                self.handle(dn, entry)
                self.records_read = self.records_read + 1

        return  # parse()


class LDIFRecordList(LDIFParser):

    """
    Collect all records of LDIF input into a single list.
    of 2-tuples (dn,entry). It can be a memory hog!
    """

    def __init__(
        self,
        input_file,
        ignored_attr_types=None, max_entries=0, process_url_schemes=None
    ):
        """
        See LDIFParser.__init__()

        Additional Parameters:
        all_records
            List instance for storing parsed records
        """
        LDIFParser.__init__(
            self, input_file, ignored_attr_types,
            max_entries, process_url_schemes
        )
        self.all_records = []

    def handle(self, dn, entry):
        """
        Append single record to dictionary of all records.
        """
        self.all_records.append((dn, entry))


class LDIFCopy(LDIFParser):

    """
    Copy LDIF input to LDIF output containing all data retrieved
    via URLs
    """

    def __init__(
        self,
        input_file, output_file,
        ignored_attr_types=None, max_entries=0, process_url_schemes=None,
        base64_attrs=None, cols=76, line_sep='\n'
    ):
        """
        See LDIFParser.__init__() and LDIFWriter.__init__()
        """
        LDIFParser.__init__(
            self, input_file, ignored_attr_types,
            max_entries, process_url_schemes
        )
        self._output_ldif = LDIFWriter(
            output_file, base64_attrs, cols, line_sep
        )

    def handle(self, dn, entry):
        """
        Write single LDIF record to output file.
        """
        self._output_ldif.unparse(dn, entry)


def ParseLDIF(f, ignore_attrs=None, maxentries=0):
    """
    Parse LDIF records read from file.
    This is a compability function. Use is deprecated!
    """
    ldif_parser = LDIFRecordList(
        f, ignored_attr_types=ignore_attrs, max_entries=maxentries,
        process_url_schemes=0
    )
    ldif_parser.parse()
    return ldif_parser.all_records

########NEW FILE########
__FILENAME__ = ldif_test
import ldif


class myparser(ldif.LDIFParser):
    def handle(self, dn, entry):
        print '----'
        if 'cn' in entry and 'mail' in entry:
            print 'Name:', entry['cn'][0]
            print 'Email:', entry['mail'][0]
        else:
            print 'Entry skipped because no name or email was found.'


try:
    myfile = open("ldif.ldif", "rb")

    myparser(myfile).parse()
except ValueError:
    pass

########NEW FILE########
__FILENAME__ = vcard_test
import vobject

myfile = open("vcards.vcf", "rb")
myvcards = vobject.readComponents(myfile)

print
print 'Extracting data...'
for myvcard in myvcards:
    print '----'
    if hasattr(myvcard, 'fn') and hasattr(myvcard, 'email'):
        print 'Name:', myvcard.fn.value
        print 'Email:', myvcard.email.value
    else:
        print 'Entry skipped because no name or email was found.'

########NEW FILE########
__FILENAME__ = admin
import logging
logger = logging.getLogger(__name__)

from django.db import models

from django.conf import settings
from django.conf.urls import patterns, url

from django.contrib import admin, messages
from django.contrib.sites.models import Site

from django.core import serializers

from django.http import HttpResponse, HttpResponseRedirect, Http404

from django.template import RequestContext, Context

from django.shortcuts import render_to_response

from django.utils.translation import ugettext, ungettext, ugettext_lazy as _
from django.utils.formats import date_format

from django.views.decorators.clickjacking import xframe_options_sameorigin

from sorl.thumbnail.admin import AdminImageMixin

from .models import (
    Newsletter, Subscription, Article, Message, Submission
)

from django.utils.timezone import now

from .admin_forms import *
from .admin_utils import *

from .settings import newsletter_settings

# Contsruct URL's for icons
ICON_URLS = {
    'yes': '%sadmin/img/icon-yes.gif' % settings.STATIC_URL,
    'wait': '%snewsletter/admin/img/waiting.gif' % settings.STATIC_URL,
    'submit': '%snewsletter/admin/img/submitting.gif' % settings.STATIC_URL,
    'no': '%sadmin/img/icon-no.gif' % settings.STATIC_URL
}


class NewsletterAdmin(admin.ModelAdmin):
    list_display = (
        'title', 'admin_subscriptions', 'admin_messages', 'admin_submissions'
    )
    prepopulated_fields = {'slug': ('title',)}

    """ List extensions """
    def admin_messages(self, obj):
        return '<a href="../message/?newsletter__id__exact=%s">%s</a>' % (
            obj.id, ugettext('Messages')
        )
    admin_messages.allow_tags = True
    admin_messages.short_description = ''

    def admin_subscriptions(self, obj):
        return \
            '<a href="../subscription/?newsletter__id__exact=%s">%s</a>' % \
            (obj.id, ugettext('Subscriptions'))
    admin_subscriptions.allow_tags = True
    admin_subscriptions.short_description = ''

    def admin_submissions(self, obj):
        return '<a href="../submission/?newsletter__id__exact=%s">%s</a>' % (
            obj.id, ugettext('Submissions')
        )
    admin_submissions.allow_tags = True
    admin_submissions.short_description = ''


class SubmissionAdmin(admin.ModelAdmin, ExtendibleModelAdminMixin):
    form = SubmissionAdminForm
    list_display = (
        'admin_message', 'admin_newsletter', 'admin_publish_date', 'publish',
        'admin_status_text', 'admin_status'
    )
    date_hierarchy = 'publish_date'
    list_filter = ('newsletter', 'publish', 'sent')
    save_as = True
    filter_horizontal = ('subscriptions',)

    """ List extensions """
    def admin_message(self, obj):
        return '<a href="%d/">%s</a>' % (obj.id, obj.message.title)
    admin_message.short_description = ugettext('submission')
    admin_message.allow_tags = True

    def admin_newsletter(self, obj):
        return '<a href="../newsletter/%s/">%s</a>' % (
            obj.newsletter.id, obj.newsletter
        )
    admin_newsletter.short_description = ugettext('newsletter')
    admin_newsletter.allow_tags = True

    def admin_publish_date(self, obj):
        if obj.publish_date:
            return date_format(obj.publish_date)
        else:
            return ''
    admin_publish_date.short_description = _("publish date")

    def admin_status(self, obj):
        if obj.prepared:
            if obj.sent:
                return u'<img src="%s" width="10" height="10" alt="%s"/>' % (
                    ICON_URLS['yes'], self.admin_status_text(obj))
            else:
                if obj.publish_date > now():
                    return \
                        u'<img src="%s" width="10" height="10" alt="%s"/>' % (
                            ICON_URLS['wait'], self.admin_status_text(obj))
                else:
                    return \
                        u'<img src="%s" width="12" height="12" alt="%s"/>' % (
                            ICON_URLS['wait'], self.admin_status_text(obj))
        else:
            return u'<img src="%s" width="10" height="10" alt="%s"/>' % (
                ICON_URLS['no'], self.admin_status_text(obj))

    admin_status.short_description = ''
    admin_status.allow_tags = True

    def admin_status_text(self, obj):
        if obj.prepared:
            if obj.sent:
                return ugettext("Sent.")
            else:
                if obj.publish_date > now():
                    return ugettext("Delayed submission.")
                else:
                    return ugettext("Submitting.")
        else:
            return ugettext("Not sent.")
    admin_status_text.short_description = ugettext('Status')

    """ Views """
    def submit(self, request, object_id):
        submission = self._getobj(request, object_id)

        if submission.sent or submission.prepared:
            messages.info(request, ugettext("Submission already sent."))
            return HttpResponseRedirect('../')

        submission.prepared = True
        submission.save()

        messages.info(request, ugettext("Your submission is being sent."))

        return HttpResponseRedirect('../../')

    """ URLs """
    def get_urls(self):
        urls = super(SubmissionAdmin, self).get_urls()

        my_urls = patterns(
            '', url(
                r'^(.+)/submit/$',
                self._wrap(self.submit),
                name=self._view_name('submit')
            )
        )

        return my_urls + urls


StackedInline = admin.StackedInline
if (
        newsletter_settings.RICHTEXT_WIDGET
        and newsletter_settings.RICHTEXT_WIDGET.__name__ == "ImperaviWidget"
):
    # Imperavi works a little differently
    # It's not just a field, it's also a media class and a method.
    # To avoid complications, we reuse ImperaviStackedInlineAdmin
    try:
        from imperavi.admin import ImperaviStackedInlineAdmin
        StackedInline = ImperaviStackedInlineAdmin
    except ImportError:
        # Log a warning when import fails as to aid debugging.
        logger.warning(
            'Error importing ImperaviStackedInlineAdmin. '
            'Imperavi WYSIWYG text editor might not work.'
        )


class ArticleInline(AdminImageMixin, StackedInline):
    model = Article
    extra = 2
    fieldsets = (
        (None, {
            'fields': ('title', 'sortorder', 'text')
        }),
        (_('Optional'), {
            'fields': ('url', 'image'),
            'classes': ('collapse',)
        }),
    )

    if newsletter_settings.RICHTEXT_WIDGET:
        formfield_overrides = {
            models.TextField: {'widget': newsletter_settings.RICHTEXT_WIDGET},
        }


class MessageAdmin(admin.ModelAdmin, ExtendibleModelAdminMixin):
    save_as = True
    list_display = (
        'admin_title', 'admin_newsletter', 'admin_preview', 'date_create',
        'date_modify'
    )
    list_filter = ('newsletter', )
    date_hierarchy = 'date_create'
    prepopulated_fields = {'slug': ('title',)}

    inlines = [ArticleInline, ]

    """ List extensions """
    def admin_title(self, obj):
        return '<a href="%d/">%s</a>' % (obj.id, obj.title)
    admin_title.short_description = ugettext('message')
    admin_title.allow_tags = True

    def admin_preview(self, obj):
        return '<a href="%d/preview/">%s</a>' % (obj.id, ugettext('Preview'))
    admin_preview.short_description = ''
    admin_preview.allow_tags = True

    def admin_newsletter(self, obj):
        return '<a href="../newsletter/%s/">%s</a>' % (
            obj.newsletter.id, obj.newsletter
        )
    admin_newsletter.short_description = ugettext('newsletter')
    admin_newsletter.allow_tags = True

    """ Views """
    def preview(self, request, object_id):
        return render_to_response(
            "admin/newsletter/message/preview.html",
            {'message': self._getobj(request, object_id)},
            RequestContext(request, {}),
        )

    @xframe_options_sameorigin
    def preview_html(self, request, object_id):
        message = self._getobj(request, object_id)

        (subject_template, text_template, html_template) = \
            message.newsletter.get_templates('message')

        if not html_template:
            raise Http404(_(
                'No HTML template associated with the newsletter this '
                'message belongs to.'
            ))

        c = Context({'message': message,
                     'site': Site.objects.get_current(),
                     'newsletter': message.newsletter,
                     'date': now(),
                     'STATIC_URL': settings.STATIC_URL,
                     'MEDIA_URL': settings.MEDIA_URL})

        return HttpResponse(html_template.render(c))

    @xframe_options_sameorigin
    def preview_text(self, request, object_id):
        message = self._getobj(request, object_id)

        (subject_template, text_template, html_template) = \
            message.newsletter.get_templates('message')

        c = Context({
            'message': message,
            'site': Site.objects.get_current(),
            'newsletter': message.newsletter,
            'date': now(),
            'STATIC_URL': settings.STATIC_URL,
            'MEDIA_URL': settings.MEDIA_URL
        }, autoescape=False)

        return HttpResponse(text_template.render(c), mimetype='text/plain')

    def submit(self, request, object_id):
        submission = Submission.from_message(self._getobj(request, object_id))

        return HttpResponseRedirect('../../../submission/%s/' % submission.id)

    def subscribers_json(self, request, object_id):
        message = self._getobj(request, object_id)

        json = serializers.serialize(
            "json", message.newsletter.get_subscriptions(), fields=()
        )
        return HttpResponse(json, mimetype='application/json')

    """ URLs """
    def get_urls(self):
        urls = super(MessageAdmin, self).get_urls()

        my_urls = patterns(
            '',
            url(r'^(.+)/preview/$',
                self._wrap(self.preview),
                name=self._view_name('preview')),
            url(r'^(.+)/preview/html/$',
                self._wrap(self.preview_html),
                name=self._view_name('preview_html')),
            url(r'^(.+)/preview/text/$',
                self._wrap(self.preview_text),
                name=self._view_name('preview_text')),
            url(r'^(.+)/submit/$',
                self._wrap(self.submit),
                name=self._view_name('submit')),
            url(r'^(.+)/subscribers/json/$',
                self._wrap(self.subscribers_json),
                name=self._view_name('subscribers_json')),
        )

        return my_urls + urls


class SubscriptionAdmin(admin.ModelAdmin, ExtendibleModelAdminMixin):
    form = SubscriptionAdminForm
    list_display = (
        'name', 'email', 'admin_newsletter', 'admin_subscribe_date',
        'admin_unsubscribe_date', 'admin_status_text', 'admin_status'
    )
    list_display_links = ('name', 'email')
    list_filter = (
        'newsletter', 'subscribed', 'unsubscribed', 'subscribe_date'
    )
    search_fields = (
        'name_field', 'email_field', 'user__first_name', 'user__last_name',
        'user__email'
    )
    readonly_fields = (
        'ip', 'subscribe_date', 'unsubscribe_date', 'activation_code'
    )
    date_hierarchy = 'subscribe_date'
    actions = ['make_subscribed', 'make_unsubscribed']

    """ List extensions """
    def admin_newsletter(self, obj):
        return '<a href="../newsletter/%s/">%s</a>' % (
            obj.newsletter.id, obj.newsletter
        )
    admin_newsletter.short_description = ugettext('newsletter')
    admin_newsletter.allow_tags = True

    def admin_status(self, obj):
        if obj.unsubscribed:
            return u'<img src="%s" width="10" height="10" alt="%s"/>' % (
                ICON_URLS['no'], self.admin_status_text(obj))

        if obj.subscribed:
            return u'<img src="%s" width="10" height="10" alt="%s"/>' % (
                ICON_URLS['yes'], self.admin_status_text(obj))
        else:
            return u'<img src="%s" width="10" height="10" alt="%s"/>' % (
                ICON_URLS['wait'], self.admin_status_text(obj))

    admin_status.short_description = ''
    admin_status.allow_tags = True

    def admin_status_text(self, obj):
        if obj.subscribed:
            return ugettext("Subscribed")
        elif obj.unsubscribed:
            return ugettext("Unsubscribed")
        else:
            return ugettext("Unactivated")
    admin_status_text.short_description = ugettext('Status')

    def admin_subscribe_date(self, obj):
        if obj.subscribe_date:
            return date_format(obj.subscribe_date)
        else:
            return ''
    admin_subscribe_date.short_description = _("subscribe date")

    def admin_unsubscribe_date(self, obj):
        if obj.unsubscribe_date:
            return date_format(obj.unsubscribe_date)
        else:
            return ''
    admin_unsubscribe_date.short_description = _("unsubscribe date")

    """ Actions """
    def make_subscribed(self, request, queryset):
        rows_updated = queryset.update(subscribed=True)
        self.message_user(
            request,
            ungettext(
                "%s user has been successfully subscribed.",
                "%s users have been successfully subscribed.",
                rows_updated
            ) % rows_updated
        )
    make_subscribed.short_description = _("Subscribe selected users")

    def make_unsubscribed(self, request, queryset):
        rows_updated = queryset.update(subscribed=False)
        self.message_user(
            request,
            ungettext(
                "%s user has been successfully unsubscribed.",
                "%s users have been successfully unsubscribed.",
                rows_updated
            ) % rows_updated
        )
    make_unsubscribed.short_description = _("Unsubscribe selected users")

    """ Views """
    def subscribers_import(self, request):
        if request.POST:
            form = ImportForm(request.POST, request.FILES)
            if form.is_valid():
                request.session['addresses'] = form.get_addresses()
                return HttpResponseRedirect('confirm/')
        else:
            form = ImportForm()

        return render_to_response(
            "admin/newsletter/subscription/importform.html",
            {'form': form},
            RequestContext(request, {}),
        )

    def subscribers_import_confirm(self, request):
        # If no addresses are in the session, start all over.
        if not 'addresses' in request.session:
            return HttpResponseRedirect('../')

        addresses = request.session['addresses']
        logger.debug('Confirming addresses: %s', addresses)
        if request.POST:
            form = ConfirmForm(request.POST)
            if form.is_valid():
                try:
                    for address in addresses.values():
                        address.save()
                finally:
                    del request.session['addresses']

                messages.success(
                    request,
                    _('%s subscriptions have been successfully added.') %
                    len(addresses)
                )

                return HttpResponseRedirect('../../')
        else:
            form = ConfirmForm()

        return render_to_response(
            "admin/newsletter/subscription/confirmimportform.html",
            {'form': form, 'subscribers': addresses},
            RequestContext(request, {}),
        )

    """ URLs """
    def get_urls(self):
        urls = super(SubscriptionAdmin, self).get_urls()

        my_urls = patterns(
            '',
            url(r'^import/$',
                self._wrap(self.subscribers_import),
                name=self._view_name('import')),
            url(r'^import/confirm/$',
                self._wrap(self.subscribers_import_confirm),
                name=self._view_name('import_confirm')),

            # Translated JS strings - these should be app-wide but are
            # only used in this part of the admin. For now, leave them here.
            url(r'^jsi18n/$',
                'django.views.i18n.javascript_catalog',
                {'packages': ('newsletter',)},
                name='newsletter_js18n')
        )

        return my_urls + urls


admin.site.register(Newsletter, NewsletterAdmin)
admin.site.register(Submission, SubmissionAdmin)
admin.site.register(Message, MessageAdmin)
admin.site.register(Subscription, SubscriptionAdmin)

########NEW FILE########
__FILENAME__ = admin_forms
import logging

logger = logging.getLogger(__name__)

from django import forms

from django.core.exceptions import ValidationError

from django.core.validators import validate_email

from django.utils.translation import ugettext_lazy as _
from django.utils.translation import ugettext

from django.conf import settings

from .models import Subscription, Newsletter, Submission


def make_subscription(newsletter, email, name=None):
    qs = Subscription.objects.filter(
        newsletter__id=newsletter.id,
        subscribed=True,
        email_field__exact=email)

    if qs.count():
        return None

    addr = Subscription(subscribed=True)
    addr.newsletter = newsletter

    addr.email_field = email

    if name:
        addr.name_field = name

    return addr


def check_email(email, ignore_errors=False):
    if settings.DEBUG:
        logger.debug("Checking e-mail address %s", email)

    email_length = \
        Subscription._meta.get_field_by_name('email_field')[0].max_length

    if len(email) <= email_length or ignore_errors:
        return email[:email_length]
    else:
        raise forms.ValidationError(
            _(
                "E-mail address %(email)s too long, maximum length is "
                "%(email_length)s characters."
            ) % {
                "email": email,
                "email_length": email_length
            }
        )


def check_name(name, ignore_errors=False):
    if settings.DEBUG:
        logger.debug("Checking name: %s", name)

    name_length = \
        Subscription._meta.get_field_by_name('name_field')[0].max_length
    if len(name) <= name_length or ignore_errors:
        return name[:name_length]
    else:
        raise forms.ValidationError(
            _(
                "Name %(name)s too long, maximum length is "
                "%(name_length)s characters."
            ) % {
                "name": name,
                "name_length": name_length
            }
        )


def parse_csv(myfile, newsletter, ignore_errors=False):
    from newsletter.addressimport.csv_util import UnicodeReader
    import codecs
    import csv

    # Detect encoding
    from chardet.universaldetector import UniversalDetector

    detector = UniversalDetector()

    for line in myfile.readlines():
        detector.feed(line)
        if detector.done:
            break

    detector.close()
    charset = detector.result['encoding']

    # Reset the file index
    myfile.seek(0)

    # Attempt to detect the dialect
    encodedfile = codecs.EncodedFile(myfile, charset)
    dialect = csv.Sniffer().sniff(encodedfile.read(1024))

    # Reset the file index
    myfile.seek(0)

    logger.info('Detected encoding %s and dialect %s for CSV file',
                charset, dialect)

    myreader = UnicodeReader(myfile, dialect=dialect, encoding=charset)

    firstrow = myreader.next()

    # Find name column
    colnum = 0
    namecol = None
    for column in firstrow:
        if "name" in column.lower() or ugettext("name") in column.lower():
            namecol = colnum

            if "display" in column.lower() or \
                    ugettext("display") in column.lower():
                break

        colnum += 1

    if namecol is None:
        raise forms.ValidationError(_(
            "Name column not found. The name of this column should be "
            "either 'name' or '%s'.") % ugettext("name")
        )

    logger.debug("Name column found: '%s'", firstrow[namecol])

    # Find email column
    colnum = 0
    mailcol = None
    for column in firstrow:
        if 'email' in column.lower() or \
                'e-mail' in column.lower() or \
                ugettext("e-mail") in column.lower():

            mailcol = colnum

            break

        colnum += 1

    if mailcol is None:
        raise forms.ValidationError(_(
            "E-mail column not found. The name of this column should be "
            "either 'email', 'e-mail' or '%(email)s'.") %
            {'email': ugettext("e-mail")}
        )

    logger.debug("E-mail column found: '%s'", firstrow[mailcol])

    #assert namecol != mailcol, \
    #    'Name and e-mail column should not be the same.'
    if namecol == mailcol:
        raise forms.ValidationError(
            _(
                "Could not properly determine the proper columns in the "
                "CSV-file. There should be a field called 'name' or "
                "'%(name)s' and one called 'e-mail' or '%(e-mail)s'."
            ) % {
                "name": _("name"),
                "e-mail": _("e-mail")
            }
        )

    logger.debug('Extracting data.')

    addresses = {}
    for row in myreader:
        if not max(namecol, mailcol) < len(row):
            logger.warn("Column count does not match for row number %d",
                        myreader.line_num, extra=dict(data={'row': row}))

            if ignore_errors:
                # Skip this record
                continue
            else:
                raise forms.ValidationError(_(
                    "Row with content '%(row)s' does not contain a name and "
                    "email field.") % {'row': row}
                )

        name = check_name(row[namecol], ignore_errors)
        email = check_email(row[mailcol], ignore_errors)

        logger.debug("Going to add %s <%s>", name, email)

        try:
            validate_email(email)
            addr = make_subscription(newsletter, email, name)
        except ValidationError:
            if ignore_errors:
                logger.warn(
                    "Entry '%s' at line %d does not contain a valid "
                    "e-mail address.",
                    name, myreader.line_num, extra=dict(data={'row': row}))
            else:
                raise forms.ValidationError(_(
                    "Entry '%s' does not contain a valid "
                    "e-mail address.") % name
                )

        if addr:
            if email in addresses:
                logger.warn(
                    "Entry '%s' at line %d contains a "
                    "duplicate entry for '%s'",
                    name, myreader.line_num, email,
                    extra=dict(data={'row': row}))

                if not ignore_errors:
                    raise forms.ValidationError(_(
                        "The address file contains duplicate entries "
                        "for '%s'.") % email)

            addresses.update({email: addr})
        else:
            logger.warn(
                "Entry '%s' at line %d is already subscribed to "
                "with email '%s'",
                name, myreader.line_num, email, extra=dict(data={'row': row}))

            if not ignore_errors:
                raise forms.ValidationError(
                    _("Some entries are already subscribed to."))

    return addresses


def parse_vcard(myfile, newsletter, ignore_errors=False):
    import vobject

    try:
        myvcards = vobject.readComponents(myfile)
    except vobject.VObjectError, e:
        raise forms.ValidationError(
            _(u"Error reading vCard file: %s" % e)
        )

    addresses = {}

    for myvcard in myvcards:
        if hasattr(myvcard, 'fn'):
            name = check_name(myvcard.fn.value, ignore_errors)
        else:
            name = None

        # Do we have an email address?
        # If not: either continue to the next vcard or
        # raise a validation error.
        if hasattr(myvcard, 'email'):
            email = check_email(myvcard.email.value, ignore_errors)
        elif not ignore_errors:
            raise forms.ValidationError(
                _("Entry '%s' contains no email address.") % name)
        else:
            continue

        try:
            validate_email(email)
            addr = make_subscription(newsletter, email, name)
        except ValidationError:
            if not ignore_errors:
                raise forms.ValidationError(
                    _("Entry '%s' does not contain a valid e-mail address.")
                    % name
                )

        if addr:
            if email in addresses and not ignore_errors:
                raise forms.ValidationError(
                    _("The address file contains duplicate entries for '%s'.")
                    % email
                )

            addresses.update({email: addr})
        elif not ignore_errors:
            raise forms.ValidationError(
                _("Some entries are already subscribed to."))

    return addresses


def parse_ldif(myfile, newsletter, ignore_errors=False):
    from addressimport import ldif

    class AddressParser(ldif.LDIFParser):
        addresses = {}

        def handle(self, dn, entry):
            if 'mail' in entry:
                email = check_email(entry['mail'][0], ignore_errors)
                if 'cn' in entry:
                    name = check_name(entry['cn'][0], ignore_errors)
                else:
                    name = None

                try:
                    validate_email(email)
                    addr = make_subscription(newsletter, email, name)
                except ValidationError:
                    if not ignore_errors:
                        raise forms.ValidationError(_(
                            "Entry '%s' does not contain a valid "
                            "e-mail address.") % name
                        )

                if addr:
                    if email in self.addresses and not ignore_errors:
                        raise forms.ValidationError(_(
                            "The address file contains duplicate entries "
                            "for '%s'.") % email
                        )

                    self.addresses.update({email: addr})
                elif not ignore_errors:
                    raise forms.ValidationError(
                        _("Some entries are already subscribed to."))

            elif not ignore_errors:
                raise forms.ValidationError(
                    _("Some entries have no e-mail address."))
    try:
        myparser = AddressParser(myfile)
        myparser.parse()
    except ValueError, e:
        if not ignore_errors:
            raise forms.ValidationError(e)

    return myparser.addresses


class ImportForm(forms.Form):

    def clean(self):
        # If there are validation errors earlier on, don't bother.
        if not ('address_file' in self.cleaned_data and
                'ignore_errors' in self.cleaned_data and
                'newsletter' in self.cleaned_data):
            return self.cleaned_data
            # TESTME: Should an error be raised here or not?
            #raise forms.ValidationError(_("No file has been specified."))

        ignore_errors = self.cleaned_data['ignore_errors']
        newsletter = self.cleaned_data['newsletter']

        myfield = self.base_fields['address_file']
        myvalue = myfield.widget.value_from_datadict(
            self.data, self.files, self.add_prefix('address_file'))

        content_type = myvalue.content_type
        allowed_types = ('text/plain', 'application/octet-stream',
                         'text/vcard', 'text/directory', 'text/x-vcard',
                         'application/vnd.ms-excel',
                         'text/comma-separated-values', 'text/csv',
                         'application/csv', 'application/excel',
                         'application/vnd.msexcel', 'text/anytext')
        if content_type not in allowed_types:
            raise forms.ValidationError(_(
                "File type '%s' was not recognized.") % content_type)

        self.addresses = []

        ext = myvalue.name.rsplit('.', 1)[-1].lower()
        if ext == 'vcf':
            self.addresses = parse_vcard(
                myvalue.file, newsletter, ignore_errors)

        elif ext == 'ldif':
            self.addresses = parse_ldif(
                myvalue.file, newsletter, ignore_errors)

        elif ext == 'csv':
            self.addresses = parse_csv(
                myvalue.file, newsletter, ignore_errors)

        else:
            raise forms.ValidationError(
                _("File extention '%s' was not recognized.") % ext)

        if len(self.addresses) == 0:
            raise forms.ValidationError(
                _("No entries could found in this file."))

        return self.cleaned_data

    def get_addresses(self):
        if hasattr(self, 'addresses'):
            logger.debug('Getting addresses: %s', self.addresses)
            return self.addresses
        else:
            return {}

    newsletter = forms.ModelChoiceField(
        label=_("Newsletter"),
        queryset=Newsletter.objects.all(),
        initial=Newsletter.get_default_id())
    address_file = forms.FileField(label=_("Address file"))
    ignore_errors = forms.BooleanField(
        label=_("Ignore non-fatal errors"),
        initial=False, required=False)


class ConfirmForm(forms.Form):

    def clean(self):
        value = self.cleaned_data['confirm']

        if not value:
            raise forms.ValidationError(
                _("You should confirm in order to continue."))

    confirm = forms.BooleanField(
        label=_("Confirm import"),
        initial=True, widget=forms.HiddenInput)


class SubscriptionAdminForm(forms.ModelForm):

    class Meta:
        model = Subscription

    def clean_email_field(self):
        data = self.cleaned_data['email_field']
        if self.cleaned_data['user'] and data:
            raise forms.ValidationError(_(
                'If a user has been selected this field '
                'should remain empty.'))
        return data

    def clean_name_field(self):
        data = self.cleaned_data['name_field']
        if self.cleaned_data['user'] and data:
            raise forms.ValidationError(_(
                'If a user has been selected '
                'this field should remain empty.'))
        return data

    def clean(self):
        cleaned_data = super(SubscriptionAdminForm, self).clean()
        if not (cleaned_data.get('user', None) or
                cleaned_data.get('email_field', None)):

            raise forms.ValidationError(_(
                'Either a user must be selected or an email address must '
                'be specified.')
            )
        return cleaned_data


class SubmissionAdminForm(forms.ModelForm):

    class Meta:
        model = Submission

    def clean_publish(self):
        """
        Make sure only one submission can be published for each message.
        """
        publish = self.cleaned_data['publish']

        if publish:
            message = self.cleaned_data['message']
            qs = Submission.objects.filter(publish=True, message=message)
            if self.instance:
                qs = qs.exclude(pk=self.instance.pk)
            if qs.exists():
                raise forms.ValidationError(_(
                    'This message has already been published in some '
                    'other submission. Messages can only be published once.')
                )

        return publish

########NEW FILE########
__FILENAME__ = admin_utils
from django.http import Http404

from functools import update_wrapper
from django.utils.translation import ugettext_lazy as _

from django.contrib.admin.util import unquote
from django.utils.encoding import force_unicode


class ExtendibleModelAdminMixin(object):
    def _getobj(self, request, object_id):
            opts = self.model._meta

            try:
                obj = self.queryset(request).get(pk=unquote(object_id))
            except self.model.DoesNotExist:
                # Don't raise Http404 just yet, because we haven't checked
                # permissions yet. We don't want an unauthenticated user to
                # be able to determine whether a given object exists.
                obj = None

            if obj is None:
                raise Http404(
                    _(
                        '%(name)s object with primary key '
                        '%(key)r does not exist.'
                    ) % {
                        'name': force_unicode(opts.verbose_name),
                        'key': unicode(object_id)
                    }
                )

            return obj

    def _wrap(self, view):
        def wrapper(*args, **kwargs):
            return self.admin_site.admin_view(view)(*args, **kwargs)
        return update_wrapper(wrapper, view)

    def _view_name(self, name):
        info = self.model._meta.app_label, self.model._meta.module_name, name

        return '%s_%s_%s' % info

########NEW FILE########
__FILENAME__ = forms
from django.utils.translation import ugettext_lazy as _

from django import forms
from django.forms.util import ValidationError

from .utils import get_user_model
User = get_user_model()

from .models import Subscription


class NewsletterForm(forms.ModelForm):
    """ This is the base class for all forms managing subscriptions. """

    class Meta:
        model = Subscription
        fields = ('name_field', 'email_field')

    def __init__(self, *args, **kwargs):

        assert 'newsletter' in kwargs, 'No newsletter specified'

        newsletter = kwargs.pop('newsletter')

        if 'ip' in kwargs:
            ip = kwargs['ip']
            del kwargs['ip']
        else:
            ip = None

        super(NewsletterForm, self).__init__(*args, **kwargs)

        self.instance.newsletter = newsletter

        if ip:
            self.instance.ip = ip


class SubscribeRequestForm(NewsletterForm):
    """
    Request subscription to the newsletter. Will result in an activation email
    being sent with a link where one can edit, confirm and activate one's
    subscription.
    """

    def clean_email_field(self):
        data = self.cleaned_data['email_field']

        if not data:
            raise ValidationError(_("An e-mail address is required."))

        # Check whether we should be subscribed to as a user
        try:
            user = User.objects.get(email__exact=data)

            raise ValidationError(_(
                "The e-mail address '%(email)s' belongs to a user with an "
                "account on this site. Please log in as that user "
                "and try again."
            ) % {'email': user.email})

        except User.DoesNotExist:
            pass

        # Check whether we have already been subscribed to
        try:
            subscription = Subscription.objects.get(
                email_field__exact=data,
                newsletter=self.instance.newsletter
            )

            if subscription.subscribed and not subscription.unsubscribed:
                raise ValidationError(
                    _("Your e-mail address has already been subscribed to.")
                )
            else:
                self.instance = subscription

            self.instance = subscription

        except Subscription.DoesNotExist:
            pass

        return data


class UpdateRequestForm(NewsletterForm):
    """
    Request updating or activating subscription. Will result in an activation
    email being sent.
    """

    class Meta(NewsletterForm.Meta):
        fields = ('email_field',)

    def clean(self):
        if not self.instance.subscribed:
            raise ValidationError(
                _("This subscription has not yet been activated.")
            )

        return super(UpdateRequestForm, self).clean()

    def clean_email_field(self):
        data = self.cleaned_data['email_field']

        if not data:
            raise ValidationError(_("An e-mail address is required."))

        # Check whether we should update as a user
        try:
            user = User.objects.get(email__exact=data)

            raise ValidationError(
                _("This e-mail address belongs to the user '%(username)s'. "
                  "Please log in as that user and try again.")
                % {'username': user.username}
            )

        except User.DoesNotExist:
            pass

        # Set our instance on the basis of the email field, or raise
        # a validationerror
        try:
            self.instance = Subscription.objects.get(
                newsletter=self.instance.newsletter,
                email_field__exact=data
            )

        except Subscription.DoesNotExist:
                raise ValidationError(
                    _("This e-mail address has not been subscribed to.")
                )

        return data


class UnsubscribeRequestForm(UpdateRequestForm):
    """
    Similar to previous form but checks if we have not
    already been unsubscribed.
    """

    def clean(self):
        if self.instance.unsubscribed:
            raise ValidationError(
                _("This subscription has already been unsubscribed from.")
            )

        return super(UnsubscribeRequestForm, self).clean()


class UpdateForm(NewsletterForm):
    """
    This form allows one to actually update to or unsubscribe from the
    newsletter. To do this, a correct activation code is required.
    """
    def clean_user_activation_code(self):
        data = self.cleaned_data['user_activation_code']

        if data != self.instance.activation_code:
            raise ValidationError(
                _('The validation code supplied by you does not match.')
            )

        return data

    user_activation_code = forms.CharField(
        label=_("Activation code"), max_length=40
    )


class UserUpdateForm(forms.ModelForm):
    """
    Form for updating subscription information/unsubscribing as a logged-in
    user.
    """

    class Meta:
        model = Subscription
        fields = ('subscribed',)
        # Newsletter here should become a read only field,
        # once this is supported by Django.

        # For now, use a hidden field.
        hidden_fields = ('newsletter',)

########NEW FILE########
__FILENAME__ = submit
import logging

logger = logging.getLogger(__name__)

from django_extensions.management.jobs import HourlyJob

from django.utils.translation import ugettext as _
from newsletter.models import Submission


class Job(HourlyJob):
    help = "Submit pending messages."

    def execute(self):
        logger.info(_('Submitting queued newsletter mailings'))
        Submission.submit_queue()

########NEW FILE########
__FILENAME__ = 0001_initial
# -*- coding: utf-8 -*-
import datetime
import south
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

if south.__version__ == '0.8.3':
    raise Exception(
        'Due to a bug in South 0.8.3, migrations cannot be run. Please '
        'upgrade to South 0.8.4 or later using `pip install -U South` and '
        'run the migrations again.'
    )


from ..utils import get_user_model
User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding model 'EmailTemplate'
        db.create_table('newsletter_emailtemplate', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('title', self.gf('django.db.models.fields.CharField')(default=u'Default', max_length=200)),
            ('action', self.gf('django.db.models.fields.CharField')(max_length=16, db_index=True)),
            ('subject', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('text', self.gf('django.db.models.fields.TextField')()),
            ('html', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
        ))
        db.send_create_signal('newsletter', ['EmailTemplate'])

        # Adding unique constraint on 'EmailTemplate', fields ['title', 'action']
        db.create_unique('newsletter_emailtemplate', ['title', 'action'])

        # Adding model 'Newsletter'
        db.create_table('newsletter_newsletter', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('title', self.gf('django.db.models.fields.CharField')(max_length=200)),
            ('slug', self.gf('django.db.models.fields.SlugField')(unique=True, max_length=50)),
            ('email', self.gf('django.db.models.fields.EmailField')(max_length=75)),
            ('sender', self.gf('django.db.models.fields.CharField')(max_length=200)),
            ('visible', self.gf('django.db.models.fields.BooleanField')(default=True, db_index=True)),
            ('subscribe_template', self.gf('django.db.models.fields.related.ForeignKey')(default=2, related_name='subcribe_template', to=orm['newsletter.EmailTemplate'])),
            ('unsubscribe_template', self.gf('django.db.models.fields.related.ForeignKey')(default=3, related_name='unsubcribe_template', to=orm['newsletter.EmailTemplate'])),
            ('update_template', self.gf('django.db.models.fields.related.ForeignKey')(default=4, related_name='update_template', to=orm['newsletter.EmailTemplate'])),
            ('message_template', self.gf('django.db.models.fields.related.ForeignKey')(default=1, related_name='message_template', to=orm['newsletter.EmailTemplate'])),
        ))
        db.send_create_signal('newsletter', ['Newsletter'])

        # Adding M2M table for field site on 'Newsletter'
        db.create_table('newsletter_newsletter_site', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('newsletter', models.ForeignKey(orm['newsletter.newsletter'], null=False)),
            ('site', models.ForeignKey(orm['sites.site'], null=False))
        ))
        db.create_unique('newsletter_newsletter_site', ['newsletter_id', 'site_id'])

        # Adding model 'Subscription'
        db.create_table('newsletter_subscription', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(to=orm[user_orm_label], null=True, blank=True)),
            ('name_field', self.gf('django.db.models.fields.CharField')(max_length=30, null=True, db_column='name', blank=True)),
            ('email_field', self.gf('django.db.models.fields.EmailField')(db_index=True, max_length=75, null=True, db_column='email', blank=True)),
            ('ip', self.gf('django.db.models.fields.IPAddressField')(max_length=15, null=True, blank=True)),
            ('newsletter', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['newsletter.Newsletter'])),
            ('create_date', self.gf('django.db.models.fields.DateTimeField')(default=datetime.datetime.now)),
            ('activation_code', self.gf('django.db.models.fields.CharField')(default='7f954ab42db0e45e6ee3e230e41b38b1e16614a8', max_length=40)),
            ('subscribed', self.gf('django.db.models.fields.BooleanField')(default=False, db_index=True)),
            ('subscribe_date', self.gf('django.db.models.fields.DateTimeField')(null=True, blank=True)),
            ('unsubscribed', self.gf('django.db.models.fields.BooleanField')(default=False, db_index=True)),
            ('unsubscribe_date', self.gf('django.db.models.fields.DateTimeField')(null=True, blank=True)),
        ))
        db.send_create_signal('newsletter', ['Subscription'])

        # Adding unique constraint on 'Subscription', fields ['user', 'email_field', 'newsletter']
        db.create_unique('newsletter_subscription', ['user_id', 'email', 'newsletter_id'])

        # Adding model 'Article'
        db.create_table('newsletter_article', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('sortorder', self.gf('django.db.models.fields.PositiveIntegerField')(default=30, db_index=True)),
            ('title', self.gf('django.db.models.fields.CharField')(max_length=200)),
            ('text', self.gf('django.db.models.fields.TextField')()),
            ('url', self.gf('django.db.models.fields.URLField')(max_length=200, null=True, blank=True)),
            ('image', self.gf('django.db.models.fields.files.ImageField')(max_length=100, null=True, blank=True)),
            ('thumb', self.gf('django.db.models.fields.CharField')(max_length=600, null=True, blank=True)),
            ('post', self.gf('django.db.models.fields.related.ForeignKey')(related_name='articles', to=orm['newsletter.Message'])),
        ))
        db.send_create_signal('newsletter', ['Article'])

        # Adding model 'Message'
        db.create_table('newsletter_message', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('title', self.gf('django.db.models.fields.CharField')(max_length=200)),
            ('slug', self.gf('django.db.models.fields.SlugField')(max_length=50)),
            ('newsletter', self.gf('django.db.models.fields.related.ForeignKey')(default=None, to=orm['newsletter.Newsletter'])),
            ('date_create', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('date_modify', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
        ))
        db.send_create_signal('newsletter', ['Message'])

        # Adding unique constraint on 'Message', fields ['slug', 'newsletter']
        db.create_unique('newsletter_message', ['slug', 'newsletter_id'])

        # Adding model 'Submission'
        db.create_table('newsletter_submission', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('newsletter', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['newsletter.Newsletter'])),
            ('message', self.gf('django.db.models.fields.related.ForeignKey')(default=2, to=orm['newsletter.Message'])),
            ('publish_date', self.gf('django.db.models.fields.DateTimeField')(default=datetime.datetime(2012, 11, 19, 0, 0), null=True, db_index=True, blank=True)),
            ('publish', self.gf('django.db.models.fields.BooleanField')(default=True, db_index=True)),
            ('prepared', self.gf('django.db.models.fields.BooleanField')(default=False, db_index=True)),
            ('sent', self.gf('django.db.models.fields.BooleanField')(default=False, db_index=True)),
            ('sending', self.gf('django.db.models.fields.BooleanField')(default=False, db_index=True)),
        ))
        db.send_create_signal('newsletter', ['Submission'])

        # Adding M2M table for field subscriptions on 'Submission'
        db.create_table('newsletter_submission_subscriptions', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('submission', models.ForeignKey(orm['newsletter.submission'], null=False)),
            ('subscription', models.ForeignKey(orm['newsletter.subscription'], null=False))
        ))
        db.create_unique('newsletter_submission_subscriptions', ['submission_id', 'subscription_id'])


    def backwards(self, orm):
        # Removing unique constraint on 'Message', fields ['slug', 'newsletter']
        db.delete_unique('newsletter_message', ['slug', 'newsletter_id'])

        # Removing unique constraint on 'Subscription', fields ['user', 'email_field', 'newsletter']
        db.delete_unique('newsletter_subscription', ['user_id', 'email', 'newsletter_id'])

        # Removing unique constraint on 'EmailTemplate', fields ['title', 'action']
        db.delete_unique('newsletter_emailtemplate', ['title', 'action'])

        # Deleting model 'EmailTemplate'
        db.delete_table('newsletter_emailtemplate')

        # Deleting model 'Newsletter'
        db.delete_table('newsletter_newsletter')

        # Removing M2M table for field site on 'Newsletter'
        db.delete_table('newsletter_newsletter_site')

        # Deleting model 'Subscription'
        db.delete_table('newsletter_subscription')

        # Deleting model 'Article'
        db.delete_table('newsletter_article')

        # Deleting model 'Message'
        db.delete_table('newsletter_message')

        # Deleting model 'Submission'
        db.delete_table('newsletter_submission')

        # Removing M2M table for field subscriptions on 'Submission'
        db.delete_table('newsletter_submission_subscriptions')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'newsletter.article': {
            'Meta': {'ordering': "('sortorder',)", 'object_name': 'Article'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('django.db.models.fields.files.ImageField', [], {'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'post': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'articles'", 'to': "orm['newsletter.Message']"}),
            'sortorder': ('django.db.models.fields.PositiveIntegerField', [], {'default': '30', 'db_index': 'True'}),
            'text': ('django.db.models.fields.TextField', [], {}),
            'thumb': ('django.db.models.fields.CharField', [], {'max_length': '600', 'null': 'True', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200', 'null': 'True', 'blank': 'True'})
        },
        'newsletter.emailtemplate': {
            'Meta': {'ordering': "('title',)", 'unique_together': "(('title', 'action'),)", 'object_name': 'EmailTemplate'},
            'action': ('django.db.models.fields.CharField', [], {'max_length': '16', 'db_index': 'True'}),
            'html': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'subject': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'text': ('django.db.models.fields.TextField', [], {}),
            'title': ('django.db.models.fields.CharField', [], {'default': "u'Default'", 'max_length': '200'})
        },
        'newsletter.message': {
            'Meta': {'unique_together': "(('slug', 'newsletter'),)", 'object_name': 'Message'},
            'date_create': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'date_modify': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'newsletter': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['newsletter.Newsletter']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'})
        },
        'newsletter.newsletter': {
            'Meta': {'object_name': 'Newsletter'},
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'message_template': ('django.db.models.fields.related.ForeignKey', [], {'default': '1', 'related_name': "'message_template'", 'to': "orm['newsletter.EmailTemplate']"}),
            'sender': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'site': ('django.db.models.fields.related.ManyToManyField', [], {'default': '[1]', 'to': "orm['sites.Site']", 'symmetrical': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '50'}),
            'subscribe_template': ('django.db.models.fields.related.ForeignKey', [], {'default': '2', 'related_name': "'subcribe_template'", 'to': "orm['newsletter.EmailTemplate']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'unsubscribe_template': ('django.db.models.fields.related.ForeignKey', [], {'default': '3', 'related_name': "'unsubcribe_template'", 'to': "orm['newsletter.EmailTemplate']"}),
            'update_template': ('django.db.models.fields.related.ForeignKey', [], {'default': '4', 'related_name': "'update_template'", 'to': "orm['newsletter.EmailTemplate']"}),
            'visible': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'db_index': 'True'})
        },
        'newsletter.submission': {
            'Meta': {'object_name': 'Submission'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'message': ('django.db.models.fields.related.ForeignKey', [], {'default': '2', 'to': "orm['newsletter.Message']"}),
            'newsletter': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['newsletter.Newsletter']"}),
            'prepared': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'publish': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'db_index': 'True'}),
            'publish_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2012, 11, 19, 0, 0)', 'null': 'True', 'db_index': 'True', 'blank': 'True'}),
            'sending': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'sent': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'subscriptions': ('django.db.models.fields.related.ManyToManyField', [], {'db_index': 'True', 'to': "orm['newsletter.Subscription']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'newsletter.subscription': {
            'Meta': {'unique_together': "(('user', 'email_field', 'newsletter'),)", 'object_name': 'Subscription'},
            'activation_code': ('django.db.models.fields.CharField', [], {'default': "'08b41d231f04490b0bfb77553fb8a7c6ea9a6376'", 'max_length': '40'}),
            'create_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email_field': ('django.db.models.fields.EmailField', [], {'db_index': 'True', 'max_length': '75', 'null': 'True', 'db_column': "'email'", 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'ip': ('django.db.models.fields.IPAddressField', [], {'max_length': '15', 'null': 'True', 'blank': 'True'}),
            'name_field': ('django.db.models.fields.CharField', [], {'max_length': '30', 'null': 'True', 'db_column': "'name'", 'blank': 'True'}),
            'newsletter': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['newsletter.Newsletter']"}),
            'subscribe_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'subscribed': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'unsubscribe_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'unsubscribed': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'null': 'True', 'blank': 'True'})
        },
        'sites.site': {
            'Meta': {'ordering': "('domain',)", 'object_name': 'Site', 'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        }
    }

    complete_apps = ['newsletter']

########NEW FILE########
__FILENAME__ = 0002_auto__del_field_article_thumb
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


from ..utils import get_user_model
User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    def forwards(self, orm):
        # Deleting field 'Article.thumb'
        db.delete_column('newsletter_article', 'thumb')


    def backwards(self, orm):
        # Adding field 'Article.thumb'
        db.add_column('newsletter_article', 'thumb',
                      self.gf('django.db.models.fields.CharField')(max_length=600, null=True, blank=True),
                      keep_default=False)


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'newsletter.article': {
            'Meta': {'ordering': "('sortorder',)", 'object_name': 'Article'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('django.db.models.fields.files.ImageField', [], {'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'post': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'articles'", 'to': "orm['newsletter.Message']"}),
            'sortorder': ('django.db.models.fields.PositiveIntegerField', [], {'default': '10', 'db_index': 'True'}),
            'text': ('django.db.models.fields.TextField', [], {}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200', 'null': 'True', 'blank': 'True'})
        },
        'newsletter.emailtemplate': {
            'Meta': {'ordering': "('title',)", 'unique_together': "(('title', 'action'),)", 'object_name': 'EmailTemplate'},
            'action': ('django.db.models.fields.CharField', [], {'max_length': '16', 'db_index': 'True'}),
            'html': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'subject': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'text': ('django.db.models.fields.TextField', [], {}),
            'title': ('django.db.models.fields.CharField', [], {'default': "u'Default'", 'max_length': '200'})
        },
        'newsletter.message': {
            'Meta': {'unique_together': "(('slug', 'newsletter'),)", 'object_name': 'Message'},
            'date_create': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'date_modify': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'newsletter': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['newsletter.Newsletter']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'})
        },
        'newsletter.newsletter': {
            'Meta': {'object_name': 'Newsletter'},
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'message_template': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'related_name': "'message_template'", 'to': "orm['newsletter.EmailTemplate']"}),
            'sender': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'site': ('django.db.models.fields.related.ManyToManyField', [], {'default': '[1]', 'to': "orm['sites.Site']", 'symmetrical': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '50'}),
            'subscribe_template': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'related_name': "'subcribe_template'", 'to': "orm['newsletter.EmailTemplate']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'unsubscribe_template': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'related_name': "'unsubcribe_template'", 'to': "orm['newsletter.EmailTemplate']"}),
            'update_template': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'related_name': "'update_template'", 'to': "orm['newsletter.EmailTemplate']"}),
            'visible': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'db_index': 'True'})
        },
        'newsletter.submission': {
            'Meta': {'object_name': 'Submission'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'message': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['newsletter.Message']"}),
            'newsletter': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['newsletter.Newsletter']"}),
            'prepared': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'publish': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'db_index': 'True'}),
            'publish_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2012, 11, 19, 0, 0)', 'null': 'True', 'db_index': 'True', 'blank': 'True'}),
            'sending': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'sent': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'subscriptions': ('django.db.models.fields.related.ManyToManyField', [], {'db_index': 'True', 'to': "orm['newsletter.Subscription']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'newsletter.subscription': {
            'Meta': {'unique_together': "(('user', 'email_field', 'newsletter'),)", 'object_name': 'Subscription'},
            'activation_code': ('django.db.models.fields.CharField', [], {'default': "'af582ec1469748463c80650a4e5d2e410b565f50'", 'max_length': '40'}),
            'create_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email_field': ('django.db.models.fields.EmailField', [], {'db_index': 'True', 'max_length': '75', 'null': 'True', 'db_column': "'email'", 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'ip': ('django.db.models.fields.IPAddressField', [], {'max_length': '15', 'null': 'True', 'blank': 'True'}),
            'name_field': ('django.db.models.fields.CharField', [], {'max_length': '30', 'null': 'True', 'db_column': "'name'", 'blank': 'True'}),
            'newsletter': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['newsletter.Newsletter']"}),
            'subscribe_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'subscribed': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'unsubscribe_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'unsubscribed': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'null': 'True', 'blank': 'True'})
        },
        'sites.site': {
            'Meta': {'ordering': "('domain',)", 'object_name': 'Site', 'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        }
    }

    complete_apps = ['newsletter']

########NEW FILE########
__FILENAME__ = 0003_auto__chg_field_article_image
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


from ..utils import get_user_model
User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    def forwards(self, orm):

        # Changing field 'Article.image'
        db.alter_column('newsletter_article', 'image', self.gf('sorl.thumbnail.fields.ImageField')(max_length=100, null=True))

    def backwards(self, orm):

        # Changing field 'Article.image'
        db.alter_column('newsletter_article', 'image', self.gf('django.db.models.fields.files.ImageField')(max_length=100, null=True))

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'newsletter.article': {
            'Meta': {'ordering': "('sortorder',)", 'object_name': 'Article'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('sorl.thumbnail.fields.ImageField', [], {'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'post': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'articles'", 'to': "orm['newsletter.Message']"}),
            'sortorder': ('django.db.models.fields.PositiveIntegerField', [], {'default': '10', 'db_index': 'True'}),
            'text': ('django.db.models.fields.TextField', [], {}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200', 'null': 'True', 'blank': 'True'})
        },
        'newsletter.emailtemplate': {
            'Meta': {'ordering': "('title',)", 'unique_together': "(('title', 'action'),)", 'object_name': 'EmailTemplate'},
            'action': ('django.db.models.fields.CharField', [], {'max_length': '16', 'db_index': 'True'}),
            'html': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'subject': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'text': ('django.db.models.fields.TextField', [], {}),
            'title': ('django.db.models.fields.CharField', [], {'default': "u'Default'", 'max_length': '200'})
        },
        'newsletter.message': {
            'Meta': {'unique_together': "(('slug', 'newsletter'),)", 'object_name': 'Message'},
            'date_create': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'date_modify': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'newsletter': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['newsletter.Newsletter']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'})
        },
        'newsletter.newsletter': {
            'Meta': {'object_name': 'Newsletter'},
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'message_template': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'related_name': "'message_template'", 'to': "orm['newsletter.EmailTemplate']"}),
            'sender': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'site': ('django.db.models.fields.related.ManyToManyField', [], {'default': '[1]', 'to': "orm['sites.Site']", 'symmetrical': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '50'}),
            'subscribe_template': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'related_name': "'subcribe_template'", 'to': "orm['newsletter.EmailTemplate']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'unsubscribe_template': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'related_name': "'unsubcribe_template'", 'to': "orm['newsletter.EmailTemplate']"}),
            'update_template': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'related_name': "'update_template'", 'to': "orm['newsletter.EmailTemplate']"}),
            'visible': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'db_index': 'True'})
        },
        'newsletter.submission': {
            'Meta': {'object_name': 'Submission'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'message': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['newsletter.Message']"}),
            'newsletter': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['newsletter.Newsletter']"}),
            'prepared': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'publish': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'db_index': 'True'}),
            'publish_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2012, 11, 19, 0, 0)', 'null': 'True', 'db_index': 'True', 'blank': 'True'}),
            'sending': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'sent': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'subscriptions': ('django.db.models.fields.related.ManyToManyField', [], {'db_index': 'True', 'to': "orm['newsletter.Subscription']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'newsletter.subscription': {
            'Meta': {'unique_together': "(('user', 'email_field', 'newsletter'),)", 'object_name': 'Subscription'},
            'activation_code': ('django.db.models.fields.CharField', [], {'default': "'f84e621ed907775c2bb0d630e227ebf63711f053'", 'max_length': '40'}),
            'create_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email_field': ('django.db.models.fields.EmailField', [], {'db_index': 'True', 'max_length': '75', 'null': 'True', 'db_column': "'email'", 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'ip': ('django.db.models.fields.IPAddressField', [], {'max_length': '15', 'null': 'True', 'blank': 'True'}),
            'name_field': ('django.db.models.fields.CharField', [], {'max_length': '30', 'null': 'True', 'db_column': "'name'", 'blank': 'True'}),
            'newsletter': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['newsletter.Newsletter']"}),
            'subscribe_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'subscribed': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'unsubscribe_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'unsubscribed': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'null': 'True', 'blank': 'True'})
        },
        'sites.site': {
            'Meta': {'ordering': "('domain',)", 'object_name': 'Site', 'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        }
    }

    complete_apps = ['newsletter']

########NEW FILE########
__FILENAME__ = 0004_template_files
# -*- coding: utf-8 -*-
import os

from django.conf import settings
from south.v2 import DataMigration

import newsletter


from ..utils import get_user_model
User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(DataMigration):
    def get_template_path(self):
        """ Return the template path. """
        if not settings.TEMPLATE_DIRS:
            raise Exception(
                'TEMPLATE_DIRS not set, could not migrate templates from '
                'databse to file!'
            )

        return os.path.join(
            settings.TEMPLATE_DIRS[0], 'newsletter', 'message'
        )

    def write_template(self, path, template):
        print 'Writing email template from DB to %s' % path

        f = open(path, 'w')
        f.write(template.encode('utf-8'))
        f.close()

    def forwards(self, orm):
        """ Grab templates from database and write to template files. """

        for newsletter in orm.Newsletter.objects.all():
            template_path = os.path.join(
                self.get_template_path(), newsletter.slug
            )

            # Optionally, create template dir
            try:
                os.makedirs(template_path)
            except OSError:
                pass

            # Subscribe template HTML, text, subject
            self.write_template(
                os.path.join(template_path, 'subscribe.html'),
                newsletter.subscribe_template.html
            )

            self.write_template(
                os.path.join(template_path, 'subscribe.txt'),
                newsletter.subscribe_template.text
            )

            self.write_template(
                os.path.join(template_path, 'subscribe_subject.txt'),
                newsletter.subscribe_template.subject
            )

            # Unsubscribe template HTML, text, subject
            self.write_template(
                os.path.join(template_path, 'unsubscribe.html'),
                newsletter.unsubscribe_template.html
            )

            self.write_template(
                os.path.join(template_path, 'unsubscribe.txt'),
                newsletter.unsubscribe_template.text
            )

            self.write_template(
                os.path.join(template_path, 'unsubscribe_subject.txt'),
                newsletter.unsubscribe_template.subject
            )

            # Update template HTML, text, subject
            self.write_template(
                os.path.join(template_path, 'update.html'),
                newsletter.update_template.html
            )

            self.write_template(
                os.path.join(template_path, 'update.txt'),
                newsletter.update_template.text
            )

            self.write_template(
                os.path.join(template_path, 'update_subject.txt'),
                newsletter.update_template.subject
            )

            # Message template HTML, text, subject
            self.write_template(
                os.path.join(template_path, 'message.html'),
                newsletter.message_template.html
            )

            self.write_template(
                os.path.join(template_path, 'message.txt'),
                newsletter.message_template.text
            )

            self.write_template(
                os.path.join(template_path, 'message_subject.txt'),
                newsletter.message_template.subject
            )

    def backwards(self, orm):
        """
        Way too lazy to write backwards migration for this one. It would have
        to load templates from the files and put them in the database.

        Also, a full backwards mapping is impossible as in the old setup a
        single template can be used for multiple newsletters.
        """
        raise RuntimeError("Cannot reverse this migration.")

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'newsletter.article': {
            'Meta': {'ordering': "('sortorder',)", 'object_name': 'Article'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('sorl.thumbnail.fields.ImageField', [], {'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'post': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'articles'", 'to': "orm['newsletter.Message']"}),
            'sortorder': ('django.db.models.fields.PositiveIntegerField', [], {'default': '20', 'db_index': 'True'}),
            'text': ('django.db.models.fields.TextField', [], {}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200', 'null': 'True', 'blank': 'True'})
        },
        'newsletter.emailtemplate': {
            'Meta': {'ordering': "('title',)", 'unique_together': "(('title', 'action'),)", 'object_name': 'EmailTemplate'},
            'action': ('django.db.models.fields.CharField', [], {'max_length': '16', 'db_index': 'True'}),
            'html': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'subject': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'text': ('django.db.models.fields.TextField', [], {}),
            'title': ('django.db.models.fields.CharField', [], {'default': "u'Default'", 'max_length': '200'})
        },
        'newsletter.message': {
            'Meta': {'unique_together': "(('slug', 'newsletter'),)", 'object_name': 'Message'},
            'date_create': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'date_modify': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'newsletter': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['newsletter.Newsletter']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'})
        },
        'newsletter.newsletter': {
            'Meta': {'object_name': 'Newsletter'},
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'message_template': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'related_name': "'message_template'", 'to': "orm['newsletter.EmailTemplate']"}),
            'sender': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'site': ('django.db.models.fields.related.ManyToManyField', [], {'default': '[1]', 'to': "orm['sites.Site']", 'symmetrical': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '50'}),
            'subscribe_template': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'related_name': "'subcribe_template'", 'to': "orm['newsletter.EmailTemplate']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'unsubscribe_template': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'related_name': "'unsubcribe_template'", 'to': "orm['newsletter.EmailTemplate']"}),
            'update_template': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'related_name': "'update_template'", 'to': "orm['newsletter.EmailTemplate']"}),
            'visible': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'db_index': 'True'})
        },
        'newsletter.submission': {
            'Meta': {'object_name': 'Submission'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'message': ('django.db.models.fields.related.ForeignKey', [], {'default': '1', 'to': "orm['newsletter.Message']"}),
            'newsletter': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['newsletter.Newsletter']"}),
            'prepared': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'publish': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'db_index': 'True'}),
            'publish_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2013, 5, 16, 0, 0)', 'null': 'True', 'db_index': 'True', 'blank': 'True'}),
            'sending': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'sent': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'subscriptions': ('django.db.models.fields.related.ManyToManyField', [], {'db_index': 'True', 'to': "orm['newsletter.Subscription']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'newsletter.subscription': {
            'Meta': {'unique_together': "(('user', 'email_field', 'newsletter'),)", 'object_name': 'Subscription'},
            'activation_code': ('django.db.models.fields.CharField', [], {'default': "'474708311b8ecc15d4e780f03193d222683d17f1'", 'max_length': '40'}),
            'create_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email_field': ('django.db.models.fields.EmailField', [], {'db_index': 'True', 'max_length': '75', 'null': 'True', 'db_column': "'email'", 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'ip': ('django.db.models.fields.IPAddressField', [], {'max_length': '15', 'null': 'True', 'blank': 'True'}),
            'name_field': ('django.db.models.fields.CharField', [], {'max_length': '30', 'null': 'True', 'db_column': "'name'", 'blank': 'True'}),
            'newsletter': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['newsletter.Newsletter']"}),
            'subscribe_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'subscribed': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'unsubscribe_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'unsubscribed': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'null': 'True', 'blank': 'True'})
        },
        'sites.site': {
            'Meta': {'ordering': "('domain',)", 'object_name': 'Site', 'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        }
    }

    complete_apps = ['newsletter']
    symmetrical = True

########NEW FILE########
__FILENAME__ = 0005_auto__del_emailtemplate__del_unique_emailtemplate_title_action__del_fi
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


from ..utils import get_user_model
User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    def forwards(self, orm):
        # Removing unique constraint on 'EmailTemplate', fields ['title', 'action']
        db.delete_unique('newsletter_emailtemplate', ['title', 'action'])

        # Deleting model 'EmailTemplate'
        db.delete_table('newsletter_emailtemplate')

        # Deleting field 'Newsletter.update_template'
        db.delete_column('newsletter_newsletter', 'update_template_id')

        # Deleting field 'Newsletter.unsubscribe_template'
        db.delete_column('newsletter_newsletter', 'unsubscribe_template_id')

        # Deleting field 'Newsletter.message_template'
        db.delete_column('newsletter_newsletter', 'message_template_id')

        # Deleting field 'Newsletter.subscribe_template'
        db.delete_column('newsletter_newsletter', 'subscribe_template_id')


    def backwards(self, orm):
        # Adding model 'EmailTemplate'
        db.create_table('newsletter_emailtemplate', (
            ('title', self.gf('django.db.models.fields.CharField')(default=u'Default', max_length=200)),
            ('text', self.gf('django.db.models.fields.TextField')()),
            ('html', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
            ('action', self.gf('django.db.models.fields.CharField')(max_length=16, db_index=True)),
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('subject', self.gf('django.db.models.fields.CharField')(max_length=255)),
        ))
        db.send_create_signal('newsletter', ['EmailTemplate'])

        # Adding unique constraint on 'EmailTemplate', fields ['title', 'action']
        db.create_unique('newsletter_emailtemplate', ['title', 'action'])


        # User chose to not deal with backwards NULL issues for 'Newsletter.update_template'
        raise RuntimeError("Cannot reverse this migration. 'Newsletter.update_template' and its values cannot be restored.")

        # User chose to not deal with backwards NULL issues for 'Newsletter.unsubscribe_template'
        raise RuntimeError("Cannot reverse this migration. 'Newsletter.unsubscribe_template' and its values cannot be restored.")

        # User chose to not deal with backwards NULL issues for 'Newsletter.message_template'
        raise RuntimeError("Cannot reverse this migration. 'Newsletter.message_template' and its values cannot be restored.")

        # User chose to not deal with backwards NULL issues for 'Newsletter.subscribe_template'
        raise RuntimeError("Cannot reverse this migration. 'Newsletter.subscribe_template' and its values cannot be restored.")

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'newsletter.article': {
            'Meta': {'ordering': "('sortorder',)", 'object_name': 'Article'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('sorl.thumbnail.fields.ImageField', [], {'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'post': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'articles'", 'to': "orm['newsletter.Message']"}),
            'sortorder': ('django.db.models.fields.PositiveIntegerField', [], {'default': '20', 'db_index': 'True'}),
            'text': ('django.db.models.fields.TextField', [], {}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200', 'null': 'True', 'blank': 'True'})
        },
        'newsletter.message': {
            'Meta': {'unique_together': "(('slug', 'newsletter'),)", 'object_name': 'Message'},
            'date_create': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'date_modify': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'newsletter': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['newsletter.Newsletter']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'})
        },
        'newsletter.newsletter': {
            'Meta': {'object_name': 'Newsletter'},
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'sender': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'site': ('django.db.models.fields.related.ManyToManyField', [], {'default': '[1]', 'to': "orm['sites.Site']", 'symmetrical': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '50'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'visible': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'db_index': 'True'})
        },
        'newsletter.submission': {
            'Meta': {'object_name': 'Submission'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'message': ('django.db.models.fields.related.ForeignKey', [], {'default': '1', 'to': "orm['newsletter.Message']"}),
            'newsletter': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['newsletter.Newsletter']"}),
            'prepared': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'publish': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'db_index': 'True'}),
            'publish_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2013, 5, 16, 0, 0)', 'null': 'True', 'db_index': 'True', 'blank': 'True'}),
            'sending': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'sent': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'subscriptions': ('django.db.models.fields.related.ManyToManyField', [], {'db_index': 'True', 'to': "orm['newsletter.Subscription']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'newsletter.subscription': {
            'Meta': {'unique_together': "(('user', 'email_field', 'newsletter'),)", 'object_name': 'Subscription'},
            'activation_code': ('django.db.models.fields.CharField', [], {'default': "'cfac7ee20279d5842214a4e8371475175ed8f00b'", 'max_length': '40'}),
            'create_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email_field': ('django.db.models.fields.EmailField', [], {'db_index': 'True', 'max_length': '75', 'null': 'True', 'db_column': "'email'", 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'ip': ('django.db.models.fields.IPAddressField', [], {'max_length': '15', 'null': 'True', 'blank': 'True'}),
            'name_field': ('django.db.models.fields.CharField', [], {'max_length': '30', 'null': 'True', 'db_column': "'name'", 'blank': 'True'}),
            'newsletter': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['newsletter.Newsletter']"}),
            'subscribe_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'subscribed': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'unsubscribe_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'unsubscribed': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'null': 'True', 'blank': 'True'})
        },
        'sites.site': {
            'Meta': {'ordering': "('domain',)", 'object_name': 'Site', 'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        }
    }

    complete_apps = ['newsletter']

########NEW FILE########
__FILENAME__ = 0006_auto__add_field_newsletter_send_html
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


from ..utils import get_user_model
User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding field 'Newsletter.send_html'
        db.add_column('newsletter_newsletter', 'send_html',
                      self.gf('django.db.models.fields.BooleanField')(default=True),
                      keep_default=False)


    def backwards(self, orm):
        # Deleting field 'Newsletter.send_html'
        db.delete_column('newsletter_newsletter', 'send_html')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'newsletter.article': {
            'Meta': {'ordering': "('sortorder',)", 'object_name': 'Article'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('sorl.thumbnail.fields.ImageField', [], {'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'post': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'articles'", 'to': "orm['newsletter.Message']"}),
            'sortorder': ('django.db.models.fields.PositiveIntegerField', [], {'default': '12', 'db_index': 'True'}),
            'text': ('django.db.models.fields.TextField', [], {}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200', 'null': 'True', 'blank': 'True'})
        },
        'newsletter.message': {
            'Meta': {'unique_together': "(('slug', 'newsletter'),)", 'object_name': 'Message'},
            'date_create': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'date_modify': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'newsletter': ('django.db.models.fields.related.ForeignKey', [], {'default': 'None', 'to': "orm['newsletter.Newsletter']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'})
        },
        'newsletter.newsletter': {
            'Meta': {'object_name': 'Newsletter'},
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'send_html': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'sender': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'site': ('django.db.models.fields.related.ManyToManyField', [], {'default': '[1]', 'to': "orm['sites.Site']", 'symmetrical': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '50'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'visible': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'db_index': 'True'})
        },
        'newsletter.submission': {
            'Meta': {'object_name': 'Submission'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'message': ('django.db.models.fields.related.ForeignKey', [], {'default': '1', 'to': "orm['newsletter.Message']"}),
            'newsletter': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['newsletter.Newsletter']"}),
            'prepared': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'publish': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'db_index': 'True'}),
            'publish_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2013, 6, 22, 0, 0)', 'null': 'True', 'db_index': 'True', 'blank': 'True'}),
            'sending': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'sent': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'subscriptions': ('django.db.models.fields.related.ManyToManyField', [], {'db_index': 'True', 'to': "orm['newsletter.Subscription']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'newsletter.subscription': {
            'Meta': {'unique_together': "(('user', 'email_field', 'newsletter'),)", 'object_name': 'Subscription'},
            'activation_code': ('django.db.models.fields.CharField', [], {'default': "'807648dd440ba29b6c2418e3cba79d5bc706b403'", 'max_length': '40'}),
            'create_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email_field': ('django.db.models.fields.EmailField', [], {'db_index': 'True', 'max_length': '75', 'null': 'True', 'db_column': "'email'", 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'ip': ('django.db.models.fields.IPAddressField', [], {'max_length': '15', 'null': 'True', 'blank': 'True'}),
            'name_field': ('django.db.models.fields.CharField', [], {'max_length': '30', 'null': 'True', 'db_column': "'name'", 'blank': 'True'}),
            'newsletter': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['newsletter.Newsletter']"}),
            'subscribe_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'subscribed': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'unsubscribe_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'unsubscribed': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'null': 'True', 'blank': 'True'})
        },
        'sites.site': {
            'Meta': {'ordering': "('domain',)", 'object_name': 'Site', 'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        }
    }

    complete_apps = ['newsletter']

########NEW FILE########
__FILENAME__ = models
import logging
logger = logging.getLogger(__name__)

from django.db import models
from django.db.models import permalink

from django.template import Context, TemplateDoesNotExist
from django.template.loader import select_template

from django.utils.translation import ugettext_lazy as _
from django.utils.translation import ugettext
from django.utils.timezone import now

from django.core.mail import EmailMultiAlternatives

from django.contrib.sites.models import Site
from django.contrib.sites.managers import CurrentSiteManager

from django.conf import settings

from sorl.thumbnail import ImageField

from .utils import (
    make_activation_code, get_default_sites, ACTIONS, get_user_model
)
User = get_user_model()


class Newsletter(models.Model):
    site = models.ManyToManyField(Site, default=get_default_sites)

    title = models.CharField(
        max_length=200, verbose_name=_('newsletter title')
    )
    slug = models.SlugField(db_index=True, unique=True)

    email = models.EmailField(
        verbose_name=_('e-mail'), help_text=_('Sender e-mail')
    )
    sender = models.CharField(
        max_length=200, verbose_name=_('sender'), help_text=_('Sender name')
    )

    visible = models.BooleanField(
        default=True, verbose_name=_('visible'), db_index=True
    )

    send_html = models.BooleanField(
        default=True, verbose_name=_('send html'),
        help_text=_('Whether or not to send HTML versions of e-mails.')
    )

    objects = models.Manager()

    # Automatically filter the current site
    on_site = CurrentSiteManager()

    def get_templates(self, action):
        """
        Return a subject, text, HTML tuple with e-mail templates for
        a particular action. Returns a tuple with subject, text and e-mail
        template.
        """

        assert action in ACTIONS + ('message', ), 'Unknown action: %s' % action

        # Common substitutions for filenames
        tpl_subst = {
            'action': action,
            'newsletter': self.slug
        }

        # Common root path for all the templates
        tpl_root = 'newsletter/message/'

        subject_template = select_template([
            tpl_root + '%(newsletter)s/%(action)s_subject.txt' % tpl_subst,
            tpl_root + '%(action)s_subject.txt' % tpl_subst,
        ])

        text_template = select_template([
            tpl_root + '%(newsletter)s/%(action)s.txt' % tpl_subst,
            tpl_root + '%(action)s.txt' % tpl_subst,
        ])

        if self.send_html:
            html_template = select_template([
                tpl_root + '%(newsletter)s/%(action)s.html' % tpl_subst,
                tpl_root + '%(action)s.html' % tpl_subst,
            ])
        else:
            # HTML templates are not required
            html_template = None

        return (subject_template, text_template, html_template)

    def __unicode__(self):
        return self.title

    class Meta:
        verbose_name = _('newsletter')
        verbose_name_plural = _('newsletters')

    @permalink
    def get_absolute_url(self):
        return (
            'newsletter_detail', (),
            {'newsletter_slug': self.slug}
        )

    @permalink
    def subscribe_url(self):
        return (
            'newsletter_subscribe_request', (),
            {'newsletter_slug': self.slug}
        )

    @permalink
    def unsubscribe_url(self):
        return (
            'newsletter_unsubscribe_request', (),
            {'newsletter_slug': self.slug}
        )

    @permalink
    def update_url(self):
        return (
            'newsletter_update_request', (),
            {'newsletter_slug': self.slug}
        )

    @permalink
    def archive_url(self):
        return (
            'newsletter_archive', (),
            {'newsletter_slug': self.slug}
        )

    def get_sender(self):
        return u'%s <%s>' % (self.sender, self.email)

    def get_subscriptions(self):
        logger.debug(u'Looking up subscribers for %s', self)

        return Subscription.objects.filter(newsletter=self, subscribed=True)

    @classmethod
    def get_default_id(cls):
        try:
            objs = cls.objects.all()
            if objs.count() == 1:
                return objs[0].id
        except:
            pass
        return None


class Subscription(models.Model):
    user = models.ForeignKey(
        User, blank=True, null=True, verbose_name=_('user')
    )

    name_field = models.CharField(
        db_column='name', max_length=30, blank=True, null=True,
        verbose_name=_('name'), help_text=_('optional')
    )

    def get_name(self):
        if self.user:
            return self.user.get_full_name()
        return self.name_field

    def set_name(self, name):
        if not self.user:
            self.name_field = name
    name = property(get_name, set_name)

    email_field = models.EmailField(
        db_column='email', verbose_name=_('e-mail'), db_index=True,
        blank=True, null=True
    )

    def get_email(self):
        if self.user:
            return self.user.email
        return self.email_field

    def set_email(self, email):
        if not self.user:
            self.email_field = email
    email = property(get_email, set_email)

    def update(self, action):
        """
        Update subscription according to requested action:
        subscribe/unsubscribe/update/, then save the changes.
        """

        assert action in ('subscribe', 'update', 'unsubscribe')

        # If a new subscription or update, make sure it is subscribed
        # Else, unsubscribe
        if action == 'subscribe' or action == 'update':
            self.subscribed = True
        else:
            self.unsubscribed = True

        logger.debug(
            _(u'Updated subscription %(subscription)s to %(action)s.'),
            {
                'subscription': self,
                'action': action
            }
        )

        # This triggers the subscribe() and/or unsubscribe() methods, taking
        # care of stuff like maintaining the (un)subscribe date.
        self.save()

    def _subscribe(self):
        """
        Internal helper method for managing subscription state
        during subscription.
        """
        logger.debug(u'Subscribing subscription %s.', self)

        self.subscribe_date = now()
        self.subscribed = True
        self.unsubscribed = False

    def _unsubscribe(self):
        """
        Internal helper method for managing subscription state
        during unsubscription.
        """
        logger.debug(u'Unsubscribing subscription %s.', self)

        self.subscribed = False
        self.unsubscribed = True
        self.unsubscribe_date = now()

    def save(self, *args, **kwargs):
        """
        Perform some basic validation and state maintenance of Subscription.

        TODO: Move this code to a more suitable place (i.e. `clean()`) and
        cleanup the code. Refer to comment below and
        https://docs.djangoproject.com/en/dev/ref/models/instances/#django.db.models.Model.clean
        """
        assert self.user or self.email_field, \
            _('Neither an email nor a username is set. This asks for '
              'inconsistency!')
        assert ((self.user and not self.email_field) or
                (self.email_field and not self.user)), \
            _('If user is set, email must be null and vice versa.')

        # This is a lame way to find out if we have changed but using Django
        # API internals is bad practice. This is necessary to discriminate
        # from a state where we have never been subscribed but is mostly for
        # backward compatibility. It might be very useful to make this just
        # one attribute 'subscribe' later. In this case unsubscribed can be
        # replaced by a method property.

        if self.pk:
            assert(Subscription.objects.filter(pk=self.pk).count() == 1)

            subscription = Subscription.objects.get(pk=self.pk)
            old_subscribed = subscription.subscribed
            old_unsubscribed = subscription.unsubscribed

            # If we are subscribed now and we used not to be so, subscribe.
            # If we user to be unsubscribed but are not so anymore, subscribe.
            if ((self.subscribed and not old_subscribed) or
               (old_unsubscribed and not self.unsubscribed)):
                self._subscribe()

                assert not self.unsubscribed
                assert self.subscribed

            # If we are unsubcribed now and we used not to be so, unsubscribe.
            # If we used to be subscribed but are not subscribed anymore,
            # unsubscribe.
            elif ((self.unsubscribed and not old_unsubscribed) or
                  (old_subscribed and not self.subscribed)):
                self._unsubscribe()

                assert not self.subscribed
                assert self.unsubscribed
        else:
            if self.subscribed:
                self._subscribe()
            elif self.unsubscribed:
                self._unsubscribe()

        super(Subscription, self).save(*args, **kwargs)

    ip = models.IPAddressField(_("IP address"), blank=True, null=True)

    newsletter = models.ForeignKey('Newsletter', verbose_name=_('newsletter'))

    create_date = models.DateTimeField(editable=False, default=now)

    activation_code = models.CharField(
        verbose_name=_('activation code'), max_length=40,
        default=make_activation_code
    )

    subscribed = models.BooleanField(
        default=False, verbose_name=_('subscribed'), db_index=True
    )
    subscribe_date = models.DateTimeField(
        verbose_name=_("subscribe date"), null=True, blank=True
    )

    # This should be a pseudo-field, I reckon.
    unsubscribed = models.BooleanField(
        default=False, verbose_name=_('unsubscribed'), db_index=True
    )
    unsubscribe_date = models.DateTimeField(
        verbose_name=_("unsubscribe date"), null=True, blank=True
    )

    def __unicode__(self):
        if self.name:
            return _(u"%(name)s <%(email)s> to %(newsletter)s") % {
                'name': self.name,
                'email': self.email,
                'newsletter': self.newsletter
            }

        else:
            return _(u"%(email)s to %(newsletter)s") % {
                'email': self.email,
                'newsletter': self.newsletter
            }

    class Meta:
        verbose_name = _('subscription')
        verbose_name_plural = _('subscriptions')
        unique_together = ('user', 'email_field', 'newsletter')

    def get_recipient(self):
        if self.name:
            return u'%s <%s>' % (self.name, self.email)

        return u'%s' % (self.email)

    def send_activation_email(self, action):
        assert action in ACTIONS, 'Unknown action: %s' % action

        (subject_template, text_template, html_template) = \
            self.newsletter.get_templates(action)

        variable_dict = {
            'subscription': self,
            'site': Site.objects.get_current(),
            'newsletter': self.newsletter,
            'date': self.subscribe_date,
            'STATIC_URL': settings.STATIC_URL,
            'MEDIA_URL': settings.MEDIA_URL
        }

        unescaped_context = Context(variable_dict, autoescape=False)

        subject = subject_template.render(unescaped_context).strip()
        text = text_template.render(unescaped_context)

        message = EmailMultiAlternatives(
            subject, text,
            from_email=self.newsletter.get_sender(),
            to=[self.email]
        )

        if html_template:
            escaped_context = Context(variable_dict)

            message.attach_alternative(
                html_template.render(escaped_context), "text/html"
            )

        message.send()

        logger.debug(
            u'Activation email sent for action "%(action)s" to %(subscriber)s '
            u'with activation code "%(action_code)s".', {
                'action_code': self.activation_code,
                'action': action,
                'subscriber': self
            }
        )

    @permalink
    def subscribe_activate_url(self):
        return ('newsletter_update_activate', (), {
            'newsletter_slug': self.newsletter.slug,
            'email': self.email,
            'action': 'subscribe',
            'activation_code': self.activation_code
        })

    @permalink
    def unsubscribe_activate_url(self):
        return ('newsletter_update_activate', (), {
            'newsletter_slug': self.newsletter.slug,
            'email': self.email,
            'action': 'unsubscribe',
            'activation_code': self.activation_code
        })

    @permalink
    def update_activate_url(self):
        return ('newsletter_update_activate', (), {
            'newsletter_slug': self.newsletter.slug,
            'email': self.email,
            'action': 'update',
            'activation_code': self.activation_code
        })


class Article(models.Model):
    """
    An Article within a Message which will be send through a Submission.
    """

    @classmethod
    def get_next_order(cls):
        """
        Get the next available Article ordering as to assure uniqueness.
        """

        next_order = cls.objects.aggregate(
            models.Max('sortorder')
        )['sortorder__max']

        if next_order:
            return next_order + 10
        else:
            return 10

    sortorder = models.PositiveIntegerField(
        help_text=_('Sort order determines the order in which articles are '
                    'concatenated in a post.'),
        verbose_name=_('sort order'), db_index=True,
        default=lambda: Article.get_next_order()
    )

    title = models.CharField(max_length=200, verbose_name=_('title'))
    text = models.TextField(verbose_name=_('text'))

    url = models.URLField(
        verbose_name=_('link'), blank=True, null=True
    )

    # Make this a foreign key for added elegance
    image = ImageField(
        upload_to='newsletter/images/%Y/%m/%d', blank=True, null=True,
        verbose_name=_('image')
    )

    # Message this article is associated with
    # TODO: Refactor post to message (post is legacy notation).
    post = models.ForeignKey(
        'Message', verbose_name=_('message'), related_name='articles'
    )

    class Meta:
        ordering = ('sortorder',)
        verbose_name = _('article')
        verbose_name_plural = _('articles')

    def __unicode__(self):
        return self.title


class Message(models.Model):
    """ Message as sent through a Submission. """

    title = models.CharField(max_length=200, verbose_name=_('title'))
    slug = models.SlugField(verbose_name=_('slug'))

    newsletter = models.ForeignKey(
        'Newsletter', verbose_name=_('newsletter'),
        default=Newsletter.get_default_id
    )

    date_create = models.DateTimeField(
        verbose_name=_('created'), auto_now_add=True, editable=False
    )
    date_modify = models.DateTimeField(
        verbose_name=_('modified'), auto_now=True, editable=False
    )

    def __unicode__(self):
        try:
            return _(u"%(title)s in %(newsletter)s") % {
                'title': self.title,
                'newsletter': self.newsletter
            }
        except Newsletter.DoesNotExist:
            logger.warn(
                'Database inconsistency, related newsletter not found '
                'for message with id %d', self.id
            )

            return "%s" % self.title

    class Meta:
        verbose_name = _('message')
        verbose_name_plural = _('messages')
        unique_together = ('slug', 'newsletter')

    @classmethod
    def get_default_id(cls):
        try:
            objs = cls.objects.all().order_by('-date_create')
            if not objs.count() == 0:
                return objs[0].id
        except:
            pass

        return None


class Submission(models.Model):
    """
    Submission represents a particular Message as it is being submitted
    to a list of Subscribers. This is where actual queueing and submission
    happends.
    """
    class Meta:
        verbose_name = _('submission')
        verbose_name_plural = _('submissions')

    def __unicode__(self):
        return _(u"%(newsletter)s on %(publish_date)s") % {
            'newsletter': self.message,
            'publish_date': self.publish_date
        }

    def submit(self):
        subscriptions = self.subscriptions.filter(subscribed=True)

        logger.info(
            ugettext(u"Submitting %(submission)s to %(count)d people"),
            {'submission': self, 'count': subscriptions.count()}
        )

        assert self.publish_date < now(), \
            'Something smells fishy; submission time in future.'

        self.sending = True
        self.save()

        try:
            (subject_template, text_template, html_template) = \
                self.message.newsletter.get_templates('message')

            for subscription in subscriptions:
                variable_dict = {
                    'subscription': subscription,
                    'site': Site.objects.get_current(),
                    'submission': self,
                    'message': self.message,
                    'newsletter': self.newsletter,
                    'date': self.publish_date,
                    'STATIC_URL': settings.STATIC_URL,
                    'MEDIA_URL': settings.MEDIA_URL
                }

                unescaped_context = Context(variable_dict, autoescape=False)

                subject = subject_template.render(unescaped_context).strip()
                text = text_template.render(unescaped_context)

                message = EmailMultiAlternatives(
                    subject, text,
                    from_email=self.newsletter.get_sender(),
                    to=[subscription.get_recipient()]
                )

                if html_template:
                    escaped_context = Context(variable_dict)

                    message.attach_alternative(
                        html_template.render(escaped_context),
                        "text/html"
                    )

                try:
                    logger.debug(
                        ugettext(u'Submitting message to: %s.'),
                        subscription
                    )

                    message.send()

                except Exception, e:
                    # TODO: Test coverage for this branch.
                    logger.error(
                        ugettext(u'Message %(subscription)s failed '
                                 u'with error: %(error)s'),
                        {'subscription': subscription,
                         'error': e}
                    )

            self.sent = True

        finally:
            self.sending = False
            self.save()

    @classmethod
    def submit_queue(cls):
        todo = cls.objects.filter(
            prepared=True, sent=False, sending=False,
            publish_date__lt=now()
        )

        for submission in todo:
            submission.submit()

    @classmethod
    def from_message(cls, message):
        logger.debug(ugettext('Submission of message %s'), message)
        submission = cls()
        submission.message = message
        submission.newsletter = message.newsletter
        submission.save()
        submission.subscriptions = message.newsletter.get_subscriptions()
        return submission

    def save(self):
        """ Set the newsletter from associated message upon saving. """
        assert self.message.newsletter

        self.newsletter = self.message.newsletter

        return super(Submission, self).save()

    @permalink
    def get_absolute_url(self):
        assert self.newsletter.slug
        assert self.message.slug

        return (
            'newsletter_archive_detail', (), {
                'newsletter_slug': self.newsletter.slug,
                'year': self.publish_date.year,
                'month': self.publish_date.month,
                'day': self.publish_date.day,
                'slug': self.message.slug
            }
        )

    newsletter = models.ForeignKey(
        'Newsletter', verbose_name=_('newsletter'), editable=False
    )
    message = models.ForeignKey(
        'Message', verbose_name=_('message'), editable=True,
        default=Message.get_default_id, null=False
    )

    subscriptions = models.ManyToManyField(
        'Subscription',
        help_text=_('If you select none, the system will automatically find '
                    'the subscribers for you.'),
        blank=True, db_index=True, verbose_name=_('recipients'),
        limit_choices_to={'subscribed': True}
    )

    publish_date = models.DateTimeField(
        verbose_name=_('publication date'), blank=True, null=True,
        default=now(), db_index=True
    )
    publish = models.BooleanField(
        default=True, verbose_name=_('publish'),
        help_text=_('Publish in archive.'), db_index=True
    )

    prepared = models.BooleanField(
        default=False, verbose_name=_('prepared'),
        db_index=True, editable=False
    )
    sent = models.BooleanField(
        default=False, verbose_name=_('sent'),
        db_index=True, editable=False
    )
    sending = models.BooleanField(
        default=False, verbose_name=_('sending'),
        db_index=True, editable=False
    )

########NEW FILE########
__FILENAME__ = settings
from django.conf import settings as django_settings
from django.utils.importlib import import_module
from django.core.exceptions import ImproperlyConfigured

from .utils import Singleton


class Settings(object):
    """
    A settings object that proxies settings and handles defaults, inspired
    by `django-appconf` and the way it works  in `django-rest-framework`.

    By default, a single instance of this class is created as `<app>_settings`,
    from which `<APP>_SETTING_NAME` can be accessed as `SETTING_NAME`, i.e.::

        from myapp.settings import myapp_settings

        if myapp_settings.SETTING_NAME:
            # DO FUNKY DANCE

    If a setting has not been explicitly defined in Django's settings, defaults
    can be specified as `DEFAULT_SETTING_NAME` class variable or property.
    """

    __metaclass__ = Singleton

    def __init__(self):
        """
        Assert app-specific prefix.
        """
        assert hasattr(self, 'settings_prefix'), 'No prefix specified.'

    def __getattr__(self, attr):
        """
        Return Django setting `PREFIX_SETTING` if explicitly specified,
        otherwise return `PREFIX_SETTING_DEFAULT` if specified.
        """

        if attr.isupper():
            # Require settings to have uppercase characters

            try:
                setting = getattr(
                    django_settings,
                    '%s_%s' % (self.settings_prefix, attr),
                )
            except AttributeError:
                if not attr.startswith('DEFAULT_'):
                    setting = getattr(self, 'DEFAULT_%s' % attr)
                else:
                    raise

            return setting

        else:
            # Default behaviour
            raise AttributeError(
                'No setting or default available for \'%s\'' % attr
            )


class NewsletterSettings(Settings):
    """ Django-newsletter specific settings. """
    settings_prefix = 'NEWSLETTER'

    DEFAULT_CONFIRM_EMAIL = True

    @property
    def DEFAULT_CONFIRM_EMAIL_SUBSCRIBE(self):
        return self.CONFIRM_EMAIL

    @property
    def DEFAULT_CONFIRM_EMAIL_UNSUBSCRIBE(self):
        return self.CONFIRM_EMAIL

    @property
    def DEFAULT_CONFIRM_EMAIL_UPDATE(self):
        return self.CONFIRM_EMAIL

    @property
    def RICHTEXT_WIDGET(self):
        # Import and set the richtext field
        NEWSLETTER_RICHTEXT_WIDGET = getattr(
            django_settings, "NEWSLETTER_RICHTEXT_WIDGET", ""
        )

        if NEWSLETTER_RICHTEXT_WIDGET:
            try:
                module, attr = NEWSLETTER_RICHTEXT_WIDGET.rsplit(".", 1)
                mod = import_module(module)
                return getattr(mod, attr)
            except Exception as e:
                # Catch ImportError and other exceptions too
                # (e.g. user sets setting to an integer)
                raise ImproperlyConfigured(
                    "Error while importing setting "
                    "NEWSLETTER_RICHTEXT_WIDGET %r: %s" % (
                        NEWSLETTER_RICHTEXT_WIDGET, e
                    )
                )

        return None

newsletter_settings = NewsletterSettings()

########NEW FILE########
__FILENAME__ = test_mailing
import itertools

from datetime import timedelta

from django.core import mail

from django.utils import unittest
from django.utils.timezone import now

from ..models import (
    Newsletter, Subscription, Submission, Message, Article, get_default_sites
)
from ..utils import ACTIONS

from .utils import MailTestCase, UserTestCase, template_exists


class MailingTestCase(MailTestCase):

    def get_newsletter_kwargs(self):
        """ Returns the keyword arguments for instanciating the newsletter. """

        return {
            'title': 'Test newsletter',
            'slug': 'test-newsletter',
            'sender': 'Test Sender',
            'email': 'test@testsender.com'
        }

    def setUp(self):
        self.n = Newsletter(**self.get_newsletter_kwargs())
        self.n.save()
        self.n.site = get_default_sites()

        self.m = Message(title='Test message',
                         newsletter=self.n,
                         slug='test-message')
        self.m.save()

        self.s = Subscription(
            name='Test Name', email='test@test.com',
            newsletter=self.n, subscribed=True
        )
        self.s.save()

    def send_email(self, action):
        assert action in ACTIONS + ('message', ), 'Unknown action: %s' % action

        if action == 'message':
            # Create submission
            sub = Submission.from_message(self.m)
            sub.prepared = True
            sub.publish_date = now() - timedelta(seconds=1)
            sub.save()

            # Send message email
            Submission.submit_queue()
        else:
            self.s.send_activation_email(action)


class ArticleTestCase(MailingTestCase):
    def make_article(self):
        a = Article()
        a.title = 'Test title'
        a.text = 'This should be a very long text with <html> in it as well.'
        a.post = self.m
        a.save()

        return a

    def update(self, article):
        return Article.objects.get(pk=article.pk)

    def test_article(self):
        self.make_article()

    def test_sortorder_defaults(self):
        total = 3

        last = 0
        for current in xrange(total):
            a = self.make_article()
            if last:
                self.assert_(a.sortorder > last)
            last = a.sortorder


class CreateSubmissionTestCase(MailingTestCase):
    def test_subscription(self):
        """ Test whether the recipient corresponds for Subscription. """

        self.assertEqual(self.s.get_recipient(), 'Test Name <test@test.com>')

    def test_submission_from_message(self):
        """ Test creating a submission from a message. """

        sub = Submission.from_message(self.m)

        subscriptions = sub.subscriptions.all()
        self.assertEqual(list(subscriptions), [self.s])

        self.assertFalse(sub.prepared)
        self.assertFalse(sub.sent)
        self.assertFalse(sub.sending)

    def test_submission_subscribed(self):
        """ Test a simpel submission with single subscriber. """

        self.s.subscribed = False
        self.s.save()

        sub = Submission.from_message(self.m)

        subscriptions = sub.subscriptions.all()
        self.assertEqual(list(subscriptions), [])

    def test_submission_unsubscribed(self):
        """ Test submission with unsubscribed activated subscriber. """

        self.s.unsubscribed = True
        self.s.save()

        sub = Submission.from_message(self.m)

        subscriptions = sub.subscriptions.all()
        self.assertEqual(list(subscriptions), [])

    def test_submission_unsubscribed_unactivated(self):
        """ Test submissions with unsubscribed unactivated subscriber. """

        self.s.subscribed = False
        self.s.unsubscribed = True
        self.s.save()

        sub = Submission.from_message(self.m)

        subscriptions = sub.subscriptions.all()
        self.assertEqual(list(subscriptions), [])

    def test_twosubmissions(self):
        """ Test submission with two activated subscribers. """

        s2 = Subscription(
            name='Test Name 2', email='test2@test.com',
            newsletter=self.n, subscribed=True
        )
        s2.save()

        sub = Submission.from_message(self.m)

        subscriptions = sub.subscriptions.all()
        self.assert_(self.s in list(subscriptions))
        self.assert_(s2 in list(subscriptions))

    def test_twosubmissions_unsubscried(self):
        """ Test submission with two subscribers, one unactivated. """

        s2 = Subscription(
            name='Test Name 2', email='test2@test.com',
            newsletter=self.n, subscribed=False
        )
        s2.save()

        sub = Submission.from_message(self.m)

        subscriptions = sub.subscriptions.all()
        self.assertEqual(list(subscriptions), [self.s])


class SubmitSubmissionTestCase(MailingTestCase):
    def setUp(self):
        super(SubmitSubmissionTestCase, self).setUp()

        self.sub = Submission.from_message(self.m)
        self.sub.save()

    def test_submission(self):
        """ Assure initial Submission is in expected state. """

        self.assertFalse(self.sub.prepared)
        self.assertFalse(self.sub.sent)
        self.assertFalse(self.sub.sending)

    def test_nosubmit(self):
        """ Assure nothing happends if not prepared. """

        # Assure nothing happends
        Submission.submit_queue()

        self.assertFalse(self.sub.prepared)
        self.assertFalse(self.sub.sent)
        self.assertFalse(self.sub.sending)

    def test_submitsubmission(self):
        """ Test queue-based submission. """

        self.sub.prepared = True
        self.sub.publish_date = now() - timedelta(seconds=1)
        self.sub.save()

        Submission.submit_queue()

        # Get the object fresh from DB, as to assure no caching takes place
        submission = Submission.objects.get(pk=self.sub.pk)

        self.assert_(submission.sent)
        self.assertFalse(submission.sending)

        # Make sure mail is being sent out
        self.assertEquals(len(mail.outbox), 1)

        # Make sure a submission contains the title and unsubscribe URL
        self.assertEmailContains(submission.message.title)
        self.assertEmailContains(submission.newsletter.unsubscribe_url())


class SubscriptionTestCase(UserTestCase, MailingTestCase):
    def setUp(self):
        super(SubscriptionTestCase, self).setUp()

        self.us = Subscription(user=self.user, newsletter=self.n)
        self.us.save()

        self.ns = Subscription(
            name='Test susbcriber', newsletter=self.n,
            email='test@test.com'
        )
        self.ns.save()

        self.ss = [self.us, self.ns]

    def test_usersubscription(self):
        self.assertEqual(self.us.name, self.user.get_full_name())
        self.assertEqual(self.us.email, self.user.email)

    def test_subscribe_unsubscribe(self):
        for s in self.ss:
            self.assertFalse(s.subscribed)
            self.assertFalse(s.unsubscribed)
            self.assertFalse(s.subscribe_date)
            self.assertFalse(s.unsubscribe_date)

            # Repeat this to ensure consequencentness
            for x in xrange(2):
                s.subscribed = True
                s.save()

                self.assert_(s.subscribed)
                self.assert_(s.subscribe_date)
                self.assertFalse(s.unsubscribed)
                old_subscribe_date = s.subscribe_date

                s.unsubscribed = True
                s.save()

                self.assertFalse(s.subscribed)
                self.assert_(s.unsubscribed)
                self.assert_(s.unsubscribe_date)

                s.unsubscribed = False
                s.save()

                self.assertFalse(s.unsubscribed)
                self.assert_(s.subscribed)
                self.assertNotEqual(s.subscribe_date, old_subscribe_date)


class AllEmailsTestsMixin(object):
    """ Mixin for testing properties of sent e-mails for all message types. """

    def assertSentEmailIsProper(self, action):
        """
        This method should be overridden in subclasses.
        Assertions identical for all message types should be in this method.
        """

        raise NotImplementedError(
            '%(class_name)s inherits from of AllEmailsTestsMixin '
            'and should define assertSentEmailIsProper method.' % {
                'class_name': self.__class__.__name__
            }
        )

    def test_subscription_email(self):
        """ Assure subscription email is proper. """

        self.send_email('subscribe')

        self.assertSentEmailIsProper('subscribe')

    def test_unsubscription_email(self):
        """ Assure unsubscription email is proper. """

        self.send_email('unsubscribe')

        self.assertSentEmailIsProper('unsubscribe')

    def test_update_email(self):
        """ Assure update email is proper. """

        self.send_email('update')

        self.assertSentEmailIsProper('update')

    def test_message_email(self):
        """ Assure message email is proper. """

        self.send_email('message')

        self.assertSentEmailIsProper('message')


class HtmlEmailsTestCase(MailingTestCase, AllEmailsTestsMixin):
    """
    TestCase for testing whether e-mails sent for newsletter
    with send_html=True have HTML alternatives.
    """

    def get_newsletter_kwargs(self):
        """
        Update keyword arguments for instanciating the newsletter
        with send_html = True.
        """

        kwargs = super(HtmlEmailsTestCase, self).get_newsletter_kwargs()
        kwargs.update(send_html=True)

        return kwargs

    def assertSentEmailIsProper(self, action):
        """
        Assert that there's exactly one email in outbox
        and that it contains alternative with mimetype text/html.
        """

        # Make sure one mail is being sent out
        self.assertEquals(len(mail.outbox), 1)

        # Make sure mail contains HTML alternative
        self.assertEmailAlternativesContainMimetype('text/html')


class TextOnlyEmailsTestCase(MailingTestCase, AllEmailsTestsMixin):
    """
    TestCase for testing whether e-mails sent for newsletter
    with send_html=False are text only.
    """

    def get_newsletter_kwargs(self):
        """
        Update keyword arguments for instanciating the newsletter
        with send_html = False.
        """

        kwargs = super(TextOnlyEmailsTestCase, self).get_newsletter_kwargs()
        kwargs.update(send_html=False)

        return kwargs

    def assertSentEmailIsProper(self, action):
        """
        Assert that there's exactly one email in outbox
        and that it has no alternative content types.
        """

        # Make sure one mail is being sent out
        self.assertEquals(len(mail.outbox), 1)

        # Make sure mail is text only
        self.assertEmailHasNoAlternatives()


template_overrides = (
    'newsletter/message/test-newsletter-with-overrides/' + action + suff
    for action, suff in itertools.product(
        ('subscribe', 'update', 'unsubscribe', 'message'),
        ('_subject.txt', '.txt', '.html')
    )
)


# When tests are run outside test project
# test templates overrides will not exist,
# so skip their testing.
@unittest.skipUnless(
    all(
        template_exists(template_name) for template_name in template_overrides
    ),
    'Test templates overrides not found.'
)
class TemplateOverridesTestCase(MailingTestCase, AllEmailsTestsMixin):
    """
    TestCase for testing template overrides for specific newsletters.
    """

    def get_newsletter_kwargs(self):
        """
        Update keyword arguments for instanciating the newsletter
        so that slug corresponds to one for which template overrides exists
        and make sure e-mails will be sent with text and HTML versions.
        """

        kwargs = super(TemplateOverridesTestCase, self).get_newsletter_kwargs()
        kwargs.update(slug='test-newsletter-with-overrides',
                      send_html=True)

        return kwargs

    def assertSentEmailIsProper(self, action):
        """
        Assert that there's exactly one email in outbox
        and that it contains proper strings from template overrides
        in subject and body.
        """

        # Make sure one mail is being sent out
        self.assertEquals(len(mail.outbox), 1)

        # Make sure mail subject contains string
        # from template override for given action
        self.assertEmailSubjectContains(
            'override for %s_subject.txt' % action
        )

        # Make sure body of mail text version contains string
        # from text template override for given action
        self.assertEmailBodyContains('override for %s.txt' % action)

        # Make sure body of mail HTML version contains string
        # from HTML template override for given action
        self.assertEmailAlternativeBodyContains(
            'override for %s.html' % action
        )

########NEW FILE########
__FILENAME__ = test_settings
from django.utils import unittest

from django.conf import settings

from django.test import TestCase
from django.test.utils import override_settings

from django.core.exceptions import ImproperlyConfigured

from newsletter.settings import newsletter_settings


class SettingsTestCase(TestCase):
    @override_settings(NEWSLETTER_RICHTEXT_WIDGET='banana.nowaythisexists')
    def test_editor_nonexistent(self):
        """
        Setting nonexistant newsletter widget yields ImproperlyConfigured.
        """

        self.assertRaises(
            ImproperlyConfigured, lambda: newsletter_settings.RICHTEXT_WIDGET
        )

    @unittest.skipUnless(
        # Only run tests when TinyMCE is available
        'tinymce' in settings.INSTALLED_APPS,
        'django-tinymce not available for testing.'
    )
    @override_settings(
        # Filter imperavi from editors so just tinymce is left
        INSTALLED_APPS=filter(
            lambda app: app != 'imperavi', settings.INSTALLED_APPS
        ),
        NEWSLETTER_RICHTEXT_WIDGET='tinymce.widgets.TinyMCE'
    )
    def test_editor_tinymce(self):
        """
        Test explicit setting TinyMCE as editor.
        """

        from tinymce.widgets import TinyMCE
        self.assertEquals(newsletter_settings.RICHTEXT_WIDGET, TinyMCE)

    @unittest.skipUnless(
        # Only run tests when TinyMCE is available
        'imperavi' in settings.INSTALLED_APPS,
        'django-imperavi not available for testing.'
    )
    @override_settings(
        # Filter tinymce from editors so just imparavi is left
        INSTALLED_APPS=filter(
            lambda app: app != 'tinymce', settings.INSTALLED_APPS
        ),
        NEWSLETTER_RICHTEXT_WIDGET='imperavi.widget.ImperaviWidget'
    )
    def test_editor_imperavi(self):
        """
        Test explicit setting Imperavi as editor.
        """

        from imperavi.admin import ImperaviWidget
        self.assertEquals(newsletter_settings.RICHTEXT_WIDGET, ImperaviWidget)

    @unittest.skipIf(
        hasattr(settings, 'NEWSLETTER_CONFIRM_EMAIL_SUBSCRIBE') or
        hasattr(settings, 'NEWSLETTER_CONFIRM_EMAIL_UNSUBSCRIBE') or
        hasattr(settings, 'NEWSLETTER_CONFIRM_EMAIL_UPDATE'),
        'Confirmation e-mail defaults overridden by Django settings.'
    )
    def test_confirm_default(self):
        """
        Test whether e-mail confirmation defaults come through.
        """
        self.assertTrue(newsletter_settings.CONFIRM_EMAIL_SUBSCRIBE)
        self.assertTrue(newsletter_settings.CONFIRM_EMAIL_UNSUBSCRIBE)
        self.assertTrue(newsletter_settings.CONFIRM_EMAIL_UPDATE)

    @override_settings(
        NEWSLETTER_CONFIRM_EMAIL_SUBSCRIBE=False
    )
    def test_confirm_subscribe_override(self):
        """
        Test whether e-mail confirmation overrides come through.
        """
        self.assertFalse(newsletter_settings.CONFIRM_EMAIL_SUBSCRIBE)

    @override_settings(
        NEWSLETTER_CONFIRM_EMAIL_UNSUBSCRIBE=False
    )
    def test_confirm_unsubscribe_override(self):
        """
        Test whether e-mail confirmation overrides come through.
        """
        self.assertFalse(newsletter_settings.CONFIRM_EMAIL_UNSUBSCRIBE)

    @override_settings(
        NEWSLETTER_CONFIRM_EMAIL_UPDATE=False
    )
    def test_confirm_update_override(self):
        """
        Test whether e-mail confirmation overrides come through.
        """
        self.assertFalse(newsletter_settings.CONFIRM_EMAIL_UPDATE)

########NEW FILE########
__FILENAME__ = test_web
# Python 2.5 compatibility
# Get the with statement from the future
from __future__ import with_statement

from datetime import datetime, timedelta

import time

# Conditioally import pytz
try:
    import pytz
except ImportError:
    pytz = None

from django import VERSION as DJANGO_VERSION

from django.core import mail
from django.core.urlresolvers import reverse

from django.utils import unittest, timezone

from django.test.utils import override_settings

from ..models import (
    Newsletter, Subscription, Submission, Message, get_default_sites
)

from ..forms import UpdateForm

from ..utils import get_user_model
User = get_user_model()

from .utils import MailTestCase, UserTestCase, WebTestCase, ComparingTestCase


# Amount of seconds to wait to test time comparisons in submissions.
WAIT_TIME = 1


class NewsletterListTestCase(WebTestCase):
    """ Base class for newsletter test cases. """

    fixtures = ['test_newsletters']

    def setUp(self):
        self.newsletters = Newsletter.objects.all()

        self.list_url = reverse('newsletter_list')


class AnonymousNewsletterListTestCase(NewsletterListTestCase):
    """ Test case for anonymous views of newsletter. """

    def test_emptylist(self):
        """ No newsletters should yield an emtpy list. """

        # Delete existing newsletters
        Newsletter.objects.all().delete()

        # Assert a 404 is returned
        response = self.client.get(self.list_url)
        self.assertEqual(response.status_code, 404)

    def test_list(self):
        """
        Test whether all newsletters are in the list and whether the links
        to them are correct.
        """
        response = self.client.get(self.list_url)

        for n in self.newsletters.filter(visible=True):
            self.assertContains(response, n.title)

            detail_url = reverse('newsletter_detail',
                                 kwargs={'newsletter_slug': n.slug})
            self.assertContains(response, '<a href="%s">' % detail_url)

        for n in self.newsletters.filter(visible=False):
            self.assertNotContains(response, n.title)

    def test_detail(self):
        for n in self.newsletters:

            detail_url = reverse(
                'newsletter_detail',
                kwargs={'newsletter_slug': n.slug}
            )

            subscribe_url = reverse(
                'newsletter_subscribe_request',
                kwargs={'newsletter_slug': n.slug}
            )

            unsubscribe_url = reverse(
                'newsletter_unsubscribe_request',
                kwargs={'newsletter_slug': n.slug}
            )

            update_url = reverse(
                'newsletter_update_request',
                kwargs={'newsletter_slug': n.slug}
            )

            archive_url = reverse(
                'newsletter_archive',
                kwargs={'newsletter_slug': n.slug}
            )

            # Check returned URL's exist and equal result of lookup methods
            self.assertTrue(subscribe_url)
            self.assertEquals(subscribe_url, n.subscribe_url())

            self.assertTrue(unsubscribe_url)
            self.assertEquals(unsubscribe_url, n.unsubscribe_url())

            self.assertTrue(update_url)
            self.assertEquals(update_url, n.update_url())

            self.assertTrue(archive_url)
            self.assertEquals(archive_url, n.archive_url())

            # Request detail URL and assert it links to all other URL's
            response = self.client.get(detail_url)

            if not n.visible:
                self.assertEqual(response.status_code, 404)
                continue

            self.assertContains(response, subscribe_url)
            self.assertContains(response, update_url)
            self.assertContains(response, unsubscribe_url)
            self.assertContains(response, archive_url)

            # Request each particular newsletter URL and assert
            # it returns a 200
            response = self.client.get(subscribe_url)
            self.assertContains(response, n.title, status_code=200)

            response = self.client.get(unsubscribe_url)
            self.assertContains(response, n.title, status_code=200)

            response = self.client.get(update_url)
            self.assertContains(response, n.title, status_code=200)

            response = self.client.get(archive_url)
            self.assertContains(response, n.title, status_code=200)

    def test_detail_invisible_not_found(self):
        """
        Test whether an invisible newsletter causes a 404 in detail view.
        """

        # Get an invisible newsletter
        n = Newsletter.objects.filter(visible=False)[0]

        detail_url = reverse(
            'newsletter_detail',
            kwargs={'newsletter_slug': n.slug}
        )

        response = self.client.get(detail_url)

        self.assertEquals(response.status_code, 404)


class UserNewsletterListTestCase(UserTestCase,
                                 NewsletterListTestCase):

    def get_user_subscription(self, newsletter):
        subscriptions = Subscription.objects.filter(newsletter=newsletter,
                                                    user=self.user)
        self.assertEqual(subscriptions.count(), 1)

        subscription = subscriptions[0]
        self.assert_(subscription.create_date)

        return subscriptions[0]

    def test_listform(self):
        """ Test whether form elements are present in list. """

        response = self.client.get(self.list_url)

        formset = response.context['formset']
        total_forms = len(formset.forms)

        self.assertEqual(
            total_forms, len(self.newsletters.filter(visible=True))
        )

        if DJANGO_VERSION[:2] == (1, 4):
            # Django 1.4
            self.assertContains(
                response,
                '<input type="hidden" name="form-TOTAL_FORMS" value="%d" '
                'id="id_form-TOTAL_FORMS" />' % total_forms
            )

            self.assertContains(
                response,
                '<input type="hidden" name="form-INITIAL_FORMS" value="%d" '
                'id="id_form-INITIAL_FORMS" />' % total_forms
            )

        else:
            # Django 1.5
            self.assertContains(
                response,
                '<input id="id_form-TOTAL_FORMS" name="form-TOTAL_FORMS" '
                'type="hidden" value="%d" />' % total_forms
            )

            self.assertContains(
                response,
                '<input id="id_form-INITIAL_FORMS" name="form-INITIAL_FORMS" '
                'type="hidden" value="%d" />' % total_forms
            )

        for form in formset.forms:
            self.assert_(
                form.instance.newsletter in self.newsletters,
                "%s not in %s" % (form.instance.newsletter, self.newsletters)
            )
            self.assertContains(response, form['id'])
            self.assertContains(response, form['subscribed'])

    def test_update(self):
        """ Attempt to subscribe a user to newsletters. """

        # Make sure no subscriptions exist on beforehand
        Subscription.objects.all().delete()

        # Construct management form data
        total_forms = self.newsletters.filter(visible=True).count()

        params = {
            'form-TOTAL_FORMS': total_forms,
            'form-INITIAL_FORMS': total_forms
        }

        # Add subscribe to all newsletters
        count = 0
        for n in self.newsletters.filter(visible=True):
            params.update({
                'form-%d-id' % count: n.id,
                'form-%d-subscribed' % count: '1'
            })

            count += 1

        # Post the form
        response = self.client.post(self.list_url, params)

        # Make sure the result is a success
        self.assertEquals(response.status_code, 200)

        subscriptions = Subscription.objects.filter(
            user=self.user
        )

        # Assert all newsletters have related subscriptions now
        self.assertTrue(subscriptions.count())
        self.assertEquals(
            subscriptions.count(),
            self.newsletters.filter(visible=True).count()
        )

    def test_invalid_update(self):
        """ Test an invalid update, which should fail. """
        # Make sure no subscriptions exist on beforehand
        Subscription.objects.all().delete()

        # TODO: Use a Mock to assert a warning has been logged
        # Ref: http://www.michaelpollmeier.com/python-mock-how-to-assert-a-substring-of-logger-output/

        # A post without any form elements should fail, horribly
        self.client.post(self.list_url)

        # A post with correct management data with weird values
        # should cause the formset not to validate.

        # Construct management form data
        total_forms = self.newsletters.filter(visible=True).count()

        params = {
            'form-TOTAL_FORMS': total_forms,
            'form-INITIAL_FORMS': total_forms
        }

        # Add subscribe to all newsletters
        count = 0
        for n in self.newsletters.filter(visible=True):
            params.update({
                # Use a wrong value here
                'form-%d-id' % count: 1000,
                'form-%d-subscribed' % count: '1'
            })

            count += 1

        # Post the form
        self.client.post(self.list_url, params)

        # Assert no subscriptions have been created
        self.assertFalse(
            Subscription.objects.filter(subscribed=True).exists())


class SubscribeTestCase(WebTestCase, MailTestCase):

    def setUp(self):
        self.n = Newsletter(title='Test newsletter',
                            slug='test-newsletter',
                            sender='Test Sender',
                            email='test@testsender.com')
        self.n.save()
        self.n.site = get_default_sites()

        self.subscribe_url = \
            reverse('newsletter_subscribe_request',
                    kwargs={'newsletter_slug': self.n.slug})
        self.subscribe_confirm_url = \
            reverse('newsletter_subscribe_confirm',
                    kwargs={'newsletter_slug': self.n.slug})
        self.subscribe_email_sent_url = \
            reverse('newsletter_activation_email_sent',
                    kwargs={'newsletter_slug': self.n.slug,
                            'action': 'subscribe'})
        self.subscribe_activated_url = \
            reverse('newsletter_action_activated',
                    kwargs={'newsletter_slug': self.n.slug,
                            'action': 'subscribe'})

        self.update_url = \
            reverse('newsletter_update_request',
                    kwargs={'newsletter_slug': self.n.slug})
        self.update_email_sent_url = \
            reverse('newsletter_activation_email_sent',
                    kwargs={'newsletter_slug': self.n.slug,
                            'action': 'update'})
        self.update_activated_url = \
            reverse('newsletter_action_activated',
                    kwargs={'newsletter_slug': self.n.slug,
                            'action': 'update'})

        self.unsubscribe_url = \
            reverse('newsletter_unsubscribe_request',
                    kwargs={'newsletter_slug': self.n.slug})
        self.unsubscribe_confirm_url = \
            reverse('newsletter_unsubscribe_confirm',
                    kwargs={'newsletter_slug': self.n.slug})
        self.unsubscribe_email_sent_url = \
            reverse('newsletter_activation_email_sent',
                    kwargs={'newsletter_slug': self.n.slug,
                            'action': 'unsubscribe'})
        self.unsubscribe_activated_url = \
            reverse('newsletter_action_activated',
                    kwargs={'newsletter_slug': self.n.slug,
                            'action': 'unsubscribe'})

        super(SubscribeTestCase, self).setUp()

    def test_urls(self):
        # TODO: is performing this test in each subclass
        #     of WebSubscribeTestCase really needed?
        self.assert_(self.subscribe_url)
        self.assert_(self.update_url)
        self.assert_(self.unsubscribe_url)
        self.assert_(self.subscribe_confirm_url)
        self.assert_(self.unsubscribe_confirm_url)
        self.assert_(self.subscribe_email_sent_url)
        self.assert_(self.update_email_sent_url)
        self.assert_(self.unsubscribe_email_sent_url)
        self.assert_(self.subscribe_activated_url)
        self.assert_(self.update_activated_url)
        self.assert_(self.unsubscribe_activated_url)


class UserSubscribeTestCase(
    SubscribeTestCase,
    UserTestCase,
    ComparingTestCase
):
    """ Test case for user subscription and unsubscription."""

    def get_user_subscription(self):
        subscriptions = Subscription.objects.filter(newsletter=self.n,
                                                    user=self.user)
        self.assertEqual(subscriptions.count(), 1)

        subscription = subscriptions[0]
        self.assert_(subscription.create_date)

        return subscriptions[0]

    def test_subscribe_view(self):
        """ Test the subscription form. """
        response = self.client.get(self.subscribe_url)

        self.assertContains(response, self.n.title, status_code=200)

        self.assertEqual(response.context['newsletter'], self.n)
        self.assertEqual(response.context['user'], self.user)

        self.assertContains(
            response,
            'action="%s"' % self.subscribe_confirm_url
        )
        self.assertContains(response, 'id="id_submit"')

        subscription = self.get_user_subscription()
        self.assertFalse(subscription.subscribed)
        self.assertFalse(subscription.unsubscribed)

    def test_subscribe_post(self):
        """ Test subscription confirmation. """
        response = self.client.post(self.subscribe_confirm_url)

        self.assertContains(response, self.n.title, status_code=200)

        self.assertEqual(response.context['newsletter'], self.n)
        self.assertEqual(response.context['user'], self.user)

        subscription = self.get_user_subscription()
        self.assert_(subscription.subscribed)
        self.assertFalse(subscription.unsubscribed)

    def test_subscribe_twice(self):
        # After subscribing we should not be able to subscribe again
        subscription = Subscription(user=self.user, newsletter=self.n)
        subscription.subscribed = True
        subscription.unsubscribed = False
        subscription.save()

        response = self.client.get(self.subscribe_url)

        self.assertContains(response, self.n.title, status_code=200)

        self.assertEqual(response.context['newsletter'], self.n)
        self.assertEqual(response.context['user'], self.user)

        self.assertNotContains(
            response, 'action="%s"' % self.subscribe_confirm_url)
        self.assertNotContains(response, 'id="id_submit"')

    def test_unsubscribe_view(self):
        """ Test the unsubscription form. """
        subscription = Subscription(user=self.user, newsletter=self.n)
        subscription.subscribed = True
        subscription.unsubscribed = False
        subscription.save()

        self.assertLessThan(
            subscription.subscribe_date, timezone.now() + timedelta(seconds=1)
        )

        response = self.client.get(self.unsubscribe_url)

        self.assertContains(response, self.n.title, status_code=200)

        self.assertEqual(response.context['newsletter'], self.n)
        self.assertEqual(response.context['user'], self.user)

        self.assertContains(
            response, 'action="%s"' % self.unsubscribe_confirm_url)
        self.assertContains(response, 'id="id_submit"')

        subscription = self.get_user_subscription()
        self.assert_(subscription.subscribed)
        self.assertFalse(subscription.unsubscribed)

    def test_unsubscribe_not_subscribed_view(self):
        """
        Test attempting to unsubscriped a user without a subscription.
        """

        response = self.client.get(self.unsubscribe_url)

        self.assertIn(
            'You are not subscribed to',
            unicode(list(response.context['messages'])[0])
        )

    def test_unsubscribe_post(self):
        """ Test unsubscription confirmation. """
        subscription = Subscription(user=self.user, newsletter=self.n)
        subscription.subscribed = True
        subscription.unsubscribed = False
        subscription.save()

        response = self.client.post(self.unsubscribe_confirm_url)

        self.assertContains(response, self.n.title, status_code=200)

        self.assertEqual(response.context['newsletter'], self.n)
        self.assertEqual(response.context['user'], self.user)

        subscription = self.get_user_subscription()
        self.assertFalse(subscription.subscribed)
        self.assert_(subscription.unsubscribed)
        self.assertLessThan(
            subscription.unsubscribe_date,
            timezone.now() + timedelta(seconds=1)
        )

    def test_unsubscribe_twice(self):
        subscription = Subscription(user=self.user, newsletter=self.n)
        subscription.subscribed = False
        subscription.unsubscribed = True
        subscription.save()

        response = self.client.get(self.unsubscribe_url)

        self.assertContains(response, self.n.title, status_code=200)

        self.assertEqual(response.context['newsletter'], self.n)
        self.assertEqual(response.context['user'], self.user)

        self.assertNotContains(
            response,
            'action="%s"' % self.unsubscribe_confirm_url
        )
        self.assertNotContains(response, 'id="id_submit"')


class AnonymousSubscribeTestCase(
    SubscribeTestCase,
    ComparingTestCase
):

    def get_only_subscription(self, **kwargs):
        """
        Assert there's exactly one subscription that match kwargs lookup.
        Return this subscription.
        """

        subscription_qs = self.n.subscription_set.filter(**kwargs)

        self.assertEquals(subscription_qs.count(), 1)

        return subscription_qs[0]

    def test_subscribe_request_view(self):
        """ Test the subscription form. """

        response = self.app.get(self.subscribe_url)

        self.assertContains(response, self.n.title, status_code=200)

        self.assertIn('name_field', response.form.fields)
        self.assertIn('email_field', response.form.fields)

        self.assertEqual(response.context['newsletter'], self.n)

    @override_settings(NEWSLETTER_CONFIRM_EMAIL_SUBSCRIBE=True)
    def test_subscribe_request_post(self):
        """ Post the subscription form. """

        response = self.client.post(
            self.subscribe_url, {
                'name_field': 'Test Name',
                'email_field': 'test@email.com'
            }
        )

        # Assure we are redirected to "subscribe activation email sent" page.
        self.assertRedirects(response, self.subscribe_email_sent_url)

        subscription = self.get_only_subscription(
            email_field__exact='test@email.com'
        )

        self.assertFalse(subscription.subscribed)
        self.assertFalse(subscription.unsubscribed)

        """ Check the subscription email. """
        self.assertEquals(len(mail.outbox), 1)

        activate_url = subscription.subscribe_activate_url()
        full_activate_url = 'http://%s%s' % (self.site.domain, activate_url)

        self.assertEmailContains(full_activate_url)

    @override_settings(NEWSLETTER_CONFIRM_EMAIL_SUBSCRIBE=False)
    def test_subscribe_request_post_no_email(self):
        """
        Post the subscription form
        with confirmation email switched off in settings.
        """

        response = self.client.post(
            self.subscribe_url, {
                'name_field': 'Test Name',
                'email_field': 'test@email.com'
            }
        )

        # Assure we are redirected to "subscribe activated" page.
        self.assertRedirects(response, self.subscribe_activated_url)

        subscription = self.get_only_subscription(
            email_field__exact='test@email.com'
        )

        # email confirmation is switched off,
        # so after subscribe request user should be subscribed
        self.assertTrue(subscription.subscribed)
        self.assertFalse(subscription.unsubscribed)

        """ Check the subscription email. """
        # no email should be send
        self.assertEquals(len(mail.outbox), 0)

    # Only run this test when settings overrides are available
    @override_settings(NEWSLETTER_CONFIRM_EMAIL_SUBSCRIBE=True)
    def test_subscribe_request_post_error(self):
        """
        Test whether a failing subscribe request email generated an error in
        the context.

        We do this by overriding the default mail backend to a settings which
        we know pretty sure is bound to fail.
        """

        with override_settings(
            EMAIL_BACKEND='django.core.mail.backends.smtp.EmailBackend'
        ):
            with override_settings(EMAIL_PORT=12345678):
                response = self.client.post(
                    self.subscribe_url, {
                        'name_field': 'Test Name',
                        'email_field': 'test@ifjoidjsufhdsidhsuufihs.dfs'
                    }
                )

        self.assertTrue(response.context['error'])

    def test_retry_subscribe(self):
        """
        When requesting a subscription for an e-mail address for which
        an unconfirmed subscription is already available, make sure
        only one subscription object gets created.

        This is a regression of #14 on GitHub.
        """

        self.assertEquals(Subscription.objects.all().count(), 0)

        # Request subscription
        self.client.post(
            self.subscribe_url, {
                'name_field': 'Test Name',
                'email_field': 'test@email.com'
            }
        )

        self.assertEquals(Subscription.objects.all().count(), 1)

        # Request subscription
        self.client.post(
            self.subscribe_url, {
                'name_field': 'Test Name',
                'email_field': 'test@email.com'
            }
        )

        self.assertEquals(Subscription.objects.all().count(), 1)

    def test_subscribe_twice(self):
        """ Subscribing twice should not be possible. """

        subscription = Subscription(newsletter=self.n,
                                    name='Test Name',
                                    email='test@email.com',
                                    subscribed=True)
        subscription.save()

        response = self.client.post(
            self.subscribe_url, {
                'name_field': 'Test Name',
                'email_field': 'test@email.com'
            }
        )

        self.assertContains(response, "already been subscribed to",
                            status_code=200)

    def test_subscribe_unsubscribed(self):
        """
        After having been unsubscribed, a user should be able to subscribe
        again.

        This relates to #5 on GitHub.
        """

        # Create a subscription
        subscription = Subscription(newsletter=self.n,
                                    name='Test Name',
                                    email='test@email.com',
                                    subscribed=True)
        subscription.save()

        # Unsubscribe
        response = self.client.post(
            subscription.unsubscribe_activate_url(),
            {
                'name_field': subscription.name,
                'email_field': subscription.email,
                'user_activation_code': subscription.activation_code
            }
        )

        # Assure we are redirected to "unsubscribe activated" page.
        self.assertRedirects(response, self.unsubscribe_activated_url)

        subscription = self.get_only_subscription(
            email_field__exact='test@email.com'
        )

        self.assertFalse(subscription.subscribed)
        self.assert_(subscription.unsubscribed)

        # Resubscribe request
        response = self.client.post(
            self.subscribe_url,
            {
                'name_field': subscription.name,
                'email_field': subscription.email,
            }
        )

        # Assure we are redirected to "email sent page"
        self.assertRedirects(response, self.subscribe_email_sent_url)

        # self.assertFalse(subscription.subscribed)
        self.assert_(subscription.unsubscribed)

        # Activate subscription
        response = self.client.post(
            subscription.subscribe_activate_url(),
            {
                'name_field': subscription.name,
                'email_field': subscription.email,
                'user_activation_code': subscription.activation_code
            }
        )

        # Assure we are redirected to "subscribe activated" page.
        self.assertRedirects(response, self.subscribe_activated_url)

        subscription = self.get_only_subscription(
            email_field__exact='test@email.com'
        )

        self.assert_(subscription.subscribed)
        self.assertFalse(subscription.unsubscribed)

    def test_user_update(self):
        """
        We should not be able to update anonymous for an email address
        belonging to an existing user.
        """

        password = User.objects.make_random_password()
        user = User.objects.create_user(
            'john', 'lennon@thebeatles.com', password)
        user.save()

        # Attempt to subscribe with user email address
        for url in (self.subscribe_url, self.update_url, self.unsubscribe_url):
            response = self.client.post(
                url, {
                    'name_field': 'Test Name',
                    'email_field': user.email
                }
            )

            self.assertContains(
                response,
                "Please log in as that user and try again.",
                status_code=200
            )

    def test_subscribe_request_activate(self):
        """ Test subscription activation. """

        subscription = Subscription(newsletter=self.n,
                                    name='Test Name',
                                    email='test@email.com')
        subscription.save()

        time.sleep(WAIT_TIME)

        self.assertFalse(subscription.subscribed)

        activate_url = subscription.subscribe_activate_url()
        self.assert_(activate_url)

        response = self.client.get(activate_url)
        self.assertInContext(response, 'form', UpdateForm)
        self.assertContains(response, subscription.activation_code)

        response = self.client.post(
            activate_url, {
                'name_field': 'Test Name',
                'email_field': 'test@email.com',
                'user_activation_code': subscription.activation_code
            }
        )

        # Assure we are redirected to "subscribe activated" page.
        self.assertRedirects(response, self.subscribe_activated_url)

        subscription = self.get_only_subscription(
            email_field__exact='test@email.com'
        )

        self.assert_(subscription.subscribed)
        self.assertFalse(subscription.unsubscribed)

        dt = (subscription.subscribe_date - subscription.create_date).seconds
        self.assertBetween(dt, WAIT_TIME, WAIT_TIME + 1)

    @override_settings(NEWSLETTER_CONFIRM_EMAIL_UNSUBSCRIBE=True)
    def test_unsubscribe_request_post(self):
        """ Post the unsubscribe request form. """

        subscription = Subscription(newsletter=self.n,
                                    name='Test Name',
                                    email='test@email.com',
                                    subscribed=True)
        subscription.save()

        response = self.client.post(
            self.unsubscribe_url, {'email_field': 'test@email.com'}
        )

        # Assure we are redirected to "unsubscribe activation email sent" page.
        self.assertRedirects(response, self.unsubscribe_email_sent_url)

        """ Check the subscription email. """
        self.assertEquals(len(mail.outbox), 1)

        activate_url = subscription.unsubscribe_activate_url()
        full_activate_url = 'http://%s%s' % (self.site.domain, activate_url)

        self.assertEmailContains(full_activate_url)

    @override_settings(NEWSLETTER_CONFIRM_EMAIL_UNSUBSCRIBE=False)
    def test_unsubscribe_request_post_no_email(self):
        """
        Post the unsubscribe request form
        with confirmation email switched off in settings.
        """

        subscription = Subscription(newsletter=self.n,
                                    name='Test Name',
                                    email='test@email.com',
                                    subscribed=True)
        subscription.save()

        response = self.client.post(
            self.unsubscribe_url, {'email_field': 'test@email.com'}
        )

        # Assure we are redirected to "unsubscribe activated" page.
        self.assertRedirects(response, self.unsubscribe_activated_url)

        changed_subscription = self.get_only_subscription(
            email_field__exact='test@email.com'
        )

        # email confirmation is switched off,
        # so after unsubscribe request user should be unsubscribed
        self.assertFalse(changed_subscription.subscribed)
        self.assertTrue(changed_subscription.unsubscribed)

        """ Check the subscription email. """
        # no email should be send
        self.assertEquals(len(mail.outbox), 0)

    @override_settings(NEWSLETTER_CONFIRM_EMAIL_UNSUBSCRIBE=True)
    def test_unsubscribe_request_post_error(self):
        """
        Test whether a failing unsubscribe request email generated an error in
        the context.

        We do this by overriding the default mail backend to a settings which
        we know pretty sure is bound to fail.
        """
        subscription = Subscription(newsletter=self.n,
                                    name='Test Name',
                                    email='test@email.com',
                                    subscribed=True)
        subscription.save()

        with override_settings(
            EMAIL_BACKEND='django.core.mail.backends.smtp.EmailBackend'
        ):
            with override_settings(EMAIL_PORT=12345678):
                response = self.client.post(
                    self.unsubscribe_url, {'email_field': 'test@email.com'}
                )

        self.assertTrue(response.context['error'])

    def test_unsubscribe_request_view(self):
        """ Test the unsubscribe request form. """
        response = self.app.get(self.unsubscribe_url)

        self.assertContains(response, self.n.title, status_code=200)

        self.assertIn('email_field', response.form.fields)

        self.assertEqual(response.context['newsletter'], self.n)

    def test_unsubscribe_request_activate(self):
        """ Update a request. """

        subscription = Subscription(newsletter=self.n,
                                    name='Test Name',
                                    email='test@email.com')
        subscription.save()

        activate_url = subscription.unsubscribe_activate_url()

        response = self.client.get(activate_url)
        self.assertInContext(response, 'form', UpdateForm)
        self.assertContains(response, subscription.activation_code)

        testname2 = 'Test Name2'
        testemail2 = 'test2@email.com'
        response = self.client.post(activate_url, {
            'name_field': testname2,
            'email_field': testemail2,
            'user_activation_code': subscription.activation_code
        })

        # Assure we are redirected to "unsubscribe activated" page.
        self.assertRedirects(response, self.unsubscribe_activated_url)

        subscription = self.get_only_subscription(
            email_field__exact=testemail2
        )

        self.assert_(subscription.unsubscribed)
        self.assertEqual(subscription.name, testname2)
        self.assertEqual(subscription.email, testemail2)

        dt = (timezone.now() - subscription.unsubscribe_date).seconds
        self.assertLessThan(dt, 2)

    def test_update_request_view(self):
        """ Test the update request form. """

        response = self.app.get(self.update_url)

        self.assertContains(response, self.n.title, status_code=200)
        self.assertIn('email_field', response.form.fields)

        self.assertEqual(response.context['newsletter'], self.n)

    @override_settings(NEWSLETTER_CONFIRM_EMAIL_UPDATE=True)
    def test_update_request_post(self):
        """ Test the update request post view. """

        subscription = Subscription(newsletter=self.n,
                                    name='Test Name',
                                    email='test@email.com',
                                    subscribed=True)
        subscription.save()

        response = self.client.post(
            self.update_url, {'email_field': 'test@email.com'}
        )

        # Assure we are redirected to "update activation email sent" page.
        self.assertRedirects(response, self.update_email_sent_url)

        """ Check the subscription email. """
        self.assertEquals(len(mail.outbox), 1)

        activate_url = subscription.update_activate_url()
        full_activate_url = 'http://%s%s' % (self.site.domain, activate_url)

        self.assertEmailContains(full_activate_url)

    @override_settings(NEWSLETTER_CONFIRM_EMAIL_UPDATE=False)
    def test_update_request_post_no_email(self):
        """
        Test the update request post view
        with confirmation email switched off in settings.
        """

        subscription = Subscription(newsletter=self.n,
                                    name='Test Name',
                                    email='test@email.com',
                                    subscribed=True)
        subscription.save()

        response = self.client.post(
            self.update_url, {'email_field': 'test@email.com'}
        )

        self.assertRedirects(response, subscription.update_activate_url())

        """ Check the subscription email. """
        # no email should be send
        self.assertEquals(len(mail.outbox), 0)

    @override_settings(NEWSLETTER_CONFIRM_EMAIL_UPDATE=True)
    def test_update_request_post_error(self):
        """
        Test whether a failing update request email generated an error in
        the context.

        We do this by overriding the default mail backend to a settings which
        we know pretty sure is bound to fail.
        """
        subscription = Subscription(newsletter=self.n,
                                    name='Test Name',
                                    email='test@email.com',
                                    subscribed=True)
        subscription.save()

        with override_settings(
            EMAIL_BACKEND='django.core.mail.backends.smtp.EmailBackend'
        ):
            with override_settings(EMAIL_PORT=12345678):
                response = self.client.post(
                    self.update_url, {'email_field': 'test@email.com'}
                )

        self.assertTrue(response.context['error'])

    def test_unsubscribe_update_unactivated(self):
        """ Test updating unsubscribed subscriptions view. """

        subscription = Subscription(newsletter=self.n,
                                    name='Test Name',
                                    email='test@email.com',
                                    subscribed=False)
        subscription.save()

        for url in (self.update_url, self.unsubscribe_url):
            response = self.client.post(
                url, {'email_field': 'test@email.com'}
            )

            self.assertContains(
                response, "This subscription has not yet been activated."
            )

    def test_unsubscribe_update_unsubscribed(self):
        """ Test updating nonexisting subscriptions view. """

        # The second call of this will fail due to a weird bug
        # where Django picks the wrong translation. Nevermind.
        for url in (self.update_url, self.unsubscribe_url):
            response = self.client.post(
                url, {'email_field': 'newemail@fdgf.com'})

            self.assertContains(
                response, "This e-mail address has not been subscribed to."
            )

    def test_update_request_activate(self):
        """ Update a request. """

        subscription = Subscription(newsletter=self.n,
                                    name='Test Name',
                                    email='test@email.com')
        subscription.save()

        activate_url = subscription.update_activate_url()

        response = self.client.get(activate_url)
        self.assertInContext(response, 'form', UpdateForm)
        self.assertContains(response, subscription.activation_code)

        testname2 = 'Test Name2'
        testemail2 = 'test2@email.com'
        response = self.client.post(activate_url, {
            'name_field': testname2,
            'email_field': testemail2,
            'user_activation_code': subscription.activation_code
        })

        # Assure we are redirected to "update activated" page.
        self.assertRedirects(response, self.update_activated_url)

        subscription = self.get_only_subscription(
            email_field__exact=testemail2
        )

        self.assert_(subscription)
        self.assert_(subscription.subscribed)
        self.assertEqual(subscription.name, testname2)
        self.assertEqual(subscription.email, testemail2)

    def test_update_request_activate_form(self):
        """
        Test requesting a form for activating an update without activation
        code in the URL.
        """

        subscription = Subscription(newsletter=self.n,
                                    name='Test Name',
                                    email='test@email.com')
        subscription.save()

        activate_url = reverse('newsletter_update', kwargs={
            'newsletter_slug': self.n.slug,
            'action': 'update',
            'email': subscription.email
        })

        response = self.client.get(activate_url)

        # Make sure the form is there
        self.assertInContext(response, 'form', UpdateForm)


class InvisibleAnonymousSubscribeTestCase(AnonymousSubscribeTestCase):
    """
    Tests for subscribing, unsubscribing and updating of subscription to
    a newsletter that is not publicly exposed on the site
    (has visible=False).

    Runs all anonymous and user test cases with invisible newsletter.
    """

    def setUp(self):
        super_obj = super(InvisibleAnonymousSubscribeTestCase, self)
        super_obj.setUp()

        # Make newsletter invisible
        self.n.visible = False
        self.n.save()


class InvisibleUserSubscribeTestCase(UserSubscribeTestCase):
    """
    Tests for subscribing, unsubscribing and updating of subscription to
    a newsletter that is not publicly exposed on the site
    (has visible=False).

    Runs all anonymous and user test cases with invisible newsletter.
    """

    def setUp(self):
        super_obj = super(InvisibleUserSubscribeTestCase, self)
        super_obj.setUp()

        # Make newsletter invisible
        self.n.visible = False
        self.n.save()


class ArchiveTestcase(NewsletterListTestCase):
    def setUp(self):
        """ Make sure we have a few submissions to test with. """

        # Pick some newsletter
        self.newsletter = Newsletter.objects.all()[0]

        # Make sure there's a HTML template for this newsletter,
        # otherwise the archive will not function.

        (subject_template, text_template, html_template) = \
            self.newsletter.get_templates('message')

        self.assertTrue(html_template)

        # Create a message first
        message = Message(
            title='Test message',
            slug='test-message',
            newsletter=self.newsletter
        )

        message.save()

        # Create a submission
        self.submission = Submission.from_message(message)

    def test_archive_invisible(self):
        """ Test whether an invisible newsletter is indeed not shown. """

        self.newsletter.visible = False
        self.newsletter.save()

        archive_url = self.submission.newsletter.archive_url()

        response = self.client.get(archive_url)
        self.assertEqual(response.status_code, 404)

        detail_url = self.submission.get_absolute_url()

        response = self.client.get(detail_url)
        self.assertEqual(response.status_code, 404)

    def test_archive_list(self):
        """ Test the Submission list view. """

        archive_url = self.submission.newsletter.archive_url()

        # When published, this should return properly
        response = self.client.get(archive_url)
        self.assertEqual(response.status_code, 200)

        self.assertContains(response, self.submission.message.title)
        self.assertContains(response, self.submission.get_absolute_url())

    def test_archive_detail(self):
        """ Test Submission detail view. """

        detail_url = self.submission.get_absolute_url()

        response = self.client.get(detail_url)
        self.assertEqual(response.status_code, 200)

        self.assertContains(response, self.submission.message.title)

    def test_archive_unpublished_detail(self):
        """ Assert that an unpublished submission is truly inaccessible. """

        self.submission.publish = False
        self.submission.save()

        archive_url = self.submission.newsletter.archive_url()

        response = self.client.get(archive_url)
        self.assertNotContains(response, self.submission.message.title)
        self.assertNotContains(response, self.submission.get_absolute_url())

        detail_url = self.submission.get_absolute_url()

        response = self.client.get(detail_url)
        self.assertEqual(response.status_code, 404)

    @unittest.skipUnless(pytz, 'pytz could not be imported.')
    @override_settings(
        TIME_ZONE='Europe/Paris',
        USE_TZ=True
    )
    def test_archive_timezone_regression(self):
        """
        Regression test for #74: Wrong submission archive urls when
        timezones are enabled.

        Ref:
            * https://docs.djangoproject.com/en/1.5/topics/i18n/timezones/#troubleshooting
            * https://github.com/dokterbob/django-newsletter/issues/74
        """
        problematic_date = datetime(2012, 3, 3, 1, 30)

        paris_date = timezone.make_aware(
            problematic_date, timezone.get_default_timezone()
        )

        # Setup submission in paris timezone
        self.submission.publish_date = paris_date
        self.submission.save()

        # Test viewing the submission in another timezone
        timezone.activate('America/New_York')

        # Test viewing the submission
        self.test_archive_detail()


class ActionTemplateViewMixin(object):
    """ Mixin for testing requests to urls for all three actions. """

    def get_action_url(self, action):
        """
        This method should be overridden in subclasses.
        Return url for given action.
        """

        raise NotImplementedError(
            '%(class_name)s inherits from of ActionTemplateViewMixin '
            'and should define get_url method.' % {
                'class_name': self.__class__.__name__
            }
        )

    def action_url_test(self, action):
        """ Assertions common for all actions. """
        response = self.client.get(self.get_action_url(action))

        self.assertEquals(response.status_code, 200)
        self.assertInContext(response, 'newsletter', Newsletter, self.n)
        self.assertInContext(response, 'action', value=action)

    def test_subscribe_url(self):
        self.action_url_test('subscribe')

    def test_unsubscribe_url(self):
        self.action_url_test('unsubscribe')

    def test_update_url(self):
        self.action_url_test('update')


class ActivationEmailSentUrlTestCase(
        ActionTemplateViewMixin, SubscribeTestCase
):
    """
    TestCase for testing requests to urls with activation email sent info.
    """

    def get_action_url(self, action):
        """ Return url with email sent info for given action. """

        return getattr(self, '%s_email_sent_url' % action)


class ActionActivatedUrlTestCase(
        ActionTemplateViewMixin, SubscribeTestCase
):
    """
    TestCase for testing requests to urls with action activated info.
    """

    def get_action_url(self, action):
        """ Return url with action activated info for given action. """

        return getattr(self, '%s_activated_url' % action)

########NEW FILE########
__FILENAME__ = utils
import logging

logger = logging.getLogger(__name__)

from django.core import mail

from django.test import TestCase

from django.contrib.sites.models import Site

from django.template import loader, TemplateDoesNotExist

from django_webtest import WebTest

from ..utils import get_user_model
User = get_user_model()


class WebTestCase(WebTest):
    def setUp(self):
        self.site = Site.objects.get_current()

        super(WebTestCase, self).setUp()

    def assertInContext(self, response, variable,
                        instance_of=None, value=None):
        try:
            instance = response.context[variable]
            self.assert_(instance)
        except KeyError:
            self.fail(
                'Asserted variable %s not in response context.' % variable
            )

        if instance_of:
            self.assert_(isinstance(instance, instance_of))

        if value:
            self.assertEqual(instance, value)


class MailTestCase(TestCase):
    def get_email_list(self, email):
        if email:
            return (email,)
        else:
            return mail.outbox

    def assertEmailContains(self, value, email=None):
        for my_email in self.get_email_list(email):
            self.assert_(
                (value in my_email.subject) or
                (value in my_email.body),
                'Email does not contain "%s".' % value
            )

    def assertEmailBodyContains(self, value, email=None):
        for my_email in self.get_email_list(email):
            self.assert_(
                value in my_email.body,
                'Email body does not contain "%s".' % value
            )

    def assertEmailSubjectContains(self, value, email=None):
        for my_email in self.get_email_list(email):
            self.assert_(
                value in my_email.subject,
                'Email subject does not contain "%s".' % value
            )

    def assertEmailHasNoAlternatives(self, email=None):
        for my_email in self.get_email_list(email):
            self.assert_(
                not getattr(my_email, 'alternatives', None),
                'Email has alternative content types.'
            )

    def assertEmailAlternativesContainMimetype(self, mimetype, email=None):
        for my_email in self.get_email_list(email):
            self.assert_(
                mimetype in (mime for content, mime in my_email.alternatives),
                'Email does not contain "%s" alternative.' % mimetype
            )

    def assertEmailAlternativeBodyContains(self, value, email=None):
        for my_email in self.get_email_list(email):
            self.assert_(
                all(
                    value in content for content, mime in my_email.alternatives
                ),
                'Email does not contain "%s" in alternative body.' % value
            )


class UserTestCase(TestCase):
    def setUp(self):
        super(UserTestCase, self).setUp()

        self.password = 'johnpassword'
        self.user = User.objects.create_user(
            'john', 'lennon@thebeatles.com', self.password)

        # Make sure the user has been created
        self.assertIn(self.user, User.objects.all())

        # Login the newly created user
        result = self.client.login(
            username=self.user.username, password=self.password
        )

        # Make sure the login went well
        self.assertTrue(result)

    def tearDown(self):
        self.client.logout()
        self.user.delete()


class ComparingTestCase(TestCase):
    def assertLessThan(self, value1, value2):
        self.assert_(value1 < value2)

    def assertMoreThan(self, value1, value2):
        self.assert_(value1 > value2)

    def assertBetween(self, value, min, max):
        self.assert_(value >= min)
        self.assert_(value <= max)

    def assertWithin(self, value, min, max):
        self.assert_(value > min)
        self.assert_(value < max)


def template_exists(template_name):
    try:
        loader.get_template(template_name)
        return True
    except TemplateDoesNotExist:
        return False

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns

from surlex.dj import surl

from .views import (
    NewsletterListView, NewsletterDetailView,
    SubmissionArchiveIndexView, SubmissionArchiveDetailView,
    SubscribeRequestView, UnsubscribeRequestView, UpdateRequestView,
    ActionTemplateView, UpdateSubscriptionViev,
)

urlpatterns = patterns(
    '',

    # Newsletter list and detail view
    surl('^$', NewsletterListView.as_view(), name='newsletter_list'),
    surl(
        '^<newsletter_slug:s>/$',
        NewsletterDetailView.as_view(), name='newsletter_detail'
    ),

    # Action request views
    surl(
        '^<newsletter_slug:s>/subscribe/$',
        SubscribeRequestView.as_view(),
        name='newsletter_subscribe_request'
    ),
    surl(
        '^<newsletter_slug:s>/subscribe/confirm/$',
        SubscribeRequestView.as_view(confirm=True),
        name='newsletter_subscribe_confirm'
    ),
    surl(
        '^<newsletter_slug:s>/update/$',
        UpdateRequestView.as_view(),
        name='newsletter_update_request'
    ),
    surl(
        '^<newsletter_slug:s>/unsubscribe/$',
        UnsubscribeRequestView.as_view(),
        name='newsletter_unsubscribe_request'
    ),
    surl(
        '^<newsletter_slug:s>/unsubscribe/confirm/$',
        UnsubscribeRequestView.as_view(confirm=True),
        name='newsletter_unsubscribe_confirm'
    ),

    # Activation email sent view
    surl(
        '^<newsletter_slug:s>/<action=subscribe|update|unsubscribe>/'
        'email-sent/$',
        ActionTemplateView.as_view(
            template_name='newsletter/subscription_%(action)s_email_sent.html'
        ),
        name='newsletter_activation_email_sent'),

    # Action confirmation views
    surl(
        '^<newsletter_slug:s>/subscription/<email=[-_a-zA-Z0-9@\.\+~]+>/'
        '<action=subscribe|update|unsubscribe>/activate/<activation_code:s>/$',
        UpdateSubscriptionViev.as_view(), name='newsletter_update_activate'
    ),
    surl(
        '^<newsletter_slug:s>/subscription/<email=[-_a-zA-Z0-9@\.\+~]+>/'
        '<action=subscribe|update|unsubscribe>/activate/$',
        UpdateSubscriptionViev.as_view(), name='newsletter_update'
    ),

    # Action activation completed view
    surl(
        '^<newsletter_slug:s>/<action=subscribe|update|unsubscribe>/'
        'activation-completed/$',
        ActionTemplateView.as_view(
            template_name='newsletter/subscription_%(action)s_activated.html'
        ),
        name='newsletter_action_activated'),

    # Archive views
    surl(
        '^<newsletter_slug:s>/archive/<year:Y>/<month:m>/<day:d>/<slug:s>/$',
        SubmissionArchiveDetailView.as_view(), name='newsletter_archive_detail'
    ),
    surl(
        '^<newsletter_slug:s>/archive/$',
        SubmissionArchiveIndexView.as_view(), name='newsletter_archive'
    ),
)

########NEW FILE########
__FILENAME__ = utils
""" Generic helper functions """

import logging
logger = logging.getLogger(__name__)

import random

try:
    from hashlib import sha1
except ImportError:
    from django.utils.hashcompat import sha_constructor as sha1

from django.contrib.sites.models import Site

from datetime import datetime

# Possible actions that user can perform
ACTIONS = ('subscribe', 'unsubscribe', 'update')


def get_user_model():
    """ get_user_model compatibility wrapper. Returns active User model. """
    try:
        from django.contrib.auth import get_user_model
    except ImportError:
        # Django < v1.5
        from django.contrib.auth.models import User
    else:
        User = get_user_model()

    return User


def make_activation_code():
    """ Generate a unique activation code. """
    random_string = str(random.random())
    random_digest = sha1(random_string).hexdigest()[:5]
    time_string = str(datetime.now().microsecond)

    combined_string = random_digest + time_string

    return sha1(combined_string).hexdigest()


def get_default_sites():
    """ Get a list of id's for all sites; the default for newsletters. """
    return [site.id for site in Site.objects.all()]


class Singleton(type):
    """
    Singleton metaclass.
    Source:
    http://stackoverflow.com/questions/6760685/creating-a-singleton-in-python
    """
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super(Singleton, cls).__call__(
                *args, **kwargs
            )

        return cls._instances[cls]

########NEW FILE########
__FILENAME__ = views
import logging

logger = logging.getLogger(__name__)

import datetime
import socket

from smtplib import SMTPException

from django.core.exceptions import ValidationError, ImproperlyConfigured
from django.core.urlresolvers import reverse
from django.conf import settings

from django.template.response import SimpleTemplateResponse

from django.shortcuts import get_object_or_404, redirect
from django.http import Http404

from django.views.generic import (
    ListView, DetailView,
    ArchiveIndexView, DateDetailView,
    TemplateView, FormView
)

from django.contrib import messages
from django.contrib.sites.models import Site
from django.contrib.auth.decorators import login_required

from django.utils.decorators import method_decorator
from django.utils.translation import ugettext, ugettext_lazy as _
from django.utils import timezone

from django.forms.models import modelformset_factory

from .models import Newsletter, Subscription, Submission
from .forms import (
    SubscribeRequestForm, UserUpdateForm, UpdateRequestForm,
    UnsubscribeRequestForm, UpdateForm
)
from .settings import newsletter_settings
from .utils import ACTIONS


class NewsletterViewBase(object):
    """ Base class for newsletter views. """
    queryset = Newsletter.on_site.filter(visible=True)
    allow_empty = False
    slug_url_kwarg = 'newsletter_slug'


class NewsletterDetailView(NewsletterViewBase, DetailView):
    pass


class NewsletterListView(NewsletterViewBase, ListView):
    """
    List available newsletters and generate a formset for (un)subscription
    for authenticated users.
    """

    def post(self, request, **kwargs):
        """ Allow post requests. """

        # All logic (for now) occurs in the form logic
        return super(NewsletterListView, self).get(request, **kwargs)

    def get_context_data(self, **kwargs):
        context = super(NewsletterListView, self).get_context_data(**kwargs)

        if self.request.user.is_authenticated():
            # Add a formset for logged in users.
            context['formset'] = self.get_formset()

        return context

    def get_formset(self):
        """
        Return a formset with newsletters for logged in users, or None.
        """

        # Short-hand variable names
        newsletters = self.get_queryset()
        request = self.request
        user = request.user

        SubscriptionFormSet = modelformset_factory(
            Subscription, form=UserUpdateForm, extra=0
        )

        # Before rendering the formset, subscription objects should
        # already exist.
        for n in newsletters:
            Subscription.objects.get_or_create(
                newsletter=n, user=user
            )

        # Get all subscriptions for use in the formset
        qs = Subscription.objects.filter(
            newsletter__in=newsletters, user=user
        )

        if request.method == 'POST':
            try:
                formset = SubscriptionFormSet(request.POST, queryset=qs)

                if not formset.is_valid():
                    raise ValidationError('Update form invalid.')

                # Everything's allright, let's save
                formset.save()

                messages.info(
                    request,
                    ugettext("Your changes have been saved.")
                )

            except ValidationError:
                # Invalid form posted. As there is no way for a user to
                # enter data - invalid forms should be ignored from the UI.

                # However, we log them for debugging purposes.
                logger.warning(
                    'Invalid form post received',
                    exc_info=True, extra={'request': request}
                )

                # Present a pristine form
                formset = SubscriptionFormSet(queryset=qs)

        else:
            formset = SubscriptionFormSet(queryset=qs)

        return formset


class ProcessUrlDataMixin(object):
    """
    Mixin providing the ability to process args and kwargs from url
    before dispatching request.
    """

    def process_url_data(self, *args, **kwargs):
        """ Subclasses should put url data processing in this method. """
        pass

    def dispatch(self, *args, **kwargs):
        self.process_url_data(*args, **kwargs)

        return super(ProcessUrlDataMixin, self).dispatch(*args, **kwargs)


class NewsletterMixin(ProcessUrlDataMixin):
    """
    Mixin retrieving newsletter based on newsletter_slug from url
    and adding it to context and form kwargs.
    """

    def process_url_data(self, *args, **kwargs):
        """
        Get newsletter based on `newsletter_slug` from url
        and add it to instance attributes.
        """

        assert 'newsletter_slug' in kwargs

        super(NewsletterMixin, self).process_url_data(*args, **kwargs)

        newsletter_queryset = kwargs.get(
            'newsletter_queryset',
            Newsletter.on_site.all()
        )
        newsletter_slug = kwargs['newsletter_slug']

        self.newsletter = get_object_or_404(
            newsletter_queryset, slug=newsletter_slug,
        )

    def get_form_kwargs(self):
        """ Add newsletter to form kwargs. """
        kwargs = super(NewsletterMixin, self).get_form_kwargs()

        kwargs['newsletter'] = self.newsletter

        return kwargs

    def get_context_data(self, **kwargs):
        """ Add newsletter to context. """
        context = super(NewsletterMixin, self).get_context_data(**kwargs)

        context['newsletter'] = self.newsletter

        return context


class ActionMixin(ProcessUrlDataMixin):
    """ Mixin retrieving action from url and adding it to context. """

    action = None

    def process_url_data(self, *args, **kwargs):
        """ Add action from url to instance attributes if not already set. """
        super(ActionMixin, self).process_url_data(*args, **kwargs)

        if self.action is None:
            assert 'action' in kwargs
            self.action = kwargs['action']

        assert self.action in ACTIONS, 'Unknown action: %s' % self.action

    def get_context_data(self, **kwargs):
        """ Add action to context. """
        context = super(ActionMixin, self).get_context_data(**kwargs)

        context['action'] = self.action

        return context

    def get_template_names(self):
        """ Return list of template names for proper action. """

        if self.template_name is None:
            raise ImproperlyConfigured(
                '%(class_name)s should define template_name, '
                'or implement get_template_names()' % {
                    'class_name': self.__class__.__name__
                }
            )

        else:
            try:
                return [self.template_name % {'action': self.action}]
            except KeyError, e:
                raise ImproperlyConfigured(
                    '%(class_name)s inherits from ActionMixin and can contain '
                    '%%(action)s in template_name to be replaced '
                    'by action name %(wrong_key)s given instead.' % {
                        'class_name': self.__class__.__name__,
                        'wrong_key': e,
                    }
                )


class ActionTemplateView(NewsletterMixin, ActionMixin, TemplateView):
    """
    View that renders a template for proper action,
    with newsletter and action in context.
    """
    pass


class ActionFormView(NewsletterMixin, ActionMixin, FormView):
    """ FormView with newsletter and action support. """

    def get_url_from_viewname(self, viewname):
        """
        Return url for given `viename`
        and associated with this view newsletter and action.
        """

        return reverse(
            viewname,
            kwargs={
                'newsletter_slug': self.newsletter.slug,
                'action': self.action
            }
        )


class ActionUserView(ActionTemplateView):
    """ Base class for subscribe and unsubscribe user views. """
    template_name = "newsletter/subscription_%(action)s_user.html"

    def process_url_data(self, *args, **kwargs):
        """ Add confirm to instance attributes. """
        super(ActionUserView, self).process_url_data(*args, **kwargs)

        # confirm is optional kwarg defaulting to False
        self.confirm = kwargs.get('confirm', False)

    def post(self, request, *args, **kwargs):
        return self.get(request, *args, **kwargs)

    @method_decorator(login_required)
    def dispatch(self, *args, **kwargs):
        return super(ActionUserView, self).dispatch(*args, **kwargs)


class SubscribeUserView(ActionUserView):
    action = 'subscribe'

    def get(self, request, *args, **kwargs):
        already_subscribed = False
        instance = Subscription.objects.get_or_create(
            newsletter=self.newsletter, user=request.user
        )[0]

        if instance.subscribed:
            already_subscribed = True
        elif self.confirm:
            instance.subscribed = True
            instance.save()

            messages.success(
                request,
                _('You have been subscribed to %s.') % self.newsletter
            )

            logger.debug(
                _('User %(rs)s subscribed to %(my_newsletter)s.'),
                {
                    "rs": request.user,
                    "my_newsletter": self.newsletter
                }
            )

        if already_subscribed:
            messages.info(
                request,
                _('You are already subscribed to %s.') % self.newsletter
            )

        return super(SubscribeUserView, self).get(request, *args, **kwargs)


class UnsubscribeUserView(ActionUserView):
    action = 'unsubscribe'

    def get(self, request, *args, **kwargs):
        not_subscribed = False

        try:
            instance = Subscription.objects.get(
                newsletter=self.newsletter, user=request.user
            )

            if not instance.subscribed:
                not_subscribed = True
            elif self.confirm:
                instance.subscribed = False
                instance.save()

                messages.success(
                    request,
                    _('You have been unsubscribed from %s.') % self.newsletter
                )

                logger.debug(
                    _('User %(rs)s unsubscribed from %(my_newsletter)s.'),
                    {
                        "rs": request.user,
                        "my_newsletter": self.newsletter
                    }
                )

        except Subscription.DoesNotExist:
            not_subscribed = True

        if not_subscribed:
            messages.info(
                request,
                _('You are not subscribed to %s.') % self.newsletter
            )

        return super(UnsubscribeUserView, self).get(request, *args, **kwargs)


class ActionRequestView(ActionFormView):
    """ Base class for subscribe, unsubscribe and update request views. """
    template_name = "newsletter/subscription_%(action)s.html"

    def process_url_data(self, *args, **kwargs):
        """ Add error to instance attributes. """
        super(ActionRequestView, self).process_url_data(*args, **kwargs)

        self.error = None

    def get_context_data(self, **kwargs):
        """ Add error to context. """
        context = super(ActionRequestView, self).get_context_data(**kwargs)

        context.update({
            'error': self.error,
        })

        return context

    def get_subscription(self, form):
        """ Return subscription for the current request. """
        return form.instance

    def no_email_confirm(self, form):
        """
        Subscribe/unsubscribe user and redirect to action activated page.
        """
        self.subscription.update(self.action)

        return redirect(
            self.get_url_from_viewname('newsletter_action_activated')
        )

    def get_success_url(self):
        return self.get_url_from_viewname('newsletter_activation_email_sent')

    def form_valid(self, form):
        self.subscription = self.get_subscription(form)

        if not getattr(
                newsletter_settings,
                'CONFIRM_EMAIL_%s' % self.action.upper()
        ):
            # Confirmation email for this action was switched off in settings.
            return self.no_email_confirm(form)

        try:
            self.subscription.send_activation_email(action=self.action)

        except (SMTPException, socket.error), e:
            logger.exception(
                'Error %s while submitting email to %s.',
                e, self.subscription.email
            )
            self.error = True

            # Although form was valid there was error while sending email,
            # so stay at the same url.
            return super(ActionRequestView, self).form_invalid(form)

        return super(ActionRequestView, self).form_valid(form)


class SubscribeRequestView(ActionRequestView):
    action = 'subscribe'
    form_class = SubscribeRequestForm
    confirm = False

    def get_form_kwargs(self):
        """ Add ip to form kwargs for submitted forms. """
        kwargs = super(SubscribeRequestView, self).get_form_kwargs()

        if self.request.method in ('POST', 'PUT'):
            kwargs['ip'] = self.request.META.get('REMOTE_ADDR')

        return kwargs

    def get_subscription(self, form):
        return form.save()

    def dispatch(self, request, *args, **kwargs):
        if request.user.is_authenticated():
            kwargs['confirm'] = self.confirm
            return SubscribeUserView.as_view()(request, *args, **kwargs)

        return super(SubscribeRequestView, self).dispatch(
            request, *args, **kwargs
        )


class UnsubscribeRequestView(ActionRequestView):
    action = 'unsubscribe'
    form_class = UnsubscribeRequestForm
    confirm = False

    def dispatch(self, request, *args, **kwargs):
        if request.user.is_authenticated():
            kwargs['confirm'] = self.confirm
            return UnsubscribeUserView.as_view()(request, *args, **kwargs)

        return super(UnsubscribeRequestView, self).dispatch(
            request, *args, **kwargs
        )


class UpdateRequestView(ActionRequestView):
    action = 'update'
    form_class = UpdateRequestForm

    def no_email_confirm(self, form):
        """ Redirect to update subscription view. """
        return redirect(self.subscription.update_activate_url())


class UpdateSubscriptionViev(ActionFormView):
    form_class = UpdateForm
    template_name = "newsletter/subscription_activate.html"

    def process_url_data(self, *args, **kwargs):
        """
        Add email, subscription and activation_code
        to instance attributes.
        """
        assert 'email' in kwargs

        super(UpdateSubscriptionViev, self).process_url_data(*args, **kwargs)

        self.subscription = get_object_or_404(
            Subscription, newsletter=self.newsletter,
            email_field__exact=kwargs['email']
        )
        # activation_code is optional kwarg which defaults to None
        self.activation_code = kwargs.get('activation_code')

    def get_initial(self):
        """ Returns the initial data to use for forms on this view. """
        if self.activation_code:
            return {'user_activation_code': self.activation_code}
        else:
            # TODO: Test coverage of this branch
            return None

    def get_form_kwargs(self):
        """ Add instance to form kwargs. """
        kwargs = super(UpdateSubscriptionViev, self).get_form_kwargs()

        kwargs['instance'] = self.subscription

        return kwargs

    def get_success_url(self):
        return self.get_url_from_viewname('newsletter_action_activated')

    def form_valid(self, form):
        """ Get our instance, but do not save yet. """
        subscription = form.save(commit=False)

        subscription.update(self.action)

        return super(UpdateSubscriptionViev, self).form_valid(form)


class SubmissionViewBase(NewsletterMixin):
    """ Base class for submission archive views. """
    date_field = 'publish_date'
    allow_empty = True
    queryset = Submission.objects.filter(publish=True)
    slug_field = 'message__slug'

    # Specify date element notation
    year_format = '%Y'
    month_format = '%m'
    day_format = '%d'

    def process_url_data(self, *args, **kwargs):
        """ Use only visible newsletters. """

        kwargs['newsletter_queryset'] = NewsletterListView().get_queryset()
        return super(
            SubmissionViewBase, self).process_url_data(*args, **kwargs)

    def get_queryset(self):
        """ Filter out submissions for current newsletter. """
        qs = super(SubmissionViewBase, self).get_queryset()

        qs = qs.filter(newsletter=self.newsletter)

        return qs

    def _make_date_lookup_arg(self, value):
        """
        Convert a date into a datetime when the date field is a DateTimeField.

        When time zone support is enabled, `date` is assumed to be in the
        default time zone, so that displayed items are consistent with the URL.

        Related discussion:
        https://github.com/dokterbob/django-newsletter/issues/74
        """
        value = datetime.datetime.combine(value, datetime.time.min)
        if settings.USE_TZ:
            value = timezone.make_aware(value, timezone.get_default_timezone())
        return value


class SubmissionArchiveIndexView(SubmissionViewBase, ArchiveIndexView):
    pass


class SubmissionArchiveDetailView(SubmissionViewBase, DateDetailView):
    def get_context_data(self, **kwargs):
        """
        Make sure the actual message is available.
        """
        context = \
            super(SubmissionArchiveDetailView, self).get_context_data(**kwargs)

        message = self.object.message

        context.update({
            'message': message,
            'site': Site.objects.get_current(),
            'date': self.object.publish_date,
            'STATIC_URL': settings.STATIC_URL,
            'MEDIA_URL': settings.MEDIA_URL
        })

        return context

    def get_template(self):
        """ Get the message template for the current newsletter. """

        (subject_template, text_template, html_template) = \
            self.object.newsletter.get_templates('message')

        # No HTML -> no party!
        if not html_template:
            raise Http404(ugettext(
                'No HTML template associated with the newsletter this '
                'message belongs to.'
            ))

        return html_template

    def render_to_response(self, context, **response_kwargs):
        """
        Return a simplified response; the template should be rendered without
        any context. Use a SimpleTemplateResponse as a RequestContext should
        not be used.
        """
        return SimpleTemplateResponse(
            template=self.get_template(),
            context=context,
            **response_kwargs
        )

########NEW FILE########
__FILENAME__ = test_settings
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3'
    }
}

INSTALLED_APPS = [
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.auth',
    'django.contrib.sites',
    'django_extensions',
    'sorl.thumbnail',
    'imperavi',
    'tinymce',
    'newsletter'
]

try:
    # If available, South is required by setuptest
    import south
    INSTALLED_APPS.append('south')
except ImportError:
    # South not installed and hence is not required
    pass

ROOT_URLCONF = 'test_urls'

SITE_ID = 1

TEMPLATE_DIRS = ('test_templates', )

# Enable time-zone support for Django 1.4 (ignored in older versions)
USE_TZ = True

# Required for django-webtest to work
STATIC_URL = '/static/'

########NEW FILE########
__FILENAME__ = test_urls
from django.conf.urls import patterns, include


urlpatterns = patterns('',
    (r'^newsletter/', include('newsletter.urls')),
)

########NEW FILE########
