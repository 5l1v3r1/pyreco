__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# dploi-fabric documentation build configuration file, created by
# sphinx-quickstart on Mon Jan  2 13:29:35 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('../'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'dploi-fabric'
copyright = u'2012, Benjamin Wohlwend, Kristian Oellegaard, Stefan Foulis'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.1.10'
# The full version, including alpha/beta/rc tags.
release = '0.1.10'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'dploi-fabricdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'dploi-fabric.tex', u'dploi-fabric Documentation',
   u'Benjamin Wohlwend, Kristian Oellegaard, Stefan Foulis', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'dploi-fabric', u'dploi-fabric Documentation',
     [u'Benjamin Wohlwend, Kristian Oellegaard, Stefan Foulis'], 1)
]

########NEW FILE########
__FILENAME__ = buildout
from fabric.operations import run as do_run
from fabric.api import task, env

@task
def run():
    """
    runs buildout
    """
    # TODO: Refactor to use utils.config
    do_run('cd %(path)s;./bin/buildout -c %(buildout_cfg)s' % env)


########NEW FILE########
__FILENAME__ = celery

########NEW FILE########
__FILENAME__ = conf
from fabric.api import env

from deployment import settings, project_name

env.project_name = project_name

for key, value in settings.items():
          value['identifier']=key

def load_settings(identifier):
    if not any(settings[identifier]['hosts']):
        raise RuntimeError("Hosts not defined, stopping...")
    env.identifier = identifier
    for key, value in settings[identifier].items():
        setattr(env, key, value)

########NEW FILE########
__FILENAME__ = base
import datetime
from fabric.api import env, run, get
from fabric.tasks import Task
import os

class DumpDatabaseTask(object):
    def get_path(self, env, reason):
        mytimestamp = datetime.datetime.now().strftime('%Y-%m-%d-%H%M%S')
        reason = reason.replace(' ', '_')
        return os.path.join('%(backup_dir)s'  % env, '%(db_name)s-' % env + mytimestamp + '-' + reason + '.sql')

    def get_command(self, env, file_name, **flags):
        raise NotImplementedError

    def run(self, reason='unknown', compress=False, **flags):
        file_name = self.get_path(env, reason)
        command = self.get_command(env, file_name, **flags)
        run(command)
        if compress:
            run('gzip ' + file_name)
            file_name += '.gz'
        return file_name

    def get_flags_string(self, **flags):
        flag_list = []
        for k, v in flags.iteritems():
            result = ('-' if len(k) == 1 else '--') + k
            if v:
                result += (' ' if len(k) == 1 else '=') + v
            flag_list.append(result)
        return ' '.join(flag_list)


class DownloadDatabase(Task):
    """
    Download the database
    """

    name = 'download'

    def __init__(self, dump_task, **flags):
        self.dump_task = dump_task
        self.flags = flags

    def run(self, path='tmp', **flags):
        flags.update(self.flags)
        file_name = self.dump_task.run(reason='for_download', compress=True, **flags)
        get(file_name, path)

########NEW FILE########
__FILENAME__ = mysql
from fabric.tasks import Task
from dploi_fabric.db.base import DumpDatabaseTask, DownloadDatabase

class MysqlDumpDatabaseTask(DumpDatabaseTask, Task):
    """
    Dump the database (MySQL)
    """
    name = 'dump'

    def get_command(self, env, file_name, **flags):
        if hasattr(env, 'db_host'):
            flags['host'] = env['db_host']
        return ('mysqldump ' + self.get_flags_string(**flags) + ' --user="%(db_username)s" --password="%(db_password)s" "%(db_name)s" > ' % env) + file_name

dump = MysqlDumpDatabaseTask()
download = DownloadDatabase(dump_task=dump, **{'lock-tables':'false'})

########NEW FILE########
__FILENAME__ = pg
from fabric.tasks import Task
from dploi_fabric.db.base import DumpDatabaseTask, DownloadDatabase

class PostgreDumpDatabaseTask(DumpDatabaseTask, Task):
    """
    Dump the database (PostgreSQL)
    """

    name = 'dump'

    def get_command(self, env, file_name, **flags):
        return ('pg_dump --no-owner ' + self.get_flags_string(**flags) + ' --username="%(db_username)s" "%(db_name)s" > ' % env) + file_name

dump = PostgreDumpDatabaseTask()
download = DownloadDatabase(dump_task=dump)

########NEW FILE########
__FILENAME__ = django_utils
import ConfigParser
import StringIO
from fabric.decorators import task
from fabric.api import env, get, put
import os
from fabric.contrib.files import exists
from .utils import config
import posixpath
from .utils import STATIC_COLLECTED, DATA_DIRECTORY
from pprint import pformat
from fabric.operations import run

def django_exec(dictionary = {}, tool="buildout"):
    # TODO: Remove this and change dependants to use utils.config
    config = ConfigParser.RawConfigParser()
    config_file = os.path.join(env.path, "config.ini")
    django_base = "." # default to current dir
    if exists(config_file):
        output = StringIO.StringIO()
        get(u"%s" % config_file, output)
        output.seek(0)
        config.readfp(output)
    
        try:
            tool = config.get("checkout", "tool")
        except (ConfigParser.NoSectionError, ConfigParser.NoOptionError):
            tool = "buildout" # default to buildout

        try:
            django_base = config.get("django", "base")
        except (ConfigParser.NoSectionError, ConfigParser.NoOptionError):
            pass
    if django_base == ".":
        django_base = ""
    if tool == "buildout":
        cmd = os.path.join(env.path, django_base, "bin/django")
        django_settings = os.path.join(env.path, django_base, "settings.py")
    else:
        cmd = "%s %s" % (os.path.join(env.path, "bin/python"), os.path.join(env.path, django_base, "manage.py"))
        django_settings = os.path.join(env.path, django_base, "settings.py")
    dictionary['django_exec'] = cmd
    dictionary['django_settings'] = django_settings
    dictionary['checkout_tool'] = tool
    return dictionary
    
def django_settings_file(dictionary = {}): # TODO: Remove this and change dependants to use utils.config
    return django_exec().get("django_settings")

@task
def manage(*args):
    """
    Proxy for manage.py
    """
    config.django_manage(" ".join(args))
    
@task
def collectstatic(staticdir='static'): # As defined in puppet config
    # TODO: Use utils.config
    run(('cd %(path)s; mkdir -p ' + staticdir) % env)
    manage("collectstatic", "--noinput", "--link")
    
@task
def append_settings():
    # TODO: make it work with multisites!
    append = config.sites["main"].get("django").get("append_settings", False)
    if append:
        site_config = config.sites["main"]
        settings_file_path = django_settings_file()
        print "Appending auto generated settings to", settings_file_path
        output = StringIO.StringIO()
        get(u"%s" % os.path.join(env.path, "../config/django.py"), output)
        output.seek(0)
        manual_settings = output.read()

        # START OF DIRTY DATABASE HACK


        additional_settings = """if "DATABASES" in locals():\n"""
        # DATABASES
        #additional_settings = "DATABASES = %s\n" % pformat(config.sites["main"].get("deployment").get("databases"))
        additional_settings +="    DATABASES = %s\n" % pformat(config.sites["main"].get("deployment").get("databases"))

        db_old_dict = config.sites["main"].get("deployment").get("databases")["default"]
        db_old_dict["ENGINE"] = db_old_dict["ENGINE"].replace("django.db.backends.", "")
        additional_settings += """else:
    DATABASE_ENGINE = "%(ENGINE)s"
    DATABASE_NAME = "%(NAME)s"
    DATABASE_USER = "%(USER)s"
    DATABASE_PASSWORD = "%(PASSWORD)s"
    DATABASE_HOST = "%(HOST)s"
""" % db_old_dict

        # // END OF DIRTY DATABASE HACK

        # CACHES
        processes = config.sites["main"].get("processes")
        cache_dict = {
            'default': {
                'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache',
                'LOCATION': 'unix:%s' % [processes[x] for x in processes if processes[x]["type"] == "memcached"][0].get("socket"),
            }
        }
        additional_settings += "CACHES = %s\n" % pformat(cache_dict)

        # PATHS
        additional_settings += """
STATIC_ROOT = "%(static_root)s"
MEDIA_ROOT = "%(media_root)s"
""" % {
            'static_root': posixpath.join(site_config.get("deployment").get("path"), STATIC_COLLECTED),
            'media_root': posixpath.join(site_config.get("deployment").get("path"), DATA_DIRECTORY, 'media/'),
        }

        output = StringIO.StringIO()
        get(settings_file_path, output)
        output.seek(0)
        settings_file = output.read()


        run("mkdir -p %s" % posixpath.join(site_config.get("deployment").get("path"), "_gen/"))
        put(StringIO.StringIO("%s\n%s\n%s" % (settings_file, additional_settings, manual_settings)), site_config.get("deployment").get("generated_settings_path"))
        put(StringIO.StringIO(""), posixpath.join(site_config.get("deployment").get("path"), "_gen/__init__.py"))
########NEW FILE########
__FILENAME__ = git
from fabric.operations import run, prompt
from fabric.api import task, env, get, put
from fabric.contrib.files import exists
import ConfigParser
import StringIO
import posixpath
from .utils import STATIC_COLLECTED, DATA_DIRECTORY
from django_utils import django_settings_file, append_settings
import os
from .messages import CAUTION
from .utils import config

@task
def update():
    test = run("cd %(path)s; git --no-pager diff --stat" % env)
    if "files changed" in test:
        print CAUTION
        print "You have local file changes to the git repository on the server. Run 'fab %s git.reset' to remove them, " \
              "or keep them by applying the diff locally with the command 'git apply filename.diff' and upload it to your git host" % env.identifier
        print
        print "You now have the following options:"
        print
        print "[D]ownload diff"
        print "Continue and [R]eset changes"
        print "[E]xit"
        download_diff = prompt("What do you want to do?", default="D")
        if download_diff.lower() == "d":
            diff = run(("cd %(path)s; git diff --color .") % env)
            for i in range(1,50):
                print
            print diff
            for i in range(1,5):
                print
            exit()
        elif download_diff.lower() == "e":
            exit()
    run("cd %(path)s; find . -iname '*.pyc' -delete" % env)
    run("cd %(path)s; git fetch origin" % env)
    run("cd %(path)s; git reset --hard" % env)
    run("cd %(path)s; git checkout %(branch)s" % env)
    run("cd %(path)s; git pull origin %(branch)s" % env)
    if exists(posixpath.join(env.path, ".gitmodules")):
        run("cd %(path)s; git submodule init" % env)
        run("cd %(path)s; git submodule update" % env)
    append_settings()

@task
def diff(what=''):
    run(("cd %(path)s; git --no-pager diff " + what) % env)

@task
def status():
    run("cd %(path)s; git status" % env)

@task
def reset():
    """
    discard all non-committed changes
    """
    run("cd %(path)s; find . -iname '*.pyc' -delete" % env)
    run("cd %(path)s; git reset --hard HEAD" % env)

@task
def incoming(remote='origin', branch=None):
    """
    Displays incoming commits 
    """
    if not branch:
        branch = env.branch
    run(("cd %(path)s; git fetch " + remote + " && git log --oneline .." + remote + '/' + branch) % env)

########NEW FILE########
__FILENAME__ = github
import os

from fabric.api import env, task, prompt, run, get
from fabric.contrib import files
import getpass
import json
import urllib2
import subprocess
import StringIO
import requests

@task
def upload_ssh_deploy_key():
    if not files.exists("/home/%(user)s/.ssh/id_rsa.pub" % env):
        if not files.exists("/home/%(user)s/.ssh/"):
            run("mkdir -p /home/%(user)s/.ssh/" % env)
        run("ssh-keygen -t rsa -f '/home/%(user)s/.ssh/id_rsa' -P ''" % env)

    output = StringIO.StringIO()
    get("/home/%(user)s/.ssh/id_rsa.pub" % env, output)
    output.seek(0)
    
    ssh_key = output.read()

    logged_in = False
    headers = {}
    while not logged_in:
        try:
            default_username = subprocess.check_output(["git", "config", "--get", "github.user"]).strip()
        except Exception:
            default_username = ''
        username = prompt("Please enter your GitHub username:", default=default_username)
        password = getpass.getpass("Please enter your GitHub password: ")

        repository = env.repo.rsplit(":", 1)[-1].replace(".git", "")
        response = requests.get("https://api.github.com/repos/%s/keys" % repository, auth=(username, password))
        if response.status_code == 401 and response.headers.get('X-GitHub-OTP', '').startswith('required'):
            headers['X-GitHub-OTP'] = prompt('Please enter the Two-Factor-Auth code:')
            response = requests.get("https://api.github.com/repos/%s/keys" % repository, auth=(username, password), headers=headers)
        response = json.loads(response.content)

        if 'message' in response:
            print(response['message'])
        else:
            logged_in = True
    
    match = [x for x in response if x.get("key") in ssh_key]
    if not match:
        data = {'key': ssh_key}
        data = json.dumps(data)
        response = requests.post("https://api.github.com/repos/%s/keys" % repository, auth=(username, password), data=data, headers=headers)

########NEW FILE########
__FILENAME__ = messages
# http://patorjk.com/software/taag/ - font Basic
#
DEPRECATED = """
=================================================================================

 d8888b. d88888b d8888b. d8888b. d88888b  .o88b.  .d8b.  d888888b d88888b d8888b.
 88  `8D 88'     88  `8D 88  `8D 88'     d8P  Y8 d8' `8b `~~88~~' 88'     88  `8D
 88   88 88ooooo 88oodD' 88oobY' 88ooooo 8P      88ooo88    88    88ooooo 88   88
 88   88 88~~~~~ 88~~~   88`8b   88~~~~~ 8b      88~~~88    88    88~~~~~ 88   88
 88  .8D 88.     88      88 `88. 88.     Y8b  d8 88   88    88    88.     88  .8D
 Y8888D' Y88888P 88      88   YD Y88888P  `Y88P' YP   YP    YP    Y88888P Y8888D'

=================================================================================
"""
EXCEPTION = """
============================================================================

d88888b db    db  .o88b. d88888b d8888b. d888888b d888888b  .d88b.  d8b   db
88'     `8b  d8' d8P  Y8 88'     88  `8D `~~88~~'   `88'   .8P  Y8. 888o  88
88ooooo  `8bd8'  8P      88ooooo 88oodD'    88       88    88    88 88V8o 88
88~~~~~  .dPYb.  8b      88~~~~~ 88~~~      88       88    88    88 88 V8o88
88.     .8P  Y8. Y8b  d8 88.     88         88      .88.   `8b  d8' 88  V888
Y88888P YP    YP  `Y88P' Y88888P 88         YP    Y888888P  `Y88P'  VP   V8P

============================================================================
"""
CAUTION = """
===============================================================
 .o88b.  .d8b.  db    db d888888b d888888b  .d88b.  d8b   db db
d8P  Y8 d8' `8b 88    88 `~~88~~'   `88'   .8P  Y8. 888o  88 88
8P      88ooo88 88    88    88       88    88    88 88V8o 88 YP
8b      88~~~88 88    88    88       88    88    88 88 V8o88
Y8b  d8 88   88 88b  d88    88      .88.   `8b  d8' 88  V888 db
 `Y88P' YP   YP ~Y8888P'    YP    Y888888P  `Y88P'  VP   V8P YP
===============================================================
"""





DOMAIN_DICT_DEPRECATION_WARNING = DEPRECATED + """
 - Please use a dict to describe domains in deployments.py , e.g.

    'domains': {
        'main': ['domain.tld'],
        'multisite1': ['domain2.tld'],
    }
=================================================================================
"""

DATABASES_DICT_DEPRECATION_WARNING = DEPRECATED + """
 - Please use a dict to describe databases in deployments.py , e.g.

    'databases': {
        'default': {
            'ENGINE': "django.db.backends.postgresql_psycopg2",
            'NAME': "username-dev",
            'USER': "username-dev",
        }
    }
=================================================================================
"""
########NEW FILE########
__FILENAME__ = newrelic
# -*- coding: utf-8 -*-
import sys
import subprocess
from functools import wraps

from fabric.api import task, env, prompt
from fabric.operations import run

from toolbox import logger


logged_output = {'stdout': "", 'stderr': ""}


class log_output():
    def __init__(self):
        global logged_output
        self.stdout_logger = logger.Logger(sys.stdout)
        self.stderr_logger = logger.Logger(sys.stderr)
        sys.stdout = self.stdout_logger
        sys.stderr = self.stderr_logger

    def __enter__(self):
        self.stdout_logger.clear()
        self.stderr_logger.clear()

    def __exit__(self, exc_type, exc_val, exc_tb):
        # TODO: Add exception handling?
        logged_output['stdout'] += self.stdout_logger.get_log()
        logged_output['stderr'] += self.stderr_logger.get_log()


def register_deployment(func):
    @wraps(func)
    def with_logging(*args, **kwargs):
        hash_before = run("cd %(path)s; git --no-pager log -1 --oneline %(branch)s --pretty='%%h'" % env)
        if hash_before == "":
            hash_before = False

        __func_ret = func(*args, **kwargs)

        try:
            handle = subprocess.check_output(["git", "config", "--get", "github.user"]).strip()
        except subprocess.CalledProcessError:
            handle = prompt("Please enter your GitHub username:")

        try:
            email = subprocess.check_output(["git", "config", "--get", "user.email"]).strip()
        except subprocess.CalledProcessError:
            email = prompt("Please enter your email address:")

        user = "%s (%s)" % (handle, email)

        log_base = "cd app && git --no-pager log -1 --oneline"
        commit_hash = run(log_base + " --pretty=%h")
        commit_message = run(log_base + " --pretty=%s")
        commit_author_name = run(log_base + " --pretty=%aN")

        if hash_before and hash_before != commit_hash:
            diff_url = "https://%s/compare/%s...%s" % (run("cd app && git config --get remote.origin.url").replace(
                "git@", "", 1).replace(":", "/", 1).replace(".git", "", 1), hash_before, commit_hash)
            msg = "%s from %s (%s)" % (commit_message, commit_author_name, diff_url)

        else:
            url = "https://%s/commit/%s" % (run("cd app && git config --get remote.origin.url").replace(
                "git@", "", 1).replace(":", "/", 1).replace(".git", "", 1), commit_hash)

            if hash_before and hash_before == commit_hash:
                msg = "No changes in the repository. %s" % url

            else:
                msg = "No pre-pull commit hash provided. %s" % url

        log = logged_output['stdout']
        if logged_output['stderr']:
            log += "\nErrors:\n%s" % str(logged_output['stderr'])

        options = {'app_name': env['user'], 'user': user, 'description': msg, 'revision': commit_hash, 'changelog': log}

        cmd = 'curl -H "x-api-key:%s"' % env['newrelic']['deployment_tracking_apikey']

        for key, val in options.items():
            cmd += ' --data-urlencode "deployment[%s]=%s"' % (key, val)

        cmd += " https://rpm.newrelic.com/deployments.xml"
        subprocess.call(cmd, shell=True)
        return __func_ret
    return with_logging

########NEW FILE########
__FILENAME__ = nginx
import StringIO
from fabric.decorators import task
from fabric.api import run, env, put

from dploi_fabric.toolbox.template import render_template
from dploi_fabric.utils import config
import posixpath


@task(alias="reload")
def reload_nginx():
    run('sudo /etc/init.d/nginx reload')
    
@task
def update_config_file(dryrun=False):
    output = ""
    for site, site_config in config.sites.items():
        context_dict = site_config
        context_dict.update({
            'domains': " ".join(site_config.deployment.get("domains")[site]),
            'www_processes': [site_config.processes[x] for x in site_config.processes if site_config.processes[x]["type"] == "gunicorn"],
        })
        template_path = context_dict['nginx']['template']
        output += render_template(template_path, context_dict)
    path = posixpath.abspath(posixpath.join(env.path, '..', 'config', 'nginx.conf'))
    if dryrun:
        print path + ':'
        print output
    else:
        put(StringIO.StringIO(output), path)
        reload_nginx()

########NEW FILE########
__FILENAME__ = project
import os

from fabric.api import env, task, prompt, run, put
from fabric.contrib import files
from dploi_fabric import git
from github import upload_ssh_deploy_key
from supervisor import update_config_file as supervisor_update_config_file
from nginx import update_config_file as nginx_update_config_file
import django_utils
from .utils import config


@task
def init():
    if files.exists(os.path.join(env.path, 'bin')):
        print "buildout environment exists already"
        return
    upload_ssh_deploy_key()
    run('mkdir -p %(path)s' % env)
    if env.repo.startswith('git'):
        run('cd %(path)s; git clone -b %(branch)s %(repo)s .' % env)
        git.update()
    elif env.repo.startswith('ssh+svn'):
        run('cd %(path)s; svn co %(repo)s' % env)
    tool = config.sites['main'].get('checkout',{}).get('tool')
    if tool == "buildout":
        run('cd %(path)s; sh init.sh -c %(buildout_cfg)s' % env)
        django_utils.append_settings()
    elif tool == "virtualenv":
        import virtualenv
        virtualenv.create()
        django_utils.append_settings()
        django_utils.manage("syncdb --all --noinput")
        django_utils.manage("migrate --fake")
    else:
        print "WARNING: Couldnt find [checkout] tool - please set it to either virtualenv or buildout in your config.ini"
        print "Got tool: %s" % tool
        django_utils.append_settings()
    supervisor_update_config_file()
    nginx_update_config_file()


@task
def upload_ssl():
    """
    Upload the SSL key and certificate to the directories and with the filenames
    specified in your settings.
    """
    for site, site_dict in config.sites.items():
        ssl_key_path = prompt("SSL Key path (%s):" % site)
        ssl_cert_path = prompt("SSL Certificate path (%s):" % site)
        put(ssl_key_path, site_dict.get("deployment").get("ssl_key_path"))
        put(ssl_cert_path, site_dict.get("deployment").get("ssl_cert_path"))

########NEW FILE########
__FILENAME__ = redis
# -*- coding: utf-8 -*-

import StringIO
import posixpath
from fabric.decorators import task
from fabric.api import run, env, put

from dploi_fabric.toolbox.template import render_template
from dploi_fabric.utils import config


@task
def update_config_file(dryrun=False):
    for site, site_config in config.sites.items():
        redis_processes = [(x, site_config.processes[x]) for x in site_config.processes if site_config.processes[x]["type"] == "redis"]
        template_path = site_config['redis']['template']
        print redis_processes
        for process_name, process in redis_processes:
            working_directoy = posixpath.normpath(posixpath.join(env.path, '..', 'data', 'redis', process_name))
            log_directory = posixpath.normpath(posixpath.join(env.path, '..', 'log', 'redis'))
            run('mkdir -p ' + working_directoy)
            run('mkdir -p ' + log_directory)
            context_dict = site_config
            context_dict.update({
                'site': site,
                'working_directory': working_directoy,
                'log_directory': log_directory,
                'process_name': process_name,
                'socket': process['socket'],
            })
            path = posixpath.abspath(posixpath.join(site_config['deployment']['path'], '..', 'config', process_name + '.conf'))
            output = render_template(template_path, context_dict)
            if dryrun:
                print path + ":"
                print output
            else:
                put(StringIO.StringIO(output), path)


########NEW FILE########
__FILENAME__ = solr

########NEW FILE########
__FILENAME__ = south
from fabric.api import env, run
from fabric.tasks import Task
from .utils import config

class SouthMigrateTask(Task):

    name = 'migrate'

    def run(self):
        config.django_manage("syncdb")
        config.django_manage("migrate")

migrate = SouthMigrateTask()
########NEW FILE########
__FILENAME__ = supervisor
import StringIO
from copy import copy
from fabric.decorators import task
from fabric.api import run, put, env
from dploi_fabric.toolbox.template import render_template
from dploi_fabric.utils import config
import posixpath


@task
def stop():
    for site, site_config in config.sites.items():
        run('sudo supervisorctl stop %s:*' %  get_group_name(site, site_config))


@task
def start():
    for site, site_config in config.sites.items():
        run('sudo supervisorctl start %s:*' % get_group_name(site, site_config))


@task
def restart():
    for site, site_config in config.sites.items():
        run('sudo supervisorctl restart %s:*' % get_group_name(site, site_config))


@task
def status():
    """
    print status of the supervisor process

    Note: "status" does not yet support the group syntax
    """
    for site, site_config in config.sites.items():
        group_name = get_group_name(site, site_config)
        for process_name, process_cmd in site_config.processes.items():
            run('sudo supervisorctl status %s:%s' % (group_name, process_name))


@task
def add():
    for site, site_config in config.sites.items():
        group_name = get_group_name(site, site_config)
        for process_name, process_cmd in site_config.processes.items():
            run('sudo supervisorctl add %s:%s' % (group_name, process_name))


@task
def update():
    for site, site_config in config.sites.items():
        group_name = get_group_name(site, site_config)
        for process_name, process_cmd in site_config.processes.items():
            run('sudo supervisorctl update %s:%s' % (group_name, process_name))


def get_group_name(site, site_config):
    return '%s-%s' % (site_config['deployment']['user'], site)


@task
def update_config_file(dryrun=False, update_command=update):
    output = ''
    groups = {}
    for site, site_config in config.sites.items():
        template_path = site_config['supervisor']['template']
        group_template_path = site_config['supervisor']['group_template']
        group_name = get_group_name(site, site_config)
        groups[group_name] = []
        for process_name, process_dict in site_config.processes.items():
            context_dict = copy(site_config)
            env_dict = {
                'HOME': site_config.deployment['home'],
                'USER': site_config.deployment['user'],
                'PYTHONPATH': ":".join([
                    site_config.deployment['path'],
                    posixpath.join(site_config.deployment['path'], site_config.get("django").get("base")+'/'),
                ]),
            }
            env_dict.update(site_config.environment)
            context_dict.update({
                'process_name': process_name,
                'process_cmd': process_dict["command"],
                'socket': process_dict["socket"],
                'env': env_dict,
                'priority': process_dict.get('priority', 200),
                'autostart': 'True' if getattr(env, 'autostart', True) else 'False',
                'killasgroup': process_dict.get('killasgroup', None),
                'stopasgroup': process_dict.get('killasgroup', None),
                'stopwaitsecs': process_dict.get('stopwaitsecs', None),
            })
            output += render_template(template_path, context_dict)
            groups[group_name].append(process_name)
    output += render_template(group_template_path, {'groups': groups})
    path = posixpath.abspath(posixpath.join(config.sites["main"].deployment['path'], '..', 'config', 'supervisor.conf'))
    if dryrun:
        print path + ':'
        print output
    else:
        put(StringIO.StringIO(output), path)
        update_command()

########NEW FILE########
__FILENAME__ = tests
import ConfigParser
import StringIO
import unittest
from dploi_fabric.utils import EnvConfigParser, Configuration, _AttributeDict, STATIC_COLLECTED

class TestConfigurationTestCase(unittest.TestCase):
    test_config = """
[django]
base = code_checkout/
append_settings = true
cmd = bin/whatever

[django:multisite1]
base = .
append_settings = false
cmd = bin/django

[static]
/static/ = %(static_collected)s

"""
    def setUp(self):
        self.env_dict = {
            'host_string': 'some.server.tld',
            'hosts': ['some.server.tld'],
            'path': '/home/username/app/',
            'user': 'username',
            'buildout_cfg': 'buildout.cfg',
            'repo': 'git@github.com:user/repo.git',
            'branch': 'master',
            'backup_dir': '/home/username/tmp/',
            'db_name': 'db-name',
            'db_username': 'db-name',
            'identifier': 'dev',
            'domains': {
                'main': ['main.domain.tld'],
                'multisite1': ['multisite1.domain.tld'],
            },
            'celery': {
                'concurrency': 32,
            }
        }
        self.sites = Configuration().load_sites(self.test_config, self.env_dict)

    def test_value_types(self):
        config = self.sites["main"]
        self.assertFalse(config.get("celery").get("enabled"))
        self.assertEqual(config.django.base, "code_checkout/")

        config = self.sites["multisite1"]
        self.assertEqual(config.django.base, ".")

    def test_celery(self):
        self.sites = Configuration().load_sites(self.test_config + """
[celery]
enabled=true""", self.env_dict)
        config = self.sites["main"]
        self.assertTrue(config.get("celery").get("enabled"))
        self.assertEqual(config.get("celery").get("concurrency"), 32)
        self.assertEqual(config.get("celery").get("maxtasksperchild"), 500)
        self.assertTrue("%s_%s_celeryd" % (config.deployment.get("user"), "main") in config.get("processes"))
        self.assertIn("celeryd  -E -B -c 32 --maxtasksperchild 500", config.get("processes").get("%s_%s_celeryd" % (config.deployment.get("user"), "main")).get("command"))

    def test_static(self):
        self.assertEqual(self.sites["main"].get("static").get("/static/"), STATIC_COLLECTED)



class TestInheritConfigParserRead(unittest.TestCase):
    test_config = """
[base]
name = test
type = nginx
count = 5
enable = false
threshold = 1.0

[base:dev]
host = dev.example.com
type = apache
count = 1
enable = True
threshold = 0.9

[other:dev]
foo = bar
"""
    def setUp(self):
        f = StringIO.StringIO(self.test_config)
        self.config = EnvConfigParser()
        self.config.readfp(f)

    def test_items(self):
        items = dict(self.config.items('base', env='dev'))
        self.assertIn('host', items)
        self.assertIn('name', items)

    def test_items_only_env(self):
        self.assertEqual(self.config.items('other', env='dev'), (('foo', 'bar'),))
        self.assertRaises(ConfigParser.NoSectionError, lambda: self.config.items('other'))

    def test_inherited_value(self):
        self.assertEquals(self.config.get('base', 'host', env='dev'), 'dev.example.com')

    def test_value_from_base(self):
        self.assertEquals(self.config.get('base', 'name', env='dev'), 'test')

    def test_overriden_value(self):
        self.assertEquals(self.config.get('base', 'type',), 'nginx')
        self.assertEquals(self.config.get('base', 'type', env='dev'), 'apache')

    def test_correct_exception_on_no_base(self):
        self.assertRaises(ConfigParser.NoOptionError, lambda: self.config.get('other', 'baz', env='dev'))

    def test_int(self):
        self.assertEquals(self.config.getint('base', 'count',), 5)
        self.assertEquals(self.config.getint('base', 'count', env='dev'), 1)

    def test_float(self):
        self.assertEquals(self.config.getfloat('base', 'threshold',), 1.0)
        self.assertEquals(self.config.getfloat('base', 'threshold', env='dev'), 0.9)

    def test_bool(self):
        self.assertFalse(self.config.getboolean('base', 'enable',))
        self.assertEqual(type(self.config.getboolean('base', 'enable',)), bool)
        self.assertTrue(self.config.getboolean('base', 'enable', env='dev'))

    def test_has_section(self):
        self.assertTrue(self.config.has_section('base'))
        self.assertTrue(self.config.has_section('base', env='dev'))
        self.assertTrue(self.config.has_section('base', env='stage'))
        self.assertFalse(self.config.has_section('base', env='stage', strict=True))
        self.assertTrue(self.config.has_section('other', env='dev'))
        self.assertFalse(self.config.has_section('other'))

    def test_section_namespaces(self):
        self.assertEqual(self.config.section_namespaces("base"), ["main", "dev"])


if __name__ == '__main__':
    unittest.main()
########NEW FILE########
__FILENAME__ = datastructures
# -*- coding: utf-8 -*-
import ConfigParser

class EnvConfigParser(ConfigParser.SafeConfigParser):
    """ A config parser that can handle "namespaced" sections. Example:

    [base]
    name = base

    [base:some-env]
    name = some-env

    """

    def _concat(self, parent, child):
        return '%s:%s' % (parent, child)

    def items(self, section, raw=False, vars=None, env=None):
        items = {}
        try:
            items.update(dict(ConfigParser.SafeConfigParser.items(self, section, raw, vars)))
        except ConfigParser.NoSectionError:
            pass
        if env:
            try:
                env_items = dict(ConfigParser.SafeConfigParser.items(self, self._concat(section, env), raw, vars))
                items.update(env_items)
            except ConfigParser.NoSectionError:
                pass
        if not items:
            raise ConfigParser.NoSectionError(self._concat(section, env) if env else section)
        return tuple(items.iteritems())

    def get(self, section, option, raw=False, vars=None, env=None):
        if env and self.has_section(self._concat(section, env)):
            try:
                return ConfigParser.SafeConfigParser.get(self, self._concat(section, env), option, raw, vars)
            except ConfigParser.NoOptionError:
                if not self.has_section(section):
                    raise
        return ConfigParser.SafeConfigParser.get(self, section, option, raw, vars)

    def _get(self, section, conv, option, env=None):
        return conv(self.get(section, option, env=env))

    def getint(self, section, option, env=None):
        return self._get(section, int, option, env)

    def getfloat(self, section, option, env=None):
        return self._get(section, float, option, env)

    def getboolean(self, section, option, env=None):
        v = self.get(section, option, env=env)
        if v.lower() not in self._boolean_states:
            raise ValueError, 'Not a boolean: %s' % v
        return self._boolean_states[v.lower()]

    def has_section(self, section, env=None, strict=False):
        if not env:
            return ConfigParser.SafeConfigParser.has_section(self,section)
        return (
            (not strict and ConfigParser.SafeConfigParser.has_section(self, section)) or
            ConfigParser.SafeConfigParser.has_section(self, self._concat(section, env))
            )

    def section_namespaces(self, section):
        namespaces = []
        for s in self.sections():
            s = s.split(":")
            if s[0] == section:
                if len(s) == 1:
                    namespaces.append("main")
                else:
                    namespaces.append(s[1])
        return namespaces

    def _interpolate(self, section, option, rawval, vars):
        return rawval

########NEW FILE########
__FILENAME__ = logger
# -*- coding: utf-8 -*-
class Logger():
    """
    Capture print statements and write them to a variable
    but still allow them to be printed on the screen.
    You can also redirect multiple streams into one Logger.
    """

    def __init__(self, stream):
        self.stream = stream
        self.log = ""

    def __getattr__(self, name):
        return getattr(self.stream, name)

    def write(self, text):
        self.stream.write(text)
        self.log += str(text)

    def get_log(self):
        return self.log

    def clear(self):
        self.log = ""

########NEW FILE########
__FILENAME__ = template
# -*- coding: utf-8 -*-
import os

from django.conf import settings
from django.template import Template
from django.template.context import Context

import dploi_fabric

settings.configure(DEBUG=True, TEMPLATE_DEBUG=True)

def render_template(path, context):
    if not isinstance(context, Context):
        context = Context(context)
    with open(path) as template_file:
        template = Template(template_file.read())
    return template.render(context)


def app_package_path(path):
    """
    returns the abs path with the dploi_fabric package as base
    """
    return os.path.abspath(os.path.join(os.path.dirname(dploi_fabric.__file__), path))

########NEW FILE########
__FILENAME__ = utils
from dploi_fabric.toolbox.template import app_package_path, render_template
import os
import posixpath

import StringIO
from fabric.operations import run, local
from fabric.api import task, env, get
from fabric.contrib.files import exists
from fabric.state import _AttributeDict


from dploi_fabric.toolbox.datastructures import EnvConfigParser
from dploi_fabric.messages import DOMAIN_DICT_DEPRECATION_WARNING

STATIC_COLLECTED = "../static/"
DATA_DIRECTORY = "../upload/"

class Configuration(object):
    """
    This class is the only correct source of information for this project.
    To reduce the amount of times config.ini is downloaded, it should always
    be used from utils.config, which is an instance of Configuration
    """
    #: Default values for the configuration
    defaults = {
        'django': {
            'base': '.',
            'append_settings': False,
            'cmd': 'bin/django',
            'args': [],
        },
        'checkout': {
            'tool': 'buildout',
        },
        'gunicorn': {
            'workers': 2,
            'maxrequests': 0,
        },
        'celery': {
            'enabled': False,
            'concurrency': 1,
            'maxtasksperchild': 500,
            'loglevel': 'WARNING',
            'celerycam': False,
            'version': None,
            'app': 'project',
        },
        'static': {

        },
        'redis': {
            'enabled': False,
            'appendonly': 'no',
            'template': app_package_path('templates/redis/redis.conf'),
        },
        'memcached': {
            'enabled': True,
            'size': 64,
        },
        'processes': {

        },
        'sendfile': {

        },
        'environment': {

        },
        'nginx': {
            'client_max_body_size': '10m',
            'template': app_package_path('templates/nginx/nginx.conf'),
        },
        'supervisor': {
            'template': app_package_path('templates/supervisor/supervisor.conf'),
            'group_template': app_package_path('templates/supervisor/supervisor-group.conf'),
            'gunicorn_command_template': app_package_path('templates/supervisor/gunicorn_command'),
            'celeryd_command_template': app_package_path('templates/supervisor/celeryd_command'),
            'celerycam_command_template': app_package_path('templates/supervisor/celerycam_command'),
        },
        'newrelic': {
            'enabled': False,
            'config_file': 'newrelic.ini',
            'environment_name': '',
            'license': '',
        }
    }
    def load_sites(self, config_file_content=None, env_dict=None):
        """
        Called from self.sites and returns a dictionary with the different sites
        and their individual settings.
        """
        if not config_file_content:
            if env.get("use_local_config_ini", False):
                output = open("config.ini")
            else:
                config_file = os.path.join(env.path, "config.ini")
                if exists(config_file):
                    output = StringIO.StringIO()
                    get(u"%s" % config_file, output)
                    output.seek(0)
                else:
                    raise Exception("Missing config.ini, tried path %s" % config_file)
        else:
            output = StringIO.StringIO(config_file_content)

        if not env_dict:
            env_dict = env

        config = EnvConfigParser()
        config.readfp(output)
        self._sites = {}
        for site in config.section_namespaces("django") or ["main"]:
            attr_dict = self.defaults.copy()
            for key, value in attr_dict.items():
                attr_dict[key] = _AttributeDict(value.copy())
            for section in config.sections():
                section = section.split(":")[0]
                if self.defaults.get(section) is None:
                    print "Caution: Section %s is not supported, skipped" % section
                    continue
                for option, default_value in config.items(section, env=site):
                    setting = self.defaults.get(section).get(option)
                    if type(setting) == bool:
                        value = config.getboolean(section, option, env=site)
                    elif type(setting) == int:
                        value = config.getint(section, option, env=site)
                    elif type(setting) == float:
                        value = config.getfloat(section, option, env=site)
                    else:
                        variables = {
                            'static_collected': STATIC_COLLECTED,
                            'data_directory': DATA_DIRECTORY,
                        }
                        value = config.get(section, option, env=site) % variables
                    attr_dict[section][option] = value
            self.sites[site] = _AttributeDict(attr_dict)
            attr_dict.update(self.deployment(site, env_dict))
            if attr_dict.get("checkout").get("tool") == "buildout":
                # e.g. bin/django -> /home/username/app/bin/django
                attr_dict["django"]["cmd"] = posixpath.join(
                    attr_dict.get("deployment").get("path"),
                    attr_dict.get("django").get("cmd")
                )
            else:
                # e.g. manage.py -> /home/username/app/bin/python /home/username/app/manage.py
                new_django_cmd = [
                    posixpath.join(
                        attr_dict.get("deployment").get("path"),
                        "bin/python",
                    ),
                    posixpath.join(
                        attr_dict.get("deployment").get("path"),
                        attr_dict.get("django").get("base"),
                        attr_dict.get("django").get("cmd")
                    )
                ]
                attr_dict["django"]["cmd"] = " ".join(new_django_cmd)
                if attr_dict["django"]["append_settings"]:
                    attr_dict["django"]["args"].append(" --settings=%s" % ('_gen.settings', ))
            if attr_dict["newrelic"]["enabled"]:
                attr_dict["django"]["cmd"] = posixpath.join(
                    attr_dict.get("deployment").get("path"),
                    "bin/newrelic-admin"
                ) +  " run-program " + attr_dict["django"]["cmd"]
            attr_dict.update({'processes': self.processes(site, env_dict)})
            attr_dict['environment'] = self.environment(site, env_dict)
            attr_dict['environment'].setdefault('DEPLOYMENT_SITE', site)
            if attr_dict['deployment']['django_settings_module']:
                attr_dict['environment']['DJANGO_SETTINGS_MODULE'] = attr_dict['deployment']['django_settings_module']
            attr_dict['environment_export'] = self.build_environment_export(attr_dict['environment'])
            attr_dict['identifier'] = env_dict.identifier
            self._sites[site] = _AttributeDict(attr_dict)
        return self._sites

    def build_environment_export(self, environment):
        """
        takes a dict with environment variables and products a shell compatible export statement:
        'export PYTHONPATH="stuff/here:more/here" USER="mysite-dev";'
        """
        vars = " ".join([u'%s=%s' % (key, value) for key, value in environment.items()])
        return u"export %s;" % vars

    @property
    def sites(self):
        if getattr(self, "_sites", False) == False:
            self.load_sites()
        return self._sites

    def processes(self, site, env_dict):
        """
        Returns a dictionary of dictionaries each having the following keys:

        * command
            command to be run by supervisor
        * port
            port number,
        * socket
            path to unix socket
        * type
            gunicorn/memcached/celeryd
        """
        process_dict = {}
        site_dict = self.sites[site]
        common_cmd_context = {
            "django_cmd": site_dict.django['cmd'],
            "django_args": " ".join(site_dict.get("django").get("args", [])),
        }
        gunicorn_cmd_context = {
            "socket": posixpath.normpath(posixpath.join(env_dict.get("path"), "..", "tmp", "%s_%s_gunicorn.sock" % (env_dict.get("user"), site))), # Asserts pony project layout
            "workers": site_dict.gunicorn['workers'],
            "maxrequests": site_dict.gunicorn['maxrequests'],
        }
        gunicorn_cmd_context.update(common_cmd_context)
        gunicorn_command_template_path = self.sites[site]['supervisor']['gunicorn_command_template']
        gunicorn_command = render_template(gunicorn_command_template_path, gunicorn_cmd_context)
        process_dict["%s_%s_gunicorn" % (env_dict.get("user"), site)] = {
                    'command': gunicorn_command,
                    'port': None,
                    'socket': gunicorn_cmd_context['socket'],
                    'type': 'gunicorn',
                    'priority': 100,
                }

        if site_dict.get("memcached").get("enabled"):
            memcached_socket = posixpath.normpath(posixpath.join(env_dict.get("path"), "..", "tmp", "%s_%s_memcached.sock" % (env_dict.get("user"), site))) # Asserts pony project layout
            process_dict["%s_%s_memcached" % (env_dict.get("user"), site)] = {
                        'command': "memcached -s %s -m %d" % (memcached_socket, int(site_dict.get("memcached").get("size"))),
                        'port': None,
                        'socket': memcached_socket,
                        'type': 'memcached',
                        'priority': 60,
                }
        if site_dict.get("celery").get("enabled"):
            conf = site_dict.get("celery")
            cmd = env_dict.get("path") if not site_dict.get("newrelic").get("enabled") else '%sbin/newrelic-admin run-program %s' % (env_dict.get("path"), env_dict.get("path"))
            cmd += 'bin/celery'
            celeryd_command_context = {
                'concurrency': conf.get("concurrency"),
                'maxtasksperchild': conf.get("maxtasksperchild"),
                'loglevel': conf.get("loglevel"),
                'path': env_dict.get("path"),
                'version': conf.get("version"),
                'celery_app': conf.get("app"),
                'has_cam': conf.get("celerycam"),
                'cmd': cmd,
                'pidfile': posixpath.normpath(posixpath.join(env_dict.get("path"), '..', 'tmp', 'celery-%s.pid' % site)),
            }
            celeryd_command_context.update(common_cmd_context)
            celeryd_command_template_path = self.sites[site]['supervisor']['celeryd_command_template']
            celeryd_command = render_template(celeryd_command_template_path, celeryd_command_context)
            process_dict["%s_%s_celeryd" % (env_dict.get("user"), site)] = {
                    'command': celeryd_command,
                    'port': None,
                    'socket': None,
                    'type': 'celeryd',
                    'priority': 40,
                    'stopasgroup': 'true',
                    'killasgroup': 'true',
                    'stopwaitsecs': conf.get('stopwaitsecs', None),
                }
            if conf.get("celerycam"):
                celerycam_command_context = {
                    'loglevel': conf.get("loglevel"),
                    'path': env_dict.get("path"),
                    'version': conf.get("version"),
                    'celery_app': conf.get("app"),
                    'cmd': cmd,
                }
                celerycam_command_context.update(common_cmd_context)
                celerycam_command_template_path = self.sites[site]['supervisor']['celerycam_command_template']
                celerycam_command = render_template(celerycam_command_template_path, celerycam_command_context)
                process_dict["%s_%s_celerycam" % (env_dict.get("user"), site)] = {
                    'command': celerycam_command,
                    'port': None,
                    'socket': None,
                    'type': 'celerycam',
                    'priority': 50,
                }
        if site_dict.get("redis").get("enabled"):
            process_name = "%s_%s_redis" % (env_dict.get("user"), site)
            redis_socket = posixpath.normpath(posixpath.join(env_dict.get("path"), "..", "tmp", process_name + ".sock" )) # Asserts pony project layout
            process_dict[process_name] = {
                'command': "/usr/bin/redis-server %s" % posixpath.normpath(posixpath.join(env_dict.get('path'), '..', 'config', process_name + '.conf')),
                'port': None,
                'socket': redis_socket,
                'type': 'redis',
                'priority': 20,
            }
        if site_dict.get('processes'):
            processes = site_dict.get('processes')
            for process, command in processes.iteritems():
                process_name = "%s_%s_process_%s" % (env_dict.get("user"), site, process)
                process_dict[process_name] = {
                    'command': posixpath.join(env_dict.get("path"), command),
                    'port': None,
                    'socket': None,
                    'type': 'supervisor',
                    'priority': env_dict.get("priority", 200),
                }

        return process_dict

    def environment(self, site, env_dict):
        site_dict = self.sites[site]
        return site_dict['environment']

    def deployment(self, site, env_dict):
        """
        Here we add the information from deployments.py and merge it into our site dictionaries.
        Can also be used to output warnings to the user, if he is using an old deployments.py
        format.
        """
        deployment_dict = {
            # Old settings
            'servername': env_dict.get("host_string"),
            'path': env_dict.get("path"),
            'backup_dir': env_dict.get("backup_dir"),
            'repo': env_dict.get("repo"),
            'branch': env_dict.get("branch"),
            'user': env_dict.get("user"),
            'buildout_cfg': env_dict.get("buildout_cfg"),
            'django_settings_module': env_dict.get("django_settings_module"),
            'generated_settings_path': posixpath.join(env_dict.get("path"), "_gen/settings.py"),

            # New settings
            'domains_redirect': env_dict.get('domains_redirect'),
            'url_redirect': env_dict.get('url_redirect'),

            'basic_auth': env_dict.get('basic_auth', False),
            'basic_auth_path': os.path.join(env_dict.get("path"), env_dict.get('basic_auth_path', None) or ""),

            'ssl': env.get('ssl', False),
            'ssl_cert_path': os.path.join(env_dict.get("path"), env_dict.get('ssl_cert_path', None) or ""),
            'ssl_key_path': os.path.join(env_dict.get("path"), env_dict.get('ssl_key_path', None) or ""),
            'bind_ip': env_dict.get('bind_ip', '*'),
            'static_error_pages': env_dict.get('static_error_pages', []),
            'big_body_endpoints': env_dict.get('big_body_endpoints', []),
            'home': '/home/%s' %  env_dict.get("user"),
        }

        if not env_dict.get("databases"):
            deployment_dict["databases"] = {
                'default': {
                    'ENGINE': env_dict.get("db_engine", "django.db.backends.postgresql_psycopg2"),
                    'NAME': env_dict.get("db_name"),
                    'USER': env_dict.get("db_username"),
                    'PASSWORD': env_dict.get("db_password"),
                    'HOST': env_dict.get("db_host", ""),
                }
            }

        if type(env_dict.get("domains")) == list:
            domains = {
                "main": env_dict.get("domains"),
            }
            print(DOMAIN_DICT_DEPRECATION_WARNING)
        elif type(env_dict.get("domains")) == dict:
            domains = env_dict.get("domains")
        elif env_dict.get("domains") is None:
            domains = {
                "main": [],
            }
            print("Warning: No domains supplied in settings, ignoring.")
        else:
            raise Exception("Invalid domain format")
        deployment_dict.update({'domains': domains})

        ###############
        # Environment #
        ###############

        environment_dict = self.sites[site].get("environment")
        for key, value in env_dict.get("environment", {}).items():
            environment_dict[key] = value

        #################
        # Gunicorn dict #
        #################
        gunicorn_dict = self.sites[site].get("gunicorn")
        gunicorn_dict["workers"] = env_dict.get("gunicorn", {}).get("workers", gunicorn_dict.get("workers"))
        gunicorn_dict["maxrequests"] = env_dict.get("gunicorn", {}).get("maxrequests", gunicorn_dict.get("maxrequests"))

        ###############
        # Celery dict #
        ###############
        celery_dict = self.sites[site].get("celery")

        celery_dict["concurrency"] = env_dict.get("celery", {}).get("concurrency", celery_dict.get("concurrency"))
        celery_dict["maxtasksperchild"] = env_dict.get("celery", {}).get("maxtasksperchild", celery_dict.get("maxtasksperchild"))

        ##############
        # nginx dict #
        ##############

        nginx_dict = self.sites[site].get("nginx")
        nginx_dict["location_settings"] = {
            "client_max_body_size": env_dict.get("nginx", {}).get("client_max_body_size", nginx_dict.get("client_max_body_size")),
        }
        nginx_dict["template"] = env_dict.get("nginx", {}).get("template", nginx_dict.get("template"))

        ##############
        # redis dict #
        ##############

        redis_dict = self.sites[site].get("redis")
        redis_dict["template"] = env_dict.get("redis", {}).get("template", redis_dict.get("template"))

        ###################
        # supervisor dict #
        ###################

        supervisor_dict = self.sites[site].get("supervisor")
        supervisor_dict["template"] = env_dict.get("supervisor", {}).get("template", supervisor_dict.get("template"))
        supervisor_dict["group_template"] = env_dict.get("supervisor", {}).get("group_template", supervisor_dict.get("group_template"))
        supervisor_dict["gunicorn_command_template"] = env_dict.get("supervisor", {}).get("gunicorn_command_template", supervisor_dict.get("gunicorn_command_template"))
        supervisor_dict["celeryd_command_template"] = env_dict.get("supervisor", {}).get("celeryd_command_template", supervisor_dict.get("celeryd_command_template"))
        supervisor_dict["celerycam_command_template"] = env_dict.get("supervisor", {}).get("celerycam_command_template", supervisor_dict.get("celerycam_command_template"))

        #################
        # newrelic dict #
        #################

        newrelic_dict = self.sites[site].get("newrelic")
        newrelic_dict["enabled"] = env_dict.get("newrelic", {}).get("enabled", newrelic_dict.get("enabled"))
        newrelic_dict["config_file"] = env_dict.get("newrelic", {}).get("config_file", newrelic_dict.get("config_file"))
        if not newrelic_dict["config_file"].startswith('/'):
            newrelic_dict["config_file"] = posixpath.abspath(posixpath.join(
                    deployment_dict["path"],
                    newrelic_dict["config_file"],
                ))
        self.sites[site]["environment"]["NEW_RELIC_CONFIG_FILE"] = newrelic_dict["config_file"]
        newrelic_dict["environment_name"] = env_dict.get("newrelic", {}).get("environment_name", newrelic_dict.get("environment_name"))
        if newrelic_dict["environment_name"]:
            self.sites[site]["environment"]["NEW_RELIC_ENVIRONMENT"] = newrelic_dict["environment_name"]

        newrelic_dict["license_key"] = env_dict.get("newrelic", {}).get("license_key", newrelic_dict.get("license_key"))
        if newrelic_dict["license_key"]:
            self.sites[site]["environment"]["NEW_RELIC_LICENSE_KEY"] = newrelic_dict["license_key"]

        return {
            'deployment': deployment_dict,
            'environment': environment_dict,
            'gunicorn': gunicorn_dict,
            'celery': celery_dict,
            'nginx': nginx_dict,
            'redis': redis_dict,
            'supervisor': supervisor_dict,
            'newrelic': newrelic_dict,
        }

    def django_manage(self, command, site="main"):
        """
        Wrapper around the commands to inject the correct pythonpath.

        Example: django_manage("migrate"), could result in

        export PYTONPATH=/home/app-dev/app/; /home/app-dev/app/bin/python /home/app-dev/app/manage.py migrate
        """
        site_dict = config.sites[site]
        cmd = site_dict.get("django").get("cmd")
        django_args = " ".join(site_dict.get("django").get("args", []))
        run('%s %s %s %s' % (site_dict['environment_export'], cmd, command, django_args))

if not __name__ == '__main__':
    #: A shared instance of configuration, always to be used
    config = Configuration()


@task
def check_config():
    for section in config_ini.config_parser.sections():
        print "[%s]" % section
        print config_ini.config_parser.items(section)

@task
def uname():
    print env.host_string
    run('uname -a')

@task
def ls():
    run('cd %(path)s;ls -lAF' % env)

@task
def ps():
    """
    show processes of this user
    """
    run('ps -f -u %(user)s | grep -v "ps -f" | grep -v sshd' % env)

@task
def download_media(to_dir="./tmp/media/", from_dir="../upload/media/"):
    """
    Downloads media from a remote folder, default ../uploads/ -> ./tmp/media/

    * Example: download_media:from_dir="py_src/project/media/"
    """
    print "Downloading media from", env.host_string
    env.from_dir = from_dir
    local('rsync -avz --no-links --progress --exclude=".svn" -e "ssh" %(user)s@%(host_string)s:"%(path)s/%(from_dir)s"' % env + " " +to_dir)

@task
def upload_media(from_dir="./tmp/media/", to_dir="../upload/media/"):
    """
    Uploads media from a local folder, default ./tmp/media -> ../uploads/
    
    * Example: upload_media:to_dir="py_src/project/media/"
    """
    print "Uploading media to", env.host_string
    env.to_dir = to_dir
    local('rsync -avz --no-links --progress --exclude=".svn" '+ from_dir +' -e "ssh" %(user)s@%(host_string)s:"%(path)s/%(to_dir)s"' % env)


@task
def use_local_config_ini():
    env.use_local_config_ini = True

########NEW FILE########
__FILENAME__ = virtualenv
from fabric.operations import run as do_run
from fabric.api import task
from .utils import config

@task
def update():
    """
    updates a virtualenv (pip install requirements.txt)
    """
    do_run('cd %(path)s; bin/pip install -r requirements.txt --upgrade --no-deps' % config.sites["main"].deployment)

@task
def create():
    """
    creates a virtualenv and calls update
    """
    do_run('cd %(path)s; virtualenv . --system-site-packages --setuptools' % config.sites["main"].deployment)
    update()
    # this is ugly. I know. But it seems that on first run, pip does not
    # install the correct version of packages that are pulled directly from
    # git. Only the second time around it uses the correct one.
    update()

########NEW FILE########
__FILENAME__ = metadata
package_name = 'dploi_fabric'
name = 'dploi-fabric'
author = 'Benjamin Wohlwend, Kristian Oellegaard, Stefan Foulis'
author_email = 'developers@divio.ch'
description = "A collection of fabric tasks"
version = __import__(package_name).__version__
project_url = 'http://github.com/dploi/%s' % name
license = 'TBA'

########NEW FILE########
