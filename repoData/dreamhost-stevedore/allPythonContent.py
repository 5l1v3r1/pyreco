__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# stevedore documentation build configuration file, created by
# sphinx-quickstart on Sun Jul 22 14:01:09 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import datetime
import subprocess

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = [
    'sphinx.ext.autodoc',
    'sphinx.ext.todo',
    'sphinx.ext.graphviz',
    'sphinx.ext.extlinks',
]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'stevedore'
copyright = u'%s, DreamHost' % datetime.date.today().year

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = subprocess.Popen(['sh', '-c', 'cd ../..; python setup.py --version'],
                           stdout=subprocess.PIPE).stdout.read()
version = version.strip()
# The full version, including alpha/beta/rc tags.
release = version

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'stevedoredoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'stevedore.tex', u'stevedore Documentation',
   u'DreamHost', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
# man_pages = [
#     ('index', 'stevedore', u'stevedore Documentation',
#      [u'DreamHost'], 1)
# ]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'stevedore', u'stevedore Documentation',
   u'DreamHost', 'stevedore', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

extlinks = {
    'issue': ('https://github.com/dreamhost/stevedore/issues/%s', 'issue '),
}

autodoc_default_flags = ['members', 'special-members', 'show-inheritance']

########NEW FILE########
__FILENAME__ = dispatch
import logging

from .enabled import EnabledExtensionManager

LOG = logging.getLogger(__name__)


class DispatchExtensionManager(EnabledExtensionManager):
    """Loads all plugins and filters on execution.

    This is useful for long-running processes that need to pass
    different inputs to different extensions.

    :param namespace: The namespace for the entry points.
    :type namespace: str
    :param check_func: Function to determine which extensions to load.
    :type check_func: callable
    :param invoke_on_load: Boolean controlling whether to invoke the
        object returned by the entry point after the driver is loaded.
    :type invoke_on_load: bool
    :param invoke_args: Positional arguments to pass when invoking
        the object returned by the entry point. Only used if invoke_on_load
        is True.
    :type invoke_args: tuple
    :param invoke_kwds: Named arguments to pass when invoking
        the object returned by the entry point. Only used if invoke_on_load
        is True.
    :type invoke_kwds: dict
    :param propagate_map_exceptions: Boolean controlling whether exceptions
        are propagated up through the map call or whether they are logged and
        then ignored
    :type invoke_on_load: bool
    """

    def map(self, filter_func, func, *args, **kwds):
        """Iterate over the extensions invoking func() for any where
        filter_func() returns True.

        The signature of filter_func() should be::

            def filter_func(ext, *args, **kwds):
                pass

        The first argument to filter_func(), 'ext', is the
        :class:`~stevedore.extension.Extension`
        instance. filter_func() should return True if the extension
        should be invoked for the input arguments.

        The signature for func() should be::

            def func(ext, *args, **kwds):
                pass

        The first argument to func(), 'ext', is the
        :class:`~stevedore.extension.Extension` instance.

        Exceptions raised from within func() are propagated up and
        processing stopped if self.propagate_map_exceptions is True,
        otherwise they are logged and ignored.

        :param filter_func: Callable to test each extension.
        :param func: Callable to invoke for each extension.
        :param args: Variable arguments to pass to func()
        :param kwds: Keyword arguments to pass to func()
        :returns: List of values returned from func()
        """
        if not self.extensions:
            # FIXME: Use a more specific exception class here.
            raise RuntimeError('No %s extensions found' % self.namespace)
        response = []
        for e in self.extensions:
            if filter_func(e, *args, **kwds):
                self._invoke_one_plugin(response.append, func, e, args, kwds)
        return response

    def map_method(self, filter_func, method_name, *args, **kwds):
        """Iterate over the extensions invoking each one's object method called
        `method_name` for any where filter_func() returns True.

        This is equivalent of using :meth:`map` with func set to
        `lambda x: x.obj.method_name()`
        while being more convenient.

        Exceptions raised from within the called method are propagated up
        and processing stopped if self.propagate_map_exceptions is True,
        otherwise they are logged and ignored.

        .. versionadded:: 0.12

        :param filter_func: Callable to test each extension.
        :param method_name: The extension method name to call
                            for each extension.
        :param args: Variable arguments to pass to method
        :param kwds: Keyword arguments to pass to method
        :returns: List of values returned from methods
        """
        return self.map(filter_func, self._call_extension_method,
                        method_name, *args, **kwds)


class NameDispatchExtensionManager(DispatchExtensionManager):
    """Loads all plugins and filters on execution.

    This is useful for long-running processes that need to pass
    different inputs to different extensions and can predict the name
    of the extensions before calling them.

    The check_func argument should return a boolean, with ``True``
    indicating that the extension should be loaded and made available
    and ``False`` indicating that the extension should be ignored.

    :param namespace: The namespace for the entry points.
    :type namespace: str
    :param check_func: Function to determine which extensions to load.
    :type check_func: callable
    :param invoke_on_load: Boolean controlling whether to invoke the
        object returned by the entry point after the driver is loaded.
    :type invoke_on_load: bool
    :param invoke_args: Positional arguments to pass when invoking
        the object returned by the entry point. Only used if invoke_on_load
        is True.
    :type invoke_args: tuple
    :param invoke_kwds: Named arguments to pass when invoking
        the object returned by the entry point. Only used if invoke_on_load
        is True.
    :type invoke_kwds: dict
    :param propagate_map_exceptions: Boolean controlling whether exceptions
        are propagated up through the map call or whether they are logged and
        then ignored
    :type invoke_on_load: bool

    """

    def __init__(self, namespace, check_func, invoke_on_load=False,
                 invoke_args=(), invoke_kwds={},
                 propagate_map_exceptions=False):
        super(NameDispatchExtensionManager, self).__init__(
            namespace=namespace,
            check_func=check_func,
            invoke_on_load=invoke_on_load,
            invoke_args=invoke_args,
            invoke_kwds=invoke_kwds,
            propagate_map_exceptions=propagate_map_exceptions,
        )

    def _init_plugins(self, extensions):
        super(NameDispatchExtensionManager, self)._init_plugins(extensions)
        self.by_name = dict((e.name, e) for e in self.extensions)

    def map(self, names, func, *args, **kwds):
        """Iterate over the extensions invoking func() for any where
        the name is in the given list of names.

        The signature for func() should be::

            def func(ext, *args, **kwds):
                pass

        The first argument to func(), 'ext', is the
        :class:`~stevedore.extension.Extension` instance.

        Exceptions raised from within func() are propagated up and
        processing stopped if self.propagate_map_exceptions is True,
        otherwise they are logged and ignored.

        :param names: List or set of name(s) of extension(s) to invoke.
        :param func: Callable to invoke for each extension.
        :param args: Variable arguments to pass to func()
        :param kwds: Keyword arguments to pass to func()
        :returns: List of values returned from func()
        """
        response = []
        for name in names:
            try:
                e = self.by_name[name]
            except KeyError:
                LOG.debug('Missing extension %r being ignored', name)
            else:
                self._invoke_one_plugin(response.append, func, e, args, kwds)
        return response

    def map_method(self, names, method_name, *args, **kwds):
        """Iterate over the extensions invoking each one's object method called
        `method_name` for any where the name is in the given list of names.

        This is equivalent of using :meth:`map` with func set to
        `lambda x: x.obj.method_name()`
        while being more convenient.

        Exceptions raised from within the called method are propagated up
        and processing stopped if self.propagate_map_exceptions is True,
        otherwise they are logged and ignored.

        .. versionadded:: 0.12

        :param names: List or set of name(s) of extension(s) to invoke.
        :param method_name: The extension method name
                            to call for each extension.
        :param args: Variable arguments to pass to method
        :param kwds: Keyword arguments to pass to method
        :returns: List of values returned from methods
        """
        return self.map(names, self._call_extension_method,
                        method_name, *args, **kwds)

########NEW FILE########
__FILENAME__ = driver
from .named import NamedExtensionManager


class DriverManager(NamedExtensionManager):
    """Load a single plugin with a given name from the namespace.

    :param namespace: The namespace for the entry points.
    :type namespace: str
    :param name: The name of the driver to load.
    :type name: str
    :param invoke_on_load: Boolean controlling whether to invoke the
        object returned by the entry point after the driver is loaded.
    :type invoke_on_load: bool
    :param invoke_args: Positional arguments to pass when invoking
        the object returned by the entry point. Only used if invoke_on_load
        is True.
    :type invoke_args: tuple
    :param invoke_kwds: Named arguments to pass when invoking
        the object returned by the entry point. Only used if invoke_on_load
        is True.
    :type invoke_kwds: dict
    """

    def __init__(self, namespace, name,
                 invoke_on_load=False, invoke_args=(), invoke_kwds={}):
        super(DriverManager, self).__init__(
            namespace=namespace,
            names=[name],
            invoke_on_load=invoke_on_load,
            invoke_args=invoke_args,
            invoke_kwds=invoke_kwds,
        )

    @classmethod
    def make_test_instance(cls, extension, namespace='TESTING',
                           propagate_map_exceptions=False):
        """Construct a test DriverManager

        Test instances are passed a list of extensions to work from rather
        than loading them from entry points.

        :param extension: Pre-configured Extension instance
        :type extension: :class:`~stevedore.extension.Extension`
        :param namespace: The namespace for the manager; used only for
            identification since the extensions are passed in.
        :type namespace: str
        :param propagate_map_exceptions: Boolean controlling whether exceptions
            are propagated up through the map call or whether they are logged
            and then ignored
        :type propagate_map_exceptions: bool
        :return: The manager instance, initialized for testing

        """

        o = super(DriverManager, cls).make_test_instance(
            [extension], namespace=namespace,
            propagate_map_exceptions=propagate_map_exceptions)
        return o

    def _init_plugins(self, extensions):
        super(DriverManager, self)._init_plugins(extensions)

        if not self.extensions:
            name = self._names[0]
            raise RuntimeError('No %r driver found, looking for %r' %
                               (self.namespace, name))
        if len(self.extensions) > 1:
            discovered_drivers = ','.join(e.entry_point_target
                                          for e in self.extensions)

            raise RuntimeError('Multiple %r drivers found: %s' %
                               (self.namespace, discovered_drivers))

    def __call__(self, func, *args, **kwds):
        """Invokes func() for the single loaded extension.

        The signature for func() should be::

            def func(ext, *args, **kwds):
                pass

        The first argument to func(), 'ext', is the
        :class:`~stevedore.extension.Extension` instance.

        Exceptions raised from within func() are logged and ignored.

        :param func: Callable to invoke for each extension.
        :param args: Variable arguments to pass to func()
        :param kwds: Keyword arguments to pass to func()
        :returns: List of values returned from func()
        """
        results = self.map(func, *args, **kwds)
        if results:
            return results[0]

    @property
    def driver(self):
        """Returns the driver being used by this manager.
        """
        ext = self.extensions[0]
        return ext.obj if ext.obj else ext.plugin

########NEW FILE########
__FILENAME__ = enabled
import logging

from .extension import ExtensionManager


LOG = logging.getLogger(__name__)


class EnabledExtensionManager(ExtensionManager):
    """Loads only plugins that pass a check function.

    The check_func argument should return a boolean, with ``True``
    indicating that the extension should be loaded and made available
    and ``False`` indicating that the extension should be ignored.

    :param namespace: The namespace for the entry points.
    :type namespace: str
    :param check_func: Function to determine which extensions to load.
    :type check_func: callable
    :param invoke_on_load: Boolean controlling whether to invoke the
        object returned by the entry point after the driver is loaded.
    :type invoke_on_load: bool
    :param invoke_args: Positional arguments to pass when invoking
        the object returned by the entry point. Only used if invoke_on_load
        is True.
    :type invoke_args: tuple
    :param invoke_kwds: Named arguments to pass when invoking
        the object returned by the entry point. Only used if invoke_on_load
        is True.
    :type invoke_kwds: dict
    :param propagate_map_exceptions: Boolean controlling whether exceptions
        are propagated up through the map call or whether they are logged and
        then ignored
    :type propagate_map_exceptions: bool

    """

    def __init__(self, namespace, check_func, invoke_on_load=False,
                 invoke_args=(), invoke_kwds={},
                 propagate_map_exceptions=False):
        self.check_func = check_func
        super(EnabledExtensionManager, self).__init__(
            namespace,
            invoke_on_load=invoke_on_load,
            invoke_args=invoke_args,
            invoke_kwds=invoke_kwds,
            propagate_map_exceptions=propagate_map_exceptions,
        )

    def _load_one_plugin(self, ep, invoke_on_load, invoke_args, invoke_kwds):
        ext = super(EnabledExtensionManager, self)._load_one_plugin(
            ep, invoke_on_load, invoke_args, invoke_kwds,
        )
        if ext and not self.check_func(ext):
            LOG.debug('ignoring extension %r', ep.name)
            return None
        return ext

########NEW FILE########
__FILENAME__ = base
import abc


class FormatterBase(object):
    """Base class for example plugin used in the tutoral.
    """

    __metaclass__ = abc.ABCMeta

    def __init__(self, max_width=60):
        self.max_width = max_width

    @abc.abstractmethod
    def format(self, data):
        """Format the data and return unicode text.

        :param data: A dictionary with string keys and simple types as
                     values.
        :type data: dict(str:?)
        :returns: Iterable producing the formatted text.
        """

########NEW FILE########
__FILENAME__ = fields
import textwrap

from stevedore.example import base


class FieldList(base.FormatterBase):
    """Format values as a reStructuredText field list.

    For example::

      : name1 : value
      : name2 : value
      : name3 : a long value
          will be wrapped with
          a hanging indent
    """

    def format(self, data):
        """Format the data and return unicode text.

        :param data: A dictionary with string keys and simple types as
                     values.
        :type data: dict(str:?)
        """
        for name, value in sorted(data.items()):
            full_text = ': {name} : {value}'.format(
                name=name,
                value=value,
            )
            wrapped_text = textwrap.fill(
                full_text,
                initial_indent='',
                subsequent_indent='    ',
                width=self.max_width,
            )
            yield wrapped_text + '\n'

########NEW FILE########
__FILENAME__ = load_as_driver
from __future__ import print_function

import argparse

from stevedore import driver


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument(
        'format',
        nargs='?',
        default='simple',
        help='the output format',
    )
    parser.add_argument(
        '--width',
        default=60,
        type=int,
        help='maximum output width for text',
    )
    parsed_args = parser.parse_args()

    data = {
        'a': 'A',
        'b': 'B',
        'long': 'word ' * 80,
    }

    mgr = driver.DriverManager(
        namespace='stevedore.example.formatter',
        name=parsed_args.format,
        invoke_on_load=True,
        invoke_args=(parsed_args.width,),
    )
    for chunk in mgr.driver.format(data):
        print(chunk, end='')

########NEW FILE########
__FILENAME__ = load_as_extension
from __future__ import print_function

import argparse

from stevedore import extension


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '--width',
        default=60,
        type=int,
        help='maximum output width for text',
    )
    parsed_args = parser.parse_args()

    data = {
        'a': 'A',
        'b': 'B',
        'long': 'word ' * 80,
    }

    mgr = extension.ExtensionManager(
        namespace='stevedore.example.formatter',
        invoke_on_load=True,
        invoke_args=(parsed_args.width,),
    )

    def format_data(ext, data):
        return (ext.name, ext.obj.format(data))

    results = mgr.map(format_data, data)

    for name, result in results:
        print('Formatter: {0}'.format(name))
        for chunk in result:
            print(chunk, end='')
        print('')

########NEW FILE########
__FILENAME__ = simple
from stevedore.example import base


class Simple(base.FormatterBase):
    """A very basic formatter.
    """

    def format(self, data):
        """Format the data and return unicode text.

        :param data: A dictionary with string keys and simple types as
                     values.
        :type data: dict(str:?)
        """
        for name, value in sorted(data.items()):
            line = '{name} = {value}\n'.format(
                name=name,
                value=value,
            )
            yield line

########NEW FILE########
__FILENAME__ = extension
"""ExtensionManager
"""

import pkg_resources

import logging


LOG = logging.getLogger(__name__)


class Extension(object):
    """Book-keeping object for tracking extensions.

    The arguments passed to the constructor are saved as attributes of
    the instance using the same names, and can be accessed by the
    callables passed to :meth:`map` or when iterating over an
    :class:`ExtensionManager` directly.

    :param name: The entry point name.
    :type name: str
    :param entry_point: The EntryPoint instance returned by
        :mod:`pkg_resources`.
    :type entry_point: EntryPoint
    :param plugin: The value returned by entry_point.load()
    :param obj: The object returned by ``plugin(*args, **kwds)`` if the
                manager invoked the extension on load.

    """

    def __init__(self, name, entry_point, plugin, obj):
        self.name = name
        self.entry_point = entry_point
        self.plugin = plugin
        self.obj = obj

    @property
    def entry_point_target(self):
        """The module and attribute referenced by this extension's entry_point.

        :return: A string representation of the target of the entry point in
            'dotted.module:object' format.
        """
        return '%s:%s' % (self.entry_point.module_name,
                          self.entry_point.attrs[0])


class ExtensionManager(object):
    """Base class for all of the other managers.

    :param namespace: The namespace for the entry points.
    :type namespace: str
    :param invoke_on_load: Boolean controlling whether to invoke the
        object returned by the entry point after the driver is loaded.
    :type invoke_on_load: bool
    :param invoke_args: Positional arguments to pass when invoking
        the object returned by the entry point. Only used if invoke_on_load
        is True.
    :type invoke_args: tuple
    :param invoke_kwds: Named arguments to pass when invoking
        the object returned by the entry point. Only used if invoke_on_load
        is True.
    :type invoke_kwds: dict
    :param propagate_map_exceptions: Boolean controlling whether exceptions
        are propagated up through the map call or whether they are logged and
        then ignored
    :type propagate_map_exceptions: bool

    """

    def __init__(self, namespace,
                 invoke_on_load=False,
                 invoke_args=(),
                 invoke_kwds={},
                 propagate_map_exceptions=False):
        self._init_attributes(
            namespace, propagate_map_exceptions=propagate_map_exceptions)
        extensions = self._load_plugins(invoke_on_load,
                                        invoke_args,
                                        invoke_kwds)
        self._init_plugins(extensions)

    @classmethod
    def make_test_instance(cls, extensions, namespace='TESTING',
                           propagate_map_exceptions=False):
        """Construct a test ExtensionManager

        Test instances are passed a list of extensions to work from rather
        than loading them from entry points.

        :param extensions: Pre-configured Extension instances to use
        :type extensions: list of :class:`~stevedore.extension.Extension`
        :param namespace: The namespace for the manager; used only for
            identification since the extensions are passed in.
        :type namespace: str
        :param propagate_map_exceptions: When calling map, controls whether
            exceptions are propagated up through the map call or whether they
            are logged and then ignored
        :type propagate_map_exceptions: bool
        :return: The manager instance, initialized for testing

        """

        o = cls.__new__(cls)
        o._init_attributes(namespace,
                           propagate_map_exceptions=propagate_map_exceptions)
        o._init_plugins(extensions)
        return o

    def _init_attributes(self, namespace, propagate_map_exceptions=False):
        self.namespace = namespace
        self.propagate_map_exceptions = propagate_map_exceptions

    def _init_plugins(self, extensions):
        self.extensions = extensions
        self._extensions_by_name = None

    ENTRY_POINT_CACHE = {}

    def _find_entry_points(self, namespace):
        if namespace not in self.ENTRY_POINT_CACHE:
            eps = list(pkg_resources.iter_entry_points(namespace))
            self.ENTRY_POINT_CACHE[namespace] = eps
        return self.ENTRY_POINT_CACHE[namespace]

    def _load_plugins(self, invoke_on_load, invoke_args, invoke_kwds):
        extensions = []
        for ep in self._find_entry_points(self.namespace):
            LOG.debug('found extension %r', ep)
            try:
                ext = self._load_one_plugin(ep,
                                            invoke_on_load,
                                            invoke_args,
                                            invoke_kwds,
                                            )
                if ext:
                    extensions.append(ext)
            except (KeyboardInterrupt, AssertionError):
                raise
            except Exception as err:
                LOG.error('Could not load %r: %s', ep.name, err)
                LOG.exception(err)
        return extensions

    def _load_one_plugin(self, ep, invoke_on_load, invoke_args, invoke_kwds):
        plugin = ep.load()
        if invoke_on_load:
            obj = plugin(*invoke_args, **invoke_kwds)
        else:
            obj = None
        return Extension(ep.name, ep, plugin, obj)

    def names(self):
        "Returns the names of the discovered extensions"
        # We want to return the names of the extensions in the order
        # they would be used by map(), since some subclasses change
        # that order.
        return [e.name for e in self.extensions]

    def map(self, func, *args, **kwds):
        """Iterate over the extensions invoking func() for each.

        The signature for func() should be::

            def func(ext, *args, **kwds):
                pass

        The first argument to func(), 'ext', is the
        :class:`~stevedore.extension.Extension` instance.

        Exceptions raised from within func() are propagated up and
        processing stopped if self.propagate_map_exceptions is True,
        otherwise they are logged and ignored.

        :param func: Callable to invoke for each extension.
        :param args: Variable arguments to pass to func()
        :param kwds: Keyword arguments to pass to func()
        :returns: List of values returned from func()
        """
        if not self.extensions:
            # FIXME: Use a more specific exception class here.
            raise RuntimeError('No %s extensions found' % self.namespace)
        response = []
        for e in self.extensions:
            self._invoke_one_plugin(response.append, func, e, args, kwds)
        return response

    @staticmethod
    def _call_extension_method(extension, method_name, *args, **kwds):
        return getattr(extension.obj, method_name)(*args, **kwds)

    def map_method(self, method_name, *args, **kwds):
        """Iterate over the extensions invoking a method by name.

        This is equivalent of using :meth:`map` with func set to
        `lambda x: x.obj.method_name()`
        while being more convenient.

        Exceptions raised from within the called method are propagated up
        and processing stopped if self.propagate_map_exceptions is True,
        otherwise they are logged and ignored.

        .. versionadded:: 0.12

        :param method_name: The extension method name
                            to call for each extension.
        :param args: Variable arguments to pass to method
        :param kwds: Keyword arguments to pass to method
        :returns: List of values returned from methods
        """
        return self.map(self._call_extension_method,
                        method_name, *args, **kwds)

    def _invoke_one_plugin(self, response_callback, func, e, args, kwds):
        try:
            response_callback(func(e, *args, **kwds))
        except Exception as err:
            if self.propagate_map_exceptions:
                raise
            else:
                LOG.error('error calling %r: %s', e.name, err)
                LOG.exception(err)

    def __iter__(self):
        """Produce iterator for the manager.

        Iterating over an ExtensionManager produces the :class:`Extension`
        instances in the order they would be invoked.
        """
        return iter(self.extensions)

    def __getitem__(self, name):
        """Return the named extension.

        Accessing an ExtensionManager as a dictionary (``em['name']``)
        produces the :class:`Extension` instance with the
        specified name.
        """
        if self._extensions_by_name is None:
            d = {}
            for e in self.extensions:
                d[e.name] = e
            self._extensions_by_name = d
        return self._extensions_by_name[name]

########NEW FILE########
__FILENAME__ = hook
from .named import NamedExtensionManager


class HookManager(NamedExtensionManager):
    """Coordinate execution of multiple extensions using a common name.

    :param namespace: The namespace for the entry points.
    :type namespace: str
    :param name: The name of the hooks to load.
    :type name: str
    :param invoke_on_load: Boolean controlling whether to invoke the
        object returned by the entry point after the driver is loaded.
    :type invoke_on_load: bool
    :param invoke_args: Positional arguments to pass when invoking
        the object returned by the entry point. Only used if invoke_on_load
        is True.
    :type invoke_args: tuple
    :param invoke_kwds: Named arguments to pass when invoking
        the object returned by the entry point. Only used if invoke_on_load
        is True.
    :type invoke_kwds: dict
    """

    def __init__(self, namespace, name,
                 invoke_on_load=False, invoke_args=(), invoke_kwds={}):
        super(HookManager, self).__init__(
            namespace,
            [name],
            invoke_on_load=invoke_on_load,
            invoke_args=invoke_args,
            invoke_kwds=invoke_kwds,
        )

    def _init_attributes(self, namespace, names, name_order=False,
                         propagate_map_exceptions=False):
        super(HookManager, self)._init_attributes(
            namespace, names,
            propagate_map_exceptions=propagate_map_exceptions)
        self._name = names[0]

    def __getitem__(self, name):
        """Return the named extensions.

        Accessing a HookManager as a dictionary (``em['name']``)
        produces a list of the :class:`Extension` instance(s) with the
        specified name, in the order they would be invoked by map().
        """
        if name != self._name:
            raise KeyError(name)
        return self.extensions

########NEW FILE########
__FILENAME__ = named
from .extension import ExtensionManager


class NamedExtensionManager(ExtensionManager):
    """Loads only the named extensions.

    This is useful for explicitly enabling extensions in a
    configuration file, for example.

    :param namespace: The namespace for the entry points.
    :type namespace: str
    :param names: The names of the extensions to load.
    :type names: list(str)
    :param invoke_on_load: Boolean controlling whether to invoke the
        object returned by the entry point after the driver is loaded.
    :type invoke_on_load: bool
    :param invoke_args: Positional arguments to pass when invoking
        the object returned by the entry point. Only used if invoke_on_load
        is True.
    :type invoke_args: tuple
    :param invoke_kwds: Named arguments to pass when invoking
        the object returned by the entry point. Only used if invoke_on_load
        is True.
    :type invoke_kwds: dict
    :param name_order: If true, sort the loaded extensions to match the
        order used in ``names``.
    :type name_order: bool
    :param propagate_map_exceptions: Boolean controlling whether exceptions
        are propagated up through the map call or whether they are logged and
        then ignored
    :type propagate_map_exceptions: bool

    """

    def __init__(self, namespace, names,
                 invoke_on_load=False, invoke_args=(), invoke_kwds={},
                 name_order=False, propagate_map_exceptions=False):
        self._init_attributes(
            namespace, names, name_order=name_order,
            propagate_map_exceptions=propagate_map_exceptions)
        extensions = self._load_plugins(invoke_on_load,
                                        invoke_args,
                                        invoke_kwds)
        self._init_plugins(extensions)

    @classmethod
    def make_test_instance(cls, extensions, namespace='TESTING',
                           propagate_map_exceptions=False):
        """Construct a test NamedExtensionManager

        Test instances are passed a list of extensions to use rather than
        loading them from entry points.

        :param extensions: Pre-configured Extension instances
        :type extensions: list of :class:`~stevedore.extension.Extension`
        :param namespace: The namespace for the manager; used only for
            identification since the extensions are passed in.
        :type namespace: str
        :param propagate_map_exceptions: Boolean controlling whether exceptions
            are propagated up through the map call or whether they are logged
            and then ignored
        :type propagate_map_exceptions: bool
        :return: The manager instance, initialized for testing

        """

        o = cls.__new__(cls)
        names = [e.name for e in extensions]
        o._init_attributes(namespace, names,
                           propagate_map_exceptions=propagate_map_exceptions)
        o._init_plugins(extensions)
        return o

    def _init_attributes(self, namespace, names, name_order=False,
                         propagate_map_exceptions=False):
        super(NamedExtensionManager, self)._init_attributes(
            namespace, propagate_map_exceptions=propagate_map_exceptions)

        self._names = names
        self._name_order = name_order

    def _init_plugins(self, extensions):
        super(NamedExtensionManager, self)._init_plugins(extensions)

        if self._name_order:
            self.extensions = [self[n] for n in self._names]

    def _load_one_plugin(self, ep, invoke_on_load, invoke_args, invoke_kwds):
        # Check the name before going any further to prevent
        # undesirable code from being loaded at all if we are not
        # going to use it.
        if ep.name not in self._names:
            return None
        return super(NamedExtensionManager, self)._load_one_plugin(
            ep, invoke_on_load, invoke_args, invoke_kwds,
        )

########NEW FILE########
__FILENAME__ = manager
"""TestExtensionManager

Extension manager used only for testing.
"""

import logging
import warnings

from stevedore import extension


LOG = logging.getLogger(__name__)


class TestExtensionManager(extension.ExtensionManager):
    """ExtensionManager that is explicitly initialized for tests.

    .. deprecated:: 0.13

       Use the :func:`make_test_instance` class method of the class
       being replaced by the test instance instead of using this class
       directly.

    :param extensions: Pre-configured Extension instances to use
                       instead of loading them from entry points.
    :type extensions: list of :class:`~stevedore.extension.Extension`
    :param namespace: The namespace for the entry points.
    :type namespace: str
    :param invoke_on_load: Boolean controlling whether to invoke the
        object returned by the entry point after the driver is loaded.
    :type invoke_on_load: bool
    :param invoke_args: Positional arguments to pass when invoking
        the object returned by the entry point. Only used if invoke_on_load
        is True.
    :type invoke_args: tuple
    :param invoke_kwds: Named arguments to pass when invoking
        the object returned by the entry point. Only used if invoke_on_load
        is True.
    :type invoke_kwds: dict

    """

    def __init__(self, extensions,
                 namespace='test',
                 invoke_on_load=False,
                 invoke_args=(),
                 invoke_kwds={}):
        super(TestExtensionManager, self).__init__(namespace,
                                                   invoke_on_load,
                                                   invoke_args,
                                                   invoke_kwds,
                                                   )
        self.extensions = extensions
        warnings.warn(
            'TestExtesionManager has been replaced by make_test_instance()',
            DeprecationWarning)

    def _load_plugins(self, invoke_on_load,
                      invoke_args,
                      invoke_kwds):
        return []

########NEW FILE########
__FILENAME__ = test_dispatch
from stevedore import dispatch


def check_dispatch(ep, *args, **kwds):
    return ep.name == 't2'


def test_dispatch():

    def invoke(ep, *args, **kwds):
        return (ep.name, args, kwds)

    em = dispatch.DispatchExtensionManager(
        'stevedore.test.extension',
        lambda *args, **kwds: True,
        invoke_on_load=True,
        invoke_args=('a',),
        invoke_kwds={'b': 'B'},
    )
    assert len(em.extensions) == 2
    assert set(em.names()) == set(['t1', 't2'])

    results = em.map(check_dispatch,
                     invoke,
                     'first',
                     named='named value',
                     )
    expected = [('t2', ('first',), {'named': 'named value'})]
    assert results == expected


def test_dispatch_map_method():
    em = dispatch.DispatchExtensionManager(
        'stevedore.test.extension',
        lambda *args, **kwds: True,
        invoke_on_load=True,
        invoke_args=('a',),
        invoke_kwds={'b': 'B'},
    )

    results = em.map_method(check_dispatch, 'get_args_and_data',
                            'first')
    assert results == [(('a',), {'b': 'B'}, 'first')]


def test_name_dispatch():

    def invoke(ep, *args, **kwds):
        return (ep.name, args, kwds)

    em = dispatch.NameDispatchExtensionManager(
        'stevedore.test.extension',
        lambda *args, **kwds: True,
        invoke_on_load=True,
        invoke_args=('a',),
        invoke_kwds={'b': 'B'},
    )
    assert len(em.extensions) == 2
    assert set(em.names()) == set(['t1', 't2'])

    results = em.map(['t2'],
                     invoke,
                     'first',
                     named='named value',
                     )
    expected = [('t2', ('first',), {'named': 'named value'})]
    assert results == expected


def test_name_dispatch_ignore_missing():

    def invoke(ep, *args, **kwds):
        return (ep.name, args, kwds)

    em = dispatch.NameDispatchExtensionManager(
        'stevedore.test.extension',
        lambda *args, **kwds: True,
        invoke_on_load=True,
        invoke_args=('a',),
        invoke_kwds={'b': 'B'},
    )

    results = em.map(['t3', 't1'],
                     invoke,
                     'first',
                     named='named value',
                     )
    expected = [('t1', ('first',), {'named': 'named value'})]
    assert results == expected


def test_name_dispatch_map_method():
    em = dispatch.NameDispatchExtensionManager(
        'stevedore.test.extension',
        lambda *args, **kwds: True,
        invoke_on_load=True,
        invoke_args=('a',),
        invoke_kwds={'b': 'B'},
    )

    results = em.map_method(['t3', 't1'], 'get_args_and_data',
                            'first')
    assert results == [(('a',), {'b': 'B'}, 'first')]

########NEW FILE########
__FILENAME__ = test_driver
"""Tests for stevedore.extension
"""

import mock
import pkg_resources

from stevedore import driver
from stevedore.tests import test_extension


def test_detect_plugins():
    em = driver.DriverManager('stevedore.test.extension', 't1')
    names = sorted(em.names())
    assert names == ['t1']


def test_call():
    def invoke(ext, *args, **kwds):
        return (ext.name, args, kwds)
    em = driver.DriverManager('stevedore.test.extension', 't1')
    result = em(invoke, 'a', b='C')
    assert result == ('t1', ('a',), {'b': 'C'})


def test_driver_property_not_invoked_on_load():
    em = driver.DriverManager('stevedore.test.extension', 't1',
                              invoke_on_load=False)
    d = em.driver
    assert d is test_extension.FauxExtension


def test_driver_property_invoked_on_load():
    em = driver.DriverManager('stevedore.test.extension', 't1',
                              invoke_on_load=True)
    d = em.driver
    assert isinstance(d, test_extension.FauxExtension)


def test_no_drivers():
    try:
        driver.DriverManager('stevedore.test.extension.none', 't1')
    except RuntimeError as err:
        assert "No 'stevedore.test.extension.none' driver found" in str(err)


def test_multiple_drivers():
    # The idea for this test was contributed by clayg:
    # https://gist.github.com/clayg/6311348
    fep_name = 'stevedore.extension.ExtensionManager._find_entry_points'
    with mock.patch(fep_name) as fep:
        fep.return_value = [
            pkg_resources.EntryPoint.parse('backend = pkg1:driver'),
            pkg_resources.EntryPoint.parse('backend = pkg2:driver'),
        ]
        for ep in fep.return_value:
            ep.load = lambda: 'pkg backend'
        try:
            driver.DriverManager('stevedore.test.multiple_drivers', 'backend')
        except RuntimeError as err:
            assert "Multiple" in str(err), str(err)
        fep.assert_called_with('stevedore.test.multiple_drivers')

########NEW FILE########
__FILENAME__ = test_enabled
from stevedore import enabled


def test_enabled():
    def check_enabled(ep):
        return ep.name == 't2'
    em = enabled.EnabledExtensionManager(
        'stevedore.test.extension',
        check_enabled,
        invoke_on_load=True,
        invoke_args=('a',),
        invoke_kwds={'b': 'B'},
    )
    assert len(em.extensions) == 1
    assert em.names() == ['t2']


def test_enabled_after_load():
    def check_enabled(ext):
        return ext.obj and ext.name == 't2'
    em = enabled.EnabledExtensionManager(
        'stevedore.test.extension',
        check_enabled,
        invoke_on_load=True,
        invoke_args=('a',),
        invoke_kwds={'b': 'B'},
    )
    assert len(em.extensions) == 1
    assert em.names() == ['t2']

########NEW FILE########
__FILENAME__ = test_example_fields
"""Tests for stevedore.exmaple.fields
"""

from stevedore.example import fields


def test_simple_items():
    f = fields.FieldList(100)
    text = ''.join(f.format({'a': 'A', 'b': 'B'}))
    expected = '\n'.join([
        ': a : A',
        ': b : B',
        '',
    ])
    assert text == expected


def test_long_item():
    f = fields.FieldList(25)
    text = ''.join(f.format({'name': 'a value longer than the allowed width'}))
    expected = '\n'.join([
        ': name : a value longer',
        '    than the allowed',
        '    width',
        '',
    ])
    assert text == expected

########NEW FILE########
__FILENAME__ = test_example_simple
"""Tests for stevedore.exmaple.simple
"""

from stevedore.example import simple


def test_simple_items():
    f = simple.Simple(100)
    text = ''.join(f.format({'a': 'A', 'b': 'B'}))
    expected = '\n'.join([
        'a = A',
        'b = B',
        '',
    ])
    assert text == expected

########NEW FILE########
__FILENAME__ = test_extension
"""Tests for stevedore.extension
"""

import mock

from stevedore import extension


class FauxExtension(object):
    def __init__(self, *args, **kwds):
        self.args = args
        self.kwds = kwds

    def get_args_and_data(self, data):
        return self.args, self.kwds, data


def test_detect_plugins():
    em = extension.ExtensionManager('stevedore.test.extension')
    names = sorted(em.names())
    assert names == ['t1', 't2']


def test_get_by_name():
    em = extension.ExtensionManager('stevedore.test.extension')
    e = em['t1']
    assert e.name == 't1'


def test_get_by_name_missing():
    em = extension.ExtensionManager('stevedore.test.extension')
    try:
        em['t3']
    except KeyError:
        pass
    else:
        assert False, 'Failed to raise KeyError'


def test_load_multiple_times_entry_points():
    # We expect to get the same EntryPoint object because we save them
    # in the cache.
    em1 = extension.ExtensionManager('stevedore.test.extension')
    eps1 = [ext.entry_point for ext in em1]
    em2 = extension.ExtensionManager('stevedore.test.extension')
    eps2 = [ext.entry_point for ext in em2]
    assert eps1[0] is eps2[0]


def test_load_multiple_times_plugins():
    # We expect to get the same plugin object (module or class)
    # because the underlying import machinery will cache the values.
    em1 = extension.ExtensionManager('stevedore.test.extension')
    plugins1 = [ext.plugin for ext in em1]
    em2 = extension.ExtensionManager('stevedore.test.extension')
    plugins2 = [ext.plugin for ext in em2]
    assert plugins1[0] is plugins2[0]


def test_use_cache():
    # If we insert something into the cache of entry points,
    # the manager should not have to call into pkg_resources
    # to find the plugins.
    cache = extension.ExtensionManager.ENTRY_POINT_CACHE
    cache['stevedore.test.faux'] = []
    with mock.patch('pkg_resources.iter_entry_points',
                    side_effect=AssertionError('called iter_entry_points')):
        em = extension.ExtensionManager('stevedore.test.faux')
        names = em.names()
    assert names == []


def test_iterable():
    em = extension.ExtensionManager('stevedore.test.extension')
    names = sorted(e.name for e in em)
    assert names == ['t1', 't2']


def test_invoke_on_load():
    em = extension.ExtensionManager('stevedore.test.extension',
                                    invoke_on_load=True,
                                    invoke_args=('a',),
                                    invoke_kwds={'b': 'B'},
                                    )
    assert len(em.extensions) == 2
    for e in em.extensions:
        assert e.obj.args == ('a',)
        assert e.obj.kwds == {'b': 'B'}


def test_map_return_values():
    def mapped(ext, *args, **kwds):
        return ext.name

    em = extension.ExtensionManager('stevedore.test.extension',
                                    invoke_on_load=True,
                                    )
    results = em.map(mapped)
    assert sorted(results) == ['t1', 't2']


def test_map_arguments():
    objs = []

    def mapped(ext, *args, **kwds):
        objs.append((ext, args, kwds))

    em = extension.ExtensionManager('stevedore.test.extension',
                                    invoke_on_load=True,
                                    )
    em.map(mapped, 1, 2, a='A', b='B')
    assert len(objs) == 2
    names = sorted([o[0].name for o in objs])
    assert names == ['t1', 't2']
    for o in objs:
        assert o[1] == (1, 2)
        assert o[2] == {'a': 'A', 'b': 'B'}


def test_map_eats_errors():

    def mapped(ext, *args, **kwds):
        raise RuntimeError('hard coded error')

    em = extension.ExtensionManager('stevedore.test.extension',
                                    invoke_on_load=True,
                                    )
    results = em.map(mapped, 1, 2, a='A', b='B')
    assert results == []


def test_map_propagate_exceptions():

    def mapped(ext, *args, **kwds):
        raise RuntimeError('hard coded error')

    em = extension.ExtensionManager('stevedore.test.extension',
                                    invoke_on_load=True,
                                    propagate_map_exceptions=True
                                    )

    try:
        em.map(mapped, 1, 2, a='A', b='B')
        assert False
    except RuntimeError:
        pass


def test_map_errors_when_no_plugins():

    def mapped(ext, *args, **kwds):
        pass

    em = extension.ExtensionManager('stevedore.test.extension.none',
                                    invoke_on_load=True,
                                    )
    try:
        em.map(mapped, 1, 2, a='A', b='B')
    except RuntimeError as err:
        assert 'No stevedore.test.extension.none extensions found' == str(err)


def test_map_method():
    em = extension.ExtensionManager('stevedore.test.extension',
                                    invoke_on_load=True,
                                    )

    result = em.map_method('get_args_and_data', 42)
    assert set(r[2] for r in result) == set([42])

########NEW FILE########
__FILENAME__ = test_hook
from stevedore import hook


def test_hook():
    em = hook.HookManager(
        'stevedore.test.extension',
        't1',
        invoke_on_load=True,
        invoke_args=('a',),
        invoke_kwds={'b': 'B'},
    )
    assert len(em.extensions) == 1
    assert em.names() == ['t1']


def test_get_by_name():
    em = hook.HookManager(
        'stevedore.test.extension',
        't1',
        invoke_on_load=True,
        invoke_args=('a',),
        invoke_kwds={'b': 'B'},
    )
    e_list = em['t1']
    assert len(e_list) == 1
    e = e_list[0]
    assert e.name == 't1'


def test_get_by_name_missing():
    em = hook.HookManager(
        'stevedore.test.extension',
        't1',
        invoke_on_load=True,
        invoke_args=('a',),
        invoke_kwds={'b': 'B'},
    )
    try:
        em['t2']
    except KeyError:
        pass
    else:
        assert False, 'Failed to raise KeyError'

########NEW FILE########
__FILENAME__ = test_named
from stevedore import named

import mock


def test_named():
    em = named.NamedExtensionManager(
        'stevedore.test.extension',
        names=['t1'],
        invoke_on_load=True,
        invoke_args=('a',),
        invoke_kwds={'b': 'B'},
    )
    actual = em.names()
    assert actual == ['t1']


def test_enabled_before_load():
    # Set up the constructor for the FauxExtension to cause an
    # AssertionError so the test fails if the class is instantiated,
    # which should only happen if it is loaded before the name of the
    # extension is compared against the names that should be loaded by
    # the manager.
    init_name = 'stevedore.tests.test_extension.FauxExtension.__init__'
    with mock.patch(init_name) as m:
        m.side_effect = AssertionError
        em = named.NamedExtensionManager(
            'stevedore.test.extension',
            # Look for an extension that does not exist so the
            # __init__ we mocked should never be invoked.
            names=['no-such-extension'],
            invoke_on_load=True,
            invoke_args=('a',),
            invoke_kwds={'b': 'B'},
        )
        actual = em.names()
        assert actual == []


def test_extensions_listed_in_name_order():
    # Since we don't know the "natural" order of the extensions, run
    # the test both ways: if the sorting is broken, one of them will
    # fail
    em = named.NamedExtensionManager(
        'stevedore.test.extension',
        names=['t1', 't2'],
        name_order=True
    )
    actual = em.names()
    assert actual == ['t1', 't2']

    em = named.NamedExtensionManager(
        'stevedore.test.extension',
        names=['t2', 't1'],
        name_order=True
    )
    actual = em.names()
    assert actual == ['t2', 't1']

########NEW FILE########
__FILENAME__ = test_test_manager
from mock import Mock, sentinel
from nose.tools import raises
from stevedore import (ExtensionManager, NamedExtensionManager, HookManager,
                       DriverManager, EnabledExtensionManager)
from stevedore.dispatch import (DispatchExtensionManager,
                                NameDispatchExtensionManager)
from stevedore.extension import Extension


test_extension = Extension('test_extension', None, None, None)
test_extension2 = Extension('another_one', None, None, None)

mock_entry_point = Mock(module_name='test.extension', attrs=['obj'])
a_driver = Extension('test_driver', mock_entry_point, sentinel.driver_plugin,
                     sentinel.driver_obj)


# base ExtensionManager

def test_instance_should_use_supplied_extensions():
    extensions = [test_extension, test_extension2]
    em = ExtensionManager.make_test_instance(extensions)

    assert extensions == em.extensions


def test_instance_should_have_default_namespace():
    em = ExtensionManager.make_test_instance([])

    assert em.namespace


def test_instance_should_use_supplied_namespace():
    namespace = 'testing.1.2.3'
    em = ExtensionManager.make_test_instance([], namespace=namespace)

    assert namespace == em.namespace


def test_extension_name_should_be_listed():
    em = ExtensionManager.make_test_instance([test_extension])

    assert test_extension.name in em.names()


def test_iterator_should_yield_extension():
    em = ExtensionManager.make_test_instance([test_extension])

    assert test_extension == next(iter(em))


def test_manager_should_allow_name_access():
    em = ExtensionManager.make_test_instance([test_extension])

    assert test_extension == em[test_extension.name]


def test_manager_should_call():
    em = ExtensionManager.make_test_instance([test_extension])
    func = Mock()

    em.map(func)

    func.assert_called_once_with(test_extension)


def test_manager_should_call_all():
    em = ExtensionManager.make_test_instance([test_extension2,
                                              test_extension])
    func = Mock()

    em.map(func)

    func.assert_any_call(test_extension2)
    func.assert_any_call(test_extension)


def test_manager_return_values():
    def mapped(ext, *args, **kwds):
        return ext.name

    em = ExtensionManager.make_test_instance([test_extension2,
                                              test_extension])
    results = em.map(mapped)
    assert sorted(results) == ['another_one', 'test_extension']


def test_manager_should_eat_exceptions():
    em = ExtensionManager.make_test_instance([test_extension])

    func = Mock(side_effect=RuntimeError('hard coded error'))

    results = em.map(func, 1, 2, a='A', b='B')
    assert results == []


@raises(RuntimeError)
def test_manager_should_propagate_exceptions():
    em = ExtensionManager.make_test_instance([test_extension],
                                             propagate_map_exceptions=True)
    func = Mock(side_effect=RuntimeError('hard coded error'))

    em.map(func, 1, 2, a='A', b='B')


# NamedExtensionManager

def test_named_manager_should_use_supplied_extensions():
    extensions = [test_extension, test_extension2]
    em = NamedExtensionManager.make_test_instance(extensions)

    assert extensions == em.extensions


def test_named_manager_should_have_default_namespace():
    em = NamedExtensionManager.make_test_instance([])

    assert em.namespace


def test_named_manager_should_use_supplied_namespace():
    namespace = 'testing.1.2.3'
    em = NamedExtensionManager.make_test_instance([], namespace=namespace)

    assert namespace == em.namespace


def test_named_manager_should_populate_names():
    extensions = [test_extension, test_extension2]
    em = NamedExtensionManager.make_test_instance(extensions)

    assert ['test_extension', 'another_one'] == em.names()


# HookManager

def test_hook_manager_should_use_supplied_extensions():
    extensions = [test_extension, test_extension2]
    em = HookManager.make_test_instance(extensions)

    assert extensions == em.extensions


def test_hook_manager_should_be_first_extension_name():
    extensions = [test_extension, test_extension2]
    em = HookManager.make_test_instance(extensions)

    # This will raise KeyError if the names don't match
    assert em[test_extension.name]


def test_hook_manager_should_have_default_namespace():
    em = HookManager.make_test_instance([test_extension])

    assert em.namespace


def test_hook_manager_should_use_supplied_namespace():
    namespace = 'testing.1.2.3'
    em = HookManager.make_test_instance([test_extension], namespace=namespace)

    assert namespace == em.namespace


def test_hook_manager_should_return_named_extensions():
    hook1 = Extension('captain', None, None, None)
    hook2 = Extension('captain', None, None, None)

    em = HookManager.make_test_instance([hook1, hook2])

    assert [hook1, hook2] == em['captain']


# DriverManager

def test_driver_manager_should_use_supplied_extension():
    em = DriverManager.make_test_instance(a_driver)

    assert [a_driver] == em.extensions


def test_driver_manager_should_have_default_namespace():
    em = DriverManager.make_test_instance(a_driver)

    assert em.namespace


def test_driver_manager_should_use_supplied_namespace():
    namespace = 'testing.1.2.3'
    em = DriverManager.make_test_instance(a_driver, namespace=namespace)

    assert namespace == em.namespace


def test_instance_should_use_driver_name():
    em = DriverManager.make_test_instance(a_driver)

    assert ['test_driver'] == em.names()


def test_instance_call():
    def invoke(ext, *args, **kwds):
        return ext.name, args, kwds

    em = DriverManager.make_test_instance(a_driver)
    result = em(invoke, 'a', b='C')

    assert result == ('test_driver', ('a',), {'b': 'C'})


def test_instance_driver_property():
    em = DriverManager.make_test_instance(a_driver)

    assert sentinel.driver_obj == em.driver


# EnabledExtensionManager

def test_enabled_instance_should_use_supplied_extensions():
    extensions = [test_extension, test_extension2]
    em = EnabledExtensionManager.make_test_instance(extensions)

    assert extensions == em.extensions


# DispatchExtensionManager

def test_dispatch_instance_should_use_supplied_extensions():
    extensions = [test_extension, test_extension2]
    em = DispatchExtensionManager.make_test_instance(extensions)

    assert extensions == em.extensions


def test_dispatch_map_should_invoke_filter_for_extensions():
    em = DispatchExtensionManager.make_test_instance([test_extension,
                                                      test_extension2])

    filter_func = Mock(return_value=False)

    args = ('A',)
    kw = {'big': 'Cheese'}

    em.map(filter_func, None, *args, **kw)

    filter_func.assert_any_call(test_extension, *args, **kw)
    filter_func.assert_any_call(test_extension2, *args, **kw)


# NameDispatchExtensionManager

def test_name_dispatch_instance_should_use_supplied_extensions():
    extensions = [test_extension, test_extension2]
    em = NameDispatchExtensionManager.make_test_instance(extensions)

    assert extensions == em.extensions


def test_name_dispatch_instance_should_build_extension_name_map():
    extensions = [test_extension, test_extension2]
    em = NameDispatchExtensionManager.make_test_instance(extensions)

    assert test_extension == em.by_name[test_extension.name]
    assert test_extension2 == em.by_name[test_extension2.name]


def test_named_dispatch_map_should_invoke_filter_for_extensions():
    em = NameDispatchExtensionManager.make_test_instance([test_extension,
                                                          test_extension2])

    func = Mock()

    args = ('A',)
    kw = {'BIGGER': 'Cheese'}

    em.map(['test_extension'], func, *args, **kw)

    func.assert_called_once_with(test_extension, *args, **kw)

########NEW FILE########
