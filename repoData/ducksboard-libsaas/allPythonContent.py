__FILENAME__ = basic_example
from __future__ import print_function

from libsaas.services import github

# use basic authentication to create a token for libsaas
basic = github.GitHub('me@example.org', 'my-github-password')

auth = basic.authorizations().create({'scopes': 'repo,gist',
                                      'note': 'libsaas example'})

# use token authentication for the rest of the calls
gh = github.GitHub(auth['token'])

# go through your followers
for follower in gh.user().followers():
    username = follower['login']

    # get the source repositories owned by each follower
    repos = gh.user(username).repos().get(type='owner')
    sources = [repo for repo in repos if not repo['fork']]

    # handle the case where a user has no repos
    if not sources:
        print("{0} has no repositories".format(username))
        continue

    # print the most watched repo of each follower, excluding forks
    most = sorted(sources, key=lambda repo: repo['watchers'])[-1]
    print("{0}'s most watched repository: {1}".format(username, most['name']))

########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# libsaas documentation build configuration file, created by
# sphinx-quickstart on Sun May 20 14:45:58 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('..'))
sys.path.insert(0, os.path.abspath('../libsaas/services'))

if not os.path.isdir('generated'):
    os.mkdir('generated')
exec(compile(open('generate_doc.py').read(), 'generate_doc.py', 'exec'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.extlinks']

autodoc_default_flags = ['no-members', 'private-members', 'no-show-inheritance']
autodoc_member_order = 'bysource'
autoclass_content = 'both'

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = 'libsaas'
copyright = '2012, Ducksboard'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.1'
# The full version, including alpha/beta/rc tags.
release = '0.1'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
html_show_sourcelink = False

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'libsaasdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'libsaas.tex', 'libsaas Documentation',
   'Ducksboard', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'libsaas', 'libsaas Documentation',
     ['Ducksboard'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'libsaas', 'libsaas Documentation',
   'Ducksboard', 'libsaas', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = generate_doc
#!/usr/bin/env python
"""
This script generates documentation files that get used when building the
libsaas API documentation.

It crawls docstrings from modules in the libsaas.services package.
"""
import inspect
import os
import pkgutil
import sys

sys.path.insert(0, os.path.abspath('..'))

from libsaas import services
from libsaas.services import base


def _title(title, char):
    return '\n{0}\n{1}\n\n'.format(title, char * len(title))


def method_path(resource, method):
    return '.'.join((resource.__module__,
                     resource.__name__,
                     method.__name__))


def walk_resource(resource, rst, top):
    for child_name in resource.list_resources():
        method = getattr(resource, child_name)
        path = method_path(resource, method)
        section_name = ', '.join([p.__name__ for p in method.produces])
        rst.write(_title(section_name, '-'))
        rst.write('.. automethod:: {0}\n'.format(path))

        for child_resource in method.produces:
            walk_resource(child_resource, rst, False)

    methods = resource.list_methods()
    if not methods:
        return

    if top:
        rst.write(_title('Service methods', '-'))

    for child_name in methods:
        method = getattr(resource, child_name)
        path = method_path(resource, method)
        rst.write('.. automethod:: {0}\n'.format(path))


def is_resource(klass):
    return inspect.isclass(klass) and issubclass(klass, base.Resource)


def process_package(importer, modname):
    module = importer.find_module(modname).load_module(modname)
    klass = inspect.getmembers(module, is_resource)[0][1]

    rst = open(os.path.join('generated', '{0}.rst'.format(modname)), 'w')

    rst.write(_title(klass.__name__, '='))
    rst.write('.. autoclass:: {0}.{1}\n'.format(modname, klass.__name__))

    walk_resource(klass, rst, True)

    rst.close()


def generate_index(modules):
    rst = open(os.path.join('generated', 'services.rst'), 'w')

    rst.write(_title('Supported services', '='))
    rst.write('.. toctree::\n    :maxdepth: 1\n\n')
    for importer, modname, is_package in modules:
        if not is_package:
            continue
        rst.write('    {0}\n'.format(modname))

    rst.close()


modules = sorted(pkgutil.iter_modules(services.__path__),
                 key=lambda tup: tup[1])

for importer, modname, is_package in modules:
    if not is_package:
        continue

    process_package(importer, modname)

generate_index(modules)

########NEW FILE########
__FILENAME__ = mashup_example
from datetime import datetime, timedelta

from libsaas.services import mailchimp, zendesk

# create Zendesk and Mailchimp services
zd = zendesk.Zendesk('mycompany', 'username', 'password')
mc = mailchimp.Mailchimp('8ac789caf98879caf897a678fa76daf-us2')

# get tickets solved yesterday
yesterday = (datetime.now() - timedelta(days=1)).strftime('%Y-%m-%d')
tickets = zd.search('updated>{0} status:solved type:ticket'.format(yesterday))

# get emails of users who requested those tickets
user_ids = [ticket['requester_id'] for ticket in tickets['results']]
emails = [zd.user(user_id).get()['user']['email'] for user_id in user_ids]

# grab the ID of the "Users" list
lists = mc.lists(filters={'list_name': 'Users'})
list_id = lists['data'][0]['id']

# set the SOLVED variable for those users in Mailchimp to yesterday
batch = [{'EMAIL': email, 'SOLVED': yesterday} for email in emails]
mc.listBatchSubscribe(list_id, batch, double_optin=False, update_existing=True)

########NEW FILE########
__FILENAME__ = requests_executor
import libsaas
from libsaas.executors import requests_executor
from libsaas.services import github

# use the Requests executor with a custom timeout and make it always send a
# user agent string
uastring = 'libsaas {0}'.format(libsaas.__versionstr__)

requests_executor.use(timeout=5.0,
                      config={'base_headers': {'User-agent': uastring}})

# unstar all starred gists
gh = github.GitHub('my-github-token')

for gist in gh.gists().starred():
    gh.gist(gist['id']).unstar()

########NEW FILE########
__FILENAME__ = base
from . import current


def use_executor(executor):
    current.process = executor


def current_executor():
    return current.process

########NEW FILE########
__FILENAME__ = current
"""
This module holds the current executor. An executor is a function that takes a
libsaas.http.Request object and a parser function and uses them to make a HTTP
request and return a Python object result.

The current executor is a global value, set using the
libsaas.executors.base.use_executor() function. Each executor module should
expose a use() function that may take additional configuration arguments, and
it should internally call base.use_executor().

Some executors might not return the result directly, for instance the Twisted
executor returns a Deferred that fires with the result of the execution.

For information about parsers, see the docstring of libsaas.parsers.
"""


def process(request, parser):
    raise NotImplementedError("no executor in use")

########NEW FILE########
__FILENAME__ = requests_executor
import logging
import requests

from libsaas import http
from . import base

__all__ = ['requests_executor']


logger = logging.getLogger('libsaas.executor.requests_executor')


extra_params = {'extra': {}}


def requests_executor(request, parser):
    """
    An executor using the requests module.
    """
    logger.info('requesting %r', request)

    logger.debug('request uri: %r, data: %r, headers: %r',
                 request.uri, request.params, request.headers)

    kwargs = {'method': request.method, 'url': request.uri,
              'headers': request.headers}
    kwargs.update(extra_params['extra'])

    if request.params:
        if request.method.upper() in http.URLENCODE_METHODS:
            kwargs['params'] = request.params
        else:
            kwargs['data'] = request.params

    resp = requests.request(**kwargs)

    logger.debug('response code: %r, body: %r, headers: %r',
                 resp.status_code, resp.content, resp.headers)

    return parser(resp.content, resp.status_code, resp.headers)


def use(**extra):
    base.use_executor(requests_executor)
    extra_params['extra'] = extra

########NEW FILE########
__FILENAME__ = test_executor
from . import base

__all__ = ['TestExecutor']


class TestExecutor(object):
    """
    An executor that just stores the request and passes a pre-set response to
    the parser.
    """
    def set_response(self, content, code, headers):
        self.content = content
        self.code = code
        self.headers = headers

    def __call__(self, request, parser):
        self.request = request
        return parser(self.content, self.code, self.headers)


def use():
    executor = TestExecutor()
    base.use_executor(executor)
    return executor

########NEW FILE########
__FILENAME__ = twisted_executor
import logging

from twisted.internet import defer, protocol, reactor
from twisted.web import client, http, http_headers
from twisted.web.iweb import IBodyProducer
from zope.interface import implements

from libsaas import port
from libsaas import http as our_http

from . import base

__all__ = ['TwistedExecutor']


logger = logging.getLogger('libsaas.executor.twisted_executor')


class StringBodyProducer(object):
    """
    A IBodyProducer that just writes the passed string as-is.
    """
    implements(IBodyProducer)

    def __init__(self, body):
        self.body = body
        self.length = len(self.body)

    def startProducing(self, consumer):
        consumer.write(self.body)
        return defer.succeed(None)

    def stopProducing(self):
        pass

    def pauseProducing(self):
        pass

    def resumeProducing(self):
        pass


class HTTPResponseProtocol(protocol.Protocol):
    """
    A simple protocol class to interpret data from a Twisted response.
    """
    def __init__(self, parser, tolerant=False):
        self.parser = parser
        self.buffer = port.StringIO()
        self.ok_reasons = [client.ResponseDone]
        if tolerant:
            self.ok_reasons.append(http.PotentialDataLoss)

    def handle_response(self, response):
        self.finished = defer.Deferred(self.cancel)
        self.code = response.code
        self.phrase = response.phrase
        self.headers = response.headers

        response.deliverBody(self)
        return self.finished

    def dataReceived(self, data):
        self.buffer.write(data)

    def connectionLost(self, reason):
        if not self.finished:
            return

        if not reason.check(*self.ok_reasons):
            self.finished.errback(reason)
            return

        try:
            headers = dict((k.lower(), v[0])
                           for k, v in self.headers.getAllRawHeaders())
            ret = self.parser(self.buffer.getvalue(), self.code, headers)
        except:
            self.finished.errback()
        else:
            self.finished.callback(ret)

    def cancel(self, d):
        self.finished = None
        if self.transport:
            self.transport.stopProducing()


class TwistedExecutor(object):
    """
    An executor using Twisted's Agent. It returns Deferreds that fire with the
    parsed output.
    """
    agent = client.Agent(reactor)

    def __init__(self, agent, tolerant):
        if agent is not None:
            self.agent = agent
        self.tolerant = tolerant

    def __call__(self, request, parser):
        logger.info('requesting %r', request)

        uri = request.uri
        producer = None

        if request.method.upper() in our_http.URLENCODE_METHODS:
            uri = self.encode_uri(request)
        else:
            producer = self.body_producer(request.params)
            content_type = 'application/x-www-form-urlencoded'
            request.headers.setdefault('Content-Type', content_type)

        logger.debug('request uri: %r, producer: %r, headers: %r',
                     uri, producer, request.headers)

        headers = self.prepare_headers(request.headers)

        d = self.agent.request(method=request.method, uri=uri,
                               headers=headers, bodyProducer=producer)
        return d.addCallback(self.got_response, parser)

    def encode_uri(self, request):
        if not request.params:
            return request.uri

        return request.uri + '?' + our_http.urlencode_any(request.params)

    def body_producer(self, params):
        if not params:
            return None

        payload = params
        if not isinstance(params, (port.text_type, port.binary_type)):
            payload = our_http.urlencode_any(params)

        return StringBodyProducer(payload)

    def prepare_headers(self, headers):
        prepared = dict((name, [val]) for name, val in headers.items())
        return http_headers.Headers(prepared)

    def got_response(self, response, parser):
        """
        Handle a Twisted HTTP Response. Read and interpret the entire response
        body and report the result. Returns a Deferred that will fire with the
        content, possible processed in some way, or errback if there has been
        an error reading the response or if the response itself is errorneous.
        """
        protocol = HTTPResponseProtocol(parser, self.tolerant)
        return protocol.handle_response(response)


def use(agent=None, tolerant=False):
    base.use_executor(TwistedExecutor(agent, tolerant))

########NEW FILE########
__FILENAME__ = urllib2_executor
import logging

from libsaas import http, port

from . import base

__all__ = ['urllib2_executor']


logger = logging.getLogger('libsaas.executor.urllib2_executor')


class RequestWithMethod(port.urllib_request.Request):

    def set_method(self, method):
        self.method = method

    def get_method(self):
        return self.method


def encode_uri(request):
    if not request.params:
        return request.uri

    return request.uri + '?' + http.urlencode_any(request.params)


def encode_data(request):
    if not request.params:
        return b''

    if isinstance(request.params, (port.text_type, port.binary_type)):
        return port.to_b(request.params)

    return http.urlencode_any(request.params)


class ErrorSwallower(port.urllib_request.HTTPErrorProcessor):

    def http_response(self, request, response):
        return response

    https_response = http_response


class Urllib2Executor(object):

    def __init__(self, extra_handlers):
        self.handlers = (ErrorSwallower, ) + extra_handlers

    def __call__(self, request, parser):
        """
        The default executor, using Python's builtin urllib2 module.
        """
        logger.info('requesting %r', request)

        uri = request.uri
        data = None

        if request.method.upper() in http.URLENCODE_METHODS:
            uri = encode_uri(request)
        else:
            data = encode_data(request)

        logger.debug('request uri: %r, data: %r, headers: %r',
                     uri, data, request.headers)

        req = RequestWithMethod(uri, data, request.headers)
        req.set_method(request.method)

        opener = port.urllib_request.build_opener(*self.handlers)
        resp = opener.open(req)

        body = resp.read()
        headers = dict(resp.info())
        logger.debug('response code: %r, body: %r, headers: %r',
                     resp.code, body, headers)

        return parser(body, resp.code, headers)


def use(extra_handlers=()):
    base.use_executor(Urllib2Executor(extra_handlers=extra_handlers))

########NEW FILE########
__FILENAME__ = auth
import base64
from hashlib import sha1
import hmac
import time
import random

from libsaas import http, port


class BasicAuth(object):
    """
    Adds a Basic authentication header to each request.
    """
    def __init__(self, username, password):
        self.username = username
        self.password = password

    def __call__(self, request):
        # According to RFC2617 the username and password are *TEXT, which
        # RFC2616 says may contain characters from outside of ISO-8859-1 if
        # they are MIME-encoded. Our first approach was to assume latin-1 in
        # username and password, but practice has proved us wrong (services
        # like Zendesk allow non-latin-1 characters in both, which are used
        # in basic auth for their API). To be as compatible as possible,
        # allow unicode in username and password, but keep resulting base64
        # in latin-1.
        auth = port.to_u('{0}:{1}').format(port.to_u(self.username),
                                           port.to_u(self.password))
        encoded = port.to_u(base64.b64encode(port.to_b(auth)), 'latin-1')
        header = 'Basic {0}'.format(encoded)
        request.headers['Authorization'] = header


class OAuthRFC5849(object):
    """
    Signs each request according to RFC5849.

    Only supports header-based authentication and only uses HMAC-SHA1.
    """
    def __init__(self, oauth_token, oauth_token_secret, key, secret):
        self.oauth_token = oauth_token
        self.oauth_token_secret = oauth_token_secret
        self.key = key
        self.secret = secret

    def __call__(self, request):
        nonce = self.generate_nonce()
        timestamp = self.generate_timestamp()

        base = self.get_base_string(request, nonce, timestamp)

        key = (self.encode(self.secret) + '&' +
               self.encode(self.oauth_token_secret))
        digest = hmac.new(port.to_b(key), port.to_b(base), sha1).digest()
        signature = self.encode(base64.b64encode(digest))

        params = self.oauth_params(nonce, timestamp, signature)
        auth = ','.join('{0}="{1}"'.format(key, val)
                        for key, val in sorted(params))
        header = 'OAuth ' + auth

        if request.headers is None:
            request.headers = {}

        request.headers['Authorization'] = header

    def use_request_params(self, request):
        """
        Whether request parameters should be included in the signature base
        string. For RFC5849 OAuth, and under the assumptions libsaas makes,
        they are included if request params are not a blob.
        """
        if request.params is None:
            return False

        if isinstance(request.params, (port.text_type, port.binary_type)):
            return False

        return True

    def get_base_string(self, request, nonce, timestamp):
        # if there are query string params, remove them from the basic string,
        # as encode_parameters already took care of including them
        parsed = port.urlparse(request.uri)
        uri = port.urlunparse((parsed.scheme, parsed.netloc, parsed.path,
                               parsed.params, '', parsed.fragment))

        return (self.encode(request.method) + '&' +
                self.encode(uri) + '&' +
                self.normalized_params(request, nonce, timestamp))

    def normalized_params(self, request, nonce, timestamp):
        params = ()

        # check for query string parameters
        params += self.encode_qs_params(request)

        # if request parameters are to be included, encode them
        if self.use_request_params(request):
            params += self.encode_request_params(request)

        # add OAuth parameters, like oauth_token, oauth_nonce etc
        params += self.oauth_params(nonce, timestamp)

        # sort them the way RFC5849 requires
        normalized = '&'.join(sorted((key + '=' + value
                                      for key, value in params)))

        # and encode the resulting string
        return self.encode(normalized)

    def encode_qs_params(self, request):
        # If there is a query string, split it out and include in the
        # parameters. In typical libsaas usage there will never be a query
        # string, since parameters should be passed as Request.params, but just
        # in case someone tried, check it.
        query = port.urlparse(request.uri).query
        params = port.parse_qsl(query, True)

        return tuple((self.encode(key), self.encode(val))
                     for key, val in params)

    def encode_request_params(self, request):
        # if params are a dict, make it into a sequence
        params = request.params
        try:
            params = tuple(params.items())
        except AttributeError:
            pass

        # encode keys and values
        return tuple((self.encode(key), self.encode(val))
                     for key, val in params)

    def generate_nonce(self):
        return str(random.getrandbits(64))

    def generate_timestamp(self):
        return str(int(time.time()))

    def oauth_params(self, nonce, timestamp, signature=None):
        params = (('oauth_nonce', nonce), ('oauth_timestamp', timestamp),
                  ('oauth_consumer_key', self.key),
                  ('oauth_token', self.oauth_token),
                  ('oauth_signature_method', 'HMAC-SHA1'))
        if signature:
            params += (('oauth_signature', signature), )

        return params

    def encode(self, val):
        # RFC5849 says that ~ should not be quoted, but / should
        return port.quote(port.to_b(val), safe='~')


class OAuth1a(OAuthRFC5849):
    """
    Signs each request according to OAuth Core 1.0 Revision A.
    """
    def use_request_params(self, request):
        """
        OAuth 1.0a only mentions POST requests, so for instance PUT bodies,
        even it their content-type is application/x-www-form-urlencoded won't
        be part of the signature base string.
        """
        if request.params is None:
            return False

        # GET parameters get appended to the URL, so they're used
        if request.method.upper() in http.URLENCODE_METHODS:
            return True

        if request.method.upper() != 'POST':
            return False

        if isinstance(request.params, (port.text_type, port.binary_type)):
            return False

        return True


# alias OAuthRFC5849 (the sane version of the spec) to just OAuth
OAuth = OAuthRFC5849

########NEW FILE########
__FILENAME__ = http
"""
HTTP utilities.
"""
from itertools import chain

from libsaas import port

URLENCODE_METHODS = ('GET', 'HEAD', 'OPTIONS')


class HTTPError(Exception):
    """
    A non-2xx code has been returned.
    """
    def __init__(self, body, code, headers):
        self.body = body
        self.code = code
        self.headers = headers

    def __repr__(self):
        return '<{0} code {1}>'.format(self.__class__.__name__, self.code)

    __str__ = __repr__


class Request(object):
    """
    Everything that's needed to make a HTTP request.
    """
    def __init__(self, method, uri, params=None, headers=None):
        """
        :var method: the HTTP method
        :vartype method: str using only ASCII characters

        :var uri: the URI, without query parameters
        :vartype uri: str using only ASCII characters

        :var params: query parameters or body
        :vartype params: dict or string, keys and values can be text, binary or
            integer and the executor will encode and quote them

        :var headers: HTTP headers
        :vartype headers: dict of str to str, both
            keys and values using only ASCII characters
        """
        self.method = method
        self.uri = uri
        self.params = params if params is not None else {}
        self.headers = headers if headers is not None else {}

    def __repr__(self):
        return "<Request [%s %s] at 0x%x>" % (self.method, self.uri,
                                              id(self))

    def __eq__(self, other):
        if not isinstance(other, Request):
            return False

        return ((other.method, other.uri, other.params, other.headers) ==
                (self.method, self.uri, self.params, self.headers))

    def __ne__(self, other):
        return not self == other


def quote_any(val):
    """
    Percent quote any value, be it binary, text or integer.
    """
    return port.quote(port.to_b(val))


def urlencode_any(d):
    """
    Encode a dictionary or a sequence of two-element tuples consisting of a
    mixture of bytes, text and integers into a str object that only uses ASCII
    characters.
    """
    try:
        d = d.items()
    except AttributeError:
        pass
    as_bytes = tuple((port.to_b(key), port.to_b(value)) for key, value in d)
    return port.urlencode(as_bytes)


def serialize_flatten(name, value, array_indices=True):
    """
    Transform a parameter name and a value (which can by any Python object)
    into a flat tuple of param tuples. This is a common way of serializing
    parameters in PHP applications.

    If array_indices is True, lists are serialized as:

        param[0]=val1&param[1]=val2

    whereas is it's False, they are serialized as:

        param[]=val1&param[]=val2

    The former is more generic and allows list values to be objects, while the
    latter is there for compatibility with services that don't understand
    numeric indices.

    >>> serialize_flatten('p1', ['v1', 'v2', 'v3'], True)
    (('p1[0]', 'v1'), ('p1[1]', 'v2'), ('p1[2]', 'v3'))

    >>> serialize_flatten('p1', ['v1', 'v2', 'v3'], False)
    (('p1[]', 'v1'), ('p1[]', 'v2'), ('p1[]', 'v3'))

    >>> serialize_flatten('p1', [{'k1': 'v1', 'k2': True},
    ...                          {'k1': 'v2', 'k2': False}])
    (('p1[0][k1]', 'v1'), ('p1[0][k2]', 'true'),
     ('p1[1][k1]', 'v2'), ('p1[1][k2]', 'false'))
    """
    # call the recursive function that returns a tuple of tuples
    return tuple(serialize_flatten_rec(name, value, array_indices))


def serialize_flatten_rec(prefix, value, array_indices):
    """
    Recursive helper for serialize_flatten.
    """
    if isinstance(value, dict):
        # serializing a dictionary, use prefix[key] as the prefix, recurse for
        # all dict items and flatten the result
        return chain.from_iterable(
            (serialize_flatten_rec('{0}[{1}]'.format(
                        port.to_u(prefix), port.to_u(key)),
                                   val, array_indices)
             for key, val in value.items()))
    elif isinstance(value, list):
        # serializing a list, use prefix[] as the prefix, recurse for
        # all items and flatten the result
        return chain.from_iterable(
            (serialize_flatten_rec('{0}[{1}]'.format(
                        port.to_u(prefix), i if array_indices else ''),
                                   val, array_indices)
             for i, val in enumerate(value)))
    elif isinstance(value, bool):
        # serializing a boolean, take the prefix as-is and serialize the value
        # to string
        return ((port.to_u(prefix), 'true' if value else 'false'), )
    else:
        # anything else, just use the prefix and value as-is
        return ((port.to_u(prefix), port.to_u(value)), )

########NEW FILE########
__FILENAME__ = parsers
"""
Premade parser functions for libsaas. Each one takes the response body, HTTP
response code and a dict of headers and should either return a result Python
object or raise HTTPError.
"""
import json

from libsaas import http

# expose the function from the xml module as a parser
from libsaas.xml import parse_xml


def parse_json(body, code, headers):
    if not 200 <= code < 300:
        raise http.HTTPError(body, code, headers)

    # JSON mandates the use of UTF-8, so assume the body is decodable
    return json.loads(body.decode('utf-8'))


def parse_empty(body, code, headers):
    if not 200 <= code < 300:
        raise http.HTTPError(body, code, headers)

########NEW FILE########
__FILENAME__ = port
"""
Utilities for writing code compatible with different versions of Python.

Mostly stolen from six, but we don't want to make it a dependency.
"""
import sys


PY3 = sys.version_info[0] == 3


if PY3:

    text_type = str
    binary_type = bytes
    integer_types = int,
    numeric_types = int, float

    from urllib import request as urllib_request
    from urllib.parse import urlencode, urlparse, urlunparse, quote, parse_qsl

    from io import StringIO

else:

    text_type = unicode
    binary_type = str
    integer_types = int, long
    numeric_types = int, long, float

    import urllib2 as urllib_request
    from urllib import urlencode, quote
    from urlparse import urlparse, urlunparse, parse_qsl

    try:
        from cStringIO import StringIO
    except ImportError:
        from StringIO import StringIO


def to_u(val, encoding='utf-8'):
    """
    Take a number, text (unicode) or binary value and return unicode. Binary
    values are decoded using the provided encoding.
    """
    if isinstance(val, text_type):
        return val
    elif isinstance(val, numeric_types):
        return text_type(val)

    return val.decode(encoding)


def to_b(val, encoding='utf-8'):
    """
    Take a number, text (unicode) or binary value and return binary. Univode
    values are encoded using the provided encoding.
    """
    if isinstance(val, binary_type):
        return val
    elif isinstance(val, numeric_types):
        return text_type(val).encode(encoding)

    return val.encode(encoding)


def method_func(klass, method_name):
    """
    Get the function object from a class and a method name.

    In Python 2 doing getattr(SomeClass, 'methodname') returns an
    instancemethod and in Python 3 a function. Use this helper to reliably get
    the function object
    """
    method = getattr(klass, method_name)
    # in Python 2 method will be an instancemethod, try to get its __func__
    # attribute and fall back to what we already have (for Python 3)
    return getattr(method, '__func__', method)


# copy-pasted from Python 2.7 sources, with the regex parameter removed

class _AssertRaisesContext(object):
    """A context manager used to implement TestCase.assertRaises* methods."""

    def __init__(self, expected):
        self.expected = expected

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, tb):
        if exc_type is None:
            try:
                exc_name = self.expected.__name__
            except AttributeError:
                exc_name = str(self.expected)
            raise self.failureException(
                "{0} not raised".format(exc_name))
        if not issubclass(exc_type, self.expected):
            # let unexpected exceptions pass through
            return False
        self.exception = exc_value # store for later retrieval
        return True


def assertRaises(exception):
    return _AssertRaisesContext(exception)

########NEW FILE########
__FILENAME__ = saas
"""
Implementation for the saas script distributed with libsaas.
"""
import collections
import inspect
import json
import logging
import optparse
import pprint
from itertools import chain, repeat

from libsaas.services import base


def extract_action(instance, parser, args):
    resource = instance

    # consume arguments until reaching an apimethod
    while args:
        current = args[0]
        resource = getattr(resource, current, None)

        if not resource:
            parser.error('no such resource %s' % args[0])
        if getattr(resource, 'is_apimethod', False):
            return resource, args[1:]
        if not isinstance(resource, collections.Callable):
            parser.error('no such resource %s' % args[0])

        # consume one token
        args.pop(0)

        # find out how many arguments does our callable take
        argspec = inspect.getargspec(resource)

        # consume as many tokens
        to_consume = len(argspec.args) - 1
        if len(args) < to_consume:
            msg = '{0} needs {1} params, {2} given'
            parser.error(msg.format(current, to_consume, len(args)))

        # produce a new resource by passing the consumed arguments to the
        # resource
        consumed, args = args[:to_consume], args[to_consume:]
        resource = resource(*list(map(try_interpret_arg, consumed)))

    parser.error('not enough arguments')


def try_interpret_arg(arg):
    try:
        return json.loads(arg)
    except:
        return arg


def parse_args(args):
    usage = ('usage: %prog service [service params] [general params] '
             '[resource|param, ...] method [param, ...]')
    parser = optparse.OptionParser(usage=usage)
    parser.add_option('--verbose', '-v', dest='verbose',
                      action='count', default=0)
    parser.add_option('--executor', '-x', dest='executor', action='store')

    if len(args) < 2:
        parser.error('not enough arguments')

    service = args[1]

    # hack to detect if the first argument is -h or --help, since we don't call
    # parse_args before adding the service-specific parameters
    if service in ('-h', '--help'):
        parser.print_help()
        parser.exit()

    try:
        module = __import__('libsaas.services', globals(), locals(), [service])
        module = getattr(module, service)
    except (ImportError, AttributeError):
        parser.error('no such service %s' % service)

    members = inspect.getmembers(module, lambda obj: inspect.isclass(obj) and
                                 issubclass(obj, base.Resource))
    if not members:
        parser.error('no such service %s' % service)

    _, klass = members[0]

    # got the service class, inspect its __init__ method to extract the keyword
    # arguments
    argspec = inspect.getargspec(klass.__init__)
    for argname, default in zip(reversed(argspec.args),
                                 chain(reversed(argspec.defaults or ()),
                                       repeat(None))):
        if argname == 'self':
            continue
        optargs = {'dest': argname}
        if default is not None:
            optargs.update({'default': default})
        parser.add_option('--%s' % argname, **optargs)

    options, args = parser.parse_args(args)

    if options.executor:
        try:
            module_name = '{0}_executor'.format(options.executor)
            module = __import__('libsaas.executors', globals(), locals(),
                                [module_name])
            module = getattr(module, module_name)
        except ImportError:
            parser.error('no such executor %s' % options.executor)

        module.use()

    level = logging.ERROR
    if options.verbose > 1:
        level = logging.DEBUG
    elif options.verbose > 0:
        level = logging.INFO

    logging.basicConfig(level=level)

    del options.verbose
    del options.executor

    if len(args) < 2:
        parser.error('not enough arguments')

    # instantiate the class, get the resource
    instance = klass(**options.__dict__)
    action, args = extract_action(instance, parser, args[2:])
    pprint.pprint(action(*list(map(try_interpret_arg, args))))


def run(args):
    parse_args(args)

########NEW FILE########
__FILENAME__ = base
import contextlib
import inspect
from functools import update_wrapper

from libsaas import http, parsers
from libsaas.executors import base, current

decorator = None
try:
    import decorator
except ImportError:
    pass


def wrap(wrapper, wrapped):
    """
    Either use the decorator module, or the builtin functools.update_wrapper
    function to wrap one function with another.

    Using decorator is preferred, because it maintains argument specification,
    making automatic documentation output look better.
    """
    if decorator:
        return decorator.decorator(wrapper, wrapped)
    return update_wrapper(wrapper, wrapped)


def serialize_param(val):
    if isinstance(val, bool):
        return 'true' if val else 'false'
    return val


def translate_identity(val):
    return val


def get_params(param_names, param_store, serialize_param=serialize_param,
               translate_param=translate_identity):
    """
    Return a dictionary suitable to be used as params in a libsaas.http.Request
    object.

    Arguments are a tuple of parameter names, a dictionary mapping those names
    to parameter values and an optional custom parameter serialization
    function. This is useful for constructs like

    def apifunc(self, p1, p2, p3=None):
        params = get_params(('p1', 'p2', 'p3'), locals())

    which will extract parameters from the called method's environment.

    As an additional convenience, if param_names is None, all parameters from
    the param store will be considered, except for 'self'. This allows for even
    shorter code in the common situation.

    The serialization function can be used for instance when the service
    expects boolean values to be represented as '0' and '1' instead of 'true'
    and 'false' or when it accepts types that can be mapped to Python types and
    mandates a specific way of encoding them as strings.

    The translation function allows changing the param name before serializing
    it. For instance, param names abused to provide inequalities, like
    'start_time<=' need such translation since 'start_time<' is not a valid
    variable name in Python. The function is expected to return the name
    to use as the query param in the URL.
    """
    if param_names is None:
        param_names = [name for name in param_store.keys() if name != 'self']

    return dict((translate_param(name), serialize_param(param_store[name]))
                for name in param_names if param_store.get(name) is not None)


class MethodNotSupported(NotImplementedError):
    """
    This resource does not implement the method.
    """
    def __str__(self):
        return self.__class__.__doc__


def apimethod(f):

    def wrapped(*args, **kwargs):
        # when using decorator the first argument passed to the wrapping
        # function is the wrapped function, so discard it if it's the case
        if args and args[0] is f:
            args = args[1:]

        # call the wrapped function, apply the filters and pass the result on
        # to the executor
        request, parser = f(*args, **kwargs)
        args[0].apply_filters(request)
        return current.process(request, parser)

    wrapped = wrap(wrapped, f)
    wrapped.is_apimethod = True
    return wrapped


def mark_apimethod(f):
    f.is_apimethod = True
    return f


def resource(*klasses):

    def wrapper(f):
        f.is_resource = True
        f.produces = klasses
        return f

    return wrapper


@contextlib.contextmanager
def extract_request():
    """
    A context manager that helps extracting the Request object from a function
    decorated with the apimethod decorator.

    Usage is:

       with extract_request():
           request = self.decorated_method()

    It works by temporarily substituting the executor with a dummy one that
    just returns the request unchanged.
    """
    prev = base.current_executor()
    try:
        base.use_executor(lambda request, _: request)
        yield
    finally:
        base.use_executor(prev)


@contextlib.contextmanager
def change_parser(parser):
    """
    A context manager that allows overriding the function that will be used to
    parse the response.

    Usage is

       with change_parser(new_parser):
           result = service.resource().method()

    It works by temporarily substituting the executor with one that replaces
    the provided parser function with the one the context manager received.
    """
    prev = base.current_executor()
    try:
        base.use_executor(lambda request, _: prev(request, parser))
        yield
    finally:
        base.use_executor(prev)


def methods_with_attribute(cls, attribute):
    return [name for name, method in
            inspect.getmembers(cls, (lambda obj: inspect.isroutine(obj) and
                                     getattr(obj, attribute, False)))]


class Resource(object):
    """
    Base class for all resources.
    """
    filters = ()
    parent = None

    @classmethod
    def list_resources(cls):
        return methods_with_attribute(cls, 'is_resource')

    @classmethod
    def list_methods(cls):
        return methods_with_attribute(cls, 'is_apimethod')

    def __init__(self, parent):
        self.parent = parent

    def require(self, condition):
        if not condition:
            raise MethodNotSupported()

    def add_filter(self, filter_function):
        self.filters += (filter_function, )

    def apply_filters(self, request):
        if self.parent is not None:
            self.parent.apply_filters(request)

        for f in self.filters:
            f(request)


class HierarchicalResource(Resource):
    """
    Base class for resources whose URL is relative to a parent resource's URL.
    """
    path = None

    def __init__(self, parent, object_id=None):
        self.parent = parent
        self.object_id = object_id

        if self.object_id:
            self.object_id = http.quote_any(self.object_id)

    def get_url(self):
        if self.object_id is None:
            return '{0}/{1}'.format(self.parent.get_url(), self.path)

        return '{0}/{1}/{2}'.format(self.parent.get_url(), self.path,
                                    self.object_id)


class RESTResource(HierarchicalResource):
    """
    Base class for resources implementing the classical CRUD operations with
    HTTP verbs.
    """
    @apimethod
    def get(self):
        """
        For single-object resources, fetch the object's data. For collections,
        fetch all of the objects.
        """
        request = http.Request('GET', self.get_url())

        return request, parsers.parse_json

    @apimethod
    def create(self, obj):
        """
        Create a new resource.

        :var obj: a Python object representing the resource to be created,
            usually in the same format as returned from `get`. Refer to the
            upstream documentation for details.
        """
        self.require_collection()
        request = http.Request('POST', self.get_url(), self.wrap_object(obj))

        return request, parsers.parse_json

    @apimethod
    def update(self, obj):
        """
        Update this resource.

        :var obj: a Python object representing the updated resource, usually in
            the same format as returned from `get`. Refer to the upstream
            documentation for details.
        """
        self.require_item()
        request = http.Request('PUT', self.get_url(), self.wrap_object(obj))

        return request, parsers.parse_json

    @apimethod
    def delete(self):
        """
        Delete this resource.
        """
        self.require_item()
        request = http.Request('DELETE', self.get_url())

        return request, parsers.parse_empty

    def require_collection(self):
        if self.object_id is not None:
            raise MethodNotSupported()

    def require_item(self):
        if self.object_id is None:
            raise MethodNotSupported()

    def wrap_object(self, obj):
        return obj

########NEW FILE########
__FILENAME__ = accesses
from libsaas import http, parsers
from libsaas.services import base

from .resource import BasecampResource


class AccessResource(BasecampResource):
    path = 'accesses'

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Accesses(AccessResource):

    @base.apimethod
    def grant(self, obj):
        """
        Create a new resource.

        :var obj: a Python object representing the resource to be created,
            usually in the same format as returned from `get`. Refer to the
            upstream documentation for details.
        """
        self.require_collection()
        request = http.Request('POST', self.get_url(), self.wrap_object(obj))

        return request, parsers.parse_empty


class Access(AccessResource):

    def get(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.apimethod
    def revoke(self):
        """
        Delete this resource.
        """
        self.require_item()
        request = http.Request('DELETE', self.get_url())

        return request, parsers.parse_empty

########NEW FILE########
__FILENAME__ = attachments
from libsaas import http, parsers
from libsaas.services import base

from .resource import BasecampResource

class AttachmentResource(BasecampResource):
    path = 'attachments'

    @base.apimethod
    def get(self, page=None):
        """
        Fetch all resources.

        :var page: the page that will be return.
            If not indicated, first one is returned.
        :vartype page: int
        """
        params = base.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json


class Attachments(AttachmentResource):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()


class GlobalAttachments(AttachmentResource):
    pass

########NEW FILE########
__FILENAME__ = calendars
from libsaas import http, parsers
from libsaas.services import base

from .resource import BasecampResource
from .comments import Comments
from . import accesses as acc


class CalendarEventResource(BasecampResource):
    path = 'calendar_events'


class CalendarEvents(CalendarEventResource):

    @base.apimethod
    def past(self):
        url = '{0}/past'.format(self.get_url())
        request = http.Request('GET', url, {})

        return request, parsers.parse_json


class CalendarEvent(CalendarEventResource):

    @base.resource(Comments)
    def comments(self):
        """
        Return the resource corresponding to all comments.
        """
        return Comments(self)


class CalendarResource(BasecampResource):
    path = 'calendars'


class Calendars(CalendarResource):
    pass


class Calendar(CalendarResource):

    @base.resource(acc.Accesses)
    def accesses(self):
        """
        Return the resource corresponding to all calendar accesses.
        """
        return acc.Accesses(self)

    @base.resource(acc.Access)
    def access(self, access_id):
        """
        Return the resource corresponding to a single access.
        """
        return acc.Access(self, access_id)

    @base.resource(CalendarEvents)
    def calendar_events(self):
        """
        Return the resource corresponding to all calendar events.
        """
        return CalendarEvents(self)

    @base.resource(CalendarEvent)
    def calendar_event(self, calendar_event_id):
        """
        Return the resource corresponding to a single calendar event.
        """
        return CalendarEvent(self, calendar_event_id)

########NEW FILE########
__FILENAME__ = comments
from libsaas.services import base

from .resource import BasecampResource


class CommentResource(BasecampResource):
    path = 'comments'


class Comments(CommentResource):

    def get(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Comment(CommentResource):

    def get(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

########NEW FILE########
__FILENAME__ = documents
from libsaas.services import base

from .resource import BasecampResource
from . import comments as c


class DocumentResource(BasecampResource):
    path = 'documents'


class Documents(DocumentResource):
    pass


class GlobalDocuments(DocumentResource):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Document(DocumentResource):

    @base.resource(c.Comments)
    def comments(self):
        """
        Return the resource corresponding to all comments.
        """
        return c.Comments(self)

########NEW FILE########
__FILENAME__ = events
from libsaas import http, parsers
from libsaas.services import base

from .resource import BasecampResource


class Events(BasecampResource):
    path = 'events'

    @base.apimethod
    def get(self, since, page=None):
        """
        Fetch all events.

        :var since: a datetime.
        :vartype since: str

        :var page: the page that will be return.
            If not indicated, first one is returned.
        :vartype page: int
        """
        params = base.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

########NEW FILE########
__FILENAME__ = people
from libsaas import http, parsers
from libsaas.services import base

from .resource import BasecampResource
from .todolists import AssignedTodos
from . import events as ev


class PeopleResource(BasecampResource):
    path = 'people'

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()


class People(PeopleResource):
    pass


class CurrentPerson(PeopleResource):

    @base.apimethod
    def get(self):
        url = '{0}/me'.format(self.get_url())
        request = http.Request('GET', url, {})

        return request, parsers.parse_json

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Person(PeopleResource):

    @base.resource(ev.Events)
    def events(self):
        """
        Return the resource corresponding to all events.
        """
        return ev.Events(self)

    @base.resource(AssignedTodos)
    def assigned_todos(self):
        """
        Return the resource corresponding to all assigned todos.
        """
        return AssignedTodos(self)

########NEW FILE########
__FILENAME__ = projects
from libsaas import http, parsers
from libsaas.services import base

from .resource import BasecampResource
from .attachments import Attachments
from .topics import ProjectTopics
from . import todolists as tdl
from . import documents as doc
from . import accesses as acc
from . import comments as c
from . import uploads as u
from . import events as ev
from . import calendars


class MessageResource(BasecampResource):
    path = 'messages'


class Messages(MessageResource):

    def get(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Message(MessageResource):

    @base.resource(c.Comments)
    def comments(self):
        """
        Return the resource corresponding to all comments.
        """
        return c.Comments(self)


class ProjectResource(BasecampResource):
    path = 'projects'


class Projects(ProjectResource):

    @base.apimethod
    def archived(self):
        url = '{0}/archived'.format(self.get_url())
        request = http.Request('GET', url, {})

        return request, parsers.parse_json


class Project(ProjectResource):

    @base.resource(acc.Accesses)
    def accesses(self):
        """
        Return the resource corresponding to all project accesses.
        """
        return acc.Accesses(self)

    @base.resource(acc.Access)
    def access(self, access_id):
        """
        Return the resource corresponding to a single access.
        """
        return acc.Access(self, access_id)

    @base.resource(ev.Events)
    def events(self):
        """
        Return the resource corresponding to all events.
        """
        return ev.Events(self)

    @base.resource(ProjectTopics)
    def topics(self):
        """
        Return the resource corresponding to all project topics.
        """
        return ProjectTopics(self)

    @base.resource(Messages)
    def messages(self):
        """
        Return the resource corresponding to all project messages.
        """
        return Messages(self)

    @base.resource(Message)
    def message(self, message_id):
        """
        Return the resource corresponding to a single message.
        """
        return Message(self, message_id)

    @base.resource(c.Comment)
    def comment(self, comment_id):
        """
        Return the resource corresponding to a single comment.
        """
        return c.Comment(self, comment_id)

    @base.resource(tdl.Todolists)
    def todolists(self):
        """
        Return the resource corresponding to all todolists.
        """
        return tdl.Todolists(self)

    @base.resource(tdl.Todolist)
    def todolist(self, todolist_id):
        """
        Return the resource corresponding to a single todolist.
        """
        return tdl.Todolist(self, todolist_id)

    @base.resource(tdl.Todo)
    def todo(self, todo_id):
        """
        Return the resource corresponding to a single todo.
        """
        return tdl.Todo(self, todo_id)

    @base.resource(doc.Documents)
    def documents(self):
        """
        Return the resource corresponding to all documents.
        """
        return doc.Documents(self)

    @base.resource(doc.Document)
    def document(self, document_id):
        """
        Return the resource corresponding to a single document.
        """
        return doc.Document(self, document_id)

    @base.resource(u.Uploads)
    def uploads(self):
        """
        Return the resource corresponding to all uploads.
        """
        return u.Uploads(self)

    @base.resource(u.Upload)
    def upload(self, upload_id):
        """
        Return the resource corresponding to a single upload.
        """
        return u.Upload(self, upload_id)

    @base.resource(Attachments)
    def attachments(self):
        """
        Return the resource corresponding to all attachments.
        """
        return Attachments(self)

    @base.resource(calendars.CalendarEvents)
    def calendar_events(self):
        """
        Return the resource corresponding to all calendar events.
        """
        return calendars.CalendarEvents(self)

    @base.resource(calendars.CalendarEvent)
    def calendar_event(self, calendar_event_id):
        """
        Return the resource corresponding to a single calendar event.
        """
        return calendars.CalendarEvent(self, calendar_event_id)

########NEW FILE########
__FILENAME__ = resource
from libsaas.services import base


class BasecampResource(base.RESTResource):
    pass

########NEW FILE########
__FILENAME__ = service
import json

from libsaas import http
from libsaas.filters import auth
from libsaas.services import base

from .attachments import GlobalAttachments
from .documents import GlobalDocuments
from .topics import Topics
from .events import Events
from . import todolists as tdl
from . import calendars as c
from . import projects as p
from . import people as pp


class Basecamp(base.Resource):
    def __init__(self, account_id, token_or_username, password=None):
        """
        Create a Basecamp service.

        :var account_id: Your Basecamp account id.
        :vartype account_id: int

        :var token_or_username: Either an OAuth 2.0 token, or the username if
          you want to use Basic authentication.
        :vartype token_or_username: str

        :var password: Only used with the Basic authentication, leave this as
            `None` when using OAuth.
        :vartype password: str

        """
        self.apiroot = 'https://basecamp.com/{0}/api/v1'

        self.add_filter(self.use_json)

        if password is None:
            self.access_token = token_or_username
            self.add_filter(self.add_authorization)
        else:
            self.add_filter(auth.BasicAuth(token_or_username, password))

        self.account_id = account_id

    def add_authorization(self, request):
        header = 'Bearer {0}'.format(self.access_token)
        request.headers['Authorization'] = header

    def use_json(self, request):
        request.uri += '.json'
        if request.method.upper() not in http.URLENCODE_METHODS:
            request.headers['Content-Type'] = 'application/json; charset=utf-8'
            request.params = json.dumps(request.params)

    def get_url(self):
        return self.apiroot.format(self.account_id)

    def set_access_token(self, access_token):
        self.access_token = access_token

    def set_account_id(self, account_id):
        self.account_id = account_id

    @base.resource(p.Projects)
    def projects(self):
        """
        Return the resource corresponding to all projects.
        """
        return p.Projects(self)

    @base.resource(p.Project)
    def project(self, project_id):
        """
        Return the resource corresponding to a single project.
        """
        return p.Project(self, project_id)

    @base.resource(pp.People)
    def people(self):
        """
        Return the resource corresponding to all people.
        """
        return pp.People(self)

    @base.resource(pp.Person, pp.CurrentPerson)
    def person(self, person_id=None):
        """
        Return the resource corresponding to a single person. If
        `person_id` is `None`, current person will be returned.
        """
        if person_id is None:
            return pp.CurrentPerson(self)

        return pp.Person(self, person_id)

    @base.resource(Events)
    def events(self):
        """
        Return the resource corresponding to all events.
        """
        return Events(self)

    @base.resource(c.Calendars)
    def calendars(self):
        """
        Return the resource corresponding to all calendars.
        """
        return c.Calendars(self)

    @base.resource(c.Calendar)
    def calendar(self, calendar_id):
        """
        Return the resource corresponding to a single calendar.
        """
        return c.Calendar(self, calendar_id)

    @base.resource(Topics)
    def topics(self):
        """
        Return the resource corresponding to all topics.
        """
        return Topics(self)

    @base.resource(tdl.GlobalTodolists)
    def todolists(self):
        """
        Return the resource corresponding to all todolists.
        """
        return tdl.GlobalTodolists(self)

    @base.resource(GlobalDocuments)
    def documents(self):
        """
        Return the resource corresponding to all documents.
        """
        return GlobalDocuments(self)

    @base.resource(GlobalAttachments)
    def attachments(self):
        """
        Return the resource corresponding to all attachments.
        """
        return GlobalAttachments(self)

########NEW FILE########
__FILENAME__ = todolists
from libsaas import http, parsers
from libsaas.services import base

from .resource import BasecampResource
from .comments import Comments


class TodoResource(BasecampResource):
    path = 'todos'


class Todos(TodoResource):

    def get(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Todo(TodoResource):

    @base.resource(Comments)
    def comments(self):
        """
        Return the resource corresponding to all comments.
        """
        return Comments(self)


class TodolistResource(BasecampResource):
    path = 'todolists'


class Todolists(TodolistResource):

    @base.apimethod
    def completed(self):
        url = '{0}/completed'.format(self.get_url())
        request = http.Request('GET', url, {})

        return request, parsers.parse_json


class GlobalTodolists(TodolistResource):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()


    @base.apimethod
    def completed(self):
        url = '{0}/completed'.format(self.get_url())
        request = http.Request('GET', url, {})

        return request, parsers.parse_json


class AssignedTodos(TodolistResource):
    path = 'assigned_todos'

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Todolist(TodolistResource):

    @base.resource(Todos)
    def todos(self):
        """
        Return the resource corresponding to all todos.
        """
        return Todos(self)

########NEW FILE########
__FILENAME__ = topics
from libsaas import http, parsers
from libsaas.services import base

from .resource import BasecampResource


class TopicResource(BasecampResource):
    path = 'topics'

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Topics(TopicResource):
    pass


class ProjectTopics(TopicResource):

    @base.apimethod
    def get(self, page=None):
        """
        Fetch all topics.

        :var page: the page that will be return.
            If not indicated, first one is returned.
        :vartype page: int
        """
        params = base.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

########NEW FILE########
__FILENAME__ = uploads
from libsaas.services import base

from .resource import BasecampResource
from . import comments as c

class UploadResource(BasecampResource):
    path = 'uploads'


class Uploads(UploadResource):

    def get(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Upload(UploadResource):

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.resource(c.Comments)
    def comments(self):
        """
        Return the resource corresponding to all comments.
        """
        return c.Comments(self)

########NEW FILE########
__FILENAME__ = changesets
from libsaas import http, parsers
from libsaas.services import base

from . import resource


class BaseChangesets(resource.BitBucketResource):

    path = 'changesets'


class Changeset(BaseChangesets):

    @base.apimethod
    def diffstat(self):
        """
        Return the diffstat for this changeset
        """
        url = '{0}/diffstat'.format(self.get_url())
        request = http.Request('GET', url)

        return request, parsers.parse_json


class Changesets(BaseChangesets):

    @base.apimethod
    def get(self, start='tip', limit=15):
        """
        Fetch changesets

        :var start: Changesets start default is 'tip'
        :var limit: Limit of changesets, default is 15
        """
        params = base.get_params(('start', 'limit'), locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

########NEW FILE########
__FILENAME__ = emails
from libsaas import http, parsers
from libsaas.services import base

from . import resource


class Emails(resource.BitBucketResource):

    path = 'emails'

    @base.apimethod
    def add(self, address):
        """
        Add an email to the user account.
        """
        return http.Request('PUT', '{0}/{1}'.format(
                self.get_url(), address)), parsers.parse_json

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Email(resource.BitBucketResource):

    def __init__(self, parent, email):
        self.parent = parent
        self.email = email

    def get_url(self):
        return '{0}/emails/{1}/'.format(self.parent.get_url(), self.email)

    @base.apimethod
    def primary(self):
        """
        Set this email as de primary email.
        """
        return http.Request('POST', '{0}'.format(self.get_url()),
                self.wrap_object({'primary': 'true'})), parsers.parse_json

    @base.apimethod
    def delete(self):
        """
        Delete this email address from the user account
        """
        return http.Request('DELETE', '{0}'.format(
                            self.get_url())), parsers.parse_json

########NEW FILE########
__FILENAME__ = groups
from libsaas import http, parsers
from libsaas.services import base

from . import resource


class GroupMembersBase(resource.BitBucketResource):

    path = 'members'


class GroupMember(GroupMembersBase):
    pass


class GroupMembers(GroupMembersBase):

    @base.apimethod
    def create(self, username):
        # BitBucket uses PUT to create new group members
        url = '{0}/{1}/'.format(self.get_url(), username)
        return http.Request('PUT', url, '*'), parsers.parse_json


class GroupsBase(resource.BitBucketResource):

    path = 'groups'

    def get_url(self):
        # the groups resource puts the 'groups' part of the path before the
        # user part
        if self.object_id is None:
            return '{0}/{1}/{2}'.format(
                self.parent.parent.get_url(), self.path, self.parent.user_id)

        return '{0}/{1}/{2}/{3}'.format(
            self.parent.parent.get_url(), self.path,
            self.parent.user_id, self.object_id)


class Groups(GroupsBase):
    pass


class Group(GroupsBase):

    @base.resource(GroupMember)
    def member(self, member):
        """
        Return the resource corresponding to a member of the group.
        """
        return GroupMember(self, member)

    @base.resource(GroupMembers)
    def members(self):
        """
        Return the resource corresponding to all members of the group.
        """
        return GroupMembers(self)

########NEW FILE########
__FILENAME__ = issues
from libsaas import http, parsers, port
from libsaas.services import base

from . import resource


class IssueComponentsBase(resource.BitBucketResource):

    path = 'components'

    def wrap_object(self, obj):
        return {'name': obj}


class IssueComponents(IssueComponentsBase):
    pass


class IssueComponent(IssueComponentsBase):
    pass


class IssueCommentsBase(resource.BitBucketResource):

    path = 'comments'

    def wrap_object(self, obj):
        return {'content': obj}


class IssueComments(IssueCommentsBase):
    pass


class IssueComment(IssueCommentsBase):
    pass


class IssueMilestonesBase(resource.BitBucketResource):

    path = 'milestones'

    def wrap_object(self, obj):
        return {'name': obj}


class IssueMilestone(IssueMilestonesBase):
    pass


class IssueMilestones(IssueMilestonesBase):
    pass


class IssueVersionsBase(resource.BitBucketResource):

    path = 'versions'

    def wrap_object(self, obj):
        return {'name': obj}


class IssueVersion(IssueVersionsBase):
    pass


class IssueVersions(IssueVersionsBase):
    pass


class RepoIssuesBase(resource.BitBucketResource):

    path = 'issues'


class RepoIssue(RepoIssuesBase):

    @base.apimethod
    def followers(self):
        """
        Fetch the followers of this issue.
        """
        request = http.Request('GET', '{0}/followers/'.format(self.get_url()))

        return request, parsers.parse_json

    @base.resource(IssueComments)
    def comments(self):
        """
        Return the resource corresponding to the comments of this issue.
        """
        return IssueComments(self)

    @base.resource(IssueComment)
    def comment(self, comment_id):
        """
        Return the resource corresponding to a single comment of this issue.
        """
        return IssueComment(self, comment_id)


class RepoIssues(RepoIssuesBase):

    @base.apimethod
    def get(self, search=None, start=None, limit=None):
        """
        Fetch issues for this repository based on the filter parameters.
        """
        url = self.get_url()
        params = base.get_params(
            ('id', 'search', 'filter', 'start', 'limit'), locals())

        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def search(self, search=None):
        """
        Search through issues.

        :var search: the query string parameter.
        """
        url = self.get_url()
        params = base.get_params(('search', ), locals())

        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def filter(self, filters):
        """
        Search through the issues applying filters.

        Look at https://confluence.atlassian.com/display/BITBUCKET/Issues
        to get a complete list of possible filters.

        :var filters: A dictionary of filters. Keys are strings corresponding
            to the filter names and values are ether string filter values or
            tuples, in which case their conditions are implicitly ORed. For
            example, {"title": ("~one", "~two")} would mean issues with the
            title containing either "one" or "two"
        :vartype filters: dict of str to str or tuple of str
        """
        # because http.Request needs params to be a dict of strings to strings
        # (roughly) and since BitBucket wants repeated parameters to express
        # OR, we'll do the quoting by hand ourselves
        def flatten_conditions(filters):
            for key, val in filters.items():
                if isinstance(val, (list, tuple)):
                    for v in val:
                        yield (port.to_b(key), port.to_b(v))
                else:
                    yield (port.to_b(key), port.to_b(val))

        to_encode = tuple(flatten_conditions(filters))
        qs = port.urlencode(to_encode)

        url = '{0}/?{1}'.format(self.get_url(), qs)
        return http.Request('GET', url), parsers.parse_json

    @base.apimethod
    def create(self, obj):
        """
        Create a new Issue.

        :var obj: a Python object with the needed params that can be:
            title: The title of the new issue
            content: The content of the new issue
            component: The componen associated with the issue
            milestone: The milestone associated with  the issue
            version: The version associated with the issue
            responsible: The username of the person responsible for the issue
            priority: The priority of the issue. Valid priorities are:

              * trivial
              * minor
              * major
              * critical
              * blocker

            status: The status of the issue. Val statuses are:

              * new
              * open
              * resolved
              * on hold
              * invalid
              * duplicate
              * wontfix

            kind: The kind of the issue. Valid kinds are:

              * bug
              * enhancement
              * proposal
              * task
        """
        request = http.Request('POST', self.get_url(), self.wrap_object(obj))

        return request, parsers.parse_json

    @base.resource(IssueComponents)
    def components(self):
        """
        Return the resource corresponding to the components of this issue.
        """
        return IssueComponents(self)

    @base.resource(IssueComment)
    def component(self, component_id):
        """
        Return the resources corresponding to one component of this issue.
        """
        return IssueComponent(self, component_id)

    @base.resource(IssueMilestones)
    def milestones(self):
        """
        Return the resources corresponding to the milestones of this issue.
        """
        return IssueMilestones(self)

    @base.resource(IssueMilestone)
    def milestone(self, milestone_id):
        """
        Return the resource corresponding to one milestone of this issue.
        """
        return IssueMilestone(self, milestone_id)

    @base.resource(IssueVersions)
    def versions(self):
        """
        Return the resource corresponding to the versions of this issue.
        """
        return IssueVersions(self)

    @base.resource(IssueVersion)
    def version(self, version_id):
        """
        Return the resource corresponding to one version of this issue.
        """
        return IssueVersion(self, version_id)

########NEW FILE########
__FILENAME__ = links
from . import resource


class RepoLinksBase(resource.BitBucketResource):

    path = 'links'


class RepoLink(RepoLinksBase):
    pass


class RepoLinks(RepoLinksBase):
    pass

########NEW FILE########
__FILENAME__ = privileges
from libsaas import http, parsers
from libsaas.services import base

from . import resource


class RepoPrivileges(resource.BitBucketResource):

    def __init__(self, parent, user, repo, specific_user=None):
        self.parent = parent
        self.user = user
        self.repo = repo
        self.specific_user = specific_user

    def get_url(self):
        url = '{0}/privileges/{1}/'.format(self.parent.parent.get_url(),
                                           self.user)

        if self.repo is not None:
            url += '{0}/'.format(self.repo)
        if self.specific_user is not None:
            url += '{0}/'.format(self.specific_user)

        return url

    @base.apimethod
    def get(self, filter=None):
        url = self.get_url()

        params = base.get_params(('filter', ), locals())
        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def grant(self, privilege):
        """
        Grant a privilege on the repo.

        :var privilege: The privilege to grant.
        :vartype privilege: str
        """
        request = http.Request('PUT', self.get_url(), privilege)

        return request, parsers.parse_empty

    @base.apimethod
    def revoke(self):
        """
        Revoke privileges on the repo from the user.
        """
        return http.Request('DELETE', self.get_url()), parsers.parse_empty


class GroupPrivileges(resource.BitBucketResource):

    def __init__(self, parent, user, group=None, repo=None):
        self.parent = parent
        self.user = user
        self.group = http.quote_any(group) if group else None
        self.repo = http.quote_any(repo) if repo else None

    @base.apimethod
    def get(self, filter=None, private=None):
        """
        Fetch the group privileges.

        :var filter: Only return specific privileges (read, write, admin).
        :vartype filter: str

        :var private: Only include private repositories.
        :vartype private: bool
        """
        params = base.get_params(('filter', 'private'), locals())
        url = '{0}/group-privileges/{1}/'.format(self.parent.parent.get_url(),
                                                 self.user)

        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def grant(self, group, repo, privilege):
        """
        Grant a privilege for a repository to a group.
        """
        url = '{0}/group-privileges/{1}/{2}/{1}/{3}/'.format(
            self.parent.parent.get_url(), self.user, repo, group)

        return http.Request('PUT', url, privilege), parsers.parse_empty

    @base.apimethod
    def revoke(self, group, repo):
        """
        Revoke privileges for a repository from a group.
        """
        url = '{0}/group-privileges/{1}/{2}/{1}/{3}/'.format(
            self.parent.parent.get_url(), self.user, repo, group)

        return http.Request('DELETE', url), parsers.parse_empty

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()

########NEW FILE########
__FILENAME__ = repositories
from libsaas import http, parsers
from libsaas.services import base

from . import resource, privileges, issues, links, changesets, services


class Repos(resource.BitBucketResource):

    path = 'repositories'

    @base.apimethod
    def get(self, *args, **kwargs):
        """
        Fetch all repositories you have access to.
        """
        url = '{0}/user/repositories/'.format(self.parent.get_url())
        return http.Request('GET', url), parsers.parse_json

    @base.apimethod
    def search(self, name=None):
        """
        Search for repositories with the given name.
        """
        params = base.get_params(('name', ), locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

    @base.apimethod
    def create(self, name, scm=None, is_private=False):
        """
        Create a new repository.

        :var name: the repository name.
        :var scm: the type of repository you want to create, can be:
            git: for git repository
            hg: for mercurial repository
        """
        params = base.get_params(('name', 'scm'), locals())
        params['is_private'] = 'true' if is_private else 'false'
        request = http.Request('POST', self.get_url(), params)

        return request, parsers.parse_json

    @base.apimethod
    def delete(self):
        """
        Delete a repository.
        """
        request = http.Request('DELETE', self.get_url())

        return request, parsers.parse_json


class Repo(resource.BitBucketResource):

    def __init__(self, parent, user, repo):
        self.parent = parent
        self.user = user
        self.repo = repo

    def get_url(self):
        return '{0}/repositories/{1}/{2}'.format(self.parent.get_url(),
                                                 self.user, self.repo)

    def require_item(self):
        pass

    def require_collection(self):
        raise base.MethodNotSupported()

    @base.apimethod
    def tags(self):
        """
        Fetch the repository tags.
        """
        url = '{0}/tags/'.format(self.get_url())
        request = http.Request('GET', url)

        return request, parsers.parse_json

    @base.apimethod
    def branches(self):
        """
        Fetch the repository branches.
        """
        url = '{0}/branches/'.format(self.get_url())
        request = http.Request('GET', url)

        return request, parsers.parse_json

    @base.apimethod
    def invite(self, user, permission):
        """
        Invite a user to participate in the repository, with the given
        permissions.

        :var user: The email of the user to invite.
        :vartype user: str

        :var permission: The permission to grant (either read or write)
        :vartype permission: str
        """
        url = '{0}/invitations/{1}/{2}/{3}'.format(self.parent.get_url(),
                                                   self.user, self.repo, user)
        params = base.get_params(('permission', ), locals())
        request = http.Request('POST', url, params)

        return request, parsers.parse_json

    @base.apimethod
    def followers(self):
        """
        Fetch the followers of this repo.
        """
        request = http.Request('GET', '{0}/followers/'.format(self.get_url()))

        return request, parsers.parse_json

    @base.apimethod
    def events(self, start=0, limit=15, etype=None):
        """
        Fetch events for this repository.

        :var start: Event start, default is 0.
        :var limit: Event result limit, default is 15.
        :var type: Event type, for example 'issue_comment'.
        """
        params = base.get_params(('start', 'limit', 'etype'), locals())
        url = '{0}/events/'.format(self.get_url())
        request = http.Request('GET', url, params)

        return request, parsers.parse_json

    @base.resource(privileges.RepoPrivileges)
    def privileges(self, specific_user=None):
        """
        Return a resource corresponding to all privileges from this repo,
        either for everyone or for a specific user.
        """
        return privileges.RepoPrivileges(
            self, self.user, self.repo, specific_user)

    @base.resource(issues.RepoIssue)
    def issue(self, id):
        """
        Return a resource corresponding to an issue from this repo.
        """
        return issues.RepoIssue(self, id)

    @base.resource(issues.RepoIssues)
    def issues(self):
        """
        Return a resource corresponding to all issues from this repo.
        """
        return issues.RepoIssues(self)

    @base.resource(links.RepoLink)
    def link(self, id):
        """
        Reurn a resource corresponding to a link from this repo.
        """
        return links.RepoLink(self, id)

    @base.resource(links.RepoLinks)
    def links(self):
        """
        Return a resouce corresponding to all the links from this repo.
        """
        return links.RepoLinks(self)

    @base.resource(changesets.Changeset)
    def changeset(self, changeset_md5):
        """
        Return a resource corresponding to a changeset for this repo.
        """
        return changesets.Changeset(self, changeset_md5)

    @base.resource(changesets.Changesets)
    def changesets(self):
        """
        Return a resource corresponding to all the changesets for this repo.
        """
        return changesets.Changesets(self)

    @base.resource(services.Service)
    def service(self, service_id):
        """
        Return a resource corresponding to one service for this repo.
        """
        return services.Service(self, service_id)

    @base.resource(services.Services)
    def services(self):
        """
        Return a resource corresponding to all the services for this repo.
        """
        return services.Services(self)

########NEW FILE########
__FILENAME__ = resource
from libsaas.services import base


class BitBucketResource(base.RESTResource):
    pass

########NEW FILE########
__FILENAME__ = service
from libsaas.filters import auth
from libsaas.services import base

from . import emails, repositories, users


class BitBucket(base.Resource):
    """
    """
    def __init__(self, username, password=None):
        """
        Create a BitBucket service.

        :var username: The username for the authenticated user.
        :vartype username: str

        :var password: The password for the authenticated user.
        :vartype password: str
        """
        self.apiroot = 'https://api.bitbucket.org/1.0'

        self.add_filter(auth.BasicAuth(username, password))
        # although not consistent throughout the documentation, BitBucket
        # resources seem to end with a trailing slash, regardless of whether
        # they represent a single object or a collection
        self.add_filter(self.add_trailing_slash)

    def add_trailing_slash(self, request):
        if not '?' in request.uri and not request.uri.endswith('/'):
            request.uri += '/'

    def get_url(self):
        return self.apiroot

    @base.resource(emails.Email)
    def email(self, email_id):
        """
        Return the resource corresponding to a single email
        """
        return emails.Email(self, email_id)

    @base.resource(emails.Emails)
    def emails(self):
        """
        Return the resource corresponding to all the emails
        """
        return emails.Emails(self)

    @base.resource(repositories.Repo)
    def repo(self, user, repo):
        """
        Return the resource corresponding to one repository
        """
        return repositories.Repo(self, user, repo)

    @base.resource(repositories.Repos)
    def repos(self):
        """
        Return the resource corresponding to all the repositories
        """
        return repositories.Repos(self)

    @base.resource(users.User)
    def user(self, user_id=None):
        """
        Return the resource corresponding to all the users
        """
        return users.User(self, user_id)


Bitbucket = BitBucket

########NEW FILE########
__FILENAME__ = services
from . import resource


class BaseServices(resource.BitBucketResource):

    path = 'services'


class Service(BaseServices):
    pass


class Services(BaseServices):
    pass

########NEW FILE########
__FILENAME__ = users
from libsaas import http, parsers
from libsaas.services import base

from . import groups, privileges, resource


class User(resource.BitBucketResource):

    def __init__(self, parent, user_id=None):
        self.parent = parent
        self.user_id = user_id

    def get_url(self):
        if self.user_id is None:
            return '{0}/user'.format(self.parent.get_url())

        return '{0}/users/{1}'.format(self.parent.get_url(), self.user_id)

    @base.apimethod
    def follows(self):
        """
        Fetch the list of repositories the authenticated user follows.
        """
        request = http.Request('GET', '{0}/follows/'.format(self.get_url()))

        return request, parsers.parse_json

    @base.apimethod
    def followers(self):
        """
        Fetch the followers of this user.
        """
        request = http.Request('GET', '{0}/followers/'.format(self.get_url()))

        return request, parsers.parse_json

    @base.apimethod
    def events(self, start=0, limit=15, etype=None):
        """
        Fetch events for this user.

        :var start: Event start, default is 0.
        :var limit: Event result limit, default is 15.
        :var type: Event type, for example 'issue_comment'.
        """
        params = base.get_params(('start', 'limit', 'etype'), locals())
        url = '{0}/events/'.format(self.get_url())
        request = http.Request('GET', url, params)

        return request, parsers.parse_json

    @base.resource(groups.Group)
    def group(self, group_name):
        """
        Return a resource corresponding a single user's groups.

        This resource only exists for User resources that specify a concrete
        username.
        """
        if not self.user_id:
            raise base.MethodNotSupported()

        return groups.Group(self, group_name)

    @base.resource(groups.Groups)
    def groups(self):
        """
        Return a resource corresponding to all of the user's groups.

        This resource only exists for User resources that specify a concrete
        username.
        """
        if not self.user_id:
            raise base.MethodNotSupported()

        return groups.Groups(self)

    @base.resource(privileges.GroupPrivileges)
    def group_privileges(self, group=None, repo=None):
        """
        Return a resource corresponding to the group privileges for a user.

        This resource only exists for User resources that specify a concrete
        username.
        """
        if not self.user_id:
            raise base.MethodNotSupported()

        return privileges.GroupPrivileges(self, self.user_id, group, repo)

########NEW FILE########
__FILENAME__ = links
from libsaas.services import base
from libsaas import http, parsers


class Link(base.Resource):
    path = 'link'

    def __init__(self, parent, link):
        self.parent = parent
        self.object_id = link

    def get_url(self):
        return '{0}/{1}'.format(self.parent.get_url(), self.path)

    def _get(self, path, params):
        params['link'] = self.object_id

        url = '{0}/{1}'.format(self.get_url(), path)
        request = http.Request('GET', url, params)

        return request, parsers.parse_json

    @base.apimethod
    def info(self):
        """
        Returns metadata about a single bitly link.
        """
        return self._get('info', {})

    @base.apimethod
    def content(self, content_type=None):
        """
        Returns the "main article" from the linked page,
        as determined by the content extractor, in either HTML
        or plain text format.

        :var content_type: specifies whether to return the content
            as html or plain text. if` not indicated, defaults to 'html'.
        :vartype content_type: str
        """
        params = base.get_params(None, locals())
        return self._get('content', params)

    @base.apimethod
    def category(self):
        """
        Returns the detected categories for a document,
        in descending order of confidence.
        """
        return self._get('category', {})

    @base.apimethod
    def social(self):
        """
        Returns the "social score" for a specified bitly link.
        """
        return self._get('social', {})

    @base.apimethod
    def location(self):
        """
        Returns the significant locations for the bitly link
        or None if locations do not exist.
        """
        return self._get('location', {})

    @base.apimethod
    def language(self):
        """
        Returns the significant languages for the bitly link.
        """
        return self._get('language', {})

    @base.apimethod
    def clicks(self, unit=None, units=None, timezone=None,
               rollup=None, limit=None, unit_reference_ts=None):
        """
        Returns the number of clicks on a single bitly link.

        :var unit: timspan: minute, hour, day, week or month.
            When unit is minute the maximum value for units is 60.
            if` not indicated, defaults to day.
        :vartype unit: str

        :var units: an integer representing the time units to query data for.
            If -1 is passed, it will return all units of time.
        :vartype units: int

        :var timezone: an integer hour offset from UTC (-14..14) or a timezone
            string. If not indicated, defaults to America/New_York.
        :vartype timezone: str

        :var rollup: returns data for multiple units rolled up to a single
            result instead of a separate value for each period of time.
        :vartype rollup: bool

        :var limit: the number of rows it will return. Default is 100.
        :vartype limit: int

        :var unit_reference_ts: an epoch timestamp, indicating the most recent
            time for which to pull metrics.
            If not indicated, it defaults to now.
        :vartype unit_reference_ts: int
        """
        params = base.get_params(None, locals())
        return self._get('clicks', params)

    @base.apimethod
    def countries(self, unit=None, units=None, timezone=None,
                  limit=None, unit_reference_ts=None):
        """
        Returns metrics about the countries referring click traffic
        to a single bitly link.

        :var unit: timspan: minute, hour, day, week or month.
            When unit is minute the maximum value for units is 60.
            if` not indicated, defaults to day.
        :vartype unit: str

        :var units: an integer representing the time units to query data for.
            If -1 is passed, it will return all units of time.
        :vartype units: int

        :var timezone: an integer hour offset from UTC (-14..14) or a timezone
            string. If not indicated, defaults to America/New_York.
        :vartype timezone: str

        :var limit: the number of rows it will return. Default is 100.
        :vartype limit: int

        :var unit_reference_ts: an epoch timestamp, indicating the most recent
            time for which to pull metrics.
            If not indicated, it defaults to now.
        :vartype unit_reference_ts: int
        """
        params = base.get_params(None, locals())
        return self._get('countries', params)

    @base.apimethod
    def encoders_count(self):
        """
        Returns the number of users who have shortened a single bitly link.
        """
        return self._get('encoders_count', {})

    @base.apimethod
    def referrers(self, unit=None, units=None, timezone=None,
                  limit=None, unit_reference_ts=None):
        """
        Returns metrics about the pages referring click traffic
        to a single bitly link.

        :var unit: timspan: minute, hour, day, week or month.
            When unit is minute the maximum value for units is 60.
            if` not indicated, defaults to day.
        :vartype unit: str

        :var units: an integer representing the time units to query data for.
            If -1 is passed, it will return all units of time.
        :vartype units: int

        :var timezone: an integer hour offset from UTC (-14..14) or a timezone
            string. If not indicated, defaults to America/New_York.
        :vartype timezone: str

        :var limit: the number of rows it will return. Default is 100.
        :vartype limit: int

        :var unit_reference_ts: an epoch timestamp, indicating the most recent
            time for which to pull metrics.
            If not indicated, it defaults to now.
        :vartype unit_reference_ts: int
        """
        params = base.get_params(None, locals())
        return self._get('referrers', params)

    @base.apimethod
    def referrers_by_domain(self, unit=None, units=None, timezone=None,
                            limit=None, unit_reference_ts=None):
        """
        Returns metrics about the pages referring click traffic
        to a single bitly link, grouped by referring domain.

        :var unit: timspan: minute, hour, day, week or month.
            When unit is minute the maximum value for units is 60.
            if` not indicated, defaults to day.
        :vartype unit: str

        :var units: an integer representing the time units to query data for.
            If -1 is passed, it will return all units of time.
        :vartype units: int

        :var timezone: an integer hour offset from UTC (-14..14) or a timezone
            string. If not indicated, defaults to America/New_York.
        :vartype timezone: str

        :var limit: the number of rows it will return. Default is 100.
        :vartype limit: int

        :var unit_reference_ts: an epoch timestamp, indicating the most recent
            time for which to pull metrics.
            If not indicated, it defaults to now.
        :vartype unit_reference_ts: int
        """
        params = base.get_params(None, locals())
        return self._get('referrers_by_domain', params)

    @base.apimethod
    def referring_domains(self, unit=None, units=None, timezone=None,
                          limit=None, unit_reference_ts=None):
        """
        Returns metrics about the domains referring click traffic
        to a single bitly link.

        :var unit: timspan: minute, hour, day, week or month.
            When unit is minute the maximum value for units is 60.
            if` not indicated, defaults to day.
        :vartype unit: str

        :var units: an integer representing the time units to query data for.
            If -1 is passed, it will return all units of time.
        :vartype units: int

        :var timezone: an integer hour offset from UTC (-14..14) or a timezone
            string. If not indicated, defaults to America/New_York.
        :vartype timezone: str

        :var limit: the number of rows it will return. Default is 100.
        :vartype limit: int

        :var unit_reference_ts: an epoch timestamp, indicating the most recent
            time for which to pull metrics.
            If not indicated, it defaults to now.
        :vartype unit_reference_ts: int
        """
        params = base.get_params(None, locals())
        return self._get('referring_domains', params)

    @base.apimethod
    def shares(self, unit=None, units=None, timezone=None,
               rollup=None, limit=None, unit_reference_ts=None):
        """
        Returns metrics about a shares of a single link.

        :var unit: timspan: minute, hour, day, week or month.
            When unit is minute the maximum value for units is 60.
            if` not indicated, defaults to day.
        :vartype unit: str

        :var units: an integer representing the time units to query data for.
            If -1 is passed, it will return all units of time.
        :vartype units: int

        :var timezone: an integer hour offset from UTC (-14..14) or a timezone
            string. If not indicated, defaults to America/New_York.
        :vartype timezone: str

        :var rollup: returns data for multiple units rolled up to a single
            result instead of a separate value for each period of time.
        :vartype rollup: bool

        :var limit: the number of rows it will return. Default is 100.
        :vartype limit: int

        :var unit_reference_ts: an epoch timestamp, indicating the most recent
            time for which to pull metrics.
            If not indicated, it defaults to now.
        :vartype unit_reference_ts: int
        """
        params = base.get_params(None, locals())
        return self._get('shares', params)


########NEW FILE########
__FILENAME__ = resource
from libsaas.services import base
from libsaas import http, parsers


class BitlyResource(base.HierarchicalResource):

    def _get(self, path, params):
        url = '{0}/{1}'.format(self.get_url(), path)
        request = http.Request('GET', url, params)
        return request, parsers.parse_json


class HighValue(BitlyResource):
    path = 'highvalue'

    @base.apimethod
    def get(self, limit):
        """
        Returns a specified number of "high-value" bitly links that
        are popular across bitly at this particular moment.

        :var limit: the maximum number of high-value links to return.
        :vartype limit: int
        """
        params = base.get_params(None, locals())

        request = http.Request('GET', self.get_url(), params)
        return request, parsers.parse_json


class Search(BitlyResource):
    path = 'search'

    @base.apimethod
    def get(self, limit=None, offset=None, query=None, lang=None,
            cities=None, domain=None, fields=None):
        """
        Search links receiving clicks across bitly by content, language, location, and more

        :var limit: the maximum number of links to return.
        :vartype limit: int

        :var offset: which result to start with (defaults to 0).
        :vartype offset: int

        :var query: the string to query for.
        :vartype query: str

        :var lang: favor results in this language (two letter ISO code).
        :vartype lang: str

        :var cities: show links active in this city.
        :vartype cities: str

        :var domain: restrict results to this web domain.
        :vartype domain: str

        :var fields: which fields to return in the response (comma-separated).
            May be any of: domain, initial_epoch, h2, h3, site, lastindexed,
            keywords, last_indexed_epoch, title, initial, summaryText, content,
            score, summaryTitle, type, description, cities, lang, url,
            referrer, aggregate_link, lastseen, page, ogtitle aggregate_link.
            By default, all will be returned.
        :vartype fields: str
        """
        params = base.get_params(None, locals())

        request = http.Request('GET', self.get_url(), params)
        return request, parsers.parse_json


class RealTime(BitlyResource):
    path = 'realtime'

    @base.apimethod
    def bursting_phrases(self):
        """
        Returns phrases that are receiving an uncharacteristically
        high volume of click traffic, and the individual links (hashes)
        driving traffic to pages containing these phrases.
        """
        return self._get('bursting_phrases', {})

    @base.apimethod
    def hot_phrases(self):
        """
        Returns phrases that are receiving a consistently high volume of click
        traffic, and the individual links (hashes) driving traffic to pages
        containing these phrases.
        """
        return self._get('hot_phrases', {})

    @base.apimethod
    def clickrate(self, phrase):
        """
        Returns the click rate for content containing a specified phrase.

        :var phrase: the phrase for which you'd like to get the click rate.
        :vartype phrase: str
        """
        params = base.get_params(None, locals())
        return self._get('clickrate', params)

########NEW FILE########
__FILENAME__ = service
from libsaas.services import base

from . import resource, links, users


class Bitly(base.Resource):
    def __init__(self, token):
        """
        Create a Bitly service.

        :var token: an OAuth 2.0 token.
        :vartype token: str

        """
        self.apiroot = 'https://api-ssl.bitly.com/v3'

        self.access_token = token
        self.add_filter(self.add_authorization)

    def add_authorization(self, request):
        request.params.update({
            'access_token': self.access_token
        })

    def get_url(self):
        return self.apiroot

    @base.resource(users.User)
    def user(self):
        """
        Return the resource corresponding to a single user.
        """
        return users.User(self)

    @base.resource(links.Link)
    def link(self, link):
        """
        Return the resource corresponding to a single link.
        """
        return links.Link(self, link)

    @base.resource(resource.HighValue)
    def highvalue(self):
        """
        Return the resource corresponding to all high-value links.
        """
        return resource.HighValue(self)

    @base.resource(resource.Search)
    def search(self):
        """
        Return the resource corresponding to all links.
        """
        return resource.Search(self)

    @base.resource(resource.RealTime)
    def realtime(self):
        """
        Return the resource corresponding to a single object.
        """
        return resource.RealTime(self)

########NEW FILE########
__FILENAME__ = users
from libsaas.services import base

from .resource import BitlyResource


class User(BitlyResource):
    path = 'user'

    @base.apimethod
    def info(self, login=None, full_name=None):
        """
        Return or update information about a user.

        :var login: the bitly login of the user whose info to look up.
            If not given, the authenticated user will be used.
        :vartype login: str

        :var full_name: set the users full name value (only available
            for the authenticated user).
        :vartype full_name: str
        """
        params = base.get_params(None, locals())
        return self._get('info', params)

    @base.apimethod
    def link_history(self, link=None, limit=None, offset=None,
                     created_before=None, created_after=None,
                     modified_after=None, expand_client_id=None,
                     archived=None, private=None, user=None):
        """
        Returns entries from a user's link history
        in reverse chronological order.

        :var link the bitly link to return metadata for (when specified,
            overrides all other options).
        :vartype login: str

        :var limit the max number of results to return.
        :vartype login: int

        :var offset the numbered result at which to start (for pagination).
        :vartype offset: int

        :var created_before timestamp as an integer unix epoch.
        :vartype created_before: int

        :var created_after timestamp as an integer unix epoch.
        :vartype created_after: int

        :var modified_after timestamp as an integer unix epoch.
        :vartype modified_after: int

        :var expand_client_id whether to provide additional information about
            encoding application.
        :vartype expand_client_id: bool

        :var archived whether to include or exclude archived
            history entries. Defaults to 'off'.
        :vartype archived: str

        :var private whether to include or exclude private
            history entries. Defaults to 'both'.
        :vartype private: str

        :var user: the user for whom to retrieve history entries
            (if different from authenticated user).
        :vartype user: str

        """
        params = base.get_params(None, locals())
        return self._get('link_history', params)

    @base.apimethod
    def network_history(self, limit=None, offset=None,
                        expand_client_id=None, expand_user=None):
        """
        Returns entries from a user's network history
        in reverse chronogical order.

        :var limit the max number of results to return.
        :vartype login: int

        :var offset the numbered result at which to start (for pagination).
        :vartype offset: int

        :var expand_client_id whether to provide additional information about
            encoding application.
        :vartype expand_client_id: bool

        :var expand_user include extra user info in response.
        :vartype expand_user: bool
        """
        params = base.get_params(None, locals())
        return self._get('network_history', params)

    @base.apimethod
    def tracking_domain_list(self):
        """
        Returns a list of tracking domains a user has configured.
        """
        params = base.get_params(None, locals())
        return self._get('tracking_domain_list', params)

    @base.apimethod
    def clicks(self, unit=None, units=None, timezone=None,
               rollup=None, limit=None, unit_reference_ts=None):
        """
        Returns the aggregate number of clicks on all of the
        authenticated user's bitly links.

        :var unit: timspan: minute, hour, day, week or month.
            When unit is minute the maximum value for units is 60.
            if` not indicated, defaults to day.
        :vartype unit: str

        :var units: an integer representing the time units to query data for.
            If -1 is passed, it will return all units of time.
        :vartype units: int

        :var timezone: an integer hour offset from UTC (-14..14) or a timezone
            string. If not indicated, defaults to America/New_York.
        :vartype timezone: str

        :var rollup: returns data for multiple units rolled up to a single
            result instead of a separate value for each period of time.
        :vartype rollup: bool

        :var limit: the number of rows it will return. Default is 100.
        :vartype limit: int

        :var unit_reference_ts: an epoch timestamp, indicating the most recent
            time for which to pull metrics.
            If not indicated, it defaults to now.
        :vartype unit_reference_ts: int
        """
        params = base.get_params(None, locals())
        return self._get('clicks', params)

    @base.apimethod
    def countries(self, unit=None, units=None, timezone=None,
                  rollup=None, limit=None, unit_reference_ts=None):
        """
        Returns aggregate metrics about the countries referring click traffic
        to all of the authenticated user's bitly links.

        :var unit: timspan: minute, hour, day, week or month.
            When unit is minute the maximum value for units is 60.
            if` not indicated, defaults to day.
        :vartype unit: str

        :var units: an integer representing the time units to query data for.
            If -1 is passed, it will return all units of time.
        :vartype units: int

        :var timezone: an integer hour offset from UTC (-14..14) or a timezone
            string. If not indicated, defaults to America/New_York.
        :vartype timezone: str

        :var rollup: returns data for multiple units rolled up to a single
            result instead of a separate value for each period of time.
        :vartype rollup: bool

        :var limit: the number of rows it will return. Default is 100.
        :vartype limit: int

        :var unit_reference_ts: an epoch timestamp, indicating the most recent
            time for which to pull metrics.
            If not indicated, it defaults to now.
        :vartype unit_reference_ts: int
        """
        params = base.get_params(None, locals())
        return self._get('countries', params)

    @base.apimethod
    def popular_links(self, unit=None, units=None, timezone=None,
                  limit=None, unit_reference_ts=None):
        """
        Returns the authenticated user's most-clicked bitly links
        (ordered by number of clicks) in a given time period.

        :var unit: timspan: minute, hour, day, week or month.
            When unit is minute the maximum value for units is 60.
            if` not indicated, defaults to day.
        :vartype unit: str

        :var units: an integer representing the time units to query data for.
            If -1 is passed, it will return all units of time.
        :vartype units: int

        :var timezone: an integer hour offset from UTC (-14..14) or a timezone
            string. If not indicated, defaults to America/New_York.
        :vartype timezone: str

        :var limit: the number of rows it will return. Default is 100.
        :vartype limit: int

        :var unit_reference_ts: an epoch timestamp, indicating the most recent
            time for which to pull metrics.
            If not indicated, it defaults to now.
        :vartype unit_reference_ts: int
        """
        params = base.get_params(None, locals())
        return self._get('popular_links', params)

    @base.apimethod
    def referrers(self, unit=None, units=None, timezone=None,
                  rollup=None, limit=None, unit_reference_ts=None):
        """
        Returns aggregate metrics about the pages referring click traffic
        to all of the authenticated user's bitly links.

        :var unit: timspan: minute, hour, day, week or month.
            When unit is minute the maximum value for units is 60.
            if` not indicated, defaults to day.
        :vartype unit: str

        :var units: an integer representing the time units to query data for.
            If -1 is passed, it will return all units of time.
        :vartype units: int

        :var timezone: an integer hour offset from UTC (-14..14) or a timezone
            string. If not indicated, defaults to America/New_York.
        :vartype timezone: str

        :var rollup: returns data for multiple units rolled up to a single
            result instead of a separate value for each period of time.
        :vartype rollup: bool

        :var limit: the number of rows it will return. Default is 100.
        :vartype limit: int

        :var unit_reference_ts: an epoch timestamp, indicating the most recent
            time for which to pull metrics.
            If not indicated, it defaults to now.
        :vartype unit_reference_ts: int
        """
        params = base.get_params(None, locals())
        return self._get('referrers', params)

    @base.apimethod
    def referring_domains(self, unit=None, units=None, timezone=None,
                          rollup=None, limit=None, unit_reference_ts=None):
        """
        Returns aggregate metrics about the domains referring click traffic
        to all of the authenticated user's bitly links

        :var unit: timspan: minute, hour, day, week or month.
            When unit is minute the maximum value for units is 60.
            if` not indicated, defaults to day.
        :vartype unit: str

        :var units: an integer representing the time units to query data for.
            If -1 is passed, it will return all units of time.
        :vartype units: int

        :var timezone: an integer hour offset from UTC (-14..14) or a timezone
            string. If not indicated, defaults to America/New_York.
        :vartype timezone: str

        :var rollup: returns data for multiple units rolled up to a single
            result instead of a separate value for each period of time.
        :vartype rollup: bool

        :var limit: the number of rows it will return. Default is 100.
        :vartype limit: int

        :var unit_reference_ts: an epoch timestamp, indicating the most recent
            time for which to pull metrics.
            If not indicated, it defaults to now.
        :vartype unit_reference_ts: int
        """
        params = base.get_params(None, locals())
        return self._get('referring_domains', params)

    @base.apimethod
    def share_counts(self, unit=None, units=None, timezone=None,
                     rollup=None, limit=None, unit_reference_ts=None):
        """
        Returns the number of shares by the authenticated user
        in a given time period.

        :var unit: timspan: minute, hour, day, week or month.
            When unit is minute the maximum value for units is 60.
            if` not indicated, defaults to day.
        :vartype unit: str

        :var units: an integer representing the time units to query data for.
            If -1 is passed, it will return all units of time.
        :vartype units: int

        :var timezone: an integer hour offset from UTC (-14..14) or a timezone
            string. If not indicated, defaults to America/New_York.
        :vartype timezone: str

        :var rollup: returns data for multiple units rolled up to a single
            result instead of a separate value for each period of time.
        :vartype rollup: bool

        :var limit: the number of rows it will return. Default is 100.
        :vartype limit: int

        :var unit_reference_ts: an epoch timestamp, indicating the most recent
            time for which to pull metrics.
            If not indicated, it defaults to now.
        :vartype unit_reference_ts: int
        """
        params = base.get_params(None, locals())
        return self._get('share_counts', params)

########NEW FILE########
__FILENAME__ = service
from libsaas import http, parsers, port
from libsaas.services import base


class CartoDB(base.Resource):
    """
    """
    def __init__(self, subdomain, api_key):
        """
        Create a CartoDB service.

        :var subdomain: The account-specific part of the CartoDB domain, for
            instance use `mycompany` if your CartpDB domain is
            `mycompany.cartodb.com`.
        :vartype subdomain: str

        :var api_key: The API key.
        :vartype api_key: str
        """
        tmpl = '{0}.cartodb.com/api'
        self.apiroot = http.quote_any(tmpl.format(port.to_u(subdomain)))
        self.apiroot = 'https://' + self.apiroot

        self.api_key = api_key
        self.add_filter(self.add_api_key)

    def get_url(self, version='v2'):
        return '{0}/{1}'.format(self.apiroot, version)

    def add_api_key(self, request):
        request.params.update({'api_key': self.api_key})

    @base.apimethod
    def sql(self, q):
        """
        SQL request to the CartoDB account

        :var q: The sql query
        :vartype q: str
        """
        params = base.get_params(None, locals())
        url = '{0}/{1}'.format(self.get_url(), 'sql')

        return http.Request('POST', url, params), parsers.parse_json

    @base.apimethod
    def viz(self, type=None):
        """
        Get the list of visualizations (undocumented endpoint)

        :var type: The visualization type
        :vartype q: str
        """
        params = base.get_params(None, locals())
        url = '{0}/{1}'.format(self.get_url('v1'), 'viz')

        return http.Request('GET', url, params), parsers.parse_json

########NEW FILE########
__FILENAME__ = resource
from libsaas import http, parsers
from libsaas.services import base


class CompeteResource(base.RESTResource):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Metric(CompeteResource):

    path = 'trended'

    def get_url(self):
        return '{0}/'.format(super(Metric, self).get_url())

    @base.apimethod
    def get(self, latest=None, start_date=None, end_date=None):
        """
        Fetch the object's data.

        :var latest: Returns the latest N months or days.
            If omitted, it returns data for the most recent 13 months
            for a monthly metric. For daily metrics, it returns data for
            the most recent 30 days.
        :vartype latest: int
        :var start_date: Return specific start date.
            If omitted, it returns data for the most recent 13 months
            for a monthly metric. For daily metrics, it returns data for
            the most recent 30 days.
        :vartype start_date: str
        :var end_date: Returns specific end date.
            If omitted, it returns data for the most recent 13 months
            for a monthly metric. For daily metrics, it returns data for
            the most recent 30 days.
        :vartype end_date: str
        """
        params = base.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json


class Site(CompeteResource):

    path = 'sites'

    def get(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.resource(Metric)
    def metric(self, metric_id):
        """
        Return the resource corresponding to a single metric for the site.
        """
        return Metric(self, metric_id)

########NEW FILE########
__FILENAME__ = service
from libsaas.services import base

from . import resource


class Compete(base.Resource):
    """
    """
    def __init__(self, api_key):
        """
        Create an Compete service.

        :var api_key: The API key.
        :vartype api_key: str
        """
        self.apiroot = 'http://apps.compete.com'

        self.api_key = api_key
        self.add_filter(self.add_api_key)

    def get_url(self):
        return self.apiroot

    def add_api_key(self, request):
        request.params.update({'apikey': self.api_key})

    @base.resource(resource.Site)
    def site(self, domain):
        """
        Return the resource corresponding to a single site.
        """
        return resource.Site(self, domain)

########NEW FILE########
__FILENAME__ = cases
from libsaas import http, parsers
from libsaas.services import base

from . import resource


class Replies(resource.PaginatedDeskResource):

    path = 'replies'


class Reply(resource.DeskResource):

    path = 'replies'


class CasesBase(resource.DeskResource):

    path = 'cases'


class Cases(CasesBase):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.apimethod
    def get(self, embed=None, fields=None, per_page=None, page=None):
        """
        Retrieve a paginated list of all cases.

        Upstream documentation: http://dev.desk.com/API/cases#list
        """
        params = base.get_params(None, locals())

        return http.Request('GET', self.get_url(), params), parsers.parse_json

    @base.apimethod
    def search(self, name=None, first_name=None, last_name=None, email=None,
               phone=None, company=None, twitter=None, labels=None,
               case_id=None, subject=None, description=None,
               status=None, priority=None, assigned_group=None,
               assigned_user=None, channels=None, notes=None, attachments=None,
               created=None, updated=None, since_created_at=None,
               max_created_at=None, since_updated_at=None, max_updated_at=None,
               since_id=None, max_id=None, per_page=None, page=None,
               embed=None, fields=None, **case_custom_fields):
        """
        Search cases based on a combination of parameters with pagination.

        Upstream documentation: http://dev.desk.com/API/cases#search
        """
        store = locals()
        store.update(store.pop('case_custom_fields'))

        params = base.get_params(None, store)
        url = '{0}/{1}'.format(self.get_url(), 'search')
        return http.Request('GET', url, params), parsers.parse_json


class Case(CasesBase):

    def __init__(self, parent, object_id, is_external=False):
        case_id = 'e-%s' % object_id if is_external else object_id
        super(Case, self).__init__(parent, case_id)

    @base.apimethod
    def message(self):
        """
        Retrieve the original message for this case.

        Upstream documentation: http://dev.desk.com/API/cases#message-show
        """
        url = '{0}/{1}'.format(self.get_url(), 'message')
        return http.Request('GET', url), parsers.parse_json

    @base.apimethod
    def history(self, per_page=None, page=None):
        """
        The case history endpoint will display a paginated list of all
        events/actions that have happened to the case

        Upstream documentation: http://dev.desk.com/API/cases#history
        """
        params = base.get_params(None, locals())
        url = '{0}/{1}'.format(self.get_url(), 'history')
        return http.Request('GET', url, params), parsers.parse_json

    @base.resource(Replies)
    def replies(self):
        """
        Return the resource corresponding to the case replies
        """
        return Replies(self)

    @base.resource(Reply)
    def reply(self, reply_id):
        """
        Return the resource corresponding to a single reply
        """
        return Reply(self, reply_id)

########NEW FILE########
__FILENAME__ = contents
from libsaas import http, parsers
from libsaas.services import base

from . import resource


class Translations(resource.PaginatedDeskResource):

    path = 'translations'


class Translation(resource.DeskResource):

    path = 'translations'


class Articles(resource.PaginatedDeskResource):

    path = 'articles'

    @base.apimethod
    def search(self, text=None, topic_ids=None, per_page=None, page=None):
        """
        Perform a search across all public articles.

        Upstream documentation: http://dev.desk.com/API/articles#search
        """
        params = base.get_params(None, locals())
        url = '{0}/{1}'.format(self.get_url(), 'search')
        return http.Request('GET', url, params), parsers.parse_json

    @base.resource(Translations)
    def translations(self):
        """
        Return the resource corresponding to the article translations
        """
        return Translations(self)

    @base.resource(Translation)
    def translation(self, translation_id):
        """
        Return the resource corresponding to a single translation
        """
        return Translation(self, translation_id)


class Article(resource.DeskResource):

    path = 'articles'


class Topics(resource.PaginatedDeskResource):

    path = 'topics'

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Topic(resource.DeskResource):

    path = 'topics'

    @base.resource(Articles)
    def articles(self):
        """
        Return the resource corresponding to topic articles
        """
        return Articles(self)

    @base.resource(Translations)
    def translations(self):
        """
        Return the resource corresponding to the topic translations
        """
        return Translations(self)

    @base.resource(Translation)
    def translation(self, translation_id):
        """
        Return the resource corresponding to a single translation
        """
        return Translation(self, translation_id)

########NEW FILE########
__FILENAME__ = customers
from libsaas import http, parsers
from libsaas.services import base

from . import resource, cases


class CustomersBase(resource.DeskResource):

    path = 'customers'

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Customers(CustomersBase):

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.apimethod
    def get(self, embed=None, fields=None, per_page=None, page=None):
        """
        Retrieve a paginated list of all customers

        Upstream documentation: http://dev.desk.com/API/customers#list
        """
        params = base.get_params(None, locals())

        return http.Request('GET', self.get_url(), params), parsers.parse_json

    @base.apimethod
    def search(self, first_name=None, last_name=None, full_name=None,
               email=None, phone=None, twitter=None, external_id=None,
               since_created_at=None, max_created_at=None, since_updated_at=None,
               max_updated_at=None, since_id=None, max_id=None, per_page=None,
               page=None, **custom_fields):
        """
        Search customers based on a combination of parameters with pagination.

        Upstream documentation: http://dev.desk.com/API/customers#search
        """
        store = locals()
        store.update(store.pop('custom_fields'))

        params = base.get_params(None, store)
        url = '{0}/{1}'.format(self.get_url(), 'search')
        return http.Request('GET', url, params), parsers.parse_json


class Customer(CustomersBase):

    @base.resource(cases.Cases)
    def cases(self):
        return cases.Cases(self)

########NEW FILE########
__FILENAME__ = insights
from libsaas import http, parsers
from libsaas.services import base


class Insights(base.HierarchicalResource):

    path = 'insights'

    @base.apimethod
    def meta(self):
        """
        Retrieve Insights meta data for the authenticated site.

        Upstream documentation: http://dev.desk.com/API/insights/#meta-show
        """
        url = '{0}/{1}'.format(self.get_url(), 'meta')

        return http.Request('GET', url), parsers.parse_json

    @base.apimethod
    def report(self, resolution=None, min_date=None, max_date=None,
               dimension1_name=None, dimension1_values=None,
               dimension2_name=None, dimension2_values=None, metrics=None,
               sort_by=None, sort_order=None, dimension1_per_page=None,
               dimension1_page=None):
        """
        Create a report.

        Upstream documentation: http://dev.desk.com/API/insights/#report-create
        """
        params = base.get_params(None, locals())
        url = '{0}/{1}'.format(self.get_url(), 'reports')

        return http.Request('POST', url, params), parsers.parse_json

########NEW FILE########
__FILENAME__ = macros
from libsaas.services import base

from . import resource


class Actions(resource.PaginatedDeskResource):

    path = 'actions'


class Action(resource.DeskResource):

    path = 'actions'

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Macros(resource.PaginatedDeskResource):

    path = 'macros'

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Macro(resource.DeskResource):

    path = 'macros'

    @base.resource(Actions)
    def actions(self):
        """
        Return the resource corresponding to macro actions
        """
        return Actions(self)

    @base.resource(Actions)
    def action(self, action_id):
        """
        Return the resource corresponding to single macro action
        """
        return Action(self, action_id)

########NEW FILE########
__FILENAME__ = resource
from libsaas import http, parsers
from libsaas.services import base


class DeskResource(base.RESTResource):

    path = None

    @base.apimethod
    def update(self, obj):
        self.require_item()
        request = http.Request('PATCH', self.get_url(), self.wrap_object(obj))

        return request, parsers.parse_json

    @base.apimethod
    def get(self, embed=None, fields=None):
        """
        For single-object resources, fetch the object's data. For collections,
        fetch all of the objects.

        Upstream documentation: http://dev.desk.com/API/using-the-api/
        """
        params = base.get_params(None, locals())

        return http.Request('GET', self.get_url(), params), parsers.parse_json


class PaginatedDeskResource(DeskResource):

    @base.apimethod
    def get(self, embed=None, fields=None, per_page=None, page=None):
        """
        Returns a paginated list of elements

        Upstream documentation: http://dev.desk.com/API/using-the-api/
        """
        params = base.get_params(None, locals())

        return http.Request('GET', self.get_url(), params), parsers.parse_json

########NEW FILE########
__FILENAME__ = service
import json

from libsaas import http, port

from libsaas.services import base
from libsaas.filters import auth

from . import cases, customers, users, contents, macros, insights


class Desk(base.Resource):
    """
    """
    def __init__(self, subdomain, api_key, api_secret=None,
                 access_token=None, access_token_secret=None):
        """
        Create a Desk service.

        :var subdomain: The account-specific part of the Desk domain, for
            instance use `mycompany` if your Desk domain is
            `mycompany.desk.com`, or the full domain if using Desk whitelabel,
            for instance `support.mycompany.com`. If the parameter contains a
            dot, it is treated as a full domain, otherwise as a subdomain.
        :vartype subdomain: str

        :var api_key: The API key.
        :vartype api_key: str

        :var api_secret: API secret.
        :vartype api_secret: str

        :var access_token: OAuth 1.0a access token.
        :vartype access_token: str

        :var access_token_secret: OAuth 1.0a access token secret.
            requests.
        :vartype access_token_secret: str
        """
        tmpl = '{0}/api/v2'
        if '.' not in subdomain:
            subdomain += '.desk.com'
        self.apiroot = http.quote_any(tmpl.format(port.to_u(subdomain)))
        self.apiroot = 'https://' + self.apiroot

        self.oauth = auth.OAuth(access_token, access_token_secret,
                                api_key, api_secret)

        self.add_filter(self.use_json)
        # authenticate has to be the last filter, because anything that
        # modifies the request after it's signed will make the signature
        # invalid!
        self.add_filter(self.authenticate)

    def get_url(self):
        return self.apiroot

    def authenticate(self, request):
        self.oauth(request)

    def use_json(self, request):
        request.headers['Content-Type'] = 'application/json'
        request.headers['Accept'] = 'application/json'

        if request.method.upper() not in http.URLENCODE_METHODS:
            request.params = json.dumps(request.params)

    @base.resource(cases.Case)
    def case(self, case_id, is_external=False):
        """
        Return the resource corresponding to a single case.

        :var case_id: The case id
        :vartype case_id: str

        :var is_external: Use the external id
        :vartype case_id: bool

        """
        return cases.Case(self, case_id, is_external)

    @base.resource(cases.Cases)
    def cases(self):
        """
        Return the resource corresponding to all the cases.
        """
        return cases.Cases(self)

    @base.resource(customers.Customer)
    def customer(self, customer_id=None):
        """
        Return the resource corresponding to a single customer.
        """
        return customers.Customer(self, customer_id)

    @base.resource(customers.Customers)
    def customers(self):
        """
        Return the resource corresponding to all customers.
        """
        return customers.Customers(self)

    @base.resource(users.Group)
    def group(self, group_id):
        """
        Return the resource corresponding to a single group.
        """
        return users.Group(self, group_id)

    @base.resource(users.Groups)
    def groups(self):
        """
        Return the resource corresponding to all groups.
        """
        return users.Groups(self)

    @base.resource(users.SiteSettings)
    def site_settings(self):
        """
        Return the resource corresponding to the site settings.
        """
        return users.SiteSettings(self)

    @base.resource(users.User)
    def user(self, user_id):
        """
        Return the resource corresponding to a single user.
        """
        return users.User(self, user_id)

    @base.resource(users.Users)
    def users(self):
        """
        Return the resource corresponding to all users.
        """
        return users.Users(self)

    @base.resource(insights.Insights)
    def insights(self):
        """
        Return the resource corresponding to insights.
        """
        return insights.Insights(self)

    @base.resource(contents.Topic)
    def topic(self, topic_id):
        """
        Return the resource corresponding to a single topic.
        """
        return contents.Topic(self, topic_id)

    @base.resource(contents.Topics)
    def topics(self):
        """
        Return the resource corresponding to all topics.
        """
        return contents.Topics(self)

    @base.resource(contents.Article)
    def article(self, article_id):
        """
        Return the resource corresponding to a single article.
        """
        return contents.Article(self, article_id)

    @base.resource(macros.Macro)
    def macro(self, macro_id):
        """
        Return the resource corresponding to a single macro.
        """
        return macros.Macro(self, macro_id)

    @base.resource(macros.Macros)
    def macros(self):
        """
        Return the resource corresponding to all macros.
        """
        return macros.Macros(self)

########NEW FILE########
__FILENAME__ = users
from libsaas import http, parsers
from libsaas.services import base

from . import resource


class ResourceMixin(object):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Groups(ResourceMixin, resource.PaginatedDeskResource):

    path = 'groups'


class Group(ResourceMixin, resource.DeskResource):

    path = 'groups'

    @base.apimethod
    def group_filters(self, per_page=None, page=None):
        """
        Retrieve a paginated list of all filters for the given group.

        Upstream documentation: http://dev.desk.com/API/groups#list-filters
        """
        params = base.get_params(None, locals())
        url = '{0}/{1}'.format(self.get_url(), 'filters')
        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def users(self, per_page=None, page=None):
        """
        Retrieve a paginated list of all users for the given group.

        Upstream documentation: http://dev.desk.com/API/groups#list-users
        """
        params = base.get_params(None, locals())
        url = '{0}/{1}'.format(self.get_url(), 'users')
        return http.Request('GET', url, params), parsers.parse_json


class Users(ResourceMixin, resource.PaginatedDeskResource):

    path = 'users'


class User(ResourceMixin, resource.DeskResource):

    path = 'users'

    @base.apimethod
    def preferences(self, per_page=None, page=None):
        """
        List all of the user's preferences.

        Upstream documentation: http://dev.desk.com/API/users/#preferences-list
        """
        params = base.get_params(None, locals())
        url = '{0}/{1}'.format(self.get_url(), 'preferences')
        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def preference(self, preference_id):
        """
        Show a single user preference

        Upstream documentation: http://dev.desk.com/API/users/#preferences-show
        """
        url = '{0}/{1}/{2}'.format(self.get_url(), 'preferences', preference_id)
        return http.Request('GET', url), parsers.parse_json

    @base.apimethod
    def update_preference(self, preference_id, obj):
        """
        Update a user preference

        Upstream documentation: http://dev.desk.com/API/users/#preferences
        """
        url = '{0}/{1}/{2}'.format(self.get_url(), 'preferences', preference_id)
        request = http.Request('PATCH', url, self.wrap_object(obj))
        return request, parsers.parse_json


class SiteSettings(ResourceMixin, resource.PaginatedDeskResource):

    path = 'site_settings'

########NEW FILE########
__FILENAME__ = datasource
import json

from libsaas import http, parsers, port

from libsaas.filters import auth
from libsaas.services import base


class Datasource(base.Resource):
    """
    """
    def __init__(self, apikey, label):
        """
        Get a datasource resource.

        :var apikey: Your API key.
        :vartype apikey: str

        :var label: data source label
        :vartype label: str
        """
        self.url_tmpl = port.to_u('https://{0}.ducksboard.com/values/{1}')
        self.label = label

        self.add_filter(auth.BasicAuth(apikey, 'x'))
        self.add_filter(self.use_json)

    def use_json(self, request):
        if request.method.upper() not in http.URLENCODE_METHODS:
            request.params = json.dumps(request.params)

    def get_url(self, api):
        return self.url_tmpl.format(api, port.to_u(self.label))

    def get_pull_url(self):
        return self.get_url('pull')

    def get_push_url(self):
        return self.get_url('push')

    @base.apimethod
    def push(self, obj):
        """
        Send a value or a list of values. Each value can have a timestamp
        associated with it. Timestamps should be UNIX timestamps expressed
        as numbers. If no timestamp is specified, the value is assumed to be
        timestamped with the current time.

        :var obj: a Python object representing the value to push to the
            data source.
            See http://dev.ducksboard.com/apidoc/push-api/#post-values-label
        """
        request = http.Request('POST', self.get_push_url(), obj)
        return request, parsers.parse_json

    @base.apimethod
    def delete(self):
        """
        Delete all data for a given data source.
        """
        request = http.Request('DELETE', self.get_push_url(), None)
        return request, parsers.parse_empty

    @base.apimethod
    def last(self, count=None):
        """
        Get the last count values for a given data source, ordered by their
        timestamp, newest data first. This resource can be used for all data
        sources.

        :var count: The amount of data returned. It might be less than the
            count parameter. The default value for count is 3 and the maximum
            is 100.
        :vartype count: int
        """
        url = '{0}/{1}'.format(self.get_pull_url(), 'last')
        params = base.get_params(('count',), locals())

        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def since(self, seconds=None):
        """
        Get the values from up to seconds ago for a given data source,
        ordered by their timestamp, newest data first.
        This resource can be used for all data sources.

        :var seconds: The first value returned might actually be from later
            than seconds ago. The default value for seconds is 3600 and the
            maximum is 7776000.
        :vartype seconds: int
        """
        url = '{0}/{1}'.format(self.get_pull_url(), 'since')
        params = base.get_params(('seconds',), locals())

        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def timespan(self, timespan=None, timezone=None):
        """
        Get the last value for a series of periods for a given data source.
        The number of values returned depends on the timespan parameter.
        If a certain period is empty, meaning that no values from inside of
        it are found, the value of the previous period is substituted, or
        null if no previous values were found.
        See {0}

        :var timespan: The allowed values for timespan are daily, weekly
            and monthly, with the default of monthly.
        :vartype timespan: str

        :var timezone: The limits of periods are actually dependent on the
            timezone parameter, as depending on which timezone you want to
            see the data in, the last value of each period might be different.
            The default for timezone is UTC.
        :vartype timezone: str
        """
        url = '{0}/{1}'.format(self.get_pull_url(), 'timespan')
        params = base.get_params(('timespan', 'timezone'), locals())

        return http.Request('GET', url, params), parsers.parse_json

    timespan.__doc__ = timespan.__doc__.format(
        'http://dev.ducksboard.com/apidoc/pull-api-http/#get-values-label-'
        'timespan-timespan-timespan-timezone-timezone')

########NEW FILE########
__FILENAME__ = resources
from libsaas import http, parsers
from libsaas.services import base


class DucksboardResource(base.RESTResource):

    def get_url(self):
        if self.object_id is None:
            return '{0}/{1}/'.format(self.parent.get_url(), self.path)

        return '{0}/{1}/{2}'.format(self.parent.get_url(), self.path,
                                    self.object_id)


class TokenBase(DucksboardResource):

    path = 'tokens'


class Tokens(TokenBase):

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Token(TokenBase):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()


class DashboardBase(DucksboardResource):

    path = 'dashboards'


class Dashboards(DashboardBase):

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Dashboard(DashboardBase):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.apimethod
    def accessed(self):
        """
        Update the access time of a dashboard. The last accessed dashboard
        is the one that gets displayed by default when accessing the
        application.
        """

        url = '{0}/{1}'.format(self.get_url(), 'accessed')

        request = http.Request('POST', url, None)
        return request, parsers.parse_json

    @base.resource(Tokens)
    def tokens(self):
        return Tokens(self)

    @base.resource(Token)
    def token(self, token):
        return Token(self, token)

    @base.apimethod
    def widgets(self):
        """
        Get a collection of widgets from a dashboard.
        """
        url = '{0}/{1}/'.format(self.get_url(), 'widgets')

        return http.Request('GET', url), parsers.parse_json


class WidgetBase(DucksboardResource):

    path = 'widgets'


class Widgets(WidgetBase):

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.apimethod
    def positions(self, positions):
        """
        Update the positions of multiple widgets at once.

        :var positions: The object keys are widget IDs. the values should
            include a row and column field. Both of them default to 1 if
            not present.
        :vartype positions: dict
        """

        url = '{0}{1}'.format(self.get_url(), 'positions')

        request = http.Request('POST', url, positions)
        return request, parsers.parse_json


class Widget(WidgetBase):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.apimethod
    def copy(self, dashboard_slug):
        """
        Copy a widget to another dashboard, specified by a slug.
        A new widget is created, with the same parameters as the copied one.
        The position is chosen automatically if not specified.

        :var dashboard_slug: dashboard slug destination
        :vartype dashboard_slug: str
        """

        url = '{0}/{1}'.format(self.get_url(), 'copy')

        request = http.Request('POST', url, {'dashboard': dashboard_slug})
        return request, parsers.parse_json


class AccountBase(DucksboardResource):

    path = 'accounts'


class Accounts(AccountBase):

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Account(AccountBase):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()


class User(base.RESTResource):

    path = 'user'

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def require_item(self):
        pass

    @base.apimethod
    def get_api_key(self):
        """
        Get your API key. This endpoint uses HTTP Basic authentication with
        your Ducksboard username and password.
        """
        url = '{0}/{1}'.format(self.get_url(), 'api_key')

        return http.Request('GET', url), parsers.parse_json

    @base.apimethod
    def reset_api_key(self):
        """
        Reset your API key. This endpoint uses HTTP Basic authentication with
        your Ducksboard username and password.
        """
        url = '{0}/{1}'.format(self.get_url(), 'api_key')

        return http.Request('POST', url, None), parsers.parse_json

########NEW FILE########
__FILENAME__ = service
import json

from libsaas import http
from libsaas.filters import auth
from libsaas.services import base

from . import resources, datasource


class Ducksboard(base.Resource):
    """
    """
    def __init__(self, apikey_or_username, password=None):
        """
        Create a Ducksboard service.

        :var apikey_or_username: Your apikey or your username if you
            want to get or reset your API key.
        :vartype apikey_or_username: str

        :var password: Only used with your username to get or reset your
            API key.
        :vartype password: str
        """
        self.apiroot = 'https://app.ducksboard.com/api'
        self.apikey_or_username = apikey_or_username

        self.add_filter(auth.BasicAuth(apikey_or_username, password))
        self.add_filter(self.use_json)

    def use_json(self, request):
        if request.method.upper() not in http.URLENCODE_METHODS:
            request.params = json.dumps(request.params)

    def get_url(self):
        return self.apiroot

    @base.resource(resources.Dashboards)
    def dashboards(self):
        """
        Return the resource corresponding to all the dashboards.
        """
        return resources.Dashboards(self)

    @base.resource(resources.Dashboard)
    def dashboard(self, slug):
        """
        Return the resource corresponding to a single dashboard.
        """
        return resources.Dashboard(self, slug)

    @base.resource(resources.Widgets)
    def widgets(self):
        """
        Return the resource corresponding to all the widgets.
        """
        return resources.Widgets(self)

    @base.resource(resources.Widget)
    def widget(self, widget_id):
        """
        Return the resource corresponding to a single widget.
        """
        return resources.Widget(self, widget_id)

    @base.resource(resources.Accounts)
    def accounts(self):
        """
        Return the resource corresponding to all the accounts.
        """
        return resources.Accounts(self)

    @base.resource(resources.Account)
    def account(self, account_id):
        """
        Return the resource corresponding to a single account.
        """
        return resources.Account(self, account_id)

    @base.resource(resources.Account)
    def user(self):
        """
        Return the resource corresponding to your user.
        """
        return resources.User(self)

    @base.resource(datasource.Datasource)
    def data_source(self, label):
        """
        Return the resource corresponding to a datasource.
        Datasources can only be accesed using the API key
        """
        return datasource.Datasource(self.apikey_or_username, label)

########NEW FILE########
__FILENAME__ = resource
from libsaas.services import base
from libsaas import http, parsers


def to_camelcase(val):
    words = val.split('_')
    words = [words[0].lower()] + [x.capitalize() for x in words[1:]]
    return ''.join(words)


class Metrics(base.HierarchicalResource):
    path = 'appMetrics'

    def get_url(self):
        grandparent = self.parent.parent
        return '{0}/{1}'.format(grandparent.get_url(), self.path)

    def _get(self, metric_name, start_date, end_date,
             country=None, version_name=None, group_by=None):
        params = base.get_params(None, locals(),
                                 translate_param=to_camelcase)
        params.pop('metricName')

        url = '{0}/{1}'.format(self.get_url(), metric_name)

        request = http.Request('GET', url, params)
        return request, parsers.parse_json

    @base.apimethod
    def active_users(self, *args, **kwargs):
        """
        Returns the total number of unique users who accessed
        the application per day.

        :var start_date: the first date to look metrics for.
        :vartype start_date: str

        :var end_date: the last date to look metrics for.
        :vartype end_date: str

        :var country: optional parameter indicating user's country.
        :vartype country: str

        :var version_name: optional parameter indicating application's version.
        :vartype version_name: str

        :var group_by: group data by DAYS, WEEKS or MONTHS.
            By default, it will group data by days.
        :vartype group_by: str
        """
        return self._get('ActiveUsers', *args, **kwargs)

    @base.apimethod
    def active_users_by_week(self, *args, **kwargs):
        """
        Returns the total number of unique users who accessed
        the application per week

        :var start_date: the first date to look metrics for.
        :vartype start_date: str

        :var end_date: the last date to look metrics for.
        :vartype end_date: str

        :var country: optional parameter indicating user's country.
        :vartype country: str

        :var version_name: optional parameter indicating application's version.
        :vartype version_name: str

        :var group_by: group data by DAYS, WEEKS or MONTHS.
            By default, it will group data by days.
        :vartype group_by: str
        """
        return self._get('ActiveUsersByWeek', *args, **kwargs)

    @base.apimethod
    def active_users_by_month(self, *args, **kwargs):
        """
        Returns the total number of unique users who accessed
        the application per month.

        :var start_date: the first date to look metrics for.
        :vartype start_date: str

        :var end_date: the last date to look metrics for.
        :vartype end_date: str

        :var country: optional parameter indicating user's country.
        :vartype country: str

        :var version_name: optional parameter indicating application's version.
        :vartype version_name: str

        :var group_by: group data by DAYS, WEEKS or MONTHS.
            By default, it will group data by days.
        :vartype group_by: str
        """
        return self._get('ActiveUsersByMonth', *args, **kwargs)

    @base.apimethod
    def new_users(self, *args, **kwargs):
        """
        Returns the total number of unique users who used the
        application for the first time per day.

        :var start_date: the first date to look metrics for.
        :vartype start_date: str

        :var end_date: the last date to look metrics for.
        :vartype end_date: str

        :var country: optional parameter indicating user's country.
        :vartype country: str

        :var version_name: optional parameter indicating application's version.
        :vartype version_name: str

        :var group_by: group data by DAYS, WEEKS or MONTHS.
            By default, it will group data by days.
        :vartype group_by: str
        """
        return self._get('NewUsers', *args, **kwargs)

    @base.apimethod
    def median_session_length(self, *args, **kwargs):
        """
        Returns the median length of a user session per day.

        :var start_date: the first date to look metrics for.
        :vartype start_date: str

        :var end_date: the last date to look metrics for.
        :vartype end_date: str

        :var country: optional parameter indicating user's country.
        :vartype country: str

        :var version_name: optional parameter indicating application's version.
        :vartype version_name: str

        :var group_by: group data by DAYS, WEEKS or MONTHS.
            By default, it will group data by days.
        :vartype group_by: str
        """
        return self._get('MedianSessionLength', *args, **kwargs)

    @base.apimethod
    def avg_session_length(self, *args, **kwargs):
        """
        Returns the average length of a user session per day.

        :var start_date: the first date to look metrics for.
        :vartype start_date: str

        :var end_date: the last date to look metrics for.
        :vartype end_date: str

        :var country: optional parameter indicating user's country.
        :vartype country: str

        :var version_name: optional parameter indicating application's version.
        :vartype version_name: str

        :var group_by: group data by DAYS, WEEKS or MONTHS.
            By default, it will group data by days.
        :vartype group_by: str
        """
        return self._get('AvgSessionLength', *args, **kwargs)

    @base.apimethod
    def sessions(self, *args, **kwargs):
        """
        Returns the total number of times users accessed
        the application per day.

        :var start_date: the first date to look metrics for.
        :vartype start_date: str

        :var end_date: the last date to look metrics for.
        :vartype end_date: str

        :var country: optional parameter indicating user's country.
        :vartype country: str

        :var version_name: optional parameter indicating application's version.
        :vartype version_name: str

        :var group_by: group data by DAYS, WEEKS or MONTHS.
            By default, it will group data by days.
        :vartype group_by: str
        """
        return self._get('Sessions', *args, **kwargs)

    @base.apimethod
    def retained_users(self, *args, **kwargs):
        """
        Returns the total number of users who remain active users of
        the application per day.

        :var start_date: the first date to look metrics for.
        :vartype start_date: str

        :var end_date: the last date to look metrics for.
        :vartype end_date: str

        :var country: optional parameter indicating user's country.
        :vartype country: str

        :var version_name: optional parameter indicating application's version.
        :vartype version_name: str

        :var group_by: group data by DAYS, WEEKS or MONTHS.
            By default, it will group data by days.
        :vartype group_by: str
        """
        return self._get('RetainedUsers', *args, **kwargs)

    @base.apimethod
    def page_views(self, *args, **kwargs):
        """
        Returns the total number of page views per day.

        :var start_date: the first date to look metrics for.
        :vartype start_date: str

        :var end_date: the last date to look metrics for.
        :vartype end_date: str

        :var country: optional parameter indicating user's country.
        :vartype country: str

        :var version_name: optional parameter indicating application's version.
        :vartype version_name: str

        :var group_by: group data by DAYS, WEEKS or MONTHS.
            By default, it will group data by days.
        :vartype group_by: str
        """
        return self._get('PageViews', *args, **kwargs)

    @base.apimethod
    def avg_page_views_per_session(self, *args, **kwargs):
        """
        Returns the average page views per session for each day.

        :var start_date: the first date to look metrics for.
        :vartype start_date: str

        :var end_date: the last date to look metrics for.
        :vartype end_date: str

        :var country: optional parameter indicating user's country.
        :vartype country: str

        :var version_name: optional parameter indicating application's version.
        :vartype version_name: str

        :var group_by: group data by DAYS, WEEKS or MONTHS.
            By default, it will group data by days.
        :vartype group_by: str
        """
        return self._get('AvgPageViewsPerSession', *args, **kwargs)


class EventResource(base.HierarchicalResource):
    def __init__(self, parent, object_id=None):
        self.parent = parent
        self.object_id = object_id

    def get_url(self):
        grandparent = self.parent.parent
        return '{0}/eventMetrics/{1}'.format(grandparent.get_url(), self.path)

    @base.apimethod
    def get(self, start_date, end_date, version_name=None):
        """
        For single-object resources, fetch the object's data. For collections,
        fetch all of the objects.

        :var start_date: the first date to look metrics for.
        :vartype start_date: str

        :var end_date: the last date to look metrics for.
        :vartype end_date: str

        :var version_name: optional parameter indicating application's version.
        :vartype version_name: str
        """
        params = base.get_params(None, locals(),
                                 translate_param=to_camelcase)
        if self.object_id:
            params['eventName'] = self.object_id

        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json


class Events(EventResource):
    path = 'Summary'


class Event(EventResource):
    path = 'Event'


class ApplicationResource(base.HierarchicalResource):

    @base.apimethod
    def get(self):
        """
        For single-object resources, fetch the object's data. For collections,
        fetch all of the objects.
        """
        request = http.Request('GET', self.get_url())

        return request, parsers.parse_json


class Application(ApplicationResource):
    path = 'appInfo/getApplication'

    def __init__(self, parent, application_api_key):
        super(Application, self).__init__(parent)

        self.application_api_key = application_api_key
        self.add_filter(self.add_authorization)

    def add_authorization(self, request):
        request.params['apiKey'] = self.application_api_key

    @base.resource(Metrics)
    def metrics(self):
        """
        Returns the resource corresponding to all metrics.
        """
        return Metrics(self)

    @base.resource(Events)
    def events(self):
        """
        Return the resource corresponding to all events.
        """
        return Events(self)

    @base.resource(Event)
    def event(self, event_name):
        """
        Returns the resource corresponding to a single event.
        """
        return Event(self, event_name)


class Applications(ApplicationResource):
    path = 'appInfo/getAllApplications'

########NEW FILE########
__FILENAME__ = service
from libsaas.services import base

from .resource import Application, Applications


class Flurry(base.Resource):
    """
    """
    def __init__(self, api_access_code):
        """
        Create a Flurry service.

        :var api_access_code: The API access code.
        :vartype api_access_code: str
        """
        self.apiroot = 'http://api.flurry.com'

        self.api_access_code = api_access_code

        self.add_filter(self.add_authorization)
        self.add_filter(self.add_json)

    def add_authorization(self, request):
        request.params['apiAccessCode'] = self.api_access_code

    def add_json(self, request):
        request.headers['Content-Type'] = 'application/json'

    def get_url(self):
        return self.apiroot

    @base.resource(Applications)
    def applications(self):
        """
        Return the resource corresponding to all applications.
        """
        return Applications(self)

    @base.resource(Application)
    def application(self, application_api_key):
        """
        Returns the resource corresponding to a single application.
        """
        return Application(self, application_api_key)

########NEW FILE########
__FILENAME__ = resource
from libsaas import http, parsers
from libsaas.services import base


class Person(base.Resource):
    path = 'person'

    def __init__(self, parent, **kwargs):
        self.parent = parent
        self.lookup = {}
        for k, v in kwargs.items():
            if v is not None:
                self.lookup[k] = v
                break

    def get_url(self):
        return '{0}/{1}'.format(self.parent.get_url(), self.path)

    @base.apimethod
    def get(self, queue=None, style=None, prettyPrint=None, countryCode=None):
        """
        Fetch a single object.

        :var queue: Using this parameter notifies FullContact that the
                    query in question will be called later.
        :vartype queue: int

        :var style: The style parameter can be used to control the document
                    structure returned. Only available for email lookups.
        :vartype style: str

        :var prettyPrint: Used to disable prettyprint formatting response
        :vartype prettyPrint: str

        :var countryCode: For phone lookups, it must be passed when using
                          non US/Canada based numbers. Use the ISO-3166
                          two-digit country code. It defaults to US.
        :vartype countryCode: str
        """
        params = base.get_params(None, locals())
        params.update(self.lookup)

        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json


class Enhanced(base.Resource):
    path = 'enhanced'

    def __init__(self, parent, email):
        self.parent = parent
        self.email = email

    def get_url(self):
        return '{0}/{1}'.format(self.parent.get_url(), self.path)

    @base.apimethod
    def get(self):
        """
        Fetch a single object.
        """
        request = http.Request('GET', self.get_url(), {'email': self.email})

        return request, parsers.parse_json


class Name(base.HierarchicalResource):
    path = 'name'

    @base.apimethod
    def normalizer(self, q, casing=None):
        """
        Take quasi-structured name data provided as a string and
        outputs the data in a structured manner.

        :var q: Name you would like to be normalized.
        :vartype q: str

        :var casing: One of: uppercase, lowercase or titlecase.
        :vartype casing: str
        """
        params = base.get_params(None, locals())
        url = '{0}/{1}'.format(self.get_url(), 'normalizer')

        request = http.Request('GET', url, params)

        return request, parsers.parse_json

    @base.apimethod
    def deducer(self, email=None, username=None, casing=None):
        """
        Take a username or email address provided as a string and
        attempts to deduce a structured name.

        :var email: It allows you to pass an email address.
        :vartype email: str

        :var username: It allows you to pass a username.
        :vartype username: str

        :var casing: One of: uppercase, lowercase or titlecase.
        :vartype casing: str
        """
        if ((email is None and username is None) or
            (email is not None and username is not None)):
           raise TypeError('deducer() must be passed just one '
                           'of email or username.')

        params = base.get_params(None, locals())
        url = '{0}/{1}'.format(self.get_url(), 'deducer')

        request = http.Request('GET', url, params)

        return request, parsers.parse_json

    @base.apimethod
    def similarity(self, q1, q2, casing=None):
        """
        Return a score indicating how two names are similar.

        :var q1: First name to compare.
        :vartype q1: str

        :var q2: Second name to compare.
        :vartype q2: str

        :var casing: One of: uppercase, lowercase or titlecase.
        :vartype casing: str
        """
        params = base.get_params(None, locals())
        url = '{0}/{1}'.format(self.get_url(), 'similarity')

        request = http.Request('GET', url, params)

        return request, parsers.parse_json

    @base.apimethod
    def stats(self, name=None, givenName=None, familyName=None, casing=None):
        """
        Determine more about a name.

        :var name: It can be used when you only know a single name and
                   you are uncertain whether it is the given name
                   or family name.
        :vartype name: str

        :var givenName: It can be used when you know that the name
                        is a first name.
        :vartype givenName: str

        :var familyName: It can be used when you know that the name
                         is a last name.
        :vartype familyName: str

        :var casing: One of: uppercase, lowercase or titlecase.
        :vartype casing: str
        """
        if ((name is None and givenName is None and familyName is None) or
            (name is not None and (
                givenName is not None or familyName is not None))):
           raise TypeError('stats() must be passed just one '
                           'of email, givenName or familyName.')

        params = base.get_params(None, locals())
        url = '{0}/{1}'.format(self.get_url(), 'stats')

        request = http.Request('GET', url, params)

        return request, parsers.parse_json

    @base.apimethod
    def parser(self, q, casing=None):
        """
        Determine what the given name and family name for a ambiguious name.

        :var q: Name you would like to be parsed.
        :vartype q: str

        :var casing: One of: uppercase, lowercase or titlecase.
        :vartype casing: str
        """
        params = base.get_params(None, locals())
        url = '{0}/{1}'.format(self.get_url(), 'parser')

        request = http.Request('GET', url, params)

        return request, parsers.parse_json


class Location(base.HierarchicalResource):
    path = 'address'

    def get(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.apimethod
    def normalizer(self, place, includeZeroPopulation=False, casing=None):
        """
        Return structured location data for a indicated place.

        :var place: The place you are interested in.
        :vartype place: str

        :var includeZeroPopulation: Will include 0 population census locations.
        :vartype includeZeroPopulation: bool

        :var casing: One of: uppercase, lowercase or titlecase.
        :vartype casing: str
        """
        params = base.get_params(None, locals())
        url = '{0}/{1}'.format(self.get_url(), 'locationNormalizer')

        request = http.Request('GET', url, params)

        return request, parsers.parse_json

    @base.apimethod
    def enrichment(self, place, includeZeroPopulation=False, casing=None):
        """
        Return a collection of lostructured location data for a indicated place.

        :var place: The place you are interested in.
        :vartype place: str

        :var includeZeroPopulation: Will include 0 population census locations.
        :vartype includeZeroPopulation: bool

        :var casing: One of: uppercase, lowercase or titlecase.
        :vartype casing: str
        """
        params = base.get_params(None, locals())
        url = '{0}/{1}'.format(self.get_url(), 'locationEnrichment')

        request = http.Request('GET', url, params)

        return request, parsers.parse_json

########NEW FILE########
__FILENAME__ = service
import json

from libsaas.services import base
from libsaas import http

from . import resource


class Fullcontact(base.Resource):
    def __init__(self, api_key):
        """
        Create a Fullcontact service.

        :var api_key: The API key.
        :vartype api_key: str
        """
        self.apiroot = 'https://api.fullcontact.com/v2'

        self.api_key = api_key

        self.add_filter(self.use_json)
        self.add_filter(self.add_api_key)

    def get_url(self):
        return self.apiroot

    def add_api_key(self, request):
        request.params.update({'apiKey': self.api_key})

    def use_json(self, request):
        request.uri += '.json'

    @base.resource(resource.Person)
    def person(self, email=None, emailMD5=None, phone=None,
               twitter=None, facebookUsername=None):
        """
        Return the resource corresponding to a single person
        """
        kwargs = list(
            filter(None, [email, emailMD5, phone, twitter, facebookUsername,]))

        if len(kwargs) != 1:
           raise TypeError(
                'person() must be passed exactly one of '
                'email, emailMD5, phone, twitter or facebookUsername')

        return resource.Person(self, email=email, emailMD5=emailMD5, phone=phone,
                               twitter=twitter, facebookUsername=facebookUsername)

    @base.resource(resource.Enhanced)
    def enhanced(self, email):
        """
        Return the resource corresponding to a single person
        """
        return resource.Enhanced(self, email)

    @base.resource(resource.Name)
    def names(self):
        """
        Return the resource corresponding to all names.
        """
        return resource.Name(self)

    @base.resource(resource.Location)
    def locations(self):
        """
        Return the resource corresponding to all locations.
        """
        return resource.Location(self)

########NEW FILE########
__FILENAME__ = authorizations
from . import resource


class AuthorizationsBase(resource.GitHubResource):

    path = 'authorizations'


class Authorization(AuthorizationsBase):
    pass


class Authorizations(AuthorizationsBase):
    pass

########NEW FILE########
__FILENAME__ = downloads
from libsaas.services import base

from . import resource


class DownloadsBase(resource.GitHubResource):

    path = 'downloads'

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Download(DownloadsBase):
    pass


class Downloads(DownloadsBase):
    pass

########NEW FILE########
__FILENAME__ = forks
from libsaas import http, parsers
from libsaas.services import base

from . import resource


class Forks(resource.GitHubResource):

    path = 'forks'

    @base.apimethod
    def get(self, sort='newest', page=None, per_page=None):
        """
        Fetch this repo's forks.

        :var sort: The sort order for the result.
        :vartype sort: str

        :var page: The starting page of the result. If left as `None`, the
            first page is returned.
        :vartype page: int

        :var per_page: The amount of results per page.
        :vartype per_page: int
        """
        params = base.get_params(('sort', 'page', 'per_page'), locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.apimethod
    def create(self):
        """
        Fork this repo.
        """
        request = http.Request('POST', self.get_url())

        return request, parsers.parse_json

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()

########NEW FILE########
__FILENAME__ = gists
from libsaas import http, parsers
from libsaas.services import base

from . import resource


class GistCommentsBase(resource.GitHubResource):

    path = 'comments'

    def wrap_object(self, obj):
        return {'body': obj}


class GistComments(GistCommentsBase):

    @base.apimethod
    def get(self, format=None, page=None, per_page=None):
        url = self.get_url()
        params = base.get_params(('page', 'per_page'), locals())
        headers = resource.mimetype_accept(format)

        return http.Request('GET', url, params, headers), parsers.parse_json


class GistComment(GistCommentsBase):

    @base.apimethod
    def get(self, format=None, page=None, per_page=None):
        url = self.get_url()
        params = base.get_params(('page', 'per_page'), locals())
        headers = resource.mimetype_accept(format)

        return http.Request('GET', url, params, headers), parsers.parse_json


class Gists(resource.GitHubResource):

    path = 'gists'

    @base.apimethod
    def public(self, page=None, per_page=None):
        """
        Fetch public gists. The parameters are the same as for `get`.
        """
        url = '{0}/public'.format(self.get_url())
        params = base.get_params(('page', 'per_page'), locals())

        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def starred(self, page=None, per_page=None):
        """
        Fetch gists starred by the authenticated user. The parameters are the
        same as for `get`.
        """
        url = '{0}/starred'.format(self.get_url())
        params = base.get_params(('page', 'per_page'), locals())

        return http.Request('GET', url, params), parsers.parse_json

    @base.resource(GistComment)
    def comment(self, comment_id):
        """
        Return the resource corresponding to a single comment on a gist.

        When updating comments, use a simple string as the parameter to
        `update`, you don't have to use `{"body": <comment body>}`.
        """
        return GistComment(self, comment_id)


class Gist(resource.GitHubResource):

    path = 'gists'

    @base.apimethod
    def star(self):
        """
        Star this gist.
        """
        url = '{0}/{1}'.format(self.get_url(), 'star')

        # include a body, because requests does not send content-length when no
        # body is present, and that makes GitHub respond with HTTP 411
        return http.Request('PUT', url, params='*'), parsers.parse_empty

    @base.apimethod
    def unstar(self):
        """
        Unstar this gist.
        """
        url = '{0}/{1}'.format(self.get_url(), 'star')

        return http.Request('DELETE', url), parsers.parse_empty

    @base.apimethod
    def is_starred(self):
        """
        Check if this gist is starred.

        :return: bool
        """
        url = '{0}/{1}'.format(self.get_url(), 'star')

        return http.Request('GET', url), resource.parse_boolean

    @base.apimethod
    def fork(self):
        """
        Fork this gist.
        """
        url = '{0}/{1}'.format(self.get_url(), 'fork')

        return http.Request('POST', url), parsers.parse_json

    def comments(self):
        """
        Return the resource corresponding to all comments on this gist.

        When creating comments, use a simple string as the parameter to
        `create`, you don't have to use `{"body": <comment body>}`.
        """
        return GistComments(self)

########NEW FILE########
__FILENAME__ = issues
from libsaas import http, parsers
from libsaas.services import base

from . import resource, labels


class Issues(resource.GitHubResource):

    path = 'issues'

    @base.apimethod
    def get(self, filter='assigned', state='open', labels=None,
            sort='created', direction='desc', since=None, format=None,
            page=None, per_page=None):
        """
        Fetch the authenticated user's issues based on the filter parameters,
        and using the specified format.

        For details on the meanings and allowed values for each parameter, see
        http://developer.github.com/v3/issues/#list-issues.
        """
        url = self.get_url()
        params = base.get_params(
            ('filter', 'state', 'labels', 'sort', 'direction',
             'since', 'page', 'per_page'), locals())

        headers = resource.mimetype_accept(format)

        return http.Request('GET', url, params, headers), parsers.parse_json


class IssueCommentsBase(resource.GitHubResource):

    path = 'comments'

    def wrap_object(self, obj):
        return {'body': obj}


class IssueComments(IssueCommentsBase):
    pass


class IssueComment(IssueCommentsBase):
    pass


class RepoIssuesBase(resource.GitHubResource):

    path = 'issues'


class IssueEventsBase(resource.GitHubResource):

    path = 'events'

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class IssueEvent(IssueEventsBase):
    pass


class IssueEvents(IssueEventsBase):
    pass


class RepoIssue(RepoIssuesBase):

    @base.resource(IssueComments)
    def comments(self):
        """
        Return the resource corresponding to the comments of this issue.

        When creating comments, use a simple string as the parameter to
        `create`, you don't have to use `{"body": <comment body>}`.
        """
        return IssueComments(self)

    @base.resource(IssueEvent)
    def event(self, event_id):
        """
        Return the resource corresponding to a single event of this issue.
        """
        return IssueEvent(self, event_id)

    @base.resource(IssueEvents)
    def events(self):
        """
        Return the resource corresponding to all the events of this issue.
        """
        return IssueEvents(self)

    @base.resource(labels.IssueLabel)
    def label(self, name):
        """
        Return the resource corresponding to a single label of this issue.
        """
        return labels.IssueLabel(self, name)

    @base.resource(labels.IssueLabels)
    def labels(self):
        """
        Return the resource corresponding to all labels of this issue.
        """
        return labels.IssueLabels(self)


class RepoIssues(RepoIssuesBase):

    @base.apimethod
    def get(self, milestone=None, state='open', assignee=None, mentioned=None,
            labels=None, sort='created', direction='desc', since=None,
            page=None, per_page=None):
        """
        Fetch issues for this repository based on the filter parameters and
        using the specified format.

        For details on the meanings and allowed values for each parameter, see
        http://developer.github.com/v3/issues/#list-issues-for-a-repository
        """
        url = self.get_url()
        params = base.get_params(
            ('milestone', 'state', 'assignee', 'mentioned', 'labels', 'sort',
             'direction', 'since', 'page', 'per_page'), locals())

        headers = resource.mimetype_accept(format)

        return http.Request('GET', url, params, headers), parsers.parse_json

    @base.resource(IssueComment)
    def comment(self, comment_id):
        """
        Return the resource corresponding to a single comment of an issue.

        When updating comments, use a simple string as the parameter to
        `update`, you don't have to use `{"body": <comment body>}`.
        """
        return IssueComment(self, comment_id)

    @base.resource(IssueEvents)
    def events(self):
        """
        Return the resource corresponding to all events of this repo's issues.
        """
        return IssueEvents(self)

########NEW FILE########
__FILENAME__ = keys
from . import resource


class RepoKeysBase(resource.GitHubResource):

    path = 'keys'


class RepoKey(RepoKeysBase):
    pass


class RepoKeys(RepoKeysBase):
    pass

########NEW FILE########
__FILENAME__ = labels
from libsaas import http, parsers
from libsaas.services import base

from . import resource


class LabelsBase(resource.GitHubResource):

    path = 'labels'

    def get_url(self):
        if self.object_id is None:
            return '{0}/{1}'.format(self.parent.get_url(), self.path)

        return '{0}/{1}/{2}'.format(self.parent.get_url(), self.path,
                                    self.object_id)


class RepoLabel(LabelsBase):
    pass


class RepoLabels(LabelsBase):
    pass


class MilestoneLabels(LabelsBase):
    pass


class IssueLabelsBase(LabelsBase):

    @base.apimethod
    def get(self, page=None, per_page=None):
        self.require_collection()
        params = base.get_params(('page', 'per_page'), locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json
    get.__doc__ = LabelsBase.get.__doc__


class IssueLabel(IssueLabelsBase):
    pass


class IssueLabels(IssueLabelsBase):

    @base.apimethod
    def replace(self, labels):
        """
        Replace all labels on this issue with new ones.

        :var labels: A list of labels to use.
        :vartype labels: list of str
        """
        request = http.Request('PUT', self.get_url(), labels)

        return request, parsers.parse_json

    @base.apimethod
    def delete(self):
        """
        Delete all labels from this issue.
        """
        request = http.Request('DELETE', self.get_url())

        return request, parsers.parse_empty

########NEW FILE########
__FILENAME__ = milestones
from libsaas import http, parsers
from libsaas.services import base

from . import resource, labels


class MilestonesBase(resource.GitHubResource):

    path = 'milestones'

    def get_url(self):
        if self.object_id is None:
            return '{0}/{1}'.format(self.parent.get_url(), self.path)

        return '{0}/{1}/{2}'.format(self.parent.get_url(), self.path,
                                    self.object_id)


class Milestone(MilestonesBase):

    @base.resource(labels.MilestoneLabels)
    def labels(self):
        """
        Return the resource corresponding to the labels of this milestone.
        """
        return labels.MilestoneLabels(self)


class Milestones(MilestonesBase):

    @base.apimethod
    def get(self, state='open', sort='due_date', direction='desc',
            page=None, per_page=None):
        """
        Fetch milestones for this repository, based on the filter parameters.

        For details on the meanings and allowed values for each parameter,
        see {0}.
        """
        url = self.get_url()
        params = base.get_params(
            ('state', 'sort', 'direction', 'page', 'per_page'), locals())

        return http.Request('GET', url, params), parsers.parse_json

    get.__doc__ = get.__doc__.format(
        'http://developer.github.com/v3/issues/milestones/'
        '#list-milestones-for-a-repository')

########NEW FILE########
__FILENAME__ = pullrequests
from libsaas import http, parsers
from libsaas.services import base

from . import resource


class PullRequestsBase(resource.GitHubResource):

    path = 'pulls'


class PullRequests(PullRequestsBase):

    @base.apimethod
    def get(self, state=None, page=None, per_page=None):
        """
        Fetch pull requests.

        :var state: Optional filter pull requests by state  state:
            open or closed (default is open)
        :vartype path: str
        """
        params = base.get_params(None, locals())
        url = self.get_url()

        return http.Request('GET', url, params), parsers.parse_json


class PullRequest(PullRequestsBase):

    @base.apimethod
    def commits(self):
        """
        Fetch commits on this pull request.
        """
        url = '{0}/commits'.format(self.get_url())

        return http.Request('GET', url), parsers.parse_json

    @base.apimethod
    def files(self):
        """
        Fetch files on this pull request.
        """
        url = '{0}/files'.format(self.get_url())

        return http.Request('GET', url), parsers.parse_json

    @base.apimethod
    def is_merged(self):
        """
        Check if this pull request has been merged.
        """
        url = '{0}/merge'.format(self.get_url())

        return http.Request('GET', url), resource.parse_boolean

########NEW FILE########
__FILENAME__ = repocommits
from libsaas import http, parsers
from libsaas.services import base

from . import resource


class RepoCommitsCommentsBase(resource.GitHubResource):

    path = 'comments'

    def wrap_object(self, obj):
        return {'body': obj}


class RepoCommitsComment(RepoCommitsCommentsBase):

    @base.apimethod
    def get(self, format=None):
        """
        Fetch the comment.

        :var format: Which format should be requested, either `raw`, `text`,
            `html` or `full`. For details on formats, see
            http://developer.github.com/v3/mime/#comment-body-properties.
        """
        params = base.get_params(('format', ), locals())

        return http.Request('GET', self.get_url(), params), parsers.parse_json


class RepoCommitsComments(RepoCommitsCommentsBase):

    @base.apimethod
    def get(self, format=None, page=None, per_page=None):
        """
        Fetch all comments for this commit.

        :var format: Which format should be requested, either `raw`, `text`,
            `html` or `full`. For details on formats, see
            http://developer.github.com/v3/mime/#comment-body-properties.
        """
        url = self.get_url()
        params = base.get_params(('page', 'per_page'), locals())
        headers = resource.mimetype_accept(format)

        return http.Request('GET', url, params, headers), parsers.parse_json

    @base.apimethod
    def create(self, comment):
        """
        Create a comment on this commit.

        :var comment: The comment body.
        :vartype comment: str
        """
        url = self.get_url()

        # when creating commits they don't get wrapped in {"body": <comment>}
        return http.Request('POST', url, params=comment), parsers.parse_json


class RepoCommits(base.HierarchicalResource):

    path = 'commits'

    @base.apimethod
    def get(self, sha=None, path=None, page=None, per_page=None):
        """
        Fetch commits for this repo.

        :var sha: Optional commit hash or branch to start listing commits from.
        :vartype sha: str

        :var path: Optional filter to only include commits that include this
            file path.
        :vartype path: str
        """
        params = base.get_params(
            ('sha', 'path', 'page', 'per_page'), locals())
        url = '{0}/{1}'.format(self.parent.get_url(), self.path)

        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def compare(self, base, head):
        """
        Fetch the comparison of two commits.

        :var base: The commit hash of the first commit.
        :vartype base: str

        :var head: The commit hash of the second commit.
        :vartype head: str
        """
        url = '{0}/compare/{1}...{2}'.format(self.parent.get_url(), base, head)

        return http.Request('GET', url), parsers.parse_json

    @base.resource(RepoCommitsComments)
    def comments(self):
        """
        Return the resource corresponding to all comments of this commit.
        """
        return RepoCommitsComments(self.parent)

    @base.resource(RepoCommitsComment)
    def comment(self, comment_id):
        """
        Return the resource corresponding to a single comment of this commit.
        """
        return RepoCommitsComment(self.parent, comment_id)


class RepoCommit(base.HierarchicalResource):

    path = 'commits'

    @base.apimethod
    def get(self):
        """
        Fetch all commits from this repo.
        """
        return http.Request('GET', self.get_url()), parsers.parse_json

    @base.resource(RepoCommitsComments)
    def comments(self):
        """
        Return a resource corresponding to all comments of this commit.
        """
        return RepoCommitsComments(self)

########NEW FILE########
__FILENAME__ = repocontents
from libsaas import http, parsers
from libsaas.services import base


def parse_redirect(body, code, headers):
    if code != 302:
        raise http.HTTPError(body, code, headers)

    return headers.get('location')


class RepoContents(base.HierarchicalResource):

    path = 'contents'

    @base.apimethod
    def readme(self, ref=None):
        """
        This method returns the preferred README for a repository.

        :var ref: Optional string name of the commit/branch/tag. Defaults to
            master.
        :vartype ref: str
        """
        params = base.get_params(None, locals())
        url = '{0}/readme'.format(self.parent.get_url())

        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def get(self, path=None, ref=None):
        """
        This method returns the contents of any file or directory in a
        repository.

        :var path: Optional content path.
        :vartype path: str

        :var ref: Optional string name of the commit/branch/tag. Defaults to
            master.
        :vartype ref: str
        """
        params = base.get_params(('ref', ), locals())
        url = self.get_url()

        if path:
            url = '{0}/{1}'.format(url, path)

        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def archivelink(self, archive_format, ref=None):
        """
        This method will return a URL to download a tarball or zipball archive
        for a repository.

        :var archive_format: Either tarball or zipball.
        :vartype path: str

        :var ref: Optional string name of the commit/branch/tag. Defaults to
            master.
        :vartype path: str
        """
        url = '{0}/{1}'.format(self.parent.get_url(), archive_format)
        if ref:
            url = '{0}/{1}'.format(url, ref)

        return http.Request('GET', url), parse_redirect

########NEW FILE########
__FILENAME__ = repos
from libsaas import http, parsers
from libsaas.services import base

from . import resource
from . import downloads, forks, issues, keys, labels, milestones, repocommits
from . import repocontents, pullrequests


class Repos(resource.GitHubResource):

    path = 'user/repos'

    @base.apimethod
    def get(self, type='all', page=None, per_page=None):
        """
        Fetch repos for this user.

        :var type: What type of repos to fetch. For details of allowed values,
            see http://developer.github.com/v3/repos/#list-user-repositories.
        """
        params = base.get_params(('page', 'per_page'), locals())
        params['type'] = type
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json


class RepoCollaborators(base.Resource):

    path = 'collaborators'

    def get_url(self):
        return '{0}/{1}'.format(self.parent.get_url(), self.path)

    @base.apimethod
    def get(self, page=None, per_page=None):
        params = base.get_params(('page', 'per_page'), locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json
    get.__doc__ = resource.GitHubResource.get.__doc__

    @base.apimethod
    def add(self, user):
        """
        Add a collaborator to this repo.

        :var user: The username of the new collaborator.
        :vartype user: str
        """
        url = '{0}/{1}'.format(self.get_url(), user)

        # include a body, because requests does not send content-length when no
        # body is present, and that makes GitHub respond with HTTP 411
        return http.Request('PUT', url, '*'), parsers.parse_empty

    @base.apimethod
    def remove(self, user):
        """
        Remove a collaborator from this repo.

        :var user: The username of the collaborator.
        :vartype user: str
        """
        url = '{0}/{1}'.format(self.get_url(), user)

        return http.Request('DELETE', url), parsers.parse_empty

    @base.apimethod
    def is_collaborator(self, user):
        """
        Check if a user is a collaborator in this repo.

        :var user: The username to check.
        :vartype user: str

        :return: bool
        """
        url = '{0}/{1}'.format(self.get_url(), user)

        return http.Request('GET', url), resource.parse_boolean


class Repo(resource.GitHubResource):

    def __init__(self, parent, user, repo):
        self.parent = parent
        self.user = http.quote_any(user)
        self.repo = http.quote_any(repo)

    def get_url(self):
        return '{0}/repos/{1}/{2}'.format(self.parent.get_url(),
                                          self.user, self.repo)

    def require_collection(self):
        return False

    def require_item(self):
        return True

    @base.apimethod
    def contributors(self, anon=False):
        """
        Fetch the contributors from this repo.

        :var anon: Include anonymous contributors.
        :vartype anon: bool
        """
        params = {'anon': 'true' if anon else 'f'}
        url = '{0}/{1}'.format(self.get_url(), 'contributors')

        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def languages(self):
        """
        Fetch the languages for this repo.
        """
        url = '{0}/{1}'.format(self.get_url(), 'languages')

        return http.Request('GET', url), parsers.parse_json

    @base.apimethod
    def teams(self):
        """
        Fetch the teams for this repo.
        """
        url = '{0}/{1}'.format(self.get_url(), 'teams')

        return http.Request('GET', url), parsers.parse_json

    @base.apimethod
    def tags(self):
        """
        Fetch the tags for this repo.
        """
        url = '{0}/{1}'.format(self.get_url(), 'tags')

        return http.Request('GET', url), parsers.parse_json

    @base.apimethod
    def branches(self):
        """
        Fetch the branches for this repo.
        """
        url = '{0}/{1}'.format(self.get_url(), 'branches')

        return http.Request('GET', url), parsers.parse_json

    @base.resource(issues.RepoIssue)
    def issue(self, issue_id):
        """
        Return a resource corresponding to a single issue from this repo.
        """
        return issues.RepoIssue(self, issue_id)

    @base.resource(issues.RepoIssues)
    def issues(self):
        """
        Return a resource corresponding to all issues from this repo.
        """
        return issues.RepoIssues(self)

    @base.resource(labels.RepoLabel)
    def label(self, name):
        """
        Return a resource corresponding to a single label from this repo.
        """
        return labels.RepoLabel(self, name)

    @base.resource(labels.RepoLabels)
    def labels(self):
        """
        Return a resource corresponding to all issues from this repo.
        """
        return labels.RepoLabels(self)

    @base.resource(milestones.Milestone)
    def milestone(self, milestone_id):
        """
        Return a resource corresponding to a single milestone in this repo.
        """
        return milestones.Milestone(self, milestone_id)

    @base.resource(milestones.Milestones)
    def milestones(self):
        """
        Return a resource corresponding to all milestones in this repo.
        """
        return milestones.Milestones(self)

    @base.resource(RepoCollaborators)
    def collaborators(self):
        """
        Return a resource corresponding to all collaborators in this repo.
        """
        return RepoCollaborators(self)

    @base.resource(repocommits.RepoCommit)
    def commit(self, sha):
        """
        Return a resource corresponding to a single commit in this repo.
        """
        return repocommits.RepoCommit(self, sha)

    @base.resource(repocommits.RepoCommits)
    def commits(self):
        """
        Return a resource corresponding to all commits in this repo.
        """
        return repocommits.RepoCommits(self)

    @base.resource(repocontents.RepoContents)
    def contents(self):
        """
        Return a resource corresponding to repo contents.
        """
        return repocontents.RepoContents(self)

    @base.resource(pullrequests.PullRequest)
    def pullrequest(self, number):
        """
        Return a resource corresponding to a single pull request for this repo.
        """
        return pullrequests.PullRequest(self, number)

    @base.resource(pullrequests.PullRequests)
    def pullrequests(self):
        """
        Return a resource corresponding to all the pull requests for this repo.
        """
        return pullrequests.PullRequests(self)

    @base.resource(downloads.Download)
    def download(self, download_id):
        """
        Return a resource corresponding to a single download in this repo.
        """
        return downloads.Downloads(self, download_id)

    @base.resource(downloads.Downloads)
    def downloads(self):
        """
        Return a resource corresponding to all commits from this repo.
        """
        return downloads.Downloads(self)

    @base.resource(forks.Forks)
    def forks(self):
        """
        Return a resource corresponding to all forks of this repo.
        """
        return forks.Forks(self)

    @base.resource(keys.RepoKey)
    def key(self, key_id):
        """
        Return a resource corresponding to a single key in this repo.
        """
        return keys.RepoKey(self, key_id)

    @base.resource(keys.RepoKeys)
    def keys(self):
        """
        Return a resource corresponding to all SSH keys of this repo.
        """
        return keys.RepoKeys(self)

########NEW FILE########
__FILENAME__ = resource
from libsaas import http, parsers
from libsaas.services import base


def mimetype_accept(format):
    if not format:
        return {}
    mimetype = 'application/vnd.github.v3.{0}+json'.format(format)
    return {'Accept': mimetype}


def parse_boolean(body, code, headers):
    # The boolean value endpoints respond with 204 if the response is true and
    # 404 if it is not.
    if code == 204:
        return True
    if code == 404:
        return False
    raise http.HTTPError(body, code, headers)


class GitHubResource(base.RESTResource):

    @base.apimethod
    def get(self, page=None, per_page=None):
        """
        For single-object resources, fetch the object's data. For collections,
        fetch all of the objects.

        :var page: For collections, where should paging start. If left as
            `None`, the first page is returned.
        :vartype page: int

        :var per_page: For collections, how many objects sould be returned. The
            maximum is 100. If left as `None`, 30 objects are returned.
        :vartype per_page: int
        """
        params = base.get_params(('page', 'per_page'), locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

    @base.apimethod
    def update(self, obj):
        """
        Update this resource.

        :var obj: a Python object representing the updated resource, usually in
            the same format as returned from `get`. Refer to the upstream
            documentation for details.
        """
        self.require_item()
        # GitHub uses PATCH for updates
        request = http.Request('PATCH', self.get_url(), self.wrap_object(obj))

        return request, parsers.parse_json

########NEW FILE########
__FILENAME__ = service
import json

from libsaas import http
from libsaas.filters import auth
from libsaas.services import base

from . import authorizations, gists, issues, repos, users


class GitHub(base.Resource):
    """
    """
    def __init__(self, token_or_username, password=None):
        """
        Create a GitHub service.

        :var token_or_username: Either an OAuth 2.0 token, or the username if
          you want to use Basic authentication.
        :vartype token_or_username: str

        :var password: Only used with the Basic authentication, leave this as
            `None` when using OAuth.
        :vartype password: str
        """
        self.apiroot = 'https://api.github.com'

        self.add_filter(self.use_json)

        if password is None:
            self.oauth_token = token_or_username
            self.add_filter(self.add_authorization)
        else:
            self.add_filter(auth.BasicAuth(token_or_username, password))

    def add_authorization(self, request):
        request.headers['Authorization'] = 'token {0}'.format(self.oauth_token)

    def use_json(self, request):
        if request.method.upper() not in http.URLENCODE_METHODS:
            request.params = json.dumps(request.params)

    def get_url(self):
        return self.apiroot

    @base.resource(authorizations.Authorization)
    def authorization(self, authorization_id):
        """
        Return the resource corresponding to a single authorization.
        Authorizations can only be accessed when using Basic authentication.
        """
        return authorizations.Authorization(self, authorization_id)

    @base.resource(authorizations.Authorizations)
    def authorizations(self):
        """
        Return the resource corresponding to all the authorizations.
        Authorizations can only be accessed when using Basic authentication.
        """
        return authorizations.Authorizations(self)

    @base.resource(gists.Gist)
    def gist(self, gist_id):
        """
        Return the resource corresponding to a single gist.
        """
        return gists.Gist(self, gist_id)

    @base.resource(gists.Gists)
    def gists(self):
        """
        Return the resource corresponding to all the gists.
        """
        return gists.Gists(self)

    @base.resource(issues.Issues)
    def issues(self):
        """
        Return the resource corresponding to all the issues of the
        authenticated user.
        """
        return issues.Issues(self)

    @base.resource(repos.Repo)
    def repo(self, user, repo):
        """
        Return the resource corresponding to a single repo.
        """
        return repos.Repo(self, user, repo)

    @base.resource(repos.Repos)
    def repos(self):
        """
        Return the resource corresponding to all the repos.
        """
        return repos.Repos(self)

    @base.resource(users.User, users.CurrentUser)
    def user(self, name=None):
        """
        Return the resource corresponding to a single user. If `name` is `None`
        the returned resource is the currently authenticated user, otherwise it
        is the user with the given name.
        """
        if name is None:
            return users.CurrentUser(self)
        return users.User(self, name)


Github = GitHub

########NEW FILE########
__FILENAME__ = users
from libsaas import http, parsers
from libsaas.services import base

from . import resource


class UserRepos(resource.GitHubResource):

    path = 'repos'

    @base.apimethod
    def get(self, type='all', page=None, per_page=None):
        """
        Fetch repos for this user.

        :var type: What type of repos to fetch. For details of allowed values,
            see http://developer.github.com/v3/repos/#list-user-repositories.
        :vartype type: str
        """
        params = base.get_params(('page', 'per_page'), locals())
        params['type'] = type
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()


class UserEmails(base.HierarchicalResource):

    path = 'emails'

    @base.apimethod
    def get(self):
        """
        Fetch all emails of the authenticated user.
        """
        request = http.Request('GET', self.get_url())

        return request, parsers.parse_json

    @base.apimethod
    def add(self, emails):
        """
        Add emails to the authenticated user.

        :var emails: A list of emails to add.
        :vartype emails: list of str
        """
        request = http.Request('POST', self.get_url(), emails)

        return request, parsers.parse_json

    @base.apimethod
    def remove(self, emails):
        """
        Remove emails from the authenticated user.

        :var emails: A list of emails to remove.
        :vartype emails: list of str
        """
        request = http.Request('DELETE', self.get_url(), emails)

        return request, parsers.parse_empty


class UsersBase(resource.GitHubResource):

    path = 'user'

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.apimethod
    def followers(self, page=None, per_page=None):
        """
        Fetch the followers of this user.
        """
        url = '{0}/{1}'.format(self.get_url(), 'followers')
        params = base.get_params(('page', 'per_page'), locals())

        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def following(self, page=None, per_page=None):
        """
        Fetch users that this user is following.
        """
        url = '{0}/{1}'.format(self.get_url(), 'following')
        params = base.get_params(('page', 'per_page'), locals())

        return http.Request('GET', url, params), parsers.parse_json


class CurrentUser(UsersBase):

    def require_collection(self):
        raise base.MethodNotSupported()

    @base.apimethod
    def update(self, obj):
        request = http.Request('PATCH', self.get_url(), obj)

        return request, parsers.parse_json
    update.__doc__ = UsersBase.__doc__

    @base.resource(UserEmails)
    def emails(self):
        """
        Return the resource corresponding to the emails of the authenticated
        user.
        """
        return UserEmails(self)

    @base.apimethod
    def follow(self, name):
        """
        Start following the given user.
        """
        url = '{0}/{1}/{2}'.format(self.get_url(), 'following', name)

        # include a body, because requests does not send content-length when no
        # body is present, and that makes GitHub respond with HTTP 411
        return http.Request('PUT', url, '*'), parsers.parse_empty

    @base.apimethod
    def unfollow(self, name):
        """
        Stop following the given user.
        """
        url = '{0}/{1}/{2}'.format(self.get_url(), 'following', name)

        return http.Request('DELETE', url), parsers.parse_empty

    @base.apimethod
    def follows(self, name):
        """
        Check if the authenticated user follows the given user.

        :return: bool
        """
        url = '{0}/{1}/{2}'.format(self.get_url(), 'following', name)

        return http.Request('GET', url), resource.parse_boolean


class User(UsersBase):

    path = 'users'

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.resource(UserRepos)
    def repos(self, page=None, per_page=None):
        """
        Return the resource corresponding to all the repos of this user.
        """
        return UserRepos(self)

########NEW FILE########
__FILENAME__ = management
from libsaas.services import base

from .resources import Accounts, Account, Segments


class Management(base.HierarchicalResource):

    path = 'management'

    @base.resource(Accounts)
    def accounts(self):
        """
        Return the resource corresponding to all accounts
        """
        return Accounts(self)

    @base.resource(Account)
    def account(self, account_id):
        """
        Return the resource corresponding to a single account
        """
        return Account(self, account_id)

    @base.resource(Segments)
    def segments(self):
        """
        Return the resource corresponding to all segments
        """
        return Segments(self)

########NEW FILE########
__FILENAME__ = reporting
from libsaas import http, parsers
from libsaas.services import base

from .resources import translate_param

class Reporting(base.HierarchicalResource):

    path = 'data'

    def get_url(self, api_endpoint):
        return '{0}/{1}/{2}'.format(self.parent.get_url(), self.path,
                                    api_endpoint)

    @base.apimethod
    def core(self, ids, start_date, end_date, metrics, dimensions=None,
            sort=None, filters=None, segment=None, start_index=None,
            max_results=None, fields=None, prettyPrint=None, userIp=None,
            quotaUser=None, access_token=None, key=None):
        """
        Query the Core Reporting API for Google Analytics report data.

        :var ids: The unique table ID of the form ga:XXXX, where XXXX is the
            Analytics view (profile) ID for which the query will retrieve the
            data.
        :vartype ids: str

        :var start-date: The first date of the date range for which you are
            requesting the data.
        :vartype start-date: str

        :var end-date: The first last of the date range for which you are
            requesting the data.
        :vartype end-date: str

        :var metrics: A list of comma-separated metrics, such as
            ga:visits,ga:bounces.
        :vartype metrics: str

        :var dimensions: A list of comma-separated dimensions for your
            Analytics data, such as ga:browser,ga:city.
        :vartype dimensions: str

        :var sort A list of comma-separated dimensions and metrics indicating
            the sorting order and sorting direction for the returned data.
        :vartype sort: str

        :var filters: Dimension or metric filters that restrict the data
            returned for your request.
        :vartype filters: str

        :var segment: Segments the data returned for your request.
        :vartype segment: str

        :var start-index: The first row of data to retrieve, starting at 1.
            Use this parameter as a pagination mechanism along with the
            max-results parameter.
        :vartype start-index: int

        :var max-results: The maximum number of rows to include in the response
        :vartype max-results: int

        :var fields: Selector specifying a subset of fields to include in the
            response.

        :var prettyPrint: Returns response with indentations and line breaks.
            Default false.
        :vartype prettyPrint: bool

        :var userIp: Specifies IP address of the end user for whom the API call
            is being made. Used to cap usage per IP.
        :vartype userIp: str

        :var quotaUser: Alternative to userIp in cases when the user's IP
            address is unknown.
        :vartype quotaUser: str

        :var access_token: One possible way to provide an OAuth 2.0 token.
        :vartype access_token: str

        :var key: Used for OAuth 1.0a authorization to specify your application
            to get quota. For example: key=AldefliuhSFADSfasdfasdfASdf.
        :vartype key: str
        """
        params = base.get_params(None, locals(),
                                 translate_param=translate_param)
        request = http.Request('GET', self.get_url('ga'), params)

        return request, parsers.parse_json

    @base.apimethod
    def realtime(self, ids, metrics, dimensions=None, sort=None, filters=None,
                 max_results=None, fields=None, prettyPrint=None, userIp=None,
                 quotaUser=None, access_token=None, key=None ):
        """
        Returns real-time data for a view (profile)

        :var ids: The unique table ID of the form ga:XXXX, where XXXX is the
            Analytics view (profile) ID for which the query will retrieve the
            data.
        :vartype ids: str

        :var metrics: A list of comma-separated metrics, such as
            ga:visits,ga:bounces.
        :vartype metrics: str

        :var dimensions: A list of comma-separated dimensions for your
            Analytics data, such as ga:browser,ga:city.
        :vartype dimensions: str

        :var sort A list of comma-separated dimensions and metrics indicating
            the sorting order and sorting direction for the returned data.
        :vartype sort: str

        :var filters: Dimension or metric filters that restrict the data
            returned for your request.
        :vartype filters: str

        :var max-results: The maximum number of rows to include in the response
        :vartype max-results: int

        :var fields: Selector specifying a subset of fields to include in the
            response.

        :var prettyPrint: Returns response with indentations and line breaks.
            Default false.
        :vartype prettyPrint: bool

        :var userIp: Specifies IP address of the end user for whom the API call
            is being made. Used to cap usage per IP.
        :vartype userIp: str

        :var quotaUser: Alternative to userIp in cases when the user's IP
            address is unknown.
        :vartype quotaUser: str

        """
        params = base.get_params(None, locals(),
                                 translate_param=translate_param)
        request = http.Request('GET', self.get_url('realtime'), params)

        return request, parsers.parse_json

########NEW FILE########
__FILENAME__ = resources
from libsaas import http, parsers
from libsaas.services import base


def translate_param(val):
    return val.replace('_', '-')


class QuotaResource(base.RESTResource):

    @base.apimethod
    def get(self, userIp=None, quotaUser=None):
        """
        Get resource

        :var userIp: Specifies IP address of the end user for whom the API call
            is being made. Used to cap usage per IP.
        :vartype userIp: str

        :var quotaUser: Alternative to userIp in cases when the user's IP
            address is unknown.
        :vartype quotaUser: str
        """
        params = base.get_params(None, locals(),
                                 translate_param=translate_param)
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class PaginatedQuotaResource(QuotaResource):

    @base.apimethod
    def get(self, max_results=None, start_index=None, userIp=None,
            quotaUser=None):
        """
        List resource

        :var max-results: The maximum number of rows to include in the response
        :vartype max-results: int

        :var start-index: The first row of data to retrieve, starting at 1.
            Use this parameter as a pagination mechanism along with the
            max-results parameter.
        :vartype start-index: int

        :var userIp: Specifies IP address of the end user for whom the API call
            is being made. Used to cap usage per IP.
        :vartype userIp: str

        :var quotaUser: Alternative to userIp in cases when the user's IP
            address is unknown.
        :vartype quotaUser: str
        """
        params = base.get_params(None, locals(),
                                 translate_param=translate_param)
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json


class GoalBase(QuotaResource):

    path = 'goals'


class Goal(GoalBase):
    pass


class Goals(GoalBase, PaginatedQuotaResource):
    pass


class ViewBase(QuotaResource):

    path = 'profiles'


class Views(ViewBase, PaginatedQuotaResource):
    pass


class View(ViewBase):

    @base.resource(Goals)
    def goals(self):
        """
        Return the resource corresponding to all goals
        """
        return Goals(self)

    @base.resource(Goal)
    def goal(self, goal_id):
        """
        Return the resource corresponding to a single goal
        """
        return Goal(self, goal_id)


class WebPropertyBase(QuotaResource):

    path = 'webproperties'


class WebProperties(WebPropertyBase, PaginatedQuotaResource):
    pass


class WebProperty(WebPropertyBase):

    @base.resource(Views)
    def views(self):
        """
        Return the resource corresponding to all views
        """
        return Views(self)

    @base.resource(View)
    def view(self, profile_id):
        """
        Return the resource corresponding to a single view
        """
        return View(self, profile_id)


class AccountBase(QuotaResource):

    path = 'accounts'


class Accounts(AccountBase, PaginatedQuotaResource):
    pass


class Account(AccountBase):

    @base.resource(WebProperties)
    def webproperties(self):
        """
        Return the resource corresponding to all web properties
        """
        return WebProperties(self)

    @base.resource(WebProperty)
    def webproperty(self, webproperty_id):
        """
        Return the resource corresponding to a single property
        """
        return WebProperty(self, webproperty_id)


class Segments(PaginatedQuotaResource):

    path = 'segments'

########NEW FILE########
__FILENAME__ = service
import json

from libsaas import http
from libsaas.services import base

from . import management, reporting


class GoogleAnalytics(base.Resource):

    APIROOT = 'https://www.googleapis.com/analytics/v3'

    def __init__(self, access_token=None):
        """
        Create a Google Analytics service.

        :var access_token:
        :vartype access_token:
        """
        self.access_token = access_token

        self.add_filter(self.add_auth)
        self.add_filter(self.use_json)

    def add_auth(self, request):
        header = 'Bearer {0}'.format(self.access_token)
        request.headers['Authorization'] = header

    def use_json(self, request):
        if (request.method.upper() not in http.URLENCODE_METHODS
                and request.params):
            request.headers['Content-Type'] = 'application/json'
            request.params = json.dumps(request.params)

    def get_url(self):
        return self.APIROOT

    def set_access_token(self, access_token):
        self.access_token = access_token

    @base.resource(management.Management)
    def management(self):
        """
        Return the resource corresponding to the management API
        """
        return management.Management(self)

    @base.resource(reporting.Reporting)
    def reporting(self):
        """
        Return the resource corresponding to the reporting API
        """
        return reporting.Reporting(self)

########NEW FILE########
__FILENAME__ = acl
from libsaas.services import base

from .resource import GoogleCalendarResource


class AclResource(GoogleCalendarResource):
    path = 'acl'


class Acls(AclResource):

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def patch(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Acl(AclResource):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

########NEW FILE########
__FILENAME__ = calendar
from libsaas import http, parsers
from libsaas.services import base

from .resource import GoogleCalendarResource
from .acl import Acls, Acl
from . import event as e


class CalendarResource(GoogleCalendarResource):
    path = 'calendars'


class Calendars(CalendarResource):

    def get(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def patch(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Calendar(CalendarResource):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.apimethod
    def clear(self):
        """
        Clear this calendar.
        """
        self.require_item()
        url = '{0}/clear'.format(self.get_url())
        request = http.Request('POST', url)

        return request, parsers.parse_empty

    @base.resource(Acls)
    def rules(self):
        """
        Return the resource corresponding to all the rules
        """
        return Acls(self)

    @base.resource(Acl)
    def rule(self, rule_id):
        """
        Return the resource corresponding to a single rule
        """
        return Acl(self, rule_id)

    @base.resource(e.Events)
    def events(self):
        """
        Return the resource corresponding to all the events
        """
        return e.Events(self)

    @base.resource(e.Event)
    def event(self, event_id):
        """
        Return the resource corresponding to a single event
        """
        return e.Event(self, event_id)


class CalendarListResource(GoogleCalendarResource):
    path = 'calendarList'


class CalendarLists(CalendarListResource):

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def patch(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class CalendarList(CalendarListResource):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

########NEW FILE########
__FILENAME__ = event
from libsaas import http, parsers
from libsaas.services import base

from .resource import GoogleCalendarResource


class EventResource(GoogleCalendarResource):
    path = 'events'


class Events(EventResource):

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def patch(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.apimethod
    def get(self, alwaysIncludeEmail=None, iCalUID=None,
            maxAttendees=None, maxResults=None, orderBy=None, pageToken=None,
            q=None, showDeleted=None, showHiddenInvitations=None,
            singleEvents=None, timeMax=None, timeMin=None, timeZone=None,
            updateMin=None):
        """
        Fetch all events on the calendar.

        :var alwaysIncludeEmail: Whether to always include a value in the
            "email" field for the organizer, creator and attendees, even
            if no real email is available. The default is False.
        :vartype alwaysIncludeEmail: str
        :var iCalUID: Specifies iCalendar UID of events to be included.
        :vartype iCalUID: str
        :var maxAttendees: The maximum number of attendees to include
            in the response. If none is indicated, only the participant
            is returned.
        :vartype maxAttendees: int
        :var maxResults: Maximum number of events returned.
        :vartype maxResults: int
        :var orderBy: The order of the events returned in the result.
            The default is an unspecified, stable order.
        :vartype orderBy: str
        :var pageToken:	Token specifying which result page to return.
        :vartype pageToken: str
        :var q: Free text search terms to find events that match these terms.
        :vartype q: str
        :var showDeleted: Whether to include deleted events.
            The default is False.
        :vartype showDeleted: str
        :var showHiddenInvitations: Whether to include hidden invitations.
            The default is False.
        :vartype showHiddenInvitations: str
        :var singleEvents: Whether to expand recurring events into instances
            and only return single one-off events and instances of recurring
            events, but not the underlying recurring events themselves.
            The default is False.
        :vartype singleEvents: str
        . :var timeMax:	Upper bound for an event's start time to filter by.
            The default is not to filter by start time.
        :vartype timeMax: str
        :var timeMin: Lower bound for an event's end time to filter by.
            The default is not to filter by end time.
        :vartype timeMin: str
        :var timeZone: Time zone used in the response.
            The default is the time zone of the calendar.
        :vartype timeZone: str
        :var updatedMin: Lower bound for an event's last modification timestamp
            to filter by. Optional. The default is not to filter by last modification time.
        :vartype updateMin: str
        """
        params = base.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

    @base.apimethod
    def create(self, obj, sendNotifications=None):
        """
        Create a new resource.

        :var obj: a Python object representing the resource to be created,
            usually in the same format as returned from `get`. Refer to the
            upstream documentation for details.
        :var sendNotifications: Whether to send notifications.
            The default is False.
        :vartype sendNotifications: str
        """
        self.require_collection()

        params = base.get_params(('sendNotifications', ), locals())
        url = self.get_url()
        if params:
            url += '?' + http.urlencode_any(params)

        request = http.Request('POST', url, self.wrap_object(obj))

        return request, parsers.parse_empty

    @base.apimethod
    def importing(self, obj):
        """
        Import an event.

        :var obj: a Python object representing the imported event.
        """
        self.require_collection()
        url = '{0}/import'.format(self.get_url())
        request = http.Request('POST', url, self.wrap_object(obj))

        return request, parsers.parse_json

    @base.apimethod
    def quick_add(self, text, sendNotifications=None):
        """
        Import an event.

        :var text: The text describing the event to be created.
        :vartype text: str
        :var sendNotifications: Whether to send notifications.
            The default is False.
        :vartype sendNotifications: str
        """
        self.require_collection()
        params = base.get_params(None, locals())
        url = '{0}/quickAdd'.format(self.get_url())
        url += '?' + http.urlencode_any(params)
        request = http.Request('POST', url)

        return request, parsers.parse_json


class Event(EventResource):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.apimethod
    def get(self, alwaysIncludeEmail=None, maxAttendees=None, timeZone=None):
        """
        For single-object resources, fetch the object's data. For collections,
        fetch all of the objects.

        :var alwaysIncludeEmail:	Whether to always include a value in the
            "email" field for the organizer, creator and attendees, even
            if no real email is available. The default is False.
        :vartype alwaysIncludeEmail: str
        :var maxAttendees: The maximum number of attendees to include
            in the response. If none is indicated, only the participant
            is returned.
        :vartype maxAttendees: int
        :var timeZone: Time zone used in the response.
            The default is the time zone of the calendar.
        :vartype timeZone: str
        """
        params = base.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

    @base.apimethod
    def update(self, obj, alwaysIncludeEmail=None, sendNotifications=None):
        """
        Update this resource.

        :var obj: a Python object representing the updated resource, usually in
            the same format as returned from `get`. Refer to the upstream
            documentation for details.
        :var alwaysIncludeEmail: Whether to always include a value in the
            "email" field for the organizer, creator and attendees, even
            if no real email is available. The default is False.
        :vartype alwaysIncludeEmail: str
        :var sendNotifications: Whether to send notifications.
            The default is False.
        :vartype sendNotifications: str
        """
        self.require_item()

        params = base.get_params(
                ('alwaysIncludeEmail', 'sendNotifications'), locals())
        url = self.get_url()
        if params:
            url += '?' + http.urlencode_any(params)

        request = http.Request('PUT', url, self.wrap_object(obj))

        return request, parsers.parse_json

    @base.apimethod
    def patch(self, obj, alwaysIncludeEmail=None, sendNotifications=None):
        """
        Patch this resource.

        :var obj: a Python object representing the updated resource, usually in
            the same format as returned from `get`. Refer to the upstream
            documentation for details.
        :var alwaysIncludeEmail: Whether to always include a value in the
            "email" field for the organizer, creator and attendees, even
            if no real email is available. The default is False.
        :vartype alwaysIncludeEmail: str
        :var sendNotifications: Whether to send notifications.
            The default is False.
        :vartype sendNotifications: str
        """
        self.require_item()

        params = base.get_params(
                ('alwaysIncludeEmail', 'sendNotifications'), locals())
        url = self.get_url()
        if params:
            url += '?' + http.urlencode_any(params)

        request = http.Request('PATCH', url, self.wrap_object(obj))

        return request, parsers.parse_json

    @base.apimethod
    def delete(self, sendNotifications=None):
        """
        Delete this resource.

        :var sendNotifications: Whether to send notifications.
            The default is False.
        :vartype sendNotifications: str
        """
        self.require_item()

        params = base.get_params(None, locals())
        url = self.get_url()
        if params:
            url += '?' + http.urlencode_any(params)

        request = http.Request('DELETE', url)

        return request, parsers.parse_empty

    @base.apimethod
    def move(self, destination, sendNotifications=None):
        """
        Move an event to another calendar.

        :var destination: Calendar identifier of the target calendar
            where the event is to be moved to.
        :vartype destination: str
        :var sendNotifications: Whether to send notifications.
            The default is False.
        :vartype sendNotifications: str
        """
        self.require_item()
        params = base.get_params(None, locals())
        url = '{0}/move'.format(self.get_url())
        url += '?' + http.urlencode_any(params)
        request = http.Request('POST', url)

        return request, parsers.parse_json

    @base.apimethod
    def instances(self, alwaysIncludeEmail=None, maxAttendees=None,
            maxResults=None, originalStart=None, pageToken=None,
            showDeleted=None, timeZone=None):
        """
        Fetch all instances of the recurring event.

        :var alwaysIncludeEmail: Whether to always include a value in the
            "email" field for the organizer, creator and attendees, even
            if no real email is available. The default is False.
        :vartype alwaysIncludeEmail: str
        :var maxAttendees: The maximum number of attendees to include
            in the response. If none is indicated, only the participant
            is returned.
        :vartype maxAttendees: int
        :var maxResults: Maximum number of instances returned.
        :vartype maxResults: int
        :var originalStart: The original start time of the instance
            in the result.
        :vartype originalStart: str
        :var pageToken:	Token specifying which result page to return.
        :vartype pageToken: str
        :var showDeleted: Whether to include deleted instances.
            The default is False.
        :vartype showDeleted: str
        :var timeZone: Time zone used in the response.
            The default is the time zone of the calendar.
        :vartype timeZone: str
        """
        params = base.get_params(None, locals())
        url = '{0}/instances'.format(self.get_url())
        request = http.Request('GET', url, params)

        return request, parsers.parse_json


########NEW FILE########
__FILENAME__ = resource
from libsaas import http, parsers
from libsaas.services import base


class GoogleCalendarResource(base.RESTResource):

    @base.apimethod
    def patch(self, obj):
        """
        Update this resource's metadata.

        :var obj: a Python object representing the updated resource.
            Refer to the upstream documentation for details.
        """
        self.require_item()
        request = http.Request('PATCH', self.get_url(), self.wrap_object(obj))

        return request, parsers.parse_json


class ReadonlyResource(base.RESTResource):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def patch(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class ColorsResource(ReadonlyResource):
    path = 'colors'


class FreeBusyResource(ReadonlyResource):
    path = 'freeBusy'

    def get(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.apimethod
    def query(self, obj):
        """
        Return free/busy info for a set of calendars.

        :var obj: a Python object representing the query.
        """
        self.require_collection()
        request = http.Request('POST', self.get_url(), self.wrap_object(obj))

        return request, parsers.parse_json

########NEW FILE########
__FILENAME__ = service
import json

from libsaas import http
from libsaas.services import base

from .user import User
from . import calendar as c
from .resource import ColorsResource, FreeBusyResource


class GoogleCalendar(base.Resource):

    APIROOT = 'https://www.googleapis.com/calendar/v3'

    def __init__(self, access_token=None):
        """
        Create a Google Calendar service.

        :var access_token:
        :vartype access_token:
        """
        self.access_token = access_token

        self.add_filter(self.add_auth)
        self.add_filter(self.use_json)

    def add_auth(self, request):
        header = 'Bearer {0}'.format(self.access_token)
        request.headers['Authorization'] = header

    def use_json(self, request):
        if (request.method.upper() not in http.URLENCODE_METHODS
                and request.params):
            request.headers['Content-Type'] = 'application/json'
            request.params = json.dumps(request.params)

    def get_url(self):
        return self.APIROOT

    def set_access_token(self, access_token):
        self.access_token = access_token

    @base.resource(c.Calendars)
    def calendars(self):
        """
        Return the resource corresponding to all the calendars
        """
        return c.Calendars(self)

    @base.resource(c.Calendar)
    def calendar(self, calendar_id):
        """
        Return the resource corresponding to a single calendar
        """
        return c.Calendar(self, calendar_id)

    @base.resource(ColorsResource)
    def colors(self):
        """
        Return the resource corresponding to all the colors
        """
        return ColorsResource(self)

    @base.resource(FreeBusyResource)
    def freebusy(self):
        """
        Return the resource corresponding to all the free/busy info
        """
        return FreeBusyResource(self)

    @base.resource(User)
    def me(self):
        """
        Return the resource corresponding to the current user
        """
        return User(self)

########NEW FILE########
__FILENAME__ = user
from libsaas.services import base

from .resource import ReadonlyResource
from .calendar import CalendarLists, CalendarList


class SettingResource(ReadonlyResource):
    path = 'settings'


class User(ReadonlyResource):
    path = 'users/me'

    def get(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.resource(SettingResource)
    def settings(self):
        """
        Return the resource corresponding to all the settings
        """
        return SettingResource(self)

    @base.resource(SettingResource)
    def setting(self, setting):
        """
        Return the resource corresponding to a single setting
        """
        return SettingResource(self, setting)

    @base.resource(CalendarLists)
    def calendar_lists(self):
        """
        Return the resource corresponding to all the calendar lists
        """
        return CalendarLists(self)

    @base.resource(CalendarList)
    def calendar_list(self, calendar_id):
        """
        Return the resource corresponding to a single calendar list
        """
        return CalendarList(self, calendar_id)

########NEW FILE########
__FILENAME__ = service
import urllib

from libsaas import http, parsers
from libsaas.services import base


class GoogleOAuth2(base.Resource):

    APIROOT = 'https://accounts.google.com/o/oauth2'

    def __init__(self, client_id, client_secret):
        """
        Create a Google Analytics service.

        :var client_id: The client_id obtained from the APIs Console. Indicates
            the client that is making the request. The value passed in this
            parameter must exactly match the value shown in the APIs Console.
        :var client_id: str

        """
        self.client_id = client_id
        self.client_secret = client_secret

        self.add_filter(self.set_header)

    def add_auth(self, request):
        header = 'Bearer {0}'.format(self.access_token)
        request.headers['Authorization'] = header

    def set_header(self, request):
        if (request.method.upper() not in http.URLENCODE_METHODS
                and request.params):
            request.headers['Content-Type'] = 'application/x-www-form-urlencoded'

    def get_url(self, api_endpoint):
        return '{0}/{1}'.format(self.APIROOT, api_endpoint)

    def get_auth_url(self, response_type, redirect_uri, scope, state=None,
                     access_type=None, approval_prompt=None, login_hint=None):
        """
        This endpoint is the target of the initial request for an access token.
        It handles active session lookup, authenticating the user, and user
        consent. The result of requests of this endpoint include access tokens,
        refresh tokens, and authorization codes.

        :var response_type: Determines if the Google OAuth 2.0 endpoint returns
            an authorization code. For installed applications, a value of code
            should be used.
        :vartype response_type: str

        :var redirect_uri: One of the redirect_uri values registered at the
            APIs Console. Determines where the response is sent.
            You may choose between urn:ietf:wg:oauth:2.0:oob or an
            http://localhost port.
        :vartype redirect_uri: str

        :var scope: Space delimited set of permissions the application
            requests. Indicates the Google API access your application is
            requesting. The values passed in this parameter inform the consent
            page shown to the user. There is an inverse relationship between
            the number of permissions requested and the likelihood of obtaining
            user consent.
        :vartype scope: str

        :var state: Indicates any state which may be useful to your application
            upon receipt of the response. The Google Authorization Server
            roundtrips this parameter, so your application receives the same
            value it sent.
        :vartype state: str

        :var access_type: online or offline. Indicates if your application
            needs to access a Google API when the user is not present at the
            browser. This parameter defaults to online. If your application
            needs to refresh access tokens when the user is not present at the
            browser, then use offline. This will result in your application
            obtaining a refresh token the first time your application exchanges
            an authorization code for a user.
        :vartype access_type: str

        :var approval_prompt: force or auto. Indicates if the user should be
            re-prompted for consent. The default is auto, so a given user
            should only see the consent page for a given set of scopes the
            first time through the sequence. If the value is force, then the
            user sees a consent page even if they have previously given consent
            to your application for a given set of scopes.
        :vartype approval_prompt: str

        :var login_hint: When your application knows which user it is trying to
            authenticate, it may provide this parameter as a hint to the
            Authentication Server. Passing this hint will either pre-fill the
            email box on the sign-in form or select the proper multi-login
            session, thereby simplifying the login flow.
        :vartype login_hint: str
        """
        params = {'client_id': self.client_id}
        params.update(base.get_params(None, locals()))
        return '{0}?{1}'.format(self.get_url('auth'), urllib.urlencode(params))


    @base.apimethod
    def access_token(self, code, redirect_uri):
        """
        Get the access and/or refresh token

        :var code: The authorization code returned from the initial request
        :vartype code: str


        :var redirect_uri: The URI registered with the application
        :vartype redirect_uri: str
        """
        params = (base.get_params(None, locals()))
        params.update({'client_id': self.client_id,
                       'client_secret': self.client_secret,
                       'grant_type': 'authorization_code'})

        request = http.Request('POST', self.get_url('token'), params)

        return request, parsers.parse_json

    @base.apimethod
    def refresh_token(self, refresh_token):
        """
        Refresh the access token

        :var refresh_token: The refresh token returned from the authorization
            code exchange
        :vartype code: str
        """
        params = (base.get_params(None, locals()))
        params.update({'client_id': self.client_id,
                       'client_secret': self.client_secret,
                       'grant_type': 'refresh_token'})

        request = http.Request('POST', self.get_url('token'), params)

        return request, parsers.parse_json


########NEW FILE########
__FILENAME__ = resource
from libsaas import http, parsers
from libsaas.services import base


def translate_param(val):
    return val.replace('_', '-')


class SpreadsheetsResource(base.RESTResource):

    APIROOT = 'https://spreadsheets.google.com/feeds'

    def __init__(self, *args, **kwargs):
        self.version = None
        return super(SpreadsheetsResource, self).__init__(*args, **kwargs)

    @base.apimethod
    def create(self, obj):
        """
        Create a new resource.

        :var obj: a Python object representing the resource to be created,
            usually in the same as returned from `get`. Refer to the upstream
            documentation for details.
        """
        self.require_collection()
        request = http.Request('POST', self.get_url(), self.wrap_object(obj))

        return request, parsers.parse_xml

    @base.apimethod
    def update(self, version, obj):
        """
        Update this resource.

        :var version: the resource version you want to update.
        :vartype version: str
        :var obj: a Python object representing the updated resource, usually in
            the same format as returned from `get`. Refer to the upstream
            documentation for details.
        """
        self.require_item()
        self.version = version
        request = http.Request('PUT', self.get_url(), self.wrap_object(obj))

        return request, parsers.parse_xml

    @base.apimethod
    def delete(self, version):
        """
        Delete this resource.

        :var version: the resource version you want to delete.
        :vartype version: str
        """
        self.require_item()
        self.version = version
        request = http.Request('DELETE', self.get_url())

        return request, parsers.parse_empty


class ListResource(SpreadsheetsResource):

    def get_url(self):
        url = '{0}/{1}/{2}/{3}/{4}/{5}'.format(
                self.APIROOT,
                self.path,
                self.parent.parent.object_id,
                self.parent.object_id,
                self.parent.visibility,
                self.parent.projection)

        if self.object_id is not None:
            url = '{0}/{1}'.format(url, self.object_id)

        if self.version is not None:
            url = '{0}/{1}'.format(url, self.version)

        return url


class RowResource(ListResource):
    path = 'list'


class Rows(RowResource):

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.apimethod
    def get(self, reverse=None, orderby=None, sq=None):
        """
        Fetch rows for the worksheet.

        :var reverse: To get rows in reverse order
        :vartype reverse: bool
        :var orderby: To sort the values in ascending order by a
            particular column.
        :vartype orderby: str
        :var sq: Use it to produce a feed with entries that meet
            the specified criteria.
        :vartype sq: str
        """
        params = base.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

class Row(RowResource):

    def get(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()


class CellResource(ListResource):
    path = 'cells'

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Cells(CellResource):

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.apimethod
    def get(self, min_row=None, max_row=None, min_col=None, max_col=None):
        """
        Fetch cells for the worksheet.

        :var min_row: To get cells above the indicated row.
        :vartype min_row: int
        :var max_row: To get cells below the given row.
        :vartype max_row: int
        :var min_col: To get cells from the indicated column.
        :vartype min_col: int
        :var max_col: To get cells to the given column.
        :vartype max_col: int
        """
        params = base.get_params(None, locals(),
                                 translate_param=translate_param)

        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

class Cell(CellResource):

    pass


class WorksheetResource(SpreadsheetsResource):

    path = 'worksheets'

    def __init__(self, parent, object_id=None,
                visibility='private', projection='full'):
        """
        Worksheet resource constructor.

        :var visibility: private or public object's visibility.
        :vartype visibility: str
        :var projection: full or basic projection, causing the feed
            to return less information (i.e. fewer fields, and only
            the most important data).
        :vartype projection: str
        """
        super(WorksheetResource, self).__init__(parent, object_id)
        self.visibility = visibility
        self.projection = projection

    def get_url(self):
        url = '{0}/{1}/{2}/{3}/{4}'.format(
                    self.parent.get_url(),
                    self.path,
                    self.parent.object_id,
                    self.visibility,
                    self.projection)

        if self.object_id is not None:
            url = '{0}/{1}'.format(url, self.object_id)

        if self.version is not None:
            url = '{0}/{1}'.format(url, self.version)

        return url


class Worksheets(WorksheetResource):

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Worksheet(WorksheetResource):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.resource(Rows)
    def rows(self):
        """
        Return the resource corresponding to all the rows
        """
        return Rows(self)

    @base.resource(Row)
    def row(self, row_id):
        """
        Return the resource corresponding to a single row
        """
        return Row(self, row_id)

    @base.resource(Cells)
    def cells(self):
        """
        Return the resource corresponding to all the cells
        """
        return Cells(self)

    @base.resource(Cell)
    def cell(self, cell_id):
        """
        Return the resource corresponding to a single cell
        """
        return Cell(self, cell_id)


class Spreadsheets(SpreadsheetsResource):

    path = 'spreadsheets/private/full'

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Spreadsheet(SpreadsheetsResource):

    def get_url(self):
        return self.parent.get_url()

    def get(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.resource(Worksheets)
    def worksheets(self, visibility, projection):
        """
        Return the resource corresponding to all the worksheets
        """
        return Worksheets(self, visibility=visibility, projection=projection)

    @base.resource(Worksheet)
    def worksheet(self, worksheet_id, visibility, projection):
        """
        Return the resource corresponding to a single worksheet
        """
        return Worksheet(self, worksheet_id, visibility, projection)

########NEW FILE########
__FILENAME__ = service
from libsaas import http, xml
from libsaas.services import base

from . import resource


class GoogleSpreadsheets(base.Resource):

    APIROOT = 'https://spreadsheets.google.com/feeds'

    def __init__(self, access_token=None):
        """
        Create a Google Spreadsheets service.

        :var access_token:
        :vartype access_token:
        """
        self.access_token = access_token

        self.add_filter(self.add_auth)
        self.add_filter(self.set_format)

    def add_auth(self, request):
        header = 'Bearer {0}'.format(self.access_token)
        request.headers['Authorization'] = header

    def get_url(self):
        return self.APIROOT

    def set_format(self, request):
        if request.method.upper() in http.URLENCODE_METHODS:
            request.params['alt'] = 'json'
        else:
            request.headers['Content-Type'] = 'application/atom+xml'
            request.params = xml.dict_to_xml(request.params)

    def set_access_token(self, access_token):
        self.access_token = access_token

    @base.resource(resource.Spreadsheets)
    def spreadsheets(self):
        """
        Return the resource corresponding to all the spreadsheets
        """
        return resource.Spreadsheets(self)

    @base.resource(resource.Spreadsheet)
    def spreadsheet(self, key):
        """
        Return the resource corresponding to a single spreadsheet
        """
        return resource.Spreadsheet(self, key)

########NEW FILE########
__FILENAME__ = comments
from libsaas.services import base

from . import resource


class CommentBase(resource.InstagramResource):

    path = 'comments'

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Comments(CommentBase):

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Comment(CommentBase):

    def get(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

########NEW FILE########
__FILENAME__ = feed
from libsaas import http, parsers
from libsaas.services import base

from . import resource


class Feed(resource.ReadonlyResource):

    path = 'feed'

    @base.apimethod
    def get(self, count=None, min_id=None, max_id=None):
        """
        Fetch all of the objects.

        :var count: Count of media to return.
        :vartype count: int

        :var min_id: Return media later than this min_id.
        :vartype min_id: int

        :var max_id: Return media earlier than this max_id.
        :vartype max_id: int
        """
        params = base.get_params(('count', 'min_id', 'max_id'), locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

########NEW FILE########
__FILENAME__ = geographies
from libsaas.services import base

from . import resource, media


class Geography(resource.ReadonlyResource):

    path = 'geographies'

    def get(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.resource(media.RecentMedia)
    def recent_media(self):
        """
        Return the resource corresponding to all recent media
        for the greography.
        """
        return media.RecentMedia(self)


########NEW FILE########
__FILENAME__ = likes
from libsaas import http, parsers
from libsaas.services import base

from . import resource


class LikeBase(resource.InstagramResource):

    path = 'likes'

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Likes(LikeBase):

    @base.apimethod
    def create(self):
        """
        Set a like on this media by the currently authenticated user.
        """
        self.require_collection()
        request = http.Request('POST', self.get_url(), self.wrap_object({}))

        return request, parsers.parse_json

    @base.apimethod
    def delete(self):
        """
        Remove a like on this media by the currently authenticated user.
        """
        self.require_collection()
        request = http.Request('DELETE', self.get_url())

        return request, parsers.parse_empty


########NEW FILE########
__FILENAME__ = locations
from libsaas import http, parsers
from libsaas.services import base

from . import resource, media


class LocationBase(resource.ReadonlyResource):

    path = 'locations'


class Locations(LocationBase):

    path = 'locations/search'

    @base.apimethod
    def get(self, lat=None, distance=None, lng=None,
            foursquare_v2_id=None, foursquare_id=None):
        """
        fetch all locations by geographic coordinate.

        :var lat: Latitude of the center search coordinate.
            If used, lng is required.
        :vartype lat: float

        :var distance: Default is 1km (distance=1000), max distance is 5km.
        :vartype distance: int

        :var lng: Longitude of the center search coordinate.
            If used, lat is required.
        :vartype lng: float

        :var foursquare_v2_id: A foursquare v2 api location id.
            If used, you are not required to use lat and ln
        :vartype foursquare_v2_id: str

        :var foursquare_id: A foursquare v1 api location id.
            If used, you are not required to use lat and lng.
            Note that this method is deprecated; you should use the
            new foursquare IDs with V2 of their API.
        :vartype foursquare_id: str
        """
        params = base.get_params(
            ('lat', 'distance', 'lng', 'foursquare_v2_id', 'foursquare_id'),
            locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json


class Location(LocationBase):

    @base.resource(media.RecentMedia)
    def recent_media(self):
        """
        Return the resource corresponding to all recent media
        for the location.
        """
        return media.RecentMedia(self)

########NEW FILE########
__FILENAME__ = media
from libsaas import http, parsers
from libsaas.services import base

from . import resource
from .comments import Comments, Comment
from .likes import Likes


class MediaBase(resource.ReadonlyResource):

    path = 'media'


class Media(MediaBase):

    @base.resource(Comments)
    def comments(self):
        """
        Return the resource corresponding to all comments for the media.
        """
        return Comments(self)

    @base.resource(Comment)
    def comment(self, comment_id):
        """
        Return the resource corresponding to a single comment for the media.
        """
        return Comment(self, comment_id)

    @base.resource(Likes)
    def likes(self):
        """
        Return the resource corresponding to all likes for the media.
        """
        return Likes(self)


class Medias(MediaBase):

    path = 'media/search'

    @base.apimethod
    def get(self, lat=None, max_timestamp=None, min_timestamp=None,
            lng=None, distance=None):
        """
        Fetch all of the objects.

        :var lat: Latitude of the center search coordinate.
            If used, lng is required.
        :vartype lat: float

        :var max_timestamp: A unix timestamp. All media returned will be
            taken later than this timestamp.
        :vartype max_timestamp: int

        :var min_timestamp: A unix timestamp. All media returned will be
            taken earlier than this timestamp.
        :vartype min_timestamp: int

        :var lng: Longitude of the center search coordinate.
            If used, lat is required.
        :vartype lng: float

        :var distance: Default is 1km (distance=1000), max distance is 5km.
        :vartype distance: int
        """
        params = base.get_params(
            ('lat', 'max_timestamp', 'min_timestamp', 'lng', 'distance'),
            locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json


class PopularMedia(MediaBase):

    path = 'media/popular'


class RecentMedia(MediaBase):

    path = 'media/recent'

    @base.apimethod
    def get(self, count=None, max_timestamp=None, min_timestamp=None,
            min_id=None, max_id=None):
        """
        Fetch all of the objects.

        :var count: Count of media to return.
        :vartype count: int

        :var max_timestamp: Return media before this UNIX timestamp.
        :vartype max_timestamp: int

        :var min_timestamp: Return media after this UNIX timestamp.
        :vartype min_timestamp: int

        :var min_id: Return media later than this min_id.
        :vartype min_id: int

        :var max_id: Return media earlier than this max_id.
        :vartype max_id: int
        """
        params = base.get_params(
            ('count', 'max_timestamp', 'min_timestamp', 'min_id', 'max_id'),
            locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json


class LikedMedia(MediaBase):

    path = 'media/liked'

    @base.apimethod
    def get(self, count=None, max_liked_id=None):
        """
        Fetch all of the objects.

        :var count: Count of media to return.
        :vartype count: int

        :var max_like_id: Return media liked before this id.
        :vartype max_like_id: int
        """
        params = base.get_params(('count', 'max_liked_id'), locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

########NEW FILE########
__FILENAME__ = relationships
from libsaas import http, parsers
from libsaas.services import base

from . import resource


class Follows(resource.ReadonlyResource):

    path = 'follows'


class FollowedBy(resource.ReadonlyResource):

    path = 'followed-by'


class RequestedBy(resource.ReadonlyResource):

    path = 'requested-by'


class Relationship(resource.ReadonlyResource):

    path = 'relationship'

    @base.apimethod
    def update(self, action):
        """
        Modifies the relationship between the current user and the target user.

        :var action: One of follow/unfollow/block/unblock/approve/deny.
        :vartype action: str
        """
        request = http.Request('POST', self.get_url(), {'action': action})

        return request, parsers.parse_json

########NEW FILE########
__FILENAME__ = resource
from libsaas.services import base


class InstagramResource(base.RESTResource):

    pass


class ReadonlyResource(InstagramResource):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()

########NEW FILE########
__FILENAME__ = service
from libsaas import http
from libsaas.services import base

from . import geographies
from .tags import Tags, Tag
from .locations import Locations, Location
from .media import Medias, Media, PopularMedia
from .users import Users, User, AuthenticatedUser

class Instagram(base.Resource):
    """
    """
    def __init__(self, client_id=None, access_token=None):
        """
        Create an Instagram service.

        :var client_id: Associates your script with a specific application.
            Required if no access_token.
        :vartype client_id: str

        :var access_token: For some requests, specifically those made on behalf
            of a user, authentication is needed. Required if no client_id.
        :vartype access_token: str
        """
        if not client_id and not access_token:
           raise TypeError('__init__() must be passed at least one '
                           'of client_id, access_token')

        self.apiroot = 'https://api.instagram.com/v1'

        self.client_id = client_id
        self.access_token = access_token
        self.add_filter(self.add_authorization)

    def add_authorization(self, request):
        params = {}
        if self.access_token:
            params['access_token'] = self.access_token
        else:
            params['client_id'] = self.client_id

        # executors will only url encode params for the methods
        # in http.URLENCODED_METHODS. That won't work for Instagram API
        # as they expect the token to be part of the url.
        if request.method.upper() == 'DELETE':
            request.uri += '?' + http.urlencode_any(params)
        else:
            request.params.update(params)
            if request.method.upper() not in http.URLENCODE_METHODS:
                request.headers['Content-Type'] = (
                    'application/x-www-form-urlencoded')

    def get_url(self):
        return self.apiroot

    @base.resource(Users)
    def users(self):
        """
        Return the resource corresponding to all users.
        """
        return Users(self)

    @base.resource(User)
    def user(self, user_id):
        """
        Return the resource corresponding to a single user.
        """
        return User(self, user_id)

    @base.resource(AuthenticatedUser)
    def authenticated_user(self):
        """
        Return the resource corresponding to the authenticated user.
        """
        return AuthenticatedUser(self)

    @base.resource(Medias)
    def medias(self):
        """
        Return the resource corresponding to all medias.
        """
        return Medias(self)

    @base.resource(PopularMedia)
    def popular_media(self):
        """
        Return the resource corresponding to all most popular media.
        """
        return PopularMedia(self)

    @base.resource(Media)
    def media(self, media_id):
        """
        Return the resource corresponding to a single media.
        """
        return Media(self, media_id)

    @base.resource(Tags)
    def tags(self):
        """
        Return the resource corresponding to all tags.
        """
        return Tags(self)

    @base.resource(Tag)
    def tag(self, tag_name):
        """
        Return the resource corresponding to a single tag.
        """
        return Tag(self, tag_name)

    @base.resource(Locations)
    def locations(self):
        """
        Return the resource corresponding to all locations.
        """
        return Locations(self)

    @base.resource(Location)
    def location(self, location_id):
        """
        Return the resource corresponding to a single location.
        """
        return Location(self, location_id)

    @base.resource(geographies.Geography)
    def geography(self, geo_id):
        """
        Return the resource corresponding to a single geography
        """
        return geographies.Geography(self, geo_id)

########NEW FILE########
__FILENAME__ = tags
from libsaas import http, parsers
from libsaas.services import base

from . import resource, media


class TagBase(resource.ReadonlyResource):

    path = 'tags'


class Tags(TagBase):

    path = 'tags/search'

    @base.apimethod
    def get(self, query):
        """
        fetch all tags by name.

        :var query: A valid tag name without a leading #. (eg. snow, nofilter).
        :vartype query: str
        """
        params = {'q': query}
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json


class Tag(TagBase):

    @base.resource(media.RecentMedia)
    def recent_media(self):
        """
        Return the resource corresponding to all recent media for the tag.
        """
        return media.RecentMedia(self)

########NEW FILE########
__FILENAME__ = users
from libsaas import http, parsers
from libsaas.services import base

from . import resource, media, feed, relationships


class UserBase(resource.ReadonlyResource):

    path = 'users'


class Users(UserBase):

    path = 'users/search'

    @base.apimethod
    def get(self, query, count=None):
        """
        Fetch all users by name.

        :var query: A query string.
        :vartype query: str

        :var count: Number of users to return.
        :vartype count: int
        """
        params = base.get_params(('count',), locals())
        params['q'] = query
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json


class User(UserBase):

    @base.resource(media.RecentMedia)
    def recent_media(self):
        """
        Return the resource corresponding to all recent media for the user.
        """
        return media.RecentMedia(self)

    @base.resource(relationships.Follows)
    def follows(self):
        """
        Return the resource corresponding to all follows for the user.
        """
        return relationships.Follows(self)

    @base.resource(relationships.FollowedBy)
    def followed_by(self):
        """
        Return the resource corresponding to all followers for the user.
        """
        return relationships.FollowedBy(self)

    @base.resource(relationships.Relationship)
    def relationship(self):
        """
        Return the resource corresponding to all relationships for the user.
        """
        return relationships.Relationship(self)


class AuthenticatedUser(UserBase):

    path = 'users/self'

    @base.resource(feed.Feed)
    def feed(self):
        """
        Return the resource corresponding to all entries for the user.
        """
        return feed.Feed(self)

    @base.resource(media.LikedMedia)
    def liked_media(self):
        """
        Return the resource corresponding to all liked media for the user.
        """
        return media.LikedMedia(self)

    @base.resource(relationships.RequestedBy)
    def requested_by(self):
        """
        Return the resource corresponding to all requests for the user.
        """
        return relationships.RequestedBy(self)


########NEW FILE########
__FILENAME__ = resource
from libsaas import http, parsers
from libsaas.services import base


class IntercomResource(base.RESTResource):

    def get_url(self):
        return '{0}/{1}'.format(self.parent.get_url(), self.path)


class UserBase(IntercomResource):

    path = 'users'

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Users(UserBase):

    @base.apimethod
    def get(self, page=None, per_page=None):
        """
        Fetch all of the objects.

        :var page: The page that should be returned. If left as `None`,
            first page are returned.
        :vartype page: int

        :var per_page: How many objects should be returned. The
            maximum is 500. If left as `None`, 500 objects are returned.
        :vartype per_page: int
        """
        params = base.get_params(('page', 'per_page'), locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

    @base.apimethod
    def update(self, obj):
        """
        Update this resource.

        :var obj: a Python object representing the updated resource, usually in
            the same format as returned from `get`. Refer to the upstream
            documentation for details.
        """
        request = http.Request('PUT', self.get_url(), self.wrap_object(obj))

        return request, parsers.parse_json


class User(UserBase):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.apimethod
    def get(self, user_id=None, email=None):
        """
        Fetch the object's data.

        :var user_id: The user_id of the user that should be returned.
            Required if no email.
        :vartype user_id: int

        :var email: The email of the user that should be returned.
            Required if no user_id.
        :vartype email: str
        """
        if not user_id and not email:
           raise TypeError('get() must be passed at least one '
                           'of user_id, email')

        params = base.get_params(('user_id', 'email'), locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json


class Impressions(IntercomResource):

    path = 'users/impressions'

    def get(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class MessageThreadBase(IntercomResource):

    path = 'users/message_threads'

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class MessageThreads(MessageThreadBase):

    @base.apimethod
    def get(self, user_id=None, email=None):
        """
        Fetch all of the objects for the user.

        :var user_id: The user_id of the user which messages should be
            returned. Required if no email.
        :vartype user_id: int

        :var email: The email of the user which messages that should be
            returned. Required if no user_id.
        :vartype email: str
        """
        if not user_id and not email:
           raise TypeError('get() must be passed at least one '
                           'of user_id, email')

        params = base.get_params(('user_id', 'email'), locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

    @base.apimethod
    def reply(self, obj):
        """
        Reply to a message thread from an admin from a user
        """
        request = http.Request('PUT', self.get_url(), self.wrap_object(obj))

        return request, parsers.parse_json


class MessageThread(MessageThreadBase):

    @base.apimethod
    def get(self, thread_id, user_id=None, email=None):
        """
        Fetch all a single object.

        :var thread_id: The thread_id of the message that should be returned.
        :vartype thread_id: int

        :var user_id: The user_id of the user which message should be returned.
            Required if no email.
        :vartype user_id: int

        :var email: The email of the user which message that should be
            returned. Required if no user_id.
        :vartype email: str
        """
        if not user_id and not email:
           raise TypeError('get() must be passed at least one '
                           'of user_id, email')

        params = base.get_params(('user_id', 'email'), locals())
        params['thread_id'] = thread_id
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json


    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

########NEW FILE########
__FILENAME__ = service
import json

from libsaas import http

from libsaas.filters import auth
from libsaas.services import base

from . import resource


class Intercom(base.Resource):
    """
    """
    def __init__(self, app_id, api_key):
        """
        Create a Intercom service.

        :var app_id: The APP identifier.
        :vartype app_id: str
        :var api_key: The API key.
        :vartype api_key: str
        """
        self.apiroot = 'https://api.intercom.io/v1'

        self.add_filter(auth.BasicAuth(app_id, api_key))
        self.add_filter(self.use_json)

    def get_url(self):
        return self.apiroot

    def use_json(self, request):
        if request.method.upper() not in http.URLENCODE_METHODS:
            request.params = json.dumps(request.params)

    @base.resource(resource.Users)
    def users(self):
        """
        Return the resource corresponding to all users.
        """
        return resource.Users(self)

    @base.resource(resource.User)
    def user(self):
        """
        Return the resource corresponding to a single user.
        """
        return resource.User(self)

    @base.resource(resource.Impressions)
    def impressions(self):
        """
        Return the resource corresponding to all impressions.
        """
        return resource.Impressions(self)

    @base.resource(resource.MessageThreads)
    def message_threads(self):
        """
        Return the resource corresponding to all message threads.
        """
        return resource.MessageThreads(self)

    @base.resource(resource.MessageThread)
    def message_thread(self):
        """
        Return the resource corresponding to a single message thread.
        """
        return resource.MessageThread(self)

########NEW FILE########
__FILENAME__ = service
import inspect

from libsaas import http, parsers, port
from libsaas.services import base


class Mailchimp(base.Resource):
    """
    """
    def __init__(self, api_key):
        """
        Create a Mailchimp service.

        :var api_key: The API key including the region, for instance
            `8ac789caf98879caf897a678fa76daf-us2`.
        :vartype api_key: str
        """
        self.api_key, dc = port.to_u(api_key).split('-')

        tmpl = '{0}.api.mailchimp.com/1.3/'
        self.apiroot = http.quote_any(tmpl.format(dc))
        self.apiroot = 'https://' + self.apiroot

        self.add_filter(self.add_api_root)
        self.add_filter(self.add_params)

    def add_api_root(self, request):
        request.uri = self.apiroot + request.uri

    def add_params(self, request):
        request.params += (('output', 'json'), ('apikey', self.api_key))

    def get_url(self, method):
        return '?method={0}'.format(method)

    def method_call(self, params):
        # a trick - get the method name from the stack frame preceding the
        # current one
        method = inspect.stack()[1][3]

        # serialize the parameters
        serialized = ()
        for name, value in params.items():
            if name == 'self':
                continue
            if value is None:
                continue
            serialized += http.serialize_flatten(name, value)

        request = http.Request('POST', self.get_url(method), serialized)
        return request, parsers.parse_json

    @base.apimethod
    def campaignContent(self, cid, for_archive=True):
        return self.method_call(locals())

    @base.apimethod
    def campaignCreate(self, type, options, content,
                       segment_opts={}, type_opts={}):
        return self.method_call(locals())

    @base.apimethod
    def campaignDelete(self, cid):
        return self.method_call(locals())

    @base.apimethod
    def campaignEcommOrderAdd(self, order):
        return self.method_call(locals())

    @base.apimethod
    def campaignPause(self, cid):
        return self.method_call(locals())

    @base.apimethod
    def campaignReplicate(self, cid):
        return self.method_call(locals())

    @base.apimethod
    def campaignResume(self, cid):
        return self.method_call(locals())

    @base.apimethod
    def campaignSchedule(self, cid, schedule_time, schedule_time_b=None):
        return self.method_call(locals())

    @base.apimethod
    def campaignSegmentTest(self, list_id, options={}):
        return self.method_call(locals())

    @base.apimethod
    def campaignSendNow(self, cid):
        return self.method_call(locals())

    @base.apimethod
    def campaignSendTest(self, cid, test_emails=[], send_type=None):
        return self.method_call(locals())

    @base.apimethod
    def campaignShareReport(self, cid, opts={}):
        return self.method_call(locals())

    @base.apimethod
    def campaignTemplateContent(self, cid):
        return self.method_call(locals())

    @base.apimethod
    def campaignUnschedule(self, cid):
        return self.method_call(locals())

    @base.apimethod
    def campaignUpdate(self, cid, name, value):
        return self.method_call(locals())

    @base.apimethod
    def campaigns(self, filters={}, start=None, limit=None):
        return self.method_call(locals())

    # XXX params order
    @base.apimethod
    def campaignAbuseReports(self, cid, since=None, start=None, limit=None):
        return self.method_call(locals())

    @base.apimethod
    def campaignAdvice(self, cid):
        return self.method_call(locals())

    @base.apimethod
    def campaignAnalytics(self, cid):
        return self.method_call(locals())

    @base.apimethod
    def campaignBounceMessage(self, cid, email):
        return self.method_call(locals())

    @base.apimethod
    def campaignBounceMessages(self, cid, start=None, limit=None, since=None):
        return self.method_call(locals())

    @base.apimethod
    def campaignClickStats(self, cid):
        return self.method_call(locals())

    @base.apimethod
    def campaignEcommOrders(self, cid, start=None, limit=None, since=None):
        return self.method_call(locals())

    @base.apimethod
    def campaignEepUrlStats(self, cid):
        return self.method_call(locals())

    @base.apimethod
    def campaignGeoOpens(self, cid):
        return self.method_call(locals())

    @base.apimethod
    def campaignGeoOpensForCountry(self, cid, code):
        return self.method_call(locals())

    @base.apimethod
    def campaignMembers(self, cid, status=None, start=None, limit=None):
        return self.method_call(locals())

    @base.apimethod
    def campaignStats(self, cid):
        return self.method_call(locals())

    @base.apimethod
    def campaignUnsubscribes(self, cid, start=None, limit=None):
        return self.method_call(locals())

    @base.apimethod
    def campaignClickDetailAIM(self, cid, url, start=None, limit=None):
        return self.method_call(locals())

    @base.apimethod
    def campaignEmailStatsAIM(self, cid, email_address=[]):
        return self.method_call(locals())

    @base.apimethod
    def campaignNotOpenedAIM(self, cid, start=None, limit=None):
        return self.method_call(locals())

    @base.apimethod
    def campaignOpenedAIM(self, cid, start=None, limit=None):
        return self.method_call(locals())

    @base.apimethod
    def ecommOrderAdd(self, order={}):
        return self.method_call(locals())

    @base.apimethod
    def ecommOrderDel(self, store_id, order_id):
        return self.method_call(locals())

    @base.apimethod
    def ecommOrders(self, start=None, limit=None, since=None):
        return self.method_call(locals())

    @base.apimethod
    def folderAdd(self, name, type=None):
        return self.method_call(locals())

    # XXX is type actually used?
    @base.apimethod
    def folderDel(self, fid, type=None):
        return self.method_call(locals())

    @base.apimethod
    def folderUpdate(self, fid, name, type=None):
        return self.method_call(locals())

    @base.apimethod
    def folders(self, type=None):
        return self.method_call(locals())

    @base.apimethod
    def gmonkeyActivity(self):
        return self.method_call(locals())

    @base.apimethod
    def gmonkeyAdd(self, cid, id, email_address=[]):
        return self.method_call(locals())

    @base.apimethod
    def gmonkeyDel(self, cid, id, email_address=[]):
        return self.method_call(locals())

    @base.apimethod
    def gmonkeyMembers(self):
        return self.method_call(locals())

    @base.apimethod
    def campaignsForEmail(self, email_address, options={}):
        return self.method_call(locals())

    @base.apimethod
    def chimpChatter(self):
        return self.method_call(locals())

    @base.apimethod
    def generateText(self, type, content):
        return self.method_call(locals())

    @base.apimethod
    def getAccountDetails(self):
        return self.method_call(locals())

    @base.apimethod
    def inlineCss(self, html, strip_css=False):
        return self.method_call(locals())

    @base.apimethod
    def listsForEmail(self, email_address):
        return self.method_call(locals())

    @base.apimethod
    def ping(self):
        return self.method_call(locals())

    @base.apimethod
    def listAbuseReports(self, id, start=None, limit=None, since=None):
        return self.method_call(locals())

    @base.apimethod
    def listActivity(self, id):
        return self.method_call(locals())

    @base.apimethod
    def listBatchSubscribe(self, id, batch=[], double_optin=True,
                           update_existing=False, replace_interests=True):
        return self.method_call(locals())

    @base.apimethod
    def listBatchUnsubscribe(self, id, emails=[], delete_member=False,
                           send_goodbye=True, send_notify=False):
        return self.method_call(locals())

    @base.apimethod
    def listClients(self, id):
        return self.method_call(locals())

    @base.apimethod
    def listGrowthHistory(self, id):
        return self.method_call(locals())

    @base.apimethod
    def listInterestGroupAdd(self, id, group_name, grouping_id=None):
        return self.method_call(locals())

    @base.apimethod
    def listInterestGroupDel(self, id, group_name, grouping_id=None):
        return self.method_call(locals())

    @base.apimethod
    def listInterestGroupUpdate(self, id, old_name, new_name,
                                grouping_id=None):
        return self.method_call(locals())

    @base.apimethod
    def listInterestGroupingAdd(self, id, name, type, groups=[]):
        return self.method_call(locals())

    @base.apimethod
    def listInterestGroupingDel(self, grouping_id):
        return self.method_call(locals())

    @base.apimethod
    def listInterestGroupingUpdate(self, grouping_id, name, value):
        return self.method_call(locals())

    @base.apimethod
    def listInterestGroupings(self, id):
        return self.method_call(locals())

    @base.apimethod
    def listLocations(self, id):
        return self.method_call(locals())

    @base.apimethod
    def listMemberActivity(self, id, email_address=[]):
        return self.method_call(locals())

    @base.apimethod
    def listMemberInfo(self, id, email_address=[]):
        return self.method_call(locals())

    # XXX params order
    @base.apimethod
    def listMembers(self, id, status='subscribed',
                    since=None, start=None, limit=None):
        return self.method_call(locals())

    @base.apimethod
    def listMergeVarAdd(self, id, tag, name, options={}):
        return self.method_call(locals())

    @base.apimethod
    def listMergeVarDel(self, id, tag):
        return self.method_call(locals())

    @base.apimethod
    def listMergeVarUpdate(self, id, tag, options={}):
        return self.method_call(locals())

    @base.apimethod
    def listMergeVars(self, id):
        return self.method_call(locals())

    @base.apimethod
    def listStaticSegmentAdd(self, id, name):
        return self.method_call(locals())

    @base.apimethod
    def listStaticSegmentDel(self, id, seg_id):
        return self.method_call(locals())

    @base.apimethod
    def listStaticSegmentMembersAdd(self, id, seg_id, batch=[]):
        return self.method_call(locals())

    @base.apimethod
    def listStaticSegmentMembersDel(self, id, seg_id, batch=[]):
        return self.method_call(locals())

    @base.apimethod
    def listStaticSegmentReset(self, id, seg_id):
        return self.method_call(locals())

    @base.apimethod
    def listStaticSegments(self, id):
        return self.method_call(locals())

    @base.apimethod
    def listSubscribe(self, id, email_address, merge_vars={},
                      email_type='html', double_optin=True,
                      update_existing=False,
                      replace_interests=True, send_welcome=False):
        return self.method_call(locals())

    @base.apimethod
    def listUnsubscribe(self, id, email_address, delete_member=False,
                        send_goodbye=True, send_notify=True):
        return self.method_call(locals())

    @base.apimethod
    def listUpdateMember(self, id, email_address, merge_vars={},
                         email_type=None, replace_interests=True):
        return self.method_call(locals())

    @base.apimethod
    def listWebhookAdd(self, id, url, actions={}, sources={}):
        return self.method_call(locals())

    @base.apimethod
    def listWebhookDel(self, id, url):
        return self.method_call(locals())

    @base.apimethod
    def listWebhooks(self, id):
        return self.method_call(locals())

    @base.apimethod
    def lists(self, filters={}, start=None, limit=None):
        return self.method_call(locals())

    @base.apimethod
    def apikeyAdd(self, username, password):
        return self.method_call(locals())

    @base.apimethod
    def apikeyExpire(self, username, password):
        return self.method_call(locals())

    @base.apimethod
    def apikeys(self, username, password, apikey, expired=False):
        return self.method_call(locals())

    @base.apimethod
    def templateAdd(self, name, html):
        return self.method_call(locals())

    @base.apimethod
    def templateDel(self, id):
        return self.method_call(locals())

    # XXX tid vs id?
    @base.apimethod
    def templateInfo(self, tid, type='user'):
        return self.method_call(locals())

    @base.apimethod
    def templateUndel(self, id):
        return self.method_call(locals())

    @base.apimethod
    def templateUpdate(self, id, values={}):
        return self.method_call(locals())

    @base.apimethod
    def templates(self, types=None, category=None, inactives=None):
        if types is None:
            types = {'user': True, 'gallery': False, 'base': False}
        if inactives is None:
            inactives = {'include': False, 'only': False}
        return self.method_call(locals())


def add_docstrings():
    for method_name in Mailchimp.list_methods():
        function = port.method_func(Mailchimp, method_name)
        # set the docstring
        function.__doc__ = """
Call Mailchimp's {0} method.

Upstream documentation: http://apidocs.mailchimp.com/api/rtfm/{1}.func.php
""".format(method_name, method_name.lower())


add_docstrings()

########NEW FILE########
__FILENAME__ = resources
import json

from libsaas import http, parsers, port
from libsaas.services import base


def parse_boolean(body, code, headers):
    # Mixpanel's track endpoint responds with '1' for True and '0' for False
    if not 200 <= code < 300:
        raise http.HTTPError(body, code, headers)

    if body == b'1':
        return True
    elif body == b'0':
        return False

    raise http.HTTPError(body, code, headers)


def parse_export(body, code, headers):
    # the export endpoint returns lines of JSON values
    if not 200 <= code < 300:
        raise http.HTTPError(body, code, headers)

    # JSON mandates the use of UTF-8, so assume each line is decodable
    return [json.loads(line.decode('utf-8')) for line in body.splitlines()]


def serialize_param(val):
    if isinstance(val, bool):
        return '1' if val else '0'
    if isinstance(val, list):
        return json.dumps([port.to_u(v) for v in val])
    return val


class Events(base.Resource):

    @base.apimethod
    def get(self, event, type, unit, interval):
        """
        Fetch event data.
        """
        params = base.get_params(('event', 'type', 'unit', 'interval'),
                                 locals(), serialize_param)
        request = http.Request('GET', 'events/', params)

        return request, parsers.parse_json

    @base.apimethod
    def top(self, type, limit=None):
        """
        Fetch the top events for today.
        """
        params = base.get_params(('type', 'limit'), locals(), serialize_param)
        request = http.Request('GET', 'events/top/', params)

        return request, parsers.parse_json

    @base.apimethod
    def names(self, type, limit=None):
        """
        Fetch the most common events over the last 31 days.
        """
        params = base.get_params(('type', 'limit'), locals(), serialize_param)
        request = http.Request('GET', 'events/names/', params)

        return request, parsers.parse_json


class Properties(base.Resource):

    @base.apimethod
    def get(self, event, name, type, unit, interval,
                   values=None, limit=None):
        """
        Fetch data of a single event.
        """
        params = base.get_params(('event', 'name', 'type',
                                  'unit', 'interval', 'values', 'limit'),
                                 locals(), serialize_param)
        request = http.Request('GET', 'events/properties/', params)

        return request, parsers.parse_json

    @base.apimethod
    def top(self, event, limit=None):
        """
        Fetch top property names for an event.
        """
        params = base.get_params(('event', 'limit'), locals(), serialize_param)

        request = http.Request('GET', 'events/properties/top/', params)

        return request, parsers.parse_json

    @base.apimethod
    def values(self, event, name, limit=None, bucket=None):
        """
        Fetch top values for a property.
        """
        params = base.get_params(('event', 'name', 'limit', 'bucket'),
                                 locals(), serialize_param)

        request = http.Request('GET', 'events/properties/values/', params)

        return request, parsers.parse_json


class Funnels(base.Resource):

    @base.apimethod
    def get(self, funnel_id, from_date=None, to_date=None, length=None,
            interval=None, unit=None, on=None, where=None, limit=None):
        """
        Fetch data for a funnel.
        """
        params = base.get_params(
            ('funnel_id', 'from_date', 'to_date', 'length', 'interval',
             'unit', 'on', 'where', 'limit'), locals(), serialize_param)

        request = http.Request('GET', 'funnels/', params)

        return request, parsers.parse_json

    @base.apimethod
    def list(self):
        """
        Fetch the list of all funnels.
        """
        request = http.Request('GET', 'funnels/list/')

        return request, parsers.parse_json


class Segmentation(base.Resource):

    @base.apimethod
    def get(self, event, from_date, to_date, on=None, unit=None, where=None,
            limit=None, type=None):
        """
        Fetch segmented and filtered data for an event.
        """
        params = base.get_params(('event', 'from_date', 'to_date', 'on',
                                 'unit', 'where', 'limit', 'type'),
                                 locals(), serialize_param)

        request = http.Request('GET', 'segmentation/', params)

        return request, parsers.parse_json

    @base.apimethod
    def numeric(self, event, from_date, to_date, on, buckets, unit=None,
                where=None, type=None):
        """
        Fetch segmented and filtered data for an event, sorted into numeric
        buckets.
        """
        params = base.get_params(('event', 'from_date', 'to_date', 'on',
                                 'buckets', 'unit', 'where', 'type'),
                                 locals(), serialize_param)

        request = http.Request('GET', 'segmentation/numeric/', params)

        return request, parsers.parse_json

    @base.apimethod
    def sum(self, event, from_date, to_date, on, unit=None, where=None):
        """
        Fetch the sum of an expression for an event per time unit.
        """
        params = base.get_params(('event', 'from_date', 'to_date', 'on',
                                  'unit', 'where'), locals(), serialize_param)

        request = http.Request('GET', 'segmentation/sum/', params)

        return request, parsers.parse_json

    @base.apimethod
    def average(self, event, from_date, to_date, on, unit=None, where=None):
        """
        Fetch the average of an expression for an event per time unit.
        """
        params = base.get_params(('event', 'from_date', 'to_date', 'on',
                                  'unit', 'where'), locals(), serialize_param)

        request = http.Request('GET', 'segmentation/average/', params)

        return request, parsers.parse_json

    @base.apimethod
    def multiseg(self, event, type, from_date, to_date, inner, outer, limit=None, unit=None):
        """
        Fetch the average of an expression for an event per time unit.
        """
        params = base.get_params(('event', 'type', 'from_date', 'to_date', 'inner', 'outer',
                                  'limit', 'unit'), locals(), serialize_param)

        request = http.Request('GET', 'segmentation/multiseg/', params)

        return request, parsers.parse_json


class Retention(base.Resource):

    @base.apimethod
    def get(self, from_date, to_date, retention_type=None, born_event=None,
            event=None, born_Where=None, where=None, interval=None,
            interval_count=None, unit=None, on=None, limit=None):
        """
        Fetch cohort analysis.
        """
        params = base.get_params(('from_date', 'to_date', 'retention_type',
                                  'born_event', 'event', 'born_where', 'where',
                                  'interval', 'interval_count', 'unit',
                                  'on', 'limit'), locals(), serialize_param)

        request = http.Request('GET', 'retention/', params)

        return request, parsers.parse_json

########NEW FILE########
__FILENAME__ = service
import base64
import calendar
import hashlib
import json
import time

from libsaas import http, port
from libsaas.services import base

from . import resources


class InsufficientSettings(Exception):
    """
    The settings of the service are not sufficient to make the request.
    """


class Mixpanel(base.Resource):
    """
    """
    USE_EXPIRE = True
    LITERAL_PROPERTY_TYPES = port.numeric_types + (list, bool)


    def __init__(self, token=None, api_key=None, api_secret=None):
        """
        Create a Mixpanel service.

        :var token: Optional token used for tracking events. If you leave this
            as None, you won't be able to track events through this service
            object.
        :vartype token: str or None

        :var api_key: Optional API key. If you leave this as None, you won't be
            able to export data through this service object.
        :vartype api_key: str or None

        :var api_secret: Optional API secret. If you leave this as None, you
            won't be able to export data through this service object.
        :vartype api_secret: str or None
        """
        self.token = token
        self.api_key = api_key
        self.api_secret = api_secret

        self.add_filter(self.sign_request)
        self.add_filter(self.update_uri)

    def sign_request(self, request):
        if getattr(request, 'nosign', False):
            return

        if not self.api_key or not self.api_secret:
            raise InsufficientSettings('api_key and api_secret are required '
                                       'for this method')

        request.params['api_key'] = self.api_key

        if self.USE_EXPIRE:
            request.params['expire'] = calendar.timegm(time.gmtime()) + 600

        to_hash = ''.join('{0}={1}'.format(key, port.to_u(request.params[key]))
                          for key in sorted(request.params.keys()))

        md5 = hashlib.md5()
        md5.update(port.to_b(to_hash))
        md5.update(port.to_b(self.api_secret))

        request.params['sig'] = md5.hexdigest()

    def update_uri(self, request):
        if request.uri.startswith('http'):
            return

        request.uri = 'http://mixpanel.com/api/2.0/' + request.uri

    def serialize_property(self, value):
        """
        Serialize a Mixpanel property value. According to
        https://mixpanel.com/docs/properties-or-segments/property-data-types
        the allowed types are string, numeric, boolean, date (represented as a
        string) and list.
        """
        if isinstance(value, self.LITERAL_PROPERTY_TYPES):
            return value

        return port.to_u(value)

    @base.apimethod
    def track(self, event, properties=None, ip=False, test=False):
        """
        Track an event.

        Upstream documentation: {0}

        :var event: The name of the event.
        :vartype event: str

        :var properties: The event's properties, your access token will be
            inserted into it automatically.
        :vartype properties: dict

        :var ip: Should Mixpanel automatically use the incoming request IP.
        :vartype ip: bool

        :var test: Use a high priority rate limited queue for testing.
        :vartype test: bool

        :return: A boolean that tells if the event has been logged.
        """
        if not self.token:
            raise InsufficientSettings('token is required for this method')

        if properties is None:
            properties = {}
        properties['token'] = self.token

        properties = dict((port.to_u(key), self.serialize_property(value)) for
                          key, value in properties.items())

        params = base.get_params(('ip', 'test'), locals(),
                                 resources.serialize_param)

        data = {'event': port.to_u(event), 'properties': properties}
        params['data'] = base64.b64encode(port.to_b(json.dumps(data)))

        request = http.Request('GET', 'http://api.mixpanel.com/track/', params)
        request.nosign = True

        return request, resources.parse_boolean

    track.__doc__ = track.__doc__.format(
        'https://mixpanel.com/docs/api-documentation/'
        'http-specification-insert-data')
    
    @base.apimethod
    def engage(self, distinct_id, data):
        """
        Store people properties

        Upstream documentation: {0}

        :var properties: The user properties, your access token will be
            inserted into it automatically.
        :vartype properties: dict

        :return: A boolean that tells if the event has been logged.
        """
        if not self.token:
            raise InsufficientSettings('token is required for this method')

        data['$token'] = self.token
        data['$distinct_id'] = distinct_id
        
        params = {'data': base64.b64encode(port.to_b(json.dumps(data)))}

        request = http.Request('GET', 'http://api.mixpanel.com/engage/', params)
        request.nosign = True

        return request, resources.parse_boolean

    engage.__doc__ = engage.__doc__.format(
        'https://mixpanel.com/docs/people-analytics/'
        'people-http-specification-insert-data')
    
    @base.apimethod
    def export(self, from_date, to_date, event=None, where=None, bucket=None):
        """
        Export raw data from your account.

        Upstream documentation: {0}

        :var from_date: Query start date, in yyyy-mm-dd format.
        :vartype from_date: str

        :var to_date: Query finish date, in yyyy-mm-dd format.
        :vartype to_date: str

        :var event: Optional list of events to export.
        :vartype event: list of str

        :var where: A filter expression.
        :vartype where: str

        :var bucket: Data bucket to query.
        :vartype bucket: str
        """
        params = base.get_params(('from_date', 'to_date',
                                  'event', 'where', 'bucket'),
                                 locals(), resources.serialize_param)

        uri = 'http://data.mixpanel.com/api/2.0/export/'
        request = http.Request('GET', uri, params)

        return request, resources.parse_export

    export.__doc__ = export.__doc__.format(
        'https://mixpanel.com/docs/api-documentation/'
        'exporting-raw-data-you-inserted-into-mixpanel#export')

    @base.resource(resources.Events)
    def events(self):
        """
        Return the resource corresponding to events.
        """
        return resources.Events(self)

    @base.resource(resources.Properties)
    def properties(self):
        """
        Return the resource corresponding to events properties.
        """
        return resources.Properties(self)

    @base.resource(resources.Funnels)
    def funnels(self):
        """
        Return the resource corresponding to funnels.
        """
        return resources.Funnels(self)

    @base.resource(resources.Segmentation)
    def segmentation(self):
        """
        Return the resource corresponding to segmentation.
        """
        return resources.Segmentation(self)

    @base.resource(resources.Retention)
    def retention(self):
        """
        Return the resource corresponding to retention (cohort analysis).
        """
        return resources.Retention(self)


def add_docstrings():
    # the upstream URLs follow a fixed pattern, so add them programatically

    def extra_doc(resource_name, method_name):
        base = 'https://mixpanel.com/docs/api-documentation/data-export-api'
        method_name = 'default' if method_name == 'get' else method_name
        doc_name = ('event-properties' if resource_name == 'properties'
                    else resource_name)

        tmpl = '\nUpstream documentation: {0}#{1}-{2}'
        return tmpl.format(base, doc_name, method_name)

    # walk the list of resources
    for resource_name in Mixpanel.list_resources():
        # get the resource class
        resource = getattr(Mixpanel, resource_name).produces[0]
        # walks its list of methods
        for method_name in resource.list_methods():
            # update the method's docstring
            function = port.method_func(resource, method_name)
            extra = extra_doc(resource_name, method_name)
            function.__doc__ += extra


add_docstrings()

########NEW FILE########
__FILENAME__ = ads
from libsaas import http, parsers
from libsaas.services import base


class TextAd(base.HierarchicalResource):

    path = 'gdn/textads'

    @base.apimethod
    def publishers(self, offset=None, page_size=None, min_times_seen=None,
                   max_times_seen=None, first_seen_before=None,
                   first_seen_after=None, last_seen_before=None,
                   last_seen_after=None, sort_field=None, sort_order=None):
        """
        Fetch the Google Display Network publishers for this ad.

        Upstream documentation: http://mixrank.com/api/documentation#textad_publishers
        """
        params = base.get_params(None, locals())
        url = self.get_url() + '/publishers'
        request = http.Request('GET', url, params)

        return request, parsers.parse_json

    @base.apimethod
    def destinations(self, offset=None, page_size=None, min_avg_position=None,
                     max_avg_position=None, min_times_seen=None,
                     max_times_seen=None, first_seen_before=None,
                     first_seen_after=None, last_seen_before=None,
                     last_seen_after=None, sort_field=None, sort_order=None):
        """
        Fetch the Google Display Network destinations for this ad.

        Upstream documentation: http://mixrank.com/api/documentation#textad_destinations
        """
        params = base.get_params(None, locals())
        url = self.get_url() + '/destinations'
        request = http.Request('GET', url, params)

        return request, parsers.parse_json


class DisplayAd(base.HierarchicalResource):

    path = 'gdn/displayads'

    @base.apimethod
    def publishers(self, offset=None, page_size=None, min_times_seen=None,
                   max_times_seen=None, first_seen_before=None,
                   first_seen_after=None, last_seen_before=None,
                   last_seen_after=None, sort_field=None, sort_order=None):
        """
        Fetch the Google Display Network publishers for this ad.

        Upstream documentation: http://mixrank.com/api/documentation#displayad_publishers
        """
        params = base.get_params(None, locals())
        url = self.get_url() + '/publishers'
        request = http.Request('GET', url, params)

        return request, parsers.parse_json

    @base.apimethod
    def destinations(self, offset=None, page_size=None, min_times_seen=None,
                     max_times_seen=None, first_seen_before=None,
                     first_seen_after=None, last_seen_before=None,
                     last_seen_after=None, sort_field=None, sort_order=None):
        """
        Fetch the Google Display Network destinations for this ad.

        Upstream documentation: http://mixrank.com/api/documentation#displayad_destinations
        """
        params = base.get_params(None, locals())
        url = self.get_url() + '/destinations'
        request = http.Request('GET', url, params)

        return request, parsers.parse_json

########NEW FILE########
__FILENAME__ = advertisers
from libsaas import http, parsers
from libsaas.services import base

from . import ads


class Advertiser(base.HierarchicalResource):

    path = 'advertisers'

    @base.resource(ads.TextAd)
    def textad(self, hash):
        """
        Return a resource corresponding to a single text ad.

        :var hash: A unique hash identifying this ad.
        :vartype hash: str
        """
        return ads.TextAd(self, hash)

    @base.resource(ads.DisplayAd)
    def displayad(self, hash):
        """
        Return a resource corresponding to a single display ad.

        :var hash: A unique hash identifying this ad.
        :vartype hash: str
        """
        return ads.DisplayAd(self, hash)

    @base.apimethod
    def summary(self):
        """
        Fetch the advertiser's summary.

        Upstream documentation: http://mixrank.com/api/documentation#advertiser
        """
        request = http.Request('GET', self.get_url())

        return request, parsers.parse_json

    @base.apimethod
    def textads(self, offset=None, page_size=None, min_avg_position=None,
                max_avg_position=None, min_times_seen=None,
                max_times_seen=None, first_seen_before=None,
                first_seen_after=None, last_seen_before=None,
                last_seen_after=None, sort_field=None, sort_order=None):
        """
        Fetch the Google Display Network text ads for this advertiser.

        Upstream documentation: http://mixrank.com/api/documentation#advertiser_textads
        """
        params = base.get_params(None, locals())
        url = self.get_url() + '/gdn/textads'
        request = http.Request('GET', url, params)

        return request, parsers.parse_json

    @base.apimethod
    def displayads(self, offset=None, page_size=None, min_times_seen=None,
                   max_times_seen=None, first_seen_before=None,
                   first_seen_after=None, last_seen_before=None,
                   last_seen_after=None, sort_field=None, sort_order=None):
        """
        Fetch the Google Display Network display ads for this advertiser.

        Upstream documentation: http://mixrank.com/api/documentation#advertiser_displayads
        """
        params = base.get_params(None, locals())
        url = self.get_url() + '/gdn/displayads'
        request = http.Request('GET', url, params)

        return request, parsers.parse_json

    @base.apimethod
    def publishers(self, offset=None, page_size=None, min_times_seen=None,
                   max_times_seen=None, min_monthly_uniques=None,
                   max_monthly_uniques=None, last_seen_before=None,
                   last_seen_after=None, sort_field=None, sort_order=None):
        """
        Fetch the Google Display Network publishers for this advertiser.

        Upstream documentation: http://mixrank.com/api/documentation#advertiser_publishers
        """
        params = base.get_params(None, locals())
        url = self.get_url() + '/gdn/publishers'
        request = http.Request('GET', url, params)

        return request, parsers.parse_json

    @base.apimethod
    def keywords(self, offset=None, page_size=None, min_times_seen=None,
                 max_times_seen=None, first_seen_before=None,
                 first_seen_after=None, last_seen_before=None,
                 last_seen_after=None, sort_field=None, sort_order=None):
        """
        Fetch the Google Display Network keywords for this advertiser.

        Upstream documentation: http://mixrank.com/api/documentation#advertiser_keywords
        """
        params = base.get_params(None, locals())
        url = self.get_url() + '/gdn/keywords'
        request = http.Request('GET', url, params)

        return request, parsers.parse_json

########NEW FILE########
__FILENAME__ = keywords
from libsaas import http, parsers
from libsaas.services import base


class Keyword(base.HierarchicalResource):

    path = 'keywords'

    @base.apimethod
    def summary(self):
        """
        Fetch the keyword summary.

        Upstream documentation: http://mixrank.com/api/documentation#keyword
        """
        request = http.Request('GET', self.get_url())

        return request, parsers.parse_json

    @base.apimethod
    def advertisers(self, offset=None, page_size=None, min_times_seen=None,
                    max_times_seen=None, first_seen_before=None,
                    first_seen_after=None, last_seen_before=None,
                    last_seen_after=None, sort_field=None, sort_order=None):
        """
        Fetch the advertisers that show ads for this keyword.

        Upstream documentation: http://mixrank.com/api/documentation#keyword_advertisers
        """
        params = base.get_params(None, locals())
        url = self.get_url() + '/gdn/advertisers'
        request = http.Request('GET', url, params)

        return request, parsers.parse_json

    @base.apimethod
    def textads(self, offset=None, page_size=None, min_avg_position=None,
                max_avg_position=None, min_times_seen=None,
                max_times_seen=None, first_seen_before=None,
                first_seen_after=None, last_seen_before=None,
                last_seen_after=None, sort_field=None, sort_order=None):
        """
        Fetch the Google Display Network text ads targeting this keyword.

        Upstream documentation: http://mixrank.com/api/documentation#keyword_textads
        """
        params = base.get_params(None, locals())
        url = self.get_url() + '/gdn/textads'
        request = http.Request('GET', url, params)

        return request, parsers.parse_json

    @base.apimethod
    def displayads(self, offset=None, page_size=None, min_times_seen=None,
                   max_times_seen=None, first_seen_before=None,
                   first_seen_after=None, last_seen_before=None,
                   last_seen_after=None, sort_field=None, sort_order=None):
        """
        Fetch the Google Display Network display ads targeting at this keyword.

        Upstream documentation: http://mixrank.com/api/documentation#keyword_displayads
        """
        params = base.get_params(None, locals())
        url = self.get_url() + '/gdn/displayads'
        request = http.Request('GET', url, params)

        return request, parsers.parse_json

########NEW FILE########
__FILENAME__ = publishers
from libsaas import http, parsers
from libsaas.services import base


class Publisher(base.HierarchicalResource):

    path = 'publishers'

    @base.apimethod
    def summary(self):
        """
        Fetch the publisher's summary.

        Upstream documentation: http://mixrank.com/api/documentation#publisher
        """
        request = http.Request('GET', self.get_url())

        return request, parsers.parse_json

    @base.apimethod
    def advertisers(self, offset=None, page_size=None, min_times_seen=None,
                    max_times_seen=None, first_seen_before=None,
                    first_seen_after=None, last_seen_before=None,
                    last_seen_after=None, sort_field=None, sort_order=None):
        """
        Fetch the advertisers that run ads on this publisher.

        Upstream documentation: http://mixrank.com/api/documentation#publisher_advertisers
        """
        params = base.get_params(None, locals())
        url = self.get_url() + '/gdn/advertisers'
        request = http.Request('GET', url, params)

        return request, parsers.parse_json

    @base.apimethod
    def textads(self, offset=None, page_size=None, min_avg_position=None,
                max_avg_position=None, min_times_seen=None,
                max_times_seen=None, first_seen_before=None,
                first_seen_after=None, last_seen_before=None,
                last_seen_after=None, sort_field=None, sort_order=None):
        """
        Fetch the Google Display Network text ads for this publisher.

        Upstream documentation: http://mixrank.com/api/documentation#advertiser_textads
        """
        params = base.get_params(None, locals())
        url = self.get_url() + '/gdn/textads'
        request = http.Request('GET', url, params)

        return request, parsers.parse_json

    @base.apimethod
    def displayads(self, offset=None, page_size=None, min_times_seen=None,
                   max_times_seen=None, first_seen_before=None,
                   first_seen_after=None, last_seen_before=None,
                   last_seen_after=None, sort_field=None, sort_order=None):
        """
        Fetch the Google Display Network display ads for this publisher.

        Upstream documentation: http://mixrank.com/api/documentation#publisher_displayads
        """
        params = base.get_params(None, locals())
        url = self.get_url() + '/gdn/displayads'
        request = http.Request('GET', url, params)

        return request, parsers.parse_json

########NEW FILE########
__FILENAME__ = service
from libsaas import http, parsers, port
from libsaas.services import base

from . import advertisers
from . import publishers
from . import keywords


class MixRank(base.Resource):
    """
    """
    def __init__(self, api_key):
        """
        Create a MixRank service.

        :var api_key: The MixRank API key.
        :vartype api_key: str
        """
        self.apiroot = 'http://api.mixrank.com/v2/json/' + port.to_u(api_key)

    def get_url(self):
        return self.apiroot

    @base.resource(advertisers.Advertiser)
    def advertiser(self, advertiser):
        """
        Return the resource corresponding to an advertiser.

        :var advertiser: The advertiser's domain name. Use the root domain
          name; in particular, do not prefix with "www." or any other
          subdomain.
        :vartype advertiser: str
        """
        return advertisers.Advertiser(self, advertiser)

    @base.resource(publishers.Publisher)
    def publisher(self, publisher):
        """
        Return the resource corresponding to a publisher.

        :var publisher: The pubisher's domain name. Use the root domain
          name; in particular, do not prefix with "www." or any other
          subdomain.
        :vartype publisher: str
        """
        return publishers.Publisher(self, publisher)

    @base.resource(keywords.Keyword)
    def keyword(self, keyword):
        """
        Return the resource corresponding to a keyword.

        :var keyword: The keyword, can contain spaces.
        :vartype keyword: str
        """
        return keywords.Keyword(self, keyword)

    @base.apimethod
    def echo(self):
        """
        Verify that the API key is valid.
        """
        request = http.Request('GET', self.get_url() + '/echo')

        return request, parsers.parse_json

########NEW FILE########
__FILENAME__ = constants
"""
Metric values for the Cols parameter in Mozscape calls.

http://apiwiki.moz.com/url-metrics#cols
"""

TITLE = 1
CANONICAL_URL = 4
SUBDOMAIN = 8
ROOT_DOMAIN = 16
EXTERNAL_LINKS = 32
SUBDOMAIN_EXTERNAL_LINKS = 64
ROOT_DOMAIN_EXTERNAL_LINKS = 128
EQUITY_LINKS = 256
SUBDOMAINS_LINKING = 512
ROOT_DOMAINS_LINKING = 1024
LINKS = 2048
SUBDOMAIN_SUBDOMAINS_LINKING = 4096
ROOT_DOMAIN_ROOT_DOMAINS_LINKING = 8192
MOZRANK = 16384
SUBDOMAIN_MOZRANK = 32768
ROOT_DOMAIN_MOZRANK = 65536
MOZTRUST = 131072
SUBDOMAIN_MOZTRUST = 262144
ROOT_DOMAIN_MOZTRUST = 524288
EXTERNAL_MOZRANK = 1048576
SUBDOMAIN_EXTERNAL_LINK_EQUITY = 2097152
ROOT_DOMAIN_EXTERNAL_LINK_EQUITY = 4194304
SUBDOMAIN_LINK_EQUITY = 8388608
ROOT_DOMAIN_LINK_EQUITY = 16777216
HTTP_STATUS_CODE = 536870912
LINKS_TO_SUBDOMAIN = 4294967296
LINKS_TO_ROOT_DOMAIN = 8589934592
ROOT_DOMAINS_LINKING_TO_SUBDOMAIN = 17179869184
PAGE_AUTHORITY = 34359738368
DOMAIN_AUTHORITY = 68719476736

########NEW FILE########
__FILENAME__ = resources
from libsaas import parsers, http
from libsaas.services import base


class Metadata(base.Resource):

    @base.apimethod
    def last_update(self):
        """
        Fetch the Unix timestamp of the last Mozscape Index update.
        """
        request = http.Request('GET', '/metadata/last_update.json')
        return request, parsers.parse_json

    @base.apimethod
    def next_update(self):
        """
        Fetch the Unix timestamp of the next Mozscape Index update.
        """
        request = http.Request('GET', '/metadata/next_update.json')
        return request, parsers.parse_json

    @base.apimethod
    def index_stats(self):
        """
        Fetch data about the volume of information in the Mozscape Index.
        """
        request = http.Request('GET', '/metadata/index_stats')
        return request, parsers.parse_json

########NEW FILE########
__FILENAME__ = service
import base64
import calendar
import hashlib
import hmac
import json
import time

from libsaas import parsers, http, port
from libsaas.services import base

from . import resources


class Mozscape(base.Resource):

    EXPIRES = 300
    timesource = time.gmtime

    def __init__(self, access_id, secret_key):
        """
        Create a Mozscape service.

        :var access_id: Your Mozscape AccessID.
        :vartype access_id: str

        :var secret_key: Your Mozscape Secret Key.
        :vartype secret_key: str
        """
        self.apiroot = 'https://lsapi.seomoz.com/linkscape'

        self.access_id = access_id
        self.secret_key = secret_key

        self.add_filter(self.add_api_root)
        self.add_filter(self.sign_request)

    def add_api_root(self, request):
        request.uri = self.apiroot + request.uri

    def sign_request(self, request):
        if getattr(request, 'nosign', False):
            return

        expires = str(calendar.timegm(self.timesource()) + self.EXPIRES)
        to_sign = port.to_b(self.access_id + '\n' + expires)
        signature = hmac.new(port.to_b(self.secret_key), to_sign, hashlib.sha1).digest()

        request.params['AccessID'] = self.access_id
        request.params['Expires'] = expires
        request.params['Signature'] = port.to_u(base64.b64encode(signature))

    @base.apimethod
    def urlmetrics(self, urls, cols):
        """
        Fetch URL metrics for one or more URLs.

        :var urls: The URLs you're interested in.
        :vartype urls: str or list of str

        :var cols: The sum of column constants for metrics you want to have
            fetched, taken from `libsaas.services.mozscape.constants`.
        """
        if isinstance(urls, list):
            return self.list_urlmetrics(urls, str(cols))

        uri = '/url-metrics/{0}/'.format(http.quote_any(urls))
        request = http.Request('GET', uri, {'Cols': str(cols)})

        return request, parsers.parse_json

    def list_urlmetrics(self, urls, cols):
        # For url-metrics the URLs are passed as POST body, but the remaining
        # parameters should still be in the URL. Work around this by manually
        # generating the signature and then replacing the body.
        request = http.Request('POST', '')
        self.sign_request(request)
        request.nosign = True

        request.params['Cols'] = cols
        uri = '/url-metrics/?' + http.urlencode_any(request.params)
        request.uri = uri
        request.params = json.dumps(urls)

        return request, parsers.parse_json

    @base.resource(resources.Metadata)
    def metadata(self):
        """
        Return the resource responsible for Mozscape Index metadata.
        """
        return resources.Metadata(self)

########NEW FILE########
__FILENAME__ = service
import json

from libsaas import http, parsers
from libsaas.services import base


class Insights(base.Resource):
    """
    """
    version = 'beta_api'

    def __init__(self, account_id, query_key=None, insert_key=None):
        """
        Create a New Relic Insights service.

        :var account_id: The account id
        :vartype account_id: str

        :var query_key: The query key.
        :vartype query_key: str

        :var insert_key: The insert key.
        :vartype insert_key: str
        """
        tmpl = 'https://insights.newrelic.com/{0}/accounts/{1}'
        self.apiroot = tmpl.format(self.version, account_id)

        self.query_key = query_key
        self.insert_key = insert_key

        self.add_filter(self.add_authorization)
        self.add_filter(self.use_json)

    def use_json(self, request):
        request.headers['Content-Type'] = 'application/json'
        request.headers['Accept'] = 'application/json'

        if request.method.upper() not in http.URLENCODE_METHODS:
            request.params = json.dumps(request.params)

    def add_authorization(self, request):
        if request.method.upper() == 'POST':
            request.headers['X-Insert-Key'] = self.insert_key
        else:
            request.headers['X-Query-Key'] = self.query_key

    def get_url(self):
        return self.apiroot

    @base.apimethod
    def query(self, nrql):
        """
        NRQL query

        :var nqrl: The nrql query
        :vartype nqrl: str

        Upstream documentation: http://docs.newrelic.com/docs/rubicon/using-nrql
        """
        params = base.get_params(None, locals())
        url = '{0}/{1}'.format(self.get_url(), 'query')

        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def insert(self, events):
        """
        Submit event or events to rubicon

        :var events: Event data
        :vartype event: dict

        Upstream documentation: http://docs.newrelic.com/docs/rubicon/inserting-events
        """
        url = '{0}/{1}'.format(self.get_url(), 'events')

        return http.Request('POST', url, events), parsers.parse_json

########NEW FILE########
__FILENAME__ = actions
from libsaas import http, parsers
from libsaas.services import base
from . import resource


class Actions(resource.PingdomGETResource):

    path = 'actions'

    @base.apimethod
    def get(self, from_=None, to=None, limit=None, offset=None, checkids=None,
            contactids=None, status=None, via=None):
        """
        Returns a list of actions (alerts) that have been generated for
        your account.

        Upstream documentation: {0}
        """

        params = base.get_params(None, locals(),
                                 translate_param=resource.translate_param)

        return http.Request('GET', self.get_url(), params), parsers.parse_json

    get.__doc__ = get.__doc__.format(
        'https://www.pingdom.com/services/api-documentation-rest/'
        '#ResourceActions')

########NEW FILE########
__FILENAME__ = analysis
from libsaas import http, parsers, port
from libsaas.services import base
from . import resource


class Analysis(resource.PingdomGETResource):

    path = 'analysis'

    @base.apimethod
    def get(self, from_=None, to=None, limit=None, offset=None):
        params = base.get_params(None, locals(),
                                 translate_param=resource.translate_param)

        return http.Request('GET', self.get_url(), params), parsers.parse_json

    @base.apimethod
    def get_raw_analysis(self, analysisid):
        """
        Get Raw Analysis Results

        :var analysisid: The specified error analysis id
        :vartype analysisid: str
        """
        url = '{0}/{1}'.format(self.get_url(), analysisid)

        request = http.Request('GET', url)
        return request, parsers.parse_json


port.method_func(Analysis, 'get').__doc__ = """
Returns a list of the latest root cause analysis results for a specified check.

Upstream documentation: {0}
""".format('https://www.pingdom.com/services/api-documentation-rest/'
           '#ResourceAnalysis')

########NEW FILE########
__FILENAME__ = checks
from libsaas import http, parsers, port
from libsaas.services import base
from . import analysis, results, summary


class ChecksBase(base.RESTResource):

    path = 'checks'


class Checks(ChecksBase):

    def require_item(self):
        pass

    @base.apimethod
    def get(self, limit=None, offset=None):
        """
        Returns a list overview of all checks.

        Upstream documentation: {0}
        """

        params = base.get_params(None, locals())

        return http.Request('GET', self.get_url(), params), parsers.parse_json

    get.__doc__ = get.__doc__.format(
        'https://www.pingdom.com/services/api-documentation-rest/'
        '#ResourceChecks')

    # redefine methods to set docstring later

    @base.mark_apimethod
    def create(self, obj):
        return super(Checks, self).create(obj)

    @base.mark_apimethod
    def update(self, obj):
        return super(Checks, self).update(obj)

    @base.mark_apimethod
    def delete(self):
        return super(Checks, self).delete()


port.method_func(Checks, 'create').__doc__ = """
Creates a new check with settings specified by provided parameters.

Upstream documentation: {0}
""".format('https://www.pingdom.com/services/api-documentation-rest/'
           '#MethodCreate+New+Check')


port.method_func(Checks, 'update').__doc__ = """
Pause or change resolution for multiple checks in one bulk call.

Upstream documentation: {0}
""".format('https://www.pingdom.com/services/api-documentation-rest/'
           '#MethodModify+Multiple+Checks')

port.method_func(Checks, 'delete').__doc__ = """
Deletes a list of checks. You will lose all collected data.

Upstream documentation: {0}
""".format('https://www.pingdom.com/services/api-documentation-rest/'
           '#MethodDelete+Multiple+Checks')


class Check(ChecksBase):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.resource(analysis.Analysis)
    def analysis(self):
        """
        Return the resource corresponding to the analysis for the check.
        """
        return analysis.Analysis(self.parent, self.object_id)

    @base.resource(results.Results)
    def results(self):
        """
        Return the resource corresponding to the results for the check.
        """
        return results.Results(self.parent, self.object_id)

    @base.resource(summary.Summary)
    def summary(self):
        """
        Return the resource corresponding to the summary for the check.
        """
        return summary.Summary(self.parent, self.object_id)

    # redefine methods to set docstring later

    @base.mark_apimethod
    def get(self):
        return super(Check, self).get()

    @base.mark_apimethod
    def update(self, obj):
        return super(Check, self).update(obj)

    @base.mark_apimethod
    def delete(self):
        return super(Check, self).delete()


port.method_func(Check, 'get').__doc__ = """
Returns a detailed description of a specified check.

Upstream documentation: {0}
""".format('https://www.pingdom.com/services/api-documentation-rest/'
           '#MethodGet+Detailed+Check+Information')

port.method_func(Check, 'update').__doc__ = """
Modify settings for a check. The provided settings will overwrite previous
values. Settings not provided will stay the same as before the update. To
clear an existing value, provide an empty value. Please note that you cannot
change the type of a check once it has been created.

Upstream documentation: {0}
""".format('https://www.pingdom.com/services/api-documentation-rest/'
           'MethodModify+Check')

port.method_func(Check, 'delete').__doc__ = """
Deletes a check. You will lose all collected data.

Upstream documentation: {0}
""".format('https://www.pingdom.com/services/api-documentation-rest/'
           '#MethodDelete+Check')

########NEW FILE########
__FILENAME__ = contacts
from libsaas import http, parsers, port
from libsaas.services import base


class ContactsBase(base.RESTResource):

    path = 'contacts'


class Contacts(ContactsBase):

    def require_item(self):
        pass

    @base.apimethod
    def get(self, limit=None, offset=None):
        """
        Returns a list of all contacts.

        Upstream documentation: {0}
        """

        params = base.get_params(None, locals())

        return http.Request('GET', self.get_url(), params), parsers.parse_json

    get.__doc__ = get.__doc__.format(
        'https://www.pingdom.com/services/api-documentation-rest/'
        '#ResourceContacts')

    # redefine methods to set docstring later

    @base.mark_apimethod
    def create(self, obj):
        return super(Contacts, self).create(obj)

    @base.mark_apimethod
    def update(self, obj):
        return super(Contacts, self).update(obj)

    @base.mark_apimethod
    def delete(self):
        return super(Contacts, self).delete()


port.method_func(Contacts, 'create').__doc__ = """
Creates a new contact with settings specified by provided parameters.

Upstream documentation: {0}
""".format('https://www.pingdom.com/services/api-documentation-rest/'
           '#MethodCreate+Contact')

port.method_func(Contacts, 'update').__doc__ = """
Modifies a list of contacts.

Upstream documentation: {0}
""".format('https://www.pingdom.com/services/api-documentation-rest/'
           '#MethodModify+Multiple+Contacts')

port.method_func(Contacts, 'delete').__doc__ = """
Deletes a list of contacts.

Upstream documentation: {0}
""".format('https://www.pingdom.com/services/api-documentation-rest/'
           '#MethodDelete+Multiple+Contacts')


class Contact(ContactsBase):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def get(self, *args, **kwargs):
        raise base.MethodNotSupported()

    # redefine methods to set docstring later

    @base.mark_apimethod
    def update(self, obj):
        return super(Contact, self).update(obj)

    @base.mark_apimethod
    def delete(self):
        return super(Contact, self).delete()


port.method_func(Contact, 'update').__doc__ = """
Modify a contact.

Upstream documentation: {0}
""".format('https://www.pingdom.com/services/api-documentation-rest/'
           'MethodModify+Contact')

port.method_func(Contact, 'delete').__doc__ = """
Deletes a contact.

Upstream documentation: {0}
""".format('https://www.pingdom.com/services/api-documentation-rest/'
           '#MethodDelete+Contact')

########NEW FILE########
__FILENAME__ = credit
from libsaas import port
from libsaas.services import base
from . import resource


class Credits(resource.PingdomGETResource):

    path = 'credits'

    # redefine methods to set docstring later

    @base.mark_apimethod
    def get(self):
        return super(Credits, self).get()


port.method_func(Credits, 'get').__doc__ = """
Returns information about remaining checks, SMS credits and
SMS auto-refill status.

Upstream documentation: {0}
""".format('https://www.pingdom.com/services/api-documentation-rest/'
           '#ResourceCredits')

########NEW FILE########
__FILENAME__ = probes
from libsaas import http, parsers, port
from libsaas.services import base
from . import resource


class Probes(resource.PingdomGETResource):

    path = 'probes'

    @base.apimethod
    def get(self, limit=None, offset=None, onlyactive=None,
            includedeleted=None):
        params = base.get_params(None, locals(),
                                 translate_param=resource.translate_param)

        return http.Request('GET', self.get_url(), params), parsers.parse_json


port.method_func(Probes, 'get').__doc__ = """
Returns a list of all Pingdom probe servers.

Upstream documentation: {0}
""".format('https://www.pingdom.com/services/api-documentation-rest/'
           '#ResourceProbes')

########NEW FILE########
__FILENAME__ = reference
from libsaas import port
from libsaas.services import base
from . import resource


class Reference(resource.PingdomGETResource):

    path = 'reference'

    # redefine methods to set docstring later

    @base.mark_apimethod
    def get(self):
        return super(Reference, self).get()


port.method_func(Reference, 'get').__doc__ = """
Get a reference of regions, timezones and date/time/number formats
and their identifiers.

Upstream documentation: {0}
""".format('https://www.pingdom.com/services/api-documentation-rest/'
           '#ResourceReference')

########NEW FILE########
__FILENAME__ = reports
from libsaas import http, parsers
from libsaas.services import base


class ReportsBase(base.RESTResource):

    path = 'reports'
    type = None

    def get_url(self):
        if self.object_id is None:
            return '{0}/{1}.{2}'.format(self.parent.get_url(), self.path,
                                        self.type)

        return '{0}/{1}.{2}/{3}'.format(self.parent.get_url(), self.path,
                                        self.type, self.object_id)

    @base.apimethod
    def get(self):
        self.require_collection()
        request = http.Request('GET', self.get_url())

        return request, parsers.parse_json


class ReportsEmail(ReportsBase):

    type = 'email'


class ReportsPublic(ReportsBase):

    type = 'public'


class ReportsShared(ReportsBase):

    type = 'shared'

########NEW FILE########
__FILENAME__ = resource
from libsaas import http, parsers
from libsaas.services import base


def translate_param(val):
    return val.rstrip('_')


class PingdomGETResource(base.RESTResource):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.apimethod
    def get(self):
        return http.Request('GET', self.get_url()), parsers.parse_json

########NEW FILE########
__FILENAME__ = results
from libsaas import http, parsers, port
from libsaas.services import base
from . import resource


class Results(resource.PingdomGETResource):

    path = 'results'

    @base.apimethod
    def get(self, from_=None, to=None, limit=None, offset=None, probes=None,
            status=None, includeanalysis=None, maxresponse=None,
            minresponse=None):
        params = base.get_params(None, locals(),
                                 translate_param=resource.translate_param)

        return http.Request('GET', self.get_url(), params), parsers.parse_json

port.method_func(Results, 'get').__doc__ = """
Return a list of raw test results for a specified check

Upstream documentation: {0}
""".format('https://www.pingdom.com/services/api-documentation-rest/'
           '#ResourceResults')

########NEW FILE########
__FILENAME__ = servertime
from libsaas import port
from libsaas.services import base
from . import resource


class Servertime(resource.PingdomGETResource):

    path = 'servertime'

    # redefine methods to set docstring later

    @base.mark_apimethod
    def get(self):
        return super(Servertime, self).get()


port.method_func(Servertime, 'get').__doc__ = """
Get the current time of the API server.

Upstream documentation: {0}
""".format('https://www.pingdom.com/services/api-documentation-rest/'
           '#ResourceServertime')

########NEW FILE########
__FILENAME__ = service
from libsaas.filters import auth
from libsaas.services import base

from . import actions, analysis, checks, contacts, credit, probes, reference
from . import reports, results, servertime, settings, summary
from . import single, traceroute


class Pingdom(base.Resource):
    """
    """
    def __init__(self, username, password, app_key):
        """
        Create a Pingdom service.

        :var username: The username for the authenticated user.
        :vartype username: str

        :var password: The password for the authenticated user.
        :vartype password: str

        :var app_key: The app_key for the application.
        :vartype app_key: str
        """
        self.apiroot = 'https://api.pingdom.com/api/2.0'
        self.app_key = app_key

        self.add_filter(auth.BasicAuth(username, password))
        self.add_filter(self.add_app_header)

    def add_app_header(self, request):
        request.headers['App-Key'] = self.app_key

    def get_url(self):
        return self.apiroot

    @base.resource(actions.Actions)
    def actions(self):
        """
        Return the resource corresponding to all actions
        """
        return actions.Actions(self)

    @base.resource(analysis.Analysis)
    def analysis(self, checkid):
        """
        Return the resource corresponding to the analysis for specified check

        :var checkid: The check id
        :vartype checkid: str
        """
        return analysis.Analysis(self, checkid)

    @base.resource(checks.Check)
    def check(self, checkid):
        """
        Return the resource corresponding to a single check

        :var checkid: The check id
        :vartype checkid: str
        """
        return checks.Check(self, checkid)

    @base.resource(checks.Checks)
    def checks(self):
        """
        Return the resource corresponding to all checks
        """
        return checks.Checks(self)

    @base.resource(contacts.Contact)
    def contact(self, contactid):
        """
        Return the resource corresponding to a single contact

        :var contactid: The contact id
        :vartype contactid: str
        """
        return contacts.Contact(self, contactid)

    @base.resource(contacts.Contacts)
    def contacts(self):
        """
        Return the resource corresponding to all contacts
        """
        return contacts.Contacts(self)

    @base.resource(credit.Credits)
    def credits(self):
        """
        Return the resource corresponding to all credits
        """
        return credit.Credits(self)

    @base.resource(probes.Probes)
    def probes(self):
        """
        Return the resource corresponding to all probes
        """
        return probes.Probes(self)

    @base.resource(reference.Reference)
    def reference(self):
        """
        Return the resource corresponding to the reference of regions
        """
        return reference.Reference(self)

    @base.resource(reports.ReportsEmail)
    def reports_email(self):
        """
        Return the resource corresponding to the email reports
        """
        return reports.ReportsEmail(self)

    @base.resource(reports.ReportsEmail)
    def report_email(self, reportid):
        """
        Return the resource corresponding to a single email report

        :var reportid: The report id
        :vartype reportid: str
        """
        return reports.ReportsEmail(self, reportid)

    @base.resource(reports.ReportsPublic)
    def reports_public(self):
        """
        Return the resource corresponding to the public reports
        """
        return reports.ReportsPublic(self)

    @base.resource(reports.ReportsPublic)
    def report_public(self, reportid):
        """
        Return the resource corresponding to a single public report

        :var reportid: The report id
        :vartype reportid: str
        """
        return reports.ReportsPublic(self, reportid)

    @base.resource(reports.ReportsShared)
    def reports_shared(self):
        """
        Return the resource corresponding to the shared reports
        """
        return reports.ReportsShared(self)

    @base.resource(reports.ReportsShared)
    def report_shared(self, reportid):
        """
        Return the resource corresponding to a single shared report

        :var reportid: The report id
        :vartype reportid: str
        """
        return reports.ReportsShared(self, reportid)

    @base.resource(results.Results)
    def results(self, checkid):
        """
        Return the resource corresponding to the raw test results for
        a specified check

        :var checkid: The check id
        :vartype checkid: str
        """
        return results.Results(self, checkid)

    @base.resource(servertime.Servertime)
    def servertime(self):
        """
        Return the resource corresponding to the servertime
        """
        return servertime.Servertime(self)

    @base.resource(settings.Settings)
    def settings(self):
        """
        Return the resource corresponding to the settings
        """
        return settings.Settings(self)

    @base.resource(summary.Summary)
    def summary(self, checkid):
        """
        Return the resource corresponding to the summary for a specified check.

        :var checkid: The check id
        :vartype checkid: str
        """
        return summary.Summary(self, checkid)

    @base.resource(single.Single)
    def single(self):
        """
        Return the resource corresponding to the single test
        """
        return single.Single(self)

    @base.resource(traceroute.Traceroute)
    def traceroute(self):
        """
        Return the resource corresponding to the traceroute test
        """
        return traceroute.Traceroute(self)

########NEW FILE########
__FILENAME__ = settings
from libsaas import port
from libsaas.services import base


class Settings(base.RESTResource):

    path = 'settings'

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def require_item(self):
        pass

    # redefine methods to set docstring later

    @base.mark_apimethod
    def update(self, obj):
        return super(Settings, self).update(obj)


port.method_func(Settings, 'update').__doc__ = """
Modify account-specific settings.

Upstream documentation: {0}
""".format('https://www.pingdom.com/services/api-documentation-rest/'
           '#MethodModify+Account+Settings')

########NEW FILE########
__FILENAME__ = single
from libsaas import http, parsers, port
from libsaas.services import base
from . import resource


class Single(resource.PingdomGETResource):

    path = 'single'

    @base.apimethod
    def get(self, **params):
        params = base.get_params(None, params,
                                 translate_param=resource.translate_param)

        return http.Request('GET', self.get_url(), params), parsers.parse_json


port.method_func(Single, 'get').__doc__ = """
Performs a single test using a specified Pingdom probe against a specified
target. Please note that this method is meant to be used sparingly, not to
set up your own monitoring solution.

Upstream documentation: {0}
""".format('https://www.pingdom.com/services/api-documentation-rest/'
           '#ResourceSingle')

########NEW FILE########
__FILENAME__ = summary
from libsaas import http, parsers, port
from libsaas.services import base
from . import resource


class Summary(base.HierarchicalResource):

    path = 'summary'

    def require_item(self):
        if self.object_id is None:
            raise base.MethodNotSupported()

    def get_url(self, summary):
        self.require_item()
        return '{0}/{1}.{2}/{3}'.format(self.parent.get_url(), self.path,
                                        summary, self.object_id)

    @base.apimethod
    def average(self, from_=None, to=None, probes=None, includeuptime=None,
                bycountry=None, byprobe=None):
        params = base.get_params(None, locals(),
                                 translate_param=resource.translate_param)
        url = self.get_url('average')
        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def hoursofday(self, from_=None, to=None, probes=None, uselocaltime=None):
        params = base.get_params(None, locals(),
                                 translate_param=resource.translate_param)
        url = self.get_url('hoursofday')
        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def outage(self, from_=None, to=None, order=None):
        params = base.get_params(None, locals(),
                                 translate_param=resource.translate_param)
        url = self.get_url('outage')
        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def performance(self, from_=None, to=None, resolution=None,
                    includeuptime=None, probes=None, order=None):
        params = base.get_params(None, locals(),
                                 translate_param=resource.translate_param)
        url = self.get_url('performance')
        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def probes(self, from_=None, to=None):
        params = base.get_params(None, locals(),
                                 translate_param=resource.translate_param)
        url = self.get_url('probes')
        return http.Request('GET', url, params), parsers.parse_json


port.method_func(Summary, 'average').__doc__ = """
Get the average time / uptime value for a specified check and time period.

Upstream documentation: {0}
""".format('https://www.pingdom.com/services/api-documentation-rest/'
           '#ResourceSummary.average')

port.method_func(Summary, 'hoursofday').__doc__ = """
Returns the average response time for each hour of the day (0-23) for a
specific check over a selected time period.
I.e. it shows you what an average day looks like during that time period.

Upstream documentation: {0}
""".format('https://www.pingdom.com/services/api-documentation-rest/'
           '#ResourceSummary.hoursofday')

port.method_func(Summary, 'outage').__doc__ = """
Get a list of status changes for a specified check and time period.
If order is speficied to descending, the list is ordered by newest
first. (Default is ordered by oldest first.)

Upstream documentation: {0}
""".format('https://www.pingdom.com/services/api-documentation-rest/'
           '#ResourceSummary.outage')

port.method_func(Summary, 'performance').__doc__ = """
For a given interval in time, return a list of sub intervals with the
given resolution. Useful for generating graphs. A sub interval may be a
week, a day or an hour depending on the choosen resolution.

Upstream documentation: {0}
""".format('https://www.pingdom.com/services/api-documentation-rest/'
           '#ResourceSummary.performance')

port.method_func(Summary, 'probes').__doc__ = """
Get a list of probes that performed tests for a specified check during a
specified period.

Upstream documentation: {0}
""".format('https://www.pingdom.com/services/api-documentation-rest/'
           '#ResourceSummary.probes')

########NEW FILE########
__FILENAME__ = traceroute
from libsaas import http, parsers, port
from libsaas.services import base
from . import resource


class Traceroute(resource.PingdomGETResource):

    path = 'traceroute'

    @base.apimethod
    def get(self, host=None, probeid=None):
        params = base.get_params(None, locals())

        return http.Request('GET', self.get_url(), params), parsers.parse_json


port.method_func(Traceroute, 'get').__doc__ = """
Perform a traceroute to a specified target from a specified Pingdom probe.

Upstream documentation: {0}
""".format('https://www.pingdom.com/services/api-documentation-rest/'
           '#ResourceTraceroute')

########NEW FILE########
__FILENAME__ = activities
from libsaas import http, parsers
from libsaas.services import base


class ActivitiesResource(base.RESTResource):

    path = 'activities'


class Activities(ActivitiesResource):

    @base.apimethod
    def get(self, user_id=None, start=None, limit=None, start_data=None,
            end_date=None):
        """
        Returns all activities assigned to a particular user

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Activities
        """
        params = base.get_params(None, locals())

        request = http.Request('GET', self.get_url(), params)
        return request, parsers.parse_json

    @base.apimethod
    def delete(self, ids):
        """
        Marks multiple activities as deleted.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Activities
        """
        params = base.get_params(None, locals())

        request = http.Request('DELETE', self.get_url(), params)
        return request, parsers.parse_json


class Activity(ActivitiesResource):
    pass


class ActivityTypesResource(base.RESTResource):

    path = 'activityTypes'


class ActivityTypes(ActivityTypesResource):

    @base.apimethod
    def delete(self, ids):
        """
        Marks multiple activities as deleted.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Activities
        """
        params = base.get_params(None, locals())

        request = http.Request('DELETE', self.get_url(), params)
        return request, parsers.parse_json


class ActivityType(ActivityTypesResource):
    pass

########NEW FILE########
__FILENAME__ = currencies
from libsaas import http, parsers
from libsaas.services import base


class Currencies(base.HierarchicalResource):

    path = 'currencies'

    @base.apimethod
    def get(self, term=None):
        """
        Returns all supported currencies which should be used when saving
        monetary values with other objects. The 'code' parameter of the
        returning objects is the currency code according to ISO 4217.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Currencies
        """
        params = base.get_params(None, locals())

        return http.Request('GET', self.get_url(), params), parsers.parse_json

########NEW FILE########
__FILENAME__ = deals
from libsaas import http, parsers
from libsaas.services import base


class Products(base.RESTResource):

    path = 'products'

    @base.apimethod
    def get(self, start=None, limit=None):
        """
        Lists products attached to a deal.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Deals
        """
        params = base.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

    @base.apimethod
    def delete(self, product_attachment_id):
        """
        Deletes a product attachment from a deal, using the
        product_attachment_id.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Deals
        """
        params = base.get_params(None, locals())
        request = http.Request('DELETE', self.get_url(), params)
        return request, parsers.parse_json


class DealsResource(base.RESTResource):

    path = 'deals'


class Deals(DealsResource):

    @base.apimethod
    def get(self, filter_id=None, start=None, limit=None, sort_by=None,
            sort_mode=None, owned_by_you=None):
        """
        Returns all deals

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Deals
        """
        params = base.get_params(None, locals())

        return http.Request('GET', self.get_url(), params), parsers.parse_json

    @base.apimethod
    def delete(self, ids):
        """
        Marks multiple deals as deleted.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Deals
        """
        params = base.get_params(None, locals())

        request = http.Request('DELETE', self.get_url(), params)
        return request, parsers.parse_json

    @base.apimethod
    def find(self, term):
        """
        Searches all deals by their title.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Deals
        """
        params = base.get_params(None, locals())
        url = '{0}/find'.format(self.get_url())
        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def timeline(self, start_date, interval, amount, field_key, user_id=None,
                 pipeline_id=None, filter_id=None):
        """
        Returns open and won deals, grouped by defined interval of time set
        in a date-type dealField (field_key) - e.g. when month is the chosen
        interval, and 3 months are asked starting from  January 1st, 2012,
        deals are returned grouped into 3 groups - January, February and
        March - based on the value of the given field_key.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Deals
        """
        params = base.get_params(None, locals())
        url = '{0}/timeline'.format(self.get_url())
        return http.Request('GET', url, params), parsers.parse_json


class Deal(DealsResource):

    @base.apimethod
    def activities(self, start=None, limit=None, done=None, exclude=None):
        """
        Lists activities associated with a deal.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Deals
        """
        params = base.get_params(None, locals())
        url = '{0}/activities'.format(self.get_url())
        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def followers(self):
        """
        Lists the followers of a deal.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Deals
        """
        url = '{0}/followers'.format(self.get_url())
        return http.Request('GET', url), parsers.parse_json

    @base.apimethod
    def updates(self, start=None, limit=None):
        """
        Lists updates about a deal.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Deals
        """
        params = base.get_params(None, locals())
        url = '{0}/updates'.format(self.get_url())
        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def participants(self, start=None, limit=None):
        """
        Lists participants associated with a deal.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Deals
        """
        params = base.get_params(None, locals())
        url = '{0}/participants'.format(self.get_url())
        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def files(self, start=None, limit=None):
        """
        Lists files associated with a deal.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Deals
        """
        params = base.get_params(None, locals())
        url = '{0}/files'.format(self.get_url())
        return http.Request('GET', url, params), parsers.parse_json

    @base.resource(Products)
    def products(self):
        """
        Returns the resource corresponding to the deal products
        """
        return Products(self)


class DealFieldsResource(base.RESTResource):

    path = 'dealFields'

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()


class DealFields(DealFieldsResource):

    @base.apimethod
    def delete(self, ids):
        """
        Marks multiple activities as deleted.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-DealFields
        """
        params = base.get_params(None, locals())
        request = http.Request('DELETE', self.get_url(), params)
        return request, parsers.parse_json


class DealField(DealFieldsResource):
    pass

########NEW FILE########
__FILENAME__ = files
from libsaas import http, parsers
from libsaas.services import base


class FilesResource(base.RESTResource):

    path = 'files'

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Files(FilesResource):

    @base.apimethod
    def get(self, start=None, limit=None):
        """
        Returns data about all files.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Files
        """
        params = base.get_params(None, locals())
        return http.Request('GET', self.get_url(), params), parsers.parse_json


class File(FilesResource):
    pass

########NEW FILE########
__FILENAME__ = filters
from libsaas import http, parsers
from libsaas.services import base


class FiltersResource(base.RESTResource):

    path = 'filters'

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Filters(FiltersResource):

    @base.apimethod
    def get(self, type=None):
        """
        Returns all filters.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Filters
        """
        params = base.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)
        return request, parsers.parse_json

    @base.apimethod
    def delete(self, ids):
        """
        Marks multiple filters as deleted.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Filters
        """
        params = base.get_params(None, locals())
        request = http.Request('DELETE', self.get_url(), params)
        return request, parsers.parse_json


class Filter(FiltersResource):
    pass

########NEW FILE########
__FILENAME__ = goals
from libsaas import http, parsers
from libsaas.services import base


class GoalsResource(base.RESTResource):

    path = 'goals'


class Goals(GoalsResource):
    pass


class Goal(GoalsResource):

    @base.apimethod
    def results(self, period_start=None, period_end=None):
        """
        Lists results of a specific goal.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Goals
        """
        params = base.get_params(None, locals())
        url = '{0}/results'.format(self.get_url())
        return http.Request('GET', url, params), parsers.parse_json

########NEW FILE########
__FILENAME__ = notes
from libsaas import http, parsers
from libsaas.services import base


class NotesResource(base.RESTResource):

    path = 'notes'


class Notes(NotesResource):

    @base.apimethod
    def get(self, user_id=None, deal_id=None, person_id=None, org_id=None,
            start=None, limit=None, sort_by=None, sort_mode=None,
            start_date=None, end_date=None):
        """
        Returns all notes.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Notes
        """
        params = base.get_params(None, locals())
        return http.Request('GET', self.get_url(), params), parsers.parse_json


class Note(NotesResource):
    pass

########NEW FILE########
__FILENAME__ = organizations
from libsaas import http, parsers
from libsaas.services import base


class OrganizationsResource(base.RESTResource):

    path = 'organizations'


class Organizations(OrganizationsResource):

    @base.apimethod
    def get(self, filter_id=None, start=None, limit=None, sort_by=None,
            sort_mode=None):
        """
        Returns all organizations

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Organizations
        """
        params = base.get_params(None, locals())

        return http.Request('GET', self.get_url(), params), parsers.parse_json

    @base.apimethod
    def delete(self, ids):
        """
        Marks multiple organizations as deleted.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Organizations
        """
        params = base.get_params(None, locals())

        request = http.Request('DELETE', self.get_url(), params)
        return request, parsers.parse_json

    @base.apimethod
    def find(self, term, start=None, limit=None):
        """
        Searches all organizations by their name.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Organizations
        """
        params = base.get_params(None, locals())
        url = '{0}/find'.format(self.get_url())
        return http.Request('GET', url, params), parsers.parse_json


class Organization(OrganizationsResource):

    @base.apimethod
    def merge(self, merge_with_id):
        """
        Merges an organization with another organization.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Organizations
        """
        params = base.get_params(None, locals())
        url = '{0}/merge'.format(self.get_url())
        return http.Request('POST', url, params), parsers.parse_json

    @base.apimethod
    def activities(self, start=None, limit=None, done=None, exclude=None):
        """
        Lists activities associated with an organization.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Organizations
        """
        params = base.get_params(None, locals())
        url = '{0}/activities'.format(self.get_url())
        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def followers(self):
        """
        Lists the followers of an organization.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Organizations
        """
        url = '{0}/followers'.format(self.get_url())
        return http.Request('GET', url), parsers.parse_json

    @base.apimethod
    def persons(self, start=None, limit=None):
        """
        Lists the persons of an organization.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Organizations
        """
        params = base.get_params(None, locals())
        url = '{0}/persons'.format(self.get_url())
        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def updates(self, start=None, limit=None):
        """
        Lists updates about an organization.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Organizations
        """
        params = base.get_params(None, locals())
        url = '{0}/updates'.format(self.get_url())
        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def deals(self, start=None, limit=None):
        """
        Lists deals associated with an organization.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Organizations
        """
        params = base.get_params(None, locals())
        url = '{0}/deals'.format(self.get_url())
        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def files(self, start=None, limit=None):
        """
        Lists files associated with an organization.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Organizations
        """
        params = base.get_params(None, locals())
        url = '{0}/files'.format(self.get_url())
        return http.Request('GET', url, params), parsers.parse_json


class OrganizationFieldsResource(base.RESTResource):

    path = 'organizationFields'

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()


class OrganizationFields(OrganizationFieldsResource):

    @base.apimethod
    def delete(self, ids):
        """
        Marks multiple activities as deleted.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-OrganizationFields
        """
        params = base.get_params(None, locals())

        request = http.Request('DELETE', self.get_url(), params)
        return request, parsers.parse_json


class OrganizationField(OrganizationFieldsResource):
    pass

########NEW FILE########
__FILENAME__ = persons
from libsaas import http, parsers
from libsaas.services import base


class PersonsResource(base.RESTResource):

    path = 'persons'


class Persons(PersonsResource):

    @base.apimethod
    def get(self, filter_id=None, start=None, limit=None, sort_by=None,
            sort_mode=None):
        """
        Returns all persons

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Persons
        """
        params = base.get_params(None, locals())

        return http.Request('GET', self.get_url(), params), parsers.parse_json

    @base.apimethod
    def delete(self, ids):
        """
        Marks multiple persons as deleted.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Persons
        """
        params = base.get_params(None, locals())
        request = http.Request('DELETE', self.get_url(), params)
        return request, parsers.parse_json

    @base.apimethod
    def find(self, term, org_id=None, start=None, limit=None):
        """
        Searches all persons by their name.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Persons
        """
        params = base.get_params(None, locals())
        url = '{0}/find'.format(self.get_url())
        return http.Request('GET', url, params), parsers.parse_json


class Person(PersonsResource):

    @base.apimethod
    def merge(self, merge_with_id):
        """
        Merges a person with another person.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Persons
        """
        params = base.get_params(None, locals())
        url = '{0}/merge'.format(self.get_url())
        return http.Request('POST', url, params), parsers.parse_json

    @base.apimethod
    def activities(self, start=None, limit=None, done=None, exclude=None):
        """
        Lists activities associated with a person.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Persons
        """
        params = base.get_params(None, locals())
        url = '{0}/activities'.format(self.get_url())
        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def followers(self):
        """
        Lists the followers of a person.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Persons
        """
        url = '{0}/followers'.format(self.get_url())
        return http.Request('GET', url), parsers.parse_json

    @base.apimethod
    def products(self, start=None, limit=None):
        """
        Lists the products of a person.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-products
        """
        params = base.get_params(None, locals())
        url = '{0}/products'.format(self.get_url())
        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def updates(self, start=None, limit=None):
        """
        Lists updates about a person.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Persons
        """
        params = base.get_params(None, locals())
        url = '{0}/updates'.format(self.get_url())
        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def deals(self, start=None, limit=None):
        """
        Lists deals associated with a person.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Persons
        """
        params = base.get_params(None, locals())
        url = '{0}/deals'.format(self.get_url())
        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def files(self, start=None, limit=None):
        """
        Lists files associated with a person.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Persons
        """
        params = base.get_params(None, locals())
        url = '{0}/files'.format(self.get_url())
        return http.Request('GET', url, params), parsers.parse_json


class PersonFieldsResource(base.RESTResource):

    path = 'personFields'

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()


class PersonFields(PersonFieldsResource):

    @base.apimethod
    def delete(self, ids):
        """
        Marks multiple activities as deleted.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-PersonFields
        """
        params = base.get_params(None, locals())
        request = http.Request('DELETE', self.get_url(), params)
        return request, parsers.parse_json


class PersonField(PersonFieldsResource):
    pass

########NEW FILE########
__FILENAME__ = pipelines
from libsaas import http, parsers
from libsaas.services import base


class StagesResource(base.RESTResource):

    path = 'stages'


class Stages(StagesResource):

    @base.apimethod
    def get(self, pipeline_id=None):
        """
        Returns data about all stages

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Stages
        """
        params = base.get_params(None, locals())

        return http.Request('GET', self.get_url(), params), parsers.parse_json

    @base.apimethod
    def delete(self, ids):
        """
        Marks multiple stages as deleted.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Stages
        """
        params = base.get_params(None, locals())

        request = http.Request('DELETE', self.get_url(), params)
        return request, parsers.parse_json


class Stage(StagesResource):

    @base.apimethod
    def deals(self, filter_id=None, user_id=None, everyone=None,
              start=None, limit=None):
        """
        Lists deals in a specific stage

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Stages
        """
        params = base.get_params(None, locals())
        url = '{0}/deals'.format(self.get_url())
        return http.Request('GET', url, params), parsers.parse_json


class PipelinesResource(base.RESTResource):

    path = 'pipelines'


class Pipelines(PipelinesResource):
    pass


class Pipeline(PipelinesResource):

    @base.apimethod
    def deals(self, filter_id=None, user_id=None, everyone=None,
              stage_id=None, start=None, limit=None):
        """
        Lists deals in a specific pipeline across all its stages.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Pipelines
        """
        params = base.get_params(None, locals())
        url = '{0}/deals'.format(self.get_url())
        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def conversion_rates(self, start_date, end_date, user_id=None):
        """
        Returns all stage-to-stage conversion and pipeline-to-close
        rates for given time period.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Pipelines
        """
        params = base.get_params(None, locals())
        url = '{0}/conversion_statistics'.format(self.get_url())
        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def movements(self, start_date, end_date, user_id=None):
        """
        Returns statistics for deals movements for given time period.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Pipelines
        """
        params = base.get_params(None, locals())
        url = '{0}/movement_statistics'.format(self.get_url())
        return http.Request('GET', url, params), parsers.parse_json

########NEW FILE########
__FILENAME__ = products
from libsaas import http, parsers
from libsaas.services import base


class ProductsResource(base.RESTResource):

    path = 'products'


class Products(ProductsResource):

    @base.apimethod
    def get(self, start=None, limit=None):
        """
        Returns all products

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Products
        """
        params = base.get_params(None, locals())

        return http.Request('GET', self.get_url(), params), parsers.parse_json

    @base.apimethod
    def find(self, term, currency=None, start=None, limit=None):
        """
        Returns data about the products that were found.
        If currency was set in request, prices in that currency are
        served back.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Products
        """
        params = base.get_params(None, locals())
        url = '{0}/find'.format(self.get_url())
        return http.Request('GET', url, params), parsers.parse_json


class Product(ProductsResource):

    @base.apimethod
    def deals(self, start=None, limit=None):
        """
        Returns data about a deals that have a product attached to.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Products
        """
        params = base.get_params(None, locals())
        url = '{0}/deals'.format(self.get_url())
        return http.Request('GET', url, params), parsers.parse_json


class ProductFieldsResource(base.RESTResource):

    path = 'productFields'

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()


class ProductFields(ProductFieldsResource):

    @base.apimethod
    def delete(self, ids):
        """
        Marks multiple activities as deleted.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-ProductFields
        """
        params = base.get_params(None, locals())

        request = http.Request('DELETE', self.get_url(), params)
        return request, parsers.parse_json


class ProductField(ProductFieldsResource):
    pass

########NEW FILE########
__FILENAME__ = service
import json

from libsaas import http, parsers
from libsaas.services import base

from . import activities, currencies, deals, files, filters, goals, notes
from . import organizations, persons, pipelines, products, users


class Pipedrive(base.Resource):
    """
    """
    def __init__(self, api_token):
        """
        Create a Pipedrive service.

        :var api_token: The API token
        :vartype api_token: str
        """
        self.apiroot = 'https://api.pipedrive.com/v1'
        self.api_token = api_token
        self.add_filter(self.add_auth)

    def get_url(self):
        return self.apiroot

    def add_auth(self, request):
        request.headers['Content-Type'] = 'application/json'

        params = {'api_token': self.api_token}

        if request.method.upper() in http.URLENCODE_METHODS:
            request.params.update(params)
        else:
            request.params = json.dumps(request.params)
            request.uri += '?' + http.urlencode_any(params)

    @base.resource(activities.ActivityType)
    def activity_type(self, type_id):
        """
        Return the resource corresponding to a single activity type

        :var type_id: The activity type id
        :vartype type_id: str
        """
        return activities.ActivityType(self, type_id)

    @base.resource(activities.ActivityTypes)
    def activity_types(self):
        """
        Return the resource corresponding to all activity types
        """
        return activities.ActivityTypes(self)

    @base.resource(activities.Activity)
    def activity(self, activity_id):
        """
        Return the resource corresponding to a single activity

        :var activity_id: The activity id
        :vartype activity_id: str
        """
        return activities.Activity(self, activity_id)

    @base.resource(activities.Activities)
    def activities(self):
        """
        Return the resource corresponding to all activities
        """
        return activities.Activities(self)

    @base.resource(users.Authorizations)
    def authorizations(self):
        """
        Return the resource corresponding to the user authorizations
        """
        return users.Authorizations(self)

    @base.resource(users.UserConnections)
    def user_connections(self):
        """
        Return the resource corresponding to the user connections
        """
        return users.UserConnections(self)

    @base.resource(users.User)
    def user(self, user_id):
        """
        Return the resource corresponding to a single user

        :var user_id: The user id
        :vartype user_id: str
        """
        return users.User(self, user_id)

    @base.resource(users.Users)
    def users(self):
        """
        Return the resource corresponding to all users
        """
        return users.Users(self)

    @base.resource(currencies.Currencies)
    def currencies(self):
        """
        Return the resource corresponding to the deals currencies
        """
        return currencies.Currencies(self)

    @base.resource(deals.DealField)
    def deal_field(self, field_id):
        """
        Return the resource corresponding to a single deal field

        :var field_id: The deal field id
        :vartype field_id: str
        """
        return deals.DealField(self, field_id)

    @base.resource(deals.DealFields)
    def deal_fields(self):
        """
        Return the resource corresponding to all deal fields
        """
        return deals.DealFields(self)

    @base.resource(deals.Deal)
    def deal(self, deal_id):
        """
        Return the resource corresponding to a single deal

        :var deal_id: The deal id
        :vartype deal_id: str
        """
        return deals.Deal(self, deal_id)

    @base.resource(deals.Deals)
    def deals(self):
        """
        Return the resource corresponding to all deals
        """
        return deals.Deals(self)

    @base.resource(files.File)
    def file(self, file_id):
        """
        Return the resource corresponding to a single file

        :var file_id: The file id
        :vartype file_id: str
        """
        return files.File(self, file_id)

    @base.resource(files.Files)
    def files(self):
        """
        Return the resource corresponding to all files
        """
        return files.Files(self)

    @base.resource(filters.Filter)
    def condition_filter(self, filter_id):
        """
        Return the resource corresponding to a single filter

        :var filter_id: The filter id
        :vartype filter_id: str
        """
        return filters.Filter(self, filter_id)

    @base.resource(filters.Filters)
    def condition_filters(self):
        """
        Return the resource corresponding to all filters
        """
        return filters.Filters(self)

    @base.resource(notes.Note)
    def note(self, note_id):
        """
        Return the resource corresponding to a single note

        :var note_id: The note id
        :vartype note_id: str
        """
        return notes.Note(self, note_id)

    @base.resource(notes.Notes)
    def notes(self):
        """
        Return the resource corresponding to all notes
        """
        return notes.Notes(self)

    @base.resource(organizations.OrganizationField)
    def organization_field(self, field_id):
        """
        Return the resource corresponding to a single organization field

        :var field_id: The organization field id
        :vartype field_id: str
        """
        return organizations.OrganizationField(self, field_id)

    @base.resource(organizations.OrganizationFields)
    def organization_fields(self):
        """
        Return the resource corresponding to all organization fields
        """
        return organizations.OrganizationFields(self)

    @base.resource(organizations.Organization)
    def organization(self, organization_id):
        """
        Return the resource corresponding to a single organization

        :var organization_id: The organization id
        :vartype organization_id: str
        """
        return organizations.Organization(self, organization_id)

    @base.resource(organizations.Organizations)
    def organizations(self):
        """
        Return the resource corresponding to all organizations
        """
        return organizations.Organizations(self)

    @base.resource(persons.PersonField)
    def person_field(self, field_id):
        """
        Return the resource corresponding to a single person field

        :var field_id: The person field id
        :vartype field_id: str
        """
        return persons.PersonField(self, field_id)

    @base.resource(persons.PersonFields)
    def person_fields(self):
        """
        Return the resource corresponding to all person fields
        """
        return persons.PersonFields(self)

    @base.resource(persons.Person)
    def person(self, person_id):
        """
        Return the resource corresponding to a single person

        :var person_id: The person id
        :vartype person_id: str
        """
        return persons.Person(self, person_id)

    @base.resource(persons.Persons)
    def persons(self):
        """
        Return the resource corresponding to all persons
        """
        return persons.Persons(self)

    @base.resource(pipelines.Stage)
    def stage(self, stage_id):
        """
        Return the resource corresponding to a single stage

        :var stage_id: The stage id
        :vartype stage_id: str
        """
        return pipelines.Stage(self, stage_id)

    @base.resource(pipelines.Stages)
    def stages(self):
        """
        Return the resource corresponding to all stages
        """
        return pipelines.Stages(self)

    @base.resource(pipelines.Pipeline)
    def pipeline(self, pipeline_id):
        """
        Return the resource corresponding to a single pipeline

        :var pipeline_id: The pipeline id
        :vartype pipeline_id: str
        """
        return pipelines.Pipeline(self, pipeline_id)

    @base.resource(pipelines.Pipelines)
    def pipelines(self):
        """
        Return the resource corresponding to all pipelines
        """
        return pipelines.Pipelines(self)

    @base.resource(products.ProductField)
    def product_field(self, field_id):
        """
        Return the resource corresponding to a single product field

        :var field_id: The product field id
        :vartype field_id: str
        """
        return products.ProductField(self, field_id)

    @base.resource(products.ProductFields)
    def product_fields(self):
        """
        Return the resource corresponding to all product fields
        """
        return products.ProductFields(self)

    @base.resource(products.Product)
    def product(self, product_id):
        """
        Return the resource corresponding to a single product

        :var product_id: The product id
        :vartype product_id: str
        """
        return products.Product(self, product_id)

    @base.resource(products.Products)
    def products(self):
        """
        Return the resource corresponding to all products
        """
        return products.Products(self)

    @base.apimethod
    def search(self, term, start=None, limit=None):
        """
        Performs a search across the account and returns SearchResults.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-SearchResults
        """
        params = base.get_params(None, locals())
        url = '{0}/searchResults'.format(self.get_url())
        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def settings(self):
        """
        Lists settings of authorized user.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-UserSettings
        """
        url = '{0}/userSettings'.format(self.get_url())
        return http.Request('GET', url), parsers.parse_json

    @base.resource(goals.Goal)
    def goal(self, goal_id):
        """
        Return the resource corresponding to a single goal

        :var goal_id: The goal id
        :vartype goal_id: str
        """
        return goals.Goal(self, goal_id)

    @base.resource(goals.Goals)
    def goals(self):
        """
        Return the resource corresponding to all goals
        """
        return goals.Goals(self)

########NEW FILE########
__FILENAME__ = users
from libsaas import http, parsers
from libsaas.services import base


class Authorizations(base.HierarchicalResource):

    path = 'authorizations'

    @base.apimethod
    def get(self, email, password):
        """
        Returns all authorizations for a particular user.
        Authorization objects contain the API tokens the user has with
        different company accounts in Pipedrive.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Authorizations
        """
        params = base.get_params(None, locals())

        return http.Request('POST', self.get_url(), params), parsers.parse_json


class UserConnections(base.HierarchicalResource):

    path = 'userConnections'

    @base.apimethod
    def get(self):
        """
        Returns data about all connections for the authorized user.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-UserConnections
        """
        return http.Request('GET', self.get_url()), parsers.parse_json


class UsersResource(base.RESTResource):

    path = 'users'

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Users(UsersResource):

    @base.apimethod
    def find(self, term):
        """
        Searches all users by their name.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Users
        """
        params = base.get_params(None, locals())
        url = '{0}/find'.format(self.get_url())
        return http.Request('GET', url, params), parsers.parse_json


class User(UsersResource):

    @base.apimethod
    def merge(self, merge_with_id):
        """
        Merges a user with another user.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Users
        """
        params = base.get_params(None, locals())
        url = '{0}/merge'.format(self.get_url())
        return http.Request('POST', url, params), parsers.parse_json

    @base.apimethod
    def activities(self, start=None, limit=None, done=None, exclude=None):
        """
        Lists activities associated with a user.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Users
        """
        params = base.get_params(None, locals())
        url = '{0}/activities'.format(self.get_url())
        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def followers(self):
        """
        Lists the followers of a user.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Users
        """
        url = '{0}/followers'.format(self.get_url())
        return http.Request('GET', url), parsers.parse_json

    @base.apimethod
    def updates(self, start=None, limit=None):
        """
        Lists updates about a user.

        Upstream documentation:
        https://developers.pipedrive.com/v1#methods-Users
        """
        params = base.get_params(None, locals())
        url = '{0}/updates'.format(self.get_url())
        return http.Request('GET', url, params), parsers.parse_json

########NEW FILE########
__FILENAME__ = accounts
from libsaas import http, parsers
from libsaas.services import base

from . import resource
from . import invoices as inv
from . import coupons as coup
from . import transactions as tx
from . import adjustments as ads
from . import subscriptions as subs


class BillingInfo(resource.RecurlyResource):

    path = 'billing_info'

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.apimethod
    def update(self, obj):
        """
        Update this resource.

        :var obj: a Python object representing the updated resource, usually in
            the same format as returned from `get`. Refer to the upstream
            documentation for details.
        """
        # skip require_item checking because we are using the account's one
        request = http.Request('PUT', self.get_url(), obj)
        return request, parsers.parse_xml

    @base.apimethod
    def delete(self):
        """
        Delete this resource.
        """
        request = http.Request('DELETE', self.get_url())
        return request, parsers.parse_empty


class AccountBase(resource.RecurlyResource):

    path = 'accounts'


class Accounts(AccountBase):

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.apimethod
    def get(self, state='active', cursor=None, per_page=None):
        """
        Fetch accounts for your site.

        :var state: The state of the accounts to return: 'active', 'closed',
            'past_due'. Defaults to 'active'.
        :vartype state: str
        """
        params = base.get_params(('cursor', 'per_page'), locals())
        params['state'] = state
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_xml


class Account(AccountBase):

    @base.resource(BillingInfo)
    def billing_info(self):
        """
        Return the resource corresponding to the account's
        current billing information.
        """
        return BillingInfo(self)

    @base.resource(coup.CouponRedemption)
    def redemption(self):
        """
        Return the resource corresponding to the
        coupon redeemed by the account.
        """
        return coup.CouponRedemption(self)

    @base.resource(subs.AccountSubscriptions)
    def subscriptions(self):
        """
        Return the resource corresponding to all subscriptions for the account.
        """
        return subs.AccountSubscriptions(self)

    @base.resource(ads.AccountAdjustments)
    def adjustments(self):
        """
        Return the resource corresponding to all charges
        and credits issued for the account.
        """
        return ads.AccountAdjustments(self)

    @base.resource(inv.AccountInvoices)
    def invoices(self):
        """
        Return the resource corresponding to all invoices for the account.
        """
        return inv.AccountInvoices(self)

    @base.resource(tx.AccountTransactions)
    def transactions(self):
        """
        Return the resource corresponding to all transactions for the account.
        """
        return tx.AccountTransactions(self)

########NEW FILE########
__FILENAME__ = adjustments
from libsaas import http, parsers
from libsaas.services import base

from . import resource


class AdjustmentsBase(resource.RecurlyResource):

    path = 'adjustments'


class AccountAdjustments(AdjustmentsBase):

    @base.apimethod
    def get(self, type=None, state=None, cursor=None, per_page=None):
        """
        Fetch credits and charges for an account.

        :var type: The type of adjustments: 'charge' or 'credit'.
        :vartype type: str

        :var state: The state of the adjustments to return: 'pending'
            or 'invoiced'.
        :vartype state: str
        """
        params = base.get_params(('type', 'state', 'cursor', 'per_page'),
                                 locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_xml

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Adjustment(AdjustmentsBase):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

########NEW FILE########
__FILENAME__ = coupons
from libsaas import http, parsers
from libsaas.services import base

from . import resource


class CouponsBase(resource.RecurlyResource):

    path = 'coupons'

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Coupons(CouponsBase):

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.apimethod
    def get(self, state=None, cursor=None, per_page=None):
        """
        Fetch all your coupons.

        :var state: The state of coupons to return: "redeemable", "expired"
            or "maxed_out".
        :vartype state: str
        """
        params = base.get_params(('state', 'cursor', 'per_page'), locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_xml


class Coupon(CouponsBase):

    pass


class CouponRedemption(CouponsBase):

    path = 'redemption'

    @base.apimethod
    def delete(self):
        """
        Delete this resource.
        """
        request = http.Request('DELETE', self.get_url())
        return request, parsers.parse_empty

########NEW FILE########
__FILENAME__ = invoices
from libsaas import http, parsers
from libsaas.services import base

from . import resource


def parse_passthrough(body, code, headers):
    if not 200 <= code < 300:
        raise http.HTTPError(body, code, headers)

    return body


class InvoicesBase(resource.RecurlyResource):

    path = 'invoices'

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Invoices(InvoicesBase):

    @base.apimethod
    def get(self, state=None, cursor=None, per_page=None):
        """
        Fetch all your invoices.

        :var state: The state of invoices to return: "open", "collected",
            "failed", or "past_due".
        :vartype state: str
        """
        params = base.get_params(('state', 'cursor', 'per_page'), locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_xml

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Invoice(InvoicesBase):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.apimethod
    def get_pdf(self, language='en-US'):
        """
        Fetch a PDF blob for the invoice.

        :var language: The language for the invoice, defaults to "en-US'.
        :vartype language: str
        """
        self.require_item()

        headers = {'Accept': 'application/pdf', 'Accept-Language': language}
        request = http.Request('GET', self.get_url(), {}, headers)

        return request, parse_passthrough

    @base.apimethod
    def mark_successful(self):
        """
        Mark an invoice as paid successfully
        """
        self.require_item()

        url = '{0}/mark_successful'.format(self.get_url())
        request = http.Request('PUT', url)

        return request, parsers.parse_empty

    @base.apimethod
    def mark_failed(self):
        """
        Mark an invoice as failed collection
        """
        self.require_item()

        url = '{0}/mark_failed'.format(self.get_url())
        request = http.Request('PUT', url)

        return request, parsers.parse_empty


class AccountInvoices(InvoicesBase):

    pass

########NEW FILE########
__FILENAME__ = plans
from libsaas.services import base

from . import resource


class AddonsBase(resource.RecurlyResource):

    path = 'add_ons'


class Addons(AddonsBase):

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Addon(AddonsBase):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()


class PlansBase(resource.RecurlyResource):

    path = 'plans'


class Plans(PlansBase):

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Plan(PlansBase):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.resource(Addons)
    def addons(self):
        """
        Return the resource corresponding to all the add-ons for the plan.
        """
        return Addons(self)

    @base.resource(Addon)
    def addon(self, add_on_code):
        """
        Return the resource corresponding to a single plan's add-on.
        """
        return Addon(self, add_on_code)

########NEW FILE########
__FILENAME__ = resource
from libsaas import http, parsers
from libsaas.services import base


def parse_count(body, code, headers):
    if not 200 <= code < 300:
        raise http.HTTPError(body, code, headers)

    # default to 1 if the header is not present - usually it means that the
    # endpoint returns a single resource and not a collection
    return int(headers.get('x-records', 1))


class RecurlyResource(base.RESTResource):

    @base.apimethod
    def get(self, cursor=None, per_page=None):
        """
        For single-object resources, fetch the object's data. For collections,
        fetch all of the objects.

        :var cursor: For collections, where should paging start. If left as
            `None`, the first page is returned.
        :vartype cursor: int

        :var per_page: For collections, how many objects sould be returned. The
            maximum is 200. If left as `None`, 50 objects are returned.
        :vartype per_page: int
        """
        params = base.get_params(('cursor', 'per_page'), locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_xml

    @base.apimethod
    def count(self, *args, **kwargs):
        """
        Fetch an integer count of the number of objects of a collection. This
        is an absolute number, regardless of paging limits, so use this if you
        want to tally up a collection instead of iterating through all of its
        objects.

        For single-object resources, returns one.

        Accepts the same arguments as `get`.
        """
        with base.extract_request():
            kwargs['per_page'] = 1
            request = self.get(*args, **kwargs)

        return request, parse_count

    @base.apimethod
    def create(self, obj):
        """
        Create a new resource.

        :var obj: a Python object representing the resource to be created,
            usually in the same as returned from `get`. Refer to the upstream
            documentation for details.
        """
        self.require_collection()
        request = http.Request('POST', self.get_url(), self.wrap_object(obj))

        return request, parsers.parse_xml

    @base.apimethod
    def update(self, obj):
        """
        Update this resource.

        :var obj: a Python object representing the updated resource, usually in
            the same format as returned from `get`. Refer to the upstream
            documentation for details.
        """
        self.require_item()
        request = http.Request('PUT', self.get_url(), self.wrap_object(obj))

        return request, parsers.parse_xml

########NEW FILE########
__FILENAME__ = service
from libsaas import http, xml

from libsaas.filters import auth
from libsaas.services import base

from . import plans as pl
from . import accounts as acc
from . import invoices as inv
from . import coupons as coup
from . import transactions as tx
from . import adjustments as ads
from . import subscriptions as subs


class Recurly(base.Resource):
    """
    """
    def __init__(self, api_key):
        """
        Create a Recurly service.

        :var api_key: The API key including.
        :vartype api_key: str
        """
        self.apiroot = 'https://api.recurly.com/v2'

        self.add_filter(auth.BasicAuth(api_key, ''))
        self.add_filter(self.use_xml)

    def get_url(self):
        return self.apiroot

    def use_xml(self, request):
        request.headers['Content-Type'] = 'application/xml'
        request.headers.setdefault('Accept', 'application/xml')

        if request.method.upper() not in http.URLENCODE_METHODS:
            request.params = xml.dict_to_xml(request.params)

    @base.resource(pl.Plans)
    def plans(self):
        """
        Return the resource corresponding to all plans.
        """
        return pl.Plans(self)

    @base.resource(pl.Plan)
    def plan(self, plan_code):
        """
        Return the resource corresponding to a single plan.
        """
        return pl.Plan(self, plan_code)

    @base.resource(acc.Accounts)
    def accounts(self):
        """
        Return the resource corresponding to all accounts.
        """
        return acc.Accounts(self)

    @base.resource(acc.Account)
    def account(self, account_code):
        """
        Return the resource corresponding to a single account.
        """
        return acc.Account(self, account_code)

    @base.resource(ads.Adjustment)
    def adjustment(self, uuid):
        """
        Return the resource corresponding to a single adjustment.
        """
        return ads.Adjustment(self, uuid)

    @base.resource(coup.Coupons)
    def coupons(self):
        """
        Return the resource corresponding to all coupons.
        """
        return coup.Coupons(self)

    @base.resource(coup.Coupon)
    def coupon(self, coupon_code):
        """
        Return the resource corresponding to a single coupon.
        """
        return coup.Coupon(self, coupon_code)

    @base.resource(inv.Invoices)
    def invoices(self):
        """
        Return the resource corresponding to all invoices.
        """
        return inv.Invoices(self)

    @base.resource(inv.Invoice)
    def invoice(self, invoice_number):
        """
        Return the resource corresponding to a single invoice.
        """
        return inv.Invoice(self, invoice_number)

    @base.resource(subs.Subscriptions)
    def subscriptions(self):
        """
        Return the resource corresponding to all subscriptions.
        """
        return subs.Subscriptions(self)

    @base.resource(subs.Subscription)
    def subscription(self, uuid):
        """
        Return the resource corresponding to a single subscription.
        """
        return subs.Subscription(self, uuid)

    @base.resource(tx.Transactions)
    def transactions(self):
        """
        Return the resource corresponding to all transactions.
        """
        return tx.Transactions(self)

    @base.resource(tx.Transaction)
    def transaction(self, uuid):
        """
        Return the resource corresponding to a single transaction.
        """
        return tx.Transaction(self, uuid)

########NEW FILE########
__FILENAME__ = subscriptions
from libsaas import http, parsers
from libsaas.services import base

from . import resource


class SubscriptionsBase(resource.RecurlyResource):

    path = 'subscriptions'

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Subscriptions(SubscriptionsBase):

    @base.apimethod
    def get(self, state='live', cursor=None, per_page=None):
        """
        Fetch all your subscription.

        :var state: The state of subscriptions to return:
            "active", "canceled", "expired", "future", "in_trial", "live",
            or "past_due". A subscription will belong to more than one state.
        :vartype state: str
        """
        params = base.get_params(('cursor', 'per_page'), locals())
        params['state'] = state
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_xml

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Subscription(SubscriptionsBase):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.apimethod
    def cancel(self):
        """
        Cancel a subscription, remaining it as active until next billing cycle.
        """
        self.require_item()

        url = '{0}/cancel'.format(self.get_url())
        request = http.Request('PUT', url)
        request.use_xml = False

        return request, parsers.parse_empty

    @base.apimethod
    def reactivate(self):
        """
        Reactivating a canceled subscription.
        """
        self.require_item()

        url = '{0}/reactivate'.format(self.get_url())
        request = http.Request('PUT', url)

        return request, parsers.parse_empty

    @base.apimethod
    def terminate(self, refund=None):
        """
        Terminate a subsciription, removing any stored billing information.

        :var refund: The type of the refund to perform: 'full' or 'partial'
            Defaults to 'none'.
        :vartype refund: str
        """
        self.require_item()

        url = '{0}/terminate'.format(self.get_url())
        params = {
            'refund': refund if refund else 'none'
        }
        url = url + '?' + http.urlencode_any(params)

        request = http.Request('PUT', url)

        return request, parsers.parse_empty

    @base.apimethod
    def postpone(self, next_renewal_date):
        """
        Postpone a subscription

        :var next_renewal_date: The next renewal date that will be applied
        :vartype next_renewal_date: str
        """
        self.require_item()

        url = '{0}/postpone'.format(self.get_url())
        params = {'next_renewal_date': next_renewal_date}
        url = url + '?' + http.urlencode_any(params)

        request = http.Request('PUT', url)

        return request, parsers.parse_empty


class AccountSubscriptions(SubscriptionsBase):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

########NEW FILE########
__FILENAME__ = transactions
from libsaas import http, parsers
from libsaas.services import base

from . import resource


class TransactionsBase(resource.RecurlyResource):

    path = 'transactions'

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Transactions(TransactionsBase):

    @base.apimethod
    def get(self, state=None, type=None, cursor=None, per_page=None):
        """
        Fetch all your transactions.

        :var state: The state of transactions to return:
            "successful", "failed", or "voided".
        :vartype state: str

        :var type: The type of transactions to return:
            "authorization", "refund", or "purchase".
        :vartype type: str
        """
        params = base.get_params(
            ('state', 'type', 'cursor', 'per_page'), locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_xml


class Transaction(TransactionsBase):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.apimethod
    def refund(self, amount_in_cents=None):
        """
        Refund or void a previous, successful transaction.
        """
        self.require_item()

        url = self.get_url()
        params = base.get_params(('amount_in_cents',), locals())
        if params:
            url = url + '?' + http.urlencode_any(params)

        request = http.Request('DELETE', url)

        return request, parsers.parse_empty


class AccountTransactions(TransactionsBase):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

########NEW FILE########
__FILENAME__ = resources
from libsaas.services import base
from libsaas import parsers, http, port


class User(base.Resource):

    def __init__(self, parent, object_id=None):
        self.parent = parent
        self.object_id = object_id

    def get_url(self, method):
        return '{0}/{1}'.format(self.parent.get_url(), method)

    def _post(self, method, data):
        data['userId'] = self.object_id

        request = http.Request('POST', self.get_url(method), data)
        return request, parsers.parse_json

    @base.apimethod
    def identify(self, traits=None, context=None, timestamp=None):
        """
        Identify an user.

        :var traits: A dictionary of traits you know about the user.
        :vartype traits: dict

        :var context: A dictionary of provider specific options.
        :vartype context: dict

        :var timestamp: An ISO 8601 date string representing
        when the identify took place.
        :vartype timestamp: str
        """
        params = base.get_params(None, locals())
        return self._post('identify', params)

    @base.apimethod
    def track(self, event, properties=None, context=None, timestamp=None):
        """
        Track an event.

        :var event: The name of the event you're tracking.
        :vartype event: str

        :var properties: A dictionary of properties for the event.
        :vartype properties: dict

        :var context: A dictionary of provider specific options.
        :vartype context: dict

        :var timestamp: An ISO 8601 date string representing
        when the event took place.
        :vartype timestamp: str
        """
        params = base.get_params(None, locals())
        return self._post('track', params)

########NEW FILE########
__FILENAME__ = service
import json

from . import resources
from libsaas import http, parsers
from libsaas.services import base


class SegmentIO(base.Resource):

    def __init__(self, api_secret):
        """
        Create a SegmentIO service

        :var api_secret: Your project's API secret.
        :vartype api_secret: str
        """
        self.apiroot = 'https://api.segment.io/v1'
        self.api_secret = api_secret

        self.add_filter(self.add_authorization)
        self.add_filter(self.use_json)

    def add_authorization(self, request):
        request.params['secret'] = self.api_secret

    def use_json(self, request):
        request.headers['Content-Type'] = 'application/json; charset=utf-8'
        request.params = json.dumps(request.params)

    def get_url(self):
        return self.apiroot

    @base.resource(resources.User)
    def user(self, user_id):
        """
        Return the resource corresponding to a single user
        """
        return resources.User(self, user_id)

    @base.apimethod
    def alias(self, from_user_id, to_user_id, context=None, timestamp=None):
        """
        Identify an user.

        :var from_user_id: The anonymous user's id before they are logged in.
        :vartype from_user_id: str

        :var to_user_id: The identified user's id after they're logged in.
        :vartype to_user_id: str

        :var context: A dictionary of provider specific options.
        :vartype context: dict

        :var timestamp: An ISO 8601 date string representing
        when the identify took place.
        :vartype timestamp: str
        """
        params = {
            'from': from_user_id,
            'to': to_user_id,
        }
        params.update(base.get_params(('context', 'timestamp'), locals()))
        url = '{0}/{1}'.format(self.get_url(), 'alias')

        request = http.Request('POST', url, params)
        return request, parsers.parse_json


########NEW FILE########
__FILENAME__ = resources
from libsaas import http, parsers
from libsaas.services import base


class SpotifyResource(base.RESTResource):

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Search(SpotifyResource):

    path = 'search/1'

    @base.apimethod
    def get(self, type, q, page=None):
        """
        Search in the Spotify's music catalogue.

        See https://developer.spotify.com/technologies/web-api/search/ and
        http://www.spotify.com/es/about/features/advanced-search-syntax/

        :var type: What to search for, artist, album or track.
        :vartype type: str

        :var q: Search string.
        :vartype q: str

        :var page: The page of the result set to return. defaults to 1
        :vartype page: int
        """
        url = '{0}/{1}'.format(self.get_url(), type)
        params = base.get_params(('q', 'page'), locals())

        return http.Request('GET', url, params), parsers.parse_json

    def artist(self, q, page=None):
        """
        Search for artists in the Spotify's music catalogue
        See http://www.spotify.com/es/about/features/advanced-search-syntax/

        :var q: Search string.
        :vartype q: str

        :var page: The page of the result set to return. defaults to 1
        :vartype page: int
        """
        return self.get('artist', q, page)

    def album(self, q, page=None):
        """
        Search for albums in the Spotify's music catalogue
        See http://www.spotify.com/es/about/features/advanced-search-syntax/

        :var q: Search string.
        :vartype q: str

        :var page: The page of the result set to return. defaults to 1
        :vartype page: int
        """
        return self.get('album', q, page)

    def track(self, q, page=None):
        """
        Search for tracks in the Spotify's music catalogue
        See http://www.spotify.com/es/about/features/advanced-search-syntax/

        :var q: Search string.
        :vartype q: str

        :var page: The page of the result set to return. defaults to 1
        :vartype page: int
        """
        return self.get('track', q, page)


class Lookup(SpotifyResource):

    NONE, BASIC, DETAILED = range(3)

    ALBUM_DETAIL = {
        BASIC: 'track',
        DETAILED: 'trackdetail'
    }

    ARTIST_DETAIL = {
        BASIC: 'album',
        DETAILED: 'albumdetail'
    }

    path = 'lookup/1/'

    @base.apimethod
    def get(self, uri, extras=None):
        """
        Lookup for an artist, album or track in the Spotify's music catalogue

        :var uri: Spotify valid uri
        :vartype uri: str

        :var extras: A comma-separated list of words that defines the detail
            level expected in the response.
        :vartype extras: str

        See https://developer.spotify.com/technologies/web-api/lookup/
        """
        params = base.get_params(('uri', 'extras'), locals())
        return http.Request('GET', self.get_url(), params), parsers.parse_json

    def artist(self, uri, detail=None):
        """
        Lookup for an artist in the Spotify's music catalogue

        :var uri: Spotify artist uri
        :vartype uri: str

        :var detail: Detail level expected in the response.
            Valid values are:
            1: returns basic information about all the albums the artist
            is featured in.
            2: returns detailed information about all the albums
            the artist is featured in.
        :vartype detail: int
        """
        extras = self.ARTIST_DETAIL.get(detail)
        return self.get(uri, extras)

    def album(self, uri, detail=None):
        """
        Lookup for an album in the Spotify's music catalogue

        :var uri: Spotify album uri
        :vartype uri: str

        :var detail: Detail level expected in the response.
            Valid values are:
            1: returns basic information about all the tracks the artist
            is featured in.
            2: returns detailed information about all the albums
            the artist is featured in.
        :vartype detail: int
        """
        extras = self.ALBUM_DETAIL.get(detail)
        return self.get(uri, extras)

    def track(self, uri):
        """
        Lookup for a track in the Spotify's music catalogue

        :var uri: Spotify track uri
        :vartype uri: str
        """
        return self.get(uri)

########NEW FILE########
__FILENAME__ = service
from libsaas.services import base

from . import resources


class Spotify(base.Resource):
    """
    """
    def __init__(self):
        """
        Create a Spotify service.
        """
        self.apiroot = 'http://ws.spotify.com/'
        self.add_filter(self.use_json)

    def use_json(self, request):
        request.headers['Content-Type'] = 'application/json'
        request.headers['Accept'] = 'application/json'

    def get_url(self):
        return self.apiroot

    @base.resource(resources.Search)
    def search(self):
        """
        Return the resource corresponding to the search service
        """
        return resources.Search(self)

    @base.resource(resources.Lookup)
    def lookup(self):
        """
        Return the resource corresponding to the lookup service
        """
        return resources.Lookup(self)

########NEW FILE########
__FILENAME__ = accounts
from libsaas.services import base

from . import resource


class Account(resource.StripeResource):

    path = 'account'

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


########NEW FILE########
__FILENAME__ = charges
from libsaas.services import base
from libsaas import parsers, http

from . import resource


class ChargesBaseResource(resource.StripeResource):

    path = 'charges'

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Charge(ChargesBaseResource):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.apimethod
    def dispute(self, obj):
        """
        Update a dispute

        :var obj: a Python object representing the updated dispute.
        """
        self.require_item()
        url = '{0}/{1}'.format(self.get_url(), 'dispute')
        request = http.Request('POST', url, self.wrap_object(obj))

        return request, parsers.parse_json

    @base.apimethod
    def refund(self, amount=None):
        """
        Refunding a charge

        :var amount: A positive integer in cents representing how much
            of this charge to refund. Can only refund up to the unrefunded
            amount remaining of the charge. Default is entire charge.
        :vartype amount: int
        """
        params = {}
        if amount:
            params.update({'amount': amount})
        url = '{0}/{1}'.format(self.get_url(), 'refund')
        request = http.Request('POST', url, params)

        return request, parsers.parse_json


class Charges(ChargesBaseResource):

    @base.apimethod
    def get(self, customer=None, count=None, offset=None):
        """
        Fetch all of the objects.

        :var customer: Only return charges for the customer specified by
            this customer ID.
        :vartype customer: str
        :var count: A limit on the number of objects to be returned.
            Count can range between 1 and 100 objects.
        :vartype count: int
        :var offset: An offset into your object array. The API will return
            the requested number of objects starting at that offset.
        :vartype offset: int
        """
        params = base.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json


########NEW FILE########
__FILENAME__ = coupons
from libsaas.services import base

from . import resource


class CouponsBaseResource(resource.StripeResource):

    path = 'coupons'

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Coupon(CouponsBaseResource):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Coupons(resource.ListResourceMixin, CouponsBaseResource):

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()

########NEW FILE########
__FILENAME__ = customers
from libsaas.services import base
from libsaas import parsers, http

from . import resource


class SubscriptionResource(resource.StripeResource):

    path = 'subscription'

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.apimethod
    def get(self):
        """
        Fetch the object's data.
        """
        request = http.Request('GET', self.get_url())

        return request, parsers.parse_json

    @base.apimethod
    def update(self, obj):
        """
        Update this resource.

        :var obj: a Python object representing the updated resource, usually in
            the same format as returned from `get`. Refer to the upstream
            documentation for details.
        """
        request = http.Request('POST', self.get_url(), self.wrap_object(obj))

        return request, parsers.parse_json

    @base.apimethod
    def delete(self):
        """
        Delete this resource.
        """
        request = http.Request('DELETE', self.get_url())

        return request, parsers.parse_empty


class DiscountResource(resource.StripeResource):

    path = 'discount'

    def get(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.apimethod
    def delete(self):
        """
        Delete this resource.
        """
        request = http.Request('DELETE', self.get_url())

        return request, parsers.parse_empty


class CustomersBaseResource(resource.StripeResource):

    path = 'customers'


class Customer(CustomersBaseResource):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.resource(SubscriptionResource)
    def subscription(self):
        """
        Return the resource corresponding to the customer's subscription.
        """
        return SubscriptionResource(self)

    @base.resource(DiscountResource)
    def discount(self):
        """
        Return the resource corresponding to a single discount.
        """
        return DiscountResource(self)


class Customers(resource.ListResourceMixin, CustomersBaseResource):

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()

########NEW FILE########
__FILENAME__ = events
from libsaas.services import base
from libsaas import parsers, http

from . import resource


class EventsBaseResource(resource.StripeResource):

    path = 'events'

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Event(EventsBaseResource):
    pass


class Events(EventsBaseResource):

    @base.apimethod
    def get(self, type=None, count=None, offset=None):
        """
        Fetch all of the objects.

        :var type: A string containing a specific event name, or group of
            events using * as a wildcard. The list will be filtered to
            include only events with a matching event property.
        :vartype type: str
        :var count: A limit on the number of objects to be returned.
            Count can range between 1 and 100 objects.
        :vartype count: int

        :var offset: An offset into your object array. The API will return
            the requested number of objects starting at that offset.
        :vartype offset: int
        """
        params = base.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

########NEW FILE########
__FILENAME__ = invoices
from libsaas.services import base
from libsaas import parsers, http

from . import resource


class LineItems(resource.StripeResource):

    path = 'lines'

    @base.apimethod
    def get(self, customer=None, count=None, offset=None):
        """
        Fetch all of the objects.

        :var customer: In the case of upcoming invoices, the customer of the
            upcoming invoice is required. In other cases it is ignored.
        :vartype customer: str
        :var count: A limit on the number of objects to be returned.
            Count can range between 1 and 100 objects.
        :vartype count: int

        :var offset: An offset into your object array. The API will return
            the requested number of objects starting at that offset.
        :vartype offset: int
        """
        params = base.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class InvoicesBaseResource(resource.StripeResource):

    path = 'invoices'

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Invoice(InvoicesBaseResource):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.resource(LineItems)
    def lines(self):
        """
        Return the resource corresponding to all invoice's lines.
        """
        return LineItems(self)

    @base.apimethod
    def pay(self):
        """
        Paying an invoice
        """
        self.require_item()
        url = '{0}/{1}'.format(self.get_url(), 'pay')
        request = http.Request('POST', url, {})

        return request, parsers.parse_json


class Invoices(InvoicesBaseResource):

    @base.apimethod
    def get(self, customer=None, count=None, offset=None):
        """
        Fetch all of the objects.

        :var customer: The identifier of the customer whose invoices to return.
            If none is provided, all invoices will be returned.
        :vartype customer: str
        :var count: A limit on the number of objects to be returned.
            Count can range between 1 and 100 objects.
        :vartype count: int

        :var offset: An offset into your object array. The API will return
            the requested number of objects starting at that offset.
        :vartype offset: int
        """
        params = base.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.apimethod
    def upcoming(self, customer):
        """
        Fetch a customer's upcoming invoice.

        :var customer: The identifier of the customer whose invoices to return.
            If none is provided, all invoices will be returned.
        :vartype customer: str
        """
        params = base.get_params(None, locals())
        url = '{0}/{1}'.format(self.get_url(), 'upcoming')
        request = http.Request('GET', url, params)

        return request, parsers.parse_json


class InvoiceItemBaseResource(resource.StripeResource):

    path = 'invoiceitems'

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()


class InvoiceItem(InvoiceItemBaseResource):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()


class InvoiceItems(InvoiceItemBaseResource):

    @base.apimethod
    def get(self, customer=None, count=None, offset=None):
        """
        Fetch all of the objects.

        :var customer: The identifier of the customer whose invoice items to return.
            If none is provided, all invoice items will be returned.
        :vartype customer: str
        :var count: A limit on the number of objects to be returned.
            Count can range between 1 and 100 objects.
        :vartype count: int

        :var offset: An offset into your object array. The API will return
            the requested number of objects starting at that offset.
        :vartype offset: int
        """
        params = base.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()

########NEW FILE########
__FILENAME__ = plans
from libsaas.services import base

from . import resource


class PlansBaseResource(resource.StripeResource):

    path = 'plans'


class Plan(PlansBaseResource):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Plans(resource.ListResourceMixin, PlansBaseResource):

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()

########NEW FILE########
__FILENAME__ = resource
from libsaas import http, parsers
from libsaas.services import base


class StripeResource(base.RESTResource):

    @base.apimethod
    def update(self, obj):
        """
        Update this resource.

        :var obj: a Python object representing the updated resource, usually in
            the same format as returned from `get`. Refer to the upstream
            documentation for details.
        """
        self.require_item()
        request = http.Request('POST', self.get_url(), self.wrap_object(obj))

        return request, parsers.parse_json


class ListResourceMixin(object):

    @base.apimethod
    def get(self, count=None, offset=None):
        """
        Fetch all of the objects.

        :var count: A limit on the number of objects to be returned.
            Count can range between 1 and 100 objects.
        :vartype count: int

        :var offset: An offset into your object array. The API will return
            the requested number of objects starting at that offset.
        :vartype offset: int
        """
        params = base.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

########NEW FILE########
__FILENAME__ = service
from libsaas.filters import auth
from libsaas.services import base

from .accounts import Account
from .plans import Plans, Plan
from .tokens import Tokens, Token
from .events import Events, Event
from .charges import Charges, Charge
from .coupons import Coupons, Coupon
from .customers import Customers, Customer
from .invoices import Invoices, Invoice, InvoiceItems, InvoiceItem


class Stripe(base.Resource):
    """
    """
    def __init__(self, api_key):
        """
        Create a Stripe service.

        :var api_key: The API key.
        :vartype api_key: str
        """
        self.apiroot = 'https://api.stripe.com/v1'

        self.add_filter(auth.BasicAuth(api_key, ''))

    def get_url(self):
        return self.apiroot

    @base.resource(Account)
    def account(self):
        """
        Return the resource corresponding to the logged account.
        """
        return Account(self)

    @base.resource(Plans)
    def plans(self):
        """
        Return the resource corresponding to all plans.
        """
        return Plans(self)

    @base.resource(Plan)
    def plan(self, id):
        """
        Return the resource corresponding to a single plan.
        """
        return Plan(self, id)

    @base.resource(Charges)
    def charges(self):
        """
        Return the resource corresponding to all charges.
        """
        return Charges(self)

    @base.resource(Charge)
    def charge(self, id):
        """
        Return the resource corresponding to a single charge.
        """
        return Charge(self, id)

    @base.resource(Customers)
    def customers(self):
        """
        Return the resource corresponding to all customers.
        """
        return Customers(self)

    @base.resource(Customer)
    def customer(self, id):
        """
        Return the resource corresponding to a single customer.
        """
        return Customer(self, id)

    @base.resource(Tokens)
    def tokens(self):
        """
        Return the resource corresponding to all tokens.
        """
        return Tokens(self)

    @base.resource(Token)
    def token(self, id):
        """
        Return the resource corresponding to a single token.
        """
        return Token(self, id)

    @base.resource(Invoices)
    def invoices(self):
        """
        Return the resource corresponding to all invoices.
        """
        return Invoices(self)

    @base.resource(Invoice)
    def invoice(self, id):
        """
        Return the resource corresponding to a single invoice.
        """
        return Invoice(self, id)

    @base.resource(Events)
    def events(self):
        """
        Return the resource corresponding to all events.
        """
        return Events(self)

    @base.resource(Event)
    def event(self, id):
        """
        Return the resource corresponding to a single event.
        """
        return Event(self, id)

    @base.resource(Coupons)
    def coupons(self):
        """
        Return the resource corresponding to all coupons.
        """
        return Coupons(self)

    @base.resource(Coupon)
    def coupon(self, id):
        """
        Return the resource corresponding to a single coupon.
        """
        return Coupon(self, id)

    @base.resource(InvoiceItems)
    def invoiceitems(self):
        """
        Return the resource corresponding to all invoiceitems.
        """
        return InvoiceItems(self)

    @base.resource(InvoiceItem)
    def invoiceitem(self, id):
        """
        Return the resource corresponding to a single invoiceitem.
        """
        return InvoiceItem(self, id)

########NEW FILE########
__FILENAME__ = tokens
from libsaas.services import base

from . import resource


class TokensBaseResource(resource.StripeResource):

    path = 'tokens'

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Token(TokensBaseResource):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Tokens(TokensBaseResource):

    def get(self, *args, **kwargs):
        raise base.MethodNotSupported()

########NEW FILE########
__FILENAME__ = actions
from libsaas import http, parsers
from libsaas.services import base

from .resource import (
    serialize_param, TrelloFieldMixin,
    TrelloResource, TrelloReadonlyResource)


class Board(TrelloReadonlyResource, TrelloFieldMixin):
    path = 'board'


class Card(TrelloReadonlyResource, TrelloFieldMixin):
    path = 'card'


class List(TrelloReadonlyResource, TrelloFieldMixin):
    path = 'list'


class Member(TrelloReadonlyResource, TrelloFieldMixin):
    path = 'member'


class MemberCreator(TrelloReadonlyResource, TrelloFieldMixin):
    path = 'memberCreator'


class Organization(TrelloReadonlyResource, TrelloFieldMixin):
    path = 'organization'


class Action(TrelloResource, TrelloFieldMixin):
    path = 'actions'

    @base.apimethod
    def get(self, fields=None, entities=None, member=None, member_fields=None,
            memberCreator=None, memberCreator_fields=None):
        """
        Fetch a single object.

        Upstream documentation:
        https://trello.com/docs/api/action/index.html#get-1-actions-idaction
        """
        self.require_item()

        params = base.get_params(
            None, locals(), serialize_param=serialize_param)
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json


    @base.resource(Board)
    def board(self):
        """
        Returns a single board
        """
        return Board(self)

    @base.resource(Card)
    def card(self):
        """
        Returns a single card
        """
        return Card(self)

    @base.resource(List)
    def list(self):
        """
        Returns a single list
        """
        return List(self)

    @base.resource(Member)
    def member(self):
        """
        Returns a single member
        """
        return Member(self)

    @base.resource(MemberCreator)
    def creator(self):
        """
        Returns a single creator
        """
        return MemberCreator(self)

    @base.resource(Organization)
    def organization(self):
        """
        Returns a single organization
        """
        return Organization(self)

########NEW FILE########
__FILENAME__ = boards
from libsaas import http, parsers
from libsaas.services import base

from .resource import (
    serialize_param, TrelloFieldMixin, TrelloFilterMixin,
    TrelloResource, TrelloCollection,
    TrelloReadonlyResource, TrelloReadonlyCollection)


class Actions(TrelloReadonlyCollection):
    path = 'actions'


class Card(TrelloReadonlyResource):
    path = 'cards'


class Cards(TrelloReadonlyCollection, TrelloFilterMixin):
    path = 'cards'


class Checklists(TrelloCollection):
    path = 'checklists'


class Lists(TrelloCollection, TrelloFilterMixin):
    path = 'lists'


class Members(TrelloReadonlyCollection, TrelloFilterMixin):
    path = 'members'


class Member(TrelloResource):
    path = 'members'

    def get(self, *args, **kwargs):
        raise base.MethodNotSupported()


class MembersInvited(TrelloReadonlyResource, TrelloFieldMixin):
    path = 'membersInvited'


class Memberships(TrelloReadonlyCollection):
    path = 'memberships'


class Membership(TrelloResource):
    path = 'memberships'

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Organization(TrelloReadonlyResource, TrelloFieldMixin):
    path = 'organization'


class Board(TrelloResource, TrelloFieldMixin):
    path = 'boards'

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.apimethod
    def get(self, **kwargs):
        """
        Fetch a single object.

        Upstream documentation:
        https://trello.com/docs/api/board/index.html#get-1-boards-board-id
        """
        params = base.get_params(None, kwargs, serialize_param=serialize_param)
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

    @base.apimethod
    def calendar_key(self):
        """
        Generates a calendar key.
        """
        url = '{0}/calendarKey/generate'.format(self.get_url())
        request = http.Request('POST', url)
        return request, parsers.parse_json

    @base.apimethod
    def email_key(self):
        """
        Generates a email key.
        """
        url = '{0}/emailKey/generate'.format(self.get_url())
        request = http.Request('POST', url)
        return request, parsers.parse_json

    @base.apimethod
    def mark_as_viewed(self):
        """
        Marks board as viewed.
        """
        url = '{0}/markAsViewed'.format(self.get_url())
        request = http.Request('POST', url)
        return request, parsers.parse_json

    @base.resource(Actions)
    def actions(self):
        """
        Returns all actions
        """
        return Actions(self)

    @base.resource(Card)
    def card(self, card_id):
        """
        Returns a single card
        """
        return Card(self, card_id)

    @base.resource(Cards)
    def cards(self):
        """
        Returns all cards
        """
        return Cards(self)

    @base.resource(Checklists)
    def checklists(self):
        """
        Returns all checklists
        """
        return Checklists(self)

    @base.resource(Lists)
    def lists(self):
        """
        Returns all lists
        """
        return Lists(self)

    @base.resource(Members)
    def members(self):
        """
        Returns all members
        """
        return Members(self)

    @base.resource(Member)
    def member(self, member_id):
        """
        Returns a single member
        """
        return Member(self, member_id)

    @base.resource(MembersInvited)
    def members_invited(self):
        """
        Returns all invited members
        """
        return MembersInvited(self)

    @base.resource(Memberships)
    def memberships(self):
        """
        Returns all memberships
        """
        return Memberships(self)

    @base.resource(Membership)
    def membership(self, membership_id):
        """
        Returns a single membership
        """
        return Membership(self, membership_id)

    @base.resource(Organization)
    def organization(self):
        """
        Returns a single organization
        """
        return Organization(self)


class Boards(TrelloCollection):
    path = 'boards'

    def get(self, *args, **kwargs):
        raise base.MethodNotSupported()

########NEW FILE########
__FILENAME__ = cards
from libsaas import http, parsers, port
from libsaas.services import base

from .resource import (
    serialize_param, TrelloFieldMixin,
    TrelloResource, TrelloCollection,
    TrelloReadonlyResource, TrelloReadonlyCollection)


class Comments(TrelloCollection):
    path = 'comments'

    def get(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.apimethod
    def update(self, obj):
        request = http.Request('PUT', self.get_url(), self.wrap_object(obj))
        return request, parsers.parse_json

    @base.apimethod
    def delete(self):
        request = http.Request('DELETE', self.get_url())
        return request, parsers.parse_empty


class Actions(TrelloReadonlyCollection):
    path = 'actions'

    @base.resource(Comments)
    def comments(self):
        """
        Returns all comments
        """
        return Comments(self)


class Attachments(TrelloCollection):
    path = 'attachments'


class Attachment(TrelloResource):
    path = 'attachments'

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Board(TrelloReadonlyResource, TrelloFieldMixin):
    path = 'board'


class CheckItemStates(TrelloReadonlyCollection):
    path = 'checkItemStates'


class CheckItems(TrelloCollection):
    path = 'checkItem'

    def get(self, *args, **kwargs):
        raise base.MethodNotSupported()


class CheckItem(TrelloResource):
    path = 'checkItem'

    def get(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.apimethod
    def convert_to_card(self):
        """
        Converts checkitem to card.
        """
        url = '{0}/convertToCard'.format(self.get_url())
        request = http.Request('POST', url)
        return request, parsers.parse_json


class Checklists(TrelloCollection):
    path = 'checklists'


class Checklist(TrelloReadonlyResource):
    path = 'checklist'

    def get(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.resource(CheckItems)
    def checkitems(self):
        """
        Returns all checkitems
        """
        return CheckItems(self)

    @base.resource(CheckItem)
    def checkitem(self, checkitem_id):
        """
        Returns a single checkitem
        """
        return CheckItem(self, checkitem_id)


class List(TrelloReadonlyResource, TrelloFieldMixin):
    path = 'list'


class Members(TrelloReadonlyCollection):
    path = 'members'


class MembersVoted(TrelloCollection):
    path = 'membersVoted'


class Stickers(TrelloCollection):
    path = 'stickers'


class Sticker(TrelloResource):
    path = 'stickers'


class Labels(TrelloCollection):
    path = 'labels'

    def get(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Label(TrelloResource):
    path = 'labels'

    def get(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Card(TrelloResource, TrelloFieldMixin):
    path = 'cards'

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.apimethod
    def get(self, **kwargs):
        params = base.get_params(None, kwargs, serialize_param=serialize_param)
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

    @base.apimethod
    def mark_as_read(self):
        """
        Marks associated notification as read.
        """
        url = '{0}/markAssociatedNotificationsRead'.format(self.get_url())
        request = http.Request('POST', url)
        return request, parsers.parse_json

    @base.resource(Actions)
    def actions(self):
        """
        Returns all actions
        """
        return Actions(self)

    @base.resource(Attachments)
    def attachments(self):
        """
        Returns all attachments
        """
        return Attachments(self)

    @base.resource(Attachment)
    def attachment(self, attachment_id):
        """
        Returns a single checklist
        """
        return Attachment(self, attachment_id)

    @base.resource(Board)
    def board(self):
        """
        Returns a single board
        """
        return Board(self)

    @base.resource(CheckItemStates)
    def checkitem_states(self):
        """
        Returns all checkitem states
        """
        return CheckItemStates(self)

    @base.resource(Checklists)
    def checklists(self):
        """
        Returns all checklists
        """
        return Checklists(self)

    @base.resource(Checklist)
    def checklist(self, checklist_id):
        """
        Returns a single checklist
        """
        return Checklist(self, checklist_id)

    @base.resource(List)
    def list(self):
        """
        Returns a single list
        """
        return List(self)

    @base.resource(Members)
    def members(self):
        """
        Returns all members
        """
        return Members(self)

    @base.resource(MembersVoted)
    def members_voted(self):
        """
        Returns all voted members
        """
        return MembersVoted(self)

    @base.resource(Stickers)
    def stickers(self):
        """
        Returns all stickers
        """
        return Stickers(self)

    @base.resource(Sticker)
    def sticker(self, sticker_id):
        """
        Returns a single sticker
        """
        return Sticker(self, sticker_id)

    @base.resource(Labels)
    def labels(self):
        """
        Returns all labels
        """
        return Labels(self)

    @base.resource(Label)
    def label(self, color):
        """
        Returns a single label
        """
        return Label(self, color)


class Cards(TrelloCollection):
    path = 'cards'

    def get(self, *args, **kwargs):
        raise base.MethodNotSupported()


port.method_func(Card, 'get').__doc__ = """
Fetch a single object.

Upstream documentation:
https://trello.com/docs/api/card/index.html#get-1-cards-card-id-or-shortlink
"""

########NEW FILE########
__FILENAME__ = checklists
from libsaas import http, parsers
from libsaas.services import base

from .resource import (
    serialize_param, TrelloFieldMixin, TrelloFilterMixin,
    TrelloResource, TrelloCollection,
    TrelloReadonlyResource, TrelloReadonlyCollection)


class Board(TrelloReadonlyResource, TrelloFieldMixin):
    path = 'board'


class Cards(TrelloReadonlyCollection, TrelloFilterMixin):
    path = 'cards'


class CheckItems(TrelloCollection):
    path = 'checkItems'


class CheckItem(TrelloResource):
    path = 'checkItems'

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Checklist(TrelloResource, TrelloFieldMixin):
    path = 'checklists'

    @base.apimethod
    def get(self, **kwargs):
        """
        Fetch a single object.

        Upstream documentation:
        https://trello.com/docs/api/checklist/index.html
        """
        params = base.get_params(None, kwargs, serialize_param=serialize_param)
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

    @base.resource(Board)
    def board(self):
        """
        Returns a single board
        """
        return Board(self)

    @base.resource(Cards)
    def cards(self):
        """
        Returns all cards
        """
        return Cards(self)

    @base.resource(CheckItems)
    def checkitems(self):
        """
        Returns all checkitems
        """
        return CheckItems(self)

    @base.resource(CheckItem)
    def checkitem(self, checkitem_id):
        """
        Returns a single checkitem
        """
        return CheckItem(self, checkitem_id)


class Checklists(TrelloCollection):
    path = 'checklists'

    def get(self, *args, **kwargs):
        raise base.MethodNotSupported()

########NEW FILE########
__FILENAME__ = lists
from libsaas import http, parsers, port
from libsaas.services import base

from .resource import (
    serialize_param, TrelloFieldMixin, TrelloFilterMixin,
    TrelloResource, TrelloCollection,
    TrelloReadonlyResource, TrelloReadonlyCollection)


class Actions(TrelloReadonlyCollection):
    path = 'actions'


class Board(TrelloReadonlyResource, TrelloFieldMixin):
    path = 'board'


class Cards(TrelloReadonlyCollection, TrelloFilterMixin):
    path = 'cards'


class List(TrelloResource, TrelloFieldMixin):
    path = 'lists'

    @base.apimethod
    def get(self, **kwargs):
        """
        Fetch a single object.

        Upstream documentation:
        https://trello.com/docs/api/list/index.html
        """
        params = base.get_params(None, kwargs, serialize_param=serialize_param)
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.apimethod
    def archive_all_cards(self):
        """
        Archive all list cards.
        """
        url = '{0}/archiveAllCards'.format(self.get_url())
        request = http.Request('POST', url)
        return request, parsers.parse_json

    @base.resource(Actions)
    def actions(self):
        """
        Returns all actions
        """
        return Actions(self)

    @base.resource(Board)
    def board(self):
        """
        Returns a single board
        """
        return Board(self)

    @base.resource(Cards)
    def cards(self):
        """
        Returns all cards
        """
        return Cards(self)


class Lists(TrelloCollection):
    path = 'lists'

    def get(self, *args, **kwargs):
        raise base.MethodNotSupported()


port.method_func(List, 'get').__doc__ = """
Fetch a single object.

Upstream documentation:
https://trello.com/docs/api/list/index.html#get-1-lists-idlist
"""

########NEW FILE########
__FILENAME__ = members
from libsaas import http, parsers
from libsaas.services import base

from .resource import (
    serialize_param, TrelloFieldMixin, TrelloFilterMixin,
    TrelloResource, TrelloCollection, TrelloReadonlyCollection)


class Actions(TrelloReadonlyCollection):
    path = 'actions'


class BoardBackgrounds(TrelloCollection):
    path = 'boardBackgrounds'


class BoardBackground(TrelloResource):
    path = 'boardBackgrounds'


class BoardStars(TrelloCollection):
    path = 'boardStars'

    @base.apimethod
    def get(self):
        request = http.Request('GET', self.get_url())

        return request, parsers.parse_json


class BoardStar(TrelloResource):
    path = 'boardStars'

    def get(self, *args, **kwargs):
        raise base.MethodNotSupported()


class CustomBoardBackgrounds(TrelloCollection):
    path = 'customBoardBackgrounds'


class CustomBoardBackground(TrelloResource):
    path = 'customBoardBackgrounds'


class CustomStickers(TrelloCollection):
    path = 'customStickers'


class CustomSticker(TrelloResource):
    path = 'customStickers'

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Boards(TrelloReadonlyCollection, TrelloFilterMixin):
    path = 'boards'


class Cards(TrelloReadonlyCollection, TrelloFilterMixin):
    path = 'cards'


class Notifications(TrelloReadonlyCollection, TrelloFilterMixin):
    path = 'notifications'


class Organizations(TrelloReadonlyCollection, TrelloFilterMixin):
    path = 'organizations'


class Sessions(TrelloReadonlyCollection):
    path = 'sessions'


class Tokens(TrelloReadonlyCollection):
    path = 'tokens'


class Member(TrelloResource, TrelloFieldMixin):
    path = 'members'

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.apimethod
    def get(self, **kwargs):
        """
        Fetch a single object.

        Upstream documentation:
        https://trello.com/docs/api/member/index.html
        """
        params = base.get_params(None, kwargs, serialize_param=serialize_param)
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

    @base.resource(Actions)
    def actions(self):
        """
        Returns all actions
        """
        return Actions(self)

    @base.resource(BoardBackgrounds)
    def board_backgrounds(self):
        """
        Returns all board backgrounds
        """
        return BoardBackgrounds(self)

    @base.resource(BoardBackgrounds)
    def board_background(self, board_background_id):
        """
        Returns a single board background
        """
        return BoardBackground(self, board_background_id)

    @base.resource(BoardStars)
    def board_stars(self):
        """
        Returns all board stars
        """
        return BoardStars(self)

    @base.resource(BoardStar)
    def board_star(self, board_star_id):
        """
        Returns a single board star
        """
        return BoardStar(self, board_star_id)

    @base.resource(CustomBoardBackgrounds)
    def custom_board_backgrounds(self):
        """
        Returns all custom board backgrounds
        """
        return CustomBoardBackgrounds(self)

    @base.resource(CustomBoardBackground)
    def custom_board_background(self, board_background_id):
        """
        Returns a single custom board background
        """
        return CustomBoardBackground(self, board_background_id)

    @base.resource(CustomStickers)
    def custom_stickers(self):
        """
        Returns all custom stickers
        """
        return CustomStickers(self)

    @base.resource(CustomSticker)
    def custom_sticker(self, sticker_id):
        """
        Returns a single custom stickers
        """
        return CustomSticker(self, sticker_id)

    @base.resource(Notifications)
    def notifications(self):
        """
        Returns all notifications
        """
        return Notifications(self)

    @base.resource(Organizations)
    def organizations(self):
        """
        Returns all organizations
        """
        return Organizations(self)

    @base.resource(Boards)
    def boards(self):
        """
        Returns all boards
        """
        return Boards(self)

    @base.resource(Cards)
    def cards(self):
        """
        Returns all cards
        """
        return Cards(self)

    @base.resource(Sessions)
    def sessions(self):
        """
        Returns all sessions
        """
        return Sessions(self)

    @base.resource(Tokens)
    def tokens(self):
        """
        Returns all tokens
        """
        return Tokens(self)

########NEW FILE########
__FILENAME__ = notifications
from libsaas import http, parsers
from libsaas.services import base

from .resource import (
    serialize_param, TrelloFieldMixin, TrelloResource, TrelloReadonlyResource)


class Board(TrelloReadonlyResource, TrelloFieldMixin):
    path = 'board'


class Card(TrelloReadonlyResource, TrelloFieldMixin):
    path = 'card'


class List(TrelloReadonlyResource, TrelloFieldMixin):
    path = 'list'


class Member(TrelloReadonlyResource, TrelloFieldMixin):
    path = 'member'


class MemberCreator(TrelloReadonlyResource, TrelloFieldMixin):
    path = 'memberCreator'


class Organization(TrelloReadonlyResource, TrelloFieldMixin):
    path = 'organization'


class Notification(TrelloResource, TrelloFieldMixin):
    path = 'notifications'

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.apimethod
    def get(self, **kwargs):
        """
        Fetch a single object.

        Upstream documentation:
        https://trello.com/docs/api/notification/index.html
        """
        params = base.get_params(None, kwargs, serialize_param=serialize_param)
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

    @base.resource(Board)
    def board(self):
        """
        Returns a single board
        """
        return Board(self)

    @base.resource(Card)
    def card(self):
        """
        Returns a single card
        """
        return Card(self)

    @base.resource(List)
    def list(self):
        """
        Returns a single list
        """
        return List(self)

    @base.resource(Member)
    def member(self):
        """
        Returns a single member
        """
        return Member(self)

    @base.resource(MemberCreator)
    def creator(self):
        """
        Returns a single creator
        """
        return MemberCreator(self)

    @base.resource(Organization)
    def organization(self):
        """
        Returns a single organization
        """
        return Organization(self)

########NEW FILE########
__FILENAME__ = organizations
from libsaas import http, parsers
from libsaas.services import base

from .resource import (
    serialize_param, TrelloFieldMixin, TrelloFilterMixin,
    TrelloResource, TrelloCollection,
    TrelloReadonlyResource, TrelloReadonlyCollection)


class Actions(TrelloReadonlyCollection):
    path = 'actions'


class Boards(TrelloReadonlyCollection, TrelloFilterMixin):
    path = 'boards'


class Members(TrelloReadonlyCollection, TrelloFilterMixin):
    path = 'members'


class Member(TrelloResource):
    path = 'members'

    def get(self, *args, **kwargs):
        raise base.MethodNotSupported()


class MembersInvited(TrelloReadonlyResource, TrelloFieldMixin):
    path = 'membersInvited'


class Memberships(TrelloReadonlyCollection):
    path = 'memberships'


class Membership(TrelloResource):
    path = 'memberships'


class Organization(TrelloResource, TrelloFieldMixin):
    path = 'organizations'

    @base.apimethod
    def get(self, **kwargs):
        """
        Fetch a single object.

        Upstream documentation:
        https://trello.com/docs/api/organization/index.html
        """
        params = base.get_params(None, kwargs, serialize_param=serialize_param)
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

    @base.resource(Actions)
    def actions(self):
        """
        Returns all actions
        """
        return Actions(self)

    @base.resource(Boards)
    def boards(self):
        """
        Returns all boards
        """
        return Boards(self)

    @base.resource(Members)
    def members(self):
        """
        Returns all members
        """
        return Members(self)

    @base.resource(Member)
    def member(self, member_id):
        """
        Returns a single member
        """
        return Member(self, member_id)

    @base.resource(MembersInvited)
    def members_invited(self):
        """
        Returns all invited members
        """
        return MembersInvited(self)

    @base.resource(Memberships)
    def memberships(self):
        """
        Returns all memberships
        """
        return Memberships(self)

    @base.resource(Membership)
    def membership(self, membership_id):
        """
        Returns a single membership
        """
        return Membership(self, membership_id)


class Organizations(TrelloCollection):
    path = 'organizations'

    def get(self, *args, **kwargs):
        raise base.MethodNotSupported()

########NEW FILE########
__FILENAME__ = resource
from libsaas import http, parsers
from libsaas.services import base


def serialize_param(val):
    if isinstance(val, bool):
        return 'true' if val else 'false'
    elif isinstance(val, list):
        return ','.join(val)

    return val


class TrelloFieldMixin(object):

    @base.apimethod
    def field(self, field):
        """
        Returns a single resource field.

        :var field: a valid resource's field.
        :vartype field: str
        """
        url = '{0}/{1}'.format(self.get_url(), field)
        request = http.Request('GET', url)
        return request, parsers.parse_json

class TrelloFilterMixin(object):

    @base.apimethod
    def filter(self, filter_id):
        """
        Fetch a collection filtered.

        :var filter: a valid resource's filter.
        :vartype filter: str
        """
        self.require_collection()
        url = '{0}/{1}'.format(self.get_url(), filter_id)
        request = http.Request('GET', url)

        return request, parsers.parse_json


class TrelloResource(base.RESTResource):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.apimethod
    def get(self, fields=None):
        """
        Fetch a single object.

        :var fields: all or comma-separated list of fields.
        :vartype fields: list
        """
        params = base.get_params(
            None, locals(), serialize_param=serialize_param)
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json


class TrelloReadonlyResource(TrelloResource):

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class TrelloCollection(base.RESTResource):

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.apimethod
    def get(self, **kwargs):
        """
        Fetch a collection.

        Upstream documentation: https://trello.com/docs/api/
        """
        params = base.get_params(None, kwargs, serialize_param=serialize_param)
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json


class TrelloReadonlyCollection(TrelloCollection):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

########NEW FILE########
__FILENAME__ = service
import json

from libsaas import http
from libsaas.services import base

from .members import Member
from .actions import Action
from .cards import Card, Cards
from .lists import List, Lists
from .boards import Board, Boards
from .notifications import Notification
from .checklists import Checklist, Checklists
from .organizations import Organization, Organizations


class Trello(base.Resource):
    """
    """
    def __init__(self, key, token=None):
        """
        Create a Trello service.

        :var key: Your application key
        :vartype key: str
        :var token: The authorization token from the user (optional).
        :vartype token: str
        """
        self.apiroot = 'https://api.trello.com/1'
        self.key = key
        self.token = token
        self.add_filter(self.add_auth)
        self.add_filter(self.use_json)

    def get_url(self):
        return self.apiroot

    def add_auth(self, request):
        params = {'key': self.key}

        if self.token:
            params.update({'token': self.token})

        if request.method.upper() in http.URLENCODE_METHODS:
            request.params.update(params)
        else:
            request.params = json.dumps(request.params)
            request.uri += '?' + http.urlencode_any(params)

    def use_json(self, request):
        if request.method.upper() not in http.URLENCODE_METHODS:
            request.headers['Content-Type'] = 'application/json'

    @base.resource(Action)
    def action(self, action_id):
        """
        Return the resource corresponding to a single action.
        """
        return Action(self, action_id)

    @base.resource(Boards)
    def boards(self):
        """
        Return the resource corresponding to all boards
        """
        return Boards(self)

    @base.resource(Board)
    def board(self, board_id):
        """
        Return the resource corresponding to a single board
        """
        return Board(self, board_id)

    @base.resource(Cards)
    def cards(self):
        """
        Return the resource corresponding to all cards
        """
        return Cards(self)

    @base.resource(Card)
    def card(self, card_id_or_shortlink):
        """
        Return the resource corresponding to a single card
        """
        return Card(self, card_id_or_shortlink)

    @base.resource(Checklists)
    def checklists(self):
        """
        Return the resource corresponding to all checklists
        """
        return Checklists(self)

    @base.resource(Checklist)
    def checklist(self, checklist_id):
        """
        Return the resource corresponding to a single checklist
        """
        return Checklist(self, checklist_id)

    @base.resource(Lists)
    def lists(self):
        """
        Return the resource corresponding to all lists
        """
        return Lists(self)

    @base.resource(List)
    def list(self, list_id):
        """
        Return the resource corresponding to a single list
        """
        return List(self, list_id)

    @base.resource(Member)
    def me(self):
        """
        Return the resource corresponding to the current member
        """
        return Member(self, 'me')

    @base.resource(Member)
    def member(self, member_id_or_username):
        """
        Return the resource corresponding to a single member
        """
        return Member(self, member_id_or_username)

    @base.resource(Notification)
    def notification(self, notification_id):
        """
        Return the resource corresponding to a single notification
        """
        return Notification(self, notification_id)

    @base.resource(Organizations)
    def organizations(self):
        """
        Return the resource corresponding to all organizations
        """
        return Organizations(self)

    @base.resource(Organization)
    def organization(self, organization_id_or_name):
        """
        Return the resource corresponding to a single organization
        """
        return Organization(self, organization_id_or_name)

########NEW FILE########
__FILENAME__ = accounts
from libsaas import http, parsers
from libsaas.services import base

from libsaas.services.twilio import resource
from libsaas.services.twilio import (
    applications, calls, conferences, notifications, numbers, queues,
    recordings, sms, usage)


class AccountsBase(resource.TwilioResource):

    path = 'Accounts'

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Account(AccountsBase):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.resource(numbers.AvailablePhoneNumbers)
    def available_phone_numbers(self):
        """
        Return an AvailablePhoneNumbers resource that allows querying
        local and toll-free available for this account.
        """
        return numbers.AvailablePhoneNumbers(self)

    @base.resource(numbers.OutgoingCallerId)
    def outgoing_caller_id(self, sid):
        """
        Return an OutgoingCallerId resource representation,
        representing a Caller ID number valid for this account.
        """
        return numbers.OutgoingCallerId(self, sid)

    @base.resource(numbers.OutgoingCallerIds)
    def outgoing_caller_ids(self):
        """
        Return a list of OutgoingCallerId resource representations,
        each representing a Caller ID number valid for this account.
        """
        return numbers.OutgoingCallerIds(self)

    @base.resource(numbers.IncomingPhoneNumber)
    def incoming_phone_number(self, sid):
        """
        Return an IncomingPhoneNumber resource representation,
        representing a phone number given to this account.
        """
        return numbers.IncomingPhoneNumber(self, sid)

    @base.resource(numbers.IncomingPhoneNumbers)
    def incoming_phone_numbers(self):
        """
        Return a list of IncomingPhoneNumber resource representations,
        each representing a phone number given to this account.
        """
        return numbers.IncomingPhoneNumbers(self)

    @base.resource(applications.ConnectApp)
    def connect_app(self, sid):
        """
        Return a Connect App resource representations,
        representing a Connect App in this account.
        """
        return applications.ConnectApp(self, sid)

    @base.resource(applications.ConnectApps)
    def connect_apps(self):
        """
        Return a list of Connect App resource representations,
        each representing a Connect App in this account.
        """
        return applications.ConnectApps(self)

    @base.resource(applications.AuthorizedConnectApp)
    def authorized_connect_app(self, sid):
        """
        Return a Connect App resource representation,
        representing a Connect App you've authorized to access this account.
        """
        return applications.AuthorizedConnectApp(self, sid)

    @base.resource(applications.AuthorizedConnectApps)
    def authorized_connect_apps(self):
        """
        Return a list of Connect App resource representations,
        each representing a Connect App you've authorized to access
        this account.
        """
        return applications.AuthorizedConnectApps(self)

    @base.resource(applications.Application)
    def application(self, sid):
        """
        Return a Application resource representation,
        representing an application within this account.
        """
        return applications.Application(self, sid)

    @base.resource(applications.Applications)
    def applications(self):
        """
        Return a list of Application resource representations,
        each representing an application within this account.
        """
        return applications.Applications(self)

    @base.resource(calls.Call)
    def call(self, sid):
        """
        Return a phone call made to and from this account.
        """
        return calls.Call(self, sid)

    @base.resource(calls.Calls)
    def calls(self):
        """
        Return a list of phone calls made to and from this account.
        """
        return calls.Calls(self)

    @base.resource(conferences.Conference)
    def conference(self, sid):
        """
        Return a conference within this account.
        """
        return conferences.Conference(self, sid)

    @base.resource(conferences.Conferences)
    def conferences(self):
        """
        Return a list of conferences within this account.
        """
        return conferences.Conferences(self)

    @base.resource(queues.Queue)
    def queue(self, sid):
        """
        Return a queue within this account.
        """
        return queues.Queue(self, sid)

    @base.resource(queues.Queues)
    def queues(self):
        """
        Return a list of queues within this account.
        """
        return queues.Queues(self)

    @base.resource(sms.SMS)
    def sms(self):
        """
        Return a SMS resource to query messages and short codes resources.
        """
        return sms.SMS(self)

    @base.resource(recordings.Transcription)
    def transcription(self, sid):
        """
        Return a Transcription resource representation for call
        made to of from this account.
        """
        return recordings.Transcription(self, sid)

    @base.resource(recordings.Transcriptions)
    def transcriptions(self):
        """
        Return a set of Transcription resource representations
        for this account.
        """
        return recordings.Transcriptions(self)

    @base.resource(recordings.Recording)
    def recording(self, sid):
        """
        Return a Recording resource representation,
        representing a recording generated during the course
        of a phone call made to or from this account.
        """
        return recordings.Recording(self, sid)

    @base.resource(recordings.Recordings)
    def recordings(self):
        """
        Return a list of Recording resource representations,
        each representing a recording generated during the course
        of a phone call made to or from this account.
        """
        return recordings.Recordings(self)

    @base.resource(notifications.Notification)
    def notification(self, sid):
        """
        Return a notification generated for this account.
        """
        return notifications.Notification(self, sid)

    @base.resource(notifications.Notifications)
    def notifications(self):
        """
        Return a list of notifications generated for this account.
        """
        return notifications.Notifications(self)

    @base.resource(usage.Usage)
    def usage(self):
        """
        Return a usage resource to query records and triggers resources.
        """
        return usage.Usage(self)


class Accounts(AccountsBase):

    @base.apimethod
    def get(self, FriendlyName=None, Status=None,
            Page=None, PageSize=None, AfterSid=None):
        """
        Fetch the (sub)accounts belonging to this account.

        :var FriendlyName: Only return the Account resources with friendly
            names that exactly match this name.
        :vartype FriendlyName: str

        :var Status: Only return Account resources with the given status.
            Can be `closed`, `suspended` or `active`.
        :vartype Status: str

        :var Page: The current page number. Zero-indexed, so the first page
            is 0.
        :vartype Page: int

        :var PageSize: How many resources to return in each list page.
            The default is 50, and the maximum is 1000.
        :vartype PageSize: int

        :var AfterSid: The last Sid returned in the previous page, used to
            avoid listing duplicated resources if new ones are created while
            paging.
        :vartype AfterSid: str
        """
        params = resource.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

########NEW FILE########
__FILENAME__ = applications
from libsaas import http, parsers
from libsaas.services import base

from libsaas.services.twilio import resource


class ApplicationsBase(resource.TwilioResource):

    path = 'Applications'


class Application(ApplicationsBase):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Applications(ApplicationsBase):

    @base.apimethod
    def get(self, FriendlyName=None, Page=None, PageSize=None, AfterSid=None):
        """
        Fetch the Applications belonging to an account.

        :var FriendlyName: Only return the Account resources with friendly
            names that exactly match this name.
        :vartype FriendlyName: str

        :var Page: The current page number. Zero-indexed, so the first page
            is 0.
        :vartype Page: int

        :var PageSize: How many resources to return in each list page.
            The default is 50, and the maximum is 1000.
        :vartype PageSize: int

        :var AfterSid: The last Sid returned in the previous page, used to
            avoid listing duplicated resources if new ones are created while
            paging.
        :vartype AfterSid: str
        """
        params = resource.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class ConnectAppsBase(resource.TwilioResource):

    path = 'ConnectApps'

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class ConnectApp(ConnectAppsBase):

    pass


class ConnectApps(ConnectAppsBase):

    @base.apimethod
    def get(self, Page=None, PageSize=None, AfterSid=None):
        """
        Fetch the Connect Apps belonging to an account.

        :var Page: The current page number. Zero-indexed, so the first page
            is 0.
        :vartype Page: int

        :var PageSize: How many resources to return in each list page.
            The default is 50, and the maximum is 1000.
        :vartype PageSize: int

        :var AfterSid: The last Sid returned in the previous page, used to
            avoid listing duplicated resources if new ones are created while
            paging.
        :vartype AfterSid: str
        """
        params = resource.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()


class AuthorizedConnectAppsBase(resource.TwilioResource):

    path = 'AuthorizedConnectApps'

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class AuthorizedConnectApp(AuthorizedConnectAppsBase):

    pass


class AuthorizedConnectApps(AuthorizedConnectAppsBase):

    @base.apimethod
    def get(self, Page=None, PageSize=None, AfterSid=None):
        """
        Fetch the Authorized Connect Apps belonging to an account.

        :var Page: The current page number. Zero-indexed, so the first page
            is 0.
        :vartype Page: int

        :var PageSize: How many resources to return in each list page.
            The default is 50, and the maximum is 1000.
        :vartype PageSize: int

        :var AfterSid: The last Sid returned in the previous page, used to
            avoid listing duplicated resources if new ones are created while
            paging.
        :vartype AfterSid: str
        """
        params = resource.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

########NEW FILE########
__FILENAME__ = calls
from libsaas import http, parsers
from libsaas.services import base

from libsaas.services.twilio import resource, notifications, recordings


class CallsBase(resource.TwilioResource):

    path = 'Calls'

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Call(CallsBase):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.resource(notifications.Notifications)
    def notifications(self):
        """
        Return a list of notifications generated for this call.
        """
        return notifications.Notifications(self)

    @base.resource(recordings.Recordings)
    def recordings(self):
        """
        Return a list of Recording resource representations,
        each representing a recording generated during the course
        of this phone call.
        """
        return recordings.Recordings(self)


class Calls(CallsBase):

    @base.apimethod
    def get(self, To=None, From=None, Status=None, StartTime=None,
            StartTimeGT=None, StartTimeLT=None, ParentCallSid=None,
            Page=None, PageSize=None, AfterSid=None):
        """
        Fetch the calls made to or from an account.

        :var To: Only show calls to this phone number or Client identifier.
        :vartype To: str

        :var From: Only show calls from this phone number or Client identifier.
        :vartype From: str

        :var Status: Only show calls currently in this status.
            May be `queued`, `ringing`, `in-progress`, `completed`, `failed`,
            `busy` or `no-answer`.
        :vartype Status: str

        :var StartTime: Only show calls that started on this date,
            given as YYYY-MM-DD.
        :vartype StartTime: str

        :var StartTimeGT: Greater than inequality for StartTime,
            use it for calls that started at or after midnight on a date
            (generates StartTime>=YYYY-MM-DD).
        :vartype StartTimeGT: str

        :var StartTimeLT: Lower than inequality for StartTime,
            use it for calls that started at or before midnight on a date
            (generates StartTime<=YYYY-MM-DD).
        :vartype StartTimeGT: str

        :var ParentCallSid: Only show calls spawned by the call with this Sid.
        :vartype ParentCallSid: str

        :var Page: The current page number. Zero-indexed, so the first page
            is 0.
        :vartype Page: int

        :var PageSize: How many resources to return in each list page.
            The default is 50, and the maximum is 1000.
        :vartype PageSize: int

        :var AfterSid: The last Sid returned in the previous page, used to
            avoid listing duplicated resources if new ones are created while
            paging.
        :vartype AfterSid: str
        """
        params = resource.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

########NEW FILE########
__FILENAME__ = conferences
from libsaas import http, parsers
from libsaas.services import base

from libsaas.services.twilio import resource


class ParticipantsBase(resource.TwilioResource):

    path = 'Participants'

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Participant(ParticipantsBase):

    pass


class Participants(ParticipantsBase):

    @base.apimethod
    def get(self, Muted=None, Page=None, PageSize=None, AfterSid=None):
        """
        Fetch the participants of a conference.

        :var Muted: Only show participants that are muted or unmuted.
            Either `True` or `False`.
        :vartype Muted: bool

        :var Page: The current page number. Zero-indexed, so the first page
            is 0.
        :vartype Page: int

        :var PageSize: How many resources to return in each list page.
            The default is 50, and the maximum is 1000.
        :vartype PageSize: int

        :var AfterSid: The last Sid returned in the previous page, used to
            avoid listing duplicated resources if new ones are created while
            paging.
        :vartype AfterSid: str
        """
        params = resource.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class ConferencesBase(resource.TwilioResource):

    path = 'Conferences'

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Conference(ConferencesBase):

    @base.resource(Participants)
    def participants(self):
        """
        Return the list of participants in this conference.
        """
        return Participants(self)

    @base.resource(Participant)
    def participant(self, sid):
        """
        Return a participant in this conference.
        """
        return Participant(self, sid)


class Conferences(ConferencesBase):

    @base.apimethod
    def get(self, Status=None, FriendlyName=None,
            DateCreated=None, DateCreatedGT=None, DateCreatedLT=None,
            DateUpdated=None, DateUpdatedGT=None, DateUpdatedLT=None,
            Page=None, PageSize=None, AfterSid=None):
        """
        Fetch the calls made to or from an account.

        :var Status: Only show conferences currently in with this status.
            May be `init`, `in-progress`, or `completed`.
        :vartype Status: str

        :var FriendlyName: List conferences who's FriendlyName is the exact
            match of this string.
        :vartype FriendlyName: str

        :var DateCreated: Only show conferences that started on this date,
            given as YYYY-MM-DD.
        :vartype DateCreated: str

        :var DateCreatedGT: Greater than inequality for DateCreated,
            use it for conferences that started at or after midnight on a date
            (generates DateCreated>=YYYY-MM-DD).
        :vartype DateCreatedGT: str

        :var DateCreatedLT: Lower than inequality for DateCreated,
            use it for conferences that started at or before midnight on a date
            (generates DateCreated<=YYYY-MM-DD).
        :vartype DateCreatedGT: str

        :var DateUpdated: Only show conferences that were last updated on
            this date, given as YYYY-MM-DD.
        :vartype DateUpdated: str

        :var DateUpdatedGT: Greater than inequality for DateUpdated,
            use it for conferences that were last updated at or after midnight
            on a date (generates DateUpdated>=YYYY-MM-DD).
        :vartype DateUpdatedGT: str

        :var DateUpdatedLT: Lower than inequality for DateUpdated,
            use it for conferences that were last updated at or before midnight
            on a date (generates DateUpdated<=YYYY-MM-DD).
        :vartype DateUpdatedGT: str

        :var Page: The current page number. Zero-indexed, so the first page
            is 0.
        :vartype Page: int

        :var PageSize: How many resources to return in each list page.
            The default is 50, and the maximum is 1000.
        :vartype PageSize: int

        :var AfterSid: The last Sid returned in the previous page, used to
            avoid listing duplicated resources if new ones are created while
            paging.
        :vartype AfterSid: str
        """
        params = resource.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

########NEW FILE########
__FILENAME__ = notifications
from libsaas import http, parsers
from libsaas.services import base

from libsaas.services.twilio import resource


class NotificationsBase(resource.TwilioResource):

    path = 'Notifications'

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Notification(NotificationsBase):

    pass


class Notifications(NotificationsBase):

    @base.apimethod
    def get(self, Log=None, MessageDate=None, MessageDateGT=None,
            MessageDateLT=None, Page=None, PageSize=None, AfterSid=None):
        """
        Fetch notifications for an account or call.

        :var Log: Only show notifications for this log, using the integer
            log values.
        :vartype Log: int

        :var MessageDate: Only show notifications for this date, given
            as YYYY-MM-DD.
        :vartype MessageDate: str

        :var MessageDateGT: Greater than inequality for MessageDate,
            use it for messages logged at or after midnight on a date
            (generates MessageDate>=YYYY-MM-DD).
        :vartype MessageDateGT: str

        :var MessageDateLT: Lower than inequality for MessageDate,
            use it for messages logged at or before midnight on a date
            (generates MessageDate<=YYYY-MM-DD).
        :vartype MessageDateGT: str

        :var Page: The current page number. Zero-indexed, so the first page
            is 0.
        :vartype Page: int

        :var PageSize: How many resources to return in each list page.
            The default is 50, and the maximum is 1000.
        :vartype PageSize: int

        :var AfterSid: The last Sid returned in the previous page, used to
            avoid listing duplicated resources if new ones are created while
            paging.
        :vartype AfterSid: str
        """
        params = resource.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()

########NEW FILE########
__FILENAME__ = numbers
from libsaas import http, parsers
from libsaas.services import base

from libsaas.services.twilio import resource


class AvailablePhoneNumbersBase(resource.TwilioResource):

    path = '{0}'

    def get_url(self):
        path = self.path.format(self.object_id)
        return '{0}/{1}'.format(self.parent.get_url(), path)

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class AvailablePhoneNumbersLocal(AvailablePhoneNumbersBase):

    path = '{0}/Local'

    @base.apimethod
    def get(self, AreaCode=None, Contains=None, InRegion=None,
            InPostalCode=None, NearLatLong=None, NearNumber=None, InLata=None,
            InRateCenter=None, Distance=None):
        """
        Fetch available local phone numbers for an account.

        :var AreaCode: Find phone numbers in the specified area code.
        :vartype AreaCode: str

        :var Contains: A pattern to match phone numbers on.
            Valid characters are `*` and [0-9a-zA-Z].
            The `*` character will match any single digit.
        :vartype Contains: str

        :var InRegion: Limit results to a particular region (State/Province).
            Given a phone number, search within the same Region as that number.
            (US and Canada only)
        :vartype InRegion: str

        :var InPostalCode: Limit results to a particular postal code.
            Given a phone number, search within the same postal code as
            that number. (US and Canada only)
        :vartype InPostalCode: str

        :var NearLatLong: Given a latitude/longitude pair lat,long find
            geographically close numbers within Distance miles.
            (US and Canada only)
        :vartype NearLatLong: str

        :var NearNumber: Given a phone number, find a geographically close
            number within Distance miles. Distance defaults to 25 miles.
            (US and Canada only)
        :vartype NearNumber: str

        :var InLata: Limit results to a specific Local access and transport
            area (LATA). Given a phone number, search within the same LATA
            as that number.
            (US and Canada only)
        :vartype InLata: str

        :var InRateCenter: Limit results to a specific rate center,
            or given a phone number search within the same rate center as
            that number. Requires InLata to be set as well.
            (US and Canada only)
        :vartype InRateCenter: str

        :var InDistance: Specifies the search radius for a Near- query in miles.
            If not specified this defaults to 25 miles.
            (US and Canada only)
        :vartype InDistance: int
        """
        params = resource.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json


class AvailablePhoneNumbersTollFree(AvailablePhoneNumbersBase):

    path = '{0}/TollFree'

    @base.apimethod
    def get(self, AreaCode=None, Contains=None):
        """
        Fetch available toll-free phone numbers for an account.

        :var AreaCode: Find phone numbers in the specified area code.
        :vartype AreaCode: str

        :var Contains: A pattern to match phone numbers on.
            Valid characters are `*` and [0-9a-zA-Z].
            The `*` character will match any single digit.
        :vartype Contains: str
        """
        params = resource.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json


class AvailablePhoneNumbers(AvailablePhoneNumbersBase):

    path = 'AvailablePhoneNumbers'

    def get(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.resource(AvailablePhoneNumbersLocal)
    def local(self, country_code):
        """
        Return a list of local AvailablePhoneNumber resource representations
        that match the specified filters, each representing a phone number
        that is currently available for provisioning within this account.
        """
        return AvailablePhoneNumbersLocal(self, country_code)

    @base.resource(AvailablePhoneNumbersTollFree)
    def toll_free(self, country_code):
        """
        Return a list of toll-free AvailablePhoneNumber resource
        representations that match the specified filters, each representing
        a phone number that is currently available for provisioning within
        this account.
        """
        return AvailablePhoneNumbersTollFree(self, country_code)


class IncomingPhoneNumbersBase(resource.TwilioResource):

    path = 'IncomingPhoneNumbers'


class IncomingPhoneNumber(IncomingPhoneNumbersBase):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()


class IncomingPhoneNumbersMixin(IncomingPhoneNumbersBase):

    @base.apimethod
    def get(self, PhoneNumber=None, FriendlyName=None,
            Page=None, PageSize=None, AfterSid=None):
        """
        Fetch incoming phone numbers list for an account.

        :var PhoneNumber: Only show the incoming phone number resources
            that match this pattern. You can specify partial numbers and
            use `*` as a wildcard for any digit.
        :vartype PhoneNumber: str

        :var FriendlyName: Only show the incoming phone number resources
            with friendly names that exactly match this name.
        :vartype FriendlyName: str

        :var Page: The current page number. Zero-indexed, so the first page
            is 0.
        :vartype Page: int

        :var PageSize: How many resources to return in each list page.
            The default is 50, and the maximum is 1000.
        :vartype PageSize: int

        :var AfterSid: The last Sid returned in the previous page, used to
            avoid listing duplicated resources if new ones are created while
            paging.
        :vartype AfterSid: str
        """
        params = resource.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class IncomingPhoneNumbersLocal(IncomingPhoneNumbersMixin):

    path = 'Local'


class IncomingPhoneNumbersTollFree(IncomingPhoneNumbersMixin):

    path = 'TollFree'


class IncomingPhoneNumbers(IncomingPhoneNumbersMixin):

    @base.resource(IncomingPhoneNumbersLocal)
    def local(self):
        return IncomingPhoneNumbersLocal(self)

    @base.resource(IncomingPhoneNumbersTollFree)
    def toll_free(self):
        return IncomingPhoneNumbersTollFree(self)


class OutgoingCallerIdsBase(resource.TwilioResource):

    path = 'OutgoingCallerIds'


class OutgoingCallerId(OutgoingCallerIdsBase):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()


class OutgoingCallerIds(OutgoingCallerIdsBase):

    @base.apimethod
    def get(self, PhoneNumber=None, FriendlyName=None,
            Page=None, PageSize=None, AfterSid=None):
        """
        Fetch outgoing caller ids for an account.

        :var PhoneNumber: Only show the incoming phone number resources
            that match this pattern. You can specify partial numbers and
            use `*` as a wildcard for any digit.
        :vartype PhoneNumber: str

        :var FriendlyName: Only show the incoming phone number resources
            with friendly names that exactly match this name.
        :vartype FriendlyName: str

        :var Page: The current page number. Zero-indexed, so the first page
            is 0.
        :vartype Page: int

        :var PageSize: How many resources to return in each list page.
            The default is 50, and the maximum is 1000.
        :vartype PageSize: int

        :var AfterSid: The last Sid returned in the previous page, used to
            avoid listing duplicated resources if new ones are created while
            paging.
        :vartype AfterSid: str
        """
        params = resource.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()

########NEW FILE########
__FILENAME__ = queues
from libsaas import http, parsers
from libsaas.services import base

from libsaas.services.twilio import resource


class MembersBase(resource.TwilioResource):

    path = 'Members'

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Member(MembersBase):

    pass


class Members(MembersBase):

    @base.apimethod
    def get(self, Page=None, PageSize=None, AfterSid=None):
        """
        Fetch the list of members for a conference.

        :var Page: The current page number. Zero-indexed, so the first page
            is 0.
        :vartype Page: int

        :var PageSize: How many resources to return in each list page.
            The default is 50, and the maximum is 1000.
        :vartype PageSize: int

        :var AfterSid: The last Sid returned in the previous page, used to
            avoid listing duplicated resources if new ones are created while
            paging.
        :vartype AfterSid: str
        """
        params = resource.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()


class QueuesBase(resource.TwilioResource):

    path = 'Queues'


class Queue(QueuesBase):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.resource(Members)
    def members(self):
        """
        Return the list of members in this queue.
        """
        return Members(self)

    @base.resource(Member)
    def member(self, sid):
        """
        Return a member in this queue.
        """
        return Member(self, sid)


class Queues(QueuesBase):

    @base.apimethod
    def get(self, Page=None, PageSize=None, AfterSid=None):
        """
        Fetch the list of conferences of an account.

        :var Page: The current page number. Zero-indexed, so the first page
            is 0.
        :vartype Page: int

        :var PageSize: How many resources to return in each list page.
            The default is 50, and the maximum is 1000.
        :vartype PageSize: int

        :var AfterSid: The last Sid returned in the previous page, used to
            avoid listing duplicated resources if new ones are created while
            paging.
        :vartype AfterSid: str
        """
        params = resource.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()

########NEW FILE########
__FILENAME__ = recordings
from libsaas import http, parsers
from libsaas.services import base

from libsaas.services.twilio import resource


class TranscriptionsBase(resource.TwilioResource):

    path = 'Transcriptions'

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Transcription(TranscriptionsBase):

    pass


class Transcriptions(TranscriptionsBase):

    @base.apimethod
    def get(self, Page=None, PageSize=None, AfterSid=None):
        """
        Fetch the list of transcriptions for an account or call.

        :var Page: The current page number. Zero-indexed, so the first page
            is 0.
        :vartype Page: int

        :var PageSize: How many resources to return in each list page.
            The default is 50, and the maximum is 1000.
        :vartype PageSize: int

        :var AfterSid: The last Sid returned in the previous page, used to
            avoid listing duplicated resources if new ones are created while
            paging.
        :vartype AfterSid: str
        """
        params = resource.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json


class RecordingsBase(resource.TwilioResource):

    path = 'Recordings'

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Recording(RecordingsBase):

    @base.resource(Transcriptions)
    def transcriptions(self):
        """
        Return a set of Transcription resource representations
        for this recording.
        """
        return Transcriptions(self)


class Recordings(RecordingsBase):

    @base.apimethod
    def get(self, CallSid=None, DateCreated=None, DateCreatedGT=None,
            DateCreatedLT=None, Page=None, PageSize=None, AfterSid=None):
        """
        Fetch the list of transcriptions for an account or call.

        :var CallSid: Show only recordings made during the call given
            by this sid.
        :vartype CallSid: str

        :var DateCreated: Only show recordings created on this date,
            given as YYYY-MM-DD.
        :vartype DateCreated: str

        :var DateCreatedGT: Greater than inequality for DateCreated,
            use it for recordings created at or after midnight on a date
            (generates DateCreated>=YYYY-MM-DD).
        :vartype DateCreatedGT: str

        :var DateCreatedLT: Lower than inequality for DateCreated,
            use it for recordings created at or before midnight on a date
            (generates DateCreated<=YYYY-MM-DD).
        :vartype DateCreatedGT: str

        :var Page: The current page number. Zero-indexed, so the first page
            is 0.
        :vartype Page: int

        :var PageSize: How many resources to return in each list page.
            The default is 50, and the maximum is 1000.
        :vartype PageSize: int

        :var AfterSid: The last Sid returned in the previous page, used to
            avoid listing duplicated resources if new ones are created while
            paging.
        :vartype AfterSid: str
        """
        params = resource.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()

########NEW FILE########
__FILENAME__ = resource
from libsaas import http, parsers
from libsaas.services import base


def translate_inequality(param_name):
    """
    Replace GT or LT at the end of a param name by '>' or '<' to
    achieve Twilio-like inequalities.
    """
    for suffix, replacement in (('GT', '>'), ('LT', '<')):
        if param_name.endswith(suffix):
            return param_name[:-len(suffix)] + replacement

    return param_name


def get_params(param_names, param_store, serialize_param=base.serialize_param,
               translate_param=translate_inequality):
    """
    Return the dictionary of params using by default translate_inequality
    as translation function
    """
    return base.get_params(param_names, param_store, serialize_param,
                           translate_param)


class TwilioResource(base.RESTResource):

    @base.apimethod
    def update(self, obj):
        """
        Update this resource.

        :var obj: a Python object representing the updated resource, usually in
            the same format as returned from `get`. Refer to the upstream
            documentation for details.
        :vartype obj: dict
        """
        self.require_item()
        # In most cases, Twilio uses POST for updates and ignores PUT.
        # In some others, both POST and PUT can update a resource.
        # Always use POST which will work everytime.
        request = http.Request('POST', self.get_url(), self.wrap_object(obj))

        return request, parsers.parse_json

########NEW FILE########
__FILENAME__ = service
from libsaas.filters import auth
from libsaas.services import base

from . import accounts


def use_json(request):
    """
    Add a .json extension to the request URI to get a JSON response.
    """
    request.uri = '{0}.json'.format(request.uri)


class Twilio(base.Resource):

    def __init__(self, account_sid, auth_token):
        """
        Create a Twilio service.

        :var account_sid: The users's account SID
        :vartype account_sid: str

        :var auth_token: THe account's API token
        :vartype auth_token: str
        """
        self.apiroot = 'https://api.twilio.com/2010-04-01'
        self.add_filter(auth.BasicAuth(account_sid, auth_token))
        self.add_filter(use_json)

    def get_url(self):
        return self.apiroot

    @base.resource(accounts.Account)
    def account(self, sid):
        """
        Return the representation of an Account or SubAccount.
        """
        return accounts.Account(self, sid)

    @base.resource(accounts.Accounts)
    def accounts(self):
        """
        Return the set of Accounts resources belonging to the Account
        used to make the API request.
        This list includes that account, along with any subaccounts belonging to it.

        You can use the Accounts list resource to create subaccounts and
        retrieve the subaccounts that exist under your main account.
        """
        return accounts.Accounts(self)

########NEW FILE########
__FILENAME__ = sms
from libsaas import http, parsers
from libsaas.services import base

from libsaas.services.twilio import resource


class MessagesBase(resource.TwilioResource):

    path = 'Messages'

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Message(MessagesBase):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Messages(MessagesBase):

    @base.apimethod
    def get(self, To=None, From=None, DateSent=None, DateSentGT=None,
            DateSentLT=None, Page=None, PageSize=None, AfterSid=None):
        """
        Fetch the list of SMS messages associated with an account.

        :var To: Only show SMS messages to this phone number.
        :vartype To: str

        :var From: Only show SMS messages from this phone number.
        :vartype From: str

        :var DateSent: Only show SMS messages on this date,
            given as YYYY-MM-DD.
        :vartype DateSent: str

        :var DateSentGT: Greater than inequality for DateSent,
            use it for message sent at or after midnight on a date
            (generates DateSent>=YYYY-MM-DD).
        :vartype DateSentGT: str

        :var DateSentLT: Lower than inequality for DateSent,
            use it for messages sent at or before midnight on a date
            (generates DateSent<=YYYY-MM-DD).
        :vartype DateSentGT: str

        :var Page: The current page number. Zero-indexed, so the first page
            is 0.
        :vartype Page: int

        :var PageSize: How many resources to return in each list page.
            The default is 50, and the maximum is 1000.
        :vartype PageSize: int

        :var AfterSid: The last Sid returned in the previous page, used to
            avoid listing duplicated resources if new ones are created while
            paging.
        :vartype AfterSid: str
        """
        params = resource.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json


class ShortCodesBase(resource.TwilioResource):

    path = 'ShortCodes'

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class ShortCode(ShortCodesBase):

    pass


class ShortCodes(ShortCodesBase):

    @base.apimethod
    def get(self, ShortCode=None, FriendlyName=None,
            Page=None, PageSize=None, AfterSid=None):
        """
        Fetch the list of short codes for an account.

        :var ShortCode: Only show the ShortCode resources that match
            this pattern. You can specify partial numbers and use `*`
            as a wildcard for any digit.
        :vartype ShortCode: str

        :var FriendlyName: Only show the ShortCode resources with friendly
            names that exactly match this name.
        :vartype FriendlyName: str

        :var Page: The current page number. Zero-indexed, so the first page
            is 0.
        :vartype Page: int

        :var PageSize: How many resources to return in each list page.
            The default is 50, and the maximum is 1000.
        :vartype PageSize: int

        :var AfterSid: The last Sid returned in the previous page, used to
            avoid listing duplicated resources if new ones are created while
            paging.
        :vartype AfterSid: str
        """
        params = resource.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()


class SMS(resource.TwilioResource):

    path = 'SMS'

    def get(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.resource(Message)
    def message(self, sid):
        """
        Return a SMS message associated with this account.
        """
        return Message(self, sid)

    @base.resource(Messages)
    def messages(self):
        """
        Return a list of SMS messages associated with this account.
        """
        return Messages(self)

    @base.resource(ShortCode)
    def short_code(self, sid):
        """
        Return a ShortCode resource representation,
        representing a short code within this account.
        """
        return ShortCode(self, sid)

    @base.resource(ShortCodes)
    def short_codes(self):
        """
        Return a list of ShortCode resource representations,
        each representing a short code within this account.
        """
        return ShortCodes(self)

########NEW FILE########
__FILENAME__ = usage
from libsaas import http, parsers
from libsaas.services import base

from libsaas.services.twilio import resource


class RecordsBase(resource.TwilioResource):

    path = 'Records'

    @base.apimethod
    def get(self, Category=None, StartDate=None, EndDate=None,
            Page=None, PageSize=None, AfterSid=None):
        """
        Fetch a list of usage records.

        :var Category: Only include usage records of this usage category.
        :vartype Category: str

        :var StartDate: Only include usage that has occurred on or after
            this date. Format is YYYY-MM-DD. All dates are in GMT.
            As a convenience, you can also specify offsets to today.
            For example, StartDate=-30days will make StartDate be 30 days
            before today.
        :vartype StartDate: str

        :var EndDate: Only include usage that has occurred on or before
            this date. Format is YYYY-MM-DD. All dates are in GMT.
            As a convenience, you can also specify offsets to today.
            For example, EndDate=+30days will make EndDate be 30 days
            from today.
        :vartype EndDate: str

        :var Page: The current page number. Zero-indexed, so the first page
            is 0.
        :vartype Page: int

        :var PageSize: How many resources to return in each list page.
            The default is 50, and the maximum is 1000.
        :vartype PageSize: int

        :var AfterSid: The last Sid returned in the previous page, used to
            avoid listing duplicated resources if new ones are created while
            paging.
        :vartype AfterSid: str
        """
        params = resource.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class RecordsDaily(RecordsBase):

    path = 'Daily'


class RecordsMonthly(RecordsBase):

    path = 'Monthly'


class RecordsYearly(RecordsBase):

    path = 'Yearly'


class RecordsAllTime(RecordsBase):

    path = 'AllTime'


class RecordsToday(RecordsBase):

    path = 'Today'


class RecordsYesterday(RecordsBase):

    path = 'Yesterday'


class RecordsThisMonth(RecordsBase):

    path = 'ThisMonth'


class RecordsLastMonth(RecordsBase):

    path = 'LastMonth'


class Records(RecordsBase):

    @base.resource(RecordsDaily)
    def daily(self):
        """
        Return multiple usage records for each usage category,
        each representing usage over a daily time-interval.
        """
        return RecordsDaily(self)

    @base.resource(RecordsMonthly)
    def monthly(self):
        """
        Return multiple usage records for each usage category,
        each representing usage over a monthly time-interval.
        """
        return RecordsMonthly(self)

    @base.resource(RecordsYearly)
    def yearly(self):
        """
        Return multiple usage records for each usage category,
        each representing usage over a yearly time-interval.
        """
        return RecordsYearly(self)

    @base.resource(RecordsAllTime)
    def all_time(self):
        """
        Return a single usage record for each usage category,
        each representing usage over the date-range specified.
        This is the same as the root .usage().records().
        """
        return RecordsAllTime(self)

    @base.resource(RecordsToday)
    def today(self):
        """
        Return a single usage record per usage category,
        for today's usage only.
        """
        return RecordsToday(self)

    @base.resource(RecordsYesterday)
    def yesterday(self):
        """
        Return a single usage record per usage category,
        for yesterday's usage only.
        """
        return RecordsYesterday(self)

    @base.resource(RecordsThisMonth)
    def this_month(self):
        """
        Return a single usage record per usage category,
        for this month's usage only.
        """
        return RecordsThisMonth(self)

    @base.resource(RecordsLastMonth)
    def last_month(self):
        """
        Return a single usage record per usage category,
        for last month's usage only.
        """
        return RecordsLastMonth(self)


class TriggersBase(resource.TwilioResource):

    path = 'Triggers'


class Trigger(TriggersBase):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Triggers(TriggersBase):

    @base.apimethod
    def get(self, Recurring=None, UsageCategory=None, TriggerBy=None,
            Page=None, PageSize=None, AfterSid=None):
        """
        Fetch a list of usage triggers resource representations.

        :var Recurring: Only show usage triggers that count over this interval.
            One of daily, monthly, or yearly. To retrieve non-recurring
            triggers, leave this empty or use alltime.
        :vartype Recurring: str

        :var UsageCategory: Only include usage triggers that watch this usage
            category.
        :vartype UsageCategory: str

        :var TriggerBy: Only show usage triggers that trigger by this field
            in the usage record. Must be one of: count, usage, or price.
        :vartype TriggerBy: str

        :var Page: The current page number. Zero-indexed, so the first page
            is 0.
        :vartype Page: int

        :var PageSize: How many resources to return in each list page.
            The default is 50, and the maximum is 1000.
        :vartype PageSize: int

        :var AfterSid: The last Sid returned in the previous page, used to
            avoid listing duplicated resources if new ones are created while
            paging.
        :vartype AfterSid: str
        """
        params = resource.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Usage(resource.TwilioResource):

    path = 'Usage'

    def get(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.resource(Records)
    def records(self):
        """
        Return a list of usage records.
        """
        return Records(self)

    @base.resource(Triggers)
    def triggers(self):
        """
        Return a list of usage triggers set on this account.
        """
        return Triggers(self)

    @base.resource(Trigger)
    def trigger(self, sid):
        """
        Return an usage trigger set on this account.
        """
        return Trigger(self, sid)

########NEW FILE########
__FILENAME__ = articles
from libsaas import http, parsers
from libsaas.services import base

from . import resource


class ArticlesBase(resource.UserVoiceResource):

    path = 'articles'

    def wrap_object(self, obj):
        return {'article': obj}


class Articles(ArticlesBase):

    @base.apimethod
    def search(self, page=None, per_page=None, query=None):
        """
        Search for articles.

        :var page: Where should paging start. If left as `None`, the first page
            is returned.
        :vartype page: int

        :var per_page: How many objects sould be returned. If left as `None`,
            10 objects are returned.
        :vartype per_page: int

        :var query: Search string.
        :vartype query: str
        """
        params = base.get_params(None, locals())
        url = '{0}/{1}'.format(self.get_url(), 'search')

        return http.Request('GET', url, params), parsers.parse_json


class Article(ArticlesBase):

    @base.apimethod
    def useful(self):
        """
        Mark the article as useful.
        """
        url = '{0}/{1}'.format(self.get_url(), 'useful')

        return http.Request('POST', url), parsers.parse_json

########NEW FILE########
__FILENAME__ = categories
from . import resource


class ForumCategoriesBase(resource.UserVoiceResource):

    path = 'categories'

    def wrap_object(self, name):
        return {'category': name}



class ForumCategories(ForumCategoriesBase):
    pass


class ForumCategory(ForumCategoriesBase):
    pass

########NEW FILE########
__FILENAME__ = comments
from libsaas import http, parsers
from libsaas.services import base

from . import resource, flags


class CommentsBase(resource.UserVoiceTextResource):

    path = 'comments'

    def wrap_object(self, name):
        return {'comment': {'text': name}}


class Comments(CommentsBase):

    def create(self, obj):
        raise base.MethodNotSupported()


class ForumSuggestionComment(CommentsBase):

    @base.resource(flags.SuggestionCommentFlags)
    def flags(self):
        """
        Return the resource corresponding to all the flags of this comment.
        """
        return flags.SuggestionCommentFlags(self)


class ForumSuggestionComments(CommentsBase):

    @base.apimethod
    def get(self, page=None, per_page=None, filter=None, sort=None):
        """
        Fetch comments on this suggestion.

        :var page: Where should paging start. If left as `None`, the first page
            is returned.
        :vartype page: int

        :var per_page: How many objects sould be returned. If left as `None`,
            10 objects are returned.
        :vartype per_page: int

        :var filter: The kind of comments to return, see upstream
            documentation for possible values.
        :vartype filter: str

        :var sort: How should the returned collection be sorted. Refer to
            upstream documentation for possible values.
        :vartype sort: str
        """
        params = base.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json


class UserComments(CommentsBase):

    def create(self, obj):
        raise base.MethodNotSupported()

    @base.apimethod
    def get(self, page=None, per_page=None, filter=None, sort=None):
        """
        Fetch comments from this user.

        :var page: Where should paging start. If left as `None`, the first page
            is returned.
        :vartype page: int

        :var per_page: How many objects sould be returned. If left as `None`,
            10 objects are returned.
        :vartype per_page: int

        :var filter: The kind of comments to return, see upstream
            documentation for possible values.
        :vartype filter: str

        :var sort: How should the returned collection be sorted. Refer to
            upstream documentation for possible values.
        :vartype sort: str
        """
        params = base.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

########NEW FILE########
__FILENAME__ = custom_fields
from libsaas import http, parsers
from libsaas.services import base

from . import resource


class CustomFields(resource.UserVoiceResource):

    path = 'custom_fields'

    def create(self, obj):
        raise base.MethodNotSupported()

    @base.apimethod
    def get(self, page=None, per_page=None, filter=None, sort=None):
        """
        Fetch all custom fields.

        :var page: Where should paging start. If left as `None`, the first page
            is returned.
        :vartype page: int

        :var per_page: How many objects sould be returned. If left as `None`,
            10 objects are returned.
        :vartype per_page: int

        :var filter: The kind of fields to return, see upstream
            documentation for possible values.
        :vartype filter: str

        :var sort: How should the returned collection be sorted. Refer to
            upstream documentation for possible values.
        :vartype sort: str
        """
        params = base.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

    @base.apimethod
    def public(self, page=None, per_page=None, sort=None):
        """
        Fetch public custom fields.

        :var page: Where should paging start. If left as `None`, the first page
            is returned.
        :vartype page: int

        :var per_page: How many objects sould be returned. If left as `None`,
            10 objects are returned.
        :vartype per_page: int

        :var filter: The kind of fields to return, see upstream
            documentation for possible values.
        :vartype filter: str

        :var sort: How should the returned collection be sorted. Refer to
            upstream documentation for possible values.
        :vartype sort: str
        """
        params = base.get_params(None, locals())
        url = '{0}/public'.format(self.get_url())
        request = http.Request('GET', url, params)

        return request, parsers.parse_json

########NEW FILE########
__FILENAME__ = faqs
from libsaas.services import base

from . import resource, flags


class Faq(resource.UserVoiceResource):

    path = 'faqs'

    def create(self, obj):
        raise base.MethodNotSupported()

    def get(self):
        raise base.MethodNotSupported()

    @base.resource(flags.FaqFlags)
    def flags(self):
        """
        Return the resource corresponding to all the flags of this FAQ.
        """
        return flags.FaqFlags(self)

########NEW FILE########
__FILENAME__ = flags
from . import resource

from libsaas import http, parsers
from libsaas.services import base


class FlagsBase(resource.UserVoiceResource):

    path = 'flags'

    def wrap_object(self, obj):
        return {'code': obj}

    @base.apimethod
    def create(self, flag):
        """
        Create a new flag.

        :var flag: The flag name. Refer to the upstream documentation for
            details.
        :vartype flag: str
        """
        self.require_collection()
        request = http.Request('POST', self.get_url(), self.wrap_object(flag))

        return request, parsers.parse_json

    def update(self, obj):
        raise base.MethodNotSupported()


class SuggestionCommentFlags(FlagsBase):
    pass


class SuggestionFlags(FlagsBase):
    pass


class FaqFlags(FlagsBase):
    pass

########NEW FILE########
__FILENAME__ = forums
from libsaas.services import base

from . import resource, categories, streams, suggestions


class ForumsBase(resource.UserVoiceResource):

    path = 'forums'

    def wrap_object(self, obj):
        return {'forum': obj}


class Forums(ForumsBase):
    pass


class Forum(ForumsBase):

    @base.resource(suggestions.ForumUserSuggestions)
    def user_suggestions(self, user_id):
        """
        Return a resource corresponding to all the suggestions of a  single
        user on this forum.
        """
        return suggestions.ForumUserSuggestions(self, user_id)

    @base.resource(suggestions.ForumSuggestion)
    def suggestion(self, suggestion_id):
        """
        Return a resource corresponding to a single suggestion on a forum.
        """
        return suggestions.ForumSuggestion(self, suggestion_id)

    @base.resource(suggestions.ForumSuggestions)
    def suggestions(self):
        """
        Return a resource corresponding to all the suggestion on a forum.
        """
        return suggestions.ForumSuggestions(self)

    @base.resource(streams.Stream)
    def stream(self):
        """
        Return a resource corresponding to the stream of events for this forum.
        """
        return streams.Stream(self)

    @base.resource(categories.ForumCategory)
    def category(self, category_id):
        """
        Return a resource corresponding to a single category on this forum.
        """
        return categories.ForumCategory(self, category_id)

    @base.resource(categories.ForumCategories)
    def categories(self):
        """
        Return a resource corresponding to all the categories on this forum.
        """
        return categories.ForumCategories(self)

########NEW FILE########
__FILENAME__ = gadgets
from . import resource


class GadgetsBase(resource.UserVoiceResource):

    path = 'gadgets'

    def wrap_object(self, obj):
        return {'gadget': obj}


class Gadgets(GadgetsBase):
    pass


class Gadget(GadgetsBase):
    pass

########NEW FILE########
__FILENAME__ = notes
from libsaas.services import base

from . import resource


class ReadonlyNotesBase(resource.UserVoiceResource):

    path = 'notes'

    def create(self, obj):
        raise base.MethodNotSupported()


class Notes(ReadonlyNotesBase):
    pass


class UserNotes(ReadonlyNotesBase):
    pass


class ForumSuggestionNotesBase(resource.UserVoiceTextResource):

    path = 'notes'

    def wrap_object(self, obj):
        return {'note': {'text': obj}}


class ForumSuggestionNotes(ForumSuggestionNotesBase):
    pass


class ForumSuggestionNote(ForumSuggestionNotesBase):
    pass

########NEW FILE########
__FILENAME__ = resource
from libsaas import http, parsers
from libsaas.services import base


class UserVoiceResource(base.RESTResource):

    @base.apimethod
    def get(self, page=None, per_page=None, sort=None):
        """
        For single-object resources, fetch the object's data. For collections,
        fetch all of the objects.

        :var page: For collections, where should paging start. If left as
            `None`, the first page is returned.
        :vartype page: int

        :var per_page: For collections, how many objects sould be returned. If
            left as `None`, 10 objects are returned.
        :vartype per_page: int

        :var sort: For collections, how should the returned collection be
            sorted. Refer to upstream documentation for possible values.
        :vartype sort: str
        """
        params = base.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

    @base.apimethod
    def create(self, obj):
        """
        Create a new resource.

        :var obj: a Python dictionary representing the resource to be created,
            in the same as returned from `get`, but one level less nested. For
            instance, if `get` returns `{'forum': {'name': 'Forum Name'}}`,
            then `obj` should be `{'name': 'New Forum'}`.

            Refer to the upstream documentation for details.
        """
        self.require_collection()
        request = http.Request('POST', self.get_url(), self.wrap_object(obj))

        return request, parsers.parse_json

    @base.apimethod
    def update(self, obj):
        """
        Update this resource.

        :var obj: a Python dictionary representing the resource to be created,
            in the same as returned from `get`, but one level less nested. For
            instance, if `get` returns `{'forum': {'name': 'Forum Name'}}`,
            then `obj` should be `{'name': 'New Forum'}`.

            Refer to the upstream documentation for details.
        """
        self.require_item()
        request = http.Request('PUT', self.get_url(), self.wrap_object(obj))

        return request, parsers.parse_json


class UserVoiceTextResource(UserVoiceResource):

    @base.apimethod
    def create(self, text):
        """
        Create a new resource.

        :var text: the text of the resource to be created.
        :vartype text: str
        """
        self.require_collection()
        request = http.Request('POST', self.get_url(), self.wrap_object(text))

        return request, parsers.parse_json

    @base.apimethod
    def update(self, text):
        """
        Update this resource.

        :var text: the new text of the resource.
        :vartype text: str
        """
        self.require_item()
        request = http.Request('PUT', self.get_url(), self.wrap_object(text))

        return request, parsers.parse_json

########NEW FILE########
__FILENAME__ = service
import json

from libsaas import http, parsers, port

from libsaas.filters import auth
from libsaas.services import base

from . import articles, forums, gadgets, streams, notes, custom_fields
from . import comments, faqs, subdomains, suggestions, tickets, topics, users
from . import support_queues


class UserVoice(base.Resource):
    """
    """
    def __init__(self, subdomain, api_key, api_secret=None,
                 access_token=None, access_token_secret=None):
        """
        Create a UserVoice service.

        :var subdomain: The account-specific part of the UserVoice domain, for
            instance use `mycompany` if your UserVoice domain is
            `mycompany.uservoice.com`.
        :vartype subdomain: str

        :var api_key: The API key.
        :vartype api_key: str

        :var api_secret: Optional API secret. If you leave this as None, all
            requests will be made as unauthenticated requests.
        :vartype api_secret: str or None

        :var access_token: Optional OAuth 1.0a access token. If you leave this
            as None, all requests be made as unauthenticated requests.
        :vartype access_token: str or None

        :var access_token_secret: Optional OAuth 1.0a access token secret. If
            you leave this as None, all requests be made as unauthenticated
            requests.
        :vartype access_token_secret: str or None
        """
        self.api_key = api_key
        self.oauth = None

        if api_secret and access_token and access_token_secret:
            self.oauth = auth.OAuth1a(access_token, access_token_secret,
                                      api_key, api_secret)

        tmpl = '{0}.uservoice.com/api/v1'
        self.apiroot = http.quote_any(tmpl.format(port.to_u(subdomain)))
        self.apiroot = 'http://' + self.apiroot

        self.add_filter(self.use_json)
        self.add_filter(self.serialize_flatten)
        # authenticate has to be the last filter, because anything that
        # modifies the request after it's signed will make the signature
        # invalid!
        self.add_filter(self.authenticate)

    def get_url(self):
        return self.apiroot

    def authenticate(self, request):
        if not self.oauth:
            # not using OAuth, make an unauthenticated request
            request.params += (('client', self.api_key), )
        else:
            # using OAuth, sign the request
            self.oauth(request)

    def use_json(self, request):
        request.headers['Accept'] = 'application/json'
        request.uri += '.json'

    def serialize_flatten(self, request):
        # use serialize_flatten to flatten params
        serialized = ()
        for name, value in request.params.items():
            serialized += http.serialize_flatten(name, value, False)
        request.params = serialized

    def urlencode_put(self, request):
        # UserVoice adheres to the OAuth 1.0 specification as published on
        # http://oauth.net/core/1.0/ *NOT* to the final version published as
        # RFC5849.
        #
        # This means that they don't include PUT request body in the base
        # signature string. The requests-oauth library that we're using
        # implements the RFC5849 version of OAuth and so for PUT requests it
        # generates signatures that UserVoice rejects.
        #
        # To work around this, for PUT requests we serialize the parameters to
        # a string before handing it off to the executor, which causes
        # requests-oauth to skip the body when calculating the signature.
        if request.method.upper() == 'PUT':
            request.params = http.urlencode_any(request.params)

    @base.apimethod
    def search(self, page=None, per_page=None, query=None):
        """
        Generic search for all objects.

        :var page: Where should paging start. If left as `None`, the first page
            is returned.
        :vartype page: int

        :var per_page: How many objects sould be returned. If left as `None`,
            10 objects are returned.
        :vartype per_page: int

        :var query: Search string.
        :vartype query: str
        """
        params = base.get_params(None, locals())
        url = '{0}/{1}'.format(self.get_url(), 'search')

        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def instant_answers_search(self, page=None, per_page=None, query=None):
        """
        Search for instant answers.

        :var page: Where should paging start. If left as `None`, the first page
            is returned.
        :vartype page: int

        :var per_page: How many objects sould be returned. If left as `None`,
            10 objects are returned.
        :vartype per_page: int

        :var query: Search string.
        :vartype query: str
        """
        params = base.get_params(None, locals())
        url = '{0}/instant_answers/{1}'.format(self.get_url(), 'search')

        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def oembed(self, url):
        """
        Fetch the HTML used to embed a suggestion.

        :var url: URL to the Suggestion you want to embed (ex:
            forums/1/suggestions/1)
        :vartype url: str
        """
        _url = '{0}/oembed'.format(self.get_url())
        return http.Request('GET', _url, {'url': url}), parsers.parse_json

    @base.resource(articles.Article)
    def article(self, article_id):
        """
        Return the resource corresponding to a single article.
        """
        return articles.Article(self, article_id)

    @base.resource(articles.Articles)
    def articles(self):
        """
        Return the resource corresponding to all the articles.
        """
        return articles.Articles(self)

    @base.resource(forums.Forum)
    def forum(self, forum_id):
        """
        Return the resource corresponding to a single forum.
        """
        return forums.Forum(self, forum_id)

    @base.resource(forums.Forums)
    def forums(self):
        """
        Return the resource corresponding to all the forums.
        """
        return forums.Forums(self)

    @base.resource(support_queues.SupportQueue)
    def support_queue(self, queue_id):
        """
        Return the resource corresponding to a single support queue.
        """
        return support_queues.SupportQueue(self, queue_id)

    @base.resource(support_queues.SupportQueues)
    def support_queues(self):
        """
        Return the resource corresponding to all the support queues.
        """
        return support_queues.SupportQueues(self)

    @base.resource(notes.Notes)
    def notes(self):
        """
        Return the resource corresponding to all the notes.
        """
        return notes.Notes(self)

    @base.resource(gadgets.Gadget)
    def gadget(self, gadget_id):
        """
        Return the resource corresponding to a single gadget.
        """
        return gadgets.Gadget(self, gadget_id)

    @base.resource(gadgets.Gadgets)
    def gadgets(self):
        """
        Return the resource corresponding to all the gadgets.
        """
        return gadgets.Gadgets(self)

    @base.resource(streams.Stream)
    def stream(self):
        """
        Return the resource corresponding to a stream.
        """
        return streams.Stream(self)

    @base.resource(tickets.Ticket)
    def ticket(self, ticket_id):
        """
        Return the resource corresponding to a single ticket.
        """
        return tickets.Ticket(self, ticket_id)

    @base.resource(tickets.Tickets)
    def tickets(self):
        """
        Return the resource corresponding to all the tickets.
        """
        return tickets.Tickets(self)

    @base.resource(subdomains.Subdomain)
    def subdomain(self, subdomain):
        """
        Return the resource corresponding to a UserVoice subdomain.
        """
        return subdomains.Subdomain(self, subdomain)

    @base.resource(suggestions.Suggestion)
    def suggestion(self, suggestion_id):
        """
        Return the resource corresponding to a single suggestion.
        """
        return suggestions.Suggestion(self, suggestion_id)

    @base.resource(suggestions.Suggestions)
    def suggestions(self):
        """
        Return the resource corresponding to all the suggestions.
        """
        return suggestions.Suggestions(self)

    @base.resource(topics.Topic)
    def topic(self, topic_id):
        """
        Return the resource corresponding a single topic.
        """
        return topics.Topic(self, topic_id)

    @base.resource(topics.Topics)
    def topics(self):
        """
        Return the resource corresponding all the topics.
        """
        return topics.Topics(self)

    @base.resource(users.User)
    def user(self, user_id=None):
        """
        Return the resource corresponding to a single user. If user_id is
        `None`, the returned resource is the currently authenticated user,
        otherwise it is the user with the given ID number.
        """
        if user_id is None:
            return users.CurrentUser(self)

        return users.User(self, user_id)

    @base.resource(users.Users)
    def users(self):
        """
        Return the resource corresponding to all the users.
        """
        return users.Users(self)

    @base.resource(comments.Comments)
    def comments(self):
        """
        Return the resource corresponding to all the comments.
        """
        return comments.Comments(self)

    @base.resource(faqs.Faq)
    def faq(self, faq_id):
        """
        Return the resource corresponding to a single FAQ.
        """
        return faqs.Faq(self, faq_id)

    @base.resource(custom_fields.CustomFields)
    def custom_fields(self):
        """
        Return the resource corresponding to custom fields.
        """
        return custom_fields.CustomFields(self)

########NEW FILE########
__FILENAME__ = streams
from libsaas import http, parsers
from libsaas.services import base


class Stream(base.HierarchicalResource):

    path = 'stream'

    @base.apimethod
    def public(self, date=None, filter=None, since=None):
        """
        Fetch all public events.

        :var date: Fetch only events from that day (EST). See upstream
            documentation for details.
        :vartype date: str

        :var filter: Specify which event types you want. See upstream
            documentation for allowed values.
        :var filter: str

        :var since: Fetch events from that moment onward. If set, the `date`
            parameter is ignored See upstream documentation for details.
        :vartype since: str
        """
        params = base.get_params(None, locals())
        url = '{0}/{1}'.format(self.get_url(), 'public')

        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def private(self, date=None, filter=None, since=None):
        """
        Fetch all private events.

        :var date: Fetch only events from that day (EST). See upstream
            documentation for details.
        :vartype date: str

        :var filter: Specify which event types you want. See upstream
            documentation for allowed values.
        :var filter: str

        :var since: Fetch events from that moment onward. If set, the `date`
            parameter is ignored See upstream documentation for details.
        :vartype since: str
        """
        params = base.get_params(None, locals())
        url = '{0}/{1}'.format(self.get_url(), 'private')

        return http.Request('GET', url, params), parsers.parse_json

########NEW FILE########
__FILENAME__ = subdomains
from libsaas import http, parsers, port
from libsaas.services import base


class Subdomain(base.HierarchicalResource):

    @base.apimethod
    def get(self):
        """
        Fetch information about the subdomain.
        """
        url = '{0}/subdomains/{1}'.format(self.parent.get_url(),
                                          port.to_u(self.object_id))
        return http.Request('GET', url), parsers.parse_json

########NEW FILE########
__FILENAME__ = suggestions
from libsaas import http, parsers
from libsaas.services import base

from . import resource, comments, flags, notes


class SuggestionsBase(resource.UserVoiceResource):

    path = 'suggestions'

    def wrap_object(self, obj):
        return {'suggestion': obj}


class Suggestions(SuggestionsBase):

    def create(self, obj):
        raise base.MethodNotSupported()

    @base.apimethod
    def search(self, page=None, per_page=None, query=None):
        """
        Search for suggestions.

        :var page: Where should paging start. If left as `None`, the first page
            is returned.
        :vartype page: int

        :var per_page: How many objects sould be returned. If left as `None`,
            10 objects are returned.
        :vartype per_page: int

        :var query: Search string.
        :vartype query: str
        """
        params = base.get_params(None, locals())
        url = '{0}/{1}'.format(self.get_url(), 'search')

        return http.Request('GET', url, params), parsers.parse_json


class Suggestion(SuggestionsBase):

    def update(self, obj):
        raise base.MethodNotSupported()

    def delete(self):
        raise base.MethodNotSupported()


class ForumSuggestion(SuggestionsBase):

    @base.apimethod
    def supporters(self, page=None, per_page=None, sort=None):
        """
        Fetch the supporters for this suggestion.

        :var page: Where should paging start. If left as `None`, the first page
            is returned.
        :vartype page: int

        :var per_page: How many objects sould be returned. If left as `None`,
            10 objects are returned.
        :vartype per_page: int

        :var sort: How should the returned collection be sorted. Refer to
            upstream documentation for possible values.
        :vartype sort: str
        """
        params = base.get_params(None, locals())
        url = '{0}/{1}'.format(self.get_url(), 'supporters')

        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def respond(self, obj):
        """
        Respond to a suggestion.

        :var obj: a Python object representing the response. Refer to the
            upstream documentation for details.
        """
        url = '{0}/{1}'.format(self.get_url(), 'respond')
        request = http.Request('PUT', url, {'response': obj})

        return request, parsers.parse_json

    @base.apimethod
    def vote(self):
        """
        Vote for this suggestion.
        """
        url = '{0}/{1}'.format(self.get_url(), 'votes')
        request = http.Request('POST', url, {'to': '1'})

        return request, parsers.parse_json

    @base.resource(notes.ForumSuggestionNote)
    def note(self, note_id):
        """
        Return the resource corresponding to a single note on this suggestion.
        """
        return notes.ForumSuggestionNote(self, note_id)

    @base.resource(notes.ForumSuggestionNotes)
    def notes(self):
        """
        Return the resource corresponding to all the notes on this suggestion.
        """
        return notes.ForumSuggestionNotes(self)

    @base.resource(comments.ForumSuggestionComment)
    def comment(self, comment_id):
        """
        Return the resource corresponding to a single comment on this suggestion.
        """
        return comments.ForumSuggestionComment(self, comment_id)

    @base.resource(comments.ForumSuggestionComments)
    def comments(self):
        """
        Return the resource corresponding to all the comments on this suggestion.
        """
        return comments.ForumSuggestionComments(self)

    @base.resource(flags.SuggestionFlags)
    def flags(self):
        """
        Return the resource corresponding to all the flags of this suggestion.
        """
        return flags.SuggestionFlags(self)


class ForumSuggestions(SuggestionsBase):

    @base.apimethod
    def get(self, page=None, per_page=None, category=None,
            filter=None, sort=None, updated_after_date=None):
        """
        Fetch suggestions from this forum.

        :var page: Where should paging start. If left as `None`, the first page
            is returned.
        :vartype page: int

        :var per_page: How many objects sould be returned. If left as `None`,
            10 objects are returned.
        :vartype per_page: int

        :var category: Either a category ID, `all` or `uncategorized`. See
            upstream documentation for details.
        :vartype category: str

        :var filter: The kind of suggestions to return, see upstream
            documentation for possible values.
        :vartype filter: str

        :var sort: How should the returned collection be sorted. Refer to
            upstream documentation for possible values.
        :vartype sort: str

        :var updated_after_date: If `filter` is `assigned_after`, a date string
            formatted `yyyy-mm-dd HH:MM:SS -0000`.
        :var updated_after_date: str
        """
        params = base.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

    @base.apimethod
    def search(self, page=None, per_page=None, category_id=None, query=None):
        """
        Search for suggestions on this forum.

        :var page: Where should paging start. If left as `None`, the first page
            is returned.
        :vartype page: int

        :var per_page: How many objects sould be returned. If left as `None`,
            10 objects are returned.
        :vartype per_page: int

        :var category_id: A category ID.
        :vartype category_id: int

        :var query: Search string.
        :vartype query: str
        """
        params = base.get_params(None, locals())
        url = '{0}/{1}'.format(self.get_url(), 'search')

        return http.Request('GET', url, params), parsers.parse_json


class UserSuggestions(SuggestionsBase):

    def create(self, obj):
        raise base.MethodNotSupported()

    @base.apimethod
    def get(self, page=None, per_page=None, category=None,
            filter=None, sort=None):
        """
        Fetch suggestions from this user on this forum.

        :var page: Where should paging start. If left as `None`, the first page
            is returned.
        :vartype page: int

        :var per_page: How many objects sould be returned. If left as `None`,
            10 objects are returned.
        :vartype per_page: int

        :var category: Either a category ID, `all` or `uncategorized`. See
            upstream documentation for details.
        :vartype category: str

        :var filter: The kind of suggestions to return, see upstream
            documentation for possible values.
        :vartype filter: str

        :var sort: How should the returned collection be sorted. Refer to
            upstream documentation for possible values.
        :vartype sort: str
        """
        params = base.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json


class ForumUserSuggestions(SuggestionsBase):

    def get_url(self):
        return '{0}/users/{1}/{2}'.format(self.parent.get_url(),
                                          self.object_id, self.path)

    def update(self, obj):
        raise base.MethodNotSupported()

    def delete(self, obj):
        raise base.MethodNotSupported()

    @base.apimethod
    def get(self, page=None, per_page=None, category=None,
            filter=None, sort=None):
        """
        Fetch suggestions from this user on this forum.

        :var page: Where should paging start. If left as `None`, the first page
            is returned.
        :vartype page: int

        :var per_page: How many objects sould be returned. If left as `None`,
            10 objects are returned.
        :vartype per_page: int

        :var category: Either a category ID, `all` or `uncategorized`. See
            upstream documentation for details.
        :vartype category: str

        :var filter: The kind of suggestions to return, see upstream
            documentation for possible values.
        :vartype filter: str

        :var sort: How should the returned collection be sorted. Refer to
            upstream documentation for possible values.
        :vartype sort: str
        """
        params = base.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

########NEW FILE########
__FILENAME__ = support_queues
from libsaas import http, parsers
from libsaas.services import base

from . import resource


class SupportQueueBase(resource.UserVoiceResource):

    path = 'support_queues'

    def wrap_object(self, obj):
        return {'support_queue': obj}


class SupportQueues(SupportQueueBase):

    @base.apimethod
    def get(self, page=None, per_page=None):
        """
        Fetch all the support queues.

        :var page: Where should paging start. If left as `None`, the first page
            is returned.
        :vartype page: int

        :var per_page: How many objects sould be returned. If left as `None`,
            10 objects are returned.
        :vartype per_page: int
        """
        params = base.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

    @base.apimethod
    def sort(self, order):
        """
        Change the order of support queues.

        :var order: A list of support queue IDs in the desired new ordering.
        :vartype order: list
        """
        params = base.get_params(None, locals())
        url = '{0}/sort'.format(self.get_url())

        request = http.Request('PUT', url, params)

        return request, parsers.parse_json


class SupportQueue(SupportQueueBase):
    pass

########NEW FILE########
__FILENAME__ = tickets
from libsaas import http, parsers
from libsaas.services import base

from . import resource


class TicketsBase(resource.UserVoiceResource):

    path = 'tickets'

    def wrap_object(self, obj):
        return {'ticket': obj}


class Tickets(TicketsBase):

    @base.apimethod
    def get(self, page=None, per_page=None, assigne_id=None,
            support_queue_id=None, support_queue=None, filter=None,
            sort=None, state=None, updated_after_date=None):
        """
        Fetch all of the tickets.

        :var page: Where should paging start. If left as `None`, the first page
            is returned.
        :vartype page: int

        :var per_page: How many objects sould be returned. If left as `None`,
            10 objects are returned.
        :vartype per_page: int

        :var assignee_id: The ID of the user assigned to the ticket.
        :vartype assignee_id: int

        :var support_queue_id: The ID of the support queue the ticket is in.
        :vartype support_queue_id: int

        :var support_queue: The name of the support queue the ticket is in.
        :vartype support_queue: str

        :var filter: Either `all` or `assigned_after`.
        :vartype filter: str

        :var sort: How should the returned collection be sorted. Refer to
            upstream documentation for possible values.
        :vartype sort: str

        :var state: Ticket state. Refer to upstream documentation for possible
            values.
        :vartype state: str

        :var updated_after_date: If `filter` is `assigned_after`, a date string
            formatted `yyyy-mm-dd HH:MM:SS -0000`.
        :var updated_after_date: str
        """
        params = base.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

    @base.apimethod
    def upsert(self, obj):
        """
        Create or update a ticket

        :var obj: a Python object representing the ticket. Refer to the upstream
            documentation for details.
        """
        url = '{0}/upsert'.format(self.get_url())
        request = http.Request('PUT', url, self.wrap_object(obj))

        return request, parsers.parse_empty

    @base.apimethod
    def search(self, page=None, per_page=None, query=None):
        """
        Search for tickets.

        :var page: Where should paging start. If left as `None`, the first page
            is returned.
        :vartype page: int

        :var per_page: How many objects sould be returned. If left as `None`,
            10 objects are returned.
        :vartype per_page: int

        :var query: Search string.
        :vartype query: str
        """
        params = base.get_params(None, locals())
        url = '{0}/{1}'.format(self.get_url(), 'search')

        return http.Request('GET', url, params), parsers.parse_json


class TicketNotesBase(resource.UserVoiceTextResource):

    path = 'notes'

    def wrap_object(self, obj):
        return {'note': {'text': obj}}


class TicketNotes(TicketNotesBase):
    pass


class TicketNote(TicketNotesBase):
    pass


class TicketMessages(resource.UserVoiceTextResource):

    path = 'ticket_messages'

    def wrap_object(self, obj):
        return {'ticket_message': obj}


class Ticket(TicketsBase):

    @base.resource(TicketNote)
    def note(self, note_id):
        """
        Return the resource corresponding to a single ticket note.
        """
        return TicketNote(self, note_id)

    @base.resource(TicketNotes)
    def notes(self):
        """
        Return the resource corresponding to all the ticket notes.
        """
        return TicketNotes(self)

    @base.resource(TicketMessages)
    def messages(self):
        """
        Return the resource corresponding to all the ticket messages.
        """
        return TicketMessages(self)

########NEW FILE########
__FILENAME__ = topics
from libsaas import http, parsers
from libsaas.services import base

from . import resource


class TopicsBase(resource.UserVoiceResource):

    path = 'topics'

    def get_url(self):
        if self.object_id is None:
            return '{0}/{1}'.format(self.parent.get_url(), self.path)

        return '{0}/{1}/{2}/articles'.format(self.parent.get_url(), self.path,
                                             self.object_id)


class Topics(TopicsBase):

    def create(self, obj):
        raise base.MethodNotSupported()


class Topic(TopicsBase):

    def get(self):
        raise base.MethodNotSupported()

    def update(self, obj):
        raise base.MethodNotSupported()

    @base.apimethod
    def articles(self, page=None, per_page=None, sort=None):
        """
        Fetch the articles on a given topic.

        :var page: Where should paging start. If left as `None`, the first page
            is returned.
        :vartype page: int

        :var per_page: How many objects sould be returned. If left as `None`,
            10 objects are returned.
        :vartype per_page: int

        :var sort: How should the returned collection be sorted. Refer to
            upstream documentation for possible values.
        :vartype sort: str
        """
        params = base.get_params(None, locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json

    @base.apimethod
    def search(self, page=None, per_page=None, query=None):
        """
        Search for articles on a given topic.

        :var page: Where should paging start. If left as `None`, the first page
            is returned.
        :vartype page: int

        :var per_page: How many objects sould be returned. If left as `None`,
            10 objects are returned.
        :vartype per_page: int

        :var query: Search string.
        :vartype query: str
        """
        params = base.get_params(None, locals())
        url = '{0}/{1}'.format(self.get_url(), 'search')

        return http.Request('GET', url, params), parsers.parse_json

########NEW FILE########
__FILENAME__ = users
from libsaas import http, parsers
from libsaas.services import base

from . import resource, comments, notes, suggestions


class UsersBase(resource.UserVoiceResource):

    path = 'users'

    def wrap_object(self, obj):
        return {'user': obj}


class Users(UsersBase):

    @base.apimethod
    def search(self, page=None, per_page=None, guid=None, query=None):
        """
        Search for users. One of `guid` or `query` mest be present.

        :var page: Where should paging start. If left as `None`, the first page
            is returned.
        :vartype page: int

        :var per_page: How many objects sould be returned. If left as `None`,
            10 objects are returned.
        :vartype per_page: int

        :var guid: Search by SSO GUID
        :vartype guid: str

        :var query: Search by username substring.
        :vartype query: str
        """
        params = base.get_params(None, locals())
        url = '{0}/{1}'.format(self.get_url(), 'search')

        return http.Request('GET', url, params), parsers.parse_json


class User(UsersBase):

    @base.resource(suggestions.UserSuggestions)
    def suggestions(self):
        """
        Return a resource corresponding to all of this user's suggestions.
        """
        return suggestions.UserSuggestions(self)

    @base.resource(notes.UserNotes)
    def notes(self):
        """
        Return the resource corresponding to all of this user's notes.
        """
        return notes.UserNotes(self)

    @base.resource(comments.UserComments)
    def comments(self):
        """
        Return the resource corresponding to all of this user's comments.
        """
        return comments.UserComments(self)

class CurrentUser(base.HierarchicalResource):

    path = 'users'

    @base.apimethod
    def get(self):
        url = '{0}/{1}'.format(self.get_url(), 'current')

        return http.Request('GET', url), parsers.parse_json

########NEW FILE########
__FILENAME__ = analytics
from libsaas import http, parsers

from libsaas.services import base
from .base import YouTubeBaseResource


def translate_param(val):
    return val.replace('_', '-')


class Analytics(YouTubeBaseResource):
    """
    The YouTube Analytics API currently provides a single method that lets
    you retrieve Analytics reports for a YouTube channel.

    https://developers.google.com/youtube/analytics/v1/available_reports.html
    identifies the different reports that you can retrieve. For each report,
    it lists the dimensions that are used to aggregate data,
    available metrics, and supported filtering options.
    """

    APIROOT = 'https://www.googleapis.com/youtube/analytics/v1/reports'

    @base.apimethod
    def get(self, ids, metrics, start_date, end_date, dimensions=None,
           filters=None, max_results=None, start_index=None, sort=None):
        """
        Retrieve YouTube Analytics data

        :var ids: Identifies the YouTube channel or content owner for which
            you are retrieving YouTube Analytics data. To request data for
            a YouTube user, set the ids parameter value to channel==USER_ID.
            To request data for a YouTube CMS content owner, set the ids
            parameter value to contentOwner==OWNER_NAME
        :vartype ids: str

        :var metrics: A comma-separated list of YouTube Analytics metrics,
            such as views or likes,dislikes. See {reports} for a list of the
            reports that you can retrieve and the metrics available in each
            report, and see{metrics} for definitions of those metrics.
        :vartype metrics: str

        :var start_date: The start date for fetching YouTube Analytics data.
            The value should be in YYYY-MM-DD format.
        :vartype start_date: str

        :var end_date: The start date for fetching YouTube Analytics data.
            The value should be in YYYY-MM-DD format.
        :vartype end_date: str

        :var dimensions: A comma-separated list of YouTube Analytics
            dimensions, such as video or ageGroup,gender. See {reports}
            for a list of the reports that you can retrieve and the
            dimensions used for those reports. Also see {dimensions} for
            definitions of those dimensions.
        :vartype dimensions: str

        :var filters: A list of filters that should be applied when retrieving
            YouTube Analytics data. The {reports} identifies the dimensions
            that can be used to filter each report, and {dimensions} defines
            those dimensions. If a request uses multiple filters, join them
            together with a semicolon (;), and the returned result table will
            satisfy both filters. For example, a filters parameter value of
            video==dMH0bHeiRNg;country==IT restricts the result set to include
            data for the given video in Italy.
        :vartype filters: str

        :var max_results: The maximum number of rows to include in the response
        :vartype max_results: str

        :var start_index: The 1-based index of the first entity to retrieve.
            Use this parameter as a pagination mechanism along with the
            max-results parameter.
        :vartype start_index: int

        :var sort: A comma-separated list of dimensions or metrics that
            determine the sort order for YouTube Analytics data. By default
            the sort order is ascending. The '-' prefix causes descending
            sort order
        :vartype sort: str
        """
        params = base.get_params(None, locals(),
                                 translate_param=translate_param)

        request = http.Request('GET', self.get_url(), params)
        return request, parsers.parse_json

    get.__doc__ = get.__doc__.format(
        reports='https://developers.google.com/youtube/analytics'
        '/v1/available_reports.html',
        metrics='https://developers.google.com/youtube/analytics'
        '/v1/dimsmets/mets.html',
        dimensions='https://developers.google.com/youtube/analytics'
        '/v1/dimsmets/dims')

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()

########NEW FILE########
__FILENAME__ = base
from libsaas.services import base


class YouTubeBaseResource(base.Resource):

    APIROOT = None

    def __init__(self, access_token=None):
        """
        Create a YouTube service.

        :var access_token:
        :vartype access_token:
        """
        self.access_token = access_token

        self.add_filter(self.add_auth)

    def add_auth(self, request):
        header = 'Bearer {0}'.format(self.access_token)
        request.headers['Authorization'] = header

    def get_url(self):
        return self.APIROOT

    def set_access_token(self, access_token):
        self.access_token = access_token

########NEW FILE########
__FILENAME__ = service
from libsaas.services import base

from .base import YouTubeBaseResource
from .analytics import Analytics
from . import v3


class YouTube(YouTubeBaseResource):

    APIROOT = 'https://www.googleapis.com/youtube/v3'

    @base.resource(Analytics)
    def analytics(self):
        """
        Return the resource corresponding to the Analytics API
        """
        return Analytics(self.access_token)

    @base.resource(v3.Activities)
    def activities(self):
        """
        Return the resource corresponding to the YouTube Activities
        """
        return v3.Activities(self)

    @base.resource(v3.Channels)
    def channels(self):
        """
        Return the resource corresponding to the YouTube Channels
        """
        return v3.Channels(self)

    @base.resource(v3.GuideCategories)
    def guide_categories(self):
        """
        Return the resource corresponding to the YouTube GuideCategories
        """
        return v3.GuideCategories(self)

    @base.resource(v3.PlaylistItems)
    def playlist_items(self):
        """
        Return the resource corresponding to the YouTube PlaylistItems
        """
        return v3.PlaylistItems(self)

    @base.resource(v3.Playlists)
    def playlists(self):
        """
        Return the resource corresponding to the YouTube Playlists
        """
        return v3.Playlists(self)

    @base.resource(v3.Search)
    def search(self):
        """
        Return the resource corresponding to the YouTube Search
        """
        return v3.Search(self)

    @base.resource(v3.Subscriptions)
    def subscriptions(self):
        """
        Return the resource corresponding to the YouTube Subscriptions
        """
        return v3.Subscriptions(self)

    @base.resource(v3.VideoCategories)
    def video_categories(self):
        """
        Return the resource corresponding to the YouTube VideoCategories
        """
        return v3.VideoCategories(self)

    @base.resource(v3.Videos)
    def videos(self):
        """
        Return the resource corresponding to the YouTube Videos
        """
        return v3.Videos(self)

########NEW FILE########
__FILENAME__ = v3
from libsaas import http, parsers
from libsaas.services import base


class YouTubeResource(base.RESTResource):

    #def get_url(self):
        #return '{0}/{1}'.format(self.parent.get_url(), self.path)

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Activities(YouTubeResource):

    path = 'activities'

    @base.apimethod
    def get(self, part, channelId=None, home=None, mine=None,
           maxResults=None, publishedAfter=None, publishedBefore=None,
           pageToken=None):
        """
        Returns a collection of channel activity events matching the
        request criteria. For example, you can retrieve events
        associated with a particular channel, events associated
        with the user's subscriptions and Google+ friends, or the
        YouTube home page feed, which is customized for each user.

        :var part: The part parameter specifies a comma-separated list
            of one or more activity resource properties that the API
            response will include. The part names that you can include
            in the parameter value are id, snippet, and contentDetails.
        :vartype part: str

        :var channelId: The channelId parameter specifies a unique YouTube
            channel ID. The API will then return a list of that channel's
            activities.
        :vartype channelId: str

        :var home: Set this parameter's value to true to retrieve the activity
            feed that displays on the YouTube home page for the currently
            authenticated user.
        :vartype home: bool

        :var mine: Set this parameter's value to true to retrieve a feed
            of the authenticated user's activities.
        :vartype mine: bool

        :var maxResults: The maxResults parameter specifies the maximum number
            of items that should be returned in the result set. Acceptable
            values are 0 to 50, inclusive. The default value is 5.
        :vartype maxResults: int

        :var publishedAfter: The publishedAfter parameter specifies the
            earliest date and time that an activity could have occurred
            for that activity to be included in the API response. If the
                parameter value specifies a day, but not a time, then any
                activities that occurred that day will be included in the
                result set. The value is specified in
                ISO 8601 (YYYY-MM-DDThh:mm:ss.sZ) format.
        :vartype publishedAfter: str

        :var publishedBefore: The publishedBefore parameter specifies the date
            and time before which an activity must have occurred for that
            activity to be included in the API response. If the parameter
            value specifies a day, but not a time, then any activities that
            occurred that day will be excluded from the result set. The
            value is specified in ISO 8601 (YYYY-MM-DDThh:mm:ss.sZ) format.
        :vartype publishedBefore: str

        :var pageToken: The pageToken parameter identifies a specific page in
            the result set that should be returned. In an API response, the
            nextPageToken and prevPageToken properties identify other pages
            that could be retrieved.
        :vartype pageToken: str
        """
        params = base.get_params(None, locals())

        request = http.Request('GET', self.get_url(), params)
        return request, parsers.parse_json


class Channels(YouTubeResource):

    path = 'channels'

    @base.apimethod
    def get(self, part, id=None, mine=None, categoryId=None,
            mySubscribers=None, maxResults=None, pageToken=None):
        """
        Returns a collection of zero or more channel resources that
        match the request criteria.

        :var part: The part parameter specifies a comma-separated list
            of one or more channel resource properties that the API
            response will include. The part names that you can include
            in the parameter value are id, snippet, contentDetails,
            statistics, and topicDetails.
        :vartype part: str

        :var id: The id parameter specifies a comma-separated list of
            the YouTube channel ID(s) for the resource(s) that are
            being retrieved. In a channel resource, the id property
            specifies the channel's YouTube channel ID.
        :vartype id: str

        :var mine: Set this parameter's value to true to instruct the
            API to only return channels owned by the authenticated user.
        :vartype mine: bool

        :var categoryId: The categoryId parameter specifies a
            Freebase topic ID thereby requesting YouTube channels associated
            with that topic. In a channel resource, the
            (key).topicDetails.topicIds[] property identifies the topic IDs
            associated with that channel.
        :vartype categoryId: str

        :var mySubscribers: Set this parameter's value to true to retrieve
            a list of channels that subscribed to the authenticated
            user's channel.
        :vartype mySubscribers: str

        :var maxResults: The maxResults parameter specifies the maximum number
            of items that should be returned in the result set. Acceptable
            values are 0 to 50, inclusive. The default value is 5.
        :vartype maxResults: int

        :var pageToken: The pageToken parameter identifies a specific page in
            the result set that should be returned. In an API response, the
            nextPageToken and prevPageToken properties identify other pages
            that could be retrieved.
        :vartype pageToken: str
        """
        params = base.get_params(None, locals())

        request = http.Request('GET', self.get_url(), params)
        return request, parsers.parse_json


class GuideCategories(YouTubeResource):

    path = 'guideCategories'

    @base.apimethod
    def get(self, part, id=None, regionCode=None, hl=None):
        """
        Returns a collection of categories that can be associated with
        YouTube videos.

        :var part: The part parameter specifies a comma-separated list
            of one or more guideCategory resource properties that
            the API response will include. The part names that you
            can include in the parameter value are id and snippet.
        :vartype part: str

        :var id: The id parameter specifies a comma-separated list
            of the YouTube channel category ID(s) for the resource(s)
            that are being retrieved. In a guideCategory resource, the
            id property specifies the YouTube channel category ID.
        :vartype id: str

        :var regionCode: The regionCode parameter instructs the API to return
            the list of video categories available in the specified country.
            The parameter value is an ISO 3166-1 alpha-2 country code.
        :vartype regionCode: str

        :var hl: The hl parameter specifies the language that should be used
            for text values in the API response. The default value is en_US.
        :vartype hl: str
        """

        params = base.get_params(None, locals())

        request = http.Request('GET', self.get_url(), params)
        return request, parsers.parse_json


class PlaylistItems(YouTubeResource):

    path = 'playlistItems'

    @base.apimethod
    def get(self, part, id=None, playlistId=None,
            maxResults=None, pageToken=None):
        """
        Returns a collection of playlist items that match the API request
        parameters. You can retrieve all of the playlist items in a specified
        playlist or retrieve one or more playlist items by their unique IDs.

        :var part: The part parameter specifies a comma-separated list of one
            or more playlistItem resource properties that the API response will
            include. The part names that you can include in the parameter value
            are id, snippet, and contentDetails.
        :vartype part: str

        :var id: The id parameter specifies a comma-separated list of one or
            more unique playlist item IDs. Note that even though this is an
            optional parameter, every request to retrieve playlist items must
            specify a value for either the id parameter or the playlistId
            parameter.
        :vartype id: str

        :var playlistId: The playlistId parameter specifies the unique ID of
            the playlist for which you want to retrieve playlist items. Note
            that even though this is an optional parameter, every request to
            retrieve playlist items must specify a value for either the id
            parameter or the playlistId parameter.
        :vartype playlistId: str

        :var maxResults: The maxResults parameter specifies the maximum number
            of items that should be returned in the result set. Acceptable
            values are 0 to 50, inclusive. The default value is 5.
        :vartype maxResults: int

        :var pageToken: The pageToken parameter identifies a specific page in
            the result set that should be returned. In an API response, the
            nextPageToken and prevPageToken properties identify other pages
            that could be retrieved.
        :vartype pageToken: str
        """
        params = base.get_params(None, locals())

        request = http.Request('GET', self.get_url(), params)
        return request, parsers.parse_json


class Playlists(YouTubeResource):

    path = 'playlists'

    @base.apimethod
    def get(self, part, id=None, mine=None,
            maxResults=None, pageToken=None):
        """
        Returns a collection of playlists that match the API request
        parameters.

        :var part: The part parameter specifies a comma-separated list of one
            or more playlist resource properties that the API response will
            include. The part names that you can include in the parameter
            value are id, snippet, and status.
        :vartype part: str

        :var id: The id parameter specifies a comma-separated list of the
        YouTube playlist ID(s) for the resource(s) that are being retrieved.
            In a playlist resource, the id property specifies the playlist's
            YouTube playlist ID.
        :vartype id: str

        :var mine: Set this parameter's value to true to instruct the API to
            only return playlists owned by the authenticated user.
        :vartype mine: bool

        :var maxResults: The maxResults parameter specifies the maximum number
            of items that should be returned in the result set. Acceptable
            values are 0 to 50, inclusive. The default value is 5.
        :vartype maxResults: int

        :var pageToken: The pageToken parameter identifies a specific page in
            the result set that should be returned. In an API response, the
            nextPageToken and prevPageToken properties identify other pages
            that could be retrieved.
        :vartype pageToken: str
        """

        params = base.get_params(None, locals())

        request = http.Request('GET', self.get_url(), params)
        return request, parsers.parse_json


class Search(YouTubeResource):

    path = 'search'

    @base.apimethod
    def get(self, part, q=None, relativeToVideo=None, maxResults=None,
            order=None, published=None, type=None, videoCaption=None,
            videoDefiniton=None, videoDimension=None,
            videoDuration=None, videoLicense=None,
            topicId=None, pageToken=None):
        """
        Returns a collection of search results that match the query parameters
        specified in the API request. By default, a search result set
        identifies matching video, channel, and playlist resources, but you
        can also configure queries to only retrieve a specific type of resource

        :var part: The part parameter specifies a comma-separated list of one
            or more search resource properties that the API response will
            include. The part names that you can include in the parameter
            value are id and snippet.
        :vartype part: str

        :var q: The q parameter specifies the query term to search for.
        :vartype q: str

        :var relativeToVideo: The relatedToVideo parameter retrieves a list
            of videos that are related to the video that the parameter value
            identifies. The parameter value must be set to a YouTube video
            ID and, if you are using this parameter, the type parameter must
            be set to video.
        :vartype relativeToVideo: str

        :var maxResults: The maxResults parameter specifies the maximum number
            of items that should be returned in the result set. Acceptable
            values are 0 to 50, inclusive. The default value is 5.
        :vartype maxResults: int

        :var order: The order parameter specifies the method that will be used
            to order resources in the API response.
            The default value is relevance. Acceptable values are: date,
            rating, relevance and view_count.
        :vartype order: str

        :var published: The published parameter indicates that the API response
            should only contain resources created within the specified time
            period. Acceptable values are: any, thisWeek, today and thisMonth.
        :vartype publsihed: str

        :var type: The type parameter restricts a search query to only retrieve
            a particular type of resource.
            The default value is video,channel,playlist.
        :vartype type: str

        :var videoCaption: The videoCaption parameter indicates whether the
            API should filter video search results based on whether they have
            captions. Acceptable values are: any, closedCaption and none.
        :vartype videoCaption: str

        :var videoDefiniton: The videoDefinition parameter lets you restrict a
            search to only include HD videos. Acceptable values are: any, high
            and standard.
        :vartype videoDefiniton: str

        :var videoDimension: The videoDimension parameter lets you restrict
            a search to only retrieve 2D or 3D videos. Acceptable values are:
            2d, 3d and any.
        :vartype videoDimension: str

        :var videoDuration: The videoDuration parameter filters video search
            results based on their duration. Acceptable values are: any, long,
            medium and shot.
        :var videoDuration: str

        :var videoLicense: The videoLicense parameter filters search results
            to only include videos with a particular license. Acceptable values
            are: any, creativeCommons and youtube.
        :var videoLicense: str

        :var topicId: The topicId parameter indicates that the API response
            should only contain resources associated with the specified topic.
            The value identifies a Freebase topic ID.
        :vartype topicId: str

        :var pageToken: The pageToken parameter identifies a specific page in
            the result set that should be returned. In an API response, the
            nextPageToken and prevPageToken properties identify other pages
            that could be retrieved.
        :vartype pageToken: str
        """
        params = base.get_params(None, locals())

        request = http.Request('GET', self.get_url(), params)
        return request, parsers.parse_json


class Subscriptions(YouTubeResource):

    path = 'subscriptions'

    @base.apimethod
    def get(self, part, id=None, mine=None, channelId=None,
            forChannelId=None, maxResults=None, order=None, pageToken=None):
        """
        Returns subscription resources that match the API request criteria.

        :var part: The part parameter specifies a comma-separated list of one
            or more subscription resource properties that the API response
            will include. The part names that you can include in the parameter
            value are id, snippet, and contentDetails.
        :vartype: str

        :var id: The id parameter specifies a comma-separated list of the
            YouTube subscription ID(s) for the resource(s) that are being
            retrieved. In a subscription resource, the id property
            specifies the YouTube subscription ID.
        :vartype id: str

        :var mine: Set this parameter's value to True to retrieve a feed of
            the authenticated user's subscriptions.
        :vartype: bool

        :var channelId: The channelId parameter specifies a YouTube
            channel ID. The API will only return that channel's subscriptions.
        :vartype channelId: str

        :var forChannelId: The forChannelId parameter specifies a
            comma-separated list of channel IDs. The API response
            will then only contain subscriptions matching those channels.
        :vartype forChannelId: str

        :var maxResults: The maxResults parameter specifies the maximum number
            of items that should be returned in the result set. Acceptable
            values are 0 to 50, inclusive. The default value is 5.
        :vartype maxResults: int

        :var order: The order parameter specifies the method that will be used
            to sort resources in the API response. Acceptable values are:
            alphabetical, relevance and unread.
        :vartype order: str

        :var pageToken: The pageToken parameter identifies a specific page in
            the result set that should be returned. In an API response, the
            nextPageToken and prevPageToken properties identify other pages
            that could be retrieved.
        :vartype pageToken: str
        """
        params = base.get_params(None, locals())

        request = http.Request('GET', self.get_url(), params)
        return request, parsers.parse_json


class VideoCategories(YouTubeResource):

    path = 'videoCategories'

    @base.apimethod
    def get(self, part, id=None, regionCode=None, hl=None):
        """
        Returns a list of categories that can be associated with
        YouTube videos.

        :var part: The part parameter specifies the videoCategory
            resource parts that the API response will include.
            Supported values are id and snippet.
        :vartype part: str

        :var id: The id parameter specifies a comma-separated list
            of video category IDs for the resources that you are retrieving.
        :vartype id: str

        :var regionCode: The regionCode parameter instructs the API to return
            the list of video categories available in the specified country.
            The parameter value is an ISO 3166-1 alpha-2 country code.
        :vartype regionCode: str

        :var hl: The hl parameter specifies the language that should be used
            for text values in the API response. The default value is en_US.
        :vartype hl: str
        """
        params = base.get_params(None, locals())

        request = http.Request('GET', self.get_url(), params)
        return request, parsers.parse_json


class Videos(YouTubeResource):

    path = 'videos'

    @base.apimethod
    def get(self, part, id):
        """
        Returns a collection of videos that match the API request parameters.

        :var part: The part parameter specifies a comma-separated list of one
            or more video resource properties that the API response will
            include. The part names that you can include in the parameter value
            are id, snippet, contentDetails, player, statistics, status, and
            topicDetails.
        :vartype part: str

        :var id: The id parameter specifies a comma-separated list of the
            YouTube video ID(s) for the resource(s) that are being retrieved.
            In a video resource, the id property specifies the video's ID.
        :vartype id: str
        """
        params = base.get_params(None, locals())

        request = http.Request('GET', self.get_url(), params)
        return request, parsers.parse_json

########NEW FILE########
__FILENAME__ = resources
from libsaas import http, parsers, port
from libsaas.services import base


class ZendeskResource(base.RESTResource):

    path = None

    @base.apimethod
    def get(self, page=None, per_page=None):
        """
        For single-object resources, fetch the object's data. For collections,
        fetch all of the objects.

        :var page: For collections, where should paging start. If left as
            `None`, the first page is returned.
        :vartype page: int

        :var per_page: For collections, how many objects sould be returned. The
            maximum is 100. If left as `None`, 100 objects are returned.
        :vartype per_page: int
        """
        params = base.get_params(('page', 'per_page'), locals())
        request = http.Request('GET', self.get_url(), params)

        return request, parsers.parse_json


class Tags(ZendeskResource):

    path = 'tags'

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class TicketsBase(ZendeskResource):

    path = 'tickets'


class Tickets(TicketsBase):

    @base.apimethod
    def recent(self, page=None, per_page=None):
        """
        Fetch all recent tickets. The parameters are the same as for the `get`
        method.
        """
        url = '{0}/{1}'.format(self.get_url(), 'recent')
        params = base.get_params(('page', 'per_page'), locals())

        return http.Request('GET', url, params), parsers.parse_json


class Ticket(TicketsBase):

    # XXX gives 404 in Zendesk
    @base.apimethod
    def collaborators(self, page=None, per_page=None):
        """
        Fetch the collaborators on a ticket.
        """
        url = '{0}/{1}'.format(self.get_url(), 'collaborators')
        params = base.get_params(('page', 'per_page'), locals())

        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def audits(self, page=None, per_page=None):
        """
        Fetch the audits on a ticket.
        """
        url = '{0}/{1}'.format(self.get_url(), 'audits')
        params = base.get_params(('page', 'per_page'), locals())

        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def metrics(self):
        """
        Fetch the ticket metrics.
        """
        url = '{0}/{1}'.format(self.get_url(), 'metrics')

        return http.Request('GET', url), parsers.parse_json

    @base.resource(Tags)
    def tags(self):
        """
        Return the resource corresponding to tags.
        """
        return Tags(self)


class UsersBase(ZendeskResource):

    path = 'users'


class Users(UsersBase):

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.apimethod
    def search(self, query, page=None, per_page=None):
        """
        Fetch users based on their usernames or email addresses.

        :var query: A username or an email address.
        :vartype query: str
        """
        url = '{0}/{1}'.format(self.get_url(), 'search')
        params = base.get_params(('query', 'page', 'per_page'), locals())

        return http.Request('GET', url, params), parsers.parse_json


class CurrentUser(base.HierarchicalResource):

    path = 'users'

    @base.apimethod
    def get(self):
        url = '{0}/{1}'.format(self.get_url(), 'me')

        return http.Request('GET', url), parsers.parse_json


class User(UsersBase):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.apimethod
    def tickets_requested(self, page=None, per_page=None):
        """
        Fetch tickets requested by this user.
        """
        url = '{0}/tickets/{1}'.format(self.get_url(), 'requested')
        params = base.get_params(('page', 'per_page'), locals())

        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def tickets_ccd(self, page=None, per_page=None):
        """
        Fetch tickets where this user is CC'd.
        """
        url = '{0}/tickets/{1}'.format(self.get_url(), 'ccd')
        params = base.get_params(('page', 'per_page'), locals())

        return http.Request('GET', url, params), parsers.parse_json


class GroupsBase(ZendeskResource):

    path = 'groups'


class Groups(GroupsBase):

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.apimethod
    def assignable(self, page=None, per_page=None):
        """
        Fetch assignable groups.
        """
        url = '{0}/{1}'.format(self.get_url(), 'assignable')
        params = base.get_params(('page', 'per_page'), locals())

        return http.Request('GET', url, params), parsers.parse_json


class Group(GroupsBase):

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()


class ActivitiesBase(ZendeskResource):

    path = 'activities'

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Activities(ActivitiesBase):

    @base.apimethod
    def get(self, since=None, page=None, per_page=None):
        """
        Fetch the list of activities

        :var since: Timestamp offset in UTC on ISO8601 form %Y-%m-%dT%H:%M:%SZ
        :vartype since: str
        """
        params = base.get_params(('since', 'page', 'per_page'), locals())

        return http.Request('GET', self.get_url(), params), parsers.parse_json


class Activity(ActivitiesBase):
    pass


class SatisfactionRatingsBase(ZendeskResource):

    path = 'satisfaction_ratings'

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class SatisfactionRatings(SatisfactionRatingsBase):

    @base.apimethod
    def received(self, page=None, per_page=None, sort_order=None):
        """
        Fetch ratings provided by customers.
        """
        url = '{0}/{1}'.format(self.get_url(), 'received')
        params = base.get_params(('page', 'per_page', 'sort_order'), locals())

        return http.Request('GET', url, params), parsers.parse_json


class SatisfactionRating(SatisfactionRatingsBase):
    pass


class ViewsBase(ZendeskResource):

    path = 'views'

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()


class Views(ViewsBase):

    @base.apimethod
    def active(self, page=None, per_page=None):
        """
        Fetch active shared and personal Views available to the current user.
        """
        url = '{0}/{1}'.format(self.get_url(), 'active')
        params = base.get_params(('page', 'per_page'), locals())

        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def count_many(self, ids):
        """
        Calculates the size of the view in terms of number of tickets the view
        will return. Only returns values for personal and shared views
        accessible to the user performing the request.

        :var ids: List of view ids
        :vartype ids: tuple of int
        """

        def serializer(val):
            if isinstance(val, (list, tuple)):
                return port.to_b(',').join(map(port.to_b, val))
            return base.serialize_param(val)

        url = '{0}/{1}'.format(self.get_url(), 'count_many')
        params = base.get_params(('ids',), locals(), serializer)
        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def preview(self, conditions, columns=None, group_by=None,
                group_order=None, sort_by=None, sort_order=None):
        """
        Views can be previewed by constructing the conditions
        in the proper format. See {0}.

        :var conditions: A representation of the conditions that constitute the
            view. See {1}.
        :vartype conditions: dict

        :var columns: The ticket fields to display. System fields are looked up
            by name, custom fields by title or id.
        :vartype columns: tuple of int or str

        :var group_by: When present, the field by which the tickets are grouped
        :vartype group_by: str

        :var group_order: The direction the tickets are grouped.
            May be one of 'asc' or 'desc'
        :vartype group_order: str

        :var sort_by: The field used for sorting. This will either be a title
            or a custom field id.
        :vartype sort_by: str

        :var sort_order: The direction the tickets are sorted. May be one of
            'asc' or 'desc'
        :vartype sort_order: str
        """

        url = '{0}/{1}'.format(self.get_url(), 'preview')
        params = base.get_params(('columns', 'group_by', 'group_order',
                                  'sort_by', 'sort_order'), locals())

        view = {'view': conditions.copy()}
        view['view'].update({'output': params})

        request = http.Request('POST', url, view)
        return request, parsers.parse_json

    preview.__doc__ = preview.__doc__.format(
        'http://developer.zendesk.com/documentation/'
        'rest_api/views.html#previewing-views',
        'http://developer.zendesk.com/documentation/'
        'rest_api/views.html#conditions')


    @base.apimethod
    def preview_count(self, conditions):
        """
        Returns the ticket count for a single preview. See {0}.

        :var conditions: A representation of the conditions that constitute the
            view. See {1}.
        :vartype conditions: dict
        """

        url = '{0}/{1}'.format(self.get_url(), 'preview/count')

        view = {'view': conditions.copy()}
        request = http.Request('POST', url, view)
        return request, parsers.parse_json

    preview_count.__doc__ = preview.__doc__.format(
        'http://developer.zendesk.com/documentation/'
        'rest_api/views.html#preview-count',
        'http://developer.zendesk.com/documentation/'
        'rest_api/views.html#conditions')


class View(ViewsBase):

    @base.apimethod
    def execute(self, sort_by=None, sort_order=None):
        """
        Get the view output. View output sorting can be controlled by passing
        the sort_by and sort_order parameters.

        :var sort_by: The field used for sorting. This will either be a title
            or a custom field id.
        :vartype sort_by: str

        :var sort_order: The direction the tickets are sorted. May be one of
            'asc' or 'desc'
        :vartype sort_order: str
        """
        url = '{0}/{1}'.format(self.get_url(), 'execute')
        params = base.get_params(('sort_by', 'sort_order'), locals())

        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def count(self):
        """
        Returns the ticket count for a single view.
        """
        url = '{0}/{1}'.format(self.get_url(), 'count')

        return http.Request('GET', url), parsers.parse_json

    @base.apimethod
    def tickets(self, page=None, per_page=None):
        """
        Returns the ticket for a single view.
        """
        params = base.get_params(None, locals())
        url = '{0}/{1}'.format(self.get_url(), 'tickets')

        return http.Request('GET', url, params), parsers.parse_json


class Exports(ZendeskResource):

    path = 'exports'

    def get(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def create(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def update(self, *args, **kwargs):
        raise base.MethodNotSupported()

    def delete(self, *args, **kwargs):
        raise base.MethodNotSupported()

    @base.apimethod
    def tickets(self, start_time):
        """
        Retrieve tickets that changed in Zendesk "since last you asked"

        :var start_time:  The time of the oldest ticket you are interested in.
            Tickets modified on or since this time will be returned. The start
            time is provided as the number of seconds since epoch UTC.
        :vartype start_time: int
        """
        url = '{0}/{1}'.format(self.get_url(), 'tickets')
        params = base.get_params(('start_time',), locals())

        return http.Request('GET', url, params), parsers.parse_json

    @base.apimethod
    def sample(self, start_time):
        """
        This end point is only to be used for testing the incremental export
        format. It is more relaxed in terms of rate limiting,
        but will only return up to 50 records.

        :var start_time:  The time of the oldest ticket you are interested in.
            Tickets modified on or since this time will be returned. The start
            time is provided as the number of seconds since epoch UTC.
        :vartype start_time: int
        """
        url = '{0}/{1}'.format(self.get_url(), 'tickets/sample')
        params = base.get_params(('start_time',), locals())

        return http.Request('GET', url, params), parsers.parse_json

########NEW FILE########
__FILENAME__ = service
import json

from libsaas import http, parsers, port

from libsaas.filters import auth
from libsaas.services import base

from . import resources


class Zendesk(base.Resource):
    """
    """
    def __init__(self, subdomain, username, password):
        """
        Create a Zendesk service.

        :var subdomain: The account-specific part of the Zendesk domain, for
            instance use `mycompany` if your Zendesk domain is
            `mycompany.zendesk.com`.
        :vartype subdomain: str

        :var username: The email of the authenticated agent.
        :vartype username: str

        :var password: The password of the authenticated agent.
        :vartype password: str
        """
        tmpl = '{0}.zendesk.com/api/v2'
        self.apiroot = http.quote_any(tmpl.format(port.to_u(subdomain)))
        self.apiroot = 'https://' + self.apiroot

        self.add_filter(auth.BasicAuth(username, password))
        self.add_filter(self.use_json)

    def get_url(self):
        return self.apiroot

    def use_json(self, request):
        request.headers['Content-Type'] = 'application/json'
        request.headers['Accept'] = 'application/json'

        request.uri += '.json'

        if request.method.upper() not in http.URLENCODE_METHODS:
            request.params = json.dumps(request.params)

    @base.resource(resources.Tickets)
    def tickets(self):
        """
        Return the resource corresponding to all the tickets.
        """
        return resources.Tickets(self)

    @base.resource(resources.Ticket)
    def ticket(self, ticket_id):
        """
        Return the resource corresponding to a single ticket.
        """
        return resources.Ticket(self, ticket_id)

    @base.resource(resources.Users)
    def users(self):
        """
        Return the resource corresponding to all users.
        """
        return resources.Users(self)

    @base.resource(resources.User, resources.CurrentUser)
    def user(self, user_id=None):
        """
        Return the resource corresponding to a single user. If `user_id` is
        `None` the returned resource is the currently authenticated user,
        otherwise it is the user with the given ID number.
        """
        if user_id is None:
            return resources.CurrentUser(self)
        return resources.User(self, user_id)

    @base.resource(resources.Groups)
    def groups(self):
        """
        Return the resource corresponding to all groups.
        """
        return resources.Groups(self)

    @base.resource(resources.Group)
    def group(self, group_id):
        """
        Return the resource corresponding to a single group.
        """
        return resources.Group(self, group_id)

    @base.resource(resources.Activities)
    def activities(self):
        """
        Return the resource corresponding to all activities.
        """
        return resources.Activities(self)

    @base.resource(resources.Activity)
    def activity(self, activity_id):
        """
        Return the resource corresponding to a single activity.
        """
        return resources.Activity(self, activity_id)

    @base.resource(resources.SatisfactionRatings)
    def satisfaction_ratings(self):
        """
        Return the resource corresponding to all satisfaction ratings.
        """
        return resources.SatisfactionRatings(self)

    @base.resource(resources.SatisfactionRating)
    def satisfaction_rating(self, rating_id):
        """
        Return the resource corresponding to a single satisfaction rating.
        """
        return resources.SatisfactionRating(self, rating_id)

    @base.apimethod
    def search(self, query, sort_order=None,
               sort_by=None, page=None, per_page=None):
        """
        Fetch the results of a search on your Zendesk account. For details on
        searching, see
        http://developer.zendesk.com/documentation/rest_api/search.html

        :var query: A free-form search term.
        :vartype query: str

        :var sort_order: Optional order in which to sort the results.
        :vartype query: str

        :var sort_by: Optional term by which to sort the results.
        :vartype sort_by: str
        """
        url = '{0}/{1}'.format(self.get_url(), 'search')
        params = base.get_params(('query', 'sort_order', 'sort_by',
                                  'page', 'per_page'), locals())

        return http.Request('GET', url, params), parsers.parse_json

    @base.resource(resources.Views)
    def views(self):
        """
        Return the resource corresponding to all views.
        """
        return resources.Views(self)

    @base.resource(resources.View)
    def view(self, view_id):
        """
        Return the resource corresponding to a single view.
        """
        return resources.View(self, view_id)

    @base.resource(resources.Exports)
    def exports(self):
        """
        Return the resource corresponding to exports.
        """
        return resources.Exports(self)

    @base.resource(resources.Tags)
    def tags(self):
        """
        Return the resource corresponding to tags.
        """
        return resources.Tags(self)

########NEW FILE########
__FILENAME__ = xml
"""
XML utilities.
"""
from __future__ import absolute_import

import collections
import os

from libsaas import http, port


# check for explicit request to use a specific library
_library = os.getenv("LIBSAAS_XML_LIBRARY")

if _library == "lxml":
    from lxml import etree
elif _library == "cElementTree":
    from xml.etree import cElementTree as etree
elif _library == "ElementTree":
    from xml.etree import ElementTree as etree
else:
    # try various implementations until one works
    try:
        from lxml import etree
    except ImportError:
        try:
            from xml.etree import cElementTree as etree
        except ImportError:
            from xml.etree import ElementTree as etree

del _library


class XMLParserException(Exception):
    """
    XML document not well formed
    """
    def __str__(self):
        return self.__doc__


def value_for_element(elem):
    # We want to have tag attributes
    elem_dict = dict(
        ('@{0}'.format(attrib), value)
        for attrib, value in elem.attrib.items() if attrib != 'type'
    )

    elem_text = elem.text and elem.text.strip()
    elem_type = elem.attrib.get('type', None)

    if elem_type == 'integer':
        value = int(elem_text)
    elif elem_type == 'float':
        value = float(elem_text)
    elif elem_type == 'boolean':
        value = elem_text.lower() == 'true'
    elif elem_type == 'array':
        tags = set([child.tag for child in elem])

        if not tags:
            return []

        if len(tags) > 1:
            raise XMLParserException()

        value = {
            tags.pop(): [value_for_element(child) for child in elem]
        }
    else:
        value = elem_text

    if not value:
        d = collections.defaultdict(list)
        for child in elem:
            d[child.tag].append(value_for_element(child))

        for key, value in d.items():
            if len(value) == 1:
                elem_dict[key] = value[0]
            else:
                elem_dict[key] = value

        return elem_dict or None

    if elem_dict:
        elem_dict.update({elem.tag: value})
        return elem_dict
    else:
        return value


def parse_xml(body, code, headers):
    """
    Return a dictionary.

    Transformation is done assuming:
    1.  If a tag indicates its value type, we'll try to cast it.
    2.  Siblings with the same tag name, become a list.
    3.  Attributes become a dict key starting with '@'.

    <duck>
        <name>Donald</name>
        <birth_date type="datetime">1934-06-04T00:00:00</birth_date>
        <first_film/>
        <last_film></last_film>
        <species href="http://en.wikipedia.org/wiki/Pekin_duck"/>
        <created_by href="http://en.wikipedia.org/wiki/Disney">
            <name>Walt Disney</name>
            <cryopreserved type="boolean">true</cryopreserved>
        </created_by>
        <family>
            <children type="array"></children>
            <uncles type="array">
                <uncle><name>Scrooge McDuck</name></uncle>
                <uncle><name>Ludwig Von Drake</name></uncle>
            </uncles>
            <nephew><name>Huey</name></nephew>
            <nephew><name>Dewey</name></nephew>
            <nephew><name>Louie</name></nephew>
        </family>
    </duck>

    {'duck': {'birth_date': '1934-06-04T00:00:00',
              'created_by': {'@href': 'http://en.wikipedia.org/wiki/Disney',
                             'cryopreserved': True,
                             'name': 'Walt Disney'},
              'family': {'nephew': [{'name': 'Huey'},
                                    {'name': 'Dewey'},
                                    {'name': 'Louie'}],
                         'children': [],
                         'uncles': {'uncle': [{'name': 'Scrooge McDuck'},
                                              {'name': 'Ludwig Von Drake'}]}},
              'first_film': None,
              'last_film': None,
              'name': 'Donald',
              'species': {'@href': 'http://en.wikipedia.org/wiki/Pekin_duck'}}
    }
    """
    if not 200 <= code < 300:
        raise http.HTTPError(body, code, headers)

    root_elem = etree.fromstring(body)
    return {
        root_elem.tag: value_for_element(root_elem)
    }


def element_for_value(obj, parent):
    for key, value in obj.items():
        if isinstance(value, dict):
            node = etree.SubElement(parent, key)
            element_for_value(value, node)
        elif isinstance(value, list):
            if not value:
                node = etree.SubElement(parent, key)

            for item in value:
                node = etree.SubElement(parent, key)
                element_for_value(item, node)
        else:
            if key.startswith('@'):
                parent.set(key.lstrip('@'), value)
            else:
                node = etree.SubElement(parent, key)
                node.text = (port.to_u(value)
                             if value is not None else port.to_u(''))


def dict_to_xml(obj):
    """
    Return a xml representation of the given dictionary:
    1.  keys of the dictionary become sublements.
    2.  if a value is a list, then key is a set of sublements.
    3.  keys starting with '@' became an attribute.

    {'duck': {'birth_date': '1934-06-04T00:00:00',
              'created_by': {'@href': 'http://en.wikipedia.org/wiki/Disney',
                             'cryopreserved': True,
                             'name': 'Walt Disney'},
              'family': {'nephew': [{'name': 'Huey'},
                                    {'name': 'Dewey'},
                                    {'name': 'Louie'}],
                         'children': [],
                         'uncles': {'uncle': [{'name': 'Scrooge McDuck'},
                                              {'name': 'Ludwig Von Drake'}]}},
              'first_film': None,
              'last_film': None,
              'name': 'Donald',
              'species': {'@href': 'http://en.wikipedia.org/wiki/Pekin_duck'}}
    }

    <?xml version="1.0" encoding="UTF-8"?>
    <duck>
        <name>Donald</name>
        <family>
            <children />
            <nephew><name>Huey</name></nephew>
            <nephew><name>Dewey</name></nephew>
            <nephew><name>Louie</name></nephew>
            <uncles>
                <uncle><name>Scrooge McDuck</name></uncle>
                <uncle><name>Ludwig Von Drake</name></uncle>
            </uncles>
        </family>
        <last_film />
        <first_film />
        <created_by href="http://en.wikipedia.org/wiki/Disney">
            <cryopreserved>True</cryopreserved>
            <name>Walt Disney</name>
        </created_by>
        <birth_date>1934-06-04T00:00:00</birth_date>
        <species href="http://en.wikipedia.org/wiki/Pekin_duck" />
    </duck>
    """
    if not obj:
        return

    # top level dictionary must contain a single entry
    # corresponding to the root element
    key, value = obj.popitem()

    root = etree.Element(key)
    element_for_value(value, root)
    return (b'<?xml version="1.0" encoding="UTF-8"?>' +
                etree.tostring(root, encoding='utf-8'))

########NEW FILE########
__FILENAME__ = test_basecamp
import json
import unittest

from libsaas import port
from libsaas.services.base import MethodNotSupported
from libsaas.executors import test_executor
from libsaas.services import basecamp


class BasecampTestCase(unittest.TestCase):

    def setUp(self):
        self.executor = test_executor.use()
        self.executor.set_response(b'{}', 200, {})

        self.service = basecamp.Basecamp('my-account-id','my-access-token')

    def expect(self, method=None, uri=None, params={}):
        if method:
            self.assertEqual(method, self.executor.request.method)

        if uri:
            self.assertEqual(
                self.executor.request.uri,
                'https://basecamp.com/my-account-id/api/v1' + uri + '.json')

        if params:
            self.assertEqual(self.executor.request.params, params)

    def test_projects(self):
        self.service.projects().get()
        self.expect('GET', '/projects', {})

        self.service.projects().archived()
        self.expect('GET', '/projects/archived', {})

        self.service.project('1234').get()
        self.expect('GET', '/projects/1234', {})

        obj = {'foo': 'bar'}
        self.service.projects().create(obj)
        self.expect('POST', '/projects', json.dumps(obj))

        self.service.project(1234).update(obj)
        self.expect('PUT', '/projects/1234', json.dumps(obj))

        self.service.project(1234).delete()
        self.expect('DELETE', '/projects/1234', {})

        self.service.project('1234').accesses().get()
        self.expect('GET', '/projects/1234/accesses', {})

        with port.assertRaises(MethodNotSupported):
            self.service.project(1234).accesses().create({})
        with port.assertRaises(MethodNotSupported):
            self.service.project(1234).access(1234).update({})
        with port.assertRaises(MethodNotSupported):
            self.service.project(1234).access(1234).delete({})

        self.service.project(1234).accesses().grant(obj)
        self.expect('POST', '/projects/1234/accesses', json.dumps(obj))

        self.service.project(1234).access(1234).revoke()
        self.expect('DELETE', '/projects/1234/accesses/1234', {})

        self.service.project('1234').events().get(since='2013-01-01')
        self.expect('GET', '/projects/1234/events', {'since': '2013-01-01'})

        self.service.project('1234').topics().get()
        self.expect('GET', '/projects/1234/topics', {})
        self.service.project('1234').topics().get(page=2)
        self.expect('GET', '/projects/1234/topics', {'page': 2})

        with port.assertRaises(MethodNotSupported):
            self.service.project(1234).topics().create({})

        with port.assertRaises(MethodNotSupported):
            self.service.project(1234).messages().get()

        self.service.project(1234).messages().create(obj)
        self.expect('POST', '/projects/1234/messages', json.dumps(obj))

        self.service.project('1234').message(1234).get()
        self.expect('GET', '/projects/1234/messages/1234', {})
        self.service.project('1234').message(1234).update(obj)
        self.expect('PUT', '/projects/1234/messages/1234', json.dumps(obj))
        self.service.project('1234').message(1234).delete()
        self.expect('DELETE', '/projects/1234/messages/1234', {})

        with port.assertRaises(MethodNotSupported):
            self.service.project(1234).message(1234).comments().get()

        self.service.project(1234).message(1234).comments().create(obj)
        self.expect('POST', '/projects/1234/messages/1234/comments',
                    json.dumps(obj))

        self.service.project(1234).comment(1234).delete()
        self.expect('DELETE', '/projects/1234/comments/1234', {})

        with port.assertRaises(MethodNotSupported):
            self.service.project(1234).comment(1234).get()
        with port.assertRaises(MethodNotSupported):
            self.service.project(1234).comment(1234).update(obj)

        self.service.project(1234).todolists().get()
        self.expect('GET', '/projects/1234/todolists', {})

        self.service.project(1234).todolists().completed()
        self.expect('GET', '/projects/1234/todolists/completed', {})

        self.service.project(1234).todolists().create(obj)
        self.expect('POST', '/projects/1234/todolists', json.dumps(obj))

        self.service.project(1234).todolist(1234).get()
        self.expect('GET', '/projects/1234/todolists/1234', {})

        self.service.project(1234).todolist(1234).update(obj)
        self.expect('PUT', '/projects/1234/todolists/1234', json.dumps(obj))

        self.service.project(1234).todolist(1234).delete()
        self.expect('DELETE', '/projects/1234/todolists/1234', {})

        with port.assertRaises(MethodNotSupported):
            self.service.project(1234).todolist(1234).todos().get()

        self.service.project(1234).todolist(1234).todos().create(obj)
        self.expect('POST', '/projects/1234/todolists/1234/todos',
                    json.dumps(obj))

        self.service.project(1234).todo(1234).get()
        self.expect('GET', '/projects/1234/todos/1234', {})

        self.service.project(1234).todo(1234).update(obj)
        self.expect('PUT', '/projects/1234/todos/1234', json.dumps(obj))

        self.service.project(1234).todo(1234).delete()
        self.expect('DELETE', '/projects/1234/todos/1234', {})

        self.service.project(1234).documents().get()
        self.expect('GET', '/projects/1234/documents', {})

        self.service.project(1234).documents().create(obj)
        self.expect('POST', '/projects/1234/documents', json.dumps(obj))

        self.service.project(1234).document(1234).get()
        self.expect('GET', '/projects/1234/documents/1234', {})

        self.service.project(1234).document(1234).update(obj)
        self.expect('PUT', '/projects/1234/documents/1234', json.dumps(obj))

        self.service.project(1234).document(1234).delete()
        self.expect('DELETE', '/projects/1234/documents/1234', {})

        with port.assertRaises(MethodNotSupported):
            self.service.project(1234).document(1234).comments().get()

        self.service.project(1234).document(1234).comments().create(obj)
        self.expect('POST', '/projects/1234/documents/1234/comments',
                    json.dumps(obj))

        with port.assertRaises(MethodNotSupported):
            self.service.project(1234).uploads().get()

        self.service.project(1234).uploads().create(obj)
        self.expect('POST', '/projects/1234/uploads', json.dumps(obj))

        self.service.project(1234).upload(1234).get()
        self.expect('GET', '/projects/1234/uploads/1234', {})

        with port.assertRaises(MethodNotSupported):
            self.service.project(1234).upload(1234).comments().get()

        self.service.project(1234).upload(1234).comments().create(obj)
        self.expect('POST', '/projects/1234/uploads/1234/comments',
                    json.dumps(obj))

        self.service.project(1234).attachments().get()
        self.expect('GET', '/projects/1234/attachments', {})

        with port.assertRaises(MethodNotSupported):
            self.service.project(1234).attachments().create(obj)

        self.service.project('1234').calendar_events().get()
        self.expect('GET', '/projects/1234/calendar_events', {})

        self.service.project(1234).calendar_events().create(obj)
        self.expect('POST', '/projects/1234/calendar_events', json.dumps(obj))

        self.service.project('1234').calendar_events().past()
        self.expect('GET', '/projects/1234/calendar_events/past', {})

        self.service.project('1234').calendar_event(1234).get()
        self.expect('GET', '/projects/1234/calendar_events/1234', {})

        self.service.project('1234').calendar_event(1234).update(obj)
        self.expect('PUT', '/projects/1234/calendar_events/1234',
                    json.dumps(obj))

        self.service.project('1234').calendar_event(1234).delete()
        self.expect('DELETE', '/projects/1234/calendar_events/1234', {})

    def test_people(self):
        self.service.people().get()
        self.expect('GET', '/people', {})

        self.service.person().get()
        self.expect('GET', '/people/me', {})

        self.service.person('1234').get()
        self.expect('GET', '/people/1234', {})

        with port.assertRaises(MethodNotSupported):
            self.service.people().create({})
        with port.assertRaises(MethodNotSupported):
            self.service.person(1234).update({})

        self.service.person(1234).delete()
        self.expect('DELETE', '/people/1234', {})

        self.service.person('1234').events().get(since='2013-01-01')
        self.expect('GET', '/people/1234/events', {'since': '2013-01-01'})

    def test_events(self):
        self.service.events().get(since='2013-01-01')
        self.expect('GET', '/events', {'since': '2013-01-01'})
        self.service.events().get(since='2013-01-01', page=3)
        self.expect('GET', '/events', {'since': '2013-01-01', 'page': 3})

        with port.assertRaises(MethodNotSupported):
            self.service.events().create({})

    def test_calendars(self):
        self.service.calendars().get()
        self.expect('GET', '/calendars', {})

        self.service.calendar('1234').get()
        self.expect('GET', '/calendars/1234', {})

        obj = {'foo': 'bar'}
        self.service.calendars().create(obj)
        self.expect('POST', '/calendars', json.dumps(obj))

        self.service.calendar('1234').accesses().get()
        self.expect('GET', '/calendars/1234/accesses', {})

        with port.assertRaises(MethodNotSupported):
            self.service.calendar(1234).accesses().create({})
        with port.assertRaises(MethodNotSupported):
            self.service.calendar(1234).access(1234).update({})
        with port.assertRaises(MethodNotSupported):
            self.service.calendar(1234).access(1234).delete({})

        self.service.calendar(1234).accesses().grant(obj)
        self.expect('POST', '/calendars/1234/accesses', json.dumps(obj))

        self.service.calendar(1234).access(1234).revoke()
        self.expect('DELETE', '/calendars/1234/accesses/1234', {})

        self.service.calendar('1234').calendar_events().get()
        self.expect('GET', '/calendars/1234/calendar_events', {})

        self.service.calendar(1234).calendar_events().create(obj)
        self.expect('POST', '/calendars/1234/calendar_events', json.dumps(obj))

        self.service.calendar('1234').calendar_events().past()
        self.expect('GET', '/calendars/1234/calendar_events/past', {})

        self.service.calendar('1234').calendar_event(1234).get()
        self.expect('GET', '/calendars/1234/calendar_events/1234', {})

        self.service.calendar('1234').calendar_event(1234).update(obj)
        self.expect('PUT', '/calendars/1234/calendar_events/1234',
                    json.dumps(obj))

        self.service.calendar('1234').calendar_event(1234).delete()
        self.expect('DELETE', '/calendars/1234/calendar_events/1234', {})

    def test_topics(self):
        self.service.topics().get()
        self.expect('GET', '/topics', {})

    def test_todolists(self):
        self.service.todolists().get()
        self.expect('GET', '/todolists', {})

        self.service.todolists().completed()
        self.expect('GET', '/todolists/completed', {})

        with port.assertRaises(MethodNotSupported):
            self.service.todolists().create({})

        with port.assertRaises(MethodNotSupported):
            self.service.todolists().create({})

    def test_documents(self):
        self.service.documents().get()
        self.expect('GET', '/documents', {})

        with port.assertRaises(MethodNotSupported):
            self.service.documents().create({})

    def test_attachments(self):
        self.service.attachments().get()
        self.expect('GET', '/attachments', {})

        obj = {'foo': 'bar'}
        self.service.attachments().create(obj)
        self.expect('POST', '/attachments', json.dumps(obj))

########NEW FILE########
__FILENAME__ = test_basic_auth
import unittest

from libsaas import http
from libsaas.filters import auth


class BasicAuthTestCase(unittest.TestCase):

    def test_simple(self):
        auth_filter = auth.BasicAuth('user', 'pass')
        req = http.Request('GET', 'http://example.net/')
        auth_filter(req)

        self.assertEqual(req.headers['Authorization'], 'Basic dXNlcjpwYXNz')

    def test_unicode(self):
        # try both a unicode and a bytes parameter
        _lambda = b'\xce\xbb'
        _ulambda = _lambda.decode('utf-8')

        auth_bytes = auth.BasicAuth('user', _lambda)
        auth_unicode = auth.BasicAuth('user', _ulambda)
        auth_mixed = auth.BasicAuth(_lambda, _ulambda)

        expected_bytes = 'Basic dXNlcjrOuw=='
        expected_unicode = expected_bytes
        expected_mixed = 'Basic zrs6zrs='

        for auth_filter, expected in ((auth_bytes, expected_bytes),
                                      (auth_unicode, expected_unicode),
                                      (auth_mixed, expected_mixed)):

            req = http.Request('GET', 'http://example.net/')
            auth_filter(req)

            self.assertEqual(req.headers['Authorization'], expected)

########NEW FILE########
__FILENAME__ = test_bitbucket
import unittest

from libsaas.executors import test_executor
from libsaas.services import base, bitbucket


class BitbucketTestCase(unittest.TestCase):

    def setUp(self):
        self.executor = test_executor.use()
        self.executor.set_response(b'{}', 200, {})

        self.service = bitbucket.BitBucket('myuser', 'password')

    def expect(self, method=None, uri=None, params=None, headers=None):
        if method:
            self.assertEqual(method, self.executor.request.method)
        if uri:
            self.assertEqual(self.executor.request.uri,
                              'https://api.bitbucket.org/1.0' + uri)
        if params:
            self.assertEqual(self.executor.request.params, params)
        if headers:
            self.assertEqual(self.executor.request.headers, headers)

    def test_repos(self):
        self.service.repos().get()
        self.expect('GET', '/user/repositories/')

        self.service.repo('myuser', 'myrepo').get()
        self.expect('GET', '/repositories/myuser/myrepo/')

        self.service.repos().search(name='django')
        self.expect('GET', '/repositories/', {'name': 'django'})

        self.service.repo('myuser', 'myrepo').tags()
        self.expect('GET', '/repositories/myuser/myrepo/tags/')

        self.service.repo('myuser', 'myrepo').branches()
        self.expect('GET', '/repositories/myuser/myrepo/branches/')

        self.service.repos().create(name='myrepo', scm='git', is_private=True)
        self.expect('POST', '/repositories/',
                    {"name": "myrepo", "scm": "git", "is_private": "true"})

        self.service.repo('myuser', 'myrepo').update({'name': 'othername'})
        self.expect('PUT', '/repositories/myuser/myrepo/',
                    {"name": "othername"})

        self.service.repo('myuser', 'myrepo').delete()
        self.expect('DELETE', '/repositories/myuser/myrepo/')

    def test_repo_links(self):
        self.service.repo('myuser', 'myrepo').links().get()
        self.expect('GET', '/repositories/myuser/myrepo/links/')

        self.service.repo('myuser', 'myrepo').link(42).get()
        self.expect('GET', '/repositories/myuser/myrepo/links/42/')

        data = {'handler': 'jira', 'link_url': 'http://test.com',
                'link_key': 'PRJ'}
        self.service.repo('myuser', 'myrepo').links().create(data)
        self.expect('POST', '/repositories/myuser/myrepo/links/', data)

        self.service.repo('myuser', 'myrepo').link(42).update(data)
        self.expect('PUT', '/repositories/myuser/myrepo/links/42/', data)

        self.service.repo('myuser', 'myrepo').link(42).delete()
        self.expect('DELETE', '/repositories/myuser/myrepo/links/42/')

    def test_repo_privileges(self):
        self.service.repo('myuser', 'myrepo').privileges().get()
        self.expect('GET', '/privileges/myuser/myrepo/')

        self.service.repo('myuser', 'myrepo').privileges('otheruser').get()
        self.expect('GET', '/privileges/myuser/myrepo/otheruser/')

        self.service.repo('myuser', 'myrepo').privileges().get(filter='write')
        self.expect('GET', '/privileges/myuser/myrepo/', {'filter': 'write'})

        self.service.repo('myuser', 'myrepo').privileges(
            'otheruser').grant('write')
        self.expect('PUT', '/privileges/myuser/myrepo/otheruser/', 'write')

        self.service.repo('myuser', 'myrepo').privileges('otheruser').revoke()
        self.expect('DELETE', '/privileges/myuser/myrepo/otheruser/')

        self.service.repo('myuser', 'myrepo').privileges().revoke()
        self.expect('DELETE', '/privileges/myuser/myrepo/')

    def test_repo_issues(self):
        self.service.repo('myuser', 'myrepo').issues().get()
        self.expect('GET', '/repositories/myuser/myrepo/issues/')

        self.service.repo('myuser', 'myrepo').issue(1000).get()
        self.expect('GET', '/repositories/myuser/myrepo/issues/1000/')

        self.service.repo('myuser', 'myrepo').issues().search('easy_install')
        self.expect('GET', '/repositories/myuser/myrepo/issues/',
                    {'search': 'easy_install'})

        self.service.repo('myuser', 'myrepo').issues().filter(
            {'title': ('~some_title', '!~another_title'), 'version': '1.0'})
        qs1 = '?title=%7Esome_title&title=%21%7Eanother_title&version=1.0'
        qs2 = '?version=1.0&title=%7Esome_title&title=%21%7Eanother_title'
        url = '/repositories/myuser/myrepo/issues/'

        # no way to predict the order in which the dictionary will be iterated
        # and it's easier this way than monkeying with OrderedDict
        try:
            self.expect('GET', url + qs1, {})
        except AssertionError:
            self.expect('GET', url + qs2, {})

        self.service.repo('myuser', 'myrepo').issues().get(start='15')
        self.expect('GET', '/repositories/myuser/myrepo/issues/',
                    {'start': '15'})

        self.service.repo('myuser', 'myrepo').issues().get(limit='10')
        self.expect('GET', '/repositories/myuser/myrepo/issues/',
                    {'limit': '10'})

        self.service.repo('myuser', 'myrepo').issues().get(start='15',
                                                           limit='10')
        self.expect('GET', '/repositories/myuser/myrepo/issues/',
                    {'start': '15', 'limit': '10'})

        data = {
            'title': 'my-issue',
            'content': 'my-issue-content',
            'component': 'my-issue-component',
            'milestone': '2',
            'version': '2.0',
            'responsible': 'some-user',
            'priotiry': 'minor',
            'status': 'new',
            'kid': 'bug'
        }
        self.service.repo('myuser', 'myrepo').issues().create(data)
        self.expect('POST', '/repositories/myuser/myrepo/issues/', data)

        self.service.repo('myuser', 'myrepo').issue(1000).update(data)
        self.expect('PUT', '/repositories/myuser/myrepo/issues/1000/', data)

        self.service.repo('myuser', 'myrepo').issue(1000).delete()
        self.expect('DELETE', '/repositories/myuser/myrepo/issues/1000/')

    def test_issues_comments(self):
        self.service.repo('myuser', 'myrepo').issue(1000).comments().get()
        self.expect('GET',
                    '/repositories/myuser/myrepo/issues/1000/comments/')

        self.service.repo('myuser', 'myrepo').issue(1000).comment(75468).get()
        self.expect('GET',
                    '/repositories/myuser/myrepo/issues/1000/comments/75468/')

        data = 'This is my comment content'
        self.service.repo(
            'myuser', 'myrepo').issue(1000).comments().create(data)
        self.expect(
            'POST', '/repositories/myuser/myrepo/issues/1000/comments/',
            {'content': data})

        self.service.repo(
            'myuser', 'myrepo').issue(1000).comment(75468).update(data)
        self.expect(
            'PUT', '/repositories/myuser/myrepo/issues/1000/comments/75468/',
            {'content': data})

        self.service.repo('myuser', 'myrepo').issue(10).comment(75468).delete()
        self.expect('DELETE',
                    '/repositories/myuser/myrepo/issues/10/comments/75468/')

    def test_issues_components(self):
        self.service.repo('myuser', 'myrepo').issues().components().get()
        self.expect('GET', '/repositories/myuser/myrepo/issues/components/')

        self.service.repo('myuser', 'myrepo').issues().component(42).get()
        self.expect('GET',
                    '/repositories/myuser/myrepo/issues/components/42/')

        data = 'My new issues component'
        self.service.repo(
            'myuser', 'myrepo').issues().components().create(data)
        self.expect('POST', '/repositories/myuser/myrepo/issues/components/',
                    {'name': data})

        self.service.repo(
            'myuser', 'myrepo').issues().component(42).update(data)
        self.expect('PUT',
                    '/repositories/myuser/myrepo/issues/components/42/',
                    {'name': data})

        self.service.repo('myuser', 'myrepo').issues().component(42).delete()
        self.expect('DELETE',
                    '/repositories/myuser/myrepo/issues/components/42/')

    def test_issues_milestones(self):
        self.service.repo('myuser', 'myrepo').issues().milestones().get()
        self.expect('GET', '/repositories/myuser/myrepo/issues/milestones/')

        self.service.repo('myuser', 'myrepo').issues().milestone(42).get()
        self.expect('GET',
                    '/repositories/myuser/myrepo/issues/milestones/42/')

        data = 'My new milestone'
        self.service.repo(
            'myuser', 'myrepo').issues().milestones().create(data)
        self.expect('POST', '/repositories/myuser/myrepo/issues/milestones/',
                    {'name': data})

        self.service.repo(
            'myuser', 'myrepo').issues().milestone(42).update(data)
        self.expect('PUT', '/repositories/myuser/myrepo/issues/milestones/42/',
                    {'name': data})

        self.service.repo('myuser', 'myrepo').issues().milestone(42).delete()
        self.expect('DELETE',
                    '/repositories/myuser/myrepo/issues/milestones/42/')

    def test_issues_versions(self):
        self.service.repo('myuser', 'myrepo').issues().versions().get()
        self.expect('GET', '/repositories/myuser/myrepo/issues/versions/')

        self.service.repo('myuser', 'myrepo').issues().version(42).get()
        self.expect('GET',
                    '/repositories/myuser/myrepo/issues/versions/42/')

        data = 'My new issue version'
        self.service.repo('myuser', 'myrepo').issues().versions().create(data)
        self.expect('POST', '/repositories/myuser/myrepo/issues/versions/',
                    {'name': data})

        self.service.repo('myuser', 'myrepo').issues().version(42).update(data)
        self.expect('PUT', '/repositories/myuser/myrepo/issues/versions/42/',
                    {'name': data})

        self.service.repo('myuser', 'myrepo').issues().version(42).delete()
        self.expect('DELETE',
                    '/repositories/myuser/myrepo/issues/versions/42/')

    def test_invitation(self):
        self.service.repo('myuser', 'myrepo').invite(
            'invited@example.org', permission='write')
        self.expect('POST', '/invitations/myuser/myrepo/invited@example.org/',
                    {'permission': 'write'})

    def test_emails(self):
        self.service.emails().get()
        self.expect('GET', '/emails/')

        self.service.email('myemail@example.org').get()
        self.expect('GET', '/emails/myemail@example.org/')

        self.service.emails().add('myemail@example.org')
        self.expect('PUT', '/emails/myemail@example.org/')

        data = {'primary': 'true'}
        self.service.email('myemail@example.org').primary()
        self.expect('POST', '/emails/myemail@example.org/', data)

        self.service.email('myemail@example.org').delete()
        self.expect('DELETE', '/emails/myemail@example.org/')

    def test_changeset(self):
        self.service.repo('myuser', 'myrepo').changesets().get()
        self.expect('GET', '/repositories/myuser/myrepo/changesets/')

        self.service.repo('myuser', 'myrepo').changeset('f28d56').get()
        self.expect('GET', '/repositories/myuser/myrepo/changesets/f28d56/')

        self.service.repo('myuser', 'myrepo').changeset('f28d56').diffstat()
        self.expect('GET',
                    '/repositories/myuser/myrepo/changesets/f28d56/diffstat/')

        self.service.repo('myuser', 'myrepo').changesets().get(limit=20)
        self.expect('GET', '/repositories/myuser/myrepo/changesets/',
                    {'start': 'tip', 'limit': 20})

    def test_events(self):
        self.service.user('myuser').events()
        self.expect('GET', '/users/myuser/events/')

        self.service.user('myuser').events(start=10, limit=20)
        self.expect('GET', '/users/myuser/events/', {'start': 10, 'limit': 20})

        self.service.repo('myuser', 'myrepo').events()
        self.expect('GET', '/repositories/myuser/myrepo/events/')

        self.service.repo('myuser', 'myrepo').events(
            start=10, limit=20, etype='issue_comment')
        self.expect('GET', '/repositories/myuser/myrepo/events/',
                    {'etype': 'issue_comment', 'start': 10, 'limit': 20})

    def test_followers(self):
        self.service.user('myuser').followers()
        self.expect('GET', '/users/myuser/followers/')

        self.service.repo('myuser', 'myrepo').followers()
        self.expect('GET', '/repositories/myuser/myrepo/followers/')

        self.service.repo('myuser', 'myrepo').issue(1245).followers()
        self.expect('GET',
                    '/repositories/myuser/myrepo/issues/1245/followers/')

        self.service.user().follows()
        self.expect('GET', '/user/follows/')

    def test_groups(self):
        self.service.user('myuser').groups().get()
        self.expect('GET', '/groups/myuser/')

        self.service.user('myuser@example.org').groups().get()
        self.expect('GET', '/groups/myuser@example.org/')

        data = {'name': 'my-group'}
        self.service.user('myuser').groups().create(data)
        self.expect('POST', '/groups/myuser/', data)

        data = {'name': 'my-other-group', 'auto-add': 'true'}
        self.service.user('myuser').group('my-group').update(data)
        self.expect('PUT', '/groups/myuser/my-group/', data)

        self.service.user('myuser').group('my-group').delete()
        self.expect('DELETE', '/groups/myuser/my-group/')

        self.service.user('myuser').group('my-group').members().get()
        self.expect('GET', '/groups/myuser/my-group/members/')

        self.service.user(
            'myuser').group('my-group').members().create('another-user')
        self.expect('PUT', '/groups/myuser/my-group/members/another-user/')

        self.service.user(
            'myuser').group('my-group').member('another-user').delete()
        self.expect('DELETE', '/groups/myuser/my-group/members/another-user/')

    def test_groups_privileges(self):
        self.assertRaises(base.MethodNotSupported,
                          self.service.user().group_privileges)

        self.service.user('myuser').group_privileges().get()
        self.expect('GET', '/group-privileges/myuser/')

        self.service.user('myuser').group_privileges().get(
            filter='admin', private=True)
        self.expect('GET', '/group-privileges/myuser/',
                    {'filter': 'admin', 'private': 'true'})

        self.service.user(
            'myuser').group_privileges().grant('my-group', 'myrepo', 'read')
        self.expect('PUT', '/group-privileges/myuser/myrepo/myuser/my-group/',
                    'read')

        self.service.user(
            'myuser').group_privileges().revoke('my-group', 'myrepo')
        self.expect('DELETE',
                    '/group-privileges/myuser/myrepo/myuser/my-group/')

    def test_services(self):
        self.service.repo('myuser', 'myrepo').services().get()
        self.expect('GET', '/repositories/myuser/myrepo/services/')

        self.service.repo('myuser', 'myrepo').service(1).get()
        self.expect('GET', '/repositories/myuser/myrepo/services/1/')

        data = {'type': 'post', 'URL': 'http://test.org/post'}
        self.service.repo('myuser', 'myrepo').services().create(data)
        self.expect('POST', '/repositories/myuser/myrepo/services/', data)

        self.service.repo('myuser', 'myrepo').service(1).update(data)
        self.expect('PUT', '/repositories/myuser/myrepo/services/1/',
                    data)

        self.service.repo('myuser', 'myrepo').service(1).delete()
        self.expect('DELETE', '/repositories/myuser/myrepo/services/1/')

########NEW FILE########
__FILENAME__ = test_bitly
import unittest

from libsaas.executors import test_executor
from libsaas.services import bitly


class BitlyTestCase(unittest.TestCase):

    def setUp(self):
        self.executor = test_executor.use()
        self.executor.set_response(b'{}', 200, {})

        self.service = bitly.Bitly('my-access-token')

    def expect(self, method=None, uri=None, params={}):
        if method:
            self.assertEqual(method, self.executor.request.method)

        if uri:
            self.assertEqual(
                self.executor.request.uri,
                'https://api-ssl.bitly.com/v3' + uri)

        if params:
            params.update({'access_token': 'my-access-token'})
            self.assertEqual(self.executor.request.params, params)

    def test_users(self):
        self.service.user().info()
        self.expect('GET', '/user/info', {})
        self.service.user().info(login='1234')
        self.expect('GET', '/user/info', {'login': '1234'})
        self.service.user().info(login='1234', full_name='foo')
        self.expect('GET', '/user/info', {
            'login': '1234', 'full_name': 'foo'
        })

        self.service.user().link_history()
        self.expect('GET', '/user/link_history', {})
        self.service.user().link_history(link='http://foo.bar')
        self.expect('GET', '/user/link_history', {
            'link': 'http://foo.bar'
        })
        self.service.user().link_history(expand_client_id=True)
        self.expect('GET', '/user/link_history', {
            'expand_client_id': 'true'
        })

        self.service.user().network_history()
        self.expect('GET', '/user/network_history', {})
        self.service.user().network_history(expand_client_id=True)
        self.expect('GET', '/user/network_history', {
            'expand_client_id': 'true'
        })

        self.service.user().tracking_domain_list()
        self.expect('GET', '/user/tracking_domain_list', {})

        for method_name in ['clicks', 'countries', 'popular_links',
                            'referrers', 'referring_domains', 'share_counts']:
            method = getattr(self.service.user(), method_name)

            method()
            self.expect('GET', '/user/%s' % method_name, {})
            method(timezone='Europe/Andorra')
            self.expect('GET', '/user/%s' % method_name, {
                'timezone': 'Europe/Andorra'
            })
            method(timezone='Europe/Andorra', unit='month')
            self.expect('GET', '/user/%s' % method_name, {
                'unit': 'month',
                'timezone': 'Europe/Andorra'
            })
            method(timezone='Europe/Andorra', unit='month')
            self.expect('GET', '/user/%s' % method_name, {
                'unit': 'month',
                'timezone': 'Europe/Andorra'
            })

    def test_links(self):
        for method_name in ['info', 'category', 'social',
                            'location', 'language', 'encoders_count']:
            method = getattr(
                    self.service.link(link='http://foo.bar'), method_name)
            method()
            self.expect('GET', '/link/%s' % method_name, {
                'link': 'http://foo.bar'
            })

        self.service.link(link='http://foo.bar').content()
        self.expect('GET', '/link/content', {
            'link': 'http://foo.bar'
        })
        self.service.link(link='http://foo.bar').content(content_type='text')
        self.expect('GET', '/link/content', {
            'content_type': 'text',
            'link': 'http://foo.bar'
        })

        for method_name in ['clicks', 'countries', 'referrers',
                            'referrers_by_domain', 'referring_domains',
                            'shares']:
            method = getattr(
                    self.service.link(link='http://foo.bar'), method_name)

            method()
            self.expect('GET', '/link/%s' % method_name, {
                'link': 'http://foo.bar'
            })
            method(timezone='Europe/Andorra')
            self.expect('GET', '/link/%s' % method_name, {
                'link': 'http://foo.bar',
                'timezone': 'Europe/Andorra'
            })
            method(timezone='Europe/Andorra', unit='month')
            self.expect('GET', '/link/%s' % method_name, {
                'link': 'http://foo.bar',
                'unit': 'month',
                'timezone': 'Europe/Andorra'
            })
            method(timezone='Europe/Andorra', unit='month')
            self.expect('GET', '/link/%s' % method_name, {
                'link': 'http://foo.bar',
                'unit': 'month',
                'timezone': 'Europe/Andorra'
            })

    def test_highvalue(self):
        self.service.highvalue().get(limit=10)
        self.expect('GET', '/highvalue', {'limit': 10})

    def test_search(self):
        self.service.search().get()
        self.expect('GET', '/search', {})
        self.service.search().get(limit=10)
        self.expect('GET', '/search', {'limit': 10})

    def test_realtime(self):
        self.service.realtime().bursting_phrases()
        self.expect('GET', '/realtime/bursting_phrases', {})

        self.service.realtime().bursting_phrases()
        self.expect('GET', '/realtime/bursting_phrases', {})

        self.service.realtime().clickrate(phrase='foo')
        self.expect('GET', '/realtime/clickrate', {'phrase': 'foo'})

########NEW FILE########
__FILENAME__ = test_cartodb
import json
import unittest

from libsaas.executors import test_executor
from libsaas.services import cartodb


class CartoDBTestCase(unittest.TestCase):

    def setUp(self):
        self.executor = test_executor.use()
        self.executor.set_response(b'{}', 200, {})

        self.api_key = 'test_key'
        self.service = cartodb.CartoDB('mydomain', self.api_key)

    def serialize(self, data):
        return json.dumps(data)

    def expect(self, method=None, uri=None, params=None, headers=None):
        if method:
            self.assertEqual(method, self.executor.request.method)

        if uri:
            self.assertEqual(self.executor.request.uri,
                              'https://mydomain.cartodb.com/api/' + uri)
        if params:
            params['api_key'] = self.api_key
            self.assertEqual(self.executor.request.params, params)

    def test_viz(self):
        self.service.viz(type='foo')
        self.expect('GET', 'v1/viz', {'type': 'foo'})

    def test_sql(self):
        query = 'select * from test'
        self.service.sql(q=query)
        self.expect('POST', 'v2/sql', {'q': query})

########NEW FILE########
__FILENAME__ = test_compete
import json
import unittest

from libsaas import port
from libsaas.executors import test_executor
from libsaas.services import compete
from libsaas.services.base import MethodNotSupported


class CompeteTestCase(unittest.TestCase):

    def setUp(self):
        self.executor = test_executor.use()
        self.executor.set_response(b'{}', 200, {})

        self.service = compete.Compete('my-api-key')

    def expect(self, method=None, uri=None, params=None):
        if method:
            self.assertEqual(method, self.executor.request.method)
        if uri:
            self.assertEqual(self.executor.request.uri,
                              'http://apps.compete.com' + uri)
        params = params or {}
        params['apikey'] = 'my-api-key'
        self.assertEqual(self.executor.request.params, params)

    def test_sites(self):
        with port.assertRaises(MethodNotSupported):
            self.service.site('libsaas.net').get()
            self.service.site('libsaas.net').create()
            self.service.site('libsaas.net').update()
            self.service.site('libsaas.net').delete()

        with port.assertRaises(MethodNotSupported):
            self.service.site('libsaas.net').metric('rank').create()
            self.service.site('libsaas.net').metric('rank').update()
            self.service.site('libsaas.net').metric('rank').delete()

        self.service.site('libsaas.net').metric('rank').get()
        self.expect('GET', '/sites/libsaas.net/trended/rank/', {})
        self.service.site('libsaas.net').metric('rank').get(latest=9)
        self.expect('GET', '/sites/libsaas.net/trended/rank/', {'latest': 9})
        (self.service.site('libsaas.net')
             .metric('rank').get(start_date='201209', end_date='201210'))
        self.expect('GET', '/sites/libsaas.net/trended/rank/', {
            'start_date': '201209',
            'end_date': '201210'
        })
        (self.service.site('libsaas.net')
             .metric('rank').get(start_date='20120901', end_date='20120915'))
        self.expect('GET', '/sites/libsaas.net/trended/rank/', {
            'start_date': '20120901',
            'end_date': '20120915'
        })


########NEW FILE########
__FILENAME__ = test_desk
import json
import unittest

from libsaas import http, port
from libsaas.executors import test_executor
from libsaas.services import base, desk


class DeskTestCase(unittest.TestCase):

    def setUp(self):
        self.executor = test_executor.use()
        self.executor.set_response(b'{}', 200, {})

        self.service = desk.Desk('domain', 'key', 'secret',
                                 'token', 'token_secret')

    def expect(self, method=None, uri=None, params=None, headers=None):
        if method is not None:
            self.assertEqual(method, self.executor.request.method)
        if uri is not None:
            self.assertEqual(self.executor.request.uri,
                             'https://domain.desk.com/api/v2' + uri)
        if params is not None:
            params = (json.dumps(params)
                      if method not in http.URLENCODE_METHODS else params)
            self.assertEqual(self.executor.request.params, params)
        if headers is not None:
            self.assertEqual(self.executor.request.headers, headers)

    def test_cases(self):
        paging = {'page': 1, 'per_page': 5}
        self.service.cases().get()
        self.expect('GET', '/cases')

        self.service.cases().get(page=1, per_page=5)
        self.expect('GET', '/cases', paging)

        self.service.case(10).get()
        self.expect('GET', '/cases/10')

        self.service.case(10, is_external=True).get()
        self.expect('GET', '/cases/e-10')

        self.service.case(10).update({'foo': 'bar'})
        self.expect('PATCH', '/cases/10', {'foo': 'bar'})

        with port.assertRaises(base.MethodNotSupported):
            self.service.cases().create()
            self.service.cases().update()
            self.service.cases().delete()
            self.service.case(10).delete()

    def test_customers(self):
        obj = {'email': 'test@test.com'}
        paging = {'page': 1, 'per_page': 5}

        self.service.customers().get(per_page=5, page=1)
        self.expect('GET', '/customers', paging)

        self.service.customer(4).get()
        self.expect('GET', '/customers/4')

        self.service.customer(4).update(obj)
        self.expect('PATCH', '/customers/4', obj)

        self.service.customers().create(obj)
        self.expect('POST', '/customers', obj)

        self.assertRaises(base.MethodNotSupported,
            self.service.customer(4).delete)

    def test_insights(self):
        self.service.insights().meta()
        self.expect('GET', '/insights/meta')

        self.service.insights().report(metrics='1,2,3')
        self.expect('POST', '/insights/reports', {'metrics': '1,2,3'})

    def test_groups(self):
        paging = {'page': 1, 'per_page': 5}
        self.service.groups().get()
        self.expect('GET', '/groups')

        self.service.groups().get(page=1, per_page=5)
        self.expect('GET', '/groups', paging)

        self.service.group(10).get()
        self.expect('GET', '/groups/10')

        self.assertRaises(base.MethodNotSupported,
            self.service.groups().create, {'foo': 'bar'})
        self.assertRaises(base.MethodNotSupported,
            self.service.group(10).delete)
        self.assertRaises(base.MethodNotSupported,
            self.service.group(10).update, {})

    def test_users(self):
        paging = {'page': 1, 'per_page': 5}
        self.service.users().get()
        self.expect('GET', '/users')

        self.service.users().get(page=1, per_page=5)
        self.expect('GET', '/users', paging)

        self.service.user(10).get()
        self.expect('GET', '/users/10')

        self.assertRaises(base.MethodNotSupported,
            self.service.users().create, {'foo': 'bar'})
        self.assertRaises(base.MethodNotSupported,
            self.service.user(10).delete)
        self.assertRaises(base.MethodNotSupported,
            self.service.user(10).update, {})

    def test_topics(self):
        obj = {'subject': 'test'}
        paging = {'page': 1, 'per_page': 5}

        self.service.topics().get(per_page=5, page=1)
        self.expect('GET', '/topics', paging)

        self.service.topic(4).get()
        self.expect('GET', '/topics/4')

        self.service.topic(4).update(obj)
        self.expect('PATCH', '/topics/4', obj)

        self.service.topics().create(obj)
        self.expect('POST', '/topics', obj)

        self.service.topic(4).delete()
        self.expect('DELETE', '/topics/4')

        self.service.topic(4).articles().get(per_page=5, page=1)
        self.expect('GET', '/topics/4/articles', paging)

        self.service.topic(4).articles().create(obj)
        self.expect('POST', '/topics/4/articles', obj)

        self.service.article(4).update(obj)
        self.expect('PATCH', '/articles/4', obj)

        self.service.article(4).get()
        self.expect('GET', '/articles/4')

        self.service.article(4).delete()
        self.expect('DELETE', '/articles/4')

    def test_macros(self):
        obj = {'foo': 'bar'}
        paging = {'page': 1, 'per_page': 5}

        self.service.macros().get(per_page=5, page=1)
        self.expect('GET', '/macros', paging)

        self.service.macro(4).get()
        self.expect('GET', '/macros/4')

        self.service.macro(4).update(obj)
        self.expect('PATCH', '/macros/4', obj)

        self.service.macros().create(obj)
        self.expect('POST', '/macros', obj)

        self.service.macro(4).delete()
        self.expect('DELETE', '/macros/4')

        self.service.macro(4).actions().get(per_page=5, page=1)
        self.expect('GET', '/macros/4/actions', paging)

        self.service.macro(4).action(1).get()
        self.expect('GET', '/macros/4/actions/1')

        self.service.macro(4).action(1).update(obj)
        self.expect('PATCH', '/macros/4/actions/1', obj)

        self.assertRaises(base.MethodNotSupported,
            self.service.macro(4).action(1).delete)

    def test_full_domain(self):
        service = desk.Desk('support.domain.com', 'key', 'secret',
                            'token', 'token_secret')
        service.users().get()
        self.assertEqual(self.executor.request.uri,
                         'https://support.domain.com/api/v2/users')

########NEW FILE########
__FILENAME__ = test_ducksboard
import json
import unittest

from libsaas.executors import test_executor
from libsaas.services import ducksboard


class DucksboardTestCase(unittest.TestCase):

    def setUp(self):
        self.executor = test_executor.use()
        self.executor.set_response(b'{}', 200, {})

        self.service = ducksboard.Ducksboard('apikey', 'pass')

    def serialize(self, data):
        return json.dumps(data)

    def expect(self, uri, method=None, params=None, subdomain=None):
        if not subdomain:
            domain = 'app.ducksboard.com/api'
        else:
            domain = '{0}.ducksboard.com/values'.format(subdomain)

        self.assertEqual(self.executor.request.uri,
                         'https://{0}/{1}'.format(domain, uri))
        if method:
            self.assertEqual(method, self.executor.request.method)
        if params:
            self.assertEqual(self.executor.request.params, params)

    def test_dashboard(self):
        self.service.dashboards().get()
        self.expect('dashboards/', 'GET')

        dashboard = {'name': 'x'}
        self.service.dashboards().create(dashboard)
        self.expect('dashboards/', 'POST', self.serialize(dashboard))

        self.service.dashboard('slug').update(dashboard)
        self.expect('dashboards/slug', 'PUT', self.serialize(dashboard))

        self.service.dashboard('slug').delete()
        self.expect('dashboards/slug', 'DELETE')

        self.service.dashboard('slug').accessed()
        self.expect('dashboards/slug/accessed', 'POST')

        self.service.dashboard('slug').widgets()
        self.expect('dashboards/slug/widgets/', 'GET')

        self.service.dashboard('slug').tokens().get()
        self.expect('dashboards/slug/tokens/', 'GET')

        self.service.dashboard('slug').token('token').get()
        self.expect('dashboards/slug/tokens/token', 'GET')

        token = {'password': 'p'}
        self.service.dashboard('slug').tokens().create(token)
        self.expect('dashboards/slug/tokens/', 'POST', self.serialize(token))

        self.service.dashboard('slug').token('token').delete()
        self.expect('dashboards/slug/tokens/token', 'DELETE')

    def test_widgets(self):
        self.service.widgets().get()
        self.expect('widgets/', 'GET')

        widget = {'widget': 'x'}
        self.service.widgets().create(widget)
        self.expect('widgets/', 'POST', self.serialize(widget))

        self.service.widget('id').update(widget)
        self.expect('widgets/id', 'PUT', self.serialize(widget))

        self.service.widget('id').delete()
        self.expect('widgets/id', 'DELETE')

        dashboard = {'dashboard': 'test'}
        self.service.widget('id').copy('test')
        self.expect('widgets/id/copy', 'POST', self.serialize(dashboard))

        positions = {"7": {"row": 1, "column": 1}}
        self.service.widgets().positions(positions)
        self.expect('widgets/positions', 'POST', self.serialize(positions))

    def test_accounts(self):
        self.service.accounts().get()
        self.expect('accounts/', 'GET')

        account = {'account': 'x'}
        self.service.accounts().create(account)
        self.expect('accounts/', 'POST', self.serialize(account))

        self.service.account('id').delete()
        self.expect('accounts/id', 'DELETE')

        self.service.account('id').get()
        self.expect('accounts/id', 'GET')

    def test_user(self):
        self.service.user().get()
        self.expect('user', 'GET')

        user = {'name': 'x'}
        self.service.user().update(user)
        self.expect('user', 'PUT', self.serialize(user))

        self.service.user().get_api_key()
        self.expect('user/api_key', 'GET')

        self.service.user().reset_api_key()
        self.expect('user/api_key', 'POST')

    def test_datasource(self):
        ds = self.service.data_source('label')

        value = {"value": 10}
        ds.push(value)
        self.expect('label', 'POST', self.serialize(value), 'push')

        ds.delete()
        self.expect('label', 'DELETE', subdomain='push')

        ds.last(5)
        self.expect('label/last', 'GET', {'count': 5}, subdomain='pull')

        ds.since(500)
        self.expect('label/since', 'GET', {'seconds': 500}, subdomain='pull')

        ds.timespan('daily', 'UTC')
        self.expect('label/timespan', 'GET',
                    {'timespan': 'daily', 'timezone': 'UTC'},
                    subdomain='pull')

        # try binary and unicode labels
        _lambda = b'\xce\xbb'
        _ulambda = _lambda.decode('utf-8')

        ds = self.service.data_source(_lambda)
        ds.delete()

        ds = self.service.data_source(_ulambda)
        ds.delete()

########NEW FILE########
__FILENAME__ = test_flurry
import unittest

from libsaas.executors import test_executor
from libsaas.services import flurry


class FlurryTestCase(unittest.TestCase):

    def setUp(self):
        self.executor = test_executor.use()
        self.executor.set_response(b'{}', 200, {})

        self.service = flurry.Flurry('my-api-access-code')

    def expect(self, uri, params={}):
        self.assertEqual('GET', self.executor.request.method)

        self.assertEqual(self.executor.request.uri,
                         'http://api.flurry.com' + uri)

        params.update({'apiAccessCode': 'my-api-access-code'})

        if params:
            self.assertEqual(self.executor.request.params, params)

    def test_applications(self):
        self.service.applications().get()
        self.expect('/appInfo/getAllApplications')

    def test_application(self):
        self.service.application('my-api-key').get()
        self.expect('/appInfo/getApplication', {
            'apiKey': 'my-api-key'
        })

        (self.service.application('my-api-key')
                     .events().get('start_date', 'end_date'))
        self.expect('/eventMetrics/Summary', {
            'apiKey': 'my-api-key',
            'startDate': 'start_date',
            'endDate': 'end_date'
        })

        (self.service.application('my-api-key')
                     .event('event_name').get('start_date', 'end_date'))
        self.expect('/eventMetrics/Event', {
            'apiKey': 'my-api-key',
            'eventName': 'event_name',
            'startDate': 'start_date',
            'endDate': 'end_date'
        })

        (self.service.application('my-api-key').metrics()
                     .active_users('start_date', 'end_date'))
        self.expect('/appMetrics/ActiveUsers', {
            'apiKey': 'my-api-key',
            'startDate': 'start_date',
            'endDate': 'end_date'
        })
        (self.service.application('my-api-key').metrics()
                     .active_users_by_week('start_date', 'end_date'))
        self.expect('/appMetrics/ActiveUsersByWeek', {
            'apiKey': 'my-api-key',
            'startDate': 'start_date',
            'endDate': 'end_date'
        })
        (self.service.application('my-api-key').metrics()
                     .active_users_by_month('start_date', 'end_date'))
        self.expect('/appMetrics/ActiveUsersByMonth', {
            'apiKey': 'my-api-key',
            'startDate': 'start_date',
            'endDate': 'end_date'
        })
        (self.service.application('my-api-key').metrics()
                     .new_users('start_date', 'end_date', group_by='WEEKS'))
        self.expect('/appMetrics/NewUsers', {
            'apiKey': 'my-api-key',
            'startDate': 'start_date',
            'endDate': 'end_date',
            'groupBy': 'WEEKS'
        })
        (self.service.application('my-api-key').metrics()
                     .median_session_length('start_date', 'end_date'))
        self.expect('/appMetrics/MedianSessionLength', {
            'apiKey': 'my-api-key',
            'startDate': 'start_date',
            'endDate': 'end_date'
        })
        (self.service.application('my-api-key').metrics()
                     .avg_session_length('start_date', 'end_date'))
        self.expect('/appMetrics/AvgSessionLength', {
            'apiKey': 'my-api-key',
            'startDate': 'start_date',
            'endDate': 'end_date',
        })
        (self.service.application('my-api-key').metrics()
                     .sessions('start_date', 'end_date'))
        self.expect('/appMetrics/Sessions', {
            'apiKey': 'my-api-key',
            'startDate': 'start_date',
            'endDate': 'end_date'
        })
        (self.service.application('my-api-key').metrics()
                     .page_views('start_date', 'end_date', version_name='v1'))
        self.expect('/appMetrics/PageViews', {
            'apiKey': 'my-api-key',
            'startDate': 'start_date',
            'endDate': 'end_date',
            'versionName': 'v1'
        })
        (self.service.application('my-api-key').metrics()
                     .avg_page_views_per_session('start_date', 'end_date'))
        self.expect('/appMetrics/AvgPageViewsPerSession', {
            'apiKey': 'my-api-key',
            'startDate': 'start_date',
            'endDate': 'end_date'
        })
        (self.service.application('my-api-key').metrics()
                     .retained_users('start_date', 'end_date', 'US'))
        self.expect('/appMetrics/RetainedUsers', {
            'apiKey': 'my-api-key',
            'startDate': 'start_date',
            'endDate': 'end_date',
            'country': 'US'
        })

########NEW FILE########
__FILENAME__ = test_fullcontact
import unittest

from libsaas.executors import test_executor
from libsaas.services import fullcontact
from libsaas import port


class FullcontactTestCase(unittest.TestCase):

    def setUp(self):
        self.executor = test_executor.use()
        self.executor.set_response(b'{}', 200, {})

        self.service = fullcontact.Fullcontact('my-api-key')

    def expect(self, method=None, uri=None, params={}):
        if method:
            self.assertEqual(method, self.executor.request.method)

        if uri:
            self.assertEqual(
                self.executor.request.uri,
                'https://api.fullcontact.com/v2' + uri)

        if params:
            params.update({'apiKey': 'my-api-key'})
            self.assertEqual(self.executor.request.params, params)

    def test_persons(self):
        self.service.person(email='email').get()
        self.expect('GET', '/person.json', {'email': 'email'})
        self.service.person(twitter='twitter').get()
        self.expect('GET', '/person.json', {'twitter': 'twitter'})

        with port.assertRaises(TypeError):
            self.service.person(email='email', facebookUsername='fb').get()

        self.service.person(email='email').get(queue=1)
        self.expect('GET', '/person.json', {
            'email': 'email',
            'queue': 1,
        })
        self.service.person(twitter='twitter').get(prettyPrint='dictionary')
        self.expect('GET', '/person.json', {
            'twitter': 'twitter',
            'prettyPrint': 'dictionary',
        })

    def test_enhanced(self):
        self.service.enhanced(email='email').get()
        self.expect('GET', '/enhanced.json', {'email': 'email'})

    def test_names(self):
        with port.assertRaises(TypeError):
            self.service.names().normalizer()

        self.service.names().normalizer('name')
        self.expect('GET', '/name/normalizer.json', {'q': 'name'})
        self.service.names().normalizer('name', 'lowercase')
        self.expect('GET', '/name/normalizer.json', {
            'q': 'name',
            'casing': 'lowercase'
        })

        with port.assertRaises(TypeError):
            self.service.names().deducer()
            self.service.names().deducer('email', 'username')

        self.service.names().deducer(email='email')
        self.expect('GET', '/name/deducer.json', {'email': 'email'})

        with port.assertRaises(TypeError):
            self.service.names().similarity()

        self.service.names().similarity('q1', 'q2')
        self.expect('GET', '/name/similarity.json', {'q1': 'q1', 'q2': 'q2'})
        self.service.names().similarity('q1', 'q2', 'titlecase')
        self.expect('GET', '/name/similarity.json', {
            'q1': 'q1',
            'q2': 'q2',
            'casing': 'titlecase'
        })

        with port.assertRaises(TypeError):
            self.service.names().stats()
            self.service.names().stats('name', 'givenName')

        self.service.names().stats('name')
        self.expect('GET', '/name/stats.json', {'name': 'name'})
        self.service.names().stats(givenName='name')
        self.expect('GET', '/name/stats.json', {'givenName': 'name'})
        self.service.names().stats(givenName='name', familyName='name')
        self.expect('GET', '/name/stats.json', {
            'givenName': 'name',
            'familyName': 'name',
        })

        with port.assertRaises(TypeError):
            self.service.names().parser()

        self.service.names().parser('name')
        self.expect('GET', '/name/parser.json', {'q': 'name'})
        self.service.names().parser('name', 'lowercase')
        self.expect('GET', '/name/parser.json', {
            'q': 'name',
            'casing': 'lowercase'
        })

    def test_locations(self):
        with port.assertRaises(TypeError):
            self.service.locations().normalizer()

        self.service.locations().normalizer('location')
        self.expect('GET', '/address/locationNormalizer.json', {
            'place': 'location',
            'includeZeroPopulation': 'false'
        })
        self.service.locations().normalizer('location', True)
        self.expect('GET', '/address/locationNormalizer.json', {
            'place': 'location',
            'includeZeroPopulation': 'true'
        })
        self.service.locations().normalizer('location', casing='lowercase')
        self.expect('GET', '/address/locationNormalizer.json', {
            'place': 'location',
            'includeZeroPopulation': 'false',
            'casing': 'lowercase'
        })

        with port.assertRaises(TypeError):
            self.service.locations().enrichment()

        self.service.locations().enrichment('location')
        self.expect('GET', '/address/locationEnrichment.json', {
            'place': 'location',
            'includeZeroPopulation': 'false'
        })
        self.service.locations().enrichment('location', True)
        self.expect('GET', '/address/locationEnrichment.json', {
            'place': 'location',
            'includeZeroPopulation': 'true'
        })
        self.service.locations().enrichment('location', casing='lowercase')
        self.expect('GET', '/address/locationEnrichment.json', {
            'place': 'location',
            'includeZeroPopulation': 'false',
            'casing': 'lowercase'
        })

########NEW FILE########
__FILENAME__ = test_github
import json
import unittest

from libsaas.executors import test_executor
from libsaas.services import base, github


class GithubTestCase(unittest.TestCase):

    def setUp(self):
        self.executor = test_executor.use()
        self.executor.set_response(b'{}', 200, {})

        self.service = github.GitHub('my-token')

    def expect(self, method=None, uri=None, params=None, headers=None):
        if method:
            self.assertEqual(method, self.executor.request.method)
        if uri:
            self.assertEqual(self.executor.request.uri,
                              'https://api.github.com' + uri)
        if params:
            self.assertEqual(self.executor.request.params, params)
        if headers:
            self.assertEqual(self.executor.request.headers, headers)

    def test_auth(self):
        service = github.GitHub('a-token')
        service.user().get()
        self.expect('GET', '/user', {}, {'Authorization': 'token a-token'})

        service = github.GitHub('user', 'password')
        service.user().get()
        self.expect('GET', '/user', {}, {'Authorization':
                                             'Basic dXNlcjpwYXNzd29yZA=='})

    def test_gists(self):
        self.service.gists().get()
        self.expect('GET', '/gists')

        self.service.gists().public()
        self.expect('GET', '/gists/public')

        self.service.gists().starred()
        self.expect('GET', '/gists/starred')

        self.service.gist('12345678').get()
        self.expect('GET', '/gists/12345678')

        data = {'x': 'x'}
        self.service.gists().create(data)
        self.expect('POST', '/gists', json.dumps(data))

        self.service.gist('12345678').update(data)
        self.expect('PATCH', '/gists/12345678', json.dumps(data))

        self.service.gist('12345678').star()
        self.expect('PUT', '/gists/12345678/star')
        self.assertTrue(self.executor.request.params)

        self.service.gist('12345678').unstar()
        self.expect('DELETE', '/gists/12345678/star')

        self.executor.set_response(b'', 204, {})
        res = self.service.gist('12345678').is_starred()
        self.expect('GET', '/gists/12345678/star')
        self.assertTrue(res)

        self.executor.set_response(b'', 404, {})
        res = self.service.gist('12345678').is_starred()
        self.assertFalse(res)

        self.executor.set_response(b'{}', 200, {})
        self.service.gist('12345678').fork()
        self.expect('POST', '/gists/12345678/fork')

        self.service.gist('12345678').delete()
        self.expect('DELETE', '/gists/12345678')

    def test_gist_comments(self):
        self.service.gist('12345678').comments().get()
        self.expect('GET', '/gists/12345678/comments')

        self.service.gists().comment('123').get()
        self.expect('GET', '/gists/comments/123')

        self.service.gists().comment('123').get('html')
        self.expect('GET', '/gists/comments/123',
                    headers={'Accept': 'application/vnd.github.v3.html+json',
                             'Authorization': 'token my-token'})

        self.service.gist('12345678').comments().create('yo')
        self.expect('POST', '/gists/12345678/comments',
                    json.dumps({'body': 'yo'}))

        self.service.gists().comment('123').update('yo')
        self.expect('PATCH', '/gists/comments/123',
                    json.dumps({'body': 'yo'}))

        self.service.gists().comment('123').delete()
        self.expect('DELETE', '/gists/comments/123')

    def test_issues(self):
        self.service.issues().get(filter='mentioned',
                                  sort='updated', format='text')
        params = {'filter': 'mentioned', 'state': 'open',
                  'sort': 'updated', 'direction': 'desc'}
        headers = {'Accept': 'application/vnd.github.v3.text+json',
                   'Authorization': 'token my-token'}
        self.expect('GET', '/issues', params, headers)

    def test_repos(self):
        self.service.repos().get()
        self.expect('GET', '/user/repos', {'type': 'all'})

        self.service.repos().get(type='owner')
        self.expect('GET', '/user/repos', {'type': 'owner'})

        self.service.repo('myuser', 'myrepo').get()
        self.expect('GET', '/repos/myuser/myrepo')

        self.service.repo('myuser', 'myrepo').update({'x': 'x'})
        self.expect('PATCH', '/repos/myuser/myrepo', json.dumps({'x': 'x'}))

        self.service.repos().create({'x': 'x'})
        self.expect('POST', '/user/repos', json.dumps({'x': 'x'}))

        self.service.repo('myuser', 'myrepo').contributors(anon=True)
        self.expect('GET', '/repos/myuser/myrepo/contributors',
                    {'anon': 'true'})

        self.service.repo('myuser', 'myrepo').languages()
        self.expect('GET', '/repos/myuser/myrepo/languages')

        self.service.repo('myuser', 'myrepo').teams()
        self.expect('GET', '/repos/myuser/myrepo/teams')

        self.service.repo('myuser', 'myrepo').tags()
        self.expect('GET', '/repos/myuser/myrepo/tags')

        self.service.repo('myuser', 'myrepo').branches()
        self.expect('GET', '/repos/myuser/myrepo/branches')

    def test_repo_issues(self):
        self.service.repo('myuser', 'myrepo').issues().get()
        self.expect('GET', '/repos/myuser/myrepo/issues')

        params = {'state': 'open', 'mentioned': 'foo',
                  'sort': 'created', 'direction': 'desc'}
        self.service.repo('myuser', 'myrepo').issues().get(mentioned='foo')
        self.expect('GET', '/repos/myuser/myrepo/issues', params)

        self.service.repo('myuser', 'myrepo').issues().get()
        self.expect('GET', '/repos/myuser/myrepo/issues')

        self.service.repo('myuser', 'myrepo').issue(4).get()
        self.expect('GET', '/repos/myuser/myrepo/issues/4')

        self.service.repo('myuser', 'myrepo').issues().create({'x': 'x'})
        self.expect('POST', '/repos/myuser/myrepo/issues',
                    json.dumps({'x': 'x'}))

        self.service.repo('myuser', 'myrepo').issue(4).update({'x': 'x'})
        self.expect('PATCH', '/repos/myuser/myrepo/issues/4',
                    json.dumps({'x': 'x'}))

    def test_issue_comments(self):
        self.service.repo('myuser', 'myrepo').issue(4).comments().get()
        self.expect('GET', '/repos/myuser/myrepo/issues/4/comments')

        self.assertRaises(AttributeError, getattr,
                          self.service.repo('myuser', 'myrepo')
                          .issue(4), 'comment')

        self.service.repo('myuser', 'myrepo').issues().comment(5).get()
        self.expect('GET', '/repos/myuser/myrepo/issues/comments/5')

        (self.service.repo('myuser', 'myrepo')
         .issue(5).comments()
         .create('comment text'))
        self.expect('POST', '/repos/myuser/myrepo/issues/5/comments',
                    json.dumps({'body': 'comment text'}))

        (self.service.repo('myuser', 'myrepo')
         .issues().comment(6)
         .update('comment text'))
        self.expect('PATCH', '/repos/myuser/myrepo/issues/comments/6',
                    json.dumps({'body': 'comment text'}))

        (self.service.repo('myuser', 'myrepo')
         .issues().comment(6)
         .delete())
        self.expect('DELETE', '/repos/myuser/myrepo/issues/comments/6')

    def test_issue_events(self):
        self.service.repo('myuser', 'myrepo').issue(4).events().get()
        self.expect('GET', '/repos/myuser/myrepo/issues/4/events')

        self.service.repo('myuser', 'myrepo').issues().events().get()
        self.expect('GET', '/repos/myuser/myrepo/issues/events')

        self.service.repo('myuser', 'myrepo').issue(4).event(5).get()
        self.expect('GET', '/repos/myuser/myrepo/issues/4/events/5')

    def test_labels(self):
        self.service.repo('myuser', 'myrepo').labels().get()
        self.expect('GET', '/repos/myuser/myrepo/labels')

        self.service.repo('myuser', 'myrepo').label('l').get()
        self.expect('GET', '/repos/myuser/myrepo/labels/l')

        self.service.repo('myuser', 'myrepo').labels().create(
            {'name': 'l', 'color': 'ffffff'})
        self.expect('POST', '/repos/myuser/myrepo/labels',
                    json.dumps({'name': 'l', 'color': 'ffffff'}))

        self.service.repo('myuser', 'myrepo').label('l').update({'name': 'l2'})
        self.expect('PATCH', '/repos/myuser/myrepo/labels/l',
                    json.dumps({'name': 'l2'}))

        self.service.repo('myuser', 'myrepo').label('l').delete()
        self.expect('DELETE', '/repos/myuser/myrepo/labels/l')

        self.service.repo('myuser', 'myrepo').issue(4).labels().get()
        self.expect('GET', '/repos/myuser/myrepo/issues/4/labels')

        (self.service.repo('myuser', 'myrepo').issue(4)
         .labels().create(['l1', 'l2']))
        self.expect('POST', '/repos/myuser/myrepo/issues/4/labels',
                    json.dumps(['l1', 'l2']))

        self.service.repo('myuser', 'myrepo').issue(4).label('l').delete()
        self.expect('DELETE', '/repos/myuser/myrepo/issues/4/labels/l')

        (self.service.repo('myuser', 'myrepo').issue(4)
         .labels().replace(['l1', 'l2']))
        self.expect('PUT', '/repos/myuser/myrepo/issues/4/labels')

        self.service.repo('myuser', 'myrepo').issue(4).labels().delete()
        self.expect('DELETE', '/repos/myuser/myrepo/issues/4/labels')

    def test_milestones(self):
        params = {'state': 'open', 'sort': 'due_date',
                  'direction': 'asc', 'page': 2}
        self.service.repo('myuser', 'myrepo').milestones().get(
            direction='asc', page=2)
        self.expect('GET', '/repos/myuser/myrepo/milestones', params)

        self.service.repo('myuser', 'myrepo').milestone(2).get()
        self.expect('GET', '/repos/myuser/myrepo/milestones/2')

        self.service.repo('myuser', 'myrepo').milestones().create({'x': 'x'})
        self.expect('POST', '/repos/myuser/myrepo/milestones',
                    json.dumps({'x': 'x'}))

        self.service.repo('myuser', 'myrepo').milestone(3).update({'x': 'x'})
        self.expect('PATCH', '/repos/myuser/myrepo/milestones/3',
                    json.dumps({'x': 'x'}))

        self.service.repo('myuser', 'myrepo').milestone(3).delete()
        self.expect('DELETE', '/repos/myuser/myrepo/milestones/3')

        self.service.repo('myuser', 'myrepo').milestone(3).labels().get()
        self.expect('GET', '/repos/myuser/myrepo/milestones/3/labels')

    def test_collaborators(self):
        self.service.repo('myuser', 'myrepo').collaborators().get(page=2)
        self.expect('GET', '/repos/myuser/myrepo/collaborators', {'page': 2})

        self.service.repo('myuser', 'myrepo').collaborators().add('foo')
        self.expect('PUT', '/repos/myuser/myrepo/collaborators/foo')

        self.service.repo('myuser', 'myrepo').collaborators().remove('foo')
        self.expect('DELETE', '/repos/myuser/myrepo/collaborators/foo')

        self.executor.set_response(b'', 204, {})
        res = (self.service.repo('myuser', 'myrepo').collaborators()
         .is_collaborator('foo'))
        self.expect('GET', '/repos/myuser/myrepo/collaborators/foo')
        self.assertTrue(res)

    def test_repo_commits(self):
        self.service.repo('myuser', 'myrepo').commits().get(sha='x', page=2)
        self.expect('GET', '/repos/myuser/myrepo/commits',
                    {'sha': 'x', 'page': 2})

        self.service.repo('myuser', 'myrepo').commit('x').get()
        self.expect('GET', '/repos/myuser/myrepo/commits/x')

        self.service.repo('myuser', 'myrepo').commits().comments().get(page=2)
        self.expect('GET', '/repos/myuser/myrepo/comments', {'page': 2})

        self.service.repo('myuser', 'myrepo').commit('x').comments().get(
            format='html', page=2)
        self.expect('GET', '/repos/myuser/myrepo/commits/x/comments',
                    {'page': 2},
                    headers={'Accept': 'application/vnd.github.v3.html+json',
                             'Authorization': 'token my-token'})

        self.service.repo('myuser', 'myrepo').commit('x').comments().create(
            {'x': 'x'})
        self.expect('POST', '/repos/myuser/myrepo/commits/x/comments',
                    json.dumps({'x': 'x'}))

        self.service.repo('myuser', 'myrepo').commits().comment(3).get()
        self.expect('GET', '/repos/myuser/myrepo/comments/3')

        (self.service.repo('myuser', 'myrepo').commits()
         .comment(3).update('comment text'))
        self.expect('PATCH', '/repos/myuser/myrepo/comments/3',
                    json.dumps({'body': 'comment text'}))

        self.service.repo('myuser', 'myrepo').commits().compare('c1', 'c2')
        self.expect('GET', '/repos/myuser/myrepo/compare/c1...c2')

        self.service.repo('myuser', 'myrepo').commits().comment(2).delete()
        self.expect('DELETE', '/repos/myuser/myrepo/comments/2')

    def test_repo_contents(self):
        self.service.repo('myuser', 'myrepo').contents().readme()
        self.expect('GET', '/repos/myuser/myrepo/readme')

        self.service.repo('myuser', 'myrepo').contents().readme('myref')
        self.expect('GET', '/repos/myuser/myrepo/readme', {'ref': 'myref'})

        self.service.repo('myuser', 'myrepo').contents().get()
        self.expect('GET', '/repos/myuser/myrepo/contents')

        self.service.repo('myuser', 'myrepo').contents().get('file', 'myref')
        self.expect('GET', '/repos/myuser/myrepo/contents/file',
                    {'ref': 'myref'})

        self.executor.set_response(b'{}', 302,
                                   {'location': 'http://example.org'})
        link = self.service.repo('myuser', 'myrepo').contents().archivelink(
            'tarball', 'myref')
        self.expect('GET', '/repos/myuser/myrepo/tarball/myref')
        self.assertEqual(link, 'http://example.org')

    def test_pullrequests(self):
        self.service.repo("myuser", "myrepo").pullrequests().get()
        self.expect('GET', '/repos/myuser/myrepo/pulls')

        self.service.repo("myuser", "myrepo").pullrequests().get('closed')
        self.expect('GET', '/repos/myuser/myrepo/pulls', {'state': 'closed'})

        self.service.repo("myuser", "myrepo").pullrequest(0).get()
        self.expect('GET', '/repos/myuser/myrepo/pulls/0')

        self.service.repo("myuser", "myrepo").pullrequest(4).commits()
        self.expect('GET', '/repos/myuser/myrepo/pulls/4/commits')

        self.service.repo("myuser", "myrepo").pullrequest(4).files()
        self.expect('GET', '/repos/myuser/myrepo/pulls/4/files')

        self.executor.set_response(b'{}', 204, {})
        res = self.service.repo('myuser', 'myrepo').pullrequest(0).is_merged()
        self.expect('GET', '/repos/myuser/myrepo/pulls/0/merge')
        self.assertTrue(res)

        self.executor.set_response(b'', 404, {})
        res = self.service.repo('myuser', 'myrepo').pullrequest(0).is_merged()
        self.expect('GET', '/repos/myuser/myrepo/pulls/0/merge')
        self.assertFalse(res)

    def test_downloads(self):
        self.service.repo('myuser', 'myrepo').downloads().get(page=2)
        self.expect('GET', '/repos/myuser/myrepo/downloads', {'page': 2})

        self.service.repo('myuser', 'myrepo').download(1).get()
        self.expect('GET', '/repos/myuser/myrepo/downloads/1')

        self.service.repo('myuser', 'myrepo').downloads().create({'x': 'x'})
        self.expect('POST', '/repos/myuser/myrepo/downloads',
                    json.dumps({'x': 'x'}))

        self.service.repo('myuser', 'myrepo').download(1).delete()
        self.expect('DELETE', '/repos/myuser/myrepo/downloads/1')

        self.assertRaises(base.MethodNotSupported,
                          self.service.repo('myuser', 'myrepo')
                          .download(1).update, {'x': 'x'})

    def test_forks(self):
        self.service.repo('myuser', 'myrepo').forks().get(per_page=3)
        self.expect('GET', '/repos/myuser/myrepo/forks',
                    {'sort': 'newest', 'per_page': 3})

        self.service.repo('myuser', 'myrepo').forks().create()
        self.expect('POST', '/repos/myuser/myrepo/forks')

    def test_users(self):
        self.service.user().get()
        self.expect('GET', '/user')

        self.service.user().update({'x': 'x'})
        self.expect('PATCH', '/user', json.dumps({'x': 'x'}))

        self.assertRaises(base.MethodNotSupported,
                          self.service.user().delete)

        self.assertRaises(base.MethodNotSupported,
                          self.service.user().create, {'x': 'x'})

        self.service.user('name').get()
        self.expect('GET', '/users/name')

        self.service.user().emails().get()
        self.expect('GET', '/user/emails')

        self.service.user().emails().add('u@example.org')
        self.expect('POST', '/user/emails', json.dumps('u@example.org'))

        self.service.user().emails().remove(['u@example.org', 'x@example.org'])
        self.expect('DELETE', '/user/emails')

    def test_followers(self):
        self.service.user().followers()
        self.expect('GET', '/user/followers')

        self.service.user('foo').followers(page=3)
        self.expect('GET', '/users/foo/followers', {'page': 3})

        self.service.user().following()
        self.expect('GET', '/user/following')

        self.service.user('foo').following(page=3)
        self.expect('GET', '/users/foo/following', {'page': 3})

        self.service.user().follow('name')
        self.expect('PUT', '/user/following/name')

        self.service.user().unfollow('name')
        self.expect('DELETE', '/user/following/name')

        self.executor.set_response(b'', 204, {})
        res = self.service.user().follows('name')
        self.expect('GET', '/user/following/name')
        self.assertTrue(res)

        self.executor.set_response(b'', 404, {})
        res = self.service.user().follows('name')
        self.expect('GET', '/user/following/name')
        self.assertFalse(res)

    def test_user_repos(self):
        self.service.user('foo').repos().get(page=2)
        self.expect('GET', '/users/foo/repos', {'page': 2, 'type': 'all'})

        self.assertRaises(base.MethodNotSupported,
                          self.service.user('foo').repos().create)

        self.assertRaises(base.MethodNotSupported,
                          self.service.user('foo').repos().update, 'x')

    def test_authorizations(self):
        self.service.authorizations().get()
        self.expect('GET', '/authorizations')

        self.service.authorization(1).get()
        self.expect('GET', '/authorizations/1')

        self.service.authorizations().create({'x': 'x'})
        self.expect('POST', '/authorizations', json.dumps({'x': 'x'}))

        self.service.authorization(1).update({'x': 'x'})
        self.expect('PATCH', '/authorizations/1', json.dumps({'x': 'x'}))

        self.service.authorization(1).delete()
        self.expect('DELETE', '/authorizations/1')

    def test_unicode(self):
        # try an unicode name
        self.service.repo('myuser', b'\xce\xbb'.decode('utf-8')).get()
        self.expect('GET', '/repos/myuser/%CE%BB')

        # try an binary name (that's not valid Unicode)
        self.service.repo('myuser', b'\xa4\xff').get()
        self.expect('GET', '/repos/myuser/%A4%FF')

        # try a unicode parameter
        self.service.gists().comment('123').update(b'\xce\xbb'.decode('utf-8'))
        self.expect('PATCH', '/gists/comments/123', r'{"body": "\u03bb"}')

########NEW FILE########
__FILENAME__ = test_googleanalytics
import unittest

from libsaas.executors import test_executor
from libsaas.services import googleanalytics


class GoogleAnalyticsTestCase(unittest.TestCase):

    def setUp(self):
        self.executor = test_executor.use()
        self.executor.set_response(b'{}', 200, {})

        self.service = googleanalytics.GoogleAnalytics('access_token')

    def expect(self, method=None, uri=None, params=None):
        if method is not None:
            self.assertEqual(method, self.executor.request.method)
        if uri is not None:
            self.assertEqual(self.executor.request.uri,
                             self.service.APIROOT + uri)
        if params is not None:
            self.assertEqual(self.executor.request.params, params)

    def test_reporting(self):
        params = {'ids': 'ga:1111', 'metrics': 'm1,m2', 'dimensions':'dim1'}

        self.service.reporting().realtime('ga:1111', 'm1,m2', 'dim1')
        self.expect('GET', '/data/realtime', params)

        params.update({'start-date': '1992-05-20', 'end-date': '1992-05-21'})
        self.service.reporting().core('ga:1111', '1992-05-20', '1992-05-21',
                                          'm1,m2', 'dim1')
        self.expect('GET', '/data/ga', params)

    def test_management(self):
        params = {'quotaUser': 'foo'}

        self.service.management().segments().get(quotaUser='foo')
        self.expect('GET', '/management/segments', params)

        self.service.management().accounts().get(quotaUser='foo')
        self.expect('GET', '/management/accounts', params)
        self.service.management().account('1').get(quotaUser='foo')
        self.expect('GET', '/management/accounts/1', params)

        (self.service.management().account('1')
         .webproperties().get(quotaUser='foo'))
        self.expect('GET', '/management/accounts/1/webproperties', params)
        (self.service.management().account('1')
         .webproperty('1').get(quotaUser='foo'))
        self.expect('GET', '/management/accounts/1/webproperties/1', params)

        (self.service.management().account('1')
            .webproperty('1').views().get(quotaUser='foo'))
        self.expect(
            'GET', '/management/accounts/1/webproperties/1/profiles', params)
        (self.service.management().account('1')
            .webproperty('1').view(1).get(quotaUser='foo'))
        self.expect(
            'GET', '/management/accounts/1/webproperties/1/profiles/1', params)

        (self.service.management().account('1')
            .webproperty('1').view(1).goals().get(quotaUser='foo'))
        self.expect(
            'GET', '/management/accounts/1/webproperties/1/profiles/1/goals',
            params)
        (self.service.management().account('1')
            .webproperty('1').view(1).goal(1).get(quotaUser='foo'))
        self.expect(
            'GET', '/management/accounts/1/webproperties/1/profiles/1/goals/1',
            params)

########NEW FILE########
__FILENAME__ = test_googlecalendar
import json
import unittest

from libsaas import port
from libsaas.executors import test_executor
from libsaas.services import googlecalendar
from libsaas.services.base import MethodNotSupported


class GoogleCalendarTestCase(unittest.TestCase):

    def setUp(self):
        self.executor = test_executor.use()
        self.executor.set_response(b'{}', 200, {})

        self.service = googlecalendar.GoogleCalendar(access_token='my-access-token')

    def expect(self, method=None, uri=None, params={}, headers=None):
        if method:
            self.assertEqual(method, self.executor.request.method)

        if uri:
            self.assertEqual(self.executor.request.uri,
                            'https://www.googleapis.com/calendar/v3' + uri)

        self.assertEqual(self.executor.request.params, params)

        if headers:
            self.assertEqual(self.executor.request.headers, headers)

    def test_user(self):
        with port.assertRaises(MethodNotSupported):
            self.service.me().get()
        with port.assertRaises(MethodNotSupported):
            self.service.me().create()
        with port.assertRaises(MethodNotSupported):
            self.service.me().update()
        with port.assertRaises(MethodNotSupported):
            self.service.me().patch()
        with port.assertRaises(MethodNotSupported):
            self.service.me().delete()

        with port.assertRaises(MethodNotSupported):
            self.service.me().settings().create()
        with port.assertRaises(MethodNotSupported):
            self.service.me().settings().update()
        with port.assertRaises(MethodNotSupported):
            self.service.me().settings().patch()
        with port.assertRaises(MethodNotSupported):
            self.service.me().settings().delete()

        self.service.me().settings().get()
        self.expect('GET', '/users/me/settings', {})

        with port.assertRaises(MethodNotSupported):
            self.service.me().setting('1234').create()
        with port.assertRaises(MethodNotSupported):
            self.service.me().setting('1234').update()
        with port.assertRaises(MethodNotSupported):
            self.service.me().setting('1234').patch()
        with port.assertRaises(MethodNotSupported):
            self.service.me().setting('1234').delete()

        self.service.me().setting('1234').get()
        self.expect('GET', '/users/me/settings/1234', {})

        with port.assertRaises(MethodNotSupported):
            self.service.me().calendar_lists().update()
        with port.assertRaises(MethodNotSupported):
            self.service.me().calendar_lists().patch()
        with port.assertRaises(MethodNotSupported):
            self.service.me().calendar_lists().delete()
        with port.assertRaises(MethodNotSupported):
            self.service.me().calendar_list('1234').create()

        self.service.me().calendar_lists().get()
        self.expect('GET', '/users/me/calendarList', {})
        obj = {'foo': 'bar'}
        self.service.me().calendar_lists().create(obj)
        self.expect('POST', '/users/me/calendarList', json.dumps(obj))

        self.service.me().calendar_list('1234').get()
        self.expect('GET', '/users/me/calendarList/1234', {})
        self.service.me().calendar_list('1234').update(obj)
        self.expect('PUT', '/users/me/calendarList/1234', json.dumps(obj))
        self.service.me().calendar_list('1234').patch(obj)
        self.expect('PATCH', '/users/me/calendarList/1234', json.dumps(obj))
        self.service.me().calendar_list('1234').delete()
        self.expect('DELETE', '/users/me/calendarList/1234', {})

    def test_colors(self):
        with port.assertRaises(MethodNotSupported):
            self.service.colors().create()
        with port.assertRaises(MethodNotSupported):
            self.service.colors().update()
        with port.assertRaises(MethodNotSupported):
            self.service.colors().patch()
        with port.assertRaises(MethodNotSupported):
            self.service.colors().delete()

        self.service.colors().get()
        self.expect('GET', '/colors', {})

    def test_freebusy(self):
        with port.assertRaises(MethodNotSupported):
            self.service.freebusy().get()
        with port.assertRaises(MethodNotSupported):
            self.service.freebusy().create()
        with port.assertRaises(MethodNotSupported):
            self.service.freebusy().update()
        with port.assertRaises(MethodNotSupported):
            self.service.freebusy().patch()
        with port.assertRaises(MethodNotSupported):
            self.service.freebusy().delete()

        obj = {'foo': 'bar'}
        self.service.freebusy().query(obj)
        self.expect('POST', '/freeBusy', json.dumps(obj))

    def test_calendar(self):
        with port.assertRaises(MethodNotSupported):
            self.service.calendars().get()
        with port.assertRaises(MethodNotSupported):
            self.service.calendars().update()
        with port.assertRaises(MethodNotSupported):
            self.service.calendars().patch()
        with port.assertRaises(MethodNotSupported):
            self.service.calendars().delete()

        obj = {'foo': 'bar'}
        self.service.calendars().create(obj)
        self.expect('POST', '/calendars', json.dumps(obj))

        with port.assertRaises(MethodNotSupported):
            self.service.calendar('1234').create()

        self.service.calendar('1234').get()
        self.expect('GET', '/calendars/1234', {})
        self.service.calendar('1234').update(obj)
        self.expect('PUT', '/calendars/1234', json.dumps(obj))
        self.service.calendar('1234').patch(obj)
        self.expect('PATCH', '/calendars/1234', json.dumps(obj))
        self.service.calendar('1234').delete()
        self.expect('DELETE', '/calendars/1234', {})

        self.service.calendar('1234').clear()
        self.expect('POST', '/calendars/1234/clear', {})

        with port.assertRaises(MethodNotSupported):
            self.service.calendar('1234').rules().update()
        with port.assertRaises(MethodNotSupported):
            self.service.calendar('1234').rules().patch()
        with port.assertRaises(MethodNotSupported):
            self.service.calendar('1234').rules().delete()

        self.service.calendar('1234').rules().get()
        self.expect('GET', '/calendars/1234/acl', {})
        obj = {'foo': 'bar'}
        self.service.calendar('1234').rules().create(obj)
        self.expect('POST', '/calendars/1234/acl', json.dumps(obj))

        with port.assertRaises(MethodNotSupported):
            self.service.calendar('1234').rule('1234').create()

        self.service.calendar('1234').rule('1234').get()
        self.expect('GET', '/calendars/1234/acl/1234', {})
        self.service.calendar('1234').rule('1234').update(obj)
        self.expect('PUT', '/calendars/1234/acl/1234', json.dumps(obj))
        self.service.calendar('1234').rule('1234').patch(obj)
        self.expect('PATCH', '/calendars/1234/acl/1234', json.dumps(obj))
        self.service.calendar('1234').rule('1234').delete()
        self.expect('DELETE', '/calendars/1234/acl/1234', {})

        with port.assertRaises(MethodNotSupported):
            self.service.calendar('1234').events().update()
        with port.assertRaises(MethodNotSupported):
            self.service.calendar('1234').events().patch()
        with port.assertRaises(MethodNotSupported):
            self.service.calendar('1234').events().delete()

        self.service.calendar('1234').events().get()
        self.expect('GET', '/calendars/1234/events', {})
        self.service.calendar('1234').events().get(timeZone='UTC')
        self.expect('GET', '/calendars/1234/events', {'timeZone': 'UTC'})
        obj = {'foo': 'bar'}
        self.service.calendar('1234').events().create(obj)
        self.expect('POST', '/calendars/1234/events', json.dumps(obj))
        self.service.calendar('1234').events().importing(obj)
        self.expect('POST', '/calendars/1234/events/import', json.dumps(obj))
        self.service.calendar('1234').events().quick_add('text', True)
        self.expect('POST',
            '/calendars/1234/events/quickAdd?text=text&sendNotifications=true')

        with port.assertRaises(MethodNotSupported):
            self.service.calendar('1234').event('1234').create()

        self.service.calendar('1234').event('1234').get()
        self.expect('GET', '/calendars/1234/events/1234', {})
        self.service.calendar('1234').event('1234').instances()
        self.expect('GET', '/calendars/1234/events/1234/instances', {})
        self.service.calendar('1234').event('1234').instances(maxResults=1)
        self.expect('GET', '/calendars/1234/events/1234/instances',
                    {'maxResults': 1})
        self.service.calendar('1234').event('1234').update(obj)
        self.expect('PUT', '/calendars/1234/events/1234', json.dumps(obj))
        self.service.calendar('1234').event('1234').update(obj, True)
        self.expect('PUT', '/calendars/1234/events/1234?alwaysIncludeEmail=true',
                    json.dumps(obj))
        self.service.calendar('1234').event('1234').patch(obj)
        self.expect('PATCH', '/calendars/1234/events/1234', json.dumps(obj))
        self.service.calendar('1234').event('1234').patch(obj, sendNotifications=True)
        self.expect('PATCH', '/calendars/1234/events/1234?sendNotifications=true',
                    json.dumps(obj))
        self.service.calendar('1234').event('1234').delete()
        self.expect('DELETE', '/calendars/1234/events/1234', {})
        self.service.calendar('1234').event('1234').delete(True)
        self.expect('DELETE', '/calendars/1234/events/1234?sendNotifications=true')
        self.service.calendar('1234').event('1234').move('1234')
        self.expect('POST', '/calendars/1234/events/1234/move?destination=1234')

########NEW FILE########
__FILENAME__ = test_googleoauth2
import unittest

from libsaas.executors import test_executor
from libsaas.services import googleoauth2


class GoogleOauth2TestCase(unittest.TestCase):

    def setUp(self):
        self.executor = test_executor.use()
        self.executor.set_response(b'{}', 200, {})

        self.service = googleoauth2.GoogleOAuth2('id', 'secret')

    def expect(self, method=None, uri=None, params=None):
        if method is not None:
            self.assertEqual(method, self.executor.request.method)
        if uri is not None:
            self.assertEqual(self.executor.request.uri,
                             self.service.APIROOT + uri)
        if params is not None:
            self.assertEqual(self.executor.request.params, params)

    def test_access_token(self):
        params = {'client_id': 'id',
                  'client_secret': 'secret',
                  'grant_type': 'authorization_code',
                  'code': 'code',
                  'redirect_uri': 'uri'}

        self.service.access_token('code', 'uri')
        self.expect('POST', '/token', params)

    def test_refresh_token(self):
        params = {'client_id': 'id',
                  'client_secret': 'secret',
                  'grant_type': 'refresh_token',
                  'refresh_token': 'token'}

        self.service.refresh_token('token')
        self.expect('POST', '/token', params)

########NEW FILE########
__FILENAME__ = test_googlespreadsheets
import unittest

from libsaas import port, xml
from libsaas.executors import test_executor
from libsaas.services import googlespreadsheets
from libsaas.services.base import MethodNotSupported


class GoogleSpreadsheetsTestCase(unittest.TestCase):

    def expect(self, method=None, uri=None, params=None, headers=None):
        if method:
            self.assertEqual(method, self.executor.request.method)
        if uri:
            self.assertEqual(self.executor.request.uri,
                              'https://spreadsheets.google.com' + uri)

        self.assertEqual(self.executor.request.params, params)

        if headers:
            self.assertEqual(self.executor.request.headers, headers)

class GoogleSpreadsheetsXMLTestCase(GoogleSpreadsheetsTestCase):

    def setUp(self):
        self.executor = test_executor.use()
        self.executor.set_response(
            b'<?xml version="1.0" encoding="UTF-8"?><root/>', 200, {})
        self.service = googlespreadsheets.GoogleSpreadsheets('my-token')

    def test_worksheets(self):
        # XXX this fails with lxml compiled against some libxml versions with:
        #    ValueError: Invalid tag name u'gs:colCount'
        # so disable the test for now
        if hasattr(xml.etree, 'LXML_VERSION'):
            # unittest doesn't have skip on Python 2.6...
            return

        create = {
            'entry': {
                '@xmlns': 'http://www.w3.org/2005/Atom',
                '@xmlns:gs': 'http://schemas.google.com/spreadsheets/2006',
                'title': 'testing',
                'gs:rowCount': 50,
                'gs:colCount': 10
            }
        }
        (self.service.spreadsheet('key').worksheets('v', 'p')
                                        .create(create.copy()))
        self.expect('POST', '/feeds/worksheets/key/v/p',
                    params=xml.dict_to_xml(create))

        update = {
            'entry': {
                '@xmlns': 'http://www.w3.org/2005/Atom',
                '@xmlns:gs': 'http://schemas.google.com/spreadsheets/2006',
                'title': 'updated',
                'gs:rowCount': 40,
                'gs:colCount': 15
            }
        }
        (self.service.spreadsheet('key').worksheet('id', 'v', 'p')
                                        .update('v1', update.copy()))
        self.expect('PUT', '/feeds/worksheets/key/v/p/id/v1',
                    params=xml.dict_to_xml(update))

        (self.service.spreadsheet('key').worksheet('id', 'v', 'p')
                                        .delete('v2'))
        self.expect('DELETE', '/feeds/worksheets/key/v/p/id/v2', None)

    def test_rows(self):
        # XXX this fails with lxml compiled against some libxml versions with:
        #    ValueError: Invalid tag name u'gs:colCount'
        # so disable the test for now
        if hasattr(xml.etree, 'LXML_VERSION'):
            # unittest doesn't have skip on Python 2.6...
            return

        create = {
            'entry': {
                '@xmlns': 'http://www.w3.org/2005/Atom',
                '@xmlns:gsx': 'http://schemas.google.com/spreadsheets/2006',
                'gsx:a': 7,
                'gsx:b': 'G'
            }
        }
        (self.service.spreadsheet('key').worksheet('id', 'v', 'p').rows()
                                        .create(create.copy()))
        self.expect('POST', '/feeds/list/key/id/v/p',
                    params=xml.dict_to_xml(create))

        update = {
            'entry': {
                '@xmlns': 'http://www.w3.org/2005/Atom',
                '@xmlns:gsx': 'http://schemas.google.com/spreadsheets/2006',
                'gsx:a': 10,
                'gsx:b': 'G',
                'gsx:c': 14
            }
        }
        (self.service.spreadsheet('key').worksheet('id', 'v', 'p').row('row')
                                        .update('v1', update.copy()))
        self.expect('PUT', '/feeds/list/key/id/v/p/row/v1',
                    params=xml.dict_to_xml(update))

        (self.service.spreadsheet('key').worksheet('id', 'v', 'p').row('row')
                                        .delete('v2'))
        self.expect('DELETE', '/feeds/list/key/id/v/p/row/v2', None)

    def test_cells(self):
        # XXX this fails with lxml compiled against some libxml versions with:
        #    ValueError: Invalid tag name u'gs:colCount'
        # so disable the test for now
        if hasattr(xml.etree, 'LXML_VERSION'):
            # unittest doesn't have skip on Python 2.6...
            return

        with port.assertRaises(MethodNotSupported):
            (self.service.spreadsheet('key').worksheet('id', 'v', 'p').cells()
                                            .create({}))
            (self.service.spreadsheet('key').worksheet('id', 'v', 'p')
                                            .cell('cell').delete('v1'))

        cell = {
            'entry': {
                '@xmlns': 'http://www.w3.org/2005/Atom',
                '@xmlns:gs': 'http://schemas.google.com/spreadsheets/2006',
                'gs:cell': {
                    '@inputValue': '=SUM(A2:A3)',
                    '@row': '5',
                    '@col': '1'
                }
            }
        }
        (self.service.spreadsheet('key').worksheet('id', 'v', 'p').cell('R5C1')
                                        .update('v1', cell.copy()))
        self.expect('PUT', '/feeds/cells/key/id/v/p/R5C1/v1',
                    params=xml.dict_to_xml(cell))


class GoogleSpreadsheetsJSONTestCase(GoogleSpreadsheetsTestCase):

    def setUp(self):
        self.executor = test_executor.use()
        self.executor.set_response(b'{}', 200, {})
        self.service = googlespreadsheets.GoogleSpreadsheets('my-token')

    def test_spreadsheets(self):
        self.service.spreadsheets().get()
        self.expect('GET', '/feeds/spreadsheets/private/full',
                    {'alt': 'json'})

        with port.assertRaises(MethodNotSupported):
            self.service.spreadsheet('key').get()

        self.service.spreadsheet('key').worksheets('v', 'p').get()
        self.expect('GET', '/feeds/worksheets/key/v/p',
                    {'alt': 'json'})

        self.service.spreadsheet('key').worksheet('id', 'v', 'p').get()
        self.expect('GET', '/feeds/worksheets/key/v/p/id',
                    {'alt': 'json'})

        self.service.spreadsheet('key').worksheet('id', 'v', 'p').rows().get()
        self.expect('GET', '/feeds/list/key/id/v/p',
                    {'alt': 'json'})

        (self.service.spreadsheet('key').worksheet('id', 'v', 'p')
                                        .rows().get(reverse=True))
        self.expect('GET', '/feeds/list/key/id/v/p',
                    {'alt': 'json', 'reverse': 'true'})

        (self.service.spreadsheet('key').worksheet('id', 'v', 'p')
                                        .rows().get(sq='height>100'))
        self.expect('GET', '/feeds/list/key/id/v/p',
                    {'alt': 'json', 'sq': 'height>100'})

        with port.assertRaises(MethodNotSupported):
            (self.service.spreadsheet('key').worksheet('id', 'v', 'p')
                                            .row('row').get())

        self.service.spreadsheet('key').worksheet('id', 'v', 'p').cells().get()
        self.expect('GET', '/feeds/cells/key/id/v/p',
                    {'alt': 'json'})

        (self.service.spreadsheet('key').worksheet('id', 'v', 'p')
                                        .cells().get(min_col=2, max_col=4))
        self.expect('GET', '/feeds/cells/key/id/v/p',
                    {'alt': 'json', 'min-col': 2, 'max-col': 4})

        (self.service.spreadsheet('key').worksheet('id', 'v', 'p')
                                        .cells().get(min_row=2, max_row=4))
        self.expect('GET', '/feeds/cells/key/id/v/p',
                    {'alt': 'json', 'min-row': 2, 'max-row': 4})

        (self.service.spreadsheet('key').worksheet('id', 'v', 'p')
                                        .cell('cell').get())
        self.expect('GET', '/feeds/cells/key/id/v/p/cell',
                    {'alt': 'json'})

########NEW FILE########
__FILENAME__ = test_http
import unittest

from libsaas import http


class SerializeFlattenTestCase(unittest.TestCase):

    def test_flatten(self):
        s = http.serialize_flatten('p1', ['v1', 'v2', 'v3'])
        self.assertEqual(s, (('p1[0]', 'v1'), ('p1[1]', 'v2'), ('p1[2]', 'v3')))

        s = http.serialize_flatten('p1', ['v1', 'v2', 'v3'], False)
        self.assertEqual(s, (('p1[]', 'v1'), ('p1[]', 'v2'), ('p1[]', 'v3')))

        s = http.serialize_flatten('p1', [{'k1': 'v1', 'k2': True},
                                          {'k1': 'v2', 'k2': False}])
        # can't predict the order in which the dictionaries be processed, so
        # just make sure all the tuples are in place
        self.assertEquals(len(s), 4)
        self.assertEquals(tuple(sorted(s[:2])),
                          (('p1[0][k1]', 'v1'), ('p1[0][k2]', 'true')))
        self.assertEquals(tuple(sorted(s[2:])),
                          (('p1[1][k1]', 'v2'), ('p1[1][k2]', 'false')))

########NEW FILE########
__FILENAME__ = test_instagram
import unittest

from libsaas import port
from libsaas.executors import test_executor
from libsaas.services import instagram
from libsaas.services.base import MethodNotSupported


class InstagramTestCase(unittest.TestCase):

    def setUp(self):
        self.executor = test_executor.use()
        self.executor.set_response(b'{}', 200, {})

        self.service = instagram.Instagram(access_token='my-access-token')

    def expect(self, method=None, uri=None, params={}, headers=None):
        if method:
            self.assertEqual(method, self.executor.request.method)

        if method == 'DELETE':
            uri += '?access_token=my-access-token'
        else:
            params.update({'access_token': 'my-access-token'})

        if uri:
            self.assertEqual(self.executor.request.uri,
                              'https://api.instagram.com/v1' + uri)

        self.assertEqual(self.executor.request.params, params)

        if headers:
            self.assertEqual(self.executor.request.headers, headers)

    def test_users(self):
        with port.assertRaises(MethodNotSupported):
            self.service.user('1234').create()
            self.service.user('1234').update()
            self.service.user('1234').delete()

        self.service.user('1234').get()
        self.expect('GET', '/users/1234', {})
        self.service.user('1234').recent_media().get()
        self.expect('GET', '/users/1234/media/recent', {})
        self.service.user('1234').recent_media().get(count=1)
        self.expect('GET', '/users/1234/media/recent', {'count': 1})
        self.service.user('1234').recent_media().get(count=1, min_id=1234)
        self.expect('GET', '/users/1234/media/recent',
                    {'count': 1, 'min_id': 1234})
        self.service.user('1234').follows().get()
        self.expect('GET', '/users/1234/follows', {})
        self.service.user('1234').followed_by().get()
        self.expect('GET', '/users/1234/followed-by', {})
        self.service.user('1234').relationship().get()
        self.expect('GET', '/users/1234/relationship', {})
        self.service.user('1234').relationship().update('unfollow')
        self.expect('POST', '/users/1234/relationship', {'action': 'unfollow'})

        with port.assertRaises(MethodNotSupported):
            self.service.authenticated_user().create()
            self.service.authenticated_user().update()
            self.service.authenticated_user().delete()

        self.service.authenticated_user().get()
        self.expect('GET', '/users/self', {})
        self.service.authenticated_user().feed().get()
        self.expect('GET', '/users/self/feed', {})
        self.service.authenticated_user().feed().get(count=1)
        self.expect('GET', '/users/self/feed', {'count': 1})
        self.service.authenticated_user().feed().get(count=1, max_id=1234)
        self.expect('GET', '/users/self/feed', {'count': 1, 'max_id': 1234})
        self.service.authenticated_user().liked_media().get()
        self.expect('GET', '/users/self/media/liked', {})
        self.service.authenticated_user().liked_media().get(count=2)
        self.expect('GET', '/users/self/media/liked', {'count': 2})
        self.service.authenticated_user().requested_by().get()
        self.expect('GET', '/users/self/requested-by', {})

        with port.assertRaises(MethodNotSupported):
            self.service.users().create()
            self.service.users().update()
            self.service.users().delete()

        self.service.users().get('test')
        self.expect('GET', '/users/search', {'q': 'test'})
        self.service.users().get('test', count=3)
        self.expect('GET', '/users/search', {'q': 'test', 'count': 3})

    def test_media(self):
        with port.assertRaises(MethodNotSupported):
            self.service.media('1234').create()
            self.service.media('1234').update()
            self.service.media('1234').delete()

        self.service.media('1234').get()
        self.expect('GET', '/media/1234', {})
        self.service.media('1234').comments().get()
        self.expect('GET', '/media/1234/comments', {})
        self.service.media('1234').comments().create({'text': 'testing'})
        self.expect('POST', '/media/1234/comments', {'text': 'testing'})
        self.service.media('1234').comment('1234').delete()
        self.expect('DELETE', '/media/1234/comments/1234', {})
        self.service.media('1234').likes().get()
        self.expect('GET', '/media/1234/likes', {})
        self.service.media('1234').likes().create()
        self.expect('POST', '/media/1234/likes', {})
        self.service.media('1234').likes().delete()
        self.expect('DELETE', '/media/1234/likes', {})

        with port.assertRaises(MethodNotSupported):
            self.service.medias().create()
            self.service.medias().update()
            self.service.medias().delete()

        self.service.medias().get()
        self.expect('GET', '/media/search', {})
        self.service.medias().get(lat=48.858844, lng=2.294351)
        self.expect('GET', '/media/search', {'lat': 48.858844, 'lng':2.294351})

        with port.assertRaises(MethodNotSupported):
            self.service.popular_media().create()
            self.service.popular_media().update()
            self.service.popular_media().delete()

        self.service.popular_media().get()
        self.expect('GET', '/media/popular', {})

    def test_tags(self):
        with port.assertRaises(MethodNotSupported):
            self.service.tag('1234').create()
            self.service.tag('1234').update()
            self.service.tag('1234').delete()

        self.service.tag('1234').get()
        self.expect('GET', '/tags/1234', {})
        self.service.tag('1234').recent_media().get()
        self.expect('GET', '/tags/1234/media/recent', {})
        self.service.tag('1234').recent_media().get(min_id=1)
        self.expect('GET', '/tags/1234/media/recent', {'min_id': 1})

        with port.assertRaises(MethodNotSupported):
            self.service.tags().create()
            self.service.tags().update()
            self.service.tags().delete()

        self.service.tags().get('tag-name')
        self.expect('GET', '/tags/search', {'q': 'tag-name'})

    def test_locations(self):
        with port.assertRaises(MethodNotSupported):
            self.service.location('1234').create()
            self.service.location('1234').update()
            self.service.location('1234').delete()

        self.service.location('1234').get()
        self.expect('GET', '/locations/1234', {})
        self.service.location('1234').recent_media().get()
        self.expect('GET', '/locations/1234/media/recent', {})
        self.service.location('1234').recent_media().get(min_id=1)
        self.expect('GET', '/locations/1234/media/recent', {'min_id': 1})

        with port.assertRaises(MethodNotSupported):
            self.service.locations().create()
            self.service.locations().update()
            self.service.locations().delete()

        self.service.locations().get()
        self.expect('GET', '/locations/search', {})
        self.service.locations().get(lat=48.858844, lng=2.294351)
        self.expect('GET', '/locations/search',
                    {'lat': 48.858844, 'lng':2.294351})

    def test_geographies(self):
        with port.assertRaises(MethodNotSupported):
            self.service.geography('1234').get()
            self.service.geography('1234').create()
            self.service.geography('1234').update()
            self.service.geography('1234').delete()

        self.service.geography('1234').recent_media().get()
        self.expect('GET', '/geographies/1234/media/recent', {})
        self.service.geography('1234').recent_media().get(count=2)
        self.expect('GET', '/geographies/1234/media/recent', {'count': 2})

########NEW FILE########
__FILENAME__ = test_intercom
import json
import unittest

from libsaas import port
from libsaas.executors import test_executor
from libsaas.services import intercom
from libsaas.services.base import MethodNotSupported


class IntercomTestCase(unittest.TestCase):

    def setUp(self):
        self.executor = test_executor.use()
        self.executor.set_response(b'{}', 200, {})

        self.service = intercom.Intercom('my-app-id', 'my-api-key')

    def expect(self, method=None, uri=None, params=None, headers=None):
        if method:
            self.assertEqual(method, self.executor.request.method)
        if uri:
            self.assertEqual(self.executor.request.uri,
                              'https://api.intercom.io/v1' + uri)
        if params:
            self.assertEqual(self.executor.request.params, params)
        if headers:
            self.assertEqual(self.executor.request.headers, headers)

    def test_users(self):
        with port.assertRaises(MethodNotSupported):
            self.service.users().delete()

        self.service.users().get()
        self.expect('GET', '/users', {})
        self.service.users().get(per_page=3)
        self.expect('GET', '/users', {'per_page': 3})
        self.service.users().get(page=3)
        self.expect('GET', '/users', {'page': 3})

        user = {'user': 'x'}
        self.service.users().create(user)
        self.expect('POST', '/users', json.dumps(user))
        self.service.users().update(user)
        self.expect('PUT', '/users', json.dumps(user))

        with port.assertRaises(TypeError):
            self.service.user().get()

        with port.assertRaises(MethodNotSupported):
            self.service.user().create()
            self.service.user().update()
            self.service.user().delete()

        self.service.user().get(user_id=1)
        self.expect('GET', '/users', {'user_id': 1})
        self.service.user().get(email='name@domain.com')
        self.expect('GET', '/users', {'email': 'name@domain.com'})

    def test_impressions(self):
        with port.assertRaises(MethodNotSupported):
            self.service.impressions().get()
            self.service.impressions().update()
            self.service.impressions().delete()

        impression = {'impression': 'x'}
        self.service.impressions().create(impression)
        self.expect('POST', '/users/impressions', json.dumps(impression))

    def test_messages(self):
        with port.assertRaises(MethodNotSupported):
            self.service.message_threads().update()
            self.service.message_threads().delete()

        with port.assertRaises(TypeError):
            self.service.message_threads().get()

        self.service.message_threads().get(user_id=1)
        self.expect('GET', '/users/message_threads', {'user_id': 1})
        self.service.message_threads().get(email='name@domain.com')
        self.expect('GET', '/users/message_threads',
                    {'email': 'name@domain.com'})

        message_thread = {'message_thread': 'x'}
        self.service.message_threads().create(message_thread)
        self.expect('POST', '/users/message_threads',
                    json.dumps(message_thread))
        self.service.message_threads().reply(message_thread)
        self.expect('PUT', '/users/message_threads',
                    json.dumps(message_thread))

        with port.assertRaises(MethodNotSupported):
            self.service.message_thread().create()
            self.service.message_thread().update()
            self.service.message_thread().delete()

        with port.assertRaises(TypeError):
            self.service.message_thread().get(1234)

        self.service.message_thread().get(1234, user_id=1)
        self.expect('GET', '/users/message_threads',
                    {'thread_id': 1234, 'user_id': 1})
        self.service.message_thread().get(1234, email='name@domain.com')
        self.expect('GET', '/users/message_threads',
                    {'thread_id': 1234, 'email': 'name@domain.com'})

########NEW FILE########
__FILENAME__ = test_libsaas
import pkgutil
import unittest


def get_suite():
    modules = []
    moditer = pkgutil.iter_modules(['test'])

    for importer, modname, is_package in moditer:
        module = importer.find_module(modname).load_module(modname)
        modules.append(module)

    suites = [unittest.TestLoader().loadTestsFromModule(module)
              for module in modules]
    return unittest.TestSuite(suites)


def main():
    return unittest.TextTestRunner(verbosity=2).run(get_suite())


if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = test_mailchimp
import unittest

from libsaas.executors import test_executor
from libsaas.services import mailchimp


class MailchimpTestCase(unittest.TestCase):

    def setUp(self):
        self.executor = test_executor.use()
        self.executor.set_response(b'{}', 200, {})

        self.service = mailchimp.Mailchimp('apikey-us2')

    def expect(self, method=None, uri=None, params=None, headers=None):
        if method:
            self.assertEqual(method, self.executor.request.method)
        if uri:
            self.assertEqual(self.executor.request.uri,
                              'https://us2.api.mailchimp.com/1.3' + uri)
        if params:
            self.assertEqual(sorted(self.executor.request.params), sorted(params))
        if headers:
            self.assertEqual(self.executor.request.headers, headers)

    def test_serialize(self):
        """
        Verify that parameters are serialized correctly.
        """
        self.service.listBatchSubscribe(3, [{'EMAIL': 'foo@example.com'},
                                            {'EMAIL': 'bar@example.com'}])
        self.expect('POST', '/?method=listBatchSubscribe',
                    (('id', '3'), ('batch[0][EMAIL]', 'foo@example.com'),
                     ('batch[1][EMAIL]', 'bar@example.com'), ('output', 'json'),
                     ('double_optin', 'true'), ('update_existing', 'false'),
                     ('replace_interests', 'true'), ('apikey', 'apikey')))

########NEW FILE########
__FILENAME__ = test_mixpanel
import base64
import json
import unittest

from libsaas import port
from libsaas.executors import test_executor
from libsaas.services import mixpanel


class MixpanelTestCase(unittest.TestCase):

    def setUp(self):
        self.executor = test_executor.use()
        self.executor.set_response(b'1', 200, {})

        self.service = mixpanel.Mixpanel('my-token', 'api-key', 'api-secret')

    def serialize(self, data):
        return base64.b64encode(json.dumps(data).encode('utf-8'))

    def expect(self, uri, params_expected=None, subdomain=None, b64params=()):
        if not subdomain:
            domain = 'mixpanel.com'
        else:
            domain = '{0}.mixpanel.com'.format(subdomain)

        if subdomain != 'api':
            uri = 'api/2.0/{0}'.format(uri)

        self.assertEqual(self.executor.request.uri,
                         'http://{0}/{1}'.format(domain, uri))
        if not params_expected:
            return

        params_used = self.executor.request.params.copy()

        if 'api_key' in params_used:
            params_expected['api_key'] = 'api-key'

        params_used.pop('sig', None)
        params_used.pop('expire', None)

        for name in b64params:
            decoded = base64.b64decode(params_used[name])
            params_used[name] = json.loads(port.to_u(decoded))

        self.assertEqual(params_used, params_expected)

    def test_track(self):
        ret = self.service.track('login', {'user': 'foo', 'important': True,
                                           'widgets': ['foo', 'bar']}, ip=True)
        data = self.serialize({'event': 'login',
                               'properties': {'token': 'my-token',
                                              'user': 'foo',
                                              'important': True,
                                              'widgets': ['foo', 'bar']}})
        self.expect('track/', {'data': data, 'ip': '1', 'test': '0'}, 'api')
        self.assertTrue(ret)

        ret = self.service.track('logout', test=True)
        data = {'event': 'logout', 'properties': {'token': 'my-token'}}
        self.expect('track/', {'data': data, 'ip': '0', 'test': '1'}, 'api',
                    b64params=('data', ))
        self.assertTrue(ret)

    def test_engage(self):
        ret = self.service.engage(42, {"$set": {"$first_name": "John",
                                                "$last_name": "Smith"}})
        data = {'$token': 'my-token', '$distinct_id': 42,
                "$set": {"$first_name": "John", "$last_name": "Smith"}}

        self.expect('engage/', {'data': data}, 'api', b64params=('data', ))
        self.assertTrue(ret)

    def test_track_failure(self):
        self.executor.set_response(b'0', 200, {})

        ret = self.service.track('ev')
        self.assertFalse(ret)

    def test_events(self):
        self.service.events().get(['login', 'logout'], 'general', 'day', 10)
        self.expect('events/', {'event': json.dumps(['login', 'logout']),
                                'type': 'general', 'unit': 'day',
                                'interval': 10})

        self.service.events().top('general', limit=10)
        self.expect('events/top/', {'type': 'general', 'limit': 10})

        self.service.events().names('general')
        self.expect('events/names/', {'type': 'general'})

    def test_properties(self):
        self.service.properties().get('login', 'plan', 'unique', 'day', 7,
                                      values=['standard', 'premium'])

        self.expect('events/properties/',
                    {'event': 'login', 'name': 'plan', 'type': 'unique',
                     'unit': 'day', 'interval': 7,
                     'values': json.dumps(['standard', 'premium'])})

        self.service.properties().top('login')
        self.expect('events/properties/top/', {'event': 'login'})

        self.service.properties().values('login', 'plan', bucket='10')
        self.expect('events/properties/values/',
                    {'event': 'login', 'name': 'plan', 'bucket': '10'})

    def test_funnels(self):
        self.service.funnels().get(10, '2012-01-01', length=5)
        self.expect('funnels/', {'funnel_id': 10, 'from_date': '2012-01-01',
                                  'length': 5})

        self.service.funnels().list()
        self.expect('funnels/list/', {})

    def test_segmentation(self):
        self.service.segmentation().get('login', '2011-01-01',
                                        '2012-01-01', type='unique')
        self.expect('segmentation/',
                    {'event': 'login', 'from_date': '2011-01-01',
                     'to_date': '2012-01-01', 'type': 'unique'})

        self.service.segmentation().numeric('login', '2011-01-01',
                                            '2012-01-01', on='true', buckets=3)
        self.expect('segmentation/numeric/',
                    {'event': 'login', 'from_date': '2011-01-01',
                     'to_date': '2012-01-01', 'on': 'true', 'buckets': 3})

        on = 'properties["succeeded"] - property["failed"]'
        self.service.segmentation().sum('buy', '2011-01-01', '2012-01-01', on)
        self.expect('segmentation/sum/',
                    {'event': 'buy', 'from_date': '2011-01-01',
                     'to_date': '2012-01-01', 'on': on})

        on = 'property["amount"]'
        self.service.segmentation().average('pay', '2011-01-01',
                                            '2012-01-01', on, 'day')
        self.expect('segmentation/average/',
                    {'event': 'pay', 'from_date': '2011-01-01',
                     'to_date': '2012-01-01', 'on': on, 'unit': 'day'})

        inner = 'property["amount"]'
        outer = 'property["succeeded"]'
        self.service.segmentation().multiseg('pay', 'general', '2011-01-01',
                                            '2012-01-01', inner, outer, 25, 'day')
        self.expect('segmentation/multiseg/',
                    {'event': 'pay', 'type': 'general', 'from_date': '2011-01-01',
                     'to_date': '2012-01-01', 'inner': inner, 'outer': outer, 'limit': 25, 'unit': 'day'})

    def test_retention(self):
        self.service.retention().get('2011-01-01', '2012-01-01',
                                     born_event='login', limit=10)
        self.expect('retention/',
                    {'from_date': '2011-01-01', 'to_date': '2012-01-01',
                     'born_event': 'login', 'limit': 10})

    def test_export(self):
        self.executor.set_response(b'{"foo": "bar"}\n{"baz": "quuz"}', 200, {})
        res = self.service.export('2011-01-01', '2012-01-01',
                                  ['login', 'logout'])
        self.expect('export/',
                    {'from_date': '2011-01-01', 'to_date': '2012-01-01',
                     'event': json.dumps(['login', 'logout'])}, 'data')

        self.assertEqual(res, [{'foo': 'bar'}, {'baz': 'quuz'}])

    def test_no_key(self):
        self.service = mixpanel.Mixpanel('my-token')

        # tracking is allowed without setting the api key and api secret
        self.service.track('login')
        data = {'event': 'login', 'properties': {'token': 'my-token'}}
        self.expect('track/', {'data': data, 'ip': '0', 'test': '0'}, 'api',
                    b64params=('data', ))

        # but data export methods fail
        exc = mixpanel.InsufficientSettings
        self.assertRaises(exc, self.service.funnels().list)
        self.assertRaises(exc, self.service.export,
                          '2011-01-01', '2012-01-01', ['login', 'logout'])

    def test_unicode(self):
        # return the lambda Unicode character
        self.executor.set_response(b'{"lambda": "\xce\xbb"}', 200, {})
        # and send a capital lambda in the request
        self.service.export('2011-01-01', '2012-01-01', [b'\xce\x9b'])

        self.expect('export/',
                    {'from_date': '2011-01-01', 'to_date': '2012-01-01',
                     'event': r'["\u039b"]'}, 'data')

        # try a unicode event name
        self.executor.set_response(b'1', 200, {})
        self.service.track(b'\xce\xbb'.decode('utf-8'))
        data = {'event': b'\xce\xbb'.decode('utf-8'), 'properties': {'token': 'my-token'}}
        self.expect('track/', {'data': data, 'ip': '0', 'test': '0'}, 'api',
                    b64params=('data', ))

########NEW FILE########
__FILENAME__ = test_mixrank
import unittest

from libsaas import http
from libsaas.executors import test_executor
from libsaas.services import mixrank


class MixRankTestCase(unittest.TestCase):

    def setUp(self):
        self.executor = test_executor.use()
        self.executor.set_response(b'{}', 200, {})
        self.service = mixrank.MixRank('api-key')

    def expect(self, method=None, uri=None, params=None, headers=None):
        if method:
            self.assertEqual(method, self.executor.request.method)
        if uri:
            self.assertEqual(self.executor.request.uri,
                              'http://api.mixrank.com/v2/json/api-key' + uri)
        if params:
            self.assertEqual(self.executor.request.params, params)
        if headers:
            self.assertEqual(self.executor.request.headers, headers)

    def test_echo(self):
        self.service.echo()
        self.expect('GET', '/echo')

        self.executor.set_response(b'{}', 401, {})
        self.assertRaises(http.HTTPError, self.service.echo)

    def test_advertisers(self):
        adv = self.service.advertiser('foo.net')

        adv.summary()
        self.expect('GET', '/advertisers/foo.net')

        adv.textads(min_avg_position=10, last_seen_after='2010-01-01')
        self.expect('GET', '/advertisers/foo.net/gdn/textads',
                    {'min_avg_position': 10, 'last_seen_after': '2010-01-01'})

        adv.displayads(offset=1)
        self.expect('GET', '/advertisers/foo.net/gdn/displayads', {'offset': 1})

        adv.publishers(min_monthly_uniques=45)
        self.expect('GET', '/advertisers/foo.net/gdn/publishers',
                    {'min_monthly_uniques': 45})

        adv.keywords(page_size=10)
        self.expect('GET', '/advertisers/foo.net/gdn/keywords', {'page_size': 10})

    def test_publishers(self):
        pub = self.service.publisher('bar.com')

        pub.summary()
        self.expect('GET', '/publishers/bar.com')

        pub.advertisers(max_times_seen=3)
        self.expect('GET', '/publishers/bar.com/gdn/advertisers',
                    {'max_times_seen': 3})

        pub.textads(min_avg_position=2)
        self.expect('GET', '/publishers/bar.com/gdn/textads',
                    {'min_avg_position': 2})

        pub.displayads(sort_field='last_seen')
        self.expect('GET', '/publishers/bar.com/gdn/displayads',
                    {'sort_field': 'last_seen'})

    def test_keywords(self):
        kw = self.service.keyword('happy donuts')

        kw.summary()
        self.expect('GET', '/keywords/happy%20donuts')

        kw.advertisers(max_times_seen=10)
        self.expect('GET', '/keywords/happy%20donuts/gdn/advertisers',
                    {'max_times_seen': 10})

        kw.textads(offset=10)
        self.expect('GET', '/keywords/happy%20donuts/gdn/textads',
                    {'offset': 10})

        kw.displayads(max_times_seen=4)
        self.expect('GET', '/keywords/happy%20donuts/gdn/displayads',
                    {'max_times_seen': 4})

    def test_textads(self):
        ad = self.service.advertiser('foo.net').textad('19cd891ba98d8f9')

        ad.publishers(last_seen_before='2000-02-03')
        self.expect('GET', '/advertisers/foo.net/gdn/textads/'
                    '19cd891ba98d8f9/publishers',
                    {'last_seen_before': '2000-02-03'})

        ad.destinations(min_avg_position=5)
        self.expect('GET', '/advertisers/foo.net/gdn/textads/'
                    '19cd891ba98d8f9/destinations', {'min_avg_position': 5})

    def test_displayads(self):
        ad = self.service.advertiser('foo.net').displayad('19cd891ba98d8f9')

        ad.publishers(min_times_seen=100)
        self.expect('GET', '/advertisers/foo.net/gdn/displayads/'
                    '19cd891ba98d8f9/publishers',
                    {'min_times_seen': 100})

        ad.destinations()
        self.expect('GET', '/advertisers/foo.net/gdn/displayads/'
                    '19cd891ba98d8f9/destinations')

########NEW FILE########
__FILENAME__ = test_mozscape
import json
import time
import unittest

from libsaas import port
from libsaas.executors import test_executor
from libsaas.services import mozscape
from libsaas.services.mozscape import constants


class MozscapeTestCase(unittest.TestCase):

    def setUp(self):
        self.executor = test_executor.use()
        self.executor.set_response(b'{}', 200, {})

        self.service = mozscape.Mozscape('access-id', 'secret-key')
        self.service.timesource = self._timesource

    def _timesource(self):
        return time.struct_time((2000, 1, 1, 1, 1, 1, 1, 1, 1))

    def expect(self, method=None, uri=None, params=None, headers=None):
        if method:
            self.assertEqual(method, self.executor.request.method)
        if uri:
            self.assertEqual(self.executor.request.uri,
                              'https://lsapi.seomoz.com/linkscape' + uri)
        if params:
            self.assertEqual(self.executor.request.params, params)
        if headers:
            self.assertEqual(self.executor.request.headers, headers)

    def test_urlmetrics(self):
        params = {'Cols': '9', 'Signature': '/pZ83jzQ+0589L0giwQkHg5yui0=',
                     'AccessID': 'access-id', 'Expires': '946688761'}

        self.service.urlmetrics('example.org/dir',
                                constants.TITLE + constants.SUBDOMAIN)
        self.expect('GET', '/url-metrics/example.org/dir/', params)

        urls = ['example.org/dir', 'example.net/other']
        self.service.urlmetrics(urls, constants.TITLE + constants.SUBDOMAIN)
        self.assertEqual(self.executor.request.method, 'POST')

        parsed = port.urlparse(self.executor.request.uri)
        self.assertEqual(
            (parsed.scheme, parsed.netloc, parsed.path),
            ('https', 'lsapi.seomoz.com', '/linkscape/url-metrics/'))
        self.assertEqual(dict(port.parse_qsl(parsed.query)), params)
        self.assertEqual(json.loads(self.executor.request.params), urls)

    def test_metadata(self):
        self.service.metadata().last_update()
        self.expect('GET', '/metadata/last_update.json')

        self.service.metadata().next_update()
        self.expect('GET', '/metadata/next_update.json')

        self.service.metadata().index_stats()
        self.expect('GET', '/metadata/index_stats')

########NEW FILE########
__FILENAME__ = test_newrelic
import json
import unittest

from libsaas.executors import test_executor
from libsaas.services import newrelic


class InsightsTestCase(unittest.TestCase):

    def setUp(self):
        self.executor = test_executor.use()
        self.executor.set_response(b'{}', 200, {})

        self.insert_key = 'insert_key'
        self.query_key = 'query_key'
        self.service = newrelic.Insights('account_id', self.query_key,
                                        self.insert_key)

    def serialize(self, data):
        return json.dumps(data)

    def expect(self, method=None, uri=None, params=None, headers=None):
        if method:
            self.assertEqual(method, self.executor.request.method)

        if self.executor.request.method.upper() == 'POST':
            self.assertEqual(self.executor.request.headers['X-Insert-Key'],
                             self.insert_key)
        else:
            self.assertEqual(self.executor.request.headers['X-Query-Key'],
                             self.query_key)

        if uri:
            self.assertEqual(self.executor.request.uri,
                             'https://insights.newrelic.com/beta_api/' +
                             'accounts/account_id/' + uri)
        if params:
            self.assertEqual(self.executor.request.params, params)

    def test_insert(self):
        events = [{'eventType': 'test', 'amount': 10}]
        self.service.insert(events)
        self.expect('POST', 'events', self.serialize(events))

    def test_sql(self):
        query = 'select * from TestEvent'
        self.service.query(query)
        self.expect('GET', 'query', {'nrql': query})

########NEW FILE########
__FILENAME__ = test_oauth
import unittest

from libsaas import http
from libsaas.filters import auth


class FakeOAuth(auth.OAuth):

    def generate_timestamp(self):
        return '123456789'

    def generate_nonce(self):
        return '987654321'


class FakeOAuth1a(auth.OAuth1a):

    def generate_timestamp(self):
        return '123456789'

    def generate_nonce(self):
        return '987654321'


class OAuthTestCase(unittest.TestCase):

    def setUp(self):
        self.auth = FakeOAuth('key', 'secret', 'token', 'token_secret')
        self.auth1a = FakeOAuth1a('key', 'secret', 'token', 'token_secret')

    def check_signature(self, req, signature):
        self.assertEquals(
            req.headers['Authorization'],
            ('OAuth oauth_consumer_key="token",oauth_nonce="987654321",'
             'oauth_signature="%s",oauth_signature_method="HMAC-SHA1",'
             'oauth_timestamp="123456789",oauth_token="key"' % signature))

    def test_oauth(self):
        req = http.Request('GET', 'http://example.net/', {'arg': 'val'})
        self.auth(req)
        self.check_signature(req, 'BCd8cSS%2FCujJjfYSwG9MzfJRA7o%3D')

        req = http.Request('POST', 'http://example.net/', {'arg': 'val'})
        self.auth(req)
        self.check_signature(req, '11x9m5rxVBRKjksv9Qei2QCFLMw%3D')

        req = http.Request('POST', 'http://example.net/', {'!foo': '~bar'})
        self.auth(req)
        self.check_signature(req, '6yW45xEiPMbEvVdt9bCbgFznrIc%3D')

        no_body_sig = 'WiLmVChCp3f75uueQM5viSLPHIo%3D'
        req = http.Request('POST', 'http://example.net/', 'foo')
        self.auth(req)
        self.check_signature(req, no_body_sig)

        req = http.Request('POST', 'http://example.net/', 'bar')
        self.auth(req)
        self.check_signature(req, no_body_sig)

    def test_base_string(self):
        # this test comes directly from RFC5849
        url = 'http://example.com/request?b5=%3D%253D&a3=a&c%40=&a2=r%20b'
        params = {'c2': '', 'a3': '2 q'}
        req = http.Request('POST', url, params)

        auth = FakeOAuth('kkk9d7dh3k39sjv7', 'foo', '9djdj82h48djs9d2', 'bar')
        base = auth.get_base_string(req, '7d8f3e4a', '137131201')

        expected = ('POST&http%3A%2F%2Fexample.com%2Frequest&a2%3Dr%2520b%26a3'
                    '%3D2%2520q%26a3%3Da%26b5%3D%253D%25253D%26c%2540%3D%26c2'
                    '%3D%26oauth_consumer_key%3D9djdj82h48djs9d2%26oauth_nonce'
                    '%3D7d8f3e4a%26oauth_signature_method%3DHMAC-SHA1%26oauth_'
                    'timestamp%3D137131201%26oauth_token%3Dkkk9d7dh3k39sjv7')
        self.assertEquals(base, expected)

    def test_unicode(self):
        # try both a unicode and a bytes parameter
        _lambda = b'\xce\xbb'
        _ulambda = _lambda.decode('utf-8')

        params = {'p1': _lambda, 'p2': _ulambda,
                  _lambda: 'p3', _ulambda: 'p4'}
        altparams = {'p1': _ulambda, 'p2': _lambda,
                     _ulambda: 'p3', _lambda: 'p4'}
        tparams = (('p1', _lambda), ('p1', _ulambda),
                   (_lambda, 'p3'), (_ulambda, 'p4'))

        req = http.Request('GET', 'http://example.net/', params)
        self.auth(req)
        self.check_signature(req, 'SQvPY80rfkxjdxJVRHlbd9WxPbc%3D')

        req = http.Request('GET', 'http://example.net/', tparams)
        self.auth(req)
        self.check_signature(req, 'i15AUj5VNYENlqf1bENS7SUHyRA%3D')

        sig = '%2BAp62XpZaOLSQxK0WQ080LHrfJw%3D'
        req = http.Request('POST', 'http://example.net/', params)
        self.auth(req)
        self.check_signature(req, sig)

        req = http.Request('POST', 'http://example.net/', altparams)
        self.auth(req)
        self.check_signature(req, sig)

        req = http.Request('POST', 'http://example.net/', tparams)
        self.auth(req)
        self.check_signature(req, 'yNF3UZo7D7mLdX0gSab1UOSlJMw%3D')

        # just a string
        no_body_sig = 'fEfK0QCWQ7BRODCafiuzDehqc1A%3D'
        req = http.Request('PUT', 'http://example.net/', _lambda)
        self.auth(req)
        self.check_signature(req, no_body_sig)

        req = http.Request('PUT', 'http://example.net/', _ulambda)
        self.auth(req)
        self.check_signature(req, no_body_sig)

    def test_oauth1a(self):
        req = http.Request('POST', 'http://example.net/', {'arg': 'val'})
        self.auth1a(req)
        self.check_signature(req, '11x9m5rxVBRKjksv9Qei2QCFLMw%3D')

        put_sig = 'fEfK0QCWQ7BRODCafiuzDehqc1A%3D'
        req = http.Request('PUT', 'http://example.net/', {'arg': 'val'})
        self.auth1a(req)
        self.check_signature(req, put_sig)

        req = http.Request('PUT', 'http://example.net/', {'foo': 'bar'})
        self.auth1a(req)
        self.check_signature(req, put_sig)

########NEW FILE########
__FILENAME__ = test_parsers
import unittest

from libsaas import xml


class XMLParserTestCase(unittest.TestCase):

    xml_header = b'<?xml version="1.0" encoding="UTF-8"?>'
    xml_duck = b'''<duck>
                    <article href="http://en.wikipedia.org/wiki/Donald_Duck"/>
                    <name>Donald</name>
                    <birth_date type="datetime">1934-06-04</birth_date>
                    <first_film/>
                    <last_film></last_film>
                    <species href="http://en.wikipedia.org/wiki/Pekin_duck">
                        Pekin duck
                    </species>
                    <created_by href="http://en.wikipedia.org/wiki/Disney">
                        <name>Walt Disney</name>
                        <cryopreserved type="boolean">true</cryopreserved>
                    </created_by>
                    <family>
                        <children type="array"></children>
                        <uncles type="array">
                            <uncle><name>Scrooge McDuck</name></uncle>
                            <uncle><name>Ludwig Von Drake</name></uncle>
                        </uncles>
                        <nephew><name>Huey</name></nephew>
                        <nephew><name>Dewey</name></nephew>
                        <nephew><name>Louie</name></nephew>
                    </family>
                </duck>'''

    def check_duck(self, duck):
        """
        Checks the given dict representing the above xml duck is ok
        """
        self.assertEqual(duck['name'], 'Donald')
        self.assertEqual(duck['first_film'], None)
        self.assertTrue('@href' in duck['article'])
        self.assertTrue('@href' in duck['species'])
        self.assertTrue(duck['species']['species'], 'Pekin duck')
        self.assertEqual(duck['created_by']['name'], 'Walt Disney')
        self.assertTrue(duck['created_by']['cryopreserved'])

        family = duck['family']
        self.assertEqual(len(family['uncles']['uncle']), 2)
        self.assertEqual(len(family['nephew']), 3)
        self.assertFalse(family['children'])

    def test_encoding(self):
        u_test = (b'<?xml version="1.0" encoding="latin1"?>'
                  b'<team><boolean>True</boolean>'
                  b'<name>Bar\xe7a</name>'
                  b'<nil />'
                  b'<number>1234</number></team>')
        resp = xml.parse_xml(u_test, 200, None)
        self.assertEqual(resp['team']['name'], b'Bar\xe7a'.decode('latin1'))

        u_test_part1 = (b'<?xml version="1.0" encoding="UTF-8"?>'
                        b'<team><boolean>True</boolean>'
                        b'<name>Bar\xc3\xa7a</name>')
        u_test_part2 = b'<number>1234</number></team>'

        # some versions of libxml2 produce <nil /> for empty tags, others
        # produce <nil></nil> - we don't care when serializing and we'll just
        # check for both
        u_test = u_test_part1 + b'<nil />' + u_test_part2
        u_test_alt = u_test_part1 + b'<nil></nil>' + u_test_part2

        resp = xml.parse_xml(u_test, 200, None)
        self.assertEqual(resp['team']['name'], b'Bar\xc3\xa7a'.decode('utf-8'))

        resp = xml.dict_to_xml({'team': {
            'name': b'Bar\xc3\xa7a'.decode('utf-8'),
            'boolean': True,
            'number': 1234,
            'nil': None
        }})

        # accept both <nil /> and <nil></nil>; can't use assertIn, as it only
        # got added in Python 2.7
        try:
            self.assertEqual(resp, u_test)
        except AssertionError:
            self.assertEqual(resp, u_test_alt)

    def test_syntax_error(self):
        wrong_xml = (b'<?xml version="1.0" encoding="UTF-8"?>'
                     b'<ducks type="array"><duck/><pig/></ducks>')
        self.assertRaises(xml.XMLParserException,
                          xml.parse_xml, wrong_xml, 200, None)

    def test_basic_usage(self):
        resp1 = xml.parse_xml(self.xml_header + self.xml_duck, 200, None)
        duck1 = resp1['duck']
        self.check_duck(duck1)

        # From generated xml: generate a dict; then, parse it again
        # It must be exactly the same than the very first dict
        resp2 = xml.parse_xml(xml.dict_to_xml(resp1), 200, None)
        duck2 = resp2['duck']
        self.check_duck(duck2)

        # Now, let's test an array...
        xml_doc = self.xml_header
        xml_doc += b'<ducks>'
        xml_doc += self.xml_duck
        xml_doc += self.xml_duck
        xml_doc += b'</ducks>'
        resp3 = xml.parse_xml(xml_doc, 200, None)
        ducks = resp3['ducks']['duck']
        for duck in ducks:
            self.check_duck(duck)

########NEW FILE########
__FILENAME__ = test_pingdom
import unittest

from libsaas import port
from libsaas.executors import test_executor
from libsaas.services import base, pingdom


class PingdomTestCase(unittest.TestCase):

    def setUp(self):
        self.executor = test_executor.use()
        self.executor.set_response(b'{}', 200, {})

        self.service = pingdom.Pingdom('username', 'password', 'key')

    def expect(self, method=None, uri=None, params=None, headers=None):
        if method is not None:
            self.assertEqual(method, self.executor.request.method)
        if uri is not None:
            self.assertEqual(self.executor.request.uri,
                             'https://api.pingdom.com/api/2.0' + uri)
        if params is not None:
            self.assertEqual(self.executor.request.params, params)
        if headers is not None:
            self.assertEqual(self.executor.request.headers, headers)

    def test_actions(self):
        paging = {'limit': 100, 'offset': 50}
        self.service.actions().get()
        self.expect('GET', '/actions')

        self.service.actions().get(limit=100, offset=50)
        self.expect('GET', '/actions', paging)

        with port.assertRaises(base.MethodNotSupported):
            self.service.actions().create()
            self.service.actions().update()
            self.service.actions().delete()

    def test_analysis(self):
        paging = {'limit': 100, 'offset': 50}
        self.service.analysis(4).get()
        self.expect('GET', '/analysis/4')

        self.service.analysis(4).get(limit=100, offset=50)
        self.expect('GET', '/analysis/4', paging)

        self.service.analysis(4).get_raw_analysis(10)
        self.expect('GET', '/analysis/4/10')

        self.service.check(4).analysis().get(limit=100, offset=50)
        self.expect('GET', '/analysis/4', paging)

        self.service.check(4).analysis().get_raw_analysis(10)
        self.expect('GET', '/analysis/4/10')

        with port.assertRaises(base.MethodNotSupported):
            self.service.analysis(4).create()
            self.service.analysis(4).update()
            self.service.analysis(4).delete()

    def test_contacts(self):
        obj = {'name': 'Super cool contact'}
        paging = {'limit': 100, 'offset': 50}

        self.service.contacts().get(offset=50, limit=100)
        self.expect('GET', '/contacts', paging)

        self.service.contact(4).update(obj)
        self.expect('PUT', '/contacts/4', obj)

        self.service.contact(4).delete()
        self.expect('DELETE', '/contacts/4')

        self.service.contacts().create(obj)
        self.expect('POST', '/contacts', obj)

        pause = {'paused': True, 'contactids': '1,2'}
        self.service.contacts().update(pause)
        self.expect('PUT', '/contacts', pause)

        delcontacts = {'delcontactids': '1,2'}
        self.service.contacts().update(delcontacts)
        self.expect('PUT', '/contacts', delcontacts)

        with port.assertRaises(base.MethodNotSupported):
            self.service.contact(4).get()

    def test_credits(self):
        self.service.credits().get()
        self.expect('GET', '/credits')

        with port.assertRaises(base.MethodNotSupported):
            self.service.credits().create()
            self.service.credits().update()
            self.service.credits().delete()

    def test_probes(self):
        paging = {'limit': 100, 'offset': 50}
        self.service.probes().get()
        self.expect('GET', '/probes')

        self.service.probes().get(limit=100, offset=50)
        self.expect('GET', '/probes', paging)

        with port.assertRaises(base.MethodNotSupported):
            self.service.probes().create()
            self.service.probes().update()
            self.service.probes().delete()

    def test_reference(self):
        self.service.reference().get()
        self.expect('GET', '/reference')

        with port.assertRaises(base.MethodNotSupported):
            self.service.reference().create()
            self.service.reference().update()
            self.service.reference().delete()

    def test_reports_email(self):
        obj = {'name': 'Super cool report'}

        self.service.reports_email().get()
        self.expect('GET', '/reports.email')

        self.service.report_email(4).update(obj)
        self.expect('PUT', '/reports.email/4', obj)

        self.service.report_email(4).delete()
        self.expect('DELETE', '/reports.email/4')

        self.service.reports_email().create(obj)
        self.expect('POST', '/reports.email', obj)

        with port.assertRaises(base.MethodNotSupported):
            self.service.report_email(4).get()

    def test_reports_public(self):
        obj = {'name': 'Super cool report'}

        self.service.reports_public().get()
        self.expect('GET', '/reports.public')

        self.service.report_public(4).update(obj)
        self.expect('PUT', '/reports.public/4', obj)

        self.service.report_public(4).delete()
        self.expect('DELETE', '/reports.public/4')

        self.service.reports_public().create(obj)
        self.expect('POST', '/reports.public', obj)

        with port.assertRaises(base.MethodNotSupported):
            self.service.report_public(4).get()

    def test_reports_shared(self):
        obj = {'name': 'Super cool report'}

        self.service.reports_shared().get()
        self.expect('GET', '/reports.shared')

        self.service.report_shared(4).update(obj)
        self.expect('PUT', '/reports.shared/4', obj)

        self.service.report_shared(4).delete()
        self.expect('DELETE', '/reports.shared/4')

        self.service.reports_shared().create(obj)
        self.expect('POST', '/reports.shared', obj)

        with port.assertRaises(base.MethodNotSupported):
            self.service.report_shared(4).get()

    def test_results(self):
        paging = {'limit': 100, 'offset': 50}
        self.service.results(4).get()
        self.expect('GET', '/results/4')

        self.service.results(4).get(limit=100, offset=50)
        self.expect('GET', '/results/4', paging)

        self.service.check(4).results().get(limit=100, offset=50)
        self.expect('GET', '/results/4', paging)

        with port.assertRaises(base.MethodNotSupported):
            self.service.results(4).create()
            self.service.results(4).update()
            self.service.results(4).delete()

    def test_servertime(self):
        self.service.servertime().get()
        self.expect('GET', '/servertime')

        with port.assertRaises(base.MethodNotSupported):
            self.service.servertime().create()
            self.service.servertime().update()
            self.service.servertime().delete()

    def test_settings(self):
        self.service.settings().get()
        self.expect('GET', '/settings')

        obj = {'phone': '112231234'}
        self.service.settings().update(obj)
        self.expect('PUT', '/settings', obj)

        with port.assertRaises(base.MethodNotSupported):
            self.service.settings().create()
            self.service.settings().delete()

    def test_summary(self):
        params = {'from': 1}
        self.service.summary(4).average(from_=1)
        self.expect('GET', '/summary.average/4', params)

        self.service.check(4).summary().average(from_=1)
        self.expect('GET', '/summary.average/4', params)

        self.service.summary(4).outage(from_=1)
        self.expect('GET', '/summary.outage/4', params)

        self.service.check(4).summary().outage(from_=1)
        self.expect('GET', '/summary.outage/4', params)

        self.service.summary(4).hoursofday(from_=1)
        self.expect('GET', '/summary.hoursofday/4', params)

        self.service.check(4).summary().hoursofday(from_=1)
        self.expect('GET', '/summary.hoursofday/4', params)

        self.service.summary(4).performance(from_=1)
        self.expect('GET', '/summary.performance/4', params)

        self.service.check(4).summary().performance(from_=1)
        self.expect('GET', '/summary.performance/4', params)

        self.service.summary(4).probes(from_=1)
        self.expect('GET', '/summary.probes/4', params)

        self.service.check(4).summary().probes(from_=1)
        self.expect('GET', '/summary.probes/4', params)

    def test_single(self):
        p = {'host': 'ducksboard.com', 'probeid': 17, 'type': 'http'}
        self.service.single().get(**p)
        self.expect('GET', '/single', p)

        with port.assertRaises(base.MethodNotSupported):
            self.service.single().create()
            self.service.single().update()
            self.service.single().delete()

    def test_traceroute(self):
        p = {'host': 'ducksboard.com', 'probeid': 17}
        self.service.traceroute().get(**p)
        self.expect('GET', '/traceroute', p)

        with port.assertRaises(base.MethodNotSupported):
            self.service.traceroute().create()
            self.service.traceroute().update()
            self.service.traceroute().delete()

########NEW FILE########
__FILENAME__ = test_pipedrive
import json
import unittest

from libsaas import http, port
from libsaas.executors import test_executor
from libsaas.services import pipedrive
from libsaas.services.base import MethodNotSupported


class PipedriveTestCase(unittest.TestCase):

    def setUp(self):
        self.executor = test_executor.use()
        self.executor.set_response(b'{}', 200, {})

        self.service = pipedrive.Pipedrive('my-api-token')

    def serialize(self, data):
        return json.dumps(data)

    def expect(self, method=None, uri=None, params=None):
        if method:
            self.assertEqual(method, self.executor.request.method)

        params = params or {}
        if method in http.URLENCODE_METHODS:
            params.update({'api_token': 'my-api-token'})
        else:
            uri += '?api_token=my-api-token'
            params = self.serialize(params)

        if uri:
            self.assertEqual(self.executor.request.uri,
                              'https://api.pipedrive.com/v1' + uri)

        self.assertEqual(self.executor.request.params, params)

    def test_activity_types(self):
        atype = {'name': 'test', 'color': 'FFFFFF'}

        self.service.activity_types().get()
        self.expect('GET', '/activityTypes')
        self.service.activity_types().create(atype)
        self.expect('POST', '/activityTypes', atype)
        self.service.activity_types().delete(ids='1,2,3')
        self.expect('DELETE', '/activityTypes', {'ids': '1,2,3'})

        self.service.activity_type('1').get()
        self.expect('GET', '/activityTypes/1')
        self.service.activity_type('1').update(atype)
        self.expect('PUT', '/activityTypes/1', atype)
        self.service.activity_type('1').delete()
        self.expect('DELETE', '/activityTypes/1')

    def test_activities(self):
        a = {'subject': 'test'}

        self.service.activities().get(user_id=1, start=10, limit=50)
        self.expect('GET', '/activities', {'user_id': 1, 'start': 10,
                                              'limit': 50})
        self.service.activities().create(a)
        self.expect('POST', '/activities', a)
        self.service.activities().delete(ids='1,2,3')
        self.expect('DELETE', '/activities', {'ids': '1,2,3'})

        self.service.activity('1').get()
        self.expect('GET', '/activities/1')
        self.service.activity('1').update(a)
        self.expect('PUT', '/activities/1', a)
        self.service.activity('1').delete()
        self.expect('DELETE', '/activities/1')

    def test_authorizations(self):
        self.service.authorizations().get('u@d.com', 'boo')
        self.expect('POST', '/authorizations',
                    {'email': 'u@d.com', 'password': 'boo'})

    def test_user_connections(self):
        self.service.user_connections().get()
        self.expect('GET', '/userConnections')

    def test_users(self):
        with port.assertRaises(MethodNotSupported):
            self.service.user(4).delete()
            self.service.user(4).update()

        paging = {'start': 100, 'limit': 50}
        u = {'name': 'Mr. Brown', 'email': 'b@d.com'}

        self.service.users().get()
        self.expect('GET', '/users')
        self.service.users().create(u)
        self.expect('POST', '/users', u)
        self.service.users().find('brown')
        self.expect('GET', '/users/find', {'term': 'brown'})

        self.service.user(1).get()
        self.expect('GET', '/users/1')
        self.service.user(1).followers()
        self.expect('GET', '/users/1/followers')
        self.service.user(1).activities(start=100, limit=50)
        self.expect('GET', '/users/1/activities', paging)
        self.service.user(1).updates(start=100, limit=50)
        self.expect('GET', '/users/1/updates', paging)
        self.service.user(1).merge(4)
        self.expect('POST', '/users/1/merge', {'merge_with_id': 4})

    def test_currencies(self):
        self.service.currencies().get('US')
        self.expect('GET', '/currencies', {'term': 'US'})

    def test_deal_fields(self):
        with port.assertRaises(MethodNotSupported):
            self.service.deal_field(4).update()

        field = {'name': 'test'}

        self.service.deal_fields().get()
        self.expect('GET', '/dealFields')
        self.service.deal_fields().create(field)
        self.expect('POST', '/dealFields', field)
        self.service.deal_fields().delete(ids='1,2,3')
        self.expect('DELETE', '/dealFields', {'ids': '1,2,3'})

        self.service.deal_field(1).get()
        self.expect('GET', '/dealFields/1')
        self.service.deal_field(1).delete()
        self.expect('DELETE', '/dealFields/1')

    def test_deals(self):
        paging = {'start': 100, 'limit': 50}
        d = {'title': 'My cool Brown'}

        self.service.deals().get(start=100, limit=50)
        self.expect('GET', '/deals', paging)
        self.service.deals().create(d)
        self.expect('POST', '/deals', d)
        self.service.deals().find('brown')
        self.expect('GET', '/deals/find', {'term': 'brown'})
        self.service.deals().delete(ids='1,2,3')
        self.expect('DELETE', '/deals', {'ids': '1,2,3'})
        self.service.deals().timeline('2013-01-01', 'day', 30, 'key')
        self.expect('GET', '/deals/timeline',
                    {'start_date': '2013-01-01', 'interval': 'day',
                     'amount': 30, 'field_key': 'key'})

        self.service.deal(1).get()
        self.expect('GET', '/deals/1')
        self.service.deal(1).followers()
        self.expect('GET', '/deals/1/followers')
        self.service.deal(1).participants(start=100, limit=50)
        self.expect('GET', '/deals/1/participants', paging)
        self.service.deal(1).updates(start=100, limit=50)
        self.expect('GET', '/deals/1/updates', paging)
        self.service.deal(1).files(start=100, limit=50)
        self.expect('GET', '/deals/1/files', paging)
        self.service.deal(1).products().get(start=100, limit=50)
        self.expect('GET', '/deals/1/products', paging)
        self.service.deal(1).products().delete(2)
        self.expect('DELETE', '/deals/1/products',
                    {'product_attachment_id': 2})
        p = {'product_id': 1, 'item_price': 100, 'amount': 2}
        self.service.deal(1).products().create(p)
        self.expect('POST', '/deals/1/products', p)

    def test_files(self):
        with port.assertRaises(MethodNotSupported):
            self.service.files().create()

        file = {'name': 'test'}
        paging = {'start': 100, 'limit': 50}

        self.service.files().get(start=100, limit=50)
        self.expect('GET', '/files', paging)
        self.service.file(1).get()
        self.expect('GET', '/files/1')
        self.service.file(1).delete()
        self.expect('DELETE', '/files/1')
        self.service.file(1).update(file)
        self.expect('PUT', '/files/1', file)

    def test_filter(self):
        with port.assertRaises(MethodNotSupported):
            self.service.condition_filters().create()

        self.service.condition_filters().get(type='deals')
        self.expect('GET', '/filters', {'type': 'deals'})
        self.service.condition_filters().delete('1,2,3')
        self.expect('DELETE', '/filters', {'ids': '1,2,3'})

        self.service.condition_filter(1).get()
        self.expect('GET', '/filters/1')
        self.service.condition_filter(1).delete()
        self.expect('DELETE', '/filters/1')

    def test_notes(self):
        note = {'content': '<h1>test</h1>'}
        paging = {'start': 100, 'limit': 50}

        self.service.notes().get(start=100, limit=50)
        self.expect('GET', '/notes', paging)
        self.service.notes().create(note)
        self.expect('POST', '/notes', note)

        self.service.note(1).get()
        self.expect('GET', '/notes/1')
        self.service.note(1).delete()
        self.expect('DELETE', '/notes/1')
        self.service.note(1).update(note)
        self.expect('PUT', '/notes/1', note)

    def test_organization_fields(self):
        with port.assertRaises(MethodNotSupported):
            self.service.organization_field(4).update()

        field = {'name': 'test'}

        self.service.organization_fields().get()
        self.expect('GET', '/organizationFields')
        self.service.organization_fields().create(field)
        self.expect('POST', '/organizationFields', field)
        self.service.organization_fields().delete(ids='1,2,3')
        self.expect('DELETE', '/organizationFields', {'ids': '1,2,3'})

        self.service.organization_field(1).get()
        self.expect('GET', '/organizationFields/1')
        self.service.organization_field(1).delete()
        self.expect('DELETE', '/organizationFields/1')

    def test_organizations(self):
        paging = {'start': 100, 'limit': 50}
        o = {'title': 'My cool Brown'}

        self.service.organizations().get(start=100, limit=50)
        self.expect('GET', '/organizations', paging)
        self.service.organizations().create(o)
        self.expect('POST', '/organizations', o)
        self.service.organizations().find('brown')
        self.expect('GET', '/organizations/find', {'term': 'brown'})
        self.service.organizations().delete(ids='1,2,3')
        self.expect('DELETE', '/organizations', {'ids': '1,2,3'})

        self.service.organization(1).get()
        self.expect('GET', '/organizations/1')
        self.service.organization(1).merge(4)
        self.expect('POST', '/organizations/1/merge', {'merge_with_id': 4})
        self.service.organization(1).update(o)
        self.expect('PUT', '/organizations/1', o)
        self.service.organization(1).followers()
        self.expect('GET', '/organizations/1/followers')
        self.service.organization(1).activities(start=100, limit=50)
        self.expect('GET', '/organizations/1/activities', paging)
        self.service.organization(1).updates(start=100, limit=50)
        self.expect('GET', '/organizations/1/updates', paging)
        self.service.organization(1).files(start=100, limit=50)
        self.expect('GET', '/organizations/1/files', paging)
        self.service.organization(1).persons(start=100, limit=50)
        self.expect('GET', '/organizations/1/persons', paging)
        self.service.organization(1).deals(start=100, limit=50)
        self.expect('GET', '/organizations/1/deals', paging)

    def test_person_fields(self):
        with port.assertRaises(MethodNotSupported):
            self.service.person_field(4).update()

        field = {'name': 'test'}

        self.service.person_fields().get()
        self.expect('GET', '/personFields')
        self.service.person_fields().create(field)
        self.expect('POST', '/personFields', field)
        self.service.person_fields().delete(ids='1,2,3')
        self.expect('DELETE', '/personFields', {'ids': '1,2,3'})

        self.service.person_field(1).get()
        self.expect('GET', '/personFields/1')
        self.service.person_field(1).delete()
        self.expect('DELETE', '/personFields/1')

    def test_persons(self):
        paging = {'start': 100, 'limit': 50}
        p = {'name': 'Mr Brown'}

        self.service.persons().get(start=100, limit=50)
        self.expect('GET', '/persons', paging)
        self.service.persons().create(p)
        self.expect('POST', '/persons', p)
        self.service.persons().find('brown')
        self.expect('GET', '/persons/find', {'term': 'brown'})
        self.service.persons().delete(ids='1,2,3')
        self.expect('DELETE', '/persons', {'ids': '1,2,3'})

        self.service.person(1).get()
        self.expect('GET', '/persons/1')
        self.service.person(1).merge(4)
        self.expect('POST', '/persons/1/merge', {'merge_with_id': 4})
        self.service.person(1).update(p)
        self.expect('PUT', '/persons/1', p)
        self.service.person(1).followers()
        self.expect('GET', '/persons/1/followers')
        self.service.person(1).products()
        self.expect('GET', '/persons/1/products')
        self.service.person(1).activities(start=100, limit=50)
        self.expect('GET', '/persons/1/activities', paging)
        self.service.person(1).updates(start=100, limit=50)
        self.expect('GET', '/persons/1/updates', paging)
        self.service.person(1).files(start=100, limit=50)
        self.expect('GET', '/persons/1/files', paging)
        self.service.person(1).deals(start=100, limit=50)
        self.expect('GET', '/persons/1/deals', paging)

    def test_stages(self):
        paging = {'start': 100, 'limit': 50}
        s = {'name': 'test', 'pipeline_id': 1}

        self.service.stages().get()
        self.expect('GET', '/stages')
        self.service.stages().create(s)
        self.expect('POST', '/stages', s)
        self.service.stages().delete(ids='1,2,3')
        self.expect('DELETE', '/stages', {'ids': '1,2,3'})

        self.service.stage(1).get()
        self.expect('GET', '/stages/1')
        self.service.stage(1).update(s)
        self.expect('PUT', '/stages/1', s)
        self.service.stage(1).deals(start=100, limit=50)
        self.expect('GET', '/stages/1/deals', paging)

    def test_pipelines(self):
        paging = {'start': 100, 'limit': 50}
        p = {'name': 'test'}

        self.service.pipelines().get()
        self.expect('GET', '/pipelines')
        self.service.pipelines().create(p)
        self.expect('POST', '/pipelines', p)

        self.service.pipeline(1).get()
        self.expect('GET', '/pipelines/1')
        self.service.pipeline(1).update(p)
        self.expect('PUT', '/pipelines/1', p)
        self.service.pipeline(1).deals(start=100, limit=50)
        self.expect('GET', '/pipelines/1/deals', paging)
        self.service.pipeline(1).conversion_rates('2012-01-01', '2012-02-02')
        self.expect('GET', '/pipelines/1/conversion_statistics',
                    {'start_date': '2012-01-01', 'end_date': '2012-02-02'})
        self.service.pipeline(1).movements('2012-01-01', '2012-02-02')
        self.expect('GET', '/pipelines/1/movement_statistics',
                    {'start_date': '2012-01-01', 'end_date': '2012-02-02'})

    def test_product_fields(self):
        with port.assertRaises(MethodNotSupported):
            self.service.product_field(4).update()

        field = {'name': 'test'}

        self.service.product_fields().get()
        self.expect('GET', '/productFields')
        self.service.product_fields().create(field)
        self.expect('POST', '/productFields', field)
        self.service.product_fields().delete(ids='1,2,3')
        self.expect('DELETE', '/productFields', {'ids': '1,2,3'})

        self.service.product_field(1).get()
        self.expect('GET', '/productFields/1')
        self.service.product_field(1).delete()
        self.expect('DELETE', '/productFields/1')

    def test_products(self):
        paging = {'start': 100, 'limit': 50}
        p = {'name': 'Blat'}

        self.service.products().get(start=100, limit=50)
        self.expect('GET', '/products', paging)
        self.service.products().create(p)
        self.expect('POST', '/products', p)
        self.service.products().find('brown')
        self.expect('GET', '/products/find', {'term': 'brown'})

        self.service.product(1).get()
        self.expect('GET', '/products/1')
        self.service.product(1).delete()
        self.expect('DELETE', '/products/1')
        self.service.product(1).update(p)
        self.expect('PUT', '/products/1', p)
        self.service.product(1).deals(start=100, limit=50)
        self.expect('GET', '/products/1/deals', paging)

    def test_search(self):
        self.service.search('brown')
        self.expect('GET', '/searchResults', {'term': 'brown'})

    def test_settings(self):
        self.service.settings()
        self.expect('GET', '/userSettings')

    def test_goals(self):
        g = {'goal_type': 'stage'}

        self.service.goals().get()
        self.expect('GET', '/goals')
        self.service.goals().create(g)
        self.expect('POST', '/goals', g)

        self.service.goal(1).get()
        self.expect('GET', '/goals/1')
        self.service.goal(1).delete()
        self.expect('DELETE', '/goals/1')
        self.service.goal(1).update(g)
        self.expect('PUT', '/goals/1', g)
        self.service.goal(1).results(period_start='2013-01-01',
                                     period_end='2013-02-02')
        self.expect('GET', '/goals/1/results',
                    {'period_start': '2013-01-01',
                     'period_end': '2013-02-02'})

########NEW FILE########
__FILENAME__ = test_recurly
import unittest

from datetime import date

from libsaas import http, xml
from libsaas.executors import test_executor
from libsaas.services import recurly


class RecurlyTestCase(unittest.TestCase):

    def setUp(self):
        self.executor = test_executor.use()
        self.executor.set_response(
            b'<?xml version="1.0" encoding="UTF-8"?><root/>', 200, {})
        self.service = recurly.Recurly('my-token')

    def expect(self, method=None, uri=None, params=None, headers=None):
        if method:
            self.assertEqual(method, self.executor.request.method)
        if uri:
            self.assertEqual(self.executor.request.uri,
                              'https://api.recurly.com/v2' + uri)
        if params:
            self.assertEqual(self.executor.request.params, params)
        if headers:
            for key, val in headers.items():
                self.assertEqual(self.executor.request.headers[key], val)

    def test_accounts(self):
        self.service.accounts().get(per_page=3)
        self.expect('GET', '/accounts', {'state': 'active', 'per_page': 3})

        self.service.accounts().get(state='closed')
        self.expect('GET', '/accounts', {'state': 'closed'})

        self.service.account(3).get()
        self.expect('GET', '/accounts/3')

        self.service.account(3).adjustments().get()
        self.expect('GET', '/accounts/3/adjustments')

        self.service.account(3).adjustments().get(state='pending')
        self.expect('GET', '/accounts/3/adjustments', {'state': 'pending'})

        self.service.account(3).adjustments().get(type='credit')
        self.expect('GET', '/accounts/3/adjustments', {'type': 'credit'})

        self.service.account(3).invoices().get()
        self.expect('GET', '/accounts/3/invoices')

        self.service.account(3).invoices().get(per_page=23)
        self.expect('GET', '/accounts/3/invoices', {'per_page': 23})

        self.service.account(3).subscriptions().get()
        self.expect('GET', '/accounts/3/subscriptions')

        self.service.account(3).subscriptions().get(per_page=23)
        self.expect('GET', '/accounts/3/subscriptions', {'per_page': 23})

        self.service.account(3).billing_info().get()
        self.expect('GET', '/accounts/3/billing_info')

        self.service.account(3).redemption().get()
        self.expect('GET', '/accounts/3/redemption')

        self.service.accounts().create({'account': {'account_code': 'x'}})
        self.expect('POST', '/accounts',
                    xml.dict_to_xml({'account': {'account_code': 'x'}}))

        self.service.account(23).update({'account': {'username': 'x'}})
        self.expect('PUT', '/accounts/23',
                    xml.dict_to_xml({'account': {'username': 'x'}}))

        self.service.account(23).adjustments().create({
            'adjustment': {'x': 'x'}
        })
        self.expect('POST', '/accounts/23/adjustments',
                    xml.dict_to_xml({'adjustment': {'x': 'x'}}))

        self.service.account(23).invoices().create({
            'invoice': {'line_items': [{
                'adjustment': {'x': 'a'}}, {'adjustment': {'x': 'b'}
            }]
        }})
        self.expect('POST', '/accounts/23/invoices',
            xml.dict_to_xml({
                'invoice': {'line_items': [{
                    'adjustment': {'x': 'a'}}, {'adjustment': {'x': 'b'}}
                ]}
        }))

        self.service.account(23).billing_info().update({
            'billing_info': {'x': 'x'}
        })
        self.expect('PUT', '/accounts/23/billing_info',
                    xml.dict_to_xml({'billing_info': {'x': 'x'}}))

        self.service.account(23).billing_info().delete()
        self.expect('DELETE', '/accounts/23/billing_info')

        self.service.account(23).redemption().create({
            'redemption': {'coupon_code': 'x'}
        })
        self.expect('POST', '/accounts/23/redemption',
                    xml.dict_to_xml({'redemption': {'coupon_code': 'x'}}))

        self.service.account(23).redemption().delete()
        self.expect('DELETE', '/accounts/23/redemption')

        self.service.account(23).delete()
        self.expect('DELETE', '/accounts/23')

    def test_adjustments(self):
        self.service.adjustment('uuid').get()
        self.expect('GET', '/adjustments/uuid')

        self.service.adjustment('uuid').delete()
        self.expect('DELETE', '/adjustments/uuid')

    def test_coupons(self):
        self.service.coupons().get(per_page=3)
        self.expect('GET', '/coupons', {'per_page': 3})

        self.service.coupons().get(state='expired')
        self.expect('GET', '/coupons', {'state': 'expired'})

        self.service.coupon('discount').get()
        self.expect('GET', '/coupons/discount')

        self.service.coupons().create({'coupon': {'coupon_code': 'x'}})
        self.expect('POST', '/coupons',
                    xml.dict_to_xml({'coupon': {'coupon_code': 'x'}}))

        self.service.coupon('discount').delete()
        self.expect('DELETE', '/coupons/discount')

    def test_invoices(self):
        self.service.invoices().get(per_page=3)
        self.expect('GET', '/invoices', {'per_page': 3})

        self.service.invoices().get(state='open')
        self.expect('GET', '/invoices', {'state': 'open'})

        self.service.invoice('1980').get()
        self.expect('GET', '/invoices/1980')

        self.service.invoice('1980').mark_successful()
        self.expect('PUT', '/invoices/1980/mark_successful')

        self.service.invoice('1980').mark_failed()
        self.expect('PUT', '/invoices/1980/mark_failed')

        blob = b'PDFBLOB'
        self.executor.set_response(blob, 200, {})
        ret = self.service.invoice('1980').get_pdf(language='en-GB')
        self.expect('GET', '/invoices/1980', {},
                    {'Accept': 'application/pdf', 'Accept-Language': 'en-GB'})
        self.assertEqual(ret, blob)

    def test_plans(self):
        self.service.plans().get(per_page=3)
        self.expect('GET', '/plans', {'per_page': 3})

        self.service.plan('basic').get()
        self.expect('GET', '/plans/basic')

        self.service.plans().create({'plan': {'x': 'x'}})
        self.expect('POST', '/plans', xml.dict_to_xml({'plan': {'x': 'x'}}))

        self.service.plan('basic').update({'plan': {'x': 'x'}})
        self.expect('PUT', '/plans/basic',
                    xml.dict_to_xml({'plan': {'x': 'x'}}))

        self.service.plan('basic').delete()
        self.expect('DELETE', '/plans/basic')

        self.service.plan('basic').addons().get(per_page=3)
        self.expect('GET', '/plans/basic/add_ons', {'per_page': 3})

        self.service.plan('basic').addon('item').get()
        self.expect('GET', '/plans/basic/add_ons/item')

        self.service.plan('basic').addons().create({'add_on': {'x': 'x'}})
        self.expect('POST', '/plans/basic/add_ons',
                    xml.dict_to_xml({'add_on': {'x': 'x'}}))

        self.service.plan('basic').addon('item').update({'add_on': {'x': 'x'}})
        self.expect('PUT', '/plans/basic/add_ons/item',
                    xml.dict_to_xml({'add_on': {'x': 'x'}}))

        self.service.plan('basic').addon('item').delete()
        self.expect('DELETE', '/plans/basic/add_ons/item')

    def test_subscriptions(self):
        self.service.subscriptions().get()
        self.expect('GET', '/subscriptions', {'state': 'live'})

        self.service.subscriptions().get(state='future')
        self.expect('GET', '/subscriptions', {'state': 'future'})

        self.service.subscriptions().get(per_page=23)
        self.expect('GET', '/subscriptions', {'state': 'live', 'per_page': 23})

        self.service.subscriptions().create({'subscription': {'x': 'x'}})
        self.expect('POST', '/subscriptions',
                    xml.dict_to_xml({'subscription': {'x': 'x'}}))

        self.service.subscription('uuid').get()
        self.expect('GET', '/subscriptions/uuid')

        self.service.subscription('uuid').update({'subscription': {'x': 'x'}})
        self.expect('PUT', '/subscriptions/uuid',
                    xml.dict_to_xml({'subscription': {'x': 'x'}}))

        self.service.subscription('uuid').cancel()
        self.expect('PUT', '/subscriptions/uuid/cancel')

        self.service.subscription('uuid').reactivate()
        self.expect('PUT', '/subscriptions/uuid/reactivate')

        self.service.subscription('uuid').terminate()
        self.expect('PUT', '/subscriptions/uuid/terminate?refund=none')

        self.service.subscription('uuid').terminate(refund='partial')
        self.expect('PUT', '/subscriptions/uuid/terminate?refund=partial')

        today = '{0}'.format(date.today())
        self.service.subscription('uuid').postpone(today)
        self.expect('PUT', ('/subscriptions/uuid/postpone?'
                            'next_renewal_date={0}').format(today))

    def test_transactions(self):
        self.service.transactions().get()
        self.expect('GET', '/transactions')

        self.service.transactions().get(state='failed')
        self.expect('GET', '/transactions', {'state': 'failed'})

        self.service.transactions().get(per_page=23)
        self.expect('GET', '/transactions', {'per_page': 23})

        self.service.transactions().get(type='refund', per_page=23)
        self.expect('GET', '/transactions', {'type': 'refund', 'per_page': 23})

        self.service.transactions().create({'transaction': {'x': 'x'}})
        self.expect('POST', '/transactions',
                    xml.dict_to_xml({'transaction': {'x': 'x'}}))

        self.service.transaction('uuid').get()
        self.expect('GET', '/transactions/uuid')

        self.service.transaction('uuid').refund()
        self.expect('DELETE', '/transactions/uuid')

        self.service.transaction('uuid').refund(amount_in_cents=1000)
        self.expect('DELETE', '/transactions/uuid?amount_in_cents=1000')

    def test_count(self):
        self.executor.set_response(
            b'<?xml version="1.0" encoding="UTF-8"?><root/>', 200,
            {'x-records': '10'})
        res = self.service.accounts().count(state='active')
        self.expect('GET', '/accounts', {'state': 'active', 'per_page': 1})
        self.assertEqual(res, 10)

        # no X-Records header, the count should come default to 1
        self.executor.set_response(
            b'<?xml version="1.0" encoding="UTF-8"?><root/>', 200, {})
        res = self.service.accounts().count(state='active')
        self.assertEqual(res, 1)

        # no 2xx response, there should be an exception
        self.executor.set_response(b'boom', 500, {})
        self.assertRaises(http.HTTPError,
                          self.service.accounts().count)

########NEW FILE########
__FILENAME__ = test_segmentio
import json
import unittest

from libsaas.services import segmentio
from libsaas.executors import test_executor


class SegmentIOTestCase(unittest.TestCase):

    def setUp(self):
        self.executor = test_executor.use()
        self.executor.set_response(b'{}', 200, {})

        self.service = segmentio.SegmentIO('my-api-secret')

    def expect(self, uri, params):
        self.assertEqual('POST', self.executor.request.method)

        self.assertEqual(self.executor.request.uri,
                         'https://api.segment.io/v1' + uri)

        params.update({'secret': 'my-api-secret'})
        self.assertEqual(json.loads(self.executor.request.params), params)

    def test_identify(self):
        self.service.user('user_id').identify()
        self.expect('/identify', {
            'userId': 'user_id',
        })

        self.service.user('user_id').identify(traits={'foo': 'bar'})
        self.expect('/identify', {
            'userId': 'user_id',
            'traits': {'foo': 'bar'}
        })

        self.service.user('user_id').identify(
            context={'providers':{'all': False}})
        self.expect('/identify', {
            'userId': 'user_id',
            'context': {'providers': {'all': False}}
        })

    def test_track(self):
        self.service.user('user_id').track('new event')
        self.expect('/track', {
            'userId': 'user_id',
            'event': 'new event',
        })

        self.service.user('user_id').track('new event', properties={'foo': 'bar'})
        self.expect('/track', {
            'userId': 'user_id',
            'properties': {'foo': 'bar'},
            'event': 'new event',
        })

        self.service.user('user_id').track(
            'new event', context={'providers':{'all': False}})
        self.expect('/track', {
            'userId': 'user_id',
            'event': 'new event',
            'context': {'providers': {'all': False}}
        })

    def test_alias(self):
        self.service.alias('from_user_id', 'to_user_id')
        self.expect('/alias', {
            'from': 'from_user_id',
            'to': 'to_user_id',
        })

########NEW FILE########
__FILENAME__ = test_spotify
import json
import unittest

from libsaas.executors import test_executor
from libsaas.services import spotify


class SpotifyTestCase(unittest.TestCase):

    def setUp(self):
        self.executor = test_executor.use()
        self.executor.set_response(b'{}', 200, {})

        self.service = spotify.Spotify()

    def serialize(self, data):
        return json.dumps(data)

    def expect(self, uri, params=None):
        self.assertEqual(self.executor.request.uri,
                         '{0}/{1}'.format(self.service.get_url(),
                                                  uri))
        if params:
            self.assertEqual(self.executor.request.params, params)

    def test_search(self):
        self.service.search().artist('test')
        self.expect('search/1/artist', {'q': 'test'})

        self.service.search().album('test')
        self.expect('search/1/album', {'q': 'test'})

        self.service.search().track('test')
        self.expect('search/1/track', {'q': 'test'})

        self.service.search().artist('test', 2)
        self.expect('search/1/artist', {'q': 'test', 'page': 2})

        self.service.search().album('test', 2)
        self.expect('search/1/album', {'q': 'test', 'page': 2})

        self.service.search().track('test', 2)
        self.expect('search/1/track', {'q': 'test', 'page': 2})

    def test_lookup(self):
        self.service.lookup().artist('test')
        self.expect('lookup/1/', {'uri': 'test'})

        self.service.lookup().album('test')
        self.expect('lookup/1/', {'uri': 'test'})

        self.service.lookup().track('test')
        self.expect('lookup/1/', {'uri': 'test'})

        self.service.lookup().artist('test', 2)
        self.expect('lookup/1/', {'uri': 'test',
                                       'extras': 'albumdetail'})

        self.service.lookup().album('test', 2)
        self.expect('lookup/1/', {'uri': 'test',
                                       'extras': 'trackdetail'})

        self.service.lookup().artist('test', 1)
        self.expect('lookup/1/', {'uri': 'test',
                                       'extras': 'album'})

        self.service.lookup().album('test', 1)
        self.expect('lookup/1/', {'uri': 'test',
                                       'extras': 'track'})

########NEW FILE########
__FILENAME__ = test_stripe
import unittest

from libsaas import port
from libsaas.services import stripe
from libsaas.executors import test_executor
from libsaas.services.base import MethodNotSupported


class StripeTestCase(unittest.TestCase):

    def setUp(self):
        self.executor = test_executor.use()
        self.executor.set_response(b'{}', 200, {})

        self.service = stripe.Stripe('my-api-key')

    def expect(self, method=None, uri=None, params={}, headers=None):
        if method:
            self.assertEqual(method, self.executor.request.method)

        if uri:
            self.assertEqual(self.executor.request.uri,
                              'https://api.stripe.com/v1' + uri)
        if params:
            self.assertEqual(self.executor.request.params, params)

        if headers:
            self.assertEqual(self.executor.request.headers, headers)

    def test_account(self):
        with port.assertRaises(MethodNotSupported):
            self.service.account().create()
            self.service.account().update()
            self.service.account().delete()

        self.service.account().get()
        self.expect('GET', '/account', {})

    def test_plans(self):
        with port.assertRaises(MethodNotSupported):
            self.service.plans().update()
            self.service.plans().delete()

        self.service.plans().get()
        self.expect('GET', '/plans', {})
        self.service.plans().get(count=23)
        self.expect('GET', '/plans', {'count': 23})

        self.service.plans().create({'key':'value'})
        self.expect('POST', '/plans', {'key': 'value'})

        with port.assertRaises(MethodNotSupported):
            self.service.plan('123').create()

        self.service.plan('123').get()
        self.expect('GET', '/plans/123', {})

        self.service.plan('123').update({'key':'value'})
        self.expect('POST', '/plans/123', {'key': 'value'})

        self.service.plan('123').delete()
        self.expect('DELETE', '/plans/123', {})

    def test_charges(self):
        with port.assertRaises(MethodNotSupported):
            self.service.charges().update()
            self.service.charges().delete()

        self.service.charges().get()
        self.expect('GET', '/charges', {})
        self.service.charges().get(customer='123', count=23)
        self.expect('GET', '/charges', {'count': 23, 'customer': '123'})

        self.service.charges().create({'key':'value'})
        self.expect('POST', '/charges', {'key': 'value'})

        with port.assertRaises(MethodNotSupported):
            self.service.charge('123').create()
            self.service.charge('123').update()
            self.service.charge('123').delete()

        self.service.charge('123').get()
        self.expect('GET', '/charges/123', {})

        self.service.charge('123').dispute({})
        self.expect('POST', '/charges/123/dispute', {})

        self.service.charge('123').refund()
        self.expect('POST', '/charges/123/refund', {})
        self.service.charge('123').refund(amount=23)
        self.expect('POST', '/charges/123/refund', {'amount': 23})

    def test_customers(self):
        with port.assertRaises(MethodNotSupported):
            self.service.customers().update()
            self.service.customers().delete()

        self.service.customers().get()
        self.expect('GET', '/customers', {})
        self.service.customers().get(count=23, offset=1)
        self.expect('GET', '/customers', {'count': 23, 'offset': 1})

        self.service.customers().create({'key':'value'})
        self.expect('POST', '/customers', {'key': 'value'})

        with port.assertRaises(MethodNotSupported):
            self.service.customer('123').create()
            self.service.customer('123').subscription().create()
            self.service.customer('123').discount().get()
            self.service.customer('123').discount().create()
            self.service.customer('123').discount().update()

        self.service.customer('123').get()
        self.expect('GET', '/customers/123', {})

        self.service.customer('123').update({'key':'value'})
        self.expect('POST', '/customers/123', {'key': 'value'})

        self.service.customer('123').delete()
        self.expect('DELETE', '/customers/123', {})

        self.service.customer('123').subscription().get()
        self.expect('GET', '/customers/123/subscription', {})

        self.service.customer('123').subscription().update({'key': 'value'})
        self.expect('POST', '/customers/123/subscription', {'key': 'value'})

        self.service.customer('123').subscription().delete()
        self.expect('DELETE', '/customers/123/subscription', {})

        self.service.customer('123').discount().delete()
        self.expect('DELETE', '/customers/123/discount', {})

    def test_tokens(self):
        with port.assertRaises(MethodNotSupported):
            self.service.tokens().get()
            self.service.tokens().update()
            self.service.tokens().delete()

        self.service.tokens().create({'key':'value'})
        self.expect('POST', '/tokens', {'key': 'value'})

        with port.assertRaises(MethodNotSupported):
            self.service.token('123').create()
            self.service.token('123').update()
            self.service.token('123').delete()

        self.service.token('123').get()
        self.expect('GET', '/tokens/123', {})

    def test_invoices(self):
        with port.assertRaises(MethodNotSupported):
            self.service.invoices().update()
            self.service.invoices().delete()

        self.service.invoices().get()
        self.expect('GET', '/invoices', {})
        self.service.invoices().get(customer=23)
        self.expect('GET', '/invoices', {'customer': 23})

        self.service.invoices().upcoming('123')
        self.expect('GET', '/invoices/upcoming', {'customer': '123'})

        self.service.invoices().create({'key':'value'})
        self.expect('POST', '/invoices', {'key': 'value'})

        with port.assertRaises(MethodNotSupported):
            self.service.invoice('123').create()
            self.service.invoice('123').delete()

        self.service.invoice('123').get()
        self.expect('GET', '/invoices/123', {})

        self.service.invoice('123').update({'key':'value'})
        self.expect('POST', '/invoices/123', {'key': 'value'})

        self.service.invoice('123').pay()
        self.expect('POST', '/invoices/123/pay', {})

        with port.assertRaises(MethodNotSupported):
            self.service.invoice('123').lines().create()
            self.service.invoice('123').lines().update()
            self.service.invoice('123').lines().delete()

        self.service.invoice('123').lines().get()
        self.expect('GET', '/invoices/123/lines', {})
        self.service.invoice('123').lines().get(offset=1)
        self.expect('GET', '/invoices/123/lines', {'offset': 1})

    def test_events(self):
        with port.assertRaises(MethodNotSupported):
            self.service.events().create()
            self.service.events().update()
            self.service.events().delete()

        self.service.events().get()
        self.expect('GET', '/events', {})
        self.service.events().get(type='type')
        self.expect('GET', '/events', {'type': 'type'})

        with port.assertRaises(MethodNotSupported):
            self.service.event('123').create()
            self.service.event('123').update()
            self.service.event('123').delete()

        self.service.event('123').get()
        self.expect('GET', '/events/123', {})

    def test_coupons(self):
        with port.assertRaises(MethodNotSupported):
            self.service.coupons().update()
            self.service.coupons().delete()

        self.service.coupons().get()
        self.expect('GET', '/coupons', {})
        self.service.coupons().get(count=23)
        self.expect('GET', '/coupons', {'count': 23})

        self.service.coupons().create({'key':'value'})
        self.expect('POST', '/coupons', {'key': 'value'})

        with port.assertRaises(MethodNotSupported):
            self.service.coupon('123').create()
            self.service.coupon('123').update()

        self.service.coupon('123').get()
        self.expect('GET', '/coupons/123', {})

        self.service.coupon('123').delete()
        self.expect('DELETE', '/coupons/123', {})

    def test_invoiceitems(self):
        with port.assertRaises(MethodNotSupported):
            self.service.invoiceitems().update()
            self.service.invoiceitems().delete()

        self.service.invoiceitems().get()
        self.expect('GET', '/invoiceitems', {})
        self.service.invoiceitems().get(count=23)
        self.expect('GET', '/invoiceitems', {'count': 23})

        self.service.invoiceitems().create({'key':'value'})
        self.expect('POST', '/invoiceitems', {'key': 'value'})

        with port.assertRaises(MethodNotSupported):
            self.service.invoiceitem('123').create()
            self.service.invoiceitem('123').update()

        self.service.invoiceitem('123').get()
        self.expect('GET', '/invoiceitems/123', {})

        self.service.invoiceitem('123').delete()
        self.expect('DELETE', '/invoiceitems/123', {})


########NEW FILE########
__FILENAME__ = test_trello
import json
import unittest

from libsaas.executors import test_executor
from libsaas.services import trello


class TrelloTestCase(unittest.TestCase):

    def setUp(self):
        self.executor = test_executor.use()
        self.executor.set_response(b'{}', 200, {})

        self.service = trello.Trello('my-key','my-token')

    def expect(self, method=None, uri=None, params={}):
        if method:
            self.assertEqual(method, self.executor.request.method)

        if method != 'GET':
            uri += '?token=my-token&key=my-key'

        self.assertEqual(
            self.executor.request.uri,
            'https://api.trello.com/1' + uri)

        if method == 'GET':
            params.update({'token': 'my-token', 'key': 'my-key'})

        if params:
            self.assertEqual(self.executor.request.params, params)

    def test_actions(self):
        self.service.action('1234').get()
        self.expect('GET', '/actions/1234', {})
        self.service.action('1234').get(fields=['id'])
        self.expect('GET', '/actions/1234', {'fields': 'id'})
        self.service.action('1234').get(fields=['id', 'name'])
        self.expect('GET', '/actions/1234', {'fields': 'id,name'})
        self.service.action('1234').get(member=True)
        self.expect('GET', '/actions/1234', {'member': 'true'})
        self.service.action('1234').field('name')
        self.expect('GET', '/actions/1234/name', {})

        self.service.action('1234').board().get()
        self.expect('GET', '/actions/1234/board', {})
        self.service.action('1234').board().get(fields=['id', 'name'])
        self.expect('GET', '/actions/1234/board', {'fields': 'id,name'})
        self.service.action('1234').board().field('name')
        self.expect('GET', '/actions/1234/board/name', {})

        self.service.action('1234').card().get()
        self.expect('GET', '/actions/1234/card', {})
        self.service.action('1234').card().get(fields=['id', 'name'])
        self.expect('GET', '/actions/1234/card', {'fields': 'id,name'})
        self.service.action('1234').card().field('name')
        self.expect('GET', '/actions/1234/card/name', {})

        self.service.action('1234').list().get()
        self.expect('GET', '/actions/1234/list', {})
        self.service.action('1234').list().get(fields=['id', 'name'])
        self.expect('GET', '/actions/1234/list', {'fields': 'id,name'})
        self.service.action('1234').list().field('name')
        self.expect('GET', '/actions/1234/list/name', {})

        self.service.action('1234').member().get()
        self.expect('GET', '/actions/1234/member', {})
        self.service.action('1234').member().get(fields=['id', 'name'])
        self.expect('GET', '/actions/1234/member', {'fields': 'id,name'})
        self.service.action('1234').member().field('name')
        self.expect('GET', '/actions/1234/member/name', {})

        self.service.action('1234').creator().get()
        self.expect('GET', '/actions/1234/memberCreator', {})
        self.service.action('1234').creator().get(fields=['id', 'name'])
        self.expect('GET', '/actions/1234/memberCreator', {'fields': 'id,name'})
        self.service.action('1234').creator().field('name')
        self.expect('GET', '/actions/1234/memberCreator/name', {})

        self.service.action('1234').organization().get()
        self.expect('GET', '/actions/1234/organization', {})
        self.service.action('1234').organization().get(fields=['id', 'name'])
        self.expect('GET', '/actions/1234/organization', {'fields': 'id,name'})
        self.service.action('1234').organization().field('name')
        self.expect('GET', '/actions/1234/organization/name', {})

        obj = {'foo': 'bar'}
        self.service.action('1234').update(obj)
        self.expect('PUT', '/actions/1234', json.dumps(obj))

        self.service.action('1234').delete()
        self.expect('DELETE', '/actions/1234')

    def test_boards(self):
        self.service.board('1234').get()
        self.expect('GET', '/boards/1234', {})
        self.service.board('1234').get(fields=['id'])
        self.expect('GET', '/boards/1234', {'fields': 'id'})
        self.service.board('1234').get(fields=['id', 'name'])
        self.expect('GET', '/boards/1234', {'fields': 'id,name'})
        self.service.board('1234').get(action_member=True)
        self.expect('GET', '/boards/1234', {'action_member': 'true'})
        self.service.board('1234').field('name')
        self.expect('GET', '/boards/1234/name', {})

        self.service.board('1234').actions().get()
        self.expect('GET', '/boards/1234/actions', {})
        self.service.board('1234').actions().get(limit=10)
        self.expect('GET', '/boards/1234/actions', {'limit': 10})

        self.service.board('1234').cards().get()
        self.expect('GET', '/boards/1234/cards', {})
        self.service.board('1234').cards().get(limit=10)
        self.expect('GET', '/boards/1234/cards', {'limit': 10})
        self.service.board('1234').cards().filter('open')
        self.expect('GET', '/boards/1234/cards/open', {})

        self.service.board('1234').card('1234').get()
        self.expect('GET', '/boards/1234/cards/1234', {})
        self.service.board('1234').card('1234').get(fields=['id'])
        self.expect('GET', '/boards/1234/cards/1234', {'fields': 'id'})

        self.service.board('1234').checklists().get()
        self.expect('GET', '/boards/1234/checklists', {})
        self.service.board('1234').checklists().get(limit=10)
        self.expect('GET', '/boards/1234/checklists', {'limit': 10})

        self.service.board('1234').lists().get()
        self.expect('GET', '/boards/1234/lists', {})
        self.service.board('1234').lists().get(limit=10)
        self.expect('GET', '/boards/1234/lists', {'limit': 10})
        self.service.board('1234').lists().filter('open')
        self.expect('GET', '/boards/1234/lists/open', {})

        self.service.board('1234').members().get()
        self.expect('GET', '/boards/1234/members', {})
        self.service.board('1234').members().get(limit=10)
        self.expect('GET', '/boards/1234/members', {'limit': 10})
        self.service.board('1234').members().filter('normal')
        self.expect('GET', '/boards/1234/members/normal', {})

        self.service.board('1234').members_invited().get()
        self.expect('GET', '/boards/1234/membersInvited', {})
        self.service.board('1234').members_invited().get(fields=['id'])
        self.expect('GET', '/boards/1234/membersInvited', {'fields': 'id'})

        self.service.board('1234').memberships().get()
        self.expect('GET', '/boards/1234/memberships', {})
        self.service.board('1234').memberships().get(limit=10)
        self.expect('GET', '/boards/1234/memberships', {'limit': 10})

        self.service.board('1234').membership('1234').get()
        self.expect('GET', '/boards/1234/memberships/1234', {})
        self.service.board('1234').membership('1234').get(fields=['id'])
        self.expect('GET', '/boards/1234/memberships/1234', {'fields': 'id'})

        self.service.board('1234').organization().get()
        self.expect('GET', '/boards/1234/organization', {})
        self.service.board('1234').organization().get(fields=['id'])
        self.expect('GET', '/boards/1234/organization', {'fields': 'id'})
        self.service.board('1234').organization().field('id')
        self.expect('GET', '/boards/1234/organization/id', {})

        obj = {'foo': 'bar'}

        self.service.boards().create(obj)
        self.expect('POST', '/boards', json.dumps(obj))

        self.service.board('1234').calendar_key()
        self.expect('POST', '/boards/1234/calendarKey/generate')

        self.service.board('1234').mark_as_viewed()
        self.expect('POST', '/boards/1234/markAsViewed')

        self.service.board('1234').email_key()
        self.expect('POST', '/boards/1234/emailKey/generate')

        self.service.board('1234').checklists().create(obj)
        self.expect('POST', '/boards/1234/checklists', json.dumps(obj))

        self.service.board('1234').lists().create(obj)
        self.expect('POST', '/boards/1234/lists', json.dumps(obj))

        self.service.board('1234').update(obj)
        self.expect('PUT', '/boards/1234', json.dumps(obj))

        self.service.board('1234').member('1234').update(obj)
        self.expect('PUT', '/boards/1234/members/1234', json.dumps(obj))

        self.service.board('1234').membership('1234').update(obj)
        self.expect('PUT', '/boards/1234/memberships/1234', json.dumps(obj))

        self.service.board('1234').member('1234').delete()
        self.expect('DELETE', '/boards/1234/members/1234')

    def test_cards(self):
        self.service.card('1234').get()
        self.expect('GET', '/cards/1234', {})
        self.service.card('1234').get(fields=['id'])
        self.expect('GET', '/cards/1234', {'fields': 'id'})
        self.service.card('1234').get(fields=['id', 'name'])
        self.expect('GET', '/cards/1234', {'fields': 'id,name'})
        self.service.card('1234').get(attachments=True)
        self.expect('GET', '/cards/1234', {'attachments': 'true'})
        self.service.card('1234').field('name')
        self.expect('GET', '/cards/1234/name', {})

        self.service.card('1234').actions().get()
        self.expect('GET', '/cards/1234/actions', {})
        self.service.card('1234').actions().get(limit=10)
        self.expect('GET', '/cards/1234/actions', {'limit': 10})

        self.service.card('1234').attachments().get()
        self.expect('GET', '/cards/1234/attachments', {})
        self.service.card('1234').attachments().get(limit=10)
        self.expect('GET', '/cards/1234/attachments', {'limit': 10})

        self.service.card('1234').attachment('1234').get()
        self.expect('GET', '/cards/1234/attachments/1234', {})
        self.service.card('1234').attachment('1234').get(fields=['id'])
        self.expect('GET', '/cards/1234/attachments/1234', {'fields': 'id'})

        self.service.card('1234').board().get()
        self.expect('GET', '/cards/1234/board', {})
        self.service.card('1234').board().get(fields=['id', 'name'])
        self.expect('GET', '/cards/1234/board', {'fields': 'id,name'})
        self.service.card('1234').board().field('name')
        self.expect('GET', '/cards/1234/board/name', {})

        self.service.card('1234').checkitem_states().get()
        self.expect('GET', '/cards/1234/checkItemStates', {})
        self.service.card('1234').checkitem_states().get(limit=10)
        self.expect('GET', '/cards/1234/checkItemStates', {'limit': 10})

        self.service.card('1234').checklists().get()
        self.expect('GET', '/cards/1234/checklists', {})
        self.service.card('1234').checklists().get(limit=10)
        self.expect('GET', '/cards/1234/checklists', {'limit': 10})

        self.service.card('1234').list().get()
        self.expect('GET', '/cards/1234/list', {})
        self.service.card('1234').list().get(fields=['id', 'name'])
        self.expect('GET', '/cards/1234/list', {'fields': 'id,name'})
        self.service.card('1234').list().field('name')
        self.expect('GET', '/cards/1234/list/name', {})

        self.service.card('1234').members().get()
        self.expect('GET', '/cards/1234/members', {})
        self.service.card('1234').members().get(limit=10)
        self.expect('GET', '/cards/1234/members', {'limit': 10})

        self.service.card('1234').members_voted().get()
        self.expect('GET', '/cards/1234/membersVoted', {})
        self.service.card('1234').members_voted().get(fields=['id'])
        self.expect('GET', '/cards/1234/membersVoted', {'fields': 'id'})

        self.service.card('1234').stickers().get()
        self.expect('GET', '/cards/1234/stickers', {})
        self.service.card('1234').stickers().get(limit=10)
        self.expect('GET', '/cards/1234/stickers', {'limit': 10})

        self.service.card('1234').sticker('1234').get()
        self.expect('GET', '/cards/1234/stickers/1234', {})
        self.service.card('1234').sticker('1234').get(fields=['id'])
        self.expect('GET', '/cards/1234/stickers/1234', {'fields': 'id'})

        obj = {'foo': 'bar'}

        self.service.cards().create(obj)
        self.expect('POST', '/cards', json.dumps(obj))

        self.service.card('1234').actions().comments().create(obj)
        self.expect('POST', '/cards/1234/actions/comments', json.dumps(obj))

        self.service.card('1234').attachments().create(obj)
        self.expect('POST', '/cards/1234/attachments', json.dumps(obj))

        self.service.card('1234').checklists().create(obj)
        self.expect('POST', '/cards/1234/checklists', json.dumps(obj))

        self.service.card('1').checklist('2').checkitems().create(obj)
        self.expect('POST', '/cards/1/checklist/2/checkItem', json.dumps(obj))

        self.service.card('1').checklist('2').checkitem('3').convert_to_card()
        self.expect(
            'POST', '/cards/1/checklist/2/checkItem/3/convertToCard',
            json.dumps({}))

        self.service.card('1234').labels().create(obj)
        self.expect('POST', '/cards/1234/labels', json.dumps(obj))

        self.service.card('1234').members_voted().create(obj)
        self.expect('POST', '/cards/1234/membersVoted', json.dumps(obj))

        self.service.card('1234').update(obj)
        self.expect('PUT', '/cards/1234', json.dumps(obj))

        self.service.card('1234').actions().comments().update(obj)
        self.expect('PUT', '/cards/1234/actions/comments', json.dumps(obj))

        self.service.card('1').checklist('2').checkitem('3').update(obj)
        self.expect('PUT', '/cards/1/checklist/2/checkItem/3', json.dumps(obj))

        self.service.card('1').sticker('2').update(obj)
        self.expect('PUT', '/cards/1/stickers/2', json.dumps(obj))

        self.service.card('1').attachment('2').delete()
        self.expect('DELETE', '/cards/1/attachments/2')

        self.service.card('1234').actions().comments().delete()
        self.expect('DELETE', '/cards/1234/actions/comments')

        self.service.card('1').checklist('2').checkitem('3').delete()
        self.expect('DELETE', '/cards/1/checklist/2/checkItem/3')

        self.service.card('1').sticker('2').delete()
        self.expect('DELETE', '/cards/1/stickers/2')

        self.service.card('1').label('2').delete()
        self.expect('DELETE', '/cards/1/labels/2')

    def test_checklists(self):
        self.service.checklist('1234').get()
        self.expect('GET', '/checklists/1234', {})
        self.service.checklist('1234').get(fields=['id'])
        self.expect('GET', '/checklists/1234', {'fields': 'id'})
        self.service.checklist('1234').get(fields=['id', 'name'])
        self.expect('GET', '/checklists/1234', {'fields': 'id,name'})
        self.service.checklist('1234').get(member=True)
        self.expect('GET', '/checklists/1234', {'member': 'true'})
        self.service.checklist('1234').field('name')
        self.expect('GET', '/checklists/1234/name', {})

        self.service.checklist('1234').board().get()
        self.expect('GET', '/checklists/1234/board', {})
        self.service.checklist('1234').board().get(fields=['id', 'name'])
        self.expect('GET', '/checklists/1234/board', {'fields': 'id,name'})
        self.service.checklist('1234').board().field('name')
        self.expect('GET', '/checklists/1234/board/name', {})

        self.service.checklist('1234').cards().get()
        self.expect('GET', '/checklists/1234/cards', {})
        self.service.checklist('1234').cards().get(limit=10)
        self.expect('GET', '/checklists/1234/cards', {'limit': 10})
        self.service.checklist('1234').cards().filter('closed')
        self.expect('GET', '/checklists/1234/cards/closed', {})

        self.service.checklist('1234').checkitems().get()
        self.expect('GET', '/checklists/1234/checkItems', {})
        self.service.checklist('1234').checkitems().get(limit=10)
        self.expect('GET', '/checklists/1234/checkItems', {'limit': 10})

        self.service.checklist('1234').checkitem('1234').get()
        self.expect('GET', '/checklists/1234/checkItems/1234', {})
        self.service.checklist('1234').checkitem('1234').get(fields=['id'])
        self.expect('GET', '/checklists/1234/checkItems/1234', {'fields': 'id'})

        obj = {'foo': 'bar'}

        self.service.checklists().create(obj)
        self.expect('POST', '/checklists', json.dumps(obj))

        self.service.checklist('1234').checkitems().create(obj)
        self.expect('POST', '/checklists/1234/checkItems', json.dumps(obj))

        self.service.checklist('1234').update(obj)
        self.expect('PUT', '/checklists/1234', json.dumps(obj))

        self.service.checklist('1234').delete()
        self.expect('DELETE', '/checklists/1234')

    def test_lists(self):
        self.service.list('1234').get()
        self.expect('GET', '/lists/1234', {})
        self.service.list('1234').get(fields=['id'])
        self.expect('GET', '/lists/1234', {'fields': 'id'})
        self.service.list('1234').get(fields=['id', 'name'])
        self.expect('GET', '/lists/1234', {'fields': 'id,name'})
        self.service.list('1234').get(member=True)
        self.expect('GET', '/lists/1234', {'member': 'true'})
        self.service.list('1234').field('name')
        self.expect('GET', '/lists/1234/name', {})

        self.service.list('1234').actions().get()
        self.expect('GET', '/lists/1234/actions', {})
        self.service.list('1234').actions().get(limit=10)
        self.expect('GET', '/lists/1234/actions', {'limit': 10})

        self.service.list('1234').board().get()
        self.expect('GET', '/lists/1234/board', {})
        self.service.list('1234').board().get(fields=['id', 'name'])
        self.expect('GET', '/lists/1234/board', {'fields': 'id,name'})
        self.service.list('1234').board().field('name')
        self.expect('GET', '/lists/1234/board/name', {})

        self.service.list('1234').cards().get()
        self.expect('GET', '/lists/1234/cards', {})
        self.service.list('1234').cards().get(limit=10)
        self.expect('GET', '/lists/1234/cards', {'limit': 10})
        self.service.list('1234').cards().filter('closed')
        self.expect('GET', '/lists/1234/cards/closed', {})

        obj = {'foo': 'bar'}

        self.service.lists().create(obj)
        self.expect('POST', '/lists', json.dumps(obj))

        self.service.list('1234').archive_all_cards()
        self.expect('POST', '/lists/1234/archiveAllCards')

        self.service.list('1234').update(obj)
        self.expect('PUT', '/lists/1234', json.dumps(obj))


    def test_members(self):
        self.service.member('1234').get()
        self.expect('GET', '/members/1234', {})
        self.service.member('1234').get(fields=['id'])
        self.expect('GET', '/members/1234', {'fields': 'id'})
        self.service.member('1234').get(fields=['id', 'name'])
        self.expect('GET', '/members/1234', {'fields': 'id,name'})
        self.service.member('1234').get(member=True)
        self.expect('GET', '/members/1234', {'member': 'true'})
        self.service.member('1234').field('name')
        self.expect('GET', '/members/1234/name', {})

        self.service.member('1234').actions().get()
        self.expect('GET', '/members/1234/actions', {})
        self.service.member('1234').actions().get(limit=10)
        self.expect('GET', '/members/1234/actions', {'limit': 10})

        self.service.member('1234').board_backgrounds().get()
        self.expect('GET', '/members/1234/boardBackgrounds', {})
        self.service.member('1234').board_backgrounds().get(limit=10)
        self.expect('GET', '/members/1234/boardBackgrounds', {'limit': 10})

        self.service.member('1234').board_background('1234').get()
        self.expect('GET', '/members/1234/boardBackgrounds/1234', {})
        self.service.member('1').board_background('2').get(fields=['id'])
        self.expect('GET', '/members/1/boardBackgrounds/2', {'fields': 'id'})

        self.service.member('1234').board_stars().get()
        self.expect('GET', '/members/1234/boardStars', {})

        self.service.member('1234').boards().get()
        self.expect('GET', '/members/1234/boards', {})
        self.service.member('1234').boards().get(fields=['id', 'name'])
        self.expect('GET', '/members/1234/boards', {'fields': 'id,name'})
        self.service.member('1234').boards().filter('closed')
        self.expect('GET', '/members/1234/boards/closed', {})

        self.service.member('1234').cards().get()
        self.expect('GET', '/members/1234/cards', {})
        self.service.member('1234').cards().get(limit=10)
        self.expect('GET', '/members/1234/cards', {'limit': 10})
        self.service.member('1234').cards().filter('closed')
        self.expect('GET', '/members/1234/cards/closed', {})

        self.service.member('1234').custom_board_backgrounds().get()
        self.expect('GET', '/members/1234/customBoardBackgrounds', {})
        self.service.member('1').custom_board_backgrounds().get(limit=10)
        self.expect('GET', '/members/1/customBoardBackgrounds', {'limit': 10})

        self.service.member('1234').custom_board_background('1234').get()
        self.expect('GET', '/members/1234/customBoardBackgrounds/1234', {})
        self.service.member('1').custom_board_background('2').get(
            fields=['id'])
        self.expect('GET', '/members/1/customBoardBackgrounds/2',
            {'fields': 'id'})

        self.service.member('1234').custom_stickers().get()
        self.expect('GET', '/members/1234/customStickers', {})
        self.service.member('1234').custom_stickers().get(limit=10)
        self.expect('GET', '/members/1234/customStickers', {'limit': 10})

        self.service.member('1234').custom_sticker('1234').get()
        self.expect('GET', '/members/1234/customStickers/1234', {})
        self.service.member('1').custom_sticker('2').get(fields=['id'])
        self.expect('GET', '/members/1/customStickers/2', {'fields': 'id'})

        self.service.member('1234').notifications().get()
        self.expect('GET', '/members/1234/notifications', {})
        self.service.member('1234').notifications().get(limit=10)
        self.expect('GET', '/members/1234/notifications', {'limit': 10})
        self.service.member('1234').notifications().filter('closed')
        self.expect('GET', '/members/1234/notifications/closed', {})

        self.service.member('1234').organizations().get()
        self.expect('GET', '/members/1234/organizations', {})
        self.service.member('1234').organizations().get(limit=10)
        self.expect('GET', '/members/1234/organizations', {'limit': 10})
        self.service.member('1234').organizations().filter('closed')
        self.expect('GET', '/members/1234/organizations/closed', {})

        self.service.member('1234').tokens().get()
        self.expect('GET', '/members/1234/tokens', {})
        self.service.member('1234').tokens().get(limit=10)
        self.expect('GET', '/members/1234/tokens', {'limit': 10})

        self.service.member('1234').sessions().get()
        self.expect('GET', '/members/1234/sessions', {})
        self.service.member('1234').sessions().get(limit=10)
        self.expect('GET', '/members/1234/sessions', {'limit': 10})

        obj = {'foo': 'bar'}

        self.service.member('1').board_backgrounds().create(obj)
        self.expect('POST', '/members/1/boardBackgrounds', json.dumps(obj))

        self.service.member('1').custom_board_backgrounds().create(obj)
        self.expect('POST', '/members/1/customBoardBackgrounds',
            json.dumps(obj))

        self.service.member('1').board_stars().create(obj)
        self.expect('POST', '/members/1/boardStars', json.dumps(obj))

        self.service.member('1').custom_stickers().create(obj)
        self.expect('POST', '/members/1/customStickers', json.dumps(obj))

        self.service.member('1234').update(obj)
        self.expect('PUT', '/members/1234', json.dumps(obj))

        self.service.member('1').board_background('2').update(obj)
        self.expect('PUT', '/members/1/boardBackgrounds/2', json.dumps(obj))

        self.service.member('1').custom_board_background('2').update(obj)
        self.expect('PUT', '/members/1/customBoardBackgrounds/2',
            json.dumps(obj))

        self.service.member('1').board_star('2').update(obj)
        self.expect('PUT', '/members/1/boardStars/2', json.dumps(obj))

        self.service.member('1').board_background('2').delete()
        self.expect('DELETE', '/members/1/boardBackgrounds/2')

        self.service.member('1').custom_board_background('2').delete()
        self.expect('DELETE', '/members/1/customBoardBackgrounds/2')

        self.service.member('1').board_star('2').delete()
        self.expect('DELETE', '/members/1/boardStars/2')

    def test_notifications(self):
        self.service.notification('1234').get()
        self.expect('GET', '/notifications/1234', {})
        self.service.notification('1234').get(fields=['id'])
        self.expect('GET', '/notifications/1234', {'fields': 'id'})
        self.service.notification('1234').get(fields=['id', 'name'])
        self.expect('GET', '/notifications/1234', {'fields': 'id,name'})
        self.service.notification('1234').get(member=True)
        self.expect('GET', '/notifications/1234', {'member': 'true'})
        self.service.notification('1234').field('name')
        self.expect('GET', '/notifications/1234/name', {})

        self.service.notification('1234').board().get()
        self.expect('GET', '/notifications/1234/board', {})
        self.service.notification('1234').board().get(fields=['id', 'name'])
        self.expect('GET', '/notifications/1234/board', {'fields': 'id,name'})
        self.service.notification('1234').board().field('name')
        self.expect('GET', '/notifications/1234/board/name', {})

        self.service.notification('1234').card().get()
        self.expect('GET', '/notifications/1234/card', {})
        self.service.notification('1234').card().get(fields=['id', 'name'])
        self.expect('GET', '/notifications/1234/card', {'fields': 'id,name'})
        self.service.notification('1234').card().field('name')
        self.expect('GET', '/notifications/1234/card/name', {})

        self.service.notification('1234').list().get()
        self.expect('GET', '/notifications/1234/list', {})
        self.service.notification('1234').list().get(fields=['id', 'name'])
        self.expect('GET', '/notifications/1234/list', {'fields': 'id,name'})
        self.service.notification('1234').list().field('name')
        self.expect('GET', '/notifications/1234/list/name', {})

        self.service.notification('1234').member().get()
        self.expect('GET', '/notifications/1234/member', {})
        self.service.notification('1234').member().get(fields=['id', 'name'])
        self.expect('GET', '/notifications/1234/member', {'fields': 'id,name'})
        self.service.notification('1234').member().field('name')
        self.expect('GET', '/notifications/1234/member/name', {})

        self.service.notification('1234').creator().get()
        self.expect('GET', '/notifications/1234/memberCreator', {})
        self.service.notification('1').creator().get(fields=['id'])
        self.expect('GET', '/notifications/1/memberCreator', {'fields': 'id'})
        self.service.notification('1234').creator().field('name')
        self.expect('GET', '/notifications/1234/memberCreator/name', {})

        self.service.notification('1234').organization().get()
        self.expect('GET', '/notifications/1234/organization', {})
        self.service.notification('1').organization().get(fields=['id'])
        self.expect('GET', '/notifications/1/organization', {'fields': 'id'})
        self.service.notification('1234').organization().field('name')
        self.expect('GET', '/notifications/1234/organization/name', {})

        obj = {'foo': 'bar'}
        self.service.notification('1234').update(obj)
        self.expect('PUT', '/notifications/1234', json.dumps(obj))

    def test_organizations(self):
        self.service.organization('1234').get()
        self.expect('GET', '/organizations/1234', {})
        self.service.organization('1234').get(fields=['id'])
        self.expect('GET', '/organizations/1234', {'fields': 'id'})
        self.service.organization('1234').get(fields=['id', 'name'])
        self.expect('GET', '/organizations/1234', {'fields': 'id,name'})
        self.service.organization('1234').get(member=True)
        self.expect('GET', '/organizations/1234', {'member': 'true'})
        self.service.organization('1234').field('name')
        self.expect('GET', '/organizations/1234/name', {})

        self.service.organization('1234').actions().get()
        self.expect('GET', '/organizations/1234/actions', {})
        self.service.organization('1234').actions().get(limit=10)
        self.expect('GET', '/organizations/1234/actions', {'limit': 10})

        self.service.organization('1234').boards().get()
        self.expect('GET', '/organizations/1234/boards', {})
        self.service.organization('1234').boards().get(limit=10)
        self.expect('GET', '/organizations/1234/boards', {'limit': 10})
        self.service.organization('1234').boards().filter('closed')
        self.expect('GET', '/organizations/1234/boards/closed', {})

        self.service.organization('1234').members().get()
        self.expect('GET', '/organizations/1234/members', {})
        self.service.organization('1234').members().get(limit=10)
        self.expect('GET', '/organizations/1234/members', {'limit': 10})
        self.service.organization('1234').members().filter('normal')
        self.expect('GET', '/organizations/1234/members/normal', {})

        self.service.organization('1234').members_invited().get()
        self.expect('GET', '/organizations/1234/membersInvited', {})
        self.service.organization('1').members_invited().get(fields=['id'])
        self.expect('GET', '/organizations/1/membersInvited', {'fields': 'id'})

        self.service.organization('1234').memberships().get()
        self.expect('GET', '/organizations/1234/memberships', {})
        self.service.organization('1234').memberships().get(limit=10)
        self.expect('GET', '/organizations/1234/memberships', {'limit': 10})

        self.service.organization('1234').membership('1234').get()
        self.expect('GET', '/organizations/1234/memberships/1234', {})

        obj = {'foo': 'bar'}

        self.service.organizations().create(obj)
        self.expect('POST', '/organizations', json.dumps(obj))

        self.service.organization('1234').update(obj)
        self.expect('PUT', '/organizations/1234', json.dumps(obj))

        self.service.organization('1234').member('1234').update(obj)
        self.expect('PUT', '/organizations/1234/members/1234', json.dumps(obj))

        self.service.organization('1').membership('2').update(obj)
        self.expect('PUT', '/organizations/1/memberships/2', json.dumps(obj))

        self.service.organization('1234').delete()
        self.expect('DELETE', '/organizations/1234')

        self.service.organization('1234').member('1234').delete()
        self.expect('DELETE', '/organizations/1234/members/1234')

        self.service.organization('1234').membership('1234').delete()
        self.expect('DELETE', '/organizations/1234/memberships/1234')

########NEW FILE########
__FILENAME__ = test_twilio
import unittest

from libsaas.executors import test_executor
from libsaas.services import base, twilio


class TwilioTestCase(unittest.TestCase):

    def setUp(self):
        self.executor = test_executor.use()
        self.executor.set_response(b'{}', 200, {})

        self.service = twilio.Twilio('my-sid', 'my-token')
        self.account = self.service.account('foo')

    def expect(self, method=None, uri=None, params=None, headers=None):
        if method is not None:
            self.assertEqual(method, self.executor.request.method)
        if uri is not None:
            self.assertEqual(self.executor.request.uri,
                             'https://api.twilio.com/2010-04-01/' + uri)
        if params is not None:
            self.assertEqual(self.executor.request.params, params)
        if headers is not None:
            self.assertEqual(self.executor.request.headers, headers)

    def test_translate_inequality(self):
        self.assertEqual('NothingToDo',
                         twilio.resource.translate_inequality('NothingToDo'))

        self.assertEqual('Greater>',
                         twilio.resource.translate_inequality('GreaterGT'))

        self.assertEqual('Lower<',
                         twilio.resource.translate_inequality('LowerLT'))

    def test_auth(self):
        service = twilio.Twilio('a-sid', 'a-token')
        service.accounts().get()
        self.expect('GET', 'Accounts.json', {},
                    {'Authorization': 'Basic YS1zaWQ6YS10b2tlbg=='})

    def test_accounts(self):
        # Account resource
        self.assertRaises(TypeError, self.service.account)

        self.account.get()
        self.expect('GET', 'Accounts/foo.json')

        update_account_data = {'FriendlyName': 'updated-account'}
        self.account.update(update_account_data)
        self.expect('POST', 'Accounts/foo.json', update_account_data)

        self.assertRaises(base.MethodNotSupported, self.account.create)
        self.assertRaises(base.MethodNotSupported, self.account.delete)

        # Accounts resource
        accounts = self.service.accounts()

        accounts.get()
        self.expect('GET', 'Accounts.json')

        accounts.get(FriendlyName='an-account')
        self.expect('GET', 'Accounts.json', {'FriendlyName': 'an-account'})

        new_account_data = {'FriendlyName': 'foo'}
        accounts.create(new_account_data)
        self.expect('POST', 'Accounts.json', new_account_data)

        self.assertRaises(base.MethodNotSupported, accounts.update)
        self.assertRaises(base.MethodNotSupported, accounts.delete)

    def test_numbers(self):
        # AvailablePhoneNumbers resource
        available_phone_numbers = self.account.available_phone_numbers()

        self.assertRaises(base.MethodNotSupported,
                          available_phone_numbers.get)
        self.assertRaises(base.MethodNotSupported,
                          available_phone_numbers.create)
        self.assertRaises(base.MethodNotSupported,
                          available_phone_numbers.update)
        self.assertRaises(base.MethodNotSupported,
                          available_phone_numbers.delete)

        # Local AvailablePhoneNumbers resource
        local_us = available_phone_numbers.local('US')

        self.assertRaises(TypeError, available_phone_numbers.local)

        local_us.get()
        self.expect('GET', 'Accounts/foo/AvailablePhoneNumbers/US/Local.json')

        local_us.get(Contains='510555****')
        self.expect('GET', 'Accounts/foo/AvailablePhoneNumbers/US/Local.json',
                    {'Contains': '510555****'})

        self.assertRaises(base.MethodNotSupported, local_us.create)
        self.assertRaises(base.MethodNotSupported, local_us.update)
        self.assertRaises(base.MethodNotSupported, local_us.delete)

        # Toll-Free AvailablePhoneNumbers resource
        toll_free_us = available_phone_numbers.toll_free('US')

        self.assertRaises(TypeError, available_phone_numbers.toll_free)

        toll_free_us.get()
        self.expect('GET', 'Accounts/foo/AvailablePhoneNumbers/US/TollFree.json')

        toll_free_us.get(Contains='510555****')
        self.expect('GET', 'Accounts/foo/AvailablePhoneNumbers/US/TollFree.json',
                    {'Contains': '510555****'})

        self.assertRaises(base.MethodNotSupported, toll_free_us.create)
        self.assertRaises(base.MethodNotSupported, toll_free_us.update)
        self.assertRaises(base.MethodNotSupported, toll_free_us.delete)

        # OutgoingCallerId resource
        caller_id = self.account.outgoing_caller_id('a-caller')

        caller_id.get()
        self.expect('GET', 'Accounts/foo/OutgoingCallerIds/a-caller.json')

        update_outgoing_data = {'FriendlyName': 'foo'}
        caller_id.update(update_outgoing_data)
        self.expect('POST', 'Accounts/foo/OutgoingCallerIds/a-caller.json',
                    update_outgoing_data)

        caller_id.delete()
        self.expect('DELETE', 'Accounts/foo/OutgoingCallerIds/a-caller.json')

        self.assertRaises(base.MethodNotSupported, caller_id.create)

        # OutgoingCallerIds resource
        caller_ids = self.account.outgoing_caller_ids()

        caller_ids.get()
        self.expect('GET', 'Accounts/foo/OutgoingCallerIds.json')

        caller_ids.get(FriendlyName='a-caller')
        self.expect('GET', 'Accounts/foo/OutgoingCallerIds.json',
                    {'FriendlyName': 'a-caller'})

        new_outgoing_data = {'PhoneNumber': 555, 'Extension': 123}
        caller_ids.create(new_outgoing_data)
        self.expect('POST', 'Accounts/foo/OutgoingCallerIds.json',
                    new_outgoing_data)

        self.assertRaises(base.MethodNotSupported, caller_ids.update)
        self.assertRaises(base.MethodNotSupported, caller_ids.delete)

        # IncomingPhoneNumber resource
        number = self.account.incoming_phone_number('55510')

        number.get()
        self.expect('GET', 'Accounts/foo/IncomingPhoneNumbers/55510.json')

        update_number_data = {'FriendlyName': 'foo'}
        number.update(update_number_data)
        self.expect('POST', 'Accounts/foo/IncomingPhoneNumbers/55510.json',
                    update_number_data)

        number.delete()
        self.expect('DELETE', 'Accounts/foo/IncomingPhoneNumbers/55510.json')

        self.assertRaises(base.MethodNotSupported, number.create)

        # IncomingPhoneNumbers resource
        numbers = self.account.incoming_phone_numbers()

        numbers.get()
        self.expect('GET', 'Accounts/foo/IncomingPhoneNumbers.json')

        numbers.get(FriendlyName='a-number')
        self.expect('GET', 'Accounts/foo/IncomingPhoneNumbers.json',
                    {'FriendlyName': 'a-number'})

        new_number_data = {'PhoneNumber': 555, 'AreaCode': 123}
        numbers.create(new_number_data)
        self.expect('POST', 'Accounts/foo/IncomingPhoneNumbers.json',
                    new_number_data)

        self.assertRaises(base.MethodNotSupported, numbers.update)
        self.assertRaises(base.MethodNotSupported, numbers.delete)

        # Local IncomingPhoneNumbers resource
        local_numbers = self.account.incoming_phone_numbers().local()

        local_numbers.get()
        self.expect('GET', 'Accounts/foo/IncomingPhoneNumbers/Local.json')

        local_numbers.get(FriendlyName='a-number')
        self.expect('GET', 'Accounts/foo/IncomingPhoneNumbers/Local.json',
                    {'FriendlyName': 'a-number'})

        new_number_data = {'PhoneNumber': 555}
        local_numbers.create(new_number_data)
        self.expect('POST', 'Accounts/foo/IncomingPhoneNumbers/Local.json',
                    new_number_data)

        self.assertRaises(base.MethodNotSupported, local_numbers.update)
        self.assertRaises(base.MethodNotSupported, local_numbers.delete)

        # Toll-Free IncomingPhoneNumbers resource
        toll_free_numbers = self.account.incoming_phone_numbers().toll_free()

        toll_free_numbers.get()
        self.expect('GET', 'Accounts/foo/IncomingPhoneNumbers/TollFree.json')

        toll_free_numbers.get(FriendlyName='number')
        self.expect('GET', 'Accounts/foo/IncomingPhoneNumbers/TollFree.json',
                    {'FriendlyName': 'number'})

        new_number_data = {'PhoneNumber': 555}
        toll_free_numbers.create(new_number_data)
        self.expect('POST', 'Accounts/foo/IncomingPhoneNumbers/TollFree.json',
                    new_number_data)

        self.assertRaises(base.MethodNotSupported, toll_free_numbers.update)
        self.assertRaises(base.MethodNotSupported, toll_free_numbers.delete)

    def test_applications(self):
        # ConnectApp resource
        connect_app = self.account.connect_app('app')

        self.assertRaises(TypeError, self.account.connect_app)

        connect_app.get()
        self.expect('GET', 'Accounts/foo/ConnectApps/app.json')

        update_app_data = {'FriendlyName': 'foo'}
        connect_app.update(update_app_data)
        self.expect('POST', 'Accounts/foo/ConnectApps/app.json',
                    update_app_data)

        self.assertRaises(base.MethodNotSupported, connect_app.create)
        self.assertRaises(base.MethodNotSupported, connect_app.delete)

        # ConnectApps resource
        connect_apps = self.account.connect_apps()

        connect_apps.get()
        self.expect('GET', 'Accounts/foo/ConnectApps.json')

        self.assertRaises(base.MethodNotSupported, connect_apps.create)
        self.assertRaises(base.MethodNotSupported, connect_apps.update)
        self.assertRaises(base.MethodNotSupported, connect_apps.delete)

        # AuthorizedConnectApp resource
        authorized_connect_app = self.account.authorized_connect_app('app')

        self.assertRaises(TypeError, self.account.authorized_connect_app)

        authorized_connect_app.get()
        self.expect('GET', 'Accounts/foo/AuthorizedConnectApps/app.json')

        self.assertRaises(base.MethodNotSupported,
                          authorized_connect_app.create)
        self.assertRaises(base.MethodNotSupported,
                          authorized_connect_app.update)
        self.assertRaises(base.MethodNotSupported,
                          authorized_connect_app.delete)

        # AuthorizedConnectApps resource
        authorized_connect_apps = self.account.authorized_connect_apps()

        authorized_connect_apps.get()
        self.expect('GET', 'Accounts/foo/AuthorizedConnectApps.json')

        self.assertRaises(base.MethodNotSupported,
                          authorized_connect_apps.create)
        self.assertRaises(base.MethodNotSupported,
                          authorized_connect_apps.update)
        self.assertRaises(base.MethodNotSupported,
                          authorized_connect_apps.delete)

        # Application resource
        application = self.account.application('app')

        self.assertRaises(TypeError, self.account.application)

        application.get()
        self.expect('GET', 'Accounts/foo/Applications/app.json')

        update_app_data = {'FriendlyName': 'foo', 'VoiceUrl': 'http://bar/'}
        application.update(update_app_data)
        self.expect('POST', 'Accounts/foo/Applications/app.json',
                    update_app_data)

        application.delete()
        self.expect('DELETE', 'Accounts/foo/Applications/app.json')

        self.assertRaises(base.MethodNotSupported, application.create)

        # Applications resource
        applications = self.account.applications()

        applications.get()
        self.expect('GET', 'Accounts/foo/Applications.json')

        applications.get(FriendlyName='foo')
        self.expect('GET', 'Accounts/foo/Applications.json',
                    {'FriendlyName': 'foo'})

        new_app_data = {'FriendlyName': 'foo'}
        applications.create(new_app_data)
        self.expect('POST', 'Accounts/foo/Applications.json', new_app_data)

        self.assertRaises(base.MethodNotSupported, applications.update)
        self.assertRaises(base.MethodNotSupported, applications.delete)

    def test_calls(self):
        # Call resource
        call = self.account.call('a-call')

        self.assertRaises(TypeError, self.account.call)

        call.get()
        self.expect('GET', 'Accounts/foo/Calls/a-call.json')

        update_call_data = {'Url': 'http://bar/', 'Status': 'completed'}
        call.update(update_call_data)
        self.expect('POST', 'Accounts/foo/Calls/a-call.json', update_call_data)

        self.assertRaises(base.MethodNotSupported, call.create)
        self.assertRaises(base.MethodNotSupported, call.delete)

        # Call Notifications resource
        call_notifications = call.notifications()

        call_notifications.get()
        self.expect('GET', 'Accounts/foo/Calls/a-call/Notifications.json')

        call_notifications.get(MessageDateGT='2012-06-06')
        self.expect('GET', 'Accounts/foo/Calls/a-call/Notifications.json',
                    {'MessageDate>': '2012-06-06'})

        self.assertRaises(base.MethodNotSupported, call_notifications.create)
        self.assertRaises(base.MethodNotSupported, call_notifications.update)
        self.assertRaises(base.MethodNotSupported, call_notifications.delete)

        # Call Recordings resource
        call_recordings = call.recordings()

        call_recordings.get()
        self.expect('GET', 'Accounts/foo/Calls/a-call/Recordings.json')

        call_recordings.get(DateCreatedLT='2012-06-06')
        self.expect('GET', 'Accounts/foo/Calls/a-call/Recordings.json',
                    {'DateCreated<': '2012-06-06'})

        self.assertRaises(base.MethodNotSupported, call_recordings.create)
        self.assertRaises(base.MethodNotSupported, call_recordings.update)
        self.assertRaises(base.MethodNotSupported, call_recordings.delete)

        # Calls resource
        calls = self.account.calls()

        calls.get()
        self.expect('GET', 'Accounts/foo/Calls.json')

        calls.get(StartTimeGT='2012-06-06')
        self.expect('GET', 'Accounts/foo/Calls.json',
                    {'StartTime>': '2012-06-06'})

        new_call_data = {'Url': 'http://bar/'}
        calls.create(new_call_data)
        self.expect('POST', 'Accounts/foo/Calls.json', new_call_data)

        self.assertRaises(base.MethodNotSupported, calls.update)
        self.assertRaises(base.MethodNotSupported, calls.delete)

    def test_conferences(self):
        # Conference resource
        conference = self.account.conference('conf')

        self.assertRaises(TypeError, self.account.conference)

        conference.get()
        self.expect('GET', 'Accounts/foo/Conferences/conf.json')

        self.assertRaises(base.MethodNotSupported, conference.create)
        self.assertRaises(base.MethodNotSupported, conference.update)
        self.assertRaises(base.MethodNotSupported, conference.delete)

        # Conference participant resource
        participant = conference.participant('guy')

        participant.get()
        self.expect('GET',
                    'Accounts/foo/Conferences/conf/Participants/guy.json')

        update_participant_data = {'Muted': True}
        participant.update(update_participant_data)
        self.expect('POST',
                    'Accounts/foo/Conferences/conf/Participants/guy.json',
                    update_participant_data)

        participant.delete()
        self.expect('DELETE',
                    'Accounts/foo/Conferences/conf/Participants/guy.json')

        self.assertRaises(base.MethodNotSupported, participant.create)

        # Conference participants resource
        participants = conference.participants()

        participants.get()
        self.expect('GET', 'Accounts/foo/Conferences/conf/Participants.json')

        participants.get(Muted=True)
        self.expect('GET', 'Accounts/foo/Conferences/conf/Participants.json',
                    {'Muted': 'true'})

        self.assertRaises(base.MethodNotSupported, participants.create)
        self.assertRaises(base.MethodNotSupported, participants.update)
        self.assertRaises(base.MethodNotSupported, participants.delete)

        # Conference resource
        conferences = self.account.conferences()

        conferences.get()
        self.expect('GET', 'Accounts/foo/Conferences.json')

        conferences.get(DateUpdatedGT='2012-06-06')
        self.expect('GET', 'Accounts/foo/Conferences.json',
                    {'DateUpdated>': '2012-06-06'})

        self.assertRaises(base.MethodNotSupported, conferences.create)
        self.assertRaises(base.MethodNotSupported, conferences.update)
        self.assertRaises(base.MethodNotSupported, conferences.delete)

    def test_queues(self):
        # Queue resource
        queue = self.account.queue('queue')

        self.assertRaises(TypeError, self.account.queue)

        queue.get()
        self.expect('GET', 'Accounts/foo/Queues/queue.json')

        update_queue_data = {'CurrentSize': 16}
        queue.update(update_queue_data)
        self.expect('POST', 'Accounts/foo/Queues/queue.json',
                    update_queue_data)

        queue.delete()
        self.expect('DELETE', 'Accounts/foo/Queues/queue.json')

        self.assertRaises(base.MethodNotSupported, queue.create)

        # Queue Member resource
        member = queue.member('member')

        member.get()
        self.expect('GET', 'Accounts/foo/Queues/queue/Members/member.json')

        update_member_data = {'Url': 'http://bar/'}
        member.update(update_member_data)
        self.expect('POST', 'Accounts/foo/Queues/queue/Members/member.json',
                    update_member_data)

        self.assertRaises(base.MethodNotSupported, member.create)
        self.assertRaises(base.MethodNotSupported, member.delete)

        # Queue Members resource
        members = queue.members()

        members.get()
        self.expect('GET', 'Accounts/foo/Queues/queue/Members.json')

        self.assertRaises(base.MethodNotSupported, members.create)
        self.assertRaises(base.MethodNotSupported, members.update)
        self.assertRaises(base.MethodNotSupported, members.delete)

        # Queues resource
        queues = self.account.queues()

        queues.get()
        self.expect('GET', 'Accounts/foo/Queues.json')

        new_queue_data = {'FriendlyName': 'foo', 'MaxSize': 12}
        queues.create(new_queue_data)
        self.expect('POST', 'Accounts/foo/Queues.json', new_queue_data)

        self.assertRaises(base.MethodNotSupported, queues.update)
        self.assertRaises(base.MethodNotSupported, queues.delete)

    def test_sms(self):
        # SMS resource
        sms = self.account.sms()

        self.assertRaises(base.MethodNotSupported, sms.get)
        self.assertRaises(base.MethodNotSupported, sms.create)
        self.assertRaises(base.MethodNotSupported, sms.update)
        self.assertRaises(base.MethodNotSupported, sms.delete)

        # SMS Message resource
        message = sms.message('message')

        self.assertRaises(TypeError, sms.message)

        message.get()
        self.expect('GET', 'Accounts/foo/SMS/Messages/message.json')

        self.assertRaises(base.MethodNotSupported, message.create)
        self.assertRaises(base.MethodNotSupported, message.update)
        self.assertRaises(base.MethodNotSupported, message.delete)

        # SMS Messages resource
        messages = sms.messages()

        messages.get()
        self.expect('GET', 'Accounts/foo/SMS/Messages.json')

        messages.get(DateSentLT='2012-06-06')
        self.expect('GET', 'Accounts/foo/SMS/Messages.json',
                    {'DateSent<': '2012-06-06'})

        new_message_data = {'To': '55510', 'Body': 'foo bar baz'}
        messages.create(new_message_data)
        self.expect('POST', 'Accounts/foo/SMS/Messages.json',
                    new_message_data)

        self.assertRaises(base.MethodNotSupported, messages.update)
        self.assertRaises(base.MethodNotSupported, messages.delete)

        # ShortCode resource
        short_code = sms.short_code('55510')

        self.assertRaises(TypeError, sms.short_code)

        short_code.get()
        self.expect('GET', 'Accounts/foo/SMS/ShortCodes/55510.json')

        update_code_data = {'FriendlyName': 'foo'}
        short_code.update(update_code_data)
        self.expect('POST', 'Accounts/foo/SMS/ShortCodes/55510.json',
                    update_code_data)

        self.assertRaises(base.MethodNotSupported, short_code.create)
        self.assertRaises(base.MethodNotSupported, short_code.delete)

        # ShortCodes resource
        short_codes = sms.short_codes()

        short_codes.get()
        self.expect('GET', 'Accounts/foo/SMS/ShortCodes.json')

        short_codes.get(ShortCode='55510')
        self.expect('GET', 'Accounts/foo/SMS/ShortCodes.json',
                    {'ShortCode': '55510'})

        self.assertRaises(base.MethodNotSupported, short_codes.create)
        self.assertRaises(base.MethodNotSupported, short_codes.update)
        self.assertRaises(base.MethodNotSupported, short_codes.delete)

    def test_recordings(self):
        # Recording resource
        recording = self.account.recording('rec')

        self.assertRaises(TypeError, self.account.recording)

        recording.get()
        self.expect('GET', 'Accounts/foo/Recordings/rec.json')

        recording.delete()
        self.expect('DELETE', 'Accounts/foo/Recordings/rec.json')

        self.assertRaises(base.MethodNotSupported, recording.create)
        self.assertRaises(base.MethodNotSupported, recording.update)

        # Recording Transcriptions resource
        record_trans = recording.transcriptions()

        record_trans.get()
        self.expect('GET', 'Accounts/foo/Recordings/rec/Transcriptions.json')

        self.assertRaises(base.MethodNotSupported, record_trans.create)
        self.assertRaises(base.MethodNotSupported, record_trans.update)
        self.assertRaises(base.MethodNotSupported, record_trans.delete)

        # Recordings resource
        recordings = self.account.recordings()

        recordings.get()
        self.expect('GET', 'Accounts/foo/Recordings.json')

        recordings.get(DateCreatedGT='2012-06-06')
        self.expect('GET', 'Accounts/foo/Recordings.json',
                    {'DateCreated>': '2012-06-06'})

        self.assertRaises(base.MethodNotSupported, recordings.create)
        self.assertRaises(base.MethodNotSupported, recordings.update)
        self.assertRaises(base.MethodNotSupported, recordings.delete)

        # Transcription resource
        transcription = self.account.transcription('trans')

        self.assertRaises(TypeError, self.account.transcription)

        transcription.get()
        self.expect('GET', 'Accounts/foo/Transcriptions/trans.json')

        self.assertRaises(base.MethodNotSupported, transcription.create)
        self.assertRaises(base.MethodNotSupported, transcription.update)
        self.assertRaises(base.MethodNotSupported, transcription.delete)

        # Transcriptions resource
        transcriptions = self.account.transcriptions()

        transcriptions.get()
        self.expect('GET', 'Accounts/foo/Transcriptions.json')

        self.assertRaises(base.MethodNotSupported, transcriptions.create)
        self.assertRaises(base.MethodNotSupported, transcriptions.update)
        self.assertRaises(base.MethodNotSupported, transcriptions.delete)

    def test_notifications(self):
        # Notification resource
        notification = self.account.notification('noti')

        self.assertRaises(TypeError, self.account.notification)

        notification.get()
        self.expect('GET', 'Accounts/foo/Notifications/noti.json')

        notification.delete()
        self.expect('DELETE', 'Accounts/foo/Notifications/noti.json')

        self.assertRaises(base.MethodNotSupported, notification.create)
        self.assertRaises(base.MethodNotSupported, notification.update)

        # Notifications resource
        notifications = self.account.notifications()

        notifications.get()
        self.expect('GET', 'Accounts/foo/Notifications.json')

        notifications.get(MessageDateGT='2012-06-06')
        self.expect('GET', 'Accounts/foo/Notifications.json',
                    {'MessageDate>': '2012-06-06'})

        self.assertRaises(base.MethodNotSupported, notifications.create)
        self.assertRaises(base.MethodNotSupported, notifications.update)
        self.assertRaises(base.MethodNotSupported, notifications.delete)

    def test_usage(self):
        # Usage resource
        usage = self.account.usage()

        self.assertRaises(base.MethodNotSupported, usage.get)
        self.assertRaises(base.MethodNotSupported, usage.create)
        self.assertRaises(base.MethodNotSupported, usage.update)
        self.assertRaises(base.MethodNotSupported, usage.delete)

        # Records resource
        records = usage.records()

        records.get()
        self.expect('GET', 'Accounts/foo/Usage/Records.json')

        records.get(Category='calls', StartDate='-30days', Page=3)
        self.expect('GET', 'Accounts/foo/Usage/Records.json',
                    {'Category': 'calls', 'StartDate': '-30days',
                     'Page': 3})

        self.assertRaises(base.MethodNotSupported, records.create)
        self.assertRaises(base.MethodNotSupported, records.update)
        self.assertRaises(base.MethodNotSupported, records.delete)

        # Records sub-resources
        subresources = [
            ('daily', 'Daily'),
            ('monthly', 'Monthly'),
            ('yearly', 'Yearly'),
            ('all_time', 'AllTime'),
            ('today', 'Today'),
            ('yesterday', 'Yesterday'),
            ('this_month', 'ThisMonth'),
            ('last_month', 'LastMonth')
        ]

        for subresource in subresources:
            resource = getattr(records, subresource[0])()
            url = 'Accounts/foo/Usage/Records/{0}.json'.format(subresource[1])

            resource.get()
            self.expect('GET', url)

            resource.get(Category='calls', StartDate='-30days', Page=3)
            self.expect('GET', url, {'Category': 'calls',
                                     'StartDate': '-30days',
                                     'Page': 3})

            self.assertRaises(base.MethodNotSupported, resource.create)
            self.assertRaises(base.MethodNotSupported, resource.update)
            self.assertRaises(base.MethodNotSupported, resource.delete)

        # Trigger resource
        trigger = usage.trigger('trigger')

        self.assertRaises(TypeError, self.account.usage().trigger)

        trigger.get()
        self.expect('GET', 'Accounts/foo/Usage/Triggers/trigger.json')

        update_trigger_data = {'CallbackUrl': 'http://foo/bar/'}
        trigger.update(update_trigger_data)
        self.expect('POST', 'Accounts/foo/Usage/Triggers/trigger.json',
                    update_trigger_data)

        trigger.delete()
        self.expect('DELETE', 'Accounts/foo/Usage/Triggers/trigger.json')

        self.assertRaises(base.MethodNotSupported, trigger.create)

        # Triggers resource
        triggers = usage.triggers()

        triggers.get()
        self.expect('GET', 'Accounts/foo/Usage/Triggers.json')

        triggers.get(UsageCategory='calls', Page=3)
        self.expect('GET', 'Accounts/foo/Usage/Triggers.json',
                    {'UsageCategory': 'calls', 'Page': 3})

        new_trigger_data = {'UsageCategory': 'calls', 'TriggerValue': '+30'}
        triggers.create(new_trigger_data)
        self.expect('POST', 'Accounts/foo/Usage/Triggers.json',
                    new_trigger_data)

        self.assertRaises(base.MethodNotSupported, triggers.update)
        self.assertRaises(base.MethodNotSupported, triggers.delete)

########NEW FILE########
__FILENAME__ = test_uservoice
import json
import unittest

from libsaas import http, port
from libsaas.executors import test_executor
from libsaas.services import base, uservoice


class UserVoiceTestCase(unittest.TestCase):

    def setUp(self):
        self.executor = test_executor.use()
        self.executor.set_response(b'{}', 200, {})

        self.service = uservoice.UserVoice('domain', 'key', 'secret',
                                           'token', 'token_secret')

    def expect(self, method=None, uri=None, params=None, headers=None):
        if method is not None:
            self.assertEqual(method, self.executor.request.method)
        if uri is not None:
            self.assertEqual(self.executor.request.uri,
                             'http://domain.uservoice.com/api/v1' + uri)
        if params is not None:
            try:
                params = tuple(params.items())
            except AttributeError:
                pass
            self.assertEqual(self.executor.request.params, params)
        if headers is not None:
            self.assertEqual(self.executor.request.headers, headers)

    def test_client_auth(self):
        service = uservoice.UserVoice('domain', 'key')
        service.articles().get()

        self.expect('GET', '/articles.json', {'client': 'key'})

    def test_articles(self):
        self.service.articles().get()
        self.expect('GET', '/articles.json')

        self.service.articles().create({'foo': 'bar'})
        self.expect('POST', '/articles.json', {'article[foo]': 'bar'})

        self.service.article(10).get()
        self.expect('GET', '/articles/10.json')

        self.service.article(10).update({'foo': 'bar'})
        self.expect('PUT', '/articles/10.json', {'article[foo]': 'bar'})

        self.service.article(10).useful()
        self.expect('POST', '/articles/10/useful.json')

        self.service.articles().search(query='foo')
        self.expect('GET', '/articles/search.json', {'query': 'foo'})

    def test_categories(self):
        self.service.forum(4).categories().get()
        self.expect('GET', '/forums/4/categories.json')

        self.service.forum(4).category(3).get()
        self.expect('GET', '/forums/4/categories/3.json')

        self.service.forum(4).categories().create({'foo': 'bar'})
        self.expect('POST', '/forums/4/categories.json',
                    {'category[foo]': 'bar'})

        self.service.forum(4).category(3).update({'foo': 'bar'})
        self.expect('PUT', '/forums/4/categories/3.json',
                    {'category[foo]': 'bar'})

        self.service.forum(4).category(3).delete()
        self.expect('DELETE', '/forums/4/categories/3.json')

    def test_comments(self):
        self.service.comments().get()
        self.expect('GET', '/comments.json')

        self.service.forum(3).suggestion(5).comments().get()
        self.expect('GET', '/forums/3/suggestions/5/comments.json')

        self.service.forum(3).suggestion(5).comment(6).get()
        self.expect('GET', '/forums/3/suggestions/5/comments/6.json')

        self.service.forum(3).suggestion(5).comments().create('foo')
        self.expect('POST', '/forums/3/suggestions/5/comments.json',
                    {'comment[text]': 'foo'})

        self.service.forum(3).suggestion(5).comment(6).update('bar')
        self.expect('PUT', '/forums/3/suggestions/5/comments/6.json',
                    {'comment[text]': 'bar'})

        self.service.forum(3).suggestion(5).comment(6).delete()
        self.expect('DELETE', '/forums/3/suggestions/5/comments/6.json')

        self.service.user(3).comments().get()
        self.expect('GET', '/users/3/comments.json')

    def test_custom_fields(self):
        self.service.custom_fields().get()
        self.expect('GET', '/custom_fields.json')

        self.service.custom_fields().public()
        self.expect('GET', '/custom_fields/public.json')

    def test_flags(self):
        self.service.forum(5).suggestion(6).comment(2).flags().get()
        self.expect('GET', '/forums/5/suggestions/6/comments/2/flags.json')

        self.service.forum(5).suggestion(6).comment(2).flags().create(
            'duplicate')
        self.expect('POST', '/forums/5/suggestions/6/comments/2/flags.json',
                    {'code': 'duplicate'})

        self.service.forum(5).suggestion(6).flags().get()
        self.expect('GET', '/forums/5/suggestions/6/flags.json')

        self.service.forum(5).suggestion(6).flags().create('duplicate')
        self.expect('POST', '/forums/5/suggestions/6/flags.json',
                    {'code': 'duplicate'})

        self.service.faq(5).flags().get()
        self.expect('GET', '/faqs/5/flags.json')

        self.service.faq(5).flags().create('inappropriate')
        self.expect('POST', '/faqs/5/flags.json',
                    {'code': 'inappropriate'})

    def test_forums(self):
        self.service.forums().get()
        self.expect('GET', '/forums.json')

        self.service.forum(2).get()
        self.expect('GET', '/forums/2.json')

        self.service.forums().create({'foo': 'bar'})
        self.expect('POST', '/forums.json', {'forum[foo]': 'bar'})

        self.service.forum(2).update({'foo': 'bar'})
        self.expect('PUT', '/forums/2.json', {'forum[foo]': 'bar'})

        self.service.forum(2).delete()
        self.expect('DELETE', '/forums/2.json')

    def test_support_queues(self):
        self.service.support_queues().get()
        self.expect('GET', '/support_queues.json')

        self.service.support_queue(2).get()
        self.expect('GET', '/support_queues/2.json')

        self.service.support_queues().create({'foo': 'bar'})
        self.expect('POST', '/support_queues.json',
                    {'support_queue[foo]': 'bar'})

        self.service.support_queues().sort([3, 2, 1])
        self.expect('PUT', '/support_queues/sort.json',
                    (('order[]', '3'), ('order[]', '2'), ('order[]', '1')))

        self.service.support_queue(2).delete()
        self.expect('DELETE', '/support_queues/2.json')

    def test_gadgets(self):
        self.service.gadgets().get()
        self.expect('GET', '/gadgets.json')

        self.service.gadget(2).get()
        self.expect('GET', '/gadgets/2.json')

        self.service.gadgets().create({'foo': 'bar'})
        self.expect('POST', '/gadgets.json', {'gadget[foo]': 'bar'})

        self.service.gadget(2).update({'foo': 'bar'})
        self.expect('PUT', '/gadgets/2.json', {'gadget[foo]': 'bar'})

        self.service.gadget(2).delete()
        self.expect('DELETE', '/gadgets/2.json')

    def test_notes(self):
        self.service.notes().get()
        self.expect('GET', '/notes.json')

        self.service.forum(6).suggestion(3).notes().get()
        self.expect('GET', '/forums/6/suggestions/3/notes.json')

        self.service.forum(6).suggestion(3).note(4).update('note')
        self.expect('PUT', '/forums/6/suggestions/3/notes/4.json',
                    {'note[text]': 'note'})

        self.service.forum(6).suggestion(3).notes().create('note')
        self.expect('POST', '/forums/6/suggestions/3/notes.json',
                    {'note[text]': 'note'})

        self.service.forum(6).suggestion(3).note(4).delete()
        self.expect('DELETE', '/forums/6/suggestions/3/notes/4.json')

        self.service.user(6).notes().get()
        self.expect('GET', '/users/6/notes.json')

    def test_oembed(self):
        self.service.oembed('forums/1/suggestions/2')
        self.expect('GET', '/oembed.json', {'url': 'forums/1/suggestions/2'})

    def test_search(self):
        self.service.search(query='foo')
        self.expect('GET', '/search.json', {'query': 'foo'})

        self.service.instant_answers_search(query='foo')
        self.expect('GET', '/instant_answers/search.json', {'query': 'foo'})

    def test_streams(self):
        self.service.stream().public()
        self.expect('GET', '/stream/public.json')

        self.service.stream().private()
        self.expect('GET', '/stream/private.json')

        self.service.forum(5).stream().public()
        self.expect('GET', '/forums/5/stream/public.json')

        self.service.forum(5).stream().private()
        self.expect('GET', '/forums/5/stream/private.json')

    def test_subdomains(self):
        self.service.subdomain('foo').get()
        self.expect('GET', '/subdomains/foo.json')

    def test_suggestions(self):
        self.service.suggestions().get()
        self.expect('GET', '/suggestions.json')

        self.service.suggestion(2).get()
        self.expect('GET', '/suggestions/2.json')

        self.service.suggestions().search(query='foo')
        self.expect('GET', '/suggestions/search.json', {'query': 'foo'})

        self.service.forum(4).suggestions().get()
        self.expect('GET', '/forums/4/suggestions.json')

        self.service.forum(3).suggestions().create({'title': 'foo'})
        self.expect('POST', '/forums/3/suggestions.json',
                    {'suggestion[title]': 'foo'})

        self.service.forum(3).suggestion(8).delete()
        self.expect('DELETE', '/forums/3/suggestions/8.json')

        self.service.user(9).suggestions().get()
        self.expect('GET', '/users/9/suggestions.json')

        self.service.forum(2).user_suggestions(9).get()
        self.expect('GET', '/forums/2/users/9/suggestions.json')

        self.service.forum(2).suggestions().search(query='foo')
        self.expect('GET', '/forums/2/suggestions/search.json',
                    {'query': 'foo'})

        self.service.forum(5).suggestion(2).respond({'status': 'foo'})
        self.expect('PUT', '/forums/5/suggestions/2/respond.json',
                    {'response[status]': 'foo'})

        self.service.forum(6).suggestion(5).vote()
        self.expect('POST', '/forums/6/suggestions/5/votes.json',
                    {'to': '1'})

    def test_supporters(self):
        self.service.forum(5).suggestion(2).supporters(sort='newest')
        self.expect('GET', '/forums/5/suggestions/2/supporters.json',
                    {'sort': 'newest'})

    def test_ticket_messages(self):
        self.service.ticket(5).messages().get()
        self.expect('GET', '/tickets/5/ticket_messages.json')

        self.service.ticket(5).messages().create({'foo': 'bar'})
        self.expect('POST', '/tickets/5/ticket_messages.json',
                    {'ticket_message[foo]': 'bar'})

    def test_ticket_notes(self):
        self.service.ticket(3).notes().get()
        self.expect('GET', '/tickets/3/notes.json')

        self.service.ticket(4).notes().create('note text')
        self.expect('POST', '/tickets/4/notes.json',
                    {'note[text]': 'note text'})

        self.service.ticket(2).note(3).update('new text')
        self.expect('PUT', '/tickets/2/notes/3.json', {'note[text]': 'new text'})

        self.service.ticket(2).note(6).delete()
        self.expect('DELETE', '/tickets/2/notes/6.json')

    def test_tickets(self):
        self.service.tickets().get()
        self.expect('GET', '/tickets.json')

        self.service.ticket(2).get()
        self.expect('GET', '/tickets/2.json')

        self.service.tickets().create({'foo': 'bar'})
        self.expect('POST', '/tickets.json', {'ticket[foo]': 'bar'})

        self.service.ticket(2).update({'foo': 'bar'})
        self.expect('PUT', '/tickets/2.json', {'ticket[foo]': 'bar'})

        self.service.ticket(2).delete()
        self.expect('DELETE', '/tickets/2.json')

        self.service.tickets().upsert({'foo': 'bar'})
        self.expect('PUT', '/tickets/upsert.json', {'ticket[foo]': 'bar'})

        self.service.tickets().search(query='foo', page=2)
        self.expect('GET', '/tickets/search.json', {'query': 'foo', 'page': '2'})

    def test_topics(self):
        self.service.topics().get()
        self.expect('GET', '/topics.json')

        self.assertRaises(base.MethodNotSupported,
                          self.service.topics().create, {'foo': 'bar'})

        self.service.topic(4).search(query='foo')
        self.expect('GET', '/topics/4/articles/search.json', {'query': 'foo'})

        self.service.topic(4).articles(sort='newest', page=3)
        self.expect('GET', '/topics/4/articles.json',
                    {'sort': 'newest', 'page': '3'})

    def test_users(self):
        self.service.users().get()
        self.expect('GET', '/users.json')

        self.service.user(2).get()
        self.expect('GET', '/users/2.json')

        self.service.user().get()
        self.expect('GET', '/users/current.json')

        self.service.users().create({'foo': 'bar'})
        self.expect('POST', '/users.json', {'user[foo]': 'bar'})

        self.service.user(2).update({'foo': 'bar'})
        self.expect('PUT', '/users/2.json', {'user[foo]': 'bar'})

        self.service.user(2).delete()
        self.expect('DELETE', '/users/2.json')

        self.service.users().search(query='foo', page=2)
        self.expect('GET', '/users/search.json', {'query': 'foo', 'page': '2'})

########NEW FILE########
__FILENAME__ = test_youtube
import unittest

from libsaas import port
from libsaas.executors import test_executor
from libsaas.services import youtube
from libsaas.services.base import MethodNotSupported, get_params


class YouTubeTestCase(unittest.TestCase):

    def setUp(self):
        self.executor = test_executor.use()
        self.executor.set_response(b'{}', 200, {})

        self.service = youtube.YouTube('my-access-token')


    def expect(self, uri=None, params=None, headers=None):
        if uri:
            self.assertEqual(self.executor.request.uri,
                             '{0}/{1}'.format(self.service.get_url(), uri))
        else:
            self.assertEqual(self.executor.request.uri,
                             youtube.Analytics.APIROOT)

        if params:
            self.assertEqual(self.executor.request.params, params)

        if headers is not None:
            self.assertEqual(self.executor.request.headers, headers)

    def test_auth(self):
        self.service.channels().get(part='snippet', mine=True)
        self.expect('channels',
                    {'mine': 'true', 'part': 'snippet'},
                    {'Authorization': 'Bearer my-access-token'})

    def test_analytics(self):
        self.service.analytics().get('CHANNEL==id1', 'm1,m2', '10-10-2010',
                                     '12-12-2012', dimensions='d1,d2',
                                     max_results=5, start_index=1, sort='m1')
        self.expect(None, {'ids': 'CHANNEL==id1', 'metrics': 'm1,m2',
                           'start-date': '10-10-2010', 'end-date': '12-12-2012',
                           'dimensions': 'd1,d2', 'max-results': 5,
                           'start-index': 1, 'sort': 'm1'})

    def test_activities(self):
        with port.assertRaises(MethodNotSupported):
            self.service.activities().create()
            self.service.activities().update()
            self.service.activities().delete()

        kwargs = {'part': 'snippet', 'mine': True, 'maxResults': 5,
                  'publishedBefore': '2012-01-01'}
        self.service.activities().get(**kwargs)
        self.expect('activities', get_params(None, kwargs))

    def test_channels(self):
        with port.assertRaises(MethodNotSupported):
            self.service.channels().create()
            self.service.channels().update()
            self.service.channels().delete()

        kwargs = {'part': 'snippet', 'mine': True, 'maxResults': 5,
                  'pageToken': 'token'}
        self.service.channels().get(**kwargs)
        self.expect('channels', get_params(None, kwargs))

    def test_guide_categories(self):
        with port.assertRaises(MethodNotSupported):
            self.service.guide_categories().create()
            self.service.guide_categories().update()
            self.service.guide_categories().delete()

        kwargs = {'part': 'snippet', 'id': 'ID', 'regionCode': 'CODE',
                  'hl': 'en_US'}
        self.service.guide_categories().get(**kwargs)
        self.expect('guideCategories', get_params(None, kwargs))

    def test_playlist_items(self):
        with port.assertRaises(MethodNotSupported):
            self.service.playlist_items().create()
            self.service.playlist_items().update()
            self.service.playlist_items().delete()

        kwargs = {'part': 'snippet', 'id': 'id1,id2', 'playlistId': 'id',
                  'maxResults': 5, 'pageToken': 'token'}
        self.service.playlist_items().get(**kwargs)
        self.expect('playlistItems', get_params(None, kwargs))

    def test_playlists(self):
        with port.assertRaises(MethodNotSupported):
            self.service.playlists().create()
            self.service.playlists().update()
            self.service.playlists().delete()

        kwargs = {'part': 'snippet', 'mine': True, 'maxResults': 5,
                  'pageToken': 'token'}
        self.service.playlists().get(**kwargs)
        self.expect('playlists', get_params(None, kwargs))

    def test_search(self):
        with port.assertRaises(MethodNotSupported):
            self.service.search().create()
            self.service.search().update()
            self.service.search().delete()

        kwargs = {'part': 'snippet', 'q': 'Leo Messi best goals', 'maxResults': 5,
                  'pageToken': 'token'}
        self.service.search().get(**kwargs)
        self.expect('search', get_params(None, kwargs))

    def test_subscriptions(self):
        with port.assertRaises(MethodNotSupported):
            self.service.subscriptions().create()
            self.service.subscriptions().update()
            self.service.subscriptions().delete()

        kwargs = {'part': 'snippet', 'id': 'subs_id', 'maxResults': 5,
                  'order': 'releveance', 'pageToken': 'token'}
        self.service.subscriptions().get(**kwargs)
        self.expect('subscriptions', get_params(None, kwargs))

    def test_video_categories(self):
        with port.assertRaises(MethodNotSupported):
            self.service.video_categories().create()
            self.service.video_categories().update()
            self.service.video_categories().delete()

        kwargs = {'part': 'snippet', 'id': 'ID', 'regionCode': 'CODE',
                  'hl': 'en_US'}
        self.service.video_categories().get(**kwargs)
        self.expect('videoCategories', get_params(None, kwargs))

    def test_videos(self):
        with port.assertRaises(MethodNotSupported):
            self.service.videos().create()
            self.service.videos().update()
            self.service.videos().delete()

        kwargs = {'part': 'snippet', 'id': 'videoid'}
        self.service.videos().get(**kwargs)
        self.expect('videos', get_params(None, kwargs))

########NEW FILE########
__FILENAME__ = test_zendesk
import json
import unittest

from libsaas.executors import test_executor
from libsaas.services import zendesk


class ZendeskTestCase(unittest.TestCase):

    def setUp(self):
        self.executor = test_executor.use()
        self.executor.set_response(b'{}', 200, {})

        self.service = zendesk.Zendesk('mydomain', 'user', 'pass')

    def serialize(self, data):
        return json.dumps(data)

    def expect(self, method=None, uri=None, params=None, headers=None):
        if method:
            self.assertEqual(method, self.executor.request.method)
        if uri:
            self.assertEqual(self.executor.request.uri,
                              'https://mydomain.zendesk.com/api/v2' + uri)
        if params:
            self.assertEqual(self.executor.request.params, params)
        if headers:
            self.assertEqual(self.executor.request.headers, headers)

    def test_tickets(self):
        self.service.tickets().get(page=3)
        self.expect('GET', '/tickets.json', {'page': 3})

        self.service.ticket(3).get()
        self.expect('GET', '/tickets/3.json')

        self.service.tickets().recent(per_page=10)
        self.expect('GET', '/tickets/recent.json', {'per_page': 10})

        self.service.tickets().create({'ticket': {'x': 'x'}})
        self.expect('POST', '/tickets.json',
                    json.dumps({'ticket': {'x': 'x'}}))

        self.service.ticket(23).update({'ticket': {'x': 'x'}})
        self.expect('PUT', '/tickets/23.json',
                    json.dumps({'ticket': {'x': 'x'}}))

        self.service.ticket(23).delete()
        self.expect('DELETE', '/tickets/23.json')

        self.service.ticket(23).collaborators(page=3)
        self.expect('GET', '/tickets/23/collaborators.json', {'page': 3})

        self.service.ticket(23).audits()
        self.expect('GET', '/tickets/23/audits.json')

    def test_users(self):
        self.service.users().get(page=10)
        self.expect('GET', '/users.json', {'page': 10})

        self.service.user(6).get()
        self.expect('GET', '/users/6.json')

        self.service.users().create({'user': {'name': 'foo'}})
        self.expect('POST', '/users.json',
                    json.dumps({'user': {'name': 'foo'}}))

        self.service.user(6).update({'user': {'name': 'bar'}})
        self.expect('PUT', '/users/6.json',
                    json.dumps({'user': {'name': 'bar'}}))

        self.service.user(6).delete()
        self.expect('DELETE', '/users/6.json')

        self.service.users().search('user@example.org')
        self.expect('GET', '/users/search.json', {'query': 'user@example.org'})

        self.service.user().get()
        self.expect('GET', '/users/me.json')

        self.service.user(6).tickets_requested(2)
        self.expect('GET', '/users/6/tickets/requested.json', {'page': 2})

        self.service.user().get()
        self.service.user(6).tickets_ccd()
        self.expect('GET', '/users/6/tickets/ccd.json', {})

    def test_groups(self):
        self.service.groups().get(page=3)
        self.expect('GET', '/groups.json', {'page': 3})

        self.service.group(3).get()
        self.expect('GET', '/groups/3.json')

        self.service.groups().create({'group': {'x': 'x'}})
        self.expect('POST', '/groups.json',
                    json.dumps({'group': {'x': 'x'}}))

        self.service.group(23).update({'group': {'x': 'x'}})
        self.expect('PUT', '/groups/23.json',
                    json.dumps({'group': {'x': 'x'}}))

        self.service.group(23).delete()
        self.expect('DELETE', '/groups/23.json')

        self.service.groups().assignable()
        self.expect('GET', '/groups/assignable.json')

    def test_activities(self):
        self.service.activities().get(page=3)
        self.expect('GET', '/activities.json', {'page': 3})

        self.service.activities().get(since="2012-03-05T10:38:52Z")
        self.expect('GET', '/activities.json',
                    {'since': "2012-03-05T10:38:52Z"})

        self.service.activity(3).get()
        self.expect('GET', '/activities/3.json')

    def test_satisfaction(self):
        self.service.satisfaction_ratings().get(page=3)
        self.expect('GET', '/satisfaction_ratings.json', {'page': 3})

        self.service.satisfaction_ratings().received(page=3)
        self.expect('GET', '/satisfaction_ratings/received.json', {'page': 3})

        self.service.satisfaction_ratings().received(page=3, sort_order='desc')
        self.expect('GET', '/satisfaction_ratings/received.json',
                    {'page': 3, 'sort_order': 'desc'})

        self.service.satisfaction_rating(3).get()
        self.expect('GET', '/satisfaction_ratings/3.json')

    def test_search(self):
        self.service.search('a term', sort_by='status')
        self.expect('GET', '/search.json',
                    {'query': 'a term', 'sort_by': 'status'})

    def test_views(self):
        self.service.views().get(page=3)
        self.expect('GET', '/views.json', {'page': 3})

        self.service.views().active()
        self.expect('GET', '/views/active.json')

        self.service.views().count_many([1, 2])
        self.expect('GET', '/views/count_many.json', {'ids': b'1,2'})

        conditions = {
            "all": [
                {"operator": "is",
                 "value": ["open"],
                 "field": "status"}
            ]
        }
        self.service.views().preview(conditions, columns=['subject'])
        conditions.update({'output': {'columns': ['subject']}})
        self.expect('POST', '/views/preview.json',
                    self.serialize({'view': conditions}))

        self.service.view(1).count()
        self.expect('GET', '/views/1/count.json')

        self.service.view(1).execute(sort_by='status')
        self.expect('GET', '/views/1/execute.json', {'sort_by': 'status'})

        self.service.view(1).tickets(page=3)
        self.expect('GET', '/views/1/tickets.json', {'page': 3})

    def test_exports(self):
        self.service.exports().tickets(start_time=1340184927)
        self.expect('GET', '/exports/tickets.json',
                    {'start_time': 1340184927})

    def test_tags(self):
        self.service.tags().get(page=10)
        self.expect('GET', '/tags.json', {'page': 10})

        self.service.ticket(23).tags().get()
        self.expect('GET', '/tickets/23/tags.json')

########NEW FILE########
