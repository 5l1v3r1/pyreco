__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# mirai documentation build configuration file, created by
# sphinx-quickstart on Sat May 10 18:53:01 2014.
#
# This file is execfile()d with the current directory set to its
# containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys
import os

# define project root (for automatic API documentation)
ROOT = os.path.abspath(os.path.split(__file__)[0] + "../../")
sys.path.append(ROOT)

# derive version from setup.py
from setup import version

# use flask's theme
sys.path.append(os.path.join(ROOT, "docs/_themes"))

# flag used to determine if the docs are being compiled on readthedocs.org
on_rtd = os.environ.get('READTHEDOCS', None) == 'True'

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration ------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions = [
    'sphinx.ext.autodoc',
    'sphinx.ext.mathjax',
    'sphinx.ext.viewcode',
    'numpydoc',
]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'mirai'
copyright = u'2014, Daniel Duckworth'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The full version, including alpha/beta/rc tags.
release = '.'.join( version(project).split('.')[0:2] )
# The short X.Y version.
version = version(project)

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = []

# The reST default role (used for this markup: `text`) to use for all
# documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

# If true, keep warnings as "system message" paragraphs in the built documents.
#keep_warnings = False


# -- Options for HTML output ----------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
if not on_rtd:
  # git submodule doesn't work with readthedocs.org right now, so instead of
  # using the flask theme defined in the _themes submodule, just use the
  # default (which, to be honest, is pretty sweet).
  html_theme = 'flask'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['_themes']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# Add any extra paths that contain custom files (such as robots.txt or
# .htaccess) here, relative to this directory. These files are copied
# directly to the root of the documentation.
#html_extra_path = []

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'miraidoc'


# -- Options for LaTeX output ---------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title,
#  author, documentclass [howto, manual, or own class]).
latex_documents = [
  ('index', 'mirai.tex', u'mirai Documentation',
   u'Daniel Duckworth', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output ---------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'mirai', u'mirai Documentation',
     [u'Daniel Duckworth'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output -------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'mirai', u'mirai Documentation',
   u'Daniel Duckworth', 'mirai', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

# If true, do not generate a @detailmenu in the "Top" node's menu.
#texinfo_no_detailmenu = False

########NEW FILE########
__FILENAME__ = scraper
from gevent.monkey import patch_all; patch_all()

from concurrent.futures import ThreadPoolExecutor
from collections import namedtuple
from urlparse import urljoin
import logging
import logging.config
import time

from mirai import Promise, TimeoutError
from pyquery import PyQuery as pq
import click
import funcy as fu
import requests


Error   = namedtuple("Error"  , ["url", "exception"])
Success = namedtuple("Success", ["url", "response" ])
Timeout = namedtuple("Timeout", ["url", "exception"])

def abslink(domain, l):
  """Turn a (potentially) relative URL into an absolute one"""
  if l.startswith("/"): return urljoin(domain, l)
  else                : return l


def links(url, text):
  """Extract all links from a web page"""
  links = pq(text)("a").map(lambda _, el: pq(el).attr("href"))
  return [
    abslink(url, l) for l in links
    if l.startswith("http") or l.startswith("/")
  ]


# def fetch(url):
#   try:
#     start    = time.time()
#     response = requests.get(url)
#     end      = time.time()
#     return Success(url, response)
#   except Exception as e:
#     return Error(url, e)
#
#
# def scrape(url, within, maxdepth=0):
#   start = time.time()
#   if within <= 0:
#     return [Timeout(url, None)]
#   elif maxdepth == 0:
#     status = fetch(url)
#     if within < time.time() - start: return [Timeout(url, e)]
#     else                           : return [status]
#   elif maxdepth < 0:
#     return []
#   else:
#     status = fetch(url)
#     if within < time.time() - start: return [Timeout(url, e)]
#     linkset = links(url, status.response.text)
#     statuses = [
#       scrape(
#         link,
#         within   = (within - (time.time() - start)),
#         maxdepth = maxdepth-1
#       )
#       for link in linkset
#     ] + [status]
#     statuses = fu.concat(statuses)
#     return statuses


def fetch(url):
  start = time.time()
  return (
    Promise.call(requests.get, url)
    .onsuccess(lambda status   : \
      logging.info(u"Fetched {} in {:0.3f} seconds.".format(url, time.time() - start)) \
    )
    .onfailure(lambda error    : \
      logging.warning(u"Failed to fetch {}".format(url))
    )
    .map      (lambda response : Success(url, response))
    .handle   (lambda error    : Error(url, error))
  )


def scrape(url, within, maxdepth=0):
  logging.info("{:0.3f} seconds left to fetch {}".format(within, url))

  start = time.time()
  if within <= 0:
    # out of time
    return Promise.value([Timeout(url, None)])
  elif maxdepth == 0:
    # don't get any more links
    return (
      fetch(url)
      .within(within)
      .map(lambda status: [status])
      .handle(lambda e: [Timeout(url, e)])
    )
  elif maxdepth < 0:
    # this shouldn't happen, but just in case
    return Promise.value([])
  else:
    # fetch links
    return (
      fetch(url)
      .within(within)
      .map(lambda status: (links(url, status.response.text), status))
      .map(lambda (linkset, status): [
        scrape(
          link,
          within   = (within - (time.time() - start)),
          maxdepth = maxdepth - 1,
        ) for link in linkset
      ] + [
        Promise.value([status])
      ])
      .flatmap(Promise.collect)
      .map(fu.cat)
      .handle(lambda err: [Timeout(url, err)])
    )


@click.command()
@click.argument("url")
@click.option("--within", type=float, default=10.0, help="Seconds available.")
@click.option("--maxdepth", type=int, default=2, help="Degrees of separation.")
def main(url, within, maxdepth):
  logging.config.dictConfig({
    "version": 1,
    "root"   : { "level": "INFO" },
    "loggers": {
      "requests": { "level": "CRITICAL" },
    }
  })

  start   = time.time()
  results = scrape(url, within, maxdepth=maxdepth).get()
  stop    = time.time()

  print u'Retrieved {:,d} URLs in {:0.3f} seconds'.format(len(results), stop-start)
  for responsetype, responses in fu.group_by(type, results).items():
    print u'{:20s} {:,d}'.format(responsetype.__name__, len(responses))


if __name__ == '__main__':
  main()

########NEW FILE########
__FILENAME__ = tutorial01
from collections import namedtuple

import requests


# containers for possible states of an HTTP response
Error   = namedtuple("Error"  , ["url", "exception"])
Success = namedtuple("Success", ["url", "response" ])


def fetch_sync(url):
  try:
    response = requests.get(url)
    return Success(url, response)
  except Exception as e:
    return Error(url, e)

########NEW FILE########
__FILENAME__ = tutorial02
from collections import namedtuple

from mirai import Promise
import requests


# containers for possible HTTP responses
Error   = namedtuple("Error"  , ["url", "exception"])
Success = namedtuple("Success", ["url", "response" ])


def fetch_async(url):
  return (
    Promise.call(requests.get, url)
    .map      (lambda response : Success(url, response))
    .handle   (lambda error    : Error(url, error))
  )

########NEW FILE########
__FILENAME__ = tutorial03
from collections import namedtuple

from mirai import Promise
import requests


# containers for possible states of an HTTP response
Error   = namedtuple("Error"  , ["url", "exception"])
Success = namedtuple("Success", ["url", "response" ])


def fetch_sync(url, retries=3):
  try:
    response = requests.get(url)
    return Success(url, response)
  except Exception as e:
    if retries > 0:
      return fetch_sync(url, retries-1)
    else:
      return Error(url, e)


def fetch_async(url, retries=3):
  return (
    Promise.call(requests.get, url)
    .map      (lambda response : Success(url, response))
    .rescue   (lambda error    :
      fetch(url, retries-1) if retries > 0
      else Promise.value(Error(url, error))
    )
  )

########NEW FILE########
__FILENAME__ = tutorial04
from collections import namedtuple
from time import time as now

from mirai import Promise, TimeoutError
import requests


# containers for possible states of an HTTP response
Error   = namedtuple("Error"  , ["url", "exception",      ])
Success = namedtuple("Success", ["url", "time", "response"])
Timeout = namedtuple("Timeout", ["url",                   ])

def time_left(start, given):
  return given - (now() - start)


def fetch_sync(url, remaining=10.0, retries=3):
  if remaining < 0: return Timeout(url)
  start = now()
  try:
    response = requests.get(url)
    if time_left(start, remaining) > 0:
      return Success(url, now() - start, response)
    else:
      return Timeout(url)
  except Exception as e:
    if retries > 0:
      return fetch_sync(url, time_left(start, remaining), retries-1)
    else:
      return Error(url, e)


def fetch_async(url, remaining=10.0, retries=3):
  if remaining < 0: return Promise.value(Timeout(url))
  start = now()
  return (
    Promise.call(requests.get, url)
    .within(remaining)
    .map      (lambda response : Success(url, now() - start, response))
    .rescue   (lambda error    :
      fetch_async(url, time_left(start, remaining), retries-1) if retries > 0
      else Promise.value(Error(url, error))
    )
  )

########NEW FILE########
__FILENAME__ = exceptions
import sys

import joblib


class MiraiError(Exception):
  """Base class for all exceptions raise by Promises"""
  pass


class AlreadyResolvedError(MiraiError):
  """
  Exception thrown when attempting to set the value or exception of a Promise
  that has already had its value or exception set.
  """
  pass


class ShadowException(MiraiError):
  """
  An exception that's never used directly. In particular, a ShadowException is
  used to wrap a thrown exception and allow it to store the traceback context
  as a string so that users of Promise will have some idea what's going on.

  Parameters
  ----------
  exception : Exception
      Other exception to wrap
  context : string
      Formatted string containing the traceback that caused `other` to be thrown
  """

  def __init__(self, exception, context):
    self.exception   = exception
    self.context = context

  def __unicode__(self):
    return u"{cls}: {msg}\n{ctx}".format(
      cls = self.__class__.__name__,
      msg = self.message,
      ctx = self.context,
    )

  def __str__(self):
    return unicode(self)

  def __repr__(self):
    return u"{cls}({msg})".format(
      cls = self.__class__.__name__,
      msg = self.message,
    )

  def __getattr__(self, key):
    return getattr(self.exception, key)

  @staticmethod
  def build(exception, context):
    """
    Construct a child class of a thrown exception and ShadowException, and
    instantiate it.
    """
    cls = exception.__class__
    t = type(
      "Mirai" + cls.__name__,
      (ShadowException, cls),
      {}
    )
    return t(exception, context)


class SafeFunction(object):
  """
  A function-like object that catches all errors and adds their execution stack
  description to their message.
  """

  def __init__(self, f):
    self.f = f

  def __call__(self, *args, **kwargs):
    try:
      return self.f(*args, **kwargs)
    except Exception as e:
      e_type, e_value, e_tb = sys.exc_info()

      # turn stack into a string
      text = joblib.format_stack.format_exc(e_type, e_value, e_tb, context=10, tb_offset=1)

      # manually delete e_tb (failing to do so will cause a memory leak. See
      # documentation for sys.exc_info())
      del e_tb

      # construct a new exception instance that's of the same class as the one
      # thrown, but also with additional context.
      raise ShadowException.build(e, text)

########NEW FILE########
__FILENAME__ = futures
from concurrent import futures
from concurrent.futures import TimeoutError
import threading
import time

from .exceptions import MiraiError, SafeFunction, AlreadyResolvedError
from .utils import proxyto

# Future methods:
#   cancel()
#   cancelled()
#   running()
#   done()
#   result(timeout=None)
#   exception(timeout=None)
#   add_done_callback(fn)
#   set_result(result)
#   set_exception(exception)
#
# futures.wait(fs, timeout=None, return_when=ALL_COMPLETED)
#   (alt: FIRST_COMPLETED, FIRST_EXCEPTION)
# futures.as_completed(fs, timeout=None)
#
# Executor methods:
#   submit(fn *args, **kwargs)
#   map(fn, iterables)
#   shutdown()


class Promise(object):
  """
  A `Promise` encapsulates the result of an asynchronous computation. Think of
  it as a single-use mailbox -- you receive a promise which will later contain
  a message.::

    import requests
    from mirai import Promise

    def async_request(method, url, *args, **kwargs):
      "fetch a url asynchronously using `requests`"

      # construct a promise to fill later
      promise = Promise()

      def sync_request():
        "fetches synchronously & propagates exceptions"
        try:
          response = requests.request(method, url, *args, **kwargs)
          promise.setvalue(response)
        except Exception as e:
          promise.setexception(e)

      # start asynchronous computation
      Promise.call(sync_request)

      # return read-only version of promise
      return promise.future()

  Parameters
  ----------
  future : concurrent.futures.Future
      Future this promise wraps.
  """

  EXECUTOR = futures.ThreadPoolExecutor(max_workers=10)

  __slots__ = ['_future', '_lock']

  def __init__(self, future=None):
    self._future = future or futures.Future()
    self._lock   = threading.Lock()

  def andthen(self, fn):
    """
    Apply a function with a single argument: the value this Promise resolves to.
    The function must return another future.  If this Promise fails, `fn` will
    not be called. Same as as `Promise.flatmap`.

    Parameters
    ----------
    fn : (value,) -> Promise
        Function to apply. Takes 1 positional argument. Must return a Promise.

    Returns
    -------
    result : Future
        Promise `fn` will return.
    """
    return self.flatmap(fn)

  def __call__(self, timeout=None):
    """
    Retrieve value of Promise; block until it's ready or `timeout` seconds
    have passed. If `timeout` seconds pass, then a `TimeoutError` will
    be raised. If this Promise failed, the set exception will be raised.

    Parameters
    ----------
    timeout : number or None
        Number of seconds to wait until raising a `TimeoutError`. If `None`,
        then wait indefinitely.

    Returns
    -------
    result : object
        Contents of this future if it resolved successfully.

    Raises
    ------
    Exception
        Set exception if this future failed.
    """
    return self.get(timeout)

  def ensure(self, fn):
    """
    Ensure that no-argument function `fn` is called when this Promise resolves,
    regardless of whether or not it completes successfuly.

    Parameters
    ----------
    fn : (,) -> None
        function to apply upon Promise completion. takes no arguments. Return
        value ignored.

    Returns
    -------
    self : Future
    """
    def ensure(v):
      try:
        Promise.call(fn)
      except Exception as e:
        pass

    return self.onsuccess(ensure).onfailure(ensure)

  def filter(self, fn):
    """
    Construct a new Promise that fails if `fn` doesn't evaluate truthily when
    given `self.get()` as its only argument. If `fn` evaluates falsily, then
    the resulting Promise fails with a `MiraiError`.

    Parameters
    ----------
    fn : (value,) -> bool
        function used to check `self.get()`. Must return a boolean-like value.

    Returns
    -------
    result : Future
        Future whose contents are the contents of this Promise if `fn` evaluates
        truth on this Promise's contents.
    """
    return (
      self
      .flatmap(lambda v: Promise.collect([
        Promise.value(v),
        Promise.call(fn, v),
      ]))
      .flatmap(lambda (v, b):
        Promise.value(v) if b
        else Promise.exception(
          MiraiError(u"Value {} was filtered out".format(v))
        )
      )
    )

  def flatmap(self, fn):
    """
    Apply a function with a single argument: the value this Promise resolves to.
    The function must return another future.  If this Promise fails, `fn` will
    not be called.

    Parameters
    ----------
    fn : (value,) -> Promise
        Function to apply. Takes 1 positional argument. Must return a Promise.

    Returns
    -------
    result : Future
        Future containing return result of `fn`.
    """

    result = Promise()

    def populate(v):
      def setvalue(fut):
        try:
          if not isinstance(fut, Promise):
            raise MiraiError(
              "Return value of `Promise.flatmap`'s argument isn't a Promise. If "
              "you mean to transform the value contained within, use `Promise.map` "
              "instead."
            )
          fut.proxyto(result)
        except Exception as e:
          result.setexception(e)

      try:
        (
          Promise.call(fn, v)
          .onsuccess(setvalue)
          .onfailure(result.setexception)
        )
      except Exception as e:
        result.setexception(e)

    self.onsuccess(populate)
    self.onfailure(result.setexception)

    return result.future()

  def foreach(self, fn):
    """
    Apply a function if this Promise resolves successfully. The function
    receives the contents of this Promise as its only argument.

    Parameters
    ----------
    fn : (value,) -> None
        Function to apply to this Promise's contents. Return value ignored.

    Returns
    -------
    self : Promise
    """
    return self.onsuccess(fn)

  def future(self):
    """
    Retrieve a `Future` encapsulating this promise. A `Future` is a read-only
    version of the exact same thing.

    Returns
    -------
    future : Future
        Future encapsulating this Promise.
    """
    return Future(self)

  def get(self, timeout=None):
    """
    Retrieve value of Promise; block until it's ready or `timeout` seconds
    have passed. If `timeout` seconds pass, then a `TimeoutError` will
    be raised. If this Promise failed, the set exception will be raised.

    Parameters
    ----------
    timeout : number or None
        Number of seconds to wait until raising a `TimeoutError`. If `None`,
        then wait indefinitely.

    Returns
    -------
    result : anything
        Contents of this future if it resolved successfully.

    Raises
    ------
    Exception
        Set exception if this future failed.
    """
    return self._future.result(timeout)

  def getorelse(self, default, timeout=None):
    """
    Like `Promise.get`, but instead of raising an exception when this Promise
    fails, returns a default value.

    Parameters
    ----------
    default : anything
        default value to return in case of timeout or exception.
    timeout : None or float
        time to wait before returning default value if this promise is unresolved.

    Returns
    -------
    result : anything
        value this Promise resolves to, if it resolves successfully, else
        `default`.
    """
    try:
      if timeout is None:
        timeout = 0
      return self.get(timeout=timeout)
    except Exception as e:
      return default

  def handle(self, fn):
    """
    If this Promise fails, call `fn` on the ensuing exception to obtain a
    successful value.

    Parameters
    ----------
    fn : (exception,) -> anything
        Function applied to recover from a failed exception. Its return value
        will be the value of the resulting Promise.

    Returns
    -------
    result : Future
        Resulting Future returned by applying `fn` to the exception, then
        setting the return value to `result`'s value. If this Promise is
        already successful, its value is propagated onto `result`.
    """
    return self.rescue(lambda v: Promise.call(fn, v))

  def isdefined(self):
    """
    Return `True` if this Promise has already been resolved, successfully or
    unsuccessfully.

    Returns
    -------
    result : bool
    """
    return self._future.done()

  def isfailure(self):
    """
    Return `True` if this Promise failed, `False` if it succeeded, and `None` if
    it's not yet resolved.

    Returns
    -------
    result : bool
    """
    v = self.issuccess()
    if v is None : return None
    else         : return not v

  def issuccess(self):
    """
    Return `True` if this Promise succeeded, `False` if it failed, and `None` if
    it's not yet resolved.

    Returns
    -------
    result : bool
    """
    if not self.isdefined():
      return None
    else:
      try:
        self.get()
        return True
      except Exception as e:
        return False

  def join_(self, *others):
    """
    Combine values of this Promise and 1 or more other Promises into a list.
    Results are in the same order `[self] + others` is in.

    Parameters
    ----------
    others : 1 or more Promises
        Promises to combine with this Promise.

    Returns
    -------
    result : Future
        Future resolving to a list of containing the values of this Promise and
        all other Promises. If any Promise fails, `result` holds the exception in
        the one which fails soonest.
    """
    return Promise.collect([self] + list(others))

  def map(self, fn):
    """
    Transform this Promise by applying a function to its value. If this Promise
    contains an exception, `fn` is not applied.

    Parameters
    ----------
    fn : (value,) -> anything
        Function to apply to this Promise's value on completion.

    Returns
    -------
    result : Future
        Future containing `fn` applied to this Promise's value. If this Promise
        fails, the exception is propagated.
    """
    result = Promise()

    def map(v):
      try:
        Promise.call(fn, v).proxyto(result)
      except Exception as e:
        result.setexception(e)

    self.onsuccess(map)
    self.onfailure(result.setexception)

    return result.future()

  def onfailure(self, fn):
    """
    Apply a callback if this Promise fails. Callbacks can be added after this
    Promise has resolved.

    Parameters
    ----------
    fn : (exception,) -> None
        Function to call upon failure. Its only argument is the exception set
        to this Promise. If this future succeeds, `fn` will not be called.

    Returns
    -------
    self : Promise
    """
    def onfailure(fut):
      try:
        fut.result()
      except Exception as e:
        Promise.call(fn, e)

    self._future.add_done_callback(onfailure)
    return self

  def onsuccess(self, fn):
    """
    Apply a callback if this Promise succeeds. Callbacks can be added after this
    Promise has resolved.

    Parameters
    ----------
    fn : (value,) -> None
        Function to call upon success. Its only argument is the value set
        to this Promise. If this future fails, `fn` will not be called.

    Returns
    -------
    self : Promise
    """
    def onsuccess(fut):
      try:
        Promise.call(fn, fut.result())
      except Exception as e:
        pass

    self._future.add_done_callback(onsuccess)
    return self

  def or_(self, *others):
    """
    Return the first Promise that finishes among this Promise and one or more
    other Promises.

    Parameters
    ----------
    others : one or more Promises
        Other futures to consider.

    Returns
    -------
    result : Future
        First future that is resolved, successfully or otherwise.
    """
    result = Promise()

    def or_():
      def setresult(v):
        try:
          v[0].proxyto(result)
        except Exception as e:
          result.setexception(e)

      try:
        (
          Promise
          .select([self] + list(others))
          .onsuccess(setresult)
          .onfailure(result.setexception)
        )
      except Exception as e:
        result.setexception(e)

    Promise.call(or_)
    return result.future()

  def proxyto(self, other):
    """
    Copy the state of this Promise to another.

    Parameters
    ----------
    other : Promise
        Another Promise to copy the state of this Promise to, upon completion.

    Returns
    -------
    self : Promise
    """
    if not isinstance(other, Promise):
      raise MiraiError(
        "Attempting to proxy this Promise onto a non-Promise object. You can "
        "only copy the state of one Promise to another. "
      )
    self.onsuccess(other.setvalue).onfailure(other.setexception)
    return self

  def rescue(self, fn):
    """
    If this Promise fails, call `fn` on the ensuing exception to recover another
    (potentially successful) Promise. Same as `Promise.handle`.

    Parameters
    ----------
    fn : (exception,) -> Promise
        Function applied to recover from a failed exception. Must return a Promise.

    Returns
    -------
    result : Future
        Resulting Future returned by apply `fn` to the exception this Promise
        contains. If this Promise is successful, its value is propagated onto
        `result`.
    """
    result = Promise()

    def rescue(e):
      def setvalue(fut):
        try:
          if not isinstance(fut, Promise):
            raise MiraiError(
              "Return value of `Promise.rescue`'s argument isn't a Promise. If "
              "you mean to transform the exception directly, use "
              "`Promise.handle` instead."
            )
          fut.proxyto(result)
        except Exception as e:
          result.setexception(e)

      try:
        (
          Promise.call(fn, e)
          .onsuccess(setvalue)
          .onfailure(result.setexception)
        )
      except Exception as e:
        result.setexception(e)

    self.onsuccess(result.setvalue)
    self.onfailure(rescue)

    return result.future()

  def respond(self, fn):
    """
    Apply a function to this Promise when it's resolved.

    Parameters
    ----------
    fn : (Promise,) -> None
        Function to apply to this Promise upon completion. Return value is ignored

    Returns
    -------
    self : Promise
    """
    def respond(fut):
      Promise.call(fn, Promise(fut))

    self._future.add_done_callback(respond)
    return self

  def select_(self, *others):
    """
    Return the first Promise that finishes among this Promise and one or more
    other Promises.

    Parameters
    ----------
    others : one or more Promises
        Other futures to consider.

    Returns
    -------
    result : Future
        First future that is resolved, successfully or otherwise.
    """
    return self.or_(*others)

  def setexception(self, e):
    """
    Set the state of this Promise as failed with a given Exception. State can
    only be set once; once a Promise is defined, it cannot be redefined. This
    operation is thread (but not process) safe.

    Parameters
    ----------
    e : Exception

    Returns
    -------
    self : Promise
    """
    self._lock.acquire()
    if self.isdefined():
      self._lock.release()
      raise AlreadyResolvedError("Promise is already resolved; you cannot set its status again.")
    else:
      self._future.set_exception(e)
      self._lock.release()
      return self

  def setvalue(self, val):
    """
    Set the state of this Promise as successful with a given value. State can
    only be set once; once a Promise is defined, it cannot be redefined. This
    operation is thread (but not process) safe.

    Parameters
    ----------
    val : value

    Returns
    -------
    self : Promise
    """
    self._lock.acquire()
    if self.isdefined():
      self._lock.release()
      raise AlreadyResolvedError("Promise is already resolved; you cannot set its status again.")
    else:
      self._future.set_result(val)
      self._lock.release()
      return self

  def unit(self):
    """
    Convert this Promise to another that disregards its result.

    Returns
    -------
    result : Future
        Promise with a value of `None` if this Promise succeeds. If this Promise
        fails, the exception is propagated.
    """
    result = Promise()
    try:
      (
        self
        .onsuccess(lambda v: result.setvalue(None))
        .onfailure(result.setexception)
      )
    except Exception as e:
      result.setexception(e)
    return result.future()

  def update(self, other):
    """
    Populate this Promise with the contents of another.

    Parameters
    ----------
    other : Promise
        Promise to copy

    Returns
    -------
    self : Promise
    """
    if not isinstance(other, Promise):
      raise MiraiError(
        "`Promise.update`'s argument isn't a Promise. You can't copy the state "
        "of this Promise onto a non-Promise object."
      )

    other.proxyto(self)
    return self

  def updateifempty(self, other):
    """
    Like `Promise.update`, but update only if this Promise isn't already defined.

    Parameters
    ----------
    other : Promise
        Promise to copy, if necessary.

    Returns
    -------
    self : Promise
    """
    if not isinstance(other, Promise):
      raise MiraiError(
        "`Promise.updateifempty`'s argument isn't a Promise. You can't copy the "
        "state of this Promise onto a non-Promise object."
      )

    def setvalue(v):
      try:
        self.setvalue(v)
      except AlreadyResolvedError as e:
        pass
      except Exception as e:
        self.setexception(e)

    def setexception(e):
      try:
        self.setexception(e)
      except AlreadyResolvedError as e_:
        pass
      except Exception as e_:
        self.setexception(e_)

    other.onsuccess(setvalue).onfailure(setexception)
    return self

  def within(self, duration):
    """
    Return a Promise whose state is guaranteed to be resolved within `duration`
    seconds. If this Promise completes before `duration` seconds expire, it will
    contain this Promise's contents. If this Promise is not resolved by then, the
    resulting Promise will fail with a `TimeoutError`.

    Parameters
    ----------
    duration : number
        Number of seconds to wait before resolving a `TimeoutError`

    Returns
    -------
    result : Promise
        Promise guaranteed to resolve in `duration` seconds.
    """
    e = TimeoutError("Promise did not finish in {} seconds".format(duration))
    return self.or_(Promise.wait(duration).flatmap(lambda v: Promise.exception(e)))

  # CONSTRUCTORS
  @classmethod
  def value(cls, val):
    """
    Construct a Promise that is already resolved successfully to a value.

    Parameters
    ----------
    val : anything
        Value to resolve new Promise to.

    Returns
    -------
    result : Future
        Future containing `val` as its value.
    """
    f = cls()
    f.setvalue(val)
    return f.future()

  @classmethod
  def wait(cls, duration):
    """
    Construct a Promise that succeeds in `duration` seconds with value `None`.

    Parameters
    ----------
    duration : number
        Number of seconds to wait before resolving a `TimeoutError`

    Returns
    -------
    result : Future
        Promise that will resolve in `duration` seconds with value `None`.
    """
    def wait():
      try:
        time.sleep(duration)
        return None
      except Exception as e:
        raise e

    return Promise.call(wait).future()

  @classmethod
  def exception(cls, exc):
    """
    Construct a Promise that has already failed with a given exception.

    Parameters
    ----------
    exc : Exception
        Exception to fail new Promise with

    Returns
    -------
    result : Future
        New Promise that has already failed with the given exception.
    """
    f = cls()
    f.setexception(exc)
    return f.future()

  # COMBINING
  @classmethod
  def _wait(cls, fs, timeout=None, return_when=futures.FIRST_EXCEPTION):
    """
    Return a future that contains a partition of `fs` into complete and
    incomplete promises.

    Parameters
    ----------
    fs : [Promise]
        List of promises to wait upon
    timeout : float or None
        number of seconds to wait before setting result's value

    Returns
    -------
    result : Future
        Future containing a 2-element tuple. The first element is a list of
        compeleted concurrent.futures.Future, the second is a list of
        incomplete ones.
    """

    result = cls()

    def wait():
      try:
        _futures = [f._future for f in fs]
        complete, incomplete = futures.wait(_futures, timeout=timeout, return_when=return_when)
        result.setvalue( (list(complete), list(incomplete)) )
      except Exception as e:
        result.setexception(e)

    # This method needs to live outside of the Promise.EXECUTOR as a race
    # condition can arise if there len(fs) == n and max_workers == n as
    # Promise.call(select) would be the n+1 st thread, causing a lock.
    thread = threading.Thread(target=wait)
    thread.daemon = True
    thread.start()

    return result.future()

  @classmethod
  def collect(cls, fs):
    """
    Convert a sequence of Promises into a Promise containing a sequence of
    values, one per Promise in `fs`. The resulting Promise resolves once all
    Promises in `fs` resolve successsfully or upon the first failure. In the
    latter case, the failing Promise's exception is propagated.

    Parameters
    ----------
    fs : [Promise]
        List of Promises to merge.

    Returns
    -------
    result : Future
        Future containing values of all Futures in `fs`. If any Future in `fs`
        fails, `result` fails with the same exception.
    """
    if len(fs) == 0:
      return Promise.value([]) # Promise below will never fulfill if there are no fs
    else:
      lock  = threading.RLock()
      xs    = [None] * len(fs)
      count = [len(fs)] # If we don't box this number in a list, then our threaded accesses below will mysteriously hang [wat]
      p     = Promise()
      for i in range(len(fs)):
        def body(i): # Capture i for closures
          def onfailure(e):
            p.updateifempty(Promise.exception(e))
          def onsuccess(x):
            with lock:
              xs[i] = x
              count[0] -= 1
              if count[0] == 0:
                p.updateifempty(Promise.value(xs))
          fs[i].onsuccess(onsuccess).onfailure(onfailure)
        body(i)
      return p

  @classmethod
  def join(cls, fs):
    """
    Construct a Promise that resolves when all Promises in `fs` have resolved. If
    any Promise in `fs` fails, the error is propagated into the resulting
    Promise.

    Parameters
    ----------
    fs : [Promise]
        List of Promises to merge.

    Returns
    -------
    result : Future
        Future containing None if all Futures in `fs` succeed, or the exception
        of the first failing Future in `fs`.
    """
    return cls.collect(fs).map(lambda v: None)

  @classmethod
  def select(cls, fs):
    """
    Return a Promise containing a tuple of 2 elements. The first is the first
    Promise in `fs` to resolve; the second is all remaining Promises that may or
    may not be resolved yet. The resolved Promise is not guaranteed to have
    completed successfully.

    Parameters
    ----------
    fs : [Promise]
        List of Promises to merge.

    Returns
    -------
    result : Future
        Future containing the first Future in `fs` to finish and all remaining
        (potentially) unresolved Futures as a tuple of 2 elements for its value.
    """
    p = Promise()
    if len(fs) == 0:
      raise ValueError('Promise.select requires at least one future')
    else:
      for f in fs:
        def body(f): # Capture f for closures below
          f.respond(lambda x: p.updateifempty(Promise.value((f, filter(lambda g: g != f, fs)))))
        body(f)
    return p

  @classmethod
  def call(cls, fn, *args, **kwargs):
    """
    Call a function asynchronously and return a Promise with its result. If an
    exception is thrown inside `fn`, a new exception type will be constructed
    inheriting both from `MiraiError` and the exception's original type. The
    new exception is the same the original, except that it also contains a
    `context` attribute detailing the stack at the time the exception was
    thrown.

    Parameters
    ----------
    fn : function
        Function to be called
    *args : arguments
    **kwargs : keyword arguments

    Returns
    -------
    result : Future
        Future containing the result of `fn(*args, **kwargs)` as its value or
        the exception thrown as its exception.
    """
    return cls(cls.EXECUTOR.submit(SafeFunction(fn), *args, **kwargs)).future()

  @classmethod
  def executor(cls, executor=None, wait=True):
    """
    Set/Get the EXECUTOR Promise uses. If setting, the current executor is
    first shut down.

    Parameters
    ----------
    executor : concurrent.futures.Executor or None
        If None, retrieve the current executor, otherwise, shutdown the current
        Executor object and replace it with this argument.
    wait : bool, optional
        Whether or not to block this thread until all workers are shut down
        cleanly.

    Returns
    -------
    executor : Executor
        Current executor
    """
    if executor is None:
      return cls.EXECUTOR
    else:
      if cls.EXECUTOR is not None:
        cls.EXECUTOR.shutdown(wait=wait)
      cls.EXECUTOR = executor
      return cls.EXECUTOR


class Future(Promise):
  """Read-only version of a Promise."""

  def __init__(self, promise):
    allowed_specials = [
      '__str__',
      '__unicode__',
      '__repr__',
      '__call__',
    ]
    proxyto(self, promise, allowed_specials)

  def setvalue(self, val):
    raise AttributeError("Futures are read only; Promises are writable")

  def setexception(self, val):
    raise AttributeError("Futures are read only; Promises are writable")


########NEW FILE########
__FILENAME__ = gevent
from __future__ import absolute_import

from concurrent.futures import Future, Executor
from threading import Thread

try:
  from gevent.pool import Pool
  from gevent.thread import get_ident
except ImportError:
  raise ImportError(
    "You need to install gevent in order to use the "
    "GreenletPoolExecutor."
  )



class GreenletPoolExecutor(Executor):
  """
  A "threadpool" that uses gevent's greenlets instead of "real" threads. Unlike
  a normal ThreadPoolExecutor, a GreenletPoolExecutor can start an unlimited
  number of threads.

  Parameters
  ----------
  max_workers : None or int, optional
      Number of worker threads to allow at once. If set to None, then unlimited
      worker threads are allowed.
  """

  def __init__(self, max_workers=None):
    self.pool = Pool(size=max_workers)
    self._open = False

  def submit(self, fn, *args, **kwargs):
    """Submit a function for evaluation.

    Parameters
    ----------
    fn : function
        function to evaluate
    args : anything
        position arguments for `fn`
    kwargs : anything
        keyword arguments for `fn`

    Returns
    -------
    future : concurrent.futures.Future
        Future to encapsulate return value or exception of `fn`
    """
    if not self._open:
      raise RuntimeError(
        "GreenletPoolExecutor is already shutdown. Adding additional threads is "
        "not allowed."
      )

    future   = Future()

    def fill(greenlet):
      "Fill `future` with `greenlet`'s contents"""
      if greenlet.successful():
        future.set_value(greenlet.value)
      else:
        future.set_exception(greenlet.exception)

    greenlet = self.pool.spawn(fn, *args, **kwargs)
    greenlet.link(fill)

    return future

  def shutdown(self, wait=True):
    """Prevent more tasks from being submitted and end all running tasks

    Parameters
    ----------
    wait : bool
        Wait for currently enqueued threads to finish gracefully. If false, a
        `GreenletExit` exception is raised within each running thread.
    """
    if wait:
      self.pool.join()
    else:
      self.pool.kill(block=False)
    self._open = True


class Thread(Thread_):
  """
  Mask a normal Thread with a gevent powered one, without actually messing with
  the `thread` module (as `gevent.monkey` does).

  Parameters
  ----------
  group : None or str, optional
      unused
  target : None or function, optional
      function to invoke when `Thread.run` is called
  name : None or str, optional
      name for this thread
  args : tuple, optional
      positional arguments to pass to `target`
  kwargs : dict, optional
      keyword arguments to pass to `target`
  """

  def __init__(group=None, target=None, name=None, args=(), kwargs={}):
    self.group  = group
    self.target = target
    self.name   = name
    self.args   = args
    self.kwargs = kwargs
    self.daemon = False   # doesn't actually do anything

    self._greenlet = Greenlet(self.run)

  def start(self):
    self._greenlet.start()

  def run(self):
    if self.target is not None:
      return self.target(*self.args, **self.kwargs)

  def join(self, timeout=None):
    self._greenlet.join(timeout=timeout)

  def getName(self):
    return self.name

  def setName(self, name):
    self.name = name

  @property
  def ident(self):
    return get_ident(self._greenlet)

  def is_alive(self):
    return self._greenlet.ready()

  def isAlive(self):
    return self.is_alive()


########NEW FILE########
__FILENAME__ = pool
from threading import Thread
from concurrent.futures import Executor, ThreadPoolExecutor, Future


class UnboundedThreadPoolExecutor(Executor):
  """
  A thread pool with an infinite number of threads.

  This interface conforms to the typical `concurrent.futures.Executor`
  interface, but doesn't limit the user to a finite number of threads. In
  normal situations, this is undesirable -- too many threads, and your program
  will spend more time switching contexts than actually working!

  On the other hand, if you patch the `thread` module with `gevent`, spawning
  tens of thousands of threads is totally OK. This is where this executor comes
  in.

  Parameters
  ----------
  max_workers: None or int, optional
      Number of worker threads. If None, a new thread is created every time a
      new task is submitted. If an integer, this executor acts exactly like a
      normal `concurrent.futures.ThreadPoolExecutor`.
  """

  def __init__(self, max_workers=None):
    self._open       = True
    self.max_workers = max_workers

    if max_workers is None:
      self._pool = None
    else:
      # finite number of workers? just use a ThreadPoolExecutor
      self._pool = ThreadPoolExecutor(max_workerss)

  def submit(self, fn, *args, **kwargs):
    """Submit a new task to be executed asynchronously.

    If `self.max_workers` is an integer, then the behavior of this function
    will be identical to that of `concurrent.futures.ThreadPoolExecutor`.
    However, if it is None, then a new daemonized thread will be constructed
    and started.

    Parameters
    ----------
    fn : function-like
        function (or callable object) to execute asynchronously.
    args : list
        positional arguments to pass to `fn`.
    kwargs: dict
        keyword arguments to pass to `fn`.

    Returns
    -------
    future : concurrent.futures.Future
        Container for future result or exception
    """
    if not hasattr(fn, '__call__'):
      raise ValueError("`fn` argument isn't callable!")

    if not self._open:
      raise RuntimeError(
        "UnboundedThreadPoolExecutor is already closed. You cannot submit "
        "any more tasks."
      )

    if self._pool is not None:
      return self._pool.submit(fn, *args, **kwargs)
    else:
      # future to contain output/exception
      future = Future()
      future.set_running_or_notify_cancel()

      # run function, save output
      def populate():
        try:
          future.set_result(fn(*args, **kwargs))
        except Exception as e:
          future.set_exception(e)

      # create/start a new thread not bound to any threadpool
      thread = Thread(target=populate)
      thread.daemon = True
      thread.start()

      return future

  def shutdown(self, wait=True):
    """Shutdown this thread pool, preventing future tasks from being enqueued.

    Parameters
    ----------
    wait : bool
        Wait for all running threads to finish. Only used if this pool was
        initialized with a fixed number of workers.
    """
    self._open = False
    if self._pool is not None:
      self._pool.shutdown(wait=wait)

########NEW FILE########
__FILENAME__ = test_futures
from concurrent.futures import ThreadPoolExecutor
import unittest

from mirai import *


class ExampleException(Exception):
  pass


class PromiseConstructorTests(object):
  """Constructing new Promises without any dependencies."""

  def test_value(self):
    self.assertEqual(Promise.value(1).get(0.5), 1)

  def test_exception(self):
    self.assertRaises(Exception, Promise.exception(Exception()).get)

  def test_wait(self):
    self.assertIsNone(Promise.wait(0.05).get(0.5), None)

  def test_call(self):

    def foo(a, b):
      return a+b

    # value matches
    self.assertEqual(3, Promise.call(foo, 1, b=2).get(0.5))

    # exceptions subclass appropriately
    def bar():
      raise NotImplementedError("Uh oh...")

    self.assertRaises(NotImplementedError, Promise.call(bar).get, 0.5)
    self.assertRaises(MiraiError, Promise.call(bar).get, 0.5)


class PromiseBasicTests(object):
  """Core Promise functionality: setting/getting state"""

  def test_setvalue(self):
    o    = object()
    fut1 = Promise()
    fut1.setvalue(o)

    self.assertEqual(fut1.get(0.5), o)

  def test_setvalue_twice(self):
    fut1 = Promise()
    fut1.setvalue(1)

    self.assertRaises(MiraiError, fut1.setvalue, 2)

    fut2 = Promise()
    fut2.setexception(1)

    self.assertRaises(MiraiError, fut2.setvalue, 2)

  def test_setexception(self):
    e    = Exception()
    fut1 = Promise()
    fut1.setexception(e)

    self.assertRaises(Exception, fut1.get)

  def test_setexception_twice(self):
    e    = Exception()
    fut1 = Promise()
    fut1.setexception(e)

    self.assertRaises(MiraiError, fut1.setexception, e)

    fut1 = Promise()
    fut1.setvalue(1)

    self.assertRaises(MiraiError, fut1.setexception, e)

  def test_get_success(self):
    fut = Promise.value(1)

    self.assertEqual(fut.get(0.5), 1)

  def test_get_exception(self):
    class VerySpecificException(Exception): pass
    fut = Promise.exception(VerySpecificException())

    # raises the right classs
    self.assertRaises(VerySpecificException, fut.get)

  def test_isdefined(self):
    self.assertFalse(Promise().isdefined())
    self.assertTrue(Promise.value(1).isdefined())
    self.assertTrue(Promise.exception(Exception()).isdefined())

  def test_isfailure(self):
    self.assertIsNone(Promise().isfailure())
    self.assertTrue(Promise.exception(Exception()).isfailure())
    self.assertFalse(Promise.value(1).isfailure())

  def test_issuccess(self):
    self.assertIsNone(Promise().issuccess())
    self.assertFalse(Promise.exception(Exception()).issuccess())
    self.assertTrue(Promise.value(1).issuccess())

  def test_proxyto(self):
    fut1 = Promise()
    fut2 = Promise.wait(0.05).map(lambda v: 1).proxyto(fut1)

    self.assertEqual(fut1.get(0.1), 1)

    fut1 = Promise()
    fut2 = Promise.wait(0.05) \
        .flatmap(lambda v: Promise.exception(MiraiError())) \
        .proxyto(fut1)

    self.assertRaises(MiraiError, fut1.get, 0.1)


class PromiseCallbackTests(object):
  """Tests for settings callbacks"""

  def test_onsuccess_success(self):
    fut1 = Promise()
    fut2 = Promise.value(1).onsuccess(lambda v: fut1.setvalue(v))

    self.assertEqual(fut1.get(0.5), 1)

  def test_onsuccess_failure(self):
    fut1 = Promise()
    fut2 = Promise.exception(Exception()).onsuccess(lambda v: fut1.setvalue(v))

    Promise.join([fut2])

    self.assertRaises(TimeoutError, fut1.within(0).get)

  def test_onfailure_success(self):
    fut1 = Promise()
    fut2 = Promise.value(1).onfailure(lambda e: fut1.setvalue(e))

    Promise.join([fut2])

    self.assertRaises(TimeoutError, fut1.within(0).get)

  def test_onfailure_failure(self):
    e    = Exception()
    fut1 = Promise()
    fut2 = Promise.exception(e).onfailure(lambda e: fut1.setvalue(e))

    self.assertEqual(fut1.get(0.5), e)


class PromiseMapTests(object):
  """Tests for map/flatmap"""

  def test_flatmap_success(self):
    fut1 = Promise.value(1)
    fut2 = fut1.flatmap(lambda v: Promise.value(v+1))

    self.assertEqual(fut2.get(0.5), 2)

  def test_flatmap_exception(self):
    fut1 = Promise.exception(Exception())
    fut2 = fut1.flatmap(lambda v: v+1)

    self.assertRaises(Exception, fut2.get)

  def test_flatmap_raises(self):
    def uhoh(v):
      raise ExampleException(v)

    fut1 = Promise.value(1)
    fut2 = fut1.flatmap(uhoh)

    self.assertRaises(ExampleException, fut2.get, 0.1)

  def test_flatmap_badfunc(self):
    fut1 = Promise.value(1)
    fut2 = fut1.flatmap(lambda: 1)

    self.assertRaises(Exception, fut2.get, 0.1)

  def test_flatmap_nonpromise_return_value(self):
    fut1 = Promise.value(1)
    fut2 = fut1.flatmap(lambda v: 1)

    self.assertRaises(MiraiError, fut2.get, 0.1)

  def test_map_success(self):
    fut1 = Promise.value(1)
    fut2 = fut1.map(lambda v: v+1)

    self.assertEqual(fut2.get(0.5), 2)

  def test_map_failure(self):
    fut1 = Promise.exception(Exception())
    fut2 = fut1.map(lambda v: v+1)

    self.assertRaises(Exception, fut2.get, 0.1)

  def test_map_raises(self):
    def uhoh(v):
      raise Exception(v)

    fut1 = Promise.value(1)
    fut2 = fut1.map(uhoh)

    self.assertRaises(Exception, fut2.get, 0.1)

  def test_map_badfunc(self):
    fut1 = Promise.value(1)
    fut2 = fut1.map(lambda: 1)
    self.assertRaises(Exception, fut2.get, 0.1)


class PromiseMiscellaneousTests(object):
  """Other Promise methods..."""

  def test_rescue_success(self):
    fut1 = Promise.value("A")
    fut2 = fut1.rescue(lambda e: "B")

    self.assertEqual(fut2.get(0.5), "A")

  def test_rescue_failure(self):
    fut1 = Promise.exception(Exception("A"))
    fut2 = fut1.rescue(lambda e: Promise.value(e.message))

    self.assertEqual(fut2.get(0.5), "A")

  def test_rescue_nonpromise_return_value(self):
    fut1 = Promise.exception(Exception("A"))
    fut2 = fut1.rescue(lambda e: "uh oh")

    self.assertRaises(MiraiError, fut2.get, 0.5)

  def test_rescue_raises(self):
    def reraise(e):
      raise e

    fut1 = Promise.exception(Exception("A"))
    fut2 = fut1.rescue(reraise)

    self.assertRaises(Exception, fut2.get, 0.5)

  def test_rescue_badfunc(self):
    fut1 = Promise.exception(Exception("A"))
    fut2 = fut1.rescue(lambda: 1)

    self.assertRaises(Exception, fut2.get, 0.5)

  def test_within_success(self):
    fut1 = Promise.value("A")
    fut2 = fut1.within(0.5)

    self.assertEqual(fut2.get(0.5), "A")

  def test_within_failure(self):
    fut1 = Promise()
    fut2 = fut1.within(0)

    self.assertRaises(TimeoutError, fut2.get)

  def test_respond(self):
    fut1 = Promise()
    Promise.value(1).respond(lambda f: f.proxyto(fut1))

    self.assertEqual(fut1.get(0.05), 1)

    fut1 = Promise()
    Promise.exception(MiraiError()).respond(lambda f: f.proxyto(fut1))

    self.assertRaises(MiraiError, fut1.get, 0.05)

  def test_unit(self):
    self.assertIsNone(Promise.value(1).unit().get(0.05))
    self.assertRaises(Exception, Promise.exception(Exception()).unit().get, 0.05)

  def test_update(self):
    self.assertEqual(Promise().update(Promise.value(1)).get(0.01), 1)
    self.assertRaises(Exception, Promise().update(Promise.exception(Exception())).get, 0.01)
    self.assertRaises(MiraiError, Promise().update, 1)

  def test_updateifempty(self):
    # nothing/value
    self.assertEqual(Promise().updateifempty(Promise.value(1)).get(0.01), 1)

    # value/value
    self.assertEqual(Promise.value(2).updateifempty(Promise.value(1)).get(0.01), 2)

    # exception/nothing
    self.assertRaises(MiraiError,
      Promise
      .exception(MiraiError())
      .updateifempty(Promise())
      .get,
      0.05
    )

    # nothing/exception
    self.assertRaises(MiraiError,
      Promise()
      .updateifempty(Promise.exception(MiraiError()))
      .get,
      0.05
    )

    # exception/value
    self.assertRaises(MiraiError,
      Promise.exception(MiraiError())
      .updateifempty(Promise.value(1))
      .get,
      0.05
    )

    self.assertRaises(MiraiError, Promise().updateifempty, 1)

  def test_executor(self):
    old = Promise.executor()
    new = Promise.executor(ThreadPoolExecutor(max_workers=10))
    self.assertEqual(Promise.call(lambda v: v+1, 1).get(0.05), 2)


class PromiseThreadcountTests(object):
  """Tests involving a fixed number of threads"""

  def test_within_many_threads(self):
    # ensure's that within actually works, even when other threads are waiting.
    import time

    Promise.executor(ThreadPoolExecutor(max_workers=20))
    promises = [
      Promise.call(time.sleep, 0.05 if i < 5 else 0.75)
      for i in range(10)
    ]
    promise = (
      Promise.collect(promises)
      .within(0.1)
      .handle(lambda err: "yay")
    )
    self.assertEqual("yay", promise.get(0.5))

  def test_within_few_threads(self):
    # ensure that code doesn't lock up if I create far more threads than I have
    # workers.
    import time

    Promise.executor(ThreadPoolExecutor(max_workers=5))

    def another(i):
      # sleep a little, and a bunch of callbacks
      if i <= 0:
        return Promise.value("done")
      else:
        result = Promise.call(create, i-1)
        for i in range(i):
          result = result.map(lambda i: i)
        time.sleep(0.05)
        return result

    promises = [Promise.call(another, i) for i in range(10)]
    promise  = (
      Promise.collect(promises)
      .within(0.25)
      .handle(lambda err: "yay")
    )

    self.assertEqual("yay", promise.get(0.5))

  def test_select_few_threads(self):
    # this ensures that Promise.select won't cause a threadlock if all workers
    # are busy with the threads it's waiting on.
    Promise.executor(ThreadPoolExecutor(max_workers=2))

    promises = [
      Promise.select([
        Promise.wait(0.5).map(lambda v: v),
        Promise.wait(0.1).map(lambda v: "yay"),
      ])
      .flatmap(lambda (winner, losers): winner)
      for i in range(2)
    ]

    # shouldn't throw a timeout error
    Promise.collect(promises).get(2.5)


class PromiseAlternativeNamesTests(object):
  """Promise methods that are just alternative names for other methods"""

  def test_andthen(self):
    self.assertEqual(
        Promise.value(2).flatmap(lambda v: Promise.value(5)).get(0.5),
        Promise.value(2).andthen(lambda v: Promise.value(5)).get(0.5),
    )

  def test_call(self):
    self.assertEqual(Promise.value(1).get(0.5), Promise.value(1)())
    self.assertRaises(TimeoutError, Promise().get, 0.05)

  def test_ensure(self):
    fut1 = Promise()
    fut2 = Promise.value(2).ensure(lambda: fut1.setvalue(2))

    self.assertEqual(fut1.get(0.5), 2)

    fut1 = Promise()
    fut2 = Promise.exception(Exception()).ensure(lambda: fut1.setvalue(2))

    self.assertEqual(fut1.get(0.5), 2)

  def test_filter(self):
    fut1 = Promise.value(1).filter(lambda v: v != 1)
    self.assertRaises(MiraiError, fut1.get, 0.1)

    fut1 = Promise.value(1).filter(lambda v: v == 1)
    self.assertEqual(fut1.get(0.05), 1)

    fut1 = Promise.exception(MiraiError()).filter(lambda v: v == 1)
    self.assertRaises(MiraiError, fut1.get, 0.1)

  def test_foreach(self):
    fut1 = Promise()
    fut2 = Promise.value(1).foreach(lambda v: fut1.setvalue(v))

    self.assertEqual(fut1.get(0.05), 1)

    fut1 = Promise()
    fut2 = Promise.exception(Exception()).foreach(lambda v: fut1.setvalue(v))

    self.assertRaises(TimeoutError, fut1.get, 0.05)

  def test_getorelse(self):
    self.assertEqual(Promise().getorelse(0.5), 0.5)
    self.assertEqual(Promise.value(1).getorelse(0.5), 1)
    self.assertEqual(Promise.exception(Exception).getorelse(0.5), 0.5)

  def test_handle(self):
    self.assertEqual(
      Promise
        .exception(Exception("uh oh"))
        .handle(lambda e: e.message)
        .get(0.05),
      "uh oh",
    )

    self.assertEqual(
      Promise
        .value(1)
        .handle(lambda e: e.message)
        .get(0.05),
      1,
    )

  def test_select_(self):
    self.assertEqual(
      Promise.wait(0.50).flatmap(lambda v: Promise.exception(MiraiError()))
      .select_(
        Promise.wait(0.05).map(lambda v: 2),
        Promise.wait(0.90).map(lambda v: 3),
      ).get(0.40),
      2,
    )


class PromiseMergingTests(object):
  """Methods for combining Promises together"""

  def test_collect_empty(self):
    self.assertEqual(Promise.collect([]).get(0.1), [])

  def test_collect_success(self):
    fut1 = [Promise.value(1), Promise.value(2), Promise.value(3)]
    fut2 = Promise.collect(fut1).within(0.01)

    self.assertEqual(fut2.get(0.5), [1,2,3])

  def test_collect_failure(self):
    fut1 = [Promise.exception(Exception()), Promise.value(2), Promise.value(3)]
    fut2 = Promise.collect(fut1)

    self.assertRaises(Exception, fut2.get)

  def test_join_success(self):
    fut1 = [Promise.wait(0.1).map(lambda v: 0.1), Promise.value(0.1)]
    fut2 = Promise.join(fut1)

    for fut in fut1:
      self.assertEqual(fut.get(0.5), 0.1)

  def test_join_failure(self):
    fut1 = [Promise.value(0), Promise().within(0.05)]
    fut2 = Promise.join(fut1)

    self.assertRaises(TimeoutError, fut2.get)

  def test_select(self):
    fut1 = [Promise(), Promise.wait(0.05).map(lambda v: 0.05)]
    resolved, rest = Promise.select(fut1).get(0.1)

    self.assertEqual(len(rest), 1)
    self.assertEqual(resolved.get(0.5), 0.05)
    self.assertFalse(rest[0].isdefined())

  def test_join_(self):
    self.assertEqual(
      Promise.value(1).join_(Promise.value(2)).get(0.05),
      [1,2],
    )

  def test_or_(self):
    self.assertEqual(
      Promise.wait(0.05).map(lambda v: 1).or_(
        Promise.wait(0.25).map(lambda v: 2),
        Promise.wait(0.50).map(lambda v: 3),
      ).get(0.1),
      1,
    )


class FutureTests(
    unittest.TestCase
  ):
  """Tests for read-only Futures"""

  def setUp(self):
    Promise.executor(ThreadPoolExecutor(max_workers=10))

  def test_proxy(self):
    promise = Promise()
    future  = promise.future()

    self.assertRaises(
      TimeoutError,
      future.get,
      timeout=0.01,
    )

    promise.setvalue(1)

    self.assertEqual(1, future.get(timeout=0.01))

  def test_no_set(self):
    future = Promise().future()
    self.assertRaises(AttributeError, future.setvalue, 1)
    self.assertRaises(AttributeError, future.setexception, Exception())


class PromiseTests(
    PromiseConstructorTests,
    PromiseBasicTests,
    PromiseCallbackTests,
    PromiseMapTests,
    PromiseMiscellaneousTests,
    PromiseThreadcountTests,
    PromiseAlternativeNamesTests,
    PromiseMergingTests,

    unittest.TestCase,
  ):

  def setUp(self):
    Promise.executor(ThreadPoolExecutor(max_workers=10))


if __name__ == '__main__':
  unittest.main()

########NEW FILE########
__FILENAME__ = test_pool
from concurrent.futures import wait
import unittest

from mirai import Promise
from mirai.pool import *
from mirai.tests.test_futures import (
    PromiseConstructorTests,
    PromiseBasicTests,
    PromiseCallbackTests,
    PromiseMapTests,
    PromiseMiscellaneousTests,
    PromiseAlternativeNamesTests,
    PromiseMergingTests,
)


class UnboundedThreadPoolExecutorTests(unittest.TestCase):

  def setUp(self):
    self.pool = UnboundedThreadPoolExecutor()

  def test_submit(self):

    def foo(a, b, c):
      return a + b * c

    futures = [self.pool.submit(foo, i, i+1, c=i+2) for i in range(100)]
    wait(futures)
    results = [f.result() for f in futures]

    self.assertEqual(
      [foo(i, i+1, c=i+2) for i in range(100)],
      results,
    )

  def test_shutdown(self):
    self.pool.shutdown()
    self.assertRaises(RuntimeError, self.pool.submit, lambda: 1)


class UnboundedThreadPoolExecutorPromiseTests(
    PromiseConstructorTests,
    PromiseBasicTests,
    PromiseCallbackTests,
    PromiseMapTests,
    PromiseMiscellaneousTests,
    PromiseAlternativeNamesTests,
    PromiseMergingTests,

    unittest.TestCase
  ):

  def setUp(self):
    self.pool = UnboundedThreadPoolExecutor()
    Promise.executor(self.pool)

########NEW FILE########
__FILENAME__ = utils

def proxyto(target, source, allowed_specials=[]):
  """Proxy all attributes to another object.

  Copies all attributes from `source` to `target`, excepting "special"
  methods (those with leading and trailing double-underscores).
  `allowed_specials` allows you to whitelist selected special methods.

  Parameters
  ----------
  target : object
      object to copy attributes to
  source : object
      object to copy attributes from
  allowed_specials : [str], optional
      names of special methods to copy.

  Returns
  -------
  target : object
  """

  # set all non-hidden methods
  for k in dir(source):
    k_is_special = k.startswith("__") and k.endswith("__")
    copy_k       = not k_is_special or k in allowed_specials
    if not hasattr(target, k) and copy_k:
      setattr(target, k, getattr(source, k))

  return target

########NEW FILE########
__FILENAME__ = _version
__version__ = '0.1.4-SNAPSHOT'

########NEW FILE########
