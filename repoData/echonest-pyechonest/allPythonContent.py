__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# pyechonest documentation build configuration file, created by
# sphinx-quickstart on Thu Sep 30 15:51:03 2010.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os, inspect

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))
sys.path.insert(0,os.path.abspath("../../pyechonest"))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.intersphinx', 'sphinx.ext.coverage', 'sphinx.ext.ifconfig']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'contents'

# General information about the project.
project = u'pyechonest'
copyright = u'2013, The Echo Nest'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '8.0.0'
# The full version, including alpha/beta/rc tags.
release = '8.0.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
# html_theme_path = ['themes/']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
html_logo = '200x160_lt.png'

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
# html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
html_additional_pages = {
    "index": "index.html",
}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'pyechonestdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'pyechonest.tex', u'pyechonest Documentation',
   u'The Echo Nest', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'pyechonest', u'pyechonest Documentation',
     [u'The Echo Nest'], 1)
]


# -- Options for Epub output ---------------------------------------------------

# Bibliographic Dublin Core info.
epub_title = u'pyechonest'
epub_author = u'The Echo Nest'
epub_publisher = u'The Echo Nest'
epub_copyright = u'2012, The Echo Nest'

# The language of the text. It defaults to the language option
# or en if the language is not set.
#epub_language = ''

# The scheme of the identifier. Typical schemes are ISBN or URL.
#epub_scheme = ''

# The unique identifier of the text. This can be a ISBN number
# or the project homepage.
#epub_identifier = ''

# A unique identification for the text.
#epub_uid = ''

# HTML files that should be inserted before the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_pre_files = []

# HTML files shat should be inserted after the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_post_files = []

# A list of files that should not be packed into the epub file.
#epub_exclude_files = []

# The depth of the table of contents in toc.ncx.
#epub_tocdepth = 3

# Allow duplicate toc entries.
#epub_tocdup = True


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/': None}

# don't document the properties!
def maybe_skip_member(app, what, name, obj, skip, options):
    if what == 'module':
        return False
    else:
        return not inspect.ismethod(obj)

def setup(app):
    app.connect('autodoc-skip-member', maybe_skip_member)

########NEW FILE########
__FILENAME__ = show_tempos
# Shows the tempos for all of the songs in a directory
# requires eyeD3, available from http://eyed3.nicfit.net/

import sys
import os
import tempo

from pyechonest import track

def show_tempo(mp3):
    "given an mp3, print out the artist, title and tempo of the song"
    pytrack = track.track_from_filename(mp3)
    print 'File:  ', mp3
    print 'Artist:', pytrack.artist if hasattr(pytrack, 'artist') else 'Unknown'
    print 'Title: ', pytrack.title if hasattr(pytrack, 'title') else 'Unknown'
    print 'Tempo: ', pytrack.tempo 
    print


def show_tempos(dir):
    "print out the tempo for each MP3 in the give directory"
    for f in os.listdir(dir):
        if f.lower().endswith(".mp3"):
            path = os.path.join(dir, f)
            show_tempo(path)


if __name__ == '__main__':
    if len(sys.argv) == 1:
        print 'usage: python show_tempos.py path'
    else:
        show_tempos(sys.argv[1])

########NEW FILE########
__FILENAME__ = tempo
import sys
from pyechonest import song

def get_tempo(artist, title):
    "gets the tempo for a song"
    results = song.search(artist=artist, title=title, results=1, buckets=['audio_summary'])
    if len(results) > 0:
        return results[0].audio_summary['tempo']
    else:
        return None


if __name__ == '__main__':
    if len(sys.argv) <> 3:
        print "Usage: python tempo.py 'artist name' 'song title'"
    else:
        tempo = get_tempo(sys.argv[1], sys.argv[2])
        if tempo:
            print 'Tempo for', sys.argv[1], sys.argv[2], 'is', tempo
        else:
            print "Can't find Tempo for artist:", sys.argv[1], 'song:', sys.argv[2]
        


########NEW FILE########
__FILENAME__ = try_new_things
#!/usr/bin/env python
# encoding: utf-8

"""
Copyright (c) 2010 The Echo Nest. All rights reserved.
Created by Tyler Williams on 2010-09-01

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
"""

# ========================
# = try_new_things.py =
# ========================
#
# enter a few of your favorite artists and create a playlist of new music that 
# you might like. 
#

import sys, os, logging
import xml.sax.saxutils as saxutils
from optparse import OptionParser
from pyechonest import artist, playlist

# set your api key here if it's not set in the environment
# config.ECHO_NEST_API_KEY = "XXXXXXXXXXXXXXXXX"
logger = logging.getLogger(__name__)

class XmlWriter(object):
    """ code from: http://users.musicbrainz.org/~matt/xspf/m3u2xspf
        Copyright (c) 2006, Matthias Friedrich <matt@mafr.de>
    """
    def __init__(self, outStream, indentAmount='  '):
        self._out = outStream
        self._indentAmount = indentAmount
        self._stack = [ ]
    
    def prolog(self, encoding='UTF-8', version='1.0'):
        pi = '<?xml version="%s" encoding="%s"?>' % (version, encoding)
        self._out.write(pi + '\n')
    
    def start(self, name, attrs={ }):
        indent = self._getIndention()
        self._stack.append(name)
        self._out.write(indent + self._makeTag(name, attrs) + '\n')
    
    def end(self):
        name = self._stack.pop()
        indent = self._getIndention()
        self._out.write('%s</%s>\n' % (indent, name))
    
    def elem(self, name, value, attrs={ }):
        # delete attributes with an unset value
        for (k, v) in attrs.items():
            if v is None or v == '':
                del attrs[k]
        
        if value is None or value == '':
            if len(attrs) == 0:
                return
            self._out.write(self._getIndention())
            self._out.write(self._makeTag(name, attrs, True) + '\n')
        else:
            escValue = saxutils.escape(value or '')
            self._out.write(self._getIndention())
            self._out.write(self._makeTag(name, attrs))
            self._out.write(escValue)
            self._out.write('</%s>\n' % name)
    
    def _getIndention(self):
        return self._indentAmount * len(self._stack)
    
    def _makeTag(self, name, attrs={ }, close=False):
        ret = '<' + name
    
        for (k, v) in attrs.iteritems():
            if v is not None:
                v = saxutils.quoteattr(str(v))
                ret += ' %s=%s' % (k, v)
        
        if close:
            return ret + '/>'
        else:
            return ret + '>'
            

            
def write_xspf(f, tuples):
    """send me a list of (artist,title,mp3_url)"""
    xml = XmlWriter(f, indentAmount='  ')
    xml.prolog()
    xml.start('playlist', { 'xmlns': 'http://xspf.org/ns/0/', 'version': '1' })
    xml.start('trackList')
    for tupe in tuples:
        xml.start('track')
        xml.elem('creator',tupe[0])
        xml.elem('title',tupe[1])
        xml.elem('location', tupe[2])
        xml.end()
    xml.end()
    xml.end()
    f.close()


def lookup_seeds(seed_artist_names):
    seed_ids = []
    for artist_name in seed_artist_names:
        try:
            seed_ids.append("%s" % (artist.Artist(artist_name).id,))
        except Exception:
            logger.info('artist "%s" not found.' % (artist_name,))
            # we could try to do full artist search here
            # and let them choose the right artist
    logger.info('seed_ids: %s' % (seed_ids,))
    return seed_ids


def find_playlist(seed_artist_ids, playable=False):
    if playable:
        logger.info("finding playlist with audio...")
        p = playlist.static(type='artist-radio', artist_id=seed_artist_ids, variety=1, buckets=['id:7digital-US', 'tracks'], limit=True)
    else:
        logger.info("finding playlist without audio...")
        p = playlist.static(type='artist-radio', artist_id=seed_artist_ids, variety=1)
    return p



if __name__ == "__main__":
    usage = 'usage: %prog [options] "artist 1" "artist 2" ... "artist N"\n\n' \
    'example:\n' \
    '\t ./%prog "arcade fire" "feist" "broken social scene" -x -f arcade_feist_scene.xspf\n' \
    '\t ./%prog "justice" "four tet" "bitshifter" -v\n'
    
    parser = OptionParser(usage=usage)
    parser.add_option("-v", "--verbose",
                      action="store_true", dest="verbose", default=False,
                      help="say what you're doing")
    parser.add_option("-a", "--audio",
                      action="store_true", dest="audio", default=False,
                      help="fetch sample audio for songs")
    parser.add_option("-x", "--xspf",
                      action="store_true", dest="xspf", default=False,
                      help="output an xspf format playlist")
    parser.add_option("-f", "--filename",
                      metavar="FILE", help="write output to FILE")

    (options, args) = parser.parse_args()
    if len(args) < 1:
        parser.error("you must provide at least 1 seed artist!")

    # handle verbose logging
    log_level = logging.ERROR
    if options.verbose:
        log_level = logging.INFO
    logging.basicConfig(level=log_level)
    logger.setLevel(log_level)
    
    # make sure output file doesn't already exist
    if options.filename and os.path.exists(options.filename):
        logger.error("The file path: %s already exists." % (options.filename,))
        sys.exit(1)

    # resolve seed artists
    seed_ids = lookup_seeds(args)

    # find playlist
    raw_plist = find_playlist(seed_ids, playable=(options.audio or options.xspf))
    
    tuple_plist = []
    for s in raw_plist:
        name = s.artist_name
        title = s.title
        url = ""
        if options.audio:
            url = s.get_tracks('7digital-US', [{}])[0].get('preview_url')
        tuple_plist.append((name,title,url))

    # write to stdout or file specified
    fout = open(options.filename, 'w') if options.filename else sys.stdout
    if options.xspf:
        write_xspf(fout, tuple_plist)
    else:
        for tupe in tuple_plist:
            fout.write("%s - %s \t %s\n" % tupe)
    logger.info("all done!")
    sys.exit(0)
########NEW FILE########
__FILENAME__ = artist
#!/usr/bin/env python
# encoding: utf-8

"""
Copyright (c) 2010 The Echo Nest. All rights reserved.
Created by Tyler Williams on 2010-04-25.

The Artist module loosely covers http://developer.echonest.com/docs/v4/artist.html
Refer to the official api documentation if you are unsure about something.
"""
import util
from proxies import ArtistProxy, ResultList
from song import Song


class Artist(ArtistProxy):
    """
    An Artist object
    
    Attributes: 
        id (str): Echo Nest Artist ID
        
        name (str): Artist Name
        
        audio (list): Artist audio
        
        biographies (list): Artist biographies
        
        blogs (list): Artist blogs
        
        familiarity (float): Artist familiarity
        
        hotttnesss (float): Artist hotttnesss
        
        images (list): Artist images
        
        news (list): Artist news
        
        reviews (list): Artist reviews
        
        similar (list): Similar Artists
        
        songs (list): A list of song objects
        
        terms (list): Terms for an artist
        
        urls (list): Artist urls
        
        video (list): Artist video
        
        years_active (list): A list of dictionaries containing start and stop years
        
    You create an artist object like this:
    
    >>> a = artist.Artist('ARH6W4X1187B99274F')
    >>> a = artist.Artist('the national')
    >>> a = artist.Artist('musicbrainz:artist:a74b1b7f-71a5-4011-9441-d0b5e4122711')
        
    """

    def __init__(self, id, **kwargs):
        """
        Artist class
        
        Args:
            id (str): an artistw ID 
            
        Returns:
            An artist object
            
        Example:
        
        >>> a = artist.Artist('ARH6W4X1187B99274F', buckets=['hotttnesss'])
        >>> a.hotttnesss
        0.80098515900997658
        >>>
        
        """
        super(Artist, self).__init__(id, **kwargs)    
    
    def __repr__(self):
        return "<%s - %s>" % (self._object_type.encode('utf-8'), self.name.encode('utf-8'))
    
    def __str__(self):
        return self.name.encode('utf-8')
    
    def __cmp__(self, other):
        return cmp(self.id, other.id)
    
    def get_audio(self, results=15, start=0, cache=True):
        """Get a list of audio documents found on the web related to an artist
        
        Args:
        
        Kwargs:
            cache (bool): A boolean indicating whether or not the cached value should be used (if available). Defaults to True.
            
            results (int): An integer number of results to return
            
            start (int): An integer starting value for the result set
        
        Returns:
            A list of audio document dicts; list contains additional attributes 'start' and 'total'
        
        Example:

        >>> a = artist.Artist('alphabeat')
        >>> a.get_audio()[0]
        {u'artist': u'Alphabeat',
         u'date': u'2010-04-28T01:40:45',
         u'id': u'70be4373fa57ac2eee8c7f30b0580899',
         u'length': 210.0,
         u'link': u'http://iamthecrime.com',
         u'release': u'The Beat Is...',
         u'title': u'DJ',
         u'url': u'http://iamthecrime.com/wp-content/uploads/2010/04/03_DJ_iatc.mp3'}
        >>> 
        """
        
        if cache and ('audio' in self.cache) and results==15 and start==0:
            return self.cache['audio']
        else:
            response = self.get_attribute('audio', results=results, start=start)
            if results==15 and start==0:
                self.cache['audio'] = ResultList(response['audio'], 0, response['total'])
            return ResultList(response['audio'], start, response['total'])
    
    audio = property(get_audio)
    
    def get_biographies(self, results=15, start=0, license=None, cache=True):
        """Get a list of artist biographies
        
        Args:
        
        Kwargs:
            cache (bool): A boolean indicating whether or not the cached value should be used (if available). Defaults to True.
            
            results (int): An integer number of results to return
            
            start (int): An integer starting value for the result set
            
            license (str): A string specifying the desired license type
        
        Returns:
            A list of biography document dicts; list contains additional attributes 'start' and 'total'
            
        Example:

        >>> a = artist.Artist('britney spears')
        >>> bio = a.get_biographies(results=1)[0]
        >>> bio['url']
        u'http://www.mtvmusic.com/spears_britney'
        >>> 
        """
        if cache and ('biographies' in self.cache) and results==15 and start==0 and license==None:
            return self.cache['biographies']
        else:
            response = self.get_attribute('biographies', results=results, start=start, license=license)
            if results==15 and start==0 and license==None:
                self.cache['biographies'] = ResultList(response['biographies'], 0, response['total'])
            return ResultList(response['biographies'], start, response['total'])
    
    biographies = property(get_biographies)    
    
    def get_blogs(self, results=15, start=0, cache=True, high_relevance=False):
        """Get a list of blog articles related to an artist
        
        Args:
            
        Kwargs:
            cache (bool): A boolean indicating whether or not the cached value should be used (if available). Defaults to True.
            
            results (int): An integer number of results to return
            
            start (int): An ingteger starting value for the result set
        
        Returns:
            A list of blog document dicts; list contains additional attributes 'start' and 'total'
        
        Example:
        
        >>> a = artist.Artist('bob marley')
        >>> blogs = a.get_blogs(results=1,start=4)
        >>> blogs.total
        4068
        >>> blogs[0]['summary']
        But the Kenyans I know relate to music about the same way Americans do. They like their Congolese afropop, 
        and I've known some to be big fans of international acts like <span>Bob</span> <span>Marley</span> and Dolly Parton. 
        They rarely talk about music that's indigenous in the way a South African or Malian or Zimbabwean would, and it's 
        even rarer to actually hear such indigenous music. I do sometimes hear ceremonial chanting from the Maasai, but only 
        when they're dancing for tourists. If East Africa isn't the most musical part ... "
        >>> 
        """

        if cache and ('blogs' in self.cache) and results==15 and start==0 and not high_relevance:
            return self.cache['blogs']
        else:
            high_relevance = 'true' if high_relevance else 'false'
            response = self.get_attribute('blogs', results=results, start=start, high_relevance=high_relevance)
            if results==15 and start==0:
                self.cache['blogs'] = ResultList(response['blogs'], 0, response['total'])
            return ResultList(response['blogs'], start, response['total'])
    
    blogs = property(get_blogs)
       
    def get_familiarity(self, cache=True):
        """Get our numerical estimation of how familiar an artist currently is to the world
        
        Args:
        
        Kwargs:
            cache (bool): A boolean indicating whether or not the cached value should be used (if available). Defaults to True.
        
        Returns:
            A float representing familiarity.
        
        Example:

        >>> a = artist.Artist('frank sinatra')
        >>> a.get_familiarity()
        0.65142555825947457
        >>> a.familiarity
        0.65142555825947457
        >>>
        """
        if not (cache and ('familiarity' in self.cache)):
            response = self.get_attribute('familiarity')
            self.cache['familiarity'] = response['artist']['familiarity']
        return self.cache['familiarity']
    
    familiarity = property(get_familiarity)    

    def get_foreign_id(self, idspace='musicbrainz', cache=True):
        """Get the foreign id for this artist for a specific id space
        
        Args:
        
        Kwargs:
            idspace (str): A string indicating the idspace to fetch a foreign id for.
        
        Returns:
            A foreign ID string
        
        Example:
        
        >>> a = artist.Artist('fabulous')
        >>> a.get_foreign_id('7digital')
        u'7digital:artist:186042'
        >>> 
        """
        if not (cache and ('foreign_ids' in self.cache) and filter(lambda d: d.get('catalog') == idspace, self.cache['foreign_ids'])):
            response = self.get_attribute('profile', bucket=['id:'+idspace])
            foreign_ids = response['artist'].get("foreign_ids", [])
            self.cache['foreign_ids'] = self.cache.get('foreign_ids', []) + foreign_ids
        cval = filter(lambda d: d.get('catalog') == idspace, self.cache.get('foreign_ids'))
        return cval[0].get('foreign_id') if cval else None
    
    def get_twitter_id(self, cache=True):
        """Get the twitter id for this artist if it exists

        Args:

        Kwargs:

        Returns:
            A twitter ID string

        Example:

        >>> a = artist.Artist('big boi')
        >>> a.get_twitter_id()
        u'BigBoi'
        >>>
        """
        if not (cache and ('twitter' in self.cache)):
            response = self.get_attribute('twitter')
            self.cache['twitter'] = response['artist'].get('twitter')
        return self.cache['twitter']
            
    def get_hotttnesss(self, cache=True):
        """Get our numerical description of how hottt an artist currently is
        
        Args:
            
        Kwargs:
            cache (bool): A boolean indicating whether or not the cached value should be used (if available). Defaults to True.
        
        Returns:
            float: the hotttnesss value
        
        Example:
        
        >>> a = artist.Artist('hannah montana')
        >>> a.get_hotttnesss()
        0.59906022155998995
        >>> a.hotttnesss
        0.59906022155998995
        >>>
        """
        if not (cache and ('hotttnesss' in self.cache)):
            response = self.get_attribute('hotttnesss')
            self.cache['hotttnesss'] = response['artist']['hotttnesss']
        return self.cache['hotttnesss']
    
    hotttnesss = property(get_hotttnesss)
    
    def get_images(self, results=15, start=0, license=None, cache=True):
        """Get a list of artist images
        
        Args:
            cache (bool): A boolean indicating whether or not the cached value should be used (if available). Defaults to True.
            
            results (int): An integer number of results to return
            
            start (int): An integer starting value for the result set
            
            license (str): A string specifying the desired license type
        
        Returns:
            A list of image document dicts; list contains additional attributes 'start' and 'total'
        
        Example:
        
        >>> a = artist.Artist('Captain Beefheart')
        >>> images = a.get_images(results=1)
        >>> images.total
        49
        >>> images[0]['url']
        u'http://c4.ac-images.myspacecdn.com/images01/5/l_e1a329cdfdb16a848288edc6d578730f.jpg'
        >>> 
        """
        
        if cache and ('images' in self.cache) and results==15 and start==0 and license==None:
            return self.cache['images']
        else:
            response = self.get_attribute('images', results=results, start=start, license=license)
            total = response.get('total') or 0
            if results==15 and start==0 and license==None:
                self.cache['images'] = ResultList(response['images'], 0, total)
            return ResultList(response['images'], start, total)
    
    images = property(get_images)    

    def get_news(self, results=15, start=0, cache=True, high_relevance=False):
        """Get a list of news articles found on the web related to an artist
        
        Args:
            cache (bool): A boolean indicating whether or not the cached value should be used (if available). Defaults to True.
            
            results (int): An integer number of results to return
            
            start (int): An integer starting value for the result set

        Returns:
            A list of news document dicts; list contains additional attributes 'start' and 'total'
        
        Example:
        
        >>> a = artist.Artist('Henry Threadgill')
        >>> news = a.news
        >>> news.total
        41
        >>> news[0]['name']
        u'Jazz Journalists Association Announces 2010 Jazz Award Winners'
        >>> 
        """
        if cache and ('news' in self.cache) and results==15 and start==0 and not high_relevance:
            return self.cache['news']
        else:
            high_relevance = 'true' if high_relevance else 'false'
            response = self.get_attribute('news', results=results, start=start, high_relevance=high_relevance)
            if results==15 and start==0:
                self.cache['news'] = ResultList(response['news'], 0, response['total'])
            return ResultList(response['news'], start, response['total'])
    
    news = property(get_news)
    
    def get_reviews(self, results=15, start=0, cache=True):
        """Get reviews related to an artist's work
        
        Args:
            
        Kwargs:
            cache (bool): A boolean indicating whether or not the cached value should be used (if available). Defaults to True.
            
            results (int): An integer number of results to return
            
            start (int): An integer starting value for the result set
        
        Returns:
            A list of review document dicts; list contains additional attributes 'start' and 'total'
        
        Example:
        
        >>> a = artist.Artist('Ennio Morricone')
        >>> reviews = a.reviews
        >>> reviews.total
        17
        >>> reviews[0]['release']
        u'For A Few Dollars More'
        >>> 
        """



        if cache and ('reviews' in self.cache) and results==15 and start==0:
            return self.cache['reviews']
        else:
            response = self.get_attribute('reviews', results=results, start=start)
            if results==15 and start==0:
                self.cache['reviews'] = ResultList(response['reviews'], 0, response['total'])
            return ResultList(response['reviews'], start, response['total'])
    
    reviews = property(get_reviews)
    
    def get_similar(self, results=15, start=0, buckets=None, limit=False, cache=True, max_familiarity=None, min_familiarity=None, \
                    max_hotttnesss=None, min_hotttnesss=None, min_results=None, reverse=False, artist_start_year_before=None, \
                    artist_start_year_after=None,artist_end_year_before=None,artist_end_year_after=None):
        """Return similar artists to this one
        
        Args:
        
        Kwargs:
            cache (bool): A boolean indicating whether or not the cached value should be used (if available). Defaults to True.
            
            results (int): An integer number of results to return
            
            start (int): An integer starting value for the result set
            
            max_familiarity (float): A float specifying the max familiarity of artists to search for
            
            min_familiarity (float): A float specifying the min familiarity of artists to search for
            
            max_hotttnesss (float): A float specifying the max hotttnesss of artists to search for
            
            min_hotttnesss (float): A float specifying the max hotttnesss of artists to search for
            
            reverse (bool): A boolean indicating whether or not to return dissimilar artists (wrecommender). Defaults to False.
        
        Returns:
            A list of similar Artist objects
        
        Example:
        
        >>> a = artist.Artist('Sleater Kinney')
        >>> similars = a.similar[:5]
        >>> similars
        [<artist - Bikini Kill>, <artist - Pretty Girls Make Graves>, <artist - Huggy Bear>, <artist - Bratmobile>, <artist - Team Dresch>]
        >>> 
        """
        buckets = buckets or []
        kwargs = {}
        if max_familiarity:
            kwargs['max_familiarity'] = max_familiarity
        if min_familiarity:
            kwargs['min_familiarity'] = min_familiarity
        if max_hotttnesss:
            kwargs['max_hotttnesss'] = max_hotttnesss
        if min_hotttnesss:
            kwargs['min_hotttnesss'] = min_hotttnesss
        if min_results:
            kwargs['min_results'] = min_results
        if buckets:
            kwargs['bucket'] = buckets
        if limit:
            kwargs['limit'] = 'true'
        if reverse:
            kwargs['reverse'] = 'true'
        if artist_start_year_before:
            kwargs['artist_start_year_before'] = artist_start_year_before
        if artist_start_year_after:
            kwargs['artist_start_year_after'] = artist_start_year_after
        if artist_end_year_before:
            kwargs['artist_end_year_before'] = artist_end_year_before
        if artist_end_year_after:
            kwargs['artist_end_year_after'] = artist_end_year_after
        
        
        if cache and ('similar' in self.cache) and results==15 and start==0 and (not kwargs):
            return [Artist(**util.fix(a)) for a in self.cache['similar']]
        else:
            response = self.get_attribute('similar', results=results, start=start, **kwargs)
            if results==15 and start==0 and (not kwargs):
                self.cache['similar'] = response['artists']
            return [Artist(**util.fix(a)) for a in response['artists']]
    
    similar = property(get_similar)    
    
    def get_songs(self, cache=True, results=15, start=0):
        """Get the songs associated with an artist
        
        Args:
        
        Kwargs:
            cache (bool): A boolean indicating whether or not the cached value should be used (if available). Defaults to True.
            
            results (int): An integer number of results to return
            
            start (int): An integer starting value for the result set
            
        Results:
            A list of Song objects; list contains additional attributes 'start' and 'total'
        
        Example:

        >>> a = artist.Artist('Strokes')
        >>> a.get_songs(results=5)
        [<song - Fear Of Sleep>, <song - Red Light>, <song - Ize Of The World>, <song - Evening Sun>, <song - Juicebox>]
        >>> 
        """
        
        if cache and ('songs' in self.cache) and results==15 and start==0:
            if not isinstance(self.cache['songs'][0], Song):
                song_objects = []
                for s in self.cache["songs"]:
                    song_objects.append(Song(id=s['id'], 
                                             title=s['title'],
                                             artist_name=self.name,
                                             artist_id=self.id))
                self.cache['songs'] = song_objects
            return self.cache['songs']
        else:
            response = self.get_attribute('songs', results=results, start=start)
            for s in response['songs']:
                s.update({'artist_id':self.id, 'artist_name':self.name})
            songs = [Song(**util.fix(s)) for s in response['songs']]
            if results==15 and start==0:
                self.cache['songs'] = ResultList(songs, 0, response['total'])
            return ResultList(songs, start, response['total'])
    
    songs = property(get_songs)

    def get_terms(self, sort='weight', cache=True):
        """Get the terms associated with an artist
        
        Args:
        
        Kwargs:
            cache (bool): A boolean indicating whether or not the cached value should be used (if available). Defaults to True.
            
            sort (str): A string specifying the desired sorting type (weight or frequency)
            
        Results:
            A list of term document dicts
            
        Example:

        >>> a = artist.Artist('tom petty')
        >>> a.terms
        [{u'frequency': 1.0, u'name': u'heartland rock', u'weight': 1.0},
         {u'frequency': 0.88569401860168606,
          u'name': u'jam band',
          u'weight': 0.9116501862732439},
         {u'frequency': 0.9656145118557401,
          u'name': u'pop rock',
          u'weight': 0.89777934440040685},
         {u'frequency': 0.8414744288140491,
          u'name': u'southern rock',
          u'weight': 0.8698567153186606},
         {u'frequency': 0.9656145118557401,
          u'name': u'hard rock',
          u'weight': 0.85738022655218893},
         {u'frequency': 0.88569401860168606,
          u'name': u'singer-songwriter',
          u'weight': 0.77427243392312772},
         {u'frequency': 0.88569401860168606,
          u'name': u'rock',
          u'weight': 0.71158718989399083},
         {u'frequency': 0.60874110500110956,
          u'name': u'album rock',
          u'weight': 0.69758668733499629},
         {u'frequency': 0.74350792060935744,
          u'name': u'psychedelic',
          u'weight': 0.68457367494207944},
         {u'frequency': 0.77213698386292873,
          u'name': u'pop',
          u'weight': 0.65039556639337293},
         {u'frequency': 0.41747136183050298,
          u'name': u'bar band',
          u'weight': 0.54974975024767025}]
        >>> 

        """
        if cache and ('terms' in self.cache) and sort=='weight':
            return self.cache['terms']
        else:
            response = self.get_attribute('terms', sort=sort)
            if sort=='weight':
                self.cache['terms'] = response['terms']
            return response['terms']
    
    terms = property(get_terms)
    
    def get_urls(self, cache=True):
        """Get the urls for an artist
        
        Args:
        
        Kwargs:
            cache (bool): A boolean indicating whether or not the cached value should be used (if available). Defaults to True.
            
        Results:
            A url document dict
            
        Example:

        >>> a = artist.Artist('the unicorns')
        >>> a.get_urls()
        {u'amazon_url': u'http://www.amazon.com/gp/search?ie=UTF8&keywords=The Unicorns&tag=httpechonecom-20&index=music',
         u'aolmusic_url': u'http://music.aol.com/artist/the-unicorns',
         u'itunes_url': u'http://itunes.com/TheUnicorns',
         u'lastfm_url': u'http://www.last.fm/music/The+Unicorns',
         u'mb_url': u'http://musicbrainz.org/artist/603c5f9f-492a-4f21-9d6f-1642a5dbea2d.html',
         u'myspace_url': u'http://www.myspace.com/iwasbornunicorn'}
        >>> 

        """
        if not (cache and ('urls' in self.cache)):
            response = self.get_attribute('urls')
            self.cache['urls'] = response['urls']
        return self.cache['urls']
    
    urls = property(get_urls)    
    
    def get_video(self, results=15, start=0, cache=True):
        """Get a list of video documents found on the web related to an artist
        
        Args:
        
        Kwargs:
            cache (bool): A boolean indicating whether or not the cached value should be used (if available). Defaults to True.
            
            results (int): An integer number of results to return
            
            start (int): An integer starting value for the result set
        
        Returns:
            A list of video document dicts; list contains additional attributes 'start' and 'total'
            
        Example:

        >>> a = artist.Artist('the vapors')
        >>> a.get_video(results=1, start=2)
        [{u'date_found': u'2009-12-28T08:27:48',
          u'id': u'd02f9e6dc7904f70402d4676516286b9',
          u'image_url': u'http://i1.ytimg.com/vi/p6c0wOFL3Us/default.jpg',
          u'site': u'youtube',
          u'title': u'The Vapors-Turning Japanese (rectangular white vinyl promo)',
          u'url': u'http://youtube.com/watch?v=p6c0wOFL3Us'}]
        >>> 

        """
        if cache and ('video' in self.cache) and results==15 and start==0:
            return self.cache['video']
        else:
            response = self.get_attribute('video', results=results, start=start)
            if results==15 and start==0:
                self.cache['video'] = ResultList(response['video'], 0, response['total'])
            return ResultList(response['video'], start, response['total'])
    
    video = property(get_video)

    def get_years_active(self, cache=True):
        """Get a list of years active dictionaries for an artist
        
        Args:
        
        Kwargs:
            cache (bool): A boolean indicating whether or not the cached value should be used (if available). Defaults to True.
        
        Returns:
            A list of years active dictionaries; list contains additional attributes 'start' and 'total'
            
        Example:

        >>> a = artist.Artist('yelle')
        >>> a.get_years_active()
        [{ start: 2005 }]
        >>> 

        """
        if cache and ('years_active' in self.cache):
            return self.cache['years_active']
        else:
            response = self.get_attribute('profile', bucket=['years_active'])
            self.cache['years_active'] = response['artist']['years_active']
            return response['artist']['years_active']
    
    years_active = property(get_years_active)
    
    def get_doc_counts(self, cache=True):
        """
        Get the number of related documents of various types for the artist.
        The types include audio, biographies, blogs, images, news, reviews, songs, videos.
        
        Note that these documents can be retrieved by calling artist.<document type>, for example,
        artist.biographies.
        
        Args:
        
        Kwargs:
            cache (bool): A boolean indicating whether or not the cached value should be used (if available).
            Defaults to True.
        
        Returns:
            A dictionary with one key for each document type, mapped to an integer count of documents.
        
        Example:
        
        >>> a = artist.Artist("The Kinks")

        >>> a.get_doc_counts()
        {u'audio': 194,
         u'biographies': 9,
         u'blogs': 379,
         u'images': 177,
         u'news': 84,
         u'reviews': 110,
         u'songs': 499,
         u'videos': 340}
         >>>
        """
        if not cache or not ('doc_counts' in self.cache):
            response = self.get_attribute("profile", bucket='doc_counts')
            self.cache['doc_counts'] = response['artist']['doc_counts']
        return self.cache['doc_counts']
    
    doc_counts = property(get_doc_counts)

def search(name=None, description=None, style=None, mood=None, start=0, \
            results=15, buckets=None, limit=False, \
            fuzzy_match=False, sort=None, max_familiarity=None, min_familiarity=None, \
            max_hotttnesss=None, min_hotttnesss=None, test_new_things=None, rank_type=None, \
            artist_start_year_after=None, artist_start_year_before=None,artist_end_year_after=None,artist_end_year_before=None):
    """Search for artists by name, description, or constraint.
    
    Args:
    
    Kwargs:
        name (str): the name of an artist
        
        description (str): A string describing the artist
        
        style (str): A string describing the style/genre of the artist
        
        mood (str): A string describing the mood of the artist
        
        start (int): An integer starting value for the result set

        results (int): An integer number of results to return
        
        buckets (list): A list of strings specifying which buckets to retrieve
        
        limit (bool): A boolean indicating whether or not to limit the results to one of the id spaces specified in buckets
        
        fuzzy_match (bool): A boolean indicating whether or not to search for similar sounding matches (only works with name)
        
        max_familiarity (float): A float specifying the max familiarity of artists to search for
        
        min_familiarity (float): A float specifying the min familiarity of artists to search for
        
        max_hotttnesss (float): A float specifying the max hotttnesss of artists to search for
        
        min_hotttnesss (float): A float specifying the max hotttnesss of artists to search for
        
        artist_start_year_before (int): Returned artists will have started recording music before this year.
        
        artist_start_year_after (int): Returned artists will have started recording music after this year.
        
        artist_end_year_before (int): Returned artists will have stopped recording music before this year.
        
        artist_end_year_after (int): Returned artists will have stopped recording music after this year.
        
        rank_type (str): A string denoting the desired ranking for description searches, either 'relevance' or 'familiarity'

    Returns:
        A list of Artist objects
    
    Example:
    
    >>> results = artist.search(name='t-pain')
    >>> results
    [<artist - T-Pain>, <artist - T-Pain & Lil Wayne>, <artist - T Pain & 2 Pistols>, <artist - Roscoe Dash & T-Pain>, <artist - Tony Moxberg & T-Pain>, <artist - Flo-Rida (feat. T-Pain)>, <artist - Shortyo/Too Short/T-Pain>]
    >>> 

    """
    limit = str(limit).lower()
    fuzzy_match = str(fuzzy_match).lower()
    kwargs = locals()
    kwargs['bucket'] = buckets or []
    del kwargs['buckets']
    """Search for artists"""
    result = util.callm("%s/%s" % ('artist', 'search'), kwargs)
    return [Artist(**util.fix(a_dict)) for a_dict in result['response']['artists']]

def top_hottt(start=0, results=15, buckets = None, limit=False):
    """Get the top hotttest artists, according to The Echo Nest
    
    Args:
    
    Kwargs:
        results (int): An integer number of results to return
        
        start (int): An integer starting value for the result set
        
        buckets (list): A list of strings specifying which buckets to retrieve
        
        limit (bool): A boolean indicating whether or not to limit the results to one of the id spaces specified in buckets
        
    Returns:
        A list of hottt Artist objects

    Example:

    >>> hot_stuff = artist.top_hottt()
    >>> hot_stuff
    [<artist - Deerhunter>, <artist - Sufjan Stevens>, <artist - Belle and Sebastian>, <artist - Glee Cast>, <artist - Linkin Park>, <artist - Neil Young>, <artist - Jimmy Eat World>, <artist - Kanye West>, <artist - Katy Perry>, <artist - Bruno Mars>, <artist - Lady Gaga>, <artist - Rihanna>, <artist - Lil Wayne>, <artist - Jason Mraz>, <artist - Green Day>]
    >>> 

    """
    buckets = buckets or []
    kwargs = {}
    if start:
        kwargs['start'] = start
    if results:
        kwargs['results'] = results
    if buckets:
        kwargs['bucket'] = buckets
    if limit:
        kwargs['limit'] = 'true'
    
    """Get top hottt artists"""
    result = util.callm("%s/%s" % ('artist', 'top_hottt'), kwargs)
    return [Artist(**util.fix(a_dict)) for a_dict in result['response']['artists']]    


def top_terms(results=15):
    """Get a list of the top overall terms
        
    Args:
    
    Kwargs:
        results (int): An integer number of results to return
        
    Returns:
        A list of term document dicts
    
    Example:
    
    >>> terms = artist.top_terms(results=5)
    >>> terms
    [{u'frequency': 1.0, u'name': u'rock'},
     {u'frequency': 0.99054710039307992, u'name': u'electronic'},
     {u'frequency': 0.96131624654034398, u'name': u'hip hop'},
     {u'frequency': 0.94358477322411127, u'name': u'jazz'},
     {u'frequency': 0.94023302416455468, u'name': u'pop rock'}]
    >>> 
    """
    
    kwargs = {}
    if results:
        kwargs['results'] = results
    
    """Get top terms"""
    result = util.callm("%s/%s" % ('artist', 'top_terms'), kwargs)
    return result['response']['terms']

def list_terms(type):
    """Get a list of best terms to use with search
    
    Args:
    
    Kwargs:
        type (str): the type of term to return, either 'mood' or 'style'
    
    Example:
    
    >>> best_terms = artist.list_terms('mood')
    >>> best_terms
    [{u'name': u'aggressive'},
     {u'name': u'ambient'},
     {u'name': u'angry'},
     {u'name': u'angst-ridden'},
     {u'name': u'bouncy'},
     {u'name': u'calming'},
     {u'name': u'carefree'}, etc.]
    """
    
    kwargs = {'type': type}
    result = util.callm("%s/%s" % ('artist', 'list_terms'), kwargs)
    return result['response']['terms']
    
def list_genres():
    """Get a list of best genres to use with genre-radio playlisting
    
    Args:
    
    Example:
    
    >>> best_terms = artist.list_genres()
    >>> best_terms
    [{u'name': u'pop'},
     {u'name': u'rock'},
     {u'name': u'country'},
    """
    kwargs = {}
    result = util.callm("%s/%s" % ('artist', 'list_genres'), kwargs)
    return result['response']['genres']

def similar(names=None, ids=None, start=0, results=15, buckets=None, limit=False, max_familiarity=None, min_familiarity=None,
            max_hotttnesss=None, min_hotttnesss=None, seed_catalog=None,artist_start_year_before=None, \
            artist_start_year_after=None,artist_end_year_before=None,artist_end_year_after=None):
    """Return similar artists to this one
    
    Args:
    
    Kwargs:
        ids (str/list): An artist id or list of ids
        
        names (str/list): An artist name or list of names
        
        results (int): An integer number of results to return
        
        buckets (list): A list of strings specifying which buckets to retrieve
        
        limit (bool): A boolean indicating whether or not to limit the results to one of the id spaces specified in buckets
        
        start (int): An integer starting value for the result set
        
        max_familiarity (float): A float specifying the max familiarity of artists to search for
        
        min_familiarity (float): A float specifying the min familiarity of artists to search for
        
        max_hotttnesss (float): A float specifying the max hotttnesss of artists to search for
        
        min_hotttnesss (float): A float specifying the max hotttnesss of artists to search for
        
        seed_catalog (str): A string specifying the catalog similar artists are restricted to
    
    Returns:
        A list of similar Artist objects
    
    Example:

    >>> some_dudes = [artist.Artist('weezer'), artist.Artist('radiohead')]
    >>> some_dudes
    [<artist - Weezer>, <artist - Radiohead>]
    >>> sims = artist.similar(ids=[art.id for art in some_dudes], results=5)
    >>> sims
    [<artist - The Smashing Pumpkins>, <artist - Biffy Clyro>, <artist - Death Cab for Cutie>, <artist - Jimmy Eat World>, <artist - Nerf Herder>]
    >>> 

    """
    
    buckets = buckets or []
    kwargs = {}

    if ids:
        if not isinstance(ids, list):
            ids = [ids]
        kwargs['id'] = ids
    if names:
        if not isinstance(names, list):
            names = [names]
        kwargs['name'] = names
    if max_familiarity is not None:
        kwargs['max_familiarity'] = max_familiarity
    if min_familiarity is not None:
        kwargs['min_familiarity'] = min_familiarity
    if max_hotttnesss is not None:
        kwargs['max_hotttnesss'] = max_hotttnesss
    if min_hotttnesss is not None:
        kwargs['min_hotttnesss'] = min_hotttnesss
    if seed_catalog is not None:
        kwargs['seed_catalog'] = seed_catalog
    if start:
        kwargs['start'] = start
    if results:
        kwargs['results'] = results
    if buckets:
        kwargs['bucket'] = buckets
    if limit:
        kwargs['limit'] = 'true'
    if artist_start_year_before:
        kwargs['artist_start_year_before'] = artist_start_year_before
    if artist_start_year_after:
        kwargs['artist_start_year_after'] = artist_start_year_after
    if artist_end_year_before:
        kwargs['artist_end_year_before'] = artist_end_year_before
    if artist_end_year_after:
        kwargs['artist_end_year_after'] = artist_end_year_after


    result = util.callm("%s/%s" % ('artist', 'similar'), kwargs)
    return [Artist(**util.fix(a_dict)) for a_dict in result['response']['artists']]

def extract(text='', start=0, results=15, buckets=None, limit=False, max_familiarity=None, min_familiarity=None,
                max_hotttnesss=None, min_hotttnesss=None):
    """Extract artist names from a block of text.
    
    Args:
    
    Kwargs:
        text (str): The text to extract artists from
    
        start (int): An integer starting value for the result set
    
        results (int): An integer number of results to return
    
        buckets (list): A list of strings specifying which buckets to retrieve
    
        limit (bool): A boolean indicating whether or not to limit the results to one of the id spaces specified in buckets
    
        max_familiarity (float): A float specifying the max familiarity of artists to search for
    
        min_familiarity (float): A float specifying the min familiarity of artists to search for
    
        max_hotttnesss (float): A float specifying the max hotttnesss of artists to search for
    
        min_hotttnesss (float): A float specifying the max hotttnesss of artists to search for
    
    Returns:
        A list of Artist objects
    
    Example:
    
    >>> results = artist.extract(text='i saw beyonce at burger king, she was eatin, she was eatin')
    >>> results

    >>> 
    
    """

    buckets = buckets or []
    kwargs = {}
    
    kwargs['text'] = text
    
    if max_familiarity is not None:
        kwargs['max_familiarity'] = max_familiarity
    if min_familiarity is not None:
        kwargs['min_familiarity'] = min_familiarity
    if max_hotttnesss is not None:
        kwargs['max_hotttnesss'] = max_hotttnesss
    if min_hotttnesss is not None:
        kwargs['min_hotttnesss'] = min_hotttnesss
    if start:
        kwargs['start'] = start
    if results:
        kwargs['results'] = results
    if buckets:
        kwargs['bucket'] = buckets
    if limit:
        kwargs['limit'] = 'true'
    
    result = util.callm("%s/%s" % ('artist', 'extract'), kwargs)
    
    return [Artist(**util.fix(a_dict)) for a_dict in result['response']['artists']]


def suggest(q='', results=15, buckets=None, limit=False, max_familiarity=None, min_familiarity=None,
                max_hotttnesss=None, min_hotttnesss=None):
    """Suggest artists based upon partial names.

    Args:

    Kwargs:
        q (str): The text to suggest artists from

        results (int): An integer number of results to return

        buckets (list): A list of strings specifying which buckets to retrieve

        limit (bool): A boolean indicating whether or not to limit the results to one of the id spaces specified in buckets

        max_familiarity (float): A float specifying the max familiarity of artists to search for

        min_familiarity (float): A float specifying the min familiarity of artists to search for

        max_hotttnesss (float): A float specifying the max hotttnesss of artists to search for

        min_hotttnesss (float): A float specifying the max hotttnesss of artists to search for

    Returns:
        A list of Artist objects

    Example:

    >>> results = artist.suggest(text='rad')
    >>> results

    >>> 

    """

    buckets = buckets or []
    kwargs = {}

    kwargs['q'] = q

    if max_familiarity is not None:
        kwargs['max_familiarity'] = max_familiarity
    if min_familiarity is not None:
        kwargs['min_familiarity'] = min_familiarity
    if max_hotttnesss is not None:
        kwargs['max_hotttnesss'] = max_hotttnesss
    if min_hotttnesss is not None:
        kwargs['min_hotttnesss'] = min_hotttnesss
    if results:
        kwargs['results'] = results
    if buckets:
        kwargs['bucket'] = buckets
    if limit:
        kwargs['limit'] = 'true'

    result = util.callm("%s/%s" % ('artist', 'suggest'), kwargs)

    return [Artist(**util.fix(a_dict)) for a_dict in result['response']['artists']]

########NEW FILE########
__FILENAME__ = catalog
#!/usr/bin/env python
# encoding: utf-8

"""
Copyright (c) 2010 The Echo Nest. All rights reserved.
Created by Scotty Vercoe on 2010-08-25.

The Catalog module loosely covers http://developer.echonest.com/docs/v4/catalog.html
Refer to the official api documentation if you are unsure about something.
"""
try:
    import json
except ImportError:
    import simplejson as json
import datetime

import warnings
import util
from proxies import CatalogProxy, ResultList
import artist, song

# deal with datetime in json
dthandler = lambda obj: obj.isoformat() if isinstance(obj, datetime.datetime) else None

def create_catalog_by_name(name, T="general"):
    """
    Creates a catalog object, with a given name. Does not check to see if the catalog already exists.

    Create a catalog object like
    """
    result = util.callm("catalog/create", {}, POST=True, 
                            data={"name":name, "type":T})
    result = result['response']
    return Catalog(result['id'], **dict( (k,result[k]) for k in ('name', 'type')))

class Catalog(CatalogProxy):
    """
    A Catalog object

    Attributes:
        id (str): Catalog ID

        name (str): Catalog Name

        read (list): A list of catalog items (objects if they are resolved, else dictionaries)

        feed (list): A list of dictionaries for news, blogs, reviews, audio, video for a catalog's artists

    Create an catalog object like so:

    >>> c = catalog.Catalog('CAGPXKK12BB06F9DE9') # get existing catalog
    >>> c = catalog.Catalog('test_song_catalog', 'song') # get existing or create new catalog

    """
    def __init__(self, id, type=None, **kwargs):
        """
        Create a catalog object (get a catalog by ID or get or create one given by name and type)

        Args:
            id (str): A catalog id or name

        Kwargs:
            type (str): 'song' or 'artist', specifying the catalog type

        Returns:
            A catalog object

        Example:

        >>> c = catalog.Catalog('my_songs', type='song')
        >>> c.id
        u'CAVKUPC12BCA792120'
        >>> c.name
        u'my_songs'
        >>>

        """
        super(Catalog, self).__init__(id, type, **kwargs)

    def __repr__(self):
        return "<%s - %s>" % (self._object_type.encode('utf-8'), self.name.encode('utf-8'))

    def __str__(self):
        return self.name.encode('utf-8')

    def update(self, items):
        """
        Update a catalog object

        Args:
            items (list): A list of dicts describing update data and action codes (see api docs)

        Kwargs:

        Returns:
            A ticket id

        Example:

        >>> c = catalog.Catalog('my_songs', type='song')
        >>> items
        [{'action': 'update',
          'item': {'artist_name': 'dAn ThE aUtOmAtOr',
                   'disc_number': 1,
                   'genre': 'Instrumental',
                   'item_id': '38937DDF04BC7FC4',
                   'play_count': 5,
                   'release': 'Bombay the Hard Way: Guns, Cars & Sitars',
                   'song_name': 'Inspector Jay From Dehli',
                   'track_number': 9,
                   'url': 'file://localhost/Users/tylerw/Music/iTunes/iTunes%20Media/Music/Dan%20the%20Automator/Bombay%20the%20Hard%20Way_%20Guns,%20Cars%20&%20Sitars/09%20Inspector%20Jay%20From%20Dehli.m4a'}}]
        >>> ticket = c.update(items)
        >>> ticket
        u'7dcad583f2a38e6689d48a792b2e4c96'
        >>> c.status(ticket)
        {u'ticket_status': u'complete', u'update_info': []}
        >>>

        """
        post_data = {}
        items_json = json.dumps(items, default=dthandler)
        post_data['data'] = items_json

        response = self.post_attribute("update", data=post_data)

        return response['ticket']

    def status(self, ticket):
        """
        Check the status of a catalog update

        Args:
            ticket (str): A string representing a ticket ID

        Kwargs:

        Returns:
            A dictionary representing ticket status

        Example:

        >>> ticket
        u'7dcad583f2a38e6689d48a792b2e4c96'
        >>> c.status(ticket)
        {u'ticket_status': u'complete', u'update_info': []}
        >>>

        """
        return self.get_attribute_simple("status", ticket=ticket)

    def get_profile(self):
        """
        Check the status of a catalog update

        Args:

        Kwargs:

        Returns:
            A dictionary representing ticket status

        Example:

        >>> c
        <catalog - test_song_catalog>
        >>> c.profile()
        {u'id': u'CAGPXKK12BB06F9DE9',
         u'name': u'test_song_catalog',
         u'pending_tickets': [],
         u'resolved': 2,
         u'total': 4,
         u'type': u'song'}
        >>>

        """
        result = self.get_attribute("profile")
        return result['catalog']

    profile = property(get_profile)
    def read_items(self, buckets=None, results=15, start=0,item_ids=None):
        """
        Returns data from the catalog; also expanded for the requested buckets.
        This method is provided for backwards-compatibility

        Args:

        Kwargs:
            buckets (list): A list of strings specifying which buckets to retrieve

            results (int): An integer number of results to return

            start (int): An integer starting value for the result set

        Returns:
            A list of objects in the catalog; list contains additional attributes 'start' and 'total'

        Example:

        >>> c
        <catalog - my_songs>
        >>> c.read_items(results=1)
        [<song - Harmonice Mundi II>]
        >>>
        """
        warnings.warn("catalog.read_items() is depreciated. Please use catalog.get_item_dicts() instead.")
        kwargs = {}
        kwargs['bucket'] = buckets or []
        kwargs['item_id'] = item_ids or []
        response = self.get_attribute("read", results=results, start=start, **kwargs)
        rval = ResultList([])
        if item_ids:
            rval.start=0;
            rval.total=len(response['catalog']['items'])
        else:
            rval.start = response['catalog']['start']
            rval.total = response['catalog']['total']
        for item in response['catalog']['items']:
            new_item = None
            # song items
            if 'song_id' in item:
                item['id'] = item.pop('song_id')
                item['title'] = item.pop('song_name')
                request = item['request']
                new_item = song.Song(**util.fix(item))
                new_item.request = request
            # artist item
            elif 'artist_id' in item:
                item['id'] = item.pop('artist_id')
                item['name'] = item.pop('artist_name')
                request = item['request']
                new_item = artist.Artist(**util.fix(item))
                new_item.request = request
            # unresolved item
            else:
                new_item = item
            rval.append(new_item)
        return rval

    read = property(read_items)

    def get_item_dicts(self, buckets=None, results=15, start=0,item_ids=None):
        """
        Returns data from the catalog; also expanded for the requested buckets

        Args:

        Kwargs:
            buckets (list): A list of strings specifying which buckets to retrieve

            results (int): An integer number of results to return

            start (int): An integer starting value for the result set

        Returns:
            A list of dicts representing objects in the catalog; list has additional attributes 'start' and 'total'

        Example:

        >>> c
        <catalog - my_songs>
        >>> c.read_items(results=1)
        [
                {
                    "artist_id": "AR78KRI1187B98E6F2",
                    "artist_name": "Art of Noise",
                    "date_added": "2012-04-02T16:50:02",
                    "foreign_id": "CAHLYLR13674D1CF83:song:1000",
                    "request": {
                        "artist_name": "The Art Of Noise",
                        "item_id": "1000",
                        "song_name": "Love"
                    },
                    "song_id": "SOSBCTO1311AFE7AE0",
                    "song_name": "Love"
                }
        ]
        """
        kwargs = {}
        kwargs['bucket'] = buckets or []
        kwargs['item_id'] = item_ids or []
        response = self.get_attribute("read", results=results, start=start, **kwargs)
        rval = ResultList(response['catalog']['items'])
        if item_ids:
            rval.start=0;
            rval.total=len(response['catalog']['items'])
        else:
            rval.start = response['catalog']['start']
            rval.total = response['catalog']['total']
        return rval

    item_dicts = property(get_item_dicts)

    def get_feed(self, buckets=None, since=None, results=15, start=0):
        """
        Returns feed (news, blogs, reviews, audio, video) for the catalog artists; response depends on requested buckets

        Args:

        Kwargs:
            buckets (list): A list of strings specifying which feed items to retrieve

            results (int): An integer number of results to return

            start (int): An integer starting value for the result set

        Returns:
            A list of news, blogs, reviews, audio or video document dicts;

        Example:

        >>> c
        <catalog - my_artists>
        >>> c.get_feed(results=15)
	{u'date_found': u'2011-02-06T07:50:25',
	 u'date_posted': u'2011-02-06T07:50:23',
 	 u'id': u'caec686c0dff361e4c53dceb58fb9d2f',
 	 u'name': u'Linkin Park \u2013 \u201cWaiting For The End\u201d + \u201cWhen They Come For Me\u201d 2/5 SNL',
 	 u'references': [{u'artist_id': u'ARQUMH41187B9AF699',
        	          u'artist_name': u'Linkin Park'}],
	 u'summary': u'<span>Linkin</span> <span>Park</span> performed "Waiting For The End" and "When They Come For Me" on Saturday Night Live. Watch the videos below and pick up their album A Thousand Suns on iTunes, Amazon MP3, CD    Social Bookmarking ... ',
	 u'type': u'blogs',
	 u'url': u'http://theaudioperv.com/2011/02/06/linkin-park-waiting-for-the-end-when-they-come-for-me-25-snl/'}
        >>>
        """
        kwargs = {}
        kwargs['bucket'] = buckets or []
	if since:
		kwargs['since']=since
        response = self.get_attribute("feed", results=results, start=start, **kwargs)
        rval = ResultList(response['feed'])
        return rval

    feed = property(get_feed)


    def delete(self):
        """
        Deletes the entire catalog

        Args:

        Kwargs:

        Returns:
            The deleted catalog's id.

        Example:

        >>> c
        <catalog - test_song_catalog>
        >>> c.delete()
        {u'id': u'CAXGUPY12BB087A21D'}
        >>>

        """
        return self.post_attribute("delete")

    def play(self, items, plays=None):
        return self.get_attribute("play", item=items, plays=plays)

    def skip(self, items, skips=None):
        return self.get_attribute("skip", item=items, skips=skips)

    def keyvalues(self):
        return self.get_attribute("keyvalues")['keyvalues']

    def favorite(self, items, favorite=None):
        if favorite != None:
            favorite = str(favorite).lower()
        return self.get_attribute("favorite", item=items, favorite=favorite)

    def ban(self, items, ban=None):
        if ban != None:
            ban = str(ban).lower()
        return self.get_attribute("ban", item=items, ban=ban)

    def rate(self, items, rating=None):
        return self.get_attribute("rate", item=items, rating=rating)
        
def get_catalog_by_name(name):
    """
    Grabs a catalog by name, if its there on the api key.
    Otherwise, an error is thrown (mirroring the API)
    """
    kwargs = {
            'name' : name,
        }
    result = util.callm("%s/%s" % ('catalog', 'profile'), kwargs)
    return Catalog(**util.fix(result['response']['catalog']))

def list_catalogs(results=30, start=0):
    """
    Returns list of all catalogs created on this API key

    Args:

    Kwargs:
        results (int): An integer number of results to return

        start (int): An integer starting value for the result set

    Returns:
        A list of catalog objects

    Example:

    >>> catalog.list_catalogs()
    [<catalog - test_artist_catalog>, <catalog - test_song_catalog>, <catalog - my_songs>]
    >>>

    """
    result = util.callm("%s/%s" % ('catalog', 'list'), {'results': results, 'start': start})
    cats = [Catalog(**util.fix(d)) for d in result['response']['catalogs']]
    start = result['response']['start']
    total = result['response']['total']
    return ResultList(cats, start, total)


########NEW FILE########
__FILENAME__ = config
#!/usr/bin/env python
# encoding: utf-8

"""
Copyright (c) 2010 The Echo Nest. All rights reserved.
Created by Tyler Williams on 2010-04-25.

Global configuration variables for accessing the Echo Nest web API.
"""

import pkg_resources

try:
    __version__ = pkg_resources.require("pyechonest")[0].version
except pkg_resources.DistributionNotFound:
    __version__ = "0.0.0"

import sys, os

envkeys = ["ECHO_NEST_API_KEY", "ECHO_NEST_CONSUMER_KEY", "ECHO_NEST_SHARED_SECRET"]
this_module = sys.modules[__name__]
for key in envkeys:
    setattr(this_module, key, os.environ.get(key, None))

API_HOST = 'developer.echonest.com'
"The API endpoint you're talking to"

API_SELECTOR = 'api'
"API selector... just 'api' for now"

API_VERSION = 'v4'
"Version of api to use... only 4 for now"

HTTP_USER_AGENT = 'PyEchonest'
"""
You may change this to be a user agent string of your
own choosing
"""

TRACE_API_CALLS = False
"""
If true, API calls will be traced to the console
"""

CALL_TIMEOUT = 10
"""
The API call timeout (seconds)
"""

CODEGEN_BINARY_OVERRIDE = None
"""
Location of your codegen binary. If not given, we will guess codegen.platform-architecture on your system path, e.g. codegen.Darwin, codegen.Linux-i386
"""

########NEW FILE########
__FILENAME__ = playlist
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Copyright (c) 2010 The Echo Nest. All rights reserved.
Created by Tyler Williams on 2010-04-25.

The Playlist module loosely covers http://developer.echonest.com/docs/v4/playlist.html
Refer to the official api documentation if you are unsure about something.
"""

import util
from proxies import PlaylistProxy
from song import Song
import catalog
import logging
logger = logging.getLogger(__name__)


def basic(type='artist-radio', artist_id=None, artist=None, song_id=None, song=None, track_id=None, dmca=False,
          results=15, buckets=None, limit=False,genres=None,):
    """Get a basic playlist
    
    Args:
    
    Kwargs:
        type (str): a string representing the playlist type ('artist-radio' or 'song-radio')
        
        artist_id (str): the artist_id to seed the playlist
        
        artist (str): the name of an artist to seed the playlist
        
        song_id (str): a song_id to seed the playlist
        
        song (str): the name of a song to seed the playlist
        
        track_id (str): the name of a track to seed the playlist
        
        dmca (bool): make the playlist dmca-compliant
        
        results (int): desired length of the playlist
        
        buckets (list): A list of strings specifying which buckets to retrieve
        
        limit (bool): Whether results should be restricted to any idspaces given in the buckets parameter
    """

    limit = str(limit).lower()
    dmca = str(dmca).lower()

    kwargs = locals()
    kwargs['bucket'] = kwargs['buckets']
    del kwargs['buckets']
    kwargs['genre'] = kwargs['genres']
    del kwargs['genres']

    result = util.callm("%s/%s" % ('playlist', 'basic'), kwargs)
    return [Song(**util.fix(s_dict)) for s_dict in result['response']['songs']]


def static(type='artist', artist_pick='song_hotttnesss-desc', variety=.5, artist_id=None, artist=None, song_id=None,
           track_id=None, description=None, style=None, mood=None, results=15, max_tempo=None, min_tempo=None,
           max_duration=None, min_duration=None, max_loudness=None, min_loudness=None, max_danceability=None,
           min_danceability=None, max_energy=None, min_energy=None, artist_max_familiarity=None,
           artist_min_familiarity=None, artist_max_hotttnesss=None, artist_min_hotttnesss=None,
           song_max_hotttnesss=None, song_min_hotttnesss=None, min_longitude=None, max_longitude=None,
           min_latitude=None, max_latitude=None, adventurousness=0.2, mode=None, key=None, buckets=None, sort=None,
           limit=False, seed_catalog=None, source_catalog=None, rank_type=None, test_new_things=None,
           artist_start_year_after=None, artist_start_year_before=None, artist_end_year_after=None,
           artist_end_year_before=None, dmca=False, distribution=None, song_type=None, genres=None):
    """Get a static playlist
    
    Args:
    
    Kwargs:
        type (str): a string representing the playlist type ('artist', 'artist-radio', ...)
        
        artist_pick (str): How songs should be chosen for each artist
        
        variety (float): A number between 0 and 1 specifying the variety of the playlist
        
        artist_id (str): the artist_id
        
        artist (str): the name of an artist
        
        song_id (str): the song_id
        
        track_id (str): the track id
        
        description (str): A string describing the artist and song
        
        style (str): A string describing the style/genre of the artist and song
    
        mood (str): A string describing the mood of the artist and song
        
        results (int): An integer number of results to return
    
        max_tempo (float): The max tempo of song results
    
        min_tempo (float): The min tempo of song results
    
        max_duration (float): The max duration of song results
    
        min_duration (float): The min duration of song results
    
        max_loudness (float): The max loudness of song results
    
        min_loudness (float): The min loudness of song results
    
        artist_max_familiarity (float): A float specifying the max familiarity of artists to search for
    
        artist_min_familiarity (float): A float specifying the min familiarity of artists to search for
    
        artist_max_hotttnesss (float): A float specifying the max hotttnesss of artists to search for
    
        artist_min_hotttnesss (float): A float specifying the max hotttnesss of artists to search for
    
        song_max_hotttnesss (float): A float specifying the max hotttnesss of songs to search for
    
        song_min_hotttnesss (float): A float specifying the max hotttnesss of songs to search for
    
        max_energy (float): The max energy of song results
    
        min_energy (float): The min energy of song results
    
        max_danceability (float): The max danceability of song results
    
        min_danceability (float): The min danceability of song results
    
        mode (int): 0 or 1 (minor or major)
    
        key (int): 0-11 (c, c-sharp, d, e-flat, e, f, f-sharp, g, a-flat, a, b-flat, b)
    
        max_latitude (float): A float specifying the max latitude of artists to search for
    
        min_latitude (float): A float specifying the min latitude of artists to search for
    
        max_longitude (float): A float specifying the max longitude of artists to search for
    
        min_longitude (float): A float specifying the min longitude of artists to search for                        
        
        adventurousness (float): A float ranging from 0 for old favorites to 1.0 for unheard music according to a seed_catalog
    
        sort (str): A string indicating an attribute and order for sorting the results
    
        buckets (list): A list of strings specifying which buckets to retrieve
    
        limit (bool): A boolean indicating whether or not to limit the results to one of the id spaces specified in buckets
        
        seed_catalog (str or Catalog): An Artist Catalog object or Artist Catalog id to use as a seed
        
        source_catalog (str or Catalog): A Catalog object or catalog id

        rank_type (str): A string denoting the desired ranking for description searches, either 'relevance' or 'familiarity'    
        
        artist_start_year_before (int): Returned song's artists will have started recording music before this year.
        
        artist_start_year_after (int): Returned song's artists will have started recording music after this year.
        
        artist_end_year_before (int): Returned song's artists will have stopped recording music before this year.
        
        artist_end_year_after (int): Returned song's artists will have stopped recording music after this year.

        distribution (str): Affects the range of artists returned and how many songs each artist will have in the playlist relative to how similar they are to the seed. (wandering, focused)

        song_type (str):  A string or list of strings of the type of songs allowed.  The only valid song type at the moment is 'christmas'.
                          Valid formats are 'song_type', 'song_type:true', 'song_type:false', or 'song_type:any'.

    Returns:
        A list of Song objects
    
    Example:
    
    >>> p = playlist.static(type='artist-radio', artist=['ida maria', 'florence + the machine'])
    >>> p
    [<song - Pickpocket>,
     <song - Self-Taught Learner>,
     <song - Maps>,
     <song - Window Blues>,
     <song - That's Not My Name>,
     <song - My Lover Will Go>,
     <song - Home Sweet Home>,
     <song - Stella & God>,
     <song - Don't You Want To Share The Guilt?>,
     <song - Forget About It>,
     <song - Dull Life>,
     <song - This Trumpet In My Head>,
     <song - Keep Your Head>,
     <song - One More Time>,
     <song - Knights in Mountain Fox Jackets>]
    >>> 

    """
    limit = str(limit).lower()

    if seed_catalog and isinstance(seed_catalog, catalog.Catalog):
        seed_catalog = seed_catalog.id

    if source_catalog and isinstance(source_catalog, catalog.Catalog):
        source_catalog = source_catalog.id
    dmca = str(dmca).lower()
    kwargs = locals()
    kwargs['bucket'] = kwargs['buckets'] or []
    del kwargs['buckets']
    kwargs['genre'] = kwargs['genres']
    del kwargs['genres']

    result = util.callm("%s/%s" % ('playlist', 'static'), kwargs)
    return [Song(**util.fix(s_dict)) for s_dict in result['response']['songs']]

class Playlist(PlaylistProxy):
    """
    A Dynamic Playlist object.
    http://developer.echonest.com/docs/v4/playlist.html#dynamic-create

    Attributes:

    Example:
    """

    def __init__(
            self, session_id=None, type=None, artist_pick=None, variety=None, artist_id=None, artist=None, song_id=None,
            track_id=None, description=None, style=None, mood=None, max_tempo=None, min_tempo=None, max_duration=None,
            min_duration=None, max_loudness=None, min_loudness=None, max_danceability=None, min_danceability=None,
            max_energy=None, min_energy=None, artist_max_familiarity=None, artist_min_familiarity=None,
            artist_max_hotttnesss=None, artist_min_hotttnesss=None, song_max_hotttnesss=None, song_min_hotttnesss=None,
            min_longitude=None, max_longitude=None, min_latitude=None, max_latitude=None, adventurousness=None,
            mode=None, key=None, buckets=None, sort=None, limit=False, seed_catalog=None, source_catalog=None,
            rank_type=None, test_new_things=None, artist_start_year_after=None, artist_start_year_before=None,
            artist_end_year_after=None, artist_end_year_before=None, dmca=False, distribution=None, song_type=None,
            session_catalog=None,genres=None,):

        limit = str(limit).lower()
        dmca = str(dmca).lower()

        if isinstance(seed_catalog, catalog.Catalog):
            seed_catalog = seed_catalog.id

        super(Playlist, self).__init__(
            session_id=session_id,
            type=type,
            artist_pick=artist_pick,
            variety=variety,
            artist_id=artist_id,
            artist=artist,
            song_id=song_id,
            track_id=track_id,
            description=description,
            style=style,
            mood=mood,
            max_tempo=max_tempo,
            min_tempo=min_tempo,
            max_duration=max_duration,
            min_duration=min_duration,
            max_loudness=max_loudness,
            min_loudness=min_loudness,
            max_danceability=max_danceability,
            min_danceability=min_danceability,
            max_energy=max_energy,
            min_energy=min_energy,
            artist_max_familiarity=artist_max_familiarity,
            artist_min_familiarity=artist_min_familiarity,
            artist_max_hotttnesss=artist_max_hotttnesss,
            artist_min_hotttnesss=artist_min_hotttnesss,
            song_max_hotttnesss=song_max_hotttnesss,
            song_min_hotttnesss=song_min_hotttnesss,
            min_longitude=min_longitude,
            max_longitude=max_longitude,
            min_latitude=min_latitude,
            max_latitude=max_latitude,
            adventurousness=adventurousness,
            mode=mode,
            key=key,
            buckets=buckets,
            sort=sort,
            limit=limit,
            seed_catalog=seed_catalog,
            source_catalog=source_catalog,
            rank_type=rank_type,
            test_new_things=test_new_things,
            artist_start_year_after=artist_start_year_after,
            artist_start_year_before=artist_start_year_before,
            artist_end_year_after=artist_end_year_after,
            artist_end_year_before=artist_end_year_before,
            dmca=dmca,
            distribution=distribution,
            song_type=song_type,
            session_catalog=session_catalog,
            genres=genres
        )


    def __repr__(self):
        return "<Dynamic Playlist - %s>" % self.session_id.encode('utf-8')

    def get_next_songs(self, results=None, lookahead=None):
        response = self.get_attribute(
            method='next',
            session_id=self.session_id,
            results=results,
            lookahead=lookahead
        )
        self.cache['songs'] = response['songs']
        self.cache['lookahead'] = response['lookahead']
        if len(self.cache['songs']):
            songs = self.cache['songs'][:]
            songs = [Song(**util.fix(song)) for song in songs]
            return songs
        else:
            return None

    def get_current_songs(self):
        if not 'songs' in self.cache:
            self.get_next_songs(results=1)
        if len(self.cache['songs']):
            songs = self.cache['songs'][:]
            songs = [Song(**util.fix(song)) for song in songs]

            return songs
        else:
            return None

    def get_lookahead_songs(self):
        if not 'lookahead' in self.cache:
            return None
        if len(self.cache['lookahead']):
            lookahead = self.cache['lookahead'][:]
            lookahead = [Song(**util.fix(song)) for song in lookahead]

            return lookahead
        else:
            return None

    songs = property(get_current_songs)

    def info(self):
        return self.get_attribute("info", session_id=self.session_id)

    def delete(self):
        self.get_attribute("delete", session_id=self.session_id)
        return True

    def restart(
        self,
        type=None,
        artist_pick=None,
        variety=None,
        artist_id=None,
        artist=None,
        song_id=None,
        track_id=None,
        description=None,
        style=None,
        mood=None,
        max_tempo=None,
        min_tempo=None,
        max_duration=None,
        min_duration=None,
        max_loudness=None,
        min_loudness=None,
        max_danceability=None,
        min_danceability=None,
        max_energy=None,
        min_energy=None,
        artist_max_familiarity=None,
        artist_min_familiarity=None,
        artist_max_hotttnesss=None,
        artist_min_hotttnesss=None,
        song_max_hotttnesss=None,
        song_min_hotttnesss=None,
        min_longitude=None,
        max_longitude=None,
        min_latitude=None,
        max_latitude=None,
        adventurousness=None,
        mode=None,
        key=None,
        buckets=None,
        sort=None,
        limit=False,
        seed_catalog=None,
        source_catalog=None,
        rank_type=None,
        test_new_things=None,
        artist_start_year_after=None,
        artist_start_year_before=None,
        artist_end_year_after=None,
        artist_end_year_before=None,
        dmca=False,
        distribution=None,
        song_type=None,
        genres=None,
    ):
        limit = str(limit).lower()
        dmca = str(dmca).lower()

        if isinstance(seed_catalog, catalog.Catalog):
            seed_catalog = seed_catalog.id


        return self.get_attribute(
            method='restart',
            session_id=self.session_id,
            type=type,
            artist_pick=artist_pick,
            variety=variety,
            artist_id=artist_id,
            artist=artist,
            song_id=song_id,
            track_id=track_id,
            description=description,
            style=style,
            mood=mood,
            max_tempo=max_tempo,
            min_tempo=min_tempo,
            max_duration=max_duration,
            min_duration=min_duration,
            max_loudness=max_loudness,
            min_loudness=min_loudness,
            max_danceability=max_danceability,
            min_danceability=min_danceability,
            max_energy=max_energy,
            min_energy=min_energy,
            artist_max_familiarity=artist_max_familiarity,
            artist_min_familiarity=artist_min_familiarity,
            artist_max_hotttnesss=artist_max_hotttnesss,
            artist_min_hotttnesss=artist_min_hotttnesss,
            song_max_hotttnesss=song_max_hotttnesss,
            song_min_hotttnesss=song_min_hotttnesss,
            min_longitude=min_longitude,
            max_longitude=max_longitude,
            min_latitude=min_latitude,
            max_latitude=max_latitude,
            adventurousness=adventurousness,
            mode=mode,
            key=key,
            bucket=buckets,
            sort=sort,
            limit=limit,
            seed_catalog=seed_catalog,
            source_catalog=source_catalog,
            rank_type=rank_type,
            test_new_things=test_new_things,
            artist_start_year_after=artist_start_year_after,
            artist_start_year_before=artist_start_year_before,
            artist_end_year_after=artist_end_year_after,
            artist_end_year_before=artist_end_year_before,
            dmca=dmca,
            distribution=distribution,
            song_type=song_type,
            genres=genres,
        )

    def steer(
        self,
        max_tempo=None,
        min_tempo=None,
        target_tempo=None,
        max_duration=None,
        min_duration=None,
        target_duration=None,
        max_loudness=None,
        min_loudness=None,
        target_loudness=None,
        max_danceability=None,
        min_danceability=None,
        target_danceability=None,
        max_energy=None,
        min_energy=None,
        target_energy=None,
        max_artist_familiarity=None,
        min_artist_familiarity=None,
        target_artist_familiarity=None,
        max_artist_hotttnesss=None,
        min_artist_hotttnesss=None,
        target_artist_hotttnesss=None,
        max_song_hotttnesss=None,
        min_song_hotttnesss=None,
        target_song_hotttnesss=None,
        more_like_this=None,
        less_like_this=None,
        adventurousness=None,
        variety=None,
        description=None,
        style=None,
        mood=None,
        song_type=None,
        genres=None
        ):

        response = self.get_attribute(
            method='steer',
            session_id=self.session_id,
            max_tempo=max_tempo,
            min_tempo=min_tempo,
            target_tempo=target_tempo,
            max_duration=max_duration,
            min_duration=min_duration,
            target_duration=target_duration,
            max_loudness=max_loudness,
            min_loudness=min_loudness,
            target_loudness=target_loudness,
            max_danceability=max_danceability,
            min_danceability=min_danceability,
            target_danceability=target_danceability,
            max_energy=max_energy,
            min_energy=min_energy,
            target_energy=target_energy,
            max_artist_familiarity=max_artist_familiarity,
            min_artist_familiarity=min_artist_familiarity,
            target_artist_familiarity=target_artist_familiarity,
            max_artist_hotttnesss=max_artist_hotttnesss,
            min_artist_hotttnesss=min_artist_hotttnesss,
            target_artist_hotttnesss=target_artist_hotttnesss,
            max_song_hotttnesss=max_song_hotttnesss,
            min_song_hotttnesss=min_song_hotttnesss,
            target_song_hotttnesss=target_song_hotttnesss,
            more_like_this=more_like_this,
            less_like_this=less_like_this,
            adventurousness=adventurousness,
            variety=variety,
            description=description,
            style=style,
            mood=mood,
            song_type=song_type,
            genres=genres,
            )

        self.cache['lookahead'] = []
        return True

    def feedback(
        self,
        ban_artist=None,
        ban_song=None,
        skip_song=None,
        favorite_artist=None,
        favorite_song=None,
        play_song=None,
        unplay_song=None,
        rate_song=None,
        invalidate_song=None,
        invalidate_artist=None,
        ):

        response = self.get_attribute(
            session_id=self.session_id,
            method='feedback',
            ban_artist=ban_artist,
            ban_song=ban_song,
            skip_song=skip_song,
            favorite_artist=favorite_artist,
            favorite_song=favorite_song,
            play_song=play_song,
            unplay_song=unplay_song,
            rate_song=rate_song,
            invalidate_song=invalidate_song,
            invalidate_artist=invalidate_artist,
            )

        self.cache['lookahead'] = []
        return True

class DeprecationHelper(object):

    def __init__(self, new_target):
        self.new_target = new_target

    def _warn(self):
        from warnings import warn
        warn("BetaPlaylist is no longer in Beta and has been moved to Playlist", DeprecationWarning, stacklevel=2)
        logger.warn("BetaPlaylist is no longer in Beta and has been moved to Playlist")

    def __call__(self, *args, **kwargs):
        self._warn()
        return self.new_target(*args, **kwargs)

    def __getattr__(self, attr):
        self._warn()
        return getattr(self.new_target, attr)

BetaPlaylist = DeprecationHelper(Playlist)

########NEW FILE########
__FILENAME__ = proxies
#!/usr/bin/env python
# encoding: utf-8

"""
Copyright (c) 2010 The Echo Nest. All rights reserved.
Created by Tyler Williams on 2010-04-25.
"""
import util

class ResultList(list):
    def __init__(self, li, start=0, total=0):
        self.extend(li)
        self.start = start
        if total == 0:
            total = len(li)
        self.total = total

class GenericProxy(object):
    def __init__(self):
        self.cache = {}
    
    def get_attribute(self, method_name, **kwargs):
        result = util.callm("%s/%s" % (self._object_type, method_name), kwargs)
        return result['response']
    
    def post_attribute(self, method_name, **kwargs):
        data = kwargs.pop('data') if 'data' in kwargs else {}
        result = util.callm("%s/%s" % (self._object_type, method_name), kwargs, POST=True, data=data)
        return result['response']
    

class ArtistProxy(GenericProxy):
    def __init__(self, identifier, buckets = None, **kwargs):
        super(ArtistProxy, self).__init__()
        buckets = buckets or []
        self.id = identifier
        self._object_type = 'artist'
        kwargs = dict((str(k), v) for (k,v) in kwargs.iteritems())
        # the following are integral to all artist objects... the rest is up to you!
        core_attrs = ['name']
        
        if not all(ca in kwargs for ca in core_attrs):
            profile = self.get_attribute('profile', **{'bucket':buckets})
            kwargs.update(profile.get('artist'))
        [self.__dict__.update({ca:kwargs.pop(ca)}) for ca in core_attrs+['id'] if ca in kwargs]        
        self.cache.update(kwargs)
    
    def get_attribute(self, *args, **kwargs):
        if util.short_regex.match(self.id) or util.long_regex.match(self.id) or util.foreign_regex.match(self.id):
            kwargs['id'] = self.id
        else:
            kwargs['name'] = self.id
        return super(ArtistProxy, self).get_attribute(*args, **kwargs)
    

class CatalogProxy(GenericProxy):
    def __init__(self, identifier, type, buckets = None, **kwargs):
        super(CatalogProxy, self).__init__()
        buckets = buckets or []
        self.id = identifier
        self._object_type = 'catalog'
        kwargs = dict((str(k), v) for (k,v) in kwargs.iteritems())
        # the following are integral to all catalog objects... the rest is up to you!
        core_attrs = ['name']
        if not all(ca in kwargs for ca in core_attrs):
            if util.short_regex.match(self.id) or util.long_regex.match(self.id) or util.foreign_regex.match(self.id):
                profile = self.get_attribute('profile')
                kwargs.update(profile['catalog'])
            else:
                if not type:
                    raise Exception('You must specify a "type"!')
                try:
                    profile = self.get_attribute('profile')
                    existing_type = profile['catalog'].get('type', 'Unknown')
                    if type != existing_type:
                        raise Exception("Catalog type requested (%s) does not match existing catalog type (%s)" % (type, existing_type))
                    
                    kwargs.update(profile['catalog'])
                except util.EchoNestAPIError:
                    profile = self.post_attribute('create', type=type, **kwargs)
                    kwargs.update(profile)
        [self.__dict__.update({ca:kwargs.pop(ca)}) for ca in core_attrs+['id'] if ca in kwargs]
        self.cache.update(kwargs)
    
    def get_attribute_simple(self, *args, **kwargs):
        # omit name/id kwargs for this call
        return super(CatalogProxy, self).get_attribute(*args, **kwargs)
    
    def get_attribute(self, *args, **kwargs):
        if util.short_regex.match(self.id) or util.long_regex.match(self.id) or util.foreign_regex.match(self.id):
            kwargs['id'] = self.id
        else:
            kwargs['name'] = self.id
        return super(CatalogProxy, self).get_attribute(*args, **kwargs)
    
    def post_attribute(self, *args, **kwargs):
        if util.short_regex.match(self.id) or util.long_regex.match(self.id) or util.foreign_regex.match(self.id):
            kwargs['id'] = self.id
        else:
            kwargs['name'] = self.id
        return super(CatalogProxy, self).post_attribute(*args, **kwargs)
    

class PlaylistProxy(GenericProxy):
    def __init__(self, session_id = None, buckets = None, **kwargs):
        super(PlaylistProxy, self).__init__()
        core_attrs = ['session_id']
        self._object_type = 'playlist'
        if session_id:
            self.session_id=session_id
        else:
            buckets = buckets or []
            kwargs['bucket'] = buckets
            kwargs['genre'] = kwargs['genres']
            del kwargs['genres']
            kwargs = dict((str(k), v) for (k,v) in kwargs.iteritems())
            
            if not all(ca in kwargs for ca in core_attrs):
                kwargs = dict((str(k), v) for (k,v) in kwargs.iteritems())
                profile = self.get_attribute('create', **kwargs)
                kwargs.update(profile)
            [self.__dict__.update({ca:kwargs.pop(ca)}) for ca in core_attrs if ca in kwargs]
            self.cache.update(kwargs)
        
    def get_attribute(self, method, **kwargs):
        return super(PlaylistProxy, self).get_attribute('dynamic/' + method, **kwargs)

class SongProxy(GenericProxy):
    def __init__(self, identifier, buckets = None, **kwargs):
        super(SongProxy, self).__init__()
        buckets = buckets or []
        self.id = identifier
        self._object_type = 'song'
        kwargs = dict((str(k), v) for (k,v) in kwargs.iteritems())
        
        # BAW -- this is debug output from identify that returns a track_id. i am not sure where else to access this..
        if kwargs.has_key("track_id"):
            self.track_id = kwargs["track_id"]
        if kwargs.has_key("tag"):
            self.tag = kwargs["tag"]
        if kwargs.has_key("score"):
            self.score = kwargs["score"]
        if kwargs.has_key('audio'):
            self.audio = kwargs['audio']
        if kwargs.has_key('release_image'):
            self.release_image = kwargs['release_image']
        
        # the following are integral to all song objects... the rest is up to you!
        core_attrs = ['title', 'artist_name', 'artist_id']
        
        if not all(ca in kwargs for ca in core_attrs):
            profile = self.get_attribute('profile', **{'id':self.id, 'bucket':buckets})
            kwargs.update(profile.get('songs')[0])
        [self.__dict__.update({ca:kwargs.pop(ca)}) for ca in core_attrs]
        self.cache.update(kwargs)
    
    def get_attribute(self, *args, **kwargs):
        kwargs['id'] = self.id
        return super(SongProxy, self).get_attribute(*args, **kwargs)
    

class TrackProxy(GenericProxy):
    def __init__(self, identifier, md5, properties):
        """
        You should not call this constructor directly, rather use the convenience functions
        that are in track.py. For example, call track.track_from_filename
        Let's always get the bucket `audio_summary`
        """
        super(TrackProxy, self).__init__()
        self.id = identifier
        self.md5 = md5
        self.analysis_url = None
        self._object_type = 'track'
        self.__dict__.update(properties)
    

########NEW FILE########
__FILENAME__ = results
#!/usr/bin/env python
# encoding: utf-8

"""
Copyright (c) 2010 The Echo Nest. All rights reserved.
Created by Tyler Williams on 2010-04-25.
"""

import logging
from util import attrdict

# I want a:
#   generic object that takes a dict and turns it into an object
#   should take on the name of a key in the dict
#   should handle lists
class Result(attrdict):
    def __init__(self, result_type, result_dict):
        self._object_type = result_type
        assert(isinstance(result_dict,dict))
        self.__dict__.update(result_dict)
    
    def __repr__(self):
        return "<Result - %s>" % (self._object_type)
    
    def __str__(self):
        return "<Result - %s>" % (self._object_type)

def make_results(result_type, response, accessor_function):
    try:
        data = accessor_function(response)
        if isinstance(data, list):
            return [Result(result_type, item) for item in data]
        elif isinstance(data, dict):
            return Result(result_type, data)
        else:
             return data
    except IndexError:
        logging.info("No songs found")


########NEW FILE########
__FILENAME__ = sandbox
#!/usr/bin/env python
# encoding: utf-8

"""
Copyright (c) 2010 The Echo Nest. All rights reserved.
Created by Tyler Williams on 2011-10-21.

The Sandbox module loosely covers http://developer.echonest.com/docs/v4/sandbox.html
Refer to the official api documentation if you are unsure about something.
"""
try:
    import json
except ImportError:
    import simplejson as json
import datetime

import util
from proxies import ResultList

def list(sandbox_name, results=15, start=0):
    """
    Returns a list of all assets available in this sandbox
    
    Args:
        sandbox_name (str): A string representing the name of the sandbox

    Kwargs:
        results (int): An integer number of results to return
        
        start (int): An integer starting value for the result set
        
    Returns:
        A list of asset dictionaries
    
    Example:

    >>> sandbox.list('bluenote')
    [{}, {}]
    >>> 

    
    """
    result = util.callm("%s/%s" % ('sandbox', 'list'), {'sandbox':sandbox_name, 'results': results, 'start': start})
    assets = result['response']['assets']
    start = result['response']['start']
    total = result['response']['total']

    return ResultList(assets, start, total)
    

def access(sandbox_name, asset_ids):
    """
    Returns a list of assets with expiring access urls that can be used to download them
    *Requires Oauth*

    Args:
        sandbox_name (str): A string representing the name of the sandbox
        asset_ids (list): A list of asset_ids (str) to fetch

    Kwargs:
        
    Returns:
        A list of asset dictionaries
    
    Example:

    >>> sandbox.access('bluenote', ['12345'])
    [{}, {}]
    >>> 

    
    """
    result = util.oauthgetm("%s/%s" % ('sandbox', 'access'), {'sandbox':sandbox_name, 'id':asset_ids})
    return  result['response']['assets']
    

########NEW FILE########
__FILENAME__ = song
#!/usr/bin/env python
# encoding: utf-8

"""
Copyright (c) 2010 The Echo Nest. All rights reserved.
Created by Tyler Williams on 2010-04-25.

The Song module loosely covers http://developer.echonest.com/docs/v4/song.html
Refer to the official api documentation if you are unsure about something.
"""
import os
import util
from proxies import SongProxy

try:
    import json
except ImportError:
    import simplejson as json
    
class Song(SongProxy):
    """
    A Song object
    
    Attributes: 
        id (str): Echo Nest Song ID
        
        title (str): Song Title
        
        artist_name (str): Artist Name
        
        artist_id (str): Artist ID
        
        audio_summary (dict): An Audio Summary dict
        
        song_hotttnesss (float): A float representing a song's hotttnesss
        
        artist_hotttnesss (float): A float representing a song's parent artist's hotttnesss
        
        artist_familiarity (float): A float representing a song's parent artist's familiarity
        
        artist_location (dict): A dictionary of strings specifying a song's parent artist's location, lattitude and longitude
        
    Create a song object like so:

    >>> s = song.Song('SOPEXHZ12873FD2AC7')
    
    """
    def __init__(self, id, buckets=None, **kwargs):
        """
        Song class
        
        Args:
            id (str): a song ID 

        Kwargs:
            buckets (list): A list of strings specifying which buckets to retrieve

        Returns:
            A Song object

        Example:

        >>> s = song.Song('SOPEXHZ12873FD2AC7', buckets=['song_hotttnesss', 'artist_hotttnesss'])
        >>> s.song_hotttnesss
        0.58602500000000002
        >>> s.artist_hotttnesss
        0.80329715999999995
        >>> 

        """
        buckets = buckets or []
        super(Song, self).__init__(id, buckets, **kwargs)
    
    def __repr__(self):
        return "<%s - %s>" % (self._object_type.encode('utf-8'), self.title.encode('utf-8'))
    
    def __str__(self):
        return self.title.encode('utf-8')
    
        
    def get_audio_summary(self, cache=True):
        """Get an audio summary of a song containing mode, tempo, key, duration, time signature, loudness, danceability, energy, and analysis_url.
        
        Args:
        
        Kwargs:
            cache (bool): A boolean indicating whether or not the cached value should be used (if available). Defaults to True.
        
        Returns:
            A dictionary containing mode, tempo, key, duration, time signature, loudness, danceability, energy and analysis_url keys.
            
        Example:
            >>> s = song.Song('SOGNMKX12B0B806320')
            >>> s.audio_summary
             {u'analysis_url': u'https://echonest-analysis.s3.amazonaws.com/TR/RnMKCg47J5LgQZr0SISyoPuRxKVQx3Z_YSuhVa/3/full.json?Signature=KBUbewLiP3sZ2X6rRZzXhrgh8fw%3D&Expires=1349809604&AWSAccessKeyId=AKIAJRDFEY23UEVW42BQ',
              u'audio_md5': u'ca3fdfa72eed23d5ad89872c38cecc0e',
              u'danceability': 0.33712086491871546,
              u'duration': 470.70666999999997,
              u'energy': 0.58186979146361684,
              u'key': 0,
              u'liveness': 0.08676759933615498,
              u'loudness': -9.5960000000000001,
              u'mode': 1,
              u'speechiness': 0.036938896635994867,
              u'tempo': 126.949,
              u'time_signature': 4}
            >>> 
            
        """
        if not (cache and ('audio_summary' in self.cache)):
            response = self.get_attribute('profile', bucket='audio_summary')
            if response['songs'] and 'audio_summary' in response['songs'][0]:
                self.cache['audio_summary'] = response['songs'][0]['audio_summary']
            else:
                self.cache['audio_summary'] = {}
        return self.cache['audio_summary']
    
    audio_summary = property(get_audio_summary)
    
    def get_song_hotttnesss(self, cache=True):
        """Get our numerical description of how hottt a song currently is
        
        Args:
        
        Kwargs:
            cache (bool): A boolean indicating whether or not the cached value should be used (if available). Defaults to True.
        
        Returns:
            A float representing hotttnesss.
        
        Example:
            >>> s = song.Song('SOLUHKP129F0698D49')
            >>> s.get_song_hotttnesss()
            0.57344379999999995
            >>> s.song_hotttnesss
            0.57344379999999995
            >>> 

        """
        if not (cache and ('song_hotttnesss' in self.cache)):
            response = self.get_attribute('profile', bucket='song_hotttnesss')
            self.cache['song_hotttnesss'] = response['songs'][0]['song_hotttnesss']
        return self.cache['song_hotttnesss']
    
    song_hotttnesss = property(get_song_hotttnesss)

    def get_song_type(self, cache=True):
        """Get the types of a song.
        
        Args:
            cache (boolean): A boolean indicating whether or not the cached value should be used
            (if available). Defaults to True.
        
        Returns:
            A list of strings, each representing a song type:  'christmas', for example.
        
        Example:
            >>> s = song.Song('SOQKVPH12A58A7AF4D')
            >>> s.song_type
            [u'christmas']
            >>> 

        """ 
        if not (cache and ('song_type' in self.cache)):
            response = self.get_attribute('profile', bucket='song_type')
            if response['songs'][0].has_key('song_type'):
                self.cache['song_type'] = response['songs'][0]['song_type']
            else:
                self.cache['song_type'] = []
        return self.cache['song_type']

    song_type = property(get_song_type)
    
    def get_artist_hotttnesss(self, cache=True):
        """Get our numerical description of how hottt a song's artist currently is
        
        Args:
        
        Kwargs:
            cache (bool): A boolean indicating whether or not the cached value should be used (if available). Defaults to True.
        
        Returns:
            A float representing hotttnesss.
        
        Example:
            >>> s = song.Song('SOOLGAZ127F3E1B87C')
            >>> s.artist_hotttnesss
            0.45645633000000002
            >>> s.get_artist_hotttnesss()
            0.45645633000000002
            >>> 
        
        """
        if not (cache and ('artist_hotttnesss' in self.cache)):
            response = self.get_attribute('profile', bucket='artist_hotttnesss')
            self.cache['artist_hotttnesss'] = response['songs'][0]['artist_hotttnesss']
        return self.cache['artist_hotttnesss']
    
    artist_hotttnesss = property(get_artist_hotttnesss)
    
    def get_artist_familiarity(self, cache=True):
        """Get our numerical estimation of how familiar a song's artist currently is to the world
        
        Args:
            cache (bool): A boolean indicating whether or not the cached value should be used (if available). Defaults to True.
        
        Returns:
            A float representing familiarity.
        
        Example:
            >>> s = song.Song('SOQKVPH12A58A7AF4D')
            >>> s.get_artist_familiarity()
            0.639626025843539
            >>> s.artist_familiarity
            0.639626025843539
            >>> 
        """
        if not (cache and ('artist_familiarity' in self.cache)):
            response = self.get_attribute('profile', bucket='artist_familiarity')
            self.cache['artist_familiarity'] = response['songs'][0]['artist_familiarity']
        return self.cache['artist_familiarity']
    
    artist_familiarity = property(get_artist_familiarity)
    
    def get_artist_location(self, cache=True):
        """Get the location of a song's artist.
        
        Args:
            cache (bool): A boolean indicating whether or not the cached value should be used (if available). Defaults to True.
        
        Returns:
            An artist location object.
        
        Example:
            >>> s = song.Song('SOQKVPH12A58A7AF4D')
            >>> s.artist_location
            {u'latitude': 34.053489999999996, u'location': u'Los Angeles, CA', u'longitude': -118.24532000000001}
            >>> 

        """
        if not (cache and ('artist_location' in self.cache)):
            response = self.get_attribute('profile', bucket='artist_location')
            self.cache['artist_location'] = response['songs'][0]['artist_location']
        return self.cache['artist_location']
    
    artist_location = property(get_artist_location)
    
    def get_foreign_id(self, idspace='', cache=True):
        """Get the foreign id for this song for a specific id space
        
        Args:
        
        Kwargs:
            idspace (str): A string indicating the idspace to fetch a foreign id for.
        
        Returns:
            A foreign ID string
        
        Example:
        
        >>> s = song.Song('SOYRVMR12AF729F8DC')
        >>> s.get_foreign_id('CAGPXKK12BB06F9DE9')
        
        >>> 
        """
        if not (cache and ('foreign_ids' in self.cache) and filter(lambda d: d.get('catalog') == idspace, self.cache['foreign_ids'])):
            response = self.get_attribute('profile', bucket=['id:'+idspace])
            rsongs = response['songs']
            if len(rsongs) == 0:
                return None
            foreign_ids = rsongs[0].get("foreign_ids", [])
            self.cache['foreign_ids'] = self.cache.get('foreign_ids', []) + foreign_ids
        cval = filter(lambda d: d.get('catalog') == idspace, self.cache.get('foreign_ids'))
        return cval[0].get('foreign_id') if cval else None

    def get_song_discovery(self, cache=True):
        """
        Args:
            cache (bool): A boolean indicating whether or not the cached value should be used (if available). Defaults to True.

        Returns:
            A float representing a song's discovery rank.

        Example:
            >>> s = song.Song('SOQKVPH12A58A7AF4D')
            >>> s.get_song_discovery()
            0.639626025843539
            >>> s.song_discovery
            0.639626025843539
            >>>
        """
        if not (cache and ('song_discovery' in self.cache)):
            response = self.get_attribute('profile', bucket='song_discovery')
            self.cache['song_discovery'] = response['songs'][0]['song_discovery']
        return self.cache['song_discovery']

    song_discovery = property(get_song_discovery)

    def get_song_currency(self, cache=True):
        """
        Args:
            cache (bool): A boolean indicating whether or not the cached value should be used (if available). Defaults to True.
        
        Returns:
            A float representing a song's currency rank.
            
        Example:
            >>> s = song.Song('SOQKVPH12A58A7AF4D')
            >>> s.get_song_currency()
            0.639626025843539
            >>> s.song_currency
            0.639626025843539
            >>>
        """
        if not (cache and ('song_currency' in self.cache)):
            response = self.get_attribute('profile', bucket='song_currency')
            self.cache['song_currency'] = response['songs'][0]['song_currency']
        return self.cache['song_currency']

    song_currency = property(get_song_currency)
    
    def get_tracks(self, catalog, cache=True):
        """Get the tracks for a song given a catalog.
        
        Args:
            catalog (str): a string representing the catalog whose track you want to retrieve.
        
        Returns:
            A list of Track dicts.
        
        Example:
            >>> s = song.Song('SOWDASQ12A6310F24F')
            >>> s.get_tracks('7digital')[0]
            {u'catalog': u'7digital',
             u'foreign_id': u'7digital:track:8445818',
             u'id': u'TRJGNNY12903CC625C',
             u'preview_url': u'http://previews.7digital.com/clips/34/8445818.clip.mp3',
             u'release_image': u'http://cdn.7static.com/static/img/sleeveart/00/007/628/0000762838_200.jpg'}
            >>> 

        """
        if not (cache and ('tracks' in self.cache) and (catalog in [td['catalog'] for td in self.cache['tracks']])):
            kwargs = {
                'bucket':['tracks', 'id:%s' % catalog],
            }
                        
            response = self.get_attribute('profile', **kwargs)
            if not 'tracks' in self.cache:
                self.cache['tracks'] = []
            # don't blow away the cache for other catalogs
            potential_tracks = response['songs'][0].get('tracks', [])
            existing_track_ids = [tr['foreign_id'] for tr in self.cache['tracks']]
            new_tds = filter(lambda tr: tr['foreign_id'] not in existing_track_ids, potential_tracks)
            self.cache['tracks'].extend(new_tds)
        return filter(lambda tr: tr['catalog']==catalog, self.cache['tracks'])


def identify(filename=None, query_obj=None, code=None, artist=None, title=None, release=None, duration=None, genre=None, buckets=None, version=None, codegen_start=0, codegen_duration=30):
    """Identify a song.
    
    Args:
        
    Kwargs:
        filename (str): The path of the file you want to analyze (requires codegen binary!)
        
        query_obj (dict or list): A dict or list of dicts containing a 'code' element with an fp code
        
        code (str): A fingerprinter code
        
        artist (str): An artist name
        
        title (str): A song title
        
        release (str): A release name
        
        duration (int): A song duration
        
        genre (str): A string representing the genre
        
        buckets (list): A list of strings specifying which buckets to retrieve
        
        version (str): The version of the code generator used to generate the code
        
        codegen_start (int): The point (in seconds) where the codegen should start
        
        codegen_duration (int): The duration (in seconds) the codegen should analyze
        
    Example:
        >>> qo
        {'code': 'eJxlldehHSEMRFsChAjlAIL-S_CZvfaXXxAglEaBTen300Qu__lAyoJYhVQdXTvXrmvXdTsKZOqoU1q63QNydBGfOd1cGX3scpb1jEiWRLaPcJureC6RVkXE69jL8pGHjpP48pLI1m7r9oiEyBXvoVv45Q-5IhylYLkIRxGO4rp18ZpEOmpFPopwfJjL0u3WceO3HB1DIvJRnkQeO1PCLIsIjBWEzYaShq4pV9Z0KzDiQ8SbSNuSyBZPOOxIJKR7dauEmXwotxDCqllEAVZlrX6F8Y-IJ0e169i_HQaqslaVtTq1W-1vKeupImzrxWWVI5cPlw-XDxckN-3kyeXDm3jKmqv6PtB1gfH1Eey5qu8qvAuMC4zLfPv1l3aqviylJhytFhF0mzqs6aYpYU04mlqgKWtNjppwNKWubR2FowlHUws0gWmPi668dSHq6rOuPuhqgRcVKKM8s-fZS937nBe23iz3Uctx9607z-kLph1i8YZ8f_TfzLXseBh7nXy9nn1YBAg4Nwjp4AzTL23M_U3Rh0-sdDFtyspNOb1bYeZZqz2Y6TaHmXeuNmfFdTueLuvdsbOU9luvtIkl4vI5F_92PVprM1-sdJ_o9_Guc0b_WimpD_Rt1DFg0sY3wyw08e6jlqhjH3o76naYvzWqhX9rOv15Y7Ww_MIF8dXzw30s_uHO5PPDfUonnzq_NJ8J93mngAkIz5jA29SqxGwwvxQsih-sozX0zVk__RFaf_qyG9hb8dktZZXd4a8-1ljB-c5bllXOe1HqHplzeiN4E7q9ZRdmJuI73gBEJ_HcAxUm74PAVDNL47D6OAfzTHI0mHpXAmY60QNmlqjDfIPzwUDYhVnoXqtvZGrBdMi3ClQUQ8D8rX_1JE_In94CBXER4lrrw0H867ei8x-OVz8c-Osh5plzTOySpKIROmFkbn5xVuK784vTyPpS3OlcSjHpL16saZnm4Bk66hte9sd80Dcj02f7xDVrExjk32cssKXjmflU_SxXmn4Y9Ttued10YM552h5Wtt_WeVR4U6LPWfbIdW31J4JOXnpn4qhH7yE_pdBH9E_sMwbNFr0z0IW5NA8aOZhLmOh3zSVNRZwxiZc5pb8fikGzIf-ampJnCSb3r-ZPfjPuvLm7CY_Vfa_k7SCzdwHNg5mICTSHDxyBWmaOSyLQpPmCSXyF-eL7MHo7zNd668JMb_N-AJJRuMwrX0jNx7a8-Rj5oN6nyWoL-jRv4pu7Ue821TzU3MhvpD9Fo-XI',
         'code_count': 151,
         'low_rank': 0,
         'metadata': {'artist': 'Harmonic 313',
                      'bitrate': 198,
                      'codegen_time': 0.57198400000000005,
                      'decode_time': 0.37954599999999999,
                      'duration': 226,
                      'filename': 'koln.mp3',
                      'genre': 'Electronic',
                      'given_duration': 30,
                      'release': 'When Machines Exceed Human Intelligence',
                      'sample_rate': 44100,
                      'samples_decoded': 661816,
                      'start_offset': 0,
                      'title': 'kln',
                      'version': 3.1499999999999999},
         'tag': 0}
        >>> song.identify(query_obj=qo)
        [<song - Köln>]
        >>> 


    """
    post, has_data, data = False, False, False
    
    if filename:
        if os.path.exists(filename):
            query_obj = util.codegen(filename, start=codegen_start, duration=codegen_duration)
            if query_obj is None:
                raise Exception("The filename specified: %s could not be decoded." % filename)
        else:
            raise Exception("The filename specified: %s does not exist." % filename)
    if query_obj and not isinstance(query_obj, list):
        query_obj = [query_obj]
        
    if filename:
        # check codegen results from file in case we had a bad result
        for q in query_obj:
            if 'error' in q:
                raise Exception(q['error'] + ": " + q.get('metadata', {}).get('filename', ''))
    
    if not (filename or query_obj or code):
        raise Exception("Not enough information to identify song.")
    
    kwargs = {}
    if code:
        has_data = True
        kwargs['code'] = code
    if title:
        kwargs['title'] = title
    if release:
        kwargs['release'] = release
    if duration:
        kwargs['duration'] = duration
    if genre:
        kwargs['genre'] = genre
    if buckets:
        kwargs['bucket'] = buckets
    if version:
        kwargs['version'] = version
    
    if query_obj and any(query_obj):
        has_data = True
        data = {'query':json.dumps(query_obj)}
        post = True
    
    if has_data:
        result = util.callm("%s/%s" % ('song', 'identify'), kwargs, POST=post, data=data)
        return [Song(**util.fix(s_dict)) for s_dict in result['response'].get('songs',[])]


def search(title=None, artist=None, artist_id=None, combined=None, description=None, style=None, mood=None,
           results=None, start=None, max_tempo=None, min_tempo=None,
           max_duration=None, min_duration=None, max_loudness=None, min_loudness=None,
           artist_max_familiarity=None, artist_min_familiarity=None, artist_max_hotttnesss=None,
           artist_min_hotttnesss=None, song_max_hotttnesss=None, song_min_hotttnesss=None, mode=None,
           min_energy=None, max_energy=None, min_danceability=None, max_danceability=None,
           key=None, max_latitude=None, min_latitude=None, max_longitude=None, min_longitude=None,
           sort=None, buckets=None, limit=False, test_new_things=None, rank_type=None,
           artist_start_year_after=None, artist_start_year_before=None, artist_end_year_after=None,
           artist_end_year_before=None,song_type=None,min_song_currency=None,max_song_currency=None,
           min_song_discovery=None, max_song_discovery=None, max_acousticness=None, min_acousticness=None,
           max_liveness=None, min_liveness=None, max_speechiness=None, min_speechiness=None,
           max_valence=None, min_valence=None):
    """Search for songs by name, description, or constraint.

    Args:

    Kwargs:
        title (str): the name of a song
        artist (str): the name of an artist
        artist_id (str): the artist_id
        combined (str): the artist name and song title
        description (str): A string describing the artist and song
        style (str): A string describing the style/genre of the artist and song
        mood (str): A string describing the mood of the artist and song
        results (int): An integer number of results to return
        max_acousticness (float): The max acousticness of song results
        min_acousticness (float): The min acousticness of song results
        max_tempo (float): The max tempo of song results
        min_tempo (float): The min tempo of song results
        max_duration (float): The max duration of song results
        min_duration (float): The min duration of song results
        max_liveness (float): The max liveness of song results
        min_liveness (float): The min liveness of song results
        max_loudness (float): The max loudness of song results
        min_loudness (float): The min loudness of song results
        max_speechiness (float): The max speechiness of song results        
        min_speechiess (float): The min speechiness of song results
        max_valence (float): The max valence of song results
        min_valence (float): The min valence of song results
        artist_max_familiarity (float): A float specifying the max familiarity of artists to search for
        artist_min_familiarity (float): A float specifying the min familiarity of artists to search for
        artist_max_hotttnesss (float): A float specifying the max hotttnesss of artists to search for
        artist_min_hotttnesss (float): A float specifying the max hotttnesss of artists to search for
        song_max_hotttnesss (float): A float specifying the max hotttnesss of songs to search for
        song_min_hotttnesss (float): A float specifying the max hotttnesss of songs to search for
        max_energy (float): The max energy of song results
        min_energy (float): The min energy of song results
        max_dancibility (float): The max dancibility of song results
        min_dancibility (float): The min dancibility of song results
        mode (int): 0 or 1 (minor or major)
        key (int): 0-11 (c, c-sharp, d, e-flat, e, f, f-sharp, g, a-flat, a, b-flat, b)
        max_latitude (float): A float specifying the max latitude of artists to search for
        min_latitude (float): A float specifying the min latitude of artists to search for
        max_longitude (float): A float specifying the max longitude of artists to search for
        min_longitude (float): A float specifying the min longitude of artists to search for                        
        sort (str): A string indicating an attribute and order for sorting the results
        buckets (list): A list of strings specifying which buckets to retrieve
        limit (bool): A boolean indicating whether or not to limit the results to one of the id spaces specified in buckets
        rank_type (str): A string denoting the desired ranking for description searches, either 'relevance' or 'familiarity
        artist_start_year_before (int): Returned songs's artists will have started recording music before this year.
        artist_start_year_after (int): Returned songs's artists will have started recording music after this year.
        artist_end_year_before (int): Returned songs's artists will have stopped recording music before this year.
        artist_end_year_after (int): Returned songs's artists will have stopped recording music after this year.
        song_type (string): A string or list of strings specifiying the type of song to search for.

    Returns:
        A list of Song objects

    Example:

    >>> results = song.search(artist='shakira', title='she wolf', buckets=['id:7digital', 'tracks'], limit=True, results=1)
    >>> results
    [<song - She Wolf>]
    >>> results[0].get_tracks('7digital')[0]
    {u'catalog': u'7digital',
     u'foreign_id': u'7digital:track:7854109',
     u'id': u'TRTOBSE12903CACEC4',
     u'preview_url': u'http://previews.7digital.com/clips/34/7854109.clip.mp3',
     u'release_image': u'http://cdn.7static.com/static/img/sleeveart/00/007/081/0000708184_200.jpg'}
    >>> 
    """
    
    limit = str(limit).lower()
    kwargs = locals()
    kwargs['bucket'] = buckets
    del kwargs['buckets']
    
    result = util.callm("%s/%s" % ('song', 'search'), kwargs)
    return [Song(**util.fix(s_dict)) for s_dict in result['response']['songs']]

def profile(ids=None, track_ids=None, buckets=None, limit=False):
    """get the profiles for multiple songs at once
        
    Args:
        ids (str or list): a song ID or list of song IDs
    
    Kwargs:
        buckets (list): A list of strings specifying which buckets to retrieve

        limit (bool): A boolean indicating whether or not to limit the results to one of the id spaces specified in buckets
    
    Returns:
        A list of term document dicts
    
    Example:

    >>> song_ids = ['SOBSLVH12A8C131F38', 'SOXMSGY1338A5D5873', 'SOJPHZO1376210AFE5', 'SOBHNKR12AB0186218', 'SOSJAHD13770F4D40C']
    >>> songs = song.profile(song_ids, buckets=['audio_summary'])
    [<song - Say It Ain't So>,
     <song - Island In The Sun>,
     <song - My Name Is Jonas>,
     <song - Buddy Holly>]
    >>> songs[0].audio_summary
    {u'analysis_url': u'https://echonest-analysis.s3.amazonaws.com/TR/7VRBNguufpHAQQ4ZjJ0eWsIQWl2S2_lrK-7Bp2azHOvPN4VFV-YnU7uO0dXgYtOKT-MTEa/3/full.json?Signature=hmNghHwfEsA4JKWFXnRi7mVP6T8%3D&Expires=1349809918&AWSAccessKeyId=AKIAJRDFEY23UEVW42BQ',
     u'audio_md5': u'b6079b2b88f8265be8bdd5fe9702e05c',
     u'danceability': 0.64540643050283253,
     u'duration': 255.92117999999999,
     u'energy': 0.30711665772260549,
     u'key': 8,
     u'liveness': 0.088994423525370583,
     u'loudness': -9.7799999999999994,
     u'mode': 1,
     u'speechiness': 0.031970700260699259,
     u'tempo': 76.049999999999997,
     u'time_signature': 4}
    >>> 
    """
    kwargs = {}

    if ids:
        if not isinstance(ids, list):
            ids = [ids]
        kwargs['id'] = ids

    if track_ids:
        if not isinstance(track_ids, list):
            track_ids = [track_ids]
        kwargs['track_id'] = track_ids

    buckets = buckets or []
    if buckets:
        kwargs['bucket'] = buckets

    if limit:
        kwargs['limit'] = 'true'
    
    result = util.callm("%s/%s" % ('song', 'profile'), kwargs)
    return [Song(**util.fix(s_dict)) for s_dict in result['response']['songs']]


########NEW FILE########
__FILENAME__ = track
import urllib2
try:
    import json
except ImportError:
    import simplejson as json

import hashlib
from proxies import TrackProxy
import util
import time

# Seconds to wait for asynchronous track/upload or track/analyze jobs to complete.
DEFAULT_ASYNC_TIMEOUT = 60

class Track(TrackProxy):
    """
    Represents an audio file and its analysis from The Echo Nest.
    All public methods in this module return Track objects.

    Depending on the information available, a Track may have some or all of the
    following attributes:

        acousticness            float: confidence the track is "acoustic" (0.0 to 1.0)
        analysis_url            URL to retrieve the complete audio analysis (time expiring)
        analyzer_version        str: e.g. '3.01a'
        artist                  str or None: artist name
        artist_id               Echo Nest ID of artist, if known
        danceability            float: relative danceability (0.0 to 1.0)
        duration                float: length of track in seconds
        energy                  float: relative energy (0.0 to 1.0)
        id                      str: Echo Nest Track ID, e.g. 'TRTOBXJ1296BCDA33B'
        key                     int: between 0 (key of C) and 11 (key of B flat) inclusive
        liveness                float: confidence the track is "live" (0.0 to 1.0)
        loudness                float: overall loudness in decibels (dB)
        md5                     str: 32-character checksum of the original audio file, if available
        mode                    int: 0 (major) or 1 (minor)
        song_id                 The Echo Nest song ID for the track, if known
        speechiness             float: likelihood the track contains speech (0.0 to 1.0)
        status                  str: analysis status, e.g. 'complete'
        tempo                   float: overall BPM (beats per minute)
        time_signature          beats per measure (e.g. 3, 4, 5, 7)
        title                   str or None: song title
        valence                 float: a range from negative to positive emotional content (0.0 to 1.0)

    The following attributes are available only after calling Track.get_analysis():
    
        analysis_channels       int: the number of audio channels used during analysis
        analysis_sample_rate    int: the sample rate used during analysis
        bars                    list of dicts: timing of each measure
        beats                   list of dicts: timing of each beat
        codestring              ENMFP code string
        code_version            version of ENMFP code generator
        decoder                 audio decoder used by the analysis (e.g. ffmpeg)
        echoprintstring         fingerprint string using Echoprint (http://echoprint.me)
        echoprint_version       version of Echoprint code generator
        end_of_fade_in          float: time in seconds track where fade-in ends
        key_confidence          float: confidence that key detection was accurate
        meta                    dict: other track metainfo (bitrate, album, genre, etc.)
        mode_confidence         float: confidence that mode detection was accurate
        num_samples             int: total samples in the decoded track
        offset_seconds          unused, always 0
        sample_md5              str: 32-character checksum of the decoded audio file
        samplerate              the audio sample rate detected in the file
        sections                list of dicts: larger sections of song (chorus, bridge, solo, etc.)
        segments                list of dicts: timing, pitch, loudness and timbre for each segment
        start_of_fade_out       float: time in seconds where fade out begins
        synchstring             string providing synchronization points throughout the track
        synch_version           version of the synch string algorithm
        tatums                  list of dicts: the smallest metrical unit (subdivision of a beat)
        tempo_confidence        float: confidence that tempo detection was accurate
        time_signature_confidence float: confidence that time_signature detection was accurate
    
    Each bar, beat, section, segment and tatum has a start time, a duration, and a confidence,
    in addition to whatever other data is given.

    Examples:

    >>> t = track.track_from_id('TRJSEBQ1390EC0B548')
    >>> t
    <track - Dark Therapy>

    >>> t = track.track_from_md5('96fa0180d225f14e9f8cbfffbf5eb81d')
    >>> t
    <track - Spoonful - Live At Winterland>
    >>>

    >>> t = track.track_from_filename('Piano Man.mp3')
    >>> t.meta
    AttributeError: 'Track' object has no attribute 'meta'
    >>> t.get_analysis()
    >>> t.meta
    {u'album': u'Piano Man',
     u'analysis_time': 8.9029500000000006,
     u'analyzer_version': u'3.1.3',
     u'artist': u'Billy Joel',
     u'bitrate': 160,
     u'detailed_status': u'OK',
     u'filename': u'/tmp/tmphrBQL9/fd2b524958548e7ecbaf758fb675fab1.mp3',
     u'genre': u'Soft Rock',
     u'sample_rate': 44100,
     u'seconds': 339,
     u'status_code': 0,
     u'timestamp': 1369400122,
     u'title': u'Piano Man'}
    >>>
    """
    def __repr__(self):
        try:
            return "<%s - %s>" % (self._object_type.encode('utf-8'), self.title.encode('utf-8'))
        except AttributeError:
            # the title is None
            return "< Track >"

    def __str__(self):
        return self.title.encode('utf-8')
        
    def get_analysis(self):
        """ Retrieve the detailed analysis for the track, if available. 
            Raises Exception if unable to create the detailed analysis. """
        if self.analysis_url:
            try:
                # Try the existing analysis_url first. This expires shortly
                # after creation.
                try:
                    json_string = urllib2.urlopen(self.analysis_url).read()
                except urllib2.HTTPError:
                    # Probably the analysis_url link has expired. Refresh it.
                    param_dict = dict(id = self.id)
                    new_track = _profile(param_dict, DEFAULT_ASYNC_TIMEOUT)
                    if new_track and new_track.analysis_url:
                        self.analysis_url = new_track.analysis_url
                        json_string = urllib2.urlopen(self.analysis_url).read()
                    else:
                        raise Exception("Failed to create track analysis.")

                analysis = json.loads(json_string)
                analysis_track = analysis.pop('track', {})
                self.__dict__.update(analysis)
                self.__dict__.update(analysis_track)
            except Exception: #pylint: disable=W0702
                # No detailed analysis found.
                raise Exception("Failed to create track analysis.")
        else:
            raise Exception("Failed to create track analysis.")


def _wait_for_pending_track(trid, timeout):
    status = 'pending'
    param_dict = {'id': trid}
    param_dict['format'] = 'json'
    param_dict['bucket'] = 'audio_summary'
    start_time = time.time()
    end_time = start_time + timeout
    # counter for seconds to wait before checking track profile again.
    timeout_counter = 3
    while status == 'pending' and time.time() < end_time:
        time.sleep(timeout_counter)
        result = util.callm('track/profile', param_dict)
        status = result['response']['track']['status'].lower()
        # Slowly increment to wait longer each time.
        timeout_counter += timeout_counter / 2
    return result

def _track_from_response(result, timeout):
    """
    This is the function that actually creates the track object
    """
    response = result['response']
    status = response['track']['status'].lower()

    if status == 'pending':
        # Need to wait for async upload or analyze call to finish.
        result = _wait_for_pending_track(response['track']['id'], timeout)
        response = result['response']
        status = response['track']['status'].lower()

    if not status == 'complete':
        track_id = response['track']['id']
        if status == 'pending':
            raise Exception('%s: the operation didn\'t complete before the timeout (%d secs)' %
                            (track_id, timeout))
        else:
            raise Exception('%s: there was an error analyzing the track, status: %s' % (track_id, status))
    else:
        # track_properties starts as the response dictionary.
        track_properties = response['track']
        # 'id' and 'md5' are separated to construct the Track object.
        identifier = track_properties.pop('id')
        md5        = track_properties.pop('md5', None) # tracks from song api calls will not have an md5
        # Pop off the audio_summary dict and make those keys attributes
        # of the Track. This includes things like tempo, energy, and loudness.
        track_properties.update(track_properties.pop('audio_summary'))
        return Track(identifier, md5, track_properties)

def _upload(param_dict, timeout, data):
    """
    Calls upload either with a local audio file,
    or a url. Returns a track object.
    """
    param_dict['format'] = 'json'
    param_dict['wait'] = 'true'
    param_dict['bucket'] = 'audio_summary'
    result = util.callm('track/upload', param_dict, POST = True, socket_timeout = 300,  data = data)
    return _track_from_response(result, timeout)

def _profile(param_dict, timeout):
    param_dict['format'] = 'json'
    param_dict['bucket'] = 'audio_summary'
    result = util.callm('track/profile', param_dict)
    return _track_from_response(result, timeout)


""" Below are convenience functions for creating Track objects, you should use them """

def _track_from_data(audio_data, filetype, timeout):
    param_dict = {}
    param_dict['filetype'] = filetype
    return _upload(param_dict, timeout, audio_data)

def track_from_file(file_object, filetype, timeout=DEFAULT_ASYNC_TIMEOUT, force_upload=False):
    """
    Create a track object from a file-like object.

    NOTE: Does not create the detailed analysis for the Track. Call
    Track.get_analysis() for that.

    Args:
        file_object: a file-like Python object
        filetype: the file type. Supported types include mp3, ogg, wav, m4a, mp4, au
        force_upload: skip the MD5 shortcut path, force an upload+analysis
    Example:
        >>> f = open("Miaow-01-Tempered-song.mp3")
        >>> t = track.track_from_file(f, 'mp3')
        >>> t
        < Track >
        >>>
    """
    if not force_upload:
        try:
            # Check if this file has already been uploaded.
            # This is much faster than uploading.
            md5 = hashlib.md5(file_object.read()).hexdigest()
            return track_from_md5(md5)
        except util.EchoNestAPIError:
            # Fall through to do a fresh upload.
            pass

    file_object.seek(0)
    return _track_from_data(file_object.read(), filetype, timeout)

def track_from_filename(filename, filetype = None, timeout=DEFAULT_ASYNC_TIMEOUT, force_upload=False):
    """
    Create a track object from a filename.

    NOTE: Does not create the detailed analysis for the Track. Call
    Track.get_analysis() for that.

    Args:
        filename: A string containing the path to the input file.
        filetype: A string indicating the filetype; Defaults to None (type determined by file extension).
        force_upload: skip the MD5 shortcut path, force an upload+analysis

    Example:
        >>> t = track.track_from_filename("Miaow-01-Tempered-song.mp3")
        >>> t
        < Track >
        >>>
    """
    filetype = filetype or filename.split('.')[-1]
    file_object = open(filename, 'rb')
    result = track_from_file(file_object, filetype, timeout, force_upload)
    file_object.close()
    return result

def track_from_url(url, timeout=DEFAULT_ASYNC_TIMEOUT):
    """
    Create a track object from a public http URL.

    NOTE: Does not create the detailed analysis for the Track. Call
    Track.get_analysis() for that.

    Args:
        url: A string giving the URL to read from. This must be on a public machine accessible by HTTP.

    Example:
        >>> t = track.track_from_url("http://www.miaowmusic.com/mp3/Miaow-01-Tempered-song.mp3")
        >>> t
        < Track >
        >>>

    """
    param_dict = dict(url = url)
    return _upload(param_dict, timeout, data=None)

def track_from_id(identifier, timeout=DEFAULT_ASYNC_TIMEOUT):
    """
    Create a track object from an Echo Nest track ID.

    NOTE: Does not create the detailed analysis for the Track. Call
    Track.get_analysis() for that.

    Args:
        identifier: A string containing the ID of a previously analyzed track.

    Example:
        >>> t = track.track_from_id("TRWFIDS128F92CC4CA")
        >>> t
        <track - Let The Spirit>
        >>>
    """
    param_dict = dict(id = identifier)
    return _profile(param_dict, timeout)

def track_from_md5(md5, timeout=DEFAULT_ASYNC_TIMEOUT):
    """
    Create a track object from an md5 hash.

    NOTE: Does not create the detailed analysis for the Track. Call
    Track.get_analysis() for that.

    Args:
        md5: A string 32 characters long giving the md5 checksum of a track already analyzed.

    Example:
        >>> t = track.track_from_md5('b8abf85746ab3416adabca63141d8c2d')
        >>> t
        <track - Neverwas Restored (from Neverwas Soundtrack)>
        >>>
    """
    param_dict = dict(md5 = md5)
    return _profile(param_dict, timeout)

########NEW FILE########
__FILENAME__ = util
#!/usr/bin/env python
# encoding: utf-8

"""
Copyright (c) 2010 The Echo Nest. All rights reserved.
Created by Tyler Williams on 2010-04-25.

Utility functions to support the Echo Nest web API interface.
"""
import urllib
import urllib2
import httplib
import config
import logging
import socket
import re
import time
import os
import subprocess
import traceback
from types import StringType, UnicodeType

try:
    import json
except ImportError:
    import simplejson as json

logger = logging.getLogger(__name__)
TYPENAMES = (
    ('AR', 'artist'),
    ('SO', 'song'),
    ('RE', 'release'),
    ('TR', 'track'),
    ('PE', 'person'),
    ('DE', 'device'),
    ('LI', 'listener'),
    ('ED', 'editor'),
    ('TW', 'tweditor'),
    ('CA', 'catalog'),
)
foreign_regex = re.compile(r'^.+?:(%s):([^^]+)\^?([0-9\.]+)?' % r'|'.join(n[1] for n in TYPENAMES))
short_regex = re.compile(r'^((%s)[0-9A-Z]{16})\^?([0-9\.]+)?' % r'|'.join(n[0] for n in TYPENAMES))
long_regex = re.compile(r'music://id.echonest.com/.+?/(%s)/(%s)[0-9A-Z]{16}\^?([0-9\.]+)?' % (r'|'.join(n[0] for n in TYPENAMES), r'|'.join(n[0] for n in TYPENAMES)))
headers = [('User-Agent', 'Pyechonest %s' % (config.__version__,))]

class MyBaseHandler(urllib2.BaseHandler):
    def default_open(self, request):
        if config.TRACE_API_CALLS:
            logger.info("%s" % (request.get_full_url(),))
        request.start_time = time.time()
        return None
        
class MyErrorProcessor(urllib2.HTTPErrorProcessor):
    def http_response(self, request, response):
        code = response.code
        if config.TRACE_API_CALLS:
            logger.info("took %2.2fs: (%i)" % (time.time()-request.start_time,code))
        if code/100 in (2, 4, 5):
            return response
        else:
            urllib2.HTTPErrorProcessor.http_response(self, request, response)

opener = urllib2.build_opener(MyBaseHandler(), MyErrorProcessor())
opener.addheaders = headers

class EchoNestException(Exception):
    """
    Parent exception class.  Catches API and URL/HTTP errors.
    """
    def __init__(self, code, message, headers):
        if code is None:
            code = -1
            message = 'Echo Nest Unknown Error'

        if message is None:
            super(EchoNestException, self).__init__('Echo Nest Error %d' % code,)
        else:
            super(EchoNestException, self).__init__(message,)
        self.headers = headers
        self.code = code

class EchoNestAPIError(EchoNestException):
    """
    API Specific Errors.
    """
    def __init__(self, code, message, headers, http_status):
        if http_status:
            http_status_message_part = ' [HTTP %d]' % http_status
        else:
            http_status_message_part = ''
        self.http_status = http_status

        formatted_message = ('Echo Nest API Error %d: %s%s' %
                             (code, message, http_status_message_part),)
        super(EchoNestAPIError, self).__init__(code, formatted_message, headers)

class EchoNestIOError(EchoNestException):
    """
    URL and HTTP errors.
    """
    def __init__(self, code=None, error=None, headers=headers):
        formatted_message = ('Echo Nest IOError: %s' % headers,)
        super(EchoNestIOError, self).__init__(code, formatted_message, headers)

def get_successful_response(raw_json):
    if hasattr(raw_json, 'headers'):
        headers = raw_json.headers
    else:
        headers = {'Headers':'No Headers'}
    if hasattr(raw_json, 'getcode'):
        http_status = raw_json.getcode()
    else:
        http_status = None
    raw_json = raw_json.read()
    try:
        response_dict = json.loads(raw_json)
        status_dict = response_dict['response']['status']
        code = int(status_dict['code'])
        message = status_dict['message']
        if (code != 0):
            # do some cute exception handling
            raise EchoNestAPIError(code, message, headers, http_status)
        del response_dict['response']['status']
        return response_dict
    except ValueError:
        logger.debug(traceback.format_exc())
        raise EchoNestAPIError(-1, "Unknown error.", headers, http_status)


# These two functions are to deal with the unknown encoded output of codegen (varies by platform and ID3 tag)
def reallyunicode(s, encoding="utf-8"):
    if type(s) is StringType:
        for args in ((encoding,), ('utf-8',), ('latin-1',), ('ascii', 'replace')):
            try:
                s = s.decode(*args)
                break
            except UnicodeDecodeError:
                continue
    if type(s) is not UnicodeType:
        raise ValueError, "%s is not a string at all." % s
    return s

def reallyUTF8(s):
    return reallyunicode(s).encode("utf-8")

def codegen(filename, start=0, duration=30):
    # Run codegen on the file and return the json. If start or duration is -1 ignore them.
    cmd = config.CODEGEN_BINARY_OVERRIDE
    if not cmd:
        # Is this is posix platform, or is it windows?
        if hasattr(os, 'uname'):
            if(os.uname()[0] == "Darwin"):
                cmd = "codegen.Darwin"
            else:
                cmd = 'codegen.'+os.uname()[0]+'-'+os.uname()[4]
        else:
            cmd = "codegen.windows.exe"

    if not os.path.exists(cmd):
        raise Exception("Codegen binary not found.")

    command = cmd + " \"" + filename + "\" " 
    if start >= 0:
        command = command + str(start) + " "
    if duration >= 0:
        command = command + str(duration)
        
    p = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    (json_block, errs) = p.communicate()
    json_block = reallyUTF8(json_block)

    try:
        return json.loads(json_block)
    except ValueError:
        logger.debug("No JSON object came out of codegen: error was %s" % (errs))
        return None


def callm(method, param_dict, POST=False, socket_timeout=None, data=None):
    """
    Call the api! 
    Param_dict is a *regular* *python* *dictionary* so if you want to have multi-valued params
    put them in a list.
    
    ** note, if we require 2.6, we can get rid of this timeout munging.
    """
    try:
        param_dict['api_key'] = config.ECHO_NEST_API_KEY
        param_list = []
        if not socket_timeout:
            socket_timeout = config.CALL_TIMEOUT

        for key,val in param_dict.iteritems():
            if isinstance(val, list):
                param_list.extend( [(key,subval) for subval in val] )
            elif val is not None:
                if isinstance(val, unicode):
                    val = val.encode('utf-8')
                param_list.append( (key,val) )

        params = urllib.urlencode(param_list)

        orig_timeout = socket.getdefaulttimeout()
        socket.setdefaulttimeout(socket_timeout)

        if(POST):
            if (not method == 'track/upload') or ((method == 'track/upload') and 'url' in param_dict):
                """
                this is a normal POST call
                """
                url = 'http://%s/%s/%s/%s' % (config.API_HOST, config.API_SELECTOR,
                                            config.API_VERSION, method)

                if data is None:
                    data = ''
                data = urllib.urlencode(data)
                data = "&".join([data, params])

                f = opener.open(url, data=data)
            else:
                """
                upload with a local file is special, as the body of the request is the content of the file,
                and the other parameters stay on the URL
                """
                url = '/%s/%s/%s?%s' % (config.API_SELECTOR, config.API_VERSION,
                                            method, params)

                if ':' in config.API_HOST:
                    host, port = config.API_HOST.split(':')
                else:
                    host = config.API_HOST
                    port = 80

                if config.TRACE_API_CALLS:
                    logger.info("%s/%s" % (host+':'+str(port), url,))
                conn = httplib.HTTPConnection(host, port = port)
                conn.request('POST', url, body = data, headers = dict([('Content-Type', 'application/octet-stream')]+headers))
                f = conn.getresponse()

        else:
            """
            just a normal GET call
            """
            url = 'http://%s/%s/%s/%s?%s' % (config.API_HOST, config.API_SELECTOR, config.API_VERSION,
                                            method, params)

            f = opener.open(url)

        socket.setdefaulttimeout(orig_timeout)

        # try/except
        response_dict = get_successful_response(f)
        return response_dict

    except IOError, e:
        if hasattr(e, 'reason'):
            raise EchoNestIOError(error=e.reason)
        elif hasattr(e, 'code'):
            raise EchoNestIOError(code=e.code)
        else:
            raise

def oauthgetm(method, param_dict, socket_timeout=None):
    try:
        import oauth2 # lazy import this so oauth2 is not a hard dep
    except ImportError:
        raise Exception("You must install the python-oauth2 library to use this method.")

    """
    Call the api! With Oauth! 
    Param_dict is a *regular* *python* *dictionary* so if you want to have multi-valued params
    put them in a list.
    
    ** note, if we require 2.6, we can get rid of this timeout munging.
    """
    def build_request(url):
        params = {
            'oauth_version': "1.0",
            'oauth_nonce': oauth2.generate_nonce(),
            'oauth_timestamp': int(time.time())
            }
        consumer = oauth2.Consumer(key=config.ECHO_NEST_CONSUMER_KEY, secret=config.ECHO_NEST_SHARED_SECRET)
        params['oauth_consumer_key'] = config.ECHO_NEST_CONSUMER_KEY
        
        req = oauth2.Request(method='GET', url=url, parameters=params)
        signature_method = oauth2.SignatureMethod_HMAC_SHA1()
        req.sign_request(signature_method, consumer, None)
        return req
    
    param_dict['api_key'] = config.ECHO_NEST_API_KEY
    param_list = []
    if not socket_timeout:
        socket_timeout = config.CALL_TIMEOUT
    
    for key,val in param_dict.iteritems():
        if isinstance(val, list):
            param_list.extend( [(key,subval) for subval in val] )
        elif val is not None:
            if isinstance(val, unicode):
                val = val.encode('utf-8')
            param_list.append( (key,val) )

    params = urllib.urlencode(param_list)
    
    orig_timeout = socket.getdefaulttimeout()
    socket.setdefaulttimeout(socket_timeout)
    """
    just a normal GET call
    """
    url = 'http://%s/%s/%s/%s?%s' % (config.API_HOST, config.API_SELECTOR, config.API_VERSION, 
                                     method, params)
    req = build_request(url)
    f = opener.open(req.to_url())
            
    socket.setdefaulttimeout(orig_timeout)
    
    # try/except
    response_dict = get_successful_response(f)
    return response_dict


def postChunked(host, selector, fields, files):
    """
    Attempt to replace postMultipart() with nearly-identical interface.
    (The files tuple no longer requires the filename, and we only return
    the response body.) 
    Uses the urllib2_file.py originally from 
    http://fabien.seisen.org which was also drawn heavily from 
    http://code.activestate.com/recipes/146306/ .
    
    This urllib2_file.py is more desirable because of the chunked 
    uploading from a file pointer (no need to read entire file into 
    memory) and the ability to work from behind a proxy (due to its 
    basis on urllib2).
    """
    params = urllib.urlencode(fields)
    url = 'http://%s%s?%s' % (host, selector, params)
    u = urllib2.urlopen(url, files)
    result = u.read()
    [fp.close() for (key, fp) in files]
    return result


def fix(x):
    # we need this to fix up all the dict keys to be strings, not unicode objects
    assert(isinstance(x,dict))
    return dict((str(k), v) for (k,v) in x.iteritems())


########NEW FILE########
