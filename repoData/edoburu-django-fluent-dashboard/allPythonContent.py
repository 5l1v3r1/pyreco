__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# django-fluent-dashboard documentation build configuration file, created by
# sphinx-quickstart on Tue Nov 15 18:45:19 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('.'))
sys.path.insert(0, os.path.abspath('..'))
os.environ['DJANGO_SETTINGS_MODULE'] = 'djangodummy.settings'

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = [
    'sphinx.ext.autodoc',
    'sphinx.ext.intersphinx',
]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'django-fluent-dashboard'
copyright = u'2011-2013, Edoburu'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.4'
# The full version, including alpha/beta/rc tags.
release = '0.4alpha'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'django-fluent-dashboarddoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'django-fluent-dashboard.tex', u'django-fluent-dashboard Documentation',
   u'Diederik van der Boor', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'django-fluent-dashboard', u'django-fluent-dashboard Documentation',
     [u'Diederik van der Boor'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'django-fluent-dashboard', u'django-fluent-dashboard Documentation',
   u'Diederik van der Boor', 'django-fluent-dashboard', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {
    'http://docs.python.org/': None,
    'https://docs.djangoproject.com/en/dev': 'https://docs.djangoproject.com/en/dev/_objects',
    'http://django-admin-tools.readthedocs.org/en/latest/': None,
}

########NEW FILE########
__FILENAME__ = settings
# Settings file to allow parsing API documentation of Django modules,
# and provide defaults to use in the documentation.
#
# This file is placed in a subfolder,
# so the docs root is not used by find_packages()

# Display proper URLs in the docs:
STATIC_URL = '/static/'

########NEW FILE########
__FILENAME__ = appgroups
"""
Splitting and organizing applications and models into groups.
This module is mostly meant for internal use.
"""
from fnmatch import fnmatch
from django.core.exceptions import ImproperlyConfigured
from django.utils.importlib import import_module
from fluent_dashboard import appsettings
import itertools

_groups = [groupdict['models'] for _, groupdict in appsettings.FLUENT_DASHBOARD_APP_GROUPS]

ALL_KNOWN_APPS = list(itertools.chain(*_groups))
if '*' in ALL_KNOWN_APPS:
    ALL_KNOWN_APPS.remove('*')  # Default for CMS group, but not useful here.

MODULE_ALIASES = {
    'AppList': 'admin_tools.dashboard.modules.AppList',
    'ModelList': 'admin_tools.dashboard.modules.ModelList',
    'AppIconList': 'fluent_dashboard.modules.AppIconList',
    'CmsAppIconList': 'fluent_dashboard.modules.CmsAppIconList',
}


def get_application_groups():
    """
    Return the applications of the system, organized in various groups.

    These groups are not connected with the application names,
    but rather with a pattern of applications.
    """

    groups = []
    for title, groupdict in appsettings.FLUENT_DASHBOARD_APP_GROUPS:
        # Allow to pass all possible arguments to the DashboardModule class.
        module_kwargs = groupdict.copy()

        # However, the 'models' is treated special, to have catch-all support.
        if '*' in groupdict['models']:
            default_module = appsettings.FLUENT_DASHBOARD_DEFAULT_MODULE
            module_kwargs['exclude'] = ALL_KNOWN_APPS
            del module_kwargs['models']
        else:
            default_module = 'CmsAppIconList'

        # Get module to display, can be a alias for known variations.
        module = groupdict.get('module', default_module)
        if MODULE_ALIASES.has_key(module):
            module = MODULE_ALIASES[module]
        module_kwargs['module'] = module
        groups.append((title, module_kwargs),)

    return groups


def sort_cms_models(cms_models):
    """
    Sort a set of CMS-related models in a custom (predefined) order.
    """
    cms_models.sort(key=lambda model: (
        get_cms_model_order(model['name']) if is_cms_app(model['app_name']) else 999,
        model['app_name'],
        model['title']
    ))


def is_cms_app(app_name):
    """
    Return whether the given application is a CMS app
    """
    for pat in appsettings.FLUENT_DASHBOARD_CMS_APP_NAMES:
        if fnmatch(app_name, pat):
            return True

    return False


def get_cms_model_order(model_name):
    """
    Return a numeric ordering for a model name.
    """
    for name, order in appsettings.FLUENT_DASHBOARD_CMS_MODEL_ORDER.iteritems():
        if name in model_name:
            return order
    return 999


def get_class(import_path):
    """
    Import a class by name.
    """
    # Used from django-form-designer
    # Copyright (c) 2009, Samuel Luescher, BSD licensed

    try:
        dot = import_path.rindex('.')
    except ValueError:
        raise ImproperlyConfigured("{0} isn't a Python path.".format(import_path))

    module, classname = import_path[:dot], import_path[dot + 1:]
    try:
        mod = import_module(module)
    except ImportError as e:
        raise ImproperlyConfigured('Error importing module {0}: "{1}"'.format(module, e))

    try:
        return getattr(mod, classname)
    except AttributeError:
        raise ImproperlyConfigured('Module "{0}" does not define a "{1}" class.'.format(module, classname))

########NEW FILE########
__FILENAME__ = appsettings
"""
Overview of all settings which can be customized.
"""
from django.conf import settings
from django.utils.translation import ugettext as _

FLUENT_DASHBOARD_ICON_THEME = getattr(settings, "FLUENT_DASHBOARD_ICON_THEME", "oxygen")

# The icon names are somewhat Oxygen specific,
# yet based on the Freedesktop Naming Naming Specification.

FLUENT_DASHBOARD_APP_ICONS = {
    'auth/group': 'resource-group.png',
    'auth/user':  'system-users.png',
    'cms/page': 'internet-web-browser.png',
    'comments/comment': 'kde-telepathy.png', #'irc-voice.png',
    'dashboardmods/rssdashboardmodule': 'feed-subscribe.png',
    'fluent_blogs/entry': 'view-calendar-journal.png',
    'fluent_pages/pagelayout': 'view-choose.png',
    'fluent_pages/page': 'internet-web-browser.png',
    'fiber/contentitem': 'folder-txt.png',
    'fiber/file': 'folder.png',
    'fiber/image': 'folder-image.png',
    'fiber/page': 'internet-web-browser.png',
    'filebrowser/filebrowser': 'folder.png',
    'filer/folder': 'folder.png',
    'form_designer/formdefinition': 'mail-mark-task.png',
    'form_designer/formlog': 'view-calendar-journal.png',
    'google_analytics/analytics': 'view-statistics.png',
    'page/page': 'internet-web-browser.png',
    'media_tree/filenode': 'folder.png',
    'registration/registrationprofile': 'list-add-user.png',
    'sharedcontent/sharedcontent': 'x-office-document.png',
    'sites/site': 'applications-internet.png',
    'snippet/snippet': 'folder-txt.png',
    'tagging/tag': 'feed-subscribe.png',
    'tagging/taggeditem': 'feed-subscribe.png',
    'threadedcomments/threadedcomment': 'kde-telepathy.png', #'irc-voice.png',
    'zinnia/category': 'folder-bookmark.png',
    'zinnia/entry': 'view-calendar-journal.png',
}

FLUENT_DASHBOARD_DEFAULT_ICON = getattr(settings, "FLUENT_DASHBOARD_DEFAULT_ICON", 'unknown.png')

FLUENT_DASHBOARD_CMS_PAGE_MODEL = getattr(settings, "FLUENT_DASHBOARD_CMS_PAGE_MODEL", None)

FLUENT_DASHBOARD_CMS_APP_NAMES = getattr(settings, "FLUENT_DASHBOARD_CMS_APP_NAMES", (
    '*cms*',        # DjangoCMS, FeinCMS and wildcard match  (should not be separate settings, causes errors in admin_tools 0.4.1)
    'fluent*',      # Fluent pages
    'fiber',        # Django-Fiber
    'filebrowser',  # django-filebrowser
    'media_tree',   # django-media-tree
))

FLUENT_DASHBOARD_CMS_MODEL_ORDER = getattr(settings, "FLUENT_DASHBOARD_CMS_MODEL_ORDER", {
    'page': 1,
    'object': 2,
    'layout': 3,
    'content': 4,
    'file': 5,
    'filebrowser': 5,
    'site': 99
})

FLUENT_DASHBOARD_APP_ICONS.update(getattr(settings, 'FLUENT_DASHBOARD_APP_ICONS', {}))

FLUENT_DASHBOARD_DEFAULT_MODULE = getattr(settings, 'FLUENT_DASHBOARD_DEFAULT_MODULE', 'admin_tools.dashboard.modules.AppList')

FLUENT_DASHBOARD_APP_GROUPS = getattr(settings, 'FLUENT_DASHBOARD_APP_GROUPS', (
    (_('CMS'), {
        'models': [
            "{0}.*".format(app) for app in FLUENT_DASHBOARD_CMS_APP_NAMES
        ],
        'module': 'fluent_dashboard.modules.CmsAppIconList',
        'collapsible': False,
    }),
    (_('Interactivity'), {
        'models': (
            'django.contrib.comments.*',
            'form_designer.*',
            'threadedcomments.*',
            'zinnia.*',
        ),
        'module': 'fluent_dashboard.modules.AppIconList',
        'collapsible': False,
    }),
    (_('Administration'), {
        'models': (
            'django.contrib.auth.*',
            'django.contrib.sites.*',
            '*.UserProfile',
            'registration.*',
            'dashboardmods.*',
            'google_analytics.*',
        ),
        'module': 'fluent_dashboard.modules.AppIconList',
        'collapsible': False,
    }),
    (_('Applications'), {
        'models': ('*',),
        'module': FLUENT_DASHBOARD_DEFAULT_MODULE,
        'collapsible': False,
    }),
    #(_('Developer tools'), ()),
))


# Provide defaults for some popular Django CMSes
if not FLUENT_DASHBOARD_CMS_PAGE_MODEL:
    if 'cms' in settings.INSTALLED_APPS:
        FLUENT_DASHBOARD_CMS_PAGE_MODEL = ('cms', 'page')
    elif 'feincms' in settings.INSTALLED_APPS:
        FLUENT_DASHBOARD_CMS_PAGE_MODEL = ('page', 'page')
    elif 'fluent_pages' in settings.INSTALLED_APPS:
        FLUENT_DASHBOARD_CMS_PAGE_MODEL = ('fluent_pages', 'page')

########NEW FILE########
__FILENAME__ = dashboard
"""
Custom dashboards for Django applications.

This package defines the following classes:

* :class:`FluentIndexDashboard`
* :class:`FluentAppIndexDashboard`

These classes need to be linked in ``settings.py`` to be loaded by `django-admin-tools`.
Off course, you can also extend the classes, and use those names in the settings instead.
"""
from admin_tools.dashboard.modules import Group
from django.conf import settings
from django.utils.translation import ugettext_lazy as _

from admin_tools.dashboard import modules, Dashboard, AppIndexDashboard

from fluent_dashboard.modules import PersonalModule, CacheStatusGroup
from fluent_dashboard.appgroups import get_application_groups, get_class



class FluentIndexDashboard(Dashboard):
    """
    A custom home screen for the Django admin interface.

    It displays the application groups based on with :ref:`FLUENT_DASHBOARD_APP_GROUPS` setting.
    To activate the dashboard add the following to your settings.py::

        ADMIN_TOOLS_INDEX_DASHBOARD = 'fluent_dashboard.dashboard.FluentIndexDashboard'

    The dashboard modules are instantiated by the following functions, which can be overwritten:

    * :func:`get_personal_module`
    * :func:`get_application_modules`
    * :func:`get_recent_actions_module`
    * :func:`get_rss_modules`
    * :func:`get_cache_status_modules`

    To have a menu which is consistent with the application groups displayed by this module,
    use the :class:`~fluent_dashboard.menu.FluentMenu` class to render the `admin_tools` menu.

    When overwriting this class, the elements can either be added in
    the :func:`__init__` method, or the :func:`init_with_context` method.
    For more information, see the `django-admin-tools` documentation.
    """
    class Media:
        css = ("fluent_dashboard/dashboard.css",)

    def __init__(self, **kwargs):
        super(FluentIndexDashboard, self).__init__(**kwargs)
        self.children.append(self.get_personal_module())
        self.children.extend(self.get_application_modules())
        self.children.append(self.get_recent_actions_module())


    def init_with_context(self, context):
        request = context['request']
        if 'dashboardmods' in settings.INSTALLED_APPS:
            self.children.extend(self.get_rss_modules())
            self.children.extend(self.get_cache_status_modules(request))


    def get_personal_module(self):
        """
        Instantiate the :class:`~fluent_dashboard.modules.PersonalModule` for use in the dashboard.
        """
        return PersonalModule(
            layout='inline',
            draggable=False,
            deletable=False,
            collapsible=False,
        )


    def get_application_modules(self):
        """
        Instantiate all application modules (i.e.
         :class:`~admin_tools.dashboard.modules.AppList`,
         :class:`~fluent_dashboard.modules.AppIconList` and
         :class:`~fluent_dashboard.modules.CmsAppIconList`)
         for use in the dashboard.
        """
        modules = []
        appgroups = get_application_groups()
        for title, kwargs in appgroups:
            AppListClass = get_class(kwargs.pop('module'))  #e.g. CmsAppIconlist, AppIconlist, Applist
            modules.append(AppListClass(title, **kwargs))
        return modules


    def get_recent_actions_module(self):
        """
        Instantiate the :class:`~admin_tools.dashboard.modules.RecentActions` module for use in the dashboard.
        """
        return modules.RecentActions(_('Recent Actions'), 5, enabled=False, collapsible=False)


    def get_cache_status_modules(self, request):
        """
        Instantiate the :class:`~fluent_dashboard.modules.CacheStatusGroup` module for use in the dashboard.

        This module displays the status of Varnish and Memcache,
        if the :ref:`dashboardmods` package is installed and the caches are configured.
        By default, these modules are only shown for the superuser.
        """
        if not request.user.is_superuser:
            return []

        return [CacheStatusGroup()]


    def get_rss_modules(self):
        """
        Instantiate the RSS modules for use in the dashboard.
        This module displays the RSS feeds of the :ref:`dashboardmods` package, if it is installed, and configured.
        """
        if not 'dashboardmods' in settings.INSTALLED_APPS:
            return []
        import dashboardmods
        return dashboardmods.get_rss_dash_modules()


class FluentAppIndexDashboard(AppIndexDashboard):
    """
    A custom application index page for the Django admin interface.

    This dashboard is displayed when one specific application is opened via the breadcrumb.
    It displays the models and recent actions of the specific application.
    To activate the dashboards add the following to your settings.py::

        ADMIN_TOOLS_APP_INDEX_DASHBOARD = 'fluent_dashboard.dashboard.FluentAppIndexDashboard'
    """

    # disable title because its redundant with the model list module
    title = ''

    def __init__(self, app_title, models, **kwargs):
        super(FluentAppIndexDashboard, self).__init__(app_title, models, **kwargs)
        self.children += (
            self.get_model_list_module(),
            self.get_recent_actions_module(),
        )


    def get_model_list_module(self):
        """
        Instantiate a standard :class:`~admin_tools.dashboard.modules.ModelList` class
        to display the models of this application.
        """
        return modules.ModelList(self.app_title, self.models)


    def get_recent_actions_module(self):
        """
        Instantiate the :class:`~admin_tools.dashboard.modules.RecentActions` module
        for use in the appliation index page.
        """
        return modules.RecentActions(
            _('Recent Actions'),
            include_list=self.get_app_content_types(),
            limit=5,
            enabled=False,
            collapsible=False
        )

########NEW FILE########
__FILENAME__ = items
"""
Additional menu items.
"""
from admin_tools.menu import items
from django.contrib.contenttypes.models import ContentType
from django.core import urlresolvers
from django.core.exceptions import ObjectDoesNotExist
from django.template.defaultfilters import capfirst
from django.utils.translation import ugettext as _
from fluent_dashboard.appgroups import sort_cms_models
import re

RE_CHANGE_URL = re.compile("(.+)_([^_]+)_change")


class CmsModelList(items.ModelList):
    """
    A custom :class:`~admin_tools.menu.items.ModelList` that displays menu items for each model.
    It has a strong bias towards sorting CMS apps on top.
    """
    def init_with_context(self, context):
        """
        Initialize the menu.
        """
        # Apply the include/exclude patterns:
        listitems = self._visible_models(context['request'])

        # Convert to a similar data structure like the dashboard icons have.
        # This allows sorting the items identically.
        models = [
            { 'name': model._meta.module_name,
              'app_name': model._meta.app_label,
              'title': capfirst(model._meta.verbose_name_plural),
              'url': self._get_admin_change_url(model, context)
            }
            for model, perms in listitems if self.is_item_visible(model, perms)
        ]

        # Sort models.
        sort_cms_models(models)

        # Convert to items
        for model in models:
            self.children.append(items.MenuItem(title=model['title'], url=model['url']))


    def is_item_visible(self, model, perms):
        """
        Return whether the model should be displayed in the menu.
        By default it checks for the ``perms['change']`` value; only items with change permission will be displayed.
        This function can be extended to support "view permissions" for example.

        :param model: The model class
        :param perms: The permissions from :func:`ModelAdmin.get_model_perms()<django.contrib.admin.ModelAdmin.get_model_perms>`.
        """
        return perms['change']


class ReturnToSiteItem(items.MenuItem):
    """
    A "Return to site" button for the menu.
    It redirects the user back to the frontend pages.

    By default, it attempts to find the current frontend URL that corresponds
    with the model that's being edited in the admin 'change' page.
    If this is not possible, the default URL (``/``) will be used instead.

    The menu item has a custom ``returntosite`` CSS class to be distinguishable between the other menu items.
    """
    #: Set the default title
    title = _('Return to site')
    #: Set the default URL
    url = '/'
    # Make the item distinguishable between the other menu items
    css_classes = ['returntosite']


    def init_with_context(self, context):
        """
        Find the current URL based on the context.
        It uses :func:`get_edited_object` to find the model,
        and calls ``get_absolute_url()`` to get the frontend URL.
        """
        super(ReturnToSiteItem, self).init_with_context(context)

        # See if the current page is being edited, update URL accordingly.
        edited_model = self.get_edited_object(context['request'])
        if edited_model:
            try:
                url = edited_model.get_absolute_url()
            except (AttributeError, urlresolvers.NoReverseMatch) as e:
                pass
            else:
                if url:
                    self.url = url


    def get_edited_object(self, request):
        """
        Return the object which is currently being edited.
        Returns ``None`` if the match could not be made.
        """
        resolvermatch = urlresolvers.resolve(request.path_info)
        if resolvermatch.namespace == 'admin' and resolvermatch.url_name.endswith('_change'):
            # In "appname_modelname_change" view of the admin.
            # Extract the appname and model from the url name.
            match = RE_CHANGE_URL.match(resolvermatch.url_name)
            if not match:
                return None

            object_id = resolvermatch.args[0]  # Can be string (e.g. a country code as PK).
            return self.get_object_by_natural_key(match.group(1), match.group(2), object_id)
        return None


    def get_object_by_natural_key(self, app_label, model_name, object_id):
        """
        Return a model based on a natural key.
        This is a utility function for :func:`get_edited_object`.
        """
        try:
            model_type = ContentType.objects.get_by_natural_key(app_label, model_name)
        except ContentType.DoesNotExist:
            return None

        try:
            return model_type.get_object_for_this_type(pk=object_id)
        except ObjectDoesNotExist:
            return None

########NEW FILE########
__FILENAME__ = menu
"""
Custom menu for fluent_dashboard apps.
"""
from django.core.urlresolvers import reverse
from django.utils.translation import ugettext_lazy as _
from admin_tools.menu import items, Menu
from admin_tools.utils import get_admin_site_name
from fluent_dashboard.items import CmsModelList, ReturnToSiteItem
from fluent_dashboard.appgroups import get_application_groups


class FluentMenu(Menu):
    """
    Custom Menu for admin site.

    The top level menu items created by this menu reflect the application groups
    defined in :ref:`FLUENT_DASHBOARD_APP_GROUPS`. By using both
    the :class:`~fluent_dashboard.dashboard.FluentIndexDashboard` and this class,
    the menu and dashboard modules at the admin index page will consistent.
    The :class:`~fluent_dashboard.items.ReturnToSiteItem` is also added at the end of the menu.

    To activate the menu add the following to your settings.py::

        ADMIN_TOOLS_MENU = 'fluent_dashboard.menu.FluentMenu'
    """
    def init_with_context(self, context):
        """
        Initialize the menu items.
        """
        site_name = get_admin_site_name(context)

        self.children += [
            items.MenuItem(_('Dashboard'), reverse('{0}:index'.format(site_name))),
            items.Bookmarks(),
        ]

        for title, kwargs in get_application_groups():
            if kwargs.get('enabled', True):
                self.children.append(CmsModelList(title, **kwargs))

        self.children += [
            ReturnToSiteItem()
        ]

########NEW FILE########
__FILENAME__ = modules
"""
Custom modules for the admin dashboard.

This package adds the following classes:

* :class:`AppIconList`
* :class:`CmsAppIconList`
* :class:`PersonalModule`
* :class:`CacheStatusGroup`
"""
import logging
import socket
import django
from django.conf import settings
from django.core.exceptions import ImproperlyConfigured
from django.core.urlresolvers import reverse, NoReverseMatch
from django.db.models.loading import get_model
from django.utils.translation import ugettext as _
from admin_tools.utils import get_admin_site_name
from admin_tools.dashboard import modules
from fluent_dashboard import appsettings
from fluent_dashboard.appgroups import is_cms_app, sort_cms_models


logger = logging.getLogger("fluent_dashboard.modules")


class PersonalModule(modules.LinkList):
    """
    A simple module to display a welcome message.

    .. image:: /images/personalmodule.png
       :width: 471px
       :height: 77px
       :alt: PersonalModule for django-fluent-dashboard

    It renders the template ``fluent_dashboard/modules/personal.html``,
    unless the ``template`` variable is overwritten.
    The module overrides :class:`~admin_tools.dashboard.modules.LinkList`,
    allowing links to be added to the element.
    The :ref:`FLUENT_DASHBOARD_CMS_PAGE_MODEL` setting is used to display a link to the pages module.
    If this setting is not defined, a general text will be displayed instead.
    """
    # Set admin_tools defaults
    draggable = False
    deletable = False
    collapsible = False

    #: Define the title to display
    title = _('Welcome,')

    #: The model to use for the CMS pages link.
    cms_page_model = appsettings.FLUENT_DASHBOARD_CMS_PAGE_MODEL

    #: Define the template to render
    template = 'fluent_dashboard/modules/personal.html'

    def init_with_context(self, context):
        """
        Initializes the link list.
        """
        super(PersonalModule, self).init_with_context(context)
        current_user = context['request'].user
        if django.VERSION < (1, 5):
            current_username = current_user.first_name or current_user.username
        else:
            current_username = current_user.get_short_name() or current_user.get_username()
        site_name = get_admin_site_name(context)

        # Personalize
        self.title = _('Welcome,') + ' ' + (current_username)

        # Expose links
        self.pages_link = None
        self.pages_title = None
        self.password_link = reverse('{0}:password_change'.format(site_name))
        self.logout_link = reverse('{0}:logout'.format(site_name))

        if self.cms_page_model:
            try:
                app_label, model_name = self.cms_page_model
                model = get_model(app_label, model_name)
                pages_title = model._meta.verbose_name_plural.lower()
                pages_link = reverse('{site}:{app}_{model}_changelist'.format(site=site_name, app=app_label.lower(), model=model_name.lower()))
            except AttributeError:
                raise ImproperlyConfigured("The value {0} of FLUENT_DASHBOARD_CMS_PAGE_MODEL setting (or cms_page_model value) does not reffer to an existing model.".format(self.cms_page_model))
            except NoReverseMatch:
                pass
            else:
                # Also check if the user has permission to view the module.'
                if current_user.has_perm('{0}.{1}'.format(model._meta.app_label, model._meta.get_change_permission())):
                    self.pages_title = pages_title
                    self.pages_link = pages_link

    def is_empty(self):
        # Make sure the element is rendered.
        return False


class AppIconList(modules.AppList):
    """
    The list of applications, icon style.

    .. image:: /images/appiconlist.png
       :width: 471px
       :height: 124px
       :alt: AppIconList module for django-fluent-dashboard

    It uses the ``FLUENT_DASHBOARD_APP_ICONS`` setting to find application icons.
    """

    #: Specify the template to render
    template = 'fluent_dashboard/modules/app_icon_list.html'

    # Allow old Django 1.2 MEDIA_URL, but prefer STATIC_URL if it's set.
    #: The current static root (considered read only)
    icon_static_root = getattr(settings, 'STATIC_URL', settings.MEDIA_URL) or settings.MEDIA_URL
    #: The current theme folder (considerd read only)
    icon_theme_root = "{0}fluent_dashboard/{1}/".format(icon_static_root, appsettings.FLUENT_DASHBOARD_ICON_THEME)


    def init_with_context(self, context):
        """
        Initializes the icon list.
        """
        super(AppIconList, self).init_with_context(context)
        apps = self.children

        # Standard model only has a title, change_url and add_url.
        # Restore the app_name and name, so icons can be matched.
        for app in apps:
            app_name = self._get_app_name(app)
            app['name'] = app_name

            for model in app['models']:
                try:
                    model_name = self._get_model_name(model)
                    model['name'] = model_name
                    model['icon'] = self.get_icon_for_model(app_name, model_name) or appsettings.FLUENT_DASHBOARD_DEFAULT_ICON
                except ValueError:
                    model['icon'] = appsettings.FLUENT_DASHBOARD_DEFAULT_ICON

                # Automatically add STATIC_URL before relative icon paths.
                model['icon'] = self.get_icon_url(model['icon'])
                model['app_name'] = app_name


    def _get_app_name(self, appdata):
        """
        Extract the app name from the ``appdata`` that *django-admin-tools* provides.
        """
        return appdata['url'].strip('/').split('/')[-1]   # /foo/admin/appname/


    def _get_model_name(self, modeldata):
        """
        Extract the model name from the ``modeldata`` that *django-admin-tools* provides.
        """
        if 'change_url' in modeldata:
            return modeldata['change_url'].strip('/').split('/')[-1]   # /foo/admin/appname/modelname
        elif 'add_url' in modeldata:
            return modeldata['add_url'].strip('/').split('/')[-2]      # /foo/admin/appname/modelname/add
        else:
            raise ValueError("Missing attributes in modeldata to find the model name!")


    def get_icon_for_model(self, app_name, model_name, default=None):
        """
        Return the icon for the given model.
        It reads the :ref:`FLUENT_DASHBOARD_APP_ICONS` setting.
        """
        key = "{0}/{1}".format(app_name, model_name)
        return appsettings.FLUENT_DASHBOARD_APP_ICONS.get(key, default)


    def get_icon_url(self, icon):
        """
        Replaces the "icon name" with a full usable URL.

        * When the icon is an absolute URL, it is used as-is.
        * When the icon contains a slash, it is relative from the ``STATIC_URL``.
        * Otherwise, it's relative to the theme url folder.
        """
        if not icon.startswith('/') \
        and not icon.startswith('http://') \
        and not icon.startswith('https://'):
            if '/' in icon:
                return self.icon_static_root + icon
            else:
                return self.icon_theme_root + icon
        else:
            return icon



class CmsAppIconList(AppIconList):
    """
    A variation of the :class:`AppIconList` class
    with a strong bias towards sorting CMS apps on top.

    .. image:: /images/cmsappiconlist.png
       :width: 471px
       :height: 124px
       :alt: CmsAppIconList module for django-fluent-dashboard
    """
    def init_with_context(self, context):
        """
        Initializes the icon list.
        """
        super(CmsAppIconList, self).init_with_context(context)
        apps = self.children

        cms_apps     = [a for a in apps if is_cms_app(a['name'])]
        non_cms_apps = [a for a in apps if a not in cms_apps]

        if cms_apps:
            # Group the models of all CMS apps in one group.
            cms_models = []
            for app in cms_apps:
                cms_models += app['models']

            sort_cms_models(cms_models)
            single_cms_app = {'name': "Modules", 'title': "Modules", 'url': "", 'models': cms_models}

            # Put remaining groups after the first CMS group.
            self.children = [single_cms_app] + non_cms_apps


class CacheStatusGroup(modules.Group):
    """
    Display status modules for Varnish en Memcache, in a :class:`~admin_tools.modules.Group` module.

    This module is only displayed when the :ref:`dashboardmods` package
    is installed, added to the ``INSTALLED_APPS``, and the caches are configured and reachable.
    For more information, see the :ref:`optional dependencies <cachestatus>` page.

    .. image:: /images/cachestatusgroup.png
       :width: 471px
       :height: 198px
       :alt: CacheStatusGroup module for django-fluent-dashboard
    """

    #: The default title
    title = _("System status")
    #: The default display mode, can be "tabs", "stacked" or "accordion"
    display = "stacked"
    #: Hide by default
    enabled = False

    def init_with_context(self, context):
        """
        Initializes the status list.
        """
        super(CacheStatusGroup, self).init_with_context(context)

        if 'dashboardmods' in settings.INSTALLED_APPS:
            import dashboardmods
            memcache_mods = dashboardmods.get_memcache_dash_modules()

            try:
                varnish_mods = dashboardmods.get_varnish_dash_modules()
            except (socket.error, KeyError) as e:
                # dashboardmods 2.2 throws KeyError for 'cache_misses' when the Varnish cache is empty.
                # Socket errors are also ignored, to work similar to the memcache stats.
                logger.exception("Unable to request Varnish stats: {0}".format(str(e)))
                varnish_mods = []
            except ImportError:
                varnish_mods = []

            self.children = memcache_mods + varnish_mods

########NEW FILE########
