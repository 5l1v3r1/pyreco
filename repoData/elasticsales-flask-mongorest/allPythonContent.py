__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Flask-MongoRest documentation build configuration file, created by
# sphinx-quickstart on Wed Aug 22 22:13:06 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
sys.path.append(os.path.abspath('_themes'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.coverage']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Flask-MongoRest'
copyright = u'2012, Anthony Nemitz'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.1'
# The full version, including alpha/beta/rc tags.
release = '0.1.1'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'flask_small'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['_themes']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Flask-MongoRestdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Flask-MongoRest.tex', u'Flask-MongoRest Documentation',
   u'Anthony Nemitz', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'flask-mongorest', u'Flask-MongoRest Documentation',
     [u'Anthony Nemitz'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'Flask-MongoRest', u'Flask-MongoRest Documentation',
   u'Anthony Nemitz', 'Flask-MongoRest', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = app
import os

from urlparse import urlparse
from flask import Flask, request
from flask.ext.mongoengine import MongoEngine
from flask.ext.mongoengine.wtf.orm import model_form
from flask.ext.mongorest import MongoRest
from flask.ext.mongorest.views import ResourceView
from flask.ext.mongorest.resources import Resource
from flask.ext.mongorest import operators as ops
from flask.ext.mongorest.methods import *
from flask.ext.mongorest.authentication import AuthenticationBase
from flask.ext.wtf import TextField, length

from example import schemas, documents


app = Flask(__name__)

app.url_map.strict_slashes = False

app.config.update(
    DEBUG = True,
    TESTING = True,
    MONGODB_SETTINGS = {
        'HOST': 'localhost',
        'PORT': 27017,
        'DB': 'mongorest_example_app',
        'TZ_AWARE': True,
    },
)

db = MongoEngine(app)
api = MongoRest(app)

class User(db.Document):
    email = db.EmailField(unique=True, required=True)
    first_name = db.StringField(max_length=50)
    last_name = db.StringField(max_length=50)
    emails = db.ListField(db.EmailField())
    datetime = db.DateTimeField()
    datetime_local = db.DateTimeField()
    balance = db.IntField() # in cents

class UserResource(Resource):
    document = User
    filters = {
        'datetime': [ops.Exact]
    }
    uri_prefix = "/user/"

@api.register()
class UserView(ResourceView):
    resource = UserResource
    methods = [Create, Update, Fetch, List, Delete]

class Content(db.EmbeddedDocument):
    text = db.StringField()
    lang = db.StringField(max_length=3)

class ContentResource(Resource):
    document = Content

class Post(db.Document):
    title = db.StringField(max_length=120, required=True)
    description = db.StringField(max_length=120, required=False)
    author = db.ReferenceField(User)
    editor = db.ReferenceField(User)
    tags = db.ListField(db.StringField(max_length=30))
    user_lists = db.ListField(db.SafeReferenceField(User))
    sections = db.ListField(db.EmbeddedDocumentField(Content))
    content = db.EmbeddedDocumentField(Content)
    is_published = db.BooleanField()

    def primary_user(self):
        return self.user_lists[0] if self.user_lists else None

class PostResource(Resource):
    document = Post
    related_resources = {
        'content': ContentResource,
        'sections': ContentResource, #nested complex objects
        'author': UserResource,
        'editor': UserResource,
        'user_lists': UserResource,
        'primary_user': UserResource,
    }
    filters = {
        'title': [ops.Exact, ops.Startswith, ops.In(allow_negation=True)],
        'author_id': [ops.Exact],
        'is_published': [ops.Boolean],
    }
    rename_fields = {
        'author': 'author_id',
    }

    def get_objects(self, **kwargs):
        qs, has_more = super(PostResource, self).get_objects(**kwargs)
        return qs, has_more, {'more': 'stuff'}

    def get_fields(self):
        fields = super(PostResource, self).get_fields()
        if '_include_primary_user' in request.args:
            fields = set(fields) | set(['primary_user'])
        return fields

    def update_object(self, obj, data=None, save=True, parent_resources=None):
        data = data or self.data
        if data.get('author'):
            author_uri = urlparse(data['author']).path
            author_id = author_uri.lstrip(UserResource.uri_prefix)
            author = User.objects.get(pk=author_id)
            if author.email == 'vincent@vangogh.com':
                obj.tags.append('art')
        return super(PostResource, self).update_object(obj, data, save, parent_resources)

@api.register(name='posts', url='/posts/')
class PostView(ResourceView):
    resource = PostResource
    methods = [Create, Update, BulkUpdate, Fetch, List, Delete]

class LimitedPostResource(Resource):
    document = Post
    related_resources = {
        'content': ContentResource,
    }

@api.register(name='limited_posts', url='/limited_posts/')
class LimitedPostView(ResourceView):
    resource = LimitedPostResource
    methods = [Create, Update, Fetch, List]

class DummyAuthenication(AuthenticationBase):
    def authorized(self):
        return False

@api.register(name='auth', url='/auth/')
class DummyAuthView(ResourceView):
    resource = PostResource
    methods = [Create, Update, Fetch, List, Delete]
    authentication_methods = [DummyAuthenication]

@api.register(name='restricted', url='/restricted/')
class RestrictedPostView(ResourceView):
    """This class allows us to put restrictions in place regarding
       who/what can be read, changed, added or deleted"""
    resource = PostResource
    methods = [Create, Update, Fetch, List, Delete]

    # Can't read a post if it isn't published
    def has_read_permission(self, request, qs):
        return qs.filter(is_published=True)

    # Can't add a post in a published state
    def has_add_permission(self, request, obj):
        return not obj.is_published

    # Can't change a post if it is published
    def has_change_permission(self, request, obj):
        return not obj.is_published

    # Can't delete a post if it is published
    def has_delete_permission(self, request, obj):
        return not obj.is_published

class TestDocument(db.Document):
    name = db.StringField()
    other = db.StringField()
    dictfield = db.DictField()
    is_new = db.BooleanField()

TestBaseForm = model_form(TestDocument)

class TestForm(TestBaseForm):
    name = TextField(validators=[length(min=3, max=8)])

class TestResource(Resource):
    form = TestForm
    document = TestDocument

class TestFormResource(Resource):
    form = TestForm
    document = TestDocument
    uri_prefix = "/testform/"

class TestFieldsResource(Resource):
    document = TestDocument
    fields = ['id', 'name', 'upper_name']

    def upper_name(self, obj):
        return obj.name.upper()

@api.register(name='test', url='/test/')
class TestView(ResourceView):
    resource = TestResource
    methods = [Create, Update, Fetch, List]

@api.register(name='testform', url='/testform/')
class TestFormView(ResourceView):
    resource = TestFormResource
    methods = [Create, Update, Fetch, List, BulkUpdate]


@api.register(name='testfields', url='/testfields/')
class TestFieldsResource(ResourceView):
    resource = TestFieldsResource
    methods = [Create, Update, Fetch, List]

class LanguageResource(Resource):
    document = documents.Language

class PersonResource(Resource):
    document = documents.Person
    schema = schemas.Person
    related_resources = {
        'languages': LanguageResource,
    }
    save_related_fields = ['languages']

@api.register(name='person', url='/person/')
class PersonView(ResourceView):
    resource = PersonResource
    methods = [Create, Update, Fetch, List]

# extra resources for testing max_limit
class Post10Resource(PostResource):
    max_limit = 10

class Post250Resource(PostResource):
    max_limit = 250

@api.register(name='posts10', url='/posts10/')
class Post10View(ResourceView):
    resource = Post10Resource
    methods = [Create, Update, BulkUpdate, Fetch, List, Delete]

@api.register(name='posts250', url='/posts250/')
class Post250View(ResourceView):
    resource = Post250Resource
    methods = [Create, Update, BulkUpdate, Fetch, List, Delete]

# Documents, resources, and views for testing differences between db refs and object ids
class A(db.Document):
    txt = db.StringField()

class B(db.Document):
    ref = db.ReferenceField(A, dbref=True)
    txt = db.StringField()

class C(db.Document):
    ref = db.ReferenceField(A)
    txt = db.StringField()

class AResource(Resource):
    document = A

class BResource(Resource):
    document = B

class CResource(Resource):
    document = C

@api.register(url='/a/')
class AView(ResourceView):
    resource = AResource
    methods = [Create, Update, BulkUpdate, Fetch, List, Delete]

@api.register(url='/b/')
class AView(ResourceView):
    resource = BResource
    methods = [Create, Update, BulkUpdate, Fetch, List, Delete]

@api.register(url='/c/')
class AView(ResourceView):
    resource = CResource
    methods = [Create, Update, BulkUpdate, Fetch, List, Delete]


# Documents, resources, and views for testing method permissions
class MethodTestDoc(db.Document):
    txt = db.StringField()

class MethodTestResource(Resource):
    document = MethodTestDoc

@api.register(url='/create_only/')
class CreateOnlyView(ResourceView):
    resource = MethodTestResource
    methods = [Create]

@api.register(url='/update_only/')
class UpdateOnlyView(ResourceView):
    resource = MethodTestResource
    methods = [Update]

@api.register(url='/bulk_update_only/')
class BulkUpdateOnlyView(ResourceView):
    resource = MethodTestResource
    methods = [BulkUpdate]

@api.register(url='/fetch_only/')
class FetchOnlyView(ResourceView):
    resource = MethodTestResource
    methods = [Fetch]

@api.register(url='/list_only/')
class ListOnlyView(ResourceView):
    resource = MethodTestResource
    methods = [List]

@api.register(url='/delete_only/')
class DeleteOnlyView(ResourceView):
    resource = MethodTestResource
    methods = [Delete]

class ViewMethodTestDoc(db.Document):
    txt = db.StringField()

class ViewMethodTestResource(Resource):
    document = ViewMethodTestDoc

@api.register(url='/test_view_method/')
class TestViewMethodView(ResourceView):
    resource = ViewMethodTestResource
    methods = [Create, Update, BulkUpdate, Fetch, List, Delete]

    def _dispatch_request(self, *args, **kwargs):
        super(TestViewMethodView, self)._dispatch_request(*args, **kwargs)
        return { 'method': self._resource.view_method.__name__ }


if __name__ == "__main__":
    port = int(os.environ.get('PORT', 8000))
    app.run(host='0.0.0.0', port=port)


########NEW FILE########
__FILENAME__ = documents
from mongoengine import *

class Language(Document):
    name = StringField()

class Person(Document):
    name = StringField()
    languages = ListField(ReferenceField(Language))

########NEW FILE########
__FILENAME__ = schemas
from cleancat import *

from example import documents

class Language(Schema):
    name = String()

class Person(Schema):
    name = String()
    languages = List(MongoEmbeddedReference(documents.Language, Language), required=False)

########NEW FILE########
__FILENAME__ = authentication
class AuthenticationBase(object):
    def authorized(self):
        return False 

########NEW FILE########
__FILENAME__ = exceptions

class MongoRestException(Exception):
    def __init__(self, message):
        self._message = message
    def _get_message(self): 
        return self._message
    def _set_message(self, message): 
        self._message = message
    message = property(_get_message, _set_message)

class OperatorNotAllowed(MongoRestException):
    def __init__(self, operator_name):
        self.op_name = operator_name 
    def __unicode__(self):
        return u'"'+self.op_name+'" is not a valid operator name.'

class InvalidFilter(MongoRestException):
    pass
 
class ValidationError(MongoRestException):
    pass

class UnknownFieldError(Exception):
    pass

########NEW FILE########
__FILENAME__ = methods
class Create:
    method = 'POST'

class Update:
    method = 'PUT'

class BulkUpdate:
    method = 'PUT'

class Fetch:
    method = 'GET'

class List:
    method = 'GET'

class Delete:
    method = 'DELETE'

########NEW FILE########
__FILENAME__ = operators
class Operator(object):
    op = 'exact'

    # Can be overridden via constructor.
    allow_negation = False

    def __init__(self, allow_negation=False):
        self.allow_negation = allow_negation

    # Lets us specify filters as an instance if we want to override the
    # default arguments (in addition to specifying them as a class).
    def __call__(self):
        return self

    def prepare_queryset_kwargs(self, field, value, negate):
        if negate:
            return {'__'.join(filter(None, [field, 'not', self.op])): value}
        else:
            return {'__'.join(filter(None, [field, self.op])): value}

    def apply(self, queryset, field, value, negate=False):
        kwargs = self.prepare_queryset_kwargs(field, value, negate)
        return queryset.filter(**kwargs)

class Ne(Operator):
    op = 'ne'

class Lt(Operator):
    op = 'lt'

class Lte(Operator):
    op = 'lte'

class Gt(Operator):
    op = 'gt'

class Gte(Operator):
    op = 'gte'

class Exact(Operator):
    op = 'exact'

    def prepare_queryset_kwargs(self, field, value, negate):
        # Using <field>__exact causes mongoengine to generate a regular
        # expresison query, which we'd like to avoid.
        if negate:
            return {'%s__ne' % field: value}
        else:
            return {field: value}

class IExact(Operator):
    op = 'iexact'

class In(Operator):
    op = 'in'

    def prepare_queryset_kwargs(self, field, value, negate):
        # only use 'in' or 'nin' if multiple values are specified
        if ',' in value:
            value = value.split(',')
            op = negate and 'nin' or self.op
        else:
            op = negate and 'ne' or ''
        return {'__'.join(filter(None, [field, op])): value}

class Contains(Operator):
    op = 'contains'
    
class IContains(Operator):
    op = 'icontains'

class Startswith(Operator):
    op = 'startswith'
    
class IStartswith(Operator):
    op = 'istartswith'

class Endswith(Operator):
    op = 'endswith'
    
class IEndswith(Operator):
    op = 'iendswith'

class Boolean(Operator):
    op = 'exact'

    def prepare_queryset_kwargs(self, field, value, negate):
        if value == 'false':
            bool_value = False
        else:
            bool_value = True

        if negate:
            bool_value = not bool_value

        return {field: bool_value}


########NEW FILE########
__FILENAME__ = resources
import json
import datetime
import dateutil.parser
import mongoengine

from bson.dbref import DBRef
from bson.objectid import ObjectId
from flask import request, url_for
from urlparse import urlparse
from mongoengine.base.proxy import DocumentProxy
from mongoengine.fields import EmbeddedDocumentField, ListField, ReferenceField, GenericReferenceField
from mongoengine.fields import DateTimeField, DictField
from werkzeug.datastructures import MultiDict

from cleancat import ValidationError as SchemaValidationError
from flask.ext.mongorest.exceptions import ValidationError, UnknownFieldError
from flask.ext.mongorest.utils import cmp_fields, isbound, isint
from flask.ext.mongorest.utils import MongoEncoder


class ResourceMeta(type):
    def __init__(cls, name, bases, classdict):
        if classdict.get('__metaclass__') is not ResourceMeta:
            for document,resource in cls.child_document_resources.iteritems():
                if resource == name:
                    cls.child_document_resources[document] = cls
        type.__init__(cls, name, bases, classdict)

class Resource(object):
    document = None # required
    fields = None
    readonly_fields = ['id']
    form = None
    schema = None
    related_resources = {}
    related_resources_hints = {} #@todo this should be integrated into the related_resources dict, possibly as a tuple
    save_related_fields = []
    rename_fields = {}
    child_document_resources = {}
    paginate = True
    select_related = False
    allowed_ordering = []
    uri_prefix = None # Must start and end with a "/"
    max_limit = 100 # cap the number of records in the _limit param to avoid DDoS'ing the API.
    default_limit = 100 # default limit if no _limit is specified

    __metaclass__ = ResourceMeta

    def __init__(self):
        doc_fields = self.document._fields.keys()
        if self.fields == None:
            self.fields = doc_fields
        self._related_resources = self.get_related_resources()
        self._rename_fields = self.get_rename_fields()
        self._reverse_rename_fields = {}
        for k, v in self._rename_fields.iteritems():
            self._reverse_rename_fields[v] = k
        assert len(self._rename_fields) == len(self._reverse_rename_fields), \
            'Cannot rename multiple fields to the same name'
        self._filters = self.get_filters()
        self._child_document_resources = self.get_child_document_resources()
        self.data = None
        self._dirty_fields = None

    @property
    def raw_data(self):
        if not hasattr(self, '_raw_data'):
            if request.method in ('PUT', 'POST'):
                if request.mimetype and 'json' not in request.mimetype:
                    raise ValidationError({'error': "Please send valid JSON with a 'Content-Type: application/json' header."})

                try:
                    self._raw_data = json.loads(request.data)
                except ValueError:
                    raise ValidationError({'error': 'The request contains invalid JSON.'})
                if not isinstance(self._raw_data, dict):
                    raise ValidationError({'error': 'JSON data must be a dict.'})
            else:
                self._raw_data = {}

        return self._raw_data

    @classmethod
    def uri(self, path):
        """This generates a URI reference for the given path"""
        if self.uri_prefix:
            ret = self.uri_prefix+path
            return ret
        else:
            raise ValueError("Cannot generate URI for resources that do not specify a uri_prefix")

    @classmethod
    def _url(self, path):
        """This generates a complete URL for the given path.  Requires application context."""
        if self.uri_prefix:
            url = url_for(self.uri_prefix.lstrip("/").rstrip("/"),_external=True)
            ret = url+path
            return ret
        else:
            raise ValueError("Cannot generate URL for resources that do not specify a uri_prefix")

    def get_fields(self):
        return self.fields

    def get_optional_fields(self):
        return []

    def get_requested_fields(self, **kwargs):
        params = kwargs.get('params', None)

        include_all = False

        if 'fields' in kwargs:
            fields = kwargs['fields']
            all_fields_set = set(fields)
        else:
            fields = self.get_fields()
            all_fields_set = set(fields) | set(self.get_optional_fields())

        if params and '_fields' in params:
            only_fields = set(params['_fields'].split(','))
            if '_all' in only_fields:
                include_all = True
        else:
            only_fields = None

        requested_fields = []
        if include_all or only_fields == None:
            if include_all:
                field_selection = all_fields_set
            else:
                field_selection = fields
            for field in field_selection:
                requested_fields.append(field)
        else:
            for field in only_fields:
                actual_field = self._reverse_rename_fields.get(field, field)
                if actual_field in all_fields_set:
                    requested_fields.append(actual_field)

        return requested_fields

    def get_related_resources(self):
        return self.related_resources

    def get_save_related_fields(self):
        return self.save_related_fields

    def get_rename_fields(self):
        """
        @TODO should automatically support model_id for reference fields (only) and model for related_resources
        """
        return self.rename_fields

    def get_child_document_resources(self):
        return self.child_document_resources

    def get_filters(self):
        filters = {}
        for field, operators in getattr(self, 'filters', {}).iteritems():
            field_filters = {}
            for op in operators:
                if op.op == 'exact':
                    field_filters[''] = op
                field_filters[op.op] = op
            filters[field] = field_filters
        return filters


    def serialize_field(self, obj, **kwargs):
        if self.uri_prefix and hasattr(obj, "id"):
            return self._url(str(obj.id))
        else:
            return self.serialize(obj, **kwargs)

    def serialize(self, obj, **kwargs):
        if not obj:
            return {}

        # If a subclass of an obj has been called with a base class' resource,
        # use the subclass-specific serialization
        if obj.__class__ in self._child_document_resources \
        and self._child_document_resources[obj.__class__] != self.__class__:
            return obj and self._child_document_resources[obj.__class__]().serialize_field(obj, **kwargs)

        def get(obj, field_name, field_instance=None):
            """
            @TODO needs significant cleanup
            """

            has_field_instance = bool(field_instance)
            field_instance = field_instance or self.document._fields.get(field_name, None) or getattr(self.document, field_name, None)

            if has_field_instance:
                field_value = obj
            elif isinstance(obj, dict):
                return obj[field_name]
            else:
                try:
                    field_value = getattr(obj, field_name)
                except AttributeError:
                    raise UnknownFieldError

            if isinstance(field_instance, (ReferenceField, GenericReferenceField, EmbeddedDocumentField)):
                if field_name in self._related_resources:
                    return field_value and not isinstance(field_value, DBRef) and self._related_resources[field_name]().serialize_field(field_value, **kwargs)
                else:
                    if isinstance(field_value, DocumentProxy):
                        # Don't perform a DBRef isinstance check below since
                        # it might trigger an extra query.
                        return field_value.to_dbref()
                    if isinstance(field_value, DBRef):
                        return field_value
                    return field_value and field_value.to_dbref()
            elif isinstance(field_instance, ListField):
                return [val for val in [get(elem, field_name, field_instance=field_instance.field) for elem in field_value] if val]
            elif isinstance(field_instance, DictField):
                if field_instance.field:
                    return dict(
                        (key, get(elem, field_name,
                                  field_instance=field_instance.field))
                        for (key, elem) in field_value.iteritems())
                else:
                    return field_value
            elif callable(field_instance):
                if isinstance(field_value, list):
                    value = field_value
                else:
                    if isbound(field_instance):
                        value = field_instance()
                    elif isbound(field_value):
                        value = field_value()
                    else:
                        value = field_instance(obj)

                if field_name in self._related_resources:
                    if isinstance(value, list):
                        return [self._related_resources[field_name]().serialize_field(o, **kwargs) for o in value]
                    elif value is None:
                        return None
                    else:
                        return self._related_resources[field_name]().serialize_field(value, **kwargs)
                return value
            return field_value

        requested_fields = self.get_requested_fields(**kwargs)

        # We're passing kwargs to child resources so we don't want the fields.
        kwargs.pop('fields', None)
        kwargs.pop('params', None)

        data = {}
        for field in requested_fields:
            renamed_field = self._rename_fields.get(field, field)

            if hasattr(self, field) and callable(getattr(self, field)):
                value = getattr(self, field)(obj)
                if field in self._related_resources and value is not None:
                    related_resource = self._related_resources[field]()
                    if isinstance(value, mongoengine.document.Document):
                        value = related_resource.serialize_field(value)
                    elif isinstance(value, dict):
                        value = dict((k, related_resource.serialize_field(v))
                                     for (k, v) in value.iteritems())
                    else:  # assume queryset or list
                        value = [related_resource.serialize_field(o)
                                 for o in value]
                data[renamed_field] = value
            else:
                try:
                    data[renamed_field] = get(obj, field)
                except UnknownFieldError:
                    try:
                        data[renamed_field] = self.value_for_field(obj, field)
                    except UnknownFieldError:
                        pass

        return data

    def value_for_field(self, obj, field):
        # If we specify a field which doesn't exist on the resource or on the
        # object, this method lets us return a custom value.
        raise UnknownFieldError

    def validate_request(self, obj=None):
        # Don't work on original raw data, we may reuse the resource for bulk updates.
        self.data = self.raw_data.copy()

        if not self.schema and self.form:

            if request.method == 'PUT' and obj != None:
                # We treat 'PUT' like 'PATCH', i.e. when fields are not
                # specified, existing values are used.

                # TODO: This is not implemented properly for nested objects yet.

                obj_data = self.serialize(obj)
                obj_data.update(self.data)

                self.data = obj_data

        # @TODO this should rename form fields otherwise in a resource you could say "model_id" and in a form still have to use "model".

        # Do renaming in two passes to prevent potential multiple renames depending on dict traversal order.
        # E.g. if a -> b, b -> c, then a should never be renamed to c.
        fields_to_delete = []
        fields_to_update = {}
        for k, v in self._rename_fields.iteritems():
            if self.data.has_key(v):
                fields_to_update[k] = self.data[v]
                fields_to_delete.append(v)
        for k in fields_to_delete:
            del self.data[k]
        for k, v in fields_to_update.iteritems():
            self.data[k] = v

        if self.schema:
            if request.method == 'PUT' and obj != None:
                obj_data = dict([(key, getattr(obj, key)) for key in obj._fields.keys()])
            else:
                obj_data = None

            schema = self.schema(self.data, obj_data)
            try:
                self.data = schema.full_clean()
            except SchemaValidationError:
                raise ValidationError({'field-errors': schema.field_errors, 'errors': schema.errors })

        elif self.form:
            # We need to convert JSON data into form data.
            # e.g. { "people": [ { "name": "A" } ] } into { "people-0-name": "A" }
            def json_to_form_data(prefix, json_data):
                form_data = {}
                for k, v in json_data.iteritems():
                    if isinstance(v, list): # FieldList
                        for n, el in enumerate(v):
                            if isinstance(el, dict): # only dict type is supported
                                form_data.update(json_to_form_data('%s%s-%d-' % (prefix, k, n), el))
                    else:
                        if isinstance(v, dict): # DictField
                            v = json.dumps(v, cls=MongoEncoder)
                        if isinstance(v, bool) and v == False: # BooleanField
                            v = []
                        if isinstance(v, datetime.datetime): # DateTimeField
                            v = v.strftime('%Y-%m-%d %H:%M:%S')
                        if isinstance(v, DBRef): # ReferenceField
                            v = v.id
                        if v is None:
                            v = ''
                        form_data['%s%s' % (prefix, k)] = v
                return form_data

            json_data = json_to_form_data('', self.data)
            data = MultiDict(json_data)
            form = self.form(data, csrf_enabled=False)

            if not form.validate():
                raise ValidationError({'field-errors': form.errors})

            self.data = form.data

    def get_queryset(self):
        return self.document.objects

    def get_object(self, pk, qfilter=None):
        qs = self.get_queryset()
        # If a queryset filter was provided, pass our current
        # queryset in and get a new one out
        if qfilter:
            qs = qfilter(qs)
        return qs.get(pk=pk)

    def fetch_related_resources(self, objs, only_fields=None):
        document_queryset = {}
        for obj in objs:
            for field_name in self.related_resources_hints.keys():
                if only_fields != None and field_name not in only_fields:
                    continue
                resource = self.get_related_resources()[field_name]
                method = getattr(obj, field_name)
                if callable(method):
                    q = method()
                    if field_name in document_queryset.keys():
                        document_queryset[field_name] = (document_queryset[field_name] | q._query_obj)
                    else:
                        document_queryset[field_name] = q._query_obj

        hints = {}
        for k,v in document_queryset.iteritems():
            doc = self.get_related_resources()[k].document

            query = doc.objects.filter(v)

            # Don't let MongoDB do the sorting as it won't use the index.
            # Store the ordering so we can do client sorting afterwards.
            ordering = query._ordering or query._get_order_by(query._document._meta['ordering'])
            query = query.order_by()

            results = [o for o in query] # don't use list() because mongoengine will do a count query

            if ordering:
                document_queryset[k] = sorted(results, cmp_fields(ordering))
            else:
                document_queryset[k] = results

            hint_index = {}
            if k in self.related_resources_hints.keys():
                hint_field = self.related_resources_hints[k]
                for obj in document_queryset[k]:
                    hinted = str(getattr(obj, hint_field).id)
                    if hinted not in hint_index:
                        hint_index[hinted] = [obj]
                    else:
                        hint_index[hinted].append(obj)

                hints[k] = hint_index

        for obj in objs:
            for field, hint_index in hints.iteritems():
                obj_id = obj.id
                if isinstance(obj_id, DBRef):
                    obj_id = obj_id.id
                elif isinstance(obj_id, ObjectId):
                    obj_id = str(obj_id)
                if obj_id not in hint_index.keys():
                    setattr(obj, field, [])
                    continue
                setattr(obj, field, hint_index[obj_id])

    def apply_filters(self, qs, params=None):
        if params is None:
            params = request.args

        for key, value in params.iteritems():
            # If this is a resource identified by a URI, we need
            # to extract the object id at this point since
            # MongoEngine only understands the object id
            if self.uri_prefix:
                url = urlparse(value)
                uri = url.path
                value = uri.lstrip(self.uri_prefix)
            negate = False
            op_name = ''
            parts = key.split('__')
            for i in range(len(parts) + 1, 0, -1):
                field = '__'.join(parts[:i])
                allowed_operators = self._filters.get(field)
                if allowed_operators:
                    parts = parts[i:]
                    break
            if allowed_operators is None:
                continue

            if parts:
                # either an operator or a query lookup!  See what's allowed.
                op_name = parts[-1]
                if op_name in allowed_operators:
                    # operator; drop it
                    parts.pop()
                else:
                    # assume it's part of a lookup
                    op_name = ''
                if parts and parts[-1] == 'not':
                    negate = True
                    parts.pop()

            operator = allowed_operators.get(op_name, None)
            if operator is None:
                continue
            if negate and not operator.allow_negation:
                continue
            if parts:
                field = '%s__%s' % (field, '__'.join(parts))
            field = self._reverse_rename_fields.get(field, field)
            qs = operator().apply(qs, field, value, negate)
        return qs

    def apply_ordering(self, qs, params=None):
        if params is None:
            params = request.args
        if self.allowed_ordering and params.get('_order_by') in self.allowed_ordering:
            order_params = [self._reverse_rename_fields.get(p, p) for p in params['_order_by'].split(',')]
            qs = qs.order_by(*order_params)
        return qs

    def get_skip_and_limit(self, params=None):
        if params is None:
            params = request.args
        if self.paginate:
            # _limit and _skip validation
            if not isint(params.get('_limit', 1)):
                raise ValidationError({'error': '_limit must be an integer (got "%s" instead).' % params['_limit']})
            if not isint(params.get('_skip', 1)):
                raise ValidationError({'error': '_skip must be an integer (got "%s" instead).' % params['_skip']})
            if params.get('_limit') and int(params['_limit']) > self.max_limit:
                raise ValidationError({'error': "The limit you set is larger than the maximum limit for this resource (max_limit = %d)." % self.max_limit})

            limit = min(int(params.get('_limit', self.default_limit)), self.max_limit)
            # Fetch one more so we know if there are more results.
            return int(params.get('_skip', 0)), limit
        else:
            return 0, self.max_limit

    def get_objects(self, all=False, qs=None, qfilter=None):
        params = request.args
        custom_qs = True
        if qs is None:
            custom_qs = False
            qs = self.get_queryset()

        # If a queryset filter was provided, pass our current
        # queryset in and get a new one out
        if qfilter:
            qs = qfilter(qs)

        qs = self.apply_filters(qs, params)
        qs = self.apply_ordering(qs, params)

        limit = None
        if not custom_qs and not all:
            skip, limit = self.get_skip_and_limit(params)
            qs = qs.skip(skip).limit(limit+1)

        # Needs to be at the end as it returns a list.
        if self.select_related:
            qs = qs.select_related()

        if limit is not None and self.paginate:
            # It is OK to evaluate the queryset as we will do so anyway.
            qs = [o for o in qs] # don't use list() because mongoengine will do a count query
            has_more = len(qs) == limit+1
            if has_more:
                qs = qs[:-1]
        else:
            has_more = None

        # bulk-fetch related resources for moar speed
        if self.related_resources_hints:
            self.fetch_related_resources(qs, self.get_requested_fields(params=request.args))

        return qs, has_more

    def _get(self, method, data, field_name, field_instance=None, parent_resources=None):
        """
        @TODO needs significant cleanup
        """
        if not parent_resources:
            parent_resources = []

        field_data_value = data if field_instance else data[field_name]
        field_instance = field_instance or getattr(self.document, field_name)

        if isinstance(field_instance, ReferenceField):
            if field_name in self._related_resources:
                restype = self.get_related_resources()[field_name]
                if restype.uri_prefix:
                    url = urlparse(field_data_value)
                    uri = url.path
                    objid = uri.lstrip(restype.uri_prefix)
                    qobj = field_instance.document_type.objects.get(pk=objid)
                    retobj = qobj.to_dbref()
                    return retobj
                return restype().create_object(data=field_data_value, save=True, parent_resources=parent_resources+[self])
            else:
                if isinstance(field_data_value, mongoengine.Document):
                    return field_data_value
                return field_data_value and field_instance.document_type.objects.get(pk=field_data_value).to_dbref()

        elif isinstance(field_instance, DateTimeField):
            if isinstance(field_data_value, datetime.datetime):
                return field_data_value
            else:
                return field_data_value and dateutil.parser.parse(field_data_value)

        elif isinstance(field_instance, EmbeddedDocumentField):
            if field_data_value == None:
                return # no embedded document
            if field_name in self._related_resources:
                if isinstance(field_data_value, self.get_related_resources()[field_name].document):
                    return field_data_value
                return self.get_related_resources()[field_name]().create_object(data=field_data_value, save=False, parent_resources=parent_resources+[self])
            else:
                return {} # dummy embedded document

        elif isinstance(field_instance, ListField):
            def expand_list(inner_field, inner_data):
                if isinstance(inner_field, ListField):
                    return [expand_list(inner_field.field, elem) for elem in inner_data]
                elif isinstance(inner_field, EmbeddedDocumentField):
                    if isinstance(inner_data, self.get_related_resources()[field_name].document):
                        return inner_data
                    return self.get_related_resources()[field_name]().create_object(data=inner_data, save=False, parent_resources=parent_resources+[self])
                else:
                    return self._get(method, inner_data, field_name, field_instance=inner_field, parent_resources=parent_resources)
            return [expand_list(field_instance.field, elem) for elem in field_data_value]

        elif isinstance(field_instance, DictField) and field_instance.field:
            def expand_map(inner_field, inner_data):
                if isinstance(inner_field, DictField) and inner_field.field:
                    return dict(
                        (key, expand_map(inner_field.field, elem))
                        for key, elem in inner_data.items())
                elif isinstance(inner_field, EmbeddedDocumentField):
                    return self.related_resources[field_name]().create_object(data=inner_data, save=False, parent_resources=parent_resources+[self])
                else:
                    return self._get(method, inner_data, field_name, field_instance=inner_field, parent_resources=parent_resources)
            return dict(
                (key, expand_map(field_instance.field, elem))
                for key, elem in field_data_value.items())
        else:
            return field_data_value

    def save_related_objects(self, obj, parent_resources=None):
        if not parent_resources:
            parent_resources = [self]
        else:
            parent_resources += [self]

        if self._dirty_fields:
            for field_name in set(self._dirty_fields) & set(self.get_save_related_fields()):
                try:
                    related_resource = self.get_related_resources()[field_name]
                except KeyError:
                    related_resource = None

                field_instance = getattr(self.document, field_name)

                # If it's a ReferenceField, just save it.
                if isinstance(field_instance, ReferenceField):
                    instance = getattr(obj, field_name)
                    if instance:
                        if related_resource:
                            related_resource().save_object(instance, parent_resources=parent_resources)
                        else:
                            instance.save()

                # If it's a ListField(ReferenceField), save all instances.
                if isinstance(field_instance, ListField) and isinstance(field_instance.field, ReferenceField):
                    instance_list = getattr(obj, field_name)
                    for instance in instance_list:
                        if related_resource:
                            related_resource().save_object(instance, parent_resources=parent_resources)
                        else:
                            instance.save()

    def save_object(self, obj, **kwargs):
        self.save_related_objects(obj, **kwargs)
        obj.save()
        obj.reload()

        self._dirty_fields = None # No longer dirty.

    def _save(self, obj):
        try:
            self.save_object(obj)
        except mongoengine.ValidationError, e:
            def serialize_errors(errors):
                if hasattr(errors, 'iteritems'):
                    return dict((k, serialize_errors(v)) for (k, v) in errors.iteritems())
                else:
                    return unicode(errors)
            raise ValidationError({'field-errors': serialize_errors(e.errors)})

    def create_object(self, data=None, save=True, parent_resources=None):
        kwargs = {}
        data = data or self.data
        self._dirty_fields = []
        for field in self.get_fields():
            if field in self.document._fields.keys() and field not in self.readonly_fields and (type(data) is list or (type(data) is dict and data.has_key(field))):
                if self.schema:
                    kwargs[field] = data[field]
                    self._dirty_fields.append(field)
                else:
                    # TODO: remove old code
                    kwargs[field] = self._get('create_object', data, field, parent_resources=parent_resources)
        obj = self.document(**kwargs)
        if save:
            self._save(obj)
        return obj

    def update_object(self, obj, data=None, save=True, parent_resources=None):
        def equal(a, b):
            # Two mongoengine objects are equal if their ID is equal. However,
            # in this case we want to check if the data is equal. Note this
            # doesn't look into mongoengine documents which are nested within
            # mongoengine documents.
            def cmp(a, b):
                try:
                    return a == b
                except: # Exception during comparison, mainly datetimes.
                    return False
            if not cmp(a, b):
                return False
            else:
                if isinstance(a, list):
                    return all([equal(m, n) for (m, n) in zip(a, b)])
                elif isinstance(a, dict):
                    return all([equal(m, n) for (m, n) in zip(a.values(), b.values())])
                elif isinstance(a, mongoengine.Document):
                    # Don't evaluate lazy documents
                    if getattr(a, '_lazy', False) and getattr(b, '_lazy', False):
                        return True
                    return cmp(a.to_dict(), b.to_dict())
                else:
                    return True

        self._dirty_fields = []
        data = data or self.data

        # For updates, we want to update only the fields that appear in the request data rather than
        # re-updating all the document's existing/other fields.
        raw_fields = [self._reverse_rename_fields.get(field, field) for field in self.raw_data.keys()]
        fields = self.get_fields() if not obj.pk else list(set(self.get_fields()) & set(raw_fields))
        for field in fields:
            if self.schema:
                if (field in self.document._fields.keys() and
                    field not in self.readonly_fields and
                    (type(data) is list or (type(data) is dict and field in data))
                   ):
                    update = False

                    # If we're comparing reference fields, only compare ids without hitting the database
                    if isinstance(obj._fields.get(field), ReferenceField):
                        db_val = obj._db_data.get(field)
                        id_from_obj = db_val and getattr(db_val, 'id', db_val)
                        id_from_data = data.get(field) and data[field].pk
                        if id_from_obj != id_from_data:
                            update = True
                    elif not equal(getattr(obj, field), data[field]):
                        update = True

                    if update:
                        setattr(obj, field, data[field])
                        self._dirty_fields.append(field)
            else:
                # TODO: remove old code
                if field in self.document._fields.keys() and field not in self.readonly_fields and field in data:
                    if field in self._related_resources and not hasattr(self._related_resources[field], 'uri_prefix'):
                        field_instance = getattr(self.document, field)
                        if isinstance(field_instance, ReferenceField) or (isinstance(field_instance, ListField) and isinstance(field_instance.field, ReferenceField)):
                            continue # Not implemented.
                    setattr(obj, field, self._get('update_object', data, field, parent_resources=parent_resources))
        if save:
            self._save(obj)

        return obj

    def delete_object(self, obj, parent_resources=None):
        obj.delete()


########NEW FILE########
__FILENAME__ = utils
import json
import decimal
import datetime
from bson.dbref import DBRef
from bson.objectid import ObjectId

isbound = lambda m: getattr(m, 'im_self', None) is not None

def isint(int_str):
    try:
        int(int_str)
        return True
    except ValueError:
        return False

class MongoEncoder(json.JSONEncoder):
    def default(self, value, **kwargs):
        if isinstance(value, ObjectId):
            return unicode(value)
        elif isinstance(value, DBRef):
            return value.id
        if isinstance(value, datetime.datetime):
            return value.isoformat()
        if isinstance(value, datetime.date):
            return value.strftime("%Y-%m-%d")
        if isinstance(value, decimal.Decimal):
            return str(value)
        return super(MongoEncoder, self).default(value, **kwargs)

def cmp_fields(ordering):
    # Takes a list of fields and directions and returns a
    # comparison function for sorted() to perform client-side
    # sorting.
    # Example: sorted(objs, cmp_fields([('date_created', -1)]))
    def _cmp(x, y):
        for field, direction in ordering:
            result = cmp(getattr(x, field), getattr(y, field)) * direction
            if result:
                return result
        return 0
    return _cmp

########NEW FILE########
__FILENAME__ = views
import json
import mimerender
import mongoengine

from flask import request, render_template
from werkzeug.exceptions import NotFound, Unauthorized

from flask.ext.mongorest.exceptions import ValidationError
from flask.ext.mongorest.utils import MongoEncoder
from flask.ext.mongorest import methods
from flask.ext.views.base import View

mimerender = mimerender.FlaskMimeRender()

render_json = lambda **payload: json.dumps(payload, cls=MongoEncoder)
render_html = lambda **payload: render_template('mongorest/debug.html', data=json.dumps(payload, cls=MongoEncoder, sort_keys=True, indent=4))


class ResourceView(View):
    resource = None
    methods = []
    authentication_methods = []

    def __init__(self):
        assert(self.resource and self.methods)

    @mimerender(default='json', json=render_json, html=render_html)
    def dispatch_request(self, *args, **kwargs):
        # keep all the logic in a helper method (_dispatch_request) so that
        # it's easy for subclasses to override this method (when they don't want to use
        # this mimerender decorator) without them also having to copy/paste all the
        # authentication logic, etc.
        return self._dispatch_request(*args, **kwargs)

    def _dispatch_request(self, *args, **kwargs):
        authorized = True if len(self.authentication_methods) == 0 else False
        for authentication_method in self.authentication_methods:
            if authentication_method().authorized():
                authorized = True
        if not authorized:
            return {'error': 'Unauthorized'}, '401 Unauthorized'

        try:
            self._resource = self.requested_resource(request)
            return super(ResourceView, self).dispatch_request(*args, **kwargs)
        except mongoengine.queryset.DoesNotExist as e:
            return {'error': 'Empty query: ' + str(e)}, '404 Not Found'
        except mongoengine.ValidationError as e:
            return e.message, '400 Bad Request'
        except ValidationError as e:
            return e.message, '400 Bad Request'
        except Unauthorized as e:
            return {'error': 'Unauthorized'}, '401 Unauthorized'
        except NotFound as e:
            return {'error': unicode(e)}, '404 Not Found'

    def requested_resource(self, request):
        """In the case where the Resource that this view is associated with points to a Document class
           that allows inheritance, this method should indicate the specific Resource class to use
           when processing POST and PUT requests through information available in the request
           itself or through other means."""
        # Default behavior is to use the (base) resource class
        return self.resource()

    def get(self, **kwargs):
        pk = kwargs.pop('pk', None)

        # Set the view_method on a resource instance
        if pk:
            self._resource.view_method = methods.Fetch
        else:
            self._resource.view_method = methods.List


        # Create a queryset filter to control read access to the
        # underlying objects
        qfilter = lambda qs: self.has_read_permission(request, qs.clone())
        if pk is None:
            result = self._resource.get_objects(qfilter=qfilter)

            # Result usually contains objects and a has_more bool. However, in case where
            # more data is returned, we include it at the top level of the response dict
            if len(result) == 2:
                objs, has_more = result
                extra = {}
            elif len(result) == 3:
                objs, has_more, extra = result
            else:
                raise ValueError('Unsupported value of resource.get_objects')

            # Serialize the objects one by one
            ret = {
                'data': [self._resource.serialize(obj, params=request.args) for obj in objs]
            }

            if has_more != None:
                ret['has_more'] = has_more

            if extra:
                ret.update(extra)
        else:
            obj = self._resource.get_object(pk, qfilter=qfilter)
            ret = self._resource.serialize(obj, params=request.args)
        return ret

    def post(self, **kwargs):
        if 'pk' in kwargs:
            raise NotFound("Did you mean to use PUT?")

        # Set the view_method on a resource instance
        self._resource.view_method = methods.Create

        self._resource.validate_request()
        obj = self._resource.create_object()

        # Check if we have permission to create this object
        if not self.has_add_permission(request, obj):
            raise Unauthorized

        ret = self._resource.serialize(obj, params=request.args)
        if isinstance(obj, mongoengine.Document) and self._resource.uri_prefix:
            return ret, "201 Created", {"Location": self._resource._url(str(obj.id))}
        else:
            return ret

    def put(self, **kwargs):
        pk = kwargs.pop('pk', None)

        # Set the view_method on a resource instance
        if pk:
            self._resource.view_method = methods.Update
        else:
            self._resource.view_method = methods.BulkUpdate

        if pk is None:
            # Bulk update where the body contains the new values for certain
            # fields.

            # Currently, fetches all the objects and validate them separately.
            # If one of them fails, a ValidationError for this object will be
            # triggered.
            # Ideally, this would be translated into an update statement for
            # performance reasons and would perform the update either for all
            # objects, or for none, if (generic) validation fails. Since this
            # is a bulk update, only the count of objects which were updated is
            # returned.

            result = self._resource.get_objects(all=True)
            if len(result) == 2:
                objs, has_more = result
            elif len(result) == 3:
                objs, has_more, extra = result
            count = 0
            try:
                for obj in objs:
                    self._resource.validate_request(obj)
                    obj = self._resource.update_object(obj)
                    # Raise or skip?
                    if not self.has_change_permission(request, obj):
                        raise Unauthorized
                    obj.save()
                    count += 1
            except ValidationError, e:
                e.message['count'] = count
                raise e
            else:
                return {'count': count}
        else:
            obj = self._resource.get_object(pk)
            # Check if we have permission to change this object
            if not self.has_change_permission(request, obj):
                raise Unauthorized
            self._resource.validate_request(obj)
            obj = self._resource.update_object(obj)
            ret = self._resource.serialize(obj, params=request.args)
            return ret

    def delete(self, **kwargs):
        pk = kwargs.pop('pk', None)

        # Set the view_method on a resource instance
        self._resource.view_method = methods.Delete

        obj = self._resource.get_object(pk)

        # Check if we have permission to delete this object
        if not self.has_delete_permission(request, obj):
            raise Unauthorized

        self._resource.delete_object(obj)
        return {}

    # This takes a QuerySet as an argument and then
    # returns a query set that this request can read
    def has_read_permission(self, request, qs):
        return qs

    def has_add_permission(self, request, obj):
        return True

    def has_change_permission(self, request, obj):
        return True

    def has_delete_permission(self, request, obj):
        return True


########NEW FILE########
