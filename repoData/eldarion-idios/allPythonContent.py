__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# idios documentation build configuration file, created by
# sphinx-quickstart on Fri May 28 12:50:21 2010.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.append(os.path.abspath('.'))
sys.path.append(os.path.abspath('..'))
os.environ["DJANGO_SETTINGS_MODULE"] = "settings"

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = [
    'sphinx.ext.autodoc',
]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.txt'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'idios'
copyright = u'2010, Eldarion'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.1'
# The full version, including alpha/beta/rc tags.
release = '0.1.dev6'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'eldarion'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['_theme']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
html_logo = "_theme/eldarion/static/eldarion_logo_medium.png"

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'idiosdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'idios.tex', u'idios Documentation',
   u'Eldarion', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'idios', u'idios Documentation',
     [u'Eldarion'], 1)
]

########NEW FILE########
__FILENAME__ = settings

########NEW FILE########
__FILENAME__ = middleware
import re

from django import forms
from django.conf import settings
from django.db import models
from django.template import RequestContext
from django.shortcuts import render_to_response, redirect
from django.views.decorators.csrf import csrf_protect

from idios.utils import get_profile_model


class AdditionalInfoMiddleware(object):
    
    def process_request(self, request):
        exemptions = [
            r"^%s" % settings.MEDIA_URL,
            r"^%s" % settings.STATIC_URL,
            r"^/__debug__",
            r"^/account", # @@@ hack for now
        ]
        for exemption in exemptions:
            if re.match(exemption, request.path):
                return None
        kickstart = request.session.get("idios_additional_info_kickstart")
        if kickstart:
            return handle_additional_info(request)


@csrf_protect
def handle_additional_info(request):
    if request.user.is_authenticated():
        profile = request.user.get_profile()
        missing_fields = []
        # look for fields which are required on the model
        for field in profile.idios_required_fields():
            name = isinstance(field, tuple) and field[0] or field
            db_field = profile._meta.get_field(name)
            value = getattr(profile, db_field.attname)
            if isinstance(db_field, (models.CharField, models.TextField)):
                missing = not value
            else:
                missing = value is None
            if missing:
                if not isinstance(field, tuple):
                    missing_fields.append((field, db_field.formfield()))
                else:
                    missing_fields.append(field)
        if not missing_fields:
            return None
        attrs = {}
        for field in missing_fields:
            attrs[field[0]] = field[1]
        AdditionalInfoForm = type("AdditionalInfoForm", (forms.Form,), attrs)
        if request.method == "POST":
            form = AdditionalInfoForm(request.POST, request.FILES)
            if form.is_valid():
                request.session.pop("idios_additional_info_kickstart", None)
                for field, value in form.cleaned_data.iteritems():
                    setattr(profile, field, value)
                profile.save()
                return redirect(request.path)
        else:
            form = AdditionalInfoForm()
        ctx = {
            "form": form,
        }
        return render_to_response(
            "idios/additional_info.html",
            RequestContext(request, ctx)
        )

########NEW FILE########
__FILENAME__ = models
from django.core.urlresolvers import reverse
from django.db import models
from django.db.models.signals import post_save
from django.utils.translation import ugettext_lazy as _

from django.contrib.auth.models import User

import idios

from idios.utils import get_profile_model, get_profile_form

try:
    from pinax.apps.account.signals import user_logged_in
except ImportError:
    user_logged_in = None


class ClassProperty(property):
    
    def __get__(self, cls, owner):
        return self.fget.__get__(None, owner)()


class ProfileBase(models.Model):
    
    # @@@ could be unique=True if subclasses don't inherit a concrete base class
    # @@@ need to look at this more
    user = models.ForeignKey(User, verbose_name=_("user"))
    
    class Meta:
        verbose_name = _("profile")
        verbose_name_plural = _("profiles")
        abstract = True
    
    def __unicode__(self):
        return self.user.username
    
    def get_absolute_url(self):
        if idios.settings.MULTIPLE_PROFILES:
            # @@@ using PK here is kind of ugly. the alternative is to
            # generate a unique slug for each profile, which is tricky
            kwargs = {
                "profile_slug": self.profile_slug,
                "pk": self.pk
            }
        else:
            if idios.settings.USE_USERNAME:
                kwargs = {"username": self.user.username}
            else:
                kwargs = {"pk": self.pk}
        return reverse("profile_detail", kwargs=kwargs)
    
    @classmethod
    def get_form(cls):
        return get_profile_form(cls)
    
    def _default_profile_slug(cls):
        return cls._meta.module_name
    
    profile_slug = ClassProperty(classmethod(_default_profile_slug))


def create_profile(sender, instance=None, **kwargs):
    if instance is None:
        return
    profile, created = get_profile_model().objects.get_or_create(user=instance)
post_save.connect(create_profile, sender=User)


def additional_info_kickstart(sender, **kwargs):
    request = kwargs.get("request")
    request.session["idios_additional_info_kickstart"] = True
if user_logged_in: # protect against Pinax not being available
    user_logged_in.connect(additional_info_kickstart)

########NEW FILE########
__FILENAME__ = idios_tags
from django import template


register = template.Library()


@register.inclusion_tag("idios/profile_item.html")
def show_profile(user):
    return {"user": user}


@register.simple_tag
def clear_search_url(request):
    GET = request.GET.copy()
    if "search" in getvars:
        del GET["search"]
    if len(GET.keys()) > 0:
        return "%s?%s" % (request.path, GET.urlencode())
    else:
        return request.path

########NEW FILE########
__FILENAME__ = models
from django.db import models

from idios.models import ProfileBase


class SimpleProfile(ProfileBase):
    
    name = models.CharField(max_length=100)


class SecretIdentityProfile(ProfileBase):
    super_power = models.CharField(max_length=100)
    profile_slug = "secret"


class SecretVillainProfile(SecretIdentityProfile):
    
    fiendish_plot = models.CharField(max_length=100)

########NEW FILE########
__FILENAME__ = tests
from test_models import *
from test_utils import *
from test_views import *
########NEW FILE########
__FILENAME__ = test_models
from django.test import TestCase

from django.conf import settings
from django.contrib.auth.models import User

from idios.tests.utils import IdiosSettingsTestCase
from idios.tests.models import SimpleProfile, SecretIdentityProfile


__all__ = ["TestProfileBase", "TestProfileBaseMultiProfiles"]


class TestProfileBase(TestCase):
    
    fixtures = ["test_idios"]
    
    def test_auto_created(self):
        self.assertEqual(User.objects.count(),
                         SimpleProfile.objects.count())
    
    def test_get_absolute_url(self):
        p = SimpleProfile.objects.get(user__username="joe")
        self.assertEqual(p.get_absolute_url(), "/profiles/profile/joe/")
    
    def test_default_profile_slug(self):
        self.assertEqual(SimpleProfile.profile_slug, "simpleprofile")
    
    def test_unicode(self):
        p = SimpleProfile.objects.get(user__username="joe")
        self.assertEqual(unicode(p), "joe")


class TestProfileBaseMultiProfiles(IdiosSettingsTestCase):
    
    fixtures = ["test_idios"]
    setting_overrides = {
        "IDIOS_PROFILE_MODULES": ["tests.SecretIdentityProfile"]
    }
    
    def test_non_default_profile_not_auto_created(self):
        self.assertEqual(SecretIdentityProfile.objects.count(), 0)
    
    def test_get_absolute_url_default_profile(self):
        p = SimpleProfile.objects.get(user__username="joe")
        self.assertEqual(
            p.get_absolute_url(),
            "/profiles/simpleprofile/profile/%s/" % p.pk
        )
    
    def test_get_absolute_url_alternate_profile(self):
        p = SecretIdentityProfile.objects.create(user=User.objects.get(username="joe"))
        self.assertEqual(
            p.get_absolute_url(),
            "/profiles/secret/profile/%s/" % p.pk
        )
    
    def test_override_profile_slug(self):
        self.assertEqual(SecretIdentityProfile.profile_slug, "secret")

########NEW FILE########
__FILENAME__ = test_utils
from django.test import TestCase

from django.contrib.auth.models import SiteProfileNotAvailable

from idios import utils
from idios.tests.utils import IdiosSettingsTestCase
from idios.tests.models import SimpleProfile, SecretIdentityProfile


__all__ = [
    "TestUtils",
    "TestUtilsNoProfile",
    "TestUtilsMultiProfiles",
    "TestUtilsMultiProfilesBase"
]


class TestUtils(TestCase):
    
    def test_get_profile_base(self):
        """
        In a single-profile configuration, the profile base is the
        default profile.
        
        """
        self.assert_(utils.get_profile_base() is SimpleProfile)
    
    def test_get_profile_model(self):
        self.assert_(utils.get_profile_model() is SimpleProfile)
    
    def test_invalid_profile_model(self):
        utils.idios.settings.DEFAULT_PROFILE_MODULE = "tests.NonExistentProfile"
        self.assertRaises(SiteProfileNotAvailable, utils.get_profile_model)
        utils.idios.settings.DEFAULT_PROFILE_MODULE = "tests.SimpleProfile"
    
    def test_profile_form(self):
        form_class = utils.get_profile_form()
        form = form_class(data={})
        self.assertEqual(form.is_valid(), False)
        self.assertEqual(form.errors["name"], [u"This field is required."])


class TestUtilsNoProfile(IdiosSettingsTestCase):
    
    setting_overrides = {"AUTH_PROFILE_MODULE": None}
    
    def test_no_profile_model(self):
        self.assertRaises(SiteProfileNotAvailable, utils.get_profile_model)


class TestUtilsMultiProfiles(IdiosSettingsTestCase):
    
    setting_overrides = {
        "IDIOS_PROFILE_MODULES": ["tests.SecretIdentityProfile"]
    }
    
    def test_get_profile_base(self):
        """
        In a multi-profile configuration without IDIOS_PROFILE_BASE,
        the profile base is the default profile.
        
        """
        self.assert_(utils.get_profile_base() is SimpleProfile)
    
    def test_get_default_profile_model(self):
        self.assert_(utils.get_profile_model() is SimpleProfile)
    
    def test_get_alt_profile_model(self):
        self.assert_(utils.get_profile_model("secret") is SecretIdentityProfile)
    
    def test_get_invalid_profile_model(self):
        self.assertEqual(utils.get_profile_model("doesntexist"), None)
    
    def test_alt_profile_form(self):
        form_class = utils.get_profile_form(SecretIdentityProfile)
        form = form_class(data={})
        self.assertEqual(form.is_valid(), False)
        self.assertEqual(form.errors["super_power"], [u"This field is required."])


class TestUtilsMultiProfilesBase(IdiosSettingsTestCase):
    setting_overrides = {
        "IDIOS_PROFILE_MODULES": ["tests.SecretIdentityProfile"],
        "IDIOS_PROFILE_BASE": "tests.SecretIdentityProfile"
    }
    
    def test_get_profile_base(self):
        self.assert_(utils.get_profile_base() is SecretIdentityProfile)
    
    def test_invalid_profile_base(self):
        utils.idios.settings.PROFILE_BASE = "tests.NonExistentProfile"
        self.assertRaises(SiteProfileNotAvailable, utils.get_profile_base)
        utils.idios.settings.PROFILE_BASE = "tests.SecretIdentityProfile"

########NEW FILE########
__FILENAME__ = test_views
from django.test import TestCase

from django.contrib.auth.models import User, SiteProfileNotAvailable
from django.core.urlresolvers import reverse

from idios import utils
from idios.tests.utils import IdiosSettingsTestCase
from idios.tests.models import SimpleProfile, SecretIdentityProfile, SecretVillainProfile


__all__ = ["TestViews", "TestViewsMultiProfiles"]


class TestViews(IdiosSettingsTestCase):
    
    fixtures = ["test_idios"]
    
    def test_profiles(self):
        response = self.client.get(reverse("profile_list"))
        self.assertEqual(response.template.name, "idios/profiles.html")
        self.assertEqual(
            [str(p) for p in response.context["profiles"]],
            ["bob", "joe"]
        )
    
    def test_profile(self):
        response = self.client.get(
            reverse("profile_detail", kwargs={"username": "joe"})
        )
        self.assertEqual(response.template.name, "idios/profile.html")
        self.assertEqual(str(response.context["profile"]), "joe")
    
    def test_edit_profile(self):
        logged_in = self.client.login(username="joe", password="test")
        self.assert_(logged_in)
        response = self.client.get(reverse("profile_edit"))
        self.assertEqual(response.status_code, 200)
        response = self.client.post(
            reverse("profile_edit"), {"name": "Joe Doe"}
        )
        self.assertRedirects(response, "/profiles/profile/joe/")
        self.assertEqual(
            SimpleProfile.objects.get(user__username="joe").name,
            "Joe Doe"
        )
    
    def test_nonexistent_profile_slug_returns_404(self):
        logged_in = self.client.login(username="joe", password="test")
        self.assert_(logged_in)
        for url_name in ["profile_list", "profile_edit", "profile_create"]:
            url = reverse(url_name, kwargs={"profile_slug": "bad"})
            response = self.client.get(url)
            self.assertEqual(response.status_code, 404)


class TestViewsMultiProfiles(TestViews):
    fixtures = ["test_idios"]
    setting_overrides = {
        "IDIOS_PROFILE_MODULES": ["tests.SecretIdentityProfile"],
        "IDIOS_PROFILE_BASE": "tests.SecretIdentityProfile"
    }
    
    def test_non_default_profiles(self):
        profile = SecretIdentityProfile.objects.create(
            user=User.objects.get(username="joe"),
            super_power="x-ray vision"
        )
        response = self.client.get(
            reverse("profile_list", kwargs={"profile_slug": "secret"})
        )
        self.assertEqual(response.template.name, "idios/profiles.html")
        self.assertEqual(len(response.context["profiles"]), 1)
        self.assertEqual(response.context["profiles"][0], profile)
    
    def test_all_profiles(self):
        profile1 = SecretIdentityProfile.objects.create(
            user=User.objects.get(username="joe"),
            super_power="x-ray vision"
        )
        profile2 = SecretVillainProfile.objects.create(
            user=User.objects.get(username="bob"),
            super_power="cackling",
            fiendish_plot="world domination"
        )
        response = self.client.get(reverse("profile_list_all"))
        self.assertEqual(response.template.name, "idios/profiles.html")
        self.assertEqual(
            [p.super_power for p in response.context["profiles"]],
            ["x-ray vision", "cackling"]
        )
    
    def test_alternative_profile(self):
        profile = SecretIdentityProfile.objects.create(
            user=User.objects.get(username="joe"),
            super_power="x-ray vision"
        )
        response = self.client.get(
            reverse("profile_detail", kwargs={
                "profile_slug": "secret",
                "profile_pk": profile.pk
            })
        )
        self.assertEqual(response.template.name, "idios/profile.html")
        self.assertEqual(
            response.context["profile"].super_power,
            "x-ray vision"
        )
    
    def test_edit_profile(self):
        logged_in = self.client.login(username="joe", password="test")
        self.assert_(logged_in)
        response = self.client.get(reverse("profile_edit"))
        self.assertEqual(response.status_code, 200)
        response = self.client.post(
            reverse("profile_edit"),
            {"name": "Joe Doe"}
        )
        profile = SimpleProfile.objects.get(user__username="joe")
        self.assertRedirects(response, "/profiles/simpleprofile/profile/%s/" % profile.pk)
        self.assertEqual(profile.name, "Joe Doe")
    
    def test_edit_alternative_profile(self):
        profile = SecretIdentityProfile.objects.create(
            user=User.objects.get(username="joe"),
            super_power="x-ray vision"
        )
        logged_in = self.client.login(username="joe", password="test")
        self.assert_(logged_in)
        url = reverse("profile_edit", kwargs={"profile_slug": "secret"})
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        response = self.client.post(url, {"super_power": "night vision"})
        self.assertRedirects(response, "/profiles/secret/profile/%s/" % profile.pk)
        self.assertEqual(
            SecretIdentityProfile.objects.get(user__username="joe").super_power,
            "night vision"
        )
    
    def test_create_profile(self):
        logged_in = self.client.login(username="joe", password="test")
        self.assert_(logged_in)
        url = reverse("profile_create", kwargs={"profile_slug": "secret"})
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        response = self.client.post(url, {"super_power": "night vision"})
        profile = SecretIdentityProfile.objects.get(user__username="joe")
        self.assertRedirects(response, "/profiles/secret/profile/%s/" % profile.pk)
        self.assertEqual(profile.super_power, "night vision")

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *


urlpatterns = patterns("",
    url(r"^profiles/", include("idios.urls"))
)
########NEW FILE########
__FILENAME__ = utils
from django.conf import settings
from django.test import TestCase

import idios


# this would make a lovely context manager, but... 2.4 :(
class SettingsTestCase(TestCase):
    setting_overrides = {}
    NOT_FOUND = object()
    
    def _pre_setup(self):
        self._original_settings = {}
        for k,v in self.setting_overrides.items():
            self._original_settings[k] = getattr(settings, k, self.NOT_FOUND)
            if v is self.NOT_FOUND:
                delattr(settings, k)
            else:
                setattr(settings, k, v)
        super(SettingsTestCase, self)._pre_setup()
    
    def _post_teardown(self):
        super(SettingsTestCase, self)._post_teardown()
        for k,v in self._original_settings.items():
            if v is self.NOT_FOUND:
                delattr(settings, k)
            else:
                setattr(settings, k, v)


class IdiosSettingsTestCase(SettingsTestCase):
    def _pre_setup(self):
        super(IdiosSettingsTestCase, self)._pre_setup()
        idios.settings = idios.IdiosSettings()
    
    def _post_teardown(self):
        super(IdiosSettingsTestCase, self)._post_teardown()
        idios.settings = idios.IdiosSettings()

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import patterns, url

import idios
from idios.views import ProfileListView, ProfileDetailView, ProfileUpdateView, ProfileCreateView


if not idios.settings.USE_USERNAME:
    profile_detail_default = url(r"^profile/(?P<pk>\d+)/$", ProfileDetailView.as_view(), name="profile_detail")
else:
    profile_detail_default = url(r"^profile/(?P<username>[\w\._-]+)/$", ProfileDetailView.as_view(), name="profile_detail")


urlpatterns = patterns("idios.views",
    
    url(r"^$", ProfileListView.as_view(), name="profile_list"),
    url(r"^all/$", ProfileListView.as_view(all_profiles=True), name="profile_list_all"),
        
    url(r"^edit/$", ProfileUpdateView.as_view(), name="profile_edit"),
    url(r"^(?P<profile_slug>[\w\._-]+)/edit/$", ProfileUpdateView.as_view(), name="profile_edit"),
    
    url(r"^create/$", ProfileCreateView.as_view(), name="profile_create"),
    url(r"^(?P<profile_slug>[\w\._-]+)/create/$", ProfileCreateView.as_view(), name="profile_create"),
    
    profile_detail_default,
    url(r"^(?P<profile_slug>[\w\._-]+)/profile/(?P<pk>\d+)/$", ProfileDetailView.as_view(), name="profile_detail"),
    
    url(r"^(?P<profile_slug>[\w\._-]+)/$", ProfileListView.as_view(), name="profile_list"),
)

########NEW FILE########
__FILENAME__ = utils
"""
Utility functions for retrieving and generating forms for the
site-specific user profile model specified in the
``AUTH_PROFILE_MODULE`` or ``IDIOS_PROFILE_MODULES`` settings.

This file was pulled from django-profiles as it made the most sense. Slightly
modified for Eldarion standards.

"""
from django import forms
from django.db.models import get_model

from django.contrib.auth.models import SiteProfileNotAvailable

import idios


def get_profile_base():
    """
    Return a profile model class which is a concrete base class for
    all profile models (used for querying on all profiles).
    
    If multiple-profiles are not in use, this will be the single
    profile model class itself.
    
    If multiple-profiles are in use, this will be the model class
    referenced by the ``IDIOS_PROFILE_BASE`` setting.  If
    ``IDIOS_PROFILE_BASE`` is not set (some projects may not have a
    concrete base class for all profile classes), then querying all
    profiles is not possible, and the all-profiles view will simply
    query the default profile model. (Idios' own ``ProfileBase`` is
    abstract and thus non-queryable.)
    
    If the appropriate setting does not resolve to an actual model,
    raise ``django.contrib.auth.models.SiteProfileNotAvailable``.
    
    """
    if idios.settings.MULTIPLE_PROFILES and idios.settings.PROFILE_BASE:
        module = idios.settings.PROFILE_BASE
    else:
        module = idios.settings.DEFAULT_PROFILE_MODULE
    model = get_model(*module.split("."))
    if model is None:
        raise SiteProfileNotAvailable
    return model


def get_profile_model(profile_slug=None):
    """
    Return the model class for the profile module identified by the
    given ``profile_slug``, as defined in the ``AUTH_PROFILE_MODULE``
    or ``IDIOS_PROFILE_MODULES`` settings.
    
    If ``profile_slug`` is not provided, return the default profile
    model.
    
    If no matching profile model is found, return None.
    
    If no default profile model is found, raise
    ``django.contrib.auth.models.SiteProfileNotAvailable``.
    
    """
    if profile_slug is None:
        module = idios.settings.DEFAULT_PROFILE_MODULE
        if module is None:
            raise SiteProfileNotAvailable
        model = get_model(*module.split("."))
        if model is None:
            raise SiteProfileNotAvailable
    else:
        for module in idios.settings.PROFILE_MODULES:
            model = get_model(*module.split("."))
            if model and profile_slug == model.profile_slug:
                break
            else:
                model = None
    return model


def get_profile_form(profile_model=None):
    """
    Return a form class (a subclass of the default ``ModelForm``)
    suitable for creating/editing instances of the given user profile
    model.
    
    """
    if profile_model is None:
        profile_model = get_profile_model()
    class _ProfileForm(forms.ModelForm):
        class Meta:
            model = profile_model
            exclude = ["user"] # user will be filled in by the view.
    return _ProfileForm

########NEW FILE########
__FILENAME__ = views
from django.core.exceptions import ObjectDoesNotExist
from django.conf import settings
from django.http import HttpResponse, Http404, HttpResponseRedirect
from django.shortcuts import get_object_or_404
from django.template import RequestContext
from django.template.loader import render_to_string
from django.utils import simplejson as json
from django.utils.decorators import method_decorator

from django.contrib.auth.decorators import login_required
from django.contrib.auth.models import User

try:
    from django.views.generic import ListView, DetailView, CreateView, UpdateView
except ImportError:
    try:
        from cbv import ListView, DetailView, CreateView, UpdateView
    except ImportError:
        raise ImportError(
            "It appears you are running a version of Django < "
            "1.3. To use idios with this version of Django, install "
            "django-cbv==0.1.5."
        )

import idios
from idios.utils import get_profile_model, get_profile_base


class ProfileListView(ListView):
    """
    List all profiles of a given type (or the default type, if
    profile_slug is not given.)
    
    If all_profiles is set to True, all profiles are listed.
    """
    template_name = "idios/profiles.html"
    context_object_name = "profiles"
    all_profiles = False
    
    def get_model_class(self):
        profile_slug = self.kwargs.get("profile_slug", None)
        
        if self.all_profiles:
            profile_class = get_profile_base()
        else:
            profile_class = get_profile_model(profile_slug)
        
        if profile_class is None:
            raise Http404
        
        return profile_class
    
    def get_queryset(self):
        profiles = self.get_model_class().objects.select_related()
        profiles = profiles.order_by("-date_joined")
        
        search_terms = self.request.GET.get("search", "")
        order = self.request.GET.get("order", "date")
        
        if search_terms:
            profiles = profiles.filter(user__username__icontains=search_terms)
        if order == "date":
            profiles = profiles.order_by("-user__date_joined")
        elif order == "name":
            profiles = profiles.order_by("user__username")
        
        return profiles
    
    def get_context_data(self, **kwargs):
        search_terms = self.request.GET.get("search", "")
        order = self.request.GET.get("order", "date")
        
        ctx = {
            "order": order,
            "search_terms": search_terms,
        }
        ctx.update(super(ProfileListView, self).get_context_data(**kwargs))
        
        return ctx


class ProfileDetailView(DetailView):
    
    template_name = "idios/profile.html"
    context_object_name = "profile"
    
    def get_object(self):
        profile_class = get_profile_model(self.kwargs.get("profile_slug"))
        
        if profile_class is None:
            raise Http404
        
        if idios.settings.USE_USERNAME:
            self.page_user = get_object_or_404(User, username=self.kwargs["username"])
            profile = get_object_or_404(profile_class, user=self.page_user)
        else:
            profile = get_object_or_404(profile_class, pk=self.kwargs["pk"])
            self.page_user = profile.user
        
        if not self.request.user.has_perm("can_view", obj=profile):
            raise Http404
        
        return profile
    
    def get_context_data(self, **kwargs):
        base_profile_class = get_profile_base()
        profiles = base_profile_class.objects.filter(user=self.page_user)
        
        is_me = self.request.user == self.page_user
        
        ctx = {
            "is_me": is_me,
            "page_user": self.page_user,
            "profiles": profiles,
        }
        ctx.update(super(ProfileDetailView, self).get_context_data(**kwargs))
        
        return ctx


class ProfileCreateView(CreateView):
    
    template_name = "idios/profile_create.html"
    template_name_ajax = "idios/profile_create_ajax.html"
    
    def get_template_names(self):
        if self.request.is_ajax():
            return [self.template_name_ajax]
        else:
            return [self.template_name]
    
    def get_form_class(self):
        if self.form_class:
            return self.form_class
        
        profile_class = get_profile_model(self.kwargs.get("profile_slug"))
        
        if profile_class is None:
            raise Http404
        
        return profile_class.get_form()
    
    def form_valid(self, form):
        profile = form.save(commit=False)
        profile.user = self.request.user
        profile.save()
        self.object = profile
        
        return HttpResponseRedirect(self.get_success_url())
    
    def get_context_data(self, **kwargs):
        ctx = super(ProfileCreateView, self).get_context_data(**kwargs)
        ctx["profile_form"] = ctx["form"]
        return ctx
    
    def get_success_url(self):
        if self.success_url:
            return self.success_url
        return self.object.get_absolute_url()
    
    @method_decorator(login_required)
    def dispatch(self, *args, **kwargs):
        return super(ProfileCreateView, self).dispatch(*args, **kwargs)


class ProfileUpdateView(UpdateView):
    
    template_name = "idios/profile_edit.html"
    template_name_ajax = "idios/profile_edit_ajax.html"
    template_name_ajax_success = "idios/profile_edit_ajax_success.html"
    context_object_name = "profile"
    
    def get_template_names(self):
        if self.request.is_ajax():
            return [self.template_name_ajax]
        else:
            return [self.template_name]
    
    def get_form_class(self):
        if self.form_class:
            return self.form_class
        
        profile_class = get_profile_model(self.kwargs.get("profile_slug"))
        
        if profile_class is None:
            raise Http404
        
        return profile_class.get_form()
    
    def get_object(self, queryset=None):
        profile_class = get_profile_model(self.kwargs.get("profile_slug"))
        
        if profile_class is None:
            raise Http404
        
        profile = profile_class.objects.get(user=self.request.user)
        return profile
    
    def get_context_data(self, **kwargs):
        ctx = super(ProfileUpdateView, self).get_context_data(**kwargs)
        ctx["profile_form"] = ctx["form"]
        return ctx
    
    def form_valid(self, form):
        self.object = form.save()
        if self.request.is_ajax():
            data = {
                "status": "success",
                "location": self.object.get_absolute_url(),
                "html": render_to_string(self.template_name_ajax_success),
            }
            return HttpResponse(json.dumps(data), content_type="application/json")
        else:
            return HttpResponseRedirect(self.get_success_url())
    
    def form_invalid(self, form):
        if self.request.is_ajax():
            ctx = RequestContext(self.request, self.get_context_data(form=form))
            data = {
                "status": "failed",
                "html": render_to_string(self.template_name_ajax, ctx),
            }
            return HttpResponse(json.dumps(data), content_type="application/json")
        else:
            return self.render_to_response(self.get_context_data(form=form))
    
    def get_success_url(self):
        if self.success_url:
            return self.success_url
        return self.object.get_absolute_url()
    
    @method_decorator(login_required)
    def dispatch(self, *args, **kwargs):
        try:
            return super(ProfileUpdateView, self).dispatch(*args, **kwargs)
        except:
            import sys, traceback
            traceback.print_exc()

########NEW FILE########
__FILENAME__ = runtests
#!/usr/bin/env python
import sys

from os.path import dirname, abspath

from django.conf import settings
from django import VERSION as DJANGO_VERSION


middleware = [
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
]

if DJANGO_VERSION < (1,3):
    middleware.append('cbv.middleware.DeferredRenderingMiddleware')

if not settings.configured:
    settings.configure(
        DATABASE_ENGINE="sqlite3",
        INSTALLED_APPS=[
            "django.contrib.auth",
            "django.contrib.contenttypes",
            "django.contrib.sessions",
            "idios",
            "idios.tests",
        ],
        MIDDLEWARE_CLASSES=middleware,
        AUTH_PROFILE_MODULE="tests.SimpleProfile",
        ROOT_URLCONF="idios.tests.urls"
    )


from django.test.simple import run_tests


def runtests(*test_args):
    if not test_args:
        test_args = ["tests"]
    parent = dirname(abspath(__file__))
    sys.path.insert(0, parent)
    failures = run_tests(test_args, verbosity=1, interactive=True)
    sys.exit(failures)


if __name__ == "__main__":
    runtests(*sys.argv[1:])

########NEW FILE########
