__FILENAME__ = conf
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# i3pystatus documentation build configuration file, created by
# sphinx-quickstart on Mon Oct 14 17:41:37 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = 'i3pystatus'
copyright = ''

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = ''
# The full version, including alpha/beta/rc tags.
release = ''

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

# If true, keep warnings as "system message" paragraphs in the built documents.
#keep_warnings = False


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'i3pystatusdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'i3pystatus.tex', 'i3pystatus Documentation',
   'Author', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'i3pystatus', 'i3pystatus Documentation',
     ['Author'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'i3pystatus', 'i3pystatus Documentation',
   'Author', 'i3pystatus', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

# If true, do not generate a @detailmenu in the "Top" node's menu.
#texinfo_no_detailmenu = False


# -- Options for Epub output ---------------------------------------------------

# Bibliographic Dublin Core info.
epub_title = 'i3pystatus'
epub_author = 'Author'
epub_publisher = 'Author'
epub_copyright = '2013, Author'

# The language of the text. It defaults to the language option
# or en if the language is not set.
#epub_language = ''

# The scheme of the identifier. Typical schemes are ISBN or URL.
#epub_scheme = ''

# The unique identifier of the text. This can be a ISBN number
# or the project homepage.
#epub_identifier = ''

# A unique identification for the text.
#epub_uid = ''

# A tuple containing the cover image and cover page html template filenames.
#epub_cover = ()

# A sequence of (type, uri, title) tuples for the guide element of content.opf.
#epub_guide = ()

# HTML files that should be inserted before the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_pre_files = []

# HTML files shat should be inserted after the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_post_files = []

# A list of files that should not be packed into the epub file.
#epub_exclude_files = []

# The depth of the table of contents in toc.ncx.
#epub_tocdepth = 3

# Allow duplicate toc entries.
#epub_tocdup = True

# Fix unsupported image types using the PIL.
#epub_fix_images = False

# Scale large images.
#epub_max_image_width = 0

# If 'no', URL addresses will not be shown.
#epub_show_urls = 'inline'

# If false, no index is generated.
#epub_use_index = True

########NEW FILE########
__FILENAME__ = alsa
from alsaaudio import Mixer, ALSAAudioError

from i3pystatus import IntervalModule


class ALSA(IntervalModule):
    """
    Shows volume of ALSA mixer. You can also use this for inputs, btw.

    Requires pyalsaaudio

    Available formatters:

    * `{volume}` — the current volume in percent
    * `{muted}` — the value of one of the `muted` or `unmuted` settings
    * `{card}` — the associated soundcard
    * `{mixer}` — the associated ALSA mixer
    """

    interval = 1

    settings = (
        "format",
        ("mixer", "ALSA mixer"),
        ("mixer_id", "ALSA mixer id"),
        ("card", "ALSA sound card"),
        "muted", "unmuted",
        "color_muted", "color",
        "channel"
    )

    muted = "M"
    unmuted = ""
    color_muted = "#AAAAAA"
    color = "#FFFFFF"
    format = "♪: {volume}"
    mixer = "Master"
    mixer_id = 0
    card = 0
    channel = 0

    alsamixer = None
    has_mute = True

    def init(self):
        self.create_mixer()
        try:
            self.alsamixer.getmute()
        except ALSAAudioError:
            self.has_mute = False

        self.fdict = {
            "card": self.alsamixer.cardname(),
            "mixer": self.mixer,
        }

    def create_mixer(self):
        self.alsamixer = Mixer(
            control=self.mixer, id=self.mixer_id, cardindex=self.card)

    def run(self):
        self.create_mixer()

        muted = False
        if self.has_mute:
            muted = self.alsamixer.getmute()[self.channel] == 1

        self.fdict["volume"] = self.alsamixer.getvolume()[self.channel]
        self.fdict["muted"] = self.muted if muted else self.unmuted

        self.output = {
            "full_text": self.format.format(**self.fdict),
            "color": self.color_muted if muted else self.color,
        }

########NEW FILE########
__FILENAME__ = backlight
from i3pystatus.file import File


class Backlight(File):
    """
    Screen backlight info

    Available formatters:

    * `{brightness}` — current brightness relative to max_brightness
    * `{max_brightness}` — maximum brightness value
    * `{percentage}` — current brightness in percent
    """

    settings = (
        ("format", "format string, formatters: brightness, max_brightness, percentage"),
        ("backlight", "backlight, see `/sys/class/backlight/`"),
        "color",
    )
    required = ()

    backlight = "acpi_video0"
    format = "{brightness}/{max_brightness}"

    base_path = "/sys/class/backlight/{backlight}/"
    components = {
        "brightness": (int, "brightness"),
        "max_brightness": (int, "max_brightness"),
    }
    transforms = {
        "percentage": lambda cdict: (cdict["brightness"] / cdict["max_brightness"]) * 100,
    }

    def init(self):
        self.base_path = self.base_path.format(backlight=self.backlight)

        super().init()

########NEW FILE########
__FILENAME__ = battery
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import re
import configparser

from i3pystatus import IntervalModule, formatp
from i3pystatus.core.util import lchop, TimeWrapper
from i3pystatus.core.desktop import DesktopNotification


class UEventParser(configparser.ConfigParser):
    @staticmethod
    def parse_file(file):
        parser = UEventParser()
        with open(file, "r") as file:
            parser.read_string(file.read())
        return dict(parser.items("id10t"))

    def __init__(self):
        super().__init__(default_section="id10t")

    def optionxform(self, key):
        return lchop(key, "POWER_SUPPLY_")

    def read_string(self, string):
        super().read_string("[id10t]\n" + string)


class Battery:
    @staticmethod
    def create(from_file):
        battery_info = UEventParser.parse_file(from_file)
        if "POWER_NOW" in battery_info:
            return BatteryEnergy(battery_info)
        else:
            return BatteryCharge(battery_info)

    def __init__(self, battery_info):
        self.battery_info = battery_info
        self.normalize_micro()

    def normalize_micro(self):
        for key, micro_value in self.battery_info.items():
            if re.match(r"(VOLTAGE|CHARGE|CURRENT|POWER|ENERGY)_(NOW|FULL|MIN)(_DESIGN)?", key):
                self.battery_info[key] = float(micro_value) / 1000000.0

    def percentage(self, design=False):
        return self._percentage("_DESIGN" if design else "") * 100

    def status(self):
        if self.consumption():
            return "Discharging" if self.battery_info["STATUS"] == "Discharging" else "Charging"
        else:
            return "Full"


class BatteryCharge(Battery):
    def consumption(self):
        if "VOLTAGE_NOW" in self.battery_info and "CURRENT_NOW" in self.battery_info:
            return self.battery_info["VOLTAGE_NOW"] * self.battery_info["CURRENT_NOW"]  # V * A = W
        else:
            return -1

    def _percentage(self, design):
        return self.battery_info["CHARGE_NOW"] / self.battery_info["CHARGE_FULL" + design]

    def remaining(self):
        if self.status() == "Discharging":
            if "CHARGE_NOW" in self.battery_info and "CURRENT_NOW" in self.battery_info:
                # Ah / A = h * 60 min = min
                return self.battery_info["CHARGE_NOW"] / self.battery_info["CURRENT_NOW"] * 60
            else:
                return -1
        else:
            return (self.battery_info["CHARGE_FULL"] - self.battery_info["CHARGE_NOW"]) / self.battery_info[
                "CURRENT_NOW"] * 60


class BatteryEnergy(Battery):
    def consumption(self):
        return self.battery_info["POWER_NOW"]

    def _percentage(self, design):
        return self.battery_info["ENERGY_NOW"] / self.battery_info["ENERGY_FULL" + design]

    def remaining(self):
        if self.status() == "Discharging":
            # Wh / W = h * 60 min = min
            return self.battery_info["ENERGY_NOW"] / self.battery_info["POWER_NOW"] * 60
        else:
            return (self.battery_info["ENERGY_FULL"] - self.battery_info["ENERGY_NOW"]) / self.battery_info[
                "POWER_NOW"] * 60


class BatteryChecker(IntervalModule):
    """
    This class uses the /sys/class/power_supply/…/uevent interface to check for the
    battery status

    Available formatters:

    * `{remaining}` — remaining time for charging or discharging, uses TimeWrapper formatting, default format is `%E%h:%M`
    * `{percentage}` — battery percentage relative to the last full value
    * `{percentage_design}` — absolute battery charge percentage
    * `{consumption (Watts)}` — current power flowing into/out of the battery
    * `{status}`
    * `{battery_ident}` — the same as the setting
    """

    settings = (
        ("battery_ident", "The name of your battery, usually BAT0 or BAT1"),
        "format",
        ("alert", "Display a libnotify-notification on low battery"),
        "alert_percentage",
        ("alert_format_title", "The title of the notification, all formatters can be used"),
        ("alert_format_body", "The body text of the notification, all formatters can be used"),
        ("path", "Override the default-generated path"),
        ("status", "A dictionary mapping ('DIS', 'CHR', 'FULL') to alternative names"),
        ("color", "The text color"),
        ("critical_color", "The critical color"),
    )
    battery_ident = "BAT0"
    format = "{status} {remaining}"
    status = {
        "CHR": "CHR",
        "DIS": "DIS",
        "FULL": "FULL",
    }

    alert = False
    alert_percentage = 10
    alert_format_title = "Low battery"
    alert_format_body = "Battery {battery_ident} has only {percentage:.2f}% ({remaining:%E%hh:%Mm}) remaining!"
    color = "#ffffff"
    critical_color = "#ff0000"

    path = None

    def init(self):
        if not self.path:
            self.path = "/sys/class/power_supply/{0}/uevent".format(
                self.battery_ident)

    def run(self):
        urgent = False
        color = self.color

        battery = Battery.create(self.path)

        fdict = {
            "battery_ident": self.battery_ident,
            "percentage": battery.percentage(),
            "percentage_design": battery.percentage(design=True),
            "consumption": battery.consumption(),
            "remaining": TimeWrapper(0, "%E%h:%M"),
        }

        status = battery.status()
        if status in ["Charging", "Discharging"]:
            remaining = battery.remaining()
            fdict["remaining"] = TimeWrapper(remaining * 60, "%E%h:%M")
            if status == "Discharging":
                fdict["status"] = "DIS"
                if battery.percentage() <= self.alert_percentage:
                    urgent = True
                    color = self.critical_color
            else:
                fdict["status"] = "CHR"
        else:
            fdict["status"] = "FULL"

        if self.alert and fdict["status"] == "DIS" and fdict["percentage"] <= self.alert_percentage:
            DesktopNotification(
                title=formatp(self.alert_format_title, **fdict),
                body=formatp(self.alert_format_body, **fdict),
                icon="battery-caution",
                urgency=2,
                timeout=60,
            ).display()

        fdict["status"] = self.status[fdict["status"]]

        self.output = {
            "full_text": formatp(self.format, **fdict).strip(),
            "instance": self.battery_ident,
            "urgent": urgent,
            "color": color,
        }

########NEW FILE########
__FILENAME__ = clock
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os
import locale
import datetime

from i3pystatus import IntervalModule


class Clock(IntervalModule):
    """
    This class shows a clock
    """

    settings = (
        ("format", "stftime format string, `None` means to use the default, locale-dependent format"),
        ("color", "RGB hexadecimal code color specifier, default to #ffffff, set to `i3Bar` to use i3 bar default"),
    )
    format = None
    color = "#ffffff"
    interval = 1

    def init(self):
        if self.format is None:
            lang = os.environ.get('LANG', None)
            if lang:
                locale.setlocale(locale.LC_ALL, lang)
            lang = locale.getlocale()[0]
            if lang == 'en_US':
                # MDY format - United States of America
                self.format = "%a %b %-d %X"
            else:
                # DMY format - almost all other countries
                self.format = "%a %-d %b %X"

    def run(self):
        self.output = {
            "full_text": datetime.datetime.now().strftime(self.format),
            "urgent": False,
        }
        if self.color != "i3Bar":
            self.output["color"] = self.color

########NEW FILE########
__FILENAME__ = desktop
class BaseDesktopNotification:
    """
    Class to display a desktop notification

    :param title: Title of the notification
    :param body: Body text of the notification, depending on the users system configuration HTML may be used, but is not recommended
    :param icon: A XDG icon name, see http://standards.freedesktop.org/icon-naming-spec/icon-naming-spec-latest.html
    :param urgency: A value between 1 and 3 with 1 meaning low urgency and 3 high urgency.
    :param timeout: Timeout in seconds for the notification. Zero means it needs to be dismissed by the user.
    """

    def __init__(self, title, body, icon="dialog-information", urgency=1, timeout=0):
        self.title = title
        self.body = body
        self.icon = icon
        self.urgency = urgency
        self.timeout = timeout

    def display(self):
        """
        Display this notification

        :returns: boolean indicating success
        """
        return False


class DesktopNotification(BaseDesktopNotification):
    pass


try:
    from gi.repository import Notify
except ImportError:
    pass
else:
    if not Notify.init("i3pystatus"):
        raise ImportError("Couldn't initialize libnotify")

    # List of some useful icon names:
    # battery, battery-caution, battery-low
    # …

    class DesktopNotification(DesktopNotification):
        URGENCY_LUT = (
            Notify.Urgency.LOW,
            Notify.Urgency.NORMAL,
            Notify.Urgency.CRITICAL,
        )

        def display(self):
            notification = Notify.Notification.new(self.title, self.body, self.icon)
            if self.timeout:
                notification.set_timeout(self.timeout)
            notification.set_urgency(self.URGENCY_LUT[self.urgency])
            return notification.show()

########NEW FILE########
__FILENAME__ = exceptions
class ConfigError(Exception):
    """ABC for configuration exceptions"""

    def __init__(self, module, *args, **kwargs):
        self.message = "Module '{0}': {1}".format(
            module, self.format(*args, **kwargs))

        super().__init__(self.message)

    def format(self, *args, **kwargs):
        return ""


class ConfigKeyError(ConfigError, KeyError):
    def format(self, key):
        return "invalid option '{0}'".format(key)


class ConfigMissingError(ConfigError):
    def format(self, missing):
        return "missing required options: {0}".format(missing)


class ConfigAmbigiousClassesError(ConfigError):
    def format(self, ambigious_classes):
        return "ambigious module specification, found multiple classes: {0}".format(ambigious_classes)


class ConfigInvalidModuleError(ConfigError):
    def format(self):
        return "no class found"

########NEW FILE########
__FILENAME__ = imputil
import inspect
import types
from importlib import import_module
from i3pystatus.core.exceptions import ConfigAmbigiousClassesError, ConfigInvalidModuleError


class ClassFinder:
    """Support class to find classes of specific bases in a module"""

    def __init__(self, baseclass):
        self.baseclass = baseclass

    def predicate_factory(self, module):
        def predicate(obj):
            return (
                inspect.isclass(obj) and
                issubclass(obj, self.baseclass) and
                obj.__module__ == module.__name__
            )

        return predicate

    def get_matching_classes(self, module):
        # Transpose [ (name, list), ... ] to ( [name, ...], [list, ...] )
        classes = list(zip(*inspect.getmembers(module, self.predicate_factory(module))))
        return classes[1] if classes else []

    def get_class(self, module):
        classes = self.get_matching_classes(module)

        if len(classes) > 1:
            # If there are multiple Module clases bundled in one module,
            # well, we can't decide for the user.
            raise ConfigAmbigiousClassesError(module.__name__, classes)
        elif not classes:
            raise ConfigInvalidModuleError(module.__name__)

        return classes[0]

    def get_module(self, module):
        return import_module("i3pystatus.{mod}".format(mod=module))

    def instanciate_class_from_module(self, module, *args, **kwargs):
        if isinstance(module, types.ModuleType):
            return self.get_class(module)(*args, **kwargs)
        elif isinstance(module, str):
            return self.instanciate_class_from_module(self.get_module(module), *args, **kwargs)
        elif inspect.isclass(module) and issubclass(module, self.baseclass):
            return module(*args, **kwargs)
        elif args or kwargs:
            raise ValueError(
                "Additional arguments are invalid if 'module' is already an object")
        return module

########NEW FILE########
__FILENAME__ = io
import time
import json
import sys
from contextlib import contextmanager


class IOHandler:
    def __init__(self, inp=sys.stdin, out=sys.stdout):
        self.inp = inp
        self.out = out

    def write_line(self, message):
        """Unbuffered printing to stdout."""

        self.out.write(message + "\n")
        self.out.flush()

    def read(self):
        """Iterate over all input lines (Generator)"""

        while True:
            try:
                yield self.read_line()
            except EOFError:
                return

    def read_line(self):
        """
        Interrupted respecting reader for stdin.

        Raises EOFError if the end of stream has been reached
        """

        try:
            line = self.inp.readline().strip()
        except KeyboardInterrupt:
            raise EOFError()

        # i3status sends EOF, or an empty line
        if not line:
            raise EOFError()
        return line


class StandaloneIO(IOHandler):
    """
    I/O handler for standalone usage of i3pystatus (w/o i3status)

    Writing works as usual, but reading will always return a empty JSON array,
    and the i3bar protocol header
    """

    n = -1
    proto = ('{"version":1,"click_events":true}', "[", "[]", ",[]",)

    def __init__(self, interval=1):
        super().__init__()
        self.interval = interval

    def read(self):
        while True:
            try:
                time.sleep(self.interval)
            except KeyboardInterrupt:
                return

            yield self.read_line()

    def read_line(self):
        self.n += 1

        return self.proto[min(self.n, len(self.proto) - 1)]


class JSONIO:
    def __init__(self, io, skiplines=2):
        self.io = io
        for i in range(skiplines):
            self.io.write_line(self.io.read_line())

    def read(self):
        """Iterate over all JSON input (Generator)"""

        for line in self.io.read():
            with self.parse_line(line) as j:
                yield j

    @contextmanager
    def parse_line(self, line):
        """Parse a single line of JSON and write modified JSON back."""

        prefix = ""
        # ignore comma at start of lines
        if line.startswith(","):
            line, prefix = line[1:], ","

        j = json.loads(line)
        yield j
        self.io.write_line(prefix + json.dumps(j))

########NEW FILE########
__FILENAME__ = modules
from i3pystatus.core.settings import SettingsBase
from i3pystatus.core.threading import Manager
from i3pystatus.core.util import convert_position


class Module(SettingsBase):
    output = None
    position = 0

    def registered(self, status_handler):
        """Called when this module is registered with a status handler"""

    def inject(self, json):
        if self.output:
            if "name" not in self.output:
                self.output["name"] = self.__name__
            self.output["instance"] = str(id(self))
            json.insert(convert_position(self.position, json), self.output)

    def run(self):
        pass

    def on_click(self, button):
        if button == 1:  # Left mouse button
            self.on_leftclick()
        elif button == 3:  # Right mouse button
            self.on_rightclick()

    def move(self, position):
        self.position = position
        return self

    def on_leftclick(self):
        pass

    def on_rightclick(self):
        pass


class IntervalModuleMeta(type):
    """Add interval setting to `settings` attribute if it does not exist."""

    def __init__(cls, name, bases, namespace):
        super(IntervalModuleMeta, cls).__init__(name, bases, namespace)
        if not hasattr(cls, 'settings'):
            cls.settings = tuple()
        if 'interval' not in SettingsBase.flatten_settings(cls.settings):
            cls.settings += ('interval', )


class IntervalModule(Module, metaclass=IntervalModuleMeta):
    interval = 5  # seconds
    managers = {}

    def registered(self, status_handler):
        if self.interval in IntervalModule.managers:
            IntervalModule.managers[self.interval].append(self)
        else:
            am = Manager(self.interval)
            am.append(self)
            IntervalModule.managers[self.interval] = am
            am.start()

    def __call__(self):
        self.run()

    def run(self):
        """Called approximately every self.interval seconds

        Do not rely on this being called from the same thread at all times.
        If you need to always have the same thread context, subclass AsyncModule."""

########NEW FILE########
__FILENAME__ = settings
from i3pystatus.core.util import KeyConstraintDict
from i3pystatus.core.exceptions import ConfigKeyError, ConfigMissingError


class SettingsBase:
    """
    Support class for providing a nice and flexible settings interface

    Classes inherit from this class and define what settings they provide and
    which are required.

    The constructor is either passed a dictionary containing these settings, or
    keyword arguments specifying the same.

    Settings are stored as attributes of self.
    """

    settings = tuple()
    """settings should be tuple containing two types of elements:

    * bare strings, which must be valid Python identifiers.
    * two-tuples, the first element being a identifier (as above) and the second
      a docstring for the particular setting"""

    required = tuple()
    """required can list settings which are required"""

    def __init__(self, *args, **kwargs):
        def get_argument_dict(args, kwargs):
            if len(args) == 1 and not kwargs:
                # User can also pass in a dict for their settings
                # Note: you could do that anyway, with the ** syntax
                return args[0]
            return kwargs

        self.settings = self.flatten_settings(self.settings)

        sm = KeyConstraintDict(self.settings, self.required)
        settings_source = get_argument_dict(args, kwargs)

        try:
            sm.update(settings_source)
        except KeyError as exc:
            raise ConfigKeyError(type(self).__name__, key=exc.args[0]) from exc

        try:
            self.__dict__.update(sm)
        except KeyConstraintDict.MissingKeys as exc:
            raise ConfigMissingError(
                type(self).__name__, missing=exc.keys) from exc

        self.__name__ = "{}.{}".format(
            self.__module__, self.__class__.__name__)

        self.init()

    def init(self):
        """Convenience method which is called after all settings are set

        In case you don't want to type that super()…blabla :-)"""

    @staticmethod
    def flatten_settings(settings):
        def flatten_setting(setting):
            return setting[0] if isinstance(setting, tuple) else setting

        return tuple(flatten_setting(setting) for setting in settings)

########NEW FILE########
__FILENAME__ = threading
import threading
import time
import sys
import traceback
from i3pystatus.core.util import partition

timer = time.perf_counter if hasattr(time, "perf_counter") else time.clock


class Thread(threading.Thread):
    def __init__(self, target_interval, workloads=None, start_barrier=1):
        super().__init__()
        self.workloads = workloads or []
        self.target_interval = target_interval
        self.start_barrier = start_barrier
        self.daemon = True

    def __iter__(self):
        return iter(self.workloads)

    def __len__(self):
        return len(self.workloads)

    def pop(self):
        return self.workloads.pop()

    def append(self, workload):
        self.workloads.append(workload)

    @property
    def time(self):
        return sum(map(lambda workload: workload.time, self))

    def wait_for_start_barrier(self):
        while len(self) <= self.start_barrier:
            time.sleep(0.4)

    def execute_workloads(self):
        for workload in self:
            workload()
        self.workloads.sort(key=lambda workload: workload.time)

    def run(self):
        while self:
            self.execute_workloads()
            filltime = self.target_interval - self.time
            if filltime > 0:
                time.sleep(filltime)

    def branch(self, vtime, bound):
        if len(self) > 1 and vtime > bound:
            remove = self.pop()
            return [remove] + self.branch(vtime - remove.time, bound)
        return []


class Wrapper:
    def __init__(self, workload):
        self.workload = workload

    def __repr__(self):
        return repr(self.workload)


class ExceptionWrapper(Wrapper):
    def __call__(self):
        try:
            self.workload()
        except:
            sys.stderr.write("Exception in {thread} at {time}\n".format(
                thread=threading.current_thread().name,
                time=time.strftime("%c")
            ))
            traceback.print_exc(file=sys.stderr)
            sys.stderr.flush()


class WorkloadWrapper(Wrapper):
    time = 0.0

    def __call__(self):
        tp1 = timer()
        self.workload()
        self.time = timer() - tp1


class Manager:
    def __init__(self, target_interval):
        self.target_interval = target_interval
        self.upper_bound = target_interval * 1.1
        self.lower_bound = target_interval * 0.7

        initial_thread = Thread(target_interval, [self.wrap(self)])
        self.threads = [initial_thread]

    def __call__(self):
        separate = []
        for thread in self.threads:
            separate.extend(thread.branch(thread.time, self.upper_bound))
        self.create_threads(self.partition_workloads(separate))

    def __repr__(self):
        return "Manager"

    def wrap(self, workload):
        return WorkloadWrapper(ExceptionWrapper(workload))

    def partition_workloads(self, workloads):
        return partition(workloads, self.lower_bound, lambda workload: workload.time)

    def create_threads(self, threads):
        for workloads in threads:
            self.create_thread(workloads)

    def create_thread(self, workloads):
        thread = Thread(self.target_interval, workloads, start_barrier=0)
        thread.start()
        self.threads.append(thread)

    def append(self, workload):
        self.threads[0].append(self.wrap(workload))

    def start(self):
        for thread in self.threads:
            thread.start()

########NEW FILE########
__FILENAME__ = util
import collections
import functools
import re
import socket
import string


def lchop(string, prefix):
    """Removes a prefix from string

    :param string: String, possibly prefixed with prefix
    :param prefix: Prefix to remove from string
    :returns: string without the prefix
    """
    if string.startswith(prefix):
        return string[len(prefix):]
    return string


def popwhile(predicate, iterable):
    """Generator function yielding items of iterable while predicate holds for each item

    :param predicate: function taking an item returning bool
    :param iterable: iterable
    :returns: iterable (generator function)
    """
    while iterable:
        item = iterable.pop()
        if predicate(item):
            yield item
        else:
            break


def partition(iterable, limit, key=lambda x: x):
    def pop_partition():
        sum = 0.0
        while sum < limit and iterable:
            sum += key(iterable[-1])
            yield iterable.pop()

    partitions = []
    iterable.sort(reverse=True)
    while iterable:
        partitions.append(list(pop_partition()))

    return partitions


def round_dict(dic, places):
    """
    Rounds all values in a dict containing only numeric types to `places` decimal places.
    If places is None, round to INT.
    """    
    if places is None:
        for key, value in dic.items():
            dic[key] = round(value)
    else:
        for key, value in dic.items():
            dic[key] = round(value, places)


class ModuleList(collections.UserList):
    def __init__(self, status_handler, class_finder):
        self.status_handler = status_handler
        self.finder = class_finder
        super().__init__()

    def append(self, module, *args, **kwargs):
        module = self.finder.instanciate_class_from_module(
            module, *args, **kwargs)
        module.registered(self.status_handler)
        super().append(module)
        return module

    def get(self, find_id):
        find_id = int(find_id)
        for module in self:
            if id(module) == find_id:
                return module


class KeyConstraintDict(collections.UserDict):
    """
    A dict implementation with sets of valid and required keys

    :param valid_keys: Set of valid keys
    :param required_keys: Set of required keys, must be a subset of valid_keys
    """

    class MissingKeys(Exception):
        def __init__(self, keys):
            self.keys = keys

    def __init__(self, valid_keys, required_keys):
        super().__init__()

        self.valid_keys = valid_keys
        self.required_keys = set(required_keys)
        self.seen_keys = set()

    def __setitem__(self, key, value):
        """Trying to add an invalid key will raise KeyError
        """
        if key in self.valid_keys:
            self.seen_keys.add(key)
            self.data[key] = value
        else:
            raise KeyError(key)

    def __delitem__(self, key):
        self.seen_keys.remove(key)
        del self.data[key]

    def __iter__(self):
        """Iteration will raise a MissingKeys exception unless all required keys are set
        """
        if self.missing():
            raise self.MissingKeys(self.missing())

        return self.data.__iter__()

    def missing(self):
        """Returns a set of keys that are required but not set
        """
        return self.required_keys - (self.seen_keys & self.required_keys)


def convert_position(pos, json):
    if pos < 0:
        pos = len(json) + (pos + 1)
    return pos


def flatten(l):
    """
    Flattens a hierarchy of nested lists into a single list containing all elements in order

    :param l: list of arbitrary types and lists
    :returns: list of arbitrary types
    """
    l = list(l)
    i = 0
    while i < len(l):
        while isinstance(l[i], list):
            if not l[i]:
                l.pop(i)
                i -= 1
                break
            else:
                l[i:i + 1] = l[i]
        i += 1
    return l


def formatp(string, **kwargs):
    """
    Function for advanced format strings with partial formatting

    This function consumes format strings with groups enclosed in brackets. A
    group enclosed in brackets will only become part of the result if all fields
    inside the group evaluate True in boolean contexts.

    Groups can be nested. The fields in a nested group do not count as fields in
    the enclosing group, i.e. the enclosing group will evaluate to an empty
    string even if a nested group would be eligible for formatting. Nesting is
    thus equivalent to a logical or of all enclosing groups with the enclosed
    group.

    Escaped brackets, i.e. \\\\[ and \\\\] are copied verbatim to output.

    :param string: Format string
    :param **kwargs: keyword arguments providing data for the format string
    :returns: Formatted string
    """

    def build_stack(string):
        """
        Builds a stack with OpeningBracket, ClosingBracket and String tokens.
        Tokens have a level property denoting their nesting level.
        They also have a string property containing associated text (empty for
        all tokens but String tokens).
        """

        class Token:
            string = ""

        class OpeningBracket(Token):
            pass

        class ClosingBracket(Token):
            pass

        class String(Token):
            def __init__(self, str):
                self.string = str

        TOKENS = {
            "[": OpeningBracket,
            "]": ClosingBracket,
        }

        stack = []

        # Index of next unconsumed char
        next = 0
        # Last consumed char
        prev = ""
        # Current char
        char = ""
        # Current level
        level = 0

        while next < len(string):
            prev = char
            char = string[next]
            next += 1

            if prev != "\\" and char in TOKENS:
                token = TOKENS[char]()
                token.index = next
                if char == "]":
                    level -= 1
                token.level = level
                if char == "[":
                    level += 1
                stack.append(token)
            else:
                if stack and isinstance(stack[-1], String):
                    stack[-1].string += char
                else:
                    token = String(char)
                    token.level = level
                    stack.append(token)
        return stack

    def build_tree(items, level=0):
        """
        Builds a list-of-lists tree (in forward order) from a stack (reversed order),
        and formats the elements on the fly, discarding everything not eligible for
        inclusion.
        """
        subtree = []

        while items:
            nested = []
            while items[0].level > level:
                nested.append(items.pop(0))
            if nested:
                subtree.append(build_tree(nested, level + 1))

            item = items.pop(0)
            if item.string:
                string = item.string
                if level == 0:
                    subtree.append(string.format(**kwargs))
                else:
                    fields = re.findall(r"({(\w+)[^}]*})", string)
                    successful_fields = 0
                    for fieldspec, fieldname in fields:
                        if kwargs.get(fieldname, False):
                            successful_fields += 1
                    if successful_fields == len(fields):
                        subtree.append(string.format(**kwargs))
                    else:
                        return []
        return subtree

    def merge_tree(items):
        return "".join(flatten(items)).replace("\]", "]").replace("\[", "[")

    stack = build_stack(string)
    tree = build_tree(stack, 0)
    return merge_tree(tree)


class TimeWrapper:
    """
    A wrapper that implements __format__ and __bool__ for time differences and time spans.

    :param seconds: seconds (numeric)
    :param default_format: the default format to be used if no explicit format_spec is passed to __format__

    Format string syntax:

    * %h, %m and %s are the hours, minutes and seconds without leading zeros (i.e. 0 to 59 for minutes and seconds)
    * %H, %M and %S are padded with a leading zero to two digits, i.e. 00 to 59
    * %l and %L produce hours non-padded and padded but only if hours is not zero. If the hours are zero it produces an empty string.
    * %% produces a literal %
    * %E (only valid on beginning of the string) if the time is null, don't format anything but rather produce an empty string. If the time is non-null it is removed from the string.

    The formatted string is stripped, i.e. spaces on both ends of the result are removed
    """

    class TimeTemplate(string.Template):
        delimiter = "%"
        idpattern = r"[a-zA-Z]"

    def __init__(self, seconds, default_format="%m:%S"):
        self.seconds = int(seconds)
        self.default_format = default_format

    def __bool__(self):
        """:returns: `bool(seconds)`, i.e. False if seconds == 0 and True otherwise
        """
        return bool(self.seconds)

    def __format__(self, format_spec):
        """Formats the time span given the format_spec (or the default_format).
        """
        format_spec = format_spec or self.default_format
        h = self.seconds // 3600
        m, s = divmod(self.seconds % 3600, 60)
        l = h if h else ""
        L = "%02d" % h if h else ""

        if format_spec.startswith("%E"):
            format_spec = format_spec[2:]
            if not self.seconds:
                return ""
        return self.TimeTemplate(format_spec).substitute(
            h=h, m=m, s=s,
            H="%02d" % h, M="%02d" % m, S="%02d" % s,
            l=l, L=L,
        ).strip()


def require(predicate):
    """Decorator factory for methods requiring a predicate. If the
    predicate is not fulfilled during a method call, the method call
    is skipped and None is returned.

    :param predicate: A callable returning a truth value
    :returns: Method decorator

    .. seealso::

        :py:func:`internet`

    """

    def decorator(method):
        @functools.wraps(method)
        def wrapper(*args, **kwargs):
            if predicate():
                return method(*args, **kwargs)
            return None

        return wrapper

    return decorator


def internet():
    """
    Checks for a internet connection by connecting to 8.8.8.8 (Google DNS)

    :returns: True if internet connection is available
    """
    try:
        socket.create_connection(("8.8.8.8", 53), 1).close()
        return True
    except OSError:
        return False

########NEW FILE########
__FILENAME__ = cpu_usage
# -*- coding:utf-8 -*-

from i3pystatus import IntervalModule


class CpuUsage(IntervalModule):
    """
    Shows CPU usage.
    The first output will be inacurate
    Linux only

    Available formatters:

    * {usage}

    """

    format = "{usage:02}%"
    settings = (
        ("format", "format string"),
    )

    def init(self):
        self.prev_idle = 0
        self.prev_busy = 0
        self.interval = 1

    def get_usage(self):
        """
        parses /proc/stat and calcualtes total and busy time
        (more specific USER_HZ see man 5 proc for further informations )
        """
        with open('/proc/stat', 'r') as file_obj:
            stats = file_obj.readline().strip().split()

        cpu_timings = [int(x) for x in stats[1:]]
        cpu_total = sum(cpu_timings)
        del cpu_timings[3:5]
        cpu_busy = sum(cpu_timings)

        return cpu_total, cpu_busy

    def run(self):
        cpu_total, cpu_busy = self.get_usage()

        diff_cpu_total = cpu_total - self.prev_idle
        diff_cpu_busy = cpu_busy - self.prev_busy

        self.prev_idle = cpu_total
        self.prev_busy = cpu_busy

        cpu_busy_percentage = int(diff_cpu_busy / diff_cpu_total * 100)

        self.output = {
            "full_text": self.format.format(
                usage=cpu_busy_percentage
            )
        }

########NEW FILE########
__FILENAME__ = disk
import os

from i3pystatus import IntervalModule
from .core.util import round_dict


class Disk(IntervalModule):
    """
    Gets ``{used}``, ``{free}``, ``{available}`` and ``{total}`` amount of bytes on the given mounted filesystem.

    These values can also be expressed as percentages with the ``{percentage_used}``, ``{percentage_free}``
    and ``{percentage_avail}`` formats.
    """

    settings = (
        "format", "path",
        ("divisor", "divide all byte values by this value, default is 1024**3 (gigabyte)"),
        ("display_limit", "if more space is available than this limit the module is hidden"),
        ("critical_limit", "critical space limit (see critical_color)"),
        ("critical_color", "the critical color"),
        ("color", "the common color"),
        ("round_size", "precision, None for INT"),
    )
    required = ("path",)
    color = "#FFFFFF"
    critical_color = "#FF0000"
    format = "{free}/{avail}"
    divisor = 1024 ** 3
    display_limit = float('Inf')
    critical_limit = 0
    round_size = 2


    def run(self):
        stat = os.statvfs(self.path)
        available = (stat.f_bsize * stat.f_bavail) / self.divisor

        if available > self.display_limit:
            self.output = {}
            return

        cdict = {
            "total": (stat.f_bsize * stat.f_blocks) / self.divisor,
            "free": (stat.f_bsize * stat.f_bfree) / self.divisor,
            "avail": available,
            "used": (stat.f_bsize * (stat.f_blocks - stat.f_bfree)) / self.divisor,
            "percentage_free": stat.f_bfree / stat.f_blocks * 100,
            "percentage_avail": stat.f_bavail / stat.f_blocks * 100,
            "percentage_used": (stat.f_blocks - stat.f_bfree) / stat.f_blocks * 100,
        }
        round_dict(cdict, self.round_size)

        self.output = {
            "full_text": self.format.format(**cdict),
            "color": self.color if available > self.critical_limit else self.critical_color,
            "urgent": available > self.critical_limit
        }

########NEW FILE########
__FILENAME__ = file
from os.path import join

from i3pystatus import IntervalModule


class File(IntervalModule):
    """
    Rip information from text files

    components is a dict of pairs of the form:

    ::

        name => (callable, file)

    * Where `name` is a valid identifier, which is used in the format string to access
      the value of that component.
    * `callable` is some callable to convert the contents of `file`. A common choice is
      float or int.
    * `file` names a file, relative to `base_path`.

    transforms is a optional dict of callables taking a single argument (a dictionary containing the values
    of all components). The return value is bound to the key.
    """

    settings = (
        "format",
        "components",
        "transforms",
        "base_path",
        "color", "interval",
    )
    required = ("format", "components")
    base_path = "/"
    transforms = {}
    color = "#FFFFFF"

    def run(self):
        cdict = {}

        for key, (component, file) in self.components.items():
            with open(join(self.base_path, file), "r") as f:
                cdict[key] = component(f.read().strip())

        for key, transform in self.transforms.items():
            cdict[key] = transform(cdict)

        self.output = {
            "full_text": self.format.format(**cdict),
            "color": self.color
        }

########NEW FILE########
__FILENAME__ = load
from i3pystatus import IntervalModule


class Load(IntervalModule):
    """
    Shows system load
    """

    format = "{avg1} {avg5}"
    settings = (
        ("format",
         "format string used for output. {avg1}, {avg5} and {avg15} are the load average of the last one, five and fifteen minutes, respectively. {tasks} is the number of tasks (i.e. 1/285, which indiciates that one out of 285 total tasks is runnable)."),
        ("color", "The text color"),
        ("critical_limit", "Limit under witch one the battery is critical"),
        ("critical_color", "The critical color"),
    )

    file = "/proc/loadavg"
    color = "#ffffff"
    critical_limit = 1
    critical_color = "#ff0000"

    def run(self):
        with open(self.file, "r") as f:
            avg1, avg5, avg15, tasks, lastpid = f.read().split(" ", 5)

        urgent = float(avg1) > self.critical_limit

        self.output = {
            "full_text": self.format.format(avg1=avg1, avg5=avg5, avg15=avg15, tasks=tasks),
            "urgent": urgent,
            "color": self.critical_color if urgent else self.color,
        }

########NEW FILE########
__FILENAME__ = imap
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
import imaplib

from i3pystatus.mail import Backend


class IMAP(Backend):
    """
    Checks for mail on a IMAP server
    """

    settings = (
        "host", "port",
        "username", "password",
        "ssl",
        "mailbox",
    )
    required = ("host", "username", "password")

    port = 993
    ssl = True
    mailbox = "INBOX"

    imap_class = imaplib.IMAP4
    connection = None

    def init(self):
        if self.ssl:
            self.imap_class = imaplib.IMAP4_SSL

    def get_connection(self):
        if not self.connection:
            try:
                self.connection = self.imap_class(self.host, self.port)
                self.connection.login(self.username, self.password)
                self.connection.select(self.mailbox)
            except Exception:
                self.connection = None

        try:
            self.connection.select(self.mailbox)
        except Exception:
            self.connection = None

        return self.connection

    @property
    def unread(self):
        conn = self.get_connection()
        if conn:
            return len(conn.search(None, "UnSeen")[1][0].split())
        else:
            sys.stderr.write("no connection")


Backend = IMAP

########NEW FILE########
__FILENAME__ = maildir
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
from i3pystatus.mail import Backend
import subprocess


class MaildirMail(Backend):
    """
    Checks for local mail in Maildir
    """

    settings = (
        "directory",
    )
    required = ("directory",)

    directory = ""

    @property
    def unread(self):
        p = subprocess.Popen(['ls', '-l', self.directory + '/new'], stdout=subprocess.PIPE)
        stdout, stderr = p.communicate()
        stdout = stdout.decode('utf8')
        return len(stdout.split('\n')) - 2


Backend = MaildirMail

########NEW FILE########
__FILENAME__ = mbox
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
from i3pystatus.mail import Backend
import subprocess


class MboxMail(Backend):
    """
    Checks for local mail in mbox
    """

    settings = ()
    required = ()

    @property
    def unread(self):
        p = subprocess.Popen(['messages.mailutils'], stdout=subprocess.PIPE)
        stdout, stderr = p.communicate()
        stdout = stdout.decode('utf8')
        assert p.returncode == 0, "messages.mailutils returned non-zero return code"
        s_stuff, message_number = stdout.strip().rsplit(':', 1)
        return int(message_number.strip())


Backend = MboxMail

########NEW FILE########
__FILENAME__ = notmuchmail
#!/usr/bin/env python
# -*- coding: utf-8 -*-

# note that this needs the notmuch python bindings. For more info see:
# http://notmuchmail.org/howto/#index4h2
import notmuch

from i3pystatus.mail import Backend


class Notmuch(Backend):
    """
    This class uses the notmuch python bindings to check for the
    number of messages in the notmuch database with the tags "inbox"
    and "unread"
    """

    settings = required = ("db_path",)

    def init(self):
        self.db = notmuch.Database(self.db_path)

    @property
    def unread(self):
        return notmuch.Query(self.db, "tag:unread and tag:inbox").count_messages()


Backend = Notmuch

########NEW FILE########
__FILENAME__ = thunderbird
#!/usr/bin/env python2
# -*- coding: utf-8 -*-
#
# This plugin listens for dbus signals emitted by the
# thunderbird-dbus-sender extension for TB:
# https://github.com/janoliver/thunderbird-dbus-sender
# The plugin must be active and thunderbird running for the module to work
# properly.

from functools import partial

import dbus
from dbus.mainloop.glib import DBusGMainLoop
from gi.repository import GObject

from i3pystatus.mail import Backend


class Thunderbird(Backend):
    """
    This class listens for dbus signals emitted by
    the dbus-sender extension for thunderbird.

    Requires python-dbus
    """

    _unread = set()

    def init(self):
        dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)
        bus = dbus.SessionBus()
        bus.add_signal_receiver(self.new_msg,
                                dbus_interface="org.mozilla.thunderbird.DBus",
                                signal_name="NewMessageSignal")
        bus.add_signal_receiver(self.changed_msg,
                                dbus_interface="org.mozilla.thunderbird.DBus",
                                signal_name="ChangedMessageSignal")
        loop = GObject.MainLoop()
        dbus.mainloop.glib.threads_init()
        self.context = loop.get_context()

        self.run = partial(self.context.iteration, False)

    def new_msg(self, id, author, subject):
        if id not in self._unread:
            self._unread.add(id)

    def changed_msg(self, id, event):
        if event == "read" and id in self._unread:
            self._unread.remove(id)

    @property
    def unread(self):
        self.run()
        return len(self._unread)


Backend = Thunderbird

########NEW FILE########
__FILENAME__ = mem
from i3pystatus import IntervalModule
from psutil import virtual_memory
from .core.util import round_dict


class Mem(IntervalModule):
    """
    Shows memory load

    Available formatters:

    * {avail_mem}
    * {percent_used_mem}
    * {used_mem}
    * {total_mem}

    Requires psutil (from PyPI)
    """

    format = "{avail_mem} MiB"
    divisor = 1024 ** 2
    color = "#00FF00"
    warn_color = "#FFFF00"
    alert_color = "#FF0000"
    warn_percentage = 50
    alert_percentage = 80
    round_size = 1

    

    settings = (
        ("format", "format string used for output."),
        ("divisor",
         "divide all byte values by this value, default 1024**2(mebibytes"),
        ("warn_percentage", "minimal percentage for warn state"),
        ("alert_percentage", "minimal percentage for alert state"),
        ("color", "standard color"),
        ("warn_color",
         "defines the color used wann warn percentage ist exceeded"),
        ("alert_color",
         "defines the color used when alert percentage is exceeded"),
        ("round_size", "defines number of digits in round"),

    )

    def run(self):
        memory_usage = virtual_memory()
        used = memory_usage.used - memory_usage.cached - memory_usage.buffers

        if memory_usage.percent >= self.alert_percentage:
            color = self.alert_color

        elif memory_usage.percent >= self.warn_percentage:
            color = self.warn_color
        else:
            color = self.color
            
        cdict = {
                "used_mem":used / self.divisor,
                "avail_mem":memory_usage.available / self.divisor,
                "total_mem":memory_usage.total / self.divisor,
                "percent_used_mem":memory_usage.percent,
        }
        round_dict(cdict, self.round_size)


        self.output = {
            "full_text": self.format.format(**cdict),
            "color": color
        }

########NEW FILE########
__FILENAME__ = mkdocs
#!/usr/bin/env python

import pkgutil
import textwrap

import i3pystatus
import i3pystatus.mail

from .core.imputil import ClassFinder

IGNORE = ("__main__", "mkdocs", "core")
MODULE_FORMAT = """
{name}
{heading}

{doc}

Settings:

{settings}

{endstring}\n"""


class Module:
    name = ""
    doc = ""
    endstring = ""

    def __init__(self, cls, neighbours, module_name, module, heading):
        self.settings = []
        self.cls = cls
        self.heading = heading

        if neighbours == 1:
            self.name = module_name
        else:
            self.name = "{module}.{cls}".format(
                module=module_name, cls=self.cls.__name__)

        self.doc = self.cls.__doc__ or module.__doc__ or ""

        if hasattr(self.cls, "_endstring"):
            self.endstring = self.cls._endstring

        self.read_settings()

    def read_settings(self):
        for setting in self.cls.settings:
            self.settings.append(Setting(self.cls, setting))

    def format_settings(self):
        return "\n".join(map(str, self.settings))

    def __str__(self):
        return MODULE_FORMAT.format(
            name=self.name,
            doc=textwrap.dedent(self.doc),
            settings=self.format_settings(),
            heading=self.heading * len(self.name),
            endstring=self.endstring
        )


class Setting:
    doc = ""
    required = False
    default = sentinel = object()

    def __init__(self, cls, setting):
        if isinstance(setting, tuple):
            self.name = setting[0]
            self.doc = setting[1]
        else:
            self.name = setting

        if setting in cls.required:
            self.required = True
        elif hasattr(cls, self.name):
            self.default = getattr(cls, self.name)

    def __str__(self):
        attrs = []
        if self.required:
            attrs.append("required")
        if self.default is not self.sentinel:
            attrs.append("default: ``{default}``".format(default=self.default))

        formatted = ":{name}: {doc}".format(name=self.name, doc=self.doc)
        if attrs:
            formatted += " ({attrs})".format(attrs=", ".join(attrs))

        return formatted


def get_modules(path):
    modules = []
    for finder, modname, ispkg in pkgutil.iter_modules(path):
        if modname not in IGNORE:
            modules.append(get_module(finder, modname))
    return modules


def get_module(finder, modname):
    fullname = "i3pystatus.{modname}".format(modname=modname)
    return (modname, finder.find_loader(fullname)[0].load_module(fullname))


def get_all(module_path, heading, finder=None, ignore=None):
    mods = []
    if not finder:
        finder = ClassFinder(i3pystatus.Module)

    for name, module in get_modules(module_path):
        classes = finder.get_matching_classes(module)
        found = []
        for cls in classes:
            if cls.__name__ not in found:
                found.append(cls.__name__)
                mods.append(
                    Module(cls, neighbours=len(classes), module_name=name, module=module, heading=heading))

    return sorted(mods, key=lambda module: module.name)


def generate_doc_for_module(module_path, heading="+", finder=None, ignore=None):
    return "".join(map(str, get_all(module_path, heading, finder, ignore or [])))


with open("README.tpl.rst", "r") as template:
    tpl = template.read()
    tpl = tpl.replace(
        "!!module_doc!!", generate_doc_for_module(i3pystatus.__path__))
    finder = ClassFinder(baseclass=i3pystatus.mail.Backend)
    tpl = tpl.replace("!!i3pystatus.mail!!", generate_doc_for_module(
        i3pystatus.mail.__path__, "~", finder, ["Backend"]))
    with open("README.rst", "w") as output:
        output.write(tpl + "\n")

########NEW FILE########
__FILENAME__ = modsde
#!/usr/bin/env python

import urllib.request
import urllib.parse
import urllib.error
import re
import http.cookiejar
import xml.etree.ElementTree as ET
import webbrowser

from i3pystatus import IntervalModule


class ModsDeChecker(IntervalModule):
    """
    This class returns i3status parsable output of the number of
    unread posts in any bookmark in the mods.de forums.
    """

    settings = (
        ("format",
         """Use {unread} as the formatter for number of unread posts"""),
        ("offset", """subtract number of posts before output"""),
        "color", "username", "password"
    )
    required = ("username", "password")

    color = "#7181fe"
    offset = 0
    format = "{unread} new posts in bookmarks"

    login_url = "http://login.mods.de/"
    bookmark_url = "http://forum.mods.de/bb/xml/bookmarks.php"
    opener = None
    cj = None
    logged_in = False

    def init(self):
        self.cj = http.cookiejar.CookieJar()
        self.opener = urllib.request.build_opener(
            urllib.request.HTTPCookieProcessor(self.cj))

    def run(self):
        unread = self.get_unread_count()

        if not unread:
            self.output = None
        else:
            self.output = {
                "full_text": self.format.format(unread=unread),
                "urgent": "true",
                "color": self.color
            }

    def get_unread_count(self):
        if not self.logged_in:
            self.login()

        try:
            f = self.opener.open(self.bookmark_url)
            root = ET.fromstring(f.read())
            return int(root.attrib["newposts"]) - self.offset
        except Exception:
            self.cj.clear()
            self.opener = urllib.request.build_opener(
                urllib.request.HTTPCookieProcessor(self.cj))
            self.logged_in = False

    def login(self):
        data = urllib.parse.urlencode({
            "login_username": self.username,
            "login_password": self.password,
            "login_lifetime": "31536000"
        })

        try:
            response = self.opener.open(self.login_url, data.encode("ascii"))
        except Exception:
            return

        page = response.read().decode("ISO-8859-15")

        m = re.search("http://forum.mods.de/SSO.php[^']*", page)
        self.cj.clear()

        if m and m.group(0):
            # get the cookie
            response = self.opener.open(m.group(0))
            for cookie in self.cj:
                self.cj.clear
                self.logged_in = True
                self.opener.addheaders.append(
                    ("Cookie", "{}={}".format(cookie.name, cookie.value)))
            return True
        return False

    def on_leftclick(self):
        webbrowser.open_new_tab("http://forum.mods.de/bb/")

########NEW FILE########
__FILENAME__ = mpd
import socket

from i3pystatus import IntervalModule, formatp
from i3pystatus.core.util import TimeWrapper


class MPD(IntervalModule):
    """
    Displays various information from MPD (the music player daemon)

    Available formatters (uses `formatp`_)

    * `{title}` — (the title of the current song)
    * `{album}` — (the album of the current song, can be an empty string (e.g. for online streams))
    * `{artist}` — (can be empty, too)
    * `{song_elapsed}` — (Position in the currently playing song, uses `TimeWrapper`_, default is `%m:%S`)
    * `{song_length}` — (Length of the current song, same as song_elapsed)
    * `{pos}` — (Position of current song in playlist, one-based)
    * `{len}` — (Songs in playlist)
    * `{status}` — (play, pause, stop mapped through the `status` dictionary)
    * `{bitrate}` — (Current bitrate in kilobit/s)
    * `{volume}` — (Volume set in MPD)

    Left click on the module play/pauses, right click (un)mutes.
    """

    interval = 1

    settings = (
        ("host"),
        ("port", "MPD port"),
        ("format", "formatp string"),
        ("status", "Dictionary mapping pause, play and stop to output")
    )

    host = "localhost"
    port = 6600
    s = None
    format = "{title} {status}"
    format_sparse = None
    status = {
        "pause": "▷",
        "play": "▶",
        "stop": "◾",
    }

    vol = 100

    def _mpd_command(self, sock, command):
        try:
            sock.send((command + "\n").encode("utf-8"))
        except Exception as e:
            self.s = socket.create_connection((self.host, self.port))
            sock = self.s
            sock.recv(8192)
            sock.send((command + "\n").encode("utf-8"))
        try:
            reply = sock.recv(16384).decode("utf-8")
            replylines = reply.split("\n")[:-2]

            return dict(
                (line.split(": ", 1)) for line in replylines
            )
        except Exception as e:
            return None

    def init(self):
        if not self.format_sparse:
            self.format_sparse = self.format

    def run(self):
        try:
            status = self._mpd_command(self.s, "status")
            currentsong = self._mpd_command(self.s, "currentsong")
            fdict = {
                "pos": int(status.get("song", 0)) + 1,
                "len": int(status["playlistlength"]),
                "status": self.status[status["state"]],
                "volume": int(status["volume"]),

                "title": currentsong.get("Title", ""),
                "album": currentsong.get("Album", ""),
                "artist": currentsong.get("Artist", ""),
                "song_length": TimeWrapper(currentsong.get("Time", 0)),
                "song_elapsed": TimeWrapper(float(status.get("elapsed", 0))),
                "bitrate": int(status.get("bitrate", 0)),

            }
            self.output = {
                "full_text": formatp(self.format, **fdict).strip(),
            }
        except Exception as e:
            self.output = {"full_text": "error connecting MPD"}

    def on_leftclick(self):
        try:
            self._mpd_command(self.s, "pause %i" %
                                      (0 if self._mpd_command(self.s, "status")["state"] == "pause" else 1))
        except Exception as e:
            pass

    def on_rightclick(self):
        try:
            vol = int(self._mpd_command(self.s, "status")["volume"])
            if vol == 0:
                self._mpd_command(self.s, "setvol %i" % self.vol)
            else:
                self.vol = vol
                self._mpd_command(self.s, "setvol 0")
        except Exception as e:
            pass

########NEW FILE########
__FILENAME__ = network
from itertools import zip_longest
import subprocess

import netifaces

from i3pystatus import IntervalModule

# Remainder: if we raise minimum Python version to 3.3, use ipaddress module


def count_bits(integer):
    bits = 0
    while (integer):
        integer &= integer - 1
        bits += 1
    return bits


def v6_to_int(v6):
    return int(v6.replace(":", ""), 16)


def prefix6(mask):
    return count_bits(v6_to_int(mask))


def cidr6(addr, mask):
    return "{addr}/{bits}".format(addr=addr, bits=prefix6(mask))


def v4_to_int(v4):
    sum = 0
    mul = 1
    for part in reversed(v4.split(".")):
        sum += int(part) * mul
        mul *= 2 ** 8
    return sum


def prefix4(mask):
    return count_bits(v4_to_int(mask))


def cidr4(addr, mask):
    return "{addr}/{bits}".format(addr=addr, bits=prefix4(mask))


class Network(IntervalModule):
    """
    Display network information about a interface.

    Requires the PyPI package `netifaces`.

    Available formatters:

    * `{interface}` — same as setting
    * `{name}` — same as setting
    * `{v4}` — IPv4 address
    * `{v4mask}` — subnet mask
    * `{v4cidr}` — IPv4 address in cidr notation (i.e. 192.168.2.204/24)
    * `{v6}` — IPv6 address
    * `{v6mask}` — subnet mask
    * `{v6cidr}` — IPv6 address in cidr notation
    * `{mac}` — MAC of interface

    Not available addresses (i.e. no IPv6 connectivity) are replaced with empty strings.
    """

    settings = (
        ("interface", "Interface to obtain information for"),
        "format_up", "color_up",
        "format_down", "color_down",
        ("detached_down", "If the interface doesn't exist, display it as if it were down"),
        "name",
    )

    name = interface = "eth0"
    format_up = "{interface}: {v4}"
    format_down = "{interface}"
    color_up = "#00FF00"
    color_down = "#FF0000"
    detached_down = False

    def init(self):
        if self.interface not in netifaces.interfaces() and not self.detached_down:
            raise RuntimeError(
                "Unknown interface {iface}!".format(iface=self.interface))

    def collect(self):
        if self.interface not in netifaces.interfaces() and self.detached_down:
            self.format = self.format_down
            color = self.color_down
            return self.color_down, self.format_down, {"interface": self.interface, "name": self.name}, False

        info = netifaces.ifaddresses(self.interface)
        up = netifaces.AF_INET in info or netifaces.AF_INET6 in info
        fdict = dict(
            zip_longest(["v4", "v4mask", "v4cidr", "v6", "v6mask", "v6cidr"], [], fillvalue=""))

        try:
            mac = info[netifaces.AF_PACKET][0]["addr"]
        except KeyError:
            mac = "NONE"
        fdict.update({
            "interface": self.interface,
            "name": self.name,
            "mac": mac,
        })

        if up:
            format = self.format_up
            color = self.color_up
            if netifaces.AF_INET in info:
                v4 = info[netifaces.AF_INET][0]
                fdict["v4"] = v4["addr"]
                fdict["v4mask"] = v4["netmask"]
                fdict["v4cidr"] = cidr4(v4["addr"], v4["netmask"])
            if netifaces.AF_INET6 in info:
                for v6 in info[netifaces.AF_INET6]:
                    fdict["v6"] = v6["addr"]
                    fdict["v6mask"] = v6["netmask"]
                    fdict["v6cidr"] = cidr6(v6["addr"], v6["netmask"])
                    if not v6["addr"].startswith("fe80::"):  # prefer non link-local addresses
                        break
        else:
            format = self.format_down
            color = self.color_down

        return color, format, fdict, up

    def run(self):
        color, format, fdict, up = self.collect()

        self.output = {
            "full_text": format.format(**fdict),
            "color": color,
            "instance": self.interface
        }

    def on_leftclick(self):
        subprocess.Popen(["nm-connection-editor"])

########NEW FILE########
__FILENAME__ = parcel
from urllib.request import urlopen
import webbrowser

import lxml.html
from lxml.cssselect import CSSSelector

from i3pystatus import IntervalModule
from i3pystatus.core.util import internet, require


class TrackerAPI:
    def __init__(self, idcode):
        pass

    def status(self):
        return {}


class DHL(TrackerAPI):
    URL = "http://nolp.dhl.de/nextt-online-public/set_identcodes.do?lang=en&idc={idcode}"

    def __init__(self, idcode):
        self.idcode = idcode
        self.url = self.URL.format(idcode=self.idcode)

    def error(self, page):
        result = ''.join(page.xpath('//div[@class="col col-lg-12"]/h2/text()'))

        if self.idcode in result:
            return False
        return True

    def get_progress(self, page):
        elements = page.xpath('//tr[@class="mm_mailing_process "]/td/ul/li')

        for i, element in enumerate(elements, 1):
            picture_link = ''.join(element.xpath('./img/@src')).lower()

            if 'active' in picture_link:
                status = ''.join(element.xpath('./img/@alt'))

                progress = '%i' % (i / len(elements) * 100)

            elif 'default' in picture_link:
                break

        return progress, status

    def status(self):
        ret = {}
        with urlopen(self.url) as page:
            page = lxml.html.fromstring(page.read())

            if not self.error(page):
                ret["progress"] = ret["status"] = "n/a"

            else:
                progress, status = self.get_progress(page)
                ret["progress"] = progress
                ret["status"] = status

        return ret

    def get_url(self):
        return self.url


class UPS(TrackerAPI):
    URL = "http://wwwapps.ups.com/WebTracking/processRequest?HTMLVersion=5.0&Requester=NES&AgreeToTermsAndConditions=yes&loc=en_US&tracknum={idcode}"

    def __init__(self, idcode):
        self.idcode = idcode
        self.url = self.URL.format(idcode=self.idcode)

        error_selector = CSSSelector(".secBody .error")
        self.error = lambda page: len(error_selector(page)) >= 1
        self.status_selector = CSSSelector("#tt_spStatus")
        self.progress_selector = CSSSelector(".pkgProgress div")

    def status(self):
        ret = {}
        with urlopen(self.url) as page:
            page = lxml.html.fromstring(page.read())
            if self.error(page):
                ret["progress"] = ret["status"] = "n/a"
            else:
                ret["status"] = self.status_selector(page)[0].text.strip()
                progress_cls = int(
                    int(self.progress_selector(page)[0].get("class").strip("staus")) / 5 * 100)
                ret["progress"] = progress_cls
        return ret

    def get_url(self):
        return self.url


class ParcelTracker(IntervalModule):
    """
    Used to track parcel/shipments.
    """
    interval = 20

    settings = (
        ("instance", "Tracker instance, for example ``parcel.UPS('your_id_code')``"),
        "format",
        "name",
    )
    required = ("instance",)

    format = "{name}:{progress}"

    @require(internet)
    def run(self):
        fdict = {
            "name": self.name,
        }
        fdict.update(self.instance.status())

        self.output = {
            "full_text": self.format.format(**fdict).strip(),
            "instance": self.name,
        }

    def on_leftclick(self):
        webbrowser.open_new_tab(self.instance.get_url())

########NEW FILE########
__FILENAME__ = pulse
# generation commands
# h2xml.py -I $PWD -c -o pa.xml pulse/mainloop-api.h pulse/sample.h pulse/def.h pulse/operation.h pulse/context.h pulse/channelmap.h pulse/volume.h pulse/stream.h pulse/introspect.h pulse/subscribe.h pulse/scache.h pulse/version.h pulse/error.h pulse/xmalloc.h pulse/utf8.h pulse/thread-mainloop.h pulse/mainloop.h pulse/mainloop-signal.h pulse/util.h pulse/timeval.h
# xml2py.py -k efstd -o lib_pulseaudio.py -l 'pulse' -r '(pa|PA)_.+' pa.xml

from ctypes import *

_libraries = {}
_libraries['libpulse.so.0'] = CDLL('libpulse.so.0')
STRING = c_char_p
pa_volume_t = c_uint32
pa_channel_position_t = c_int
pa_usec_t = c_uint64
pa_channel_position_mask_t = c_uint64

PA_CONTEXT_READY = 4
PA_OK = 0
PA_OPERATION_CANCELLED = 2
PA_OPERATION_DONE = 1
PA_OPERATION_RUNNING = 0
PA_SUBSCRIPTION_EVENT_CHANGE = 16
PA_SUBSCRIPTION_MASK_SINK = 1


class pa_sink_port_info(Structure):
    pass


class pa_format_info(Structure):
    pass


class pa_context(Structure):
    pass


pa_context._fields_ = [
]
pa_context_notify_cb_t = CFUNCTYPE(None, POINTER(pa_context), c_void_p)
pa_context_success_cb_t = CFUNCTYPE(None, POINTER(pa_context), c_int, c_void_p)


class pa_proplist(Structure):
    pass


pa_context_event_cb_t = CFUNCTYPE(
    None, POINTER(pa_context), STRING, POINTER(pa_proplist), c_void_p)


class pa_mainloop_api(Structure):
    pass


pa_context_new = _libraries['libpulse.so.0'].pa_context_new
pa_context_new.restype = POINTER(pa_context)
pa_context_new.argtypes = [POINTER(pa_mainloop_api), STRING]
pa_context_new_with_proplist = _libraries[
    'libpulse.so.0'].pa_context_new_with_proplist
pa_context_new_with_proplist.restype = POINTER(pa_context)
pa_context_new_with_proplist.argtypes = [
    POINTER(pa_mainloop_api), STRING, POINTER(pa_proplist)]
pa_context_unref = _libraries['libpulse.so.0'].pa_context_unref
pa_context_unref.restype = None
pa_context_unref.argtypes = [POINTER(pa_context)]
pa_context_ref = _libraries['libpulse.so.0'].pa_context_ref
pa_context_ref.restype = POINTER(pa_context)
pa_context_ref.argtypes = [POINTER(pa_context)]
pa_context_set_state_callback = _libraries[
    'libpulse.so.0'].pa_context_set_state_callback
pa_context_set_state_callback.restype = None
pa_context_set_state_callback.argtypes = [
    POINTER(pa_context), pa_context_notify_cb_t, c_void_p]


# values for enumeration 'pa_context_state'
pa_context_state = c_int  # enum
pa_context_state_t = pa_context_state
pa_context_get_state = _libraries['libpulse.so.0'].pa_context_get_state
pa_context_get_state.restype = pa_context_state_t
pa_context_get_state.argtypes = [POINTER(pa_context)]

# values for enumeration 'pa_context_flags'
pa_context_flags = c_int  # enum
pa_context_flags_t = pa_context_flags


class pa_spawn_api(Structure):
    _fields_ = [
        ('prefork', CFUNCTYPE(None)),
        ('postfork', CFUNCTYPE(None)),
        ('atfork', CFUNCTYPE(None)),
    ]


pa_context_connect = _libraries['libpulse.so.0'].pa_context_connect
pa_context_connect.restype = c_int
pa_context_connect.argtypes = [
    POINTER(pa_context), STRING, pa_context_flags_t, POINTER(pa_spawn_api)]
pa_context_disconnect = _libraries['libpulse.so.0'].pa_context_disconnect
pa_context_disconnect.restype = None
pa_context_disconnect.argtypes = [POINTER(pa_context)]


class pa_operation(Structure):
    pass


class pa_sample_spec(Structure):
    _fields_ = [
        ('format', c_int),
        ('rate', c_uint32),
        ('channels', c_uint8),
    ]

# values for enumeration 'pa_subscription_mask'
pa_subscription_mask = c_int  # enum
pa_subscription_mask_t = pa_subscription_mask

# values for enumeration 'pa_subscription_event_type'
pa_subscription_event_type = c_int  # enum
pa_subscription_event_type_t = pa_subscription_event_type

pa_context_subscribe_cb_t = CFUNCTYPE(
    None, POINTER(pa_context), pa_subscription_event_type_t, c_uint32, c_void_p)
pa_context_subscribe = _libraries['libpulse.so.0'].pa_context_subscribe
pa_context_subscribe.restype = POINTER(pa_operation)
pa_context_subscribe.argtypes = [
    POINTER(pa_context), pa_subscription_mask_t, pa_context_success_cb_t, c_void_p]
pa_context_set_subscribe_callback = _libraries[
    'libpulse.so.0'].pa_context_set_subscribe_callback
pa_context_set_subscribe_callback.restype = None
pa_context_set_subscribe_callback.argtypes = [
    POINTER(pa_context), pa_context_subscribe_cb_t, c_void_p]

# values for enumeration 'pa_sink_flags'
pa_sink_flags = c_int  # enum
pa_sink_flags_t = pa_sink_flags

# values for enumeration 'pa_sink_state'
pa_sink_state = c_int  # enum
pa_sink_state_t = pa_sink_state

pa_free_cb_t = CFUNCTYPE(None, c_void_p)
pa_strerror = _libraries['libpulse.so.0'].pa_strerror
pa_strerror.restype = STRING
pa_strerror.argtypes = [c_int]


class pa_sink_info(Structure):
    pass


class pa_cvolume(Structure):
    _fields_ = [
        ('channels', c_uint8),
        ('values', pa_volume_t * 32),
    ]


class pa_channel_map(Structure):
    _fields_ = [
        ('channels', c_uint8),
        ('map', pa_channel_position_t * 32),
    ]


pa_sink_info._fields_ = [
    ('name', STRING),
    ('index', c_uint32),
    ('description', STRING),
    ('sample_spec', pa_sample_spec),
    ('channel_map', pa_channel_map),
    ('owner_module', c_uint32),
    ('volume', pa_cvolume),
    ('mute', c_int),
    ('monitor_source', c_uint32),
    ('monitor_source_name', STRING),
    ('latency', pa_usec_t),
    ('driver', STRING),
    ('flags', pa_sink_flags_t),
    ('proplist', POINTER(pa_proplist)),
    ('configured_latency', pa_usec_t),
    ('base_volume', pa_volume_t),
    ('state', pa_sink_state_t),
    ('n_volume_steps', c_uint32),
    ('card', c_uint32),
    ('n_ports', c_uint32),
    ('ports', POINTER(POINTER(pa_sink_port_info))),
    ('active_port', POINTER(pa_sink_port_info)),
    ('n_formats', c_uint8),
    ('formats', POINTER(POINTER(pa_format_info))),
]
pa_sink_info_cb_t = CFUNCTYPE(
    None, POINTER(pa_context), POINTER(pa_sink_info), c_int, c_void_p)
pa_context_get_sink_info_by_name = _libraries[
    'libpulse.so.0'].pa_context_get_sink_info_by_name
pa_context_get_sink_info_by_name.restype = POINTER(pa_operation)
pa_context_get_sink_info_by_name.argtypes = [
    POINTER(pa_context), STRING, pa_sink_info_cb_t, c_void_p]
pa_context_get_sink_info_by_index = _libraries[
    'libpulse.so.0'].pa_context_get_sink_info_by_index
pa_context_get_sink_info_by_index.restype = POINTER(pa_operation)
pa_context_get_sink_info_by_index.argtypes = [
    POINTER(pa_context), c_uint32, pa_sink_info_cb_t, c_void_p]
pa_context_get_sink_info_list = _libraries[
    'libpulse.so.0'].pa_context_get_sink_info_list
pa_context_get_sink_info_list.restype = POINTER(pa_operation)
pa_context_get_sink_info_list.argtypes = [
    POINTER(pa_context), pa_sink_info_cb_t, c_void_p]


class pa_server_info(Structure):
    pass


pa_server_info._fields_ = [
    ('user_name', STRING),
    ('host_name', STRING),
    ('server_version', STRING),
    ('server_name', STRING),
    ('sample_spec', pa_sample_spec),
    ('default_sink_name', STRING),
    ('default_source_name', STRING),
    ('cookie', c_uint32),
    ('channel_map', pa_channel_map),
]
pa_server_info_cb_t = CFUNCTYPE(
    None, POINTER(pa_context), POINTER(pa_server_info), c_void_p)
pa_context_get_server_info = _libraries[
    'libpulse.so.0'].pa_context_get_server_info
pa_context_get_server_info.restype = POINTER(pa_operation)
pa_context_get_server_info.argtypes = [
    POINTER(pa_context), pa_server_info_cb_t, c_void_p]


class pa_threaded_mainloop(Structure):
    pass


pa_threaded_mainloop._fields_ = [
]
pa_threaded_mainloop_new = _libraries['libpulse.so.0'].pa_threaded_mainloop_new
pa_threaded_mainloop_new.restype = POINTER(pa_threaded_mainloop)
pa_threaded_mainloop_new.argtypes = []
pa_threaded_mainloop_free = _libraries[
    'libpulse.so.0'].pa_threaded_mainloop_free
pa_threaded_mainloop_free.restype = None
pa_threaded_mainloop_free.argtypes = [POINTER(pa_threaded_mainloop)]
pa_threaded_mainloop_start = _libraries[
    'libpulse.so.0'].pa_threaded_mainloop_start
pa_threaded_mainloop_start.restype = c_int
pa_threaded_mainloop_start.argtypes = [POINTER(pa_threaded_mainloop)]
pa_threaded_mainloop_stop = _libraries[
    'libpulse.so.0'].pa_threaded_mainloop_stop
pa_threaded_mainloop_stop.restype = None
pa_threaded_mainloop_stop.argtypes = [POINTER(pa_threaded_mainloop)]
pa_threaded_mainloop_lock = _libraries[
    'libpulse.so.0'].pa_threaded_mainloop_lock
pa_threaded_mainloop_lock.restype = None
pa_threaded_mainloop_lock.argtypes = [POINTER(pa_threaded_mainloop)]
pa_threaded_mainloop_unlock = _libraries[
    'libpulse.so.0'].pa_threaded_mainloop_unlock
pa_threaded_mainloop_unlock.restype = None
pa_threaded_mainloop_unlock.argtypes = [POINTER(pa_threaded_mainloop)]
pa_threaded_mainloop_wait = _libraries[
    'libpulse.so.0'].pa_threaded_mainloop_wait
pa_threaded_mainloop_wait.restype = None
pa_threaded_mainloop_wait.argtypes = [POINTER(pa_threaded_mainloop)]
pa_threaded_mainloop_signal = _libraries[
    'libpulse.so.0'].pa_threaded_mainloop_signal
pa_threaded_mainloop_signal.restype = None
pa_threaded_mainloop_signal.argtypes = [POINTER(pa_threaded_mainloop), c_int]
pa_threaded_mainloop_accept = _libraries[
    'libpulse.so.0'].pa_threaded_mainloop_accept
pa_threaded_mainloop_accept.restype = None
pa_threaded_mainloop_accept.argtypes = [POINTER(pa_threaded_mainloop)]
pa_threaded_mainloop_get_retval = _libraries[
    'libpulse.so.0'].pa_threaded_mainloop_get_retval
pa_threaded_mainloop_get_retval.restype = c_int
pa_threaded_mainloop_get_retval.argtypes = [POINTER(pa_threaded_mainloop)]
pa_threaded_mainloop_get_api = _libraries[
    'libpulse.so.0'].pa_threaded_mainloop_get_api
pa_threaded_mainloop_get_api.restype = POINTER(pa_mainloop_api)
pa_threaded_mainloop_get_api.argtypes = [POINTER(pa_threaded_mainloop)]
pa_threaded_mainloop_in_thread = _libraries[
    'libpulse.so.0'].pa_threaded_mainloop_in_thread
pa_threaded_mainloop_in_thread.restype = c_int
pa_threaded_mainloop_in_thread.argtypes = [POINTER(pa_threaded_mainloop)]

pa_sw_volume_to_dB = _libraries['libpulse.so.0'].pa_sw_volume_to_dB
pa_sw_volume_to_dB.restype = c_double
pa_sw_volume_to_dB.argtypes = [pa_volume_t]

pa_operation_unref = _libraries['libpulse.so.0'].pa_operation_unref
pa_operation_unref.restype = None
pa_operation_unref.argtypes = [POINTER(pa_operation)]

########NEW FILE########
__FILENAME__ = pyload
import urllib.request
import urllib.parse
import urllib.error
import http.cookiejar
import webbrowser
import json

from i3pystatus import IntervalModule


class pyLoad(IntervalModule):
    """
    Shows pyLoad status

    Available formatters:

    * `{captcha}` (see captcha_true and captcha_false, which are the values filled in for this formatter)
    * `{progress}` (average over all running downloads)
    * `{progress_all}` (percentage of completed files/links in queue)
    * `{speed}` (kilobytes/s)
    * `{download}` (downloads enabled, also see download_true and download_false)
    * `{total}` (number of downloads)
    * `{free_space}` (free space in download directory in gigabytes)
    """
    interval = 5

    settings = (
        ("address", "Address of pyLoad webinterface"),
        "format",
        "captcha_true", "captcha_false",
        "download_true", "download_false",
        "username", "password"
    )
    required = ("username", "password")

    address = "http://127.0.0.1:8000"
    format = "{captcha} {progress_all:.1f}% {speed:.1f} kb/s"
    captcha_true = "Captcha waiting"
    captcha_false = ""
    download_true = "Downloads enabled"
    download_false = "Downloads disabled"

    def _rpc_call(self, method, data=None):
        if not data:
            data = {}
        urlencoded = urllib.parse.urlencode(data).encode("ascii")
        return json.loads(self.opener.open("{address}/api/{method}/".format(address=self.address, method=method),
                                           urlencoded).read().decode("utf-8"))

    def init(self):
        self.cj = http.cookiejar.CookieJar()
        self.opener = urllib.request.build_opener(
            urllib.request.HTTPCookieProcessor(self.cj))

    def login(self):
        return self._rpc_call("login", {
            "username": self.username,
            "password": self.password,
        })

    def run(self):
        self.login()
        server_status = self._rpc_call("statusServer")
        downloads_status = self._rpc_call("statusDownloads")

        if downloads_status:
            progress = sum(dl["percent"]
                           for dl in downloads_status) / len(downloads_status) * 100
        else:
            progress = 100.0

        fdict = {
            "download": self.download_true if server_status["download"] else self.download_false,
            "speed": server_status["speed"] / 1024,
            "progress": progress,
            "progress_all": sum(pkg["linksdone"] for pkg in self._rpc_call("getQueue")) / server_status["total"] * 100,
            "captcha": self.captcha_true if self._rpc_call("isCaptchaWaiting") else self.captcha_false,
            "free_space": self._rpc_call("freeSpace") / (1024 ** 3),
        }

        self.output = {
            "full_text": self.format.format(**fdict).strip(),
            "instance": self.address,
        }

    def on_leftclick(self):
        webbrowser.open_new_tab(self.address)

########NEW FILE########
__FILENAME__ = regex
import re

from i3pystatus import IntervalModule


class Regex(IntervalModule):
    """
    Simple regex file watcher

    The groups of the regex are passed to the format string as positional arguments.
    """

    flags = 0
    format = "{0}"
    settings = (
        ("format", "format string used for output"),
        "regex",
        ("file", "file to search for regex matches"),
        ("flags", "Python.re flags"),
    )
    required = ("regex", "file")

    def init(self):
        self.re = re.compile(self.regex, self.flags)

    def run(self):
        with open(self.file, "r") as f:
            match = self.re.search(f.read())
            self.output = {
                "full_text": self.format.format(*match.groups()),
            }

########NEW FILE########
__FILENAME__ = runwatch
import glob
import os.path

from i3pystatus import IntervalModule


class RunWatch(IntervalModule):
    """
    Expands the given path using glob to a pidfile and checks
    if the process ID found inside is valid
    (that is, if the process is running).
    You can use this to check if a specific application,
    such as a VPN client or your DHCP client is running.

    Available formatters are {pid} and {name}.
    """

    format_up = "{name}"
    format_down = "{name}"
    color_up = "#00FF00"
    color_down = "#FF0000"
    settings = (
        "format_up", "format_down",
        "color_up", "color_down",
        "path", "name",
    )
    required = ("path", "name")

    @staticmethod
    def is_process_alive(pid):
        return os.path.exists("/proc/{pid}/".format(pid=pid))

    def run(self):
        alive = False
        pid = 0
        try:
            with open(glob.glob(self.path)[0], "r") as f:
                pid = int(f.read().strip())
            alive = self.is_process_alive(pid)
        except Exception:
            pass

        if alive:
            fmt = self.format_up
            color = self.color_up
        else:
            fmt = self.format_down
            color = self.color_down

        self.output = {
            "full_text": fmt.format(name=self.name, pid=pid),
            "color": color,
            "instance": self.name
        }

########NEW FILE########
__FILENAME__ = spotify
import threading
import math

from i3pystatus import Module
from gi.repository import Playerctl, GLib


class Spotify(Module):
    """
    This class shows information from Spotify.

    Left click will toggle pause/play of the current song.
    Right click will skip the song.

    Dependent on Playerctl ( https://github.com/acrisci/playerctl ) and GLib
    """

    format = "{artist} - {title}"
    color = "#ffffff"

    settings = (
        ("format", "Format string. {artist}, {title}, {album}, {volume}, and {length} are available for output."),
        ("color", "color of the output"),
    )

    def main_loop(self):
        """ Mainloop blocks so we thread it."""
        self.player = Playerctl.Player()
        self.player.on('metadata', self.on_track_change)
        main = GLib.MainLoop()
        main.run()

    def init(self):
        try:
            t = threading.Thread(target=self.main_loop)
            t.daemon = True
            t.start()
        except Exception as e:
            self.output = {
                "full_text": "Error creating new thread!",
                "color": "#FF0000"
            }

    def on_track_change(self, player, e):
        artist = player.get_artist()
        title = player.get_title()
        album = player.get_album()
        volume = player.props.volume

        time = e["mpris:length"] / 60.0e6
        minutes = math.floor(time)
        seconds = round(time % 1 * 60)
        if seconds < 10:
            seconds = "0" + str(seconds)
        length = "{}:{}".format(minutes, seconds)

        self.output = {
            "full_text": self.format.format(
                artist=artist, title=title,
                album=album, length=length,
                volume=volume),
            "color": self.color
        }

    def on_leftclick(self):
        self.player.play_pause()

    def on_rightclick(self):
        self.player.next()

########NEW FILE########
__FILENAME__ = temp
import re
import glob

from i3pystatus import IntervalModule


class Temperature(IntervalModule):
    """
    Shows CPU temperature of Intel processors

    AMD is currently not supported as they can only report a relative temperature, which is pretty useless
    """

    settings = (
        ("format",
         "format string used for output. {temp} is the temperature in degrees celsius, {critical} and {high} are the trip point temps."),
        "color", "color_critical", "high_factor"
    )
    format = "{temp} °C"
    high_factor = 0.7
    color = "#FFFFFF"
    color_high = "#FFFF00"
    color_critical = "#FF0000"

    def init(self):
        self.base_path = "/sys/devices/platform/coretemp.0"
        input = glob.glob(
            "{base_path}/temp*_input".format(base_path=self.base_path))[0]
        self.input = re.search("temp([0-9]+)_input", input).group(1)
        self.base_path = "{base_path}/temp{input}_".format(
            base_path=self.base_path, input=self.input)

        with open("{base_path}crit".format(base_path=self.base_path), "r") as f:
            self.critical = float(f.read().strip()) / 1000
            self.high = self.critical * self.high_factor

    def run(self):
        with open("{base_path}input".format(base_path=self.base_path), "r") as f:
            temp = float(f.read().strip()) / 1000

        urgent = False
        color = self.color
        if temp >= self.critical:
            urgent = True
            color = self.color_critical
        elif temp >= self.high:
            urgent = True
            color = self.color_high

        self.output = {
            "full_text": self.format.format(temp=temp, critical=self.critical, high=self.high),
            "urgent": urgent,
            "color": color,
        }

########NEW FILE########
__FILENAME__ = text
import subprocess

from i3pystatus import Module


class Text(Module):
    """
    Display static, colored text.
    """

    settings = (
        "text",
        ("color", "HTML color code #RRGGBB"),
        ("cmd_leftclick", "Shell command to execute on left click"),
        ("cmd_rightclick", "Shell command to execute on right click"),
    )
    required = ("text",)

    color = None
    cmd_leftclick = "test"
    cmd_rightclick = "test"

    def init(self):
        self.output = {
            "full_text": self.text
        }
        if self.color:
            self.output["color"] = self.color


    def on_leftclick(self):
        subprocess.call(self.cmd_leftclick, shell=True)

    def on_rightclick(self):
        subprocess.call(self.cmd_rightclick, shell=True)

########NEW FILE########
__FILENAME__ = weather
from i3pystatus import IntervalModule
import pywapi
from i3pystatus.core.util import internet, require


class Weather(IntervalModule):
    """
    This module gets the weather from weather.com using pywapi module
    First, you need to get the code for the location from the www.weather.com
    Available formatters:

    * {current_temp}
    * {humidity}

    Requires pywapi from PyPI.
    """

    interval = 20

    settings = (
        "location_code",
        ("colorize", "Enable color with temperature and UTF-8 icons."),
        ("units", "Celsius (metric) or Fahrenheit (imperial)"),
        "format",
    )
    required = ("location_code",)

    units = "metric"
    format = "{current_temp}"
    colorize = False
    color_icons = {
        "Fair":  (u"\u2600", "#FFCC00"),
        "Cloudy": (u"\u2601", "#F8F8FF"),
        "Partly Cloudy": (u"\u2601", "#F8F8FF"),  # \u26c5 is not in many fonts
        "Rainy": (u"\u2614", "#CBD2C0"),
        "Sunny": (u"\u263C", "#FFFF00"),
        "Snow": (u"\u2603", "#FFFFFF"),
        "default": ("", None),
    }

    @require(internet)
    def run(self):
        result = pywapi.get_weather_from_weather_com(self.location_code, self.units)
        conditions = result["current_conditions"]
        temperature = conditions["temperature"]
        humidity = conditions["humidity"]
        units = result["units"]
        color = None
        current_temp = "{t}°{d} ".format(t=temperature, d=units["temperature"])

        if self.colorize:
            icon, color = self.color_icons.get(conditions["text"],
                                               self.color_icons["default"])
            current_temp = "{t}°{d} {i}".format(t=temperature,
                                                d=units["temperature"],
                                                i=icon)
            color = color

        self.output = {
            "full_text": self.format.format(current_temp=current_temp, humidity=humidity),
            "color": color
        }

########NEW FILE########
__FILENAME__ = wireless
import basiciw

from i3pystatus.network import Network


class Wireless(Network):
    """
    Display network information about a interface.

    Requires the PyPI packages `netifaces` and `basiciw`.

    This is based on the network module, so all options and formatters are
    the same, except for these additional formatters and that detached_down doesn't work.

    * `{essid}` — ESSID of currently connected wifi
    * `{freq}` — Current frequency
    * `{quality}` — Link quality in percent
    """

    interface = "wlan0"

    def collect(self):
        color, format, fdict, up = super().collect()

        if up:
            iwi = basiciw.iwinfo(self.interface)
            fdict["essid"] = iwi["essid"]
            fdict["freq"] = iwi["freq"]
            quality = iwi["quality"]
            if quality["quality_max"] > 0:
                fdict["quality"] = quality["quality"] / quality["quality_max"]
            else:
                fdict["quality"] = quality["quality"]
            fdict["quality"] *= 100
        else:
            fdict["essid"] = ""
            fdict["freq"] = fdict["quality"] = 0.0

        return color, format, fdict, up

########NEW FILE########
__FILENAME__ = test_battery
#!/usr/bin/env python

import unittest

from i3pystatus import battery


def factory(path, format, expected):
    def test():
        bc = battery.BatteryChecker(path=path, format=format)
        bc.run()
        print(bc.output["full_text"])
        assert bc.output["full_text"] == expected
    test.description = path + ":" + format
    return test


def basic_test_generator():
    cases = [
        ("test_battery_basic1", "FULL", "0.000", ""),
        ("test_battery_basic2", "FULL", "0.000", ""),
        ("test_battery_basic3", "DIS", "15.624", "4h:04m"),
        ("test_battery_basic4", "DIS", "17.510", "1h:46m"),
        ("test_battery_basic5", "DIS", "11.453", "4h:52m"),
        ("test_battery_basic6", "CHR", "30.764", "0h:20m"),
        ("test_battery_basic7", "DIS", "27.303", "1h:44m"),
    ]
    for path, status, consumption, remaining in cases:
        yield factory(path, "{status}", status)
        yield factory(path, "{consumption:.3f}", consumption)
        yield factory(path, "{remaining_hm}", remaining)

########NEW FILE########
__FILENAME__ = test_core_modules
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import unittest

from i3pystatus.core.modules import IntervalModule


class IntervalModuleMetaTest(unittest.TestCase):

    def test_no_settings(self):
        class NoSettings(IntervalModule):
            pass
        self.assertEqual(NoSettings.settings, ('interval',))

    def test_no_interval_setting(self):
        class NoIntervalSetting(IntervalModule):
            settings = (('option', 'desc'),)
        self.assertEqual(NoIntervalSetting.settings,
                         (('option', 'desc'), 'interval'))

    def test_settings_with_interval(self):
        class SettingsInteval(IntervalModule):
            settings = ('option', 'interval')
        self.assertEqual(SettingsInteval.settings, ('option', 'interval'))

    def test_settings_with_interval_desc(self):
        class SetttingsIntervalDesc(IntervalModule):
            settings = (('interval', 'desc'),)
        self.assertEqual(SetttingsIntervalDesc.settings,
                         (('interval', 'desc'),))

########NEW FILE########
__FILENAME__ = test_core_util
#!/usr/bin/env python

import unittest
from unittest.mock import MagicMock
import string
import random
import types

from i3pystatus.core.exceptions import ConfigAmbigiousClassesError, ConfigInvalidModuleError
from i3pystatus.core import util, ClassFinder


def test_lchop_prefixed():
    assert util.lchop("12345", "12") == "345"


def test_lchop_no_prefix():
    assert util.lchop("345", "") == "345"


def test_lchop_unmatched():
    assert util.lchop("12345", "345") == "12345"


def partition(iterable, limit, assrt):
    partitions = util.partition(iterable, limit)
    partitions = [sorted(partition) for partition in partitions]
    for item in assrt:
        assert sorted(item) in partitions


def partition_test_generator():
    cases = [
        ([1, 2, 3, 4], 3, [[1, 2], [3], [4]]),
        ([2, 1, 3, 4], 3, [[1, 2], [3], [4]]),
        ([0.33, 0.45, 0.89], 1, [[0.33, 0.45, 0.89]]),
        ([], 10, []),
    ]

    for iterable, limit, assrt in cases:
        yield partition, iterable, limit, assrt


def popwhile(iterable, predicate, assrt):
    assert list(util.popwhile(predicate, iterable)) == assrt


def popwhile_test_generator():
    cases = [
        ([1, 2, 3, 4], lambda x: x < 2, []),
        ([1, 2, 3, 4], lambda x: x < 5 and x > 2, [4, 3]),
        ([1, 2, 3, 4], lambda x: x == 4, [4]),
        ([1, 2, 3, 4], lambda x: True, [4, 3, 2, 1]),
        ([1, 2], lambda x: False, []),
    ]

    for iterable, predicate, assrt in cases:
        yield popwhile, iterable, predicate, assrt


def keyconstraintdict_missing(valid, required, feedkeys, assrt_missing):
    kcd = util.KeyConstraintDict(valid_keys=valid, required_keys=required)
    kcd.update(dict.fromkeys(feedkeys))

    assert kcd.missing() == set(assrt_missing)


def keyconstraintdict_missing_test_generator():
    cases = [
        # ( valid,              required, feed,      missing )
        (("foo", "bar", "baz"), ("foo",), ("bar",), ("foo",)),
        (("foo", "bar", "baz"), ("foo",), tuple(), ("foo",)),
        (("foo", "bar", "baz"), ("bar", "baz"), ("bar", "baz"), tuple()),
        (("foo", "bar", "baz"), ("bar", "baz"),
         ("bar", "foo", "baz"), tuple()),
    ]

    for valid, required, feed, missing in cases:
        yield keyconstraintdict_missing, valid, required, feed, missing


class ModuleListTests(unittest.TestCase):
    class ModuleBase:
        pass

    def setUp(self):
        self.status_handler = MagicMock()
        self.ml = util.ModuleList(self.status_handler, ClassFinder(self.ModuleBase))

    def test_append_simple(self):
        module = self.ModuleBase()
        module.registered = MagicMock()

        self.ml.append(module)
        module.registered.assert_called_with(self.status_handler)

    def _create_module_class(self, name, bases=None):
        if not bases:
            bases = (self.ModuleBase,)
        return type(name, bases, {
            "registered": MagicMock(),
            "__init__": MagicMock(return_value=None),
        })

    def test_append_class_instanciation(self):
        module_class = self._create_module_class("module_class")

        self.ml.append(module_class)

        module_class.__init__.assert_called_with()
        module_class.registered.assert_called_with(self.status_handler)

    def test_append_module(self):
        pymod = types.ModuleType("test_mod")
        pymod.some_class = self._create_module_class("some_class")
        pymod.some_class.__module__ = "test_mod"

        self.ml.append(pymod)

        pymod.some_class.__init__.assert_called_with()
        pymod.some_class.registered.assert_called_with(self.status_handler)

    def test_append_module2(self):
        # Here we test if imported classes are ignored as they should
        pymod = types.ModuleType("test_mod")
        pymod.some_class = self._create_module_class("some_class")
        pymod.some_class.__module__ = "other_module"

        with self.assertRaises(ConfigInvalidModuleError):
            self.ml.append(pymod)

        assert not pymod.some_class.__init__.called
        assert not pymod.some_class.registered.called

    def test_ambigious_classdef(self):
        pymod = types.ModuleType("test_mod")
        pymod.some_class = self._create_module_class("some_class")
        pymod.some_class.__module__ = "test_mod"
        pymod.some_other_class = self._create_module_class("some_other_class")
        pymod.some_other_class.__module__ = "test_mod"

        with self.assertRaises(ConfigAmbigiousClassesError):
            self.ml.append(pymod)

    def test_invalid_module(self):
        pymod = types.ModuleType("test_mod")

        with self.assertRaises(ConfigInvalidModuleError):
            self.ml.append(pymod)


    def test_append_class_inheritance(self):
        in_between = self._create_module_class("in_between")
        cls = self._create_module_class("cls", (in_between,))

        self.ml.append(cls)

        cls.__init__.assert_called_with()
        cls.registered.assert_called_with(self.status_handler)


class KeyConstraintDictAdvancedTests(unittest.TestCase):
    def test_invalid_1(self):
        kcd = util.KeyConstraintDict(valid_keys=tuple(), required_keys=tuple())
        with self.assertRaises(KeyError):
            kcd["invalid"] = True

    def test_invalid_2(self):
        kcd = util.KeyConstraintDict(
            valid_keys=("foo", "bar"), required_keys=tuple())
        with self.assertRaises(KeyError):
            kcd["invalid"] = True

    def test_incomplete_iteration(self):
        kcd = util.KeyConstraintDict(
            valid_keys=("foo", "bar"), required_keys=("foo",))
        with self.assertRaises(util.KeyConstraintDict.MissingKeys):
            for x in kcd:
                pass

    def test_completeness(self):
        kcd = util.KeyConstraintDict(
            valid_keys=("foo", "bar"), required_keys=("foo",))
        kcd["foo"] = False
        for x in kcd:
            pass
        assert kcd.missing() == set()

    def test_remove_required(self):
        kcd = util.KeyConstraintDict(
            valid_keys=("foo", "bar"), required_keys=("foo",))
        kcd["foo"] = None
        assert kcd.missing() == set()
        del kcd["foo"]
        assert kcd.missing() == {"foo"}

    def test_set_twice(self):
        kcd = util.KeyConstraintDict(
            valid_keys=("foo", "bar"), required_keys=("foo",))
        kcd["foo"] = 1
        kcd["foo"] = 2
        assert kcd.missing() == set()
        del kcd["foo"]
        assert kcd.missing() == {"foo"}


class FormatPTests(unittest.TestCase):
    def test_escaping(self):
        assert util.formatp("[razamba \[ mabe \]]") == "razamba [ mabe ]"

    def test_numerical(self):
        assert util.formatp("[{t} - [schmuh {x}]]", t=1, x=2) == "1 - schmuh 2"
        assert util.formatp("[{t} - [schmuh {x}]]", t=1, x=0) == "1 - "
        assert util.formatp("[{t} - [schmuh {x}]]", t=0, x=0) == ""

    def test_nesting(self):
        s = "[[{artist} - ]{album} - ]{title}"
        assert util.formatp(s, title="Black rose") == "Black rose"
        assert util.formatp(
            s, artist="In Flames", title="Gyroscope") == "Gyroscope"
        assert util.formatp(
            s, artist="SOAD", album="Toxicity", title="Science") == "SOAD - Toxicity - Science"
        assert util.formatp(
            s, album="Toxicity", title="Science") == "Toxicity - Science"

    def test_bare(self):
        assert util.formatp("{foo} blar", foo="bar") == "bar blar"

    def test_presuffix(self):
        assert util.formatp(
            "ALINA[{title} schnacke]KOMMAHER", title="") == "ALINAKOMMAHER"
        assert util.formatp("grml[{title}]") == "grml"
        assert util.formatp("[{t}]grml") == "grml"

    def test_side_by_side(self):
        s = "{status} [{artist} / [{album} / ]]{title}[ {song_elapsed}/{song_length}]"
        assert util.formatp(s, status="▷", title="Only For The Weak",
                            song_elapsed="1:41", song_length="4:55") == "▷ Only For The Weak 1:41/4:55"
        assert util.formatp(
            s, status="", album="Foo", title="Die, Die, Crucified", song_elapsed="2:52") == " Die, Die, Crucified"
        assert util.formatp("[[{a}][{b}]]", b=1) == "1"

    def test_complex_field(self):
        class NS:
            pass
        obj = NS()
        obj.attr = "bar"

        s = "[{a:.3f} m]{obj.attr}"
        assert util.formatp(s, a=3.14123456789, obj=obj) == "3.141 mbar"
        assert util.formatp(s, a=0.0, obj=obj) == "bar"

########NEW FILE########
